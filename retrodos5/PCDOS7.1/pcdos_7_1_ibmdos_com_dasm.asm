

;
; +-------------------------------------------------------------------------+
; |   This file has been generated by The Interactive Disassembler (IDA)    |
; |           Copyright (c) 2018 Hex-Rays, <support@hex-rays.com>           |
; |                            Freeware version                             |
; +-------------------------------------------------------------------------+
;
; Input SHA256 : F426A13B1E2E5A05BC7E56A18D551608D3BDC4CB14045324468860A3725E2084
; Input MD5    : 7F03764471D91E450F960EAE084831A6
; Input CRC32  : 4C51484C


                .386
                .model flat

; ===========================================================================

; Segment type: Regular
DOSDATA         segment byte public 'DOSDATA' use16
                assume cs:DOSDATA
                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
                db 4 dup(0)
DataVersion     dw 1
WinoldPatch1    db 8 dup(0)             ; ...
MYNUM           dw 0                    ; ...
FCBLRU          dw 0                    ; ...
OpenLRU         dw 0
OEM_HANDLER     dd 0FFFFFFFFh
LeaveAddr       dw offset LeaveDOS
RetryCount      dw 3                    ; ...
RetryLoop       dw 1                    ; ...
LastBuffer      dd 0FFFFFFFFh           ; ...
CONTPOS         dw 0                    ; ...
arena_head      dw 0                    ; ...
DPBHEAD         dd 0                    ; ...
SFT_ADDR        dd SFTABL               ; ...
BCLOCK          dd 0                    ; ...
BCON            dd 0                    ; ...
MAXSEC          dw 128                  ; ...
BUFFHEAD        dd 0                    ; ...
CDSADDR         dd 0                    ; ...
SFTFCB          dd 0                    ; ...
KEEPCOUNT       dw 0
NUMIO           db 0                    ; ...
CDSCOUNT        db 0                    ; ...
NULDEV          dw 2 dup(0)             ; ...
                dw 8004h                ; Null device attributes = DEVTYP|ISNULL
                dw offset SNULDEV       ; Strategy entry point
                dw offset INULDEV       ; Interrupt entry point
                db 'NUL     '           ; Name of null device
SPLICES         db 0                    ; ...
Special_Entries dw 0
UU_IFS_DOS_CALL dd 0                    ; ...
ChkCopyProt     dw 0                    ; ...
A20OFF_PSP      dw 0                    ; ...
BUFFERS_PARM1   dw 0
BUFFERS_PARM2   dw 0
BOOTDRIVE       db 0                    ; ...
DDMOVE          db 0                    ; ...
EXT_MEM_SIZE    dw 0
BufferQueue     dd 0                    ; ...
                                        ; HASHINITVAR
DirtyBufferCount dw 0                   ; ...
SC_CACHE_PTR    dd 0
SC_CACHE_COUNT  dw 0                    ; ...
BuffInHMA       db 0                    ; ...
LoMemBuff       dd 0                    ; ...
UU_BUF_EMS_FIRST_PAGE db 0, 0, 0
CL0FATENTRY     dw 0FFFFh               ; ...
IoStatFail      db 0                    ; ...
ALLOCMSAVE      db 0                    ; ...
A20OFF_COUNT    db 0                    ; ...
DOS_FLAG        db 0                    ; ...
UNPACK_OFFSET   dw 0                    ; ...
UMBFLAG         db 0                    ; ...
SAVE_AX         dw 0                    ; ...
UMB_HEAD        dw 0FFFFh               ; ...
START_ARENA     dw 1                    ; ...
JShare          dd BadCall              ; ...
MFT_enter       dd OKCall               ; ...
MFTClose        dd OKCall               ; ...
MFTclU          dd BadCall              ; ...
MFTCloseP       dd BadCall              ; ...
MFTCloN         dd BadCall              ; ...
set_block       dd BadCall              ; ...
clr_block       dd BadCall              ; ...
chk_block       dd OKCall               ; ...
MFT_get         dd BadCall              ; ...
ShSave          dd BadCall              ; ...
ShChk           dd BadCall              ; ...
ShCol           dd OKCall               ; ...
ShCloseFile     dd BadCall              ; ...
ShSU            dd BadCall              ; ...
SFTABL          dd 0FFFFFFFFh           ; ...
                dw 5                    ; sf_default_number
SFT0_SFTable    db 295 dup(0)           ; ...
CARPOS          db 0                    ; ...
STARTPOS        db 0                    ; ...
INBUF           db 128 dup(0)           ; ...
CONBUF          db 131 dup(0)           ; ...
PFLAG           db 0                    ; ...
VDERFLG         db 0                    ; ...
CHARCO          db 3                    ; ...
chSwitch        db '/'
AllocMethod     db 0                    ; ...
fShare          db 0                    ; ...
DIFFNAM         db 1                    ; ...
MYNAME          db 10h dup(20h)         ; ...
CritPatch       dw offset redir_patch   ; ...
                dw offset redir_patch
                dw offset redir_patch
                dw offset redir_patch
                dw 0
                db 90h                  ; SWAPPABLE DATA AREA
ERRORMODE       db 0                    ; ...
                                        ; critical error flag
INDOS           db 0                    ; ...
WPERR           db 0FFh                 ; ...
                                        ; drive on which current critical error occurred
EXTERR_LOCUS    db 0                    ; ...
                                        ; locus of last error
EXTERR          dw 0                    ; ...
                                        ; extended error code of last error
EXTERR_ACTION   db 0                    ; ...
                                        ; suggested action for last error
EXTERR_CLASS    db 0                    ; ...
                                        ; class of last error
EXTERRPT        dd 0                    ; ...
                                        ; Extended Error pointer
DMAADD          dd 80h                  ; ...
                                        ; current DTA (Disk Transfer Address)
CurrentPDB      dw 0                    ; ...
ConC_Spsave     dw 0                    ; ...
exit_code       dw 0                    ; ...
CURDRV          db 0                    ; ...
CNTCFLAG        db 0                    ; ...
CPSWFLAG        db 0
CPSWSAVE        db 0
USER_IN_AX      dw 0                    ; ...
PROC_ID         dw 0                    ; ...
USER_ID         dw 0                    ; ...
FirstArena      dw 0                    ; ...
BestArena       dw 0                    ; ...
LastArena       dw 0                    ; ...
ENDMEM          dw 0                    ; ...
LASTENT         dw 0                    ; ...
FAILERR         db 0                    ; ...
ALLOWED         db 0                    ; ...
NoSetDir        db 0                    ; ...
DidCTRLC        db 0                    ; ...
SpaceFlag       db 0                    ; ...
                db 90h
DAY             db 0                    ; ...
MONTH           db 0                    ; ...
YEAR            dw 0                    ; ...
                                        ; YEAR (and CENTURY)
DAYCNT          dw 0FFFFh               ; ...
WEEKDAY         db 0                    ; ...
CONSWAP         db 0                    ; ...
IDLEINT         db 1                    ; ...
fAborting       db 0                    ; ...
DEVCALL_REQLEN  db 0                    ; ...
                                        ; offset DEVCALL
DEVCALL_REQUNIT db 0                    ; ...
DEVCALL_REQFUNC db 0                    ; ...
DEVCALL_REQSTAT dw 0                    ; ...
                db 8 dup(0)
CALLUNIT        db 0                    ; ...
                                        ; CALLMED ; media byte
CALLBR          db 0                    ; ...
                                        ; CALLXAD ; dword
CALLVIDM        db 0                    ; ...
CALLXAD_2       dw 0                    ; ...
CALLBPB         dw 0                    ; ...
                                        ; CALLSCNT
CALLSSEC        dw 0                    ; ...
CALLVIDRW       dd 0                    ; ...
CALLNEWSC       dw 2 dup(0)             ; ...
CALLDEVAD       dd 0                    ; ...
IOCALL          db 0                    ; ...
IOCALL_REQUNIT  db 0                    ; ...
IOCALL_REQFUNC  db 0                    ; ...
IOCALL_REQSTAT  dw 0                    ; ...
                db 8 dup(0)
IOMED           db 0                    ; ...
IOXAD           dd 0                    ; ...
IOSCNT          dw 0                    ; ...
IOSSEC          dw 0                    ; ...
DSKSTCALL       db 14                   ; ...
                db 0
DSKSTCOM        db 5                    ; ...
DSKSTST         dw 0                    ; ...
                db 8 dup(0)
DSKCHRET        db 0                    ; ...
DEVIOBUF_PTR    dw offset DEVIOBUF      ; ...
DOSSEG_INIT     dw 0                    ; ...
DSKSTCNT        dw 1                    ; ...
                dw 0
CreatePDB       db 0                    ; ...
Lock_Buffer     dd 0                    ; ...
                dd 0
IOCTL_drvnum    db 90h                  ; ...
USERNUM         dd 0                    ; ...
TIMEBUF         dw 3 dup(0)             ; ...
                                        ; MSDAT001S
DEVIOBUF        dw 0                    ; ...
OPENBUF         db 128 dup(0)           ; ...
RENBUF          db 128 dup(0)           ; ...
SEARCHBUF       db 53 dup(0)            ; ...
DUMMYCDS        db 88 dup(0)            ; ...
NAME1           db 12 dup(0)            ; ...
                                        ; DEVFCB
NAME2           db 13 dup(0)            ; ...
DESTSTART       dw 0                    ; ...
                db 5 dup(0)             ; ((dir_entry.size)-($-DEVFCB))
ATTRIB          db 0                    ; ...
EXTFCB          db 0                    ; ...
SATTRIB         db 0                    ; ...
OPEN_ACCESS     db 0                    ; ...
FOUNDDEL        db 0                    ; ...
FOUND_DEV       db 0                    ; ...
FSPLICE         db 0                    ; ...
FSHARING        db 0                    ; ...
SECCLUSPOS      db 0                    ; ...
TRANS           db 0                    ; ...
READOP          db 0                    ; ...
THISDRV         db 0                    ; ...
CLUSFAC         db 0                    ; ...
CLUSSPLIT       db 0                    ; ...
INSMODE         db 0                    ; ...
CMETA           db 0                    ; ...
VOLID           db 0                    ; ...
EXIT_TYPE       dw 0                    ; ...
CREATING        db 0                    ; ...
DELALL          db 0                    ; ...
EXITHOLD        dd 0                    ; ...
USER_SP         dw 0                    ; ...
USER_SS         dw 0                    ; ...
CONTSTK         dw 0                    ; ...
THISDPB         dd 0                    ; ...
CLUSSAVE        dw 0                    ; ...
CLUSSEC         dd 0                    ; ...
PREREAD         dw 0                    ; ...
FATBYT          dw 0                    ; ...
FATBYTE         dw 0                    ; ...
DEVPT           dd 0                    ; ...
THISSFT         dd 0                    ; ...
THISCDS         dd 0                    ; ...
THISFCB         dd 0                    ; ...
SFN             dw 0FFFFh               ; ...
JFN             dw 0                    ; ...
PJFN            dd 0                    ; ...
WFP_START       dw 0                    ; ...
REN_WFP         dw 0                    ; ...
CURR_DIR_END    dw 0                    ; ...
NEXTADD         dw 0                    ; ...
LASTPOS         dw 0                    ; ...
CLUSNUM         dw 0                    ; ...
DIRSEC          dw 2 dup(0)             ; ...
DIRSTART        dw 0                    ; ...
SECPOS          dd 0                    ; ...
VALSEC          dw 2 dup(0)             ; ...
BYTSECPOS       dw 0                    ; ...
BYTPOS          dd 0                    ; ...
BYTCNT1         dw 0                    ; ...
BYTCNT2         dw 0                    ; ...
SECCNT          dw 0                    ; ...
ENTFREE         dw 0                    ; ...
ENTLAST         dw 0                    ; ...
NXTCLUSNUM      dw 0                    ; ...
GROWCNT         dd 0                    ; ...
CURBUF          dd 0                    ; ...
CONSFT          dd 0                    ; ...
SAVEBX          dw 0                    ; ...
SAVEDS          dw 0                    ; ...
RESTORE_TMP     dw 0                    ; ...
NSS             dw 0                    ; ...
NSP             dw 0                    ; ...
EXTOPEN_FLAG    dw 0                    ; ...
EXTOPEN_ON      db 0                    ; ...
EXTOPEN_IO_MODE dw 0                    ; ...
SAVE_DI         dw 0                    ; ...
SAVE_ES         dw 0                    ; ...
SAVE_DX         dw 0                    ; ...
SAVE_CX         dw 0                    ; ...
SAVE_BX         dw 0                    ; ...
SAVE_SI         dw 0                    ; ...
SAVE_DS         dw 0                    ; ...
HIGH_SECTOR     dw 0                    ; ...
OffsetMagicPatch dw offset MagicPatch   ; ...
DISK_FULL       db 0                    ; ...
TEMP_VAR        dw 0                    ; ...
TEMP_VAR2       dw 0                    ; ...
DrvErr          db 0                    ; ...
DOS34_FLAG      dw 0                    ; ...
NO_FILTER_PATH  dd 0
NO_FILTER_DPATH dd 0
AbsRdWr_SS      dw 0                    ; ...
AbsRdWr_SP      dw 0                    ; ...
                db 0
RENAMEDMA       db 384 dup(0)           ; ...
AUXSTACK        db 384 dup(0)           ; ...
DSKSTACK        db '@#IBM:12.01.2003.build_1.32#@ IBMDOS.COM(USA)',0 ; ...
                db 338 dup(0)           ; IOSTACK (just after DSKSTACK)
PRINTER_FLAG    db 0                    ; ...
VOLCHNG_FLAG    db 0FFh                 ; ...
                db 0
TEMP_DOSLOC     dw 0FFFFh               ; ...
LNE_COUNT       dw 0                    ; ...
                db 14 dup(0)
ENTLAST_PREV    dw 0                    ; ...
                db 36 dup(0)
absdrw_extd     db 0                    ; ...
DIRSTART_HW     dw 0                    ; ...
CLUSNUM_HW      dw 0                    ; ...
NXTCLUSNUM_HW   dw 0                    ; ...
LASTPOS_HW      dw 0                    ; ...
FATBYT_HW       dw 0                    ; ...
DESTSTART_HW    dw 0                    ; ...
CLUSTNUM_HW     dw 0                    ; ...
CLUSDATA_HW     dw 0                    ; ...
                                        ; (0 = release, -1 = allocate) INPUT for PACK
CCONTENT_HW     dw 0                    ; ...
                                        ; UNPACK output
ROOTCLUST_HW    dw 0                    ; ...
CCOUNT_HW       dw 0                    ; ...
                                        ; for ALLOCATE
CLUSTERS_HW     dw 0                    ; ...
                dw 0
                dw 0
CLSKIP_HW       dw 0                    ; ...
                                        ;
                                        ; SWAP_END
UCASE_TAB       dw 128                  ; ...
UCASE_TAB_2     db 128,154, 69, 65,142, 65,143,128 ; ...
                db  69, 69, 69, 73, 73, 73,142,143
                db 144,146,146, 79,153, 79, 85, 85
                db  89,153,154,155,156,157,158,159
                db  65, 73, 79, 85,165,165,166,167
                db 168,169,170,171,172,173,174,175
                db 176,177,178,179,180,181,182,183
                db 184,185,186,187,188,189,190,191
                db 192,193,194,195,196,197,198,199
                db 200,201,202,203,204,205,206,207
                db 208,209,210,211,212,213,214,215
                db 216,217,218,219,220,221,222,223
                db 224,225,226,227,228,229,230,231
                db 232,233,234,235,236,237,238,239
                db 240,241,242,243,244,245,246,247
                db 248,249,250,251,252,253,254,255
FILE_UCASE_TAB  dw 128                  ; ...
FILE_UCASE_TAB_2 db 128,154, 69, 65,142, 65,143,128 ; ...
                db  69, 69, 69, 73, 73, 73,142,143
                db 144,146,146, 79,153, 79, 85, 85
                db  89,153,154,155,156,157,158,159
                db  65, 73, 79, 85,165,165,166,167
                db 168,169,170,171,172,173,174,175
                db 176,177,178,179,180,181,182,183
                db 184,185,186,187,188,189,190,191
                db 192,193,194,195,196,197,198,199
                db 200,201,202,203,204,205,206,207
                db 208,209,210,211,212,213,214,215
                db 216,217,218,219,220,221,222,223
                db 224,225,226,227,228,229,230,231
                db 232,233,234,235,236,237,238,239
                db 240,241,242,243,244,245,246,247
                db 248,249,250,251,252,253,254,255
COLLATE_TAB     dw 256                  ; ...
                db  0, 1, 2, 3, 4, 5, 6, 7
                db  8, 9,10,11,12,13,14,15
                db 16,17,18,19,20,21,22,23
                db 24,25,26,27,28,29,30,31
                db ' !"#$%&',27h,'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                db '[\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~'
                db 127
                db 'CUEAAAACEEEIIIAAEAAOOOUUYOU$$$$$AIOUNN'
                db 166,167
                db '?'
                db 169,170,171,172
                db '!','"','"'
                db 176,177,178,179,180,181,182,183
                db 184,185,186,187,188,189,190,191
                db 192,193,194,195,196,197,198,199
                db 200,201,202,203,204,205,206,207
                db 208,209,210,211,212,213,214,215
                db 216,217,218,219,220,221,222,223
                db 224
                db 'S'
                db 226,227,228,229,230,231,232,233
                db 234,235,236,237,238,239,240,241
                db 242,243,244,245,246,247,248,249
                db 250,251,252,253,254,255
DBCS_TAB        dw 0                    ; ...
DBCS_TAB_2      db 16 dup(0)            ; ...
IBMDOSVERSION   db 7
                db 10                   ; MSVERSION
YRTAB           db 200,166,200,165,200,165,200,165 ; ...
MONTAB          db 31                   ; ...
february        db 28                   ; ...
                db 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
FILE_CHAR_TAB   dw 22                   ; ...
                                        ; length
                db 1                    ; include all
                db 0
                db 255
                db 0                    ; exclude 0 - 20h
                db 0
                db 20h
                db 2
                db 14                   ; exclude 14 special
                db '."/\[]:|<>+=;,'
                db 24 dup(0)            ; reserved
SysInitTable    dw offset DPBHEAD       ; ...
                                        ; SYSINITVARS
                dw 0
                dw offset COUNTRY_CDPG
                dw 0
                db 3 dup(0)
TEMPSEG         dw 0                    ; ...
redir_patch     db 0                    ; ...
DosHasHMA       db 0                    ; ...
FixExePatch     dw 0                    ; ...
RationalPatchPtr dw 0                   ; ...
; ---------------------------------------------------------------------------

MAP_CASE:                               ; ...
                cmp     al, 80h
                jb      short L_RET     ; Map no chars below 80H ever

Map1:                                   ;
                sub     al, 80h         ; Turn into index value
                push    ds
                push    bx
                mov     bx, offset UCASE_TAB_2 ; UCASE_TAB+2
                push    cs
                pop     ds
                assume ds:DOSCODE
                xlat                    ; Get upper case character
                pop     bx
                pop     ds
                assume ds:nothing

L_RET:                                  ; ...
                retf
; ---------------------------------------------------------------------------
Dir_Info_Buff   db 32 dup(0)            ; ...
Next_Element_Start dw 0                 ; ...
USER_SP_2F      dw offset FAKE_STACK_2F ; ...
FAKE_STACK_2F   dw 14 dup(0)            ; ...
                                        ; Packet_Temp
SCAN_FLAG       db 0                    ; ...
DATE_FLAG       dw 0                    ; ...
AbsDskErr       dw 0                    ; ...
                                        ; Storage for Abs dsk read/write err
NO_NAME_ID      db 'NO NAME    '        ; ...
                                        ; null media id
LOOKSIZ         db 0
; ---------------------------------------------------------------------------

SNULDEV:                                ; ...
                or      word ptr es:[bx+3], 100h ; [es:bx+SRHEAD.REQSTAT],STDON

INULDEV:                                ; ...
                retf
; ---------------------------------------------------------------------------
                db 0
UmbSave2        db 5 dup(0)             ; ...
UmbSaveFlag     db 0                    ; ...
ERR_TABLE_21    db    1,   7,   4,0FFh  ; ...
                db    2,   8,   3,   2  ; CLASS ACTION and LOCUS info for the INT 21h errors
                db    3,   8,   3,   2
                db    4,   1,   4,   1
                db    5,   3,   3,0FFh
                db    6,   7,   4,   1
                db    7,   7,   5,   5
                db    8,   1,   4,   5
                db    9,   7,   4,   5
                db  0Ah,   7,   4,   5
                db  0Bh,   9,   3,   1
                db  0Ch,   7,   4,   1
                db  0Dh,   9,   4,   1
                db  0Fh,   8,   3,   2
                db  10h,   3,   3,   2
                db  11h, 0Dh,   3,   2
                db  12h,   8,   3,   2
                db  50h, 0Ch,   3,   2
                db  20h, 0Ah,   2,   2
                db  21h, 0Ah,   2,   2
                db  54h,   1,   4,0FFh
                db  56h,   3,   3,   1
                db  52h,   1,   4,   2
                db  32h,   9,   3,   3
                db  55h, 0Ch,   3,   3
                db  57h,   9,   3,   1
                db  53h, 0Dh,   4,   1
                db  24h,   1,   4,   5
                db  26h,   1,   4,   1
                db  27h,   1,   4,   1
                db  5Ah, 0Dh,   4,   2
                db 0FFh,0FFh,0FFh,0FFh
ERR_TABLE_24    db  13h, 0Bh,   7,   2  ; ...
                db  14h,   4,   5,   1  ; CLASS ACTION and LOCUS info for the INT 24h errors
                db  15h,   5,   7,0FFh
                db  16h,   4,   5,   1
                db  17h, 0Bh,   4,   2
                db  18h,   4,   5,   1
                db  19h,   5,   1,   2
                db  1Ah, 0Bh,   7,   2
                db  1Bh, 0Bh,   4,   2
                db  1Ch,   2,   7,   4
                db  1Dh,   5,   4,0FFh
                db  1Eh,   5,   4,0FFh
                db  1Fh, 0Dh,   4,0FFh
                db  20h, 0Ah,   2,   2
                db  21h, 0Ah,   2,   2
                db  22h, 0Bh,   7,   2
                db  32h,   9,   3,   3
                db  23h,   7,   4,   1
                db  24h,   1,   4,   5
                db 0FFh, 0Dh,   5,0FFh
ErrMap24        db  13h, 14h, 15h, 16h, 17h, 18h, 19h, 1Ah ; ...
                db  1Bh, 1Ch, 1Dh, 1Eh, 1Fh, 1Fh, 1Fh, 22h
SPECIAL_VERSION dw 0                    ; ...
OLD_FIRSTCLUS   dw 0                    ; ...
exec_init_SP    dw 0                    ; ...
exec_init_SS    dw 0                    ; ...
exec_init_IP    dw 0                    ; ...
exec_init_CS    dw 0                    ; ...
exec_signature  dw 0                    ; ...
exec_len_mod_512 dw 0
exec_pages      dw 0                    ; ...
exec_rle_count  dw 0                    ; ...
exec_par_dir    dw 0                    ; ...
exec_min_BSS    dw 0                    ; ...
exec_max_BSS    dw 0                    ; ...
exec_SS         dw 0                    ; ...
exec_SP         dw 0                    ; ...
exec_chksum     dw 0
exec_IP         dw 0                    ; ...
exec_CS         dw 0
exec_rle_table  dw 0                    ; ...
Win386_Info     db 4, 0                 ; ...
                                        ; WIN386_SIS version
                dd 0                    ; .Next_Dev_Ptr
Win386_Inf_Virt_Dev_Ptr dd 0            ; ...
                                        ; .Virt_Dev_File_Ptr
                dd 0                    ; .Reference_Data
Instance_Data_Ptr dw offset Instance_Table
Win386_Info_16  dw 0                    ; ...
                dw offset Unknown_Table
                dw 0                    ; Win386_IIS.size
Instance_Table  dw offset CONTPOS       ; ...
InsTBL_CONTPOS_seg dw 0                 ; ...
                dw 2
                dw offset BCON
                dw 0
                dw 4
                dw offset CARPOS
                dw 0
                dw 106h
                dw offset CHARCO
                dw 0
                dw 1
                dw offset exec_init_SP
                dw 0
                dw 22h
                dw offset UMBFLAG
                dw 0
                dw 1
                dw offset UMB_HEAD
                dw 0
                dw 2
                dw offset DOS_FLAG
                dw 0C9h
                dw 1
                dw offset INDOS_FLAG    ; what for ?
                dw 0C9h
                dw 1
                dw offset DEVIO_IN_PROGRESS ; "devio call in progress" status flag ptr
                dw 0C9h
                dw 1
                dw 0
                dw 0
                dw 0FFFFh
                dw 0FFFFh
CL0FATENTRY_HW  dw 0FFFFh               ; ...
Unknown_Table   dw 0                    ; ...
                dw 0C9h
                dw offset SFTABL
                dw offset CARPOS
                dw 0C9h
                dw offset UNKNOWN1      ; ?
                dw 0
                dw 0
Win386_DOSVars  db 5                    ; ...
                                        ; Major_version
                db 0                    ; Minor_version
                dw offset SAVEDS
                dw offset SAVEBX
                dw offset INDOS
                dw offset USER_ID
                dw offset CritPatch
                dw offset UMB_HEAD
IsWin386        db 2 dup(0)             ; ...
                db 36h,0F6h, 6,20h, 3,0FFh ; Patch for Sidekick
                db 75h, 0Ch
                db 36h, 0FFh, 36h, 58h, 3
                db 0CDh, 28h
                db 80h,3Eh,20h, 3, 0    ; Patch for PortOfEntry
                db 75h, 37h
                db 0BCh, 0A0h, 0Ah
LocalSFT        dd 0                    ; ...
DOSINTTABLE     dd DIVOV                ; ...
DOSINTTABLE_4   dd QUIT                 ; ...
DOSINTTABLE_8   dd COMMAND              ; ...
DOSINTTABLE_12  dd ABSDRD               ; ...
DOSINTTABLE_16  dd ABSDWRT              ; ...
DOSINTTABLE_20  dd stay_resident        ; ...
DOSINTTABLE_24  dd INT2F                ; ...
DOSINTTABLE_28  dd CALL_ENTRY           ; ...
SS_Save         dw 0                    ; ...
SP_Save         dw 0                    ; ...
; ---------------------------------------------------------------------------

ldivov:                                 ; ...
                jmp     short divov_cont ; DIVIDE BY 0 handler
; ---------------------------------------------------------------------------
                call    EnsureA20ON     ; we must turn on A20 if OFF

divov_cont:                             ; ...
                jmp     cs:DOSINTTABLE  ; jmp to DOS
; ---------------------------------------------------------------------------

lquit:                                  ; ...
                jmp     short quit_cont ; INT 20h Handler
; ---------------------------------------------------------------------------
                call    EnsureA20ON

quit_cont:                              ; ...
                jmp     cs:DOSINTTABLE_4 ; jmp far [cs:DOSINTTABLE+4] ; jump to DOS
; ---------------------------------------------------------------------------

lcommand:                               ; ...
                jmp     short command_cont ; INT 21h Handler
; ---------------------------------------------------------------------------
                call    EnsureA20ON

command_cont:                           ; ...
                jmp     cs:DOSINTTABLE_8
; ---------------------------------------------------------------------------

labsdrd:                                ; ...
                jmp     short absdrd_cont ; INT 25h
; ---------------------------------------------------------------------------
                call    EnsureA20ON

absdrd_cont:                            ; ...
                jmp     cs:DOSINTTABLE_12
; ---------------------------------------------------------------------------

labsdwrt:                               ; ...
                jmp     short absdwrt_cont ; INT 26h
; ---------------------------------------------------------------------------
                call    EnsureA20ON

absdwrt_cont:                           ; ...
                jmp     cs:DOSINTTABLE_16
; ---------------------------------------------------------------------------

lstay_resident:                         ; ...
                jmp     short sr_cont   ; INT 27h
; ---------------------------------------------------------------------------
                call    EnsureA20ON

sr_cont:                                ; ...
                jmp     cs:DOSINTTABLE_20
; ---------------------------------------------------------------------------

lint2f:                                 ; ...
                jmp     short int2f_cont ; INT 2Fh
; ---------------------------------------------------------------------------
                call    EnsureA20ON     ; we must turn on A20 if OFF

int2f_cont:                             ; ...
                jmp     cs:DOSINTTABLE_24 ; jmp far [cs:DOSINTTABLE+24]
; ---------------------------------------------------------------------------

lcall_entry:                            ; ...
                jmp     short callentry_cont ; CPM entry
; ---------------------------------------------------------------------------
                call    EnsureA20ON

callentry_cont:                         ; ...
                jmp     cs:DOSINTTABLE_28 ; jmp far [cs:DOSINTTABLE+28] ; jmp to DOS
; ---------------------------------------------------------------------------
DosRetAddr23    dd 0                    ; ...
DosRetAddr24    dd 0                    ; ...
; ---------------------------------------------------------------------------

LowInt23:                               ; ...
                pop     word ptr cs:DosRetAddr23
                pop     word ptr cs:DosRetAddr23+2
                int     23h             ; DOS - CONTROL "C" EXIT ADDRESS
                                        ; Return: return via RETF 2 with CF set
                                        ; DOS will abort program with errorlevel 0
                                        ; else
                                        ; interrupted DOS call continues
                call    EnsureA20ON
                jmp     cs:DosRetAddr23
; ---------------------------------------------------------------------------

LowInt24:                               ; ...
                pop     word ptr cs:DosRetAddr24
                pop     word ptr cs:DosRetAddr24+2
                int     24h             ; DOS - FATAL ERROR HANDLER ADDRESS
                                        ; Automatically called upon detection of unrecoverable I/O error.
                call    EnsureA20ON
                jmp     cs:DosRetAddr24
; ---------------------------------------------------------------------------

LowInt28:                               ; ...
                int     28h             ; DOS 2+ internal - KEYBOARD BUSY LOOP
                call    EnsureA20ON
                retf
; ---------------------------------------------------------------------------

disa20_xfer:                            ; ...
                call    XMMDisableA20   ; disable A20
                cli                     ; DS:SI points to entry point
                                        ; AX:DI points to initial stack
                                        ; DX has PDB pointer
                                        ; BX has initial AX value
                mov     cs:INDOS, 0
                mov     ss:INDOS_FLAG, 0
                mov     ss, ax          ; set up user's stack
                mov     sp, di          ; and SP
                sti
                push    ds              ; fake long call to entry
                push    si
                mov     es, dx          ; set up proper seg registers
                mov     ds, dx
                mov     ax, bx          ; set up proper AX
                retf
; ---------------------------------------------------------------------------

disa20_iret:                            ; ...
                call    XMMDisableA20
                dec     ds:INDOS
                dec     ds:INDOS_FLAG
                mov     ss, ds:USER_SS  ; restore user stack
                mov     sp, ds:USER_SP
                mov     bp, sp
                mov     [bp+0], al      ; [BP+user_env.user_AX]
                les     ax, dword ptr ds:NSS
                mov     ds:USER_SP, es
                mov     ds:USER_SS, ax
                pop     ax              ; restore user regs
                pop     bx
                pop     cx
                pop     dx
                pop     si
                pop     di
                pop     bp
                pop     ds
                pop     es

lirett:                                 ; ...
                iret

; =============== S U B R O U T I N E =======================================


XMMDisableA20   proc near               ; ...
                push    bx
                push    ax
                mov     ah, 6           ; XMM_LOCAL_DISABLE_A20
                call    cs:XMMcontrol
                pop     ax
                pop     bx
                retn
XMMDisableA20   endp

; ---------------------------------------------------------------------------
XMMcontrol      dd 0                    ; ...
                dd 0
SC_STATUS       dw 0                    ; ...

; =============== S U B R O U T I N E =======================================


EnsureA20ON     proc near               ; ...
                pushf
                push    ds
                push    es
                push    cx
                push    si
                push    di
                xor     si, si          ; Compare the 4 words at 0000:0080
                mov     ds, si          ; with the 4 at FFFF:0090
                assume ds:DOSCODE
                dec     si
                mov     di, 90h         ; 0FFFFh:0090h ; HighMemory
                mov     es, si
                mov     si, 80h         ; 0000h:0080h ; LowMemory
                mov     cx, 4
                cld
                repe cmpsw
                jz      short EA20_OFF

EA20_RET:                               ; ...
                pop     di
                pop     si
                pop     cx
                pop     es
                pop     ds
                assume ds:nothing
                popf
                retn
; ---------------------------------------------------------------------------

EA20_OFF:                               ; ...
                push    bx
                push    ax
                mov     ax, cs
                mov     cs:SS_Save, ss
                mov     cs:SP_Save, sp
                mov     ss, ax
                assume ss:DOSCODE
                mov     sp, offset AUXSTACK
                mov     ah, 5           ; XMM_LOCAL_ENABLE_A20
                call    cs:XMMcontrol   ; call far [cs:XMMcontrol]
                or      ax, ax
                jz      short XMMerror  ; AX = 0 fatal error
                mov     ss, cs:SS_Save
                assume ss:nothing
                mov     sp, cs:SP_Save
                pop     ax
                pop     bx
                jmp     short EA20_RET
; ---------------------------------------------------------------------------

XMMerror:                               ; ...
                mov     ah, 0Fh
                int     10h             ; - VIDEO - GET CURRENT VIDEO MODE
                                        ; Return: AH = number of columns on screen
                                        ; AL = current video mode
                                        ; BH = current active display page
                cmp     al, 7
                jz      short XMMcont
                mov     ax, 2
                int     10h             ; - VIDEO - SET VIDEO MODE
                                        ; AL = mode

XMMcont:                                ; ...
                mov     ax, 500h
                int     10h             ; - VIDEO - SELECT DISPLAY PAGE
                                        ; AL = display page, 0-7  for modes 0 & 1, 0-3  for modes 2 & 3
                mov     si, offset XMMERRMSG ; "\r\n"
                push    cs
                pop     ds
                assume ds:DOSCODE
                cld

XMMprnt:                                ; ...
                lodsb
                cmp     al, 24h ; '$'   ; indicates end of XMMERRMSG
                jz      short XMMStall
                mov     ah, 0Eh
                mov     bx, 7
                int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
                                        ; AL = character, BH = display page (alpha modes)
                                        ; BL = foreground color (graphics modes)
                jmp     short XMMprnt
; ---------------------------------------------------------------------------

XMMStall:                               ; ...
                sti
                jmp     short XMMStall
EnsureA20ON     endp

; ---------------------------------------------------------------------------
OldInstanceJunk dw 70h                  ; ...
                                        ; segment of BIOS
                dw 0                    ; indicate stacks in SYSINIT area
                dw 6                    ; 6 instance items
OldInstanceJunk_6 dw 0                  ; ...
                dw offset CONTPOS
                dw 2
                dw 0
                dw offset BCON
                dw 4
                dw 0
                dw offset CARPOS
                dw 106h
                dw 0
                dw offset CHARCO
                dw 1
                dw 0
                dw offset exec_init_SP
                dw 34
                dw 70h
                dw 0Ch                  ; ALTAH byte in dos bios
                dw 1
; ---------------------------------------------------------------------------

RatBugCode:                             ; ...
                push    cx
                mov     cx, ds:10h

rbc_loop:                               ; ...
                loop    rbc_loop
                pop     cx
                retf
; ---------------------------------------------------------------------------
UmbSave1        db 11 dup(0)            ; ...
OLD_FIRSTCLUS_HW dw 0                   ; ...
FastOpenTable   dw 2                    ; ...
FastTable_2     dw offset FastRet       ; ...
                dw 0
                dw offset FastRet
                dw 0
FastOpenFlg     db 0                    ; ...
FastOpen_Ext_Info db 6 dup(0)           ; ...
UNKNOWN1        dw 0                    ; ...
                db 5 dup(0)
PATHNAMELEN     dw 67                   ; ...
                db 31 dup(0)
CurSC_DRIVE     db 0FFh                 ; ...
WinoldPatch2    db 8 dup(0)             ; ...
FIRST_BUFF_ADDR dw 0                    ; ...
DOSP1_ID        db 36h,0C5h,36h         ; Windows 3.1 patches
                db 36h, 5,0C5h,74h, 7,0E8h
                db 90h,90h
DOSP12_ID       db 36h,0C5h,36h
                db 36h, 5,0C5h,74h, 7,0E8h
DOSP3_ID        db 51h, 6,57h,0BAh
                db 29h, 2,0E8h
                db 9Ah,0E3h,5Fh, 7
DOSP4_ID        db 59h
DOSP5_ID        db 51h
                db 0ACh,3Ch,1Ah,74h, 5
                db 0E8h
DOSP7_ID        db 2Eh,8Ch,1Eh
                db 7Eh, 5
                db 2Eh,89h,1Eh
                db 7Ch, 5
                db 8Ch,0CBh
                db 8Eh,0DBh
                db 0FEh, 6
                db 0CFh, 2
                db 33h,0C0h
DOSP8_ID        db 50h,36h,0A1h
                db 0EAh, 2,26h,3Bh,45h
                db 2Fh,58h
DOSP10_ID       db  6,1Fh
                db 8Bh,0DFh
                db 33h,0C0h,8Bh,0D0h,0E8h
                db 0DFh,0Eh
                db 1Eh,36h,0C5h,36h,36h, 5,0E8h,0AFh
                db 0Eh,8Bh,0D7h,0B4h,86h,36h,8Bh,3Eh
                db  9, 3,0F7h,0C7h, 0,80h,74h,19h
                db 0E8h,47h,17h,8Bh,0FAh,0Ah,0C0h,74h
                db 10h,3Ch, 3,74h, 3,1Fh,0EBh,0CFh
                db 5Fh
                db 36h,0C4h,3Eh,36h, 5,0E9h,0A1h, 4
                db 5Fh, 8Bh, 0FAh
DOSP13_ID       db 0ACh,3Ch,24h,74h, 8,0B3h, 7,0B4h
                db 0Eh,0CDh,10h,0EBh,0F3h,0EBh,0FEh
XMMERRMSG       db 0Dh,0Ah              ; ...
                db 'A20 Hardware Error',0Dh,0Ah,'$'
COUNTRY_CDPG    db 0, 0, 0, 0, 0, 0, 0, 0 ; ...
                                        ; reserved words
                db '\COUNTRY.SYS',0     ; path name of country.sys
                db 51 dup(0)
                dw 437                  ; system code page id
                dw 6                    ; number of entries
COUNTRY_CDPG_76 db 2                    ; ...
                                        ; SetUcase
                dw offset UCASE_TAB
                dw 0
                db 4                    ; SetUcaseFile
                dw offset FILE_UCASE_TAB
                dw 0
                db 5                    ; SetFileList
                dw offset FILE_CHAR_TAB
                dw 0
                db 6                    ; SetCollate
                dw offset COLLATE_TAB
                dw 0
                db 7                    ; SetDBCS
                dw offset DBCS_TAB
                dw 0
                db 1                    ; SetCountryInfo
                dw 38                   ; NEW_COUNTRY_SIZE
_COUNTRY_ID     dw 1                    ; ...
                                        ; USA country id
                dw 437                  ; USA system code page id
COUNTRY_CDPG_108 dw 0                   ; ...
                                        ; date format
                db '$',0,0,0,0          ; currency symbol
                db ',',0                ; thousand separator
                db '.',0                ; decimal separator
                db '-',0                ; date separator
                db ':',0                ; time separator
                db 0                    ; currency format flag
                db 2                    ; # of digits after decimal in currency
                db 0                    ; time format
                dw offset MAP_CASE      ; mono case routine entry point
                dw 0                    ; segment of entry point
                db ',',0                ; data list separator
                dw 5 dup(0)             ; reserved
INDOS_FLAG      db 0                    ; ...
DEVIO_IN_PROGRESS db 0                  ; ...
_ENU            db 'ENU',0              ; ...
_USA            db 'USA',0
_US             db 'US'
                dw 1
                dw 2
                dw 0
_AM             db 'AM',0
_PM             db 'PM',0
_MMDDYY         db 'M/d/yy     dddd,MMMMdd,yyyy         '
                db 0
                db 0
                dw 0
VxDpath         db 'c:\wina20.386',0    ; ...
                db 0
drv_flags_1     db 0                    ; ...
drive_flags     db 26 dup(0)            ; ...
DriverLoad      db 1                    ; ...
BiosDataPtr     dw 2 dup(0)             ; ...
                db 5 dup(0)
                dw 4
                dw offset INDOS_FLAG
                dw offset drive_flags
                dw offset NLS_YES
                dw offset unknown_zero_dd
NLS_YES         db 'Y'                  ; ...
NLS_NO          db 'N'                  ; ...
NLS_yes2        db 'y'                  ; ...
NLS_no2         db 'n'                  ; ...
unknown_zero_dd dd 0                    ; ...
Rational386PatchPtr dw 0                ; ...
; ---------------------------------------------------------------------------

MagicPatch:                             ; ...
                retf
; ---------------------------------------------------------------------------
                db  90h
                db  90h
                db  90h
                db  90h
                db  90h
DOSDATA         ends

; ---------------------------------------------------------------------------
; File Name   : C:\Yedek\pcdos_7_1\IBMDOS.COM
; Format      : Binary file
; Base Address: 0000h Range: 0000h - A646h Loaded length: A646h
; ===========================================================================

; Segment type: Regular
DOSCODE         segment byte public 'DOSCODE' use16
                assume cs:DOSCODE
                ;org 3F10h
                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

$STARTCODE:                             ; ...
                jmp     DOSINIT
; ---------------------------------------------------------------------------
                dw offset $STARTCODE
BioDataSeg      dw 70h
DosDSeg         dw 0                    ; ...
                                        ; DOSDATA segment address
MSMAJOR         db 7                    ; DOS_MAJOR_VERSION
MSMINOR         db 10                   ; DOS_MINOR_VERSION
I21_MAP_E_TAB   db 38h, 2, 1, 2, 39h, 3, 3, 2 ; ...
                db 5, 3Ah, 4, 10h, 3, 2, 5, 3Bh ; INT 21h Error code mapping table
                db 2, 2, 3, 3Ch, 4, 3, 2, 4
                db 5, 3Dh, 6, 3, 2, 0Ch, 4, 1Ah
                db 5, 3Eh, 1, 6, 3Fh, 2, 6, 5
                db 40h, 2, 6, 5, 41h, 3, 3, 2
                db 5, 42h, 2, 6, 1, 43h, 4, 3
                db 2, 1, 5, 44h, 5, 0Fh, 0Dh, 1
                db 6, 5, 45h, 2, 6, 4, 46h, 2
                db 6, 4, 47h, 2, 1Ah, 0Fh, 48h, 2
                db 7, 8, 49h, 2, 7, 9, 4Ah, 3
                db 7, 9, 8, 4Bh, 8, 3, 1, 2
                db 4, 0Bh, 0Ah, 8, 5, 4Eh, 3, 3
                db 2, 12h, 4Fh, 1, 12h, 56h, 5, 11h
                db 3, 2, 10h, 5, 57h, 4, 6, 8
                db 0Dh, 1, 58h, 1, 1, 5Ah, 4, 3
                db 2, 4, 5, 5Bh, 5, 50h, 3, 2
                db 4, 5, 5Ch, 4, 6, 1, 24h, 21h
                db 65h, 2, 1, 2, 66h, 2, 1, 2
                db 68h, 1, 6, 67h, 3, 4, 8, 1
                db 6Ch, 0Ah, 3, 2, 0Ch, 4, 50h, 8
                db 1Ah, 0Dh, 1, 5, 69h, 4, 0Fh, 0Dh
                db 1, 5, 70h, 1, 1, 0FFh
                db 0
DISPATCH        dw offset $ABORT        ; ...
                                        ; Standard Functions (INT 21h System Calls)
                dw offset $STD_CON_INPUT
                dw offset $STD_CON_OUTPUT
                dw offset $STD_AUX_INPUT
                dw offset $STD_AUX_OUTPUT
                dw offset $STD_PRINTER_OUTPUT
                dw offset $RAW_CON_IO
                dw offset $RAW_CON_INPUT
                dw offset $STD_CON_INPUT_NO_ECHO
                dw offset $STD_CON_STRING_OUTPUT
                dw offset $STD_CON_STRING_INPUT
                dw offset $STD_CON_INPUT_STATUS
                dw offset $STD_CON_INPUT_FLUSH
                dw offset $DISK_RESET
                dw offset $SET_DEFAULT_DRIVE
                dw offset $FCB_OPEN
                dw offset $FCB_CLOSE
                dw offset $DIR_SEARCH_FIRST
                dw offset $DIR_SEARCH_NEXT
                dw offset $FCB_DELETE
                dw offset $FCB_SEQ_READ
                dw offset $FCB_SEQ_WRITE
                dw offset $FCB_CREATE
                dw offset $FCB_RENAME
                dw offset NO_OP
                dw offset $GET_DEFAULT_DRIVE
                dw offset $SET_DMA
                dw offset $SLEAZEFUNC
                dw offset $SLEAZEFUNCDL
                dw offset NO_OP
                dw offset NO_OP
                dw offset $GET_DEFAULT_DPB
                dw offset NO_OP
                dw offset $FCB_RANDOM_READ
                dw offset $FCB_RANDOM_WRITE
                dw offset $GET_FCB_FILE_LENGTH
                dw offset $GET_FCB_POSITION
                dw offset $SET_INTERRUPT_VECTOR
                dw offset $CREATE_PROCESS_DATA_BLOCK
                dw offset $FCB_RANDOM_READ_BLOCK
                dw offset $FCB_RANDOM_WRITE_BLOCK
                dw offset $PARSE_FILE_DESCRIPTOR
                dw offset $GET_DATE
                dw offset $SET_DATE
                dw offset $GET_TIME
                dw offset $SET_TIME
                dw offset $SET_VERIFY_ON_WRITE
                dw offset $GET_DMA
                dw offset $GET_VERSION
                dw offset $KEEP_PROCESS
                dw offset $GET_DPB
                dw offset $SET_CTRL_C_TRAPPING
                dw offset $GET_INDOS_FLAG
                dw offset $GET_INTERRUPT_VECTOR
                dw offset $GET_DRIVE_FREESPACE
                dw offset $CHAR_OPER
                dw offset $INTERNATIONAL
                dw offset $MKDIR
                dw offset $RMDIR
                dw offset $CHDIR
                dw offset $CREAT
                dw offset $OPEN
                dw offset $CLOSE
                dw offset $READ
                dw offset $WRITE
                dw offset $UNLINK
                dw offset $LSEEK
                dw offset $CHMOD
                dw offset $IOCTL
                dw offset $DUP
                dw offset $DUP2
                dw offset $CURRENT_DIR
                dw offset $ALLOC
                dw offset $DEALLOC
                dw offset $SETBLOCK
                dw offset $EXEC
                dw offset $EXIT
                dw offset $WAIT
                dw offset $FIND_FIRST
                dw offset $FIND_NEXT
                dw offset $SET_CURRENT_PDB
                dw offset $GET_CURRENT_PDB
                dw offset $GET_IN_VARS
                dw offset $SETDPB
                dw offset $GET_VERIFY_ON_WRITE
                dw offset $DUP_PDB
                dw offset $RENAME
                dw offset $FILE_TIMES
                dw offset $ALLOCOPER
                dw offset $GetExtendedError
                dw offset $CreateTempFile
                dw offset $CreateNewFile
                dw offset $LockOper
                dw offset $ServerCall
                dw offset $UserOper
                dw offset $AssignOper
                dw offset $NameTrans
                dw offset NO_OP
                dw offset $GET_CURRENT_PDB
                dw offset $ECS_Call
                dw offset $SET_PRINTER_FLAG
                dw offset $GetExtCntry
                dw offset $GetSetCdPg
                dw offset $ExtHandle
                dw offset $COMMIT
                dw offset $GSetMediaID
                dw offset $COMMIT
                dw offset NO_OP
                dw offset $Extended_Open ; 6Ch
                dw offset NO_OP         ; 6Dh, OS/2 "DosMkDir2" - ROM DOS: Find first ROM program
                dw offset NO_OP         ; 6Eh, OS/2 "DosEnumAttrib" - ROM DOS: Find next ROM program
                dw offset NO_OP         ; 6Fh, OS/2 "DosQMaxEASize" - ROM DOS: Get/set searched ROM area
                dw offset $ExtCountryInfo ; 70h, MSDOS 7 (WIN 95) - Get/set extended country information
                                        ;         GET/SET INTERNATIONALIZATION INFORMATION
                dw offset $LONGNAME     ; 71h, MSDOS 7 (WIN 95) LONG FILENAME FUNCTIONS
                dw offset $LONGNAME     ; 72h, MSDOS 7 (WIN 95) LFN-FindClose
                dw offset $FAT32EXT     ; 73h, MSDOS 7 - FAT32 extended drive functions
FOO             dw offset Leave2F       ; ...
DTab            dw offset DOSTable      ; ...
DOSTable        db 50                   ; ...
                dw offset DOSInstall
                dw offset DOS_CLOSE
                dw offset RECSET
                dw offset DOSGetGroup
                dw offset PATHCHRCMP
                dw offset OUTT
                dw offset NET_I24_ENTRY
                dw offset PLACEBUF
                dw offset FREE_SFT
                dw offset BUFWRITE
                dw offset SHARE_VIOLATION
                dw offset SHARE_ERROR
                dw offset SET_SFT_MODE
                dw offset DATE16
                dw offset Idle
                dw offset SCANPLACE
                dw offset Idle
                dw offset StrCpy
                dw offset StrLen
                dw offset UCase
                dw offset POINTCOMP
                dw offset CHECKFLUSH
                dw offset SFFromSFN
                dw offset GetCDSFromDrv
                dw offset Get_User_Stack
                dw offset GETTHISDRV
                dw offset DriveFromText
                dw offset SETYEAR
                dw offset DSUM
                dw offset DSLIDE
                dw offset StrCmp
                dw offset InitCDS
                dw offset pJFNFromHandle
                dw offset $NameTrans
                dw offset CAL_LK
                dw offset DEVNAME
                dw offset Idle
                dw offset DStrLen
                dw offset NLS_OPEN
                dw offset $CLOSE
                dw offset NLS_LSEEK
                dw offset $READ
                dw offset FastInit
                dw offset NLS_IOCTL
                dw offset GetDevList
                dw offset NLS_GETEXT
                dw offset MSG_RETRIEVAL
                dw offset NO_OP
                dw offset int_2Fh_1230h
                dw offset int_2Fh_1231h
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR STATCHK

$SET_CTRL_C_TRAPPING:                   ; ...
                cmp     al, 7           ; Is this a valid subfunction?
                jbe     short scct_1    ; yes
                mov     al, 0FFh
                iret
; ---------------------------------------------------------------------------

scct_1:                                 ; ...
                push    ds
                mov     ds, cs:DosDSeg
                push    ax
                push    si
                mov     si, offset CNTCFLAG
                xor     ah, ah
                or      ax, ax          ; Check for subfunction 0
                jnz     short scct_2
                mov     dl, [si]        ; DS:SI --> Ctrl C Status byte
                jmp     short scct_9s
; ---------------------------------------------------------------------------

scct_2:                                 ; ...
                dec     ax
                jnz     short scct_3
                and     dl, 1           ; mask off bit 0 of DL and
                mov     [si], dl        ; save it as new Ctrl C status
                jmp     short scct_9s
; ---------------------------------------------------------------------------

scct_3:                                 ; ...
                dec     ax
                jnz     short scct_4
                and     dl, 1           ; mask off bit 0 of DL and
                xchg    dl, [si]        ; exchange DL with old status byte
                jmp     short scct_9s
; ---------------------------------------------------------------------------

scct_4:                                 ; ...
                cmp     al, 3           ; test for 5 after it was dec twice
                jnz     short scct_5
                mov     dl, ds:BOOTDRIVE ; return boot drive in DL
                jmp     short scct_9s
; ---------------------------------------------------------------------------

scct_5:                                 ; ...
                jb      short scct_9s
                cmp     al, 4           ; test for 6 after it was dec twice
                jnz     short scct_6
                mov     bx, 0A07h       ; 7.10 ; (MINOR_VERSION<<8)+MAJOR_VERSION
                mov     dx, 0           ; DOSREVNM
                cmp     ds:DosHasHMA, dh ; is DOS in HMA? no
                jz      short scct_9s
                mov     dh, 10h         ; yes
                jmp     short scct_9s   ; return version & 'DOS in HMA' status
; ---------------------------------------------------------------------------

scct_6:                                 ; ...
                and     ds:DOS_FLAG, 0DFh ; clear bit 5 of DOS flag
                cmp     dl, 1
                jnz     short scct_9s
                or      ds:DOS_FLAG, 20h ; set bit 5 of DOS flag

scct_9s:                                ; ...
                pop     si
                pop     ax
                pop     ds
                iret
; ---------------------------------------------------------------------------

SetCtrlShortEntry:                      ; ...
                jmp     short $SET_CTRL_C_TRAPPING
; ---------------------------------------------------------------------------

$SET_CURRENT_PDB:                       ; ...
                push    ds
                mov     ds, cs:DosDSeg
                mov     ds:CurrentPDB, bx
                pop     ds
                iret
; ---------------------------------------------------------------------------

$GET_CURRENT_PDB:                       ; ...
                push    ds
                mov     ds, cs:DosDSeg
                mov     bx, ds:CurrentPDB
                pop     ds
                iret
; ---------------------------------------------------------------------------

$SET_PRINTER_FLAG:                      ; ...
                push    ds
                mov     ds, cs:DosDSeg
                mov     ds:PRINTER_FLAG, al
                pop     ds
                iret
; END OF FUNCTION CHUNK FOR STATCHK
; ---------------------------------------------------------------------------

QUIT:                                   ; ...
                xor     ah, ah
                jmp     short SAVREGS
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR STATCHK

BADCALL:                                ; ...
                xor     al, al

irett:                                  ; ...
                iret
; END OF FUNCTION CHUNK FOR STATCHK
; ---------------------------------------------------------------------------

CALL_ENTRY:                             ; ...
                push    ds              ; System call entry point and dispatcher
                                        ; ***
                                        ; An alternative method of entering the system
                                        ; is to perform a CALL 5 in the program segment prefix
                                        ; with the contents of CL indicating what system call
                                        ; the user would like
                mov     ds, cs:DosDSeg
                pop     ds:SAVEDS
                pop     ax
                pop     ax
                pop     ds:USER_SP
                pushf                   ; Re-order the stack
                                        ; to simulate an interrupt 21h.
                cli
                push    ax
                push    ds:USER_SP      ; Stack now ordered as if INT had been used
                push    ds:SAVEDS
                pop     ds
                cmp     cl, 36          ; MAXCALL
                                        ; This entry point doesn't get as many calls
                ja      short BADCALL
                mov     ah, cl
                jmp     short SAVREGS
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR STATCHK

COMMAND:                                ; ...
                cli                     ; This is the normal INT 21h entry point.
                                        ; We first perform a quick test to see if
                                        ; we need to perform expensive DOS-entry
                                        ; functions. Certain system calls are done
                                        ; without interrupts being enabled.
                cmp     ah, 73h
                ja      short BADCALL

SAVREGS:                                ; ...
                cmp     ah, 33h         ; Check Minimum special case number
                jb      short SaveAllRegs
                jz      short SetCtrlShortEntry
                cmp     ah, 64h         ; Check Maximum case number
                ja      short SaveAllRegs
                jz      short $SET_PRINTER_FLAG
                cmp     ah, 51h
                jz      short $GET_CURRENT_PDB
                cmp     ah, 50h
                jz      short $SET_CURRENT_PDB
                cmp     ah, 62h
                jz      short $GET_CURRENT_PDB

SaveAllRegs:                            ; ...
                push    es
                push    ds
                push    bp
                push    di
                push    si
                push    dx
                push    cx
                push    bx
                push    ax
                mov     ax, ds
                mov     ds, cs:DosDSeg
                mov     ds:SAVEDS, ax
                mov     ax, ds:USER_SP
                mov     ds:SAVEBX, bx
                mov     ds:NSP, ax
                mov     ax, ds:USER_SS
                mov     ds:NSS, ax
                xor     ax, ax          ; 0
                test    ds:IsWin386, 1  ; WIN386 patch. Do not update USER_ID
                mov     ds:FSHARING, al ; allow redirection
                jnz     short set_indos_flag ; if win386 present
                mov     ds:USER_ID, ax

set_indos_flag:                         ; ...
                inc     ds:INDOS        ; Flag that we're in the DOS
                inc     ds:INDOS_FLAG   ; duplicated INDOS flag (what for ?)
                mov     ax, ds:CurrentPDB
                mov     ds:USER_SP, sp
                mov     ds:USER_SS, ss
                mov     ds:PROC_ID, ax
                mov     ds, ax
                pop     ax
                push    ax
                mov     word ptr ds:2Eh, sp ; [PDB.USER_STACK]
                mov     word ptr ds:30h, ss ; [PDB.USER_STACK+2]
                mov     ss, cs:DosDSeg

REDISP:                                 ; ...
                mov     sp, offset AUXSTACK
                sti
                mov     bx, ss
                mov     ds, bx
                xchg    ax, bx
                xor     ax, ax
                mov     ds:EXTOPEN_ON, al ; Clear extended open flag
                and     ds:DOS34_FLAG, 800h ; EXEC_AWARE_REDIR
                                        ; clear all bits except bit 11
                mov     ds:CONSWAP, al  ; random clean up of possibly mis-set flags
                mov     ds:NoSetDir, al ; set directories on search
                mov     ds:FAILERR, al  ; FAIL not in progress
                inc     ax
                mov     ds:IDLEINT, al  ; presume that we can issue INT 28h
                xchg    ax, bx          ; Restore AX and BX = 1
                mov     bl, ah
                add     bx, bx          ; 2 bytes per call in table
                cld
                or      ah, ah
                jz      short DSKROUT
                cmp     ah, 59h         ; GETEXTENDEDERROR
                jz      short DISPCALL
                cmp     ah, 0Ch         ; STD_CON_INPUT_FLUSH ; 12
                ja      short DSKROUT

IOROUT:                                 ;
                cmp     ds:ERRORMODE, 0 ; Are we in an INT 24h
                jnz     short DISPCALL  ; Stay on AUXSTACK if INT 24h
                mov     sp, offset PRINTER_FLAG ; mov sp,IOSTACK
                jmp     short DISPCALL
; ---------------------------------------------------------------------------

DSKROUT:                                ; ...
                mov     ds:USER_IN_AX, ax
                mov     word ptr ds:WPERR, 1FFh
                mov     ds:ERRORMODE, 0
                push    ax
                mov     ah, 82h
                int     2Ah             ; Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7
                pop     ax
                mov     ds:IDLEINT, 0
                mov     sp, offset DSKSTACK ; "@#IBM:12.01.2003.build_1.32#@ IBMDOS.CO"...
                test    ds:CNTCFLAG, 0FFh
                jz      short DISPCALL
                push    ax
                call    DSKSTATCHK
                pop     ax

DISPCALL:                               ; ...
                mov     bx, cs:DISPATCH[bx]
                xchg    bx, ds:SAVEBX
                mov     ds, ds:SAVEDS
                call    ss:SAVEBX
                and     ss:DOS_FLAG, 0DBh

LeaveDOS:                               ; ...
                cli
                mov     ds, cs:DosDSeg
                cmp     ds:A20OFF_COUNT, 0
                jnz     short disa20

LeaveA20On:                             ; ...
                dec     ds:INDOS
                dec     ds:INDOS_FLAG
                mov     ss, ds:USER_SS
                mov     sp, ds:USER_SP
                mov     bp, sp
                mov     [bp+0], al
                les     ax, dword ptr ds:NSS
                mov     ds:USER_SS, ax
                mov     ds:USER_SP, es
                pop     ax
                pop     bx
                pop     cx
                pop     dx
                pop     si
                pop     di
                pop     bp
                pop     ds
                pop     es
                iret
; ---------------------------------------------------------------------------

disa20:                                 ; ...
                mov     bx, ds:A20OFF_PSP
                cmp     bx, ds:CurrentPDB
                jnz     short LeaveA20On
                dec     ds:A20OFF_COUNT
                push    ds
                mov     bx, offset disa20_iret
                push    bx
                retf
; END OF FUNCTION CHUNK FOR STATCHK

; =============== S U B R O U T I N E =======================================


restore_world   proc near               ; ...
                mov     es, cs:DosDSeg
                pop     es:RESTORE_TMP
                pop     ax
                pop     bx
                pop     cx
                pop     dx
                pop     si
                pop     di
                pop     bp
                pop     ds
                jmp     es:RESTORE_TMP
restore_world   endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


save_world      proc near               ; ...
                mov     es, cs:DosDSeg
                pop     es:RESTORE_TMP
                push    ds
                push    bp
                push    di
                push    si
                push    dx
                push    cx
                push    bx
                push    ax
                push    es:RESTORE_TMP
                push    bp
                mov     bp, sp
                mov     es, word ptr [bp+20]
                pop     bp
                retn
save_world      endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


Get_User_Stack  proc near               ; ...
                mov     ds, cs:DosDSeg
                lds     si, dword ptr ds:USER_SP
                retn
Get_User_Stack  endp

; ---------------------------------------------------------------------------
ERRIN           db 2                    ; ...
                db 6
                db 0Ch
                db 4
                db 8
                db 0
ERROUT          db 80h
                db 40h
                db 2
                db 10h
                db 4
                db 3

; =============== S U B R O U T I N E =======================================


AbsSetup        proc near               ; ...
                mov     ss:absdrw_extd, ah ; Extended ABS Disk Read/Write flag
                                        ; (AH=1 for INT 21h ax=7305h function)
                or      ah, ah
                jnz     short AbsSetup1 ; INT 21h AX=7305h
                                        ; INT 25h
                inc     ss:INDOS_FLAG   ; Windows DOSBOX's INDOS flag ?
                inc     ss:INDOS

AbsSetup1:                              ; ...
                sti
                cld
                push    ds
                push    ss
                pop     ds
                call    GETBP
                pop     ds
                jb      short errdriv

AbsSetup2:
                mov     ss:HIGH_SECTOR, 0
                call    RW32_CONVERT
                jb      short errdriv
                call    null_sub        ; SET_RQ_SC_PARMS
                push    ds
                push    si
                push    ax
                push    ss
                pop     ds
                mov     si, offset OPENBUF
                mov     [si], al
                add     byte ptr [si], 41h ; 'A'
                mov     word ptr [si+1], 3Ah ; ':'
                mov     ax, 300h
                clc
                int     2Ah             ; Microsoft Networks - CHECK DIRECT I/O
                                        ; DS:SI -> ASCIZ disk device name (may be full path or only drive
                                        ; specifier--must include the colon)
                                        ; Return: CF clear if absolute disk access allowed
                pop     ax
                pop     si
                pop     ds
                jnb     short AbsSetup_retn

errdriv:                                ; ...
                mov     ss:EXTERR, 32h  ; error_not_supported
                mov     ss:AbsDskErr, 207h ; disk error ? (bad address mark)

AbsSetup_retn:                          ; ...
                retn
AbsSetup        endp

; ---------------------------------------------------------------------------

ABSDRD:                                 ; ...
                xor     ah, ah          ; Interrupt 25h handler (ah=0)
                xor     si, si          ; clear read/write mode flags
                                        ; (used with INT 21h ax=7305h)

FAT32_ABSDRD:                           ; ...
                cli                     ; ah=1
                clc
; START OF FUNCTION CHUNK FOR FAT32_ABSDWRT

absdrd_1:                               ; ...
                push    ax
                mov     ax, ds
                mov     ds, cs:DosDSeg
                mov     ds:TEMPSEG, ax
                pop     ax
                push    es
                jnb     short absdrd_2  ; (not jumped from ABSDWRT) absolute disk read
                                        ; (jumped from ABSDRWT)
                or      ah, ah
                stc                     ; absolute disk write
                jmp     short absdrd_3
; ---------------------------------------------------------------------------

absdrd_2:                               ; ...
                or      ah, ah

absdrd_3:                               ; ...
                jnz     short absdrd_4  ; EXTENDED ABSOLUTE DISK READ/WRITE
                mov     ds:AbsRdWr_SS, ss
                mov     ds:AbsRdWr_SP, sp
                mov     ss, cs:DosDSeg
                mov     sp, offset DSKSTACK ; "@#IBM:12.01.2003.build_1.32#@ IBMDOS.CO"...

absdrd_4:                               ; ...
                mov     ds, ds:TEMPSEG
                push    es
                call    save_world
                push    es
                jnb     short absdrd_5  ; absolute disk read
                jmp     absdrwt_3       ; (jumping back to) absolute disk write
; ---------------------------------------------------------------------------

absdrd_5:                               ; ...
                call    AbsSetup
                jb      short ILEAVE
                call    ECritDisk
                mov     ss:CurSC_DRIVE, 0FFh ; invalidate secondary cache
                call    LCritDisk
                call    DSKREAD
                jnz     short ERR_LEAVE
                mov     cx, di
                mov     ss:TEMP_VAR2, ds
                mov     ss:TEMP_VAR, bx ; CX = # of contiguous sectors read
                                        ; ES:BP -> Drive Parameter Block (DPB)
                                        ; [HIGH_SECTOR]:DX = physical sector # of 1st sector in extent
                                        ; [TEMP_VAR2]:[TEMP_VAR] = Transfer address
                call    DskRdBufScan
                jmp     short ILEAVE
; ---------------------------------------------------------------------------

TLEAVE:                                 ; ...
                jz      short ILEAVE

ERR_LEAVE:                              ; ...
                push    es
                push    cs
                pop     es
                assume es:DOSCODE
                xor     ah, ah
                mov     cx, 6
                mov     di, offset ERRIN
                repne scasb
                jnz     short LEAVECODE
                mov     ah, es:[di+5]   ; [ES:DI+NUMERR-1]

LEAVECODE:                              ; ...
                pop     es
                assume es:nothing
                mov     ss:AbsDskErr, ax
                stc

ILEAVE:                                 ; ...
                pop     es
                call    restore_world
                pop     es
                pushf
                cmp     ss:absdrw_extd, 0 ; FAT32- EXTENDED ABSOLUTE DISK READ/WRITE flag
                jnz     short ILEAVE_EXTD ; INT 21h AX=7305h
                                        ; INT 25h
                popf
                cli
                mov     ax, ss:AbsDskErr
                dec     ss:INDOS
                dec     ss:INDOS_FLAG
                push    ss
                pop     es
                mov     ss, es:AbsRdWr_SS
                assume ss:DOSCODE
                mov     sp, es:AbsRdWr_SP
                pop     es
                sti
                retf
; ---------------------------------------------------------------------------

ILEAVE_EXTD:                            ; ...
                popf
                mov     ax, ss:AbsDskErr
                pop     es
                sti
                retn
; END OF FUNCTION CHUNK FOR FAT32_ABSDWRT
; ---------------------------------------------------------------------------

ABSDWRT:                                ; ...
                xor     ah, ah
                mov     si, 1

; =============== S U B R O U T I N E =======================================


FAT32_ABSDWRT   proc far                ; ...

; FUNCTION CHUNK AT 43CA SIZE 000000AD BYTES

                cmp     al, 2
                jb      short absdrwt_2 ; floppy disk
                                        ; hard disk
                push    bx
                push    ds
                mov     ds, cs:DosDSeg
                xor     bh, bh
                mov     bl, al          ;
                                        ; NOTE: PCDOS 7.1 kernel does not set
                                        ; DOS_FLAG bit 6 or drive_flags bit 7
                                        ; (It appears that these bits are set
                                        ; by Windows or a system utility or
                                        ; driver that knows the addresses of
                                        ; these FLAGs in the DOSDATA segment.)
                                        ; Erdogan Tan - 03/01/2024
                test    ds:drive_flags[bx], 80h ; test bit 7 (locked bit) ; 29/01/2024
                jnz     short absdwrt_1 ; locked (logical drive) -allowed to abs write-
                                        ; NOTE: lock/unlock are MSDOS/PCDOS 7 extd functions
                test    ds:DOS_FLAG, 40h ; test bit 6 (large disk support -windows- bit?)
                                        ; NOTE: Retro DOS v5 kernel must set this bit.

absdwrt_1:                              ; ...
                pop     ds
                pop     bx
                jnz     short absdrwt_2 ; allowed
                stc
                call    errdriv         ; error
                retf
; ---------------------------------------------------------------------------

absdrwt_2:                              ; ...
                cli
                stc                     ; writable disk
                                        ; ('jumped from ABSDWRT' sign for common r/w code)
                jmp     absdrd_1        ; jump to ABSDRD (common r/w) code
; ---------------------------------------------------------------------------

absdrwt_3:                              ; ...
                call    AbsSetup
                jb      short ILEAVE
                call    chk_set_first_access
                call    ECritDisk
                mov     ss:CurSC_DRIVE, 0FFh ; invalidate secondary cache
                call    Fastxxx_Purge   ; purge fastopen
                call    LCritDisk
                push    ds
                call    DskWrtBufPurge
                pop     ds
                call    DSKWRITE
                jmp     TLEAVE
FAT32_ABSDWRT   endp


; =============== S U B R O U T I N E =======================================


GETBP           proc near               ; ...
                push    ax              ; logical unit number
                add     al, 1           ; no increment; need carry flag
                jb      short SKIPGET
                call    GETTHISDRV
                jnb     short SKIPGET   ; good drive
                xor     ah, ah
                cmp     ax, 1Ah         ; error_not_DOS_disk
                jz      short SKIPGET   ; unknown media
                stc
                mov     ds:EXTERR, ax   ; invalid drive or Non DOS drive
                mov     ds:AbsDskErr, 201h

SKIPGET:                                ; ...
                pop     ax
                jnb     short GETBP_@f
                retn
; ---------------------------------------------------------------------------

GETBP_@f:                               ; ...
                les     bp, ds:THISCDS
                test    byte ptr es:[bp+44h], 80h ; [es:bp+curdir.flags+1],
                                        ; curdir_isnet>>8
                jz      short GETBP_CDS

GETBP_err:                              ; ...
                mov     ds:EXTERR, 32h ; '2' ; error_not_supported
                stc
                retn
; ---------------------------------------------------------------------------

GETBP_CDS:                              ; ...
                les     bp, es:[bp+45h] ; [ES:BP+curdir.devptr]
                push    ax
                mov     ax, es
                or      ax, bp
                pop     ax
                jz      short GETBP_err ; zero address, error
GETBP           endp


; =============== S U B R O U T I N E =======================================


GOTDPB          proc near               ; ...
                mov     word ptr ds:THISDPB, bp
                mov     word ptr ds:THISDPB+2, es
                retn
GOTDPB          endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR $IOCTL

SYS_RET_OK:                             ; ...
                call    Get_User_Stack
                and     word ptr [si+16h], 0FFFEh ; [SI+user_env.user_F],~f_Carry

DO_RET:                                 ; ...
                mov     [si], ax
                retn
; ---------------------------------------------------------------------------

SYS_RET_ERR:                            ; ...
                xor     ah, ah          ; hack to allow for smaller error rets
                call    ETAB_LK         ; Make sure code is OK, EXTERR gets set
                call    ErrorMap

From_GetSet:                            ; ...
                call    Get_User_Stack
                or      word ptr [si+16h], 1 ; [SI+user_env.user_F],f_Carry
                stc
                jmp     short DO_RET
; END OF FUNCTION CHUNK FOR $IOCTL
; ---------------------------------------------------------------------------

NO_OP:                                  ; ...
                xor     al, al          ; obsolete system calls dispatch to here
                retn

; =============== S U B R O U T I N E =======================================


FCB_RET_ERR     proc near               ; ...
                xor     ah, ah
                mov     ss:EXTERR, ax
                call    ErrorMap
                mov     al, 0FFh        ; -1
                retn
FCB_RET_ERR     endp


; =============== S U B R O U T I N E =======================================


ErrorMap        proc near               ; ...
                push    si
                mov     si, offset ERR_TABLE_21
                cmp     ss:FAILERR, 0   ; Check for SPECIAL case.
                jz      short EXTENDED_NORMAL ; All is OK.
                mov     ss:EXTERR, 53h  ; error_FAIL_I24 ; real reason

EXTENDED_NORMAL:                        ; ...
                call    CAL_LK          ; Set CLASS,ACTION,LOCUS for EXTERR
                pop     si
                retn
ErrorMap        endp


; =============== S U B R O U T I N E =======================================


CAL_LK          proc near               ; ...
                push    ds              ; Look up and set CLASS ACTION and LOCUS values
                                        ;  for GetExtendedError
                push    ax
                push    bx
                mov     ds, cs:DosDSeg  ; DOSDATA segment
                mov     bx, ds:EXTERR   ; Get error in BL

TABLK1:                                 ; ...
                lodsb
                cmp     al, 0FFh
                jz      short GOT_VALS  ; End of table
                cmp     al, bl
                jz      short GOT_VALS  ; Got entry
                add     si, 3           ; Next table entry
                jmp     short TABLK1
; ---------------------------------------------------------------------------

GOT_VALS:                               ; ...
                lodsw
                cmp     ah, 0FFh
                jz      short NO_SET_ACT
                mov     ds:EXTERR_ACTION, ah ; Set ACTION

NO_SET_ACT:                             ; ...
                cmp     al, 0FFh
                jz      short NO_SET_CLS
                mov     ds:EXTERR_CLASS, al ; Set CLASS

NO_SET_CLS:                             ; ...
                lodsb                   ; Get LOCUS
                cmp     al, 0FFh
                jz      short NO_SET_LOC
                mov     ds:EXTERR_LOCUS, al

NO_SET_LOC:                             ; ...
                pop     bx
                pop     ax
                pop     ds
                retn
CAL_LK          endp


; =============== S U B R O U T I N E =======================================


ETAB_LK         proc near               ; ...
                push    ds              ; check for appropriate error code
                push    si
                push    cx
                push    bx
                push    ss
                pop     ds
                assume ds:DOSCODE
                mov     EXTERR, ax      ; Set EXTERR with "real" error
                mov     si, offset I21_MAP_E_TAB
                mov     bh, al          ; Real code to BH
                mov     bl, byte ptr USER_IN_AX+1 ; Sys call to BL

TABLK2:                                 ; ...
                lods    word ptr cs:[si]
                cmp     al, 0FFh        ; End of table?
                jz      short NOT_IN_TABLE
                cmp     al, bl          ; Found call?
                jz      short GOT_CALL  ; Yes
                xchg    ah, al
                xor     ah, ah
                add     si, ax          ; Next table entry
                jmp     short TABLK2
; ---------------------------------------------------------------------------

NOT_IN_TABLE:                           ; ...
                mov     al, bh          ; Restore original code
                jmp     short NO_MAP
; ---------------------------------------------------------------------------

GOT_CALL:                               ; ...
                mov     cl, ah
                xor     ch, ch          ; Count of valid err codes to CX

CHECK_CODE:                             ; ...
                lods    byte ptr cs:[si]
                cmp     al, bh          ; Code OK?
                jz      short NO_MAP    ; Yes
                loop    CHECK_CODE

NO_MAP:                                 ; ...
                xor     ah, ah          ; AX is now valid code
                pop     bx
                pop     cx
                pop     si
                pop     ds
                assume ds:nothing
                retn
ETAB_LK         endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


SetBad          proc near               ; ...
                mov     ax, 1           ; error_invalid_function
                push    ds
                mov     ds, cs:DosDSeg
                mov     ds:EXTERR_LOCUS, 1 ; errLOC_Unk
                pop     ds
                stc
                retn
SetBad          endp


; =============== S U B R O U T I N E =======================================


BadCall         proc far                ; ...
                call    SetBad
                retf
BadCall         endp


; =============== S U B R O U T I N E =======================================


OKCall          proc far                ; ...
                clc
                retf
OKCall          endp

; ---------------------------------------------------------------------------

INT2F:                                  ; ...
                sti
                cmp     ah, 11h         ; MultNET
                jnz     short INT2FSHR

TestInstall:                            ; ...
                or      al, al
                jz      short Leave2F

BadFunc:                                ; ...
                call    SetBad

Leave2F:                                ; ...
                retf    2
; ---------------------------------------------------------------------------

INT2FSHR:                               ; ...
                cmp     ah, 10h         ; MultSHARE
                jz      short TestInstall
                cmp     ah, 14h         ; NLSFUNC
                jz      short TestInstall
                cmp     ah, 12h         ; MultDOS
                jnz     short check_win
                jmp     DispatchDOS
; ---------------------------------------------------------------------------

check_win:                              ; ...
                cmp     ah, 16h         ; MultWin386
                jz      short Win386_Msg
                cmp     ah, 46h         ; WINOLDAP
                jnz     short next_i2f
                jmp     Winold_swap
; ---------------------------------------------------------------------------

next_i2f:                               ; ...
                jmp     far ptr 70h:5
; ---------------------------------------------------------------------------

Win386_Msg:                             ; ...
                push    ds
                mov     ds, cs:DosDSeg
                cmp     al, 3           ; win386 2.xx instance data call?
                jnz     short Win386_Msg_exit
                jmp     OldWin386Init   ; yes, return instance data
; ---------------------------------------------------------------------------

Win386_Msg_exit:                        ; ...
                cmp     al, 6           ; Win386_Exit  ; is it an exit call?
                jnz     short Win386_Msg_devcall
                jmp     Win386_Leaving
; ---------------------------------------------------------------------------

Win386_Msg_devcall:                     ; ...
                cmp     al, 7           ; Win386_Devcall ; is it call from DOSMGR?
                jnz     short Win386_Msg_init
                jmp     Win386_Query
; ---------------------------------------------------------------------------

Win386_Msg_init:                        ; ...
                cmp     al, 5           ; Win386_Init ; is it an init call?
                jz      short Win386_Starting
                jmp     win_nexti2f
; ---------------------------------------------------------------------------

Win386_Starting:                        ; ...
                push    ax
                push    cx
                push    di
                push    es
                push    ds
                pop     es
                mov     di, offset INBUF
                mov     cx, 5
                cld

Win386_s_floop:                         ; ...
                mov     ax, 'OC'        ; 4F43h ('CO' in NASM syntax)
                stosw
                mov     ax, ' N'        ; 204Eh ('N ' in NASM syntax)
                stosw
                add     di, 55
                loop    Win386_s_floop
                pop     es
                pop     di
                pop     cx
                pop     ax
                test    dx, 1           ; is this really win386?
                jz      short Win386_vchk ; yes
                jmp     win_nexti2f     ; win 286 dos extender
; ---------------------------------------------------------------------------

Win386_vchk:                            ; ...
                mov     word ptr ds:Win386_Inf_Virt_Dev_Ptr, 0
                mov     word ptr ds:Win386_Inf_Virt_Dev_Ptr+2, 0
                cmp     di, 400h        ; version >= 400
                jnb     short jmp_to_noVxD31

Win386_vxd:
                push    ax
                push    bx
                push    cx
                push    dx
                push    si
                mov     bx, ds:UMB_HEAD
                push    di
                cmp     bx, 0FFFFh
                jz      short Vxd31
                mov     ds:UmbSaveFlag, 1
                push    ds
                push    es
                push    ds
                pop     es
                mov     ds, bx
                xor     si, si
                clc                     ; not necessary (XOR already clears CF)

restore_ubmhead:                        ; ...
                cld                     ; !! PCDOS 7.1 bug !!
                                        ; jump from 'Win386_Leaving' here was/is wrong
                                        ; (DI and SI would be reversed for 'Win386_Leaving')
                                        ; Erdogan Tan - 05/01/2024
                mov     di, offset UmbSave1
                mov     cx, 11
                rep movsb
                mov     di, offset UmbSave2
                mov     cl, 5
                rep movsb
                jnb     short restore_ubmhead_c ; (not jumped from 'Win386_Leaving')
                jmp     restore_ubmhead_ok ; (jumped from 'Win386_Leaving' just after 'stc')
; ---------------------------------------------------------------------------

restore_ubmhead_c:                      ; ...
                pop     es
                pop     ds

Vxd31:                                  ; ...
                test    ds:DOS_FLAG, 2  ; SUPPRESS_WINA20
                jz      short Dont_Supress
                pop     di
                pop     si
                pop     dx
                pop     cx
                pop     bx
                pop     ax

jmp_to_noVxD31:                         ; ...
                jmp     short noVxD31
; ---------------------------------------------------------------------------

Dont_Supress:                           ; ...
                mov     al, ds:BOOTDRIVE
                add     al, 40h ; '@'   ; 'A'-1
                mov     byte ptr ds:VxDpath, al ; "c:\\wina20.386"
                mov     ax, 6C00h       ; ExtOpen<<8
                mov     bx, 2080h       ; read access, compatibility mode
                                        ; no inherit, suppress crit err
                mov     cx, 7           ; hidden,system,read-only attr
                cwd
                inc     dx              ; dx bit 0 = 1 ; fail if file does not exist
                mov     si, offset VxDpath ; "c:\\wina20.386"
                mov     di, 0FFFFh
                int     21h             ; DOS - 4.0 - EXTENDED OPEN/CREATE
                                        ; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
                                        ; BH = flags, CX = create attribute, DL = action if file exists/does not exists
                                        ; DH = 00h (reserved), DS:SI -> ASCIZ file name
                pop     di
                pop     si
                pop     dx
                pop     cx
                jnb     short VxDthere  ; we found the VxD, go ahead
                push    dx
                push    ds
                push    si
                mov     si, offset NoVxDErrMsg ; "You must have the file WINA20.386 in th"...
                push    cs
                pop     ds
                assume ds:DOSCODE
                mov     cx, 99          ; VxDMesLen
                mov     ah, 2           ; write char to console
                cld

vxdlp:                                  ; ...
                lodsb
                xchg    dl, al
                int     21h             ; DOS - DISPLAY OUTPUT
                                        ; DL = character to send to standard output
                loop    vxdlp
                pop     si
                pop     ds
                assume ds:nothing
                pop     dx
                pop     bx
                pop     ax
                inc     cx
                jmp     short jmp_to_win_nexti2f
; ---------------------------------------------------------------------------

VxDthere:                               ; ...
                mov     bx, ax
                mov     ah, 3Eh
                int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
                                        ; BX = file handle
                mov     bx, offset Win386_Info
                mov     word ptr [bx+6], offset VxDpath ; "c:\\wina20.386"
                mov     word ptr [bx+8], ds
                pop     bx
                pop     ax

noVxD31:                                ; ...
                or      ds:IsWin386, 1
                or      ds:redir_patch, 1
                push    dx
                mov     dx, bx
                mov     bx, offset Win386_Info
                mov     [bx+2], dx
                mov     word ptr [bx+4], es
                pop     dx
                push    ds
                pop     es

jmp_to_win_nexti2f:                     ; ...
                jmp     win_nexti2f
; ---------------------------------------------------------------------------

Win386_Leaving:                         ; ...
                test    dx, 1           ; is this really win386?
                jnz     short jmp_to_win_nexti2f ; NO! It's win 286 dos extender!

Win386_Leaving_c:                       ; was umb_arena saved at win start up ?
                cmp     ds:UmbSaveFlag, 1
                jnz     short noumb     ; not saved
                mov     ds:UmbSaveFlag, 0 ; clear UmbSaveFlag
                                        ; and restore previously saved umb_head
                push    ax
                push    es
                push    cx
                push    si
                push    di
                mov     es, ds:UMB_HEAD
                assume es:nothing
                xor     di, di
                stc                     ; CF=1 is a sign to jump 'restore_ubmhead_ok' address
                                        ; from -the common code at- 'restore_ubmhead' address
                                        ; (.. but this is a BUG!)
                                        ; ;
                jmp     restore_ubmhead ; !! PCDOS 7.1 bug !!
                                        ; (jumped code does not restore umbhead,
                                        ; MSDOS 6.22 code was correct, modification is wrong)
                                        ; Erdogan Tan - 05/01/2024
                                        ;
                                        ; Correct code here, would be:
                                        ;    cld
                                        ;    mov  si,UmbSave1
                                        ;    mov  cx,11
                                        ;    rep  movsb
                                        ;    mov  si,UmbSave2
                                        ;    mov  cl,5
                                        ;    rep  movsb
; ---------------------------------------------------------------------------

restore_ubmhead_ok:                     ; ...
                pop     di
                pop     si
                pop     cx
                pop     es
                assume es:nothing
                pop     ax

noumb:                                  ; ...
                and     ds:IsWin386, 0FEh
                and     ds:redir_patch, 0
                jmp     short win_nexti2f
; ---------------------------------------------------------------------------

Win386_Query:                           ; ...
                cmp     bx, 15h         ; Win386_DOSMGR ; is this from DOSMGR?
                jnz     short win_nexti2f ; no, ignore it & chain to next
                or      cx, cx          ; is it an instance query?
                jnz     short dosmgr_func ; no, some DOSMGR query
                inc     cx              ; indicate that data is instanced
                mov     bx, offset Win386_DOSVars
                push    ds
                pop     es              ; es:bx points at offset table
                jmp     short PopIret
; ---------------------------------------------------------------------------

OldWin386Init:                          ; ...
                pop     ax
                mov     si, offset OldInstanceJunk ; ds:si = instance table
                mov     ax, 5248h       ; 'HR' ; indicate instance data present
                jmp     short win_nexti2f2
; ---------------------------------------------------------------------------

dosmgr_func:                            ; ...
                dec     cx
                jz      short win386_patch ; call to patch DOS
                dec     cx
                jz      short PopIret   ; remove DOS patches, ignore
                dec     cx
                jz      short win386_size ; get size of DOS data structures
                dec     cx
                jz      short jmp_to_win386_inst ; instance more data
                loop    PopIret         ; no functions above this
                mov     ax, es          ; Get DOS device driver size
                                        ; ax = device header segment
                dec     ax              ; get arena header
                push    es
                mov     es, ax          ; arena header for device driver
                assume es:nothing
                cmp     byte ptr es:[di], 44h ; 'D' ; is it a device arena?
                jnz     short cantsize  ; no
                inc     ax              ; get back device header segment
                cmp     es:[di+1], ax   ; owner field pointing at driver?
                jnz     short cantsize  ; no
                mov     ax, es:[di+3]   ; get arena size in paragraphs
                pop     es
                assume es:nothing
                mov     bx, 16
                mul     bx
                mov     cx, ax
                mov     bx, dx
                jmp     short win386_done ; return with device driver size
; ---------------------------------------------------------------------------

cantsize:                               ; ...
                pop     es
                xor     ax, ax

win386_inst:                            ; ...
                xor     dx, dx          ; ask DOSMGR to use its methods
                jmp     short PopIret
; ---------------------------------------------------------------------------

win386_patch:                           ; ...
                mov     bx, dx          ; move patch bitfield to bx
                jmp     short win386_done ; done, return
; ---------------------------------------------------------------------------

win386_size:                            ; ...
                test    dl, 1           ; check for CDS size bit
                jz      short PopIret   ; no, unknown structure -- return
                mov     cl, 88          ; cx = CDS size
                jmp     short win386_done ; return with the size
; ---------------------------------------------------------------------------

jmp_to_win386_inst:                     ; ...
                jmp     short win386_inst
; ---------------------------------------------------------------------------

win386_done:                            ; ...
                mov     ax, 0B97Ch      ; WIN_OP_DONE
                mov     dx, 0A2ABh      ; DOSMGR_OP_DONE

PopIret:                                ; ...
                pop     ds
                iret
; ---------------------------------------------------------------------------

win_nexti2f:                            ; ...
                pop     ds

win_nexti2f2:                           ; ...
                jmp     next_i2f

; =============== S U B R O U T I N E =======================================


getwinlast      proc near               ; ...
                mov     si, ds:CurrentPDB
                dec     si
                mov     es, si
                add     si, es:3
                retn
getwinlast      endp

; ---------------------------------------------------------------------------

Winold_swap:                            ; ...
                push    ds
                push    es
                push    si
                push    di
                push    cx
                mov     ds, cs:DosDSeg
                cmp     al, 1           ; swap Windows out call
                jnz     short swapin    ; no, check if Swap in call
                call    getwinlast
                push    ds
                pop     es
                mov     ds, si          ; ds = memory arena of Windows
                xor     si, si
                mov     di, offset WinoldPatch1
                mov     cx, 8
                cld
                rep movsb               ; save first 8 bytes
                mov     cl, 8
                mov     di, offset WinoldPatch2
                rep movsb               ; save next 8 bytes
                jmp     short winold_done
; ---------------------------------------------------------------------------

swapin:                                 ; ...
                cmp     al, 2           ; swap Windows in call?
                jnz     short winold_done ; no, something else, pass it on
                call    getwinlast
                mov     es, si
                xor     di, di
                mov     si, offset WinoldPatch1
                mov     cx, 8
                cld
                rep movsb               ; restore first 8 bytes
                mov     cl, 8
                mov     si, offset WinoldPatch2
                rep movsb               ; restore next 8 bytes

winold_done:                            ; ...
                pop     cx
                pop     di
                pop     si
                pop     es
                pop     ds
                jmp     next_i2f        ; chain on
; ---------------------------------------------------------------------------

int_2Fh_1231h:                          ; ...
                push    ds              ; Windows95 - SET/CLEAR "REPORT WINDOWS TO DOS PROGRAMS" FLAG
                mov     ds, cs:DosDSeg
                xor     ax, ax
                or      dl, dl
                jnz     short not_1231_dl_0
                mov     ds:IsWin386+1, 1 ; set byte after "IsWIN386" to 01h
                jmp     short int_2f_1231h_retn
; ---------------------------------------------------------------------------
                nop

not_1231_dl_0:                          ; ...
                cmp     dl, 1
                jnz     short not_1231_dl_1 ; clear "IsWIN386" bit 1
                or      ds:IsWin386, 2  ; set "IsWIN386" bit 1
                jmp     short int_2f_1231h_retn
; ---------------------------------------------------------------------------
                nop

not_1231_dl_1:                          ; ...
                cmp     dl, 2
                jnz     short not_1231_dl_2
                and     ds:IsWin386, 0FDh ; clear bit 1
                jmp     short int_2f_1231h_retn
; ---------------------------------------------------------------------------

not_1231_dl_2:                          ; ...
                inc     ax              ; return error, ax = 1
                stc

int_2f_1231h_retn:                      ; ...
                pop     ds
                retn
; ---------------------------------------------------------------------------

DispatchDOS:                            ; ...
                push    cs:FOO          ; push return address
                push    cs:DTab         ; push table address
                push    ax              ; push index
                push    bp
                mov     bp, sp          ; stack looks like:
                                        ;  0  BP
                                        ;  2  DISPATCH
                                        ;  4  TABLE
                                        ;  6  RETURN
                                        ;  8  LONG-RETURN
                                        ;  C  FLAGS
                                        ;  E  AX
                mov     ax, [bp+14]     ; get AX value
                pop     bp
                call    TableDispatch
                jmp     BadFunc         ; return indicates invalid function
; ---------------------------------------------------------------------------

DOSGetGroup:                            ; ...
                mov     ds, cs:DosDSeg
                retn
; ---------------------------------------------------------------------------

DOSInstall:                             ; ...
                mov     al, 0FFh
                retn

; =============== S U B R O U T I N E =======================================


RW32_CONVERT    proc near               ; ...
                inc     cx              ; -1 -> 0
                jz      short new32format
                dec     cx
                cmp     word ptr es:[bp+0Fh], 0 ; [es:bp+DPB.FAT_SIZE]
                jz      short rw32_conv_err ; FAT32 fs
                push    ax
                push    dx
                mov     dl, es:[bp+4]   ; [es:bp+DPB.CLUSTER_MASK]
                mov     ax, es:[bp+0Dh] ; [es:bp+DPB.MAX_CLUSTER]
                cmp     dl, 0FEh        ; 254 ; Sectors/cluster - 1
                jz      short letold    ; removable
                inc     dl
                xor     dh, dh
                mul     dx
                or      dx, dx          ; > 32mb ?

letold:                                 ; ...
                pop     dx
                pop     ax
                jz      short old_style ; no

rw32_conv_err:                          ; ...
                stc
                retn
; ---------------------------------------------------------------------------

new32format:                            ; ...
                mov     dx, [bx+2]      ; [BX+ABS_32RW.SECTOR_RBA+2]
                push    ds
                mov     ds, cs:DosDSeg  ; set up ds to DOSDATA
                mov     ds:HIGH_SECTOR, dx
                pop     ds
                mov     dx, [bx]        ; [BX+ABS_32RW.SECTOR_RBA]
                mov     cx, [bx+4]      ; [BX+ABS_32RW.ABS_RW_COUNT]
                lds     bx, [bx+6]      ; [BX+ABS_32RW.BUFFER_ADDR]

old_style:                              ; ...
                clc
                retn
RW32_CONVERT    endp


; =============== S U B R O U T I N E =======================================


Fastxxx_Purge   proc near               ; ...
                push    ax
                push    si
                push    dx
                push    ds
                mov     ds, cs:DosDSeg
                test    ds:FastOpenFlg, 80h ; Fast_yes ; fastopen installed ?
                pop     ds
                jz      short nofast    ; no
                mov     ah, 1           ; FastOpen_ID
                mov     al, 5           ; FONC_purge
                mov     dl, es:[bp+0]   ; set up drive number
                call    Fast_Dispatch   ; call fastopen/seek

nofast:                                 ; ...
                pop     dx
                pop     si
                pop     ax
                retn
Fastxxx_Purge   endp

; ---------------------------------------------------------------------------
DIVMES          db 0Dh,0Ah              ; ...
                db 'Divide overflow',0Dh,0Ah
DivMesLen       dw 19                   ; ...
NoVxDErrMsg     db 'You must have the file WINA20.386 in the root of your boot drive',0Dh ; ...
                db 0Ah
                db 'to run Windows in Enhanced Mode',0Dh,0Ah
CANCHAR         db 1Bh                  ; ...
                                        ; CANCEL ; Cancel line character
ESCCHAR         db 0                    ; ...
                                        ; ESCCH ; Lead-in character for escape sequences
ESCTAB          db 40h                  ; ...
                                        ; Ctrl-Z - F6
                db 4Dh                  ; Copy one char - -->
                db 3Bh                  ; Copy one char - F1
                db 53h                  ; Skip one char - DEL
                db 3Ch                  ; Copy to char - F2
                db 3Eh                  ; Skip to char - F4
                db 3Dh                  ; Copy line - F3
                db 3Dh                  ; Kill line (no change to template ) - Not used
                db 3Fh                  ; Reedit line (new template) - F5
                db 4Bh                  ; Backspace - <--
                db 52h                  ; Enter insert mode - INS (toggle)
                db 52h                  ; Exit insert mode - INS (toggle)
                db 41h                  ; Escape character - F7
                db 41h                  ; End of table
ESCFUNC         dw offset GETCH         ; ...
                                        ; Ignore the escape sequence
                dw offset TWOESC
                dw offset EXITINS
                dw offset EXITINS       ; ENTERINS
                dw offset BACKSP
                dw offset REEDIT
                dw offset KILNEW
                dw offset COPYLIN
                dw offset SKIPSTR
                dw offset COPYSTR
                dw offset SKIPONE
                dw offset COPYONE
                dw offset COPYONE
                dw offset CTRLZ
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR FINDOLD

OEMFunctionKey:                         ; ...
                call    $STD_CON_INPUT_NO_ECHO
                mov     cl, 14          ; ESCTABLEN
                push    di
                mov     di, offset ESCTAB
                push    es
                push    cs
                pop     es
                assume es:DOSCODE
                repne scasb
                pop     es
                assume es:nothing
                pop     di
                shl     cx, 1
                mov     bp, cx
                jmp     cs:ESCFUNC[bp]
; END OF FUNCTION CHUNK FOR FINDOLD

; =============== S U B R O U T I N E =======================================


$GET_DATE       proc near               ; ...
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    READTIME
                mov     ax, YEAR
                mov     bx, word ptr DAY
                call    Get_User_Stack
                mov     [si+6], bx      ; [SI+user_env.user_DX]
                add     ax, 1980
                mov     [si+4], ax      ; [SI+user_env.user_CX]
                mov     al, ss:WEEKDAY

_RET24:                                 ; ...
                retn
$GET_DATE       endp


; =============== S U B R O U T I N E =======================================


$SET_DATE       proc near               ; ...
                mov     al, 0FFh        ; -1
                sub     cx, 1980        ; Fix bias in year
                jb      short _RET24    ; Error if not big enough
                cmp     cx, 119         ; Year must be less than 2100
                ja      short RET24
                or      dh, dh
                jz      short _RET24
                or      dl, dl
                jz      short _RET24    ; Error if either month or day is 0
                cmp     dh, 12          ; Check against max. month
                ja      short RET24
                push    ss
                pop     ds
                call    DODATE

RET24:                                  ; ...
                retn
$SET_DATE       endp


; =============== S U B R O U T I N E =======================================


$GET_TIME       proc near               ; ...
                push    ss
                pop     ds
                call    READTIME
                call    Get_User_Stack  ; Get pointer to user registers
                mov     [si+6], dx      ; [SI+user_env.user_DX]
                mov     [si+4], cx      ; [SI+user_env.user_CX]

set_time_ok:                            ; ...
                xor     al, al

RET26:                                  ; ...
                retn
$GET_TIME       endp


; =============== S U B R O U T I N E =======================================


$SET_TIME       proc near               ; ...
                mov     al, 0FFh        ; Flag in case of error
                cmp     ch, 24          ; Check hours
                jnb     short RET26
                cmp     cl, 60          ; Check minutes
                jnb     short RET26
                cmp     dh, 60          ; Check seconds
                jnb     short RET26
                cmp     dl, 100         ; Check 1/100's
                jnb     short RET26
                push    cx
                push    dx
                push    ss
                pop     ds
                mov     bx, offset TIMEBUF
                mov     cx, 6
                xor     ax, ax
                cwd
                push    bx
                call    SETREAD
                push    ds
                lds     si, BCLOCK
                assume ds:nothing
                call    DEVIOCALL2      ; Get correct day count
                pop     ds
                pop     bx
                call    SETWRITE
                pop     ds:TIMEBUF+4
                pop     ds:TIMEBUF+2
                lds     si, ds:BCLOCK
                call    DEVIOCALL2      ; Set the time
                jmp     short set_time_ok
$SET_TIME       endp


; =============== S U B R O U T I N E =======================================


DATE16          proc near               ; ...
                mov     ds, cs:DosDSeg
                push    cx
                push    es
                call    READTIME
                pop     es
                add     cl, cl
                add     cl, cl
                add     cx, cx
                add     cx, cx
                add     cx, cx
                shr     dh, 1
                or      cl, dh
                mov     dx, cx
                mov     ax, word ptr ds:MONTH
                mov     cl, 4
                shl     al, cl
                add     ax, ax
                pop     cx
                or      al, ds:DAY

RET21:                                  ; ...
                retn
DATE16          endp


; =============== S U B R O U T I N E =======================================


READTIME        proc near               ; ...
                mov     ds:DATE_FLAG, 0 ; reset date flag for CPMIO
                push    si
                push    bx
                mov     bx, offset TIMEBUF
                mov     cx, 6
                xor     ax, ax
                cwd
                call    SETREAD
                push    ds
                lds     si, ds:BCLOCK
                call    DEVIOCALL2      ; Get correct date and time
                pop     ds
                pop     bx
                pop     si
                mov     ax, ds:TIMEBUF
                mov     cx, ds:TIMEBUF+2
                mov     dx, ds:TIMEBUF+4
                cmp     ax, ds:DAYCNT   ; See if day count is the same
                jz      short RET21
                cmp     ax, 43830       ; FOURYEARS*30 ; Number of days in 120 years
                jnb     short RET22     ; Ignore if too large
                mov     ds:DAYCNT, ax
                push    si
                push    cx
                push    dx
                xor     dx, dx
                mov     cx, 1461        ; FOURYEARS ; Number of days in 4 years
                div     cx
                add     ax, ax
                add     ax, ax
                add     ax, ax          ; Multiply by 8 (no. of half-years)
                mov     cx, ax          ; <240 implies AH=0
                mov     si, offset YRTAB ; Table of days in each year
                call    DSLIDE          ; Find out which of four years we're in
                shr     cx, 1           ; Convert half-years to whole years
                jnb     short SK        ; Extra half-year?
                add     dx, 200

SK:                                     ; ...
                call    SETYEAR
                mov     cl, 1           ; At least at first month in year
                mov     si, offset MONTAB ; Table of days in each month
                call    DSLIDE          ; Find out which month we're in
                mov     ds:MONTH, cl
                inc     dx              ; Remainder is day of month (start with one)
                mov     ds:DAY, dl
                call    WKDAY           ; Set day of week
                pop     dx
                pop     cx
                pop     si

RET22:                                  ; ...
                retn
READTIME        endp


; =============== S U B R O U T I N E =======================================


DSLIDE          proc near               ; ...
                mov     ah, 0           ; (AH is already ZERO here!) 6/1/2024

DSLIDE1:                                ; ...
                lodsb                   ; Get count of days
                cmp     dx, ax          ; See if it will fit
                jb      short RET22
                sub     dx, ax
                inc     cx              ; Count one more month/year
                jmp     short DSLIDE1
DSLIDE          endp


; =============== S U B R O U T I N E =======================================


SETYEAR         proc near               ; ...
                mov     ds, cs:DosDSeg
                mov     byte ptr ds:YEAR, cl

CHKYR:                                  ; ...
                test    cl, 3           ; Check for leap year
                mov     al, 28          ; 28 days if no leap year
                jnz     short SAVFEB
                inc     al              ; Add leap day

SAVFEB:                                 ; ...
                mov     ds:february, al ; [MONTAB+1],AL ; Store for February

RET23:                                  ; ...
                retn
SETYEAR         endp


; =============== S U B R O U T I N E =======================================


DODATE          proc near               ; ...
                call    CHKYR           ; Set Feb. up for new year
                mov     al, dh
                mov     bx, (offset YRTAB+7) ; MONTAB-1
                xlat                    ; Look up days in month
                cmp     al, dl
                mov     al, 0FFh        ; -1
                jb      short RET23     ; Error if too many days
                call    SETYEAR
                mov     word ptr ds:DAY, dx ; Set both day and month
                shr     cx, 1
                shr     cx, 1
                mov     ax, 1461        ; FOURYEARS
                mov     bx, dx
                mul     cx
                mov     cl, byte ptr ds:YEAR
                and     cl, 3
                mov     si, offset YRTAB
                mov     dx, ax
                add     cx, cx          ; Two entries per year, so double count
                call    DSUM            ; Add up the days in each year
                mov     cl, bh          ; Month of year
                mov     si, offset MONTAB
                dec     cx              ; Account for months starting with one
                call    DSUM            ; Add up days in each month
                mov     cl, bl          ; Day of month
                dec     cx              ; Account for days starting with one
                add     dx, cx          ; Add in to day total
                xchg    ax, dx          ; Get day count in AX
                mov     ds:DAYCNT, ax
                push    si
                push    bx
                push    ax
                mov     bx, offset TIMEBUF
                mov     cx, 6
                xor     ax, ax
                cwd
                push    bx
                call    SETREAD
                push    ds
                lds     si, ds:BCLOCK
                call    DEVIOCALL2      ; Get correct date and time
                pop     ds
                pop     bx
                call    SETWRITE
                pop     ds:TIMEBUF
                push    ds
                lds     si, ds:BCLOCK
                call    DEVIOCALL2      ; Set the date
                pop     ds
                pop     bx
                pop     si

WKDAY:                                  ; ...
                mov     ax, ds:DAYCNT
                xor     dx, dx
                mov     cx, 7
                inc     ax
                inc     ax              ; First day was Tuesday
                div     cx              ; Compute day of week
                mov     ds:WEEKDAY, dl
                xor     al, al          ; Flag OK
                retn
DODATE          endp


; =============== S U B R O U T I N E =======================================


DSUM            proc near               ; ...
                mov     ah, 0
                jcxz    short DSUM9

DSUM1:                                  ; ...
                lodsb
                add     dx, ax
                loop    DSUM1

DSUM9:                                  ; ...
                retn
DSUM            endp


; =============== S U B R O U T I N E =======================================


$GET_VERSION    proc near               ; ...
                lds     cx, ss:USERNUM
                mov     bx, ds
                push    ss
                pop     ds
                assume ds:DOSCODE
                cmp     al, 1
                jnz     short Norm_Vers
                xor     bh, bh          ; return 0 (not ROMDOS version)

Norm_Vers:                              ; ...
                mov     ds, CurrentPDB  ; Get the version number from the
                                        ; current app's PSP segment
                assume ds:nothing
                mov     ax, word ptr ds:40h ; [PDB.Version]
                                        ; AX = DOS version number
                call    Get_User_Stack

gdrvfspc_ret:                           ; ...
                mov     [si], ax        ; [SI+user_env.user_AX]
                mov     [si+4], cx      ; [SI+user_env.user_CX]

set_user_bx:                            ; ...
                mov     [si+2], bx      ; [SI+user_env.user_BX]
                retn
$GET_VERSION    endp

; ---------------------------------------------------------------------------

$GET_VERIFY_ON_WRITE:                   ; ...
                mov     al, ss:VDERFLG
                retn
; ---------------------------------------------------------------------------

$SET_VERIFY_ON_WRITE:                   ; ...
                and     al, 1
                mov     ss:VDERFLG, al

RET27:                                  ; ...
                retn

; =============== S U B R O U T I N E =======================================


$INTERNATIONAL  proc near               ; ...

; FUNCTION CHUNK AT 4BE2 SIZE 0000002E BYTES

                cmp     al, 0FFh        ; -1 means country code is in BX
                jz      short BX_HAS_CODE
                mov     bl, al          ; Put AL country code in BX
                xor     bh, bh

BX_HAS_CODE:                            ; ...
                push    ds
                pop     es
                push    dx
                pop     di              ; User buffer to ES:DI
                push    ss
                pop     ds
                assume ds:DOSCODE
                cmp     di, 0FFFFh      ; -1
                jz      short international_set
                or      bx, bx
                jnz     short international_find
                mov     si, offset COUNTRY_CDPG
                jmp     short international_copy
; ---------------------------------------------------------------------------

international_find:                     ; ...
                xor     bp, bp          ; 0 ; flag it for GetCntry only
                call    international_get
                jb      short errtn
                or      bx, bx          ; nlsfunc finished it ?
                jnz     short international_copy ; no, copy by myself
                mov     bx, dx          ; put country back
                jmp     short international_ok3
$INTERNATIONAL  endp


; =============== S U B R O U T I N E =======================================


international_get proc near             ; ...
                mov     si, offset COUNTRY_CDPG
                cmp     bx, ss:[si+68h] ; [SI+DOS_CCDPG.ccDosCountry]
                jz      short RET27     ; = current country id
                mov     dx, bx
                xor     bx, bx          ; bx = 0, default code page
                mov     ax, 1400h
                int     2Fh             ; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
                                        ; Return: AL = 00h not installed, OK to install
                                        ; 01h not installed, not OK
                                        ; FFh installed
                cmp     al, 0FFh        ; not in memory
                jnz     short interr
                mov     ax, 1403h       ; set country info
                or      bp, bp          ; GetCntry ?
                jnz     short stcdpg
                inc     ax              ; AX = 1404h ; get country info

stcdpg:                                 ; ...
                int     2Fh             ; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
                                        ; BX = code page, DX = country code, DS:SI -> internal code page structure
                                        ; ES:DI -> user buffer
                                        ; Return: AL = status
                or      al, al
                jz      short RET27

setcarry:                               ; ...
                stc
                retn
; ---------------------------------------------------------------------------

interr:                                 ; ...
                mov     al, 0FFh
                jmp     short setcarry
international_get endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR $INTERNATIONAL

international_copy:                     ; ...
                mov     bx, ss:[si+68h] ; [ss:SI+DOS_CCDPG.ccDosCountry]
                mov     si, offset COUNTRY_CDPG_108 ; COUNTRY_CDPG+DOS_CCDPG.ccDFormat
                mov     cx, 12          ; OLD_COUNTRY_SIZE/2
                push    ds
                push    ss
                pop     ds
                rep movsw
                pop     ds
                assume ds:nothing

international_ok3:                      ; ...
                call    Get_User_Stack
                call    set_user_bx     ; MOV [SI+user_env.user_BX],BX

international_ok:                       ; ...
                mov     ax, bx
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

international_set:                      ; ...
                mov     bp, 1
                call    international_get
                jnb     short international_ok

errtn:                                  ; ...
                cmp     al, 0FFh
                jz      short errtn2

errtn1:                                 ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

errtn2:                                 ; ...
                mov     al, 1           ; error_invalid_function
                jmp     short errtn1    ; NLSFUNC not existent
; END OF FUNCTION CHUNK FOR $INTERNATIONAL
; ---------------------------------------------------------------------------

$ExtCountryInfo:                        ; ...
                cmp     al, 2           ; INT 21h, AH = 70h (06/01/2024 - Erdogan Tan)
                                        ; GET/SET INTERNATIONALIZATION INFORMATION
                                        ; ****
                                        ; AL = subfunction
                                        ; 00h SET general internationalization info
                                        ;     CX = buffer size (up to 38 bytes)
                                        ;     DS:SI -> buffer containing internationalization info
                                        ;  first three bytes are skipped, the rest is copied to somewhere
                                        ;  in the DOS data segment
                                        ; 01h SET extended internationalization info
                                        ;     CX = number of bytes to set (up to 58 bytes)
                                        ;     DS:SI -> buffer containing internationalization info
                                        ; 02h GET extended internationalization info
                                        ;     CX = buffer size in bytes (up to 58 bytes used)
                                        ;     ES:DI -> buffer
                                        ; ****
                                        ; (Ref: Ralf Brown's Interrupt List) - had some mistakes -
                ja      short errtn2
                push    es
                push    ss
                jnz     short ext_cntry_inf_1
                pop     es              ; AX = GET 35 bytes info (from offset 3 to 37)
                                        ; (38 bytes buffer is used)
                mov     di, offset _COUNTRY_ID
                mov     ax, es:[di-2]   ; NEW_COUNTRY_SIZE = 38
                mov     bx, 3           ; skip the 1st 3 bytes of the buffer
                add     si, bx
                jmp     short ext_cntry_inf_4
; ---------------------------------------------------------------------------

ext_cntry_inf_1:                        ; ...
                dec     al
                jnz     short ext_cntry_inf_2 ; AX = 2
                pop     es              ; AX = 1 (set)
                mov     di, offset _ENU ; "ENU"
                jmp     short ext_cntry_inf_3
; ---------------------------------------------------------------------------

ext_cntry_inf_2:                        ; ...
                pop     ds              ; AX = 2 (get)
                mov     si, offset _ENU ; "ENU"

ext_cntry_inf_3:                        ; ...
                xor     bx, bx          ; 0
                mov     ax, 58          ; 3Ah

ext_cntry_inf_4:                        ; ...
                cmp     cx, ax          ; > 38 ? (58)
                jb      short ext_cntry_inf_5 ; no
                mov     cx, ax          ; yes, decrease size to 38 (58)

ext_cntry_inf_5:                        ; ...
                mov     ax, cx          ; buffer (filled) size
                sub     cx, bx          ; copy byte count
                rep movsb
                pop     es
                jmp     ret_ax_to_user_cx ; ax -> user's cx

; =============== S U B R O U T I N E =======================================


$GetExtCntry    proc near               ; ...
                cmp     al, 20h         ; CAP_ONE_CHAR  ; < 20h
                jb      short notcap
                test    al, 80h         ; UPPER_TABLE
                jnz     short fileupper ; file upper case
                mov     bx, offset UCASE_TAB_2 ; UCASE_TAB+2
                                        ; get normal upper case
                jmp     short capit
; ---------------------------------------------------------------------------

fileupper:                              ; ...
                and     al, 7Fh
                mov     bx, offset FILE_UCASE_TAB_2 ; FILE_UCASE_TAB+2
                                        ; get file upper case

capit:                                  ; ...
                cmp     al, 20h         ; CAP_ONE_CHAR ; cap one char ?
                jnz     short chkyes
                mov     al, dl          ; set up AL
                call    GETLET3         ; upper case it
                call    Get_User_Stack  ; get user stack
                mov     [si+6], al      ; [SI+user_env.user_DX]
                jmp     short nono      ; done
; ---------------------------------------------------------------------------

chkyes:                                 ; ...
                cmp     al, 23h         ; CHECK_YES_NO
                jnz     short capstring ; no
                                        ; Yes/No
                xor     ax, ax          ; presume NO
                cmp     dl, ss:NLS_YES
                jz      short yesyes    ; Y(ES)
                cmp     dl, ss:NLS_yes2
                jz      short yesyes    ; y(es)
                cmp     dl, ss:NLS_NO
                jz      short nono      ; N(O)
                cmp     dl, ss:NLS_no2
                jz      short nono      ; n(o)
                inc     ax              ; not YES or NO

yesyes:                                 ; ...
                inc     ax              ; YES = 1

nono:                                   ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

capstring:                              ; ...
                mov     si, dx
                cmp     al, 21h         ; CAP_STRING
                jnz     short capascii
                jcxz    short nono

concap:                                 ; ...
                lodsb                   ; get char
                call    GETLET3         ; upper case it
                mov     [si-1], al      ; store back
                loop    concap          ; continue
                jmp     short nono      ; done
; ---------------------------------------------------------------------------

capascii:                               ; ...
                cmp     al, 22h         ; CAP_ASCIIZ
                jnz     short capinval

concap2:                                ; ...
                lodsb                   ; get char
                or      al, al          ; end of string ?
                jz      short nono      ; yes
                call    GETLET3         ; upper case it
                mov     [si-1], al      ; store back
                jmp     short concap2   ; continue
; ---------------------------------------------------------------------------

notcap:                                 ; ...
                cmp     cx, 5           ; minimum size is 5
                jb      short capinval  ; sizeerror

GEC_CONT:
                push    ss
                pop     ds
                assume ds:DOSCODE
                mov     si, offset COUNTRY_CDPG
                or      al, al
                jnz     short GETCNTRY  ;
                                        ; AL = 0 (INT 21h, AX=6500h)
                                        ; Set extended country-dependent information
                                        ; (SET GENERAL INTERNATIONALIZATION INFO)
                sub     cx, 7           ; minimum 8 bytes
                jbe     short capinval  ; error_invalid_function
                mov     bx, [si+48h]    ; [SI+DOS_CCDPG.ccSysCodePage]
                lea     si, [si+66h]    ; SI+DOS_CCDPG.ccCountryInfoLen
                mov     ax, [si]
                sub     ax, 4
                cmp     cx, ax
                jbe     short set_inter_info
                mov     cx, ax

set_inter_info:                         ; ...
                mov     ax, cx
                add     ax, 4
                mov     es:[di+1], ax   ; info length/size (will be written)
                add     si, 6           ; DOS_CCDPG.ccDFormat
                add     di, 7           ; points to date format
                call    XCHGP           ; ds:si = user's buffer + 6
                                        ; es:di = country info buffer + 7
                jmp     short OK_RETN
; ---------------------------------------------------------------------------

GETCNTRY:                               ; ...
                cmp     dx, 0FFFFh      ; -1 ; active country ?
                jnz     short GETCDPG
                mov     dx, [si+68h]    ; [SI+DOS_CCDPG.ccDosCountry]

GETCDPG:                                ; ...
                cmp     bx, 0FFFFh      ; -1 ; active code page?
                jnz     short CHKAGAIN
                mov     bx, [si+6Ah]    ; [SI+DOS_CCDPG.ccDosCodePage] ; get active code page

CHKAGAIN:                               ; ...
                cmp     dx, [si+68h]    ; [SI+DOS_CCDPG.ccDosCountry] ; same ?
                jnz     short CHKNLS    ; no
                cmp     bx, [si+6Ah]    ; [SI+DOS_CCDPG.ccDosCodePage] ; same ?
                jnz     short CHKNLS    ; no

CHKTYPE:                                ; yes, same code page and same country id
                mov     bx, [si+48h]    ; [SI+DOS_CCDPG.ccSysCodePage]
                push    cx
                mov     cx, [si+4Ah]    ; [SI+DOS_CCDPG.ccNumber_of_entries]
                mov     si, offset COUNTRY_CDPG_76 ; COUNTRY_CDPG+DOS_CCDPG.ccSetUcase

NXTENTRY:                               ; ...
                cmp     al, [si]        ; compare info type
                jz      short FOUNDIT
                add     si, 5           ; next entry
                loop    NXTENTRY
                pop     cx

capinval:                               ; ...
                jmp     errtn2          ; error_invalid_function
; ---------------------------------------------------------------------------

FOUNDIT:                                ; ...
                movsb                   ; move info id byte
                pop     cx              ; restore char count
                cmp     al, 1           ; SetCountryInfo ; select country info type ?
                jz      short setsize   ; yes
                mov     cx, 4           ; 4 bytes will be moved
                mov     ax, 5           ; 5 bytes will be returned in CX

OK_RETN:                                ; ...
                rep movsb               ; copy info
                mov     cx, ax          ; CX = actual length returned
                mov     ax, bx          ; return sys code page in ax

GETDONE:                                ; ...
                call    Get_User_Stack  ; return actual length to user's CX
                mov     [si+4], cx      ; [SI+user_env.user_CX]

nono_jmp:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

setsize:                                ; ...
                sub     cx, 3           ; size after length field
                cmp     [si], cx        ; less than table size
                jnb     short setsize2  ; no
                mov     cx, [si]        ; truncate to table size

setsize2:                               ; ...
                mov     es:[di], cx     ; copy actual length to user's buffer
                inc     di              ; update index
                inc     di
                inc     si
                inc     si
                mov     ax, cx
                add     ax, 3           ; AX has the actual length
                jmp     short OK_RETN
; ---------------------------------------------------------------------------

CHKNLS:                                 ; ...
                xor     ah, ah
                mov     bp, ax
                mov     ax, 1400h
                int     2Fh             ; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
                                        ; Return: AL = 00h not installed, OK to install
                                        ; 01h not installed, not OK
                                        ; FFh installed
                cmp     al, 0FFh
                jz      short NLSNXT    ; in memory

sizeerror:                              ; ...
                jmp     short capinval
; ---------------------------------------------------------------------------

NLSNXT:                                 ; ...
                mov     ax, 1402h
                int     2Fh             ; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
                                        ; BP = subfunction, BX = code page
                                        ; DX = country code, DS:SI -> internal code page structure
                                        ; ES:DI -> user buffer, CX = size of user buffer
                                        ; Return: AL = status
                                        ; 00h successful
                                        ; else DOS error code
                cmp     al, 0
                jnz     short NLSERROR
                mov     ax, [si+48h]    ; [SI+DOS_CCDPG.ccSysCodePage]
                jmp     short GETDONE
; ---------------------------------------------------------------------------

NLSERROR:                               ; ...
                jmp     SYS_RET_ERR
$GetExtCntry    endp


; =============== S U B R O U T I N E =======================================


$GetSetCdPg     proc near               ; ...
                push    ss
                pop     ds
                mov     si, offset COUNTRY_CDPG
                cmp     al, 1           ; get global code page
                jnz     short setglpg
                mov     bx, [si+6Ah]    ; [SI+DOS_CCDPG.ccDosCodePage]
                mov     dx, [si+48h]    ; [SI+DOS_CCDPG.ccSysCodePage]
                call    Get_User_Stack
                call    set_user_bx
                mov     [si+6], dx      ; [SI+user_env.user_DX]

OK_RETURN:                              ; ...
                jmp     short nono_jmp
; ---------------------------------------------------------------------------

setglpg:                                ; ...
                cmp     al, 2           ; set global codepage
                jnz     short nomem
                mov     dx, [si+68h]    ; [SI+DOS_CCDPG.ccDosCountry]
                mov     ax, 1400h
                int     2Fh             ; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
                                        ; Return: AL = 00h not installed, OK to install
                                        ; 01h not installed, not OK
                                        ; FFh installed
                cmp     al, 0FFh
                jnz     short nomem
                mov     ax, 1401h
                int     2Fh             ; - Multiplex - NLSFUNC.COM - CHANGE CODE PAGE
                                        ; DS:SI -> internal code page structure
                                        ; BX = new code page, DX = country code???
                                        ; Return: AL = status
                                        ; 00h successful
                                        ; else DOS error code
                or      al, al
                jz      short OK_RETURN
                cmp     al, 65          ; set device code page failed
                jnz     short seterr
                cbw
                mov     EXTERR, ax
                mov     EXTERR_ACTION, 6 ; errACT_Ignore
                mov     EXTERR_CLASS, 5 ; errCLASS_HrdFail
                mov     EXTERR_LOCUS, 4 ; errLOC_SerDev
                jmp     From_GetSet
; ---------------------------------------------------------------------------

seterr:                                 ; ...
                jmp     short NLSERROR  ; transfer SYS_RET_ERR
; ---------------------------------------------------------------------------

nomem:                                  ; ...
                jmp     short sizeerror ; function not defined
$GetSetCdPg     endp

; ---------------------------------------------------------------------------

$GET_DRIVE_FREESPACE:                   ; ...
                push    ss
                pop     ds
                mov     al, dl
                call    GETTHISDRV      ; Get drive
                jb      short BADFDRV   ; User FAILed to I 24
                call    DISK_INFO
                jnb     short gdrvfspc_1
                xchg    dx, bx
                jmp     short BADFDRV
; ---------------------------------------------------------------------------

gdrvfspc_1:                             ; ...
                xor     ah, ah          ; Chuck Fat ID byte
                push    di
                call    TestNet
                pop     di
                jb      short gdrvfspc_2
                call    modify_cluster_count ;
                                        ; if hw of total clusters (di) > 0
                                        ; sectors per cluster and cluster counts
                                        ; will be modified (shifted)
                                        ; (but sectors per clust * clust count will be same)
                                        ; /// disk size -calculation- limit = 2 GB ///

gdrvfspc_2:                             ; ...
                xchg    dx, bx          ; bx = free clusters (after xchg)

DoSt:                                   ; ...
                call    Get_User_Stack
                mov     [si+6], dx      ; [SI+user_env.user_DX] ; total clusters
                jmp     gdrvfspc_ret    ; ax = sectors per cluster (modified)
; ---------------------------------------------------------------------------

BADFDRV:                                ; ...
                call    FCB_RET_ERR
                mov     ax, 0FFFFh      ; -1
                jmp     short DoSt
; ---------------------------------------------------------------------------

$GET_DMA:                               ; ...
                mov     bx, word ptr ss:DMAADD ; Get Disk Transfer Address
                mov     cx, word ptr ss:DMAADD+2
                call    Get_User_Stack
                mov     [si+10h], cx
                jmp     set_user_bx
; ---------------------------------------------------------------------------

$SET_DMA:                               ; ...
                mov     word ptr ss:DMAADD, dx ; Set Disk Transfer Address
                mov     word ptr ss:DMAADD+2, ds
                retn
; ---------------------------------------------------------------------------

$GET_DEFAULT_DRIVE:                     ; ...
                mov     al, ss:CURDRV
                retn
; ---------------------------------------------------------------------------

$SET_DEFAULT_DRIVE:                     ; ...
                mov     al, dl
                inc     al              ; A=1, B=2...
                call    GetVisDrv       ; see if visible drive
                jb      short SETRET    ; errors do not set
                mov     ss:CURDRV, al   ; no, set

SETRET:                                 ; ...
                mov     al, ss:CDSCOUNT ; let user see what the count really is
                retn

; =============== S U B R O U T I N E =======================================


$GET_INTERRUPT_VECTOR proc near         ; ...
                call    RECSET
                les     bx, es:[bx]
                call    Get_User_Stack

set_user_es_bx:                         ; ...
                mov     word ptr [si+10h], es ; [SI+user_env.user_ES]
                jmp     set_user_bx
$GET_INTERRUPT_VECTOR endp

; ---------------------------------------------------------------------------

$SET_INTERRUPT_VECTOR:                  ; ...
                call    RECSET
                cli
                mov     es:[bx], dx
                mov     word ptr es:[bx+2], ds
                sti
                test    ss:DOS_FLAG, 4  ; EXECA20OF
                                        ; was the previous call an int 21h exec call ?
                jnz     short siv_1     ; yes
                retn
; ---------------------------------------------------------------------------

siv_1:                                  ; ...
                cmp     ss:A20OFF_COUNT, 0
                jnz     short siv_2
                mov     ss:A20OFF_COUNT, 1 ; indicate to dos dispatcher to
                                        ; turn A20 Off before returning to user

siv_2:                                  ; ...
                retn

; =============== S U B R O U T I N E =======================================


RECSET          proc near               ; ...
                xor     bx, bx
                mov     es, bx
                assume es:DOSCODE
                mov     bl, al
                shl     bx, 1
                shl     bx, 1
                retn
RECSET          endp

; ---------------------------------------------------------------------------

$CHAR_OPER:                             ; ...
                or      al, al          ; get switch?
                mov     dl, '/'         ; assume yes
                jz      short chop_1    ; jump if yes
                cmp     al, 2           ; check device availability?
                mov     dl, 0FFh        ; -1 ; assume yes
                jz      short chop_1    ; jump if yes
                retn                    ; otherwise just quit
; ---------------------------------------------------------------------------

chop_1:                                 ; ...
                call    Get_User_Stack
                mov     [si+6], dx      ; [SI+user_env.user_DX]
                                        ; store value for user
                retn
; ---------------------------------------------------------------------------

$GetExtendedError:                      ; ...
                push    ss
                pop     ds
                mov     ax, EXTERR
                les     di, EXTERRPT
                assume es:nothing
                mov     bx, word ptr EXTERR_ACTION ; BL = Action, BH = Class
                mov     ch, EXTERR_LOCUS
                call    Get_User_Stack
                mov     [si+0Ah], di    ; [SI+user_env.user_DI]
                call    set_user_es_bx
                mov     [si+4], cx      ; [SI+user_env.user_CX]

_jmp_to_SYS_RET_OK:                     ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

$ECS_Call:                              ; ...
                or      al, al
                jnz     short _okok
                call    Get_User_Stack
                mov     word ptr [si+8], offset DBCS_TAB_2 ; [SI+user_env.user_SI],
                                        ; DBCS_TAB+2
                push    es
                mov     es, cs:DosDSeg
                mov     word ptr [si+14], es ; [SI+user_env.user_DS]
                pop     es

_okok:                                  ; ...
                jmp     short _jmp_to_SYS_RET_OK
; ---------------------------------------------------------------------------

$LONGNAME:                              ; ...
                xor     al, al          ; longname functions are not supported

lfn_error:                              ; ...
                call    Get_User_Stack
                or      word ptr [si+16h], 1 ; [SI+user_env.user_F],f_Carry
                stc
                mov     [si], ax        ; [SI+user_env.user_ax]
                retn
; ---------------------------------------------------------------------------

$FAT32EXT:                              ; ...
                cmp     al, 5           ; INT 21h AX = 7305h
                jbe     short valid_fat32_ext_function
                mov     al, 1           ; error_invalid_function

fat32_ext_func_err:                     ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

function_5_invalid_cx:                  ; ...
                mov     al, 57h         ; error_invalid_parameter

fat32_ext_func_err_j:                   ; ...
                jmp     short fat32_ext_func_err
; ---------------------------------------------------------------------------

valid_fat32_ext_function:               ; ...
                jnz     short not_function_5
                cmp     cx, 0FFFFh      ; Function 5 - FAT32 - EXTENDED ABSOLUTE DISK READ/WRITE
                jnz     short function_5_invalid_cx
                test    si, 9FFEh       ; read/write mode flags
                jnz     short function_5_invalid_cx
                mov     al, dl          ; drive number, 1 = A
                dec     al
                mov     ah, 1
                test    si, 1
                jz      short function_5_read
                call    near ptr FAT32_ABSDWRT ; INT 21h AX = 7305h (SI bit 0 = 1)
                jmp     short fat32_absdrw_ret
; ---------------------------------------------------------------------------

function_5_read:                        ; ...
                call    FAT32_ABSDRD    ; INT 21h AX = 7305h (SI bit 0 = 0)

fat32_absdrw_ret:                       ; ...
                jb      short lfn_error
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

not_function_5:                         ; ...
                cmp     al, 3
                jz      short function_73_3 ; Function 3 - FAT32 - GET EXTENDED FREE SPACE ON DRIVE
                cmp     al, 2
                jb      short chk_drive_lock_flush
                jmp     $GET_DPB        ; Function 2 - FAT32 - "Get_ExtDPB" - GET EXTENDED DPB
                                        ; Function 4 - FAT32 - Set DPB TO USE FOR FORMATTING
; ---------------------------------------------------------------------------

chk_drive_lock_flush:                   ; ...
                cmp     dl, 26          ; MSDOS 7 - DRIVE LOCKING AND FLUSHING
                jbe     short drv_lock_flush_1
                mov     al, 0Fh         ; invalid drive number

drv_lock_flush_err:                     ; ...
                jmp     short fat32_ext_func_err_j ; ax = error code
; ---------------------------------------------------------------------------

drv_lock_flush_1:                       ; ...
                dec     dl
                jns     short drv_lock_flush_2
                mov     dl, ss:CURDRV   ; 0 = default/current drive)

drv_lock_flush_2:                       ; ...
                mov     dh, 0
                mov     bx, dx
                cmp     cl, 1           ; which flag to get or set
                jbe     short drv_lock_flush_3
                mov     al, 1           ; error_invalid_function
                jmp     short drv_lock_flush_err
; ---------------------------------------------------------------------------

drv_lock_flush_3:                       ; ...
                mov     ah, ss:drive_flags[bx]
                or      cl, cl
                jz      short get_set_indctd_flag ; use bit 1 and bit 2
                or      al, al          ; get drive's dirty-buffers flag
                jz      short get_dirty_buf_flag ; use bit 3
                and     ah, 0F7h        ; clear bit 3
                and     ch, 8           ; izolate bit 3 of the new flag value
                or      ah, ch          ; set AH bit 3 according to CH bit 3
                mov     ss:drive_flags[bx], ah ; set or reset dirty buffer flag
                test    ah, 8
                jnz     short set_dirty_flag_ok ; bit 3 is set/1
                mov     al, 0FFh
                call    FLUSHBUF

set_dirty_flag_ok:                      ; ...
                jmp     short jmp_to_SYS_RET_OK
; ---------------------------------------------------------------------------

get_dirty_buf_flag:                     ; ...
                and     ah, 8           ; izolate dirty buffers flag
                jmp     short mov_flag_cl_to_al ; AH = new flag and 08h (bit 3 used)
; ---------------------------------------------------------------------------

get_set_indctd_flag:                    ; ...
                or      al, al
                jz      short get_indicated_flag
                and     ah, 0F9h        ; clear bit 1 and bit 2
                test    ch, 2           ; new value for indicated flag
                jz      short reset_indctd_flags ; bit 1 is zero
                or      ah, 6           ; set bit 1 and bit 2

reset_indctd_flags:                     ; ...
                mov     ss:drive_flags[bx], ah
                jmp     short jmp_to_SYS_RET_OK
; ---------------------------------------------------------------------------

get_indicated_flag:                     ; ...
                and     ah, 6           ; AH = new flag and 06h (bits 1 and 2 used)

mov_flag_cl_to_al:                      ; ...
                mov     al, cl          ; value of CL on entry

ret_ax_to_user_cx:                      ; ...
                call    Get_User_Stack
                mov     [si+4], ax      ; [SI+user_env.user_cx] ; requested flag

jmp_to_SYS_RET_OK:                      ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

function_73_3:                          ; ...
                mov     si, dx          ; FAT32 - GET EXTENDED FREE SPACE ON DRIVE
                                        ; AX = 7303h
                                        ; DS:DX -> ASCIZ string for drive ("C:\" or "\\SERVER\Share")
                                        ; ES:DI -> buffer for extended free space structure
                                        ; CX = length of buffer for extended free space
                call    DriveFromText
                xchg    ax, dx
                lodsw
                dec     dl
                cmp     dl, 26
                jnb     short func_73_3_err2
                or      ah, ah
                jnz     short func_73_3_err2
                call    PATHCHRCMP
                jnz     short func_73_3_err2
                inc     dl
                cmp     cx, 44          ; buffer (Structure) size must be 44
                jb      short func_73_3_err4
                cmp     word ptr es:[di+2], 0 ; buffer structure version (must be 0)
                jnz     short func_73_3_err3
                push    ss
                pop     ds
                mov     al, dl
                call    GETTHISDRV
                jnb     short fill_efs_struc_b

func_73_3_err1:                         ; ...
                call    FCB_RET_ERR

func_73_3_err2:                         ; ...
                mov     al, 0Fh         ; error_invalid_drive

jmp_to_SYS_RET_ERR:                     ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

func_73_3_err3:                         ; ...
                mov     al, 57h         ; error_invalid_parameter

jmp_to_jmp_SYS_RET_ERR:                 ; ...
                jmp     short jmp_to_SYS_RET_ERR
; ---------------------------------------------------------------------------

func_73_3_err4:                         ; ...
                mov     al, 18h         ; error_bad_length
                jmp     short jmp_to_jmp_SYS_RET_ERR
; ---------------------------------------------------------------------------

fill_efs_struc_b:                       ; ...
                call    DISK_INFO
                jb      short func_73_3_err1
                xor     ah, ah
                push    si              ; si:dx = free cluster count
                push    di              ; di:bx = number of clusters
                call    Get_User_Stack
                mov     es, word ptr [si+10h] ; user's buffer segment (in ES)
                mov     di, [si+0Ah]    ; user's buffer offset/address (in DI)
                mov     es:[di+10h], bx ; total number of clusters on the drive
                mov     es:[di+20h], bx ; total allocation units, without adjustment for compression
                pop     bx
                mov     es:[di+12h], bx ; total number of clusters on the drive, hw
                mov     es:[di+22h], bx ; total allocation units, hw
                mov     es:[di+0Ch], dx ; number of available clusters
                mov     es:[di+1Ch], dx ; number of available allocation units, without adjustment
                pop     dx
                mov     es:[di+0Eh], dx ; number of available clusters, hw
                mov     es:[di+1Eh], dx ; number of available allocation units, hw
                mov     es:[di+8], cx   ; bytes per sector
                mov     es:[di+4], ax   ; sectors per cluster (with adjustment for compression)
                mov     cx, ax
                mul     bx              ; 32 bit multiplication
                jb      short dsk_cap_calc_overf ; disk capacity calculation overflow error
                mov     bx, ax
                mov     ax, es:[di+20h] ; total allocation units, lw
                mul     cx
                add     dx, bx
                jnb     short dsk_cap_calc_ok

dsk_cap_calc_overf:                     ; ...
                mov     ax, 0FFFFh      ; set to 0FFFFFFFFh
                mov     dx, ax

dsk_cap_calc_ok:                        ; ...
                mov     es:[di+1Ah], dx
                mov     es:[di+18h], ax ; total number of physical sectors on the drive,
                                        ; without adjustment for compression
                mov     ax, cx          ; 32 bit multiplication
                mul     word ptr es:[di+0Eh] ; number of available clusters, hw
                jb      short dsk_free_calc_overf
                mov     bx, ax
                mov     ax, es:[di+0Ch] ; number of available clusters, lw
                mul     cx
                add     dx, bx
                jnb     short dsk_free_calc_ok

dsk_free_calc_overf:                    ; ...
                mov     ax, 0FFFFh
                mov     dx, ax

dsk_free_calc_ok:                       ; ...
                mov     es:[di+16h], dx ; hw
                mov     es:[di+14h], ax ; number of physical sectors available on the drive,
                                        ; without adjustment for compression
                xor     ax, ax          ; 0
                mov     es:[di+0Ah], ax ; number of bytes per sector, high word = 0
                mov     es:[di+6], ax   ; number of sectors per cluster, high word = 0
                mov     es:[di+24h], ax ; reserved, 8 bytes zero
                mov     es:[di+26h], ax
                mov     es:[di+28h], ax
                mov     es:[di+2Ah], ax
                mov     ax, 44
                mov     es:[di], ax     ; size of returned structure = 44
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

Set_DPBforFormat:                       ; ...
                cmp     word ptr [si+4], 24 ; [SI+user_env.user_CX]
                                        ; size of buffer (must be at least 18h)
                jnb     short setdpbf_2
                mov     al, 18h         ; error_bad_length

setdpbf_1:                              ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

setdpbf_2:                              ; ...
                push    es              ; ES:BP = Drive parameter block
                push    bp
                mov     es, word ptr [si+10h] ; [SI+user_env.user_ES]
                mov     di, [si+0Ah]    ; [SI+user_env.user_DI]
                pop     si
                pop     ds
                assume ds:nothing
                mov     ax, es:[di+4]   ; (call) function number
                cmp     word ptr es:[di+2], 0 ; structure version (must be 0)
                jnz     short setdpbf_3
                cmp     word ptr es:[di+6], 0 ; (must be 0)
                jnz     short setdpbf_3
                cmp     ax, 4           ; (max) 5 functions (0 to 4)
                jbe     short setdpbf_4

setdpbf_3:                              ; ...
                mov     al, 57h         ; error_invalid_parameter
                jmp     short setdpbf_1
; ---------------------------------------------------------------------------

setdpbf_4:                              ; ...
                mov     word ptr es:[di], 18h ; (call) size
                or      al, al
                jz      short setdpbf_5 ; invalidate DPB counts
                jmp     setdpbf_18
; ---------------------------------------------------------------------------

setdpbf_5:                              ; ...
                xor     dx, dx          ; 0
                mov     bx, [si+0Dh]    ; DPB.MAX_CLUSTER
                cmp     word ptr [si+0Fh], 0 ; DPB.FAT_SIZE
                jnz     short setdpbf_6 ; not FAT32
                mov     dx, [si+2Fh]
                mov     bx, [si+2Dh]    ; DPB.LAST_CLUSTER

setdpbf_6:                              ; ...
                mov     ax, es:[di+0Ah]
                mov     cx, es:[di+8]   ; new DPB free count
                                        ; (00000000h=no change, FFFFFFFFh=unknown)
                or      ax, ax
                jnz     short setdpbf_7
                jcxz    short setdpbf_11

setdpbf_7:                              ; ...
                cmp     ax, 0FFFFh
                jnz     short setdpbf_8
                cmp     cx, 0FFFFh
                jz      short setdpbf_10 ; (set as UNKNOWN/INITIAL)

setdpbf_8:                              ; ...
                cmp     ax, dx          ; must be < DPB.LAST_CLUSTER
                jnz     short setdpbf_9
                cmp     cx, bx

setdpbf_9:                              ; ...
                jnb     short setdpbf_3

setdpbf_10:                             ; ...
                or      byte ptr [si+18h], 1 ; DPB.FIRST_ACCESS (bit 0 = 1)
                mov     [si+1Fh], cx    ; DPB.FREE_CNT
                cmp     word ptr [si+0Fh], 0 ; DP.FAT_SIZE
                jnz     short setdpbf_11 ; FAT12 or FAT16
                mov     [si+21h], ax    ; DPB.FREE_CNT_HW

setdpbf_11:                             ; ...
                mov     ax, es:[di+0Eh]
                mov     cx, es:[di+0Ch] ; new DPB next-free
                                        ; (00000000h=no change, FFFFFFFFh=unknown)
                or      ax, ax
                jnz     short setdpbf_12
                jcxz    short setdpbf_17

setdpbf_12:                             ; ...
                cmp     ax, 0FFFFh
                jnz     short setdpbf_13
                cmp     cx, 0FFFFh
                jz      short setdpbf_16 ; (set as UNKNOWN/INITIAL)

setdpbf_13:                             ; ...
                cmp     ax, 0           ; must be >= 2
                jnz     short setdpbf_14
                cmp     cx, 2

setdpbf_14:                             ; ...
                jb      short setdpbf_3
                cmp     ax, dx          ; must be < DPB.LAST_CLUSTER
                jnz     short setdpbf_15
                cmp     cx, bx

setdpbf_15:                             ; ...
                ja      short setdpbf_3

setdpbf_16:                             ; ...
                or      byte ptr [si+18h], 1 ; DPB.FIRST_ACCESS (bit 0 = 1)
                mov     [si+1Dh], cx    ; DPB.NEXT_FREE
                cmp     word ptr [si+0Fh], 0 ; DPB.FAT_SIZE
                jnz     short setdpbf_17 ; FAT16 or FAT12
                mov     [si+3Bh], ax
                mov     [si+39h], cx    ; DPB.FAT32_NXTFREE

setdpbf_17:                             ; ...
                mov     ax, 7304h       ; done (successful)
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

setdpbf_18:                             ; ...
                dec     al
                jnz     short setdpbf_19
                push    ds              ; rebuild DPB from BPB
                push    si
                lds     si, es:[di+8]   ; BIOS Parameter Block
                pop     bp
                pop     es
                mov     cx, 4558h       ; 'XE' (NASM syntax)
                mov     dx, 4152h       ; 'RA' (NASM syntax)
                call    $SETDPB
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

setdpbf_19:                             ; ...
                dec     al
                jnz     short setdpbf_20 ;
                                        ; force media change
                                        ; (next access to drive rebuild DPB)
                or      byte ptr [si+18h], 80h ; DPB.FIRST_ACCESS (bit 7 = 1)
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

setdpbf_20:                             ; ...
                cmp     word ptr [si+0Fh], 0 ; DPB.FAT_SIZE
                jz      short setdpbf_22 ; FAT32
                mov     al, 0Fh         ; error_invalid_drive
                                        ; (function 3 or 4 are only for drives with FAT32 fs)

setdpbf_21:                             ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

setdpbf_22:                             ; ...
                dec     al
                jz      short setdpbf_30 ; get/set active FAT number and mirroring
                mov     ax, [si+35h]    ; get/set root directory cluster number
                                        ; DPB.ROOT_CLUSTER
                mov     es:[di+0Ch], ax ; (ret) previous root directory cluster number
                mov     ax, [si+37h]
                mov     es:[di+0Eh], ax
                mov     cx, es:[di+0Ah]
                mov     ax, es:[di+8]   ; (call) new root directory cluster number
                cmp     ax, 0FFFFh      ; -1 --> return only previous root dir cluster number
                jnz     short setdpbf_23
                cmp     cx, 0FFFFh
                jz      short setdpbf_29

setdpbf_23:                             ; ...
                cmp     cx, 0           ; cluster number must be >= 2
                jnz     short setdpbf_24
                cmp     ax, 2

setdpbf_24:                             ; ...
                jnb     short setdpbf_26

setdpbf_25:                             ; ...
                jmp     setdpbf_3       ; error (invalid parameter)
; ---------------------------------------------------------------------------

setdpbf_26:                             ; ...
                cmp     cx, [si+2Fh]    ; must be <= DPB.LAST_CLUSTER
                jnz     short setdpbf_27
                cmp     ax, [si+2Dh]

setdpbf_27:                             ; ...
                ja      short setdpbf_25 ; error
                mov     [si+37h], cx    ; DPB.ROOT_CLUSTER
                mov     [si+35h], ax
                or      byte ptr [si+18h], 2 ; DPB.FIRST_ACCESS (bit 1 = 1)
                push    ds
                push    si
                pop     bp
                pop     es
                call    ECritDisk
                call    update_fat32_fsinfo
                call    LCritDisk
                jnb     short setdpbf_29
                mov     al, 1Fh         ; error_gen_failure

setdpbf_28:                             ; ...
                jmp     short setdpbf_21
; ---------------------------------------------------------------------------

setdpbf_29:                             ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

setdpbf_30:                             ; ...
                and     word ptr [si+23h], 8Fh ; DPB.EXT_FLAGS (clear bit 4-6)
                mov     cx, [si+23h]
                mov     es:[di+0Ch], cx ; (ret) previous active FAT/mirroring state
                mov     word ptr es:[di+0Eh], 0 ;
                                        ; put zero to Set_DPBforFormat struc offset 14
                mov     dx, es:[di+8]   ; (call) new active FAT/mirroring state,
                                        ;  or FFFFFFFFh to get
                cmp     dx, 0FFFFh
                jnz     short setdpbf_31
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

setdpbf_31:                             ; ...
                test    dx, 0FF70h
                jz      short setdpbf_33 ; bit 4-6 of DPB.EXT_FLAGS must be 0
                mov     al, 57h         ; error_invalid_parameter

setdpbf_32:                             ; ...
                jmp     short setdpbf_28
; ---------------------------------------------------------------------------

setdpbf_33:                             ; ...
                mov     al, 1           ; error_invalid_function
                                        ; (modification is not allowed)
                jmp     short setdpbf_32
; ---------------------------------------------------------------------------

$PARSE_FILE_DESCRIPTOR:                 ; ...
                call    MAKEFCB
                push    si
                call    Get_User_Stack
                pop     word ptr [si+8] ; [SI+user_env.user_SI]
                retn

; =============== S U B R O U T I N E =======================================


set_exerr_locus_unk proc near           ; ...
                push    ax
                mov     al, 1           ; errLOC_Unk

set_exerr_locus:                        ; ...
                mov     ss:EXTERR_LOCUS, al
                pop     ax
                retn
set_exerr_locus_unk endp


; =============== S U B R O U T I N E =======================================


set_exerr_locus_disk proc near          ; ...
                push    ax
                mov     al, 2           ; errLOC_Disk
                jmp     short set_exerr_locus
set_exerr_locus_disk endp


; =============== S U B R O U T I N E =======================================


set_exerr_locus_ser proc near           ; ...
                push    ax
                mov     al, 4           ; errLOC_SerDev
                jmp     short set_exerr_locus
set_exerr_locus_ser endp


; =============== S U B R O U T I N E =======================================


set_exerr_locus_mem proc near           ; ...
                push    ax
                mov     al, 5           ; errLOC_Mem
                jmp     short set_exerr_locus
set_exerr_locus_mem endp

; ---------------------------------------------------------------------------

$SLEAZEFUNC:                            ; ...
                mov     dl, 0           ; default drive

$SLEAZEFUNCDL:                          ; ...
                push    ss
                pop     ds
                assume ds:DOSCODE
                mov     al, dl
                call    GETTHISDRV      ; Get CDS structure
                jb      short BADSLDRIVE
                call    DISK_INFO
                jb      short BADSLDRIVE
                mov     byte ptr FATBYTE, ah ; FAT (MEDIA) ID byte
                xor     ah, ah          ; AH = 0
                                        ; AL = sectors per cluster
                push    di              ; di:bx = number of clusters
                call    TestNet
                pop     di
                jb      short sleazefunc1
                push    cx              ; bytes per sector
                call    modify_cluster_count
                pop     cx              ; ax = sectors per cluster (modified)
                                        ; dx = number of clusters (modified)
                                        ; if bytes per cluster > 16384
                                        ;    and hw of cluster count > 0
                                        ;    bx = 0FFFEh (invalidated parms sign)

sleazefunc1:                            ; ...
                mov     di, offset FATBYTE
                call    Get_User_Stack
                mov     [si+4], cx      ; [SI+user_env.user_CX]
                mov     [si+6], bx      ; [SI+user_env.user_DX]
                mov     [si+2], di      ; [SI+user_env.user_BX]
                mov     word ptr [si+0Eh], ss ; [SI+user_env.user_DS]
                                        ; stash correct pointer
                retn
; ---------------------------------------------------------------------------

BADSLDRIVE:                             ; ...
                jmp     FCB_RET_ERR     ; error
; ---------------------------------------------------------------------------

$GET_INDOS_FLAG:                        ; ...
                call    Get_User_Stack
                mov     word ptr [si+2], offset INDOS ; [SI+user_env.user_BX]

getin_segm:                             ; ...
                mov     word ptr [si+10h], ss ; [SI+user_env.user_ES]
                retn
; ---------------------------------------------------------------------------

$GET_IN_VARS:                           ; ...
                call    Get_User_Stack  ; Return Pointer to DOS Variables
                mov     word ptr [si+2], offset DPBHEAD ; [SI+user_env.user_BX],
                                        ; SYSINITVARS
                jmp     short getin_segm
; ---------------------------------------------------------------------------

$GET_DEFAULT_DPB:                       ; ...
                mov     dl, 0

$GET_DPB:                               ; ...
                push    ss
                pop     ds
                mov     al, dl
                call    GETTHISDRV      ; Get CDS structure
                mov     al, 0Fh         ; error_invalid_drive
                jnb     short getdpb_3

getdpb_1:                               ; ...
                call    Get_User_Stack
                cmp     word ptr [si], 7302h ; INT 21h, AX = 7302h ? Get_ExtDPB
                                        ; GET EXTENDED DPB
                jz      short getdpb_2
                cmp     word ptr [si], 7304h ; INT 21h, AX = 7304h ? Set_DPBforFormat
                                        ; Set DPB TO USE FOR FORMATTING
                jnz     short ISNODRV

getdpb_2:                               ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

ISNODRV:                                ; ...
                mov     al, 0FFh        ; -1 ; invalid (or network) drive
                retn
; ---------------------------------------------------------------------------

getdpb_3:                               ; ...
                les     di, THISCDS
                test    byte ptr es:[di+44h], 80h ; [ES:DI+curdir.flags+1],
                                        ; (curdir_isnet>>8)
                jnz     short getdpb_1
                call    ECritDisk
                call    FATREAD_CDS
                call    LCritDisk
                mov     al, 53h         ; error_FAIL_I24
                jb      short getdpb_1
                call    Get_User_Stack
                cmp     word ptr [si], 7304h ; INT 21h, AX = 7304h ?
                jnz     short getdpb_4
                jmp     Set_DPBforFormat
; ---------------------------------------------------------------------------

getdpb_4:                               ; ...
                cmp     word ptr [si], 7302h ; INT 21h, AX = 7302h ?
                jz      short getdpb_5
                cmp     word ptr es:[bp+0Fh], 0
                jz      short getdpb_1
                mov     [si+2], bp
                mov     word ptr [si+0Eh], es
                xor     al, al          ; status = 0 = successful
                retn
; ---------------------------------------------------------------------------

getdpb_5:                               ; ...
                mov     al, 18h         ; error_bad_length
                cmp     word ptr [si+4], 63 ; [SI+user_env.user_CX]
                                        ; length of buffer (must be 63 bytes)
                jb      short getdpb_2  ; error
                push    es              ; ES:BP = Drive parameter block
                push    bp
                mov     es, word ptr [si+16] ; [SI+user_env.user_ES]
                mov     di, [si+10]     ; [SI+user_env.user_DI]
                mov     bx, [si+8]      ; [SI+user_env.user_SI] (!)
                pop     si
                pop     ds
                assume ds:nothing
                mov     ax, 61          ; length of following data (003Dh)
                stosw
                mov     cx, ax
                push    di
                rep movsb
                pop     di
                cmp     bx, 0F1A6h      ; (!) signature (undocumented),
                                        ;  must be 0F1A6h to get device driver
                                        ;  address and next-DPB pointer
                                        ; (Ref: Ralf Brown's Interrupt List)
                jz      short getdpb_6
                xor     ax, ax          ; 0
                dec     ax              ; -1
                mov     es:[di+19h], ax ; pointer to next DPB (invalidated)
                mov     es:[di+1Bh], ax
                mov     es:[di+13h], ax ; pointer to driver address (invalidated)
                mov     es:[di+15h], ax

getdpb_6:                               ; ...
                cmp     word ptr es:[di+0Fh], 0 ; FAT (16 bit) size ?
                jz      short getdpb_8  ; FAT32
                                        ; FAT16 or FAT12
                mov     ax, es:[di+0Dh] ; DPB.MAX_CLUSTER
                mov     es:[di+2Dh], ax ; DPB.LAST_CLUSTER
                mov     ax, es:[di+0Fh] ; DPB.FAT_SIZE
                mov     es:[di+31h], ax ; DPB.FAT32_SIZE
                mov     ax, es:[di+1Dh] ; DPB.NEXT_FREE
                mov     es:[di+39h], ax ; DPB.FAT32_NXTFREE
                mov     ax, es:[di+0Bh] ; DPB.FIRST_SECTOR
                mov     es:[di+29h], ax ; DPB.FCLUS_FSECTOR
                xor     ax, ax          ; 0
                mov     es:[di+2Fh], ax ; DPB.LAST_CLUSTER high word
                mov     es:[di+33h], ax ; DPB.FAT32_SIZE high word
                mov     es:[di+3Bh], ax ; DPB.FAT32_NXTFREE high word
                mov     es:[di+2Bh], ax ; DPB.FCLUS_FSECTOR high word
                mov     es:[di+35h], ax ; DPB.ROOT_CLUSTER
                mov     es:[di+37h], ax ; DPB.ROOT_CLUSTER high word
                mov     es:[di+23h], ax ; DPB.EXT_FLAGS
                dec     ax              ; -1
                mov     es:[di+25h], ax ; DPB.FSINFO_SECTOR (invalidated)
                mov     es:[di+27h], ax ; DPB.BKBOOT_SECTOR (invalidated)
                cmp     ax, es:[di+1Fh] ; DPB.FREE_COUNT (= -1 ?)
                jz      short getdpb_7
                inc     ax              ; -1 -> 0

getdpb_7:                               ; ...
                mov     es:[di+21h], ax ; DPB.PB.FREE_COUNT high word

getdpb_8:                               ; ...
                xor     ax, ax          ; status = 0 = successful
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

$DISK_RESET:                            ; ...
                mov     al, 0FFh        ; -1
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    ECritDisk
                or      byte ptr DOS34_FLAG, 4 ; FROM_DISK_RESET
                call    FLUSHBUF
                and     byte ptr DOS34_FLAG, 0FBh ; NO_FROM_DISK_RESET
                les     bp, DPBHEAD

drst_1:                                 ; ...
                cmp     bp, 0FFFFh      ; -1 ?
                jz      short drst_2    ; yes, it is the last DPB
                call    update_fat32_fsinfo ; update FSINFO (sector) parameters
                les     bp, es:[bp+19h] ; DPB.NEXT_DPB
                jmp     short drst_1
; ---------------------------------------------------------------------------

drst_2:                                 ; ...
                mov     SC_STATUS, 0    ; Throw out secondary cache
                mov     bx, 0FFFFh      ; -1
                mov     word ptr LastBuffer+2, bx ; Invalidate 'last-buffer' used
                mov     word ptr LastBuffer, bx
                call    LCritDisk
                mov     ax, 0FFFFh
                push    ax
                mov     ax, 1120h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
                                        ; DS = DOS CS
                                        ; Return: CF clear (successful)
                pop     ax
                retn
; ---------------------------------------------------------------------------
word3           dw 3                    ; ...

; =============== S U B R O U T I N E =======================================


$SETDPB         proc near               ; ...
                mov     di, bp          ; Buffer address (es:bp)
                inc     di              ; Skip over dpb_drive and dpb_UNIT
                inc     di
                lodsw                   ; dpb_sector_size ; bytes per sector
                stosw                   ; .BPB_BYTESPERSECTOR
                cmp     cx, 4558h       ; 'XE' (NASM syntax)
                                        ; CX = signature 4558h ('EX') for FAT32 extended BPB/DPB
                jnz     short not_fat32_extension
                cmp     dx, 4152h       ; 'RA' (NASM syntax)
                                        ; DX = signature 4152h ('AR') for FAT32 extended BPB/DPB
                jz      short chk_fat32_conditions

not_fat32_extension:                    ; ...
                xor     cx, cx          ; 0 ; (Do not use FAT32 extensions -32 bit parameters-)

chk_fat32_conditions:                   ; ...
                push    cx              ; (*)
                cmp     byte ptr [si+3], 0 ; .BPB_NUMBEROFFATS
                jz      short nofat
                cmp     word ptr [si+9], 0 ; .BPB_SECTORSPERFAT ; BPB_FATSz16
                jnz     short yesfat
                cmp     word ptr [si+29], 0 ; .BPB_FAT32VERSION ; BPB_FSVer
                jz      short yesfat

nofat:                                  ; ...
                xor     ax, ax
                mov     es:[di+4], al   ; DPB.FAT_COUNT = 0
                add     di, 15          ; DPB.DRIVER_ADDR
                add     si, 11          ; .BPB_SECTORSPERTRACK
                mov     es:[bp+15], ax  ; DPB.FAT_SIZE = 0
                jmp     setend
; ---------------------------------------------------------------------------

yesfat:                                 ; ...
                mov     dx, ax          ; bytes per sector
                lodsb                   ; .BPB_SECTORSPERCLUSTER
                xor     ah, ah
                or      ax, ax
                jz      short nofat
                dec     al
                stosb                   ; DPB.CLUSTER_MASK ; Sectors/cluster - 1
                inc     al

LOG2LOOP:                               ; ...
                test    al, 1
                jnz     short SAVLOG
                inc     ah
                shr     al, 1
                jmp     short LOG2LOOP
; ---------------------------------------------------------------------------

SAVLOG:                                 ; ...
                mov     al, ah
                stosb                   ; DPB.CLUSTER_SHIFT ; Log2 of sectors/cluster
                mov     bl, al
                movsw                   ; .BPB_RESERVEDSECTORS -> DPB.FIRST_FAT
                lodsb                   ; .BPB_NUMBEROFFATS
                stosb                   ; DPB.FAT_COUNT
                mov     bh, al
                lodsw                   ; .BPB_ROOTENTRIES
                stosw                   ; DPB.ROOT_ENTRIES
                mov     cl, 5
                shr     dx, cl          ; Directory entries per sector
                dec     ax
                add     ax, dx          ; Round Up
                mov     cx, dx
                xor     dx, dx
                div     cx
                mov     cx, ax          ; Number of root directory sectors
                inc     di
                inc     di
                movsw                   ; .BPB_TOTALSECTORS -> DPB.MAX_CLUSTER (temporary)
                lodsb                   ; .BPB_MEDIADESCRIPTOR
                mov     es:[bp+23], al  ; DPB.MEDIA
                lodsw                   ; .BPB_SECTORSPERFAT
                stosw                   ; DPB.FAT_SIZE
                xor     dx, dx
                or      ax, ax
                jnz     short savlog1   ; 16 bit FAT size
                pop     dx              ; (*) FAT32 extensions
                                        ; (use 32 bit FAT and Root Dir size if >0)
                push    dx              ; (*)
                or      dx, dx
                jz      short savlog1   ; Do not use FAT32 extensions
                                        ; (do not use 32 bit FAT size field)
                mov     ax, [si+12]     ; .BPB_SECTORSPERFAT32 ; BPB_FATSz32
                mov     dx, [si+14]     ; .BPB_SECTORSPERFAT32+2

savlog1:                                ; ...
                push    cx              ; (**) Root directory sectors
                mov     cx, ax          ; 32 bit multiply
                mov     al, bh          ; FAT count
                xor     ah, ah
                mul     dx
                xchg    ax, cx
                mov     dl, bh          ; FAT count
                xor     dh, dh
                mul     dx
                add     dx, cx
                pop     cx              ; (**)
                cmp     ax, dx
                jnz     short savlog2
                or      ax, ax
                jnz     short savlog2
                inc     di
                inc     di
                jmp     short setend
; ---------------------------------------------------------------------------

savlog2:                                ; ...
                add     ax, es:[bp+6]   ; dx:ax = (total) FAT sectors
                                        ; add ax,[es:bp+DPB.FIRST_FAT]
                adc     dx, 0
                stosw                   ; DPB.DIR_SECTOR
                add     ax, cx          ; + root directory size
                mov     es:[bp+11], ax  ; DPB.FIRST_SECTOR ; First data sector
                adc     dx, 0
                pop     cx              ; (*)
                push    cx
                jcxz    short savlog3
                mov     es:[bp+41], ax  ; DPB.BIG_FIRST_SECTOR ; FAT32 first sector field
                mov     es:[bp+43], dx

savlog3:                                ; ...
                mov     cl, bl          ; cluster shift
                cmp     word ptr es:[bp+13], 0 ; DPB.MAX_CLUSTER
                                        ; (contains 16 bit .BPB_TOTALSECTORS as temporary)
                jnz     short normal_dpb
                xor     ch, ch
                push    dx
                mov     bx, [si+8]      ; SI points to .BPB_SECTORSPERTRACK and SI+8 is
                                        ; .BPB_BIGTOTALSECTORS (32 bit total sectors)
                mov     dx, [si+10]
                sub     bx, ax
                pop     ax
                sbb     dx, ax          ; dx:bx = data sectors (for cluster count calc)
                or      cx, cx
                jz      short norot

rott:                                   ; ...
                clc
                rcr     dx, 1
                rcr     bx, 1
                loop    rott

norot:                                  ; ...
                mov     ax, bx          ; dx:ax = cluster count
                jmp     short setend
; ---------------------------------------------------------------------------

normal_dpb:                             ; ...
                sub     ax, es:[bp+13]  ; first sector - total sectors
                xor     dx, dx
                neg     ax              ; data sectors = total sectors - first sector
                shr     ax, cl          ; cluster count

setend:                                 ; ...
                pop     cx              ; (*) 0 = not 32 bit fat sectors
                push    cx              ; (*)
                add     ax, 1
                adc     dx, 0           ; calculated # clusters HW
                mov     bx, ax          ; calculated # clusters LW
                mov     ax, es:[bp+15]  ; FAT size (16 bit)
                jcxz    short setend1   ; Do not use 32 bit FAT sectors field
                xor     cx, cx
                or      ax, ax
                jnz     short setend1
                mov     ax, [si+12]     ; .BPB_SECTORSPERFAT32  ; 32 bit FAT size field.
                mov     cx, [si+14]     ; .BPB_SECTORSPERFAT32+2

setend1:                                ; ...
                push    dx              ; cx:ax = FAT size (in sectors)
                                        ; dx:bx = calculated number of clusters
                xchg    ax, cx
                mul     word ptr es:[bp+2] ; DPB.SECTOR_SIZE
                xchg    ax, cx
                mul     word ptr es:[bp+2]
                add     dx, cx          ; dx:ax = FAT size in bytes
                pop     cx              ; calculated # clusters HW
                or      cx, cx
                jnz     short setend2   ; FAT32
                cmp     bx, 0FF6h
                jb      short setend_fat12 ; FAT12

setend2:                                ; ...
                or      cx, cx          ; HW of calculated cluster count
                jnz     short setend3
                cmp     bx, 0FFF6h
                jb      short setend4   ; FAT16

setend3:                                ; ...
                shr     dx, 1           ; FAT32 ; 4 byte (32 bit) cluster number
                                        ; fatsiz/4 = # of fat entries
                rcr     ax, 1
                shr     dx, 1
                jz      short setend5   ; dx = 0
                rcr     ax, 1
                jmp     short setend_fat16
; ---------------------------------------------------------------------------

setend4:                                ; ...
                shr     dx, 1           ; FAT16 ; 2 byte (16 bit) cluster number
                                        ; fatsiz/2 = # of fat entries
                jnz     short setend_faterr ; dx > 0

setend5:                                ; ...
                rcr     ax, 1           ; FAT16 ; 2 byte (16 bit) cluster number
                                        ; fatsiz/2 = # of fat entries
                cmp     ax, 0FF7h       ; 4096-10+1
                jb      short setend_faterr
                jmp     short setend_fat16
; ---------------------------------------------------------------------------

setend_fat12:                           ; ...
                add     ax, ax          ; FAT12 ; 1.5 byte (12 bit) cluster number
                                        ; (fatsiz*2)/3 = # of fat entries
                adc     dx, dx
                cmp     dx, 3           ; if our fatspace is more than we need
                                        ; use calculated size
                jnb     short setend_faterr
                div     cs:word3

setend_fat16:                           ; ...
                sub     ax, 1
                sbb     dx, 0
                cmp     dx, cx          ; is fat big enough?
                ja      short setend_faterr
                cmp     ax, bx
                jbe     short setend_fat32 ; use max value that'll fit

setend_faterr:                          ; ...
                mov     ax, bx          ; use calculated value
                mov     dx, cx

setend_fat32:                           ; ...
                cmp     word ptr es:[bp+15], 0 ; DPB.FAT_SIZE ; 16 bit FAT size
                jnz     short setend6
                mov     word ptr es:[bp+17], 0FFFFh ; DPB.DIR_SECTOR
                                        ; (16 bit directory sector field)
                mov     word ptr es:[bp+13], 0 ; DPB.MAX_CLUSTER (16 bit)
                jmp     short setend7
; ---------------------------------------------------------------------------

setend6:                                ; ...
                mov     es:[bp+13], ax  ; DPB.MAX_CLUSTER = calculated last cluster number

setend7:                                ; ...
                pop     cx              ; (*) 1 = use FAT32 extensions
                                        ;     0 = don't use FAT32 extensions (32 bit fields)
                jcxz    short setend_fat ; do not use FAT32 extensions
                mov     es:[bp+45], ax  ; DPB.MAX_CLUSTER32 ; dx:ax = last cluster number
                mov     es:[bp+47], dx
                mov     ax, 0FFFFh      ; -1
                lea     di, [bp+33]     ; DPB.FREE_CNT_HW
                                        ; High word of free cluster count
                stosw                   ; -1 ; 0FFFFh
                lea     si, [si+16]     ; FAT32 flags
                movsw                   ; DPB FAT32 flags ; [bp+23h]
                add     si, 6
                lodsw                   ; FSINFO structure sector number
                mov     dx, [si-24h]    ; .BPB_RESERVEDSECTORS ; Number of reserved sectors.
                or      ax, ax
                jz      short setend8
                cmp     ax, dx
                jb      short setend9

setend8:                                ; ...
                mov     ax, 0FFFFh      ; -1 ; invalid

setend9:                                ; ...
                stosw                   ; DPB FSINFO structure sector number
                                        ; [bp+25h]
                lodsw                   ; Sector number of the backup boot sector
                or      ax, ax
                jz      short setend10
                cmp     ax, dx
                jb      short setend11

setend10:                               ; ...
                mov     ax, 0FFFFh      ; -1 ; invalid

setend11:                               ; ...
                stosw                   ; DPB backup boot sector address
                                        ; [bp+27h]
                add     di, 8           ; [bp+31h]
                xor     dx, dx
                mov     ax, es:[di-34]  ; [bp+0Fh] ; DPB.MAX_CLUSTER
                cmp     ax, dx
                jnz     short setend12  ; > 0 (not FAT32)
                mov     ax, [si-16]     ; FAT32 Sectors per FAT ; .BPB_SECTORSPERFAT32
                mov     dx, [si-14]

setend12:                               ; ...
                stosw                   ; DPB FAT32 FAT size in sectors ; [bp+31h]
                mov     ax, dx
                stosw
                sub     si, 8           ; Root directory cluster number
                movsw                   ; DPB Root Dir Cluster ; [bp+35h]
                movsw
                xor     ax, ax          ; DPB reserved ; [bp+39h]
                stosw
                stosw

setend_fat:                             ; ...
                xor     ax, ax
                mov     es:[bp+29], ax  ; DPB.NEXT_FREE ; last allocated cluster #
                dec     ax
                mov     es:[bp+31], ax  ; DPB.FREE_CNT (-1 = unknown)
                retn
$SETDPB         endp


; =============== S U B R O U T I N E =======================================


$DUP_PDB        proc near               ; ...
                mov     ds, cs:DosDSeg
                assume ds:nothing
                mov     ds:CreatePDB, 0FFh ; indicate a new process
                mov     ds, ds:CurrentPDB
                push    si
                jmp     short CreateCopy
; ---------------------------------------------------------------------------

$CREATE_PROCESS_DATA_BLOCK:             ; ...
                call    Get_User_Stack
                mov     ds, word ptr [si+14h] ; [SI+user_env.user_CS]
                push    word ptr ds:2   ; [PDB.BLOCK_LEN]

CreateCopy:                             ; ...
                mov     es, dx
                xor     si, si          ; copy entire PDB
                mov     di, si
                mov     cx, 128
                rep movsw
                mov     cx, 20          ; FILPERPROC
                mov     di, 18h         ; PDB.JFN_TABLE
                push    ds
                lds     si, ds:34h      ; [PDB.JFN_Pointer]
                rep movsb
                pop     ds
                mov     ds, cs:DosDSeg
                cmp     ds:CreatePDB, 0
                jz      short Create_PDB_cont
                mov     ds, cs:DosDSeg
                xor     bx, bx
                mov     cx, 20

Create_dup_jfn:                         ; ...
                push    es
                call    SFFromHandle
                mov     al, 0FFh        ; unassigned JFN
                jb      short CreateStash
                test    byte ptr es:[di+6], 10h ; [ES:DI+SF_ENTRY.sf_flags+1],
                                        ; (sf_no_inherit>>8)
                jnz     short CreateStash ; if no-inherit bit is set, skip dup.
                mov     ah, es:[di+2]   ; [ES:DI+SF_ENTRY.sf_mode]
                and     ah, 0F0h        ; SHARING_MASK
                cmp     ah, 70h         ; SHARING_NET_FCB
                jz      short CreateStash
                mov     word ptr ds:THISSFT, di
                mov     word ptr ds:THISSFT+2, es
                call    DOS_DUP
                call    pJFNFromHandle
                mov     al, es:[di]

CreateStash:                            ; ...
                pop     es
                mov     es:[bx+18h], al ; [ES:BX+PDB.JFN_TABLE]
                inc     bx              ; next jfn
                loop    Create_dup_jfn
                mov     bx, ds:CurrentPDB ; get current process
                mov     es:16h, bx      ; [ES:PDB.PARENT_PID]
                mov     ds:CurrentPDB, es
                mov     ds, bx

Create_PDB_cont:                        ; ...
                push    ds
                mov     ds, cs:DosDSeg
                mov     ds:CreatePDB, 0
                pop     ds
                pop     ax
$DUP_PDB        endp


; =============== S U B R O U T I N E =======================================


SETMEM          proc near               ; ...
                xor     cx, cx
                mov     ds, cx
                assume ds:DOSCODE
                mov     es, dx
                mov     si, 88h         ; addr_int_terminate
                mov     di, 0Ah         ; SAVEXIT
                mov     cl, 6
                rep movsw
                mov     es:2, ax
                sub     ax, dx
                cmp     ax, 0FFFh       ; MAXDIF
                jbe     short HAVDIF
                mov     ax, 0FFFh       ; MAXDIF

HAVDIF:                                 ; ...
                sub     ax, 10h         ; Allow for 100h byte "stack" in .COM files
                mov     bx, 0Ch         ; ENTRYPOINTSEG
                sub     bx, ax
                mov     cl, 4
                shl     ax, cl
                mov     ds, dx
                assume ds:nothing
                mov     ds:6, ax        ; [PDB.CPM_CALL+1]
                mov     ds:8, bx        ; [PDB.CPM_CALL+3]
                cmp     ax, 0FEF0h      ; WRAPOFFSET
                jz      short addr_ok
                mov     word ptr ds:6, 0C0h ; [PDB.CPM_CALL+1],0C0h
                mov     word ptr ds:8, 0 ; [PDB.CPM_CALL+3],0

addr_ok:                                ; ...
                mov     word ptr ds:0, 20CDh ; PDB.EXIT_CALL],(int_abort*256) + mi_INT
                mov     byte ptr ds:5, 9Ah ; [PDB.CPM_CALL],mi_Long_CALL
                mov     word ptr ds:50h, 21CDh ; [PDB.CALL_SYSTEM],(int_command*256) + mi_INT
                mov     byte ptr ds:52h, 0CBh ; [PDB.CALL_SYSTEM+2],mi_Long_RET
                mov     word ptr ds:34h, 18h ; [PDB.JFN_Pointer],PDB.JFN_TABLE
                mov     word ptr ds:36h, ds ; PDB.JFN_Pointer+2],DS
                mov     word ptr ds:32h, 14h ; [PDB.JFN_Length],FILPERPROC
                mov     word ptr ds:38h, 0FFFFh ; [PDB.Next_PDB],-1
                mov     word ptr ds:3Ah, 0FFFFh ; [PDB.Next_PDB+2],-1
                mov     word ptr es:40h, 0A07h ; [ES:PDB.Version],
                                        ; (MINOR_VERSION*256)+MAJOR_VERSION
                retn
SETMEM          endp

; ---------------------------------------------------------------------------

$GSetMediaID:                           ; ...
                push    ds
                push    si
                lds     si, ss:THISCDS
                lds     si, [si+45h]    ; [si+curdir.devptr]
                                        ; local pointer to DPB or net device
                mov     si, [si+0Fh]    ; [si+DPB.FAT_SIZE]
                mov     cx, 866h        ; assume get for IOCTL
                                        ; major function = Generic IOCtl (08h)
                                        ; minor function = GetMediaId (66h)
                cmp     al, 1           ; set ?
                jb      short doioctl1  ; get
                ja      short errorfunc ; invalid
                mov     cl, 46h         ; minor function = SetMediaId (46h)
                or      si, si
                jz      short doioctl2  ; FAT32 fs

doioctl1:                               ; ...
                or      si, si
                jnz     short doioctl   ; FAT fs (FAT12, FAT16)
                pop     ds
                push    ds
                mov     si, dx          ; disk info
                                        ; .................................
                                        ; 00h    WORD    0000h (info level)
                                        ; 02h    DWORD   disk serial number (binary)
                                        ; 06h 11 BYTEs   volume label or "NO NAME    " if none present
                                        ; 11h  8 BYTEs   (AL=00h only) filesystem type
                                        ;     "FAT12   "
                                        ;     "FAT16   "
                                        ;     "FAT32   " ; PCDOS 7.1
                                        ;     "CDROM   "
                                        ;     "CD001   "
                                        ;     "CDAUDIO "
                                        ; .................................
                                        ; ; (ref: Ralf Brown's Interrupt List)
                cmp     word ptr [si+11h], 4146h ; 'FA'
                jnz     short doioctl
                cmp     word ptr [si+13h], 3354h ; 'T3'
                jnz     short doioctl
                cmp     word ptr [si+15h], 2032h ; '2 '
                jnz     short doioctl
                cmp     word ptr [si+17h], 2020h ; '  '
                jnz     short doioctl

doioctl2:                               ; ...
                mov     ch, 48h         ; new generic ioctl function (FAT32)
                                        ; (major function bit 6 is 1)

doioctl:                                ; ...
                pop     si
                pop     ds
                mov     al, 0Dh         ; generic IOCTL
                call    $IOCTL          ; let IOCTL take care of it
                retn
; ---------------------------------------------------------------------------

errorfunc:                              ; ...
                mov     al, 1           ; error_invalid_function
                jmp     SYS_RET_ERR

; =============== S U B R O U T I N E =======================================


StrCmp          proc near               ; ...
                push    si
                push    di
                push    ax

Cmplp:                                  ; ...
                lodsb
                call    UCase           ; convert to upper case
                call    PATHCHRCMP      ; convert '/' to '\'
                mov     ah, al
                mov     al, es:[di]
                inc     di
                call    UCase
                call    PATHCHRCMP
                cmp     ah, al
                jnz     short PopRet    ; Strings dif
                or      al, al
                jnz     short Cmplp     ; More string

PopRet:                                 ; ...
                pop     ax
                pop     di
                pop     si
                retn
StrCmp          endp


; =============== S U B R O U T I N E =======================================


StrCpy          proc near               ; ...
                push    ax

CPYLoop:                                ; ...
                lodsb
                call    UCase           ; convert to upper case
                call    PATHCHRCMP      ; convert / to \
                stosb
                or      al, al
                jnz     short CPYLoop
                pop     ax
                retn
StrCpy          endp


; =============== S U B R O U T I N E =======================================


FStrCpy         proc near               ; ...
                push    ax

FCPYLoop:                               ; ...
                lodsb
                stosb
                or      al, al
                jnz     short FCPYLoop
                pop     ax
                retn
FStrCpy         endp


; =============== S U B R O U T I N E =======================================


StrLen          proc near               ; ...
                push    di
                push    ax
                mov     cx, 65535       ; -1 ; 0FFFFh
                xor     al, al
                repne scasb
                not     cx
                pop     ax
                pop     di
                retn
StrLen          endp


; =============== S U B R O U T I N E =======================================


DStrLen         proc near               ; ...
                call    XCHGP
                call    StrLen
                call    XCHGP
                retn
DStrLen         endp


; =============== S U B R O U T I N E =======================================


XCHGP           proc near               ; ...
                push    ds
                push    es
                pop     ds
                pop     es
                xchg    si, di

xchgp_retn:                             ; ...
                retn
XCHGP           endp


; =============== S U B R O U T I N E =======================================


Idle            proc near               ; ...
                cmp     ss:FSHARING, 0
                jnz     short xchgp_retn
                push    cx
                mov     cx, ss:RetryLoop
                jcxz    short Idle3

Idle1:                                  ; ...
                push    cx
                xor     cx, cx

Idle2:                                  ; ...
                loop    Idle2
                pop     cx
                loop    Idle1

Idle3:                                  ; ...
                pop     cx
                retn
Idle            endp


; =============== S U B R O U T I N E =======================================

; Attributes: bp-based frame

TableDispatch   proc near               ; ...

TFrame.Index    = byte ptr  4
TFrame.Tab      = word ptr  6

                push    bp
                mov     bp, sp
                push    bx
                mov     bx, [bp+TFrame.Tab]
                mov     bl, cs:[bx]
                cmp     [bp+TFrame.Index], bl
                jnb     short TableError
                mov     bl, [bp+TFrame.Index]
                xor     bh, bh
                shl     bx, 1
                inc     bx
                add     bx, [bp+TFrame.Tab]
                mov     bx, cs:[bx]
                mov     [bp+TFrame.Tab], bx
                pop     bx
                pop     bp
                add     sp, 4
                retn
; ---------------------------------------------------------------------------

TableError:                             ; ...
                pop     bx
                pop     bp
                retn    6
TableDispatch   endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


TestNet         proc near               ; ...
                mov     es, cs:DosDSeg
                les     di, es:THISCDS
                cmp     di, 0FFFFh      ; -1
                jz      short CMCRet    ; UNC? carry is clear
                test    byte ptr es:[di+44h], 80h ; [ES:DI+curdir.flags+1],
                                        ; (curdir_isnet>>8)
                jnz     short CMCRet    ; jump has carry clear
                retn                    ; carry is clear
; ---------------------------------------------------------------------------

CMCRet:                                 ; ...
                cmc
                retn
TestNet         endp


; =============== S U B R O U T I N E =======================================


IsSFTNet        proc near               ; ...
                test    byte ptr es:[di+6], 80h ; [ES:DI+SF_ENTRY.sf_flags+1],
                                        ; (sf_isnet>>8)
                retn
IsSFTNet        endp

; ---------------------------------------------------------------------------

FastInit:                               ; ...
                push    es
                mov     es, cs:DosDSeg
                mov     di, offset FastTable_2 ; points to fastxxx entry
                dec     bx              ; decrement index
                mov     dx, bx
                shl     bx, 1
                shl     bx, 1           ; each entry is DWORD
                add     di, bx
                mov     ax, es:[di+2]
                mov     cx, cs          ; get DOS segment
                cmp     ax, cx          ; first time installed ?
                jz      short ok_install ; yes
                or      ax, ax
                stc
                jnz     short FSret     ; already installed !

ok_install:                             ; ...
                cmp     si, 0FFFFh      ; Query only ?
                jz      short FSret     ; yes
                mov     cx, ds          ; get FASTXXX entry segment
                mov     es:[di+2], cx   ; initialize routine entry
                                        ; initialize routine offset
                mov     es:[di], si
                mov     di, offset FastOpenFlg ; FastFlg
                add     di, dx          ; index to a FASTXXX flag
                or      byte ptr es:[di], 80h ; Fast_yes
                                        ; indicate installed

FSret:                                  ; ...
                pop     es
                retn
; ---------------------------------------------------------------------------

FastRet:                                ; ...
                stc
                sbb     ax, ax          ; AX = -1, CF = 1
                retf
; ---------------------------------------------------------------------------

NLS_OPEN:                               ; ...
                mov     al, cl          ; set up correct interface for $OPEN
                call    $OPEN
                retn
; ---------------------------------------------------------------------------

NLS_LSEEK:                              ; ...
                push    ss:USER_SP      ; save user stack
                push    ss:USER_SS
                call    Fake_User_Stack
                mov     ax, bp          ; set up correct interface for $LSEEK
                call    $LSEEK

NLS_SEEK_RET:                           ; ...
                pop     ss:USER_SS      ; restore user stack
                pop     ss:USER_SP
                retn

; =============== S U B R O U T I N E =======================================


Fake_User_Stack proc near               ; ...
                mov     ax, ss:USER_SP_2F ; replace with INT 2Fh stack
                mov     ss:USER_SP, ax
                mov     ax, ss
                mov     ss:USER_SS, ax
                retn
Fake_User_Stack endp

; ---------------------------------------------------------------------------

GetDevList:                             ; ...
                mov     si, offset SysInitTable
                mov     ds, cs:DosDSeg
                lds     si, [si]
                mov     ax, [si+22h]    ; [SI+SYSI.DEV]
                mov     bx, [si+24h]    ; [SI+SYSI.DEV+2]
                retn
; ---------------------------------------------------------------------------

NLS_IOCTL:                              ; ...
                push    ss:USER_SP
                push    ss:USER_SS
                call    Fake_User_Stack
                mov     ax, bp          ; set up correct interface for $IOCTL
                call    $IOCTL
                jmp     short NLS_SEEK_RET
; ---------------------------------------------------------------------------

NLS_GETEXT:                             ; ...
                mov     ax, ss:EXTERR   ; return extended error

MSG_RETRIEVAL:                          ; ...
                retn

; =============== S U B R O U T I N E =======================================


ECritDisk       proc near               ; ...
                push    cx
                mov     ch, 0
                mov     cl, ss:redir_patch
                jcxz    short ECritDisk_3
                pop     cx
                push    ax
                mov     ax, 8001h

ECritDisk_1:                            ; ...
                push    cx
                mov     ch, 0
                mov     cl, ss:IsWin386
                jcxz    short ECritDisk2
                pop     cx
                int     2Ah             ; Microsoft Networks - BEGIN DOS CRITICAL SECTION
                                        ; AL = critical section number (00h-0Fh)
                pop     ax
                retn
; ---------------------------------------------------------------------------

ECritDisk2:                             ; ...
                push    es
                mov     cx, 0
                mov     es, cx
                assume es:DOSCODE
                pushf                   ; simulate INT 2Ah
                call    es:00A8h        ; call far (INT 2Ah vector)
                pop     es
                assume es:nothing
                pop     cx
                pop     ax
                retn
; ---------------------------------------------------------------------------

ECritDisk_3:                            ; ...
                pop     cx
                retn
ECritDisk       endp


; =============== S U B R O U T I N E =======================================


LCritDisk       proc near               ; ...
                push    cx
                mov     ch, 0
                mov     cl, ss:redir_patch
                jcxz    short ECritDisk_3
                pop     cx
                push    ax
                mov     ax, 8101h
                jmp     short ECritDisk_1
LCritDisk       endp


; =============== S U B R O U T I N E =======================================


ECritDevice     proc near               ; ...
                push    cx
                mov     ch, 0
                mov     cl, ss:redir_patch
                jcxz    short ECritDisk_3
                pop     cx
                push    ax
                mov     ax, 8002h
                jmp     short ECritDisk_1
ECritDevice     endp


; =============== S U B R O U T I N E =======================================


LCritDevice     proc near               ; ...
                push    cx
                mov     ch, 0
                mov     cl, ss:redir_patch
                jcxz    short ECritDisk_3
                pop     cx
                push    ax
                mov     ax, 8102h
                jmp     short ECritDisk_1
LCritDevice     endp


; =============== S U B R O U T I N E =======================================


$STD_CON_INPUT_NO_ECHO proc near        ; ...
                push    ds              ; Input character from console, no echo
                push    si

INTEST:                                 ; ...
                call    near ptr STATCHK
                jnz     short GET
                cmp     ss:PRINTER_FLAG, 0 ; is printer idle?
                jnz     short no_sys_wait
                mov     ah, 5           ; get input status with system wait
                call    IOFUNC

no_sys_wait:                            ; ...
                mov     ah, 84h
                int     2Ah             ; Microsoft Networks - KEYBOARD BUSY LOOP
                cmp     byte ptr ss:DATE_FLAG, 0FFh ; date is updated may be every
                jnz     short NoUpdate  ; 255 x ? ms if no one calls
                push    ax
                push    bx
                push    cx
                push    dx
                push    ds
                push    ss
                pop     ds
                assume ds:DOSCODE
                xor     ax, ax
                call    Save_Restore_Packet ; save DEVCALL packet
                call    READTIME
                mov     ax, 1
                call    Save_Restore_Packet ; restore DEVCALL packet
                pop     ds
                assume ds:nothing
                pop     dx
                pop     cx
                pop     bx
                pop     ax

NoUpdate:                               ; ...
                inc     ss:DATE_FLAG
                jmp     short INTEST
; ---------------------------------------------------------------------------

GET:                                    ; ...
                xor     ah, ah
                call    IOFUNC
                pop     si
                pop     ds
                mov     ss:SCAN_FLAG, 0
                cmp     al, 0           ; extended code ?
                jnz     short noscan
                inc     ss:SCAN_FLAG    ; set this flag for ALT_Q key

noscan:                                 ; ...
                retn
$STD_CON_INPUT_NO_ECHO endp

; ---------------------------------------------------------------------------

$STD_CON_STRING_OUTPUT:                 ; ...
                mov     si, dx          ; Console String Output

NEXT_STR1:                              ; ...
                lodsb
                cmp     al, 24h ; '$'
                jz      short noscan
                call    OUTT
                jmp     short NEXT_STR1

; =============== S U B R O U T I N E =======================================


$STD_CON_STRING_INPUT proc near         ; ...
                push    ss              ; Input Line from Console
                pop     es
                assume es:DOSCODE
                mov     si, dx
                xor     ch, ch          ; 0
                lodsw
                or      al, al
                jz      short noscan    ; Buffer is 0 length!!?
                mov     bl, ah          ; Init template counter
                mov     bh, ch
                cmp     al, bl
                jbe     short NOEDIT    ; If length of buffer inconsistent
                                        ;  with contents
                cmp     byte ptr [bx+si], 0Dh ; c_CR
                jz      short EDITON    ; If CR correctly placed EDIT is OK

NOEDIT:                                 ; ...
                mov     bl, ch          ; Reset buffer

EDITON:                                 ; ...
                mov     dl, al
                dec     dx              ; DL is # of bytes we can put in the buffer
$STD_CON_STRING_INPUT endp

; START OF FUNCTION CHUNK FOR FINDOLD

NEWLIN:                                 ; ...
                mov     al, ss:CARPOS
                mov     ss:STARTPOS, al ; Remember position in raw buffer
                push    si
                mov     di, offset INBUF ; Build the new line here
                mov     ss:INSMODE, ch  ; Insert mode off
                mov     bh, ch          ; No chars from template yet
                mov     dh, ch          ; No chars to new line yet
                call    $STD_CON_INPUT_NO_ECHO ; Get first char
                cmp     al, 0Ah         ; Linefeed ; c_LF
                jnz     short GOTCH

GETCH:                                  ; ...
                call    $STD_CON_INPUT_NO_ECHO

GOTCH:                                  ; ...
                cmp     al, 6           ; Ignore ^F
                jz      short GETCH
                cmp     al, cs:ESCCHAR  ; function-key lead byte ?
                jz      short ESCAPE    ; change reserved keyword
                cmp     al, 7Fh         ; c_DEL ; destructive backspace
                jz      short BACKSP
                cmp     al, 8           ; c_BS ; destructive backspaces
                jz      short BACKSP
                cmp     al, 0Dh         ; c_CR ; CR terminates the line.
                jz      short ENDLIN
                cmp     al, 0Ah         ; c_LF ; LF goes to a new line
                jz      short PHYCRLF   ; and keeps on reading.
                cmp     al, cs:CANCHAR  ; ^X (or ESC) deletes the line
                jz      short KILNEW    ;  and starts over

SAVCH:                                  ; ...
                cmp     dh, dl
                jnb     short BUFFUL    ; buffer is full
                stosb                   ; save the input character
                inc     dh              ; increment count in buffer
                call    BUFOUT          ; Print control chars nicely
                cmp     ss:INSMODE, 0
                jnz     short GETCH     ; insertmode => don't advance template
                cmp     bh, bl
                jnb     short GETCH     ; no more characters in template
                inc     si              ; Skip to next char in template
                inc     bh              ; remember position in template
                jmp     short GETCH
; ---------------------------------------------------------------------------

BUFFUL:                                 ; ...
                mov     al, 7           ; Bell to signal full buffer
                call    OUTT
                jmp     short GETCH
; ---------------------------------------------------------------------------

ESCAPE:                                 ; ...
                jmp     OEMFunctionKey  ; let the OEM's handle the key dispatch
; ---------------------------------------------------------------------------

ENDLIN:                                 ; ...
                stosb                   ; Put the CR in the buffer
                call    OUTT            ; Echo it
                pop     di              ; Get start of user buffer
                mov     [di-1], dh      ; Tell user how many bytes
                inc     dh              ; DH is length including CR

COPYNEW:                                ; ...
                push    ds              ; XCHG ES,DS
                push    es
                pop     ds
                assume ds:DOSCODE
                pop     es
                assume es:nothing
                mov     si, offset INBUF
                mov     cl, dh          ; set up count
                rep movsb               ; Copy final line to user buffer
; END OF FUNCTION CHUNK FOR FINDOLD

OLDBAK_RETN:                            ; ...
                retn
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR FINDOLD

PHYCRLF:                                ; ...
                call    CRLF            ; Output a CRLF to the user screen
                                        ; and do NOT store it into the buffer

GETCH_j:                                ; ...
                jmp     short GETCH
; END OF FUNCTION CHUNK FOR FINDOLD
; ---------------------------------------------------------------------------

LineDel:                                ; ...
                or      dh, dh          ; Delete the previous line
                jz      short GETCH
                call    BackSpace
                jmp     short LineDel
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR FINDOLD

KILNEW:                                 ; ...
                mov     al, 5Ch ; '\'
                call    OUTT            ; Print the CANCEL indicator
                pop     si              ; Remember start of edit buffer

PUTNEW:                                 ; ...
                call    CRLF            ; Go to next line on screen
                mov     al, ss:STARTPOS
                call    TAB             ; Tab over
                jmp     NEWLIN          ; Start over again
; ---------------------------------------------------------------------------

BACKSP:                                 ; ...
                call    BackSpace       ; Destructively back up one char position
                jmp     short GETCH_j
; END OF FUNCTION CHUNK FOR FINDOLD

; =============== S U B R O U T I N E =======================================


BackSpace       proc near               ; ...
                or      dh, dh
                jz      short OLDBAK    ; No chars in line,
                                        ;  do nothing to line
                call    BACKUP          ; Do the backup
                mov     al, es:[di]     ; Get the deleted char
                cmp     al, 20h ; ' '   ; Was a normal char
                jnb     short OLDBAK
                cmp     al, 9
                jz      short BAKTAB    ; Was a tab, fix up users display
                cmp     al, 15h         ; "U"-"@" ; ctrl-U is a section symbol
                                        ;  not ^U
                jz      short OLDBAK
                cmp     al, 14h         ; "T"-"@" ; ctrl-T is a paragraphs symbol
                                        ;  not ^T
                jz      short OLDBAK
                call    BACKMES

OLDBAK:                                 ; ...
                cmp     ss:INSMODE, 0
                jnz     short OLDBAK_RETN ; In insert mode, done
                or      bh, bh
                jz      short OLDBAK_RETN ;
                                        ; Not advanced in template,
                                        ;  stay where we are
                dec     bh              ; Go back in template
                dec     si
                retn
; ---------------------------------------------------------------------------

BAKTAB:                                 ; ...
                push    di
                dec     di              ; Back up one char
                std                     ; Go backward
                mov     cl, dh          ; Number of chars currently in line
                mov     al, 20h ; ' '
                push    bx
                mov     bl, 7           ; Max
                jcxz    short FIGTAB    ; At start, do nothing

FNDPOS:                                 ; ...
                scasb                   ; Look back
                jbe     short CHKCNT
                cmp     byte ptr es:[di+1], 9
                jz      short HAVTAB    ; Found a tab
                dec     bl              ; Back one char if non tab control char

CHKCNT:                                 ; ...
                loop    FNDPOS

FIGTAB:                                 ; ...
                sub     bl, ss:STARTPOS

HAVTAB:                                 ; ...
                sub     bl, dh
                add     cl, bl
                and     cl, 7           ; CX has correct number to erase
                cld                     ; Back to normal
                pop     bx
                pop     di
                jz      short OLDBAK    ; Nothing to erase

TABBAK:                                 ; ...
                call    BACKMES
                loop    TABBAK          ; Erase correct number of chars
                jmp     short OLDBAK
BackSpace       endp


; =============== S U B R O U T I N E =======================================


BACKUP          proc near               ; ...
                dec     dh              ; Back up in line
                dec     di
BACKUP          endp


; =============== S U B R O U T I N E =======================================


BACKMES         proc near               ; ...
                mov     al, 8           ; c_BS ; Backspace
                call    OUTT
                mov     al, 20h ; ' '   ; SPACE char ; Erase
                call    OUTT
                mov     al, 8           ; Backspace
                jmp     OUTT            ; Done
BACKMES         endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR FINDOLD

TWOESC:                                 ; ...
                mov     al, cs:ESCCHAR  ; User really wants an ESC character
                                        ;  in his line
                jmp     SAVCH
; ---------------------------------------------------------------------------

COPYLIN:                                ; ...
                mov     cl, bl          ; Total size of template
                sub     cl, bh          ; Minus position in template,
                                        ;  is number to move
                jmp     short COPYEACH
; ---------------------------------------------------------------------------

COPYSTR:                                ; ...
                call    FINDOLD         ; Find the char
                jmp     short COPYEACH  ; Copy up to it
; ---------------------------------------------------------------------------

COPYONE:                                ; ...
                mov     cl, 1

COPYEACH:                               ; ...
                mov     ss:INSMODE, 0   ; All copies turn off insert mode
                cmp     dh, dl
                jz      short GETCH2    ; At end of line, can't do anything
                cmp     bh, bl
                jz      short GETCH2    ; At end of template, can't do anything
                lodsb
                stosb
                call    BUFOUT
                inc     bh              ; Ahead in template
                inc     dh              ; Ahead in line
                loop    COPYEACH

GETCH2:                                 ; ...
                jmp     GETCH
; ---------------------------------------------------------------------------

SKIPONE:                                ; ...
                cmp     bh, bl
                jz      short GETCH2    ; At end of template
                inc     bh              ; Ahead in template
                inc     si
                jmp     short GETCH2
; ---------------------------------------------------------------------------

SKIPSTR:                                ; ...
                call    FINDOLD         ; Find out how far to go
                add     si, cx          ; Go there
                add     bh, cl
                jmp     short GETCH2
; END OF FUNCTION CHUNK FOR FINDOLD

; =============== S U B R O U T I N E =======================================


FINDOLD         proc near               ; ...

; FUNCTION CHUNK AT 4967 SIZE 00000019 BYTES
; FUNCTION CHUNK AT 58F1 SIZE 0000007B BYTES
; FUNCTION CHUNK AT 596D SIZE 00000005 BYTES
; FUNCTION CHUNK AT 597B SIZE 00000018 BYTES
; FUNCTION CHUNK AT 5A04 SIZE 00000042 BYTES

                call    $STD_CON_INPUT_NO_ECHO
                cmp     al, cs:ESCCHAR  ; did he type a function key?
                jnz     short FINDSETUP ; no, set up for scan
                call    $STD_CON_INPUT_NO_ECHO ; eat next char
                jmp     short NOTFND    ; go try again
; ---------------------------------------------------------------------------

FINDSETUP:                              ; ...
                mov     cl, bl
                sub     cl, bh          ; CX is number of chars to end of template
                jz      short NOTFND    ; At end of template
                dec     cx              ; Cannot point past end, limit search
                jz      short NOTFND    ; If only one char in template, forget it
                push    es
                push    ds
                pop     es
                assume es:DOSCODE
                push    di
                mov     di, si          ; Template to ES:DI
                inc     di
                repne scasb             ; Look
                pop     di
                pop     es
                assume es:nothing
                jnz     short NOTFND    ; Didn't find the char
                not     cl              ; Turn how far to go into how far we went
                add     cl, bl          ; Add size of template
                sub     cl, bh          ; Subtract current pos,
                                        ;  result distance to skip

FINDOLD_RETN:                           ; ...
                retn
; ---------------------------------------------------------------------------

NOTFND:                                 ; ...
                pop     bp              ; Chuck return address

GETCH2_j:                               ; ...
                jmp     short GETCH2
; ---------------------------------------------------------------------------

REEDIT:                                 ; ...
                mov     al, 40h ; '@'   ; Output re-edit character
                call    OUTT
                pop     di
                push    di
                push    es
                push    ds
                call    COPYNEW         ; Copy current line into template
                pop     ds
                assume ds:nothing
                pop     es
                pop     si
                mov     bl, dh          ; Size of line is new size template
                jmp     PUTNEW          ; Start over again
; ---------------------------------------------------------------------------

EXITINS:                                ; ...
                not     ss:INSMODE      ; ENTERINS
                jmp     short GETCH2_j
; ---------------------------------------------------------------------------

CTRLZ:                                  ; ...
                mov     al, 1Ah         ; "Z"-"@"
                jmp     SAVCH
FINDOLD         endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


CRLF            proc near               ; ...
                mov     al, 0Dh         ; c_CR
                call    OUTT
                mov     al, 0Ah         ; c_LF
                jmp     OUTT
CRLF            endp

; ---------------------------------------------------------------------------

$RAW_CON_IO:                            ; ...
                mov     al, dl          ; Input/Output raw char from console, no echo
                cmp     al, 0FFh        ; -1 if input
                jnz     short RAWOUT
                les     di, dword ptr ss:USER_SP ; Get pointer to register save area
                xor     bx, bx
                call    GET_IO_SFT
                jb      short FINDOLD_RETN
                mov     ah, 1
                call    IOFUNC
                jnz     short RESFLG
                call    SPOOLINT
                or      byte ptr es:[di+16h], 40h ; [ES:DI+user_env.user_F],40h
                                        ; Set user's zero flag
                xor     al, al

RET17:                                  ; ...
                retn
; ---------------------------------------------------------------------------

RESFLG:                                 ; ...
                and     byte ptr es:[di+16h], 0BFh ; [ES:DI+user_env.user_F],0FFh-40h
                                        ; Reset user's zero flag

rci0:                                   ; ...
                call    SPOOLINT

$RAW_CON_INPUT:                         ; ...
                push    bx
                xor     bx, bx
                call    GET_IO_SFT
                pop     bx
                jb      short RET17
                mov     ah, 1
                call    IOFUNC
                jnz     short rci5
                mov     ah, 84h
                int     2Ah             ; Microsoft Networks - KEYBOARD BUSY LOOP
                jmp     short rci0
; ---------------------------------------------------------------------------

rci5:                                   ; ...
                xor     ah, ah
                call    IOFUNC
                retn

; =============== S U B R O U T I N E =======================================


RAWOUT          proc near               ; ...
                push    bx
                mov     bx, 1
                call    GET_IO_SFT
                jb      short RAWRET1
                mov     bx, [si+5]      ; [SI+SF_ENTRY.sf_flags]
                                        ; DS set up by get_io_sft
                and     bx, 8080h       ; sf_isnet+devid_device
                cmp     bx, 80h         ; devid_device
                jnz     short RAWNORM
                push    ds
                lds     bx, [si+7]      ; [SI+SF_ENTRY.sf_devptr]
                                        ; output to special?
                test    byte ptr [bx+4], 10h ; ISSPEC
                pop     ds
                jz      short RAWNORM   ; if not, do normally
                push    ds
                xor     bx, bx
                mov     ds, bx
                assume ds:DOSCODE
                pushf                   ; simulate INT 29h
                call    ds:00A4h        ; call far [29h*4] ; call far [00A4h]
                pop     ds
                assume ds:nothing

RAWRET:                                 ; ...
                clc

RAWRET1:                                ; ...
                pop     bx

RAWRET2:                                ; ...
                retn
; ---------------------------------------------------------------------------

RAWNORM:                                ; ...
                call    RAWOUT3
                jmp     short RAWRET
RAWOUT          endp


; =============== S U B R O U T I N E =======================================


RAWOUT2         proc near               ; ...
                call    GET_IO_SFT      ; Output the character in AL to handle in BX
                jb      short RAWRET2
RAWOUT2         endp


; =============== S U B R O U T I N E =======================================


RAWOUT3         proc near               ; ...
                push    ax
                jmp     short RAWOSTRT
; ---------------------------------------------------------------------------

ROLP:                                   ; ...
                call    SPOOLINT
                or      ss:DOS34_FLAG, 200h ; [ss:DOS34_FLAG],CTRL_BREAK_FLAG
                call    DSKSTATCHK      ; check control break

RAWOSTRT:                               ; ...
                mov     ah, 3
                call    IOFUNC
                jz      short ROLP
                inc     ax              ; fail on I24 if ax = -1
                pop     ax
                jz      short nosend    ; yes, do not send char
                mov     ah, 2
                call    IOFUNC

nosend:                                 ; ...
                clc                     ; Clear carry indicating successful
                retn
RAWOUT3         endp


; =============== S U B R O U T I N E =======================================


Save_Restore_Packet proc near           ; ...
                push    ds
                push    es
                push    si
                push    di
                mov     di, offset FAKE_STACK_2F
                mov     si, offset DEVCALL_REQLEN ; DEVCALL
                or      ax, ax
                jz      short save_packet
                xchg    si, di

save_packet:                            ; ...
                push    ss
                pop     ds
                assume ds:DOSCODE
                push    ss
                pop     es
                assume es:DOSCODE
                mov     cx, 11
                rep movsw
                pop     di
                pop     si
                pop     es
                assume es:nothing
                pop     ds
                assume ds:nothing
                retn
Save_Restore_Packet endp

; ---------------------------------------------------------------------------

$STD_CON_INPUT:                         ; ...
                call    $STD_CON_INPUT_NO_ECHO
                push    ax
                call    OUTT
                pop     ax

CON_INPUT_RETN:                         ; ...
                retn
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR OUTT

outch2:                                 ; ...
                push    ax
                call    near ptr STATCHK
                pop     ax
                jmp     short OUTSKIP
; END OF FUNCTION CHUNK FOR OUTT
; ---------------------------------------------------------------------------

$STD_CON_OUTPUT:                        ; ...
                mov     al, dl

; =============== S U B R O U T I N E =======================================


OUTT            proc near               ; ...

; FUNCTION CHUNK AT 5B69 SIZE 00000007 BYTES
; FUNCTION CHUNK AT 5BF1 SIZE 00000008 BYTES
; FUNCTION CHUNK AT 5BFC SIZE 00000008 BYTES
; FUNCTION CHUNK AT 5C51 SIZE 00000007 BYTES

                cmp     al, 20h ; ' '
                jb      short CTRLOUT
                cmp     al, 7Fh
                jz      short OUTCH
                inc     ss:CARPOS

OUTCH:                                  ; ...
                push    ds
                push    si
                inc     ss:CHARCO       ; invoke statchk...
                and     ss:CHARCO, 3Fh  ; every 64th character
                jz      short outch2

OUTSKIP:                                ; ...
                call    RAWOUT          ; output the character
                pop     si
                pop     ds
                test    ss:PFLAG, 0FFh  ; -1
                jz      short CON_INPUT_RETN
                push    bx
                push    ds
                push    si
                mov     bx, 1
                call    GET_IO_SFT
                jb      short TRIPOPJ
                mov     bx, [si+5]      ; [SI+SF_ENTRY.sf_flags]
                test    bh, 80h         ; (sf_isnet>>8)
                jnz     short TRIPOPJ
                test    bl, 80h         ; devid_device
                jz      short TRIPOPJ
                mov     bx, 4
                call    GET_IO_SFT      ; GET_IO_SFT will set up DS:SI to sft entry
                jb      short TRIPOPJ
                test    byte ptr [si+6], 8 ; [SI+SF_ENTRY.sf_flags+1],
                                        ; (sf_net_spool>>8) ; StdPrn redirected?
                jz      short LISSTRT2J
                mov     ss:PFLAG, 0     ; If a spool, NEVER echo

TRIPOPJ:                                ; ...
                jmp     TRIPOP
; ---------------------------------------------------------------------------

LISSTRT2J:                              ; ...
                jmp     LISSTRT2
; ---------------------------------------------------------------------------

CTRLOUT:                                ; ...
                cmp     al, 0Dh         ; c_CR
                jz      short ZERPOS
                cmp     al, 8           ; c_BS
                jz      short BACKPOS
                cmp     al, 9           ; c_HT
                jnz     short OUTCH
                mov     al, ss:CARPOS
                or      al, 0F8h
                neg     al
OUTT            endp


; =============== S U B R O U T I N E =======================================


TAB             proc near               ; ...
                push    cx
                mov     cl, al
                mov     ch, 0
                jcxz    short POPTAB

TABLP:                                  ; ...
                mov     al, 20h ; ' '
                call    OUTT
                loop    TABLP

POPTAB:                                 ; ...
                pop     cx
                retn
TAB             endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR OUTT

ZERPOS:                                 ; ...
                mov     ss:CARPOS, 0
                jmp     short OUTCH
; END OF FUNCTION CHUNK FOR OUTT
; ---------------------------------------------------------------------------

j_OUTT:                                 ; ...
                jmp     OUTT
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR OUTT

BACKPOS:                                ; ...
                dec     ss:CARPOS
                jmp     OUTCH
; END OF FUNCTION CHUNK FOR OUTT

; =============== S U B R O U T I N E =======================================


BUFOUT          proc near               ; ...
                cmp     al, 20h ; ' '
                jnb     short j_OUTT    ; Normal char
                cmp     al, 9
                jz      short j_OUTT    ; OUT knows how to expand tabs
                cmp     al, 15h         ; "U"-"@" ; turn ^U to section symbol
                jz      short CTRLU
                cmp     al, 14h         ; "T"-"@" ; turn ^T to paragraph symbol
                jz      short CTRLU
                push    ax
                mov     al, 5Eh ; '^'
                call    OUTT            ; Print '^' before control chars
                pop     ax
                or      al, 40h         ; Turn it into Upper case mate

CTRLU:                                  ; ...
                call    OUTT

BUFOUT_RETN:                            ; ...
                retn
BUFOUT          endp

; ---------------------------------------------------------------------------

$STD_AUX_INPUT:                         ; ...
                call    near ptr STATCHK
                mov     bx, 3
                call    GET_IO_SFT
                jb      short BUFOUT_RETN
                jmp     short TAISTRT
; ---------------------------------------------------------------------------

AUXILP:                                 ; ...
                call    SPOOLINT

TAISTRT:                                ; ...
                mov     ah, 1
                call    IOFUNC
                jz      short AUXILP
                xor     ah, ah
                call    IOFUNC
                retn
; ---------------------------------------------------------------------------

$STD_AUX_OUTPUT:                        ; ...
                push    bx
                mov     bx, 3
                jmp     short SENDOUT
; ---------------------------------------------------------------------------

$STD_PRINTER_OUTPUT:                    ; ...
                push    bx
                mov     bx, 4

SENDOUT:                                ; ...
                mov     al, dl
                push    ax
                call    near ptr STATCHK
                pop     ax
                push    ds
                push    si
; START OF FUNCTION CHUNK FOR OUTT

LISSTRT2:                               ; ...
                call    RAWOUT2

TRIPOP:                                 ; ...
                pop     si
                pop     ds
                pop     bx

SCIS_RETN:                              ; ...
                retn
; END OF FUNCTION CHUNK FOR OUTT
; ---------------------------------------------------------------------------

$STD_CON_INPUT_STATUS:                  ; ...
                call    near ptr STATCHK
                mov     al, 0           ; no xor!!
                jz      short SCIS_RETN
                dec     ax              ; -1
                retn
; ---------------------------------------------------------------------------

$STD_CON_INPUT_FLUSH:                   ; ...
                push    ax
                push    dx
                xor     bx, bx
                call    GET_IO_SFT
                jb      short BADJFNCON
                mov     ah, 4
                call    IOFUNC

BADJFNCON:                              ; ...
                pop     dx
                pop     ax
                mov     ah, al
                cmp     al, 1
                jz      short REDISPJ
                cmp     al, 6
                jz      short REDISPJ
                cmp     al, 7
                jz      short REDISPJ
                cmp     al, 8
                jz      short REDISPJ
                cmp     al, 0Ah
                jz      short REDISPJ
                mov     al, 0
                retn
; ---------------------------------------------------------------------------

REDISPJ:                                ; ...
                cli
                jmp     REDISP
; ---------------------------------------------------------------------------

$GET_FCB_POSITION:                      ; ...
                call    GetExtended     ; point to FCB
                call    GetExtent       ; DX:AX is current record
                mov     [si+21h], ax    ; [SI+SYS_FCB.RR] ; drop in low order piece
                mov     [si+23h], dl    ; [SI+SYS_FCB.RR+2] ; drop in high order piece
                cmp     word ptr [si+0Eh], 64 ; [SI+SYS_FCB.RECSIZ]
                jnb     short GetFCBBye
                mov     [si+24h], dh    ; [SI+SYS_FCB.RR+2+1]
                                        ; Set 4th byte only if record size < 64

GetFCBBye:                              ; ...
                jmp     NO_OP           ; jmp FCB_RET_OK
; ---------------------------------------------------------------------------

$FCB_DELETE:                            ; ...
                mov     di, offset OPENBUF
                call    TransFCB        ; convert FCB to path
                jb      short BadPath   ; signal no deletions
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    DOS_DELETE
                jnb     short GetFCBBye ; do a good return

BadPath:                                ; ...
                jmp     FCB_RET_ERR     ; let someone else signal the error
; ---------------------------------------------------------------------------

$GET_FCB_FILE_LENGTH:                   ; ...
                call    GetExtended     ; get real FCB pointer
                                        ; DX points to Input FCB
                mov     di, offset OPENBUF ; appropriate buffer in DOSDATA
                push    ds              ; save pointer to true FCB
                push    si
                call    TransFCB        ; Trans name DS:DX, sets SATTRIB
                pop     si
                pop     ds
                assume ds:nothing
                jb      short BadPath
                push    ds              ; save pointer
                push    si
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    GET_FILE_INFO   ; grab the info
                pop     si              ; get pointer back
                pop     ds
                assume ds:nothing
                jb      short BadPath   ; invalid something
                mov     dx, bx          ; get high order size
                mov     ax, di          ; get low order size
                mov     bx, [si+0Eh]    ; [SI+SYS_FCB.RECSIZ]
                                        ; get his record size
                or      bx, bx          ; empty record => 0 size for file
                jnz     short GetSize   ; not empty
                mov     bl, 128

GetSize:                                ; ...
                xchg    ax, dx          ; move high order for divide
                xor     dx, dx          ; clear out high
                div     bx
                push    ax              ; save dividend
                mov     ax, di          ; get low order piece
                div     bx
                mov     cx, dx          ; save remainder
                pop     dx              ; get high order dividend
                jcxz    short LengthStore
                add     ax, 1
                adc     dx, 0           ; 32-bit increment

LengthStore:                            ; ...
                mov     [si+21h], ax    ; [SI+SYS_FCB.RR] ; store low order
                mov     [si+23h], dl    ; [SI+SYS_FCB.RR+2] ; store high order
                or      dh, dh
                jz      short GetFCBBye ; not storing insignificant zero
                mov     [si+24h], dh    ; [SI+SYS_FCB.RR+3] ; save that high piece

GoodRet:                                ; ...
                jmp     short GetFCBBye
; ---------------------------------------------------------------------------

$FCB_CLOSE:                             ; ...
                xor     al, al          ; default search attributes
                call    GetExtended     ; DS:SI point to real FCB
                jz      short NoAttr    ; not extended
                mov     al, [si-1]      ; get attributes

NoAttr:                                 ; ...
                mov     ss:ATTRIB, al   ; stash away found attributes
                call    SFTFromFCB
                jb      short GoodRet
                mov     al, es:[di+4]   ; [ES:DI+SF_ENTRY.sf_attr]
                xor     ah, ah
                push    ax
                call    CheckShare
                jnz     short NoStash
                mov     al, ss:ATTRIB
                mov     es:[di+4], al   ; [ES:DI+SF_ENTRY.sf_attr]
                                        ; attempted attribute for close

NoStash:                                ; ...
                push    ds
                lds     ax, [si+14h]    ; [SI+SYS_FCB.FDATE]
                                        ; move in the time and date
                mov     es:[di+0Fh], ax ; [ES:DI+SF_ENTRY.sf_date]
                mov     word ptr es:[di+0Dh], ds ; [ES:DI+SF_ENTRY.sf_time]
                pop     ds
                lds     ax, [si+10h]    ; [SI+SYS_FCB.FILSIZ]
                mov     es:[di+11h], ax ; [ES:DI+SF_ENTRY.sf_size]
                mov     word ptr es:[di+13h], ds ; [ES:DI+SF_ENTRY.sf_size+2]
                or      word ptr es:[di+5], 4000h ; [ES:DI+SF_ENTRY.sf_flags],
                                        ; sf_close_nodate
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    DOS_CLOSE
                les     di, THISSFT
                pop     cx
                mov     es:[di+4], cl   ; [ES:DI+SF_ENTRY.sf_attr]
                                        ; restore SFT attribute
                pushf
                cmp     word ptr es:[di], 0 ; [ES:DI+SF_ENTRY.sf_ref_count],0
                                        ; zero ref count gets blasted
                jnz     short CloseOK
                push    ax
                mov     al, 4Dh ; 'M'
                call    BlastSFT
                pop     ax

CloseOK:                                ; ...
                popf

CloseOK2:                               ; ...
                jnb     short GoodRet
                cmp     al, 6           ; error_invalid_handle
                jz      short GoodRet
                mov     al, 2           ; error_file_not_found

fcb_close_err:                          ; ...
                jmp     FCB_RET_ERR     ; fren90
; ---------------------------------------------------------------------------

$FCB_RENAME:                            ; ...
                call    GetExtended     ; get pointer to real FCB
                push    dx
                mov     al, [si]        ; get drive byte
                add     si, 10h         ; point to destination
                mov     di, offset RENBUF
                push    word ptr [si]
                push    ds
                push    si              ; save source pointer for TransFCB
                mov     [si], al        ; drop in real drive
                mov     dx, si          ; let TransFCB know where the FCB is
                call    TransFCB        ; munch this pathname
                pop     si
                pop     ds
                assume ds:nothing
                pop     word ptr [si]   ; get path back
                pop     dx
                jb      short fcb_close_err
                mov     si, ss:WFP_START
                mov     ss:REN_WFP, si
                mov     di, offset OPENBUF
                call    TransFCB
                jb      short fcb_close_err
                mov     ss:PATHNAMELEN, 67 ; set pathname length to 67
                                        ; DIRSTRLEN = 67
                call    DOS_RENAME
                jb      short fcb_close_err ; fren90
                jmp     short CloseOK2

; =============== S U B R O U T I N E =======================================


SaveFCBInfo     proc near               ; ...
                les     di, ss:THISSFT
                call    IsSFTNet
                jz      short SaveLocal
                mov     ax, es:[di+0Bh] ; [ES:DI+sf_serial_ID]
                mov     [si+1Ch], ax    ; [SI+fcb_netID]
                mov     bl, 80h         ; FCBNETWORK
                jmp     short SaveSFN
; ---------------------------------------------------------------------------

SaveLocal:                              ; ...
                call    CheckShare
                jnz     short SaveShare ; sharer present

SaveNoShare:                            ; no sharer
                test    byte ptr es:[di+5], 80h ;
                                        ; [ES:DI+SF_ENTRY.sf_flags],devid_device
                jnz     short SaveNoShareDev ; Device
                mov     ax, es:[di+1Bh] ; [ES:DI+SF_ENTRY.sf_dirsec]
                mov     [si+1Dh], ax    ; [SI+fcb_nsl_dirsec]
                mov     ax, es:[di+1Dh] ; [es:di+SF_ENTRY.sf_dirsec+2]
                mov     bl, es:[di+4]   ; [es:di+SF_ENTRY.sf_attr]
                mov     bh, bl
                ror     bl, 1
                add     bh, bh
                or      bl, bh
                and     bl, 0C0h
                or      al, bl
                mov     [si+18h], al    ; [si+fcb_sfn] ; sector number = 22 bits
                mov     al, es:[di+1Fh] ; [ES:DI+SF_ENTRY.sf_dirpos]
                                        ; location in sector
                mov     [si+1Fh], al    ; [SI+fcb_nsl_dirpos]
                mov     ax, es:[di+2Bh] ; [es:di+SF_ENTRY.sf_chain] ; .sf_chain ! (MSDOS 6.22)
                                        ; first cluster (32 bit) !?
                mov     [si+1Bh], ax    ; [SI+fcb_nsl_firclus]
                mov     bl, 0

SetFCBBits:                             ; ...
                mov     ax, es:[di+5]   ; [ES:DI+SF_ENTRY.sf_flags]
                and     al, 0C0h        ; mask off drive bits
                or      al, es:[di+2]   ; [ES:DI+SF_ENTRY.sf_mode]
                                        ; stick in open mode
                mov     [si+1Ah], al    ; [SI+fcb_nsl_bits] ; save dirty info
                or      bl, bl
                jz      short SaveNoSFN ; do not save SFN if local file
                jmp     short SaveSFN   ; go and save SFN
; ---------------------------------------------------------------------------

SaveNoShareDev:                         ; ...
                push    es
                les     ax, es:[di+7]   ; [es:di+SF_ENTRY.sf_devptr]
                mov     [si+1Ah], ax    ; [SI+fcb_nsld_drvptr]
                mov     word ptr [si+1Ch], es ; [si+fcb_nsld_drvptr+2]
                pop     es              ; FCBDEVICE
                mov     bl, 40h
                jmp     short SetFCBBits ; go and save SFN
; ---------------------------------------------------------------------------

SaveShare:                              ; ...
                call    ss:ShSave       ; call far [ss:JShare+(10*4)] ; 10 = ShSave

SaveSFN:                                ; ...
                lea     ax, [di-6]      ; [DI-SFT.SFTable]
                sub     ax, word ptr ss:SFTFCB ; Adjust for offset to table.
                push    bx
                mov     bl, 59          ; SF_ENTRY.size
                div     bl
                mov     [si+18h], al    ; [SI+fcb_sfn] ; last used SFN
                pop     bx              ; bx = FCB type (net/Share or local)

SaveNoSFN:                              ; ...
                mov     ax, es:[di+5]   ; [ES:DI+SF_ENTRY.sf_flags] ; get real drive
                and     al, 3Fh
                or      al, bl
                mov     [si+19h], al    ; [SI+fcb_l_drive]
                mov     ax, ss:FCBLRU   ; get lru count
                inc     ax
                mov     es:[di+15h], ax ; [ES:DI+sf_LRU]
                jnz     short SimpleStuff ;
                                        ; lru flag overflowed
                mov     bx, 15h         ; SF_ENTRY.sf_position
                call    ResetLRU

SimpleStuff:                            ; ...
                mov     ss:FCBLRU, ax   ; Set new LRU to AX
                retn
SaveFCBInfo     endp


; =============== S U B R O U T I N E =======================================


ResetLRU        proc near               ; ...
                mov     ax, 8000h
                push    es
                push    di
                les     di, ss:SFTFCB   ; get pointer to head
                mov     cx, es:[di+4]   ; [ES:DI+SFT.SFCount]
                lea     di, [di+6]      ; [DI+SFT.SFTable] ; point at table

ovScan:                                 ; ...
                sub     es:[bx+di], ax  ; decrement lru count
                ja      short ovLoop
                mov     es:[bx+di], ax  ; truncate at 0

ovLoop:                                 ; ...
                add     di, 59          ; SF_ENTRY.size
                loop    ovScan          ; advance to next
                pop     di
                pop     es
                mov     es:[bx+di], ax
                retn
ResetLRU        endp


; =============== S U B R O U T I N E =======================================


LRUFCB          proc near               ; ...
                push    es
                call    save_world
                mov     ds, cs:DosDSeg
                or      al, al          ; Check if regenerate allocation
                jnz     short lru1      ; Try to find SFT to use
                les     di, ds:LocalSFT
                mov     cx, es
                or      cx, di          ; is address == 0?
                jz      short lru1      ; invalid local SFT, find one

gotlocalSFT:                            ; ...
                mov     word ptr ds:THISSFT, di
                mov     word ptr ds:THISSFT+2, es
                clc
                jmp     LRUDone         ; clear up SFT and return
; ---------------------------------------------------------------------------

lru1:                                   ; ...
                les     di, ds:SFTFCB   ; es:di = SF Table for FCBs
                mov     cx, es:[di+4]   ; cx = number of SFTs
                lea     di, [di+6]      ; [di+SFT.SFTable] ; es:di = first SFT
                mov     bx, 0FFFFh      ; (max. LRU value)
                mov     si, bx
                mov     dx, bx
                mov     bp, bx

findSFT:                                ; ...
                or      word ptr es:[di], 0 ; [es:di+SF_ENTRY.sf_ref_count]
                                        ; reference count = 0 ?
                jz      short gotSFT    ; yes, SFT is free
                cmp     word ptr es:[di], 0FFFFh ; [es:di+SF_ENTRY.sf_ref_count],
                                        ; sf_busy
                jz      short gotSFT    ; not busy, can use it
                test    word ptr es:[di+5], 8000h ; [ES:DI+SF_ENTRY.sf_flags],
                                        ; sf_isnet
                jnz     short lru5      ; network SFT, get net/Share LRU
                call    CheckShare
                jnz     short lru5

hackpoint:                              ; ...
                mov     word ptr ds:LocalSFT, di
                mov     word ptr ds:LocalSFT+2, es ; store local SFT address
                or      al, al          ; Is operation = REGEN?
                jz      short gotlocalSFT ; yes, return this SFT for reuse
                cmp     es:[di+15h], bx ; [es:di+sf_LRU],bx ; SFT.LRU < min?
                jnb     short lru4      ; no, skip
                mov     bx, es:[di+15h] ; [es:di+sf_LRU] ; yes, store new min
                mov     si, di          ; store SFT position

lru4:                                   ; ...
                add     di, 59          ; SF_ENTRY.size ; go to next SFT
                loop    findSFT
                dec     cx
                mov     di, si
                cmp     si, cx          ; local SFT available?
                jnz     short gotSFT    ; yes, return it
                mov     di, bp
                cmp     bp, cx          ; net/Share SFT available?
                jnz     short gotnetSFT ; yes, return it
                jmp     short errorbadSFT ; error, no FCB available.
; ---------------------------------------------------------------------------

lru5:                                   ; ...
                cmp     es:[di+15h], dx ; [es:di+sf_LRU],dx ; SFT.LRU < min?
                jnb     short lru4      ; no, skip
                mov     dx, es:[di+15h] ; [es:di+sf_LRU]
                                        ; yes, store new minimum
                mov     bp, di
                jmp     short lru4
; ---------------------------------------------------------------------------

gotSFT:                                 ; ...
                or      al, al
                jz      short hackpoint ; save es:di in LocalSFT
                mov     ax, es
                cmp     word ptr ds:LocalSFT, di ; Offset same?
                jnz     short notinvalid
                cmp     word ptr ds:LocalSFT+2, ax ; Segments same?
                jnz     short notinvalid ; no, no need to invalidate
                xor     ax, ax
                mov     word ptr ds:LocalSFT, ax
                mov     word ptr ds:LocalSFT+2, ax

notinvalid:                             ; ...
                jmp     gotlocalSFT
; ---------------------------------------------------------------------------

gotnetSFT:                              ; ...
                or      al, al
                jnz     short closenet
                mov     word ptr ds:LocalSFT, di ; store local SFT address
                mov     word ptr ds:LocalSFT+2, es

closenet:                               ; ...
                mov     word ptr ds:THISSFT, di ; set thissft
                mov     word ptr ds:THISSFT+2, es

LRUClose:                               ; ...
                cmp     word ptr es:[di], 0 ; [es:di+SF_ENTRY.sf_ref_count]
                                        ; is ref count still <> 0?
                jz      short LRUDone   ; nope, all done
                call    DOS_CLOSE
                jnb     short LRUClose  ; no error => clean up
                cmp     al, 6           ; error_invalid_handle
                jz      short LRUClose

errorbadSFT:                            ; ...
                stc
                jmp     short LRUDead
; ---------------------------------------------------------------------------

LRUDone:                                ; ...
                xor     al, al
                call    BlastSFT        ; fill SFT with 0 (AL), 'C' cleared

LRUDead:                                ; ...
                call    restore_world
                pop     es
                mov     es, cs:DosDSeg
                les     di, es:THISSFT  ; es:di points at allocated SFT
                jb      short LruFCB_err
                retn
; ---------------------------------------------------------------------------

LruFCB_err:                             ; ...
                mov     al, 23h         ; error_FCB_unavailable
                retn
LRUFCB          endp


; =============== S U B R O U T I N E =======================================


RegenCopyName   proc near               ; ...
                lodsb                   ; load character
                call    UCase           ; convert char to upper case
                stosb                   ; store converted character
                loop    RegenCopyName
                retn
RegenCopyName   endp


; =============== S U B R O U T I N E =======================================


FCBRegen        proc near               ; ...

; FUNCTION CHUNK AT 5FFB SIZE 0000006A BYTES

                mov     al, [si+19h]    ; [SI+fcb_l_drive]
                test    al, 80h         ; FCBSPECIAL
                jz      short RegenNoSharing
                call    CheckShare      ; test for sharer
                jnz     short RegenFail ; yep, fail this.
                mov     ax, 1100h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - INSTALLATION CHECK
                                        ; Return: AL = 00h  not installed, OK to install
                                        ; 01h  not installed, not OK to install
                                        ; FFh  installed
                or      al, al          ; is it there?
                jz      short RegenDead ; no, just fail the operation

RegenFail:                              ; ...
                mov     ax, ss:USER_IN_AX
                cmp     ah, 10h         ; FCB_CLOSE
                jz      short RegenDead
                call    FCBHardErr      ; massive hard error

RegenDead:                              ; ...
                stc                     ; carry set

FCBRegen_retn:                          ; ...
                retn
; ---------------------------------------------------------------------------

RegenNoSharing:                         ; ...
                call    CheckShare
                jnz     short RegenFail
                push    ax
                mov     al, 0           ; indicate it is a regen operation
                call    LRUFCB
                pop     ax
                jb      short FCBRegen_retn
                mov     word ptr es:[di+2], 8002h ; [ES:DI+SF_ENTRY.sf_mode],
                                        ; sf_isFCB+open_for_both+SHARING_COMPAT
                and     al, 3Fh         ; get drive number for flags
                cbw
                or      ax, 4000h       ; sf_close_nodate ; normal FCB operation
                mov     cl, [si+1Ah]    ; [SI+fcb_nsl_bits] ; stick in dirty bits.
                mov     ch, cl
                and     ch, 0C0h        ; mask off the dirty/device bits
                or      al, ch
                and     cl, 0Fh         ; access_mask  ; get the mode bits
                mov     es:[di+2], cl   ; [ES:DI+SF_ENTRY.sf_mode]
                mov     es:[di+5], ax   ; [ES:DI+SF_ENTRY.sf_flags],AX ; initial flags
                mov     ax, ss:PROC_ID
                mov     es:[di+31h], ax ; [ES:DI+SF_ENTRY.sf_PID]
                push    ds
                push    si
                push    es
                push    di
                push    ss
                pop     es
                assume es:DOSCODE
                mov     di, offset NAME1
                mov     cx, 8
                inc     si              ; Skip past drive byte to name in FCB
                call    RegenCopyName   ; copy the name to NAME1
                push    ss
                pop     ds
                assume ds:DOSCODE
                mov     ATTRIB, 16h     ; attr_hidden+attr_system+attr_directory
                call    DEVNAME
                pop     di
                pop     es
                assume es:nothing
                pop     si
                pop     ds
                assume ds:nothing
                jb      short RegenFileNoSharing ; not found on device list => file
                mov     es:[di+5], bh   ; [ES:DI+SF_ENTRY.sf_flags] ; device parms
                mov     byte ptr es:[di+4], 0 ; [ES:DI+SF_ENTRY.sf_attr] ; attribute
                lds     si, ss:DEVPT    ; get device driver
FCBRegen        endp


; =============== S U B R O U T I N E =======================================


regen_save_dpb  proc near               ; ...
                mov     es:[di+7], si   ; [ES:DI+SF_ENTRY.sf_devptr]
                mov     word ptr es:[di+9], ds ; [ES:DI+SF_ENTRY.sf_devptr+2]
                retn
regen_save_dpb  endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR FCBRegen

RegenDeadJ:                             ; ...
                jmp     short RegenDead
; ---------------------------------------------------------------------------

RegenFileNoSharing:                     ; ...
                mov     ax, es:[di+5]   ; [ES:DI+SF_ENTRY.sf_flags]
                and     ax, 3Fh
                push    ds
                push    si
                call    FIND_DPB
                call    regen_save_dpb
                pop     si
                pop     ds
                jb      short RegenDeadJ
                mov     ax, [si+1Dh]    ; [SI+fcb_nsl_dirsec]
                mov     es:[di+1Bh], ax ; [ES:DI+SF_ENTRY.sf_dirsec]
                mov     al, [si+18h]    ; [si+fcb_sfn]
                and     al, 0C0h        ; get the 2 attribute bits
                mov     ah, al
                rol     ah, 1
                shr     al, 1
                or      al, ah
                and     al, 3Fh         ; mask off unused bits
                mov     es:[di+4], al   ; [es:di+SF_ENTRY.sf_attr]
                mov     al, [si+18h]    ; [si+fcb_sfn]
                and     al, 3Fh         ; mask off top 2 bits -- attr bits
                sub     ah, ah
                mov     es:[di+1Dh], ax ; [es:di+SF_ENTRY.sf_dirsec+2]
                                        ; update high word
                mov     ax, [si+1Bh]    ; [SI+fcb_nsl_firclus]
                mov     es:[di+2Bh], ax ; [es:di+SF_ENTRY.sf_chain] ; .sf_chain ! (MSDOS 6.22)
                                        ; first cluster (32 bit) !?
                mov     es:[di+35h], ax ; [ES:DI+SF_ENTRY.sf_lstclus]
                xor     ax, ax          ; 0
                mov     es:[di+2Dh], ax ; [es:di+SF_ENTRY.sf_chain+2] ; .sf_chain ! (MSDOS 6.22)
                                        ; high word of first cluster (32 bit) !?
                mov     es:[di+37h], ax ; [ES:DI+SF_ENTRY.sf_lstclus+2]
                mov     al, [si+1Fh]    ; [SI+fcb_nsl_dirpos]
                mov     es:[di+1Fh], al ; [ES:DI+SF_ENTRY.sf_dirpos]
                inc     word ptr es:[di] ; Increment reference count
                call    set_sftfcb_entry ; put SFT entry number in the SFTFCB table
                                        ; as FCB index number
                lea     si, [si+1]      ; [SI+SYS_FCB.name]
                lea     di, [di+20h]    ; [DI+SF_ENTRY.sf_name]
                mov     cx, 11          ; SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
                call    RegenCopyName
                clc
                retn
; END OF FUNCTION CHUNK FOR FCBRegen

; =============== S U B R O U T I N E =======================================


BlastSFT        proc near               ; ...
                call    SFT_FREE
                push    di
                mov     cx, 59          ; SF_ENTRY.size
                rep stosb
                pop     di
                sub     ax, ax          ; 0
                mov     es:[di], ax     ; word [ES:DI+SF_ENTRY.sf_ref_count],0
                mov     es:[di+15h], ax ; %define sf_LRU SF_ENTRY.sf_position
                                        ; word [es:di+sf_LRU],0
                dec     ax              ; -1
                mov     es:[di+17h], ax ; %define sf_OpenAge SF_ENTRY.sf_position+2
                                        ; word [es:di+sf_OpenAge],-1
                retn
BlastSFT        endp


; =============== S U B R O U T I N E =======================================


CheckFCB        proc near               ; ...
                test    byte ptr [si+19h], 0C0h ; [si+fcb_l_drive],
                                        ; FCBNETWORK|FCBSHARE|FCBDEVICE
                jz      short BadSFT
                les     di, ss:SFTFCB
                cmp     es:[di+4], al   ; [ES:DI+SFT.SFCount]
                jb      short BadSFT
                mov     bl, 59
                mul     bl
                lea     di, [di+6]      ; [DI+SFT.SFTable]
                add     di, ax
                mov     ax, ss:PROC_ID
                cmp     es:[di+31h], ax ; [ES:DI+SF_ENTRY.sf_PID]
                jnz     short BadSFT    ; must match process
                cmp     word ptr es:[di], 0 ; [ES:DI+SF_ENTRY.sf_ref_count]
                jz      short BadSFT    ; must also be in use
                mov     al, [si+19h]    ; [SI+fcb_l_drive]
                test    al, 80h         ; FCBSPECIAL ; a special FCB?
                jz      short CheckNoShare ; No. try local or device
                push    ax
                and     al, 0C0h        ; FCBMASK
                cmp     al, 0C0h        ; FCBSHARE ; net FCB?
                pop     ax
                jnz     short CheckNet  ; no
                                        ; yes
                call    ss:ShChk        ; Call far [ss:JShare+(11*4)] ; 11 = ShChk
                jb      short BadSFT

CheckD:                                 ; ...
                and     al, 3Fh
                mov     ah, es:[di+5]   ; [ES:DI+SF_ENTRY.sf_flags]
                and     ah, 3Fh
                cmp     ah, al
                jnz     short BadSFT

CheckD_retn:                            ; ...
                retn
; ---------------------------------------------------------------------------

BadSFT:                                 ; ...
                stc
                retn
; ---------------------------------------------------------------------------

CheckNet:                               ; ...
                mov     ax, [si+1Ch]    ; [SI+fcb_netID]
                cmp     ax, es:[di+0Bh] ; %define sf_serial_ID SF_ENTRY.sf_firclus
                                        ; [ES:DI+sf_serial_ID]
                jnz     short BadSFT
                retn
; ---------------------------------------------------------------------------

CheckNoShare:                           ; ...
                mov     bx, [si+1Ah]    ; [SI+fcb_nsld_drvptr]
                cmp     bx, es:[di+7]   ; [ES:DI+SF_ENTRY.sf_devptr]
                jnz     short BadSFT
                mov     bx, [si+1Ch]    ; [SI+fcb_nsld_drvptr+2]
                cmp     bx, es:[di+9]
                jnz     short BadSFT    ; [ES:DI+SF_ENTRY.sf_devptr+2]
                jmp     short CheckD
CheckFCB        endp


; =============== S U B R O U T I N E =======================================


SFTFromFCB      proc near               ; ...
                push    ax
                push    bx
                mov     al, [si+18h]    ; [SI+fcb_sfn] ; set SFN for check
                call    CheckFCB
                pop     bx
                pop     ax
                mov     word ptr ss:THISSFT, di
                mov     word ptr ss:THISSFT+2, es
                jnb     short Set_SFT   ; no problems, just set thissft
                push    es
                call    save_world
                call    FCBRegen
                call    restore_world
                pop     es
                mov     ax, ss:EXTERR
                jb      short CheckD_retn

Set_SFT:                                ; ...
                les     di, ss:THISSFT
                push    ss:PROC_ID      ; set process id
                pop     word ptr es:[di+31h] ; [ES:DI+SF_ENTRY.sf_PID]
                retn                    ; cf=0
SFTFromFCB      endp


; =============== S U B R O U T I N E =======================================


FCBHardErr      proc near               ; ...
                mov     es, cs:DosDSeg
                mov     ax, 23h         ; error_FCB_unavailable
                mov     es:ALLOWED, 8   ; Allowed_FAIL
                les     bp, es:THISDPB
                mov     di, 1           ; Fake some registers
                mov     cx, di
                xor     dx, dx
                cmp     es:[bp+0Fh], dx ; [es:bp+DPB.FAT_SIZE]
                jz      short fcbharderr_fat32 ; FAT32
                mov     es:HIGH_SECTOR, dx
                mov     dx, es:[bp+0Bh] ; [es:bp+DPB.FIRST_SECTOR]
                jmp     short fcbharderr_fat
; ---------------------------------------------------------------------------

fcbharderr_fat32:                       ; ...
                mov     dx, es:[bp+2Bh] ; [es:bp+DPB.FCLUS_FSECTOR+2]
                mov     es:HIGH_SECTOR, dx
                mov     dx, es:[bp+29h] ; [es:bp+DPB.FCLUS_FSECTOR]

fcbharderr_fat:                         ; ...
                call    HARDERR
                stc
                retn
FCBHardErr      endp


; =============== S U B R O U T I N E =======================================


GetRR           proc near               ; ...
                mov     ax, [si+21h]    ; [SI+SYS_FCB.RR]
                mov     dx, [si+23h]    ; [SI+SYS_FCB.RR+2]
                cmp     bx, 64          ; ignore MSB of RR if recsiz > 64
                jb      short GetRRBye
GetRR           endp

; START OF FUNCTION CHUNK FOR GetExtent

GetExtent_bye:                          ; ...
                xor     dh, dh
; END OF FUNCTION CHUNK FOR GetExtent

GetRRBye:                               ; ...
                retn

; =============== S U B R O U T I N E =======================================


GetExtent       proc near               ; ...

; FUNCTION CHUNK AT 616A SIZE 00000002 BYTES

                mov     al, [si+20h]    ; [SI+SYS_FCB.NR]
                mov     dx, [si+0Ch]    ; [SI+SYS_FCB.EXTENT]
                shl     al, 1
                shr     dx, 1
                rcr     al, 1
                mov     ah, dl
                mov     dl, dh
                jmp     short GetExtent_bye
GetExtent       endp


; =============== S U B R O U T I N E =======================================


SetExtent       proc near               ; ...
                push    ax
                push    dx
                mov     cx, ax
                and     al, 7Fh         ; next rec field
                mov     [si+20h], al    ; [SI+SYS_FCB.NR]
                and     cl, 80h         ; save upper bit
                shl     cx, 1
                rcl     dx, 1           ; move high bit of CX to low bit of DX
                mov     al, ch
                mov     ah, dl
                mov     [si+0Ch], ax    ; [SI+SYS_FCB.EXTENT],AX  ; all done
                pop     dx
                pop     ax
                retn
SetExtent       endp


; =============== S U B R O U T I N E =======================================


GetExtended     proc near               ; ...
                mov     si, dx
                cmp     byte ptr [si], 0FFh ; -1 ; look for extention
                jnz     short GetBye    ; not there
                add     si, 7           ; point to FCB

GetBye:                                 ; ...
                cmp     si, dx          ; set condition codes

getextd_retn:                           ; ...
                retn
GetExtended     endp


; =============== S U B R O U T I N E =======================================


GetRecSize      proc near               ; ...
                mov     bx, [si+0Eh]    ; [SI+SYS_FCB.RECSIZ] ; get his record size
                or      bx, bx          ; is it nul?
                jnz     short getextd_retn
                mov     bl, 128         ; use default size
                mov     [si+0Eh], bx    ; stuff it back
                retn
GetRecSize      endp

; ---------------------------------------------------------------------------

$FCB_RANDOM_WRITE_BLOCK:                ; ...
                mov     al, 0Ah         ; RANDOM+BLOCK
                jmp     short FCBIO
; ---------------------------------------------------------------------------

$FCB_RANDOM_READ_BLOCK:                 ; ...
                mov     al, 0Eh         ; RANDOM+FCBREAD+BLOCK
                jmp     short FCBIO
; ---------------------------------------------------------------------------

$FCB_SEQ_READ:                          ; ...
                mov     al, 4           ; FCBREAD
                jmp     short FCBIO
; ---------------------------------------------------------------------------

$FCB_SEQ_WRITE:                         ; ...
                mov     al, 0
                jmp     short FCBIO
; ---------------------------------------------------------------------------

$FCB_RANDOM_READ:                       ; ...
                mov     al, 6           ; RANDOM+FCBREAD
                jmp     short FCBIO
; ---------------------------------------------------------------------------

$FCB_RANDOM_WRITE:                      ; ...
                mov     al, 2           ; RANDOM

FCBIO:                                  ; ...
                push    bp
                mov     bp, sp
                sub     sp, 20
                mov     [bp-20], al     ; FCBOp
                mov     byte ptr [bp-1], 0 ; FCBErr
                call    GetExtended
                test    byte ptr [bp-20], 8 ; test FCBOp,BLOCK
                jnz     short GetPos
                mov     cx, 1

GetPos:                                 ; ...
                mov     [bp-3], cx      ; mov cRec,cx
                call    GetExtent       ; RecPos = GetExtent ();
                call    GetRecSize      ; RecSize = GetRecSize ();
                mov     [bp-9], bx      ; RecSize
                test    byte ptr [bp-20], 2 ; test FCBOp,RANDOM
                jz      short GetRec
                call    GetRR

GetRec:                                 ; ...
                mov     [bp-7], ax      ; mov RecPosL,ax
                mov     [bp-5], dx      ; mov RecPosH,dx
                call    SetExtent
                mov     ax, [bp-5]      ; RecPosH
                mul     bx
                mov     di, ax
                mov     ax, [bp-7]      ; RecPosL
                mul     bx              ; bPos = RecPos * RecSize
                add     dx, di
                mov     [bp-13], ax     ; bPosL
                mov     [bp-11], dx     ; bPosH
                mov     ax, [bp-3]      ; cRec
                mul     bx              ; cByte = cRec * RecSize
                mov     [bp-15], ax     ; cByte
                add     ax, word ptr ss:DMAADD ; if (cByte+DMA > 64K) {
                adc     dx, 0
                jz      short DoOper
                mov     byte ptr [bp-1], 2 ; FCBErr = FTRIM;
                mov     ax, word ptr ss:DMAADD ; cRec = (64K-DMA)/RecSize;
                neg     ax
                jnz     short DoDiv
                dec     ax

DoDiv:                                  ; ...
                xor     dx, dx
                div     bx
                mov     [bp-3], ax      ; cRec
                mul     bx              ; cByte = cRec * RecSize;
                mov     [bp-15], ax     ; cByte
                                        ; }

DoOper:                                 ; ...
                xor     bx, bx
                mov     [bp-17], bx     ; cResult = 0;
                cmp     [bp-15], bx     ; if (cByte <> 0 ||
                jnz     short DoGetExt
                test    byte ptr [bp-1], 2 ; test FCBErr,FTRIM
                                        ; (FCBErr&FTRIM) == 0) {
                jz      short DoGetExt
                jmp     short SkipOp
; ---------------------------------------------------------------------------

DoGetExt:                               ; ...
                call    SFTFromFCB      ; if (!SFTFromFCB (SFT,FCB))
                jnb     short ContinueOp

FCBDeath:                               ; ...
                call    FCB_RET_ERR     ; signal error, map for extended
                mov     word ptr [bp-19], 0 ; cRecRes
                                        ; no bytes transferred
                mov     byte ptr [bp-1], 1 ; MOV FCBErr,FEOF
                jmp     FCBSave
; ---------------------------------------------------------------------------

ContinueOp:                             ; ...
                push    ds
                lds     ax, [si+10h]    ; [SI+SYS_FCB.FILSIZ]
                mov     es:[di+11h], ax ; [ES:DI+SF_ENTRY.sf_size]
                mov     word ptr es:[di+13h], ds ; [ES:DI+SF_ENTRY.sf_size+2]
                lds     ax, [bp-13]     ; bPos (bPosL, bPosH)
                mov     dx, ds
                pop     ds
                mov     es:[di+15h], ax ; [ES:DI+SF_ENTRY.sf_position]
                xchg    dx, es:[di+17h] ; [ES:DI+SF_ENTRY.sf_position+2]
                push    dx              ; save away Open age.
                mov     cx, [bp-15]     ; cByte
                mov     di, offset DOS_READ
                test    byte ptr [bp-20], 4 ; test FCBOp,FCBREAD
                jnz     short DoContext
                mov     di, offset DOS_WRITE

DoContext:                              ; ...
                push    bp
                push    ds
                push    si
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    di ; DOS_READ   ; DOS_READ or DOS_WRITE
                pop     si
                pop     ds
                assume ds:nothing
                pop     bp
                jb      short FCBDeath
                cmp     ss:DISK_FULL, 0
                jz      short NODSKFULL
                mov     ss:DISK_FULL, 0

NODSKFULL:                              ; ...
                mov     [bp-17], cx     ; cResult
                call    SaveFCBInfo     ; SaveFCBInfo (FCB);
                pop     word ptr es:[di+17h] ; [ES:DI+SF_ENTRY.sf_position+2]
                                        ; restore open age
                                        ; (sf_OpenAge = SF_ENTRY.sf_position+2)
                push    es
                les     ax, es:[di+11h] ; [ES:DI+SF_ENTRY.sf_size]
                mov     [si+10h], ax    ; [SI+SYS_FCB.FILSIZ]
                mov     word ptr [si+12h], es ; [SI+SYS_FCB.FILSIZ+2]
                pop     es

SkipOp:                                 ; ...
                mov     ax, [bp-17]     ; cResult
                xor     dx, dx
                div     word ptr [bp-9] ; cRecRes = cResult / RecSize;
                mov     [bp-19], ax     ; cRecRes
                add     [bp-7], ax      ; RecPosL
                adc     word ptr [bp-5], 0 ; RecPosH
                                        ; RecPos += cRecResult;
                cmp     ax, [bp-3]      ; if (cRecRes <> cRec)
                jz      short TryBlank
                test    byte ptr [bp-20], 4 ; test FCBOp,FCBREAD
                                        ; if (OP&FCBRead || !DEVICE)
                jnz     short SetEOF
                test    byte ptr es:[di+5], 80h ; [ES:DI+SF_ENTRY.sf_flags],
                                        ; devid_device
                jnz     short TryBlank

SetEOF:                                 ; ...
                mov     byte ptr [bp-1], 1 ; mov FCBErr,FEOF

TryBlank:                               ; ...
                or      dx, dx          ; if (cResult%RecSize <> 0) {
                jz      short SetExt
                add     word ptr [bp-7], 1 ; RecPosL
                adc     word ptr [bp-5], 0 ; RecPosH
                                        ; RecPos++;
                test    byte ptr [bp-20], 4 ; test FCBOp,FCBREAD
                                        ; if(OP&FCBRead) <> 0) {
                jz      short SetExt
                inc     word ptr [bp-19] ; cRecRes++;
                mov     byte ptr [bp-1], 3 ; FCBErr = FTRIM | FEOF;
                mov     cx, [bp-9]      ; Blank (RecSize-cResult%RecSize,
                                        ;        DMA+cResult);
                sub     cx, dx
                xor     al, al
                les     di, ss:DMAADD
                add     di, [bp-17]     ; cResult
                rep stosb               ; } }

SetExt:                                 ; ...
                mov     dx, [bp-5]      ; RecPosH
                mov     ax, [bp-7]      ; RecPosL
                test    byte ptr [bp-20], 2 ; test FCBOp,RANDOM
                                        ; if ((OP&Random) == 0 ||
                jz      short DoSetExt
                test    byte ptr [bp-20], 8 ; test FCBOp,BLOCK
                                        ; (OP&BLOCK) <> 0)
                jz      short TrySetRR

DoSetExt:                               ; ...
                call    SetExtent       ; SetExtent (RecPos, FCB);

TrySetRR:                               ; ...
                test    byte ptr [bp-20], 8 ; test FCBOp,BLOCK
                jz      short TryReturn
                mov     [si+21h], ax    ; FCB->RR = RecPos;
                                        ; [SI+SYS_FCB.RR]
                mov     [si+23h], dl    ; [SI+SYS_FCB.RR+2]
                cmp     word ptr [si+0Eh], 64 ; [SI+SYS_FCB.RECSIZ]
                jnb     short TryReturn
                mov     [si+24h], dh    ; Set 4th byte only if record size < 64
                                        ; [SI+SYS_FCB.RR+2+1]

TryReturn:                              ; ...
                test    byte ptr [bp-20], 4 ; test FCBOp,FCBREAD
                                        ; if (!(FCBOP & FCBREAD)) {
                jnz     short FCBSave
                push    ds
                call    DATE16
                pop     ds
                mov     [si+14h], ax    ; FCB->FDate = date;
                                        ; [SI+SYS_FCB.FDATE]
                mov     [si+16h], dx    ; FCB->FTime = time;
                                        ; [SI+SYS_FCB.FTIME]

FCBSave:                                ; ...
                test    byte ptr [bp-20], 8 ; test FCBOp,BLOCK
                                        ; if ((op&BLOCK) <> 0)
                jz      short DoReturn
                mov     cx, [bp-19]     ; cRecRes ; user_CX = cRecRes;
                call    Get_User_Stack
                mov     [si+4], cx      ; [SI+user_env.user_CX]

DoReturn:                               ; ...
                mov     al, [bp-1]      ; FCBErr ; return (FCBERR);
                mov     sp, bp
                pop     bp
                retn
; ---------------------------------------------------------------------------

$FCB_OPEN:                              ; ...
                mov     ax, 2           ; SHARING_COMPAT+open_for_both
                mov     cx, offset DOS_OPEN

DoAccess:                               ; ...
                push    ds
                push    dx
                push    cx
                push    ax
                mov     di, offset OPENBUF
                call    TransFCB        ; crunch the fcb
                pop     ax
                pop     cx
                pop     dx
                pop     ds
                jnb     short FindFCB   ; everything seems ok

FCBOpenErr:                             ; ...
                jmp     FCB_RET_ERR
; ---------------------------------------------------------------------------

FindFCB:                                ; ...
                call    GetExtended
                push    ax
                mov     al, 1           ; indicate Open/Create operation
                call    LRUFCB          ; get a sft entry (no error)
                pop     ax
                jb      short HardMessage
                mov     word ptr es:[di+2], 8000h ; [es:di+SF_ENTRY.sf_mode],
                                        ; sf_isFCB
                push    ds
                push    si
                push    bx
                mov     si, cx
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    si              ; DOS_OPEN or DOS_CREATE
                pop     bx
                pop     si
                pop     ds
                assume ds:nothing
                les     di, ss:THISSFT
                jnb     short FCBOK     ; operation succeeded

failopen:                               ; ...
                push    ax
                mov     al, 52h ; 'R'   ; clear out field (free sft)
                call    BlastSFT
                pop     ax
                cmp     ax, 4           ; error_too_many_open_files
                jz      short HardMessage
                cmp     ax, 24h         ; error_sharing_buffer_exceeded
                jnz     short DeadFCB

HardMessage:                            ; ...
                push    ax
                call    FCBHardErr
                pop     ax

DeadFCB:                                ; ...
                jmp     short FCBOpenErr
; ---------------------------------------------------------------------------

FCBOK:                                  ; ...
                call    IsSFTNet        ; Non Fat file?
                jnz     short FCBOK2    ; yes
                call    CheckShare      ; share around?
                jnz     short FCBOK1    ; yes
                mov     word ptr ss:LocalSFT, di
                mov     word ptr ss:LocalSFT+2, es

FCBOK1:                                 ; ...
                test    byte ptr es:[di+5], 80h ; [es:di+SFTENTRY.sf_flags],
                                        ; devid_device
                jnz     short FCBOK2    ; local device
                                        ; local (disk) file
                test    byte ptr es:[di+4], 8 ; [es:di+SFTENTRY.sf_attr],
                                        ; attr_volume_id
                jnz     short FCBOK2
                push    es
                push    di
                les     di, es:[di+7]   ; [es:di+SF_ENTRY.sf_devptr]
                                        ; local file's DPB
                cmp     word ptr es:[di+0Fh], 0 ; [es:di+DPB.FAT_SIZE]
                pop     di
                pop     es
                jnz     short FCBOK2    ; not FAT32
                mov     ax, 0Fh         ; error_invalid_drive ; for FAT32
                jmp     short failopen
; ---------------------------------------------------------------------------

FCBOK2:                                 ; ...
                inc     word ptr es:[di] ; inc word [ES:DI+SF_ENTRY.sf_ref_count]
                call    set_sftfcb_entry
                call    SaveFCBInfo
                test    byte ptr es:[di+5], 80h ; [ES:DI+SF_ENTRY.sf_flags],
                                        ; devid_device
                jnz     short FCBNoDrive
                mov     al, [si]
                call    GETTHISDRV
                inc     al
                mov     [si], al

FCBNoDrive:                             ; ...
                mov     word ptr [si+0Eh], 80h ; [SI+SYS_FCB.RECSIZ],128
                                        ; default record size
                push    es
                les     ax, es:[di+0Dh] ; [es:di+SF_ENTRY.sf_time]
                mov     [si+16h], ax    ; [si+SYS_FCB.FTIME]
                mov     word ptr [si+14h], es ; [si+SYS_FCB.FDATE]
                pop     es
                push    es
                les     ax, es:[di+11h] ; [es:di+SF_ENTRY.sf_size]
                mov     [si+10h], ax    ; [si+SYS_FCB.FILSIZ]
                mov     word ptr [si+12h], es ; [si+SYS_FCB.FILSIZ+2]
                pop     es
                xor     ax, ax          ; 0
                mov     [si+0Ch], ax    ; [si+SYS_FCB.EXTENT] ; beginning of file
                les     di, ss:SFTFCB   ; pointer to head of the list
                mov     ah, es:[di+4]   ; [es:si+SFT.SFCount]
                                        ; number of SFTs to scan

OpenScan:                               ; ...
                cmp     al, [si+18h]    ; [SI+fcb_sfn]
                jz      short SkipCheck
                push    ax
                call    CheckFCB        ; do they match
                pop     ax
                jnb     short OpenFound ; found a match!

SkipCheck:                              ; ...
                inc     al              ; advance to next FCB
                cmp     al, ah          ; table full?
                jnz     short OpenScan  ; no, go for more

OpenDone:                               ; ...
                xor     al, al          ; return success
                retn
; ---------------------------------------------------------------------------

OpenFound:                              ; ...
                mov     [si+18h], al    ; [SI+fcb_sfn] ; assign with this
                inc     word ptr es:[di] ; inc word [ES:DI+SF_ENTRY.sf_ref_count]
                call    set_sftfcb_entry
                mov     ax, ss:FCBLRU   ; update LRU counts
                mov     es:[di+15h], ax ; [es:di+sf_LRU]
                push    ss
                pop     ds
                assume ds:DOSCODE
                les     di, THISSFT
                dec     word ptr es:[di] ; dec word [ES:DI+SF_ENTRY.sf_ref_count]
                                        ; free the newly allocated SFT
                call    ShareEnd
                mov     al, 43h ; 'C'
                call    BlastSFT
                jmp     short OpenDone
; ---------------------------------------------------------------------------

$FCB_CREATE:                            ; ...
                mov     cx, offset DOS_CREATE
                xor     ax, ax          ; attributes to create
                call    GetExtended     ; get extended FCB
                jz      short DoAccessJ ; not an extended FCB
                mov     al, [si-1]      ; get attributes

DoAccessJ:                              ; ...
                jmp     DoAccess
; ---------------------------------------------------------------------------

$DIR_SEARCH_FIRST:                      ; ...
                mov     word ptr ss:THISFCB, dx
                mov     word ptr ss:THISFCB+2, ds
                mov     si, dx
                cmp     byte ptr [si], 0FFh
                jnz     short NORMFCB4
                add     si, 7           ; point to drive select byte

NORMFCB4:                               ; ...
                push    word ptr [si]   ; save original drive byte
                mov     di, ss
                mov     es, di
                assume es:DOSCODE
                mov     di, offset OPENBUF
                call    TransFCB        ; convert the FCB, set SATTRIB EXTFCB
                jnb     short SearchIt
                pop     bx

dcf_errj:                               ; ...
                jmp     FCB_RET_ERR
; ---------------------------------------------------------------------------

SearchIt:                               ; ...
                mov     di, ss
                mov     ds, di
                les     di, DMAADD
                assume es:nothing
                push    di
                push    es
                mov     word ptr DMAADD, offset SEARCHBUF
                mov     word ptr DMAADD+2, ds
                or      DOS34_FLAG, 400h ; SEARCH_FASTOPEN
                call    DOS_SEARCH_FIRST
                pop     word ptr DMAADD+2
                pop     word ptr DMAADD
                jnb     short SearchSet
                pop     bx
                jmp     short dcf_errj
; ---------------------------------------------------------------------------

SearchSet:                              ; ...
                mov     si, offset SEARCHBUF
                les     di, THISFCB
                test    EXTFCB, 0FFh
                jz      short NORMFCB1
                add     di, 7           ; point past the extension

NORMFCB1:                               ; ...
                pop     bx              ; get original drive byte
                or      bl, bl
                jnz     short SearchDrv
                mov     bl, CURDRV
                inc     bl

SearchDrv:                              ; ...
                lodsb
                xchg    al, bl
                inc     di
                mov     cx, 10          ; 20/2
                rep movsw
                xchg    al, bl
                stosb
                les     di, DMAADD
                test    EXTFCB, 0FFh
                jz      short NORMFCB2
                mov     al, 0FFh
                stosb
                inc     al
                mov     ah, al
                stosb
                stosw
                stosw
                mov     al, SATTRIB
                stosb

NORMFCB2:                               ; ...
                mov     al, bl          ; User Drive byte
                stosb
                mov     cx, 16          ; 32 / 2 words of dir entry
                rep movsw
                jmp     NO_OP           ; FCB_RET_OK
; ---------------------------------------------------------------------------

$DIR_SEARCH_NEXT:                       ; ...
                mov     word ptr ss:THISFCB, dx
                mov     word ptr ss:THISFCB+2, ds
                mov     al, 0
                mov     ss:SATTRIB, al
                mov     ss:EXTFCB, al
                mov     di, ss
                mov     es, di
                assume es:DOSCODE
                mov     di, offset SEARCHBUF
                mov     si, dx
                cmp     byte ptr [si], 0FFh
                jnz     short NORMFCB6
                add     si, 6
                lodsb
                mov     ss:SATTRIB, al
                dec     ss:EXTFCB

NORMFCB6:                               ; ...
                lodsb
                push    ax
                mov     al, [si+20]
                stosb
                mov     cx, 10          ; 20/2
                rep movsw
                mov     di, ss
                mov     ds, di
                les     di, DMAADD
                assume es:nothing
                push    di
                push    es
                mov     di, offset SEARCHBUF
                mov     word ptr DMAADD, di
                mov     word ptr DMAADD+2, ds
                mov     ax, ds
                mov     es, ax
                assume es:DOSCODE
                call    DOS_SEARCH_NEXT
                pop     word ptr DMAADD+2
                pop     word ptr DMAADD
                jb      short SearchNoMore
                jmp     SearchSet
; ---------------------------------------------------------------------------

SearchNoMore:                           ; ...
                les     di, THISFCB
                assume es:nothing
                test    EXTFCB, 0FFh
                jz      short NORMFCB8
                add     di, 7           ; point past the extension

NORMFCB8:                               ; ...
                pop     bx
                mov     es:[di], bl
                jmp     FCB_RET_ERR
; ---------------------------------------------------------------------------

FindError:                              ; ...
                mov     al, 3           ; error_path_not_found

FF_errj:                                ; ...
                jmp     SYS_RET_ERR     ; error and map into one
; ---------------------------------------------------------------------------

$FIND_FIRST:                            ; ...
                mov     si, dx
                mov     ss:SATTRIB, cl  ; Search attribute
                mov     di, offset OPENBUF
                call    TransPathSet    ; convert the path
                jb      short FindError

Find_it:
                mov     di, ss
                mov     ds, di
                les     di, DMAADD
                push    di
                push    es
                mov     word ptr DMAADD, offset SEARCHBUF
                mov     word ptr DMAADD+2, ds
                or      DOS34_FLAG, 400h ; SEARCH_FASTOPEN
                call    DOS_SEARCH_FIRST ; Find it
                pop     word ptr DMAADD+2
                pop     word ptr DMAADD
                jb      short FF_errj

FindSet:                                ; ...
                mov     si, offset SEARCHBUF
                les     di, DMAADD
                mov     cx, 10
                rep movsw
                movsb
                push    si              ; Save pointer to start of entry
                mov     al, [si+11]     ; [SI+dir_entry.dir_attr]
                stosb
                add     si, 22          ; dir_entry.dir_time
                movsw                   ; dir_time
                movsw                   ; dir_date
                inc     si              ; Skip dir_first
                inc     si
                movsw                   ; dir_size (2 words)
                movsw
                pop     si              ; Point back to dir_name
                call    PackName
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

$FIND_NEXT:                             ; ...
                mov     di, ss
                mov     es, di
                assume es:DOSCODE
                mov     di, offset SEARCHBUF
                lds     si, ss:DMAADD
                assume ds:nothing
                mov     cx, 10
                rep movsw
                movsb
                mov     di, ss
                mov     ds, di
                assume ds:DOSCODE
                les     di, DMAADD
                assume es:nothing
                push    di
                push    es
                mov     di, offset SEARCHBUF
                mov     word ptr DMAADD, di
                mov     word ptr DMAADD+2, ds
                mov     ax, ds
                mov     es, ax
                assume es:DOSCODE
                call    DOS_SEARCH_NEXT ; Find it
                pop     word ptr DMAADD+2
                pop     word ptr DMAADD
                jnb     short FindSet   ; No error, set info
                jmp     SYS_RET_ERR

; =============== S U B R O U T I N E =======================================


PackName        proc near               ; ...
                mov     cx, 4           ; Convert file names from FCB to ASCIZ format
                rep movsw

main_kill_tail:                         ; ...
                cmp     byte ptr es:[di-1], 20h ; ' '
                jnz     short find_check_dot
                dec     di              ; Back up over trailing space
                inc     cx
                cmp     cx, 8
                jb      short main_kill_tail

find_check_dot:                         ; ...
                cmp     word ptr [si], 2020h
                jnz     short got_ext   ; Some chars in extension
                cmp     byte ptr [si+2], 20h ; ' '
                jz      short find_done ; No extension

got_ext:                                ; ...
                mov     al, 2Eh ; '.'
                stosb
                movsw
                movsb

ext_kill_tail:                          ; ...
                cmp     byte ptr es:[di-1], 20h ; ' '
                jnz     short find_done
                dec     di              ; Back up over trailing space
                jmp     short ext_kill_tail
; ---------------------------------------------------------------------------

find_done:                              ; ...
                xor     ax, ax          ; NUL terminate
                stosb
                retn
PackName        endp

; ---------------------------------------------------------------------------

GET_FAST_SEARCH:                        ;
                or      ss:DOS34_FLAG, 400h ; SEARCH_FASTOPEN
                call    DOS_SEARCH_FIRST
                retn

; =============== S U B R O U T I N E =======================================


$CURRENT_DIR    proc near               ; ...
                call    ECritDisk
                mov     al, dl          ; get drive number (0=def, 1=A)
                call    GetVisDrv
                jnb     short CurrentValidate

CurdirErr:                              ; ...
                call    LCritDisk
                push    ds
                mov     ds, cs:DosDSeg
                assume ds:nothing
                mov     al, ds:DrvErr
                pop     ds

curdir_errj:                            ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

CurrentValidate:                        ; ...
                push    ds
                push    si
                mov     ds, cs:DosDSeg
                mov     ds:NoSetDir, 0

DoCheck:
                mov     di, offset OPENBUF
                call    ValidateCDS
                push    es
                push    di
                pop     si
                pop     ds
                pop     di
                pop     es
                assume es:nothing
                jb      short CurdirErr
                add     si, [si+4Fh]    ; [SI+curdir.end]
                cmp     byte ptr [si], 5Ch ; '\' ; root or subdirs present?
                jnz     short CurrentCopy
                inc     si

CurrentCopy:                            ; ...
                push    ax
                lodsb                   ; get char
                or      al, al
                jz      short FOK
                cmp     al, 5
                jz      short FCHANGE
                jmp     short FFF
; ---------------------------------------------------------------------------

FCPYNEXT:                               ; ...
                lodsb                   ; get char

FFF:                                    ; ...
                cmp     al, 5Ch ; '\'   ; beginning of directory ?
                jnz     short FOK       ; no
                stosb
                lodsb
                cmp     al, 5           ; 1st char of dir is 05?
                jnz     short FOK       ; no

FCHANGE:                                ; ...
                mov     al, 0E5h        ; make it E5

FOK:                                    ; ...
                stosb                   ; put into user's buffer
                or      al, al          ; final char
                jnz     short FCPYNEXT  ; no
                pop     ax
                xor     al, al          ; MZ 19 Jan 84
                call    LCritDisk
                jmp     SYS_RET_OK      ; no more, bye!
$CURRENT_DIR    endp

; ---------------------------------------------------------------------------

$RMDIR:                                 ; ...
                push    dx              ; Save ptr to name
                push    ds
                mov     si, dx
                mov     di, offset OPENBUF
                push    di
                call    TransPathNoSet  ; Translate the name
                pop     di
                jnb     short rmlset
                pop     ds
                pop     dx
                mov     al, 3           ; error_path_not_found

rmdir_chdir_errj:                       ; ...
                jmp     short curdir_errj
; ---------------------------------------------------------------------------

rmlset:                                 ; ...
                cmp     ss:CMETA, 0FFh
                jnz     short rmerr
                push    ss
                pop     es
                assume es:DOSCODE
                xor     al, al          ; al = 0 , ie drive a:

rmloop:                                 ; ...
                call    GetCDSFromDrv   ; Get curdir for drive in al
                jb      short rmcont    ; If error, exit loop & cont normally
                test    word ptr [si+43h], 4000h ; [SI+curdir.flags],curdir_inuse
                jz      short rmdir_nxt
                call    StrCmp          ; Are the 2 paths the same?
                jz      short rmerr     ; Yes, report error.

rmdir_nxt:                              ; ...
                inc     al              ; Go check next drive.
                jmp     short rmloop
; ---------------------------------------------------------------------------

rmerr:                                  ; ...
                pop     ds
                pop     dx
                mov     al, 10h         ; error_current_directory

rmdir_chdir_errj2:                      ; ...
                jmp     short rmdir_chdir_errj
; ---------------------------------------------------------------------------

rmcont:                                 ; ...
                pop     ds
                pop     dx              ; Restore ptr the name
                mov     si, offset DOS_RMDIR
                call    TestNet
                mov     di, 67          ; DIRSTRLEN
                jnb     short rmcont2   ; local directory
                mov     di, 128

rmcont2:                                ; ...
                mov     ss:PATHNAMELEN, di
                jmp     DoDirCall
; ---------------------------------------------------------------------------

$CHDIR:                                 ; ...
                mov     ss:PATHNAMELEN, 67 ; DIRSTRLEN
                mov     di, offset OPENBUF
                mov     si, dx
                call    TransPath       ; go munge the path and get real CDS
                jnb     short ChDirCrack ; no errors, try path

ChDirErrP:                              ; ...
                mov     al, 3           ; error_path_not_found

chdir_errj:                             ; ...
                jmp     short rmdir_chdir_errj2
; ---------------------------------------------------------------------------

ChDirCrack:                             ; ...
                cmp     ds:CMETA, 0FFh  ; No meta chars allowed.
                jnz     short ChDirErrP
                les     di, ds:THISCDS
                assume es:nothing
                cmp     di, 0FFFFh      ; if (ThisCDS == NULL)
                jz      short ChDirErrP ;     error ();
                call    DOS_CHDIR       ; Find out if the directory exists.
                jb      short chdir_errj
                les     di, ds:THISCDS  ; Get back CDS to see if a join as seen.
                test    word ptr es:[di+43h], 2000h ;
                                        ; [ES:DI+curdir.flags],curdir_splice
                mov     dx, ds:DIRSTART_HW
                jz      short GotCDS
                push    es              ; The CDS was joined.
                push    di              ; Let's go back and grab the logical CDS.
                push    dx
                push    cx
                call    Get_User_Stack  ; get original text
                mov     di, [si+6]      ; [SI+user_env.user_DX]
                mov     ds, word ptr [si+0Eh] ; [SI+user_env.user_DS]
                mov     si, offset OPENBUF
                xchg    si, di
                xor     al, al          ; do no splicing
                push    di
                call    TransPathNoSet  ; Munge path
                pop     si
                les     di, ds:THISCDS  ; get new CDS
                mov     word ptr es:[di+49h], 0FFFFh ; [es:di+curdir.ID],-1
                mov     word ptr es:[di+4Bh], 0FFFFh ; [es:di+curdir.ID+2],-1
                pop     cx
                pop     dx
                pop     di
                pop     es

GotCDS:                                 ; ...
                call    Check_PathLen
                ja      short ChDirErrP
                test    word ptr es:[di+43h], 8000h ;
                                        ; [ES:DI+curdir.flags],curdir_isnet
                jnz     short SkipRecency
                test    word ptr es:[di+43h], 2000h ; for Join and Subst
                                        ; [ES:DI+curdir.flags],curdir_splice
                jz      short setdirclus
                mov     cx, 0FFFFh      ; -1
                mov     dx, cx

setdirclus:                             ; ...
                mov     es:[di+49h], cx ; [ES:DI+curdir.ID]
                mov     es:[di+4Bh], dx ; [ES:DI+curdir.ID+2]
                les     di, ds:THISCDS  ; get logical CDS

SkipRecency:                            ; ...
                call    FStrCpy
                xor     al, al

mkdir_ok:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

$MKDIR:                                 ; ...
                mov     ss:PATHNAMELEN, 67 ; DIRSTRLEN

mkdir_x:                                ; ...
                mov     si, offset DOS_MKDIR

DoDirCall:                              ; ...
                mov     di, offset OPENBUF
                push    si
                mov     si, dx          ; get source
                call    TransPath       ; go munge the path
                pop     si
                jnb     short MkDirCrack ; no errors, try path

MkErrP:                                 ; ...
                mov     al, 3           ; error_path_not_found

MkErr:                                  ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

MkDirCrack:                             ; ...
                cmp     ss:CMETA, 0FFh  ; -1
                jnz     short MkErrP
                push    si
                call    Check_PathLen   ; check path len > [PATNAMELEN]
                                        ; > 67 or 128
                pop     si
                jbe     short pathok
                mov     al, 5           ; error_access_denied
                jmp     short MkErr
; ---------------------------------------------------------------------------

pathok:                                 ; ...
                call    si              ; go get file
                jb      short MkErr     ; error
                jmp     short mkdir_ok  ; ok

; =============== S U B R O U T I N E =======================================


Check_PathLen   proc near               ; ...
                mov     si, ss:WFP_START
Check_PathLen   endp


; =============== S U B R O U T I N E =======================================


Check_PathLen2  proc near               ; ...
                push    ss
                pop     ds
                assume ds:DOSCODE
                push    cx
                push    dx
                call    DStrLen
                pop     dx
                cmp     cx, PATHNAMELEN
                pop     cx
                retn
Check_PathLen2  endp

; ---------------------------------------------------------------------------
IOCTLJMPTABLE   dw offset ioctl_getset_data ; ...
                dw offset ioctl_getset_data ; 1
                dw offset ioctl_control_string ; 2
                dw offset ioctl_control_string
                dw offset ioctl_get_dev
                dw offset ioctl_get_dev ; 5
                dw offset ioctl_status
                dw offset ioctl_status
                dw offset ioctl_rem_media
                dw offset ioctl_drive_attr ; 9
                dw offset ioctl_handle_redir
                dw offset Set_Retry_Parameters
                dw offset GENERICIOCTLHANDLE ; 0Ch
                dw offset GENERICIOCTL  ; 0Dh
                dw offset ioctl_drive_owner
                dw offset ioctl_drive_owner
                dw offset GENERICIOCTLHANDLE ; query_handle_support
                dw offset GENERICIOCTL  ; query_device_support ; 11h

; =============== S U B R O U T I N E =======================================


$IOCTL          proc near               ; ...

; FUNCTION CHUNK AT 450E SIZE 0000001C BYTES
; FUNCTION CHUNK AT 6AC7 SIZE 0000004A BYTES

                mov     si, ds          ; Stash DS for calls 2,3,4 and 5
                push    ss
                pop     ds
                cmp     al, 11h         ; al must be between 0 & 11h
                ja      short ioctl_bad_funj2
                mov     di, ax
                and     di, 0FFh
                add     di, di
                jmp     cs:IOCTLJMPTABLE[di]
; ---------------------------------------------------------------------------

ioctl_bad_funj2:                        ; ...
                jmp     ioctl_bad_fun
; ---------------------------------------------------------------------------

ioctl_getset_data:                      ; ...
                call    SFFromHandle
                jnb     short ioctl_check_permissions ; have valid handle

ioctl_bad_handle:                       ; ...
                mov     al, 6           ; error_invalid_handle

ioctl_error:                            ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

ioctl_check_permissions:                ; ...
                cmp     al, 0
                mov     al, es:[di+5]   ; [ES:DI+SF_ENTRY.sf_flags]
                jz      short ioctl_read
                or      dh, dh
                jz      short ioctl_check_device
                mov     al, 0Dh         ; error_invalid_data ; no DH <> 0
                jmp     short ioctl_error
; ---------------------------------------------------------------------------

ioctl_check_device:                     ; ...
                test    al, 80h         ; devid_device  ; can I set this handle?
                jz      short ioctl_bad_funj2
                or      dl, 80h         ; devid_device
                                        ; Make sure user doesn't
                                        ; turn off the device bit!!
                call    set_exerr_locus_ser
                mov     es:[di+5], dl   ; [ES:DI+SF_ENTRY.sf_flags]

ioctl_ok:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

ioctl_read:                             ; ...
                call    set_exerr_locus_disk
                xor     ah, ah
                test    al, 80h         ; devid_device
                jz      short ioctl_no_high
                call    set_exerr_locus_ser
                les     di, es:[di+7]   ; [ES:DI+SF_ENTRY.sf_devptr]
                                        ; Get device pointer
                mov     ah, es:[di+5]   ; [ES:DI+SYSDEV.ATT+1] ; Get high byte

ioctl_no_high:                          ; ...
                mov     dx, ax
                call    Get_User_Stack
                mov     [si+6], dx      ; [SI+user_env.user_DX]

ioctl_ok_j:                             ; ...
                jmp     short ioctl_ok
; ---------------------------------------------------------------------------

ioctl_control_string:                   ; ...
                call    SFFromHandle
                jb      short ioctl_bad_handle
                test    byte ptr es:[di+5], 80h ; [ES:DI+SF_ENTRY.sf_flags],
                                        ; devid_device

ioctl_bad_funj:                         ; ...
                jz      short ioctl_bad_funj2
                call    set_exerr_locus_ser
                les     di, es:[di+7]   ; [ES:DI+SF_ENTRY.sf_devptr]
                xor     bl, bl
                jmp     ioctl_do_string
; ---------------------------------------------------------------------------

ioctl_status:                           ; ...
                mov     ah, 1
                sub     al, 6           ; 6=0,7=1
                jz      short ioctl_get_status
                mov     ah, 3

ioctl_get_status:                       ; ...
                push    ax
                call    GET_IO_SFT
                pop     ax
                jnb     short DO_IOFUNC

ioctl_bad_handle_j:                     ; ...
                jmp     short ioctl_bad_handle ; invalid SFT
; ---------------------------------------------------------------------------

DO_IOFUNC:                              ; ...
                call    IOFUNC
                mov     ah, al
                mov     al, 0FFh
                jnz     short ioctl_status_ret
                inc     al

ioctl_status_ret:                       ; ...
                jmp     short ioctl_ok_j
; ---------------------------------------------------------------------------

Set_Retry_Parameters:                   ; ...
                mov     RetryLoop, cx
                or      dx, dx
                jz      short ioctl_bad_funj
                mov     RetryCount, dx
                jmp     short ioctl_status_ret
; ---------------------------------------------------------------------------

GENERICIOCTLHANDLE:                     ; ...
                call    SFFromHandle
                jb      short ioctl_bad_handle_j
                test    byte ptr es:[di+6], 80h ; [ES:DI+SF_ENTRY.sf_flags+1],
                                        ; (sf_isnet>>8)
                jnz     short ioctl_bad_funj3
                call    set_exerr_locus_ser
                les     di, es:[di+7]   ; [es:di+SF_ENTRY.sf_devptr]
                mov     IOCTL_drvnum, 0FFh ; invalidate drive number
                                        ; (for extended -lock/unlock- functions)
                jmp     short Do_GenIOCTL
; ---------------------------------------------------------------------------

GENERICIOCTL:                           ; ...
                call    set_exerr_locus_disk
                cmp     ch, 48h         ; category (extended, disk lock/unlock)
                jz      short GenIOCTL_chk_net ; extended (MSDOS/PCDOS 7)
                cmp     ch, 8           ; IOC_DC ; category (disk control, normal)
                jz      short GenIOCTL_chk_net ; Only disk devices are allowed to use
                                        ; Generic IOCTL

ioctl_bad_funj3:                        ; ...
                jmp     ioctl_bad_fun   ; no handles with Generic IOCTL
; ---------------------------------------------------------------------------

GenIOCTL_chk_net:                       ; ...
                mov     IOCTL_drvnum, bl ; drive number
                call    Check_If_Net
                jnz     short ioctl_bad_funj3

Do_GenIOCTL:                            ; ...
                cmp     ch, 48h         ; category code 48h for FAT32
                jz      short GenioCTL_extended ; MSDOS/PCDOS 7 functions
                                        ; (lock/unlock)
                cmp     ch, 8           ; disk control (for FAT12/16)
                jnz     short GenIOCTL_normal

GenioCTL_extended:                      ; ...
                cmp     cl, 6Ah         ; UNLOCK LOGICAL VOLUME
                jz      short GenIOCTL_chk_lock
                cmp     cl, 4Ah         ; LOCK LOGICAL VOLUME
                jnz     short GenIOCTL_normal

GenIOCTL_chk_lock:                      ; ...
                cmp     cl, 4Ah         ; LOCK LOGICAL VOLUME
                jnz     short GenIOCTL_lock_unlock
                cmp     bh, 4           ; lock level (0-4)
                jz      short GenIOCTL_lock_unlock
                or      bh, bh
                jnz     short ioctl_bad_fun

GenIOCTL_lock_unlock:                   ; ...
                mov     bl, IOCTL_drvnum ; drive number (1=A:, 2=B: ..)
                xor     bh, bh
                dec     bx
                cmp     bl, 26          ; logical disk number limit
                jnb     short ioctl_bad_fun
                cmp     cl, 6Ah         ; UNLOCK LOGICAL VOLUME
                jnz     short GenIOCTL_lock
                and     drive_flags[bx], 7Fh ; UNLOCK
                jmp     short GenIOCTL_OK
; ---------------------------------------------------------------------------

GenIOCTL_lock:                          ; ...
                or      drive_flags[bx], 80h ; LOCK

GenIOCTL_OK:                            ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

GenIOCTL_normal:                        ; ...
                test    byte ptr es:[di+4], 40h ; [ES:DI+SYSDEV.ATT],DEV320
                jz      short ioctl_bad_fun
                mov     IOCALL_REQFUNC, 13h ; [IOCALL_REQFUNC],GENIOCTL ; 19
                cmp     al, 10h         ; IOCTL_QUERY_HANDLE
                jl      short SetIOCtlBlock
                test    byte ptr es:[di+4], 80h ; byte [ES:DI+SYSDEV.ATT],IOQUERY
                jz      short ioctl_bad_fun ; No support for query
                mov     IOCALL_REQFUNC, 19h ; IOCTL_QUERY

SetIOCtlBlock:                          ; ...
                push    es
                push    di
                mov     IOCALL, 17h     ; IOCTL_REQ.size ; 23
                mov     IOCALL_REQUNIT, bl
                mov     IOMED, ch       ; [IOCALL+IOCTL_REQ.MAJORFUNCTION]
                mov     byte ptr IOXAD, cl ; [IOCALL+IOCTL_REQ.MINORFUNCTION]
                mov     word ptr IOXAD+1, si ; [IOCALL+IOCTL_REQ.REG_SI]
                mov     word ptr IOXAD+3, di ; [IOCALL+IOCTL_REQ.REG_DI]
                mov     IOSCNT+1, dx    ; [IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET]
                mov     IOSSEC+1, si    ; [IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET+2]
                mov     bx, offset IOCALL
                push    ss
                pop     es
                assume es:DOSCODE
                pop     si
                pop     ds
                assume ds:nothing
                jmp     ioctl_do_IO
; ---------------------------------------------------------------------------

ioctl_bad_fun:                          ; ...
                mov     al, 1           ; error_invalid_function
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------
                jmp     ioctl_bad_handle
; ---------------------------------------------------------------------------

ioctl_rem_media:                        ; ...
                call    Check_If_Net
                jnz     short ioctl_bad_fun
                test    byte ptr es:[di+5], 8 ; [es:di+SYSDEV.ATT+1],(DEVOPCL>>8)
                jz      short ioctl_bad_fun
                mov     ss:IOCALL_REQFUNC, 0Fh ; DEVRMD
                mov     al, 0Dh         ; REMHL
                mov     ah, bl
                mov     word ptr ss:IOCALL, ax ; [SS:IOCALL_REQLEN]
                xor     ax, ax
                mov     ss:IOCALL_REQSTAT, ax
                push    es
                pop     ds
                assume ds:DOSCODE
                mov     si, di
                push    ss
                pop     es
                mov     bx, offset IOCALL
                push    ds
                push    si
                call    DEVIOCALL2
                pop     si
                pop     ds
                assume ds:nothing
                mov     ax, ss:IOCALL_REQSTAT
                and     ah, 2           ; STBUI>>8
                mov     cl, 9
                shr     ax, cl

ioctl_da_ok_j:                          ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

ioctl_drive_attr:                       ; ...
                mov     al, bl
                call    GETTHISDRV
                jb      short ioctl_drv_err
                call    Get_Driver_BL
                jb      short ioctl_drv_err ; drive not valid
                mov     dx, 942h        ; 0942h -> Attribute word
                                        ; bit 11 - open/close/remmedia calls supported
                                        ; bit 8 - (new type driver)
                                        ; bit 6 - Generic IOCTL call supported
                                        ; bit 1 - driver supports 32-bit sector addressing
                jnz     short ioctl_drive_attr2 ; NET device
                mov     dx, es:[di+4]   ; [es:di+SYSDEV.ATT]
                                        ; get device attribute word

ioctl_drive_attr2:                      ; ...
                mov     bl, al          ; drive number (A=0)
                les     di, ss:THISCDS  ; NOTE: PCDOS 7.1 has bug here,
                                        ; ds must be same with ss here...
                                        ; because there is 'les di, [ds:THISCDS]' in
                                        ; Get_Driver_BL
                                        ; and a second 'test byte ptr es:[ di+44h],80h'
                                        ; is not necessary; also its result (jnz)
                                        ; overwrites DS. /// Erdogan Tan - 30/01/2024
                assume es:nothing
                test    byte ptr es:[di+44h], 80h ; [ES:DI+curdir.flags+1],
                                        ; (curdir_isnet>>8)
                jz      short IOCTLShare
                mov     dx, 1000h       ; remote device (bit 12)

IOCTLShare:                             ; ...
                push    ss
                pop     ds
                assume ds:DOSCODE
                mov     si, offset OPENBUF
                add     bl, 41h ; 'A'
                mov     [si], bl
                mov     word ptr [si+1], 3Ah ; ':'
                mov     ax, 300h
                clc
                int     2Ah             ; Microsoft Networks - CHECK DIRECT I/O
                                        ; DS:SI -> ASCIZ disk device name (may be full path or only drive
                                        ; specifier--must include the colon)
                                        ; Return: CF clear if absolute disk access allowed
                jnb     short IOCTLLocal
                or      dx, 200h        ; Shared, bit 9

IOCTLLocal:                             ; ...
                test    byte ptr es:[di+44h], 10h ; [ES:DI+curdir.flags+1],(curdir_local>>8)
                jz      short ioctl_set_DX
                or      dx, 8000h

ioctl_set_DX:                           ; ...
                call    Get_User_Stack
                mov     [si+6], dx

ioctl_gd_ok_j:                          ; ...
                jmp     short ioctl_da_ok_j
; ---------------------------------------------------------------------------

ioctl_drv_err:                          ; ...
                mov     al, 0Fh         ; error_invalid_drive

ioctl_gd_err_j:                         ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

ioctl_handle_redir:                     ; ...
                call    SFFromHandle    ; ES:DI -> SFT
                jnb     short ioctl_got_sft ; have valid handle
                jmp     ioctl_bad_handle
; ---------------------------------------------------------------------------

ioctl_got_sft:                          ; ...
                mov     dx, es:[di+5]   ; [ES:DI+SF_ENTRY.sf_flags] ; Get flags
                jmp     short ioctl_set_DX
; ---------------------------------------------------------------------------

ioctl_bad_funj5:                        ; ...
                jmp     ioctl_bad_fun
; ---------------------------------------------------------------------------

ioctl_get_dev:                          ; ...
                call    Check_If_Net
                jnz     short ioctl_bad_funj5

ioctl_do_string:                        ; ...
                test    byte ptr es:[di+5], 40h ; [ES:DI+SYSDEV.ATT+1],(DEVIOCTL>>8)
                jz      short ioctl_bad_funj5
                mov     IOCALL_REQFUNC, 3 ; DEVRDIOCTL ; IOCTL read
                test    al, 1
                jz      short ioctl_control_call
                mov     IOCALL_REQFUNC, 0Ch ; DEVWRIOCTL ; IOCTL write

ioctl_control_call:                     ; ...
                mov     al, 20          ; It is 22 in
                                        ; MSDOS 6.22 MSDOS.SYS and Windows ME IO.SYS
                mov     ah, bl
                mov     word ptr IOCALL, ax ; [IOCALL_REQLEN]
                xor     ax, ax
                mov     IOCALL_REQSTAT, ax ; [IOCALL_REQSTAT]
                mov     IOMED, al
                mov     IOSCNT, cx
                mov     word ptr IOXAD, dx
                mov     word ptr IOXAD+2, si
                push    es
                pop     ds
                assume ds:nothing
                mov     si, di
                push    ss
                pop     es
                assume es:DOSCODE
                mov     bx, offset IOCALL

ioctl_do_IO:                            ; ...
                call    DEVIOCALL2
                test    byte ptr ss:IOCALL_REQSTAT+1, 80h ; (STERR>>8)
                jnz     short ioctl_string_err
                mov     ax, ss:IOSCNT
                jmp     short ioctl_gd_ok_j
; ---------------------------------------------------------------------------

ioctl_string_err:                       ; ...
                mov     di, ss:IOCALL_REQSTAT
                and     di, 0FFh        ; STECODE
                mov     ax, di
                call    SET_I24_EXTENDED_ERROR
                mov     ax, ss:EXTERR
                jmp     short ioctl_gd_err_j
$IOCTL          endp


; =============== S U B R O U T I N E =======================================


Get_Driver_BL   proc near               ; ...
                push    ax
                mov     al, bl          ; drive number (0=default)
                call    GETTHISDRV
                jb      short ioctl_bad_drv
                xor     bl, bl
                mov     ds:EXTERR_LOCUS, 3 ; errLOC_Net
                les     di, ds:THISCDS
                assume es:nothing
                test    byte ptr es:[di+44h], 80h ; [ES:DI+curdir.flags+1],
                                        ; (curdir_isnet>>8)
                les     di, es:[di+45h] ; [ES:DI+curdir.devptr]
                jnz     short got_dev_ptr ; Is net
                call    set_exerr_locus_disk ; mov byte [EXTERR_LOCUS],errLOC_Disk ; 2
                mov     bl, es:[di+1]   ; [ES:DI+DPB.UNIT] ; Unit number
                les     di, es:[di+13h] ; [ES:DI+DPB.DRIVER_ADDR] ; Driver addr

got_dev_ptr:                            ; ...
                clc

ioctl_bad_drv:                          ; ...
                pop     ax
                retn
Get_Driver_BL   endp


; =============== S U B R O U T I N E =======================================


Check_If_Net    proc near               ; ...
                call    Get_Driver_BL
                jb      short ioctl_drv_err_pop ; invalid drive letter
                retn                    ; ZF = 1 if not a net device
; ---------------------------------------------------------------------------

ioctl_drv_err_pop:                      ; ...
                pop     ax
                jmp     ioctl_drv_err
Check_If_Net    endp ; sp-analysis failed

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR $IOCTL

ioctl_bad_funj4:                        ; ...
                jmp     ioctl_bad_fun
; ---------------------------------------------------------------------------

ioctl_string_errj:                      ; ...
                jmp     short ioctl_string_err
; ---------------------------------------------------------------------------

ioctl_drive_owner:                      ; ...
                call    Check_If_Net
                jnz     short ioctl_bad_funj4
                test    byte ptr es:[di+4], 40h ; [ES:DI+SYSDEV.ATT],DEV320
                jz      short ioctl_bad_funj4
                mov     ds:IOCALL_REQFUNC, 23 ; DEVGETOWN ; default to get owner
                cmp     al, 0Eh         ; Get Owner ?
                jz      short GetOwner
                mov     ds:IOCALL_REQFUNC, 24 ; DEVSETOWN

GetOwner:                               ; ...
                mov     al, 0Dh         ; OWNHL
                mov     ah, bl          ; Unit number
                mov     word ptr ds:IOCALL, ax ; [IOCALL_REQLEN]
                xor     ax, ax
                mov     ds:IOCALL_REQSTAT, ax
                push    es
                pop     ds
                mov     si, di          ; DS:SI -> driver
                push    ss
                pop     es
                assume es:DOSCODE
                mov     bx, offset IOCALL ; ES:BX -> Call header
                push    ds
                push    si
                call    DEVIOCALL2
                pop     si
                pop     ds
                test    byte ptr ss:IOCALL_REQSTAT+1, 80h ; (STERR>>8)
                jnz     short ioctl_string_errj
                mov     al, ss:IOCALL_REQUNIT ; Get owner returned by device
                                        ; owner returned is 1-based.
                jmp     SYS_RET_OK
; END OF FUNCTION CHUNK FOR $IOCTL

; =============== S U B R O U T I N E =======================================


DOS_DELETE      proc near               ; ...
                call    TestNet
                jnb     short LOCAL_DELETE
                mov     ax, 1113h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
                                        ; SS = DS = DOS CS, SDA first filename pointer -> fully-qualified filename in DOS CS
                                        ; SDA CDS pointer -> current directory structure for drive with file
                                        ; Return: CF set on error
                retn
; ---------------------------------------------------------------------------

LOCAL_DELETE:                           ; ...
                mov     ds:FOUNDDEL, 0  ; No files found and no files deleted
                call    ECritDisk
                mov     word ptr ds:CREATING, 0E500h ; DIRFREE*256+0 ; Assume not del *.*
                mov     si, ds:WFP_START

SKPNUL:                                 ; ...
                lodsb
                or      al, al
                jnz     short SKPNUL    ; go to end
                sub     si, 4           ; Back over possible "*.*"
                cmp     word ptr [si], 2E2Ah ; "*."
                jnz     short TEST_QUEST
                cmp     byte ptr [si+2], 2Ah ; '*'
                jz      short CHECK_ATTS

TEST_QUEST:                             ; ...
                sub     si, 9           ; Back over possible "????????.???"
                xchg    di, si
                push    ss
                pop     es
                mov     ax, 3F3Fh       ; '??'
                mov     cx, 4           ; four sets of "??"
                repe scasw
                jnz     short NOT_ALL
                xchg    di, si
                lodsw
                cmp     ax, 3F2Eh       ; ".?"
                jnz     short NOT_ALL
                lodsw
                cmp     ax, '??'        ; 3F3Fh
                jnz     short NOT_ALL

CHECK_ATTS:                             ; ...
                mov     al, ds:SATTRIB
                and     al, 1Fh         ; attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
                                        ; Look only at hidden bits
                cmp     al, 1Fh
                jnz     short NOT_ALL
                mov     ds:DELALL, 0    ; DEL *.* - flag deleting all

NOT_ALL:                                ; ...
                mov     ds:NoSetDir, 1
                call    GetPathNoSet
                jnb     short Del_found ; [CURBUF+2]:SI = First Cluster field in dir entry
                                        ; [CURBUF+2]:BX = Directory entry
                jnz     short _bad_path
                or      cl, cl
                jz      short _bad_path

No_file:                                ; ...
                mov     ax, 2           ; error_file_not_found

ErrorReturn:                            ; ...
                stc
                jmp     No_Set_Flag
; ---------------------------------------------------------------------------

_bad_path:                              ; ...
                mov     ax, 3           ; error_path_not_found
                jmp     short ErrorReturn
; ---------------------------------------------------------------------------

Del_found:                              ; ...
                jnz     short NOT_DIR   ; Check for dir specified
                cmp     ds:DELALL, 0    ; DelAll = 0 allows delete of dir.
                jz      short NOT_DIR

Del_access_err:                         ; ...
                mov     ax, 5
                jmp     short ErrorReturn
; ---------------------------------------------------------------------------

NOT_DIR:                                ; ...
                or      ah, ah          ; Check if device name
                js      short Del_access_err ; Can't delete I/O devices

DELFILE:                                ; ...
                or      ds:FOUNDDEL, 1  ; FILEFOUND ; file found, not deleted yet
                push    ds
                mov     ah, ds:DELALL
                lds     di, ds:CURBUF
                test    ss:ATTRIB, 1    ; attr_read_only ; are we deleting RO files too?
                jnz     short DoDelete
                test    byte ptr [bx+0Bh], 1 ; [BX+dir_entry.dir_attr],attr_read_only
                jz      short DoDelete  ; not read only

Skip_it:                                ; ...
                pop     ds
                jmp     short DELNXT    ; Skip it (Note ES:BP not set)
; ---------------------------------------------------------------------------

DoDelete:                               ; ...
                call    REN_DEL_Check   ; Sets ES:BP = [THISDPB]
                jb      short Skip_it

DEL_SHARE_OK:                           ;
                test    byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty
                jnz     short yesdirty
                call    INC_DIRTY_COUNT
                or      byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty

yesdirty:                               ; ...
                mov     [bx], ah        ; [BX+dir_entry.dir_name],AH ; Put in E5h or 0
                xor     bx, bx
                cmp     es:[bp+0Fh], bx
                jnz     short yesdirty_fc_1 ; not FAT32
                mov     bx, [si-6]      ; high word of the first cluster (FAT32)

yesdirty_fc_1:                          ; ...
                mov     ss:CLUSTNUM_HW, bx
                mov     bx, [si]
                pop     ds
                or      ds:FOUNDDEL, 10h ; FILEDELETED
                cmp     ds:CLUSTNUM_HW, 0
                jnz     short yesdirty_fc_2
                cmp     bx, 2

yesdirty_fc_2:                          ; ...
                jb      short DELNXT    ; File has invalid FIRCLUS (too small)
                cmp     word ptr es:[bp+0Fh], 0 ; [es:bp+DPB.FAT_SIZE]
                jnz     short yesdirty_fc_3
                push    bx
                mov     bx, ds:CLUSTNUM_HW
                cmp     bx, es:[bp+2Fh]
                pop     bx
                jnz     short yesdirty_fc_4
                cmp     bx, es:[bp+2Dh]
                jmp     short yesdirty_fc_4
; ---------------------------------------------------------------------------

yesdirty_fc_3:                          ; ...
                cmp     bx, es:[bp+0Dh] ; [ES:BP+DPB.MAX_CLUSTER]

yesdirty_fc_4:                          ; ...
                ja      short DELNXT    ; File has invalid FIRCLUS (too big)
                call    RELEASE         ; Free file data
                jb      short No_fileJ
                call    FastOpen_Delete

DELNXT:                                 ; ...
                les     bp, ds:THISDPB
                assume es:nothing
                call    GETENTRY        ; Registers need to be reset
                jb      short No_fileJ
                call    NEXTENT
                jb      short DELNXT2
                jmp     DELFILE
; ---------------------------------------------------------------------------

DELNXT2:                                ; ...
                les     bp, ds:THISDPB
                call    update_fat32_fsinfo
                mov     al, es:[bp+0]   ; [ES:BP+DPB.DRIVE]
                call    FLUSHBUF
                jb      short No_fileJ
                test    ds:FOUNDDEL, 10h ; FILEDELETE
                jz      short DelError
                test    ds:ATTRIB, 8    ; attr_volume_id
                jz      short No_Set_Flag
                push    ax
                push    es
                push    di
                les     di, ds:THISCDS
                xor     bh, bh
                mov     ah, es:[di]     ; Get drive
                sub     ah, 'A'         ; Convert to 0-based
                mov     ds:VOLCHNG_FLAG, ah
                call    Set_Media_ID
                call    FATREAD_CDS     ; force media check
                pop     di
                pop     es
                pop     ax

No_Set_Flag:                            ; ...
                call    LCritDisk
                retn
; ---------------------------------------------------------------------------

DelError:                               ; ...
                test    ds:FOUNDDEL, 1  ; FILEFOUND ; not deleted. Did we find file?
                jnz     short Del_access_errJ ; yes. Access denied

No_fileJ:                               ; ...
                jmp     No_file         ; Nope
; ---------------------------------------------------------------------------

Del_access_errJ:                        ; ...
                jmp     Del_access_err
DOS_DELETE      endp


; =============== S U B R O U T I N E =======================================


REN_DEL_Check   proc near               ; ...
                push    ds              ; check for access for rename and delete
                push    di
                push    ax
                push    bx
                push    si
                push    ss
                pop     es
                assume es:DOSCODE
                mov     di, ss:WFP_START ; points to name
                mov     si, bx
                mov     ds, word ptr ss:CURBUF+2
                assume ds:DOSCODE
                mov     bx, di          ; Set backup limit for skipback
                inc     bx              ; Skip over d: to point to leading '\'
                inc     bx
                call    StrLen          ; CX is length of ES:DI including NUL
                dec     cx              ; Don't include nul in count
                add     di, cx          ; Point to NUL at end of string
                call    SkipBack        ; Back up one element
                inc     di              ; Point to start of last element
                mov     ss:SAVE_BX, di  ; save for DOS_RENAME
                call    PackName        ; Transfer name from entry to ASCIZ tail.
                pop     si              ; Get back entry pointers
                pop     bx
                push    bx
                push    si              ; Back on stack
                push    ss
                pop     ds
                push    es              ; (not necessary) ; 31/01/2024
                push    di
                call    ShCloseFile     ; Call far [JShare+(13*4)] ; 13 = ShCloseFile
                cmp     fShare, 0FFh
                jnz     short rdc_1
                mov     word ptr THISSFT+2, es
                mov     word ptr THISSFT, di
                jmp     short rdc_2
; ---------------------------------------------------------------------------

rdc_1:                                  ; ...
                mov     word ptr THISSFT+2, ds
                mov     word ptr THISSFT, 765h ; AUXSTACK-SF_ENTRY.size
                                        ; RENAMEDMA+(384-59)

rdc_2:                                  ; ...
                pop     di
                pop     es
                assume es:nothing
                xor     ah, ah          ; Indicate file to DOOPEN (high bit off)
                call    DOOPEN          ; Fill in SFT for share check
                les     di, THISSFT
                mov     word ptr es:[di+2], 10h ; [ES:DI+SF_ENTRY.sf_mode],SHARING_DENY_BOTH
                                        ; requires exclusive access
                mov     word ptr es:[di], 1 ; [ES:DI+SF_ENTRY.sf_ref_count],1 ; Pretend open
                call    ShareEnter
                jb      short CheckDone
                les     di, THISSFT
                mov     word ptr es:[di], 0 ; [ES:DI+SF_ENTRY.sf_ref_count]
                                        ; Pretend closed and free
                call    ShareEnd        ; Tell sharer we're done with THISSFT
                clc

CheckDone:                              ; ...
                les     bp, THISDPB
                pop     si
                pop     bx
                pop     ax
                pop     di
                pop     ds
                assume ds:nothing
                retn
REN_DEL_Check   endp


; =============== S U B R O U T I N E =======================================


FastOpen_Delete proc near               ; ...

; FUNCTION CHUNK AT 6D16 SIZE 0000000B BYTES

                pushf
                push    si
                push    di
                push    bx
                push    ax
                mov     si, ss:WFP_START ; ds:si points to path name
                mov     al, 3           ; FONC_delete
                jmp     short fastinvoke
FastOpen_Delete endp

; ---------------------------------------------------------------------------

FastOpen_Rename:                        ; ...
                pushf
                push    si
                push    di
                push    bx
                push    ax
                mov     si, ss:REN_WFP  ; ds:si-->Path name addrs
                mov     di, offset NAME1 ; FONC_Rename
                mov     al, 6
; START OF FUNCTION CHUNK FOR FastOpen_Update
;   ADDITIONAL PARENT FUNCTION FastOpen_Delete

fastinvoke:                             ; ...
                mov     bx, offset FastTable_2
                call    dword ptr [bx]
                pop     ax
                pop     bx
                pop     di
                pop     si
                popf
                retn
; END OF FUNCTION CHUNK FOR FastOpen_Update

; =============== S U B R O U T I N E =======================================


FastOpen_Update proc near               ; ...

; FUNCTION CHUNK AT 6D16 SIZE 0000000B BYTES

                pushf
                push    si
                push    di
                push    bx
                push    ax
                mov     al, 4           ; FONC_update
                jmp     short fastinvoke
FastOpen_Update endp


; =============== S U B R O U T I N E =======================================


Fast_Dispatch   proc near               ; ...
                mov     si, offset FastTable_2
                call    dword ptr ss:[si] ; CALL far [SS:SI]
                retn
Fast_Dispatch   endp


; =============== S U B R O U T I N E =======================================


DOS_RENAME      proc near               ; ...
                call    TestNet
                jnb     short LOCAL_RENAME
                mov     ax, 1111h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
                                        ; SS = DS = DOS CS, SDA first filename pointer = offset of fully-qualified old name
                                        ; SDA CDS pointer -> current directory
                                        ; Return: CF set on error
                retn
; ---------------------------------------------------------------------------

LOCAL_RENAME:                           ; ...
                call    set_exerr_locus_disk
                mov     si, ds:WFP_START
                mov     di, ds:REN_WFP
                mov     al, [si]
                mov     ah, [di]
                or      ax, 2020h       ; Lower case
                cmp     al, ah
                jz      short SAMEDRV
                mov     ax, 11h         ; error_not_same_device
                stc
                retn
; ---------------------------------------------------------------------------

SAMEDRV:                                ; ...
                push    word ptr ds:DMAADD+2
                push    word ptr ds:DMAADD
                mov     word ptr ds:DMAADD+2, ds
                mov     word ptr ds:DMAADD, offset RENAMEDMA
                mov     ds:FOUND_DEV, 0 ; Rename fails on DEVS, assume not a dev
                call    ECritDisk
                call    DOS_SEARCH_FIRST ; Sets [NoSetDir] to 1,
                                        ; [CURBUF+2]:BX points to entry
                jnb     short Check_Dev
                cmp     ax, 12h         ; error_no_more_files
                jnz     short GOTERR
                mov     ax, 2           ; error_file_not_found

GOTERR:                                 ; ...
                stc

RENAME_POP:                             ; ...
                pop     word ptr ds:DMAADD
                pop     word ptr ds:DMAADD+2
                call    LCritDisk
                retn
; ---------------------------------------------------------------------------

Check_Dev:                              ; ...
                mov     ax, 5           ; error_access_denied
                push    ds
                lds     si, ds:DMAADD   ; check if source a dir
                add     si, 21          ; find_buf.attr
                test    byte ptr [si+0Bh], 10h ; [SI+dir_entry.dir_attr],attr_directory
                jz      short notdir
                mov     si, ds:REN_WFP  ; if yes
                call    Check_PathLen2  ; make sure path length < PATHNAMELEN (67)

notdir:                                 ; ...
                pop     ds
                ja      short GOTERR
                cmp     ds:FOUND_DEV, 0
                jnz     short GOTERR
                mov     si, bx
                add     si, 26          ; dir_entry.dir_first
                call    REN_DEL_Check
                jnb     short REN_OK1
                mov     ax, 20h         ; error_sharing_violation

RENAME_POPJ:                            ; ...
                jmp     short RENAME_POP
; ---------------------------------------------------------------------------

REN_OK1:                                ; ...
                lds     si, ds:DMAADD
                add     si, 21          ; find_buf.attr
                test    byte ptr [si+0Bh], 10h ; [SI+dir_entry.dir_attr],attr_directory
                jnz     short SWAP_SOURCE
                call    FastOpen_Delete ; delete dir info in fastopen

SWAP_SOURCE:                            ; ...
                mov     ax, ds:WFP_START ; Swap source and destination
                mov     si, ds:REN_WFP
                mov     ds:WFP_START, si
                mov     ds:REN_WFP, ax
                mov     ds:CURR_DIR_END, 0FFFFh ; -1 ; No current dir on dest
                mov     word ptr ds:CREATING, 0E5FFh ; DIRFREE*256+0FFh
                                        ; Creating, not DEL *.*
                call    GetPathNoSet
                jb      short NODEST
                or      ah, ah          ; Device?
                jns     short SAVEDEST  ; No, continue

BAD_ACC:                                ; ...
                mov     ax, 5           ; error_access_denied
                stc

RENAME_CLEAN:                           ; ...
                pushf
                push    ax
                les     bp, ds:THISDPB
                call    update_fat32_fsinfo
                mov     al, ds:THISDRV
                call    FLUSHBUF
                pop     ax
                cmp     ds:FAILERR, 0
                jnz     short BAD_ERR
                popf
                jmp     short RENAME_POPJ
; ---------------------------------------------------------------------------

BAD_ERR:                                ; ...
                pop     ax
                mov     ax, 3           ; error_path_not_foun
                jmp     GOTERR
; ---------------------------------------------------------------------------

NODEST:                                 ; ...
                jnz     short BAD_PATH
                cmp     ds:FAILERR, 0
                jnz     short BAD_PATH  ; Search for dest failed
                or      cl, cl
                jnz     short SAVEDEST

BAD_PATH:                               ; ...
                mov     ax, 3
                stc
                jmp     short RENAME_POPJ
; ---------------------------------------------------------------------------

SAVEDEST:                               ; ...
                push    ss
                pop     es
                assume es:DOSCODE
                mov     di, offset NAME2
                mov     si, offset NAME1
                mov     cx, 11
                rep movsb               ; Save dest with metas at NAME2
                mov     ax, ds:DIRSTART_HW
                mov     ds:DESTSTART_HW, ax
                mov     ax, ds:DIRSTART
                mov     ds:DESTSTART, ax

BUILDDEST:                              ; ...
                push    ss
                pop     es              ; needed due to JMP BUILDDEST below
                mov     bx, (offset RENAMEDMA+15h) ; Source of replace chars
                mov     di, offset NAME1 ; Real dest name goes here
                mov     si, offset NAME2 ; Raw dest
                mov     cx, 11
                call    NEW_RENAME      ; replace ? chars
                mov     ds:ATTRIB, 16h  ; attr_all
                                        ; Stop duplicates with any attributes
                mov     ds:CREATING, 0FFh
                call    DEVNAME         ; Check if we built a device name
                jnb     short BAD_ACC
                mov     bx, ds:DESTSTART_HW
                mov     ds:ROOTCLUST_HW, bx
                mov     bx, ds:DESTSTART
                les     bp, ds:THISDPB
                assume es:nothing
                call    SETDIRSRCH      ; Reset search to start of dir
                jb      short BAD_ACCJ  ; Screw up
                call    FINDENTRY       ; See if new name already exists
                jnb     short BAD_ACCJ  ; Error if found
                cmp     ds:FAILERR, 0
                jnz     short BAD_ACCJ  ; Find failed because user FAILed to I 24
                mov     ax, ds:DESTSTART ; DIRSTART of dest
                mov     dx, ds:DESTSTART_HW
                les     bp, ds:THISDPB
                cmp     word ptr es:[bp+0Fh], 0 ; [es:bp+DPB.FAT_SIZE]
                jnz     short builddst_1 ; not FAT32
                cmp     dx, word ptr ds:RENAMEDMA+11h
                jnz     short builddst_2

builddst_1:                             ; ...
                cmp     ax, word ptr ds:RENAMEDMA+0Fh ; DIRSTART_HW of source
                jz      short SIMPLE_RENAME ; If =, just give new name

builddst_2:                             ; ...
                mov     al, ds:RENAMEDMA+20h ; RENAMEDMA+21+dir_entry.dir_attr]
                test    al, 10h         ; attr_directory
                jnz     short BAD_ACCJ  ; Can only do a simple rename on dirs,
                                        ; otherwise the . and .. entries get wiped.
                mov     ds:ATTRIB, al
                mov     word ptr ds:THISSFT+2, ds
                mov     si, (offset RENAMEDMA+145h) ; AUXSTACK-SF_ENTRY.size
                                        ; RENAMEDMA+325
                mov     word ptr ds:THISSFT, si
                mov     word ptr [si+2], 2 ; [SI+SF_ENTRY.sf_mode],
                                        ; SHARING_COMPAT+open_for_both
                xor     cx, cx          ; Set "device ID" for call into makenode
                call    RENAME_MAKE     ; This is in mknode
                jnb     short GOT_DEST

BAD_ACCJ:                               ; ...
                jmp     BAD_ACC
; ---------------------------------------------------------------------------

GOT_DEST:                               ; ...
                push    bx
                les     di, ds:THISSFT  ; RENAME_MAKE entered this into sharing
                call    ShareEnd        ; we need to remove it.
                pop     bx
                les     di, ds:CURBUF
                call    SET_BUF_DIRTY
                mov     di, bx
                add     di, 11          ; dir_entry.dir_attr ; skip name
                mov     si, (offset RENAMEDMA+20h) ; RENAMEDMA+21+dir_entry.dir_attr
                mov     cx, 21          ; dir_entry.size-dir_entry.dir_attr
                rep movsb
                call    GET_SOURCE
                jb      short RENAME_OVER
                mov     di, bx
                mov     es, word ptr ds:CURBUF+2
                assume es:DOSCODE
                mov     al, 0E5h        ; DIRFREE
                stosb
                jmp     short DIRTY_IT
; ---------------------------------------------------------------------------

SIMPLE_RENAME:                          ; ...
                call    GET_SOURCE
                jb      short RENAME_OVER
                mov     di, bx
                mov     es, word ptr ds:CURBUF+2
                assume es:nothing
                mov     si, offset NAME1
                mov     cx, 11
                rep movsb

DIRTY_IT:                               ; ...
                mov     di, word ptr ds:CURBUF
                call    SET_BUF_DIRTY
                push    si
                lds     si, ds:DMAADD
                add     si, 21          ; find_buf.attr
                test    byte ptr [si+0Bh], 10h ; [SI+dir_entry.dir_attr],
                                        ; attr_directory
                jz      short NOT_DIR2
                call    FastOpen_Rename

NOT_DIR2:                               ; ...
                pop     si
                mov     si, (offset RENAMEDMA+1)
                call    ECritDisk
                mov     ds:CREATING, 0  ; Correct setting for search
                call    RENAME_NEXT
                jb      short RENAME_OVER
                lea     si, [bx+1Ah]    ; [BX+dir_entry.dir_first]
                call    REN_DEL_Check
                jnb     short REN_OK2
                mov     ax, 20h         ; error_sharing_violation

jmp_to_rename_clean:                    ; ...
                jmp     RENAME_CLEAN
; ---------------------------------------------------------------------------

REN_OK2:                                ; ...
                mov     al, ds:RENAMEDMA+20h ; [RENAMEDMA+21+dir_entry.dir_attr]
                test    al, 10h         ; attr_directory
                jz      short Ren_Directory
                call    FastOpen_Delete

jmp_to_builddest:                       ; ...
                jmp     BUILDDEST
; ---------------------------------------------------------------------------

Ren_Directory:                          ; ...
                call    FastOpen_Rename
                jmp     short jmp_to_builddest
; ---------------------------------------------------------------------------

RENAME_OVER:                            ; ...
                clc
                jmp     short jmp_to_rename_clean
DOS_RENAME      endp


; =============== S U B R O U T I N E =======================================


GET_SOURCE      proc near               ; ...
                les     bp, ds:THISDPB
                xor     bx, bx
                cmp     es:[bp+0Fh], bx ; DPB.FAT_SIZE > 0 ?
                jnz     short gs_cont   ; yes, it is not FAT32
                mov     bx, word ptr ds:RENAMEDMA+11h ; DirStart+2

gs_cont:                                ; ...
                mov     ds:ROOTCLUST_HW, bx ; hw of cluster number
                mov     bx, word ptr ds:RENAMEDMA+0Fh ; DirStart
                call    SETDIRSRCH
                jb      short gs_ret_label
                call    STARTSRCH
                mov     ax, word ptr ds:RENAMEDMA+0Dh ; Lastent
                call    GETENT

gs_ret_label:                           ; ...
                retn
GET_SOURCE      endp


; =============== S U B R O U T I N E =======================================


NEW_RENAME      proc near               ; ...
                lodsb
                cmp     al, '?'         ; 3Fh
                jnz     short NOCHG
                mov     al, [bx]        ; Get replace char

NOCHG:                                  ; ...
                stosb
                inc     bx              ; Next replace char
                loop    NEW_RENAME
                retn
NEW_RENAME      endp


; =============== S U B R O U T I N E =======================================


GET_FILE_INFO   proc near               ; ...
                call    TestNet
                jnb     short LOCAL_INFO
                mov     ax, 110Fh
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
                                        ; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
                                        ; SDA CDS pointer -> current directory
                                        ; Return: CF set on error, AX = file attributes
                retn
; ---------------------------------------------------------------------------

LOCAL_INFO:                             ; ...
                call    ECritDisk
                mov     ds:NoSetDir, 1  ; if we find a dir, don't change to it
                call    GET_FAST_PATH
                jnb     short info_check_dev

NO_PATH:                                ; ...
                jnz     short bad_path1
                or      cl, cl
                jz      short bad_path1

info_no_file:                           ; ...
                mov     ax, 2           ; error_file_not_found

BadRet:                                 ; ...
                stc

JustRet:                                ; ...
                call    LCritDisk
                retn
; ---------------------------------------------------------------------------

bad_path1:                              ; ...
                mov     ax, 3           ; error_path_not_found
                jmp     short BadRet
; ---------------------------------------------------------------------------

info_check_dev:                         ; ...
                or      ah, ah
                js      short info_no_file ; device
                cmp     word ptr ds:CURBUF, 0FFFFh ; -1 ; is it a root dir?
                jnz     short not_root  ; no, CurBuf ptr is valid
                xor     ah, ah
                mov     al, 10h         ; attr_directory
                clc
                jmp     short JustRet
; ---------------------------------------------------------------------------

not_root:                               ; ...
                push    ds
                mov     ds, word ptr ds:CURBUF+2
                mov     si, bx
                xor     bx, bx          ; Assume size=0 (dir)
                mov     di, bx
                mov     cx, [si+16h]    ; [SI+dir_entry.dir_time]
                mov     dx, [si+18h]    ; [SI+dir_entry.dir_date]
                xor     ah, ah
                mov     al, [si+0Bh]    ; [SI+dir_entry.dir_attr]
                test    al, 10h         ; attr_directory
                jnz     short NO_SIZE
                mov     di, [si+1Ch]    ; [SI+dir_entry.dir_size_l]
                mov     bx, [si+1Eh]    ; [SI+dir_entry.dir_size_h]

NO_SIZE:                                ; ...
                pop     ds
                clc

OK_BYE:                                 ; ...
                jmp     short JustRet
GET_FILE_INFO   endp


; =============== S U B R O U T I N E =======================================


SET_FILE_ATTRIBUTE proc near            ; ...
                test    ax, 0FFD8h      ; ~attr_changeable
                jz      short set_look

_BAD_ACC:                               ; ...
                call    set_exerr_locus_unk
                mov     ds:EXTERR_CLASS, 7 ; errCLASS_Apperr
                mov     ds:EXTERR_ACTION, 4 ; errACT_Abort
                mov     ax, 5           ; error_access_denied
                stc
                retn
; ---------------------------------------------------------------------------

set_look:                               ; ...
                call    TestNet
                jnb     short LOCAL_SET
                push    ax
                mov     ax, 110Eh
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
                                        ; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
                                        ; SDA CDS pointer -> current directory
                                        ; STACK: WORD new file attributes
                                        ; Return: CF set on error
                pop     bx
                retn
; ---------------------------------------------------------------------------

LOCAL_SET:                              ; ...
                call    ECritDisk
                push    ax              ; Save new attributes
                mov     ds:NoSetDir, 1  ; if we find a dir, don't change to it
                call    GETPATH
                jnb     short set_check_device
                pop     bx              ; Clean stack (don't zap AX)
                jmp     short NO_PATH
; ---------------------------------------------------------------------------

set_check_device:                       ; ...
                or      ah, ah
                jns     short set_check_share
                pop     ax
                call    LCritDisk
                jmp     short _BAD_ACC  ; device
; ---------------------------------------------------------------------------

set_check_share:                        ; ...
                pop     ax              ; Get new attributes
                cmp     word ptr ds:CURBUF, 0FFFFh ; -1 ; is this the root dir
                jz      short cannot_set_root ; return error
                call    REN_DEL_Check
                jnb     short set_do
                mov     ax, 20h         ; error_sharing_violation

jmp_to_OK_BYE:                          ; ...
                jmp     short OK_BYE
; ---------------------------------------------------------------------------

cannot_set_root:                        ; ...
                mov     ax, 5           ; error_access_denied
                stc
                jmp     short OK_BYE
; ---------------------------------------------------------------------------

set_do:                                 ; ...
                les     di, ds:CURBUF
                and     byte ptr es:[bx+0Bh], 0D8h ; [ES:BX+dir_entry.dir_attr],
                                        ; ~attr_changeable
                or      es:[bx+0Bh], al
                call    SET_BUF_DIRTY
                mov     al, ds:THISDRV
                push    dx
                push    di
                mov     ah, 0           ; dir entry update
                mov     dl, al          ; drive number A=0,B=1,,
                mov     di, bx
                call    FastOpen_Update
                pop     di
                pop     dx
                call    FLUSHBUF
                jnb     short jmp_to_OK_BYE
                jmp     info_no_file
SET_FILE_ATTRIBUTE endp


; =============== S U B R O U T I N E =======================================


GET_FAST_PATH   proc near               ; ...
                or      ss:FastOpenFlg, 1 ; FastOpen_Set
                call    GETPATH
                pushf
                and     ss:FastOpenFlg, 80h ; Fast_yes
                popf
                retn
GET_FAST_PATH   endp


; =============== S U B R O U T I N E =======================================


DOS_DUP         proc near               ; ...
                mov     es, cs:DosDSeg
                les     di, es:THISSFT

DOS_Dup_Direct:                         ; ...
                call    IsSFTNet
                jnz     short DO_INC
                call    DEV_OPEN_SFT

DO_INC:                                 ; ...
                inc     word ptr es:[di] ; [ES:DI+SF_ENTRY.sf_ref_count]
                retn
DOS_DUP         endp

; ---------------------------------------------------------------------------

DOS_CREATE:                             ; ...
                xor     ah, ah          ; 0 ; Truncate is OK

Create_inter:                           ; ...
                test    al, 80h         ; ~(attr_all+attr_ignore+attr_volume_id)
                jnz     short AttErr
                test    al, 8           ; attr_volume_id
                jz      short NoReset
                or      byte ptr ds:DOS34_FLAG, 80h ; DBCS_VOLID
                mov     al, 8           ; attr_volume_id

NoReset:                                ; ...
                or      al, 20h         ; attr_archive ; File changed
                test    al, 50h         ; attr_directory+attr_device
                jz      short ATT_OK

AttErr:                                 ; ...
                mov     ax, 5           ; Attribute problem
                call    set_exerr_locus_unk ; MOV byte [EXTERR_LOCUS],errLOC_Unk ; 1
                jmp     short SET_MKND_ERR ; Gotta use MKDIR to make dirs,
                                        ; NEVER allow attr_device to be set
; ---------------------------------------------------------------------------

ATT_OK:                                 ; ...
                les     di, ds:THISSFT
                push    es
                les     si, ds:THISCDS
                cmp     si, 0FFFFh      ; -1
                jnz     short TEST_RE_NET
                pop     es
                test    ds:EXTOPEN_ON, 1 ; EXT_OPEN_ON  ; extended open ?
                jz      short NOEXTOP   ; no, do normal

IFS_extopen:                            ; ...
                push    ax
                mov     ax, 112Eh       ; (MultNET SHL 8) OR 46

NOEXTOP2:                               ; ...
                int     2Fh             ; Multiplex - DOS 4 IFSFUNC.EXE - ???
                                        ; SS = DS = DOS CS, STACK: WORD ??? low byte = ???
                                        ; Return: CF set on error
                                        ; CF clear if successful
                pop     bx              ; (BX is trashed anyway)
                mov     ds:EXTOPEN_ON, 0
                retn
; ---------------------------------------------------------------------------

NOEXTOP:                                ; ...
                push    ax
                mov     ax, 1118h       ; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE
                                        ; ES:DI -> uninitialized SFT, SS = DOS CS
                                        ; SDA first filename pointer -> fully-qualified name of file
                                        ; STACK: WORD file creation mode???
                jmp     short NOEXTOP2
; ---------------------------------------------------------------------------

TEST_RE_NET:                            ; ...
                test    byte ptr es:[si+44h], 80h ; [ES:SI+curdir.flags+1],curdir_isnet>>8
                pop     es
                jz      short LOCAL_CREATE
                call    Set_EXT_mode
                jb      short dochk
                or      word ptr es:[di+2], 2 ; [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both

dochk:                                  ; ...
                test    ds:EXTOPEN_ON, 1 ; EXT_OPEN_ON
                jnz     short IFS_extopen
                push    ax
                mov     ax, 1117h       ; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
                                        ; ES:DI -> uninitialized SFT, SS = DOS CS
                                        ; SDA first filename pointer -> fully-qualified name of file to open
                                        ; SDA CDS pointer -> current directory
                                        ; Return: CF set on error
                jmp     short NOEXTOP2
; ---------------------------------------------------------------------------

LOCAL_CREATE:                           ; ...
                call    Set_EXT_mode
                jb      short setdone
                or      word ptr es:[di+2], 2 ; [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both

setdone:                                ; ...
                call    ECritDisk
                call    MakeNode
                jnb     short Create_ok
                mov     ds:VOLCHNG_FLAG, 0FFh ; -1
                call    LCritDisk
; START OF FUNCTION CHUNK FOR DOS_MKDIR

SET_MKND_ERR:                           ; ...
                mov     bx, offset CRTERRTAB
                xlat    byte ptr cs:[bx]
                stc
                retn
; END OF FUNCTION CHUNK FOR DOS_MKDIR
; ---------------------------------------------------------------------------
CRTERRTAB       db 0                    ; ...
                db 5                    ; error_access_denied ; MakeNode error 1
                db 52h                  ; error_cannot_make
                db 50h                  ; error_file_exists
                db 3                    ; error_path_not_found
                db 5                    ; error_access_denied
                db 20h                  ; error_sharing_violation ; MakeNode error 6
                db 2                    ; error_file_not_found ; MakeNode error 7
; ---------------------------------------------------------------------------

Create_ok:                              ; ...
                call    FastOpen_Delete
                mov     al, ds:SATTRIB
                test    al, 8           ; attr_volume_id
                jz      short NoVolLabel
                les     di, ds:THISCDS
                mov     ah, es:[di]     ; [ES:DI+curdir.text] ; get drive letter
                sub     ah, 41h ; 'A'   ; convert to drive number
                mov     ds:VOLCHNG_FLAG, ah ; Set flag to indicate volid change
                mov     bh, 1           ; set volume id to boot record
                call    Set_Media_ID
                call    ECritDisk
                call    FATREAD_CDS     ; force a media check
                call    LCritDisk

NoVolLabel:                             ; ...
                mov     ax, 2
                les     di, ds:THISSFT
                call    ds:ShSU         ; call far [JShare+(14*4)] ; 14 = ShSU
                call    LCritDisk
                jmp     SET_SFT_MODE
; ---------------------------------------------------------------------------

DOS_Create_New:                         ; ...
                mov     ah, 1
                jmp     Create_inter

; =============== S U B R O U T I N E =======================================


Set_Media_ID    proc near               ; ...
                push    ax
                push    es
                push    di
                inc     ah
                mov     bl, ah
                mov     al, 0Dh         ; generic IOCTL
                mov     cx, 4866h       ; ch = FAT32 disk drive (CATEGORY CODE)
                                        ; cl = minor code,
                                        ;      get volume serial number (and name)
                mov     dx, offset FAKE_STACK_2F ; Packet_Temp

Set_Media_ID_1:                         ; ...
                push    cx
                push    bx
                push    dx
                xor     bh, bh
                call    $IOCTL
                pop     dx
                pop     bx
                pop     cx
                jnb     short Set_Media_ID_2
                cmp     ch, 48h         ; is it FAT32 disk drive request?
                stc
                jnz     short geterr    ; (ch=8 request failed!)
                mov     ch, 8           ; set category code for (old) FAT disk drive
                                        ; (except FAT32)
                jmp     short Set_Media_ID_1 ; and try again
; ---------------------------------------------------------------------------

Set_Media_ID_2:                         ; ...
                or      bh, bh
                jz      short NoName
                mov     si, offset NAME1
                jmp     short doset
; ---------------------------------------------------------------------------

NoName:                                 ; ...
                mov     si, offset NO_NAME_ID ; "NO NAME    "

doset:                                  ; ...
                mov     di, dx
                add     di, 6           ; MEDIA_ID_INFO.MEDIA_Label
                push    ss
                pop     ds
                assume ds:DOSCODE
                push    ss
                pop     es
                assume es:DOSCODE
                push    cx
                mov     cx, 11
                rep movsb
                pop     cx
                mov     cl, 46h         ; set volume serial number (and name)
                mov     al, 0Dh         ; generic IOCTL
                xor     bh, bh
                call    $IOCTL

geterr:                                 ; ...
                push    ss
                pop     ds
                pop     di
                pop     es
                assume es:nothing
                pop     ax
                retn
Set_Media_ID    endp


; =============== S U B R O U T I N E =======================================


Set_EXT_mode    proc near               ; ...
                test    ss:EXTOPEN_ON, 1 ; EXT_OPEN_ON ; from extended open
                jz      short NOTEX     ; no, do normal
                push    ax
                mov     ax, ss:SAVE_BX
                or      es:[di+2], ax   ; [ES:DI+SF_ENTRY.sf_mode]
                pop     ax
                stc

NOTEX:                                  ; ...
                retn
Set_EXT_mode    endp

; ---------------------------------------------------------------------------

DOS_OPEN:                               ; ...
                mov     NoSetDir, 0
                call    Check_Access_AX
                jb      short do_ret_label
                les     di, THISSFT
                xor     ah, ah
                mov     es:[di+2], al   ; [ES:DI+SF_ENTRY.sf_mode]
                push    es
                les     si, THISCDS
                cmp     si, 0FFFFh      ; -1
                jnz     short TEST_RE_NET1
                pop     es
                test    EXTOPEN_ON, 1   ; EXT_OPEN_ON
                jz      short _NOEXTOP  ; do normal

_IFS_extopen:                           ; ...
                mov     al, byte ptr SAVE_BX
                push    ax              ; pass create attr to IFS
                mov     ax, 112Eh       ; (MultNET*256)+46
                int     2Fh             ; Multiplex - DOS 4 IFSFUNC.EXE - ???
                                        ; SS = DS = DOS CS, STACK: WORD ??? low byte = ???
                                        ; Return: CF set on error
                                        ; CF clear if successful
                pop     bx              ; trash bx

do_ret_label:                           ; ...
                retn
; ---------------------------------------------------------------------------

_NOEXTOP:                               ; ...
                test    DOS_FLAG, 1     ; EXECOPEN
                jz      short not_exec_open
                test    byte ptr DOS34_FLAG+1, 8 ; (EXEC_AWARE_REDIR>>8)
                jz      short not_exec_open
                mov     al, 23h         ; SHARING_DENY_WRITE+EXEC_OPEN

not_exec_open:                          ; ...
                push    ax
                mov     ax, 1116h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE
                                        ; ES:DI -> uninitialized SFT, SS = DOS CS
                                        ; SDA first filename pointer -> fully-qualified name of file to open
                                        ; STACK: WORD file open mode
                                        ; Return: CF set on error
                pop     bx
                retn
; ---------------------------------------------------------------------------

TEST_RE_NET1:                           ; ...
                test    word ptr es:[si+43h], 8000h ; [ES:SI+curdir.flags],curdir_isnet
                pop     es
                jz      short LOCAL_OPEN
                test    EXTOPEN_ON, 1   ; EXT_OPEN_ON
                jnz     short _IFS_extopen
                jmp     short _NOEXTOP  ; do_net_int2f
; ---------------------------------------------------------------------------

LOCAL_OPEN:                             ; ...
                call    ECritDisk
                or      FastOpenFlg, 5  ; FastOpen_Set+Special_Fill_Set
                call    GETPATH
                jnb     short Open_found
                jnz     short bad_path2
                or      cl, cl
                jz      short bad_path2
                mov     ax, 2           ; error_file_not_found

OpenBadRet:                             ; ...
                and     ss:FastOpenFlg, 80h
                stc
                call    LCritDisk
                jmp     Clear_FastOpen  ; (retn)
; ---------------------------------------------------------------------------

bad_path2:                              ; ...
                mov     ax, 3           ; error_path_not_found
                jmp     short OpenBadRet
; ---------------------------------------------------------------------------

Open_Bad_Access:                        ; ...
                mov     ax, 5           ; error_access_denied
                jmp     short OpenBadRet
; ---------------------------------------------------------------------------

Open_found:                             ; ...
                jz      short Open_Bad_Access
                or      ah, ah
                js      short open_ok   ; Devices don't have attributes
                mov     es, word ptr CURBUF+2 ; get buffer location
                assume es:DOSCODE
                mov     al, es:[bx+0Bh] ; [ES:BX+dir_entry.dir_attr]
                test    al, 8           ; attr_volume_id
                jnz     short Open_Bad_Access ; can't open volume ids
                test    al, 1           ; attr_read_only ; check write on read only
                jz      short open_ok
                push    ds
                push    si
                lds     si, THISSFT
                assume ds:nothing
                mov     cx, [si+2]      ; [SI+SF_ENTRY.sf_mode]
                test    cx, 8000h       ; sf_isFCB ; is it FCB?
                jnz     short ResetAccess ; yes, reset the access
                mov     dl, cl
                and     dl, 0F0h        ; SHARING_MASK
                cmp     dl, 70h         ; SHARING_NET_FCB ; is it net FCB?
                jnz     short NormalOpen ; no

ResetAccess:                            ; ...
                and     cx, 0FFFCh      ; ~3 ; ~open_mode_mask ; clear access
                mov     [si+2], cx      ; [SI+SF_ENTRY.sf_mode]
                jmp     short FillSFT
; ---------------------------------------------------------------------------

NormalOpen:                             ; ...
                and     cl, 3           ; it was 'and cl,0Fh' in MSDOS 6.22
                                        ; (and cl,access_mask)
                                        ; this may be open_mode_mask
                cmp     cl, 0           ; open_for_read ; is it open for read?
                jz      short FillSFT   ; yes
                pop     si
                pop     ds
                jmp     short Open_Bad_Access
; ---------------------------------------------------------------------------

FillSFT:                                ; ...
                pop     si
                pop     ds

open_ok:                                ; ...
                call    DOOPEN          ; Fill in SFT
                and     ss:FastOpenFlg, 80h ; Fast_yes
                call    DO_SHARE_CHECK
                jnb     short SHARE_OK
                call    LCritDisk
                jmp     short Clear_FastOpen ; (retn)
; ---------------------------------------------------------------------------

SHARE_OK:                               ; ...
                mov     ax, 3
                les     di, ds:THISSFT
                assume es:nothing
                call    ds:ShSU         ; call far [JShare+(14*4)] ; 14 = ShSU
                call    LCritDisk

SET_SFT_MODE:                           ; ...
                les     di, ds:THISSFT  ; Finish SFT initialization for new reference
                call    DEV_OPEN_SFT
                test    word ptr es:[di+2], 8000h ; [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
                jz      short Clear_FastOpen ; sf_mode correct
                mov     ax, ds:CurrentPDB
                mov     es:[di+31h], ax ; [ES:DI+SF_ENTRY.sf_PID]
                                        ; For FCB sf_PID=PDB

Clear_FastOpen:                         ; ...
                retn

; =============== S U B R O U T I N E =======================================


SHARE_ERROR     proc near               ; ...
                test    word ptr es:[di+2], 8000h ; [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
                jnz     short _HARD_ERR
                mov     cl, es:[di+2]   ; [ES:DI+SF_ENTRY.sf_mode]
                and     cl, 0F0h        ; SHARING_MASK
                cmp     cl, 0
                jnz     short _NO_HARD_ERR

_HARD_ERR:                              ; ...
                call    SHARE_VIOLATION
                jnb     short Clear_FastOpen ; User wants retry

_NO_HARD_ERR:                           ; ...
                mov     ax, 20h
                stc
                retn
SHARE_ERROR     endp


; =============== S U B R O U T I N E =======================================


DO_SHARE_CHECK  proc near               ; ...
                call    ECritDisk       ; enter critical section

OPN_RETRY:                              ; ...
                mov     cx, ds:RetryCount

OpenShareRetry:                         ; ...
                push    cx              ; Save number left to do
                call    SHARE_CHECK     ; Final Check
                pop     cx              ; CX = # left
                jnb     short Share_Ok2 ; No problem with access
                call    Idle
                loop    OpenShareRetry  ; One more retry used up
                les     di, ds:THISSFT
                call    SHARE_ERROR
                jnb     short OPN_RETRY ; User wants more retry

Share_Ok2:                              ; ...
                call    LCritDisk       ; leave critical section
                retn
DO_SHARE_CHECK  endp


; =============== S U B R O U T I N E =======================================


Check_Access_AX proc near               ; ...
                mov     ds:OPEN_ACCESS, al ; Sharing Mode (bit 4 to 7)
                                        ; Access Mode (bit 0 to 3)
                push    bx
                mov     bl, al
                and     bl, 0F0h        ; SHARING_MASK
                cmp     ds:FSHARING, 0
                jz      short CheckShareMode ; not through server call, must be ok
                cmp     bl, 70h         ; SHARING_NET_FCB
                jz      short CheckAccessMode ; we have an FCB

CheckShareMode:                         ; ...
                cmp     bl, 40h         ; is this a good sharing mode?
                ja      short Make_Bad_Access

CheckAccessMode:                        ; ...
                mov     bl, al
                and     bl, 3           ; access_mask = 0Fh
                cmp     bl, 2
                ja      short Make_Bad_Access
                pop     bx
                clc
                retn
; ---------------------------------------------------------------------------

Make_Bad_Access:                        ; ...
                mov     ax, 0Ch         ; error_invalid_access
                pop     bx
                stc
                retn
Check_Access_AX endp


; =============== S U B R O U T I N E =======================================


DISK_INFO       proc near               ; ...
                call    TestNet
                jnb     short LOCAL_DSK_INFO
                xor     si, si          ; free cluster count hw = 0
                xor     di, di          ; number of clusters hw = 0
                mov     ax, 110Ch
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
                                        ; ES:DI -> current directory
                                        ; Return: AL = sectors per cluster, BX = total clusters
                                        ; CX = bytes per sector, DX = number of available clusters
                cmp     bx, 0FFFFh
                jnz     short dsk_info_1
                mov     di, bx

dsk_info_1:                             ; ...
                cmp     dx, 0FFFFh
                jnz     short disk_info_retn
                mov     si, dx

disk_info_retn:                         ; ...
                retn
; ---------------------------------------------------------------------------

LOCAL_DSK_INFO:                         ; ...
                call    set_exerr_locus_disk ; mov byte [EXTERR_LOCUS],errLOC_Disk
                call    ECritDisk
                call    FATREAD_CDS     ; perform media check
                jb      short dsk_info_2
                xor     ax, ax
                mov     ds:CLUSTNUM_HW, ax ; clear high word of cluster number
                mov     bx, 2           ; Get first FAT sector into CURBUF
                call    UNPACK

dsk_info_2:                             ; ...
                jnb     short dsk_info_3
                jmp     CRIT_LEAVE
; ---------------------------------------------------------------------------

dsk_info_3:                             ; ...
                lds     si, ds:CURBUF
                mov     ah, [si+24]     ; [SI+BUFINSIZ] ; get FAT ID BYTE
                push    ss
                pop     ds
                assume ds:DOSCODE
                xor     si, si
                mov     di, si
                mov     dx, es:[bp+1Fh] ; [ES:BP+DPB.FREE_CNT] ; get free count
                cmp     es:[bp+0Fh], si ; FAT32 (16 bit FAT size = 0) ?
                jz      short dsk_info_4 ; yes
                mov     cx, es:[bp+0Dh] ; [ES:BP+DPB.MAX_CLUSTER]
                jmp     short dsk_info_5 ; zf=0, si=di=0
; ---------------------------------------------------------------------------

dsk_info_4:                             ; ...
                mov     di, es:[bp+2Fh] ; DPB.LAST_CLUSTER+2
                mov     cx, es:[bp+2Dh] ; DPB.LAST_CLUSTER
                mov     si, es:[bp+21h] ; DPB.FREE_CNT_HW ; hw of free cluster count
                cmp     dx, si          ; same (zero) ?

dsk_info_5:                             ; ...
                jnz     short dsk_info_6 ; not same (not zero)
                inc     dx
                jz      short dsk_info_8 ; 0FFFFh -> 0 (free count is invalid/initial)
                                        ; free count calculation is needed
                dec     dx

dsk_info_6:                             ; ...
                cmp     si, di          ; same hw ?
                jnz     short dsk_info_7 ; no
                cmp     dx, cx          ; same lw ?

dsk_info_7:                             ; ...
                jb      short GotVal    ; free cluster count < last cluster number
                xor     dx, dx          ; 0

dsk_info_8:                             ; ...
                xor     si, si          ; 0
                sub     cx, 1           ; last cluster number - 1 = number of clusters
                sbb     di, si
                or      byte ptr es:[bp+18h], 1 ; DPB.FIRST_ACCESS ; set first access

SCANFREE:                               ; ...
                push    si
                push    CCONTENT_HW
                push    di
                call    UNPACK
                pop     di
                pop     CCONTENT_HW
                pop     si
                jb      short CRIT_LEAVE
                jnz     short NOTFREECLUS
                inc     dx              ; a free one
                jnz     short NOTFREECLUS
                inc     si              ; increase hw of free cluster count

NOTFREECLUS:                            ; ...
                inc     bx              ; next cluster
                jnz     short NOTFREECLUS2
                inc     CLUSTNUM_HW     ; increase hw of (next) cluster number

NOTFREECLUS2:                           ; ...
                sub     cx, 1           ; decrease remain cluster count for calculation
                sbb     di, 0
                jnz     short SCANFREE
                jcxz    short NOTFREECLUS3 ; calculation completed
                jmp     short SCANFREE
; ---------------------------------------------------------------------------

NOTFREECLUS3:                           ; ...
                mov     di, CLUSTNUM_HW
                sub     bx, 1
                sbb     di, 0           ; di:bx = last cluster number

ReturnVals:                             ; ...
                xor     cx, cx
                sub     bx, 1
                sbb     di, cx          ; di:bx = number of clusters
                mov     al, es:[bp+4]   ; [ES:BP+DPB.CLUSTER_MASK] ; spc - 1
                inc     al              ; sectors per cluster
                mov     es:[bp+1Fh], dx ; [ES:BP+DPB.FREE_CNT] ; free cluster count, lw
                cmp     es:[bp+0Fh], cx ; FAT32 (16 bit FAT size = 0) ?
                jnz     short ReturnVals2 ; no
                mov     es:[bp+21h], si ; DPB.FREE_CNT_HW ; hw of free cluster count
                call    update_fat32_fsinfo

ReturnVals2:                            ; ...
                mov     cx, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE] ; bytes per sector
                clc

CRIT_LEAVE:                             ; ...
                call    LCritDisk
                retn
; ---------------------------------------------------------------------------

GotVal:                                 ; ...
                mov     bx, cx
                jmp     short ReturnVals
DISK_INFO       endp

; ---------------------------------------------------------------------------

modify_spc:                             ; ...
                push    ax              ; ax = sectors per cluster
                push    dx
                mul     cx              ; bytes per sector
                cmp     dx, 0
                jnz     short mspc_1
                cmp     ax, 16384       ; 16 kilobytes (per cluster)
                                        ; ***
                                        ; actual disk size limit
                                        ; without invalidating cluster counts is
                                        ; 2 GB (512K clusters * 8 sectors per cluster)
                                        ;      (128K clusters * 32 sectors per cluster)

mspc_1:                                 ; ...
                pop     dx
                pop     ax
                jbe     short mspc_3    ; bytes per cluster <= 16 KB
                                        ; ***
                                        ; bytes per cluster > 16 KB
                xor     di, di          ; 0
                mov     bx, 0FFFEh      ; (invalidated)
                or      si, si          ; hw of free cluster count
                jz      short mspc_2    ; si = 0
                mov     si, di          ; si = 0
                mov     dx, bx          ; dx = bx = 0FFFEh (invalidated)

mspc_2:                                 ; ...
                retn
; ---------------------------------------------------------------------------

mspc_3:                                 ; ...
                shl     ax, 1           ; sectors per clust = sectors per clust * 2
                                        ; (ax <= 32768)
                shr     di, 1           ; cluster count = cluster count /2
                                        ; di:bx = modified value of total clusters

mspc_4:
                rcr     bx, 1
                shr     si, 1           ; free clusters = free clusters / 2
                rcr     dx, 1           ; si:dx = modified value of free clusters

modify_cluster_count:                   ; ...
                or      di, di          ; hw of cluster count
                jnz     short modify_spc
                retn

; =============== S U B R O U T I N E =======================================


update_fat32_fsinfo proc near           ; ...
                push    cx
                push    dx
                xor     cx, cx
                mov     dx, es:[bp+25h] ; DPB.FSINFO_SECTOR
                cmp     es:[bp+0Fh], cx ; DPB.FAT_SIZE
                                        ; (16bit FAT size field = 0 for FAT32 fs)
                jnz     short u_fat32_inf_1
                cmp     dx, 0FFFFh      ; -1
                jnz     short u_fat32_inf_2

u_fat32_inf_1:                          ; ...
                pop     dx
                pop     cx
                and     byte ptr es:[bp+18h], 0F4h ; clear bit 0,1 and 3
                                        ; bit 0 - FSINFO update (dirty) bit
                                        ; bit 1 - BPB_RootClus update bit
                                        ; bit 3 - BPB_ExtFlags update bit
                retn
; ---------------------------------------------------------------------------

u_fat32_inf_2:                          ; ...
                push    ax
                push    bx
                push    di
                push    si
                push    ds
                cmp     ss:BuffInHMA, 0 ; is buffers in HMA?
                jz      short u_fat32_inf_3 ; no
                lds     di, ss:LoMemBuff ; read it into scratch buffer
                assume ds:nothing
                sub     di, 24          ; BUFINSIZ ; space for buffer header
                                        ; (buffer header size = 24)
                clc
                jmp     short u_fat32_inf_4
; ---------------------------------------------------------------------------

u_fat32_inf_3:                          ; ...
                push    es
                push    bp
                call    GETCURHEAD      ; ds:di = first buffer in queue
                push    dx
                call    BUFWRITE        ; BufWrite writes a buffer to the disk,
                                        ;  if it's dirty.
                pop     dx
                pop     bp
                pop     es

u_fat32_inf_4:                          ; ...
                jb      short u_fat32_inf_5
                xor     cx, cx
                lea     bx, [di+24]     ; buffer data address
                mov     ss:ALLOWED, 18h ; Allowed_FAIL+Allowed_RETRY
                mov     ss:HIGH_SECTOR, cx ; 0
                inc     cx              ; cx = sector count
                                        ; es:bp = DPB
                push    bx              ; ds:bx = buffer (data) address
                push    dx              ; HIGH_SECTOR:dx = disk sector address
                call    DREAD           ; read fs info sector
                pop     dx
                pop     bx
                jb      short u_fat32_inf_5
                cmp     word ptr [bx], 5252h ; 'RR'
                jnz     short u_fat32_inf_5
                cmp     word ptr [bx+2], 4161h ; 'aA' ; (NASM syntax)
                jnz     short u_fat32_inf_5
                cmp     word ptr [bx+1E4h], 7272h ; 'rr' at offset 484
                jnz     short u_fat32_inf_5
                cmp     word ptr [bx+1E6h], 6141h ; 'Aa' at offset 486
                jnz     short u_fat32_inf_5
                cmp     word ptr [bx+1FEh], 0AA55h ; boot signature at offset 510
                jnz     short u_fat32_inf_5
                mov     ax, es:[bp+1Fh] ; DPB.FREE_CNT
                mov     [bx+1E8h], ax   ; FSINFO.Free_Count at offset 488
                mov     ax, es:[bp+21h] ; DPB.FREE_CNT+2
                mov     [bx+1EAh], ax   ; FSINFO.Free_Count+2
                mov     ax, es:[bp+39h] ; DPB.FAT32_NXTFREE
                mov     [bx+1ECh], ax   ; FSINFO.Nxt_Free at offset 492
                mov     ax, es:[bp+3Bh] ; DPB.FAT32_NXTFREE+2
                mov     [bx+1EEh], ax   ; FSINFO.Nxt_Free+2
                xor     cx, cx
                mov     ss:HIGH_SECTOR, cx ; 0
                inc     cx              ; 1
                call    DWRITE

u_fat32_inf_5:                          ; ...
                pop     ds
                pop     si
                pop     di
                pop     bx
                pop     ax
                jmp     u_fat32_inf_1
update_fat32_fsinfo endp


; =============== S U B R O U T I N E =======================================


DOS_SEARCH_FIRST proc near              ; ...
                les     di, ds:THISCDS
                cmp     di, 0FFFFh      ; -1
                jnz     short TEST_RE_NET2
                mov     ax, 1119h       ; (MultNET<<8)|25
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - ???
                retn
; ---------------------------------------------------------------------------

TEST_RE_NET2:                           ; ...
                test    byte ptr es:[di+44h], 80h ; [ES:DI+curdir.flags+1],
                                        ; curdir_isnet>>8
                jz      short LOCAL_SEARCH_FIRST
                mov     ax, 111Bh       ; (MultNET<<8)|27
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - FINDFIRST
                                        ; SS = DS = DOS CS, [DTA] = uninitialized 21-byte findfirst search data
                                        ; SDA first filename pointer -> fully-qualified search template
                                        ; SDA CDS pointer -> current directory
                                        ; Return: CF set on error
                retn
; ---------------------------------------------------------------------------

LOCAL_SEARCH_FIRST:                     ; ...
                call    ECritDisk
                test    byte ptr ds:DOS34_FLAG+1, 4 ; (SEARCH_FASTOPEN>>8)
                jz      short NOFN
                or      ds:FastOpenFlg, 1 ; FastOpen_Set

NOFN:                                   ; ...
                mov     ds:NoSetDir, 1  ; if we find a dir, don't change to it

CHECK_QUESTION:
                mov     si, ss
                mov     ds, si
                assume ds:DOSCODE
                mov     si, WFP_START   ; ds:si -> final path

getnext:                                ; ...
                lodsb                   ; get char
                or      al, al          ; is it null ?
                jz      short NO_Question ; yes
                cmp     al, 3Fh ; '?'   ; is '?'
                jnz     short getnext   ; no
                and     FastOpenFlg, 80h ; Fast_yes ; reset fastopen

NO_Question:                            ; ...
                call    GETPATH
                jnb     short find_check_dev
                jnz     short bad_path3
                or      cl, cl
                jz      short bad_path3

find_no_more:                           ; ...
                mov     ax, 12h         ; error_no_more_files

BadBye:                                 ; ...
                and     ss:FastOpenFlg, 80h ; Fast_yes  ; reset fastopen
                stc
                call    LCritDisk
                retn
; ---------------------------------------------------------------------------

bad_path3:                              ; ...
                mov     ax, 3           ; error_path_not_found
                jmp     short BadBye
; ---------------------------------------------------------------------------

find_check_dev:                         ; ...
                or      ah, ah
                jns     short found_entry
                mov     LASTENT, 0FFFFh ; Cause DOS_SEARCH_NEXT to fail
                inc     FOUND_DEV       ; Tell DOS_RENAME we found a device

found_entry:                            ; ...
                les     di, DMAADD
                mov     si, WFP_START   ; get pointer to beginning
                lodsb
                sub     al, 40h ; '@'   ; 'A'-1  ; logical drive
                stosb                   ; High bit not set (local)

found_it:                               ; ...
                les     di, DMAADD
                inc     di
                push    ds
                test    FastOpenFlg, 10h ; Set_For_Search ; from fastopen
                jz      short notfast
                mov     si, bx
                mov     ds, word ptr CURBUF+2
                jmp     short movmov
; ---------------------------------------------------------------------------

notfast:                                ; ...
                mov     si, offset NAME1 ; find_buf 2 = formatted name

movmov:                                 ; ...
                movsb
                cmp     byte ptr es:[di-1], 5
                jnz     short NOTKANJB
                mov     byte ptr es:[di-1], 0E5h

NOTKANJB:                               ; ...
                mov     cx, 5
                rep movsw
                pop     ds
                assume ds:nothing
                mov     al, ds:ATTRIB
                stosb
                push    ax              ; Save AH device info
                mov     ax, ds:LASTENT
                stosw
                mov     ax, ds:DIRSTART
                stosw
                mov     ax, ds:DIRSTART_HW
                stosw
                add     di, 2
                pop     ax              ; Recover AH device info
                or      ah, ah
                js      short DOSREL    ; Device entry is DOSGROUP relative
                cmp     word ptr ds:CURBUF, 0FFFFh ; -1
                jnz     short OKSTORE
                test    ds:FastOpenFlg, 10h ; Set_For_Search
                                        ; from fastopen and is good
                jnz     short OKSTORE
                mov     word ptr es:[di-8], 0FFFFh ; Cause DOS_SEARCH_NEXT to fail
                                        ; by stuffing a -1 at Lastent
                jmp     find_no_more
; ---------------------------------------------------------------------------

OKSTORE:                                ; ...
                mov     ds, word ptr ds:CURBUF+2

DOSREL:                                 ; ...
                mov     si, bx          ; start of entry
                mov     cx, 16          ; dir_entry.size>>1
                mov     ax, di          ; save the 1st byte addr
                rep movsw
                mov     di, ax          ; restore 1st byte addr
                cmp     byte ptr es:[di], 5 ; special char check
                jnz     short NO05
                mov     byte ptr es:[di], 0E5h ; convert it back to E5

NO05:                                   ; ...
                and     ss:FastOpenFlg, 80h ; Fast_yes
                push    ss
                pop     ds
                assume ds:DOSCODE
                clc
                call    LCritDisk
                retn
DOS_SEARCH_FIRST endp

; ---------------------------------------------------------------------------

DOS_SEARCH_NEXT_X:                      ; DOS_SEARCH_NEXT (MSDOS 6.22, Win ME)
                les     di, DMAADD

; =============== S U B R O U T I N E =======================================


DOS_SEARCH_NEXT proc near               ; ...
                mov     al, es:[di]
                test    al, 80h         ; Test for NET
                jz      short LOCAL_SEARCH_NEXT
                mov     ax, 111Ch       ; (MultNET<<8)|28
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - FINDNEXT
                                        ; SS = DS = DOS CS, [DTA] = 21-byte findfirst search data
                                        ; Return: CF set on error, AX = DOS error code
                                        ; CF clear if successful
                retn
; ---------------------------------------------------------------------------

LOCAL_SEARCH_NEXT:                      ; ...
                mov     EXTERR_LOCUS, 2 ; errLOC_Disk
                call    ECritDisk
                mov     word ptr THISCDS, offset DUMMYCDS
                mov     word ptr THISCDS+2, ds
                add     al, 40h ; '@'   ; 'A' - 1
                call    InitCDS
                jb      short No_files  ; Bogus drive letter
                les     di, THISCDS     ; Get CDS pointer
                les     bp, es:[di+45h] ; [ES:DI+curdir.devptr] ; Get DPB pointer
                mov     word ptr THISDPB, bp
                mov     word ptr THISDPB+2, es
                mov     al, es:[bp+0]
                mov     THISDRV, al
                mov     word ptr CREATING, 0E500h ; (DIRFREE*256)+0
                mov     NoSetDir, 1     ; if we find a dir, don't change to it
                lds     si, DMAADD
                assume ds:nothing
                lodsb                   ; Drive Byte
DOS_SEARCH_NEXT endp


; =============== S U B R O U T I N E =======================================


RENAME_NEXT     proc near               ; ...
                mov     di, ss
                mov     es, di
                assume es:DOSCODE
                mov     di, offset NAME1
                movsb                   ; Search name
                mov     cx, 5
                rep movsw
                lodsb                   ; Attribute
                mov     ss:ATTRIB, al
                lodsw                   ; LastEnt
                or      ax, ax
                js      short No_files

cont_load:                              ; Save LastEnt
                push    ax
                lodsw                   ; DirStart
                mov     bx, ax
                lodsw                   ; DIRSTART_HW
                mov     bp, ss
                mov     ds, bp
                assume ds:DOSCODE
                les     bp, THISDPB     ; Recover ES:BP
                assume es:nothing
                cmp     word ptr es:[bp+0Fh], 0 ; [es:bp+DPB.FAT_SIZE]
                jz      short cont_load2 ; FAT32 fs
                xor     ax, ax          ; 0

cont_load2:                             ; ...
                mov     ROOTCLUST_HW, ax ; 0 or DIRSTART_HW
                call    SETDIRSRCH
                jb      short No_files_pop

SEARCH_GOON:
                call    STARTSRCH
                pop     ax
                call    GETENT
                jb      short No_files
                call    NEXTENT
                jb      short No_files
                xor     ah, ah          ; If Search_Next, can't be a DEV
                jmp     found_it
; ---------------------------------------------------------------------------

No_files_pop:                           ; ...
                pop     ax              ; Clean stack

No_files:                               ; ...
                jmp     find_no_more
RENAME_NEXT     endp


; =============== S U B R O U T I N E =======================================


DOS_ABORT       proc near               ; ...
                mov     es, ss:CurrentPDB
                mov     cx, es:32h      ; [ES:PDB.JFN_Length] ; Number of JFNs

reset_free_jfn:                         ; ...
                mov     bx, cx
                push    cx
                dec     bx              ; get jfn (start with last one)
                call    $CLOSE
                pop     cx
                loop    reset_free_jfn  ; and do 'em all
                push    ss
                pop     ds
                mov     ax, 111Dh
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - CLOSE ALL REMOTE FILES FOR PROCESS
                                        ; DS???, SS = DOS CS
                call    MFTCloseP       ; call far [JShare+(4*4)] ; 4 = MFTCloseP
                les     di, ss:SFTFCB   ; (FCB cache) grab the pointer to the table

SFTFCB_check:                           ; ...
                mov     cx, es
                or      cx, di
                jcxz    short FCBScanDone ; (FCB cache table) not installed
                push    di
                mov     cx, es:[di+4]   ; [es:di+SFT.SFCount]
                jcxz    short SFTFCB_check2
                lea     di, [di+6]      ; [DI+SFT.SFTable]
                mov     ax, ss:PROC_ID

FCBTest:                                ; ...
                cmp     es:[di+31h], ax ; [es:di+SF_ENTRY.sf_PID]
                jnz     short FCBNext   ; not one of ours, skip it
                call    SFT_FREE        ; blast ref count

FCBNext:                                ; ...
                add     di, 59          ; SF_ENTRY.size
                loop    FCBTest

SFTFCB_check2:                          ; ...
                pop     di
                les     di, es:[di]
                cmp     di, 0FFFFh
                jnz     short SFTFCB_check

FCBScanDone:                            ; ...
                xor     bx, bx

Scan:                                   ; ...
                push    bx
                call    SFFromSFN
                pop     bx
                jnb     short Scan1
                retn
; ---------------------------------------------------------------------------

Scan1:                                  ; ...
                cmp     word ptr es:[di], 0FFFFh ; sf_busy ; -1
                                        ; Is Sft busy?
                jnz     short scan_next ; no
                mov     ax, ss:PROC_ID
                cmp     es:[di+31h], ax ; [es:di+SF_ENTRY.sf_PID]
                jnz     short scan_next
                mov     ax, ss:USER_ID
                sub     ax, es:[di+2Fh] ; [es:di+SF_ENTRY.sf_UID]
                jnz     short scan_next
                call    SFT_FREE

scan_next:                              ; ...
                inc     bx
                jmp     short Scan
DOS_ABORT       endp


; =============== S U B R O U T I N E =======================================


DOS_CLOSE       proc near               ; ...
                les     di, THISSFT
                mov     bx, es:[di+5]   ; [ES:DI+SF_ENTRY.sf_flags]
                test    bh, 80h         ; (sf_isnet>>8)
                jz      short LocalClose
                mov     ax, 1106h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE FILE
                                        ; ES:DI -> SFT
                                        ; SFT DPB field -> DPB of drive containing file
                                        ; Return: CF set on error, AX = DOS error code
                                        ; CF clear if successful
                retn
; ---------------------------------------------------------------------------

LocalClose:                             ; ...
                call    ECritDisk
                call    SetSFTTimes
                call    FREE_SFT        ; dec ref count or mark as busy
                push    ss
                pop     ds
                push    ax
                push    bx
                call    ShareEnd
                pop     bx
                pop     ax
DOS_CLOSE       endp


CloseEntry:                             ; ...
                push    ax
                test    bx, 0C0h        ; devid_file_clean+devid_device
                jz      short rdir
                jmp     FREE_SFT_OK
; ---------------------------------------------------------------------------

rdir:                                   ; ...
                call    DirFromSFT
                mov     al, 5           ; error_access_denied
                jb      short jmp_to_CloseFinish
                test    word ptr [si+2], 4 ; [SI+SF_ENTRY.sf_mode],
                                        ; devid_device_null ; bit 2 - null device
                jnz     short clook
                push    ds
                push    bx
                lds     bx, [si+7]      ; [si+SF_ENTRY.sf_devptr]
                assume ds:nothing
                mov     bl, [bx]        ; DPB.DRIVE
                xor     bh, bh          ; 0
                test    ss:drive_flags[bx], 4 ; bit 2 - last access date/time flag?
                pop     bx
                jz      short skip_upd_laccdt ; no support for last access date&time
                pop     ds
                push    ds
                call    DATE16
                mov     es:[di+12h], ax ; [es:di+dir_entry.dir_lstaccdate]

skip_upd_laccdt:                        ; ...
                pop     ds

clook:                                  ; ...
                push    di
                push    si
                lea     si, [si+20h]    ; [SI+SF_ENTRY.sf_name]
                call    XCHGP
                call    MetaCompare
                call    XCHGP
                pop     si
                pop     di
                jz      short CLOSE_GO  ; Name OK

Bye:
                mov     di, si
                push    ds
                pop     es              ; ES:DI points to SFT
                push    ss
                pop     ds
                assume ds:DOSCODE
                stc
                mov     al, 2           ; error_file_not_found

jmp_to_CloseFinish:                     ; ...
                jmp     CloseFinish2
; ---------------------------------------------------------------------------

CLOSE_GO:                               ; ...
                mov     al, [si+4]      ; [SI+SF_ENTRY.sf_attr]
                test    word ptr [si+2], 8000h ; [SI+SF_ENTRY.sf_mode],sf_isFCB
                jz      short nofcb
                mov     ch, es:[di+0Bh] ; [ES:DI+dir_entry.dir_attr]
                mov     ss:ATTRIB, al
                jmp     short setattr
; ---------------------------------------------------------------------------

nofcb:                                  ; ...
                mov     es:[di+0Bh], al ; [ES:DI+dir_entry.dir_attr]

setattr:                                ; ...
                or      byte ptr es:[di+0Bh], 20h ; [ES:DI+dir_entry.dir_attr],
                                        ; attr_archive
                mov     ax, es:[di+1Ah] ; [ES:DI+dir_entry.dir_first]
                mov     ss:OLD_FIRSTCLUS, ax ; save old first cluster
                mov     ax, es:[di+14h] ; [ES:DI+dir_entry.dir_fclus_hi]
                mov     ss:OLD_FIRSTCLUS_HW, ax
                mov     ax, [si+2Bh]    ; [SI+SF_ENTRY.sf_chain]
                                        ; first cluster (32 bit) low word !?
                mov     es:[di+1Ah], ax ; [ES:DI+dir_entry.dir_first]
                mov     ax, [si+2Dh]    ; [SI+SF_ENTRY.sf_chain+2]
                                        ; first cluster (32 bit) high word !?
                mov     es:[di+14h], ax ; [ES:DI+dir_entry.dir_fclus_hi]
                push    ds
                lds     ax, [si+11h]    ; [SI+SF_ENTRY.sf_size]
                assume ds:nothing
                mov     es:[di+1Ch], ax ; [ES:DI+dir_entry.dir_size_l]
                mov     word ptr es:[di+1Eh], ds ; [ES:DI+dir_entry.dir_size_h]
                pop     ds
                push    ds
                lds     ax, [si+0Dh]    ; [SI+SF_ENTRY.sf_time]
                mov     es:[di+16h], ax ; [ES:DI+dir_entry.dir_time]
                mov     word ptr es:[di+18h], ds ; [ES:DI+dir_entry.dir_date]
                pop     ds
                test    byte ptr es:[bx+5], 40h ; [ES:BX+BUFFINFO.buf_flags],
                                        ; buf_dirty
                jnz     short yesdirty4
                call    INC_DIRTY_COUNT
                or      byte ptr es:[bx+5], 40h ; [ES:BX+BUFFINFO.buf_flags],
                                        ; buf_dirty

yesdirty4:                              ; ...
                push    ds
                push    si
                mov     cx, [si+2Bh]    ; [es:di+SF_ENTRY.sf_chain]
                                        ; first cluster (32 bit) low word !?
                mov     al, ss:THISDRV
                push    dx
                mov     ah, 0           ; dir entry update
                mov     dl, al
                push    bx
                mov     bx, [si+2Dh]    ; [es:di+SF_ENTRY.sf_chain+2]
                                        ; first cluster (32 bit) high word !?
                or      bx, bx
                jnz     short do_update2
                or      cx, cx
                jnz     short do_update2
                mov     ah, 3           ; do a delete cache entry
                mov     dh, [si+1Fh]    ; [SI+SF_ENTRY.sf_dirpos]
                lds     di, [si+1Bh]    ; [SI+SF_ENTRY.sf_dirsec]
                mov     cx, ds          ; cx:di = dir sector
                jmp     short do_update
; ---------------------------------------------------------------------------

do_update2:                             ; ...
                cmp     bx, ss:OLD_FIRSTCLUS_HW ; same as old first cluster?
                jnz     short do_update3 ; no
                cmp     cx, ss:OLD_FIRSTCLUS
                jz      short do_update ; yes

do_update3:                             ; ...
                mov     ah, 2           ; delete the old entry
                mov     cx, ss:OLD_FIRSTCLUS
                mov     bx, ss:OLD_FIRSTCLUS_HW

do_update:                              ; ...
                push    ss
                pop     ds
                assume ds:DOSCODE
                xchg    bx, si
                call    FastOpen_Update ; invoke fastopen
                xchg    bx, si
                pop     bx
                pop     dx
                call    FLUSHBUF        ; flush all relevant buffers
                pop     di
                pop     es
                mov     al, 5           ; error_access_denied
                jb      short CloseFinish

FREE_SFT_OK:                            ; ...
                test    word ptr es:[di+5], 8080h ; [ES:DI+SF_ENTRY.sf_flags],
                                        ; sf_isnet+devid_device
                jnz     short CloseFinish2
                push    es
                push    bp
                les     bp, es:[di+7]   ; [ES:DI+SF_ENTRY.sf_devptr]
                call    update_fat32_fsinfo
                pop     bp
                pop     es
                jmp     short CloseFinish2
; ---------------------------------------------------------------------------

CloseFinish:                            ; ...
                push    ds
                push    bx
                lds     bx, es:[di+7]   ; [ES:DI+SF_ENTRY.sf_devptr]
                assume ds:nothing
                mov     bl, [bx]        ; DPB.DRIVE
                xor     bh, bh          ; 0
                and     ss:drive_flags[bx], 0FBh ; clear bit 2
                pop     bx
                pop     ds
                stc

CloseFinish2:                           ; ...
                pushf
                call    DEV_CLOSE_SFT
; ---------------------------------------------------------------------------
                popf
                pop     cx
                pushf
                loop    NoFree
                call    SFT_FREE
; START OF FUNCTION CHUNK FOR DOS_COMMIT

NoFree:                                 ; ...
                call    LCritDisk
                popf
                retn
; END OF FUNCTION CHUNK FOR DOS_COMMIT

; =============== S U B R O U T I N E =======================================


FREE_SFT        proc near               ; ...
                pushf
                mov     ax, es:[di]     ; [ES:DI+SF_ENTRY.sf_ref_count]
                dec     ax
                jnz     short SetCount
                dec     ax

SetCount:                               ; ...
                xchg    ax, es:[di]
                popf
                retn
FREE_SFT        endp


; =============== S U B R O U T I N E =======================================


DirFromSFT      proc near               ; ...
                call    set_exerr_locus_disk
                push    es
                push    di
                mov     dx, es:[di+1Dh] ; [ES:DI+SF_ENTRY.sf_dirsec+2]
                mov     ds:HIGH_SECTOR, dx
                push    dx
                mov     dx, es:[di+1Bh] ; [ES:DI+SF_ENTRY.sf_dirsec]
                push    dx
                call    FATREAD_SFT
                pop     dx
                pop     ds:HIGH_SECTOR
                jb      short PopDone
                xor     al, al
                mov     ds:ALLOWED, 18h ; Allowed_FAIL+Allowed_RETRY
                call    GETBUFFR
                jb      short PopDone
                pop     si
                pop     ds
                les     di, ss:CURBUF
                or      byte ptr es:[di+5], 4 ; [ES:DI+BUFFINFO.buf_flags],
                                        ; buf_isDIR
                mov     bx, di
                lea     di, [di+18h]    ; [DI+BUFINSIZ] ; Point to buffer
                mov     al, 32          ; dir_entry.size
                mul     byte ptr [si+1Fh] ; [SI+SF_ENTRY.sf_dirpos]
                add     di, ax          ; Point at the entry
                retn                    ; carry is clear
; ---------------------------------------------------------------------------

PopDone:                                ; ...
                pop     di
                pop     es

PopDone_retn:                           ; ...
                retn
DirFromSFT      endp


; =============== S U B R O U T I N E =======================================


DOS_COMMIT      proc near               ; ...

; FUNCTION CHUNK AT 7861 SIZE 00000005 BYTES

                les     di, ds:THISSFT
                mov     bx, es:[di+5]
                test    bl, 0C0h
                jnz     short PopDone_retn
                test    bh, 80h
                jz      short LOCAL_COMMIT
                mov     ax, 1107h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
                                        ; ES:DI -> SFT
                                        ; SFT DPB field -> DPB of drive containing file
                                        ; Return: CF set on error, AX = DOS error code
                                        ; CF clear if successful

localcommit_retn:                       ; ...
                retn
; ---------------------------------------------------------------------------

LOCAL_COMMIT:                           ; ...
                call    ECritDisk
                call    SetSFTTimes
                mov     ax, 0FFFFh
                call    CloseEntry
; ---------------------------------------------------------------------------
                pushf
                call    DEV_OPEN_SFT
                jmp     NoFree
DOS_COMMIT      endp


; =============== S U B R O U T I N E =======================================


SetSFTTimes     proc near               ; ...
                test    bx, 40C0h       ; sf_close_nodate+devid_file_clean+devid_device
                jnz     short localcommit_retn
                push    ax
                push    bx
                call    DATE16          ; Date/Time to AX/DX
                mov     es:[di+0Fh], ax ; [ES:DI+SF_ENTRY.sf_date]
                mov     es:[di+0Dh], dx ; [ES:DI+SF_ENTRY.sf_time]
                xor     ax, ax
                call    ds:ShSU         ; call far [JShare+(14*4)] ; 14 = ShSU
                pop     bx
                pop     ax
                retn
SetSFTTimes     endp


; =============== S U B R O U T I N E =======================================


DOS_MKDIR       proc near               ; ...

; FUNCTION CHUNK AT 710B SIZE 00000007 BYTES
; FUNCTION CHUNK AT 790A SIZE 00000008 BYTES
; FUNCTION CHUNK AT 7912 SIZE 000000DD BYTES
; FUNCTION CHUNK AT 79F2 SIZE 00000031 BYTES

                call    TestNet
                jnb     short LOCAL_MKDIR
                mov     ax, 1103h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY
                                        ; SS = DOS CS
                                        ; SDA first filename pointer -> fully-qualified directory name
                                        ; SDA CDS pointer -> current directory
                                        ; Return: CF set on error, AX = DOS error code
                                        ; CF clear if successful
                retn
DOS_MKDIR       endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR DOS_CHDIR
;   ADDITIONAL PARENT FUNCTION DOS_MKDIR

NODEACCERRJ:                            ; ...
                mov     ax, 5           ; error_access_denied

_BadRet:                                ; ...
                stc

chdir_mkdir_done:                       ; ...
                call    LCritDisk
                retn
; END OF FUNCTION CHUNK FOR DOS_CHDIR
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR DOS_MKDIR

PATHNFJ:                                ; ...
                call    LCritDisk
                jmp     SET_MKND_ERR
; ---------------------------------------------------------------------------

LOCAL_MKDIR:                            ; ...
                call    ECritDisk
                mov     word ptr ds:THISSFT+2, ss
                mov     word ptr ds:THISSFT, offset RENBUF
                mov     word ptr ds:RENBUF+33h, 0 ; [RENBUF+SF_ENTRY.sf_MFT]
                                        ; make sure SHARER won't complain.
                mov     al, 10h         ; attr_directory
                call    MakeNode
                jb      short PATHNFJ
                cmp     ax, 3
                jz      short NODEACCERRJ ; Can't make a device into a directory
                les     bp, ds:THISDPB  ; Makenode zaps this
                lds     di, ds:CURBUF
                sub     si, di
                push    si              ; Pointer to dir_first
                lds     ax, [di+6]      ; [DI+BUFFINFO.buf_sector]
                push    ds
                push    ax
                push    ss
                pop     ds
                assume ds:DOSCODE
                xor     ax, ax
                mov     dx, ax          ; 0
                xchg    dx, DIRSTART_HW ; Null directory
                xchg    ax, DIRSTART
                cmp     word ptr es:[bp+0Fh], 0 ; [es:bp+DPB.FAT_SIZE]
                jnz     short LOCAL_MKDIR_cont ; not FAT32
                cmp     es:[bp+35h], ax ; [es:bp+DPB.ROOT_CLUSTER]
                jnz     short LOCAL_MKDIR_cont
                cmp     es:[bp+37h], dx ; [es:bp+DPB.ROOT_CLUSTER+2]
                jnz     short LOCAL_MKDIR_cont
                xor     ax, ax
                xor     dx, dx          ; dx:ax = 0 for root directory

LOCAL_MKDIR_cont:                       ; ...
                push    dx
                push    ax
                call    NEWDIR
                jb      short NODEEXISTSPOPDEL
                call    GETENT
                jb      short NODEEXISTSPOPDEL
                les     di, CURBUF
                call    SET_BUF_DIRTY

yesdirty5:
                add     di, 24
                mov     ax, 202Eh       ; ". " ; (NASM syntax)
                mov     dx, DIRSTART_HW
                mov     CLUSTERS_HW, dx
                mov     dx, DIRSTART
                call    SETDOTENT
                mov     ax, 2E2Eh       ; ".."
                pop     dx              ; Parent
                pop     CLUSTERS_HW
                call    SETDOTENT
                les     bp, THISDPB
                mov     ALLOWED, 18h    ; Allowed_FAIL+Allowed_RETRY
                pop     dx              ; Entry sector
                pop     HIGH_SECTOR
                xor     al, al
                call    GETBUFFR        ; Pre read
                jb      short NODEEXISTSP
                mov     ax, DIRSTART_HW
                mov     dx, DIRSTART
                lds     di, CURBUF
                assume ds:nothing
                or      byte ptr [di+5], 4 ; [DI+BUFFINFO.buf_flags],buf_isDIR
                pop     si              ; dir_first pointer
                add     si, di
                mov     [si], dx        ; dir_entry.dir_first
                mov     [si-6], ax      ; dir_entry.dir_fclus_hi
                xor     dx, dx
                mov     [si+2], dx      ; Zero size
                mov     [si+4], dx

DIRUP:                                  ; ...
                test    byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty
                jnz     short yesdirty6 ; already dirty
                call    INC_DIRTY_COUNT
                or      byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty

yesdirty6:                              ; ...
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    update_fat32_fsinfo
                mov     al, es:[bp+0]   ; [ES:BP+DPB.DRIVE]
                call    FLUSHBUF
                mov     ax, 5           ; error_access_denied
; END OF FUNCTION CHUNK FOR DOS_MKDIR
; START OF FUNCTION CHUNK FOR DOS_CHDIR

lmd_cd_done:                            ; ...
                jmp     chdir_mkdir_done
; END OF FUNCTION CHUNK FOR DOS_CHDIR
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR DOS_MKDIR

NODEEXISTSPOPDEL:                       ; ...
                pop     dx              ; Parent
                pop     dx
                pop     dx              ; Entry sector
                pop     HIGH_SECTOR
                les     bp, THISDPB
                mov     ALLOWED, 18h    ; Allowed_FAIL+Allowed_RETRY
                xor     al, al
                call    GETBUFFR        ; Pre read
                jb      short NODEEXISTSP
                lds     di, CURBUF
                assume ds:nothing
                or      byte ptr [di+5], 4 ; [DI+BUFFINFO.buf_flags],buf_isDIR
                pop     si              ; dir_first pointer
                add     si, di
                sub     si, 26          ; dir_entry.dir_first
                                        ; Point back to start of dir entry
                mov     byte ptr [si], 0E5h ; Free the entry
                call    DIRUP           ; Error doesn't matter since erroring anyway

NODEEXISTS:                             ; ...
                jmp     NODEACCERRJ
; ---------------------------------------------------------------------------

NODEEXISTSP:                            ; ...
                pop     si              ; Clean stack
                jmp     short NODEEXISTS
; END OF FUNCTION CHUNK FOR DOS_MKDIR

; =============== S U B R O U T I N E =======================================


DOS_CHDIR       proc near               ; ...

; FUNCTION CHUNK AT 790A SIZE 00000008 BYTES
; FUNCTION CHUNK AT 79EF SIZE 00000003 BYTES
; FUNCTION CHUNK AT 7ABB SIZE 00000003 BYTES

                call    TestNet
                jnb     short LOCAL_CHDIR
                mov     ax, 1105h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - CHDIR
                                        ; SS = DOS CS
                                        ; SDA first filename pointer -> fully-qualified directory name
                                        ; SDA CDS pointer -> current directory
                                        ; Return: CF set on error, AX = DOS error code
                                        ; CF clear if successful
                retn
; ---------------------------------------------------------------------------

LOCAL_CHDIR:                            ; ...
                call    ECritDisk
                test    byte ptr es:[di+44h], 20h ; [ES:DI+curdir.flags+1],
                                        ; (curdir_splice>>8)
                jz      short nojoin
                mov     word ptr es:[di+4Bh], 0FFFFh ; [ES:DI+curdir.ID+2]
                mov     word ptr es:[di+49h], 0FFFFh ; [ES:DI+curdir.ID]

nojoin:                                 ; ...
                mov     ds:NoSetDir, 0  ; FALSE
                mov     ds:SATTRIB, 16h ; attr_directory+attr_system+attr_hidden
                or      ds:FastOpenFlg, 1
                call    GETPATH
                lahf
                and     ds:FastOpenFlg, 80h ; FastOpen_Set ; set fastopen flag
                sahf
                mov     ax, 3           ; error_path_not_found
                jb      short ChDirDone
                jnz     short NOTDIRPATH ; Path not a DIR
                mov     cx, ds:DIRSTART
                clc

ChDirDone:                              ; ...
                jmp     short lmd_cd_done
DOS_CHDIR       endp


; =============== S U B R O U T I N E =======================================


DOS_RMDIR       proc near               ; ...

; FUNCTION CHUNK AT 7ABB SIZE 00000003 BYTES

                call    TestNet
                jnb     short LOCAL_RMDIR
                mov     ax, 1101h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
                                        ; SS = DOS CS
                                        ; SDA first filename pointer -> fully-qualified directory name
                                        ; SDA CDS pointer -> current directory
                                        ; Return: CF set on error, AX = DOS error code
                                        ; CF clear if successful
                retn
; ---------------------------------------------------------------------------

LOCAL_RMDIR:                            ; ...
                call    ECritDisk
                mov     ds:NoSetDir, 0
                mov     ds:SATTRIB, 16h ; attr_directory+attr_system+attr_hidden
                call    GETPATH
                jb      short NOPATH    ; Path not found
                jnz     short NOTDIRPATH ; Path not a DIR
                mov     di, ds:DIRSTART
                or      di, di          ; Root ?
                jnz     short LOCAL_RMDIR_cont ; No
                cmp     ds:DIRSTART_HW, 0
                jz      short NOTDIRPATH ; root directory

LOCAL_RMDIR_cont:                       ; ...
                cmp     word ptr es:[bp+0Fh], 0 ; [es:bp+DPB.FAT_SIZE]
                jnz     short rmdir_get_buf ; not FAT32
                cmp     di, es:[bp+35h] ; [es:bp+DPB.ROOT_CLUSTER]
                jnz     short rmdir_get_buf
                mov     di, ds:DIRSTART_HW
                cmp     di, es:[bp+37h] ; [es:bp+DPB.ROOT_CLUSTER+2]
                jnz     short rmdir_get_buf
                jmp     short NOTDIRPATH
; ---------------------------------------------------------------------------

NOPATH:                                 ; ...
                mov     ax, 3           ; error_path_not_found
                jmp     _BadRet
; ---------------------------------------------------------------------------

NOTDIRPATHPOP:                          ; ...
                pop     ax
                pop     ax

NOTDIRPATHPOP2:                         ; ...
                pop     ax
DOS_RMDIR       endp

; START OF FUNCTION CHUNK FOR DOS_CHDIR
;   ADDITIONAL PARENT FUNCTION DOS_RMDIR

NOTDIRPATH:                             ; ...
                jmp     NODEACCERRJ
; END OF FUNCTION CHUNK FOR DOS_CHDIR
; ---------------------------------------------------------------------------

rmdir_get_buf:                          ; ...
                lds     di, ds:CURBUF
                sub     bx, di          ; Compute true offset
                push    bx              ; Save entry pointer
                les     di, [di+6]      ; [DI+BUFFINFO.buf_sector]
                push    es              ; Save sector number
                push    di
                push    ss
                pop     ds
                assume ds:DOSCODE
                push    ss
                pop     es
                assume es:DOSCODE
                mov     di, offset NAME1
                mov     ax, 3Fh ; '?'
                mov     cx, 10
                rep stosb               ; al = '?'
                stosw                   ; ah = 0 ; Nul terminate it
                call    STARTSRCH       ; Set search
                call    GETENTRY        ; Get start of directory
                jb      short NOTDIRPATHPOP ; Screw up
                mov     ds, word ptr CURBUF+2
                assume ds:nothing
                mov     si, bx
                lodsw
                cmp     ax, 202Eh       ; First entry '.'?
                jnz     short NOTDIRPATHPOP ; Nope
                add     si, 30          ; Next entry
                lodsw
                cmp     ax, 2E2Eh       ; Second entry '..'?
                jnz     short NOTDIRPATHPOP ; Nope
                push    ss
                pop     ds
                assume ds:DOSCODE
                mov     LASTENT, 2      ; Skip . and ..
                call    GETENTRY        ; Get next entry
                jb      short NOTDIRPATHPOP ; Screw up
                mov     ATTRIB, 16h     ; attr_directory+attr_hidden+attr_system
                call    SRCH            ; Do a search
                jnb     short NOTDIRPATHPOP
                cmp     FAILERR, 0
                jnz     short NOTDIRPATHPOP ; Failure of search due to I 24 FAIL
                les     bp, THISDPB
                assume es:nothing
                mov     bx, DIRSTART_HW
                mov     CLUSTNUM_HW, bx
                mov     bx, DIRSTART
                call    RELEASE         ; Release data in sub dir
                jb      short NOTDIRPATHPOP
                call    update_fat32_fsinfo
                pop     dx
                pop     HIGH_SECTOR
                mov     ALLOWED, 18h
                xor     al, al          ; Pre read
                call    GETBUFFR        ; Get sector back
                jnb     short rmdir_fde
                jmp     NOTDIRPATHPOP2
; ---------------------------------------------------------------------------

rmdir_fde:                              ; ...
                lds     di, CURBUF
                assume ds:nothing
                or      byte ptr [di+5], 4 ; [DI+BUFFINFO.buf_flags],buf_isDIR
                pop     bx              ; Pointer to start of entry
                add     bx, di          ; Corrected
                mov     byte ptr [bx], 0E5h ; Free the entry
                push    ds
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    FastOpen_Delete
                pop     ds
                assume ds:nothing
                jmp     DIRUP

; =============== S U B R O U T I N E =======================================


SWAPBACK        proc near               ; ...
                mov     ds:CONSWAP, 0
                retn
SWAPBACK        endp


; =============== S U B R O U T I N E =======================================


SWAPCON         proc near               ; ...
                push    ax
                mov     ax, word ptr ds:THISSFT
                mov     ds:CONSWAP, 1   ; ConSwap = TRUE
                mov     word ptr ds:CONSFT, ax
                mov     ax, word ptr ds:THISSFT+2
                mov     word ptr ds:CONSFT+2, ax
                pop     ax
                retn
SWAPCON         endp

; ---------------------------------------------------------------------------

dos_read_acc_err:                       ; ...
                jmp     SET_ACC_ERR

; =============== S U B R O U T I N E =======================================


DOS_READ        proc near               ; ...
                les     di, ds:THISSFT
                mov     al, es:[di+2]
                and     al, 3           ; open_mode_mask ?
                                        ; (it was 0Fh -access_mask- in MSDOS6.22 MSDOS.SYS)
                cmp     al, 1           ; open_for_write
                jz      short dos_read_acc_err
                call    SETUP
                jcxz    short NoIORet
                call    IsSFTNet
                jz      short LOCAL_READ
                mov     ax, 1108h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - READ FROM REMOTE FILE
                                        ; ES:DI -> SFT
                                        ; SFT DPB field -> DPB of drive containing file
                                        ; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
                                        ; Return: CF set on error, CX = bytes read
                retn
; ---------------------------------------------------------------------------

NoIORet:                                ; ...
                clc
                retn
; ---------------------------------------------------------------------------

LOCAL_READ:                             ; ...
                test    byte ptr es:[di+5], 80h ; [ES:DI+SF_ENTRY.sf_flags],devid_device
                jnz     short READDEV
                mov     ds:EXTERR_LOCUS, 2 ; errLOC_Disk
                call    ECritDisk
                call    DISKREAD
                call    LCritDisk
                retn
; ---------------------------------------------------------------------------

READDEV:                                ; ...
                mov     ds:EXTERR_LOCUS, 4 ; errLOC_SerDev
                mov     bl, es:[di+5]   ; [ES:DI+SF_ENTRY.sf_flags]
                les     di, ds:DMAADD
                test    bl, 40h         ; devid_device_EOF ; End of file?
                jz      short ENDRDDEVJ3
                test    bl, 4           ; devid_device_null ; NUL device?
                jz      short TESTRAW   ; no
                xor     al, al          ; Indicate EOF by setting zero

ENDRDDEVJ3:                             ; ...
                jmp     ENDRDDEVJ
; ---------------------------------------------------------------------------

TESTRAW:                                ; ...
                test    bl, 20h         ; devid_device_raw ; Raw mode?
                jnz     short DVRDRAW   ; Yes, let the device do all local editing
                test    bl, 1           ; devid_device_con_in ; Is it console device?
                jz      short NOTRDCON  ; no
                jmp     READCON         ; yes
; ---------------------------------------------------------------------------

DVRDRAW:                                ; ...
                push    es
                pop     ds              ; Xaddr to DS:DI
                test    ss:IsWin386, 1
                jz      short ReadRawRetry ; not present
                test    bl, 1           ; devid_device_con_in ; is it console device?
                jz      short ReadRawRetry ; no, do normal read
                jmp     do_polling      ; yes, do win386 polling loop
; ---------------------------------------------------------------------------

ReadRawRetry:                           ; ...
                mov     bx, di          ; DS:BX transfer addr
                xor     ax, ax          ; Media Byte, unit = 0
                cwd                     ; Start at 0
                call    SETREAD
                push    ds
                lds     si, ss:THISSFT
                call    DEVIOCALL
                mov     dx, di
                mov     ah, 86h         ; Read error
                mov     di, ss:DEVCALL_REQSTAT
                or      di, di
                jns     short CRDROK    ; no errors
                call    CHARHARD
                mov     di, dx          ; DS:DI is Xaddr
                sub     cx, ss:CALLBPB  ; [ss:CALLSCNT]
                add     di, ss:CALLBPB  ; [ss:CALLSCNT]
                or      al, al
                jz      short CRDROK    ; Ignore
                cmp     al, 3
                jz      short CRDFERR   ; fail
                pop     ds
                jmp     short ReadRawRetry ; Retry
; ---------------------------------------------------------------------------

CRDFERR:                                ; ...
                pop     di              ; Clean stack

DEVIOFERR:                              ; ...
                les     di, ss:THISSFT
                jmp     SET_ACC_ERR_DS
; ---------------------------------------------------------------------------

CRDROK:                                 ; ...
                pop     di              ; Chuck saved seg of Xaddr
                mov     di, dx
                add     di, ss:CALLBPB  ; [ss:CALLSCNT] ; Amount transferred
                jmp     short ENDRDDEVJ3
; ---------------------------------------------------------------------------

NOTRDCON:                               ; ...
                push    es
                pop     ds
                mov     bx, di
                xor     ax, ax
                cwd
                push    cx
                mov     cx, 1
                call    SETREAD
                pop     cx
                lds     si, ss:THISSFT
                lds     si, [si+7]      ; [SI+SF_ENTRY.sf_devptr]

DVRDLP:                                 ; ...
                call    DSKSTATCHK
                call    DEVIOCALL2
                push    di              ; Save "count" done
                mov     ah, 86h
                mov     di, ss:DEVCALL_REQSTAT
                or      di, di
                jns     short CRDOK
                call    CHARHARD
                pop     di
                mov     ss:CALLBPB, 1   ; [SS:CALLSCNT]
                cmp     al, 1
                jz      short DVRDLP    ; Retry
                cmp     al, 3
                jz      short DEVIOFERR ; FAIL
                xor     al, al          ; Ignore, Pick some random character
                jmp     short DVRDIGN
; ---------------------------------------------------------------------------

CRDOK:                                  ; ...
                pop     di
                cmp     ss:CALLBPB, 1   ; [SS:CALLSCNT]
                jnz     short ENDRDDEVJ
                push    ds
                mov     ds, ss:CALLXAD_2 ; [SS:CALLXAD+2]
                assume ds:DOSCODE
                mov     al, [di]        ; Get the character we just read
                pop     ds
                assume ds:nothing

DVRDIGN:                                ; ...
                inc     word ptr ss:CALLBR ; [SS:CALLXAD] ; Next character
                mov     ss:DEVCALL_REQSTAT, 0
                inc     di              ; Next character
                cmp     al, 1Ah         ; ^Z?
                jz      short ENDRDDEVJ ; Yes, done zero set (EOF)
                cmp     al, 0Dh         ; c_CR ; CR?
                loopne  DVRDLP          ; Loop if no, else done
                inc     ax              ; Resets zero flag so NOT EOF, unless

ENDRDDEVJ:                              ; ...
                jmp     ENDRDDEV
; ---------------------------------------------------------------------------

do_polling:                             ; ...
                mov     bx, di          ; ds:bx is Xfer address
                xor     ax, ax
                cwd
                call    SETREAD         ; prepare device packet

do_io:                                  ; ...
                mov     byte ptr es:[bx+2], 5 ; DEVRDND ; Change command code
                push    ds
                lds     si, ss:THISSFT  ; get device header
                call    DEVIOCALL       ; call device driver
                pop     ds
                test    word ptr es:[bx+3], 8000h ; [es:bx+SRHEAD.REQSTAT],
                                        ; STERR ; check if error
                jz      short check_busy ; no
                push    ds
                mov     dx, di

invoke_charhard:                        ; ...
                call    CHARHARD        ; invoke int 24h handler
                mov     di, dx
                or      al, al
                jz      short pop_done_read ; ignore by user,assume read is done
                cmp     al, 3
                jz      short devrderr  ; user issued a 'fail',indicate error
                pop     ds
                jmp     short do_io     ; user issued a retry
; ---------------------------------------------------------------------------

check_busy:                             ; ...
                test    word ptr es:[bx+3], 200h ; [es:bx+SRHEAD.REQSTAT],0200h
                                        ; see if busy bit set
                jnz     short no_char
                mov     byte ptr es:[bx+2], 4 ; DEVRD ; command code is READ now
                mov     word ptr es:[bx+18], 1 ; change count to 1 character
                push    ds
                lds     si, ss:THISSFT
                call    DEVIOCALL
                mov     dx, di
                mov     di, es:[bx+3]   ; [es:bx+SRHEAD.REQSTAT]
                                        ; get returned status
                mov     ah, 86h
                test    di, 8000h       ; STERR ; was there an error during read?
                jnz     short invoke_charhard

next_char:                              ; no,read next character
                pop     ds
                mov     di, dx
                dec     cx              ; decrement count
                jz      short done_read ; all characters read in
                inc     word ptr es:[bx+14] ; update transfer address
                jmp     short do_io     ; read next character in
; ---------------------------------------------------------------------------

devrderr:                               ; ...
                pop     di              ; discard segment address
                les     di, ss:THISSFT
                jmp     SET_ACC_ERR_DS  ; indicate error
; ---------------------------------------------------------------------------

no_char:                                ; ...
                push    ax
                mov     ah, 84h
                int     2Ah             ; Microsoft Networks - KEYBOARD BUSY LOOP
                                        ; indicate idle to WIN386
                pop     ax
                jmp     short do_io
; ---------------------------------------------------------------------------

pop_done_read:                          ; ...
                pop     ds

done_read:                              ; ...
                add     di, ss:CALLBPB  ; [ss:CALLSCNT]
                jmp     ENDRDDEVJ3      ; jump back to normal DOS raw read exit
; ---------------------------------------------------------------------------

TRANBUF:                                ; ...
                lodsb
                stosb
                cmp     al, 0Dh         ; c_CR ; Check for carriage return
                jnz     short NORMCH
                mov     byte ptr [si], 0Ah ; c_LF

NORMCH:                                 ; ...
                cmp     al, 0Ah         ; c_LF
                loopne  TRANBUF
                jnz     short ENDRDCON
                xor     si, si          ; Cause a new buffer to be read
                call    OUTT            ; Transmit linefeed
                or      al, 1           ; Clear zero flag--not end of file

ENDRDCON:                               ; ...
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    SWAPBACK
                mov     CONTPOS, si

ENDRDDEV:                               ; ...
                push    ss
                pop     ds
                mov     NEXTADD, di
                jnz     short SETSFTC   ; Zero set if Ctrl-Z found in input
                les     di, THISSFT
                and     byte ptr es:[di+5], 0BFh ; [ES:DI+SF_ENTRY.sf_flags],
                                        ; ~devid_device_EOF
                                        ; Mark as no more data available

SETSFTC:                                ; ...
                call    SETSFT
                retn
; ---------------------------------------------------------------------------

READCON:                                ; ...
                call    SWAPCON
                mov     si, CONTPOS
                or      si, si
                jnz     short TRANBUF
                cmp     CONBUF, 80h     ; 128
                jz      short GETBUF
                mov     word ptr CONBUF, 0FF80h ;
                                        ; Set up 128-byte buffer with no template

GETBUF:                                 ; ...
                push    cx
                push    es
                push    di
                mov     dx, offset CONBUF
                call    $STD_CON_STRING_INPUT ; Get input buffer
                pop     di
                pop     es
                mov     si, (offset CONBUF+2)
                pop     cx
                cmp     byte ptr [si], 1Ah ; Check for Ctrl-Z in first character
                jnz     short TRANBUF
                mov     al, 1Ah
                stosb
                dec     di
                mov     al, 0Ah         ; c_LF
                call    OUTT            ; Send linefeed
                xor     si, si
                jmp     short ENDRDCON
DOS_READ        endp


; =============== S U B R O U T I N E =======================================

; Attributes: thunk

BadMode         proc near               ; ...
                jmp     SET_ACC_ERR
BadMode         endp


; =============== S U B R O U T I N E =======================================


DOS_WRITE       proc near               ; ...
                les     di, THISSFT
                mov     al, es:[di+2]   ; [ES:DI+SF_ENTRY.sf_mode]
                and     al, 3           ; open_mode_mask ?
                cmp     al, 0           ; open_for_read
                jz      short BadMode

Check_FCB_RO:                           ;
                test    byte ptr es:[di+3], 80h ; [ES:DI+SF_ENTRY.sf_mode+1],
                                        ; (sf_isFCB>>8)
                jz      short WRITE_NO_MODE ; Not an FCB
                test    byte ptr es:[di+4], 1 ; [ES:DI+SF_ENTRY.sf_attr],
                                        ; attr_read_only
                jnz     short BadMode   ; Can't write to Read_Only files via FCB

WRITE_NO_MODE:                          ; ...
                call    SETUP
                test    byte ptr es:[di+6], 80h ; call IsSFTNet
                                        ; [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
                jz      short LOCAL_WRITE
                mov     ax, 1109h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
                                        ; ES:DI -> SFT
                                        ; SFT DPB field -> DPB of drive containing file
                                        ; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
                                        ; Return: CF set on error, CX = bytes written
                retn
; ---------------------------------------------------------------------------

LOCAL_WRITE:                            ; ...
                test    byte ptr es:[di+5], 80h ; [ES:DI+SF_ENTRY.sf_flags],devid_device
                                        ; Check for named device I/O
                jnz     short WRTDEV
                mov     EXTERR_LOCUS, 2 ; errLOC_Disk
                call    ECritDisk
                call    DISKWRITE
                jb      short nocommit
                les     di, THISSFT
                test    byte ptr es:[di+3], 40h ; [ES:DI+SF_ENTRY.sf_mode+1],
                                        ; (AUTO_COMMIT_WRITE>>8)
                jz      short nocommit
                push    cx
                call    DOS_COMMIT
                pop     cx

nocommit:                               ; ...
                call    LCritDisk
                retn
; ---------------------------------------------------------------------------

DVWRTRAW:                               ; ...
                xor     ax, ax          ; Media Byte, unit = 0
                call    SETWRITE
                push    ds              ; Save seg of transfer
                lds     si, ss:THISSFT
                assume ds:nothing
                call    DEVIOCALL       ; DS:SI -> DEVICE
                mov     dx, di          ; Offset part of Xaddr saved in DX
                mov     di, ss:DEVCALL_REQSTAT
                mov     ah, 87h
                or      di, di
                jns     short CWRTROK
                call    CHARHARD
                mov     di, ss:CALLBPB  ; [ss:CALLSCNT]
                mov     bx, dx          ; update ptr & count to reflect
                                        ; number of chars xferred
                sub     cx, di
                add     bx, di
                mov     di, bx          ; Recall transfer addr
                or      al, al
                jz      short CWRTROK   ; Ignore
                cmp     al, 3
                jz      short CWRFERR
                pop     ds              ; Recover saved seg of transfer
                jmp     short DVWRTRAW  ; Try again
; ---------------------------------------------------------------------------

CWRFERR:                                ; ...
                pop     ax              ; Chuck saved seg of transfer
                jmp     CRDFERR         ; Will pop one more stack element
; ---------------------------------------------------------------------------

CWRTROK:                                ; ...
                pop     ax              ; Chuck saved seg of transfer
                pop     ds
                mov     ax, ds:CALLBPB  ; [CALLSCNT]
                                        ; Get actual number of bytes transferred

ENDWRDEV:                               ; ...
                les     di, ds:THISSFT
                mov     cx, ax
                call    ADDREC
                retn
; ---------------------------------------------------------------------------

WRTNUL:                                 ; ...
                mov     dx, cx          ; Entire transfer done

WRTCOOKJ:                               ; ...
                jmp     WRTCOOKDONE
; ---------------------------------------------------------------------------

WRTDEV:                                 ; ...
                mov     ds:EXTERR_LOCUS, 4 ; errLOC_SerDev
                or      byte ptr es:[di+5], 40h ; [ES:DI+SF_ENTRY.sf_flags],
                                        ; devid_device_EOF
                                        ; Reset EOF for input
                mov     bl, es:[di+5]   ; [ES:DI+SF_ENTRY.sf_flags]
                xor     ax, ax
                jcxz    short ENDWRDEV  ; problem of creating on a device
                push    ds
                mov     al, bl
                lds     bx, ds:DMAADD   ; Xaddr to DS:BX
                mov     di, bx          ; Xaddr to DS:DI
                cwd                     ; Set starting point
                test    al, 20h         ; devid_device_raw
                jnz     short DVWRTRAW

TEST_DEV_CON:                           ;
                test    al, 2           ; devid_device_con_out
                                        ; Console output device?
                jnz     short WRITECON  ; yes
                test    al, 4           ; devid_device_null
                jnz     short WRTNUL
                mov     ax, dx
                cmp     byte ptr [bx], 1Ah ; ^Z?
                jz      short WRTCOOKJ  ; Yes, transfer nothing
                push    cx
                mov     cx, 1
                call    SETWRITE
                lds     si, ss:THISSFT
                pop     cx
                lds     si, [si+7]      ; [SI+SF_ENTRY.sf_devptr]

DVWRTLP:                                ; ...
                call    DSKSTATCHK
                call    DEVIOCALL2
                push    di
                mov     di, ss:DEVCALL_REQSTAT
                mov     ah, 87h
                or      di, di
                jns     short CWROK
                call    CHARHARD
                pop     di
                mov     ss:CALLBPB, 1   ; [SS:CALLSCNT]
                cmp     al, 1
                jz      short DVWRTLP   ; Retry
                or      al, al
                jz      short DVWRTIGN  ; Ignore
                jmp     CRDFERR         ; Fail, pops one stack element
; ---------------------------------------------------------------------------

CWROK:                                  ; ...
                pop     di
                cmp     ss:CALLBPB, 0   ; [SS:CALLSCNT]
                jz      short WRTCOOKDONE

DVWRTIGN:                               ; ...
                inc     dx
                inc     word ptr ss:CALLBR ; [SS:CALLXAD]
                inc     di
                push    ds
                mov     ds, ss:CALLXAD_2 ; [SS:CALLXAD+2]
                cmp     byte ptr [di], 1Ah ; ^Z?
                pop     ds
                jz      short WRTCOOKDONE
                mov     ss:DEVCALL_REQSTAT, 0
                loop    DVWRTLP

WRTCOOKDONE:                            ; ...
                mov     ax, dx
                pop     ds
                jmp     ENDWRDEV
; ---------------------------------------------------------------------------

WRITECON:                               ; ...
                push    ds
                push    ss
                pop     ds
                call    SWAPCON
                pop     ds
                mov     si, bx
                push    cx

WRCONLP:                                ; ...
                lodsb
                cmp     al, 1Ah         ; ^Z?
                jz      short CONEOF    ; yes
                call    OUTT
                loop    WRCONLP

CONEOF:                                 ; ...
                pop     ax              ; Count
                pop     ds
                sub     ax, cx          ; Amount actually written
                call    SWAPBACK
                jmp     ENDWRDEV
DOS_WRITE       endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


GET_IO_SFT      proc near               ; ...
                cmp     ss:CONSWAP, 0   ; Convert JFN num in BX to sf_entry in DS:SI
                jnz     short GetRedir

GetNormal:                              ; ...
                push    ss
                pop     ds
                push    es
                push    di
                call    SFFromHandle
                jb      short RET44P
                mov     si, es
                mov     ds, si
                mov     si, di

RET44P:                                 ; ...
                pop     di
                pop     es
                retn
; ---------------------------------------------------------------------------

GetRedir:                               ; ...
                cmp     bx, 1
                ja      short GetNormal
                lds     si, ss:CONSFT
                clc

get_io_sft_retn:                        ; ...
                retn
GET_IO_SFT      endp


; =============== S U B R O U T I N E =======================================


DIRREAD         proc near               ; ...
                xor     dx, dx
                cmp     ds:DIRSTART_HW, dx
                jnz     short SubDir
                cmp     ds:DIRSTART, dx
                jnz     short SubDir
                xchg    ax, dx
                jmp     short DoRead
; ---------------------------------------------------------------------------

SubDir:                                 ; ...
                mov     dl, al
                mov     cl, es:[bp+5]   ; [ES:BP+DPB.CLUSTER_SHIFT]
                and     dl, es:[bp+4]   ; [ES:BP+DPB.CLUSTER_MASK]
                shr     ax, cl

DoRead:                                 ; ...
                mov     ds:SECCLUSPOS, dl
                mov     cx, ax          ; (CX) = number of clusters to skip.
                mov     ah, dl          ; (AH) = remainder
                mov     bx, ds:CLUSNUM_HW
                mov     ds:NXTCLUSNUM_HW, bx
                mov     ds:CLUSTNUM_HW, bx
                mov     dx, ds:DIRSEC+2
                mov     bx, ds:CLUSNUM
                mov     ds:HIGH_SECTOR, dx
                mov     dx, ds:DIRSEC
                add     dl, ah
                adc     dh, 0
                adc     ds:HIGH_SECTOR, 0
                mov     ds:NXTCLUSNUM, bx
                jcxz    short FIRSTCLUSTER

SKPCLLP:                                ; ...
                call    UNPACK

dirread_cont:                           ; ...
                jb      short get_io_sft_retn
                push    ds:CLUSTNUM_HW
                pop     ds:CLUSTERS_HW
                push    ds:CCONTENT_HW
                pop     ds:CLUSTNUM_HW
                xchg    bx, di
                call    IsEOF           ; test for eof based on fat size
                jnb     short HAVESKIPPED
                loop    SKPCLLP

HAVESKIPPED:                            ; ...
                mov     ds:NXTCLUSNUM, bx
                mov     bx, ds:CLUSTNUM_HW
                mov     ds:NXTCLUSNUM_HW, bx
                mov     dx, di
                mov     bx, ds:CLUSTERS_HW
                mov     ds:CLUSTNUM_HW, bx
                mov     bl, ah
                call    FIGREC

FIRSTCLUSTER:                           ; ...
                mov     ds:ALLOWED, 18h ; Allowed_RETRY+Allowed_FAIL
                xor     al, al          ; Indicate pre-read
                call    GETBUFFR
                jb      short dirread_cont

SET_BUF_AS_DIR:                         ; ...
                push    ds
                push    si
                lds     si, ds:CURBUF
                or      byte ptr [si+5], 4 ; [SI+BUFFINFO.buf_flags],buf_isDIR
                pop     si
                pop     ds

dirread_retn:                           ; ...
                retn
DIRREAD         endp


; =============== S U B R O U T I N E =======================================


FATSECRD        proc near               ; ...

; FUNCTION CHUNK AT 8027 SIZE 00000007 BYTES

                mov     ss:ALLOWED, 18h ; Allowed_RETRY+Allowed_FAIL
                mov     di, cx
                mov     cl, es:[bp+8]   ; [ES:BP+DPB.FAT_COUNT]
                mov     ax, es:[bp+0Fh] ; [ES:BP+DPB.FAT_SIZE]
                xor     ch, ch
                or      ax, ax
                jnz     short FATSECRD_cont ; not FAT32
                test    byte ptr es:[bp+23h], 80h ; [ES:BP+DPB.EXT_FLAGS]
                jz      short FATSECRD_cont
                mov     cx, 1           ; only one FAT is active

FATSECRD_cont:                          ; ...
                push    ss:HIGH_SECTOR
                push    dx

NXTFAT:                                 ; ...
                push    cx
                push    ax
                push    ss:HIGH_SECTOR
                push    dx
                mov     cx, di
                call    DSKREAD
                pop     dx
                pop     ss:HIGH_SECTOR
                pop     ax
                pop     cx
                jz      short RET41P
                or      ax, ax
                jnz     short NXTFAT2   ; not FAT32
                add     dx, es:[bp+31h] ; DPB.FAT32_SIZE
                push    ax
                mov     ax, es:[bp+33h] ; DPB.FAT32_SIZE+2
                adc     ss:HIGH_SECTOR, ax
                pop     ax
                jmp     short NXTFAT3
; ---------------------------------------------------------------------------

NXTFAT2:                                ; ...
                add     dx, ax
                adc     ss:HIGH_SECTOR, 0

NXTFAT3:                                ; ...
                loop    NXTFAT
                pop     dx
                pop     ss:HIGH_SECTOR
                mov     cx, di
FATSECRD        endp


; =============== S U B R O U T I N E =======================================


DREAD           proc near               ; ...
                call    DSKREAD
                jz      short dirread_retn
                mov     ss:READOP, 0    ; Read
                call    HARDERRRW
                cmp     al, 1           ; RETRY
                jz      short DREAD
                cmp     al, 3           ; FAIL
                clc
                jnz     short NO_CAR    ; IGNORE
                stc

NO_CAR:                                 ; ...
                retn
DREAD           endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR FATSECRD

RET41P:                                 ; ...
                pop     dx
                pop     ss:HIGH_SECTOR
                retn
; END OF FUNCTION CHUNK FOR FATSECRD

; =============== S U B R O U T I N E =======================================


CHECK_WRITE_LOCK proc near              ; ...
                test    byte ptr es:[di+4], 8 ; [ES:DI+SF_ENTRY.sf_attr],
                                        ; attr_volume_id
                jz      short write_cont
                call    SET_ACC_ERR_DS
                retn
; ---------------------------------------------------------------------------

write_cont:                             ; ...
                push    cx
                or      cx, cx
                jnz     short Not_Truncate
                dec     cx              ; -1 ; check for lock on whole file

Not_Truncate:                           ; ...
                mov     al, 80h         ; check write access
                call    LOCK_CHECK      ; check lock
                pop     cx
                jnb     short WRITE_OK  ; lock ok
                call    WRITE_LOCK_VIOLATION ; issue I24
                jnb     short write_cont ; retry

WRITE_OK:                               ; ...
                retn
CHECK_WRITE_LOCK endp


; =============== S U B R O U T I N E =======================================


CHECK_READ_LOCK proc near               ; ...
                test    byte ptr es:[di+4], 8 ; [ES:DI+SF_ENTRY.sf_attr],
                                        ; attr_volume_id
                jz      short do_retry
                call    SET_ACC_ERR
                retn
; ---------------------------------------------------------------------------

do_retry:                               ; ...
                xor     al, al          ; check read access
                call    LOCK_CHECK      ; check lock
                jnb     short READLOCK_OK ; lock ok
                call    READ_LOCK_VIOLATION ; issue I24
                jnb     short do_retry  ; retry

READLOCK_OK:                            ; ...
                retn
CHECK_READ_LOCK endp


; =============== S U B R O U T I N E =======================================


DSKREAD         proc near               ; ...
                push    cx              ; DS:BX = Transfer address
                                        ; [HIGH_SECTOR]:DX = Disk sector address
                                        ; CX = Sector count
                                        ; ES:BP = DPB
                mov     ah, es:[bp+17h] ; [ES:BP+DPB.MEDIA]
                mov     al, es:[bp+1]   ; [ES:BP+DPB.UNIT]
                push    bx
                push    es
                call    SETREAD
                jmp     short DODSKOP
DSKREAD         endp


; =============== S U B R O U T I N E =======================================


DWRITE          proc near               ; ...
                call    DSKWRITE
                jnz     short dwrite1
                retn                    ; Carry clear (retz)
; ---------------------------------------------------------------------------

dwrite1:                                ; ...
                mov     ss:READOP, 1    ; Write
                call    HARDERRRW
                cmp     al, 1           ; Check for retry
                jz      short DWRITE
                cmp     al, 3           ; Check for FAIL
                clc
                jnz     short NO_CAR2   ; Ignore
                stc

NO_CAR2:                                ; ...
                retn
DWRITE          endp


; =============== S U B R O U T I N E =======================================


DSKWRITE        proc near               ; ...
                push    cx              ; DS:BX = Transfer address
                                        ; [HIGH_SECTOR]:DX = Disk sector address
                                        ; CX = Sector count
                                        ; ES:BP = DPB
                mov     ah, es:[bp+17h] ; [ES:BP+DPB.MEDIA]
                mov     al, es:[bp+1]   ; [ES:BP+DPB.UNIT]
                push    bx
                push    es
                call    SETWRITE

DODSKOP:                                ; ...
                mov     cx, ds
                pop     ds              ; DS:BP points to DPB
                push    ds
                lds     si, ds:[bp+13h] ; [ds:BP+DPB.DRIVER_ADDR]
                call    DEVIOCALL2
                mov     ds, cx
                pop     es
                pop     bx
                pop     di
                mov     cx, ss:CALLBPB  ; [SS:CALLSCNT] ; Number of sectors transferred
                mov     ax, ss:DEVCALL_REQSTAT
                sub     cx, di
                neg     cx              ; Number of sectors not transferred
                test    ax, 8000h       ; test ah,(STERR>>8)
                retn
DSKWRITE        endp


; =============== S U B R O U T I N E =======================================


HARDERRRW       proc near               ; ...
                cmp     al, 0Fh         ; error_I24_wrong_disk
                jnz     short DO_ERR
                push    ax
                push    es
                les     ax, ss:CALLVIDRW
                mov     word ptr ss:EXTERRPT, ax
                mov     word ptr ss:EXTERRPT+2, es
                pop     es
                pop     ax

DO_ERR:                                 ; ...
                call    HARDERR
                retn
HARDERRRW       endp


; =============== S U B R O U T I N E =======================================


SETUP           proc near               ; ...
                lds     si, es:[di+7]   ; [ES:DI+SF_ENTRY.sf_devptr]
                mov     word ptr ss:THISDPB+2, ds
                mov     bx, ss
                mov     ds, bx
                mov     bx, word ptr ds:DMAADD
                mov     word ptr ds:THISDPB, si
                mov     ds:NEXTADD, bx  ; Set NEXTADD to start of Xaddr
                mov     ds:TRANS, 0     ; No transferes
                mov     ax, es:[di+15h] ; [ES:DI+SF_ENTRY.sf_position]
                mov     dx, es:[di+17h] ; [ES:DI+SF_ENTRY.sf_position+2]
                mov     word ptr ds:BYTPOS, ax
                mov     word ptr ds:BYTPOS+2, dx
                test    word ptr es:[di+5], 8080h ; [ES:DI+SF_ENTRY.sf_flags],
                                        ; sf_isnet+devid_device
                jnz     short NOSETSTUFF
                push    es
                les     bp, ds:THISDPB
                mov     bl, es:[bp+0]   ; [ES:BP+DPB.DRIVE]
                push    cx              ; SHR32 and DIV32 use CX.
                mov     ds:THISDRV, bl
                mov     bx, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE]
                call    DIV32           ; DX:AX/BX = CX:AX + DX (rem)
                mov     ds:BYTSECPOS, dx
                mov     word ptr ds:SECPOS, ax
                mov     word ptr ds:SECPOS+2, cx
                mov     bx, ax
                mov     dx, cx
                and     bl, es:[bp+4]   ; [ES:BP+DPB.CLUSTER_MASK]
                mov     ds:SECCLUSPOS, bl
                call    SHR32           ; (DX:AX SHR dpb_cluster_shift)
                pop     cx              ; CX = byte count.
                cmp     word ptr es:[bp+0Fh], 0 ; [es:bp+DPB.FAT_SIZE]
                jnz     short setup_1   ; not FAT32
                cmp     dx, es:[bp+2Fh] ; [ES:BP+DPB.LAST_CLUSTER+2]
                jnz     short setup_2
                cmp     ax, es:[bp+2Dh] ; [ES:BP+DPB.LAST_CLUSTER]
                jmp     short setup_2
; ---------------------------------------------------------------------------

setup_1:                                ; ...
                or      dx, dx
                jnz     short EOFERR
                cmp     ax, es:[bp+0Dh] ; [ES:BP+DPB.MAX_CLUSTER]

setup_2:                                ; ...
                ja      short EOFERR
                mov     ds:CLUSNUM, ax
                mov     ds:CLUSNUM_HW, dx
                pop     es

NOSETSTUFF:                             ; ...
                mov     ax, cx          ; Byte count.
                add     ax, word ptr ds:DMAADD ; See if it will fit in one segment
                jb      short setup_3   ; Must be less than 64K
                retn
; ---------------------------------------------------------------------------

setup_3:                                ; ...
                mov     ax, word ptr ds:DMAADD
                neg     ax              ; Amount of room left in segment
                jnz     short NoDec
                dec     ax

NoDec:                                  ; ...
                mov     cx, ax          ; Can do this much
                jcxz    short NOROOM    ; Silly user gave Xaddr of FFFF in segment
                retn
; ---------------------------------------------------------------------------

EOFERR:                                 ; ...
                pop     es              ; ES:DI point to SFT
                xor     cx, cx          ; No bytes read

NOROOM:                                 ; ...
                pop     bx              ; Kill return address
                clc
                retn                    ; RETURN TO CALLER OF CALLER
SETUP           endp


; =============== S U B R O U T I N E =======================================


BREAKDOWN       proc near               ; ...
                mov     ax, ds:BYTSECPOS
                mov     bx, cx
                or      ax, ax
                jz      short SAVFIR    ; Partial first sector?
                sub     ax, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE]
                neg     ax              ; Max number of bytes left in first sector
                sub     bx, ax          ; Subtract from total length
                jnb     short SAVFIR
                add     ax, bx          ; Don't use all of the rest of the sector
                xor     bx, bx          ; And no bytes are left

SAVFIR:                                 ; ...
                mov     ds:BYTCNT1, ax
                mov     ax, bx
                xor     dx, dx
                div     word ptr es:[bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
                                        ; How many whole sectors?
                mov     ds:SECCNT, ax
                mov     ds:BYTCNT2, dx  ; Bytes remaining for last sector

_RET45:                                 ; ...
                retn
BREAKDOWN       endp


; =============== S U B R O U T I N E =======================================


READ_LOCK_VIOLATION proc near           ; ...
                mov     ds:READOP, 0

ERR_ON_CHECK:                           ; ...
                test    byte ptr es:[di+3], 80h ; [ES:DI+SF_ENTRY.sf_mode+1],
                                        ; (sf_isFCB>>8)
                jnz     short HARD_ERR
                push    cx
                mov     cl, es:[di+2]   ; [ES:DI+SF_ENTRY.sf_mode]
                and     cl, 0F0h        ; SHARING_MASK
                cmp     cl, 0           ; SHARING_COMPAT
                pop     cx
                jnz     short NO_HARD_ERR

HARD_ERR:                               ; ...
                call    LOCK_VIOLATION
                jnb     short _RET45

NO_HARD_ERR:                            ; ...
                xor     cx, cx          ; No bytes transferred
                mov     ax, 21h         ; error_lock_violation
                stc

RET3:                                   ; ...
                retn
READ_LOCK_VIOLATION endp


; =============== S U B R O U T I N E =======================================


WRITE_LOCK_VIOLATION proc near          ; ...
                mov     ds:READOP, 1
                jmp     short ERR_ON_CHECK
WRITE_LOCK_VIOLATION endp


; =============== S U B R O U T I N E =======================================


DISKREAD        proc near               ; ...

; FUNCTION CHUNK AT 821D SIZE 00000006 BYTES
; FUNCTION CHUNK AT 822C SIZE 0000008E BYTES
; FUNCTION CHUNK AT 82BD SIZE 0000001A BYTES

                mov     ax, es:[di+11h] ; [ES:DI+SF_ENTRY.sf_size]
                mov     bx, es:[di+13h] ; [ES:DI+SF_ENTRY.sf_size+2]
                sub     ax, word ptr ds:BYTPOS
                sbb     bx, word ptr ds:BYTPOS+2
                jb      short RDERR     ; Read starts past EOF
                jnz     short ENUF      ; More than 64k to EOF
                or      ax, ax
                jz      short RDERR     ; Read starts at EOF
                cmp     ax, cx
                jnb     short ENUF      ; I/O fits
                mov     cx, ax          ; Limit read to up til EOF

ENUF:                                   ; ...
                call    CHECK_READ_LOCK
                jb      short RET3

_READ_OK:                               ; There are no locks
                les     bp, ds:THISDPB
                call    BREAKDOWN
                mov     cx, ds:CLUSNUM
                mov     dx, ds:CLUSNUM_HW
                call    FNDCLUS
                jb      short SET_ACC_ERR_DS ; ds=ss
                cmp     ds:CLSKIP_HW, 0
                jnz     short RDERR
                jcxz    short SKIPERR

RDERR:                                  ; ...
                mov     ah, 0Eh         ; read/data/fail
                jmp     WRTERR22
DISKREAD        endp


; =============== S U B R O U T I N E =======================================

; Attributes: thunk

SETSFTJ2        proc near               ; ...
                jmp     SETSFT
SETSFTJ2        endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR DISKREAD

CANOT_READ:                             ; ...
                pop     cx              ; Clean stack
                pop     bx
                pop     ds:CCONTENT_HW  ; PCDOS 7.1 BUG!?
; END OF FUNCTION CHUNK FOR DISKREAD    ; I think, this would be 'pop ss:CCONTENT_HW'
                                        ; because ds<>ss while jumping here.
                                        ; Erdogan Tan - 09/02/2024

; =============== S U B R O U T I N E =======================================


SET_ACC_ERR_DS  proc near               ; ...
                push    ss
                pop     ds
SET_ACC_ERR_DS  endp


; =============== S U B R O U T I N E =======================================


SET_ACC_ERR     proc near               ; ...
                xor     cx, cx
                mov     ax, 5           ; error_access_denied
                stc
                retn
SET_ACC_ERR     endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR DISKREAD

SKIPERR:                                ; ...
                mov     ds:LASTPOS, dx
                mov     ds:CLUSNUM, bx
                mov     bx, ds:CLUSTNUM_HW
                mov     ds:CLUSNUM_HW, bx
                cmp     ds:BYTCNT1, 0
                jz      short RDMID
                call    BUFRD
                jb      short SET_ACC_ERR_DS ; ds=ss

RDMID:                                  ; ...
                cmp     ds:SECCNT, 0
                jz      short RDLAST
                call    NEXTSEC
                jb      short SETSFTJ2
                mov     ds:TRANS, 1     ; A transfer is taking place
                mov     dl, ds:SECCLUSPOS ;
                                        ; (dx/DL = Extent start) ((dh = ?))
                mov     cx, ds:SECCNT
                mov     bx, ds:CLUSNUM_HW
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, ds:CLUSNUM

RDLP:                                   ; ...
                call    OPTIMIZE
                jb      short SET_ACC_ERR_DS ; ds=ss
                push    ds:CCONTENT_HW  ; (Next physical cluster, hw)
                push    di              ; DI = Next physical cluster.
                push    ax              ; AX = # of sectors remaining.
                push    bx              ; [DMAADD+2]:BX = Transfer address.
                mov     ds:ALLOWED, 38h ; Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
                mov     ds, word ptr ds:DMAADD+2
                push    dx              ; [HIGH_SECTOR]:DX = phys. sector #.
                push    cx              ; CX = # of contiguous sectors to read.
                call    null_sub        ; SET_RQ_SC_PARMS
                call    DREAD
                pop     cx
                pop     dx
                pop     ss:TEMP_VAR
                jb      short CANOT_READ ; ds<>ss
                mov     ss:TEMP_VAR2, ds
                call    DskRdBufScan
                mov     cx, ss
                mov     ds, cx
                pop     cx              ; # of sectors remaining.
                pop     bx              ; Next physical cluster.
                pop     ds:CLUSTNUM_HW  ; (Next physical cluster, hw)
                jcxz    short RDLAST
                call    IsEOF           ; test for eof on fat size
                jnb     short SETSFT
                mov     dl, 0
                add     ds:LASTPOS, 1   ; We'll be using next cluster
                adc     ds:LASTPOS_HW, 0
                jmp     short RDLP
; END OF FUNCTION CHUNK FOR DISKREAD

; =============== S U B R O U T I N E =======================================

; Attributes: thunk

j_SET_ACC_ERR_DS proc near              ; ...
                jmp     SET_ACC_ERR_DS
j_SET_ACC_ERR_DS endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR DISKREAD

RDLAST:                                 ; ...
                mov     ax, ds:BYTCNT2
                or      ax, ax
                jz      short SETSFT
                mov     ds:BYTCNT1, ax
                call    NEXTSEC
                jb      short SETSFT
                mov     ds:BYTSECPOS, 0
                call    BUFRD
                jb      short j_SET_ACC_ERR_DS ; ds=ss
; END OF FUNCTION CHUNK FOR DISKREAD

; =============== S U B R O U T I N E =======================================


SETSFT          proc near               ; ...
                les     di, ds:THISSFT

SETCLUS:                                ; ...
                mov     cx, ds:NEXTADD
                sub     cx, word ptr ds:DMAADD ; Number of bytes transfered
                test    byte ptr es:[di+5], 80h ; [ES:DI+SF_ENTRY.sf_flags],
                                        ; devid_device
                jnz     short ADDREC    ; don't set clusters if device
                mov     ax, ds:CLUSNUM_HW
                mov     es:[di+37h], ax ; [ES:DI+SF_ENTRY.sf_lstclus+2]
                mov     ax, ds:LASTPOS_HW
                mov     es:[di+0Bh], ax ; [ES:DI+SF_ENTRY.sf_cluspos_hw] ; PCDOS 7.1 & Win ME
                                        ; [ES:DI+SF_ENTRY.sf_firclus] ; MSDOS 5.0-6.22
                mov     ax, ds:CLUSNUM
                mov     es:[di+35h], ax ; [ES:DI+SF_ENTRY.sf_lstclus]
                mov     ax, ds:LASTPOS
                mov     es:[di+19h], ax ; [ES:DI+SF_ENTRY.sf_cluspos]
SETSFT          endp


; =============== S U B R O U T I N E =======================================


ADDREC          proc near               ; ...
                jcxz    short RET28
                add     es:[di+15h], cx ; [ES:DI+SF_ENTRY.sf_position]
                                        ; Update current position
                adc     word ptr es:[di+17h], 0 ; [ES:DI+SF_ENTRY.sf_position+2]

RET28:                                  ; ...
                clc
                retn
ADDREC          endp


; =============== S U B R O U T I N E =======================================


DskRdBufScan    proc near               ; ...
                cmp     ss:DirtyBufferCount, 0 ; Any dirty buffers?
                jz      short bufx      ; -no, skip all work.
                mov     bx, ss:HIGH_SECTOR
                add     cx, dx
                mov     si, bx
                adc     si, 0
                call    GETCURHEAD      ; DS:DI -> 1st buf in queue.
                mov     ax, [di+2]      ; [di+BUFFINFO.buf_prev]
                mov     ss:FIRST_BUFF_ADDR, ax
                mov     al, es:[bp+0]   ; [es:bp+DPB.DRIVE]

bufq:                                   ; ...
                cmp     al, [di+4]      ; [di+BUFFINFO.buf_ID] ; Same drive?
                jnz     short bufq1     ; no
                cmp     bx, [di+8]      ; [di+BUFFINFO.buf_sector+2]
                jnz     short bufq01
                cmp     dx, [di+6]      ; [di+BUFFINFO.buf_sector]

bufq01:                                 ; ...
                ja      short bufq1
                cmp     si, [di+8]
                jnz     short bufq02
                cmp     cx, [di+6]

bufq02:                                 ; ...
                ja      short bufq2

bufq1:                                  ; ...
                cmp     di, ss:FIRST_BUFF_ADDR ; Scanned entire buffer queue?
                mov     di, [di]        ; [di+BUFFINFO.buf_next]
                jnz     short bufq      ; -no, do next buffer

bufx:                                   ; ...
                retn                    ; Exit.
; ---------------------------------------------------------------------------

bufq2:                                  ; ...
                push    ax
                test    byte ptr [di+5], 40h ; [di+BUFFINFO.buf_flags],buf_dirty
                jz      short bufq3
                push    cx
                push    dx
                push    si
                push    di
                push    es
                mov     ax, dx
                sub     ax, [di+6]      ; [di+BUFFINFO.buf_sector]
                neg     ax
                mov     cx, es:[bp+2]   ; [es:bp+DPB.SECTOR_SIZE]
                lea     si, [di+18h]    ; [di+BUFINSIZ]
                mul     cx
                les     di, dword ptr ss:TEMP_VAR
                add     di, ax
                shr     cx, 1
                cmp     ss:DDMOVE, 0
                jz      short near ptr bufq03+1 ; rep movsw
                                        ; (skip 32 bit prefix)
                shr     cx, 1

bufq03:                                 ; ...
                rep movsd
                pop     es
                pop     di
                pop     si
                pop     dx
                pop     cx

bufq3:                                  ; ...
                mov     ax, di
                call    SCANPLACE
                cmp     ax, ss:FIRST_BUFF_ADDR
                pop     ax
                jnz     short bufq
                retn
DskRdBufScan    endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR DISKWRITE

WRTEOFJ:                                ; ...
                jmp     WRTEOF
; END OF FUNCTION CHUNK FOR DISKWRITE

; =============== S U B R O U T I N E =======================================


dskwrt_retj     proc near               ; ...
                jmp     dskwrt_retn
dskwrt_retj     endp


; =============== S U B R O U T I N E =======================================


DISKWRITE       proc near               ; ...

; FUNCTION CHUNK AT 839D SIZE 00000003 BYTES

                call    CHECK_WRITE_LOCK
                jb      short dskwrt_retj
                and     word ptr es:[di+5], 0BFBFh ; [ES:DI+SF_ENTRY.sf_flags],
                                        ; ~(sf_close_nodate|devid_file_clean)
                les     ax, es:[di+11h] ; [ES:DI+SF_ENTRY.sf_size]
                mov     ds:TEMP_VAR2, es
                mov     ds:TEMP_VAR, ax
                les     bp, ds:THISDPB
                call    BREAKDOWN
                mov     ax, word ptr ds:BYTPOS
                mov     dx, word ptr ds:BYTPOS+2
                jcxz    short WRTEOFJ   ; Make the file length = sf_position
                add     ax, cx
                adc     dx, 0           ; DX:AX = last byte to write + 1.
                jnb     short dskwrt_1

ACC_ERRWJ2:                             ; ...
                jmp     SET_ACC_ERRW
; ---------------------------------------------------------------------------

dskwrt_1:                               ; ...
                test    byte ptr es:[di+3], 10h ; [es:di+SF_ENTRY.sf_mode+1],10h
                jnz     short dskwrt_3  ; > 2GB file size (up to 4GB) allowed
                cmp     dx, 7FFFh       ; check for 2GB file size limit
                jnz     short dskwrt_2
                cmp     ax, 0FFFFh

dskwrt_2:                               ; ...
                ja      short ACC_ERRWJ2 ; error,
                                        ; file position/pointer overs 2GB limit!

dskwrt_3:                               ; ...
                mov     bx, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE]
                call    DIV32           ; DX:AX/BX = CX:AX + DX (rem.).
                mov     si, ax
                mov     ds:HIGH_SECTOR, cx
                or      dx, dx
                push    dx
                mov     dx, cx
                jnz     short CALCLUS
                sub     ax, 1           ; DX:AX must be zero base indexed
                sbb     dx, 0

CALCLUS:                                ; ...
                call    SHR32           ; 32 bit shift right (dx:ax)
                pop     cx
                xchg    cx, dx
                push    cx
                push    ax              ; !*! cx:ax = Last cluster to write
                push    dx              ; # of bytes in last sector to write
                mov     dx, ds:TEMP_VAR2
                mov     ax, ds:TEMP_VAR ; DX:AX = current file size (in bytes).
                call    DIV32
                mov     ds:TEMP_VAR2, cx
                mov     ds:VALSEC+2, cx
                mov     cx, ax
                mov     bx, si
                or      dx, dx
                jz      short NORND
                add     ax, 1           ; Round up if any remainder
                adc     ds:VALSEC+2, 0

NORND:                                  ; ...
                mov     ds:VALSEC, ax
                xor     ax, ax
                mov     word ptr ds:GROWCNT, ax
                mov     word ptr ds:GROWCNT+2, ax
                mov     di, ds:HIGH_SECTOR
                pop     ax              ; # of bytes in last sector to write
                cmp     di, ds:TEMP_VAR2
                jb      short NOGROW
                jz      short lowsec
                sub     bx, cx
                sbb     di, ds:TEMP_VAR2
                jmp     short yesgrow
; ---------------------------------------------------------------------------

lowsec:                                 ; ...
                xor     di, di
                sub     bx, cx
                jb      short NOGROW
                jz      short TESTTAIL

yesgrow:                                ; ...
                mov     cx, dx
                xchg    ax, bx
                mul     word ptr es:[bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
                                        ; Bytes of full sector growth
                mov     ds:HIGH_SECTOR, dx
                mov     ds:TEMP_VAR2, ax
                mov     ax, di
                mul     word ptr es:[bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
                add     ax, ds:HIGH_SECTOR
                xchg    ax, dx
                mov     ax, ds:TEMP_VAR2
                sub     ax, cx          ; Take off current "tail"
                sbb     dx, 0
                add     ax, bx          ; Add on new "tail"
                adc     dx, 0
                jmp     short SETGRW
; ---------------------------------------------------------------------------

HAVSTART:                               ; ...
                mov     ds:CLSKIP_HW, si
                mov     cx, ax
                call    SKPCLP
                mov     ax, ds:CLSKIP_HW
                cmp     ax, cx
                jnz     short HAVSTART_cont
                jcxz    short DOWRTJ

HAVSTART_cont:                          ; ...
                mov     ds:CCOUNT_HW, ax
                call    ALLOCATE
                jnb     short DOWRTJ

WRTERR:                                 ; ...
                mov     ah, 0Fh         ; write/data/fail/abort

WRTERR22:                               ; ...
                mov     al, ds:THISDRV
                xor     cx, cx          ; No bytes transferred
                les     di, ds:THISSFT
                clc

dskwrt_retn:                            ; ...
                retn
; ---------------------------------------------------------------------------

DOWRTJ:                                 ; ...
                jmp     DOWRT
; ---------------------------------------------------------------------------

TESTTAIL:                               ; ...
                sub     ax, dx
                jbe     short NOGROW
                xor     dx, dx

SETGRW:                                 ; ...
                mov     word ptr ds:GROWCNT, ax
                mov     word ptr ds:GROWCNT+2, dx

NOGROW:                                 ; ...
                mov     cx, ds:CLUSNUM  ; First cluster accessed
                mov     dx, ds:CLUSNUM_HW
                call    FNDCLUS
                pop     ax
                pop     si              ; !*! si:ax = Last cluster
                jb      short ACC_ERRWJ ; ds=ss
                mov     ds:CLUSNUM, bx
                mov     ds:LASTPOS, dx
                sub     ax, dx          ; Last cluster minus current cluster
                sbb     si, ds:LASTPOS_HW
                mov     dx, ds:CLUSTNUM_HW
                mov     ds:CLUSNUM_HW, dx
                jnz     short NOGROW2
                or      ax, ax
                jz      short DOWRT

NOGROW2:                                ; ...
                cmp     cx, ds:CLSKIP_HW
                jnz     short dskwrt_4
                jcxz    short HAVSTART

dskwrt_4:                               ; ...
                push    cx
                push    ds:CLSKIP_HW
                mov     ds:CCOUNT_HW, si
                mov     cx, ax
                call    ALLOCATE
                pop     ds:CLSKIP_HW
                pop     cx
                jb      short WRTERR
                mov     dx, ds:LASTPOS
                add     dx, 1
                adc     ds:LASTPOS_HW, 0
                sub     cx, 1
                sbb     ds:CLSKIP_HW, 0
                jnz     short dskwrt_5
                or      cx, cx

dskwrt_5:                               ; ...
                jz      short NOSKIP
                call    SKPCLP
                jnb     short NOSKIP

ACC_ERRWJ:                              ; ...
                jmp     SET_ACC_ERRW
; ---------------------------------------------------------------------------

NOSKIP:                                 ; ...
                mov     ds:CLUSNUM, bx
                mov     ax, ds:CLUSTNUM_HW
                mov     ds:CLUSNUM_HW, ax
                mov     ds:LASTPOS, dx

DOWRT:                                  ; ...
                cmp     ds:BYTCNT1, 0
                jz      short WRTMID
                mov     bx, ds:CLUSNUM_HW
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, ds:CLUSNUM
                call    BUFWRT
                jb      short ACC_ERRWJ ; ds=ss

WRTMID:                                 ; ...
                mov     ax, ds:SECCNT
                or      ax, ax
                jnz     short WRTMID2
                jmp     WRTLAST
; ---------------------------------------------------------------------------

WRTMID2:                                ; ...
                add     word ptr ds:SECPOS, ax
                adc     word ptr ds:SECPOS+2, 0
                call    NEXTSEC
                jb      short SET_ACC_ERRW ; ds=ss
                mov     ds:TRANS, 1     ; A transfer is taking place
                mov     dl, ds:SECCLUSPOS ; DL = Extent start
                mov     bx, ds:CLUSNUM_HW
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, ds:CLUSNUM
                mov     cx, ds:SECCNT

WRTLP:                                  ; ...
                call    OPTIMIZE
                jb      short SET_ACC_ERRW ; ds=ss
                push    ds:CCONTENT_HW
                push    di              ; CCONTENT_HW:DI = Next physical cluster
                push    ax              ; AX = # sectors remaining
                call    DskWrtBufPurge  ; DS trashed.
                mov     ds, word ptr ss:DMAADD+2
                mov     ss:ALLOWED, 38h ; Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE

DWRITE_LUP:                             ; ...
                call    DSKWRITE
                jz      short DWRITE_OKAY ; ds<>ss
                cmp     al, 27h         ; error_handle_Disk_Full
                jz      short DWRITE_DISK_FULL
                mov     ss:READOP, 1
                call    HARDERRRW
                cmp     al, 1           ; Check for retry
                jz      short DWRITE_LUP
                cmp     al, 3           ; Check for FAIL
                clc
                jnz     short DWRITE_OKAY ; Ignore
                stc

DWRITE_OKAY:                            ; ...
                pop     cx              ; CX = # sectors remaining
                pop     bx
                pop     ss:CLUSTNUM_HW  ; CLUSTNUM_HW:BX = Next physical cluster
                push    ss
                pop     ds
                jb      short SET_ACC_ERRW ; ds=ss
                jcxz    short WRTLAST
                mov     dl, 0
                add     ds:LASTPOS, 1   ; We'll be using next cluster
                adc     ds:LASTPOS_HW, 0
                jmp     short WRTLP
; ---------------------------------------------------------------------------

DWRITE_DISK_FULL:                       ; ...
                push    ss
                pop     ds
                pop     cx              ; unjunk stack
                pop     bx
                pop     ds:CLUSTNUM_HW
                mov     ds:DISK_FULL, 1
                stc
                jmp     WRTERR          ; go to disk full exit
; ---------------------------------------------------------------------------

SET_ACC_ERRW:                           ; ...
                jmp     SET_ACC_ERR_DS
; ---------------------------------------------------------------------------

WRTLAST:                                ; ...
                mov     ax, ds:BYTCNT2
                or      ax, ax
                jz      short FINWRT
                mov     ds:BYTCNT1, ax
                call    NEXTSEC
                jb      short SET_ACC_ERRW
                mov     ds:BYTSECPOS, 0
                call    BUFWRT

SET_ACC_ERRWJ:                          ; ...
                jb      short SET_ACC_ERRW

FINWRT:                                 ; ...
                les     di, ds:THISSFT
                mov     ax, word ptr ds:GROWCNT
                mov     cx, word ptr ds:GROWCNT+2
                or      ax, ax
                jnz     short UPDATE_size
                jcxz    short SAMSIZ

UPDATE_size:                            ; ...
                add     es:[di+11h], ax ; [ES:DI+SF_ENTRY.sf_size]
                adc     es:[di+13h], cx ; [ES:DI+SF_ENTRY.sf_size+2]
                mov     ax, 1
                call    ds:ShSU         ; call far [JShare+(14*4)] ; 14 = ShSU

SAMSIZ:                                 ; ...
                jmp     SETCLUS         ; ES:DI already points to SFT
; ---------------------------------------------------------------------------

WRTEOF:                                 ; ...
                mov     cx, ax
                or      cx, dx
                jnz     short WRTEOF1
                jmp     KILLFIL
; ---------------------------------------------------------------------------

WRTEOF1:                                ; ...
                cmp     dx, 7FFFh       ; 2GB file size limit
                jnz     short WRTEOF2
                cmp     ax, 0FFFFh

WRTEOF2:                                ; ...
                jbe     short WRTEOF3
                push    es
                les     di, ds:THISSFT
                test    byte ptr es:[di+3], 10h ; [es:di+SF_ENTRY.sf_mode+1],10h
                pop     es
                jz      short SET_ACC_ERRW ; > 2GB file size not allowed

WRTEOF3:                                ; ...
                sub     ax, 1
                sbb     dx, 0
                push    bx
                mov     bx, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE]
                call    DIV32
                pop     bx
                mov     dx, cx
                mov     ds:HIGH_SECTOR, cx
                call    SHR32
                mov     cx, ax
                call    FNDCLUS

SET_ACC_ERRWJ2:                         ; ...
                jb      short SET_ACC_ERRWJ
                mov     ax, ds:CLSKIP_HW
                cmp     ax, cx
                jnz     short dskwrt_6
                jcxz    short RELFILE

dskwrt_6:                               ; ...
                mov     ds:CCOUNT_HW, ax
                call    ALLOCATE
                jb      short WRTERRJ   ; disk full

UPDATE:                                 ; ...
                mov     ax, word ptr ds:BYTPOS
                les     di, ds:THISSFT
                mov     es:[di+11h], ax ; ES:DI+SF_ENTRY.sf_size]
                mov     ax, word ptr ds:BYTPOS+2
                mov     es:[di+13h], ax ; ES:DI+SF_ENTRY.sf_size+2]
                mov     ax, 2
                call    ds:ShSU         ; call far [JShare+(14*4)] ; 14 = ShSU
                xor     cx, cx
                jmp     ADDREC
; ---------------------------------------------------------------------------

WRTERRJ:                                ; ...
                jmp     WRTERR
; ---------------------------------------------------------------------------

RELFILE:                                ; ...
                push    es              ; Reset Lstclus and cluspos to
                les     di, ds:THISSFT  ; beginning of file if current
                push    ax              ; cluspos is past EOF.
                mov     ax, ds:LASTPOS_HW
                cmp     ax, es:[di+0Bh] ; [ES:DI+SF_ENTRY.sf_firclus]
                                        ; [ES:DI+SF_ENTRY.sf_cluspos_hw] !?
                pop     ax
                jnz     short dskwrt_7
                cmp     dx, es:[di+19h] ; [ES:DI+SF_ENTRY.sf_cluspos]

dskwrt_7:                               ; ...
                jnb     short SKIPRESET
                mov     dx, es:[di+2Bh] ; [ES:DI+SF_ENTRY.sf_chain]
                                        ; first cluster (32 bit) lw !?
                mov     word ptr es:[di+19h], 0
                mov     es:[di+35h], dx ; [ES:DI+SF_ENTRY.sf_lstclus]
                mov     word ptr es:[di+0Bh], 0
                mov     dx, es:[di+2Dh] ; [ES:DI+SF_ENTRY.sf_chain]
                                        ; first cluster (32 bit) hw !?
                mov     es:[di+37h], dx ; [ES:DI+SF_ENTRY.sf_lstclus+2]

SKIPRESET:                              ; ...
                pop     es
                xor     dx, dx
                dec     dx
                mov     ds:CLUSDATA_HW, dx ; 0FFFFh
                call    RELBLKS

dskwrt_8:                               ; ...
                jb      short SET_ACC_ERRWJ2 ; ds=ss

UPDATEJ:                                ; ...
                jmp     short UPDATE
; ---------------------------------------------------------------------------

KILLFIL:                                ; ...
                xor     bx, bx
                push    es
                les     di, ds:THISSFT
                xchg    bx, es:[di+2Dh] ; [ES:DI+SF_ENTRY.sf_chain+2]
                                        ; first cluster (32 bit) hw !?
                mov     ds:CLUSTNUM_HW, bx
                xor     bx, bx          ; 0
                mov     es:[di+0Bh], bx ; [ES:DI+SF_ENTRY.sf_firclus]
                                        ; [ES:DI+SF_ENTRY.sf_cluspos_hw] !?
                mov     es:[di+37h], bx ; [ES:DI+SF_ENTRY.sf_lstclus+2]
                mov     es:[di+19h], bx ; [ES:DI+SF_ENTRY.sf_cluspos]
                mov     es:[di+35h], bx ; [ES:DI+SF_ENTRY.sf_lstclus]
                xchg    bx, es:[di+2Bh] ; [ES:DI+SF_ENTRY.sf_chain]
                                        ; first cluster (32 bit) !?
                pop     es
                cmp     bx, ds:CLUSTNUM_HW
                jnz     short dskwrt_9
                or      bx, bx

dskwrt_9:                               ; ...
                jz      short UPDATEJ
                push    es              ; since first cluster # is 0
                push    bp              ; we must delete the old cache entry
                push    ax
                push    cx
                les     bp, ds:THISDPB  ; get current DPB
                push    dx
                mov     dl, es:[bp+0]   ; get current drive
                mov     cx, bx          ; first cluster #
                mov     ah, 2           ; delete cache entry by drive:firclus
                call    FastOpen_Update ; call fastopen
                pop     dx
                pop     cx
                pop     ax
                pop     bp
                pop     es
                call    RELEASE
                jmp     short dskwrt_8
DISKWRITE       endp


; =============== S U B R O U T I N E =======================================


DskWrtBufPurge  proc near               ; ...
                push    bx
                push    cx
                mov     bx, ss:HIGH_SECTOR
                add     cx, dx
                mov     si, bx
                adc     si, 0
                mov     al, es:[bp+0]   ; [es:bp+DPB.DRIVE]
                call    GETCURHEAD

_bufq:                                  ; ...
                cmp     al, [di+4]      ; [di+BUFFINFO.buf_ID] ; Same drive?
                jnz     short bufq5     ; no
                cmp     bx, [di+8]      ; [di+BUFFINFO.buf_sector+2]
                jnz     short bufq04
                cmp     dx, [di+6]      ; [di+BUFFINFO.buf_sector]

bufq04:                                 ; ...
                ja      short bufq5
                cmp     si, [di+8]
                jnz     short bufq05
                cmp     cx, [di+6]

bufq05:                                 ; ...
                jbe     short bufq5
                test    byte ptr [di+5], 40h ; [di+BUFFINFO.buf_flags],buf_dirty
                jz      short bufq4
                call    DEC_DIRTY_COUNT

bufq4:                                  ; ...
                mov     word ptr [di+4], 20FFh ; [di+BUFFINFO.buf_ID],
                                        ; ((buf_visit<<8)|0FFh)
                call    SCANPLACE
                jmp     short bufq6
; ---------------------------------------------------------------------------

bufq5:                                  ; ...
                mov     di, [di]        ; [di+BUFFINFO.buf_next]

bufq6:                                  ; ...
                cmp     di, ss:FIRST_BUFF_ADDR
                jnz     short _bufq     ; go do next buffer.
                pop     cx
                pop     bx
                retn
DskWrtBufPurge  endp


; =============== S U B R O U T I N E =======================================


DIV32           proc near               ; ...
                cmp     bx, 512
                jnz     short div5
                mov     cx, dx
                mov     dx, ax          ; CX:AX = Dividend
                and     dx, 1FFh        ; DX = Remainder
                mov     al, ah
                mov     ah, cl
                mov     cl, ch
                xor     ch, ch
                shr     cx, 1
                rcr     ax, 1
                retn
; ---------------------------------------------------------------------------

div5:                                   ; ...
                mov     cx, ax
                mov     ax, dx
                xor     dx, dx
                div     bx              ; 0:AX/BX
                xchg    ax, cx
                div     bx              ; DX:AX/BX
                retn
DIV32           endp


; =============== S U B R O U T I N E =======================================


SHR32           proc near               ; ...
                mov     cl, es:[bp+5]   ; [ES:BP+DPB.CLUSTER_SHIFT]
                xor     ch, ch          ; ZF=1
                jcxz    short norota

rotashft2:                              ; ...
                shr     dx, 1           ; ZF reflects state of DX.
                rcr     ax, 1           ; ZF not affected.
                loop    rotashft2

norota:                                 ; ...
                retn
SHR32           endp


; =============== S U B R O U T I N E =======================================


FINDENTRY       proc near               ; ...
                call    STARTSRCH
                mov     al, ds:ATTRIB
                and     al, 9Eh         ; ~attr_ignore
                cmp     al, 8           ; attr_volume_id
                jnz     short NOTVOLSRCH
                call    SETROOTSRCH

NOTVOLSRCH:                             ; ...
                call    GETENTRY
                jnb     short SRCH
                jb      short SETESRET_j

SRCH:                                   ; ...
                mov     ds:LNE_COUNT, 0 ; reset long name entry count

SRCH2:                                  ; ...
                push    ds
                mov     ds, word ptr ds:CURBUF+2
                mov     ah, [bx]        ; [BX+dir_entry.dir_name]
                or      ah, ah
                jz      short FREE
                push    ax
                mov     al, [bx+0Bh]    ; [BX+dir_entry.dir_attr]
                call    check_longname
                pop     ax
                jz      short NEXTENT2
                cmp     ah, ss:DELALL
                jz      short FREE
                test    byte ptr [bx+0Bh], 8 ; [BX+dir_entry.dir_attr],
                                        ; attr_volume_id
                jz      short CHKFNAM
                inc     ss:VOLID

CHKFNAM:                                ; ...
                mov     si, ss
                mov     es, si
                mov     si, bx
                mov     di, offset NAME1
                cmp     ss:NAME1, 0E5h
                jnz     short NO_E5
                mov     ss:NAME1, 5

NO_E5:                                  ; ...
                call    MetaCompare
                jz      short FOUND
                pop     ds
FINDENTRY       endp


; =============== S U B R O U T I N E =======================================


NEXTENT         proc near               ; ...
                les     bp, ds:THISDPB
                call    NEXTENTRY
                jnb     short SRCH

SETESRET_j:                             ; ...
                jmp     short SETESRET
; ---------------------------------------------------------------------------

NEXTENT2:                               ; ...
                pop     ds
                inc     ds:LNE_COUNT    ; Long Name entry count

NEXTENT3:                               ; ...
                les     bp, ds:THISDPB
                call    NEXTENTRY
                jnb     short SRCH2
                jmp     short SETESRET
; ---------------------------------------------------------------------------

FREE:                                   ; ...
                pop     ds
                mov     cx, ds:LASTENT
                cmp     cx, ds:ENTFREE
                jnb     short TSTALL
                mov     ds:ENTFREE, cx

TSTALL:                                 ; ...
                cmp     ah, ds:DELALL
                jz      short NEXTENT3
                mov     ds:ENTLAST, cx
                stc
                jmp     short SETESRET
; ---------------------------------------------------------------------------

FOUND:                                  ; ...
                mov     ch, [si]
                pop     ds
                mov     ah, ds:ATTRIB
                and     ah, 9Eh         ; ~attr_ignore
                lea     si, [si+0Fh]    ; [SI+dir_entry.dir_first-dir_entry.dir_attr]
                test    ch, 8           ; attr_volume_id
                jz      short check_one_volume_id
                test    ah, 8           ; attr_volume_id
                jz      short NEXTENT
                xor     ah, ah
                jmp     short RETFF
; ---------------------------------------------------------------------------

check_one_volume_id:                    ; ...
                cmp     ah, 8           ; attr_volume_id
                jz      short NEXTENT
                call    MatchAttributes
                jz      short RETFF
                test    ds:CREATING, 0FFh ; -1
                jz      short NEXTENT

RETFF:                                  ; ...
                les     bp, ds:THISDPB
                mov     ah, es:[bp+0]   ; [ES:BP+DPB.DRIVE]

SETESRET:                               ; ...
                push    ss
                pop     es
                push    ds:ENTLAST
                pop     ds:ENTLAST_PREV ; previous ENTLAST
                jnb     short SETESRETN
                mov     ds:LNE_COUNT, 0 ; reset long name entry count

SETESRETN:                              ; ...
                retn
NEXTENT         endp


; =============== S U B R O U T I N E =======================================


MetaCompare     proc near               ; ...
                mov     cx, 11

WILDCRD:                                ; ...
                repe cmpsb
                jz      short MetaRet
                cmp     byte ptr es:[di-1], 3Fh ; '?'
                jz      short WILDCRD

MetaRet:                                ; ...
                retn                    ; Zero set, Match
MetaCompare     endp


; =============== S U B R O U T I N E =======================================


NEXTENTRY       proc near               ; ...
                mov     ax, ds:LASTENT
                cmp     ax, ds:ENTLAST
                jz      short NONE
                inc     ax
                lea     bx, [bx+32]
                cmp     bx, dx
                jnz     short HAVIT
                cmp     ds:DIRSTART, 0
                jnz     short nextentry_cont
                cmp     ds:DIRSTART_HW, 0
                jnz     short nextentry_cont
                cmp     ax, es:[bp+9]   ; [es:bp+DPB.ROOT_ENTRIES]
                                        ; Number of root directory entries
                jnb     short NONE
                jmp     short GETENT
; ---------------------------------------------------------------------------

nextentry_cont:                         ; ...
                mov     bl, ds:SECCLUSPOS
                inc     bl
                cmp     bl, ds:CLUSFAC
                jb      short SAMECLUS
                mov     bx, ds:NXTCLUSNUM_HW
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, ds:NXTCLUSNUM
                call    IsEOF
                jnb     short NONE
                cmp     ds:CLUSTNUM_HW, 0
                jnz     short GETENT
                cmp     bx, 2
                jnb     short GETENT

NONE:                                   ; ...
                stc
                retn
; ---------------------------------------------------------------------------

HAVIT:                                  ; ...
                mov     ds:LASTENT, ax
                clc

nextentry_retn:                         ; ...
                retn
; ---------------------------------------------------------------------------

SAMECLUS:                               ; ...
                mov     ds:SECCLUSPOS, bl
                mov     ds:LASTENT, ax
                push    ds
                lds     di, ds:CURBUF
                lds     dx, [di+6]      ; [DI+BUFFINFO.buf_sector]
                mov     ss:HIGH_SECTOR, ds
                add     dx, 1
                adc     ss:HIGH_SECTOR, 0
                pop     ds
                call    FIRSTCLUSTER
                xor     bx, bx
                jmp     short SETENTRY
NEXTENTRY       endp


; =============== S U B R O U T I N E =======================================


GETENTRY        proc near               ; ...
                mov     ax, ds:LASTENT

GETENT:                                 ; ...
                mov     ds:LASTENT, ax
                mov     cl, 5
                rol     ax, cl
                mov     dx, ax
                and     ax, 0FFE0h      ; ~(32-1)
                and     dx, 1Fh
                mov     bx, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE]
                and     bl, 0E0h        ; Must be multiple of 32
                div     bx
                mov     bx, dx          ; Position within sector
                                        ; NOTE: This BX value is not used in DIRREAD
                                        ; Erdogan Tan - 14/02/2024
                push    dx
                call    DIRREAD
                pop     bx
                jb      short nextentry_retn

SETENTRY:                               ; ...
                mov     dx, word ptr ds:CURBUF
                add     dx, 24          ; BUFINSIZ
                add     bx, dx
                add     dx, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE]
                clc
                retn
GETENTRY        endp

; ---------------------------------------------------------------------------
sft_fcb_table   db 20 dup(0)            ; ...
sftfcb_cluster  dw 2 dup(0)             ; ...
sftfcb_direntry dw 0                    ; ...
                db 114 dup(0)           ; 6*20 = 120 ; entry size = 6 bytes
SRCH_CLUSTER    dw 0                    ; ...
SRCH_CLUSTER_HW dw 0                    ; ...

; =============== S U B R O U T I N E =======================================


SETDIRSRCH      proc near               ; ...
                cmp     ds:ROOTCLUST_HW, 0
                jnz     short SETDIRSRCH_FAT32
                or      bx, bx
                jz      short SETROOTSRCH

SETDIRSRCH_FAT32:                       ; ...
                mov     ax, ds:ROOTCLUST_HW
                mov     ds:DIRSTART_HW, ax
                mov     ds:CLUSTNUM_HW, ax
                mov     ds:DIRSTART, bx
                mov     al, es:[bp+4]   ; [ES:BP+DPB.CLUSTER_MASK]
                inc     al
                mov     ds:CLUSFAC, al
                push    si
                test    ds:FastOpenFlg, 2 ; [FastOpenFlg],Lookup_Success
                jnz     short UNP_OK
                call    UNPACK
                jnb     short UNP_OK
                pop     si
                retn
; ---------------------------------------------------------------------------

UNP_OK:                                 ; ...
                mov     ds:CLUSNUM, di  ; CCONTENT_HW:DI = Contents of FAT
                                        ; for given cluster (from UNPACK)
                mov     dx, ds:CCONTENT_HW
                mov     ds:CLUSNUM_HW, dx
                mov     cs:SRCH_CLUSTER, bx ; Directory start cluster number
                                        ; for searching/locating (directory entry)
                mov     dx, ds:CLUSTNUM_HW
                mov     cs:SRCH_CLUSTER_HW, dx
                mov     dx, bx
                xor     bl, bl
                mov     ds:SECCLUSPOS, bl ;
                                        ; CLUSTNUM_HW:DX = Physical cluster number
                call    FIGREC
                mov     si, ds:HIGH_SECTOR
                mov     ds:DIRSEC+2, si
                mov     ds:DIRSEC, dx
                pop     si
                clc
                retn
SETDIRSRCH      endp


; =============== S U B R O U T I N E =======================================


SETROOTSRCH     proc near               ; ...
                mov     ds:ROOTCLUST_HW, 0
                cmp     word ptr es:[bp+0Fh], 0 ; DPB.FAT_SIZE
                jnz     short SETROOTSRCH_FAT ; not FAT32

SETROOTSRCH_FAT32:                      ;
                mov     bx, es:[bp+37h] ; DPB.ROOT_CLUSTER+2
                mov     ds:ROOTCLUST_HW, bx
                cmp     bx, es:[bp+2Fh] ; DPB.LAST_CLUSTER+2
                mov     bx, es:[bp+35h] ; DPB.ROOT_CLUSTER
                jnz     short sdsrch_fat32_1
                cmp     bx, es:[bp+2Dh] ; DPB.LAST_CLUSTER

sdsrch_fat32_1:                         ; ...
                ja      short sdsrch_fat32_3
                cmp     ds:ROOTCLUST_HW, 0
                jnz     short sdsrch_fat32_2
                cmp     bx, 2
                jb      short sdsrch_fat32_3

sdsrch_fat32_2:                         ; ...
                jmp     SETDIRSRCH_FAT32
; ---------------------------------------------------------------------------

sdsrch_fat32_3:                         ; ...
                stc
                jmp     short setdirsrch_retn
; ---------------------------------------------------------------------------

SETROOTSRCH_FAT:                        ; ...
                xor     ax, ax
                mov     ds:DIRSEC+2, ax
                mov     ds:DIRSTART, ax
                mov     ds:DIRSTART_HW, ax
                mov     cs:SRCH_CLUSTER_HW, ax ; search start dir cluster num = 1
                                        ; (root directory)
                inc     ax
                mov     cs:SRCH_CLUSTER, ax ; 1 ; FAT root directory (<2)
                dec     ax              ; 0
                mov     ds:SECCLUSPOS, al
                dec     ax              ; -1
                mov     ds:CLUSNUM, ax
                mov     ds:CLUSNUM_HW, ax
                mov     ax, es:[bp+0Bh] ; [ES:BP+DPB.FIRST_SECTOR]
                mov     dx, es:[bp+11h] ; [ES:BP+DPB.DIR_SECTOR]
                sub     ax, dx
                mov     ds:CLUSFAC, al
                mov     ds:DIRSEC, dx
                clc

setdirsrch_retn:                        ; ...
                retn
SETROOTSRCH     endp


; =============== S U B R O U T I N E =======================================


set_sftfcb_entry proc near              ; ...
                push    ax              ; set SFT number and entry
                                        ; in the new internal table
                                        ; (only for FCB calls)
                push    cx
                push    dx
                push    bx
                push    bp
                push    si
                push    di              ; ES:DI = SFT entry
                call    find_sft_entry_number ;
                                        ; ax = SFT entry index number
                                        ;      of the last SFT entry
                xor     bx, bx
                mov     cx, 20          ; find empty entry (slot) in the table

set_sftfcbe_1:                          ; ...
                cmp     cs:(sftfcb_cluster+2)[bx], 0 ; [cs:bx+sftfcb.cluster+2]
                                        ; directory (search) starting cluster, hw
                jnz     short set_sftfcbe_2
                cmp     cs:sftfcb_cluster[bx], 0 ; [cs:bx+sftfcb.cluster]
                                        ; directory (search) starting cluster, lw

set_sftfcbe_2:                          ; ...
                jnz     short set_sftfcbe_3 ; not empty (sfcb table) entry
                push    cx
                mov     cx, cs:SRCH_CLUSTER ; search start dir cluster number
                mov     cs:sftfcb_cluster[bx], cx ; directory start cluster
                mov     cx, cs:SRCH_CLUSTER_HW
                mov     cs:sftfcb_cluster[bx], cx ; PCDOS 7.1 BUG! (This would be
                                        ; 'cs:sftfcb_cluster+2[bx],cx')
                                        ; Erdogan Tan - 23/01/2024
                pop     cx
                mov     dx, ss:LASTENT  ; LAST (found) entry in the directory
                mov     cs:sftfcb_direntry[bx], dx ; [cs:bx+sftfcb.direntry]
                                        ; directory entry number
                xchg    ax, bx
                xor     dx, dx
                mov     cx, 6           ; sftfcb table has 6 byte entries
                div     cx
                xchg    ax, bx
                mov     cs:sft_fcb_table[bx], al ; put SFT entry number in SFT-FCB
                                        ; table (offset is FCB index number 0 to 19)
                jmp     short set_setfcbe_4
; ---------------------------------------------------------------------------

set_sftfcbe_3:                          ; ...
                add     bx, 6
                loop    set_sftfcbe_1

set_setfcbe_4:                          ; ...
                pop     di
                pop     si
                pop     bp
                pop     bx
                pop     dx
                pop     cx
                pop     ax
                retn
set_sftfcb_entry endp


; =============== S U B R O U T I N E =======================================


find_sft_entry_number proc near         ; ...
                push    es              ; es:di = SFT entry
                xor     cx, cx
                mov     dx, es
                mov     es, cs:DosDSeg
                les     bx, es:SFT_ADDR ; address of the first SFT

f_sfte_1:                               ; ...
                mov     ax, es
                cmp     ax, dx          ; same SFT segment ?
                jnz     short f_sfte_2  ; no
                mov     ax, di
                sub     ax, bx          ; ax = entry offset
                sub     ax, 6           ; ax = offset from start of the SFT table
                                        ; SFT.SFTable
                mov     bx, 59          ; SF_ENTRY.size (SFT entry size)
                xor     dx, dx
                div     bx              ; ax = SFT entry index in the table
                add     ax, cx          ; ax = SFT index number (for requested SFT entry)
                pop     es
                retn
; ---------------------------------------------------------------------------

f_sfte_2:                               ; ...
                add     cx, es:[bx+4]   ; SFT.SFCount ; number of entries in the table
                les     bx, es:[bx]     ; SFT.SFLink
                cmp     bx, 0FFFFh      ; the last SFT
                jnz     short f_sfte_1
                stc                     ; (not found)
                pop     es
                retn
find_sft_entry_number endp


; =============== S U B R O U T I N E =======================================


int_2Fh_1230h   proc near               ; ...
                call    find_sft_entry_number ; Windows95 - FIND SFT ENTRY IN INTERNAL FILE TABLES
                jb      short find_sfte_i_error
                push    es              ; ax = SFT enty index number (of the requested SFT entry)
                push    di
                push    cs
                pop     es
                assume es:DOSCODE
                mov     cx, 20          ; statically allocated with 20 entries,
                                        ; and used only for FCB calls
                mov     di, offset sft_fcb_table ; new file system (internal) table
                                        ;  only for fcb calls

scan_next_sftfcb:                       ; ...
                repne scasb
                stc
                jnz     short sfte_i_notfound ; not found (cf=1)
                lea     bx, [di-1]      ; offset of the entry in the table
                sub     bx, offset sft_fcb_table ;
                                        ; index into new file system table
                mov     dx, bx
                add     bx, bx          ; 2*bx
                add     bx, dx          ; 3*bx
                add     bx, bx          ; bx = 6*bx  ; entry size = 6 bytes
                mov     si, es:(sftfcb_cluster+2)[bx] ; dir start cluster number, hw
                mov     dx, es:sftfcb_direntry[bx] ; directory entry number
                push    cx
                mov     cx, es:sftfcb_cluster[bx] ; dir start cluster number, lw
                or      cx, cx
                jnz     short sfte_i_found
                or      si, si
                jnz     short sfte_i_found
                pop     cx
                or      cx, cx
                jnz     short scan_next_sftfcb
                stc                     ; not found (cf=1)
                jmp     short sfte_i_notfound
; ---------------------------------------------------------------------------

sfte_i_found:                           ; ...
                pop     ax              ; clear stack
                clc                     ; found (cf=0)

sfte_i_notfound:                        ; ...
                pop     di
                pop     es
                assume es:nothing

find_sfte_i_error:                      ; ...
                mov     ax, 0
                retn
int_2Fh_1230h   endp


; =============== S U B R O U T I N E =======================================


SFT_FREE        proc near               ; ...
                push    ax
                push    cx
                push    dx
                push    bx
                push    bp
                push    si
                push    di
                mov     word ptr es:[di], 0 ; [ES:DI+SF_ENTRY.sf_ref_Count]
                call    int_2Fh_1230h
                jb      short sftf_1
                mov     cs:(sftfcb_cluster+2)[bx], 0 ; clear directory start cluster
                                        ;  in the new (sftfcb) table
                mov     cs:sftfcb_cluster[bx], 0 ; ((empty entry))

sftf_1:                                 ; ...
                pop     di
                pop     si
                pop     bp
                pop     bx
                pop     dx
                pop     cx
                pop     ax
                retn
SFT_FREE        endp


; =============== S U B R O U T I N E =======================================


check_longname  proc near               ; ...
                and     al, 0Fh
                cmp     al, 0Fh
                retn
check_longname  endp


; =============== S U B R O U T I N E =======================================


GETPATH         proc near               ; ...
                mov     word ptr ds:CREATING, 0E500h ; DIRFREE*256+0
GETPATH         endp                    ; Not Creating, not DEL *.*


; =============== S U B R O U T I N E =======================================


GetPathNoSet    proc near               ; ...

; FUNCTION CHUNK AT 8C9D SIZE 000001B6 BYTES

                call    set_exerr_locus_disk
                mov     word ptr ds:CURBUF, 0FFFFh ; -1 ; initial setting
                mov     di, ds:WFP_START ; point to the beginning of the name
                cmp     word ptr [di+1], 5C3Ah ; ':\'
                jz      short CrackIt
                add     di, 3
                mov     si, di          ; not required ! (15/02/2024)
                                        ; (it is written in CHKDEV proc already!)
                call    CHKDEV
                jb      short InternalError

Build_devJ:                             ; ...
                mov     al, ds:SATTRIB
                mov     ds:ATTRIB, al
                call    set_exerr_locus_unk
                push    ss
                pop     es
                mov     si, offset NAME1
                mov     di, ds:WFP_START
                mov     dx, di
                mov     cx, 8           ; 8 chars in device name

MoveLoop:                               ; ...
                lodsb
                stosb
                cmp     al, 20h ; ' '
                jz      short NoSave
                mov     dx, di

NoSave:                                 ; ...
                loop    MoveLoop
                mov     di, dx
                mov     [di], cl        ; 0 ; end of string
                call    Build_device_ent ; Clears carry sets zero
                inc     al              ; reset zero
                retn
; ---------------------------------------------------------------------------

InternalError:                          ; ...
                jmp     short InternalError
; ---------------------------------------------------------------------------

CrackIt:                                ; ...
                mov     ds:ATTRIB, 16h  ; attr_directory+attr_system+attr_hidden
                les     di, ds:THISCDS
                mov     ax, 0FFFFh
                mov     bx, es:[di+4Bh] ; [ES:DI+curdir.ID+2]
                mov     ds:ROOTCLUST_HW, bx
                mov     bx, es:[di+49h] ; [ES:DI+curdir.ID]
                mov     si, ds:CURR_DIR_END
                cmp     si, ax          ; if Current directory is not part
                jz      short NO_CURR_D ; then we must crack from root
                cmp     ds:ROOTCLUST_HW, ax
                jnz     short CrackIt2
                cmp     bx, ax          ; is the current directory cluster valid

CrackIt2:                               ; ...
                jz      short NO_CURR_D ; no, crack from the root
                test    ds:FastOpenFlg, 1
                jz      short GOT_SEARCH_CLUSTER
                push    es
                push    di
                push    cx
                push    word ptr [si-1]
                push    si
                push    bx
                push    ds:ROOTCLUST_HW
                mov     byte ptr [si-1], 0
                mov     si, ds:WFP_START
                mov     bx, offset FastOpenTable
                mov     di, offset Dir_Info_Buff
                mov     cx, offset FastOpen_Ext_Info
                mov     al, 1           ; FONC_Look_up
                push    ds
                pop     es
                call    dword ptr [bx+2] ; call far [BX+fastopen_entry.name_caching]
                jb      short GO_Chk_end1
                cmp     byte ptr [si], 0
                jz      short GO_Chk_end
                stc
                jmp     short GO_Chk_end
; ---------------------------------------------------------------------------

GO_Chk_end1:                            ; ...
                clc

GO_Chk_end:                             ; ...
                pop     ds:ROOTCLUST_HW
                pop     bx
                pop     si
                pop     word ptr [si-1]
                pop     cx
                pop     di
                pop     es
                jnb     short GOT_SEARCH_CLUSTER ; crack based on cur dir

NO_CURR_D:                              ; ...
                mov     si, ds:WFP_START
                add     si, 3
                les     bp, ds:THISDPB
                jmp     short ROOTPATH
; ---------------------------------------------------------------------------

GOT_SEARCH_CLUSTER:                     ; ...
                les     bp, ds:THISDPB
                call    SETDIRSRCH
                jnb     short FINDPATH
                xor     cl, cl          ; set zero
                stc
                retn
GetPathNoSet    endp


; =============== S U B R O U T I N E =======================================


CHKDEV          proc near               ; ...
                mov     si, di
                push    ss
                pop     es
                mov     di, offset NAME1
                mov     cx, 9

TESTLOOP:                               ; ...
                call    GETLET
                cmp     al, 2Eh ; '.'
                jz      short TESTDEVICE
                call    PATHCHRCMP
                jz      short NOTDEV
                or      al, al
                jz      short TESTDEVICE
                stosb
                loop    TESTLOOP

NOTDEV:                                 ; ...
                stc
                retn
; ---------------------------------------------------------------------------

TESTDEVICE:                             ; ...
                inc     cx
                inc     cx
                mov     al, 20h ; ' '
                rep stosb
                push    ss
                pop     ds
                call    DEVNAME
                retn
CHKDEV          endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR GetPathNoSet

ROOTPATH:                               ; ...
                call    SETROOTSRCH
                cmp     byte ptr [si], 0
                jnz     short FINDPATH
                mov     al, ds:SATTRIB
                mov     ds:ATTRIB, al
                xor     ah, ah
                retn
; ---------------------------------------------------------------------------

FINDPATH:                               ; ...
                push    es
                push    si
                mov     di, si
                mov     cx, ds:DIRSTART ; Get start clus of dir being searched
                cmp     ds:CURR_DIR_END, 0FFFFh ; -1
                jz      short NOIDS     ; No current dir part
                cmp     di, ds:CURR_DIR_END
                jnz     short NOIDS     ; Not to current dir end yet
                les     di, ds:THISCDS
                mov     ax, ds:DIRSTART_HW
                mov     es:[di+4Bh], ax ; [ES:DI+curdir.ID+2]
                                        ; Set current directory cluster
                mov     es:[di+49h], cx ; [ES:DI+curdir.ID]

NOIDS:                                  ; ...
                push    ss
                pop     es
                mov     di, offset NAME1
                mov     ax, 2020h
                stosb
                stosw
                stosw
                stosw
                stosw
                stosw
                mov     di, offset NAME1
                xor     ah, ah

GetNam:                                 ; ...
                inc     cl              ; not required ! (15/02/2024)
                lodsb
                cmp     al, 2Eh ; '.'
                jz      short _SetExt
                or      al, al
                jz      short _GetDone
                cmp     al, 5Ch ; '\'
                jz      short _GetDone
                cmp     al, 3Fh ; '?'
                jnz     short StoNam
                or      ah, 1

StoNam:                                 ; ...
                stosb
                jmp     short GetNam
; ---------------------------------------------------------------------------

_SetExt:                                ; ...
                mov     di, (offset NAME1+8)

GetExt:                                 ; ...
                lodsb
                or      al, al
                jz      short _GetDone
                cmp     al, 5Ch ; '\'
                jz      short _GetDone
                cmp     al, 3Fh ; '?'
                jnz     short StoExt
                or      ah, 1

StoExt:                                 ; ...
                stosb
                jmp     short GetExt
; ---------------------------------------------------------------------------

_BADPATH_j:                             ; ...
                jmp     _BADPATH
; ---------------------------------------------------------------------------

_GetDone:                               ; ...
                dec     si
                mov     cl, ah          ; 0 or 1
                or      cl, 80h
                pop     di              ; Start of this element
                pop     es              ; Restore ES:BP
                cmp     si, di
                jz      short _BADPATH_j ; NUL parse (two delims most likely)

check_device:
                push    si
                mov     al, [si]
                or      al, al
                jnz     short NOT_LAST
                mov     bh, ds:SATTRIB
                mov     ds:ATTRIB, bh

NOT_LAST:                               ; ...
                push    es
                push    ss
                pop     es
                call    DEVNAME
                pop     es
                jb      short FindFile  ; Not a device
                or      al, al          ; Test next char again
                jnz     short FILEINPATH_j ; Device name in middle of path
                pop     si
                jmp     Build_devJ
; ---------------------------------------------------------------------------

BADPATHPOP_j:                           ; ...
                jmp     BADPATHPOP
; ---------------------------------------------------------------------------

FindFile:                               ; ...
                cmp     ds:NAME1, 0E5h
                jnz     short NOE5
                mov     ds:NAME1, 5

NOE5:                                   ; ...
                push    di              ; Start of this element
                push    es
                push    cx              ; CL return from NameTrans
                call    LookupPath      ; call fastopen to get dir entry
                jnb     short DIR_FOUND ; found dir entry
                call    FINDENTRY

DIR_FOUND:                              ; ...
                pop     cx
                pop     es
                pop     di
                jb      short BADPATHPOP_j
                lds     di, ds:CURBUF
                test    byte ptr [bx+0Bh], 10h ; [BX+dir_entry.dir_attr],attr_directory
                jnz     short GO_NEXT

FILEINPATH_j:                           ; ...
                jmp     FILEINPATH      ; Error or end of path
; ---------------------------------------------------------------------------

GO_NEXT:                                ; ...
                cmp     ss:NoSetDir, 0
                jz      short SetDir
                mov     dx, di          ; Save pointer to entry
                mov     cx, ds
                push    ss
                pop     ds
                pop     di
                test    ds:FastOpenFlg, 1 ; FastOpen_Set
                jz      short _nofast
                test    ds:FastOpenFlg, 2 ; Lookup_Success
                jz      short _nofast
                mov     di, ds:Next_Element_Start ; no need to insert it again

_nofast:                                ; ...
                cmp     byte ptr [di], 0
                jnz     short NEXT_ONE
                jmp     _SETRET
; ---------------------------------------------------------------------------

NEXT_ONE:                               ; ...
                push    di
                mov     di, dx
                mov     ds, cx

SetDir:                                 ; ...
                xor     dx, dx
                cmp     es:[bp+0Fh], dx ; cmp [es:bp+DPB.FAT_SIZE],0
                jnz     short SetDir2
                mov     dx, [si-6]      ; dir_entry.dir_fclus_hi

SetDir2:                                ; ...
                mov     ss:ROOTCLUST_HW, dx ; 0
                mov     dx, [si]        ; dir_entry.dir_first
                push    ds
                push    ss
                pop     ds
                test    ds:FastOpenFlg, 2 ; Lookup_Success
                jz      short DO_NORMAL ; fastopen not in memory
                                        ;  or path not not found
                mov     bx, dx
                mov     di, ds:CLUSNUM  ; clusnum was set in LookupPath
                push    ax              ; save device id (AH)
                call    SETDIRSRCH
                pop     ax              ; restore device id (AH)
                add     sp, 2           ; pop ds in stack
                jmp     short FAST_OPEN_SKIP
; ---------------------------------------------------------------------------

DO_NORMAL:                              ; ...
                pop     ds              ; DS = [curbuf + 2]
                sub     bx, di          ; Offset into sector of start of entry
                sub     si, di          ; Offset into sector of dir_first
                push    bx
                push    ax
                push    si
                push    cx
                lds     bx, [di+6]      ; [DI+BUFFINFO.buf_sector]
                push    bx
                push    ds
                mov     bx, dx
                push    ss
                pop     ds
                call    SETDIRSRCH
                pop     ds:HIGH_SECTOR
                pop     dx
                jb      short SKIP_GETB
                mov     ds:ALLOWED, 18h ; Allowed_RETRY+Allowed_FAIL
                xor     al, al
                call    GETBUFFR        ; Get the entry buffer back

SKIP_GETB:                              ; ...
                pop     cx
                pop     si
                pop     ax
                pop     bx
                jnb     short SET_THE_BUF
                pop     di              ; Start of next element
                mov     si, di          ; Point with SI
                jmp     short _BADPATH
; ---------------------------------------------------------------------------

SET_THE_BUF:                            ; ...
                call    SET_BUF_AS_DIR
                mov     di, word ptr ds:CURBUF
                add     si, di          ; Get the offsets back
                add     bx, di

FAST_OPEN_SKIP:                         ; ...
                pop     di              ; Start of next element
                call    InsertPath      ; insert dir entry info
                mov     al, [di]
                or      al, al
                jz      short _SETRET   ; At end
                inc     di              ; Skip over "/"
                mov     si, di          ; Point with SI
                call    PATHCHRCMP
                jnz     short find_bad_name ; oops
                jmp     FINDPATH        ; Next element
; ---------------------------------------------------------------------------

find_bad_name:                          ; ...
                dec     si              ; Undo above INC to get failure point

_BADPATH:                               ; ...
                xor     cl, cl          ; Set zero
                jmp     short BADPRET
; ---------------------------------------------------------------------------

FILEINPATH:                             ; ...
                pop     di              ; Start of next element
                push    ss
                pop     ds
                test    ds:FastOpenFlg, 1 ; FastOpen_Set
                jz      short NO_FAST
                test    ds:FastOpenFlg, 2 ; Lookup_Success
                jz      short NO_FAST
                mov     di, ds:Next_Element_Start

NO_FAST:                                ; ...
                mov     al, [di]
                or      al, al
                jnz     short NO_FAST2
                call    InsertPath      ; insert dir entry info
                inc     al              ; Reset zero

_SETRET:                                ; ...
                retn
; ---------------------------------------------------------------------------

NO_FAST2:                               ; ...
                mov     si, di          ; Path too long
                jmp     short BADPRET
; ---------------------------------------------------------------------------

BADPATHPOP:                             ; ...
                pop     si              ; Start of next element
                mov     al, [si]
                mov     si, di          ; Start of bad element
                or      al, al          ; zero if bad element is last,
                                        ; non-zero if path too long

BADPRET:                                ; ...
                mov     al, ds:SATTRIB
                mov     ds:ATTRIB, al   ; Make sure return correct
                stc
                retn
; END OF FUNCTION CHUNK FOR GetPathNoSet

; =============== S U B R O U T I N E =======================================


STARTSRCH       proc near               ; ...
                les     bp, ds:THISDPB
                xor     ax, ax
                mov     ds:LASTENT, ax
                mov     ds:VOLID, al    ; No volume ID found
                dec     ax
                mov     ds:ENTFREE, ax
                mov     ds:ENTLAST, ax
                retn
STARTSRCH       endp


; =============== S U B R O U T I N E =======================================


MatchAttributes proc near               ; ...
                push    ax
                mov     al, ss:ATTRIB
                not     al
                and     al, ch
                and     al, 16h         ; attr_all
                pop     ax
                retn
MatchAttributes endp


; =============== S U B R O U T I N E =======================================


DEVNAME         proc near               ; ...
                push    si
                push    di
                push    cx
                push    ax
                push    word ptr ds:NAME1
                cmp     ds:NAME1, 5
                jnz     short NOKTR
                mov     ds:NAME1, 0E5h

NOKTR:                                  ; ...
                test    ds:ATTRIB, 8    ; attr_volume_id
                jnz     short RET31
                mov     si, offset NULDEV

LOOKIO:                                 ; ...
                test    word ptr [si+4], 8000h ; [SI+SYSDEV.ATT],DEVTYP
                jz      short SKIPDEV   ; Skip block devices (NET and LOCAL)
                mov     ax, si
                add     si, 10          ; SYSDEV.NAME
                mov     di, offset NAME1
                mov     cx, 4           ; All devices are 8 letters
                repe cmpsw              ; Check for name in list
                xchg    ax, si
                jz      short IOCHK     ; Found it?

SKIPDEV:                                ; ...
                lds     si, [si]        ; Get address of next device
                cmp     si, 0FFFFh      ; -1 ; At end of list?
                jnz     short LOOKIO

RET31:                                  ; ...
                stc                     ; Not found

RETNV:                                  ; ...
                mov     cx, ss
                mov     ds, cx
                pop     word ptr ds:NAME1
                pop     ax
                pop     cx
                pop     di
                pop     si
                retn
; ---------------------------------------------------------------------------

IOCHK:                                  ; ...
                mov     word ptr ss:DEVPT+2, ds ; Save pointer to device
                mov     bh, [si+4]      ; [SI+SYSDEV.ATT]
                or      bh, 0C0h
                and     bh, 0DFh        ; ~(020h)
                mov     word ptr ss:DEVPT, si
                jmp     short RETNV
DEVNAME         endp


; =============== S U B R O U T I N E =======================================


Build_device_ent proc near              ; ...
                mov     ax, 2020h
                mov     di, (offset NAME1+8) ; DEVFCB+8 ; Point to extent field
                stosw
                stosb                   ; Blank out extent field
                mov     al, 40h         ; attr_device
                stosb                   ; Set attribute field
                xor     ax, ax
                mov     cx, 10
                rep stosw
                call    DATE16
                mov     di, (offset NAME2+0Ah) ; DEVFCB+dir_entry.dir_time
                xchg    ax, dx
                stosw
                xchg    ax, dx
                stosw
                mov     si, di          ; SI points to dir_first field
                mov     ax, word ptr ds:DEVPT
                stosw                   ; Dir_first points to device
                mov     ax, word ptr ds:DEVPT+2
                stosw
                mov     ah, bh          ; Put device atts in AH
                mov     bx, offset NAME1 ; DEVFCB
                xor     al, al          ; Set zero, clear carry
                retn
Build_device_ent endp


; =============== S U B R O U T I N E =======================================

; Attributes: bp-based frame

ValidateCDS     proc near               ; ...

SaveCDS         = dword ptr -6
Temp            = word ptr -2

                push    bp
                mov     bp, sp
                sub     sp, 6
                mov     [bp+Temp], di
                lds     si, ss:THISCDS
                mov     word ptr [bp+SaveCDS], si
                mov     word ptr [bp+SaveCDS+2], ds
                call    ECritDisk
                test    word ptr [si+43h], 8000h ; [SI+curdir.flags],curdir_isnet
                jz      short _DoSplice
                jmp     FatFail
; ---------------------------------------------------------------------------

_DoSplice:                              ; ...
                xor     dl, dl
                xchg    dl, ss:NoSetDir
                push    ss
                pop     es
                call    FStrCpy
                mov     si, [bp+Temp]
                push    ss
                pop     ds
                call    Splice
                push    ss              ; FatReadCDS (ThisCDS);
                pop     ds
                mov     ds:NoSetDir, dl
                les     di, ds:THISCDS
                push    bp
                call    FATREAD_CDS
                pop     bp
                jb      short FatFail
                lds     si, ds:THISCDS
                cmp     word ptr [si+4Bh], 0FFFFh ; if (ThisCDS->ID == -1) {
                jnz     short _DoSplice2
                cmp     word ptr [si+49h], 0FFFFh

_DoSplice2:                             ; ...
                jnz     short RestoreCDS
                push    ss
                pop     es
                push    ss:WFP_START
                cmp     si, word ptr [bp+SaveCDS]
                jnz     short DoChdir
                mov     di, [bp+Temp]
                mov     ss:WFP_START, di
                call    FStrCpy

DoChdir:                                ; ...
                push    ss
                pop     ds
                push    word ptr ds:SATTRIB
                push    bp
                call    DOS_CHDIR
                pop     bp
                pop     bx
                pop     ds:WFP_START
                mov     ds:SATTRIB, bl
                mov     di, ds:DIRSTART_HW
                lds     si, [bp+SaveCDS]
                jnb     short SetCluster
                mov     word ptr ss:THISCDS, si
                mov     word ptr ss:THISCDS+2, ds
                xor     cx, cx
                xor     di, di
                mov     [si+3], cl

SetCluster:                             ; ...
                lds     si, ss:THISCDS
                test    word ptr [si+43h], 2000h ; [SI+curdir.flags],curdir_splice
                jz      short _setdirclus
                mov     cx, 0FFFFh      ; -1
                mov     di, cx

_setdirclus:                            ; ...
                mov     ss:DIRSTART_HW, di
                mov     [si+4Bh], di    ; [SI+curdir.ID+2]
                mov     [si+49h], cx    ; [SI+curdir.ID]

RestoreCDS:                             ; ...
                les     di, [bp+SaveCDS]
                mov     word ptr ss:THISCDS, di
                mov     word ptr ss:THISCDS+2, es
                clc

FatFail:                                ; ...
                call    LCritDisk
                les     di, [bp+SaveCDS]
                mov     sp, bp
                pop     bp
                retn
ValidateCDS     endp


; =============== S U B R O U T I N E =======================================


CheckThisDevice proc near               ; ...
                push    di
                push    si
                mov     di, si
                mov     al, [si]
                call    PATHCHRCMP      ; is it a path char?
                jnz     short ParseDev  ; no, go attempt to parse device
                inc     si              ; simulate LODSB
                lodsw
                or      ax, 2020h
                cmp     ax, 6564h       ; cmp ax,'de' ; (NASM syntax)
                jnz     short NotDevice ; assume not device
                lodsb
                or      al, 20h
                cmp     al, 76h ; 'v'   ; cmp al,'v'
                jnz     short NotDevice ; assume not device
                lodsb
                call    PATHCHRCMP      ; do we have the last path separator?
                jnz     short NotDevice ; no. go for it.

ParseDev:                               ; ...
                push    ds
                push    si
                call    NameTrans
                cmp     byte ptr [si], 0 ; parse entire string?
                stc                     ; simulate a Carry return from DevName
                jnz     short SkipSearch ; no parse. simulate a file return.
                push    ss
                pop     ds
                mov     al, ds:SATTRIB
                mov     ds:ATTRIB, al   ; set Attrib for DevName
                call    DEVNAME

SkipSearch:                             ; ...
                pop     si
                pop     ds

CheckReturn:                            ; ...
                pop     di
                jnb     short Check_Done ; if device then do not reset pointer
                mov     si, di

Check_Done:                             ; ...
                pop     di
                cmc                     ; invert carry. Carry => device
                retn
; ---------------------------------------------------------------------------

NotDevice:                              ; ...
                stc
                jmp     short CheckReturn
CheckThisDevice endp


; =============== S U B R O U T I N E =======================================


LookupPath      proc near               ; ...
                test    ss:FastOpenFlg, 1 ; FastOpen_Set
                jnz     short FASTINST  ; flg is set in DOSOPEN

NOLOOK:                                 ; ...
                jmp     NOLOOKUP
; ---------------------------------------------------------------------------

FASTINST:                               ; ...
                test    ss:FastOpenFlg, 8 ; No_Lookup ; no more lookup?
                jnz     short NOLOOK    ; yes
                mov     bx, offset FastOpenTable
                mov     si, ss:WFP_START ; si points to path name
                mov     di, offset Dir_Info_Buff
                mov     cx, offset FastOpen_Ext_Info
                mov     al, 1           ; FONC_Look_up
                push    ds
                pop     es
                call    dword ptr [bx+2] ; call far [BX+fastopen_entry.name_caching]
                jnb     short FASTINST2
                jmp     NOTFOUND        ; fastopen not in memory
; ---------------------------------------------------------------------------

FASTINST2:                              ; ...
                lea     bx, [si-2]
                cmp     bx, ss:WFP_START ; path found ?
                jz      short NOTFOUND  ; no
                cmp     byte ptr [si], 0 ; partiallyfound
                jnz     short parfnd    ; is attribute matched ?
                push    cx
                mov     cl, ss:ATTRIB
                mov     ch, ss:SATTRIB
                mov     ss:ATTRIB, ch   ; attrib=sattrib
                mov     ch, es:[di+0Bh] ; [ES:DI+dir_entry.dir_attr]
                call    MatchAttributes
                pop     cx
                jnz     short NOLOOKUP  ; not matched
                cmp     ss:NoSetDir, 0
                jz      short parfnd
                cmp     byte ptr [si], 0
                jnz     short parfnd
                test    byte ptr es:[di+0Bh], 10h
                jz      short parfnd
                mov     bx, cx
                jmp     short parfnd2
; ---------------------------------------------------------------------------

parfnd:                                 ; ...
                mov     bx, cx
                mov     ax, [bx+0Bh]    ; [bx+FEI.dirstart]
                mov     ss:DIRSTART, ax
                mov     ax, [bx+7]      ; [bx+FEI.clusnum+2]
                mov     ss:CLUSNUM_HW, ax
                mov     ax, [bx+5]      ; [bx+FEI.clusnum]
                mov     ss:CLUSNUM, ax

parfnd2:                                ; ...
                mov     ss:Next_Element_Start, si
                mov     ax, [bx+9]      ; [bx+FEI.lastent]
                mov     ss:LASTENT, ax
                push    es
                les     bx, ss:THISDPB
                mov     ah, es:[bx]     ; [ES:BX+DPB.DRIVE]
                pop     es
                mov     word ptr ss:CURBUF, 0 ; indicate not root dir
                mov     word ptr ss:CURBUF+2, es ; [curbuf+2].bx points to
                mov     bx, di          ; start of entry
                lea     si, [di+1Ah]    ; [DI+dir_entry.dir_first]
                                        ; [curbuf+2]:si points to dir_first field
                or      ss:FastOpenFlg, 12h ; Lookup_Success+Set_For_Search
                retn
; ---------------------------------------------------------------------------

NOTFOUND:                               ; ...
                cmp     ax, 0FFFFh      ; -1  ; not in memory ?
                jnz     short Partial_Success ; yes, in memory
                mov     ss:FastOpenFlg, 0 ; no more fastopen

Partial_Success:                        ; ...
                and     ss:FastOpenFlg, 0FBh ; Special_Fill_Reset

NOLOOKUP:                               ; ...
                stc
                retn
LookupPath      endp


; =============== S U B R O U T I N E =======================================


InsertPath      proc near               ; ...
                pushf
                test    ss:FastOpenFlg, 1 ; FastOpen_Set
                                        ; only DOSOPEN can take advantage of
                jz      short GET_NEXT_ELEMENT ; the FastOpen
                test    ss:FastOpenFlg, 2 ; Lookup_Success ; Lookup just happened
                jz      short INSERT_DIR_INFO ; no
                and     ss:FastOpenFlg, 0FDh ; Lookup_Reset
                                        ; we got dir info from fastopen so
                mov     di, ss:Next_Element_Start ; no need to insert it again
                jmp     short GET_NEXT2
; ---------------------------------------------------------------------------

INSERT_DIR_INFO:                        ; ...
                push    ds
                push    es
                push    bx
                push    si
                push    di
                push    cx
                push    ax
                lds     di, ss:CURBUF
                mov     si, offset FastOpen_Ext_Info
                lds     ax, [di+6]      ; [DI+BUFFINFO.buf_sector]
                                        ; get directory sector
                mov     ss:[si+1], ax   ; [SS:SI+FEI.dirsec]
                mov     word ptr ss:[si+3], ds ; [SS:SI+FEI.dirsec+2]
                push    ss
                pop     ds
                mov     ax, ds:CLUSNUM_HW ; save next cluster number
                mov     [si+7], ax      ; [si+FEI.clusnum+2]
                mov     ax, ds:CLUSNUM
                mov     [si+5], ax      ; [si+FEI.clusnum]
                mov     ax, ds:LASTENT  ; save lastentry for search first
                mov     [si+9], ax      ; [si+FEI.lastent]
                mov     ax, ds:DIRSTART ; save  for search first
                mov     [si+0Bh], ax    ; [si+FEI.dirstart]
                mov     ax, bx
                add     di, 24          ; BUFINSIZ
                sub     ax, di          ; AX = relative to start of sector
                mov     cl, 32          ; dir_entry.size
                div     cl
                mov     [si], al        ; mov [si+FEI.dirpos],al
                                        ; save directory entry # in buffer
                push    ds
                pop     es
                mov     ds, word ptr ds:CURBUF+2
                mov     di, bx
                cmp     word ptr [di+1Ah], 0 ; [DI+dir_entry.dir_first]
                                        ; never insert info when file is empty
                jz      short SKIP_INSERT ; newly created file
                                        ;
                                        ; ; 21/02/2024 - Erdogan Tan
                                        ; ; Note: PCDOS 7.1 IBMDOS.COM code doesn't check high word
                                        ; ;   of the 1st cluster here
                                        ; ;;;
                                        ; ; 21/02/2024 - Retro DOS v5.0
                                        ; ;jnz    short dont_skip_insert
                                        ; ;;cmp   word [di+14h],0
                                        ; ;cmp    word [di+dir_entry.dir_fclus_hi],0
                                        ; ;jz short SKIP_INSERT
                                        ; ;dont_skip_insert:  ; Retro DOS v5.0
                                        ; ;;;
                push    si
                pop     bx
                mov     al, 2           ; FONC_insert
                                        ; call fastopen insert operation
                mov     si, offset FastOpenTable
                call    dword ptr es:[si+2] ; call far [ES:SI+fastopen_entry.name_caching]
                clc

SKIP_INSERT:                            ; ...
                pop     ax
                pop     cx
                pop     di
                pop     si
                pop     bx
                pop     es
                pop     ds

GET_NEXT2:                              ; ...
                or      ss:FastOpenFlg, 8 ; No_Lookup

GET_NEXT_ELEMENT:                       ; ...
                popf
                retn
InsertPath      endp

; ---------------------------------------------------------------------------
LenTab          db 22                   ; ...
                                        ; length of packets
                                        ; DRDWRHL
                db 14                   ; DRDNDHL
                db 22                   ; DRDWRHL
                db 13                   ; DSTATHL
                db 13                   ; DFLSHL
                                        ; (This was 15 in MSDOS 6.22 MSDOS.SYS & Win ME IO.SYS)
                db 14                   ; DRDNDHL
CmdTab          db 86h                  ; ...
                                        ; 0 input
                db 4                    ; DEVRD ; Read
                db 86h                  ; 1 input status
                db 5                    ; DEVRDND
                db 87h                  ; 2 output
                db 8                    ; DEVWRT ; Write
                db 87h                  ; 3 output status
                db 10                   ; DEVOST ; Output status
                db 86h                  ; 4 input flush
                db 7                    ; DEVIFL ; Input flush
                db 86h                  ; 5 input status with system WAIT
                db 5                    ; DEVRDND ; Non destructive read no wait (char devs)

; =============== S U B R O U T I N E =======================================


IOFUNC          proc near               ; ...
                mov     word ptr ss:IOXAD+2, ss
                mov     word ptr ss:IOXAD, offset DEVIOBUF
                mov     ss:IOSCNT, 1
                mov     ss:DEVIOBUF, ax
                test    byte ptr [si+6], 80h ; [SI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
                jz      short IOTO22
                jmp     IOTOFILE
; ---------------------------------------------------------------------------

IOTO22:                                 ; ...
                test    byte ptr [si+5], 80h ; [SI+SF_ENTRY.sf_flags],devid_device
                jnz     short IOTO33
                jmp     IOTOFILE
; ---------------------------------------------------------------------------

IOTO33:                                 ; ...
                push    es
                call    save_world
                mov     dx, ds
                mov     bx, ss
                mov     ds, bx
                mov     es, bx
                xor     bx, bx
                cmp     ah, 5           ; system wait enabled?
                jnz     short _no_sys_wait
                mov     bh, 4           ; Set bit 10 in status word for driver

_no_sys_wait:                           ; ...
                mov     ds:IOCALL_REQSTAT, bx
                xor     bx, bx
                mov     ds:IOMED, bl
                mov     bl, ah          ; get function
                mov     ah, cs:LenTab[bx]
                add     bx, bx
                mov     cx, word ptr cs:CmdTab[bx]
                mov     bx, offset IOCALL
                mov     ds:IOCALL, ah   ; [IOCALL_REQLEN]
                mov     ds:IOCALL_REQFUNC, ch
                mov     ds, dx
                call    DEVIOCALL
                mov     di, ss:IOCALL_REQSTAT
                and     di, di
                js      short DevErr

OKDevIO:                                ; ...
                mov     ax, ss
                mov     ds, ax
                cmp     ch, 5           ; DEVRDND
                jnz     short DNODRD
                mov     al, ds:IOMED    ; [IORCHR]
                mov     byte ptr ds:DEVIOBUF, al

DNODRD:                                 ; ...
                mov     ah, byte ptr ds:IOCALL_REQSTAT+1
                not     ah              ; Zero = busy, not zero = ready
                and     ah, 2           ; STBUI>>8
                call    restore_world
                pop     es
                pushf
                mov     al, ss:IoStatFail ; assume fail error
                cbw                     ; sign extend to word
                inc     ax              ; 21/02/2024 - Erdogan Tan
                                        ; this may be a BUG
                                        ; MSDOS 6.22 MSDOS.SYS & Win ME IO.SYS code is
                                        ;  cbw
                                        ;  cmp  ax,-1
                                        ;  jne  short not_fail_ret
                                        ;  inc  byte [ss:IoStatFail]
                                        ;  popf
                                        ;  retn
                jnz     short not_fail_ret
                dec     ax
                jnz     short not_fail_ret ; jns ?
                inc     ss:IoStatFail
                popf
                retn
; ---------------------------------------------------------------------------

not_fail_ret:                           ; ...
                mov     ax, ss:DEVIOBUF
                popf
                retn
; ---------------------------------------------------------------------------

DevErr:                                 ; ...
                mov     ah, cl
                call    CHARHARD
                cmp     al, 1
                jnz     short NO_RETRY
                call    restore_world
                pop     es
                jmp     IOFUNC
; ---------------------------------------------------------------------------

NO_RETRY:                               ; ...
                and     byte ptr ss:IOCALL_REQSTAT+1, 0FDh ; [SS:IOCALL_REQSTAT+1],
                                        ; ~(STBUI>>8)
                cmp     al, 3
                jnz     short not_fail
                dec     ss:IoStatFail   ; set flag indicating fail on I24

not_fail:                               ; ...
                jmp     short OKDevIO
; ---------------------------------------------------------------------------

IOTOFILE:                               ; ...
                or      ah, ah
                jz      short IOIN
                dec     ah
                jz      short IOIST
                dec     ah
                jz      short IOUT
                retn
; ---------------------------------------------------------------------------

IOIST:                                  ; ...
                push    word ptr [si+15h] ; [SI+SF_ENTRY.sf_position]
                push    word ptr [si+17h] ; [SI+SF_ENTRY.sf_position+2]
                call    IOIN
; ---------------------------------------------------------------------------
                pop     word ptr [si+17h] ; [SI+SF_ENTRY.sf_position+2]
                pop     word ptr [si+15h] ; [SI+SF_ENTRY.sf_position]
                retn
; ---------------------------------------------------------------------------

IOUT:                                   ; ...
                call    SETXADDR
                call    DOS_WRITE
                call    RESTXADDR
; ---------------------------------------------------------------------------

IOUT_retn:                              ; ...
                retn
IOFUNC          endp


; =============== S U B R O U T I N E =======================================

; Attributes: noreturn

IOIN            proc near               ; ...
                call    SETXADDR
                or      ss:DOS34_FLAG, 40h ; Disable_EOF_I24
                call    DOS_READ
                and     ss:DOS34_FLAG, 0FFBFh ; NO_Disable_EOF_I24
                or      cx, cx
                call    RESTXADDR
; ---------------------------------------------------------------------------
                mov     al, byte ptr ss:DEVIOBUF ; Get byte from trans addr
                jnz     short IOUT_retn
                mov     al, 1Ah         ; ^Z if no bytes
                retn
IOIN            endp


; =============== S U B R O U T I N E =======================================


SETXADDR        proc near               ; ...
                pop     ss:CALLBPB      ; [SS:CALLSCNT] ; Return address
                push    es
                call    save_world
                mov     word ptr ss:THISSFT+2, ds
                lds     cx, ss:DMAADD
                push    cx
                push    ds
                lds     cx, ss:IOXAD
                mov     word ptr ss:DMAADD, cx ; Set byte trans addr
                mov     word ptr ss:DMAADD+2, ds
                mov     cx, ss
                mov     ds, cx
                mov     word ptr ds:THISSFT, si ; Finish setting SFT pointer
                mov     cx, ds:IOSCNT   ; ioscnt specifies length of buffer
                jmp     ds:CALLBPB      ; [CALLSCNT]
SETXADDR        endp


; =============== S U B R O U T I N E =======================================

; Attributes: noreturn

RESTXADDR       proc near               ; ...
                pop     ds:CALLBPB      ; [CALLSCNT] ; Return address
                pop     word ptr ds:DMAADD+2 ; Restore Disk trans addr
                pop     word ptr ds:DMAADD
                call    restore_world
RESTXADDR       endp

                pop     es
                jmp     ss:CALLBPB      ; [SS:CALLSCNT] ; Return address

; =============== S U B R O U T I N E =======================================


DEV_OPEN_SFT    proc near               ; ...
                push    es
                call    save_world
                mov     al, 0Dh         ; DEVOPN
                jmp     short DO_OPCLS
DEV_OPEN_SFT    endp


; =============== S U B R O U T I N E =======================================


DEV_CLOSE_SFT   proc near               ; ...
                push    es
                call    save_world
                mov     al, 0Eh         ; DEVCLS

DO_OPCLS:                               ; ...
                test    byte ptr es:[di+6], 80h ; [es:di+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
                jnz     short OPCLS_DONE ; NOP on net SFTs
                xor     ah, ah
                test    byte ptr es:[di+5], 80h ; [ES:DI+SF_ENTRY.sf_flags],devid_device
                les     di, es:[di+7]   ; [ES:DI+SF_ENTRY.sf_devptr] ; Get DPB or device
                jnz     short GOT_DEV_ADDR
                cmp     ss:fShare, 1
                jbe     short OPCLS_DONE
                mov     cx, es:[di]     ; [ES:DI+DPB.DRIVE]
                mov     ah, ch          ; [ES:DI+DPB.UNIT]
                les     di, es:[di+13h] ; [ES:DI+DPB.DRIVER_ADDR]

GOT_DEV_ADDR:                           ; ...
                test    byte ptr es:[di+5], 8 ; [ES:DI+SYSDEV.ATT+1],(DEVOPCL>>8)
                jz      short OPCLS_DONE
                push    es
                pop     ds
                mov     si, di          ; DS:SI -> device

OPCLS_RETRY:                            ; ...
                push    ss
                pop     es
                mov     di, offset DEVCALL_REQLEN ; DEVCALL
                mov     bx, di
                push    ax
                mov     al, 0Dh         ; DOPCLHL
                stosb                   ; Length
                pop     ax
                xchg    ah, al          ; Unit
                stosw
                xchg    ah, al
                mov     word ptr es:[di], 0 ; Status
                push    ax              ; Save Unit,Command
                call    DEVIOCALL2
                mov     di, es:[bx+3]   ; [ES:BX+SRHEAD.REQSTAT]
                and     di, di
                jns     short OPCLS_DONEP ; No error
                test    byte ptr [si+5], 80h ; [SI+SYSDEV.ATT+1],(DEVTYP>>8)
                jz      short BLKDEV
                mov     ah, 86h         ; Read error in data, Char dev
                jmp     short HRDERR
; ---------------------------------------------------------------------------

BLKDEV:                                 ; ...
                mov     al, cl          ; Drive number
                mov     ah, 6           ; Read error in data, Blk dev

HRDERR:                                 ; ...
                call    CHARHARD
                cmp     al, 1
                jnz     short OPCLS_DONEP ; IGNORE or FAIL
                                        ; Note that FAIL is essentually IGNORED
                pop     ax              ; Get back Unit, Command
                jmp     short OPCLS_RETRY
; ---------------------------------------------------------------------------

OPCLS_DONEP:                            ; ...
                pop     ax              ; Clean stack

OPCLS_DONE:                             ; ...
                call    restore_world
                pop     es
                retn
DEV_CLOSE_SFT   endp


; =============== S U B R O U T I N E =======================================


DEVIOCALL       proc near               ; ...
                lds     si, [si+7]      ; CALLNEWSC, HIGH_SECTOR & CALLDEVAD
DEVIOCALL       endp                    ; LDS SI,[SI+SF_ENTRY.sf_devptr]


; =============== S U B R O U T I N E =======================================


DEVIOCALL2      proc near               ; ...
                call    ECritDevice
                test    byte ptr [si+5], 80h ; [SI+SYSDEV.ATT+1],(DEVTYP>>8)
                jnz     short chardev2
                mov     al, es:[bx+2]   ; [ES:BX+SRHEAD.REQFUNC]
                cmp     al, 4           ; DEVRD
                jz      short chkext
                cmp     al, 8           ; DEVWRT
                jz      short chkext
                cmp     al, 9           ; DEVWRTV
                jnz     short chardev2

chkext:                                 ; ...
                test    byte ptr [si+4], 2 ; [SI+SYSDEV.ATT],EXTDRVR
                jz      short chksector
                mov     ax, 0FFFFh      ; -1 ; old sector
                add     byte ptr es:[bx], 8 ; make length to 30
                xchg    ax, ss:CALLSSEC
                mov     ss:CALLNEWSC, ax
                mov     ax, ss:HIGH_SECTOR
                mov     ss:CALLNEWSC+2, ax
                jmp     short chardev2
; ---------------------------------------------------------------------------

chksector:                              ; ...
                cmp     ss:HIGH_SECTOR, 0 ; if >32mb
                jnz     short chardev3  ; then fake error

chardev2:                               ; ...
                inc     ss:DEVIO_IN_PROGRESS ; lock (deviocall in progress)
                mov     ax, [si+6]      ; [SI+SYSDEV.STRAT]
                mov     word ptr ss:CALLDEVAD, ax
                mov     word ptr ss:CALLDEVAD+2, ds
                call    ss:CALLDEVAD
                mov     ax, [si+8]      ; [SI+SYSDEV.INT]
                mov     word ptr ss:CALLDEVAD, ax
                call    ss:CALLDEVAD
                dec     ss:DEVIO_IN_PROGRESS ; unlock (deviocall completed)

dev_exit:                               ; ...
                call    LCritDevice
                retn
; ---------------------------------------------------------------------------

chardev3:                               ; ...
                mov     word ptr es:[bx+3], 8107h ; [ES:BX+SRHEAD.REQSTAT],
                                        ; STERR+STDON+error_I24_not_DOS_disk
                jmp     short dev_exit
DEVIOCALL2      endp


; =============== S U B R O U T I N E =======================================


SETREAD         proc near               ; ...
                push    di
                push    cx
                push    ax
                mov     cl, 4           ; DEVRD

SETCALLHEAD:                            ; ...
                mov     al, 22          ; DRDWRHL
                mov     di, ss
                mov     es, di
                mov     di, offset DEVCALL_REQLEN ; DEVCALL
                stosb                   ; length
                pop     ax
                stosb                   ; Unit
                mov     es:[di], cl     ; Command code
                inc     di
                mov     word ptr es:[di], 0 ; Status
                add     di, 10
                mov     es:[di], ah     ; Media byte
                inc     di
                mov     cx, ax
                mov     es:[di], bx     ; Transfer addr
                mov     word ptr es:[di+2], ds
                add     di, 4
                pop     ax
                stosw                   ; Count
                xchg    ax, dx
                stosw                   ; Start
                xchg    ax, cx
                xchg    dx, cx
                pop     di
                mov     bx, offset DEVCALL_REQLEN ; DEVCALL
                retn
SETREAD         endp


; =============== S U B R O U T I N E =======================================


SETWRITE        proc near               ; ...
                push    di
                push    cx
                push    ax
                mov     cl, 8           ; DEVWRT
                add     cl, ss:VDERFLG
                jmp     short SETCALLHEAD
SETWRITE        endp

; ---------------------------------------------------------------------------
                stc
                retn
; ---------------------------------------------------------------------------
                clc
                retn
; ---------------------------------------------------------------------------
                stc
                retn

; =============== S U B R O U T I N E =======================================


BUILDDIR        proc near               ; ...
                mov     ax, ds:ENTFREE
                cmp     ax, 0FFFFh
                jz      short CHECK_IF_ROOT
                clc
                retn
; ---------------------------------------------------------------------------

CHECK_IF_ROOT:                          ; ...
                cmp     ds:DIRSTART_HW, 0
                jnz     short NEWDIR
                cmp     ds:DIRSTART, 0
                jnz     short NEWDIR
                stc                     ; Can't grow root

builddir_retn:                          ; ...
                retn
; ---------------------------------------------------------------------------

NEWDIR:                                 ; ...
                mov     bx, ds:DIRSTART_HW
                mov     ds:CLUSTNUM_HW, bx
                or      bx, bx
                mov     bx, ds:DIRSTART
                jnz     short NEWDIR2
                or      bx, bx
                jz      short NULLDIR

NEWDIR2:                                ; ...
                call    GETEOF
                jb      short builddir_retn ; Screw up

NULLDIR:                                ; ...
                xor     cx, cx
                mov     ds:CCOUNT_HW, cx ; 0
                inc     cx              ; 1
                call    ALLOCATE
                jb      short builddir_retn
                mov     dx, ds:DIRSTART
                cmp     dx, ds:DIRSTART_HW
                jnz     short ADDINGDIR
                or      dx, dx
                jnz     short ADDINGDIR
                push    ds:CLUSTNUM_HW
                pop     ds:ROOTCLUST_HW
                call    SETDIRSRCH
                jb      short builddir_retn
                mov     ds:LASTENT, 0FFFFh
                jmp     short GOTDIRREC
; ---------------------------------------------------------------------------

ADDINGDIR:                              ; ...
                push    bx
                push    ds:CLUSTNUM_HW
                mov     bx, ds:CLUSNUM_HW
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, ds:CLUSNUM
                call    IsEOF
                pop     ds:CLUSTNUM_HW
                pop     bx
                jb      short NOTFIRSTGROW
                mov     ds:CLUSNUM, bx
                push    cx              ; (not necessary)
                push    ax
                push    bp
                mov     ax, ds:CLUSTNUM_HW
                mov     ds:CLUSNUM_HW, ax
                mov     ah, 1           ; CLUSNUM update
                mov     dl, es:[bp+0]   ; drive #
                mov     cx, ds:DIRSTART ; first cluster #
                mov     bp, bx          ; CLUSNUM
                call    FastOpen_Update ; update CLUSNUM in the fastopen cache
                pop     bp
                pop     ax
                pop     cx

NOTFIRSTGROW:                           ; ...
                mov     dx, bx
                xor     bl, bl
                call    FIGREC

GOTDIRREC:                              ; ...
                mov     cl, es:[bp+4]   ; [ES:BP+DPB.CLUSTER_MASK]
                inc     cx
                xor     ch, ch

ZERODIR:                                ; ...
                push    cx
                mov     ds:ALLOWED, 18h ; Allowed_FAIL+Allowed_RETRY
                mov     al, 0FFh
                call    GETBUFFR
                jnb     short GET_SSIZE
                pop     cx
                retn
; ---------------------------------------------------------------------------

GET_SSIZE:                              ; ...
                mov     cx, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE]
                push    es
                les     di, ds:CURBUF
                or      byte ptr es:[di+5], 4 ; [ES:DI+BUFFINFO.buf_flags],buf_isDIR
                push    di
                add     di, 24
                xor     ax, ax
                shr     cx, 1
                rep stosw
                jnb     short EVENZ
                stosb

EVENZ:                                  ; ...
                pop     di
                call    SET_BUF_DIRTY
                pop     es
                add     dx, 1
                adc     ds:HIGH_SECTOR, cx
                pop     cx
                loop    ZERODIR
                mov     ax, ds:LASTENT
                inc     ax
                clc
                retn
BUILDDIR        endp


; =============== S U B R O U T I N E =======================================


SETDOTENT       proc near               ; ...
                stosw                   ; set up a . or .. directory entry
                                        ;  for a directory
                mov     cx, 4
                mov     ax, 2020h
                rep stosw
                stosb
                mov     al, 10h         ; Set up attribute
                stosb
                add     di, 8
                mov     ax, ds:CLUSTERS_HW
                stosw                   ; Set up first cluster field, hw
                mov     si, word ptr ds:THISSFT ; Initialize time and date of creation
                mov     ax, [si+0Dh]    ; [SI+SF_ENTRY.sf_time]
                stosw
                mov     ax, [si+0Fh]    ; [SI+SF_ENTRY.sf_date]
                stosw
                mov     ax, dx          ; Set up first cluster field, lw
                stosw
                xchg    ax, cx
                stosw
                stosw
                retn
SETDOTENT       endp


; =============== S U B R O U T I N E =======================================


MakeNode        proc near               ; ...

; FUNCTION CHUNK AT 953B SIZE 00000003 BYTES
; FUNCTION CHUNK AT 955F SIZE 00000040 BYTES
; FUNCTION CHUNK AT 95A3 SIZE 00000009 BYTES
; FUNCTION CHUNK AT 95E9 SIZE 00000030 BYTES

                mov     word ptr ds:CREATING, 0E5FFh ; DIRFREE*256 + 0FFh
                                        ; Creating, not DEL *.*
                push    ax              ; Save AH value
                mov     ds:NoSetDir, 0
                mov     ds:SATTRIB, al
                call    GetPathNoSet
                mov     dl, cl
                xchg    ax, cx          ; Device ID to CH
                pop     ax              ; Get back AH
                jnb     short make_exists ; File existed
                jnz     short make_err_4 ; Path bad
                cmp     dl, 80h         ; Check "CL" return from GETPATH
                jz      short RENAME_MAKE ; jz short make_type
                                        ; Name simply not found, and no metas

make_err_4:                             ; ...
                mov     al, 4           ; case 1 bad path
MakeNode        endp

; START OF FUNCTION CHUNK FOR RENAME_MAKE
;   ADDITIONAL PARENT FUNCTION MakeNode

make_err_ret:                           ; ...
                cbw
                stc
                retn
; END OF FUNCTION CHUNK FOR RENAME_MAKE

; =============== S U B R O U T I N E =======================================


RENAME_MAKE     proc near               ; ...

; FUNCTION CHUNK AT 953B SIZE 00000003 BYTES
; FUNCTION CHUNK AT 959F SIZE 00000004 BYTES
; FUNCTION CHUNK AT 95B8 SIZE 00000031 BYTES

                test    ds:EXTOPEN_ON, 1 ; make_type:
                                        ; EXT_OPEN_ON
                jz      short make_type2
                or      ds:EXTOPEN_ON, 4 ; EXT_FILE_NOT_EXISTS
                test    byte ptr ds:EXTOPEN_FLAG, 0F0h
                jnz     short make_type2
                stc
                mov     ax, 7           ; file not found

make_retn:                              ; ...
                retn
; ---------------------------------------------------------------------------

make_type2:                             ; ...
                les     di, ds:THISSFT
                xor     ax, ax          ; nothing exists Disk Node
                stc                     ; Not found
                jmp     short make_new
RENAME_MAKE     endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR MakeNode

make_exists:                            ; ...
                jz      short make_exists_dir
                mov     al, 3           ; file exists type 3
                                        ;  (error or device node)
                test    ds:ATTRIB, 18h  ; attr_volume_id+attr_directory
                jnz     short make_err_ret_5 ; Cannot already exist as Disk or Device Node
                                        ;  if making DIR or Volume ID
                or      ch, ch
                js      short make_share ; No further checks on attributes if device
                or      ah, ah
                jnz     short make_err_ret ; truncating NOT OK (AL = 3)
                push    cx              ; Save device ID
                mov     es, word ptr ds:CURBUF+2
                mov     ch, es:[bx+0Bh] ; [ES:BX+dir_entry.dir_attr]
                                        ; Get file attributes
                test    ch, 1           ; attr_read_only
                jnz     short make_err_ret_5P ; Cannot create on read only files
                call    MatchAttributes
                pop     cx              ; Devid back in CH
                jnz     short make_err_ret_5 ; Attributes not ok
                xor     al, al          ; AL = 0, Disk Node

make_share:                             ; ...
                cbw
                push    ax
                push    cx
                mov     ah, ch          ; Device ID to AH
                call    DOOPEN          ; Fill in SFT for share check
                les     di, ds:THISSFT
                push    si
                push    bx
                call    ShareEnter
                jnb     short MakeEndShare
                pop     bx
                pop     si
                pop     cx
                pop     ax
; END OF FUNCTION CHUNK FOR MakeNode
; START OF FUNCTION CHUNK FOR RENAME_MAKE

Make_Share_ret:                         ; ...
                mov     al, 6
                jmp     short make_err_ret
; END OF FUNCTION CHUNK FOR RENAME_MAKE
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR MakeNode

make_err_ret_5P:                        ; ...
                pop     cx              ; Get back device ID

make_err_ret_5:                         ; ...
                mov     al, 5           ; Attribute mismatch
                jmp     short make_err_ret
; ---------------------------------------------------------------------------

make_exists_dir:                        ; ...
                mov     al, 1           ; exists as directory, always an error
                jmp     short make_err_ret
; END OF FUNCTION CHUNK FOR MakeNode

; =============== S U B R O U T I N E =======================================


make_save       proc near               ; ...
                push    ax
                mov     ax, cx          ; Device ID to AH
                call    NEWENTRY
                pop     ax              ; 0 if Disk, 3 if File
                jnb     short make_retn
                mov     al, 2           ; create failed case 2

make_save_retn:                         ; ...
                retn
make_save       endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR RENAME_MAKE

make_new:                               ; ...
                call    make_save
                jb      short make_save_retn ; case 2 fail
                test    ds:ATTRIB, 10h  ; attr_directory
                jnz     short make_save_retn ; Don't "open" directories,
                                        ; so don't tell the sharer about them
                push    ax
                push    bx
                push    si
                call    ShareEnter
                pop     si
                pop     bx
                pop     ax
                jnb     short make_save_retn
                push    ax
                les     di, ds:CURBUF
                mov     byte ptr es:[bx], 0E5h ; DIRFREE ; nuke newly created entry
                call    SET_BUF_DIRTY
                les     bp, ds:THISDPB
                mov     al, es:[bp+0]   ; get drive for flush
                call    FLUSHBUF        ; write out buffer
                pop     ax
                jmp     short Make_Share_ret
; END OF FUNCTION CHUNK FOR RENAME_MAKE
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR MakeNode

MakeEndShare:                           ; ...
                les     di, ds:THISSFT  ; grab SFT
                xor     ax, ax
                call    ECritDisk       ; call ECritSFT
                xchg    ax, es:[di]     ; [ES:DI+SF_ENTRY.sf_ref_count]
                push    ax
                push    di
                push    es
                pushf
                call    ShareEnd        ; remove sharing
                popf
                pop     es
                pop     di
                pop     word ptr es:[di] ; [ES:DI+SF_ENTRY.sf_ref_count]
                call    LCritDisk       ; call LCritSFT
                pop     bx
                pop     si
                pop     cx
                pop     ax
                call    make_save
                jb      short make_save_retn ; bye if error
                push    ax
                push    bx
                push    si
                pushf
                call    ShareEnter      ; reassert the share access
                popf
                pop     si
                pop     bx
                pop     ax
; END OF FUNCTION CHUNK FOR MakeNode

makeendshare_retn:                      ; ...
                retn

; =============== S U B R O U T I N E =======================================


NEWENTRY        proc near               ; ...
                les     bp, ds:THISDPB
                jnb     short EXISTENT
                cmp     ds:FAILERR, 0
                stc
                jnz     short makeendshare_retn ; User FAILed, node might exist
                call    BUILDDIR        ; Try to build dir
                jb      short makeendshare_retn ; Failed
                call    GETENT          ; Point at that free entry
                jb      short makeendshare_retn ; Failed
                jmp     short FREESPOT
; ---------------------------------------------------------------------------

ERRRET3:                                ; ...
                stc

newentry_retn:                          ; ...
                retn
; ---------------------------------------------------------------------------

EXISTENT:                               ; ...
                or      ah, ah          ; Check if file is I/O device
                jns     short NOT_DEV1
                jmp     DOOPEN          ; If so, proceed with open
; ---------------------------------------------------------------------------

NOT_DEV1:                               ; ...
                call    FREEENT         ; Free cluster chain
                jb      short newentry_retn ; Failed

FREESPOT:                               ; ...
                test    ds:ATTRIB, 8    ; attr_volume_id
                jz      short NOTVOLID
                cmp     ds:VOLID, 0
                jnz     short ERRRET3   ; Can't create a second volume ID

NOTVOLID:                               ; ...
                mov     es, word ptr ds:CURBUF+2
                mov     di, bx
                mov     si, offset NAME1
                mov     cx, 5
                rep movsw               ; Move name into dir entry
                movsb
                mov     al, ds:ATTRIB
                stosb                   ; Attributes
                mov     cl, 5
                xor     ax, ax
                rep stosw               ; Zero pad
                call    DATE16
                xchg    ax, dx
                stosw                   ; dir_time
                xchg    ax, dx
                mov     es:[di-6], ax   ; last access date
                stosw                   ; dir_date
                xor     ax, ax
                push    di              ; Correct SI input value
                                        ; (recomputed for new buffer)
                stosw                   ; Zero dir_first and size
                stosw
                stosw

updnxt:
                mov     si, word ptr ds:CURBUF
                test    byte ptr es:[si+5], 40h ; [ES:SI+BUFFINFO.buf_flags],buf_dirty
                jnz     short yesdirty9 ; don't increment dirty count
                call    INC_DIRTY_COUNT
                or      byte ptr es:[si+5], 40h ; ES:SI+BUFFINFO.buf_flags],buf_dirty

yesdirty9:                              ; ...
                les     bp, ds:THISDPB
                mov     al, es:[bp+0]   ; [ES:BP+DPB.DRIVE]
                                        ; Sets AH value again (in AL)
                push    ax
                push    bx
                push    es
                push    di
                les     di, ds:THISSFT
                test    byte ptr es:[di+5], 80h ; [ES:DI+SF_ENTRY.sf_flags],devid_device
                jnz     short GotADevice
                push    ds
                push    bx
                lds     bx, ds:THISDPB
                mov     es:[di+7], bx   ; [ES:DI+SF_ENTRY.sf_devptr]
                mov     bx, ds
                mov     es:[di+9], bx   ; [ES:DI+SF_ENTRY.sf_devptr+2]
                pop     bx
                pop     ds              ; need to use DS for segment later on

GotADevice:                             ; ...
                pop     di
                pop     es
                call    FLUSHBUF
                pop     bx
                pop     ax
                pop     si              ; Get SI input back
                mov     ah, al          ; Get I/O driver number back
                jnb     short DOOPEN
                retn                    ; Failed
NEWENTRY        endp


; =============== S U B R O U T I N E =======================================


DOOPEN          proc near               ; ...
                mov     dh, ah          ; AH to different place
                xor     dl, dl
                or      ah, ah
                js      short DEV_SFT0
                les     di, ds:THISDPB
                cmp     word ptr es:[di+0Fh], 0 ; [es:di+DPB.FAT_SIZE]
                jz      short DEV_SFT0  ; FAT32
                inc     dl

DEV_SFT0:                               ; ...
                les     di, ds:THISSFT
                add     di, 4           ; SF_ENTRY.sf_attr
                                        ; Skip ref_count and mode fields
                xor     al, al
                or      dh, dh
                js      short DEV_SFT1
                mov     ds, word ptr ds:CURBUF+2
                mov     al, [bx+0Bh]    ; [BX+dir_entry.dir_attr]
                                        ; If file, get attrib from dir entry

DEV_SFT1:                               ; ...
                stosb                   ; sf_attr, ES:DI -> sf_flags
                xor     ax, ax
                mov     al, dh
                or      al, 40h         ; devid_file_clean
                stosw                   ; sf_flags, ES:DI -> sf_devptr
                push    ds
                lds     ax, [bx+1Ah]    ; [BX+dir_entry.dir_first] ; Assume device
                or      dh, dh
                js      short DEV_SFT2
                lds     ax, ss:THISDPB  ; Was file

DEV_SFT2:                               ; ...
                stosw                   ; store offset
                mov     ax, ds
                pop     ds
                stosw                   ; store segment, ES:DI -> sf_firclus
                push    si
                add     di, 32          ; SF_ENTRY.sf_chain ; first cluster (32 bit) !?
                movsw                   ; first cluster, lw
                add     si, 0FFF8h      ; add si, -8
                lodsw                   ; first cluster, hw
                or      dl, dl
                jz      short FILE_SFT0 ; FAT32
                xor     ax, ax          ; clear hw of first cluster (invalid)

FILE_SFT0:                              ; ...
                stosw
                add     di, 0FFDEh      ; add di, -34
                movsw                   ; dir_time -> sf_time
                movsw                   ; dir_date -> sf_date
                lodsw                   ; skip dir_first, DS:SI -> dir_size_l
                lodsw                   ; dir_size_l in AX, DS:SI -> dir_size_h
                xchg    ax, cx          ; dir_size_l in CX
                lodsw                   ; dir_size_h (size AX:CX), DS:SI -> ????
                or      dh, dh
                jns     short FILE_SFT1
                xor     ax, ax          ; 0
                mov     cx, ax          ; Devices are open ended

FILE_SFT1:                              ; ...
                xchg    ax, cx
                stosw                   ; Low word of sf_size
                xchg    ax, cx
                stosw                   ; High word of sf_size, ES:DI -> sf_position
                xor     ax, ax          ; 0
                stosw
                stosw                   ; sf_position = 0, ES:DI -> sf_cluspos
                or      dh, dh
                js      short DEV_SFT3
                stosw                   ; sf_cluspos ; 19h
                add     di, 0FFF0h      ; add di, -16
                stosw                   ; sf_cluspos_h (sf_firclus in MSDOS 5.0-6.22)
                add     di, 14          ; sf_dirsec ; 27
                mov     ax, es:[di+10h] ; [ES:DI+SF_ENTRY.sf_chain] ; 43
                                        ; first cluster (32 bit)
                mov     es:[di+1Ah], ax ; [ES:DI+SF_ENTRY.sf_lstclus] ; 53
                mov     ax, es:[di+12h] ; [ES:DI+SF_ENTRY.sf_chain+2] ; 45
                mov     es:[di+1Ch], ax ; [ES:DI+SF_ENTRY.sf_lstclus+2] ; 55
                push    ds
                push    ss
                pop     ds
                test    ds:FastOpenFlg, 4 ; Special_Fill_Set
                jz      short Not_FastOpen
                mov     si, offset FastOpen_Ext_Info
                mov     ax, [si+1]      ; FEI.dirsec
                stosw                   ; sf_dirsec, lw
                mov     ax, [si+3]      ; FEI.dirsec+2
                stosw                   ; sf_dirsec, hw
                mov     al, [si]        ; FEI.dirpos
                stosb                   ; sf_dirpos ; 31
                pop     ds
                jmp     short Next_Name
; ---------------------------------------------------------------------------

Not_FastOpen:                           ; ...
                pop     ds
                mov     si, word ptr ss:CURBUF
                mov     ax, [si+6]      ; [SI+BUFFINFO.buf_sector]
                stosw                   ; sf_dirsec, lw ; 27
                mov     ax, [si+8]      ; [SI+BUFFINFO.buf_sector+2]
                stosw                   ; sf_dirsec, hw ; 29
                mov     ax, bx
                add     si, 24          ; BUFINSIZ ; DS:SI-> start of data in buffer
                sub     ax, si          ; AX = BX relative to start of sector
                mov     cl, 32          ; dir_entry.size
                div     cl
                stosb                   ; sf_dirpos ; 31

Next_Name:                              ; ...
                jmp     short FILE_SFT2
; ---------------------------------------------------------------------------

DEV_SFT3:                               ; ...
                add     di, 7           ; SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos

FILE_SFT2:                              ; ...
                mov     si, bx          ; DS:SI points to dir_name
                mov     cx, 11
                rep movsb               ; sf_name
                pop     si              ; recover DS:SI -> dir_first
                push    ss
                pop     ds
                clc

doopen_retn:                            ; ...
                retn
DOOPEN          endp


; =============== S U B R O U T I N E =======================================


FREEENT         proc near               ; ...
                push    ds
                lds     di, ds:CURBUF
                mov     cx, [si]        ; Get pointer to clusters
                mov     ax, [si-6]      ; hw of first cluster (dir_first)
                mov     dx, [di+8]      ; [DI+BUFFINFO.buf_sector+2]
                mov     ss:HIGH_SECTOR, dx
                mov     dx, [di+6]      ; [DI+BUFFINFO.buf_sector]
                pop     ds
                cmp     word ptr es:[bp+0Fh], 0 ; [ES:BP+DPB.FAT_SIZE]
                jnz     short freeent2
                cmp     ax, 0
                jnz     short freeent1
                cmp     cx, 2

freeent1:                               ; ...
                jb      short RET1      ; Was 0 length file
                                        ; (or mucked Firclus if AX:CX=1)
                cmp     ax, es:[bp+2Fh] ; [ES:BP+DPB.LAST_CLUSTER+2]
                jnz     short freeent3
                cmp     cx, es:[bp+2Dh] ; [ES:BP+DPB.LAST_CLUSTER]
                jmp     short freeent3
; ---------------------------------------------------------------------------

freeent2:                               ; ...
                xor     ax, ax          ; 0
                cmp     cx, 2
                jb      short RET1      ; Was 0 length file (or mucked Firclus if CX=1)
                cmp     cx, es:[bp+0Dh] ; [ES:BP+DPB.MAX_CLUSTER]

freeent3:                               ; ...
                ja      short RET1      ; Treat like zero length file (firclus mucked)
                sub     bx, di
                push    bx
                push    ds:HIGH_SECTOR
                push    dx
                mov     bx, cx
                mov     ds:CLUSTNUM_HW, ax
                call    RELEASE         ; Free any data allocated
                pop     dx
                pop     ds:HIGH_SECTOR
                jb      short freeent4

GET_BUF_BACK:                           ;
                mov     ds:ALLOWED, 18h ; Allowed_RETRY+Allowed_FAIL
                xor     al, al
                call    GETBUFFR

freeent4:                               ; ...
                pop     bx
                jb      short doopen_retn
                call    SET_BUF_AS_DIR
                add     bx, word ptr ds:CURBUF
                lea     si, [bx+1Ah]    ; [bx+dir_entry.dir_first] ; Get corrected SI

RET1:                                   ; ...
                clc
                retn
FREEENT         endp


; =============== S U B R O U T I N E =======================================


FNDCLUS         proc near               ; ...
                push    es              ; DX:CX = No. of clusters to skip
                les     di, ds:THISSFT
                mov     ds:CLSKIP_HW, dx
                mov     bx, es:[di+37h] ;  [ES:DI+SF_ENTRY.sf_lstclus+2]
                mov     ds:CLUSTNUM_HW, bx
                or      bx, bx
                mov     dx, es:[di+0Bh] ; [ES:DI+SF_ENTRY.sf_firclus] ; MSDOS 5.0-6.22
                                        ; [ES:DI+SF_ENTRY.sf_cluspos_hw] ; PCDOS 7.1
                mov     ds:LASTPOS_HW, dx
                mov     bx, es:[di+35h] ; [ES:DI+SF_ENTRY.sf_lstclus]
                mov     dx, es:[di+19h] ; [ES:DI+SF_ENTRY.sf_cluspos]
                jnz     short fndclus_1
                or      bx, bx
                jnz     short fndclus_1
                jmp     NOCLUS
; ---------------------------------------------------------------------------

fndclus_1:                              ; ...
                sub     cx, dx
                push    ax
                mov     ax, ds:LASTPOS_HW
                sbb     ds:CLSKIP_HW, ax
                pop     ax
                jnb     short FINDIT
                add     cx, dx
                mov     bx, ds:LASTPOS_HW
                adc     ds:CLSKIP_HW, bx
                xor     dx, dx          ; 0
                mov     ds:LASTPOS_HW, dx
                mov     bx, es:[di+2Dh] ; [ES:DI+SF_ENTRY.sf_chain+2] ; MSDOS 5.0-6.22
                                        ; [ES:DI+SF_ENTRY.sf_fcluster+2] ; PCDOS 7.1
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, es:[di+2Bh] ; [ES:DI+SF_ENTRY.sf_chain] ; MSDOS 5.0-6.22
                                        ; [ES:DI+SF_ENTRY.sf_fcluster] ; PCDOS 7.1

FINDIT:                                 ; ...
                pop     es
                cmp     cx, ds:CLSKIP_HW
                jnz     short SKPCLP
                jcxz    short RET9      ; cf=0
FNDCLUS         endp


; =============== S U B R O U T I N E =======================================


SKPCLP          proc near               ; ...
                push    ds:LASTPOS_HW
                push    dx
                push    ds:CLSKIP_HW
                push    cx
                call    UNPACK
                pop     cx
                pop     ds:CLSKIP_HW
                pop     dx
                pop     ds:LASTPOS_HW
                jb      short fndclus_retn
                push    ds:CLUSTNUM_HW
                push    bx
                mov     bx, di
                mov     di, ds:CCONTENT_HW
                mov     ds:CLUSTNUM_HW, di
                call    IsEOF
                jb      short SKPCLP2
                pop     bx
                pop     ds:CLUSTNUM_HW
                jmp     short RET9      ; cf=0
; ---------------------------------------------------------------------------

SKPCLP2:                                ; ...
                add     sp, 4
                inc     dx
                jnz     short SKPCLP3
                inc     ds:LASTPOS_HW

SKPCLP3:                                ; ...
                sub     cx, 1
                sbb     ds:CLSKIP_HW, 0
                jnz     short SKPCLP    ; loop
                or      cx, cx
                jnz     short SKPCLP    ; loop

RET9:                                   ; ...
                clc                     ; (not necessary) ; 25/02/2024
                retn
; ---------------------------------------------------------------------------

NOCLUS:                                 ; ...
                pop     es
                push    di
                xor     di, di
                add     cx, 1
                adc     ds:CLSKIP_HW, di ; CLSKIP_HW:BX = Last cluster skipped to
                sub     dx, 1
                sbb     ds:LASTPOS_HW, di ; LASTPOS_HW:DX = Position of last cluster
                pop     di
                clc

fndclus_retn:                           ; ...
                retn
SKPCLP          endp


; =============== S U B R O U T I N E =======================================


BUFSEC          proc near               ; ...
                push    ds:CLUSTNUM_HW
                mov     dx, ds:CLUSNUM_HW
                mov     ds:CLUSTNUM_HW, dx
                mov     dx, ds:CLUSNUM
                mov     bl, ds:SECCLUSPOS
                mov     ds:ALLOWED, 38h ; Allowed_FAIL+Allowed_RETRY+Allowed_IGNORE
                call    FIGREC
                call    GETBUFFR
                pop     ds:CLUSTNUM_HW
                jb      short fndclus_retn
                mov     ds:TRANS, 1     ; A transfer is taking place
                mov     si, ds:NEXTADD
                mov     di, si
                mov     cx, ds:BYTCNT1
                add     di, cx
                mov     ds:NEXTADD, di
                les     di, ds:CURBUF
                or      byte ptr es:[di+5], 8 ; [ES:DI+BUFFINFO.buf_flags],
                                        ; buf_isDATA
                lea     di, [di+24]     ; [DI+BUFINSIZ] ; Point to buffer
                add     di, ds:BYTSECPOS
                clc                     ; (not necessary!?) ; 25/02/2024
                retn
BUFSEC          endp


; =============== S U B R O U T I N E =======================================


BUFRD           proc near               ; ...
                push    es              ; pre-read sector
                xor     ax, ax
                call    BUFSEC
                jnb     short BUF_OK    ; ds=ss

BUF_IO_FAIL:                            ; ...
                pop     es
                jmp     short RBUFPLACED ; ds=ss
; ---------------------------------------------------------------------------

BUF_OK:                                 ; ...
                mov     bx, es
                mov     es, word ptr ds:DMAADD+2
                mov     ds, bx
                xchg    di, si
                shr     cx, 1
                rep movsw               ; Copy Buffer to Transfer memory.
                adc     cx, 0           ; CX=1 if odd # of bytes, else CX=0.
                                        ; ! jnc short EVENRD !
                                        ; ! movsb !
                rep movsb               ; Copy last byte.

EVENRD:                                 ; 25/02/2024 - Erdogan Tan
                pop     es
                lds     di, ss:CURBUF
                lea     bx, [di+24]     ; [DI+BUFINSIZ]
                sub     si, bx
                call    PLACEBUF
                cmp     si, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE] ; Read Last byte?
                jb      short RBUFPLACEDC ; ds<>ss
                mov     word ptr ss:BufferQueue, di

RBUFPLACEDC:                            ; ...
                clc

RBUFPLACED:                             ; ...
                push    ss
                pop     ds
                retn
BUFRD           endp


; =============== S U B R O U T I N E =======================================


BUFWRT          proc near               ; ...
                add     word ptr ds:SECPOS, 1
                adc     word ptr ds:SECPOS+2, 0
                mov     ax, word ptr ds:SECPOS+2
                cmp     ax, ds:VALSEC+2
                mov     al, 1
                ja      short NOREAD
                jb      short _doread
                mov     ax, word ptr ds:SECPOS
                cmp     ax, ds:VALSEC   ; Has sector been written before?
                mov     al, 1           ; no need to read sector before buffer update
                ja      short NOREAD    ; Skip preread if SECPOS>VALSEC

_doread:                                ; ...
                xor     al, al          ; pre read is needed

NOREAD:                                 ; ...
                push    es
                call    BUFSEC
                jb      short BUF_IO_FAIL ; ds=ss
                mov     ds, word ptr ds:DMAADD+2 ;
                                        ; DS:SI-> Source within Transfer memory block
                                        ; ES:DI-> Destination within Buffer
                shr     cx, 1           ; CX = # of whole WORDs; CF=1 if odd # of bytes
                rep movsw
                adc     cx, cx          ; ! jnc short EVENWRT !
                                        ; ! movsb !
                rep movsb

EVENWRT:                                ; 25/02/2024 - Erdogan Tan
                pop     es
                lds     bx, ss:CURBUF
                test    byte ptr [bx+5], 40h ; [BX+BUFFINFO.buf_flags],buf_dirty
                jnz     short yesdirty10
                inc     ss:DirtyBufferCount
                or      byte ptr [bx+5], 40h

yesdirty10:                             ; ...
                lea     si, [bx+24]     ; [BX+BUFINSIZ]
                sub     di, si
                cmp     di, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE]
                jb      short WBUFPLACED ; Written last byte?
                                        ; No, leave buf where it is
                mov     word ptr ss:BufferQueue, bx ; Make it prime candidate for
                                        ; chucking even though it is MRU.

WBUFPLACED:                             ; ...
                clc
                mov     ax, ss
                mov     ds, ax
                retn
BUFWRT          endp


; =============== S U B R O U T I N E =======================================


NEXTSEC         proc near               ; ...
                test    ds:TRANS, 0FFh
                jz      short CLRET
                mov     al, ds:SECCLUSPOS
                inc     al
                cmp     al, es:[bp+4]
                jbe     short SAVPOS
                mov     bx, ds:CLUSNUM_HW
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, ds:CLUSNUM
                call    IsEOF
                jnb     short NONEXT
                call    UNPACK
                jb      short NONEXT
                push    di
                mov     di, ds:CCONTENT_HW
                mov     ds:CLUSNUM_HW, di
                pop     di
                mov     ds:CLUSNUM, di
                add     ds:LASTPOS, 1
                adc     ds:LASTPOS_HW, 0
                mov     al, 0

SAVPOS:                                 ; ...
                mov     ds:SECCLUSPOS, al

CLRET:                                  ; ...
                clc
                retn
; ---------------------------------------------------------------------------

NONEXT:                                 ; ...
                stc
                retn
NEXTSEC         endp


; =============== S U B R O U T I N E =======================================


OPTIMIZE        proc near               ; ...
                push    dx
                push    ds:CLUSTNUM_HW
                push    bx
                mov     al, es:[bp+4]   ; [ES:BP+DPB.CLUSTER_MASK]
                inc     al              ; Number of sectors per cluster
                mov     ah, al
                sub     al, dl          ; AL = Num of sectors left in first cluster
                mov     dx, cx
                xor     cx, cx

OPTCLUS:                                ; ...
                call    UNPACK
                jb      short OP_ERR    ; ds=ss

clusgot2:                               ; AL has number of sectors available
                add     cl, al          ;  in current cluster
                adc     ch, 0           ; CX has number of sequential sectors
                                        ;  found so far
                cmp     cx, dx          ; DX has number of sectors left to transfer
                jnb     short BLKDON
                mov     al, ah          ; AH has number of sectors available
                                        ;  in next cluster
                push    di
                xor     di, di
                add     bx, 1
                adc     ds:CLUSTNUM_HW, di
                mov     di, ds:CCONTENT_HW
                cmp     di, ds:CLUSTNUM_HW
                pop     di
                jnz     short clusgot3
                cmp     di, bx
                jz      short OPTCLUS

clusgot3:                               ; ...
                sub     bx, 1
                sbb     ds:CLUSTNUM_HW, 0

FINCLUS:                                ; ...
                push    bx
                add     ds:LASTPOS, bx
                mov     bx, ds:CLUSTNUM_HW
                adc     ds:LASTPOS_HW, bx
                mov     ds:CLUSNUM_HW, bx
                pop     ds:CLUSNUM      ; Last cluster accessed
                sub     dx, cx          ; Number of sectors still needed
                push    dx
                mov     ax, cx          ; CX has number of sequential sectors
                                        ;  found so far
                mul     word ptr es:[bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
                mov     si, ds:NEXTADD
                add     ax, si          ; Adjust by size of transfer
                mov     ds:NEXTADD, ax
                pop     ax              ; Number of sectors still needed
                pop     dx              ; Starting cluster, lw
                pop     bx              ; Starting cluster, hw
                mov     ds:CLUSTNUM_HW, bx
                sub     ds:LASTPOS, dx
                sbb     ds:LASTPOS_HW, bx
                pop     bx              ; BL = sector position within cluster
                call    FIGREC
                mov     bx, si
                clc
                retn
; ---------------------------------------------------------------------------

OP_ERR:                                 ; ...
                add     sp, 6
                stc
                retn
; ---------------------------------------------------------------------------

BLKDON:                                 ; ...
                sub     cx, dx          ; Number of sectors in cluster we don't want
                sub     ah, cl          ; Number of sectors in cluster we accepted
                dec     ah              ; Adjust to mean position within cluster
                mov     ds:SECCLUSPOS, ah
                mov     cx, dx          ; Anyway, make the total equal to the request
                jmp     short FINCLUS
OPTIMIZE        endp


; =============== S U B R O U T I N E =======================================


FIGREC          proc near               ; ...
                push    ax
                push    cx
                xor     cx, cx
                mov     cl, es:[bp+5]   ; DPB.CLUSTER_SHIFT
                mov     ax, ss:CLUSTNUM_HW
                sub     dx, 2
                sbb     ax, 0
                jcxz    short noshift

rotleft:                                ; ...
                clc
                rcl     dx, 1
                rcl     ax, 1
                loop    rotleft

noshift:                                ; ...
                or      dl, bl
                cmp     word ptr es:[bp+0Fh], 0 ; DPB.FAT_SIZE
                jnz     short noshift1  ; not FAT32
                add     dx, es:[bp+29h] ; DPB.FCLUS_FSECTOR
                adc     ax, es:[bp+2Bh]
                jmp     short noshift2
; ---------------------------------------------------------------------------

noshift1:                               ; ...
                add     dx, es:[bp+0Bh] ; DPB.FIRST_SECTOR
                adc     ax, 0

noshift2:                               ; ...
                mov     ss:HIGH_SECTOR, ax
                pop     cx
                pop     ax

figrec_retn:                            ; ...
                retn
FIGREC          endp


; =============== S U B R O U T I N E =======================================


callmagic       proc near               ; ...
                push    ds
                push    ss:OffsetMagicPatch
                retf
callmagic       endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR ALLOCATE

alloc_disk_full:                        ; ...
                jmp     Disk_Full_Return
; END OF FUNCTION CHUNK FOR ALLOCATE

; =============== S U B R O U T I N E =======================================


ALLOCATE        proc near               ; ...

; FUNCTION CHUNK AT 9ACC SIZE 00000003 BYTES

                clc                     ; COUNT_HW:CX = Number of clusters to allocate
                push    cs
                call    callmagic
                jb      short alloc_disk_full

Regular_Allocate_Path:
                push    bx
                xor     bx, bx          ; 0
                push    ds:CLUSTNUM_HW
                mov     ds:CLUSTNUM_HW, bx ; cluster 0
                call    UNPACK
                mov     ds:FATBYT, di   ;
                                        ; CCONTENT_HW:DI = content of FAT
                                        ;  (for cluster 0)
                mov     bx, ds:CCONTENT_HW
                mov     ds:FATBYT_HW, bx
                pop     ds:CLUSTNUM_HW
                pop     bx
                jb      short figrec_retn
                push    ds:CCOUNT_HW
                push    cx
                push    ds:CLUSTNUM_HW
                push    bx
                mov     dx, bx
                xor     bx, bx
                cmp     es:[bp+0Fh], bx ; [es:bp+DPB.FAT_SIZE]
                xchg    bx, ds:CLUSTNUM_HW
                mov     ds:CLUSDATA_HW, bx
                mov     bx, es:[bp+1Dh] ; [es:bp+DPB.NEXT_FREE]
                jnz     short ads0
                mov     bx, es:[bp+3Bh] ; [es:bp+DPB.FAT32_NXTFREE+2]
                mov     ds:CLUSTNUM_HW, bx
                cmp     bx, 0
                mov     bx, es:[bp+39h] ; [es:bp+DPB.FAT32_NXTFREE]
                jnz     short ads1

ads0:                                   ; ...
                cmp     bx, 2

ads1:                                   ; ...
                ja      short FINDFRE

ads2:                                   ; ...
                xor     bx, bx
                cmp     es:[bp+0Fh], bx ; [es:bp+DPB.FAT_SIZE]
                jnz     short ads3
                mov     word ptr es:[bp+39h], 2 ; [es:bp+DPB.FAT32_NXTFREE]
                mov     es:[bp+3Bh], bx ; [es:bp+DPB.FAT32_NXTFREE+2]

ads3:                                   ; ...
                mov     ds:CLUSTNUM_HW, bx ; 0
                mov     word ptr es:[bp+1Dh], 2 ; [es:bp+DPB.NEXT_FREE]
                inc     bx              ; 1
                or      es:[bp+18h], bl ; [es:bp+DPB.FIRST_ACCESS]

FINDFRE:                                ; ...
                add     bx, 1
                adc     ds:CLUSTNUM_HW, 0
                cmp     word ptr es:[bp+0Fh], 0 ; [es:bp+DPB.FAT_SIZE]
                jnz     short ads4      ; not FAT32
                push    bx
                mov     bx, ds:CLUSTNUM_HW
                cmp     bx, es:[bp+2Fh] ; [es:bp+DPB.LAST_CLUSTER+2]
                pop     bx
                jnz     short ads5
                cmp     bx, es:[bp+2Dh] ; [es:bp+DPB.LAST_CLUSTER]
                jmp     short ads5
; ---------------------------------------------------------------------------

ads4:                                   ; ...
                cmp     bx, es:[bp+0Dh] ; [es:bp+DPB.MAX_CLUSTER]

ads5:                                   ; ...
                jbe     short ads6
                jmp     ads15
; ---------------------------------------------------------------------------

ads6:                                   ; ...
                push    cx
                push    ds:CCOUNT_HW
                push    bx
                push    ds:CLUSTNUM_HW
                push    dx
                push    ds:CLUSDATA_HW
                call    UNPACK
                pop     ds:CLUSDATA_HW
                pop     dx
                pop     ds:CLUSTNUM_HW
                pop     bx
                pop     ds:CCOUNT_HW
                pop     cx
                jnb     short ads7
                jmp     ads13
; ---------------------------------------------------------------------------

ads7:                                   ; ...
                jnz     short FINDFRE
                mov     es:[bp+1Dh], bx ; [es:bp+DPB.NEXT_FREE]
                cmp     word ptr es:[bp+0Fh], 0 ; [es:bp+DPB.FAT_SIZE]
                jnz     short ads8      ; not FAT32
                push    bx
                mov     bx, ds:CLUSTNUM_HW
                mov     es:[bp+3Bh], bx ; [es:bp+DPB.FAT32_NXTFREE+2]
                pop     bx
                mov     es:[bp+39h], bx ; [es:bp+DPB.FAT32_NXTFREE]

ads8:                                   ; ...
                or      byte ptr es:[bp+18h], 1 ; [es:bp+DPB.FIRST_ACCESS]
                push    cx
                push    ds:CCOUNT_HW
                push    bx
                push    ds:CLUSTNUM_HW
                push    dx
                push    ds:CLUSDATA_HW
                xor     dx, dx          ; 0
                mov     ds:CLUSDATA_HW, dx
                inc     dx              ; 1 ; mark this free guy as "1"
                call    PACK            ; set special "temporary" mark
                pop     ds:CLUSTNUM_HW
                pop     bx
                pop     ds:CLUSDATA_HW
                pop     dx
                pop     ds:CCOUNT_HW
                pop     cx
                jb      short ads13
                push    ax
                xor     ax, ax
                cmp     es:[bp+0Fh], ax ; [es:bp+DPB.FAT_SIZE]
                jnz     short ads10     ; not FAT32
                dec     ax
                cmp     es:[bp+21h], ax ; [es:bp+DPB.FREE_CNT+2]
                jnz     short ads9
                cmp     es:[bp+1Fh], ax ; [es:bp+DPB.FREE_CNT]

ads9:                                   ; ...
                jz      short NO_ALLOC
                add     es:[bp+1Fh], ax ; Reduce free count by 1
                                        ; [es:bp+DPB.FREE_CNT]
                adc     es:[bp+21h], ax ; [es:bp+DPB.FREE_CNT+2]
                jmp     short NO_ALLOC
; ---------------------------------------------------------------------------

ads10:                                  ; ...
                dec     ax              ; 0FFFFh ; -1
                cmp     es:[bp+1Fh], ax ; [es:bp+DPB.FREE_CNT]
                jz      short NO_ALLOC  ; Free count not valid
                dec     word ptr es:[bp+1Fh] ; [es:bp+DPB.FREE_CNT]
                                        ; Reduce free count by 1

NO_ALLOC:                               ; ...
                pop     ax
                push    cx
                push    ds:CCOUNT_HW
                push    dx
                push    ds:CLUSDATA_HW
                call    PACK
                pop     ds:CLUSTNUM_HW
                pop     bx
                pop     ds:CCOUNT_HW
                pop     cx
                jb      short ads13
                mov     dx, ds:CLUSTNUM_HW
                mov     ds:CLUSDATA_HW, dx
                mov     dx, bx
                sub     cx, 1
                sbb     ds:CCOUNT_HW, 0
                cmp     cx, ds:CCOUNT_HW
                jnz     short ads11
                jcxz    short ads12

ads11:                                  ; ...
                jmp     FINDFRE
; ---------------------------------------------------------------------------

ads12:                                  ; ...
                mov     dx, 0FFFFh
                mov     ds:CLUSDATA_HW, dx
                call    PACK

ads13:                                  ; ...
                pop     bx
                pop     ds:CLUSTNUM_HW
                pop     cx
                pop     ds:CCOUNT_HW
                jnb     short ads14

ads_ret:                                ; ...
                retn
; ---------------------------------------------------------------------------

ads14:                                  ; ...
                call    UNPACK          ; Get first cluster allocated for return
                jb      short ads_ret
                call    RESTFATBYT      ; Restore correct cluster 0 value
                jb      short ads_ret
                push    ax
                mov     ax, ds:CCONTENT_HW
                xchg    ax, ds:CLUSTNUM_HW
                xchg    bx, di          ; CLUSTNUM_HW:DI = last cluster in file upon our entry
                or      ax, di
                pop     ax
                jnz     short ads_ret   ; we were extending an existing file

dofastk:
                push    dx
                mov     dx, es
                les     di, ds:THISSFT
                push    bx
                mov     bx, ds:CLUSTNUM_HW
                mov     es:[di+2Dh], bx ; [es:di+SF_ENTRYT.sf_chain+2] ; 32 bit fclust, hw
                mov     es:[di+37h], bx ; [es:di+SF_ENTRYT.sf_lstclus+2] ; 32 bit lclust, hw
                pop     bx
                mov     es:[di+2Bh], bx ; [es:di+SF_ENTRYT.sf_chain] ; 32 bit fcluster, lw
                mov     es:[di+35h], bx ; [es:di+SF_ENTRYT.sf_lstclus] ; 32 bit lcluster, lw
                mov     es, dx
                pop     dx
                retn
; ---------------------------------------------------------------------------

ads15:                                  ; ...
                cmp     word ptr es:[bp+0Fh], 0 ; [es:bp+DPB.FAT_SIZE]
                jz      short ads16     ; FAT32
                cmp     word ptr es:[bp+1Dh], 2 ; [es:bp+DPB.NEXT_FREE]
                jmp     short ads17
; ---------------------------------------------------------------------------

ads16:                                  ; ...
                cmp     word ptr es:[bp+3Bh], 0 ; [es:bp+DPB.FAT32_NXTFREE+2]
                jnz     short ads17
                cmp     word ptr es:[bp+39h], 2 ; [es:bp+DPB.FAT32_NXTFREE]

ads17:                                  ; ...
                jz      short ads18
                jmp     ads2            ; start scan from front of disk
; ---------------------------------------------------------------------------

ads18:                                  ; ...
                pop     bx
                mov     dx, 0FFFFh      ; -1
                mov     ds:CLUSDATA_HW, dx
                pop     ds:CLUSTNUM_HW
                call    RELBLKS
                pop     ax
                pop     ds:CLUSTERS_HW
                sub     ax, cx
                sbb     ds:CLUSTERS_HW, 0
                call    RESTFATBYT

Disk_Full_Return:                       ; ...
                mov     ds:DISK_FULL, 1
                stc
                retn
ALLOCATE        endp


; =============== S U B R O U T I N E =======================================


RESTFATBYT      proc near               ; ...
                push    bx
                push    dx
                push    di
                xor     bx, bx          ; 0
                push    ds:CLUSTNUM_HW
                push    ds:CLUSDATA_HW
                push    ds:CCONTENT_HW  ; (not necessary ?)
                mov     ds:CLUSTNUM_HW, bx ; 0
                mov     dx, ds:FATBYT_HW
                mov     ds:CLUSDATA_HW, dx
                mov     dx, ds:FATBYT
                call    PACK
                pop     ds:CCONTENT_HW
                pop     ds:CLUSDATA_HW
                pop     ds:CLUSTNUM_HW
                pop     di
                pop     dx
                pop     bx
                retn
RESTFATBYT      endp


; =============== S U B R O U T I N E =======================================


RELEASE         proc near               ; ...
                xor     dx, dx
                mov     ds:CLUSDATA_HW, dx ; (dx = 0, release)
RELEASE         endp


; =============== S U B R O U T I N E =======================================


RELBLKS         proc near               ; ...
                call    UNPACK
                jbe     short RET12
                mov     ax, di          ; CCONTENT_HW:DI= Content of FAT
                                        ;  for given cluster (next cluster)
                push    dx
                push    ax
                call    PACK
                pop     ax
                mov     dx, ds:CCONTENT_HW
                mov     ds:CLUSTNUM_HW, dx ; next cluster (hw) to be released
                mov     bx, ax          ; next cluster (lw) to be released
                pop     dx
                jb      short RET12
                or      dx, dx          ; 0 (delete/release) or -1 (EOF)
                jnz     short NO_DEALLOC ; Was putting EOF mark (dx = -1)
                cmp     dx, ds:CLUSDATA_HW ; > 0 ? (delete, release)
                jnz     short NO_DEALLOC ; no, EOF (allocate, -1), (dx = 0)
                cmp     word ptr es:[bp+1Fh], 0FFFFh ; [ES:BP+DPB.FREE_CNT],-1
                                        ; Free count valid?
                jz      short NO_DEALLOC ; No (dx = 0)

relblks_ifc:                            ; ...
                inc     word ptr es:[bp+1Fh] ; [ES:BP+DPB.FREE_CNT]
                                        ; Increase free count by 1
                jnz     short NO_DEALLOC2
                cmp     es:[bp+0Fh], dx ; [ES:BP+DPB.FAT_SIZE]
                jnz     short NO_DEALLOC2 ; not FAT32
                inc     word ptr es:[bp+21h] ; [ES:BP+DPB.FREE_CNT+2]
                jmp     short NO_DEALLOC2
; ---------------------------------------------------------------------------

NO_DEALLOC:                             ; ...
                cmp     es:[bp+0Fh], dx ; dx is -1 or 0
                                        ;  (valid 16 bit fat size is another number)
                jnz     short NO_DEALLOC2 ; FAT (FAT16 or FAT12)
                                        ; dx = 0, FAT32
                cmp     word ptr es:[bp+21h], 0FFFFh ; [ES:BP+DPB.FREE_CNT+2]
                jnz     short relblks_ifc

NO_DEALLOC2:                            ; ...
                cmp     ds:CLUSTNUM_HW, 0
                jnz     short NO_DEALLOC3
                dec     ax              ; check for "1"
                jz      short RET12     ; is last cluster of incomplete chain

NO_DEALLOC3:                            ; ...
                call    IsEOF
                jb      short RELEASE

RET12:                                  ; ...
                retn
RELBLKS         endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR GETEOF

GETEOF1:                                ; ...
                mov     di, ax
                mov     ds:CLUSTERS_HW, dx ; CLUSTERS_HW:DI = Cluster Count
                pop     ax
                pop     dx
                retn
; END OF FUNCTION CHUNK FOR GETEOF

; =============== S U B R O U T I N E =======================================


GETEOF          proc near               ; ...

; FUNCTION CHUNK AT 9D73 SIZE 00000009 BYTES

                push    dx
                push    ax
                xor     dx, dx          ; cluster count = 0
                xor     ax, ax

GETEOF2:                                ; ...
                call    UNPACK
                jb      short GETEOF1
                inc     ax              ; CCONTENT_HW:DI = next cluster (cluster content)
                jnz     short GETEOF3
                inc     dx

GETEOF3:                                ; ...
                push    bx
                push    ds:CLUSTNUM_HW
                mov     bx, ds:CCONTENT_HW
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, di
                call    IsEOF
                pop     ds:CLUSTNUM_HW
                pop     bx
                jnb     short GETEOF1   ; EOF
                mov     bx, ds:CCONTENT_HW ; not EOF
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, di
                jmp     short GETEOF2   ; get next cluster
GETEOF          endp


; =============== S U B R O U T I N E =======================================


MAKEFCB         proc near               ; ...
                xor     dl, dl          ; 0
                mov     ss:SpaceFlag, dl ; Flag--not ambiguous file name
                test    al, 2           ; DRVBIT
                jnz     short DEFDRV
                mov     es:[di], dl     ; use default drive

DEFDRV:                                 ; ...
                inc     di
                mov     cx, 8
                test    al, 4           ; NAMBIT
                xchg    ax, bx
                mov     al, 20h ; ' '
                jz      short FILLB     ; go fill with blanks
                add     di, cx
                xor     cx, cx          ; Don't fill any

FILLB:                                  ; ...
                rep stosb
                mov     cl, 3
                test    bl, 8           ; EXTBIT
                jz      short FILLB2
                add     di, cx
                xor     cx, cx          ; 0

FILLB2:                                 ; ...
                rep stosb
                xchg    ax, cx
                stosw
                stosw                   ; Initialize two words after to zero
                sub     di, 16          ; Point back at start
                test    bl, 1           ; SCANSEPARATOR
                                        ; Scan off separators if not zero
                jz      short SKPSPC
                call    SCANB           ; Peel off blanks and tabs
                call    DELIM           ; Is it a one-time-only delimiter?
                jnz     short NOSCAN
                inc     si              ; Skip over the delimiter

SKPSPC:                                 ; ...
                call    SCANB

NOSCAN:                                 ; ...
                call    GETLET
                jbe     short NODRV     ; Quit if termination character
                cmp     byte ptr [si], 3Ah ; ':' ;
                                        ; Check for potential drive specifier
                jnz     short NODRV
                inc     si              ; Skip over colon
                sub     al, 40h ; '@'   ; Convert drive letter to drive number (A=1)
                jbe     short BADDRV    ; Drive letter out of range
                push    ax
                call    GetVisDrv
                pop     ax
                jnb     short HAVDRV
                cmp     ss:DrvErr, 1Ah  ; error_not_DOS_disk
                jz      short HAVDRV

BADDRV:                                 ; ...
                mov     dl, 0FFh        ; -1

HAVDRV:                                 ; ...
                stosb                   ; Put drive specifier in first byte
                inc     si
                dec     di              ; Counteract next two instructions

NODRV:                                  ; ...
                dec     si              ; Back up
                inc     di              ; Skip drive byte
MAKEFCB         endp


; =============== S U B R O U T I N E =======================================


NORMSCAN        proc near               ; ...
                mov     cx, 8
                call    GETWORD         ; Get 8-letter file name
                cmp     byte ptr [si], 2Eh ; '.'
                jnz     short NODOT
                inc     si              ; Skip over dot if present
                mov     cx, 3           ; Get 3-letter extension
                test    byte ptr ss:DOS34_FLAG+1, 1 ; (DBCS_VOLID2>>8)
                jz      short VOLOK
                movsb
                dec     cx

VOLOK:                                  ; ...
                call    MUSTGETWORD

NODOT:                                  ; ...
                mov     al, dl
                and     ss:DOS34_FLAG, 0FEFFh ; ~DBCS_VOLID2
                retn
NORMSCAN        endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR GETWORD

NONAM:                                  ; ...
                add     di, cx
                dec     si
                retn
; END OF FUNCTION CHUNK FOR GETWORD

; =============== S U B R O U T I N E =======================================


GETWORD         proc near               ; ...

; FUNCTION CHUNK AT 9E3E SIZE 00000004 BYTES

                call    GETLET
                jbe     short NONAM
                dec     si
GETWORD         endp


; =============== S U B R O U T I N E =======================================


MUSTGETWORD     proc near               ; ...
                call    GETLET
                jnz     short MustCheckCX
                test    ss:SpaceFlag, 0FFh
                jz      short FILLNAM
                cmp     al, 20h ; ' '
                jnz     short FILLNAM

MustCheckCX:                            ; ...
                jcxz    short MUSTGETWORD
                dec     cx
                cmp     al, 2Ah ; '*'   ; Check for ambiguous file specifier
                jnz     short NOSTAR
                mov     al, 3Fh ; '?'
                rep stosb

NOSTAR:                                 ; ...
                stosb
                cmp     al, 3Fh ; '?'
                jnz     short MUSTGETWORD
                or      dl, 1           ; Flag ambiguous file name
                jmp     short MUSTGETWORD
; ---------------------------------------------------------------------------

FILLNAM:                                ; ...
                mov     al, 20h ; ' '
                rep stosb
                dec     si
                retn
MUSTGETWORD     endp


; =============== S U B R O U T I N E =======================================


SCANB           proc near               ; ...
                lodsb
                call    SPCHK
                jz      short SCANB
                dec     si

scanb_retn:                             ; ...
                retn
SCANB           endp


; =============== S U B R O U T I N E =======================================


NameTrans       proc near               ; ...
                mov     ss:SpaceFlag, 1
                push    ss
                pop     es
                mov     di, offset NAME1
                push    di
                mov     al, 20h ; ' '
                mov     cx, 11
                rep stosb               ; Fill "FCB" at NAME1 with spaces
                xchg    ax, cx
                cwd
                stosb
                pop     di
                call    NORMSCAN
                cmp     ss:NAME1, 0E5h
                jnz     short scanb_retn
                mov     ss:NAME1, 5     ; Magic name translation
                retn
NameTrans       endp

; ---------------------------------------------------------------------------
CharType        db  66h, 66h, 66h, 66h,   6, 66h, 66h, 66h ; ...
                db  66h, 66h, 66h, 66h, 66h, 66h, 66h, 66h
                db 0F8h,0F6h,0FFh,0FFh,0FFh, 4Fh,0F4h, 6Eh
                db 0FFh,0FFh,0FFh,0FFh,0FFh, 44h, 44h,0F4h
                db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
                db 0FFh,0FFh,0FFh,0FFh,0FFh, 6Fh, 66h,0FFh
                db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
                db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0F4h

; =============== S U B R O U T I N E =======================================


GETLET          proc near               ; ...
                lodsb
GETLET          endp


; =============== S U B R O U T I N E =======================================


UCase           proc near               ; ...
                push    bx
                mov     bx, offset FILE_UCASE_TAB_2 ; FILE_UCASE_TAB+2

gl_0:                                   ; ...
                cmp     al, 'a'
                jb      short gl_2      ; Already upper case, go check type
                cmp     al, 'z'
                ja      short gl_1
                sub     al, 20h         ; Convert to upper case

gl_1:                                   ; ...
                cmp     al, 80h
                jb      short gl_2      ; Not EuroChar, go check type
                sub     al, 80h         ; translate to upper case with this index
                push    ds
                mov     ds, cs:DosDSeg
                xlat                    ; ds as file_ucase_tab is in DOSDATA
                pop     ds

gl_2:                                   ; ...
                push    ax
                call    GetCharType     ; returns type flags in AL
                test    al, 1           ; FCHK ; test for normal character
                pop     ax
                pop     bx
                retn
UCase           endp


; =============== S U B R O U T I N E =======================================


GETLET3         proc near               ; ...
                push    bx
                jmp     short gl_0
GETLET3         endp


; =============== S U B R O U T I N E =======================================


DELIM           proc near               ; ...
                push    ax
                call    GetCharType
                test    al, 2           ; FDELIM
                pop     ax
                retn
DELIM           endp


; =============== S U B R O U T I N E =======================================


SPCHK           proc near               ; ...
                push    ax
                call    GetCharType
                test    al, 4           ; FSPCHK
                pop     ax
                retn
SPCHK           endp


; =============== S U B R O U T I N E =======================================


GetCharType     proc near               ; ...
                cmp     al, 7Eh         ; CharType_last ; beyond end of table?
                jnb     short gct_90
                push    bx
                mov     bx, offset CharType ; load lookup table
                shr     al, 1           ; adjust for half-byte table entry size
                xlat    byte ptr cs:[bx] ; get flags
                pop     bx
                jnb     short gct_80    ; carry clear, no shift needed
                push    cx
                mov     cl, 4           ; we want high nibble, shift it down
                shr     al, cl
                pop     cx

gct_80:                                 ; ...
                and     al, 0Fh         ; clear the unused nibble
                retn
; ---------------------------------------------------------------------------

gct_90:                                 ; ...
                mov     al, 0Fh         ; set all flags
                retn
GetCharType     endp


; =============== S U B R O U T I N E =======================================


PATHCHRCMP      proc near               ; ...
                cmp     al, 2Fh ; '/'
                jbe     short PathRet
                cmp     al, 5Ch ; '\'
                retn
; ---------------------------------------------------------------------------

GotFor:                                 ; ...
                mov     al, 5Ch ; '\'
                retn
; ---------------------------------------------------------------------------

PathRet:                                ; ...
                jz      short GotFor
                retn
PATHCHRCMP      endp

; ---------------------------------------------------------------------------
LowInt23Addr    dw offset LowInt23      ; ...
LowInt23_SEG    dw 0                    ; ...
LowInt24Addr    dw offset LowInt24      ; ...
LowInt24_SEG    dw 0                    ; ...
LowInt28Addr    dw offset LowInt28      ; ...
LowInt28_SEG    dw 0                    ; ...

; =============== S U B R O U T I N E =======================================


DSKSTATCHK      proc near               ; ...
                cmp     ss:INDOS, 1
                jz      short dskstatchk1
                retn
; ---------------------------------------------------------------------------

dskstatchk1:                            ; ...
                push    cx
                push    es
                push    bx
                push    ds
                push    si
                mov     bx, ss
                mov     es, bx
                mov     ds, bx
                mov     ds:DSKSTCOM, 5  ; DEVRDND
                mov     ds:DSKSTCALL, 14 ; DRDNDHL
                mov     ds:DSKSTST, 0
                mov     bx, offset DSKSTCALL
                lds     si, ds:BCON
                call    DEVIOCALL2
                push    ds
                push    ss
                pop     ds
                test    byte ptr ds:DSKSTST+1, 2
                jz      short _GotCh
                xor     al, al

RET36:                                  ; ...
                pop     si
                pop     si
                pop     ds
                pop     bx
                pop     es
                pop     cx
                retn
; ---------------------------------------------------------------------------

_GotCh:                                 ; ...
                mov     al, ds:DSKCHRET
                cmp     al, 3           ; "C"-"@"
                jnz     short RET36
                mov     ds:DSKSTCOM, 4  ; DEVRD
                mov     ds:DSKSTCALL, 16h ; DRDWRHL
                mov     ds:DSKCHRET, cl
                mov     ds:DSKSTST, 0
                mov     ds:DSKSTCNT, 1
                pop     ds
                call    DEVIOCALL2      ; Eat the ^C
                pop     si
                pop     ds
                pop     bx
                pop     es
                pop     cx
                jmp     CNTCHAND
DSKSTATCHK      endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR STATCHK

NOSTOP:                                 ; ...
                cmp     al, 16          ; "P"-"@"
                jnz     short check_next
                cmp     ss:SCAN_FLAG, 0 ; ALT_Q ?
                jz      short INCHKJ    ; no
                retn
; ---------------------------------------------------------------------------

check_next:                             ; ...
                cmp     al, 3           ; "C"-"@"
                jz      short INCHKJ

check_end:                              ; ...
                retn
; ---------------------------------------------------------------------------

INCHKJ:                                 ; ...
                jmp     INCHK
; END OF FUNCTION CHUNK FOR STATCHK

; =============== S U B R O U T I N E =======================================


SPOOLINT        proc near               ; ...
                pushf
                cmp     ss:IDLEINT, 0
                jz      short POPFRET
                cmp     ss:ERRORMODE, 0
                jnz     short POPFRET
                push    word ptr ss:IDLEINT
                cmp     ss:DosHasHMA, 0 ; Q: is dos running in HMA
                jnz     short do_low_int28 ; Y: the int must be done from low mem
                int     28h             ; DOS 2+ internal - KEYBOARD BUSY LOOP
                jmp     short spool_ret_addr
; ---------------------------------------------------------------------------

do_low_int28:                           ; ...
                call    dword ptr cs:LowInt28Addr ; call far [cs:LowInt28Addr]

spool_ret_addr:                         ; ...
                pop     word ptr ss:IDLEINT

POPFRET:                                ; ...
                popf

_RET18:                                 ; ...
                retn
SPOOLINT        endp


; =============== S U B R O U T I N E =======================================


STATCHK         proc far                ; ...

; FUNCTION CHUNK AT 4123 SIZE 00000088 BYTES
; FUNCTION CHUNK AT 41AF SIZE 00000003 BYTES
; FUNCTION CHUNK AT 41D7 SIZE 00000148 BYTES
; FUNCTION CHUNK AT 9FBF SIZE 00000015 BYTES

                call    DSKSTATCHK      ; Allows ^C to be detected under
                                        ; input redirection
                push    bx
                xor     bx, bx
                call    GET_IO_SFT
                pop     bx
                jb      short _RET18
                mov     ah, 1
                call    IOFUNC
                jz      short SPOOLINT
                cmp     al, 19          ; 'S'-'@'
                jnz     short NOSTOP
                cmp     ss:SCAN_FLAG, 0 ; ALT_R ?
                jnz     short check_end ; yes
                xor     ah, ah
                call    IOFUNC          ; Eat Cntrl-S
                jmp     short PAUSOSTRT
; ---------------------------------------------------------------------------

PRINT_ON_OFF:                           ; ...
                not     ss:PFLAG
                push    bx
                mov     bx, 4
                call    GET_IO_SFT
                pop     bx
                jb      short _RET18
                push    es
                push    di
                push    ds
                pop     es
                mov     di, si
                test    byte ptr es:[di+6], 8 ; [ES:DI+SF_ENTRY.sf_flags+1],(sf_net_spool>>8)
                jz      short NORM_PR   ; Not redirected, echo is OK
                push    ax
                mov     ax, 1126h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - ???
                                        ; Return: CF set on error, AX = error code
                                        ; STACK unchanged
                pop     ax
                jnb     short NORM_PR   ; Echo is OK
                mov     ss:PFLAG, 0     ; If not allowed, disable echo
                push    ax
                mov     ax, 1124h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - ???
                                        ; ES:DI -> SFT, SS = DOS CS
                pop     ax
                jmp     short RETP6
; ---------------------------------------------------------------------------

NORM_PR:                                ; ...
                cmp     ss:PFLAG, 0
                jnz     short PRNOPN
                call    DEV_CLOSE_SFT
                jmp     short RETP6
; ---------------------------------------------------------------------------

PRNOPN:                                 ; ...
                call    DEV_OPEN_SFT

RETP6:                                  ; ...
                pop     di
                pop     es

STATCHK_RETN:                           ; ...
                retn
; ---------------------------------------------------------------------------

PAUSOLP:                                ; ...
                call    SPOOLINT

PAUSOSTRT:                              ; ...
                mov     ah, 1
                call    IOFUNC
                jz      short PAUSOLP

INCHK:                                  ; ...
                push    bx
                xor     bx, bx
                call    GET_IO_SFT
                pop     bx
                jb      short STATCHK_RETN
                xor     ah, ah
                call    IOFUNC
                cmp     al, 10h         ; "P"-"@"
                jz      short PRINT_ON_OFF ; must be CTRL_P
                cmp     al, 3           ; "C"-"@"
                jnz     short STATCHK_RETN

CNTCHAND:                               ; ...
                test    byte ptr ss:DOS34_FLAG+1, 2 ; (CTRL_BREAK_FLAG>>8)
                jnz     short around_deadlock
                mov     al, 3           ; Display "^C"
                call    BUFOUT
                call    CRLF

around_deadlock:                        ; ...
                push    ss
                pop     ds
                cmp     ds:CONSWAP, 0
                jz      short NOSWAP
                call    SWAPBACK

NOSWAP:                                 ; ...
                cli                     ; Prepare to play with stack
                mov     ss, ds:USER_SS  ; User stack now restored
                mov     sp, ds:USER_SP
                call    restore_world   ; User registers now restored
                pop     es
                push    ds
                mov     ds, cs:DosDSeg
                mov     ds:INDOS, 0     ; Go to known state
                mov     ds:INDOS_FLAG, 0
                mov     ds:ERRORMODE, 0
                mov     ds:ConC_Spsave, sp ; save his SP
                add     ds:ConC_Spsave, 2
                cmp     ds:DosHasHMA, 0 ; Q: is dos running in HMA
                pop     ds
                jnz     short do_low_int23 ; Y: the int must be done from low mem
                clc
                int     23h             ; DOS - CONTROL "C" EXIT ADDRESS
                                        ; Return: return via RETF 2 with CF set
                                        ; DOS will abort program with errorlevel 0
                                        ; else
                                        ; interrupted DOS call continues
                jmp     short ctrlc_ret_addr
; ---------------------------------------------------------------------------

do_low_int23:                           ; ...
                clc
                call    dword ptr cs:LowInt23Addr ; call far [cs:LowInt23Addr]

ctrlc_ret_addr:                         ; ...
                cli
                push    ax
                mov     ax, ds
                mov     ds, cs:DosDSeg
                mov     ds:TEMPSEG, ax
                pop     ax
                mov     ds:USER_IN_AX, ax
                pushf
                pop     ax
                cmp     sp, ds:ConC_Spsave
                jnz     short ctrlc_try_new ; current SP not the same as saved SP

ctrlc_repeat:                           ; ...
                mov     ax, ds:USER_IN_AX
                mov     ds, ds:TEMPSEG  ; restore ds and original sp

COMMANDJ:                               ; ...
                jmp     COMMAND
; ---------------------------------------------------------------------------

ctrlc_try_new:                          ; ...
                test    al, 1           ; f_Carry
                pop     ax              ; add sp,2
                jz      short ctrlc_repeat
                mov     ds, ds:TEMPSEG

ctrlc_abort:                            ; ...
                mov     ax, 4C00h       ; (EXIT*256) + 0
                push    ds
                mov     ds, cs:DosDSeg
                mov     ds:DidCTRLC, 0FFh ; -1
                pop     ds
                jmp     short COMMANDJ
STATCHK         endp ; sp-analysis failed

; ---------------------------------------------------------------------------

DIVOV:                                  ; ...
                mov     si, offset DIVMES ; "\r\nDivide overflow\r\n"
                mov     bx, cs:DivMesLen
                mov     ss, cs:DosDSeg
                mov     sp, 7A0h        ; AUXSTACK
                call    _OUTMES
                jmp     short ctrlc_abort ; Use Ctrl-C abort on divide overflow

; =============== S U B R O U T I N E =======================================


_OUTMES         proc near               ; ...
                push    ss
                pop     es
                push    ss
                pop     ds
                mov     ds:DSKSTCOM, 8  ; DEVWRT
                mov     ds:DSKSTCALL, 16h ; DRDWRHL
                mov     ds:DSKSTST, 0
                mov     ds:DSKSTCNT, bx
                mov     bx, offset DSKSTCALL
                mov     ds:DEVIOBUF_PTR, si
                mov     ds:DOSSEG_INIT, cs
                lds     si, ds:BCON
                call    DEVIOCALL2
                mov     es:DEVIOBUF_PTR, offset DEVIOBUF
                mov     es:DSKSTCNT, 1
                retn
_OUTMES         endp


; =============== S U B R O U T I N E =======================================


CHARHARD        proc near               ; ...
                cmp     ss:ERRORMODE, 0 ; Q: are we in the middle of int 24
                jnz     short chard1    ; Y: allow fail
                or      ah, 10h         ; Allowed_RETRY ; assume ctrl p
                test    ss:PFLAG, 0FFh  ; Q: has ctrl p been pressed
                jnz     short ctrlp     ; Y:

chard1:                                 ; ...
                or      ah, 38h         ; Allowed_IGNORE+Allowed_RETRY+Allowed_FAIL

ctrlp:                                  ; ...
                mov     ss:ALLOWED, ah
                mov     word ptr ss:EXITHOLD+2, es
                mov     word ptr ss:EXITHOLD, bp
                push    si
                and     di, 0FFh        ; STECODE
                mov     bp, ds          ; Device pointer is BP:SI
                call    near ptr FATALC
                pop     si
                retn
CHARHARD        endp


; =============== S U B R O U T I N E =======================================


HARDERR         proc near               ; ...
                xchg    ax, di          ; Error code in DI, count in AX
                and     di, 0FFh        ; STECODE
                cmp     di, 0           ; error_I24_write_protect
                                        ; Write Protect Error?
                jnz     short NOSETWRPERR
                push    ax
                mov     al, es:[bp+0]   ; [ES:BP+DPB.DRIVE]
                mov     ss:WPERR, al    ; Flag drive with WP error
                pop     ax

NOSETWRPERR:                            ; ...
                sub     ax, cx          ; Number of sectors successfully transferred
                add     dx, ax          ; First sector number to retry
                adc     ss:HIGH_SECTOR, 0
                push    dx
                mul     word ptr es:[bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
                                        ; DX:AX = Number of bytes transferred
                pop     dx
                add     bx, ax          ; First address for retry
                xor     ah, ah          ; Flag disk section in error
                cmp     ss:HIGH_SECTOR, 0
                jnz     short TESTDIR
                cmp     dx, es:[bp+6]   ; [ES:BP+DPB.FIRST_FAT]
                                        ; In reserved area?
                jb      short ERRINT

TESTDIR:                                ; ...
                inc     ah
                cmp     word ptr es:[bp+0Fh], 0 ; [es:bp+DPB.FAT_SIZE]
                jnz     short TESTDIR3  ; not FAT32
                push    dx
                mov     dx, ss:HIGH_SECTOR
                cmp     dx, es:[bp+2Bh] ; [es:bp+DPB.FCLUS_FSECTOR+2]
                pop     dx
                jnz     short TESTDIR1  ; Err in FAT must force recomp of freespace
                cmp     dx, es:[bp+29h] ; [es:bp+DPB.FCLUS_FSECTOR]

TESTDIR1:                               ; ...
                jnb     short TESTDIR2
                mov     word ptr es:[bp+1Fh], 0FFFFh ; -1 ; [es:bp+DPB.FREE_CNT]
                mov     word ptr es:[bp+21h], 0FFFFh ; -1 ; [es:bp+DPB.FREE_CNT+2]
                jmp     short ERRINT
; ---------------------------------------------------------------------------

TESTDIR2:                               ; ...
                inc     ah
                inc     ah
                jmp     short ERRINT
; ---------------------------------------------------------------------------

TESTDIR3:                               ; ...
                cmp     dx, es:[bp+11h] ; [ES:BP+DPB.DIR_SECTOR]
                jnb     short TESTDIR4  ; not in FAT
                mov     word ptr es:[bp+1Fh], 0FFFFh ; [ES:BP+DPB.FREE_CNT],-1
                jmp     short ERRINT
; ---------------------------------------------------------------------------

TESTDIR4:                               ; ...
                inc     ah
                cmp     dx, es:[bp+0Bh] ; [ES:BP+DPB.FIRST_SECTOR]
                jb      short ERRINT
                inc     ah

ERRINT:                                 ; ...
                shl     ah, 1           ; Make room for read/write bit
                or      ah, ss:READOP
                or      ah, ss:ALLOWED  ; Set the allowed bits
HARDERR         endp


; =============== S U B R O U T I N E =======================================


FATAL           proc near               ; ...
                mov     al, es:[bp+0]   ; [ES:BP+DPB.DRIVE]
FATAL           endp


; =============== S U B R O U T I N E =======================================


FATAL1          proc near               ; ...
                mov     word ptr ss:EXITHOLD+2, es
                mov     word ptr ss:EXITHOLD, bp ; The only things we preserve
                les     si, es:[bp+13h] ; [ES:BP+DPB.DRIVER_ADDR]
                mov     bp, es          ; BP:SI points to the device involved
FATAL1          endp


; =============== S U B R O U T I N E =======================================


FATALC          proc far                ; ...

; FUNCTION CHUNK AT B40B SIZE 0000000D BYTES
; FUNCTION CHUNK AT B420 SIZE 00000022 BYTES

                call    SET_I24_EXTENDED_ERROR
                cmp     di, 0Ch         ; error_I24_gen_failure
                jbe     short NET_I24_ENTRY ; GOT_RIGHT_CODE
                mov     di, 0Ch         ; Error codes above gen_failure get
                                        ; mapped to gen_failure. Real codes
                                        ; only come via GetExtendedError

NET_I24_ENTRY:                          ; ...
                cmp     ss:ERRORMODE, 0 ; No INT 24s if already INT 24
                jz      short NoSetFail
                mov     al, 3
                jmp     short FailRet
; ---------------------------------------------------------------------------

NoSetFail:                              ; ...
                mov     ss:CONTSTK, sp
                push    ss
                pop     es
                cmp     ss:SFN, 0FFFFh  ; -1
                jz      short _NoFree
                push    ds
                push    si
                lds     si, ss:PJFN
                mov     byte ptr [si], 0FFh
                pop     si
                pop     ds

_NoFree:                                ; ...
                cli                     ; Prepare to play with stack
                inc     ss:ERRORMODE    ; Flag INT 24 in progress
                dec     ss:INDOS        ; INT 24 handler might not return
                dec     ss:INDOS_FLAG
                test    ss:EXTOPEN_ON, 2 ; EXT_OPEN_I24_OFF
                jz      short i24yes
                mov     al, 3           ; fake fail
                jmp     short passi24
; ---------------------------------------------------------------------------

i24yes:                                 ; ...
                mov     ss, ss:USER_SS
                mov     sp, es:USER_SP  ; User stack pointer restored
                cmp     es:DosHasHMA, 0 ; Q: is dos running in HMA
                jnz     short do_low_int24 ; Y: the int must be done from low mem
                int     24h             ; DOS - FATAL ERROR HANDLER ADDRESS
                                        ; Automatically called upon detection of unrecoverable I/O error.
                jmp     short criterr_ret_addr
; ---------------------------------------------------------------------------

do_low_int24:                           ; ...
                call    dword ptr cs:LowInt24Addr ; call far [cs:LowInt24Addr]

criterr_ret_addr:                       ; ...
                mov     es:USER_SP, sp  ; restore our stack
                mov     es:USER_SS, ss
                push    es
                pop     ss

passi24:                                ; ...
                mov     sp, ss:CONTSTK
                inc     ss:INDOS        ; Back in the DOS
                inc     ss:INDOS_FLAG
                mov     ss:ERRORMODE, 0 ; Back from INT 24
                sti

FailRet:                                ; ...
                les     bp, ss:EXITHOLD
                cmp     al, 1
                jb      short CheckIgnore ; 0 => ignore
                jz      short CheckRetry ; 1 => retry
                cmp     al, 3           ; 3 => fail
                jnz     short DoAbort   ; 2, invalid => abort
                test    ss:ALLOWED, 8   ; Allowed_FAIL ; Can we?
                jz      short DoAbort   ; No, do abort

DoFail:                                 ; ...
                mov     al, 3
                test    ss:EXTOPEN_ON, 2 ; EXT_OPEN_I24_OFF
                jnz     short CleanUp
                inc     ss:FAILERR      ; Tell everybody

CleanUp:                                ; ...
                mov     ss:WPERR, 0FFh  ; -1
                cmp     ss:SFN, 0FFFFh  ; -1
                jnz     short CleanUp2
                retn
; ---------------------------------------------------------------------------

CleanUp2:                               ; ...
                push    ds
                push    si
                push    ax
                mov     ax, ss:SFN
                lds     si, ss:PJFN
                mov     [si], al
                pop     ax
                pop     si
                pop     ds
                retn
; ---------------------------------------------------------------------------

CheckIgnore:                            ; ...
                test    ss:ALLOWED, 20h ; Allowed_IGNORE ; Can we?

CheckRI:                                ; ...
                jz      short DoFail    ; No, do fail
                jmp     short CleanUp
; ---------------------------------------------------------------------------

CheckRetry:                             ; ...
                test    ss:ALLOWED, 10h ; Allowed_RETRY ; Can we?
                jmp     short CheckRI   ; No, do fail
; ---------------------------------------------------------------------------

DoAbort:                                ; ...
                push    ss
                pop     ds
                cmp     ds:CONSWAP, 0
                jz      short NOSWAP2
                call    SWAPBACK

NOSWAP2:                                ; ...
                cmp     ds:fAborting, 0
                jnz     short DoFail
                mov     byte ptr ds:EXIT_TYPE, 2 ; EXIT_HARD_ERROR
                xor     al, al
                jmp     exit_inner
; ---------------------------------------------------------------------------

reset_environment:                      ; ...
                push    ds
                mov     ah, 82h
                int     2Ah             ; Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7
                mov     ss:fAborting, 0FFh
                mov     ax, 1122h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
                                        ; SS = DOS CS
                mov     al, 22h
                call    $GET_INTERRUPT_VECTOR
                pop     cx
                push    es
                push    bx
                mov     bx, ss:CurrentPDB
                mov     ds, bx
                mov     ax, ds:16h      ; [PDB.PARENT_PID]
                cmp     ax, bx
                jz      short reset_return ; parentPDB = CurrentPDB
                cmp     bx, cx
                jnz     short reset_return ; CurrentPDB <> ThisPDB
                push    ax
                cmp     byte ptr ss:EXIT_TYPE, 3 ; EXIT_KEEP_PROCESS
                jz      short reset_to_parent
                call    arena_free_process
                call    DOS_ABORT

reset_to_parent:                        ; ...
                pop     ss:CurrentPDB   ; set up process as parent

reset_return:                           ; ...
                push    ss
                pop     ds
                mov     al, 0FFh        ; -1
                call    ECritDisk
                call    FLUSHBUF
                call    LCritDisk
                cli
                mov     ds:INDOS, 0     ; Go to known state
                mov     ds:INDOS_FLAG, 0
                mov     ds:WPERR, 0FFh  ; Forget about WP error
                mov     ds:fAborting, 0 ; let aborts occur
                pop     word ptr ds:EXITHOLD
                pop     word ptr ds:EXITHOLD+2
                mov     ds, ds:CurrentPDB
                mov     ss, word ptr ds:30h ; [PDB.USER_STACK+2]
                mov     sp, ds:2Eh      ; [PDB.USER_STACK]
                call    restore_world
FATALC          endp

                pop     es
                push    ax
                mov     ax, ds
                mov     ds, cs:DosDSeg
                mov     ds:TEMPSEG, ax  ; Save DS in TEMPSEG, not on stack.
                pop     ax
                mov     ds:USER_SP, ax
                pop     ax              ; suck off CS:IP of interrupt
                pop     ax
                pop     ax
                lahf
                xchg    ah, al
                and     al, 2
                mov     ah, 0F2h
                push    ax
                push    word ptr ds:EXITHOLD+2
                push    word ptr ds:EXITHOLD
                mov     ax, ds:USER_SP
                mov     ds, ds:TEMPSEG  ; restore ds
                iret

; =============== S U B R O U T I N E =======================================


SET_I24_EXTENDED_ERROR proc near        ; ...
                push    ax
                mov     ax, offset SPECIAL_VERSION ; ErrMap24End
                                        ; size of ErrMap24
                sub     ax, offset ErrMap24
                push    ds
                mov     ds, cs:DosDSeg
                cmp     di, ax
                mov     ax, di
                jnb     short NoTrans
                mov     al, ds:ErrMap24[di]
                xor     ah, ah

NoTrans:                                ; ...
                mov     ds:EXTERR, ax
                pop     ds
                pop     ax
                push    si
                mov     si, offset ERR_TABLE_24
                call    CAL_LK
                pop     si
                retn
SET_I24_EXTENDED_ERROR endp


; =============== S U B R O U T I N E =======================================


IsEOF           proc near               ; ...
                call    IsFAT32         ; is it FAT32 drive ?
                jnb     short IsEOF_FAT ; no, it has 12 or 16 bit FAT
                cmp     ss:CLUSTNUM_HW, 0FFFh ; FAT32
                jnz     short IsEOF_other1 ; not EOF
                cmp     bx, 0FFF8h      ; 32 bit compare

IsEOF_other1:                           ; ...
                retn                    ; cf=0 -> EOF, cf=1 -> not EOF
; ---------------------------------------------------------------------------

IsEOF_FAT:                              ; ...
                cmp     word ptr es:[bp+0Dh], 0FF6h ; [es:bp+DPB.MAX_CLUSTER]
                                        ; is this 16 bit fat?
                jnb     short EOF16     ; yes, check for eof there
                cmp     bx, 0FF0h
                jz      short IsEOF_other
                cmp     bx, 0FF8h       ; do the 12 bit compare

IsEOF_other:                            ; ...
                retn                    ; cf=0 -> EOF, cf=1 -> not EOF
; ---------------------------------------------------------------------------

EOF16:                                  ; ...
                cmp     bx, 0FFF8h      ; 16 bit compare
                retn                    ; cf=0 -> EOF, cf=1 -> not EOF
IsEOF           endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR UNPACK

up_1:                                   ; ...
                cmp     ds:CLUSTNUM_HW, bx ; 0
                jnz     short up_cont
                mov     di, ds:CL0FATENTRY_HW
                or      di, di
                mov     ds:CCONTENT_HW, di
                mov     di, ds:CL0FATENTRY
                jnz     short unpack_retn
                or      di, di

unpack_retn:                            ; ...
                retn                    ; [CCONTENT_HW]:DI = contents of CL0FATENTRY
; END OF FUNCTION CHUNK FOR UNPACK

; =============== S U B R O U T I N E =======================================


UNPACK          proc near               ; ...

; FUNCTION CHUNK AT A435 SIZE 00000019 BYTES

                or      bx, bx
                jz      short up_1

up_cont:                                ; ...
                cmp     word ptr es:[bp+0Fh], 0 ; [ES:BP+DPB.FAT_SIZE]
                jnz     short up_fat    ; not FAT32
                mov     si, es:[bp+2Fh] ; [ES:BP+DPB.LAST_CLUSTER+2]
                cmp     ds:CLUSTNUM_HW, si
                jnz     short up_2
                cmp     bx, es:[bp+2Dh] ; [ES:BP+DPB.LAST_CLUSTER]
                jmp     short up_2
; ---------------------------------------------------------------------------

up_fat:                                 ; ...
                cmp     bx, es:[bp+0Dh] ; [ES:BP+DPB.MAX_CLUSTER]

up_2:                                   ; ...
                ja      short HURTFAT   ; error (> cluster count)
                call    MAPCLUSTER
                jb      short _DoContext ; (ds<>ss)
                push    word ptr [di+2] ; offset CLUSSAVE+2
                pop     ss:CCONTENT_HW  ; high word of cluster number
                mov     di, [di]        ; offset CLUSSAVE
                jnz     short High12
                call    IsFAT32
                jb      short up_fat32  ; FAT32 volume (drive)
                mov     ss:CCONTENT_HW, 0
                mov     si, es:[bp+0Dh] ; [ES:BP+DPB.MAX_CLUSTER]
                                        ; is this 16-bit fat?
                cmp     si, 0FF6h       ; 4096-10
                jb      short Unpack12  ; No, go 'AND' off bits

up_fat32:                               ; ...
                or      di, di          ; set zero condition code, clears carry
                mov     si, ss
                mov     ds, si
                jnz     short up_retn
                or      ds:CCONTENT_HW, di ; [CCONTENT_HW]:DI = 0 -> zf = 1

up_retn:                                ; ...
                retn
; ---------------------------------------------------------------------------

High12:                                 ; ...
                mov     ss:CCONTENT_HW, 0
                shr     di, 1
                shr     di, 1
                shr     di, 1
                shr     di, 1

Unpack12:                               ; ...
                and     di, 0FFFh

_DoContext:                             ; ...
                mov     si, ss
                mov     ds, si
                retn
; ---------------------------------------------------------------------------

HURTFAT:                                ; ...
                call    chk_set_first_access
                push    ax
                mov     ah, 88h         ; Allowed_FAIL+80h
                mov     ss:ALLOWED, 8   ; Allowed_FAIL
                push    ss:CLUSTNUM_HW  ; (necessary!?)
                push    bx              ; (necessary!?)
                call    FATAL           ; NOTE: DI would be 0FFFFh here (or 0FFFh as in MSDOS 6.?)
                                        ; because, in SET_I24_EXTENDED_ERROR in FATAL,
                                        ; DI is compared with error code
                                        ; ;
                                        ; xor di,di
                                        ; dec di ; 0FFFFh
                                        ; push di
                                        ; call FATAL
                                        ; pop word [ss:CCONTENT_HW]
                                        ; ;
                                        ; Erdogan Tan - 02/03/2024
                pop     bx
                pop     ss:CLUSTNUM_HW
                xor     di, di
                dec     di              ; 0FFFFh
                mov     ss:CCONTENT_HW, di
                cmp     al, 3
                clc
                jnz     short OKU_RET   ; Try to ignore bad FAT
                stc                     ; User said FAIL

OKU_RET:                                ; ...
                pop     ax

hurtfat_retn:                           ; ...
                retn
UNPACK          endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR PACK

p_clust_0:                              ; ...
                cmp     ds:CLUSTNUM_HW, bx ; 0
                jnz     short p_cont
                push    ax
                mov     ax, ds:CLUSDATA_HW ; Cluster Data/Content (High Word)
                mov     ds:CL0FATENTRY_HW, ax
                pop     ax
                mov     ds:CL0FATENTRY, dx
                retn
; END OF FUNCTION CHUNK FOR PACK

; =============== S U B R O U T I N E =======================================


PACK            proc near               ; ...

; FUNCTION CHUNK AT A4E6 SIZE 00000013 BYTES

                or      bx, bx          ; CLUSDATA_HW:DX = cluster data/content
                                        ; CLUSTNUM_HW:BX = cluster number (to be updated)
                                        ; ES:BP = pointer to DPB
                                        ;
                                        ; are we packing cluster 0 ?
                jz      short p_clust_0 ; place value in CL0FATENTRY

p_cont:                                 ; ...
                call    MAPCLUSTER
                jb      short _DoContext
                mov     si, [di]
                jz      short ALIGNED   ; byte (not nibble) aligned
                add     dx, dx          ; move data to upper 12 bits
                add     dx, dx
                add     dx, dx
                add     dx, dx
                and     si, 0Fh         ; leave in original low 4 bits
                jmp     short PACKIN
; ---------------------------------------------------------------------------

ALIGNED:                                ; ...
                call    IsFAT32
                jnb     short p_fat
                mov     si, ss:CLUSDATA_HW
                xor     si, [di+2]      ; hw of cluster number
                                        ; offset CLUSSAVE+2
                and     si, 0FFFh
                xor     [di+2], si
                mov     [di], dx
                jmp     short PACKIN2
; ---------------------------------------------------------------------------

p_fat:                                  ; ...
                cmp     word ptr es:[bp+0Dh], 0FF6h ; [ES:BP+DPB.MAX_CLUSTER],4096-10
                                        ; is 16 bit FAT ?
                jnb     short Pack16    ; yes, go clobber original data
                and     si, 0F000h      ; leave in upper 4 bits of original
                and     dh, 0Fh         ; store only 12 bits
                jmp     short PACKIN
; ---------------------------------------------------------------------------

Pack16:                                 ; ...
                xor     si, si          ; no original data

PACKIN:                                 ; ...
                or      si, dx
                mov     [di], si

PACKIN2:                                ; ...
                lds     si, ss:CURBUF
                test    byte ptr [si+5], 40h ; [SI+BUFFINFO.buf_flags],buf_dirty
                jnz     short yesdirty11 ; don't increment dirty count
                inc     ss:DirtyBufferCount
                or      byte ptr [si+5], 40h ; [SI+BUFFINFO.buf_flags],buf_dirty

yesdirty11:                             ; ...
                cmp     ss:CLUSSPLIT, 0
                mov     dx, ss
                mov     ds, dx
                jz      short hurtfat_retn
                push    ax
                push    ds:CLUSTNUM_HW
                push    bx
                push    cx
                mov     ax, ds:CLUSSAVE
                add     si, 24          ; BUFINSIZ
                mov     ds, word ptr ds:CURBUF+2
                mov     [si], ah
                lds     dx, ss:CLUSSEC
                push    ax
                mov     ss:HIGH_SECTOR, ds
                mov     si, ss
                mov     ds, si
                mov     si, 1
                xor     al, al
                call    GETBUFFRB
                pop     ax
                jb      short POPP_RET
                lds     di, ds:CURBUF
                test    byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty
                jnz     short yesdirty12
                inc     ss:DirtyBufferCount
                or      byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty

yesdirty12:                             ; ...
                add     di, 23          ; BUFINSIZ-1
                add     di, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE]
                clc
                mov     [di], al

POPP_RET:                               ; ...
                mov     cx, ss
                mov     ds, cx
                pop     cx
                pop     bx
                pop     ss:CLUSTNUM_HW
                pop     ax
                retn
PACK            endp


; =============== S U B R O U T I N E =======================================


IsFAT32         proc near               ; ...
                cmp     word ptr es:[bp+0Fh], 1 ; [es:bp+DPB.FAT_SIZE]
                jnb     short isfat32eof_2 ; not FAT32
                cmp     word ptr es:[bp+2Fh], 0 ; [es:bp+DPB.LAST_CLUSTER+2]
                jnz     short isfat32eof_1 ; FAT32
                cmp     word ptr es:[bp+2Dh], 0FFF6h ; [es:bp+DPB.LAST_CLUSTER]

isfat32eof_1:                           ; ...
                cmc                     ; cf=1 -> FAT32

isfat32eof_2:                           ; ...
                retn
IsFAT32         endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR MAPCLUSTER

_DoDiv:                                 ; ...
                xchg    ax, di
                xchg    ax, dx
                div     cx
                xchg    ax, di
                div     cx
                jmp     short DivDone
; END OF FUNCTION CHUNK FOR MAPCLUSTER

; =============== S U B R O U T I N E =======================================


MAPCLUSTER      proc near               ; ...

; FUNCTION CHUNK AT A5CE SIZE 00000009 BYTES

                mov     ds:CLUSSPLIT, 0
                push    ax
                push    bx
                push    cx
                push    dx
                push    ds:CLUSTNUM_HW
                mov     ax, bx
                mov     dx, ds:CLUSTNUM_HW
                xor     di, di
                call    IsFAT32
                jnb     short mapcl1    ; not FAT32
                shl     ax, 1
                rcl     dx, 1
                rcl     di, 1
                shl     ax, 1
                rcl     dx, 1
                rcl     di, 1           ; DI:DX:AX = 4*(DX:AX)
                jmp     short Map16     ; 32 bit FAT
; ---------------------------------------------------------------------------

mapcl1:                                 ; ...
                cmp     word ptr es:[bp+0Dh], 0FF6h ; [ES:BP+DPB.MAX_CLUSTER]
                jnb     short mapcl2    ; 16 bit FAT
                shr     dx, 1
                rcr     ax, 1

mapcl2:                                 ; ...
                add     ax, bx
                adc     dx, ds:CLUSTNUM_HW
                adc     di, di

Map16:                                  ; ...
                mov     cx, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE]
                cmp     cx, 512
                jnz     short _DoDiv
                push    ax
                shr     di, 1
                rcr     dx, 1
                rcr     ax, 1
                mov     al, ah          ; 9 bit shift to right
                mov     ah, dl
                mov     dl, dh
                xor     dh, dh
                shr     di, 1
                adc     dh, dh
                xchg    dx, di          ; DI:AX = sector contains requested cluster data
                pop     dx
                and     dx, 1FFh        ; offset in sector

DivDone:                                ; ...
                add     ax, es:[bp+6]   ; [ES:BP+DPB.FIRST_FAT]
                adc     di, 0
                dec     cx              ; CX is sector size - 1
                push    di
                push    ax
                push    dx
                push    cx
                mov     dx, ax
                mov     ds:HIGH_SECTOR, di
                xor     al, al
                mov     si, 1
                call    GETBUFFRB
                pop     cx
                pop     ax
                pop     dx              ; CX is sec siz-1, AX is offset in sec
                pop     bx              ; BX:DX is sector
                jb      short MAP_POP   ; (ds=ss)
                lds     si, ds:CURBUF
                lea     di, [si+18h]    ; [SI+BUFINSIZ]
                add     di, ax
                cmp     ax, cx
                jnz     short MAPRET    ; ds<>ss
                mov     al, [di]
                mov     si, ss
                mov     ds, si
                inc     ds:CLUSSPLIT
                mov     byte ptr ds:CLUSSAVE, al
                mov     word ptr ds:CLUSSEC, dx
                xor     ax, ax          ; 0
                add     dx, 1
                mov     word ptr ds:CLUSSEC+2, bx
                adc     bx, ax          ; adc bx,0
                mov     ds:HIGH_SECTOR, bx
                mov     si, 1
                call    GETBUFFRB
                jb      short MAP_POP   ; (ds=ss)
                lds     si, ds:CURBUF
                lea     di, [si+18h]    ; [SI+BUFINSIZ]
                mov     al, [di]
                mov     di, ss
                mov     ds, di
                mov     byte ptr ds:CLUSSAVE+1, al
                mov     di, offset CLUSSAVE

MAPRET:                                 ; ...
                pop     ss:CLUSTNUM_HW  ; (ds<>ss)
                pop     dx
                pop     cx
                pop     bx
                xor     ax, ax
                call    IsFAT32
                jb      short MapSet
                cmp     word ptr es:[bp+0Dh], 0FF6h ; [ES:BP+DPB.MAX_CLUSTER]
                jnb     short MapSet    ; 16 bit FAT
                mov     ax, bx          ; 12 bit FAT

MapSet:                                 ; ...
                test    al, 1           ; set zero flag if not on boundary
                pop     ax
                retn
; ---------------------------------------------------------------------------

MAP_POP:                                ; ...
                pop     ss:CLUSTNUM_HW  ; (ds=ss)
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                retn
MAPCLUSTER      endp


; =============== S U B R O U T I N E =======================================


FATREAD_SFT     proc near               ; ...
                les     bp, es:[di+7]   ; [ES:DI+SF_ENTRY.sf_devptr]

fatread_gotdpb:                         ; ...
                mov     al, es:[bp+0]   ; [ES:BP+DPB.DRIVE]
                mov     ds:THISDRV, al
                call    GOTDPB          ; Set THISDPB
                call    FAT_GOT_DPB

fatread_sft_retn:                       ; ...
                retn
FATREAD_SFT     endp


; =============== S U B R O U T I N E =======================================


FATREAD_CDS     proc near               ; ...
                push    es
                push    di
                les     bp, es:[di+45h] ; [ES:DI+curdir.devptr]
                call    fatread_gotdpb
                pop     di
                pop     es
                jb      short fatread_sft_retn
                jnz     short NO_CHANGE

MED_CHANGE:                             ;
                mov     ax, 0FFFFh      ; -1
                push    ds
                mov     cl, ds:CDSCOUNT
                xor     ch, ch          ; CX is number of structures
                lds     si, es:[di+45h] ; [ES:DI+curdir.devptr]
                                        ; Find all CDS with this devptr
                les     di, ss:CDSADDR  ; (es:di) = CDS pointer

frcd20:                                 ; ...
                test    byte ptr es:[di+44h], 80h ; [ES:DI+curdir.flags+1],
                                        ; (curdir_isnet>>8)
                jnz     short frcd25
                cmp     si, es:[di+45h] ; [ES:DI+curdir.devptr]
                jnz     short frcd25    ; no match
                mov     bx, ds
                cmp     bx, es:[di+47h] ; [ES:DI+curdir.devptr+2]
                jnz     short frcd25    ; CDS not for this drive
                test    es:[di+49h], ax ; [ES:DI+curdir.ID]
                                        ; If root (0), leave root
                jz      short frcd25    ; = 0
                                        ; PCDOS 7.1 bug (!?) ; Erdogan Tan - 03/03/2024
                                        ; test dword ptr es:[di+49h],-1 ; Win ME
                                        ; jz short frcd25
                test    es:[di+4Bh], ax ; [ES:DI+curdir.ID+2]
                jz      short frcd25    ; leave root (= 0)
                mov     es:[di+4Bh], ax ; else invalid (-1)
                mov     es:[di+49h], ax ; -1

frcd25:                                 ; ...
                add     di, 88          ; add di,curdir.size
                                        ; Point to next CDS
                loop    frcd20
                pop     ds

NO_CHANGE:                              ; ...
                les     bp, ds:THISDPB
                clc
                retn
FATREAD_CDS     endp


; =============== S U B R O U T I N E =======================================


chk_set_first_access proc near          ; ...
                cmp     word ptr es:[bp+0Fh], 0 ; DPB.FAT_SIZE
                jnz     short chk_set_fa_1 ; FAT (FAT12 or FAT16)
                                        ; FAT32
                cmp     word ptr es:[bp+21h], 0FFFFh ; DPB.FREE_CNT_HW
                mov     word ptr es:[bp+21h], 0FFFFh ; High word of free cluster count
                jnz     short chk_set_fa_2

chk_set_fa_1:                           ; ...
                cmp     word ptr es:[bp+1Fh], 0FFFFh ; DPB.FREE_CNT

chk_set_fa_2:                           ; ...
                mov     word ptr es:[bp+1Fh], 0FFFFh ; Count of free clusters, -1 if unknown
                jz      short chk_set_fa_3
                or      byte ptr es:[bp+18h], 1 ; DPB.FIRST_ACCESS

chk_set_fa_3:                           ; ...
                retn
chk_set_first_access endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR FAT_GOT_DPB

FATERR:                                 ; ...
                call    chk_set_first_access ; Err in FAT must force recalc of freespace
                and     di, 0FFh        ; STECODE
                mov     ds:ALLOWED, 18h ; [ALLOWED],Allowed_FAIL+Allowed_RETRY
                mov     ah, 1Ah         ; 2+Allowed_FAIL+Allowed_RETRY
                                        ; (While trying to read FAT)
                mov     al, ds:THISDRV  ; Tell which drive
                call    FATAL1
                les     bp, ds:THISDPB
                cmp     al, 3
                jnz     short FAT_GOT_DPB ; User said retry

FATERR_fail:                            ; ...
                stc                     ; User said FAIL
                retn
; END OF FUNCTION CHUNK FOR FAT_GOT_DPB

; =============== S U B R O U T I N E =======================================


FAT_GOT_DPB     proc near               ; ...

; FUNCTION CHUNK AT A756 SIZE 0000001E BYTES

                push    ss              ; SS is DOSDATA
                pop     ds
                mov     ax, es
                or      ax, bp
                jz      short FATERR_fail
                mov     al, 19
                mov     ah, es:[bp+1]   ; [ES:BP+DPB.UNIT]
                mov     ds:DEVCALL_REQFUNC, 1 ; DEVMDCH
                mov     word ptr ds:DEVCALL_REQLEN, ax
                mov     al, es:[bp+17h] ; [ES:BP+DPB.MEDIA]
                mov     ds:DEVCALL_REQSTAT, 0
                mov     ds:CALLUNIT, al ; [CALLMED]
                push    es
                push    ds
                mov     bx, offset DEVCALL_REQLEN ; offset DEVCALL
                lds     si, es:[bp+13h] ; [ES:BP+DPB.DRIVER_ADDR]
                pop     es
                call    DEVIOCALL2
                push    ss
                pop     ds
                pop     es
                mov     di, ds:DEVCALL_REQSTAT
                or      di, di
                js      short FATERR
                mov     ah, es:[bp+18h] ; [ES:BP+DPB.FIRST_ACCESS]
                mov     al, ds:THISDRV  ; Use physical unit number
                and     ah, 80h         ; izolate (FAT) first access bit
                and     byte ptr es:[bp+18h], 7Fh ; clear first access (FAT) bit 7
                cmp     ds:VOLCHNG_FLAG, al
                jnz     short CHECK_BYT
                mov     ds:VOLCHNG_FLAG, 0FFh ; -1
                jmp     GOGETBPB
; ---------------------------------------------------------------------------

CHECK_BYT:                              ; ...
                or      ah, ds:CALLBR   ; [CALLRBYT]
                js      short NEWDSK
                jz      short CHKBUFFDIRT
                clc
                retn                    ; Media not changed (NZ)
; ---------------------------------------------------------------------------

DISK_CHNG_ERR:                          ; ...
                push    es
                push    bp
                les     bp, es:[bp+13h] ; [ES:BP+DPB.DRIVER_ADDR]
                test    byte ptr es:[bp+5], 8 ; [es:bp+SYSDEV.ATT+1],(DEVOPCL>>8)
                pop     bp
                pop     es
                jz      short FAIL_OPJ2
                push    ds
                push    di
                push    ss
                pop     ds
                mov     ds:ALLOWED, 18h ; Allowed_FAIL+Allowed_RETRY
                push    es
                les     di, dword ptr ds:CALLVIDM ; Get volume ID pointer
                mov     word ptr ds:EXTERRPT+2, es
                pop     es
                mov     word ptr ds:EXTERRPT, di
                mov     ax, 0Fh         ; error_I24_wrong_disk
                mov     ds:READOP, 1    ; Write
                call    HARDERR
                pop     di
                pop     ds
                cmp     al, 3

FAIL_OPJ2:                              ; ...
                jz      short FAIL_OP
                jmp     FAT_GOT_DPB     ; Retry
; ---------------------------------------------------------------------------

CHKBUFFDIRT:                            ; ...
                cmp     ss:DirtyBufferCount, 0 ; any dirty buffers ?
                jz      short NEWDSK    ; no, skip the check
                call    GETCURHEAD      ; get pointer to first buffer

nbuffer:                                ; ...
                cmp     [di+4], al      ; [di+BUFFINFO.buf_ID] ; Unit OK ?
                jnz     short lfnxt     ; no
                test    byte ptr [di+5], 40h ; is the buffer dirty ?
                jz      short lfnxt     ; no, go for next buffer
                push    ss
                clc
                pop     ds
                retn
; ---------------------------------------------------------------------------

FAIL_OP:                                ; ...
                push    ss
                stc
                pop     ds
                retn
; ---------------------------------------------------------------------------

jmp_to_DISK_CHNG_ERR:                   ; ...
                jmp     short DISK_CHNG_ERR
; ---------------------------------------------------------------------------

lfnxt:                                  ; ...
                mov     di, [di]        ; [di+BUFFINFO.buf_next] ; get next buffer
                cmp     ss:FIRST_BUFF_ADDR, di ; is this where we started ?
                jnz     short nbuffer   ; no, check this guy also
                                        ; If no dirty buffers, assume Media changed

NEWDSK:                                 ; ...
                mov     word ptr es:[bp+1Fh], 0FFFFh ; [ES:BP+DPB.FREE_CNT],-1
                                        ; Media changed, must recompute
                cmp     word ptr es:[bp+0Fh], 0 ; [ES:BP+DPB.FAT_SIZE] = 0 for FAT32 fs
                jnz     short newdsk2   ; not FAT32
                mov     word ptr es:[bp+21h], 0FFFFh ; [ES:BP+DPB.FREE_CNT_HW],-1

newdsk2:                                ; ...
                call    GETCURHEAD

nxbuffer:                               ; ...
                cmp     [di+4], al      ; [DI+BUFFINFO.buf_ID],al ; This drive ?
                jnz     short lfnxt2
                test    byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty
                jnz     short jmp_to_DISK_CHNG_ERR
                mov     word ptr [di+4], 20FFh ; [DI+BUFFINFO.buf_ID],
                                        ; (buf_visit*256)+0FFh ; free up
                call    SCANPLACE
                jmp     short skpbuff
; ---------------------------------------------------------------------------

lfnxt2:                                 ; ...
                mov     di, [di]        ; [di+BUFFINFO.buf_next]

skpbuff:                                ; ...
                cmp     di, ss:FIRST_BUFF_ADDR
                jnz     short nxbuffer
                cmp     ss:SC_CACHE_COUNT, 0 ; look ahead buffers ?
                jz      short GOGETBPB  ; no
                cmp     al, ss:CurSC_DRIVE ; same as changed drive ?
                jnz     short GOGETBPB  ; no
                mov     ss:CurSC_DRIVE, 0FFh ; invalidate look ahead buffers

GOGETBPB:                               ; ...
                lds     di, es:[bp+13h] ; [ES:BP+DPB.DRIVER_ADDR]
                test    byte ptr [di+5], 20h ; [DI+SYSDEV.ATT+1],(ISFATBYDEV>>8)
                jnz     short GETFREEBUF
                push    ss
                pop     ds
                mov     word ptr es:[bp+2], 200h ; DPB.SECTOR_SIZE ; bytes per sector
                mov     word ptr es:[bp+6], 1 ; DPB.FIRST_FAT ; starting sector of FATs
                mov     byte ptr es:[bp+8], 1 ; DPB.FAT_COUNT ; number of FATs
                mov     word ptr es:[bp+0Dh], 3 ; DPB.MAX_CLUSTER ; cluster count + 1
                mov     word ptr es:[bp+0Fh], 1 ; DPB.FAT_SIZE ; FAT sectors (16 bit)
                mov     ds:CLUSTNUM_HW, 0 ; high word of cluster number (for UNPACK)
                mov     bx, 2           ; Read the 1st FAT sector into CURBUF
                call    UNPACK

FAIL_OPJ:                               ; ...
                jnb     short unpack_ok
                jmp     FAIL_OP
; ---------------------------------------------------------------------------

unpack_ok:                              ; ...
                lds     di, ds:CURBUF
                jmp     short GOTGETBUF
; ---------------------------------------------------------------------------

GETFREEBUF:                             ; ...
                xor     dx, dx
                lds     di, ss:LoMemBuff
                sub     di, 24          ; sub di,BUFINSIZ
                cmp     ss:BuffInHMA, dl ; 0
                jnz     short GOTGETBUF ; buffer is in HMA
                                        ; use [LowMemBuff] to transfer at first
                push    es
                push    bp
                mov     ss:HIGH_SECTOR, dx ; 0
                call    GETCURHEAD
                call    BUFWRITE
                pop     bp
                pop     es
                jb      short FAIL_OPJ

GOTGETBUF:                              ; ...
                add     di, 24          ; add di,BUFINSIZ
                mov     ss:CALLXAD_2, ds ; [SS:CALLXAD+2]
                mov     ax, ss
                mov     ds, ax
                mov     word ptr ds:CALLBR, di ; [CALLXAD]
                mov     al, 22          ; DBPBHL
                mov     ah, es:[bp+1]   ; [ES:BP+DPB.UNIT]
                mov     ds:DEVCALL_REQFUNC, 2 ; DEVBPB
                mov     word ptr ds:DEVCALL_REQLEN, ax
                mov     ds:DEVCALL_REQSTAT, 0
                mov     al, es:[bp+17h] ; [ES:BP+DPB.MEDIA]
                push    es
                push    ds
                mov     ds:CALLUNIT, al ; [CALLMED]
                mov     bx, offset DEVCALL_REQLEN ; offset DEVCALL
                lds     si, es:[bp+13h] ; [ES:BP+DPB.DRIVER_ADDR]
                                        ; DS:SI Points to device header
                pop     es              ; ES:BX Points to call header
                call    DEVIOCALL2
                pop     es
                mov     di, ss
                mov     ds, di
                mov     di, ds:DEVCALL_REQSTAT
                or      di, di
                jns     short gotgetbuf2 ;
                                        ; have error
                lds     di, dword ptr ds:CALLBR ; [CALLXAD] ; Buffer (data) address
                mov     word ptr [di-20], 0FFh ; byte BUFFINFO.buf_ID = 0FFh ; FREE
                                        ; byte BUFFINFO.buf_flags = 0
                jmp     FATERR
; ---------------------------------------------------------------------------

gotgetbuf2:                             ; ...
                lds     si, dword ptr ds:CALLBPB ; Address of the BPB (DEVCALL offset 18)
                xor     cx, cx          ; 0
                mov     es:[bp+1Dh], cx ; [ES:BP+DPB.NEXT_FREE] = 0
                                        ; recycle scanning pointer
                mov     dx, 4152h       ; 'RA' ; FAT32 extended BPB/DPB signature
                cmp     [si+0Bh], cx    ; BPB.fatsecs ; 16 bit FAT size = 0 for FAT32 fs
                jnz     short gotgetbuf3 ; not FAT32
                mov     es:[bp+39h], cx ; [ES:BP+DPB.FAT32_NXTFREE],0
                mov     es:[bp+3Bh], cx ; [ES:BP+DPB.FAT32_NXTFREE+2],0
                dec     cx              ; -1
                mov     es:[bp+1Fh], cx ; (DPB.FREE_CNT) set free count to -1 (unknown)
                mov     es:[bp+21h], cx
                mov     cx, 4558h       ; 'XE' ; FAT32 extended BPB/DPB signature

gotgetbuf3:                             ; ...
                call    $SETDPB
                lds     di, dword ptr ss:CALLBR ; [SS:CALLXAD] ; Get back buffer pointer
                mov     dx, es:[bp+25h] ; [es:bp+DPB.FSINFO_SECTOR]
                xor     cx, cx          ; 0
                cmp     es:[bp+0Fh], cx ; [es:bp+DPB.FAT_SIZE] ; 16 bit FAT size field
                jz      short gotgetbuf4 ; FAT32 fs
                jmp     gotgetbuf12     ; FAT fs
; ---------------------------------------------------------------------------

gotgetbuf4:                             ; ...
                cmp     dx, 0FFFFh      ; invalid ?
                jnz     short gotgetbuf5 ; no
                jmp     gotgetbuf12     ; skip reading FSINFO sector
; ---------------------------------------------------------------------------

gotgetbuf5:                             ; ...
                mov     ss:HIGH_SECTOR, cx ; 0
                mov     bx, di
                cmp     ss:BuffInHMA, 0
                jz      short gotgetbuf6 ; buffer is in conventional (<=640KB) memory
                lds     bx, ss:LoMemBuff ; use a buffer in conventional memory
                mov     di, bx

gotgetbuf6:                             ; ...
                mov     ss:ALLOWED, 18h ; Allowed_FAIL+Allowed_RETRY
                inc     cx
                push    di
                push    bx
                call    DREAD
                pop     bx
                pop     di
                jb      short gotgetbuf11 ;
                                        ; ds:di = (FSINFO sector) buffer
                                        ; FSI_HeadSig = 41615252h
                cmp     word ptr [di], 5252h ; 'RR' ; check if it is a valid FSINFO sector
                jnz     short gotgetbuf11 ; not valid
                cmp     word ptr [di+2], 4161h ; 'aA' ; (NASM syntax)
                jnz     short gotgetbuf11
                cmp     word ptr [di+484], 7272h ; 'rr' ; FSI_StrucSig = 61417272h
                jnz     short gotgetbuf11
                cmp     word ptr [di+486], 6141h ; 'Aa'
                jnz     short gotgetbuf11 ; not valid
                push    dx              ; valid
                push    bx
                push    cx
                mov     bx, es:[bp+2Fh] ; [es:bp+DPB.LAST_CLUSTER+2]
                mov     cx, es:[bp+2Dh] ; [es:bp+DPB.LAST_CLUSTER]
                mov     ax, [di+488]    ; FSI_FreeCount ; bx:cx = number of clusters + 1
                mov     dx, [di+490]    ; FSI_FreeCount+2
                cmp     dx, bx          ; is Free Count >= (Number of Clusters + 1) ?
                jnz     short gotgetbuf7 ; if yes, it is invalid value (must be 0FFFFFFFFh)
                cmp     ax, cx

gotgetbuf7:                             ; ...
                jnb     short gotgetbuf8 ; yes, invalid value (must be 0FFFFFFFFh)
                mov     es:[bp+1Fh], ax ; no, valid free count
                                        ; save free count into [es:bp+DPB.FREE_CNT]
                mov     es:[bp+21h], dx ; [es:bp+DPB.FREE_CNT+2]

gotgetbuf8:                             ; ...
                mov     ax, [di+492]    ; FSI_Nxt_Free
                mov     dx, [di+494]
                cmp     dx, bx          ; is the next free clust num >= (num of clusters + 1) ?
                jnz     short gotgetbuf9 ; invalid (if dx > bx)
                cmp     ax, cx

gotgetbuf9:                             ; ...
                jnb     short gotgetbuf10 ; invalid
                mov     es:[bp+39h], ax ; save next free (search) cluster number
                mov     es:[bp+3Bh], dx ; into [es:bp+DPB.FAT32_NXTFREE]
                mov     es:[bp+1Dh], ax ; and into [es:bp+DPB.NEXT_FREE] ; low word

gotgetbuf10:                            ; ...
                pop     cx
                pop     bx
                pop     dx

gotgetbuf11:                            ; ...
                cmp     ss:BuffInHMA, 0 ; is buffer in HMA ?
                jnz     short gotgetbuf12 ; yes
                mov     word ptr [di-20], 0FFh ; invalidate buffer (set it as free buffer)

gotgetbuf12:                            ; ...
                cmp     ss:BuffInHMA, 0
                jnz     short gotgetbuf16
                cmp     word ptr es:[bp+6], 1 ; [es:bp+DPB.FIRST_FAT]
                jz      short gotgetbuf13
                mov     word ptr [di-20], 0FFh ; invalidate buffer (set it as free buffer)
                                        ; di = buffer header + 4 (BUFFINFO.buf_ID)

gotgetbuf13:                            ; ...
                mov     al, es:[bp+8]   ; [es:bp+DPB.FAT_COUNT]
                mov     [di-14], al     ; BUFFINFO.buf_wrtcnt ; buffer header address + 10
                mov     ax, es:[bp+0Fh] ; [es:bp+DPB.FAT_SIZE] ; 16 bit FAT size field
                or      ax, ax
                jnz     short gotgetbuf14 ; FAT (FAT12 or FAT16) fs
                                        ; FAT32 fs
                mov     ax, es:[bp+31h] ; [es:bp+DPB.FAT32_SIZE] ; FAT sectors (per one FAT)
                mov     [di-13], ax     ; BUFFINFO.buf_wrtcntinc ; # sectors between each write
                mov     ax, es:[bp+33h] ; [es:bp+DPB.FAT32_SIZE+2]
                jmp     short gotgetbuf15
; ---------------------------------------------------------------------------

gotgetbuf14:                            ; ...
                mov     [di-13], ax     ; BUFFINFO.buf_wrtcntinc
                xor     ax, ax          ; 0

gotgetbuf15:                            ; ...
                mov     [di-15], ax     ; BUFFINFO.buf_wrtcntinc+2 ; hw of sectors per FAT
                                        ; PCDOS 7.1 BUG !? This would be 'mov [di-11],ax'
                                        ; Erdogan Tan - 03/03/2024

gotgetbuf16:                            ; ...
                mov     ax, ss          ; SS is DOSDATA
                mov     ds, ax
                xor     al, al          ; Media changed (Z), Carry clear
                retn
FAT_GOT_DPB     endp


; =============== S U B R O U T I N E =======================================


GETCURHEAD      proc near               ; ...
                lds     di, ss:BufferQueue ; Pointer to the first buffer
                mov     word ptr ss:LastBuffer, 0FFFFh ; -1 ; invalidate last buffer
                mov     ss:FIRST_BUFF_ADDR, di ; save first buffer address
                retn
GETCURHEAD      endp


; =============== S U B R O U T I N E =======================================


SCANPLACE       proc near               ; ...
                push    word ptr [di]   ; [di+BUFFINFO.buf_next]
                call    PLACEBUF
                pop     di
                retn
SCANPLACE       endp


; =============== S U B R O U T I N E =======================================


PLACEBUF        proc near               ; ...
                push    ax
                push    bx
                mov     ax, [di]        ; [DI+BUFFINFO.buf_next]
                mov     bx, word ptr ss:BufferQueue ; bx = offset of head of list
                cmp     ax, bx          ; Buf = last?
                jz      short nret      ; Yes, special case
                cmp     di, bx          ; Buf = first?
                jnz     short not_first
                mov     word ptr ss:BufferQueue, ax ; Yes, special case
                jmp     short nret      ; Continue with repositioning
; ---------------------------------------------------------------------------

not_first:                              ; ...
                push    si
                mov     si, [di+2]      ; [DI+BUFFINFO.buf_prev] ; prior Buf
                mov     [si], ax        ; [SI+BUFFINFO.buf_next]
                xchg    ax, si
                mov     [si+2], ax      ; [SI+BUFFINFO.buf_prev]
                mov     si, [bx+2]      ; [BX+BUFFINFO.buf_prev] ; last buffer
                mov     [bx+2], di      ; [BX+BUFFINFO.buf_prev]
                mov     [si], di        ; [SI+BUFFINFO.buf_next] ; Add Buf to end of list
                mov     [di+2], si      ; [DI+BUFFINFO.buf_prev] ; Update link in Buf too
                mov     [di], bx        ; [DI+BUFFINFO.buf_next]
                pop     si

nret:                                   ; ...
                pop     bx
                pop     ax
                cmp     byte ptr [di+4], 0FFh ; [DI+BUFFINFO.buf_ID],-1 ; Buffer FREE?
                jnz     short pbx       ; -no, jump.
                mov     word ptr ss:BufferQueue, di ; -yes, make it LRU.

pbx:                                    ; ...
                retn
PLACEBUF        endp

; ---------------------------------------------------------------------------

POINTCOMP:                              ; ...
                cmp     si, di
                jnz     short _ret_label
                push    cx
                push    dx
                mov     cx, ds
                mov     dx, es
                cmp     cx, dx
                pop     dx
                pop     cx

_ret_label:                             ; ...
                retn

; =============== S U B R O U T I N E =======================================


GETBUFFR        proc near               ; ...
                xor     si, si

GETBUFFRB:                              ; ...
                mov     ds:PREREAD, ax
                or      si, si
                jz      short getb1
                cmp     word ptr es:[bp+0Fh], 0
                jnz     short getb1     ; not FAT32
                mov     ax, es:[bp+23h] ; [es:bp+DPB.EXT_FLAGS]
                test    al, 80h         ; bit 7 -- 1 means only one FAT is active
                jz      short getb1
                and     ax, 0Fh         ; Active FAT is the one referenced in bits 0-3
                jz      short getb1
                push    dx
                mov     cx, ax          ; Zero based number of active FAT.
                                        ; (Only valid if mirroring is disabled.)
                mul     word ptr es:[bp+33h] ; [es:bp+DPB.FAT32_SIZE+2]
                xchg    ax, cx
                mul     word ptr es:[bp+31h] ; [es:bp+DPB.FAT32_SIZE]
                add     cx, dx
                pop     dx
                add     dx, ax
                adc     ds:HIGH_SECTOR, cx

getb1:                                  ; ...
                mov     al, es:[bp+0]   ; [ES:BP+DPB.DRIVE]
                mov     bx, 0FFFFh      ; -1
                lds     di, ds:LastBuffer ; Get the recency pointer
                mov     cx, ss:HIGH_SECTOR
                cmp     di, 0FFFFh      ; Recency pointer valid?
                jz      short getb5     ; No
                cmp     dx, [di+6]      ; [DI+BUFFINFO.buf_sector]
                jnz     short getb5
                cmp     cx, [di+8]      ; [DI+BUFFINFO.buf_sector+2]
                jnz     short getb5
                cmp     al, [di+4]      ; [DI+BUFFINFO.buf_ID]
                jnz     short getb5
                jmp     getb35
; ---------------------------------------------------------------------------

getb5:                                  ; ...
                lds     di, ss:BufferQueue ; ... CALL GETCURHEAD ...
                mov     word ptr ss:LastBuffer, 0FFFFh
                mov     ss:FIRST_BUFF_ADDR, di

getb10:                                 ; ...
                cmp     dx, [di+6]      ; [DI+BUFFINFO.buf_sector]
                jnz     short getb11    ; wrong sector lo
                cmp     cx, [di+8]      ; [DI+BUFFINFO.buf_sector+2]
                jnz     short getb11    ; wrong sector hi
                cmp     al, [di+4]      ; [DI+BUFFINFO.buf_ID]
                jnz     short getb11    ; Found the requested sector
                jmp     getb25
; ---------------------------------------------------------------------------

getb11:                                 ; ...
                cmp     byte ptr [di+4], 0FFh ; Free buffer ?
                jnz     short getb12    ; no
                mov     bx, di          ; save buffer (offset) addr

getb12:                                 ; ...
                mov     di, [di]        ; [DI+BUFFINFO.BUF_NEXT]
                cmp     di, ss:FIRST_BUFF_ADDR ; back at the front again?
                jnz     short getb10    ; no, continue looking
                cmp     bx, 0FFFFh      ; -1 ; invalid (not a free buffer addr)
                jz      short getb12x
                mov     di, bx          ; restore free buff (header offset) addr
                jmp     short getb13
; ---------------------------------------------------------------------------

getb12x:                                ; ...
                push    cx
                push    si
                push    dx
                push    bp
                push    es
                call    BUFWRITE        ; Write out the dirty buffer
                pop     es
                pop     bp
                pop     dx
                pop     si
                pop     ss:HIGH_SECTOR
                jb      short getb19x   ; if got hard error

getb13:                                 ; ...
                xor     ah, ah          ; initial flags
                cmp     byte ptr ss:PREREAD, ah ; am to Read in the new sector?
                jnz     short getb20    ; no, we're done
                lea     bx, [di+24]     ; LEA BX,[DI+BUFINSIZ]
                mov     cx, 1
                push    si
                push    di
                push    dx
                push    es
                cmp     ss:BuffInHMA, 0 ; is buffers in HMA?
                jz      short getb14    ; no
                push    ds
                push    bx
                lds     bx, ss:LoMemBuff ; Then let's read it into scratch buff

getb14:                                 ; ...
                or      si, si          ; FAT sector ?
                jz      short getb15    ; no
                call    FATSECRD        ; yes
                mov     ah, 2           ; buf_isFAT
                jmp     short getb17    ; Buffer is marked free if read barfs
; ---------------------------------------------------------------------------

getb15:                                 ; ...
                call    DREAD           ; Buffer is marked free if read barfs
                mov     ah, 0           ; Set buf_flags to no type, DO NOT XOR!

getb17:                                 ; ...
                mov     ch, 0
                mov     cl, ss:BuffInHMA ; did we read into scratch buff ?
                jcxz    short getb19    ; no
                mov     cx, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE]
                mov     si, bx
                pop     di
                pop     es
                pushf
                shr     cx, 1
                cld
                cmp     ss:DDMOVE, 0
                jz      short near ptr getb18+1 ; rep movsw (skip 32bit prefix)
                shr     cx, 1

getb18:                                 ; ...
                rep movsd               ; move the contents of scratch buffer
                mov     dx, es
                mov     ds, dx
                popf                    ; Retrieve possible CY from DREAD

getb19:                                 ; ...
                pop     es
                pop     dx
                pop     di
                pop     si

getb19x:                                ; ...
                jb      short getbx

getb20:                                 ; ...
                mov     cx, ss:HIGH_SECTOR
                mov     al, es:[bp+0]   ; [ES:BP+DPB.DRIVE]
                mov     [di+6], dx      ; [DI+BUFFINFO.buf_sector]
                mov     [di+0Fh], bp    ; [DI+BUFFINFO.buf_DPB]
                mov     word ptr [di+11h], es ; [DI+BUFFINFO.buf_DPB+2]
                mov     [di+8], cx      ; [DI+BUFFINFO.buf_sector+2]
                mov     [di+4], ax      ; [DI+BUFFINFO.buf_ID]

getb25:                                 ; ...
                mov     byte ptr [di+0Ah], 1 ; [DI+BUFFINFO.buf_wrtcnt],1
                                        ; Default to not a FAT sector
                xor     ax, ax
                mov     [di+0Dh], ax
                or      si, si          ; FAT sector ?
                jz      short getb30    ; no
                cmp     word ptr es:[bp+0Fh], 0 ; [es:bp+DPB.FAT_SIZE]
                jnz     short getb27    ; not FAT32
                test    word ptr es:[bp+23h], 80h ; [es:bp+DPB.EXT_FLAGS]
                jnz     short getb26    ; bit 7 -- 1 means only one FAT is active
                mov     al, es:[bp+8]   ; [es:bp+DPB.FAT_COUNT]
                mov     [di+0Ah], al    ; [di+BUFFINFO.buf_wrtcnt]

getb26:                                 ; ...
                mov     ax, es:[bp+33h] ; [es:bp+DPB.FAT32_SIZE+2]
                mov     [di+0Dh], ax    ; [di+BUFFINFO.buf_wrtcntinc+2]
                mov     ax, es:[bp+31h] ; [es:bp+DPB.FAT32_SIZE]
                jmp     short getb30
; ---------------------------------------------------------------------------

getb27:                                 ; ...
                mov     al, es:[bp+8]   ; [es:bp+DPB.FAT_COUNT]
                mov     [di+0Ah], al    ; [di+BUFFINFO.buf_wrtcnt]
                mov     ax, es:[bp+0Fh] ; [es:bp+DPB.FAT_SIZE]

getb30:                                 ; ...
                mov     [di+0Bh], ax    ; [di+BUFFINFO.buf_wrtcntinc]
                call    PLACEBUF
                mov     word ptr ss:LastBuffer+2, ds
                mov     word ptr ss:LastBuffer, di

getb35:                                 ; ...
                mov     word ptr ss:CURBUF+2, ds
                mov     word ptr ss:CURBUF, di
                clc

getbx:                                  ; ...
                mov     ax, ss
                mov     ds, ax

getbuffr_retn:                          ; ...
                retn
GETBUFFR        endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


FLUSHBUF        proc near               ; ...
                cmp     al, 0FFh        ; -1
                jnz     short flshbuf_2
                mov     bx, 26

flshbuf_1:                              ; ...
                and     ss:drv_flags_1[bx], 0F7h ; [ss:bx+drive_flags-1],0F7h
                                        ; clear bit 3
                dec     bx              ; backward
                jnz     short flshbuf_1

flshbuf_2:                              ; ...
                call    GETCURHEAD
                test    byte ptr ss:DOS34_FLAG, 4 ; FROM_DISK_RESET
                jnz     short scan_buf_queue
                cmp     ss:DirtyBufferCount, 0
                jz      short end_scan

scan_buf_queue:                         ; ...
                call    CHECKFLUSH
                mov     ah, [di+4]      ; [DI+BUFFINFO.buf_ID]
                cmp     ss:WPERR, ah
                jz      short free_the_buf
                test    byte ptr ss:DOS34_FLAG, 4 ; FROM_DISK_RESET
                jz      short dont_free_the_buf

free_the_buf:                           ; ...
                mov     word ptr [di+4], 0FFh

dont_free_the_buf:                      ; ...
                mov     di, [di]        ; [DI+BUFFINFO.buf_next]
                cmp     di, ss:FIRST_BUFF_ADDR
                jnz     short scan_buf_queue

end_scan:                               ; ...
                push    ss
                pop     ds
                cmp     ds:FAILERR, 0
                jz      short flushbuf_retn
                stc

flushbuf_retn:                          ; ...
                retn
FLUSHBUF        endp


; =============== S U B R O U T I N E =======================================


CHECKFLUSH      proc near               ; ...
                mov     ah, 0FFh        ; -1
                cmp     [di+4], ah      ; [DI+BUFFINFO.buf_ID]
                jz      short getbuffr_retn ; Skip free buffer, carry clear
                cmp     ah, al
                jz      short DOBUFFER  ; do this buffer
                cmp     al, [di+4]      ; [DI+BUFFINFO.buf_ID]
                clc
                jnz     short getbuffr_retn ; Buffer not for this unit or SFT
                xor     bx, bx
                mov     bl, al
                test    ss:drive_flags[bx], 8 ; bit 3
                jnz     short getbuffr_retn

DOBUFFER:                               ; ...
                test    byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty
                jz      short getbuffr_retn
                push    ax
                push    word ptr [di+4] ; [DI+BUFFINFO.buf_ID]
                call    BUFWRITE
                pop     ax
                jb      short LEAVE_BUF ; Leave buffer marked free (lost)
                and     ah, 0BFh        ; ~buf_dirty  ; Buffer is clean, clears carry
                mov     [di+4], ax      ; [DI+BUFFINFO.buf_ID]

LEAVE_BUF:                              ; ...
                pop     ax

checkflush_retn:                        ; ...
                retn
CHECKFLUSH      endp


; =============== S U B R O U T I N E =======================================


BUFWRITE        proc near               ; ...
                mov     ax, 0FFh
                xchg    ax, [di+4]      ; [DI+BUFFINFO.buf_ID]
                cmp     al, 0FFh
                jz      short checkflush_retn
                test    ah, 40h         ; buf_dirty
                jz      short checkflush_retn
                call    DEC_DIRTY_COUNT
                cmp     al, ss:WPERR
                jz      short checkflush_retn
                les     dx, [di+6]      ; [DI+BUFFINFO.buf_sector]
                lea     bx, [di+24]     ; [DI+BUFINSIZ]
                mov     cl, [di+10]     ; [DI+BUFFINFO.buf_wrtcnt]
                mov     ch, 0
                mov     ss:HIGH_SECTOR, es
                les     bp, [di+15]     ; [DI+BUFFINFO.buf_DPB]
                mov     ss:ALLOWED, 18h ; Allowed_RETRY+Allowed_FAIL
                test    ah, 8           ; buf_isDATA
                jz      short NO_IGNORE
                or      ss:ALLOWED, 20h ; Allowed_IGNORE

NO_IGNORE:                              ; ...
                mov     si, [di+13]     ; [DI+BUFFINFO.buf_wrtcntinc+2]
                mov     ax, [di+11]     ; [DI+BUFFINFO.buf_wrtcntinc]
                push    di
                xor     di, di
                push    ds
                push    bx

WRTAGAIN:                               ; ...
                push    si              ; SI:AX = FAT size (in sectors)
                push    ss:HIGH_SECTOR
                push    di
                push    cx
                push    ax
                mov     cx, 1
                push    bx
                push    dx
                push    ds
                cmp     ss:BuffInHMA, 0
                jz      short NBUFFINHMA
                push    cx
                push    es
                mov     si, bx
                mov     cx, es:[bp+2]   ; [es:bp+DPB.SECTOR_SIZE]
                les     di, ss:LoMemBuff
                shr     cx, 1
                mov     bx, di
                cld
                cmp     ss:DDMOVE, 0
                jz      short near ptr bufwr_movsd+1 ; rep movsw
                shr     cx, 1

bufwr_movsd:                            ; ...
                rep movsd
                push    es
                pop     ds
                pop     es
                pop     cx

NBUFFINHMA:                             ; ...
                call    DWRITE
                pop     ds
                pop     dx
                pop     bx
                pop     ax
                pop     cx
                pop     di
                pop     ss:HIGH_SECTOR
                pop     si
                jb      short NOSET
                mov     di, 1

NOSET:                                  ; ...
                add     dx, ax
                adc     ss:HIGH_SECTOR, si
                loop    WRTAGAIN
                pop     bx
                pop     ds
                sub     di, 1
                pop     di
                retn
BUFWRITE        endp


; =============== S U B R O U T I N E =======================================


null_sub        proc near               ; ...
                retn                    ; SET_RQ_SC_PARMS
null_sub        endp


; =============== S U B R O U T I N E =======================================


SET_BUF_DIRTY   proc near               ; ...
                test    byte ptr es:[di+5], 40h ; [ES:DI+BUFFINFO.buf_flags],buf_dirty
                jnz     short yesdirty2
                or      byte ptr es:[di+5], 40h ; [ES:DI+BUFFINFO.buf_flags],buf_dirty
SET_BUF_DIRTY   endp


; =============== S U B R O U T I N E =======================================


INC_DIRTY_COUNT proc near               ; ...
                inc     ss:DirtyBufferCount

yesdirty2:                              ; ...
                retn
INC_DIRTY_COUNT endp


; =============== S U B R O U T I N E =======================================


DEC_DIRTY_COUNT proc near               ; ...
                cmp     ss:DirtyBufferCount, 0
                jz      short ddcx
                dec     ss:DirtyBufferCount

ddcx:                                   ; ...
                retn
DEC_DIRTY_COUNT endp

; ---------------------------------------------------------------------------

$WAIT:                                  ; ...
                xor     ax, ax
                xchg    ax, ss:exit_code
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

$EXEC:                                  ; ...
                mov     ss:A20OFF_COUNT, 0
                cmp     al, 5           ; is this ExecReady call ?
                jnz     short Exec_@f   ; no, continue
                pop     cx              ; change ret address to LeaveDOS
                mov     cx, offset LeaveDOS
                push    cx

Exec_@f:                                ; ...
                push    bp
                mov     bp, sp
                sub     sp, 29
                cmp     al, 5           ; only 0, 1, 3 or 5 are allowed
                jbe     short Exec_Check_2

Exec_Bad_Fun:                           ; ...
                call    set_exerr_locus_unk ; mov byte [ss:EXTERR_LOCUS],errLOC_Unk ; 1
                mov     al, 1           ; error_invalid_function

Exec_Ret_Err:                           ; ...
                mov     sp, bp
                pop     bp
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

ExecReadyJ:                             ; ...
                call    ExecReady
                jmp     norm_ovl        ; do a Leave & xfer sysret_OK
; ---------------------------------------------------------------------------

Exec_Check_2:                           ; ...
                cmp     al, 2
                jz      short Exec_Bad_Fun
                cmp     al, 4           ; 2 & 4 are not allowed
                jz      short Exec_Bad_Fun
                cmp     al, 5
                jz      short ExecReadyJ ; SET EXECUTION STATE
                mov     [bp-4], bx      ; Exec_BlkL,BX ; stash args
                mov     word ptr [bp-2], es ; Exec_BlkH,ES
                mov     [bp-5], al      ; Exec_Func,AL
                mov     byte ptr [bp-6], 0 ; Exec_Load_High,0
                mov     [bp-26], dx     ; ExecNameL,DX ; set up length of exec name
                mov     word ptr [bp-24], ds ; ExecNameH,DS
                mov     si, dx          ; move pointer to convenient place
                call    DStrLen
                mov     [bp-22], cx     ; ExecNameLen,CX ; save length
                mov     al, ss:AllocMethod ; save alloc method
                mov     ss:ALLOCMSAVE, al
                mov     al, 0A0h        ; Access mode bits: (0 to 2)
                                        ; 000  read access
                                        ;
                                        ; Sharing mode bits: (4 to 6)
                                        ; 010  deny others write access
                                        ;
                                        ; bit 7 - private
                push    bp
                or      ss:DOS_FLAG, 1  ; EXECOPEN
                push    ds
                push    dx
                call    $OPEN
                pop     dx
                pop     ds
                jnb     short Exec_Open_Ok
                xor     al, al
                call    $OPEN

Exec_Open_Ok:                           ; ...
                pushf
                and     ss:DOS_FLAG, 0FEh ; ~EXECOPEN ; reset flag
                popf
                pop     bp
                jb      short Exec_Ret_Err
                mov     [bp-8], ax      ; Exec_FH,AX
                mov     bx, ax
                xor     al, al
                call    $IOCTL
                jb      short Exec_BombJ
                test    dl, 80h         ; devid_ISDEV
                jz      short Exec_Check_Environ
                mov     al, 2           ; error_file_not_found

Exec_BombJ:                             ; ...
                jmp     Exec_Bomb
; ---------------------------------------------------------------------------

BadEnv:                                 ; ...
                mov     al, 0Ah         ; error_bad_environment
                jmp     Exec_Bomb
; ---------------------------------------------------------------------------

Exec_Check_Environ:                     ; ...
                mov     word ptr [bp-18], 0 ; Exec_Load_Block,0
                mov     word ptr [bp-14], 0 ; Exec_Environ,0
                test    byte ptr [bp-5], 2 ; Exec_Func,exec_func_overlay
                jnz     short Exec_Read_Header
                lds     si, [bp-4]      ; Exec_Blk ; get block
                mov     ax, [si]        ; [SI+EXEC1.ENVIRON] ; address of environ
                or      ax, ax
                jnz     short Exec_Scan_Env
                mov     ds, ss:CurrentPDB
                mov     ax, ds:44       ; [PDB.ENVIRON]
                or      ax, ax
                jz      short Exec_Read_Header

Exec_Scan_Env:                          ; ...
                mov     es, ax
                xor     di, di
                mov     cx, 8000h       ; at most 32k of environment
                xor     al, al

Exec_Get_Environ_Len:                   ; ...
                repne scasb             ; find that nul byte
                jnz     short BadEnv
                dec     cx              ; Dec CX for the next nul byte test
                js      short BadEnv    ; gone beyond the end of the environment
                scasb                   ; is there another nul byte?
                jnz     short Exec_Get_Environ_Len ; no, scan some more
                push    di
                lea     bx, [di+11h]    ; LEA BX,[DI+0Fh+2]
                add     bx, [bp-22]     ; ExecNameLen ; BX <- length of environment
                                        ; remember argv[0] length
                                        ; round up and remember argc
                mov     cl, 4
                shr     bx, cl          ; number of paragraphs needed
                push    es
                call    $ALLOC          ; can we get the space?
                pop     ds
                pop     cx
                jnb     short Exec_Save_Environ
                jmp     short Exec_No_Mem ; nope... cry and sob
; ---------------------------------------------------------------------------

Exec_Save_Environ:                      ; ...
                mov     es, ax
                mov     [bp-14], ax     ; Exec_Environ,AX  ; save him for a rainy day
                xor     si, si
                mov     di, si
                rep movsb               ; copy the environment
                xchg    ax, cx
                inc     ax
                stosw
                lds     si, [bp-26]     ; lds SI,ExecName
                mov     cx, [bp-22]     ; mov CX,ExecNameLen
                rep movsb

Exec_Read_Header:                       ; ...
                push    ss
                pop     ds
                mov     cx, 26          ; exec_header_len ; header size
                mov     dx, offset exec_signature
                push    es
                push    ds
                call    ExecRead
                pop     ds
                pop     es
                jb      short Exec_Bad_File
                or      ax, ax
                jz      short Exec_Bad_File
                cmp     ax, 26          ; exec_header_len
                                        ; did we read the right number?
                jnz     short Exec_Com_Filej ;
                                        ; yep... continue
                test    ds:exec_max_BSS, 0FFFFh ; -1 ; indicate load high?
                jnz     short Exec_Check_Sig
                mov     byte ptr [bp-6], 0FFh ; mov Exec_Load_High,-1

Exec_Check_Sig:                         ; ...
                mov     ax, ds:exec_signature
                cmp     ax, 5A4Dh       ; 'MZ' ; exe_valid_signature
                jz      short Exec_Save_Start ; assume com file if no signature
                cmp     ax, 4D5Ah       ; 'ZM' ; exe_valid_old_signature
                jz      short Exec_Save_Start

Exec_Com_Filej:                         ; ...
                jmp     Exec_Com_File
; ---------------------------------------------------------------------------

Exec_Save_Start:                        ; ...
                mov     ax, ds:exec_pages ; get 512-byte pages
                mov     cl, 5           ; convert to paragraphs
                shl     ax, cl
                sub     ax, ds:exec_par_dir ; AX = size in paragraphs
                mov     [bp-12], ax     ; mov Exec_Res_Len_Para,AX
                test    byte ptr [bp-5], 2 ; test Exec_Func,exec_func_overlay
                jz      short Exec_Allocate ; allocation of space
                les     di, [bp-4]      ; les DI,Exec_Blk
                push    es
                les     ax, es:[di]     ; les ax,[ES:DI+EXEC3.load_addr]
                mov     [bp-20], ax     ; mov Exec_DMA,AX
                mov     word ptr [bp-10], es ; mov Exec_Rel_Fac,ES
                pop     es
                jmp     Exec_Find_Res
; ---------------------------------------------------------------------------

Exec_No_Mem:                            ; ...
                mov     al, 8           ; error_not_enough_memory
                jmp     short Exec_Bomb
; ---------------------------------------------------------------------------

Exec_Bad_File:                          ; ...
                mov     al, 0Bh         ; error_bad_format

Exec_Bomb:                              ; ...
                mov     bx, [bp-8]      ; mov BX,Exec_FH
                call    Exec_Dealloc
                call    LCritDisk       ; call LCritMEM
                push    ax
                push    bp
                call    $CLOSE
                pop     bp
                pop     ax
                jmp     Exec_Ret_Err
; ---------------------------------------------------------------------------

Exec_Chk_Mem:                           ; ...
                mov     al, ss:AllocMethod ; save current alloc method in ax
                mov     bl, ss:ALLOCMSAVE
                mov     ss:AllocMethod, bl ; restore original allocmethod
                test    bl, 40h         ; HIGH_ONLY
                jnz     short Exec_No_Mem ; no space in UMBs. Quit
                test    al, 40h         ; HIGH_ONLY
                jz      short Exec_No_Mem ; no memory
                mov     ax, ss:SAVE_AX
                jmp     short Exec_Norm_Alloc ; Try again
; ---------------------------------------------------------------------------

Exec_Allocate:                          ; ...
                xor     bx, bx
                mov     [bp-29], bl     ; mov Exec_NoStack,bl ; 0
                cmp     ds:exec_SS, bx  ; is there a stack seg ?
                jnz     short ea1       ; yes, continue normal processing
                cmp     ds:exec_SP, bx  ; is there a stack ptr ?
                jnz     short ea1       ; yes, continue normal processing
                inc     byte ptr [bp-29] ; inc Exec_NoStack
                cmp     ax, 0FF0h       ; 1000h-10h ; Q: is this >= 64K-256 bytes
                jnb     short ea1       ; Y: don't set Exec_SP
                add     ax, 10h         ; add 10h paras to mem requirement

ea1:                                    ; ...
                test    ds:AllocMethod, 80h ; HIGH_FIRST
                                        ; Q: is the alloc strat high_first
                jz      short Exec_Norm_Alloc ; N: normal allocate
                                        ; Y: set high_only bit
                or      ds:AllocMethod, 40h ; HIGH_ONLY

Exec_Norm_Alloc:                        ; ...
                mov     ds:SAVE_AX, ax  ; save ax for possible 2nd
                                        ; attempt at allocating memory
                mov     bx, 0FFFFh      ; see how much room in arena
                push    ds
                call    $ALLOC          ; should have carry set and BX has max
                pop     ds
                mov     ax, ds:SAVE_AX
                add     ax, 10h         ; room for header
                cmp     bx, 11h         ; enough room for a header
                jb      short Exec_Chk_Mem
                cmp     ax, bx          ; is there enough for bare image?
                ja      short Exec_Chk_Mem
                test    byte ptr [bp-6], 0FFh ; test Exec_Load_High,-1
                jnz     short Exec_BX_Max ; load high, use max
                add     ax, ds:exec_min_BSS ; go for min allocation
                jb      short Exec_Chk_Mem
                cmp     ax, bx          ; enough space?
                ja      short Exec_Chk_Mem ; nope...
                sub     ax, ds:exec_min_BSS
                add     ax, ds:exec_max_BSS ; go for the MAX
                jb      short Exec_BX_Max
                cmp     ax, bx
                jbe     short Exec_Got_Block

Exec_BX_Max:                            ; ...
                mov     ax, bx

Exec_Got_Block:                         ; ...
                push    ds
                mov     bx, ax
                mov     [bp-10h], bx    ; mov Exec_Size,BX
                call    $ALLOC          ; get the space
                pop     ds
                jnb     short ea0
                jmp     Exec_Chk_Mem
; ---------------------------------------------------------------------------

ea0:                                    ; ...
                mov     cl, ds:ALLOCMSAVE
                mov     ds:AllocMethod, cl ; restore allocmethod
                cmp     byte ptr [bp-29], 0 ; cmp Exec_NoStack,0
                jz      short ea2
                cmp     bx, 1000h       ; Q: >= 64K memory block
                jnb     short ea2       ; Y: Exec_SP = 0
                mov     cl, 4
                shl     bx, cl          ; get byte offset
                sub     bx, 100h        ; take care of PSP
                mov     ds:exec_SP, bx  ; Exec_SP = top of block

ea2:                                    ; ...
                mov     [bp-18], ax     ; mov Exec_Load_Block,AX
                add     ax, 10h
                test    byte ptr [bp-6], 0FFh ; test Exec_Load_High,-1
                jz      short Exec_Use_AX ; use ax for load info
                add     ax, [bp-16]     ; add AX,Exec_Size ; go to end
                sub     ax, [bp-12]     ; sub AX,Exec_Res_Len_Para
                                        ; drop off header
                sub     ax, 10h         ; drop off pdb

Exec_Use_AX:                            ; ...
                mov     [bp-10], ax     ; mov Exec_Rel_Fac,AX ; new segment
                mov     [bp-20], ax     ; mov Exec_DMA,AX ; beginning of dma

Exec_Find_Res:                          ; ...
                mov     dx, [bp-20]     ; mov DX,Exec_DMA
                mov     [bp-28], dx     ; mov Exec_DMA_Save,DX
                mov     dx, ds:exec_par_dir
                push    dx
                mov     cl, 4
                shl     dx, cl          ; low word of location
                pop     ax
                mov     cl, 12
                shr     ax, cl          ; high word of location
                mov     cx, ax          ; CX <- high
                mov     bx, [bp-8]      ; mov BX,Exec_FH
                push    ds
                xor     al, al
                call    $LSEEK          ; Seek to resident
                pop     ds
                jnb     short Exec_Big_Read ; Read resident into memory
                jmp     Exec_Bomb
; ---------------------------------------------------------------------------

Exec_Big_Read:                          ; ...
                mov     bx, [bp-12]     ; mov BX,Exec_Res_Len_Para
                cmp     bx, 1000h       ; Too many bytes to read?
                jb      short Exec_Read_OK
                mov     bx, 0FE0h       ; Max in one chunk FE00 bytes

Exec_Read_OK:                           ; ...
                sub     [bp-12], bx     ; sub Exec_Res_Len_Para,BX
                                        ; We read (soon) this many
                push    bx
                mov     cl, 4
                shl     bx, cl          ; Get count in bytes from paras
                mov     cx, bx          ; Count in correct register
                push    ds
                mov     ds, word ptr [bp-20] ; mov DS,Exec_DMA ; Set up read buffer
                xor     dx, dx
                push    cx
                call    ExecRead
                pop     cx              ; Get old count to verify
                pop     ds
                jb      short Exec_Bad_FileJ
                cmp     cx, ax          ; Did we read enough?
                pop     bx              ; Get paragraph count back
                jz      short ExecCheckEnd ; and do reloc if no more to read
                sub     cx, ax
                cmp     cx, 512
                jnb     short Exec_Bad_FileJ ; If we are off by 512 bytes or more
                                        ; then the header lied and we have an error

ExecCheckEnd:                           ; ...
                add     [bp-20], bx     ; add Exec_DMA,BX ; Bump dma address
                test    word ptr [bp-12], 0FFFFh ; test Exec_Res_Len_Para,-1
                jnz     short Exec_Big_Read

exec_do_reloc:                          ;
                mov     cx, [bp-10]     ; mov CX,Exec_Rel_Fac
                mov     ax, ds:exec_SS  ; get initial SS
                add     ax, cx          ; and relocate him
                mov     ds:exec_init_SS, ax
                mov     ax, ds:exec_SP
                mov     ds:exec_init_SP, ax
                les     ax, dword ptr ds:exec_IP
                mov     ds:exec_init_IP, ax
                mov     ax, es
                add     ax, cx          ; relocated...
                mov     ds:exec_init_CS, ax
                xor     cx, cx
                mov     dx, ds:exec_rle_table
                mov     bx, [bp-8]      ; mov BX,Exec_FH
                push    ds
                xor     ax, ax
                call    $LSEEK
                pop     ds
                jnb     short exec_get_entries

Exec_Bad_FileJ:                         ; ...
                jmp     Exec_Bad_File
; ---------------------------------------------------------------------------

exec_get_entries:                       ; ...
                mov     dx, ds:exec_rle_count ; Number of entries left

exec_read_reloc:                        ; ...
                push    dx
                mov     dx, offset OPENBUF
                mov     cx, 396         ; ((Exec_Internal_Buffer_Size)/4)*4
                                        ; (397>>2)<<2
                push    ds
                call    ExecRead
                pop     es
                pop     dx
                jb      short Exec_Bad_FileJ
                mov     cx, 99          ; (Exec_Internal_Buffer_Size)/4
                                        ; (397>>2)
                mov     di, offset OPENBUF ; mov DI,Exec_Internal_Buffer
                mov     si, [bp-10]     ; mov SI,Exec_Rel_Fac
                                        ; Relocate a single address

exec_reloc_one:                         ; ...
                or      dx, dx          ; Any more entries?
                jz      short Exec_Set_PDBJ ; no
                lds     bx, es:[di]     ; Get ra/sa of entry
                mov     ax, ds          ; Relocate address of item
                add     ax, [bp-28]     ; add AX,Exec_DMA_Save
                mov     ds, ax
                add     [bx], si
                add     di, 4
                dec     dx
                loop    exec_reloc_one  ; End of internal buffer?
                push    es
                pop     ds
                jmp     short exec_read_reloc ; Read in the next
                                        ; piece of the relocation table
; ---------------------------------------------------------------------------

Exec_Set_PDBJ:                          ; ...
                push    es              ; determine if this is a buggy exe packed file
                                        ; and if so patch in the right code
                push    ax
                push    cx
                mov     es, word ptr [bp-28] ; mov es,Exec_DMA_Save ; load segment
                mov     ax, ss:exec_init_CS
                mov     cx, ss:exec_init_IP
                call    ss:FixExePatch
                call    ss:Rational386PatchPtr
                pop     cx
                pop     ax
                pop     es
                jmp     Exec_Set_PDB
; ---------------------------------------------------------------------------

Exec_No_Memj:                           ; ...
                jmp     Exec_No_Mem
; ---------------------------------------------------------------------------

Exec_Com_File:                          ; ...
                test    byte ptr [bp-5], 2 ; test Exec_Func,exec_func_overlay
                jz      short Exec_Alloc_Com_File
                lds     si, [bp-4]      ; lds SI,Exec_Blk ; get arg block
                lodsw                   ; get load address
                mov     [bp-20], ax     ; mov Exec_DMA,AX
                mov     ax, 0FFFFh
                jmp     short Exec_Read_Block ; read it all!
; ---------------------------------------------------------------------------

Exec_Chk_Com_Mem:                       ; ...
                mov     al, ss:AllocMethod ; save current alloc method in ax
                mov     bl, ss:ALLOCMSAVE
                mov     ss:AllocMethod, bl ; restore original allocmethod
                test    bl, 40h         ; HIGH_ONLY
                                        ; Q: was the HIGH_ONLY bit already set
                jnz     short Exec_No_Memj ; Y: no space in UMBs. Quit
                                        ; N: continue
                test    al, 40h         ; HIGH_ONLY
                                        ; Q: did we set the HIGH_ONLY bit
                jz      short Exec_No_Memj ; N: no memory
                mov     ax, [bp-18]     ; mov ax,Exec_Load_Block
                                        ; ax = block we just allocated
                xor     bx, bx          ; bx => free arena
                call    ChangeOwner     ; free this block
                jmp     short Exec_Norm_Com_Alloc
; ---------------------------------------------------------------------------

Exec_Alloc_Com_File:                    ; ...
                test    ss:AllocMethod, 80h ; HIGH_FIRST
                                        ; Q: is the alloc strat high_first
                jz      short Exec_Norm_Com_Alloc ; N: normal allocate
                                        ; Y: set high_only bit
                or      ss:AllocMethod, 40h ; HIGH_ONLY

Exec_Norm_Com_Alloc:                    ; ...
                mov     bx, 0FFFFh
                call    $ALLOC          ; largest piece available as error
                or      bx, bx
                jz      short Exec_Chk_Com_Mem
                mov     [bp-16], bx     ; mov Exec_Size,BX
                                        ; save size of allocation block
                push    bx
                call    $ALLOC          ; largest piece available
                pop     bx              ; get size of block...
                mov     [bp-18], ax     ; mov Exec_Load_Block,AX
                add     ax, 10h         ; increment for header
                mov     [bp-20], ax     ; mov Exec_DMA,AX
                xor     ax, ax          ; presume 64K read...
                cmp     bx, 1000h       ; 64k or more in block?
                jnb     short Exec_Read_Com ; yes, read only 64k
                mov     ax, bx          ; convert size to bytes
                mov     cl, 4
                shl     ax, cl
                cmp     ax, 200h        ; enough memory for PSP and stack?
                jbe     short Exec_Chk_Com_Mem ; jump if not
                sub     ax, 100h        ; size of the block is < 64K
                                        ; reserve 256 bytes for stack

Exec_Read_Com:                          ; ...
                sub     ax, 100h        ; remember size of psp

Exec_Read_Block:                        ; ...
                push    ax              ; save number to read
                mov     bx, [bp-8]      ; mov BX,Exec_FH ; of com file
                xor     cx, cx          ; but seek to 0:0
                xor     ax, ax          ; seek relative to beginning
                cwd
                call    $LSEEK          ; back to beginning of file
                pop     cx              ; number to read
                mov     ds, word ptr [bp-20] ; mov DS,Exec_DMA
                xor     dx, dx
                push    cx
                call    ExecRead
                pop     si              ; get number of bytes to read
                jnb     short OkRead
                jmp     Exec_Bad_File
; ---------------------------------------------------------------------------

OkRead:                                 ; ...
                cmp     ax, si          ; did we read them all?
                jnz     short OkRead2   ; no
                jmp     Exec_Chk_Com_Mem
; ---------------------------------------------------------------------------

OkRead2:                                ; ...
                mov     bl, ss:ALLOCMSAVE
                mov     ss:AllocMethod, bl ; restore alloc method
                test    byte ptr [bp-5], 2 ; test Exec_Func,exec_func_overlay
                jnz     short Exec_Set_PDB ; no starto, chumo!
                mov     ax, [bp-20]     ; mov AX,Exec_DMA
                sub     ax, 10h
                mov     ss:exec_init_CS, ax
                mov     ss:exec_init_IP, 100h ; initial IP is 100h
                add     si, 0FEh        ; SI is AT MOST FF00h.
                                        ; Add FE to account for PSP
                                        ; word of 0 on stack.
                cmp     si, 0FFFEh      ; Q: was there >= 64K available
                jz      short Exec_St_Ok ; Y: stack is fine
                add     si, 100h        ; N: add the xtra 100h for stack

Exec_St_Ok:                             ; ...
                mov     ss:exec_init_SP, si ; max value for read is also SP!
                mov     ss:exec_init_SS, ax
                mov     ds, ax
                mov     word ptr [si], 0 ; 0 for return
                call    ss:ChkCopyProt  ; We now determine if this is a Copy Protected App.
                                        ; If so the A20OFF_COUNT is set to 6.
                                        ; Note that ChkCopyProt will point to a ret if
                                        ; DOS is loaded low. Also DS contains the load segment.

Exec_Set_PDB:                           ; ...
                mov     bx, [bp-8]      ; mov BX,Exec_FH ; we are finished with the file.
                call    Exec_Dealloc
                push    bp
                call    $CLOSE          ; release the jfn
                pop     bp
                call    Exec_Alloc
                test    byte ptr [bp-5], 2 ; test Exec_Func,exec_func_overlay
                jz      short Exec_Build_Header
                call    Scan_Execname
                call    Scan_Special_Entries
                cmp     ss:DriverLoad, 0 ; was Sysinit processing done?
                jz      short norm_ovl  ; yes, no special handling
                push    si
                push    es
                les     si, dword ptr ss:BiosDataPtr ; get ptr to BIOS data block
                cmp     byte ptr es:[si], 0 ; in Sysinit?
                jz      short sysinit_done ; no, Sysinit is finished
                mov     es, ss:CurrentPDB ; es = current PSP (Sysinit PSP)
                push    ss:SPECIAL_VERSION
                pop     word ptr es:40h ; [es:PDB.Version] ; store lie version in Sysinit PSP
                jmp     short setver_done
; ---------------------------------------------------------------------------

sysinit_done:                           ; ...
                mov     ss:DriverLoad, 0 ; Sysinit done,special handling off

setver_done:                            ; ...
                pop     es
                pop     si

norm_ovl:                               ; ...
                mov     sp, bp
                pop     bp
                jmp     SYS_RET_OK      ; overlay load -> done
; ---------------------------------------------------------------------------

Exec_Build_Header:                      ; ...
                mov     dx, [bp-18]     ; mov DX,Exec_Load_Block
                mov     si, 1           ; ARENA.OWNER ; pointer to owner field
                mov     ax, [bp-14]     ; mov AX,Exec_Environ ; get environ pointer
                or      ax, ax
                jz      short No_Owner  ; no environment
                dec     ax              ; point to header
                mov     ds, ax
                mov     [si], dx        ; assign ownership

No_Owner:                               ; ...
                mov     ax, [bp-18]     ; mov ax,Exec_Load_Block
                                        ; get load block pointer
                dec     ax
                mov     ds, ax          ; point to header
                mov     [si], dx        ; assign ownership
                push    ds
                pop     es
                mov     di, 8           ; ARENA.NAME ; ES:DI points to destination
                call    Scan_Execname   ; parse execname
                                        ; ds:si->name, cx=name length
                push    cx              ; save for fake version
                push    si              ; save for fake version

MoveName:                               ; ...
                lodsb                   ; get char
                cmp     al, 2Eh ; '.'   ; is '.', may be name.exe
                jz      short Mem_Done  ; no, move to header
                stosb                   ; move char
                cmp     di, 16          ; ARENAHEADERSIZE ; end of mem arena block?
                jnb     short Mem_Done  ; jump if so
                loop    MoveName        ; continue

Mem_Done:                               ; ...
                xor     al, al          ; make ASCIIZ
                cmp     di, 16          ; ARENAHEADERSIZE ; if not all filled
                jnb     short Fill8
                stosb

Fill8:                                  ; ...
                pop     si              ; ds:si -> file name
                pop     cx
                call    Scan_Special_Entries
                push    dx
                mov     si, [bp-16]     ; mov SI,Exec_Size
                add     si, dx
                call    $DUP_PDB        ; ES is now PDB
                pop     dx
                push    word ptr [bp-14] ; push Exec_Environ
                pop     word ptr es:2Ch ; pop word [ES:PDB.ENVIRON]
                push    ss:SPECIAL_VERSION ; Set the DOS version number to ..
                pop     word ptr es:40h ; pop word [ES:PDB.Version]
                                        ; .. to be used for this application
                lds     si, [bp-4]      ; lds SI,Exec_Blk ; get the block
                push    ds
                push    si
                lds     si, [si+6]      ; lds SI,[SI+EXEC0.5C_FCB] ; get the 5c fcb
                mov     cx, 12          ; copy drive, name and ext
                push    cx
                mov     di, 5Ch
                mov     bl, [si]
                rep movsb               ; DI = 5Ch + 12 = 5Ch + 0Ch = 68h
                xchg    ax, cx          ; zero extent, etc for CPM
                stosw
                stosw
                pop     cx              ; get block
                pop     si
                pop     ds
                push    ds              ; save (again)
                push    si
                lds     si, [si+0Ah]    ; lds SI,[SI+EXEC0.6C_FCB] ; get 6C FCB
                mov     bh, [si]        ; do same as above
                rep movsb
                stosw
                stosw
                pop     si              ; get block (last time)
                pop     ds
                lds     si, [si+2]      ; lds SI,[SI+EXEC0.COM_LINE] ; command line
                or      cl, 80h
                mov     di, cx
                rep movsb               ; Wham!
                dec     cl              ; get 0FFh in CL
                mov     al, bh
                xor     bh, bh
                call    GetVisDrv
                jnb     short Exec_BL
                mov     bh, cl

Exec_BL:                                ; ...
                mov     al, bl
                xor     bl, bl
                call    GetVisDrv
                jnb     short Exec_Set_Return
                mov     bl, cl

Exec_Set_Return:                        ; ...
                call    Get_User_Stack  ; get his return address
                lds     ax, [si+12h]
                push    ds              ; suck out the CS and IP
                push    ax
                mov     es:0Ah, ax      ; [ES:PDB.EXIT]
                mov     word ptr es:0Ch, ds ; [ES:PDB.EXIT+2]
                xor     ax, ax
                mov     ds, ax          ; save them where we can get them
                                        ; later when the child exits.
                assume ds:DOSCODE
                pop     word ptr addr_int_terminate ; 22h*4
                pop     word ptr addr_int_terminate+2 ; (22h*4)+2
                mov     word ptr ss:DMAADD, 80h
                mov     ds, ss:CurrentPDB
                assume ds:nothing
                mov     word ptr ss:DMAADD+2, ds
                test    byte ptr [bp-5], 1 ; test Exec_Func,exec_func_no_execute
                jz      short exec_go
                lds     si, dword ptr ss:exec_init_SP ; get stack
                les     di, [bp-4]      ; les DI,Exec_Blk ; and block for return
                mov     word ptr es:[di+10h], ds ; mov [ES:DI+EXEC1.SS],DS
                                        ; return SS
                dec     si              ; 'push' default AX
                dec     si
                mov     [si], bx        ; save default AX reg
                mov     es:[di+0Eh], si ; mov [ES:DI+EXEC1.SP],SI ; return 'SP'
                lds     ax, dword ptr ss:exec_init_IP
                mov     word ptr es:[di+14h], ds ; mov [ES:DI+EXEC1.CS],DS
                                        ; initial entry stuff
                mov     es:[di+12h], ax ; mov [ES:DI+EXEC1.IP],AX
                mov     sp, bp
                pop     bp
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

exec_go:                                ; ...
                lds     si, dword ptr ss:exec_init_IP ; get entry point
                les     di, dword ptr ss:exec_init_SP ; new stack
                mov     ax, es
                cmp     ss:DosHasHMA, 0 ; Q: is dos in HMA
                jz      short Xfer_To_User ; N: transfer control to user
                push    ds              ; Y: control must go to low mem stub
                mov     ds, cs:DosDSeg  ; where we disable a20
                                        ; and Xfer control to user
                or      ds:DOS_FLAG, 4  ; Set bit to signal int 21h
                                        ; ah = 25h & ah= 49h
                mov     ds:A20OFF_PSP, dx ; set the PSP for which A20 is
                                        ; going to be turned OFF.
                mov     ax, ds          ; segment of low mem stub
                pop     ds
                push    ax              ; ret far into the low mem stub
                mov     ax, offset disa20_xfer
                push    ax
                mov     ax, es          ; restore ax
                retf
; ---------------------------------------------------------------------------

Xfer_To_User:                           ; ...
                cli                     ; DS:SI points to entry point
                                        ; AX:DI points to initial stack
                                        ; DX has PDB pointer
                                        ; BX has initial AX value
                mov     ss:INDOS, 0
                mov     ss:INDOS_FLAG, 0
                mov     ss, ax          ; set up user's stack
                mov     sp, di          ; and SP
                sti
                push    ds              ; fake long call to entry
                push    si
                mov     es, dx          ; set up proper seg registers
                mov     ds, dx
                mov     ax, bx          ; set up proper AX
                retf

; =============== S U B R O U T I N E =======================================


ExecRead        proc near               ; ...
                call    Exec_Dealloc
                mov     bx, [bp-8]      ; MOV bx,Exec_FH
                push    bp
                call    $READ
                pop     bp
                call    Exec_Alloc
                retn
ExecRead        endp


; =============== S U B R O U T I N E =======================================


Exec_Dealloc    proc near               ; ...
                push    bx
                sub     bx, bx          ; (bx) = ARENA_OWNER_SYSTEM
                call    ECritDisk
                call    ChangeOwners
                pop     bx
                retn
Exec_Dealloc    endp


; =============== S U B R O U T I N E =======================================


Exec_Alloc      proc near               ; ...
                push    bx
                mov     bx, ss:CurrentPDB
                call    ChangeOwners
                call    LCritDisk       ; call LCritMEM
                pop     bx
                retn
Exec_Alloc      endp


; =============== S U B R O U T I N E =======================================


ChangeOwners    proc near               ; ...
                pushf
                push    ax
                mov     ax, [bp-14]     ; mov AX,Exec_Environ
                call    ChangeOwner
                mov     ax, [bp-18]     ; mov AX,Exec_Load_Block
                call    ChangeOwner
                pop     ax
                popf

chgown_retn:                            ; ...
                retn
ChangeOwners    endp


; =============== S U B R O U T I N E =======================================


ChangeOwner     proc near               ; ...
                or      ax, ax          ; is area allocated?
                jz      short chgown_retn ; no, do nothing
                dec     ax
                push    ds
                mov     ds, ax
                mov     ds:1, bx        ; mov [ARENA.OWNER],BX
                pop     ds
                retn
ChangeOwner     endp


; =============== S U B R O U T I N E =======================================


Scan_Execname   proc near               ; ...
                lds     si, [bp-26]     ; lds SI,ExecName ; DS:SI points to name

Scan_Execname1:                         ; ...
                mov     cx, si          ; CX= starting addr

Scan0:                                  ; ...
                lodsb                   ; get char
                cmp     al, 3Ah ; ':'   ; is ':' , may be A:name
                jz      short Scan_Execname1 ; yes, save si
                cmp     al, 5Ch ; '\'   ; is '\', may be A:\name
                jz      short Scan_Execname1 ; yes, save si
                cmp     al, 0           ; is end of name
                jnz     short Scan0     ; no, continue scanning
                sub     si, cx          ; get name's length
                xchg    si, cx          ; cx= length, si= starting addr
                retn
Scan_Execname   endp


; =============== S U B R O U T I N E =======================================


Scan_Special_Entries proc near          ; ...
                dec     cx
                mov     ss:SPECIAL_VERSION, 0A07h ; (MINOR_VERSION<<8)+MAJOR_VERSION
                les     di, ss:UU_IFS_DOS_CALL ; ES:DI --> Table in SETVER.SYS
                mov     ax, es
                or      ax, di
                jz      short End_List  ; If ZR then no table

GetEntries:                             ; ...
                mov     al, es:[di]     ; end of list
                or      al, al
                jz      short End_List  ; yes
                mov     ss:TEMP_VAR2, di ; save di
                cmp     al, cl          ; same length ?
                jnz     short SkipOne   ; no
                inc     di              ; es:di -> special name
                push    cx              ; save length and name addr
                push    si
                push    ax              ; save len

sse_next_char:                          ; ...
                lodsb
                call    UCase
                scasb
                jnz     short Not_Matched
                loop    sse_next_char
                mov     ax, es:[di]     ; get special version
                mov     ss:SPECIAL_VERSION, ax ; save it
                pop     ax              ; take len off the stack
                pop     si
                pop     cx

End_List:                               ; ...
                retn
; ---------------------------------------------------------------------------

Not_Matched:                            ; ...
                pop     ax              ; get len from stack
                pop     si              ; restore si,cx
                pop     cx

SkipOne:                                ; ...
                mov     di, ss:TEMP_VAR2 ; restore old di
                xor     ah, ah          ; position to next entry
                add     di, ax
                add     di, 3           ; DI -> next entry length
                jmp     short GetEntries
Scan_Special_Entries endp

; ---------------------------------------------------------------------------

$KEEP_PROCESS:                          ; ...
                push    ax              ; Terminate and stay resident handler
                mov     byte ptr ss:EXIT_TYPE, 3 ; EXIT_KEEP_PROCESS
                mov     es, ss:CurrentPDB
                cmp     dx, 6           ; keep enough space around for system info
                jnb     short Keep_Shrink
                mov     dx, 6

Keep_Shrink:                            ; ...
                mov     bx, dx
                push    bx
                push    es
                call    $SETBLOCK
                pop     ds
                pop     bx
                jb      short Keep_Done ; failed on modification
                mov     ax, ds
                add     ax, bx
                mov     ds:2, ax        ; [PDB.BLOCK_LEN]

Keep_Done:                              ; ...
                pop     ax
                jmp     short exit_inner ; let abort take care of the rest
; ---------------------------------------------------------------------------

stay_resident:                          ; ...
                mov     ax, 3100h       ; (KEEP_PROCESS<<8)+0
                                        ; Lower part is return code
                add     dx, 15
                rcr     dx, 1
                mov     cl, 3
                shr     dx, cl
                jmp     COMMAND
; ---------------------------------------------------------------------------

$EXIT:                                  ; ...
                xor     ah, ah          ; return to parent process
                xchg    ah, ss:DidCTRLC
                or      ah, ah
                mov     byte ptr ss:EXIT_TYPE, 0 ; EXIT_TERMINATE
                jz      short exit_inner
                mov     byte ptr ss:EXIT_TYPE, 1 ; EXIT_CTRL_C
; START OF FUNCTION CHUNK FOR FATALC

exit_inner:                             ; ...
                call    Get_User_Stack
                push    ss:CurrentPDB
                pop     word ptr [si+14h] ; [SI+user_env.user_CS]
                jmp     short abort_inner
; END OF FUNCTION CHUNK FOR FATALC
; ---------------------------------------------------------------------------

$ABORT:                                 ; ...
                xor     al, al          ; Terminate a process
                mov     byte ptr ss:EXIT_TYPE, 0 ; EXIT_ABORT
; START OF FUNCTION CHUNK FOR FATALC

abort_inner:                            ; ...
                mov     ah, byte ptr ss:EXIT_TYPE
                mov     ss:exit_code, ax
                call    Get_User_Stack
                mov     ds, word ptr [si+14h] ; [SI+user_env.user_CS]
                                        ; set up old interrupts
                xor     ax, ax
                mov     es, ax
                assume es:DOSCODE
                mov     si, 0Ah         ; SAVEXIT
                mov     di, 88h         ; addr_int_terminate
                movsw
                movsw
                movsw
                movsw
                movsw
                movsw
                jmp     reset_environment
; END OF FUNCTION CHUNK FOR FATALC
; ---------------------------------------------------------------------------

RetExePatch:                            ; ...
                retn

; =============== S U B R O U T I N E =======================================


test_umb_flag   proc near               ; ...
                test    ss:UMBFLAG, 1   ; LINKSTATE  ; Q: are umb's linked
                retn                    ; ZF=1 -> N: scan from arena_head
test_umb_flag   endp                    ; ZF=0 -> Y: start_arena = umb_head


; =============== S U B R O U T I N E =======================================


arena_free_process proc near            ; ...
                mov     ax, ss:arena_head

arena_free_process_start:               ; ...
                mov     di, 0           ; ARENA.SIGNATURE
                call    check_signature

arena_free_process_loop:                ; ...
                jb      short check_signature_ok ; AFP_RETN
                push    es
                pop     ds
                assume ds:DOSCODE
                cmp     word ptr ds:1, bx ; [ARENA.OWNER] ; is block owned by pid?
                jnz     short arena_free_next ; no, skip to next
                mov     word ptr ds:1, di ; [ARENA.OWNER] ; yes... free him

arena_free_next:                        ; ...
                cmp     byte ptr [di], 5Ah ; 'Z' ; arena_signature_end
                                        ; end of road, Jack?
                jz      short arena_chk_umbs ; never come back no more
                call    arena_next      ; next item in ES/AX carry set if trash
                jmp     short arena_free_process_loop
; ---------------------------------------------------------------------------

arena_chk_umbs:                         ; ...
                mov     ax, ss:UMB_HEAD
                cmp     ax, 0FFFFh      ; Q: is umb_head initialized
                jz      short check_signature_ok ; N: we're done
                mov     di, ds
                cmp     di, ax          ; Q: is last arena above umb_head
                jb      short arena_free_process_start
                retn                    ; Y: we've scanned umbs also. done.
arena_free_process endp


; =============== S U B R O U T I N E =======================================


arena_next      proc near               ; ...
                mov     ax, ds          ; AX <- current block
                add     ax, word ptr ds:3 ; [ARENA.SIZE] ; + current block length
                inc     ax              ; remember that header!
arena_next      endp


; =============== S U B R O U T I N E =======================================


check_signature proc near               ; ...
                mov     es, ax
                assume es:nothing
                cmp     byte ptr es:[di], 4Dh ; 'M' ; arena_signature_normal
                jz      short check_signature_ok
                cmp     byte ptr es:[di], 5Ah ; 'Z' ; arena_signature_end
                jz      short check_signature_ok
                stc

check_signature_ok:                     ; ...
                retn
check_signature endp


; =============== S U B R O U T I N E =======================================


Coalesce        proc near               ; ...
                cmp     byte ptr [di], 5Ah ; 'Z' ; arena_signature_end
                jz      short check_signature_ok
                call    arena_next
                jb      short check_signature_ok ; IF next block isnt free THEN return
                cmp     es:1, di        ; [ES:ARENA.OWNER]
                jnz     short check_signature_ok
                mov     cx, es:3        ; [ES:ARENA.SIZE] ; next block size
                inc     cx              ; + 1 (for header size)
                add     word ptr ds:3, cx ; [ARENA.SIZE]
                mov     cl, es:[di]     ; move up signature
                mov     [di], cl
                jmp     short Coalesce  ; try again
Coalesce        endp


; =============== S U B R O U T I N E =======================================


$ALLOC          proc near               ; ...

; FUNCTION CHUNK AT B528 SIZE 00000035 BYTES
; FUNCTION CHUNK AT B55D SIZE 00000076 BYTES
; FUNCTION CHUNK AT B5D3 SIZE 0000003A BYTES

                call    ECritDisk       ; call ECritMEM
                mov     ax, ss:arena_head
                test    ss:AllocMethod, 0C0h ; HIGH_FIRST+HIGH_ONLY
                mov     ss:START_ARENA, ax ; assume LOW_FIRST
                jz      short norm_alloc
                call    test_umb_flag
                jz      short norm_alloc
                mov     ax, ss:UMB_HEAD
                mov     ss:START_ARENA, ax ; start_arena = umb_head

norm_alloc:                             ; ...
                xor     ax, ax          ; 0
                mov     di, ax
                mov     ss:FirstArena, ax ; 0 ; init the options
                mov     ss:BestArena, ax
                mov     ss:LastArena, ax
                push    ax              ; alloc_max = 0

start_scan:                             ; ...
                mov     ax, ss:START_ARENA ; beginning of arena
                call    check_signature
                jb      short alloc_err

alloc_scan:                             ; ...
                push    es
                pop     ds
                assume ds:nothing
                cmp     ds:1, di        ; [ARENA.OWNER]
                jz      short alloc_free ; IF current block is free THEN examine

alloc_next:                             ; ...
                call    test_umb_flag
                jz      short norm_strat
                test    ss:AllocMethod, 80h ; HIGH_FIRST
                                        ; Q: is alloc strategy high_first
                jz      short norm_strat ; N: see if we reached last arena
                mov     ax, ss:START_ARENA
                cmp     ax, ss:arena_head ;  Q: did we start scan from arena_head
                jnz     short norm_strat ; N: see if we reached last arena
                mov     ax, ds          ; ax = current block
                cmp     ax, ss:UMB_HEAD ; Q: check against umb_head
                jmp     short alloc_chk_end
; ---------------------------------------------------------------------------

norm_strat:                             ; ...
                cmp     byte ptr [di], 5Ah ; 'Z' ; arena_signature_end
                                        ; IF current block is last THEN

alloc_chk_end:                          ; ...
                jz      short alloc_end ; GOTO end
                call    arena_next      ; AX, ES <- next block, Carry set if error
                jnb     short alloc_scan ; IF no error THEN GOTO scan

alloc_err:                              ; ...
                pop     ax
$ALLOC          endp

; START OF FUNCTION CHUNK FOR $SETBLOCK

alloc_trashed:                          ; ...
                call    LCritDisk       ; call LCritMEM

alloc_trashed2:                         ; ...
                mov     al, 7           ; error_arena_trashed
; END OF FUNCTION CHUNK FOR $SETBLOCK
; START OF FUNCTION CHUNK FOR $ALLOC

alloc_errj:                             ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

alloc_end:                              ; ...
                cmp     ss:FirstArena, 0
                jz      short alloc_chk
                jmp     alloc_do_split
; ---------------------------------------------------------------------------

alloc_chk:                              ; ...
                mov     ax, ss:arena_head
                cmp     ax, ss:START_ARENA ; Q: started scanning from arena_head
                jz      short alloc_fail ; Y: not enough memory
                test    ss:AllocMethod, 40h ; HIGH_ONLY
                                        ; Q: is the alloc strat HIGH_ONLY
                jnz     short alloc_fail ; Y: return size of largest UMB
                mov     ss:START_ARENA, ax ; N: start scanning from arena_head
                jmp     short start_scan
; ---------------------------------------------------------------------------

alloc_fail:                             ; ...
                call    Get_User_Stack
                pop     bx
                mov     [si+2], bx      ; [SI+user_env.user_BX]
                call    LCritDisk       ; call LCritMEM
                mov     al, 8           ; error_not_enough_memory
                jmp     short alloc_errj
; END OF FUNCTION CHUNK FOR $ALLOC
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR $ALLOC

alloc_free:                             ; ...
                call    Coalesce        ; add following free block to current
                jb      short alloc_err
                mov     cx, ds:3        ; [ARENA.SIZE]
                pop     dx
                cmp     cx, dx          ; check for max found size
                jbe     short alloc_test
                mov     dx, cx

alloc_test:                             ; ...
                push    dx
                cmp     bx, cx
                ja      short alloc_next
                cmp     ss:FirstArena, 0
                jnz     short alloc_best
                mov     ss:FirstArena, ds ; save first one found

alloc_best:                             ; ...
                cmp     ss:BestArena, 0
                jz      short alloc_make_best ; initial best
                push    es
                mov     es, ss:BestArena
                cmp     es:3, cx        ; [ES:ARENA.SIZE]
                                        ; is size of best larger than found?
                pop     es
                jbe     short alloc_last

alloc_make_best:                        ; ...
                mov     ss:BestArena, ds ; assign best

alloc_last:                             ; ...
                mov     ss:LastArena, ds ; assign last
                jmp     alloc_next
; ---------------------------------------------------------------------------

alloc_do_split_high:                    ; ...
                mov     ds, ss:LastArena
                mov     cx, ds:3        ; [ARENA.SIZE]
                sub     cx, bx
                mov     dx, ds
                jz      short alloc_set_owner ; sizes are equal, no split
                add     dx, cx          ; point to next block
                mov     es, dx          ; no decrement!
                dec     cx
                xchg    bx, cx          ; bx has size of lower block
                jmp     short alloc_set_sizes ; cx has upper (requested) size
; ---------------------------------------------------------------------------

alloc_do_split:                         ; ...
                mov     cl, ss:AllocMethod
                and     cl, 3Fh         ; mask off bit 7
                cmp     cl, 1           ; BEST_FIT
                ja      short alloc_do_split_high
                mov     ds, ss:FirstArena
                jb      short alloc_get_size
                mov     ds, ss:BestArena
; END OF FUNCTION CHUNK FOR $ALLOC
; START OF FUNCTION CHUNK FOR $ALLOC
;   ADDITIONAL PARENT FUNCTION $SETBLOCK

alloc_get_size:                         ; ...
                mov     cx, ds:3        ; [ARENA.SIZE]
                mov     ax, ds
                sub     cx, bx          ; get room left over
                mov     dx, ax
                jz      short alloc_set_owner ; IF BX = size THEN (don't split)
                add     ax, bx
                inc     ax              ; remember the header
                mov     es, ax          ; ES <- DS + BX (new header location)
                dec     cx              ; CX <- size of split block

alloc_set_sizes:                        ; ...
                mov     ds:3, bx        ; [ARENA.SIZE]
                mov     bl, 4Dh ; 'M'   ; arena_signature_normal
                mov     es:3, cx        ; split size
                xchg    bl, [di]        ; current signature
                mov     es:1, di        ; [ES:ARENA.OWNER]
                mov     es:[di], bl     ; new block sig <- old block sig

alloc_set_owner:                        ; ...
                mov     ds, dx
                mov     ax, ss:CurrentPDB
                mov     ds:1, ax        ; [ARENA.OWNER]
                mov     ax, ds
                inc     ax
                pop     bx
                call    LCritDisk       ; call LCritMEM

alloc_ok:                               ; ...
                jmp     SYS_RET_OK
; END OF FUNCTION CHUNK FOR $ALLOC

; =============== S U B R O U T I N E =======================================


$SETBLOCK       proc near               ; ...

; FUNCTION CHUNK AT B523 SIZE 00000005 BYTES
; FUNCTION CHUNK AT B5D3 SIZE 0000003A BYTES

                call    ECritDisk       ; call ECritMEM
                mov     di, 0           ; ARENA.SIGNATURE
                mov     ax, es
                dec     ax
                call    check_signature
                jnb     short setblock_grab

setblock_bad:                           ; ...
                jmp     alloc_trashed
; ---------------------------------------------------------------------------

setblock_grab:                          ; ...
                mov     ds, ax
                call    Coalesce
                jb      short setblock_bad
                mov     cx, ds:3        ; [ARENA.SIZE]
                push    cx
                cmp     bx, cx
                jbe     short alloc_get_size
                jmp     alloc_fail
$SETBLOCK       endp


; =============== S U B R O U T I N E =======================================


$DEALLOC        proc near               ; ...
                call    ECritDisk       ; call ECritMEM
                test    ss:DOS_FLAG, 4  ; EXECA20OFF
                jz      short deallocate ; Q: was the previous call an int 21h
                                        ;  exec call
                                        ; N: continue
                cmp     ss:A20OFF_COUNT, 0
                jnz     short deallocate
                inc     ss:A20OFF_COUNT

deallocate:                             ; ...
                mov     di, 0           ; ARENA.SIGNATURE
                mov     ax, es
                dec     ax
                call    check_signature
                jb      short dealloc_err
                mov     es:1, di        ; [ES:ARENA.OWNER]
                call    LCritDisk       ; call LCritMEM

dealloc_ok:                             ; ...
                jmp     short alloc_ok
; ---------------------------------------------------------------------------

dealloc_err:                            ; ...
                call    LCritDisk
                mov     al, 9           ; error_invalid_block

AllocOperErrj:                          ; ...
                jmp     SYS_RET_ERR
$DEALLOC        endp

; ---------------------------------------------------------------------------

$ALLOCOPER:                             ; ...
                or      al, al          ; get/set allocation mechanism
                jz      short AllocGetStrat
                cmp     al, 1
                jz      short AllocSetStrat
                cmp     al, 2
                jz      short AllocGetLink
                cmp     al, 3
                jz      short AllocSetLink

AllocOperError:                         ; ...
                call    set_exerr_locus_mem
                mov     al, 1
                jmp     short AllocOperErrj
; ---------------------------------------------------------------------------

AllocGetStrat:                          ; ...
                mov     al, ss:AllocMethod
                xor     ah, ah

AllocOperOk:                            ; ...
                jmp     short dealloc_ok
; ---------------------------------------------------------------------------

AllocSetStrat:                          ; ...
                push    bx
                and     bl, 3Fh         ; STRAT_MASK ; mask off bit 6 & 7
                cmp     bx, 2
                pop     bx              ; BX must be 0-2
                ja      short AllocOperError
                mov     ss:AllocMethod, bl
                jmp     short AllocOperOk
; ---------------------------------------------------------------------------

AllocGetLink:                           ; ...
                mov     al, ss:UMBFLAG  ; return link state in al
                and     al, 1           ; LINKSTATE
                jmp     short AllocOperOk
; ---------------------------------------------------------------------------

AllocSetLink:                           ; ...
                mov     cx, ss:UMB_HEAD
                inc     cx              ; Q: has umb_head been initialized
                jz      short AllocOperError ; -1 ; N: error
                dec     cx
                dec     bx
                jz      short LinkUmbs
                inc     bx
                jz      short UnlinkUmbs
                jmp     short AllocOperError
; ---------------------------------------------------------------------------

UnlinkUmbs:                             ; ...
                call    test_umb_flag   ; test byte [ss:UMBFLAG],LINKSTATE
                                        ; Q: umbs unlinked?
                jz      short unlinked  ; Y: return
                call    GetLastArena    ; get arena before umb_head in DS
                mov     byte ptr ds:0, 5Ah ; 'Z' ; arena_signature_end
                and     ss:UMBFLAG, 0FEh ; ~LINKSTATE
                                        ; indicate unlink'd state in umbflag

unlinked:                               ; ...
                jmp     short AllocOperOk
; ---------------------------------------------------------------------------

LinkUmbs:                               ; ...
                call    test_umb_flag   ; Q: umbs linked?
                jnz     short linked    ; Y: return
                call    GetLastArena    ; get arena before umb_head
                mov     byte ptr ds:0, 4Dh ; 'M' ; arena_signature_normal
                or      ss:UMBFLAG, 1   ; LINKSTATE
                                        ; indicate link'd state in umbflag

linked:                                 ; ...
                jmp     short AllocOperOk

; =============== S U B R O U T I N E =======================================


GetLastArena    proc near               ; ...
                push    ax
                mov     ax, ss:arena_head
                mov     es, ax
                xor     di, di
                cmp     byte ptr es:[di], 5Ah ; 'Z' ; arena_signature_end
                                        ; Q: is this the last arena
                jz      short GLA_done  ; Y: return last arena in ES

GLA_next:                               ; ...
                mov     ds, ax
                call    arena_next      ; ax, es -> next arena
                jb      short GLA_err
                call    test_umb_flag   ; Q: are UMBs linked
                jnz     short GLA_chkumb ; Y: terminating condition is umb_head
                cmp     byte ptr es:[di], 5Ah ; 'Z' ; Q: is this the last arena
                jmp     short GLA_@f
; ---------------------------------------------------------------------------

GLA_chkumb:                             ; ...
                cmp     ax, cx          ; Q: is this umb_head

GLA_@f:                                 ; ...
                jnz     short GLA_next  ; N: get next arena

GLA_done:                               ; ...
                call    test_umb_flag
                jnz     short GLA_ret
                mov     ds, ax
                call    arena_next
                jb      short GLA_err
                cmp     ax, cx
                jnz     short GLA_err

GLA_ret:                                ; ...
                clc
                pop     ax
                retn
; ---------------------------------------------------------------------------

GLA_err:                                ; ...
                stc
                pop     ax
                pop     ax              ; return address to _$ALLOCOPER (the caller)
                call    set_exerr_locus_mem
                jmp     alloc_trashed2  ; (error return from _$ALLOCOPER)
GetLastArena    endp

; ---------------------------------------------------------------------------
SERVERTAB       dw offset SERVER_DISP   ; ...
SERVERLEAVE     dw offset SERVERRETURN  ; ...
SERVER_DISP     db 11                   ; ...
                                        ; (SERVER_DISP_END-SERVER_DISP-1)/2 = 11
                dw offset SRV_CALL      ; 0
                dw offset COMMIT_ALL    ; 1
                dw offset CLOSE_NAME    ; 2
                dw offset CLOSE_UID     ; 3
                dw offset CLOSE_UID_PID ; 4
                dw offset GET_LIST      ; 5
                dw offset GET_DOS_DATA  ; 6
                dw offset SPOOL_OPER    ; 7
                dw offset SPOOL_OPER    ; 8
                dw offset SPOOL_OPER    ; 9
                dw offset _$SetExtendedError ; 10
                                        ; SERVER_DISP_END
; ---------------------------------------------------------------------------

$ServerCall:                            ; ...
                cmp     al, 7
                jb      short SET_STUFF
                cmp     al, 9
                jbe     short NO_SET_ID ; No DPL on calls 7,8,9

SET_STUFF:                              ; ...
                mov     si, dx          ; Point to DPL with DS:SI
                mov     bx, [si+12h]    ; [SI+DPL.UID]
                test    ss:IsWin386, 1
                jnz     short skip_win386
                mov     ss:USER_ID, bx  ; Set UID

skip_win386:                            ; ...
                mov     bx, [si+14h]    ; [SI+DPL.PID]
                mov     ss:PROC_ID, bx  ; Set process ID

NO_SET_ID:                              ; ...
                push    cs:SERVERLEAVE
                push    cs:SERVERTAB
                push    ax
                call    TableDispatch
                call    set_exerr_locus_unk ; Extended Error Locus
                mov     al, 1           ; error_invalid_function

servercall_error:                       ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

SERVERRETURN:                           ; ...
                retn
; ---------------------------------------------------------------------------

COMMIT_ALL:                             ; ...
                xor     bx, bx
                push    ss
                pop     ds
                call    ECritDisk       ; call ECritSFT

CommitLoop:                             ; ...
                push    bx              ; scan SFT cache
                call    SFFromSFN
                jb      short CommitDone
                cmp     word ptr es:[di], 0 ; [ES:DI+SF_ENTRY.sf_Ref_Count]
                jz      short CommitNext
                cmp     word ptr es:[di], 0FFFFh ; [ES:DI+SF_ENTRY.sf_Ref_Count],sf_busy
                jz      short CommitNext
                test    word ptr es:[di+5], 8000h ; [ES:DI+SF_ENTRY.sf_flags],sf_isnet
                jnz     short CommitNext
                mov     word ptr ds:THISSFT, di
                mov     word ptr ds:THISSFT+2, es
                call    DOS_COMMIT

CommitNext:                             ; ...
                pop     bx
                inc     bx
                jmp     short CommitLoop
; ---------------------------------------------------------------------------

CommitDone:                             ; ...
                call    LCritDisk       ; call LCritSFT
                pop     bx

Commit_Ok:                              ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

CLOSE_NAME:                             ; ...
                call    ss:MFTCloN      ; Call far [SS:JShare+(5*4)] ; 5 = MFTcloN

CheckReturns:                           ; ...
                jnb     short Commit_Ok

func_err:                               ; ...
                jmp     short servercall_error
; ---------------------------------------------------------------------------

CLOSE_UID:                              ; ...
                call    ss:MFTclU       ; Call far [SS:JShare+(3*4)] ; 3 = MTFTclu
                jmp     short CheckReturns
; ---------------------------------------------------------------------------

CLOSE_UID_PID:                          ; ...
                call    ss:MFTCloseP    ; Call far [SS:JShare+(4*4)] ; 4 = MFTCloseP
                jmp     short CheckReturns
; ---------------------------------------------------------------------------

GET_LIST:                               ; ...
                call    ss:MFT_get      ; Call far [SS:JShare+(9*4)] ; 9 = MFT_get
                jb      short func_err
                call    Get_User_Stack
                mov     [si+2], bx      ; [SI+user_env.user_BX]
                mov     [si+10], di     ; [SI+user_env.user_DI]
                mov     word ptr [si+16], es ; [SI+user_env.user_ES]

SetCXOK:                                ; ...
                mov     [si+4], cx      ; [SI+user_env.user_CX]

Commit_Okj2:                            ; ...
                jmp     short Commit_Ok
; ---------------------------------------------------------------------------

SRV_CALL:                               ; ...
                pop     ax              ; get rid of call to $srvcall
                push    ds
                push    si
                call    Get_User_Stack
                pop     di
                pop     es              ; DS:SI point to stack
                                        ; ES:DI point to DPL
                call    XCHGP
                push    si              ; DS:SI point to DPL
                                        ; ES:DI point to stack
                mov     cx, 6           ; copy the registers from DPL
                rep movsw               ; Put in AX,BX,CX,DX,SI,DI
                inc     di
                inc     di              ; Skip user_BP
                movsw                   ; DS
                movsw                   ; ES
                pop     si              ; DS:SI -> DPL
                mov     ax, [si]        ; [SI+DPL.AX]
                mov     bx, [si+2]      ; [SI+DPL.BX]
                mov     cx, [si+4]      ; [SI+DPL.CX]
                mov     dx, [si+6]      ; [SI+DPL.DX]
                mov     di, [si+10]     ; [SI+DPL.DI]
                mov     es, word ptr [si+14] ; [SI+DPL.ES]
                push    word ptr [si+8] ; [SI+DPL.SI]
                mov     ds, word ptr [si+12] ; [SI+DPL.DS]
                pop     si
                mov     ss:SAVEDS, ds
                mov     ss:SAVEBX, bx
                mov     ss:FSHARING, 0FFh ; -1 ; set no redirect flag
                jmp     REDISP
; ---------------------------------------------------------------------------

GET_DOS_DATA:                           ; ...
                push    ss
                pop     es
                mov     di, offset ERRORMODE ; offset SWAP_START
                mov     cx, offset UCASE_TAB ; offset SWAP_END
                mov     dx, offset USER_IN_AX ; offset SWAP_ALWAYS
                sub     cx, di
                sub     dx, di
                shr     cx, 1           ; div by 2, remainder in carry
                adc     cx, 0           ; div by 2 + round up
                add     cx, cx          ; round up to 2 boundary
                call    Get_User_Stack
                mov     word ptr [si+14], es ; [SI+user_env.user_DS]
                mov     [si+8], di      ; [SI+user_env.user_SI]
                mov     [si+6], dx      ; [SI+user_env.user_DX]
                jmp     short SetCXOK
; ---------------------------------------------------------------------------

SPOOL_OPER:                             ; ...
                push    ax
                mov     ax, 1125h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
                                        ; STACK: WORD subfunction
                                        ; Return: CF set on error, AX = error code
                                        ; STACK unchanged
                pop     bx
                jnb     short Commit_Okj2
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

_$SetExtendedError:                     ; ...
                mov     ax, [si]        ; [SI+DPL.AX]
                mov     ss:EXTERR, ax
                mov     ax, [si+10]     ; [SI+DPL.DI]
                mov     word ptr ss:EXTERRPT, ax
                mov     ax, [si+14]     ; [SI+DPL.ES]
                mov     word ptr ss:EXTERRPT+2, ax
                mov     ax, [si+2]      ; [SI+DPL.BX]
                mov     word ptr ss:EXTERR_ACTION, ax
                mov     ax, [si+4]      ; [SI+DPL.CX]
                mov     ss:EXTERR_LOCUS, ah
                retn

; =============== S U B R O U T I N E =======================================


pJFNFromHandle  proc near               ; ...
                mov     es, cs:DosDSeg  ; es -> dosdata
                mov     es, es:CurrentPDB ; get user process data block
                cmp     bx, es:32h      ; [ES:PDB.JFN_Length]
                                        ; is handle greater than allocated ?
                jnb     short ReturnCarry_inv_hndl ; yes
                les     di, es:34h      ; [ES:PDB.JFN_Pointer]
                                        ; get pointer to beginning of table
                add     di, bx          ; add in offset, clear 'C'
                retn
; ---------------------------------------------------------------------------

ReturnCarry_inv_hndl:                   ; ...
                mov     al, 6           ; error_invalid_handle

ReturnCarry:                            ; ...
                stc

pJFNFromHandle_error:                   ; ...
                retn
pJFNFromHandle  endp


; =============== S U B R O U T I N E =======================================


SFFromHandle    proc near               ; ...
                call    pJFNFromHandle  ; get jfn pointer
                jb      short pJFNFromHandle_error
                cmp     byte ptr es:[di], 0FFh ; -1 ; unused handle
                jz      short ReturnCarry_inv_hndl2
                push    bx              ; save handle
                mov     bl, es:[di]     ; get SFN
                xor     bh, bh          ; ignore upper half
                call    SFFromSFN       ; get real sf spot
                pop     bx              ; restore
                retn
; ---------------------------------------------------------------------------

ReturnCarry_inv_hndl2:                  ; ...
                mov     al, 6           ; error_invalid_handle
                jmp     short ReturnCarry
SFFromHandle    endp


; =============== S U B R O U T I N E =======================================


SFFromSFN       proc near               ; ...
                mov     es, cs:DosDSeg  ; es -> dosdata
                les     di, es:SFT_ADDR ; (es:di) = start of SFT table

sfsfn5:                                 ; ...
                cmp     bx, es:[di+4]   ; [ES:DI+SFT.SFCount]
                                        ; is handle in this table?
                jb      short sfsfn7    ; yes, go grab it
                sub     bx, es:[di+4]   ; [ES:DI+SFT.SFCount]
                les     di, es:[di]     ; [ES:DI+SFT.SFLink]
                                        ; get next table segment
                cmp     di, 0FFFFh      ; -1 ; end of tables?
                jnz     short sfsfn5    ; no, try again
                stc
                retn                    ; return with error, not found
; ---------------------------------------------------------------------------

sfsfn7:                                 ; ...
                push    ax
                mov     ax, 59          ; SF_ENTRY.size
                mul     bl              ; (ax) = offset into this SF block
                add     di, ax          ; add base of SF block
                pop     ax
                add     di, 6           ; SFT.SFTable  ; offset into structure
                retn                    ; return with 'C' clear
SFFromSFN       endp


; =============== S U B R O U T I N E =======================================


JFNFree         proc near               ; ...
                xor     bx, bx          ; (bx) = initial JFN to try = 0

jfnf1:                                  ; ...
                call    pJFNFromHandle  ; get the appropriate handle
                jb      short jfnf5     ; no more handles
                cmp     byte ptr es:[di], 0FFh ; -1 ; free?
                jz      short jfnfx     ; yes, carry is clear
                inc     bx              ; no, next handle
                jmp     short jfnf1     ; and try again
; ---------------------------------------------------------------------------

jfnf5:                                  ; ...
                mov     al, 4           ; error_too_many_open_files

jfnfx:                                  ; ...
                retn
JFNFree         endp


; =============== S U B R O U T I N E =======================================


SFNFree         proc near               ; ...
                push    ax              ; Allocate a Free SFN/SFT
                xor     bx, bx          ; 0

sfnf5:                                  ; ...
                push    bx              ; (bx) = SFN to consider
                call    SFFromSFN       ; get the potential handle
                pop     bx
                jb      short sfnf95    ; no more free SFNs
                cmp     word ptr es:[di], 0 ; [ES:DI+SF_ENTRY.sf_Ref_Count] ; free?
                jz      short sfnf20    ; yep, got one
                cmp     word ptr es:[di], 0FFFFh ; [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
                jz      short sfnf10    ; special busy mark

sfnf7:                                  ; ...
                inc     bx              ; try the next one
                jmp     short sfnf5
; ---------------------------------------------------------------------------

sfnf10:                                 ; ...
                mov     ax, ss:USER_ID
                cmp     es:[di+2Fh], ax ; [ES:DI+SF_ENTRY.sf_UID]
                jnz     short sfnf7     ; not ours
                mov     ax, ss:PROC_ID
                cmp     es:[di+31h], ax ; [ES:DI+SF_ENTRY.sf_PID]
                jnz     short sfnf7     ; can't use this one, try the next

sfnf20:                                 ; ...
                mov     word ptr es:[di], 0FFFFh ; [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
                mov     ax, ss:USER_ID
                mov     es:[di+2Fh], ax ; [ES:DI+SF_ENTRY.sf_UID]
                mov     ax, ss:PROC_ID
                mov     es:[di+31h], ax ; [ES:DI+SF_ENTRY.sf_PID]
                pop     ax
                clc
                retn                    ; return with no error
; ---------------------------------------------------------------------------

sfnf95:                                 ; ...
                pop     ax
                jmp     short jfnf5     ; return with 'C' and error
SFNFree         endp


; =============== S U B R O U T I N E =======================================


$CLOSE          proc near               ; ...
                call    CheckOwner      ; get system file entry
                jb      short CloseError
                push    ss
                pop     ds
                mov     word ptr ds:THISSFT, di
                mov     word ptr ds:THISSFT+2, es ; DS:SI point to JFN table entry
                                        ; ES:DI point to SFT
                cmp     word ptr es:[di], 1 ; [ES:DI+SF_ENTRY.sf_ref_count]
                                        ; will the SFT become free?
                jz      short FreeJFN   ; yes, free JFN anyway.
                mov     al, es:[di+2]   ; [ES:DI+SF_ENTRY.sf_mode]
                and     al, 0F0h        ; SHARING_MASK
                cmp     al, 70h         ; SHARING_NET_FCB
                jz      short PostFree  ; 70-mode and big ref count => free it

FreeJFN:                                ; ...
                call    pJFNFromHandle
                mov     byte ptr es:[di], 0FFh ; release the JFN

PostFree:                               ; ...
                call    DOS_CLOSE
                jb      short CloseError
                mov     ah, 3Eh         ; CLOSE ; Bogus multiplan fix

CloseOk:                                ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

CloseError:                             ; ...
                jmp     SYS_RET_ERR
$CLOSE          endp

; ---------------------------------------------------------------------------

$COMMIT:                                ; ...
                call    CheckOwner      ; get system file entry
                jb      short CommitError
                push    ss
                pop     ds
                mov     word ptr ds:THISSFT, di
                mov     word ptr ds:THISSFT+2, es
                call    DOS_COMMIT
                jb      short CommitError
                mov     ah, 68h         ; COMMIT
                jmp     short CloseOk
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR $READ

CommitError:                            ; ...
                jmp     short CloseError
; END OF FUNCTION CHUNK FOR $READ
; ---------------------------------------------------------------------------

$ExtHandle:                             ; ...
                xor     bp, bp          ; 0: enlarge  1: shrink  2:psp
                cmp     bx, 20          ; FILPERPROC
                jnb     short exth2     ; Don't set less than FilPerProc no
                mov     bx, 20

exth2:                                  ; ...
                mov     es, ss:CurrentPDB
                mov     cx, word ptr es:32h ; [ES:PDB.JFN_Length]
                                        ; get number of handle allowed
                cmp     bx, cx          ; the requested == current
                jz      short CloseOk   ; yes and exit
                ja      short larger    ; go allocate new table
                inc     bp              ; bp = 1 ; shrink
                mov     ds, es:36h      ; [ES:PDB.JFN_Pointer+2]
                mov     si, bx
                sub     cx, bx          ; get difference

chck_handles:                           ; ...
                cmp     byte ptr [si], 0FFh ; -1 ; scan through handles to ensure
                jnz     short too_many_files ; close status
                inc     si
                loop    chck_handles
                cmp     bx, 20          ; FILPERPROC
                ja      short larger
                inc     bp              ; bp = 2 ; psp
                mov     di, 24          ; PDB.JFN_TABLE
                push    bx
                jmp     short movhandl
; ---------------------------------------------------------------------------

larger:                                 ; ...
                inc     bx
                jz      short invalid_func ; 65535 is not allowed
                dec     bx
                clc
                push    bx
                add     bx, 0Fh         ; adjust to paragraph boundary
                mov     cl, 4
                rcr     bx, cl
                and     bh, 1Fh         ; clear most 3 bits
                push    bp
                call    $ALLOC          ; allocate memory
                pop     bp
                jb      short no_memory ; not enough memory
                mov     es, ax
                xor     di, di          ; es:di points to new table memory

movhandl:                               ; ...
                mov     ds, ss:CurrentPDB
                test    bp, 3           ; enlarge ?
                jz      short enlarge   ; yes
                pop     cx              ; cx = the amount you shrink
                push    cx
                jmp     short copy_hand
; ---------------------------------------------------------------------------

too_many_files:                         ; ...
                mov     al, 4           ; error_too_many_open_files
; START OF FUNCTION CHUNK FOR $READ

CommitErrorj:                           ; ...
                jmp     short CommitError
; END OF FUNCTION CHUNK FOR $READ
; ---------------------------------------------------------------------------

enlarge:                                ; ...
                mov     cx, ds:32h      ; [PDB.JFN_Length]
                                        ; get number of old handles

copy_hand:                              ; ...
                mov     dx, cx
                lds     si, ds:34h      ; [PDB.JFN_Pointer]
                                        ; get old table pointer
                rep movsb               ; copy infomation to new table
                pop     cx              ; get new number of handles
                push    cx
                sub     cx, dx          ; get the difference
                mov     al, 0FFh        ; -1 ; set availability to handles
                rep stosb
                mov     ds, ss:CurrentPDB
                cmp     word ptr ds:34h, 0 ; [PDB.JFN_Pointer]
                                        ; check if original table pointer
                jnz     short update_info ; yes, go update PDB entries
                push    bp
                push    ds
                push    es
                mov     es, word ptr ds:36h ; [PDB.JFN_Pointer+2]
                                        ; get old table segment
                call    $DEALLOC        ; deallocate old table memory
                pop     es
                pop     ds
                pop     bp

update_info:                            ; ...
                test    bp, 2           ; psp?
                jz      short non_psp   ; no
                mov     word ptr ds:34h, 18h ; [PDB.JFN_Pointer],PDB.JFN_TABLE
                                        ; restore
                jmp     short final
; ---------------------------------------------------------------------------

non_psp:                                ; ...
                mov     word ptr ds:34h, 0 ; [PDB.JFN_Pointer]
                                        ; new table pointer offset always 0

final:                                  ; ...
                mov     word ptr ds:36h, es ; [PDB.JFN_Pointer+2]
                                        ; new table segment
                pop     word ptr ds:32h ; [PDB.JFN_Length]
                                        ; restore new number of handles
; START OF FUNCTION CHUNK FOR $READ

ok_done:                                ; ...
                jmp     SYS_RET_OK
; END OF FUNCTION CHUNK FOR $READ
; ---------------------------------------------------------------------------

no_memory:                              ; ...
                pop     bx              ; clean stack
                mov     al, 8           ; error_not_enough_memory
                jmp     short CommitErrorj
; ---------------------------------------------------------------------------

invalid_func:                           ; ...
                mov     al, 1           ; error_invalid_function
; START OF FUNCTION CHUNK FOR $READ

CommitErrorj3:                          ; ...
                jmp     short CommitErrorj
; END OF FUNCTION CHUNK FOR $READ

; =============== S U B R O U T I N E =======================================


$READ           proc near               ; ...

; FUNCTION CHUNK AT B971 SIZE 00000002 BYTES
; FUNCTION CHUNK AT B9D7 SIZE 00000002 BYTES
; FUNCTION CHUNK AT BA22 SIZE 00000003 BYTES
; FUNCTION CHUNK AT BA2C SIZE 00000002 BYTES

                mov     si, offset DOS_READ

ReadDO:                                 ; ...
                call    pJFNFromHandle
                jb      short ReadError
                mov     al, es:[di]
                call    CheckOwner      ; get the handle
                jb      short ReadError
                mov     word ptr ss:THISSFT, di
                mov     word ptr ss:THISSFT+2, es
                test    byte ptr es:[di+3], 20h ; [ES:DI+SF_ENTRY.sf_mode+1],(INT_24_ERROR>>8)
                                        ; need i24
                jz      short needi24   ; yes
                or      ss:EXTOPEN_ON, 2 ; EXT_OPEN_I24_OFF ; set it off

needi24:                                ; ...
                mov     ax, ds          ; original segment
                lds     bx, ss:DMAADD
                push    bx
                push    ds
                mov     bx, dx
                shr     bx, 1
                shr     bx, 1
                shr     bx, 1
                shr     bx, 1
                add     ax, bx          ; new segment
                and     dx, 0Fh         ; normalize offset
                mov     word ptr ss:DMAADD, dx
                mov     word ptr ss:DMAADD+2, ax
                mov     ax, ss
                mov     ds, ax
                call    si ; DOS_READ   ; indirect call to operation
                pop     word ptr ds:DMAADD+2
                pop     word ptr ds:DMAADD
                jb      short ReadError
                mov     ax, cx          ; get correct return in correct reg

Read_Ok:                                ; ...
                jmp     short ok_done   ; successful return
; ---------------------------------------------------------------------------

ReadError:                              ; ...
                jmp     short CommitErrorj3
$READ           endp

; ---------------------------------------------------------------------------

$WRITE:                                 ; ...
                mov     si, offset DOS_WRITE
                jmp     short ReadDO

; =============== S U B R O U T I N E =======================================


$LSEEK          proc near               ; ...
                call    CheckOwner      ; get system file entry

LSeekError:                             ; ...
                jb      short ReadError

CHKOWN_OK:                              ;
                cmp     al, 2           ; is the seek value correct?
                ja      short LSeekError1 ; no

LSeekDisp:                              ; yes, go dispatch
                cmp     al, 1           ; best way to dispatch; check middle
                jb      short LSeekStore ; just store CX:DX
                ja      short LSeekEOF  ; seek from end of file
                add     dx, es:[di+15h] ; [ES:DI+SF_ENTRY.sf_position]
                adc     cx, es:[di+17h] ; [ES:DI+SF_ENTRY.sf_position+2]

LSeekStore:                             ; ...
                mov     ax, cx
                xchg    ax, dx          ; DX:AX is the correct value

LSeekSetpos:                            ; ...
                mov     es:[di+15h], ax ; [ES:DI+SF_ENTRY.sf_position]
                mov     es:[di+17h], dx ; [ES:DI+SF_ENTRY.sf_position+2]
                call    Get_User_Stack
                mov     [si+6], dx      ; [SI+user_env.user_DX] ; return DX:AX
                jmp     short Read_Ok   ; successful return
; ---------------------------------------------------------------------------

LSeekEOF:                               ; ...
                test    byte ptr es:[di+6], 80h ; [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
                jnz     short Check_LSeek_Mode ; is net

LOCAL_LSeek:                            ; ...
                add     dx, es:[di+11h] ; [ES:DI+SF_ENTRY.sf_size]
                adc     cx, es:[di+13h] ; [ES:DI+SF_ENTRY.sf_size+2]
                jmp     short LSeekStore ; go and set the position
; ---------------------------------------------------------------------------

Check_LSeek_Mode:                       ; ...
                test    byte ptr es:[di+3], 80h ; [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
                jnz     short LOCAL_LSeek ; FCB treated like local file
                mov     ax, es:[di+2]   ; ES:DI+SF_ENTRY.sf_mode]
                and     ax, 0F0h        ; SHARING_MASK
                cmp     ax, 40h         ; SHARING_DENY_NONE
                jz      short NET_LSEEK ; LSEEK exported in this mode
                cmp     ax, 30h         ; SHARING_DENY_READ
                jnz     short LOCAL_LSeek ; Treated like local Lseek

NET_LSEEK:                              ; ...
                mov     ax, 1121h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE
                                        ; CX:DX = offset (in bytes) from end
                                        ; ES:DI -> SFT, SFT DPB field -> DPB of drive with file
                                        ; SS = DOS CS
                                        ; Return: CF set on error
                                        ; CF clear if successful, DX:AX = new file position
                jnb     short LSeekSetpos

LSeekError3:                            ; ...
                jmp     short ReadError
; ---------------------------------------------------------------------------

LSeekError1:                            ; ...
                call    set_exerr_locus_unk ; Extended Error Locus
                mov     al, 1           ; error_invalid_function

LSeekError2:                            ; ...
                jmp     SYS_RET_ERR
$LSEEK          endp

; ---------------------------------------------------------------------------

$FILE_TIMES:                            ; ...
                cmp     al, 7           ; SET CREATION DATE AND TIME
                                        ; 6 = GET CREATION DATE AND TIME
                                        ; 5 = SET LAST ACCESS DATE AND TIME
                jnb     short LSeekError1
                cmp     al, 4           ; GET LAST ACCESS DATE AND TIME
                jnb     short ft1
                cmp     al, 2           ; 0 = GET FILE'S LAST-WRITTEN DATE AND TIME
                                        ; 1 = SET FILE'S LAST-WRITTEN DATE AND TIME
                jnb     short LSeekError1 ; 2,3 -> invalid

ft1:                                    ; ...
                call    CheckOwner      ; get sft
                jb      short LSeekError ; bad handle
                cmp     al, 1
                ja      short ft2       ; PCDOS 7.1 (MSDOS 7) sub function
                or      al, al          ; get time/date ?
                jnz     short ft_set_time ; no, set
                lds     cx, es:[di+0Dh] ; [es:di+SF_ENTRY.sf_time]
                                        ; get the time
                mov     dx, ds          ; & date ; [es:di+SF_ENTRY.sf_date]
                call    Get_User_Stack
                mov     [si+4], cx      ; [si+user_env.user_CX]
                mov     [si+6], dx      ; [si+user_env.user_DX]
                jmp     short ft_ok
; ---------------------------------------------------------------------------

ft_set_time:                            ; ...
                call    ECritDisk       ; call ECritSFT
                mov     es:[di+0Dh], cx ; [es:di+SF_ENTRY.sf_time] ; drop in new time
                mov     es:[di+0Fh], dx ; [es:di+SF_ENTRY.sf_date] ; and date
                xor     ax, ax
                call    ss:ShSU         ; call far [ss:JShare+(14*4)] ; 14 = ShSU
                and     word ptr es:[di+5], 0FFBFh ; [es:di+SF_ENTRY.sf_flags],~devid_file_clean
                or      word ptr es:[di+5], 4000h ; [es:di+SF_ENTRY.sf_flags],sf_close_nodate
                call    LCritDisk       ; call LCritSFT

ft_ok:                                  ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

ft2:                                    ; ...
                test    byte ptr es:[di+5], 80h ; [es:di+SF_ENTRY.sf_flags],devid_device
                jnz     short ft3       ; device
                call    IsSFTNet

ft3:                                    ; ...
                jz      short ft5       ; local file
                test    al, 1           ; 0 = GET, 1 = SET
                jnz     short ft_okj    ; SET
                mov     dx, es:[di+0Fh] ; [es:di+SF_ENTRY.sf_date]
                                        ; (sub cx,cx ; Windows ME IO.SYS BIOSCODE:A348h)

ft4:                                    ; ...
                call    Get_User_Stack
                mov     [si+4], cx      ; [si+user_env.user_CX] ; time
                mov     [si+6], dx      ; [si+user_env.user_DX] ; date

ft_okj:                                 ; ...
                jmp     short ft_ok
; ---------------------------------------------------------------------------

ft5:                                    ; ...
                push    ss              ; Retrieve the directory entry for the file
                pop     ds
                push    ax
                push    dx
                push    cx              ; ES:DI point to SFT
                call    DirFromSFT      ; locate a directory entry given an SFT
                pop     cx
                pop     dx
                jnb     short ft6       ; ES:DI point to entry
                                        ; (DS:SI point to SFT)
                                        ; (ES:BX point to buffer header)
                pop     cx

ft_error:                               ; ...
                jmp     short LSeekError2
; ---------------------------------------------------------------------------

ft6:                                    ; ...
                pop     ax
                test    al, 1           ; SET ?
                jnz     short ft8       ; yes
                xor     cx, cx          ; (always) last access time = 0
                mov     dx, es:[di+12h] ; [es:di+dir_entry.dir_lstaccdate]
                cmp     al, 6           ; GET CREATION DATE AND TIME ?
                jnz     short ft7       ; no, GET LAST ACCESS DATE AND TIME
                mov     cx, es:[di+0Eh] ; [es:di+dir_entry.dir_crttime]
                mov     dx, es:[di+10h] ; [es:di+dir_entry.dir_crtdate]

ft7:                                    ; ...
                jmp     short ft4
; ---------------------------------------------------------------------------

ft8:                                    ; ...
                test    dl, 1Fh         ; check date (set) values
                                        ; DAY (1 to 31) > 0 ?
                jnz     short ft9       ; yes, valid

ft_err_invd:                            ; ...
                mov     al, 0Dh         ; error_invalid_data

ft_errj:                                ; ...
                jmp     short ft_error
; ---------------------------------------------------------------------------

ft9:                                    ; ...
                test    dx, 1E0h        ; MONTH (1 to 12) > 0 ?
                jz      short ft_err_invd ; no, invalid
                push    dx
                and     dx, 1E0h        ; isolate MONTH
                cmp     dx, 180h        ; > 12 ?
                pop     dx
                ja      short ft_err_invd ; yes, invalid
                cmp     al, 5           ; SET LAST ACCESS DATE AND TIME ?
                jnz     short ft10      ; no, SET CREATION DATE AND TIME
                mov     es:[di+12h], dx ; [es:di+dir_entry.dir_lstaccdate]
                jmp     short ft11
; ---------------------------------------------------------------------------

ft10:                                   ; ...
                mov     ax, cx          ; check time (set) values
                and     ax, 0F81Fh      ; isolate seconds/2 and hour
                cmp     ah, 0B8h        ; HOUR > 23 ?
                ja      short ft_err_invd ; yes, invalid
                cmp     al, 1Dh         ; SECONDS/2 > 29 (count of 2 seconds)
                ja      short ft_err_invd ; yes, invalid
                mov     ax, cx
                and     ax, 7E0h        ; isolate MINUTE
                cmp     ax, 760h        ; MINUTE > 59 ?
                ja      short ft_err_invd ; yes, invalid
                mov     es:[di+10h], dx ; [es:di+dir_entry.dir_crtdate]
                mov     es:[di+0Eh], cx ; [es:di+dir_entry.dir_crttime]

ft11:                                   ; ...
                test    byte ptr es:[bx+5], 40h ; [es:bx+BUFFINFO.buf_flags],buf_dirty
                jnz     short ft12
                call    INC_DIRTY_COUNT
                or      byte ptr es:[bx+5], 40h ; [es:bx+BUFFINFO.buf_flags],buf_dirty

ft12:                                   ; ...
                push    es
                pop     ds
                mov     di, bx          ; DS:DI - pointer to buffer
                mov     al, 0FFh        ; Drive number, -1 means do not check for drive
                call    CHECKFLUSH
                jb      short ft_error

ok_ret:                                 ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

$DUP:                                   ; ...
                mov     ax, bx          ; duplicate a jfn, bx = file handle
                call    JFNFree

DupErrorCheck:                          ; ...
                jnb     short dupjfn_1  ; free handle addr in ES:DI, new in BX
                jmp     LSeekError3     ; nope, bye
; ---------------------------------------------------------------------------

dupjfn_1:                               ; ...
                push    es
                push    di
                pop     si
                pop     ds              ; ds:si = (free) jfn address
                xchg    ax, bx          ; get back old handle
                call    CheckOwner      ; get sft in ES:DI
                jnb     short dupjfn_2
                jmp     short ft_errj   ; errors go home
; ---------------------------------------------------------------------------

dupjfn_2:                               ; ...
                call    DOS_Dup_Direct
                call    pJFNFromHandle  ; get pointer
                mov     bl, es:[di]     ; get SFT number
                mov     [si], bl        ; stuff in new SFT
                jmp     short ok_ret    ; and go home
; ---------------------------------------------------------------------------

$DUP2:                                  ; ...
                push    bx              ; force a dup on a particular jfn
                push    cx              ; bx = file handle, cx = new file handle
                mov     bx, cx
                call    $CLOSE          ; close destination handle
                pop     bx
                pop     ax              ; old in AX, new in BX
                call    pJFNFromHandle
                jmp     short DupErrorCheck ; check error and do dup

; =============== S U B R O U T I N E =======================================


CheckOwner      proc near               ; ...
                call    SFFromHandle
                jb      short co_ret_label
                push    ax
                test    ss:IsWin386, 1
                jz      short no_win386 ; win386 is not present
                xor     ax, ax          ; set the zero flag
                pop     ax
                jnz     short _skip_win386

CheckOwner_retn:                        ; ...
                retn
; ---------------------------------------------------------------------------

_skip_win386:                           ; ...
                jmp     short CheckOwner_err
; ---------------------------------------------------------------------------

no_win386:                              ; ...
                mov     ax, ss:USER_ID
                cmp     ax, es:[di+2Fh] ; [es:di+SF_ENTRY.sf_UID]
                pop     ax
                jz      short CheckOwner_retn

CheckOwner_err:                         ; ...
                mov     al, 6           ; error_invalid_handle
                stc

co_ret_label:                           ; ...
                retn
CheckOwner      endp

; ---------------------------------------------------------------------------

$AssignOper:                            ; ...
                cmp     al, 7           ; set in_use ?
                jnz     short chk08     ; no

srinuse:                                ; ...
                push    ax
                mov     al, dl          ; AL= drive id
                call    GetCDSFromDrv   ; ds:si -> cds
                pop     ax
                jb      short baddrv    ; bad drive
                cmp     word ptr [si+45h], 0 ; [SI+curdir.devptr]
                jz      short baddrv
                cmp     al, 7           ; set ?
                jnz     short resetdrv  ; no
                or      byte ptr [si+44h], 40h ; [SI+curdir.flags+1],(curdir_inuse>>8)
                jmp     short okdone
; ---------------------------------------------------------------------------

resetdrv:                               ; ...
                and     byte ptr [si+44h], 0BFh ; [SI+curdir.flags+1],(~curdir_inuse)>>8
                jmp     short okdone
; ---------------------------------------------------------------------------

baddrv:                                 ; ...
                mov     ax, 0Fh         ; error_invalid_drive
                jmp     short ASS_ERR
; ---------------------------------------------------------------------------

chk08:                                  ; ...
                cmp     al, 8           ; reset inuse ?
                jz      short srinuse   ; yes
                push    ax
                mov     ax, 111Eh
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
                                        ; SS = DOS CS
                                        ; STACK: WORD function to execute
                                        ; Return: CF set on error, AX = error code
                                        ; STACK unchanged
                pop     bx
                jb      short ASS_ERR

okdone:                                 ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

ASS_ERR:                                ; ...
                jmp     SYS_RET_ERR

; =============== S U B R O U T I N E =======================================


FIND_DPB        proc near               ; ...
                lds     si, ss:DPBHEAD  ; Find a DPB from a drive number

fdpb5:                                  ; ...
                cmp     si, 0FFFFh      ; -1
                jz      short fdpb10
                cmp     al, [si]        ; [SI+DPB.DRIVE]
                jz      short ret_label15 ; Carry clear (retz)
                lds     si, [si+19h]    ; [SI+DPB.NEXT_DPB]
                jmp     short fdpb5
; ---------------------------------------------------------------------------

fdpb10:                                 ; ...
                stc

ret_label15:                            ; ...
                retn
FIND_DPB        endp


; =============== S U B R O U T I N E =======================================


InitCDS         proc near               ; ...
                push    ax              ; set up an empty CDS
                                        ; AL has uppercase drive letter
                les     di, ss:THISCDS
                mov     word ptr es:[di+43h], 0 ; [ES:DI+curdir.flags] ; "free" CDS
                sub     al, 40h ; '@'   ; "A"-1  ; A = 1
                cmp     ss:NUMIO, al
                jb      short icdsx     ; Drive does not map a physical drive
                dec     ax              ; (AL) = 0 if A, 1 if B, etc.
                push    ax
                add     al, 'A'
                mov     ah, ':'
                mov     es:[di], ax     ; [ES:DI+curdir.text] ; set "x:"
                mov     word ptr es:[di+2], 5Ch ; '\' ; [ES:DI+curdir.text+2],"\"
                                        ; NUL terminate
                or      byte ptr es:[di+44h], 40h ; [ES:DI+curdir.flags+1],
                                        ; (curdir_inuse>>8)
                sub     ax, ax
                mov     es:[di+49h], ax ; [ES:DI+curdir.ID],0
                mov     es:[di+4Bh], ax ; [ES:DI+curdir.ID+2],0
                mov     al, 2
                mov     es:[di+4Fh], ax ; [ES:DI+curdir.end],2
                pop     ax              ; (al) = drive number
                push    ds
                push    si
                call    FIND_DPB
                jb      short icds5     ; OOOOPPPPPSSSS!!!!
                mov     es:[di+45h], si ; [ES:DI+curdir.devptr]
                mov     word ptr es:[di+47h], ds ; [ES:DI+curdir.devptr+2]

icds5:                                  ; ...
                pop     si
                pop     ds

icdsx:                                  ; ...
                pop     ax

RET45:                                  ; ...
                retn
InitCDS         endp

; ---------------------------------------------------------------------------

$UserOper:                              ; ...
                cmp     al, 1           ; get/set current user ID (for net)
                                        ; AL has function type
                jb      short UserGet   ; 0-get
                jz      short UserSet   ; 1-set
                cmp     al, 5           ; 5-printer-get-flags
                jbe     short UserPrint ; 2-printer-set
                                        ; 3-printer-get
                                        ; 4-printer-set-flags
                call    set_exerr_locus_unk
                mov     al, 1           ; error_invalid_function

useroper_error:                         ; ...
                jmp     short ASS_ERR
; ---------------------------------------------------------------------------

UserGet:                                ; ...
                push    ds              ; return to user the string
                pop     es
                mov     di, dx          ; destination
                mov     cx, ss:MYNUM    ; Get number
                call    Get_User_Stack
                mov     [si+4], cx      ; [SI+user_env.user_CX]
                                        ; Set number return
                push    ss
                pop     ds
                mov     si, offset MYNAME ; point source to user string

UserMove:                               ; ...
                mov     cx, 15
                rep movsb
                xor     ax, ax          ; 16th byte is 0
                stosb

UserBye:                                ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

UserSet:                                ; ...
                mov     ss:MYNUM, cx    ; set the current user
                mov     si, dx          ; user space has source
                push    ss
                pop     es
                mov     di, offset MYNAME ; point dest to user string
                inc     ss:DIFFNAM      ; signal change
                jmp     short UserMove
; ---------------------------------------------------------------------------

UserPrint:                              ; ...
                push    ax
                mov     ax, 111Fh
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
                                        ; STACK: WORD function
                                        ; Return: CF set on error, AX = error code
                                        ; STACK unchanged
                pop     dx
                jnb     short UserBye
                jmp     short useroper_error

; =============== S U B R O U T I N E =======================================


GetVisDrv       proc near               ; ...
                call    GETTHISDRV      ; correctly map non-spliced inuse drives
                                        ; get inuse drive
                jb      short RET45
                push    ds
                push    si
                lds     si, ss:THISCDS
                test    byte ptr [si+44h], 20h ; [SI+curdir.flags+1],(curdir_splice>>8)
                pop     si
                pop     ds
                jz      short RET45     ; if not spliced, return OK
                mov     ss:DrvErr, 0Fh  ; error_invalid_drive
                stc
                retn
GetVisDrv       endp


; =============== S U B R O U T I N E =======================================


GETTHISDRV      proc near               ; ...
                or      al, al          ; are we using default drive?
                jnz     short GTD10     ; no, go get the CDS pointers
                mov     al, ss:CURDRV   ; get the current drive
                inc     ax              ; Counteract next instruction

GTD10:                                  ; ...
                dec     ax              ; 0 = A
                push    ds
                push    si
                call    set_exerr_locus_disk
                cmp     ss:FSHARING, 0  ; Logical or Physical?
                jz      short GTD20     ; Logical
                push    ax
                push    es
                push    di
                mov     word ptr ss:THISCDS, offset DUMMYCDS
                mov     word ptr ss:THISCDS+2, ss
                add     al, 'A'
                call    InitCDS
                test    byte ptr es:[di+44h], 40h ; [ES:DI+curdir.flags+1],
                                        ; (curdir_inuse>>8)
                pop     di
                pop     es
                pop     ax
                jz      short GTD30
                jmp     short GTDX      ; carry clear
; ---------------------------------------------------------------------------

GTD20:                                  ; ...
                call    GetCDSFromDrv
                jb      short GTD30     ; Unassigned CDS -> return error already set
                test    byte ptr [si+44h], 40h ; [SI+curdir.flags+1],(curdir_inuse>>8)
                jnz     short GTDX

GTD30:                                  ; ...
                mov     al, 0Fh         ; error_invalid_drive ; invalid FAT drive
                mov     ss:DrvErr, al   ; save this for IOCTL
                call    set_exerr_locus_unk ; [ss:EXTERR_LOCUS],errLOC_Unk
                stc

GTDX:                                   ; ...
                pop     si
                pop     ds
                retn
GETTHISDRV      endp


; =============== S U B R O U T I N E =======================================


GetCDSFromDrv   proc near               ; ...
                cmp     al, ss:CDSCOUNT ; is this a valid designator ?
                jnb     short GetCDS_err ; error

GetCDS:                                 ; yes, get the macro
                push    bx
                push    ax
                lds     si, ss:CDSADDR  ; get pointer to table
                mov     bl, 88          ; curdir.size
                mul     bl              ; get net offset
                add     si, ax          ; convert to true pointer
                mov     word ptr ss:THISCDS, si
                mov     word ptr ss:THISCDS+2, ds
                pop     ax
                pop     bx
                clc                     ; no error
                retn
; ---------------------------------------------------------------------------

GetCDS_err:                             ; ...
                stc                     ; signal error
                retn
GetCDSFromDrv   endp


; =============== S U B R O U T I N E =======================================

; Attributes: bp-based frame

TransFCB        proc near               ; ...

FCBTmp          = byte ptr -10h

                push    bp
                mov     bp, sp
                sub     sp, 10h
                push    ss
                pop     es
                push    es
                push    di
                lea     di, [bp+FCBTmp] ; point to FCB temp area
                mov     ss:EXTFCB, 0    ; no extended FCB found
                mov     ss:SATTRIB, 0   ; default search attributes
                call    GetExtended     ; get FCB, extended or not
                jz      short GetDrive  ; not an extended FCB, get drive
                mov     al, [si-1]      ; get attributes
                mov     ss:SATTRIB, al  ; store search attributes
                mov     ss:EXTFCB, 0FFh ; -1 ; signal extended FCB

GetDrive:                               ; ...
                lodsb                   ; get drive byte
                call    GETTHISDRV
                jb      short BadPack
                call    TextFromDrive   ; convert 0-based drive to text
                mov     cx, 11
                push    si              ; back over name, ext

FCBScan:                                ; ...
                lodsb                   ; get a byte
                call    GetCharType     ; get flags
                test    al, 8           ; FFCB
                jz      short BadPack
                loop    FCBScan
                pop     si
                mov     bx, di
                call    PackName        ; crunch the path
                pop     di              ; get original destination
                pop     es
                push    ss
                pop     ds
                lea     si, [bp+FCBTmp] ; lea si,[bp-16] ; point at new pathname
                cmp     byte ptr [bx], 0
                jz      short BadPack
                push    bp
                call    TransPathSet    ; convert the path
                pop     bp
                jnb     short FCBRet

BadPack:                                ; ...
                stc
                mov     al, 3           ; error_path_not_found

FCBRet:                                 ; ...
                mov     sp, bp
                pop     bp

TransPath_retn:                         ; ...
                retn
TransFCB        endp


; =============== S U B R O U T I N E =======================================


TransPath       proc near               ; ...
                xor     al, al          ; 0
                jmp     short SetSplice
TransPath       endp


; =============== S U B R O U T I N E =======================================


TransPathSet    proc near               ; ...

; FUNCTION CHUNK AT BEF1 SIZE 000000A5 BYTES

                mov     al, 0FFh        ; -1

SetSplice:                              ; ...
                mov     ss:NoSetDir, al ; NoSetDir = !fExact
                mov     al, 0FFh        ; -1

TransPathNoSet:                         ; ...
                mov     ss:FSPLICE, al  ; fSplice = TRUE
                mov     ss:CMETA, 0FFh  ; -1
                mov     ss:WFP_START, di
                mov     ss:CURR_DIR_END, 0FFFFh ; -1 ; crack from start
                push    ss              ; DS:SI - point to ASCIZ string path
                                        ; DI - point to buffer in DOSDATA
                pop     es
                lea     bp, [di+134]    ; [DI+TEMPLEN] ; end of buffer
                cmp     ss:FSHARING, 0  ; if no sharing
                jz      short CheckUNC  ; skip to UNC check
                                        ; ES:DI point to buffer
                call    DriveFromText   ; get drive and advance DS:SI
                call    GETTHISDRV      ; Set ThisCDS and convert to 0-based
                jb      short NoPath
                call    TextFromDrive   ; drop in new
                lea     bx, [di+1]      ; backup limit
                call    Canonicalize    ; copy and canonicalize
                jb      short TransPath_retn ; errors
                push    ss
                pop     ds
                mov     si, ds:WFP_START ; point to name
                test    ds:FSPLICE, 0FFh
                jz      short NoServerSplice
                call    Splice

NoServerSplice:                         ; ...
                push    ss
                pop     ds
                les     di, ds:THISCDS  ; for FATREAD
                call    ECritDisk
                call    FATREAD_CDS
                call    LCritDisk

NoPath:                                 ; ...
                mov     al, 3           ; error_path_not_found
                                        ; (Set up for possible bad path error)
                retn                    ; (any errors are in Carry flag)
; ---------------------------------------------------------------------------

CheckUNC:                               ; ...
                mov     word ptr ss:THISCDS, 0FFFFh ; -1 ; NULL thisCDS
                mov     ax, 1123h       ; NetSpoolCheck
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
                                        ; DS:SI -> ASCIZ filename to canonicalize
                                        ; ES:DI -> 128-byte buffer for qualified name
                                        ; Return: CF set if not resolved
                jnb     short UNCDone
                call    DriveFromText   ; eat drive letter
                push    ax
                mov     ax, [si]        ; get first two bytes of path
                call    PATHCHRCMP      ; convert to normal form
                xchg    ah, al          ; swap for second byte
                call    PATHCHRCMP      ; convert to normal form
                jnz     short CheckDevice ; not a path char
                cmp     ah, al          ; are they same?
                jnz     short CheckDevice ; nope
                pop     ax              ; We have a UNC request
                                        ; (prefixed with two leading \\s)
                movsw                   ; get the lead \\.

UNCCpy:                                 ; ...
                lodsb                   ; get a byte
                call    UCase           ; convert the char
                or      al, al
                jz      short UNCTerm   ; end of string. All done.
                call    PATHCHRCMP      ; is it a path char?
                mov     bx, di          ; backup position
                stosb
                jnz     short UNCCpy    ; no, go copy
                call    Canonicalize    ; wham (and set cMeta)

UNCDone:                                ; ...
                push    ss
                pop     ds
                retn                    ; (return error code)
; ---------------------------------------------------------------------------

UNCTerm:                                ; ...
                stosb
                jmp     short UNCDone
; ---------------------------------------------------------------------------

CheckDevice:                            ; ...
                pop     ax              ; retrieve drive info
                cmp     byte ptr [si], 0 ; check for null file
                jnz     short CheckPath
                mov     al, 2           ; error_file_not_found
                stc
                retn
; ---------------------------------------------------------------------------

CheckPath:                              ; ...
                push    ax
                push    bp              ; save drive number
                call    no5Dshere
                pop     bp
                pop     ax
                jnb     short DoFile
                mov     ss:FSHARING, 0FFh ; -1 ; simulate sharing dos call
                call    GETTHISDRV      ; set ThisCDS and init DUMMYCDS
                mov     ss:FSHARING, 0
                call    TextFromDrive
                mov     al, 2Fh ; '/'   ; path separator
                stosb
                call    StrCpy          ; move remainder of string
                clc                     ; everything OK.
                push    ss
                pop     ds

DoFile_retn:                            ; ...
                retn
TransPathSet    endp

; ---------------------------------------------------------------------------

no5Dshere:                              ; ...
                jmp     CheckThisDevice ; snoop for device
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR TransPathSet

DoFile:                                 ; ...
                call    GetVisDrv       ; get proper CDS
                mov     al, 3           ; error_path_not_found
                jb      short DoFile_retn ; CARRY set -> bogus drive/spliced
                push    ds
                push    si
                push    es
                push    di
                call    ValidateCDS     ; poke CDS and make everything OK
                pop     di
                pop     es
                pop     si
                pop     ds
                mov     al, 3           ; error_path_not_found
                jb      short DoFile_retn
                push    ds
                push    si
                lds     si, ss:THISCDS  ; point to CDS
                mov     bx, di          ; point to destination
                add     bx, [si+4Fh]    ; [SI+curdir.end] ; point to backup limit
                lea     bp, [di+134]    ; [DI+TEMPLEN] ; regenerate end of buffer
                call    FStrCpy
                dec     di
                mov     al, 5Ch ; '\'   ; Make sure that there is a path char at end.
                cmp     es:[di-1], al
                jz      short GetOrig   ; get original string
                stosb

GetOrig:                                ; ...
                dec     di              ; point to path char
                pop     si
                pop     ds
                call    PathSep         ; is DS:SI a path sep?
                jnz     short PathAssure ; no, DI is correct. Assure a path char
                or      al, al          ; end of string?
                jz      short DoCanon   ; yes, skip.
                mov     di, bx          ; back up to root point.

SkipPath:                               ; ...
                lodsb
                call    PATHCHRCMP
                jz      short SkipPath
                dec     si
                or      al, al
                jz      short DoCanon

PathAssure:                             ; ...
                mov     al, 5Ch ; '\'   ; DS:SI start at some file name.
                                        ; ES:DI points at some path char.
                stosb

DoCanon:                                ; ...
                call    Canonicalize    ; ES:DI point to the correct spot
                                        ;      for canonicalization to begin.
                                        ; BP is the max extent to advance DI
                                        ; BX is the backup limit for
                jb      short DoFile_retn ; badly formatted path
                push    ss              ; The string has been moved to ES:DI.
                pop     ds
                mov     di, ds:WFP_START ; DS:SI point to string
                lds     si, ds:THISCDS  ; point to CDS
                call    PathPref        ; is there a prefix?
                jnz     short DoSplice  ; no, do splice
                                        ; yes, we have a match
                mov     al, [si-1]      ; last char to match
                call    PATHCHRCMP      ; did we end on a path char? (root)
                jz      short DoSplice  ; yes, no current dir here.
                cmp     byte ptr es:[di], 0 ; end at NUL?
                jz      short DoSplice  ; yes
                inc     di              ; point to after current path char
                mov     ss:CURR_DIR_END, di

DoSplice:                               ; ...
                push    ss              ; Splice the result.
                pop     ds              ; back to DOSDATA
                mov     si, ds:WFP_START ; point to beginning of string
                xor     cx, cx
                test    ds:FSPLICE, 0FFh ; -1
                jz      short SkipSplice
                call    Splice          ; replaces in place.

SkipSplice:                             ; ...
                push    ss
                pop     ds
                les     di, ds:THISCDS  ; point to correct drive
                test    word ptr es:[di+43h], 8000h ; [ES:DI+curdir.flags],
                                        ; curdir_isnet
                jnz     short Done      ; net, no fatread necessary (retnz)
                jcxz    short Done
                call    ECritDisk
                call    FATREAD_CDS
                call    LCritDisk
                mov     al, 3           ; error_path_not_found
                                        ; (Set up for possible bad path error)

Done:                                   ; ...
                retn                    ; (any errors in carry flag)
; END OF FUNCTION CHUNK FOR TransPathSet

; =============== S U B R O U T I N E =======================================


Canonicalize    proc near               ; ...
                lodsb                   ; copy a path and remove . and .. entries
                                        ; ; DS:SI - point to ASCIZ string path
                                        ; ; ES:DI - point to buffer
                                        ; ; BX - backup limit (offset from ES)
                                        ; ;      points to slash
                                        ; ; BP - end of buffer
                call    PATHCHRCMP      ; while (PathChr (*s))
                jnz     short CanonDec
                cmp     di, bp          ; if (d > dlim)
                jnb     short CanonBad  ; goto error;
                stosb
                jmp     short Canonicalize ; *d++ = *s++;
; ---------------------------------------------------------------------------

CanonDec:                               ; ...
                dec     si

CanonLoop:                              ; ...
                xor     ax, ax          ; 0
                cmp     [si], al        ; if (*s == 0) {
                jnz     short DoComponent
                cmp     byte ptr es:[di-1], 3Ah ; ':' ;  if (d[-1] == ':')
                jnz     short DoTerminate
                mov     al, 5Ch ; '\'   ; *d++ = '\';
                stosb
                mov     al, ah

DoTerminate:                            ; ...
                stosb                   ; *d++ = 0;
                clc                     ; return (0);
                retn
; ---------------------------------------------------------------------------

CanonBad:                               ; ...
                call    ScanPathChar    ; check for path chars in rest of string
                mov     al, 3           ; error_path_not_found
                                        ; (Set up for bad path error)
                jz      short PathEnc   ; path character encountered in string
                mov     al, 2           ; error_file_not_found
                                        ; (Set bad file error)

PathEnc:                                ; ...
                stc

CanonBad_retn:                          ; ...
                retn
; ---------------------------------------------------------------------------

DoComponent:                            ; ...
                call    CopyComponent   ; if (!CopyComponent (s, d))
                jb      short CanonBad_retn ; return (-1);
                cmp     word ptr es:[di], 2Eh ; '.' ; '.' + (0 SHL 8)
                jz      short Skip1
                cmp     word ptr es:[di], 2E2Eh ; '..'
                jnz     short CanonNormal
                dec     di              ; d--;

Skip1:                                  ; ...
                call    SkipBack        ; SkipBack ();
                mov     al, 3           ; error_path_not_found
                jb      short CanonBad_retn
                jmp     short CanonPath
; ---------------------------------------------------------------------------

CanonNormal:                            ; ...
                add     di, cx          ; else
                                        ;    d += ct;

CanonPath:                              ; ...
                call    PathSep
                jnz     short CanonBad  ; something else...
                lodsb                   ; get the char
                call    PATHCHRCMP      ; is it path char?
                jnz     short CanonDec  ; no, go test for nul
                cmp     di, bp          ; beyond buffer end?
                jnb     short CanonBad  ; yep, error.
                stosb                   ; copy the one byte

CanonPathLoop:                          ; ...
                lodsb                   ; get next byte
                call    PATHCHRCMP      ; path char again?
                jz      short CanonPathLoop ; yep, grab another
                dec     si              ; back up
                jmp     short CanonLoop ; go copy component
Canonicalize    endp


; =============== S U B R O U T I N E =======================================


PathSep         proc near               ; ...
                mov     al, [si]        ; determine if char is a path separator
PathSep         endp


; =============== S U B R O U T I N E =======================================


PathSepGotCh    proc near               ; ...
                or      al, al          ; test for zero
                jz      short CanonBad_retn ; return if equal to zero (NUL)
                call    PATHCHRCMP      ; check for path character
                retn                    ; and return HIS determination
PathSepGotCh    endp


; =============== S U B R O U T I N E =======================================


SkipBack        proc near               ; ...
                cmp     di, bx          ; while (TRUE) {
                jb      short SkipBad   ; if (d < dlim)
                dec     di              ; goto err;
                mov     al, es:[di]     ; if (pathchr (*--d))
                call    PATHCHRCMP      ; break;
                jnz     short SkipBack
                clc                     ; return (0);
                retn
; ---------------------------------------------------------------------------

SkipBad:                                ; ...
                mov     al, 3           ; error_path_not_found ; bad path error
                stc                     ; return (-1);
                retn
SkipBack        endp


; =============== S U B R O U T I N E =======================================


CopyComponent   proc near               ; ...
                sub     sp, 14          ; room for temp buffer
                push    ds
                push    si
                push    es
                push    di
                push    bp
                mov     bp, sp
                mov     ah, 2Eh ; '.'
                lodsb
                stosb
                cmp     al, ah          ; if ((*d++=*s++) == '.') {
                jnz     short NormalComp
                call    PathSep         ; if (!pathsep(*s))
                jz      short NulTerm
                lodsb                   ; if ((*d++=*s++) != '.'
                stosb
                cmp     al, ah
                jnz     short CopyBad
                call    PathSep
                jnz     short CopyBad   ; || !pathsep (*s))
                                        ; return -1;

NulTerm:                                ; ...
                xor     al, al          ; *d++ = 0;
                stosb
                mov     [bp+6], si      ; CopySoff
                jmp     short _GoodRet  ;     }
; ---------------------------------------------------------------------------

NormalComp:                             ; ...
                mov     si, [bp+6]      ; CopySoff
                                        ; else {
                call    NameTrans       ; s = NameTrans (s, Name1);
                cmp     si, [bp+6]      ; CopySoff
                jz      short CopyBad   ; if (s == CopySOff)
                                        ;    return (-1);
                cmp     ss:FSHARING, 0  ; if (!fSharing) {
                jnz     short DoPack
                and     dl, 1
                add     ss:CMETA, dl    ; cMeta += fMeta;
                jg      short CopyBad   ; if (cMeta > 0)
                                        ;   return (-1);
                jnz     short DoPack
                or      dl, dl          ; else
                                        ;   if (cMeta == 0 && fMeta == 0
                jz      short CopyBadPath ; return (-1);

DoPack:                                 ; ...
                mov     [bp+6], si      ; CopySoff
                push    ss
                pop     ds
                mov     si, offset NAME1
                lea     di, [bp+10]     ; CopyTemp
                push    di
                call    PackName        ; PackName (Name1, temp);
                pop     di
                call    StrLen          ; if (strlen(temp)+d > bp)
                dec     cx
                add     cx, [bp+2]      ; CopyDoff
                cmp     cx, [bp+0]      ; CopyB
                jnb     short CopyBad   ; return (-1);
                mov     si, di          ; strcpy (d, temp);
                les     di, [bp+2]      ; CopyD
                call    FStrCpy         ;   }

_GoodRet:                               ; ...
                clc
                jmp     short CopyEnd   ; return 0;
; ---------------------------------------------------------------------------

CopyBad:                                ; ...
                stc
                call    ScanPathChar    ; check for path chars in rest of string
                mov     al, 2           ; error_file_not_found
                jnz     short CopyEnd

CopyBadPath:                            ; ...
                stc
                mov     al, 3           ; error_path_not_found

CopyEnd:                                ; ...
                pop     bp
                pop     di
                pop     es
                pop     si
                pop     ds
                lahf
                add     sp, 14          ; reclaim temp buffer
                call    StrLen
                dec     cx
                sahf
                retn
CopyComponent   endp


; =============== S U B R O U T I N E =======================================


Splice          proc near               ; ...
                test    ss:SPLICES, 0FFh ; pseudo mount by string substitution
                jz      short AllDone
                push    word ptr ss:THISCDS
                push    word ptr ss:THISCDS+2 ; TmpCDS = ThisCDS
                push    ds
                push    si
                pop     di
                pop     es
                xor     ax, ax          ; for (i=1; s = GetCDSFromDrv (i); i++)

SpliceScan:                             ; ...
                call    GetCDSFromDrv
                jb      short SpliceDone
                inc     al
                test    word ptr [si+43h], 2000h ; [SI+curdir.flags],curdir_splice
                jz      short SpliceScan
                push    di              ; if ( Spliced (i) ) {
                call    PathPref        ; if (!PathPref (s, d))
                jz      short SpliceFound

SpliceSkip:                             ; ...
                pop     di
                jmp     short SpliceScan ; continue;
; ---------------------------------------------------------------------------

SpliceFound:                            ; ...
                cmp     byte ptr es:[di], 0 ; if (*s || NoSetDir) {
                jnz     short SpliceDo
                test    ss:NoSetDir, 0FFh
                jnz     short SpliceSkip

SpliceDo:                               ; ...
                mov     si, di          ; p = src + strlen (p);
                push    es
                pop     ds
                pop     di
                call    TextFromDrive1  ; src = TextFromDrive1(src,i);
                mov     ax, ss:CURR_DIR_END
                or      ax, ax
                js      short NoPoke
                add     ax, di          ; curdirend += src-p;
                sub     ax, si
                mov     ss:CURR_DIR_END, ax

NoPoke:                                 ; ...
                cmp     byte ptr [si], 0 ; if (*p)
                jnz     short SpliceCopy ; *src++ = '\\';
                mov     al, 5Ch ; '\'
                stosb

SpliceCopy:                             ; ...
                call    FStrCpy         ; strcpy (src, p);
                add     sp, 4           ; throw away saved stuff
                or      cl, 1           ; signal splice done.
                jmp     short DoSet     ; return;
; ---------------------------------------------------------------------------

SpliceDone:                             ; ...
                pop     word ptr ss:THISCDS+2 ;  }
                pop     word ptr ss:THISCDS ; ThisCDS = TmpCDS;

AllDone:                                ; ...
                xor     cx, cx

DoSet:                                  ; ...
                lds     si, ss:THISCDS  ; ThisDPB = ThisCDS->devptr;
                les     di, [si+45h]    ; [SI+curdir.devptr]
                mov     word ptr ss:THISDPB, di
                mov     word ptr ss:THISDPB+2, es

Splice_retn:                            ; ...
                retn
Splice          endp

; ---------------------------------------------------------------------------

$NameTrans:                             ; ...
                push    ds              ; partially process a name
                push    si
                push    es
                push    di              ; DS:SI - source string for translation
                                        ; ES:DI - pointer to buffer
                push    cx
                mov     ch, 16h
                call    SetAttrib       ; attr_hidden+attr_system+attr_directory
                mov     di, offset OPENBUF
                call    TransPath       ; to translation (everything)
                pop     cx
                pop     di
                pop     es
                pop     si
                pop     ds
                jnb     short TransOK
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

TransOK:                                ; ...
                mov     si, offset OPENBUF
                push    ss
                pop     ds
                call    FStrCpy
                jmp     SYS_RET_OK

; =============== S U B R O U T I N E =======================================


DriveFromText   proc near               ; ...
                xor     al, al          ; 0 ; return drive number from a text string
                cmp     byte ptr [si], 0
                jz      short Splice_retn
                cmp     byte ptr [si+1], 3Ah ; ':'
                jnz     short Splice_retn
                lodsw
                or      al, 20h         ; convert to lowercase
                sub     al, 60h         ; 'a'-1
                jnz     short Splice_retn ; al = drv number
                mov     al, 0FFh        ; nuke AL...
                retn                    ; AL has drive number
DriveFromText   endp


; =============== S U B R O U T I N E =======================================


TextFromDrive   proc near               ; ...
                inc     al              ; convert a drive number to a text string

TextFromDrive1:                         ; ...
                add     al, 40h ; '@'   ; 'A'-1 ; *d++ = drive-1+'A';
                mov     ah, 3Ah ; ':'   ; strcat (d, ":");
                stosw

PathPref_retn:                          ; ...
                retn
TextFromDrive   endp


; =============== S U B R O U T I N E =======================================


PathPref        proc near               ; ...
                call    DStrLen         ; see if one path is a prefix of another
                dec     cx              ; get length
                                        ; do not include nul byte
                repe cmpsb              ; compare
                jnz     short PathPref_retn ; return NZ
                push    ax
                mov     al, [si-1]      ; get last byte to match
                call    PATHCHRCMP      ; is it a path char (Root!)
                jz      short Prefix    ; yes, match root (I hope)
                mov     al, es:[di]     ; get next char to match
                call    PathSepGotCh    ; was it a pathchar?

Prefix:                                 ; ...
                pop     ax
                retn                    ; (if) Zero flag set => prefix found
PathPref        endp


; =============== S U B R O U T I N E =======================================


ScanPathChar    proc near               ; ...
                lodsb                   ; fetch a character
                call    PathSepGotCh
                jnz     short ScanPathChar ; not \, / or NUL => go back for more
                call    PATHCHRCMP      ; path separator?
                retn
ScanPathChar    endp


; =============== S U B R O U T I N E =======================================


$OPEN           proc near               ; ...
                xor     ah, ah          ; General file open/create code

$Open2:                                 ; ...
                mov     ch, 16h         ; attr_hidden+attr_system+attr_directory
                call    SetAttrib
                mov     cx, offset DOS_OPEN
                push    ax

AccessFile:                             ; ...
                call    ECritDisk       ; call ECritSFT
                call    SFNFree         ; get a free sfn
                call    LCritDisk       ; call LCritSFT
                jb      short OpenFailJ ; oops, no free sft's
                mov     ss:SFN, bx
                mov     word ptr ss:THISSFT, di
                mov     word ptr ss:THISSFT+2, es
                call    JFNFree         ; get a free jfn

OpenFailJ:                              ; ...
                jb      short OpenFail

SaveJFN:                                ; there were free JFNs... try SFN
                mov     word ptr ss:PJFN, di
                mov     word ptr ss:PJFN+2, es
                mov     ss:JFN, bx
                mov     bx, ss:SFN
                mov     si, dx          ; get name in appropriate place
                mov     es:[di], bl     ; assign the JFN
                mov     di, offset OPENBUF
                push    cx
                call    TransPath       ; convert the path
                pop     bx
                lds     si, ss:THISSFT
                jb      short OpenClean
                cmp     ss:CMETA, 0FFh
                jz      short SetSearch ; no error, go and open file
                mov     al, 2           ; error_file_not_found
                                        ; no meta chars allowed
                jmp     short OpenClean
; ---------------------------------------------------------------------------

OpenFail:                               ; ...
                sti
                pop     cx              ; Clean stack
                jmp     short OpenCritLeave
; ---------------------------------------------------------------------------

SetSearch:                              ; ...
                pop     ax              ; Mode (Open), Attributes (Create)
                xor     cx, cx          ; 0
                cmp     bx, offset DOS_OPEN
                mov     [si+2], cx      ; [SI+SF_ENTRY.sf_mode],0
                                        ; initialize mode field to 0
                mov     [si+33h], cx    ; [SI+SF_ENTRY.sf_MFT],0
                                        ; clean out sharing info
                jnz     short _DoOper
                test    al, 80h         ; SHARING_NO_INHERIT
                jz      short _DoOper
                and     al, 7Fh         ; mask off inherit bit
                mov     cx, 1000h       ; sf_no_inherit

_DoOper:                                ; ...
                push    di
                push    es
                push    ds
                pop     es
                push    si
                pop     di              ; (es:di) = SFT address
                call    Set_EXT_mode
                pop     es
                pop     di
                push    ss
                pop     ds
                push    cx
                call    bx              ; DOS_OPEN (or DOS_CREATE)
                pop     cx
                lds     si, ds:THISSFT
                jb      short OpenE2    ; check extended open hooks first
                mov     word ptr [si], 1 ; SF_ENTRY.sf_ref_count
                or      [si+5], cx      ; SF_ENTRY.sf_flags
                push    ds
                pop     es
                mov     di, si
                call    set_sftfcb_entry ; set SFT-FCB entry
                                        ; in the internal (SFT_FCB) table
                                        ; (used for FCB calls only!)
                mov     ax, ss:JFN
                call    ss:ShCol        ; Call far [ss:JShare+(12*4)] ; 12 = ShCol
                mov     ss:SFN, 0FFFFh  ; -1 ; clear out sfn pointer
                jmp     SYS_RET_OK      ; bye with no errors
; ---------------------------------------------------------------------------

OpenE2:                                 ; ...
                cmp     ax, 87          ; error_invalid_parameter
                                        ; (Extended Open hooks check)
                jnz     short OpenE     ; (not IFS extended open)
                jmp     short OpenCritLeave ; keep handle
; ---------------------------------------------------------------------------

OpenClean:                              ; ...
                pop     bx              ; clean off stack

OpenE:                                  ; ...
                mov     word ptr [si], 0 ; [SI+SF_ENTRY.sf_ref_count],0
                                        ; release SFT
                lds     si, ss:PJFN
                mov     byte ptr [si], 0FFh ; free the SFN...

OpenCritLeave:                          ; ...
                mov     ss:SFN, 0FFFFh  ; -1 ; remove mark.
                cmp     ss:EXTERR, 37   ; error_Code_Page_Mismatched
                jnz     short NORERR
                jmp     From_GetSet
; ---------------------------------------------------------------------------

NORERR:                                 ; ...
                jmp     SYS_RET_ERR
$OPEN           endp


; =============== S U B R O U T I N E =======================================


$CREAT          proc near               ; ...
                push    cx              ; create a new file and open him for input
                mov     cx, offset DOS_CREATE
$CREAT          endp

; START OF FUNCTION CHUNK FOR $CreateNewFile

AccessSet:                              ; ...
                mov     ss:SATTRIB, 6   ; attr_hidden+attr_system
                jmp     AccessFile
; END OF FUNCTION CHUNK FOR $CreateNewFile
; ---------------------------------------------------------------------------

$CHMOD:                                 ; ...
                cmp     al, 0FFh        ; MS-DOS 7.20 (Win98) - EXTENDED-LENGTH FILENAME OPERATIONS
                                        ; AX = 43FFh
                                        ; BP = 5053h ('PS')
                                        ; CL = function
                                        ; 39h "mkdir" create directory
                                        ; DS:DX -> ASCIZ pathname
                                        ; 56h rename file
                                        ; DS:DX -> ASCIZ filename of existing file (no wildcards)
                                        ; ES:DI -> ASCIZ new filename (no wildcards)
                                        ;
                                        ; ref: Ralf Brown's Interrupt List
                jnz     short std_chmod
                cmp     bp, 5053h
                jnz     short chmod_x_2
                mov     ah, cl
                mov     ss:PATHNAMELEN, 128 ; ((mov byte [ss:PATHNAMELEN],128)) ; Retro DOS v5.0
                cmp     cl, 39h
                jnz     short chmod_x_1
                jmp     mkdir_x
; ---------------------------------------------------------------------------

chmod_x_1:                              ; ...
                cmp     cl, 56h
                jz      short rename_x

chmod_x_2:                              ; ...
                mov     al, 1
                jmp     short NORERR
; ---------------------------------------------------------------------------

std_chmod:                              ; ...
                mov     di, offset OPENBUF
                push    ax
                push    cx
                mov     si, dx
                call    TransPathSet    ; get correct path
                pop     cx
                pop     ax
                jb      short NotFound
                push    ss              ; ChModErr
                pop     ds
                cmp     ds:CMETA, 0FFh  ; -1
                jnz     short NotFound
                mov     ds:SATTRIB, 16h ; attr_hidden+attr_system+attr_directory
                sub     al, 1           ; fast way to discriminate
                jb      short ChModGet  ; 0 -> go get value
                jz      short ChModSet  ; 1 -> go set value
                call    set_exerr_locus_unk
                mov     al, 1           ; error_invalid_function ; bad value

chmod_errj:                             ; ...
                jmp     short NORERR
; ---------------------------------------------------------------------------

ChModGet:                               ; ...
                call    GET_FILE_INFO   ; suck out the ol' info
                jb      short ChModE    ; error codes are already set for ret
                call    Get_User_Stack
                mov     [si+4], ax      ; [SI+user_env.user_CX]
                                        ; return the attributes

OpenOkj:                                ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

ChModSet:                               ; ...
                mov     ax, cx          ; get attrs in position
                call    SET_FILE_ATTRIBUTE
                jb      short ChModE
                jmp     short UnLinkOK
; ---------------------------------------------------------------------------

NotFound:                               ; ...
                mov     al, 3           ; error_path_not_found

ChModE:                                 ; ...
                jmp     short chmod_errj
; ---------------------------------------------------------------------------

$UNLINK:                                ; ...
                push    cx              ; Delete a File
                mov     si, dx          ; Point at input string
                mov     di, offset OPENBUF ; temp spot for path
                call    TransPathSet    ; go get normalized path
                pop     cx              ; search attributes
                jb      short NotFound  ; badly formed path
                cmp     ss:CMETA, 0FFh  ; -1 ; meta chars?
                jnz     short NotFound
                push    ss
                pop     ds
                mov     ch, 6           ; attr_hidden+attr_system
                                        ; unlink appropriate files
                call    SetAttrib
                call    DOS_DELETE      ; remove that file

UnlinkE:                                ; ...
                jb      short ChModE

UnLinkOK:                               ; ...
                jmp     short OpenOkj
; ---------------------------------------------------------------------------

$RENAME:                                ; ...
                mov     ss:PATHNAMELEN, 67

rename_x:                               ; ...
                push    cx              ; cx = search attributes
                push    ds
                push    dx              ; DS:DX = source
                push    es
                pop     ds              ; ES:DI = destination
                mov     si, di          ; move dest to source
                mov     di, offset RENBUF
                call    TransPathSet    ; munge the paths
                push    ss:WFP_START    ; get pointer
                pop     ss:REN_WFP      ; stash it
                pop     si
                pop     ds
                pop     cx

epjc2:                                  ; ...
                jb      short NotFound  ; get old error
                cmp     ss:CMETA, 0FFh  ; -1
                jnz     short NotFound
                push    cx
                mov     di, offset OPENBUF ; appropriate buffer
                call    TransPathSet
                pop     cx
                jb      short epjc2
                push    ss
                pop     ds
                cmp     ds:CMETA, 0FFh  ; -1
                jb      short NotFound
                les     di, ds:THISCDS
                push    di
                push    es
                mov     di, offset OPENBUF
                push    ss
                pop     es              ; es:di-> source
                xor     al, al          ; scan all CDS

rnloop:                                 ; ...
                call    GetCDSFromDrv
                jb      short dorn      ; end of CDS
                call    StrCmp          ; current dir ?
                jz      short rnerr     ; yes
                inc     al              ; next
                jmp     short rnloop
; ---------------------------------------------------------------------------

rnerr:                                  ; ...
                pop     ax              ; ADD SP,4
                pop     ax
                mov     al, 16          ; error_current_directory
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

dorn:                                   ; ...
                pop     word ptr ss:THISCDS+2
                pop     word ptr ss:THISCDS
                push    ss
                pop     ds
                mov     ch, 16h         ; attr_directory+attr_hidden+attr_system
                call    SetAttrib
                call    DOS_RENAME      ; do the deed
                jb      short UnlinkE
                jmp     short UnLinkOK

; =============== S U B R O U T I N E =======================================


$CreateNewFile  proc near               ; ...

; FUNCTION CHUNK AT C273 SIZE 00000009 BYTES

                push    cx              ; Save attributes on stack
                mov     cx, offset DOS_Create_New ; routine to call
                jmp     AccessSet       ; use good ol' open
$CreateNewFile  endp


; =============== S U B R O U T I N E =======================================


BinToAscii      proc near               ; ...
                push    ax              ; convert a number to a string
                                        ; (in order to generate temp file names)
                                        ; ax = value
                xchg    ah, al
                aam     10h             ; AH = AL / 16 and AL = remainder
                add     ax, 4141h       ; 'AA'
                stosw
                pop     ax
                aam     10h             ; db 0D4h,10h
                add     ax, 4141h       ; add ax,'AA'
                stosw
                retn
BinToAscii      endp

; ---------------------------------------------------------------------------

$CreateTempFile:                        ; ...
                push    bp              ; create a unique name
                mov     bp, sp
                sub     sp, 10
                test    cx, 0FFD8h      ; ~attr_changeable
                jz      short OKatts    ; Ok if no non-changeable bits set
                mov     ax, 5           ; error_access_denied
                jmp     short SETTMPERR
; ---------------------------------------------------------------------------

OKatts:                                 ; ...
                mov     [bp-10], cx     ; attr
                mov     [bp-8], dx      ; FilPtrL ; pointer to file
                mov     word ptr [bp-6], ds ; FilPtrH
                mov     word ptr [bp-2], ds ; EndPtrH ; seg pointer to end of dir
                push    ds
                pop     es              ; destination for nul search
                mov     di, dx
                mov     cx, di
                neg     cx              ; number of bytes remaining in segment
                or      cx, cx
                jnz     short okok
                dec     cx              ; -1

okok:                                   ; ...
                xor     ax, ax
                repne scasb
                dec     di              ; point back to the null
                mov     al, es:[di-1]   ; Get char before the NUL
                call    PATHCHRCMP      ; Is it a path separator?
                jz      short SETENDPTR ; Yes
                mov     al, 5Ch ; '\'
                stosb                   ; Add a path separator (and INC DI)

SETENDPTR:                              ; ...
                mov     [bp-4], di      ; EndPtrL ; pointer to the tail

CreateLoop:                             ; ...
                push    ss              ; let ReadTime see variables
                pop     ds
                push    bp
                call    READTIME        ; go get time
                pop     bp
                les     di, [bp-4]      ; EndPtr ; point to the string
                mov     ax, cx
                call    BinToAscii      ; store upper word
                mov     ax, dx
                call    BinToAscii      ; store lower word
                xor     al, al
                stosb                   ; nul terminate
                lds     dx, [bp-8]      ; FilPtr ; get name
                mov     cx, [bp-10]     ; Attr ; get attr
                push    bp
                call    $CreateNewFile  ; try to create a new file
                pop     bp
                jnb     short CreateDone ; failed, go try again
                cmp     al, 50h         ; error_file_exists
                jz      short CreateLoop
                cmp     al, 5           ; error_access_denied
                jnz     short SETTMPERR
                mov     al, byte ptr ss:EXTERR
                cmp     al, 41h         ; error_net_access_denied
                jz      short SETTMPERR
                cmp     al, 53h         ; error_FAIL_I24
                jz      short SETTMPERR
                cmp     al, 50h         ; error_file_exists
                jz      short CreateLoop
                les     di, ss:THISCDS
                cmp     di, 0FFFFh
                jz      short CreateLoop
                test    word ptr es:[di+43h], 8000h
                jnz     short CreateLoop

SETTMPERR:                              ; ...
                stc

CreateDone:                             ; ...
                mov     sp, bp
                pop     bp
                jb      short CreateFail
                jmp     SYS_RET_OK      ; success!
; ---------------------------------------------------------------------------

CreateFail:                             ; ...
                jmp     SYS_RET_ERR

; =============== S U B R O U T I N E =======================================


SetAttrib       proc near               ; ...
                cmp     ss:FSHARING, 0  ; fSharing == FALSE => set sattrib to CH
                                        ; fSharing == TRUE => set sattrib to CL
                jnz     short Set
                mov     cl, ch

Set:                                    ; ...
                mov     ss:SATTRIB, cl
                retn
SetAttrib       endp

; ---------------------------------------------------------------------------

$Extended_Open:                         ; ...
                mov     ss:EXTOPEN_FLAG, dx ; save ext. open flag
                mov     ss:EXTOPEN_IO_MODE, 0 ; initialize IO mode
                test    dh, 0FEh        ; RESERVED_BITS_MASK>>8
                                        ; reserved bits 0 ?
                jnz     short ext_inval2 ; no
                mov     ah, dl
                cmp     dl, 0           ; all fail ?
                jz      short ext_inval2 ; yes, error
                and     dl, 0Fh         ; EXISTS_MASK ; get exists action byte
                cmp     dl, 2
                ja      short ext_inval2
                and     ah, 0F0h        ; NOT_EXISTS_MASK ; get no exists action byte
                cmp     ah, 10h
                ja      short ext_inval2
                mov     ss:SAVE_ES, es  ; save API parms
                mov     ss:SAVE_DI, di
                push    ss:EXTOPEN_FLAG
                pop     ss:SAVE_DX
                mov     ss:SAVE_CX, cx
                mov     ss:SAVE_BX, bx
                mov     ss:SAVE_DS, ds
                mov     ss:SAVE_SI, si
                mov     dx, si          ; ds:dx points to file name
                mov     ax, bx          ; ax= mode
                jmp     short goopen2
; ---------------------------------------------------------------------------

ext_inval2:                             ; ...
                mov     al, 1           ; error_invalid_function ; invalid function
                jmp     short CreateFail
; ---------------------------------------------------------------------------

goopen2:                                ; ...
                test    bh, 20h         ; INT_24_ERROR>>8
                jz      short goopen
                or      ss:EXTOPEN_ON, 2 ; EXT_OPEN_I24_OFF ; set bit to disable

goopen:                                 ; ...
                or      ss:EXTOPEN_ON, 1 ; EXT_OPEN_ON ; set Extended Open active
                mov     byte ptr ss:EXTOPEN_FLAG+1, 0
                cmp     byte ptr ss:EXTOPEN_FLAG, 10h ; EXT_EXISTS_FAIL+EXT_NEXISTS_CREATE
                jnz     short chknext
                call    $CreateNewFile
                jb      short error_return
                cmp     ss:EXTOPEN_ON, 0
                jz      short ok_return2
                mov     ss:EXTOPEN_FLAG, 2 ; ACTION_CREATED_OPENED
                jmp     setXAttr
; ---------------------------------------------------------------------------

ok_return2:                             ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

chknext:                                ; ...
                test    byte ptr ss:EXTOPEN_FLAG, 1 ; EXT_EXISTS_OPEN
                jnz     short exist_open ; must be replace open
                call    $CREAT
                jb      short error_return
                cmp     ss:EXTOPEN_ON, 0
                jz      short ok_return2
                mov     ss:EXTOPEN_FLAG, 2 ; ACTION_CREATED_OPENED
                test    ss:EXTOPEN_ON, 4 ; EXT_FILE_NOT_EXISTS
                jnz     short setXAttr
                mov     ss:EXTOPEN_FLAG, 3 ; ACTION_REPLACED_OPENED
                jmp     short setXAttr
; ---------------------------------------------------------------------------

error_return2:                          ; ...
                stc

error_return:                           ; ...
                retn
; ---------------------------------------------------------------------------

exist_open:                             ; ...
                cmp     ss:FSHARING, 0  ; server doscall?
                jz      short noserver  ; no
                mov     cl, ch          ; cl=search attribute

noserver:                               ; ...
                call    $Open2
                jnb     short ext_ok
                cmp     ss:EXTOPEN_ON, 0
                jz      short error_return2
                cmp     ax, 2           ; error_file_not_found
                jnz     short error_return2
                test    ss:EXTOPEN_FLAG, 10h ; EXT_NEXISTS_CREATE
                jnz     short do_creat

extexit:                                ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

do_creat:                               ; ...
                mov     cx, ss:SAVE_CX  ; get ds:dx for file name
                lds     si, dword ptr ss:SAVE_SI ; cx = attribute;
                mov     dx, si
                call    $CREAT          ; do create
                jb      short extexit
                mov     ss:EXTOPEN_FLAG, 2 ; ACTION_CREATED_OPENED
                jmp     short setXAttr  ; set XAs
; ---------------------------------------------------------------------------

ext_ok:                                 ; ...
                cmp     ss:EXTOPEN_ON, 0 ; IFS call ?
                jz      short ok_return ; yes
                mov     ss:EXTOPEN_FLAG, 1 ; ACTION_OPENED

setXAttr:                               ; ...
                push    ax
                call    Get_User_Stack
                mov     ax, ss:EXTOPEN_FLAG
                mov     [si+4], ax      ; [SI+user_env.user_CX] ; set action code for cx
                pop     ax
                mov     [si], ax        ; [SI+user_env.user_AX] ; set handle for ax

ok_return:                              ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

$LockOper:                              ; ...
                cmp     al, 1           ; Lock Calls
                ja      short lock_bad_func
                push    di
                call    SFFromHandle
                jnb     short lock_do
                pop     di
                mov     al, 6           ; error_invalid_handle

lockoperr:                              ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

lock_bad_func:                          ; ...
                call    set_exerr_locus_unk ; mov byte [SS:EXTERR_LOCUS],errLOC_Unk
                mov     al, 1           ; error_invalid_function

lockoperrj:                             ; ...
                jmp     short lockoperr
; ---------------------------------------------------------------------------

lock_do:                                ; ...
                mov     bx, ax
                mov     bp, offset Lock_Buffer
                mov     [bp+0], dx      ; [bp+LockBuf.Lock_position] ; set low offset
                mov     [bp+2], cx      ; [bp+LockBuf.Lock_position+2] ; set high offset
                pop     word ptr [bp+4] ; [bp+LockBuf.Lock_length] ; set low length
                mov     [bp+6], si      ; [bp+LockBuf.Lock_length+2] ; set high length
                mov     cx, 1           ; one range
                push    ss
                pop     ds
                mov     dx, bp
                test    al, 1           ; UNLOCK_ALL ; function 1 ?
                jnz     short DOS_Unlock ; yes
                jmp     short DOS_Lock  ; function 0
; ---------------------------------------------------------------------------

DOS_Unlock:                             ; ...
                test    byte ptr es:[di+6], 80h ; [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
                jz      short LOCAL_UNLOCK
                mov     ax, 110Ah
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
                                        ; BX = file handle, CX:DX = starting offset, SI = high word of size
                                        ; STACK: WORD low word of size, ES:DI -> SFT
                                        ; SFT DPB field -> DPB of drive containing file, SS = DOS CS
                                        ; Return: CF set error
                jmp     short ValChk
; ---------------------------------------------------------------------------

LOCAL_UNLOCK:                           ; ...
                call    ds:clr_block    ; Call far [JShare+(7*4)] ; 7 = clr_block

ValChk:                                 ; ...
                jnb     short Lock_OK
                jmp     short lockoperrj
; ---------------------------------------------------------------------------

Lock_OK:                                ; ...
                mov     ax, ds:TEMP_VAR
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

DOS_Lock:                               ; ...
                test    byte ptr es:[di+6], 80h ; [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
                jz      short LOCAL_LOCK
                mov     ax, 110Ah
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
                                        ; BX = file handle, CX:DX = starting offset, SI = high word of size
                                        ; STACK: WORD low word of size, ES:DI -> SFT
                                        ; SFT DPB field -> DPB of drive containing file, SS = DOS CS
                                        ; Return: CF set error
                jmp     short ValChk
; ---------------------------------------------------------------------------

LOCAL_LOCK:                             ; ...
                call    ds:set_block    ; Call far [JShare+(6*4)] ; 6 = Set_Block
                jmp     short ValChk

; =============== S U B R O U T I N E =======================================


LOCK_CHECK      proc near               ; ...
                mov     bx, ds:RetryCount ; Number retries

LockRetry:                              ; ...
                push    bx
                push    ax
                call    ds:chk_block    ; call far [JShare+(8*4)] ; 8 = chk_block
                pop     ax
                pop     bx
                jnb     short lc_ret_label ; There are no locks (retnc)
                call    Idle            ; wait a while
                dec     bx              ; remember a retry
                jnz     short LockRetry ; more retries left...
                stc

lc_ret_label:                           ; ...
                retn
LOCK_CHECK      endp


; =============== S U B R O U T I N E =======================================


LOCK_VIOLATION  proc near               ; ...
                push    ds
                push    es
                push    di
                push    cx
                mov     ax, 21h         ; error_lock_violation
                mov     ds:ALLOWED, 18h ; Allowed_FAIL+Allowed_RETRY
                les     bp, ds:THISDPB
                mov     di, 1           ; Fake some registers
                mov     cx, di
                xor     dx, dx          ; 0
                cmp     es:[bp+0Fh], dx ; cmp [es:bp+DPB.FAT_SIZE],dx
                jnz     short lockv_1   ; not FAT32
                mov     dx, es:[bp+2Bh] ; [es:bp+DPB.FCLUS_FSECTOR+2]
                mov     ds:HIGH_SECTOR, dx
                mov     dx, es:[bp+29h] ; [es:bp+DPB.FCLUS_FSECTOR]
                jmp     short lockv_2
; ---------------------------------------------------------------------------

lockv_1:                                ; ...
                mov     ds:HIGH_SECTOR, dx ; 0
                mov     dx, es:[bp+0Bh] ; [ES:BP+DPB.FIRST_SECTOR]

lockv_2:                                ; ...
                call    HARDERR
                pop     cx
                pop     di
                pop     es
                pop     ds
                cmp     al, 1
                jz      short lc_ret_label ; 1 = retry, carry clear
                stc
                retn
LOCK_VIOLATION  endp


; =============== S U B R O U T I N E =======================================


CheckShare      proc near               ; ...
                push    ds
                mov     ds, cs:DosDSeg
                cmp     ds:fShare, 0
                pop     ds
                retn
CheckShare      endp


; =============== S U B R O U T I N E =======================================


SHARE_CHECK     proc near               ; ...
                call    ds:MFT_enter    ; call far [JShare+(1*4)] ; 1 = MFT_Enter

shchk_retn:                             ; ...
                retn
SHARE_CHECK     endp


; =============== S U B R O U T I N E =======================================


SHARE_VIOLATION proc near               ; ...
                push    ds
                push    es
                push    di
                mov     ds:READOP, 0    ; All share errors are reading
                mov     ds:ALLOWED, 18h ; Allowed_FAIL+Allowed_RETRY
                les     bp, ds:THISDPB
                mov     di, 1           ; Fake some registers
                mov     cx, di
                cmp     word ptr es:[bp+0Fh], 0 ; [es:bp+DPB.FAT_SIZE]
                jz      short sharev_1  ; FAT32
                mov     ds:HIGH_SECTOR, 0
                mov     dx, es:[bp+11h] ; [ES:BP+DPB.DIR_SECTOR]
                jmp     short sharev_2
; ---------------------------------------------------------------------------

sharev_1:                               ; ...
                mov     dx, es:[bp+2Bh] ; [es:bp+DPB.FCLUS_FSECTOR+2]
                mov     ds:HIGH_SECTOR, dx
                mov     dx, es:[bp+29h] ; [es:bp+DPB.FCLUS_FSECTOR]

sharev_2:                               ; ...
                call    HARDERR
                pop     di
                pop     es
                pop     ds
                cmp     al, 1
                jz      short shchk_retn ; 1 = retry, carry clear
                stc
                retn
SHARE_VIOLATION endp


; =============== S U B R O U T I N E =======================================


ShareEnd        proc near               ; ...
                call    ds:MFTClose     ; call far [JShare+(2*4)] ; 2 = MFTClose
                retn
ShareEnd        endp


; =============== S U B R O U T I N E =======================================


ShareEnter      proc near               ; ...
                push    cx

retry:                                  ; ...
                mov     cx, ds:RetryCount

attempt:                                ; ...
                les     di, ds:THISSFT
                xor     ax, ax
                push    cx
                mov     es:[di+33h], ax ; [ES:DI+SF_ENTRY.sf_MFT],0 ; indicate free SFT
                call    SHARE_CHECK     ; attempt to enter into the sharing set
                pop     cx
                jnb     short done      ; success, let the user see this
                call    Idle            ; wait a while
                loop    attempt         ; go back for another attempt
                call    SHARE_VIOLATION ; signal the problem to the user
                jnb     short retry     ; user said to retry, go do it

done:                                   ; ...
                pop     cx
                retn
ShareEnter      endp


; =============== S U B R O U T I N E =======================================


ExecReady       proc near               ; ...
                mov     si, dx
                test    word ptr [si+2], 1 ; [si+ERStruc.ER_Flags],ER_EXE
                jz      short er_setver
                mov     ax, [si+8]      ; [si+ERStruc.ER_PSP]
                add     ax, 10h
                mov     es, ax
                mov     cx, [si+0Ah]    ; [si+ERStruc.ER_StartAddr]
                mov     ax, [si+0Ch]    ; [si+ERStruc.ER_StartAddr+2]
                call    ss:FixExePatch
                call    ss:Rational386PatchPtr

er_setver:                              ; ...
                test    word ptr [si+2], 2 ; [si+ERStruc.ER_Flags],ER_OVERLAY
                jnz     short er_chkdoshi ; Y: set A20OFF_COUNT if DOS high
                                        ; N: set up lie version first
                push    ds
                push    si
                lds     si, [si+4]      ; [si+ERStruc.ER_ProgName]
                call    Scan_Execname1
                call    Scan_Special_Entries
                pop     si
                pop     ds
                mov     es, word ptr [si+8] ; [si+ERStruc.ER_PSP]
                mov     ax, ss:SPECIAL_VERSION
                mov     es:40h, ax      ; [es:PDB.Version]

er_chkdoshi:                            ; ...
                cmp     ss:DosHasHMA, 0
                jz      short er_done
                mov     ax, [si+8]      ; [si+ERStruc.ER_PSP] ; ax = PSP
                or      ss:DOS_FLAG, 4  ; EXECA20OFF
                test    word ptr [si+2], 1 ; [si+ERStruc.ER_Flags],ER_EXE
                                        ; Q: COM file
                jnz     short er_setA2  ; N: inc a20off_count,
                                        ; set a20off_psp and ret
                push    ds
                mov     ds, ax          ; DS = load segment of com file
                call    IsCopyProt      ; check if copy protected
                pop     ds

er_setA2:                               ; ...
                inc     ss:A20OFF_COUNT
                mov     ss:A20OFF_PSP, ax ; set the PSP for which A20 is to be
                                        ; turned OFF.

er_done:                                ; ...
                xor     ax, ax
                retn
ExecReady       endp

; ---------------------------------------------------------------------------
rpFind1         db 0FAh, 0E4h, 21h, 60h, 33h, 0C0h, 0E6h, 43h, 8Bh, 16h ; ...
                                        ; cli
                                        ; in  al, 21h
                                        ; pusha
                                        ; xor ax, ax
                                        ; out 43h, al
                                        ; mov dx, ...
rpFind1a        db 0B0h, 0Eh, 0E6h, 37h, 33h, 0C0h, 0E6h, 0F2h ; ...
                                        ; mov al, 0Eh
                                        ; out 37h, al
                                        ; xor ax, ax
                                        ; out 0F2h, al
rpFind2         db 0Fh, 20h, 0C0h       ; ...
                                        ; mov eax, cr0
rpFind3         db 0Fh, 22h, 0C0h, 0EAh ; ...
                                        ; mov cr0, eax
                                        ; jmp far ptr xxx
                                        ; mov ss, bx
rpRepl2         db 66h, 50h, 51h, 0Fh, 20h, 0C0h ; ...
                                        ; push eax
                                        ; push cx
                                        ; mov eax, cr0
rpRepl3         db 8Eh, 0D3h, 59h, 66h, 58h ; ...
                                        ; mov ss, bx
                                        ; pop cx
                                        ; pop eax
rpFind4         db 93h, 58h, 8Bh, 0CCh  ; ...
                                        ; xchg bx, ax
                                        ; pop ax
                                        ; mov cx, sp
rpFind5         db 0B8h, 0Ch, 0DEh, 0CDh, 67h, 8Bh, 0E1h, 0FFh, 0E3h ; ...
                                        ; mov ax, DE0Ch
                                        ; int 67h
                                        ; mov sp, cx
                                        ; jmp bx
rpRepl4         db 93h, 58h, 8Bh, 0CCh  ; ...
                db 2Eh, 66h, 0A3h
                db 0, 0
                db 2Eh, 66h, 89h, 36h
                db 0, 0                 ; xchg bx, ax
                                        ; pop ax
                                        ; mov cx, sp
                                        ; mov dword ptr cs:[xxxx], eax
                                        ; mov dword ptr cs:[xxxx], esi
rpRepl5         db 8Bh, 0E1h            ; ...
                db 2Eh, 66h, 0A1h
                db 0, 0
                db 2Eh, 66h, 8Bh, 36h
                db 0, 0
                db 0FFh, 0E3h           ; mov sp, cx
                                        ; mov eax, dword ptr cs:[xxxx]
                                        ; mov esi, dword ptr cs:[xxxx]
                                        ; jmp bx
rpFind6         db 0FAh, 52h, 51h       ; ...
                                        ; cli
                                        ; push dx
                                        ; push cx
rpFind7a        db 0B8h, 0Ch, 0DEh, 66h, 26h, 0FFh, 1Eh ; ...
                                        ; mov ax, 0DE0Ch
                                        ; call fword ptr es:[xxxx]
rpFind7b        db 59h, 5Ah, 5Bh        ; ...
                                        ; pop cx
                                        ; pop dx
                                        ; pop bx
rpRepl6         db 0FAh, 66h, 50h, 66h, 53h, 66h, 51h, 66h, 52h ; ...
                                        ; cli
                                        ; push eax
                                        ; push ebx
                                        ; push ecx
                                        ; push edx
rpRepl7         db 66h, 5Ah, 66h, 59h, 66h, 5Bh, 66h, 58h, 5Bh ; ...
                                        ; pop edx
                                        ; pop ecx
                                        ; pop ebx
                                        ; pop eax
                                        ; pop bx
rpFind8         db 60h, 6, 1Eh, 0B8h, 0, 0, 8Eh, 0D8h ; ...
                                        ; pusha
                                        ; push es
                                        ; push ds
                                        ; mov ax, dgroup ; jump back to here from replace8
                                        ; mov ds, ax
rpFind9         db 1Fh, 7, 61h          ; ...
                                        ; pop ds
                                        ; pop es
                                        ; popa
rpRepl8         db 66h, 60h, 6, 1Eh     ; ...
                                        ; pushad
                                        ; push es
                                        ; push ds
rpRepl9         db 1Fh, 7, 66h, 61h, 0C3h ; ...
                                        ; pop ds
                                        ; pop es
                                        ; popad
                                        ; retn ; no need to jmp back to main-line
rpBug1Strs      dw offset rpFind2       ; ...
                dw 3                    ; rpFind2Len
                dw offset rpFind3
                dw 4                    ; rpFind3Len
                dw 20h
rpBug2Strs      dw offset rpFind4       ; ...
                dw 4                    ; rpFind4Len
                dw offset rpFind5
                dw 9                    ; rpFind5Len
                dw 80h
rpBug3Strs      dw offset rpFind6       ; ...
                dw 3                    ; rpFind6Len
                dw offset rpFind7a
                dw 7                    ; rpFind7aLen
                dw 80h
rpBug4Strs      dw offset rpFind8       ; ...
                dw 4                    ; rpRepl8Len
                dw offset rpFind9
                dw 3                    ; rpFind9Len
                dw 80h
; ---------------------------------------------------------------------------

Rational386Patch:                       ; ...
                cmp     word ptr es:0, 395 ; version number goes here - versions
                jnb     short rp3QuickOut ; 3.95+ don't need patching
                cmp     word ptr es:0Ch, 20h ; ' ' ;  always has this value here
                jnz     short rp3QuickOut
                push    ax
                mov     ax, 18h         ; extender has 18h at
                cmp     es:24, ax       ; offsets 24, 28, & 36
                jnz     short rp3QO_ax
                cmp     es:28, ax
                jnz     short rp3QO_ax
                cmp     es:36, ax
                jz      short rp3Maybe

rp3QO_ax:                               ; ...
                pop     ax

rp3QuickOut:                            ; ...
                retn
; ---------------------------------------------------------------------------

rp3Maybe:                               ; ...
                cld
                pusha
                push    es
                push    ds
                sub     sp, 6           ; StackVars.size ; make space for stack variables
                mov     bp, sp
                push    cs
                pop     ds
                assume ds:DOSCODE
                mov     ax, es:0
                mov     [bp+0], ax      ; [bp+StackVars.sv_wVersion]
                call    VerifyVersion   ; check that binary version # matches
                                        ; ascii string
                jnz     short rp3Exit_j
                mov     cx, 4500h       ; force search len to 4700h
                                        ; (searches start at offset 200h)
                mov     [bp+2], cx      ; [bp+StackVars.sv_cbCodeSeg]
                mov     es, word ptr es:20h ; es=code segment
                mov     si, offset rpFind1 ; string to find
                mov     dx, 10          ; rpFind1Len ; length to match
                call    ScanCodeSeq     ; look for code seq
                jz      short rpGotPatch
                mov     si, offset rpFind1a
                mov     dx, 8           ; rpFind1Len
                call    ScanCodeSeq
                jz      short rpGotPatch

rp3Exit_j:                              ; ...
                jmp     rp3Exit
; ---------------------------------------------------------------------------

rpGotPatch:                             ; ...
                mov     [bp+4], di      ; [bp-StackVars.sv_pPatch] ; save patch pointer
                cmp     word ptr [bp+0], 381 ; BUG 1, [bp+StackVars.sv_wVersion],381
                                        ; only need bug 1 if version
                jnb     short rpBug2    ; < 3.81
                mov     bx, offset rpBug1Strs ; locate find2 & find3 code
                call    FindBadCode
                jb      short rpBug2
                push    di              ; rpFind3 offset
                mov     di, si          ; rpFind2 offset
                mov     dx, 3           ; rpFind2Len
                cmp     byte ptr es:[di-1], 51h ; find2 preceeded by push cx?
                jnz     short rp_no_cx
                dec     di              ; yes, gobble up push cx too
                inc     dx

rp_no_cx:                               ; ...
                mov     si, offset rpRepl2 ; patch out find2 sequence
                mov     cx, 6           ; rpRepl2Len
                call    GenPatch
                pop     di              ; rpFind3 offset
                cmp     byte ptr es:[di-1], 59h ; find3 preceeded by pop cx?
                jnz     short rp_no_cx2
                mov     byte ptr es:[di-1], 90h ; yes, no-op it

rp_no_cx2:                              ; ...
                mov     ax, [bp+4]      ; [bp+StackVars.sv_pPatch] ; change offset of far jmp
                mov     es:[di+4], ax   ; [es:di+rpFind3Len] ; to go to patch code
                push    di
                mov     si, offset rpRepl3 ; copy repl3 to patch area
                mov     cx, 5           ; rpRepl3Len
                call    CopyPatch
                pop     bx
                add     bx, 8           ; rpFind3Len+4 ; skip over find3 and far jmp
                call    GenJump         ; jmp back from patch area
                mov     [bp+4], di      ; [bp+StackVars.sv_pPatch]
                                        ; to main-line, update patch area pointer

rpBug2:                                 ; ...
                mov     bx, offset rpBug2Strs ; BUG 2, locate find4 & find5 code
                call    FindBadCode
                jb      short rpBug3
                push    word ptr [bp+4] ; [bp+StackVars.sv_pPatch] ; save current patch pointer
                push    di              ; save find5 offset
                mov     di, si          ; rpFind4 offset
                mov     dx, 4           ; rpFind4Len
                mov     si, offset rpRepl4
                mov     cx, 15          ; rpRepl4Len
                call    GenPatch        ; patch out find4 code
                pop     di              ; find5 offset
                add     di, 5           ; keep 5 bytes of find5 code
                mov     bx, [bp+4]      ; [bp+StackVars.sv_pPatch] ; jump to patch area
                push    bx              ; save repl5 location
                call    GenJump
                mov     si, offset rpRepl5 ; copy repl5 code to patch
                mov     cx, 15          ; rpRepl5Len ; area -- it has a jmp bx
                call    CopyPatch       ; so no need to jmp back to
                                        ; main-line code
                pop     di              ; repl5 location
                pop     si              ; repl4 location
                mov     ax, [bp+4]      ; [bp+StackVars.sv_pPatch] ; (where dwords go)
                mov     es:[si+7], ax   ; [es:si+rpRepl4o1Len] ; offset for EAX
                mov     es:[di+5], ax   ; [es:di+rpRepl5o1Len]
                add     ax, 4
                mov     es:[si+0Dh], ax ; [es:si+rpRepl4o2Len] ; offset for ESI
                mov     es:[di+0Bh], ax ; [es:di+rpRepl5o2Len]
                add     word ptr [bp+4], 8 ; [bp+StackVars.sv_pPatch]
                                        ; reserve space for 2 dwords in patch area

rpBug3:                                 ; ...
                mov     bx, offset rpBug3Strs ; BUG 3, locate find6 & find7a code
                call    FindBadCode
                jb      short rpBug4
                add     di, 9           ; rpFind7aLen + 2 ; skip over offset in find7a
                push    si              ; code and locate find7b sequence
                mov     si, offset rpFind7b
                mov     dx, 3           ; rpFind7bLen
                call    ScanCodeSeq_di
                pop     si
                jnz     short rpBug4
                push    di              ; save find7b code offset
                mov     di, si
                mov     dx, 3           ; rpFind6Len
                mov     si, offset rpRepl6
                mov     cx, 9           ; rpRepl6Len
                call    GenPatch        ; patch out find6 code
                pop     di
                mov     dx, 3           ; rpFind7bLen
                mov     si, offset rpRepl7
                mov     cx, 9           ; rpRepl7Len
                call    GenPatch        ; patch out find7b code

rpBug4:                                 ; ...
                cmp     word ptr [bp+0], 360 ; BUG 4, only applies if version > 3.60
                jbe     short rp3Exit   ; and < 3.95
                mov     bx, offset rpBug4Strs ; locate find8 & find9 code
                call    FindBadCode
                jb      short rp3Exit
                push    di              ; save find9 code offset
                mov     di, si
                mov     dx, 3
                mov     si, offset rpRepl8
                mov     cx, 4           ; rpRepl8Len
                call    GenPatch        ; patch out find8 code
                pop     di
                mov     bx, [bp+4]      ; [bp+StackVars.sv_pPatch]
                                        ; patch find9 to jmp to patch area
                call    GenJump
                mov     si, offset rpRepl9 ; copy replacement code to patch area
                mov     cx, 5           ; rpRepl9Len
                call    CopyPatch       ; --it does a RET, so no jmp back to main-line

rp3Exit:                                ; ...
                add     sp, 6           ; StackVars.size
                pop     ds
                assume ds:nothing
                pop     es
                popa
                pop     ax
                retn

; =============== S U B R O U T I N E =======================================


FindBadCode     proc near               ; ...
                mov     cx, [bp+2]      ; [bp+StackVars.sv_cbCodeSeg] ; search length
                mov     si, [bx]        ; [bx+Searchpair.sp_off1] ; ds:si -> search string
                mov     dx, [bx+2]      ; [bx+SearchPair.sp_len1] ; dx = search len
                call    ScanCodeSeq
                jnz     short fbc_error ; done if 1st not found
                push    di              ; save 1st string offset
                mov     si, [bx+4]      ; [bx+SearchPair.sp_off2]
                mov     dx, [bx+6]      ; [bx+SearchPair.sp_len2]
                call    ScanCodeSeq_di  ; don't change flags after this!
                pop     si              ; restore 1st string offset
                jnz     short fbc_error
                mov     ax, di
                sub     ax, si          ; sanity check that
                jb      short fbc_error ; si < di && di - si <= allowed diff
                cmp     ax, [bx+8]      ; [bx+SearchPair.sp_diff]
                ja      short fbc_error
                clc
                retn
; ---------------------------------------------------------------------------

fbc_error:                              ; ...
                stc
                retn
FindBadCode     endp


; =============== S U B R O U T I N E =======================================


GenPatch        proc near               ; ...
                push    di              ; save offset of buggy code
                mov     bx, [bp+4]      ; [bp+StackVars.sv_pPatch]
                call    GenJump         ; jump from buggy code to patch area
                call    CopyPatch       ; copy replacement code to patch area
                pop     bx              ; offset of buggy code + buggy code length
                add     bx, dx          ; = return from patch offset
                call    GenJump         ; jump from patch area back to main-line code,
                mov     [bp+4], di      ; [bp+StackVars.sv_pPatch] ; update patch pointer
                retn
GenPatch        endp


; =============== S U B R O U T I N E =======================================


CopyPatch       proc near               ; ...
                push    cx
                mov     di, [bp+4]      ; [bp+StackVars.sv_pPatch]
                                        ; patch pointer is the dest offset
                cld
                rep movsb
                pop     cx
                mov     [bp+4], di      ; [bp+StackVars.sv_pPatch]
                                        ; update net pointer location
                retn
CopyPatch       endp


; =============== S U B R O U T I N E =======================================


GenJump         proc near               ; ...
                mov     al, 0E9h        ; jmp rel16 opcode
                stosb
                mov     ax, bx          ; calc offset to 'to' location
                sub     ax, di
                sub     ax, 2
                stosw                   ; output offset
                retn
GenJump         endp


; =============== S U B R O U T I N E =======================================


ScanCodeSeq     proc near               ; ...
                mov     di, 200h        ; Looks for a pattern pointed to by DS:SI
                                        ; & len DX in ES:200 to ES:200+CX-1

ScanCodeSeq_di:                         ; ...
                push    cx
                sub     cx, dx
                inc     cx

scsagain:                               ; ...
                push    si
                push    di
                push    cx
                mov     cx, dx
                repe cmpsb
                pop     cx
                pop     di
                pop     si
                jz      short scsfound
                inc     di
                loop    scsagain

scsfound:                               ; ...
                pop     cx
                retn
ScanCodeSeq     endp


; =============== S U B R O U T I N E =======================================


VerifyVersion   proc near               ; ...
                mov     si, es:2Ah      ; offset of version number in ascii
                mov     bl, 10
                add     si, 3           ; point to last digit
                call    VVDigit
                jnz     short vvexit
                call    VVDigit
                jnz     short vvexit
                cmp     byte ptr es:[si], 2Eh ; '.'
                jnz     short vvexit
                dec     si
                call    VVDigit

vvexit:                                 ; ...
                retn
VerifyVersion   endp


; =============== S U B R O U T I N E =======================================


VVDigit         proc near               ; ...
                div     bl
                add     ah, '0'         ; 30h
                dec     si
                cmp     es:[si+1], ah
                mov     ah, 0           ; do not xor or sub we need Z
                retn
VVDigit         endp

; ---------------------------------------------------------------------------
exepatch_start  db 6                    ; ...
                db 8Ch, 0D8h
                db 2Bh, 0C2h
                db 8Eh, 0D8h
                db 8Eh, 0C0h
                db 0BFh, 0Fh, 0
                db 57h
                db 0B9h, 10h, 0
                db 0B0h, 0FFh
                db 0F3h, 0AEh
                db 47h
                db 8Bh, 0F7h
                db 5Fh
                db 58h
                db 2Bh, 0C2h
                db 8Eh, 0C0h
                db 0B9h, 4, 2
                db 8Bh, 0C6h
                db 0F7h, 0D0h
                db 0D3h, 0E8h
                db 74h, 13h
                db 8Ch, 0DAh
                db 83h, 0CEh, 0F0h
                db 2Bh, 0D0h
                db 73h, 8
                db 0F7h, 0DAh
                db 0D3h, 0E2h
                db 2Bh, 0F2h
                db 33h, 0D2h
                db 8Eh, 0DAh
                db 87h, 0F7h
                db 1Eh
                db 6
                db 1Fh
                db 7
                db 0FEh, 0CDh
                db 75h, 0DBh
                db 0ACh
                db 92h
                db 4Eh
                db 0ADh
                db 8Bh, 0C8h
                db 46h
                db 8Ah, 0C2h
                db 24h, 0FEh
                db 3Ch, 0B0h
                db 75h, 5
                db 0ACh
                db 0F3h, 0AAh
                db 0EBh, 6
                db 3Ch, 0B2h
                db 75h, 6Ch
                db 0F3h, 0A4h
                db 92h
                db 0A8h, 1
                db 74h, 0B9h
                db 90h, 90h
scan_patch1     db 8Ch, 0C3h            ; ...
                db 8Ch, 0D8h
                db 2Bh, 0C2h
                db 8Eh, 0D8h
                db 8Eh, 0C0h
                db 0BFh, 0Fh, 0
                db 0B9h, 10h, 0
                db 0B0h, 0FFh
                db 0F3h, 0AEh
                db 47h
                db 8Bh, 0F7h
                db 8Bh, 0C3h
                db 2Bh, 0C2h
                db 8Eh, 0C0h
                db 0BFh, 0Fh, 0
                db 0B1h, 4
                db 8Bh, 0C6h
                db 0F7h, 0D0h
                db 0D3h, 0E8h
                db 74h, 9
                db 8Ch, 0DAh
                db 2Bh, 0D0h
                db 8Eh, 0DAh
                db 83h, 0CEh, 0F0h
                db 8Bh, 0C7h
                db 0F7h, 0D0h
                db 0D3h, 0E8h
                db 74h, 9
                db 8Ch, 0C2h
                db 2Bh, 0D0h
                db 8Eh, 0C2h
                db 83h, 0CFh, 0F0h
scan_patch2     db 8Ch, 0C3h            ; ...
                db 8Ch, 0D8h
                db 48h
                db 8Eh, 0D8h
                db 8Eh, 0C0h
                db 0BFh, 0Fh, 0
                db 0B9h, 10h, 0
                db 0B0h, 0FFh
                db 0F3h, 0AEh
                db 47h
                db 8Bh, 0F7h
                db 8Bh, 0C3h
                db 48h
                db 8Eh, 0C0h
                db 0BFh, 0Fh, 0
                db 0B1h, 4
                db 8Bh, 0C6h
                db 0F7h, 0D0h
                db 0D3h, 0E8h
                db 74h, 0Ah
                db 8Ch, 0DAh
                db 2Bh, 0D0h
                db 8Eh, 0DAh
                db 81h, 0CEh, 0F0h, 0FFh
                db 8Bh, 0C7h
                db 0F7h, 0D0h
                db 0D3h, 0E8h
                db 74h, 0Ah
                db 8Ch, 0C2h
                db 2Bh, 0D0h
                db 8Eh, 0C2h
                db 81h, 0CFh, 0F0h, 0FFh
scan_patch3     db 8Ch, 0C3h            ; ...
                db 8Ch, 0D8h
                db 48h
                db 8Eh, 0D8h
                db 8Eh, 0C0h
                db 0BFh, 0Fh, 0
                db 0B9h, 10h, 0
                db 0B0h, 0FFh
                db 0F3h, 0AEh
                db 47h
                db 8Bh, 0F7h
                db 8Bh, 0C3h
                db 48h
                db 8Eh, 0C0h
                db 0BFh, 0Fh, 0
                db 0B1h, 4
                db 8Bh, 0C6h
                db 0F7h, 0D0h
                db 0D3h, 0E8h
                db 74h, 9
                db 8Ch, 0DAh
                db 2Bh, 0D0h
                db 8Eh, 0DAh
                db 83h, 0CEh, 0F0h
                db 8Bh, 0C7h
                db 0F7h, 0D0h
                db 0D3h, 0E8h
                db 74h, 9
                db 8Ch, 0C2h
                db 2Bh, 0D0h
                db 8Eh, 0C2h
                db 83h, 0CFh, 0F0h
scan_com        db 0ACh                 ; ...
                db 8Ah, 0D0h
                db 4Eh
                db 0ADh
                db 8Bh, 0C8h
                db 46h
                db 8Ah, 0C2h
                db 24h, 0FEh
                db 3Ch, 0B0h
                db 75h, 6
                db 0ACh
                db 0F3h, 0AAh
                db 0EBh, 7, 90h
                db 3Ch, 0B2h
                db 75h, 6Bh
                db 0F3h, 0A4h
                db 8Ah, 0C2h
                db 0A8h, 1
; ---------------------------------------------------------------------------

ExePatch:                               ; ...
                call    ExePackPatch
                call    ss:RationalPatchPtr
                retn

; =============== S U B R O U T I N E =======================================


ExePackPatch    proc near               ; ...
                push    bx
                mov     bx, es          ; bx has load segment
                cmp     bx, 0FFFh       ; Q: is the load segment > 64K
                jbe     short ep_contep_cont ; N:
                pop     bx              ; Y: no need to patch
                retn
; ---------------------------------------------------------------------------

ep_contep_cont:                         ; ...
                push    ds
                push    es
                push    ax
                push    cx
                push    si
                push    di
                sub     cx, 2           ; Q: is IP >=2
                jnb     short epp_1     ; N: exit
                jmp     ep_notpacked    ; ax:cx now points to location of
                                        ; 'RB' if this is an exepacked file.
; ---------------------------------------------------------------------------

epp_1:                                  ; ...
                mov     di, cx
                mov     es, ax
                mov     ss:UNPACK_OFFSET, di ; save pointer to 'RB' in unpack_offset
                cmp     word ptr es:[di], 4252h ; 'RB'
                jz      short epp_2
                jmp     ep_notpacked
; ---------------------------------------------------------------------------

epp_2:                                  ; ...
                push    cs
                pop     ds
                assume ds:DOSCODE
                add     di, 6Ch         ; PATCH1_COM_OFFSET
                                        ; es:di -> points to place in packed file
                                        ; where we hope to find scan string.
                call    chk_common_str  ; check for match
                jnz     short ep_chkpatch2 ; Q: does the patch match
                                        ; N: check at patch2_offset
                                        ; Y: check for rest of patch string
                mov     si, offset scan_patch1 ; ds:si -> scan string
                mov     di, ss:UNPACK_OFFSET ; restore di to point to 'RB'
                add     di, 28h         ; PATCH1_OFFSET
                                        ; es:di -> points to place in packed file
                                        ; where we hope to find scan string.
                mov     cl, 68          ; size_scan_patch1
                mov     bx, 142         ; CHKSUM1_LEN
                mov     ax, 0EF4Eh      ; PATCH1_CHKSUM
                call    chk_patchsum    ; check if patch and chk sum compare
                jb      short ep_done1  ; Q: did we pass the test
                                        ; N: exit
                                        ; Y: overlay code with new
                mov     si, offset exepatch_start ; str1
                mov     cl, 102         ; size_str1
                rep movsb

ep_done1:                               ; ...
                jmp     short ep_notpacked ; ep_done
; ---------------------------------------------------------------------------
                nop

ep_chkpatch2:                           ; ...
                mov     di, 76h         ; PATCH2_COM_OFFSET
                                        ; es:di -> possible location of patch
                                        ; in another version of unpack
                call    chk_common_str  ; check for match
                jnz     short ep_chkpatch3 ; Q: does the patch match
                                        ; N: check for patch3_offset
                                        ; Y: check for rest of patch string
                mov     si, offset scan_patch2 ; ds:si -> scan string
                mov     di, 32h         ; PATCH2_OFFSET
                                        ; es:di -> points to place in packed file
                                        ; where we hope to find scan string.
                mov     cl, 68          ; size_scan_patch2
                mov     bx, 140         ; CHKSUM2_LEN
                mov     ax, 78B2h       ; PATCH2_CHKSUM
                call    chk_patchsum    ; check if patch and chk sum compare
                jnb     short ep_patchcode2 ; Q: did we pass the test
                                        ; Y: overlay code with new
                                        ; N: try with a different chksum
                mov     si, offset scan_patch2 ; ds:si -> scan string
                mov     cl, 68          ; size_scan_patch2
                mov     bx, 129         ; CHKSUM2A_LEN
                mov     ax, 1C47h       ; PATCH2A_CHKSUM
                call    chk_patchsum    ; check if patch and chk sum compare
                jb      short ep_notpacked

ep_patchcode2:                          ; ...
                mov     si, offset exepatch_start ; str1
                mov     cl, 3           ; first_stop
                rep movsb
                mov     ax, 4890h       ; ax = opcodes for dec ax, nop
                stosw
                inc     si
                inc     si
                mov     cl, 20          ; second_stop
                rep movsb
                stosw                   ; put in dec ax and nop
                inc     si
                inc     si
                mov     cl, 75
                rep movsb
                jmp     short ep_notpacked ; ep_done
; ---------------------------------------------------------------------------

ep_chkpatch3:                           ; ...
                mov     di, 74h         ; PATCH3_COM_OFFSET
                                        ; es:di -> possible location of patch
                                        ; in another version of unpack
                call    chk_common_str  ; check for match
                jnz     short ep_notpacked ; Q: does the patch match
                                        ; N: exit
                                        ; Y: check for rest of patch string
                mov     si, offset scan_patch3 ; ds:si -> scan string
                mov     di, 32h         ; PATCH3_OFFSET
                                        ; es:di -> points to place in packed file
                                        ; where we hope to find scan string.
                mov     cl, 66          ; size_scan_patch3
                mov     bx, 139         ; CHKSUM3_LEN
                mov     ax, 4EDEh       ; PATCH3_CHKSUM
                call    chk_patchsum    ; check if patch and chk sum compare
                jb      short ep_notpacked ; Q: did we pass the test
                                        ; N: exit
                                        ; Y: overlay code with new
                mov     si, offset exepatch_start ; str1
                mov     cl, 3           ; first_stop
                rep movsb
                mov     al, 48h         ; al = opcode for dec ax
                stosb
                inc     si              ; add si,2
                inc     si
                mov     cl, 20          ; second_stop
                rep movsb
                stosb                   ; put in dec ax
                inc     si
                inc     si
                mov     cl, 75          ; last_stop
                rep movsb

ep_notpacked:                           ; ...
                pop     di
                pop     si
                pop     cx
                pop     ax
                pop     es
                pop     ds
                assume ds:nothing
                pop     bx
                retn
ExePackPatch    endp


; =============== S U B R O U T I N E =======================================


chk_common_str  proc near               ; ...
                mov     si, offset scan_com
                mov     cx, 32          ; size_scan_com
                repe cmpsb
                jz      short ccs_done
                cmp     byte ptr es:[di-1], 56h
                jnz     short ccs_done
                repe cmpsb

ccs_done:                               ; ...
                retn
chk_common_str  endp


; =============== S U B R O U T I N E =======================================


chk_patchsum    proc near               ; ...
                push    di
                repe cmpsb
                jnz     short cp_fail   ; Q: does the patch match
                                        ; N: exit
                                        ; Y:
                mov     di, ss:UNPACK_OFFSET ; di -> start of unpack code
                mov     cx, bx          ; cx = length of check sum
                mov     bx, ax          ; save check sum passed to us in bx
                xor     ax, ax

ep_chksum:                              ; ...
                add     ax, es:[di]
                inc     di
                inc     di
                loop    ep_chksum
                pop     di
                cmp     ax, bx          ; Q: does the check sum match
                jnz     short cp_fail   ; N: exit
                                        ; Y:
                clc
                retn
; ---------------------------------------------------------------------------

cp_fail:                                ; ...
                stc
                retn
chk_patchsum    endp

; ---------------------------------------------------------------------------
RScanPattern1   db 0, 0, 20h, 0, 0, 0, 40h, 0 ; ...
                db 1, 0
RScanPattern2   db 8Bh, 0Eh, 10h, 0, 90h, 0E2h, 0FEh, 0E8h ; ...
RScanPattern3   db 8Bh, 0Eh, 10h, 0, 0E2h, 0FEh, 0E8h ; ...
; ---------------------------------------------------------------------------

RationalPatch:                          ; ...
                cld
                pusha
                push    es
                push    ds
                mov     di, 0Ah         ; look for pat1 at offset 0Ah
                push    cs
                pop     ds
                assume ds:DOSCODE
                mov     si, offset RScanPattern1
                mov     cx, 10
                repe cmpsb              ; do we have the pattern ?
                jnz     short rpexit    ; no
                mov     ax, es:0
                cmp     ax, 348         ; is it a buggy version ?
                jb      short rpexit
                cmp     ax, 383         ; is it a buggy version ?
                ja      short rpexit
                call    VerifyVersion
                jnz     short rpexit
                mov     cx, es:16h      ; Length of buggy code seg
                sub     cx, 200h        ; Length we search
                                        ; (we start at offset 200h)
                mov     es, word ptr es:20h ; es=buggy code segment
                mov     si, offset RScanPattern2
                mov     dx, 8           ; RLen2
                call    ScanCodeSeq     ; look for code seq with nop
                jz      short rpfound
                mov     si, offset RScanPattern3
                mov     dx, 15          ; RLen3
                call    ScanCodeSeq     ; look for code seq w/o nop
                jnz     short rpexit

rpfound:                                ; ...
                mov     al, 9Ah         ; far call opcode
                stosb
                mov     ax, offset RatBugCode
                stosw
                mov     ax, ss
                stosw
                mov     cx, dx
                sub     cx, 6           ; filler (with NOPs)
                mov     al, 90h
                rep stosb

rpexit:                                 ; ...
                pop     ds
                assume ds:nothing
                pop     es
                popa
                retn
; ---------------------------------------------------------------------------
CPScanPattern   db 89h, 26h, 48h, 1     ; ...
                db 8Ch, 0Eh, 4Ch, 1
                db 0C7h, 6, 4Ah, 1, 0, 1
                db 8Ch, 0Eh, 13h, 1
                db 0B8h, 20h, 1
                db 0BEh, 0, 1

; =============== S U B R O U T I N E =======================================


IsCopyProt      proc near               ; ...
                cmp     word ptr ds:11Bh, 5343h ; cmp word [CPID1Offset],ID1
                jnz     short CP_done
                cmp     word ptr ds:173h, 5044h ; cmp word [CPID2Offset],ID2
                jnz     short CP_done
                cmp     word ptr ds:146h, 0F413h ; cmp word [CPID3Offset],ID3
                jnz     short CP_done
                cmp     word ptr ds:124h, 8000h ; cmp word [CPID4Offset],ID4
                jnz     short CP_done
                push    cs
                pop     es
                assume es:DOSCODE
                mov     di, offset CPScanPattern
                mov     si, 175h        ; CPStartOffset
                mov     cx, 24          ; CPSPlen
                repe cmpsb
                jnz     short CP_done
                mov     ss:A20OFF_COUNT, 0Ah

CP_done:                                ; ...
                retn
IsCopyProt      endp

; ---------------------------------------------------------------------------

initiret:                               ; ...
                iret
; ---------------------------------------------------------------------------
InitBioDataSeg  dw 70h                  ; ...

; =============== S U B R O U T I N E =======================================


ParaRound       proc near               ; ...
                add     ax, 0Fh
                rcr     ax, 1
                shr     ax, 1
                shr     ax, 1
                shr     ax, 1
                retn
ParaRound       endp


; =============== S U B R O U T I N E =======================================


WhatCPUType     proc near               ; ...
                pushf
                push    bx
                xor     bx, bx          ; 0
                xor     ax, ax          ; 0
                push    ax              ; AX = 0 ; put it on the stack
                popf                    ; shove it into the flags
                pushf                   ; it back out of the flags
                pop     ax              ; and into ax
                and     ax, 0F000h      ; mask off high four bits
                cmp     ax, 0F000h      ; was it all 1's?
                jz      short cpu_8086  ; yes ; it's an 8086 or 8088
                mov     ax, 0F000h      ; now try to set the high four bit
                push    ax
                popf
                pushf
                pop     ax              ; and see what happens
                and     ax, 0F000h      ; any high bits set ?
                jz      short cpu_286   ; no ; it's an 80286

cpu_386:
                inc     bx

cpu_286:                                ; ...
                inc     bx

cpu_8086:                               ; ...
                mov     ax, bx          ; AX = 0 if 8086 or 8088
                                        ;    = 1 if 80286
                                        ;    = 2 if 80386
                pop     bx
                popf
                retn
WhatCPUType     endp

; ---------------------------------------------------------------------------

DOSINIT:                                ; ...
                cli
                cld
                push    dx              ; top of memory (memory size in paragraphs)
                push    si              ; 0
                push    ds              ; IBMDOS.SYS loading segment
                push    di              ; 0
                mov     bx, es          ; CURRENT_DOS_LOCATION (segment)
                mov     ax, 0D20Fh      ; MEMSTRT ; get offset of end of init code
                add     ax, 0Fh         ; round up
                and     ax, 0FFF0h
                mov     si, ax          ; DOSDATA segment offset in IBMDOS.SYS
                push    cs
                pop     ds              ; DOSCODE segment
                assume ds:DOSCODE
                mov     es, cs:InitBioDataSeg ; BIOSDATA segment (always 0070h)
                assume es:nothing
                mov     es, word ptr es:3 ; DOSDATA segment ptr
                assume es:DOSCODE
                xor     di, di          ; offset 0
                mov     cx, 1346h       ; DOSDATA size (4934 bytes)
                rep movsb
                pop     di
                pop     ds
                assume ds:nothing
                pop     si
                pop     dx
                push    es
                push    ds
                pop     es
                assume es:nothing
                pop     ds
                mov     ds:BiosDataPtr, di ; CURRENT_DOS_LOCATION (offset = 0)
                mov     ds:BiosDataPtr+2, bx ; CURRENT_DOS_LOCATION (segment)
                mov     cs:DosDSeg, ds
                mov     cs:LowInt23_SEG, ds
                mov     cs:LowInt24_SEG, ds
                mov     cs:LowInt28_SEG, ds
                mov     ds:ENDMEM, dx
                mov     ds:USER_SP, sp
                mov     ds:USER_SS, ss
                push    ds
                pop     ss
                mov     sp, offset DSKSTACK ; "@#IBM:12.01.2003.build_1.32#@ IBMDOS.CO"...
                mov     ax, offset RetExePatch
                mov     ds:FixExePatch, ax
                mov     ds:RationalPatchPtr, ax
                mov     ds:ChkCopyProt, ax
                call    WhatCPUType     ; get cpu type (0 < 286,1==286,2 >= 386)
                cmp     al, 2           ; 386 or later?
                mov     ax, offset Rational386Patch ; yes
                jnb     short di_set_patch
                mov     ax, offset RetExePatch ; < 386, don't need this patch

di_set_patch:                           ; ...
                mov     ds:Rational386PatchPtr, ax
                mov     ax, cs
                mov     ds:TEMP_DOSLOC, ax
                mov     ds:NULDEV+2, es
                mov     ds:NULDEV, si
                mov     ds:Win386_Info_16, ds ; [Win386_Info+14+2]
                                        ; [Win386_Info+Win386_SIS.Instance_Data_Ptr+2]
                push    si
                mov     cx, 7
                mov     si, offset InsTBL_CONTPOS_seg ; Instance_Table+2

Instance_init_loop:                     ; ...
                mov     word ptr [si], ds ; set offset in instance entry
                add     si, 6           ; size_of_Win386_IIS ; move on to next entry
                loop    Instance_init_loop
                mov     cx, 5           ; five entries in the instance table
                mov     si, offset OldInstanceJunk_6 ; OldInstanceJunk+6

OldInstance_init_loop:                  ; ...
                mov     word ptr [si], ds ; set offset in instance entry
                add     si, 6           ; move on to next entry
                loop    OldInstance_init_loop
                pop     si              ; restore pointer to device chain
                push    es
                pop     ds
                push    ds
                xor     ax, ax          ; 0
                mov     ds, ax          ; point DS to int vector table
                assume ds:DOSCODE
                mov     ax, offset initiret
                mov     word ptr 0:0A8h, ax ; [2Ah*4]
                mov     ax, cs
                mov     word ptr 0:0A8+2, ax ; [(2Ah*4)+2]
                pop     ds              ; restore segment of device chain
                assume ds:nothing
                call    CHARINIT        ; initialize console driver
                push    si              ; save pointer to header
                push    ss              ; move pointer to dos data...
                pop     es
                mov     di, offset SFT0_SFTable ; SFTABL+SFT.SFTable ; Point to sft 0
                mov     ax, 3           ; Refcount
                stosw                   ; SF_ENTRY.sf_ref_count
                dec     al              ; ax = 2 ; Access rd/wr, compatibility
                stosw                   ; .sf_mode
                xor     al, al          ; 0
                stosb                   ; .sf_attr
                mov     al, 0C3h        ; devid_device_EOF|devid_device|ISCIN|ISCOUT
                stosw                   ; .sf_flags
                mov     ax, si          ; device pointer in devptr
                stosw                   ; .sf_devptr
                mov     ax, ds
                stosw                   ; SFT0_SFTable + 9 ; .sf_devptr_hw
                xor     ax, ax          ; 0
                add     di, 32          ; SFTABL+SFT.SFTable + 43
                stosw                   ; SFT0_SFTable + 43 ; SF_ENTRY.sf_fclus32
                stosw                   ; .sf_fclus32 + 2
                add     di, -34         ; 0FFDEh ; SFTABL+SFT.SFTable + 13
                stosw                   ; SFT0_SFTable + 13 ; SF_ENTRY.sf_time
                stosw                   ; .sf_date
                dec     ax              ; -1
                stosw                   ; SFT0_SFTable + 17 ; .sf_size
                stosw                   ; .sf_size + 2
                inc     ax              ; 0
                stosw                   ; SFT0_SFTable + 21 ; .sf_position
                stosw                   ; .sf_position + 2
                add     di, 7           ; SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
                                        ; SFT0_SFTable + 32
                add     si, 10          ; SYSDEV.NAME
                mov     cx, 4
                rep movsw               ; name
                mov     cl, 3
                mov     al, 20h ; ' '   ; extension
                rep stosb               ; SFT0_SFTable + 40
                pop     si              ; get back pointer to header
                or      byte ptr [si+4], 3 ; ISCIN|ISCOUT
                mov     word ptr ss:BCON, si
                mov     word ptr ss:BCON+2, ds

CHAR_INIT_LOOP:                         ; ...
                lds     si, [si]        ; AUX device
                call    CHARINIT
                test    byte ptr [si+4], 8 ; [SI+SYSDEV.ATT],ISCLOCK
                jz      short CHAR_INIT_LOOP
                mov     word ptr ss:BCLOCK, si
                mov     word ptr ss:BCLOCK+2, ds
                mov     bp, 1346h       ; MSDAT001E ; ES:BP points to DPB
                mov     word ptr ss:DPBHEAD, bp ; pointer to DPB's
                mov     word ptr ss:DPBHEAD+2, es

PERDRV:                                 ; ...
                lds     si, [si]        ; [SI+SYSDEV.NEXT] ; Next device
                cmp     si, 0FFFFh      ; -1
                jnz     short PERDRV2
                jmp     CONTINIT
; ---------------------------------------------------------------------------

PERDRV2:                                ; ...
                call    CHARINIT
                test    word ptr [si+4], 8000h ; [SI+SYSDEV.ATT],DEVTYP
                jnz     short PERDRV    ; Skip any other character devs
                mov     cl, ss:CALLUNIT
                xor     ch, ch
                mov     [si+10], cl     ; [si+SYSDEV.NAME]
                mov     dl, ss:NUMIO
                xor     dh, dh          ; 0
                add     ss:NUMIO, cl
                push    ds
                push    si
                lds     bx, dword ptr ss:CALLBPB

PERUNIT:                                ; ...
                mov     si, [bx]        ; DS:SI Points to BPB
                inc     bx
                inc     bx              ; On to next BPB
                mov     es:[bp+0], dl   ; DPB.DRIVE
                mov     es:[bp+1], dh   ; DPB.UNIT
                push    bx
                push    cx
                push    dx
                mov     dx, 4152h       ; 'RA'
                xor     cx, cx          ; 0
                mov     es:[bp+29], cx  ; [es:bp+DPB.NEXT_FREE]
                cmp     [si+11], cx     ; BPB_FATSz16 ; [si+A_BPB.SECTORSPERFAT]
                jnz     short PERUNIT2  ; FAT (FAT12 or FAT16) -old DPB-
                                        ; FAT32 -new- DPB
                mov     es:[bp+57], cx  ; [es:bp+DPB.FAT32_NXTFREE]
                mov     es:[bp+59], cx  ; [es:bp+DPB.FAT32_NXTFREE+2]
                dec     cx              ; 0FFFFh  ; -1
                mov     es:[bp+31], cx  ; [es:bp+DPB.FREE_CNT]
                mov     es:[bp+33], cx  ; [es:bp+DPB.FREE_CNT_HW]
                mov     cx, 4558h       ; 'XE'

PERUNIT2:                               ; ...
                call    $SETDPB         ; build DPB!
                mov     ax, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE]
                cmp     ax, ss:MAXSEC   ; Q:is this the largest sector so far
                jbe     short NOTMAX    ; N:
                mov     ss:MAXSEC, ax   ; Y: save it in maxsec

NOTMAX:                                 ; ...
                mov     ax, bp
                add     ax, 61          ; next DPB (PCDOS 7.1 DPB size = 61)
                mov     es:[bp+25], ax  ; DPB.NEXT_DPB offset
                mov     word ptr es:[bp+27], es ; DPB.NEXT_DPB segment
                mov     byte ptr es:[bp+24], 0FFh ; DPB.FIRST_ACCESS = -1
                pop     dx
                pop     cx
                pop     bx
                mov     ax, ds          ; save segment of bpb array
                pop     si
                pop     ds
                mov     es:[bp+19], si  ; DPB.DRIVER_ADDR offset
                mov     word ptr es:[bp+21], ds ; DPB.DRIVER_ADDR segment
                push    ds
                push    si
                inc     dh
                inc     dl
                mov     ds, ax
                add     bp, 61          ; DPBSIZ
                loop    PERUNIT
                pop     si              ; restore pointer to device header
                pop     ds
                jmp     PERDRV
; ---------------------------------------------------------------------------

CONTINIT:                               ; ...
                sub     bp, 61          ; sub bp,DPBSIZ ; back up to last dpb
                mov     ax, 0FFFFh
                mov     [bp+25], ax     ; [bp+DPB.NEXT_DPB],-1
                mov     [bp+27], ax     ; [bp+DPB.NEXT_DPB+2],-1
                add     bp, 61          ; DPBSIZ ; advance to free memory again
                                        ; the DPB chain is done.
                push    ss
                pop     ds
                mov     ax, bp
                call    ParaRound       ; round up to segment
                mov     dx, ds          ; dx = dosdata segment
                add     dx, ax          ; dx = ds+ax first free segment
                mov     bx, 0Fh
                mov     cx, ds:ENDMEM
                mov     ds:DOSSEG_INIT, ds ; [DSKCHRET+3]
                push    dx              ; preserve first free segment
                mov     ax, ds:TEMP_DOSLOC ; ax = segment to patch in
                mov     es, ax          ; es = segment of DOS
                mov     ds:TEMP_DOSLOC, 0FFFFh ; -1 means first call to patch_misc_segments
                call    patch_vec_segments ; uses AX as doscode segment
                call    patch_misc_segments ; patch in segments for sharer and
                                        ; other tables with seg in ES.
                mov     ds:TEMP_DOSLOC, es ; put back segment of dos code
                pop     dx              ; restore first free segment
                xor     ax, ax
                mov     ds, ax          ; 0
                assume ds:DOSCODE
                mov     es, ax          ; 0
                assume es:DOSCODE
                mov     di, 90h         ; INT 24h vector
                                        ; addr_int_fatal_abort
                mov     ax, ss:TEMP_DOSLOC
                mov     [di+2], ax      ; segment
                mov     di, 82h         ; INTBASE+2
                mov     word ptr 0, offset DIVOV
                mov     di, 80h         ; INTBASE
                mov     ax, offset irett
                mov     cx, 9           ; sets offsets for ints 20h-28h

iset1:                                  ; ...
                stosw
                inc     di
                inc     di
                loop    iset1
                add     di, 4           ; skip vector 29h
                mov     cx, 6           ; sets offsets for ints 2Ah-2Fh

iset2:                                  ; ...
                stosw
                inc     di
                inc     di
                loop    iset2
                add     di, 8           ; skip vector 30h & 31h
                mov     cx, 14          ; sets offsets for ints 32h-3Fh

iset3:                                  ; ...
                stosw
                inc     di
                inc     di
                loop    iset3
                mov     word ptr 00BCh, offset INT2F ; mov word [02Fh*4],INT2F
                mov     ax, ss:TEMP_DOSLOC
                mov     word ptr 00BEh, ax
                mov     byte ptr 00C0h, 0EAh ; mov byte [ENTRYPOINT],mi_long_jmp
                mov     word ptr 00C1h, offset CALL_ENTRY ; mov word [ENTRYPOINT+1],CALL_ENTRY
                mov     word ptr 0080h, offset QUIT ; mov word [addr_int_abort],QUIT
                mov     word ptr 0084h, offset COMMAND ; mov word [addr_int_command],COMMAND
                mov     word ptr 0088h, 100h ; mov word [addr_int_terminate],100h
                mov     word ptr 008Ah, dx ; mov word [addr_int_terminate+2],dx
                mov     word ptr 0094h, offset ABSDRD ; mov word [addr_int_disk_read],ABSDRD
                mov     word ptr 0098h, offset ABSDWRT ; mov word [addr_int_disk_write],ABSDWRT
                mov     word ptr 009Ch, offset stay_resident ; mov word [addr_int_keep_process],STAY_RESIDENT
                push    ss
                pop     ds
                assume ds:nothing
                push    ss
                pop     es
                assume es:nothing
                push    dx              ; remember address of arena
                inc     dx              ; leave room for arena header
                mov     ds:CurrentPDB, dx ; set current pdb
                xor     di, di          ; 0
                mov     es, dx          ; point es:di at end of memory where psp will be
                xor     ax, ax
                mov     cx, 128         ; psp is 128 words
                rep stosw               ; zero out psp area
                mov     ax, ds:ENDMEM
                call    SETMEM          ; build psp at dx; ax is memory size
                push    ss
                pop     ds
                mov     di, 24          ; PDB.JFN_TABLE
                xor     ax, ax          ; es:di -> pdb_jfn_table in psp
                stosw                   ; 0
                stosb                   ; 0,1 and 2 are con device
                mov     al, 0FFh
                mov     cx, 17          ; FILPERPROC-3
                rep stosb               ; rest are unused
                push    ss
                pop     es
                mov     word ptr ds:SFT_ADDR+2, ds
                mov     si, offset SysInitTable ; Fill in the segment addresses of sysinitvar
                                        ; and country_cdpg in sysinittable
                mov     word ptr es:[si+6], es ; [es:si+SYSI_EXT.Country_Tab+2]
                mov     word ptr es:[si+2], es ; [es:si+SYSI_EXT.SysInitVars+2]
                mov     word ptr es:BUFFHEAD+2, es
                mov     si, offset BufferQueue ; HASHINITVAR
                mov     word ptr es:BUFFHEAD, si
                pop     dx              ; restore address of arena
                mov     word ptr ds:DMAADD+2, dx
                mov     es:arena_head, dx
                mov     ds, dx
                mov     byte ptr ds:0, 5Ah ; 'Z' ; [ARENA.SIGNATURE],arena_signature_end
                mov     word ptr ds:1, 0 ; [ARENA.OWNER],arena_owner_system
                mov     ax, ss:ENDMEM
                sub     ax, dx
                dec     ax
                mov     ds:3, ax        ; [ARENA.SIZE]
                mov     di, offset SFT0_SFTable ; SFTABL+SFT.SFTable
                mov     ax, 3
                stosw                   ; adjust refcount
                mov     di, offset SysInitTable
                inc     dx              ; advance dx from arena to psp
                mov     ds, dx          ; point ds to psp
                mov     dx, offset _seg_reinit
                mov     cx, offset exepatch_start
                sub     cx, offset $STARTCODE ; sub cx, 3F10h
                                        ; cx = (doscode - exepatch) - dosinit
                mov     ax, offset initiret ; SYSBUF
                sub     ax, offset $STARTCODE ; sub ax, 3F10h
                                        ; ax = size of doscode - dosinit
                mov     sp, ss:USER_SP
                mov     ss, ss:USER_SS
                retf

; =============== S U B R O U T I N E =======================================


CHARINIT        proc near               ; ...
                mov     ss:DEVCALL_REQLEN, 25 ; 19h
                mov     ss:DEVCALL_REQUNIT, 0
                mov     ss:DEVCALL_REQFUNC, 0
                mov     ss:DEVCALL_REQSTAT, 0
                push    es
                push    bx
                push    ax
                mov     bx, offset DEVCALL_REQLEN ; offset DEVCALL
                push    ss
                pop     es
                call    DEVIOCALL2
                pop     ax
                pop     bx
                pop     es
                retn
CHARINIT        endp


; =============== S U B R O U T I N E =======================================


check_XMM       proc near               ; ...
                push    ax
                mov     ax, 4300h
                int     2Fh             ; - Multiplex - XMS - INSTALLATION CHECK
                                        ; Return: AL = 80h XMS driver installed
                                        ; AL <> 80h no driver
                cmp     al, 80h
                jnz     short cXMM_no_driver
                push    bx
                push    dx
                push    ds
                push    es
                mov     ax, 4310h
                int     2Fh             ; - Multiplex - XMS - GET DRIVER ADDRESS
                                        ; Return: ES:BX -> driver entry point
                mov     ds, cs:DosDSeg
                mov     word ptr ds:XMMcontrol, bx
                mov     word ptr ds:XMMcontrol+2, es

cXMMexit:
                clc
                pop     es
                pop     ds
                pop     dx
                pop     bx
                pop     ax
                retn
; ---------------------------------------------------------------------------

cXMM_no_driver:                         ; ...
                stc
                pop     ax
                retn
check_XMM       endp

; ---------------------------------------------------------------------------
num_entry       db 0                    ; ...
; ---------------------------------------------------------------------------

_seg_reinit:                            ; ...
                push    ds
                mov     ds, cs:DosDSeg
                call    patch_misc_segments ; patch in segments for sharer and
                                        ; other tables with seg in ES.
                or      ax, ax
                jnz     short patch_vec_seg ; patch vectors with segment in es
                cmp     cs:num_entry, al ; Q: is it the first call to this
                jnz     short second_entry ; N: just patch the stub with segment in ES
                                        ; Y: patch the vectors with stub
                mov     ax, ds
                call    patch_vec_segments ; patch the segment of vectors
                call    patch_offset    ; patch the offsets of vectors

second_entry:                           ; ...
                mov     ax, es          ; patch the stub with segment in es
                mov     di, offset DOSINTTABLE
                mov     cx, 8
                push    ds
                pop     es

dosinttabloop:                          ; ...
                inc     di
                inc     di
                stosw
                loop    dosinttabloop
                cmp     ax, 0F000h      ; Q: is the DOS running in the HMA
                jb      short sr_done   ; N: done
                call    check_XMM       ; Y: set up the XMS entry point
                jb      short sr_done   ; failed to set up XMS do not do
                                        ; A20 toggling in the stub.
                call    patch_in_nops   ; enable the stub to check A20 state
                mov     ds:DosHasHMA, 1 ; set flag telling DOS control of HMA
                mov     ds:FixExePatch, offset ExePatch ; set pointer to the routine that
                                        ; patches buggy exepacked code.
                mov     ds:ChkCopyProt, offset IsCopyProt ; set pointer to the routine
                                        ; that detects copy protected apps
                call    WhatCPUType
                cmp     al, 1
                jnz     short sr_done   ; we need Rational Patch only on 286 systems
                mov     ds:RationalPatchPtr, offset RationalPatch
                jmp     short sr_done
; ---------------------------------------------------------------------------

patch_vec_seg:                          ; ...
                mov     ax, es          ; patch vectors with segment in es
                call    patch_vec_segments ; patch in DOSCODE for the segments

sr_done:                                ; ...
                mov     cs:num_entry, 1
                pop     ds
                retf                    ; ! far return !

; =============== S U B R O U T I N E =======================================


patch_vec_segments proc near            ; ...
                push    es
                xor     cx, cx
                mov     es, cx
                assume es:DOSCODE
                mov     di, 82h         ; INTBASE+2 ; di -> segment of int 20h vector
                mov     word ptr es:2, ax ; segment of default divide trap handler
                inc     cx
                inc     cx              ; cx = 2

ps_set1:                                ; ...
                stosw
                inc     di
                inc     di
                loop    ps_set1
                add     di, 4           ; skip int 22h vector
                stosw                   ; set int 23h
                add     di, 6           ; skip int 24h
                mov     cx, 4           ; set vectors 25h-28h

ps_set2:                                ; ...
                stosw
                inc     di
                inc     di
                loop    ps_set2
                add     di, 4           ; skip int 29h
                mov     cx, 6           ; set vectors 2Ah-2Fh

ps_set3:                                ; ...
                stosw
                inc     di
                inc     di
                loop    ps_set3
                add     di, 8           ; skip vector 30h & 31h
                mov     cx, 14          ; sets segs for ints 32h-3Fh

ps_set4:                                ; ...
                stosw
                inc     di
                inc     di
                loop    ps_set4
                mov     word ptr es:ENTRYPOINT+3, ax ; [es:0C3h]
                pop     es
                assume es:nothing
                retn
patch_vec_segments endp


; =============== S U B R O U T I N E =======================================


patch_misc_segments proc near           ; ...
                push    bx
                push    es
                push    ax
                mov     ax, es          ; ax - > DOS segment
                push    ds
                pop     es              ; es -> DOSDATA
                mov     di, offset JShare ; initialize the jump table for the sharer
                mov     bx, ds:TEMP_DOSLOC ; bx = location to which the share
                                        ; table was patched during the first
                                        ; call to this routine
                mov     cx, 15

jumptabloop:                            ; ...
                inc     di
                inc     di              ; skip offset
                cmp     bx, 0FFFFh      ; Q: is this called for the 1st time
                jz      short share_patch ; Y: patch in sharer table
                                        ; N:
                cmp     bx, es:[di]     ; Q: has share been installed
                jnz     short no_share_patch ; Y: don't patch in sharer table

share_patch:                            ; ...
                stosw                   ; drop in segment

no_share_patch:                         ; ...
                loop    jumptabloop
                mov     si, offset COUNTRY_CDPG
                mov     word ptr [si+4Fh], ds ; [si+DOS_CCDPG.ccUcase_ptr+2]
                mov     word ptr [si+54h], ds ; [si+DOS_CCDPG.ccFileUcase_ptr+2]
                mov     word ptr [si+59h], ds ; [si+DOS_CCDPG.ccFileChar_ptr+2]
                mov     word ptr [si+5Eh], ds ; [si+DOS_CCDPG.ccCollate_ptr+2]
                mov     word ptr [si+80h], ds ; [si+DOS_CCDPG.ccMono_ptr+2]
                mov     word ptr [si+63h], ds ; [si+DOS_CCDPG.ccDBCS_ptr+2]
                mov     si, offset FastOpenTable ; fastopen routines are in doscode
                                        ; so patch with doscode seg in ax
                cmp     ds:TEMP_DOSLOC, 0FFFFh ; Q: first time
                jz      short fast_patch ; Y: patch segment
                mov     cx, ds:TEMP_DOSLOC ; Q: has fastopen patched in it's segment
                cmp     cx, [si+4]      ; [si+fastopen_entry.name_caching+2]
                jnz     short no_fast_patch ; Y: don't patch in doscode seg

fast_patch:                             ; ...
                mov     [si+4], ax      ; [si+fastopen_entry.name_caching+2]

no_fast_patch:                          ; ...
                pop     ax
                pop     es
                pop     bx
                retn
patch_misc_segments endp


; =============== S U B R O U T I N E =======================================


patch_offset    proc near               ; ...
                push    es
                xor     ax, ax          ; 0
                mov     es, ax          ; set default divide trap address
                assume es:DOSCODE
                mov     word ptr es:0, offset ldivov
                mov     di, 80h         ; INTBASE ; di-> offset of int 20 handler
                mov     ax, offset lirett
                mov     cx, 2           ; set vectors 20h & 21h to point to iret

po_iset1:                               ; ...
                stosw
                inc     di
                inc     di
                loop    po_iset1
                add     di, 4           ; skip vector 22h
                stosw                   ; set offset of 23h
                add     di, 6           ; skip 24h
                mov     cx, 4           ; sets offsets for ints 25h-28h

po_iset2:                               ; ...
                stosw
                inc     di
                inc     di
                loop    po_iset2
                add     di, 4           ; skip vector 29h
                mov     cx, 6           ; sets offsets for ints 2Ah-2Fh

po_iset3:                               ; ...
                stosw
                inc     di
                inc     di
                loop    po_iset3
                add     di, 8           ; skip vector 30h & 31h
                mov     cx, 14          ; sets offsets for ints 32h-3Fh

po_iset4:                               ; ...
                stosw
                inc     di
                inc     di
                loop    po_iset4
                mov     word ptr es:0BCh, offset lint2f ; INT 2Fh
                mov     byte ptr es:0C0h, 0EAh ; [es:ENTRYPOINT],mi_long_jmp
                mov     word ptr es:0C1h, offset lcall_entry ; [es:ENTRYPOINT+1],lcall_entry
                mov     word ptr es:80h, offset lquit ; [es:addr_int_abort] ; INT 20h
                mov     word ptr es:84h, offset lcommand ; [es:addr_int_command] ; INT 21h
                mov     word ptr es:94h, offset labsdrd ; [es:addr_int_disk_read] ; INT 25h
                mov     word ptr es:98h, offset labsdwrt ; [es:addr_int_disk_write] ; INT 26h
                mov     word ptr es:9Ch, offset lstay_resident ; [es:addr_int_keep_process] ; INT 27h
                pop     es
                assume es:nothing
                retn
patch_offset    endp

; ---------------------------------------------------------------------------
patch_table     dw offset ldivov        ; ...
                                        ; i0patch
                dw offset lquit         ; i20patch
                dw offset lcommand      ; i21patch
                dw offset labsdrd       ; i25patch
                dw offset labsdwrt      ; i26patch
                dw offset lstay_resident ; i27patch
                dw offset lint2f        ; i2fpatch
                dw offset lcall_entry   ; cpmpatch

; =============== S U B R O U T I N E =======================================


patch_in_nops   proc near               ; ...
                push    ax
                push    si
                mov     si, offset patch_table
                mov     ax, 9090h
                mov     cx, 8

pin_loop:                               ; ...
                mov     di, cs:[si]
                stosw
                inc     si
                inc     si
                loop    pin_loop
                pop     si
                pop     ax
                retn
patch_in_nops   endp

; ---------------------------------------------------------------------------
                db    0
DOSCODE         ends


                end
