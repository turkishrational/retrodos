

;
; +-------------------------------------------------------------------------+
; |   This file has been generated by The Interactive Disassembler (IDA)    |
; |           Copyright (c) 2018 Hex-Rays, <support@hex-rays.com>           |
; |                            Freeware version                             |
; +-------------------------------------------------------------------------+
;
; Input SHA256 : F426A13B1E2E5A05BC7E56A18D551608D3BDC4CB14045324468860A3725E2084
; Input MD5    : 7F03764471D91E450F960EAE084831A6
; Input CRC32  : 4C51484C


                .386
                .model flat

; ===========================================================================

; Segment type: Regular
DOSDATA         segment byte public 'DOSDATA' use16
                assume cs:DOSDATA
                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
byte_0          db 4 dup(0)             ; ...
DataVersion     dw 1
WinoldPatch1    db 8 dup(0)             ; ...
MYNUM           dw 0
FCBLRU          dw 0                    ; ...
OpenLRU         dw 0
OEM_HANDLER     dd 0FFFFFFFFh
LeaveAddr       dw offset LeaveDOS
RetryCount      dw 3                    ; ...
RetryLoop       dw 1                    ; ...
LastBuffer      dd 0FFFFFFFFh           ; ...
CONTPOS         dw 0                    ; ...
arena_head      dw 0                    ; ...
DPBHEAD         dd 0                    ; ...
SFT_ADDR        dd SFTABL               ; ...
BCLOCK          dd 0                    ; ...
BCON            dd 0                    ; ...
MAXSEC          dw 128                  ; ...
BUFFHEAD        dd 0                    ; ...
CDSADDR         dd 0                    ; ...
SFTFCB          dd 0                    ; ...
KEEPCOUNT       dw 0
NUMIO           db 0                    ; ...
CDSCOUNT        db 0                    ; ...
NULDEV          dw 2 dup(0)             ; ...
word_4C         dw 8004h                ; Null device attributes = DEVTYP|ISNULL
off_4E          dw offset SNULDEV       ; Strategy entry point
off_50          dw offset INULDEV       ; Interrupt entry point
asc_52          db 'NUL     '           ; Name of null device
SPLICES         db 0                    ; ...
Special_Entries dw 0
UU_IFS_DOS_CALL dd 0
ChkCopyProt     dw 0                    ; ...
A20OFF_PSP      dw 0                    ; ...
word_65         dw 0
                dw 0
BOOTDRIVE       db 0                    ; ...
DDMOVE          db 0                    ; ...
EXT_MEM_SIZE    dw 0
BufferQueue     dd 0                    ; ...
DirtyBufferCount dw 0                   ; ...
SC_CACHE_PTR    dd 0
SC_CACHE_COUNT  dw 0                    ; ...
BuffInHMA       db 0                    ; ...
LoMemBuff       dd 0                    ; ...
UU_BUF_EMS_FIRST_PAGE db 0, 0, 0
CL0FATENTRY     dw 0FFFFh               ; ...
IoStatFail      db 0                    ; ...
ALLOCMSAVE      db 0                    ; ...
A20OFF_COUNT    db 0                    ; ...
DOS_FLAG        db 0                    ; ...
UNPACK_OFFSET   dw 0                    ; ...
UMBFLAG         db 0                    ; ...
word_8A         dw 0                    ; ...
UMB_HEAD        dw 0FFFFh               ; ...
START_ARENA     dw 1                    ; ...
JShare          dd BadCall              ; ...
MFT_enter       dd OKCall               ; ...
MFTClose        dd OKCall               ; ...
                dd BadCall
MFTCloseP       dd BadCall              ; ...
MFTCloN         dd BadCall
set_block       dd BadCall              ; ...
clr_block       dd BadCall              ; ...
chk_block       dd OKCall               ; ...
MFT_get         dd BadCall
ShSave          dd BadCall              ; ...
ShChk           dd BadCall              ; ...
ShCol           dd OKCall
ShCloseFile     dd BadCall              ; ...
ShSU            dd BadCall              ; ...
SFTABL          dd 0FFFFFFFFh           ; ...
                dw 5
SFT0_SFTable    db 295 dup(0)           ; ...
CARPOS          db 0                    ; ...
STARTPOS        db 0                    ; ...
INBUF           db 128 dup(0)           ; ...
CONBUF          db 131 dup(0)           ; ...
PFLAG           db 0                    ; ...
VDERFLG         db 0                    ; ...
CHARCO          db 3                    ; ...
chSwitch        db '/'
AllocMethod     db 0                    ; ...
fShare          db 0                    ; ...
DIFFNAM         db 1
MYNAME          db 10h dup(20h)         ; ...
CritPatch       dw offset redir_patch   ; ...
                dw offset redir_patch
                dw offset redir_patch
                dw offset redir_patch
                dw 0
                db 90h                  ; SWAPPABLE DATA AREA
ERRORMODE       db 0                    ; ...
                                        ; critical error flag
INDOS           db 0                    ; ...
WPERR           db 0FFh                 ; ...
                                        ; drive on which current critical error occurred
EXTERR_LOCUS    db 0                    ; ...
                                        ; locus of last error
EXTERR          dw 0                    ; ...
                                        ; extended error code of last error
EXTERR_ACTION   db 0                    ; ...
                                        ; suggested action for last error
EXTERR_CLASS    db 0                    ; ...
                                        ; class of last error
EXTERRPT        dd 0                    ; ...
                                        ; Extended Error pointer
DMAADD          dd 80h                  ; ...
                                        ; current DTA (Disk Transfer Address)
CurrentPDB      dw 0                    ; ...
ConC_Spsave     dw 0                    ; ...
exit_code       dw 0                    ; ...
CURDRV          db 0                    ; ...
CNTCFLAG        db 0                    ; ...
                db 0
                db 0
USER_IN_AX      dw 0                    ; ...
PROC_ID         dw 0                    ; ...
USER_ID         dw 0                    ; ...
FirstArena      dw 0                    ; ...
BestArena       dw 0                    ; ...
LastArena       dw 0                    ; ...
ENDMEM          dw 0                    ; ...
LASTENT         dw 0                    ; ...
FAILERR         db 0                    ; ...
ALLOWED         db 0                    ; ...
NoSetDir        db 0                    ; ...
DidCTRLC        db 0                    ; ...
SpaceFlag       db 0                    ; ...
                db 90h
DAY             db 0                    ; ...
MONTH           db 0                    ; ...
YEAR            dw 0                    ; ...
                                        ; YEAR (and CENTURY)
DAYCNT          dw 0FFFFh               ; ...
WEEKDAY         db 0                    ; ...
CONSWAP         db 0                    ; ...
IDLEINT         dw 1                    ; ...
DEVCALL_REQLEN  db 0                    ; ...
                                        ; offset DEVCALL
DEVCALL_REQUNIT db 0                    ; ...
DEVCALL_REQFUNC db 0                    ; ...
DEVCALL_REQSTAT dw 0                    ; ...
                db 8 dup(0)
CALLUNIT        db 0                    ; ...
CALLBR          db 0                    ; ...
CALLVIDM        db 0                    ; ...
CALLXAD_2       dw 0                    ; ...
CALLBPB         dw 0                    ; ...
CALLSSEC        dw 0                    ; ...
CALLVIDRW       dd 0                    ; ...
CALLNEWSC       dw 2 dup(0)             ; ...
CALLDEVAD       dd 0                    ; ...
IOCALL          db 0                    ; ...
IOCALL_REQUNIT  db 0                    ; ...
IOCALL_REQFUNC  db 0                    ; ...
IOCALL_REQSTAT  dw 0                    ; ...
                db 8 dup(0)
IOMED           db 0                    ; ...
IOXAD           dd 0                    ; ...
IOSCNT          dw 0                    ; ...
IOSSEC          dw 0                    ; ...
DSKSTCALL       db 14                   ; ...
                db 0
DSKSTCOM        db 5                    ; ...
DSKSTST         dw 0                    ; ...
                db 8 dup(0)
DSKCHRET        db 0                    ; ...
DEVIOBUF_PTR    dw offset DEVIOBUF
DOSSEG_INIT     dw 0                    ; ...
DSKSTCNT        dw 1                    ; ...
                dw 0
CreatePDB       db 0                    ; ...
Lock_Buffer     dd 0                    ; ...
                dd 0
byte_3B1        db 90h                  ; ...
USERNUM         dd 0                    ; ...
TIMEBUF         dw 3 dup(0)             ; ...
DEVIOBUF        dw 0                    ; ...
OPENBUF         db 128 dup(0)           ; ...
RENBUF          db 128 dup(0)           ; ...
SEARCHBUF       db 53 dup(0)            ; ...
DUMMYCDS        db 88 dup(0)            ; ...
NAME1           db 12 dup(0)            ; ...
NAME2           db 13 dup(0)            ; ...
DESTSTART       dw 0                    ; ...
                db 5 dup(0)
ATTRIB          db 0                    ; ...
EXTFCB          db 0                    ; ...
SATTRIB         db 0                    ; ...
OPEN_ACCESS     db 0
FOUNDDEL        db 0                    ; ...
FOUND_DEV       db 0                    ; ...
FSPLICE         db 0                    ; ...
FSHARING        db 0                    ; ...
SECCLUSPOS      db 0                    ; ...
TRANS           db 0                    ; ...
READOP          db 0                    ; ...
THISDRV         db 0                    ; ...
CLUSFAC         db 0                    ; ...
CLUSSPLIT       db 0                    ; ...
INSMODE         db 0                    ; ...
CMETA           db 0                    ; ...
VOLID           db 0                    ; ...
EXIT_TYPE       dw 0                    ; ...
CREATING        db 0                    ; ...
DELALL          db 0                    ; ...
EXITHOLD        dd 0
USER_SP         dw 0                    ; ...
USER_SS         dw 0                    ; ...
CONTSTK         dw 0
THISDPB         dd 0                    ; ...
CLUSSAVE        dw 0                    ; ...
CLUSSEC         dd 0                    ; ...
PREREAD         dw 0                    ; ...
FATBYT          dw 0                    ; ...
FATBYTE         dw 0                    ; ...
DEVPT           dd 0                    ; ...
THISSFT         dd 0                    ; ...
THISCDS         dd 0                    ; ...
THISFC          dd 0                    ; ...
SFN             dw 0FFFFh               ; ...
                dw 0
dword_5AE       dd 0
WFP_START       dw 0                    ; ...
REN_WFP         dw 0                    ; ...
CURR_DIR_END    dw 0                    ; ...
NEXTADD         dw 0                    ; ...
LASTPOS         dw 0                    ; ...
CLUSNUM         dw 0                    ; ...
DIRSEC          dw 2 dup(0)             ; ...
DIRSTART        dw 0                    ; ...
SECPOS          dd 0                    ; ...
VALSEC          dw 2 dup(0)             ; ...
BYTSECPOS       dw 0                    ; ...
BYTPOS          dd 0                    ; ...
BYTCNT1         dw 0                    ; ...
                dw 0
SECCNT          dw 0                    ; ...
ENTFREE         dw 0                    ; ...
ENTLAST         dw 0                    ; ...
word_5DC        dw 0
GROWCNT         dd 0                    ; ...
CURBUF          dd 0                    ; ...
CONSFT          dd 0                    ; ...
SAVEBX          dw 0                    ; ...
SAVEDS          dw 0                    ; ...
RESTORE_TMP     dw 0                    ; ...
NSS             dw 0                    ; ...
NSP             dw 0                    ; ...
EXTOPEN_FLAG    dw 0                    ; ...
EXTOPEN_ON      db 0                    ; ...
EXTOPEN_IO_MODE dw 0                    ; ...
SAVE_DI         dw 0                    ; ...
SAVE_ES         dw 0                    ; ...
SAVE_DX         dw 0                    ; ...
SAVE_CX         dw 0                    ; ...
SAVE_BX         dw 0                    ; ...
SAVE_SI         dw 0                    ; ...
SAVE_DS         dw 0                    ; ...
HIGH_SECTOR     dw 0                    ; ...
OffsetMagicPatch dw offset MagicPatch   ; ...
DISK_FULL       db 0                    ; ...
TEMP_VAR        dw 0                    ; ...
TEMP_VAR2       dw 0                    ; ...
DrvErr          db 0                    ; ...
DOS34_FLAG      dw 0                    ; ...
dword_613       dd 0                    ; ...
                dd 0
AbsRdWr_SS      dw 0                    ; ...
AbsRdWr_SP      dw 0                    ; ...
                db 0
RENAMEDMA       db 384 dup(0)           ; ...
AUXSTACK        db 384 dup(0)           ; ...
DSKSTACK        db '@#IBM:12.01.2003.build_1.32#@ IBMDOS.COM(USA)',0 ; ...
                db 338 dup(0)           ; IOSTACK (just after DSKSTACK)
PRINTER_FLAG    db 0                    ; ...
VOLCHNG_FLAG    db 0FFh                 ; ...
                db 0
TEMP_DOSLOC     dw 0FFFFh               ; ...
byte_AA5        db 54 dup(0)
absdrw_extd     db 0                    ; ...
DIRSTART_HW     dw 0                    ; ...
CLUSNUM_HW      dw 0                    ; ...
unk_AE0         db    0
                db    0
LASTPOS_HW      dw 0                    ; ...
FATBYT_HW       dw 0                    ; ...
DESTSTART_HW    dw 0                    ; ...
CLUSTNUM_HW     dw 0                    ; ...
CL0FATENTRY_SIG dw 0                    ; ...
CCONTENT_HW     dw 0                    ; ...
ROOTCLUST_HW    dw 0                    ; ...
word_AF0        dw 0                    ; ...
CLUSTERS_HW     dw 0                    ; ...
                dw 0
                dw 0
CLSKIP_HW       dw 0                    ; ...
UCASE_TAB       dw 128                  ; ...
UCASE_TAB_2     db 128,154, 69, 65,142, 65,143,128 ; ...
                db  69, 69, 69, 73, 73, 73,142,143
                db 144,146,146, 79,153, 79, 85, 85
                db  89,153,154,155,156,157,158,159
                db  65, 73, 79, 85,165,165,166,167
                db 168,169,170,171,172,173,174,175
                db 176,177,178,179,180,181,182,183
                db 184,185,186,187,188,189,190,191
                db 192,193,194,195,196,197,198,199
                db 200,201,202,203,204,205,206,207
                db 208,209,210,211,212,213,214,215
                db 216,217,218,219,220,221,222,223
                db 224,225,226,227,228,229,230,231
                db 232,233,234,235,236,237,238,239
                db 240,241,242,243,244,245,246,247
                db 248,249,250,251,252,253,254,255
FILE_UCASE_TAB  dw 128                  ; ...
FILE_UCASE_TAB_2 db 128,154, 69, 65,142, 65,143,128 ; ...
                db  69, 69, 69, 73, 73, 73,142,143
                db 144,146,146, 79,153, 79, 85, 85
                db  89,153,154,155,156,157,158,159
                db  65, 73, 79, 85,165,165,166,167
                db 168,169,170,171,172,173,174,175
                db 176,177,178,179,180,181,182,183
                db 184,185,186,187,188,189,190,191
                db 192,193,194,195,196,197,198,199
                db 200,201,202,203,204,205,206,207
                db 208,209,210,211,212,213,214,215
                db 216,217,218,219,220,221,222,223
                db 224,225,226,227,228,229,230,231
                db 232,233,234,235,236,237,238,239
                db 240,241,242,243,244,245,246,247
                db 248,249,250,251,252,253,254,255
COLLATE_TAB     dw 256                  ; ...
                db  0, 1, 2, 3, 4, 5, 6, 7
                db  8, 9,10,11,12,13,14,15
                db 16,17,18,19,20,21,22,23
                db 24,25,26,27,28,29,30,31
                db ' !"#$%&',27h,'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                db '[\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~'
                db 127
                db 'CUEAAAACEEEIIIAAEAAOOOUUYOU$$$$$AIOUNN'
                db 166,167
                db '?'
                db 169,170,171,172
                db '!','"','"'
                db 176,177,178,179,180,181,182,183
                db 184,185,186,187,188,189,190,191
                db 192,193,194,195,196,197,198,199
                db 200,201,202,203,204,205,206,207
                db 208,209,210,211,212,213,214,215
                db 216,217,218,219,220,221,222,223
                db 224
                db 'S'
                db 226,227,228,229,230,231,232,233
                db 234,235,236,237,238,239,240,241
                db 242,243,244,245,246,247,248,249
                db 250,251,252,253,254,255
DBCS_TAB        dw 0                    ; ...
DBCS_TAB_2      db 16 dup(0)            ; ...
IBMDOSVERSION   db 7
                db 10                   ; MSVERSION
YRTAB           db 200,166,200,165,200,165,200,165 ; ...
MONTAB          db 31                   ; ...
february        db 28                   ; ...
                db 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
FILE_CHAR_TAB   dw 22                   ; ...
                                        ; length
                db 1                    ; include all
                db 0
                db 255
                db 0                    ; exclude 0 - 20h
                db 0
                db 20h
                db 2
                db 14                   ; exclude 14 special
                db '."/\[]:|<>+=;,'
                db 24 dup(0)            ; reserved
SysInitTable    dw offset DPBHEAD       ; ...
                                        ; SYSINITVARS
                dw 0
                dw offset COUNTRY_CDPG
                dw 0
                db 3 dup(0)
TEMPSEG         dw 0                    ; ...
redir_patch     db 0                    ; ...
DosHasHMA       db 0                    ; ...
FixExePatch     dw 0                    ; ...
UnknownPatch    dw 0                    ; ...
; ---------------------------------------------------------------------------

MAP_CASE:                               ; ...
                cmp     al, 80h
                jb      short L_RET     ; Map no chars below 80H ever

Map1:                                   ;
                sub     al, 80h         ; Turn into index value
                push    ds
                push    bx
                mov     bx, offset UCASE_TAB_2 ; UCASE_TAB+2
                push    cs
                pop     ds
                assume ds:DOSCODE
                xlat                    ; Get upper case character
                pop     bx
                pop     ds
                assume ds:nothing

L_RET:                                  ; ...
                retf
; ---------------------------------------------------------------------------
                db 0
                db 0
                db 0
                dw 0
                db 0
                db 5 dup(0)
byte_D87        db 23 dup(0)
USER_SP_2F      dw offset FAKE_STACK_2F ; ...
FAKE_STACK_2F   dw 14 dup(0)            ; ...
SCAN_FLAG       db 0                    ; ...
DATE_FLAG       dw 0                    ; ...
AbsDskErr       dw 0                    ; ...
                                        ; Storage for Abs dsk read/write err
NO_NAME_ID      db 'NO NAME    '        ; null media id
                db    0
; ---------------------------------------------------------------------------

SNULDEV:                                ; ...
                or      word ptr es:[bx+3], 100h ; [es:bx+SRHEAD.REQSTAT+1],(STDON>>8)

INULDEV:                                ; ...
                retf
; ---------------------------------------------------------------------------
                db 0
UmbSave2        db 5 dup(0)             ; ...
UmbSaveFlag     db 0                    ; ...
ERR_TABLE_21    db    1,   7,   4,0FFh  ; ...
                db    2,   8,   3,   2  ; CLASS ACTION and LOCUS info for the INT 21h errors
                db    3,   8,   3,   2
                db    4,   1,   4,   1
                db    5,   3,   3,0FFh
                db    6,   7,   4,   1
                db    7,   7,   5,   5
                db    8,   1,   4,   5
                db    9,   7,   4,   5
                db  0Ah,   7,   4,   5
                db  0Bh,   9,   3,   1
                db  0Ch,   7,   4,   1
                db  0Dh,   9,   4,   1
                db  0Fh,   8,   3,   2
                db  10h,   3,   3,   2
                db  11h, 0Dh,   3,   2
                db  12h,   8,   3,   2
                db  50h, 0Ch,   3,   2
                db  20h, 0Ah,   2,   2
                db  21h, 0Ah,   2,   2
                db  54h,   1,   4,0FFh
                db  56h,   3,   3,   1
                db  52h,   1,   4,   2
                db  32h,   9,   3,   3
                db  55h, 0Ch,   3,   3
                db  57h,   9,   3,   1
                db  53h, 0Dh,   4,   1
                db  24h,   1,   4,   5
                db  26h,   1,   4,   1
                db  27h,   1,   4,   1
                db  5Ah, 0Dh,   4,   2
                db 0FFh,0FFh,0FFh,0FFh
ERR_TABLE_24    db  13h, 0Bh,   7,   2  ; CLASS ACTION and LOCUS info for the INT 24h errors
                db  14h,   4,   5,   1
                db  15h,   5,   7,0FFh
                db  16h,   4,   5,   1
                db  17h, 0Bh,   4,   2
                db  18h,   4,   5,   1
                db  19h,   5,   1,   2
                db  1Ah, 0Bh,   7,   2
                db  1Bh, 0Bh,   4,   2
                db  1Ch,   2,   7,   4
                db  1Dh,   5,   4,0FFh
                db  1Eh,   5,   4,0FFh
                db  1Fh, 0Dh,   4,0FFh
                db  20h, 0Ah,   2,   2
                db  21h, 0Ah,   2,   2
                db  22h, 0Bh,   7,   2
                db  32h,   9,   3,   3
                db  23h,   7,   4,   1
                db  24h,   1,   4,   5
                db 0FFh, 0Dh,   5,0FFh
ErrMap24        db  13h, 14h, 15h, 16h, 17h, 18h, 19h, 1Ah
                db  1Bh, 1Ch, 1Dh, 1Eh, 1Fh, 1Fh, 1Fh, 22h
SPECIAL_VERSION dw 0                    ; ...
OLD_FIRSTCLUS   dw 0                    ; ...
exec_init_SP    dd 0                    ; ...
exec_init_IP    dd 0                    ; ...
                dw 0
                dw 0
                dw 0
                dw 0
                dw 0
                dw 0
                dw 0
                dw 0
                dw 0
                dw 0
                dw 0
                dw 0
                dw 0
Win386_Info     db 4, 0                 ; ...
                                        ; WIN386_SIS version
                dd 0                    ; .Next_Dev_Ptr
Win386_Inf_Virt_Dev_Ptr dd 0            ; ...
                                        ; .Virt_Dev_File_Ptr
                dd 0                    ; .Reference_Data
Instance_Data_Ptr dw offset Instance_Table, offset byte_0 ; ...
                dw offset Unknown_Ptr
                dw 0                    ; Win386_IIS.size
Instance_Table  dw offset CONTPOS       ; ...
InsTBL_CONTPOS_seg dw 0                 ; ...
                dw 2
                dw offset BCON
                dw 0
                dw 4
                dw offset CARPOS
                dw 0
                dw 106h
                dw offset CHARCO
                dw 0
                dw 1
                dw offset exec_init_SP
                dw 0
                dw 22h
                dw offset UMBFLAG
                dw 0
                dw 1
                dw offset UMB_HEAD
                dw 0
                dw 2
                dw offset DOS_FLAG
                dw 0C9h
                dw 1
                dw offset INDOS_FLAG    ; what for ?
                dw 0C9h
                dw 1
                dw offset DEVIO_IN_PROGRESS ; "devio call in progress" status flag ptr
                dw 0C9h
                dw 1
                dw 0
                dw 0
                dw 0FFFFh
                dw 0FFFFh
CL0FATENTRY_HW  dw 0FFFFh               ; ...
Unknown_Ptr     dw 0                    ; ...
                dw 0C9h
                dw 0CCh
                dw offset CARPOS
                dw 0C9h
                dw offset UNKNOWN1      ; ?
                dw 0
                dw 0
Win386_DOSVars  db 5                    ; ...
                                        ; Major_version
                db 0                    ; Minor_version
                dw offset SAVEDS
                dw offset SAVEBX
                dw offset INDOS
                dw offset USER_ID
                dw offset CritPatch
                dw offset UMB_HEAD
IsWin386        db 2 dup(0)             ; ...
                db 36h,0F6h, 6,20h, 3,0FFh ; Patch for Sidekick
                db 75h, 0Ch
                db 36h, 0FFh, 36h, 58h, 3
                db 0CDh, 28h
                db 80h,3Eh,20h, 3, 0    ; Patch for PortOfEntry
                db 75h, 37h
                db 0BCh, 0A0h, 0Ah
LocalSFT        dd 0                    ; ...
DOSINTTABLE     dd DIVOV                ; ...
DOSINTTABLE_4   dd QUIT                 ; ...
DOSINTTABLE_8   dd COMMAND              ; ...
DOSINTTABLE_12  dd ABSDRD               ; ...
DOSINTTABLE_16  dd ABSDWRT              ; ...
DOSINTTABLE_20  dd stay_resident        ; ...
DOSINTTABLE_24  dd INT2F                ; ...
DOSINTTABLE_28  dd CALL_ENTRY           ; ...
SS_Save         dw 0                    ; ...
SP_Save         dw 0                    ; ...
; ---------------------------------------------------------------------------

ldivov:                                 ; ...
                jmp     short divov_cont
; ---------------------------------------------------------------------------
                call    EnsureA20ON

divov_cont:                             ; ...
                jmp     cs:DOSINTTABLE
; ---------------------------------------------------------------------------

lquit:                                  ; ...
                jmp     short quit_cont
; ---------------------------------------------------------------------------
                call    EnsureA20ON

quit_cont:                              ; ...
                jmp     cs:DOSINTTABLE_4
; ---------------------------------------------------------------------------

lcommand:                               ; ...
                jmp     short command_cont
; ---------------------------------------------------------------------------
                call    EnsureA20ON

command_cont:                           ; ...
                jmp     cs:DOSINTTABLE_8
; ---------------------------------------------------------------------------

labsdrd:                                ; ...
                jmp     short absdrd_cont
; ---------------------------------------------------------------------------
                call    EnsureA20ON

absdrd_cont:                            ; ...
                jmp     cs:DOSINTTABLE_12
; ---------------------------------------------------------------------------

labsdwrt:                               ; ...
                jmp     short absdwrt_cont
; ---------------------------------------------------------------------------
                call    EnsureA20ON

absdwrt_cont:                           ; ...
                jmp     cs:DOSINTTABLE_16
; ---------------------------------------------------------------------------

lstay_resident:                         ; ...
                jmp     short sr_cont
; ---------------------------------------------------------------------------
                call    EnsureA20ON

sr_cont:                                ; ...
                jmp     cs:DOSINTTABLE_20
; ---------------------------------------------------------------------------

lint2f:                                 ; ...
                jmp     short int2f_cont
; ---------------------------------------------------------------------------
                call    EnsureA20ON

int2f_cont:                             ; ...
                jmp     cs:DOSINTTABLE_24
; ---------------------------------------------------------------------------

lcall_entry:                            ; ...
                jmp     short callentry_cont
; ---------------------------------------------------------------------------
                call    EnsureA20ON

callentry_cont:                         ; ...
                jmp     cs:DOSINTTABLE_28
; ---------------------------------------------------------------------------
DosRetAddr23    dd 0                    ; ...
DosRetAddr24    dd 0                    ; ...
; ---------------------------------------------------------------------------

LowInt23:                               ; ...
                pop     word ptr cs:DosRetAddr23
                pop     word ptr cs:DosRetAddr23+2
                int     23h             ; DOS - CONTROL "C" EXIT ADDRESS
                                        ; Return: return via RETF 2 with CF set
                                        ; DOS will abort program with errorlevel 0
                                        ; else
                                        ; interrupted DOS call continues
                call    EnsureA20ON
                jmp     cs:DosRetAddr23
; ---------------------------------------------------------------------------

LowInt24:                               ; ...
                pop     word ptr cs:DosRetAddr24
                pop     word ptr cs:DosRetAddr24+2
                int     24h             ; DOS - FATAL ERROR HANDLER ADDRESS
                                        ; Automatically called upon detection of unrecoverable I/O error.
                call    EnsureA20ON
                jmp     cs:DosRetAddr24
; ---------------------------------------------------------------------------

LowInt28:                               ; ...
                int     28h             ; DOS 2+ internal - KEYBOARD BUSY LOOP
                call    EnsureA20ON
                retf
; ---------------------------------------------------------------------------

disa20_xfer:                            ; ...
                call    XMMDisableA20
                cli
                mov     cs:INDOS, 0
                mov     ss:INDOS_FLAG, 0
                mov     ss, ax
                mov     sp, di
                sti
                push    ds
                push    si
                mov     es, dx
                mov     ds, dx
                mov     ax, bx
                retf
; ---------------------------------------------------------------------------

disa20_iret:                            ; ...
                call    XMMDisableA20
                dec     ds:INDOS
                dec     ds:INDOS_FLAG
                mov     ss, ds:USER_SS
                mov     sp, ds:USER_SP
                mov     bp, sp
                mov     [bp+0], al
                les     ax, dword ptr ds:NSS
                mov     ds:USER_SP, es
                mov     ds:USER_SS, ax
                pop     ax
                pop     bx
                pop     cx
                pop     dx
                pop     si
                pop     di
                pop     bp
                pop     ds
                pop     es

lirett:                                 ; ...
                iret

; =============== S U B R O U T I N E =======================================


XMMDisableA20   proc near               ; ...
                push    bx
                push    ax
                mov     ah, 6
                call    cs:XMMcontrol
                pop     ax
                pop     bx
                retn
XMMDisableA20   endp

; ---------------------------------------------------------------------------
XMMcontrol      dd 0                    ; ...
                dd 0
SC_STATUS       dw 0                    ; ...

; =============== S U B R O U T I N E =======================================


EnsureA20ON     proc near               ; ...
                pushf
                push    ds
                push    es
                push    cx
                push    si
                push    di
                xor     si, si
                mov     ds, si
                assume ds:DOSCODE
                dec     si
                mov     di, 90h
                mov     es, si
                mov     si, 80h
                mov     cx, 4
                cld
                repe cmpsw
                jz      short loc_10A7

loc_10A0:                               ; ...
                pop     di
                pop     si
                pop     cx
                pop     es
                pop     ds
                assume ds:nothing
                popf
                retn
; ---------------------------------------------------------------------------

loc_10A7:                               ; ...
                push    bx
                push    ax
                mov     ax, cs
                mov     cs:SS_Save, ss
                mov     cs:SP_Save, sp
                mov     ss, ax
                assume ss:DOSCODE
                mov     sp, offset AUXSTACK
                mov     ah, 5
                call    cs:XMMcontrol
                or      ax, ax
                jz      short loc_10D3
                mov     ss, cs:SS_Save
                assume ss:nothing
                mov     sp, cs:SP_Save
                pop     ax
                pop     bx
                jmp     short loc_10A0
; ---------------------------------------------------------------------------

loc_10D3:                               ; ...
                mov     ah, 0Fh
                int     10h             ; - VIDEO - GET CURRENT VIDEO MODE
                                        ; Return: AH = number of columns on screen
                                        ; AL = current video mode
                                        ; BH = current active display page
                cmp     al, 7
                jz      short loc_10E0
                mov     ax, 2
                int     10h             ; - VIDEO - SET VIDEO MODE
                                        ; AL = mode

loc_10E0:                               ; ...
                mov     ax, 500h
                int     10h             ; - VIDEO - SELECT DISPLAY PAGE
                                        ; AL = display page, 0-7  for modes 0 & 1, 0-3  for modes 2 & 3
                mov     si, 1213h
                push    cs
                pop     ds
                assume ds:DOSCODE
                cld

loc_10EB:                               ; ...
                lodsb
                cmp     al, 24h ; '$'
                jz      short loc_10F9
                mov     ah, 0Eh
                mov     bx, 7
                int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
                                        ; AL = character, BH = display page (alpha modes)
                                        ; BL = foreground color (graphics modes)
                jmp     short loc_10EB
; ---------------------------------------------------------------------------

loc_10F9:                               ; ...
                sti
                jmp     short loc_10F9
EnsureA20ON     endp

; ---------------------------------------------------------------------------
OldInstanceJunk dw 70h                  ; ...
                                        ; segment of BIOS
                dw 0                    ; indicate stacks in SYSINIT area
                dw 6                    ; 6 instance items
OldInstanceJunk_6 dw 0                  ; ...
                dw offset CONTPOS
                dw 2
                dw 0
                dw offset BCON
                dw 4
                dw 0
                dw offset CARPOS
                dw 106h
                dw 0
                dw offset CHARCO
                dw 1
                dw 0
                dw offset exec_init_SP
                dw 34
                dw 70h
                dw 0Ch                  ; ALTAH byte in dos bios
                dw 1
; ---------------------------------------------------------------------------
                push    cx
                mov     cx, FCBLRU

loc_112B:                               ; ...
                loop    loc_112B
                pop     cx
                retf
; ---------------------------------------------------------------------------
UmbSave1        db 11 dup(0)            ; ...
OLD_FIRSTCLUS_HW dw 0                   ; ...
FastOpenTable   dw 2                    ; ...
FastTable_2     dw offset FastRet       ; ...
                dw 0
                dw offset FastRet
                dw 0
FastOpenFlg     db 0                    ; ...
                db  0, 0, 0, 0, 0, 0
UNKNOWN1        dw 0                    ; ...
                db  0, 0, 0, 0, 0
DIRSTRLEN       dw 67                   ; ...
                db  0, 0, 0, 0, 0, 0, 0, 0
                db  0, 0, 0, 0, 0, 0, 0, 0
                db  0, 0, 0, 0, 0, 0, 0, 0
                db  0, 0, 0, 0, 0, 0, 0
CurSC_DRIVE     db 0FFh                 ; ...
WinoldPatch2    db 8 dup(0)             ; ...
FIRST_BUFF_ADDR dw 0                    ; ...
DOSP1_ID        db 36h,0C5h,36h         ; Windows 3.1 patches
                db 36h, 5,0C5h,74h, 7,0E8h
                db 90h,90h
DOSP12_ID       db 36h,0C5h,36h
                db 36h, 5,0C5h,74h, 7,0E8h
DOSP3_ID        db 51h, 6,57h,0BAh
                db 29h, 2,0E8h
                db 9Ah,0E3h,5Fh, 7
DOSP4_ID        db 59h
DOSP5_ID        db 51h
                db 0ACh,3Ch,1Ah,74h, 5
                db 0E8h
DOSP7_ID        db 2Eh,8Ch,1Eh
                db 7Eh, 5
                db 2Eh,89h,1Eh
                db 7Ch, 5
                db 8Ch,0CBh
                db 8Eh,0DBh
                db 0FEh, 6
                db 0CFh, 2
                db 33h,0C0h
DOSP8_ID        db 50h,36h,0A1h
                db 0EAh, 2,26h,3Bh,45h
                db 2Fh,58h
DOSP10_ID       db  6,1Fh
                db 8Bh,0DFh
                db 33h,0C0h,8Bh,0D0h,0E8h
                db 0DFh,0Eh
                db 1Eh,36h,0C5h,36h,36h, 5,0E8h,0AFh
                db 0Eh,8Bh,0D7h,0B4h,86h,36h,8Bh,3Eh
                db  9, 3,0F7h,0C7h, 0,80h,74h,19h
                db 0E8h,47h,17h,8Bh,0FAh,0Ah,0C0h,74h
                db 10h,3Ch, 3,74h, 3,1Fh,0EBh,0CFh
                db 5Fh
                db 36h,0C4h,3Eh,36h, 5,0E9h,0A1h, 4
                db 5Fh, 8Bh, 0FAh
DOSP13_ID       db 0ACh,3Ch,24h,74h, 8,0B3h, 7,0B4h
                db 0Eh,0CDh,10h,0EBh,0F3h,0EBh,0FEh
XMMERRMSG       db 0Dh,0Ah
                db 'A20 Hardware Error',0Dh,0Ah,'$'
COUNTRY_CDPG    db 0, 0, 0, 0, 0, 0, 0, 0 ; ...
                                        ; reserved words
                db '\COUNTRY.SYS',0     ; path name of country.sys
                db 51 dup(0)
                dw 437                  ; system code page id
                dw 6                    ; number of entries
COUNTRY_CDPG_76 db 2                    ; ...
                                        ; SetUcase
                dw offset UCASE_TAB
                dw 0
                db 4                    ; SetUcaseFile
                dw offset FILE_UCASE_TAB
                dw 0
                db 5                    ; SetFileList
                dw offset FILE_CHAR_TAB
                dw 0
                db 6                    ; SetCollate
                dw offset COLLATE_TAB
                dw 0
                db 7                    ; SetDBCS
                dw offset DBCS_TAB
                dw 0
                db 1                    ; SetCountryInfo
                dw 38                   ; NEW_COUNTRY_SIZE
_COUNTRY_ID     dw 1                    ; ...
                                        ; USA country id
                dw 437                  ; USA system code page id
COUNTRY_CDPG_108 dw 0                   ; ...
                                        ; date format
                db '$',0,0,0,0          ; currency symbol
                db ',',0                ; thousand separator
                db '.',0                ; decimal separator
                db '-',0                ; date separator
                db ':',0                ; time separator
                db 0                    ; currency format flag
                db 2                    ; # of digits after decimal in currency
                db 0                    ; time format
                dw offset MAP_CASE      ; mono case routine entry point
                dw 0                    ; segment of entry point
                db ',',0                ; data list separator
                dw 5 dup(0)             ; reserved
INDOS_FLAG      db 0                    ; ...
DEVIO_IN_PROGRESS db 0                  ; ...
_ENU            db 'ENU',0              ; ...
_USA            db 'USA',0
_US             db 'US'
                dw 1
                dw 2
                dw 0
_AM             db 'AM',0
_PM             db 'PM',0
_MMDDYY         db 'M/d/yy     dddd,MMMMdd,yyyy         '
                db 0
                db 0
                dw 0
VxDpath         db 'c:\wina20.386',0    ; ...
                db 0
drv_flags_1     db 0                    ; ...
drive_flags     db 26 dup(0)            ; ...
                db 1
BiosComBlockPtr dw 2 dup(0)             ; ...
                db 5 dup(0)
                dw 4
                dw offset INDOS_FLAG
                dw offset drive_flags
                dw offset NLS_YES
                dw offset unknown_zero_dd
NLS_YES         db 'Y'                  ; ...
NLS_NO          db 'N'                  ; ...
NLS_yes2        db 'y'                  ; ...
NLS_no2         db 'n'                  ; ...
unknown_zero_dd dd 0                    ; ...
Rational386PatchPtr dw 0                ; ...
; ---------------------------------------------------------------------------

MagicPatch:                             ; ...
                retf
; ---------------------------------------------------------------------------
                db  90h
                db  90h
                db  90h
                db  90h
                db  90h
DOSDATA         ends

; ---------------------------------------------------------------------------
; File Name   : C:\Yedek\pcdos_7_1\IBMDOS.COM
; Format      : Binary file
; Base Address: 0000h Range: 0000h - A646h Loaded length: A646h
; ===========================================================================

; Segment type: Regular
DOSCODE         segment byte public 'DOSCODE' use16
                assume cs:DOSCODE
                ;org 3F10h
                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

$STARTCODE:                             ; ...
                jmp     DOSINIT
; ---------------------------------------------------------------------------
                dw offset $STARTCODE
BioDataSeg      dw 70h
DosDSeg         dw 0                    ; ...
                                        ; DOSDATA segment address
MSMAJOR         db 7                    ; DOS_MAJOR_VERSION
MSMINOR         db 10                   ; DOS_MINOR_VERSION
I21_MAP_E_TAB   db 38h, 2, 1, 2, 39h, 3, 3, 2 ; ...
                db 5, 3Ah, 4, 10h, 3, 2, 5, 3Bh ; INT 21h Error code mapping table
                db 2, 2, 3, 3Ch, 4, 3, 2, 4
                db 5, 3Dh, 6, 3, 2, 0Ch, 4, 1Ah
                db 5, 3Eh, 1, 6, 3Fh, 2, 6, 5
                db 40h, 2, 6, 5, 41h, 3, 3, 2
                db 5, 42h, 2, 6, 1, 43h, 4, 3
                db 2, 1, 5, 44h, 5, 0Fh, 0Dh, 1
                db 6, 5, 45h, 2, 6, 4, 46h, 2
                db 6, 4, 47h, 2, 1Ah, 0Fh, 48h, 2
                db 7, 8, 49h, 2, 7, 9, 4Ah, 3
                db 7, 9, 8, 4Bh, 8, 3, 1, 2
                db 4, 0Bh, 0Ah, 8, 5, 4Eh, 3, 3
                db 2, 12h, 4Fh, 1, 12h, 56h, 5, 11h
                db 3, 2, 10h, 5, 57h, 4, 6, 8
                db 0Dh, 1, 58h, 1, 1, 5Ah, 4, 3
                db 2, 4, 5, 5Bh, 5, 50h, 3, 2
                db 4, 5, 5Ch, 4, 6, 1, 24h, 21h
                db 65h, 2, 1, 2, 66h, 2, 1, 2
                db 68h, 1, 6, 67h, 3, 4, 8, 1
                db 6Ch, 0Ah, 3, 2, 0Ch, 4, 50h, 8
                db 1Ah, 0Dh, 1, 5, 69h, 4, 0Fh, 0Dh
                db 1, 5, 70h, 1, 1, 0FFh
                db 0
DISPATCH        dw offset $ABORT        ; ...
                                        ; Standard Functions (INT 21h System Calls)
                dw offset $STD_CON_INPUT
                dw offset $STD_CON_OUTPUT
                dw offset $STD_AUX_INPUT
                dw offset $STD_AUX_OUTPUT
                dw offset $STD_PRINTER_OUTPUT
                dw offset $RAW_CON_IO
                dw offset $RAW_CON_INPUT
                dw offset $STD_CON_INPUT_NO_ECHO
                dw offset $STD_CON_STRING_OUTPUT
                dw offset $STD_CON_STRING_INPUT
                dw offset $STD_CON_INPUT_STATUS
                dw offset $STD_CON_INPUT_FLUSH
                dw offset $DISK_RESET
                dw offset $SET_DEFAULT_DRIVE
                dw offset $FCB_OPEN
                dw offset $FCB_CLOSE
                dw offset $DIR_SEARCH_FIRST
                dw offset $DIR_SEARCH_NEXT
                dw offset $FCB_DELETE
                dw offset $FCB_SEQ_READ
                dw offset $FCB_SEQ_WRITE
                dw offset $FCB_CREATE
                dw offset $FCB_RENAME
                dw offset NO_OP
                dw offset $GET_DEFAULT_DRIVE
                dw offset $SET_DMA
                dw offset $SLEAZEFUNC
                dw offset $SLEAZEFUNCDL
                dw offset NO_OP
                dw offset NO_OP
                dw offset $GET_DEFAULT_DPB
                dw offset NO_OP
                dw offset $FCB_RANDOM_READ
                dw offset $FCB_RANDOM_WRITE
                dw offset $GET_FCB_FILE_LENGTH
                dw offset $GET_FCB_POSITION
                dw offset $SET_INTERRUPT_VECTOR
                dw offset $CREATE_PROCESS_DATA_BLOCK
                dw offset $FCB_RANDOM_READ_BLOCK
                dw offset $FCB_RANDOM_WRITE_BLOCK
                dw offset $PARSE_FILE_DESCRIPTOR
                dw offset $GET_DATE
                dw offset $SET_DATE
                dw offset $GET_TIME
                dw offset $SET_TIME
                dw offset $SET_VERIFY_ON_WRITE
                dw offset $GET_DMA
                dw offset $GET_VERSION
                dw offset $KEEP_PROCESS
                dw offset $GET_DPB
                dw offset $SET_CTRL_C_TRAPPING
                dw offset $GET_INDOS_FLAG
                dw offset $GET_INTERRUPT_VECTOR
                dw offset $GET_DRIVE_FREESPACE
                dw offset $CHAR_OPER
                dw offset $INTERNATIONAL
                dw offset $MKDIR
                dw offset $RMDIR
                dw offset $CHDIR
                dw offset $CREAT
                dw offset $OPEN
                dw offset $CLOSE
                dw offset $READ
                dw offset $WRITE
                dw offset $UNLINK
                dw offset $LSEEK
                dw offset $CHMOD
                dw offset $IOCTL
                dw offset $DUP
                dw offset $DUP2
                dw offset $CURRENT_DIR
                dw offset $ALLOC
                dw offset $DEALLOC
                dw offset $SETBLOCK
                dw offset $EXEC
                dw offset $EXIT
                dw offset $WAIT
                dw offset $FIND_FIRST
                dw offset $FIND_NEXT
                dw offset $SET_CURRENT_PDB
                dw offset $GET_CURRENT_PDB
                dw offset $GET_IN_VARS
                dw offset $SETDPB
                dw offset $GET_VERIFY_ON_WRITE
                dw offset $DUP_PDB
                dw offset $RENAME
                dw offset $FILE_TIMES
                dw offset $ALLOCOPER
                dw offset $GetExtendedError
                dw offset $CreateTempFile
                dw offset $CreateNewFile
                dw offset $LockOper
                dw offset $ServerCall
                dw offset $UserOper
                dw offset $AssignOper
                dw offset $NameTrans
                dw offset NO_OP
                dw offset $GET_CURRENT_PDB
                dw offset $ECS_Call
                dw offset $SET_PRINTER_FLAG
                dw offset $GetExtCntry
                dw offset $GetSetCdPg
                dw offset $ExtHandle
                dw offset $COMMIT
                dw offset $GSetMediaID
                dw offset $COMMIT
                dw offset NO_OP
                dw offset $Extended_Open ; 6Ch
                dw offset NO_OP         ; 6Dh, OS/2 "DosMkDir2" - ROM DOS: Find first ROM program
                dw offset NO_OP         ; 6Eh, OS/2 "DosEnumAttrib" - ROM DOS: Find next ROM program
                dw offset NO_OP         ; 6Fh, OS/2 "DosQMaxEASize" - ROM DOS: Get/set searched ROM area
                dw offset $ExtCountryInfo ; 70h, MSDOS 7 (WIN 95) - Get/set extended country information
                                        ;         GET/SET INTERNATIONALIZATION INFORMATION
                dw offset $LONGNAME     ; 71h, MSDOS 7 (WIN 95) LONG FILENAME FUNCTIONS
                dw offset $LONGNAME     ; 72h, MSDOS 7 (WIN 95) LFN-FindClose
                dw offset $FAT32EXT     ; 73h, MSDOS 7 - FAT32 extended drive functions
FOO             dw offset Leave2F       ; ...
DTab            dw offset DOSTable      ; ...
DOSTable        db 50                   ; ...
                dw offset DOSInstall
                dw offset DOS_CLOSE
                dw offset RECSET
                dw offset DOSGetGroup
                dw offset PATHCHRCMP
                dw offset OUTT
                dw offset NET_I24_ENTRY
                dw offset PLACEBUF
                dw offset FREE_SFT
                dw offset BUFWRITE
                dw offset SHARE_VIOLATION
                dw offset SHARE_ERROR
                dw offset SET_SFT_MODE
                dw offset DATE16
                dw offset Idle
                dw offset SCANPLACE
                dw offset Idle
                dw offset StrCpy
                dw offset StrLen
                dw offset UCase
                dw offset POINTCOMP
                dw offset CHECKFLUSH
                dw offset SFFromSFN
                dw offset GetCDSFromDrv
                dw offset Get_User_Stack
                dw offset GETTHISDRV
                dw offset DriveFromText
                dw offset SETYEAR
                dw offset DSUM
                dw offset DSLIDE
                dw offset StrCmp
                dw offset InitCDS
                dw offset pJFNFromHandle
                dw offset $NameTrans
                dw offset CAL_LK
                dw offset DEVNAME
                dw offset Idle
                dw offset DStrLen
                dw offset NLS_OPEN
                dw offset $CLOSE
                dw offset NLS_LSEEK
                dw offset $READ
                dw offset FastInit
                dw offset NLS_IOCTL
                dw offset GetDevList
                dw offset NLS_GETEXT
                dw offset MSG_RETRIEVAL
                dw offset NO_OP
                dw offset int_2Fh_1230h
                dw offset int_2Fh_1231h
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR STATCHK

$SET_CTRL_C_TRAPPING:                   ; ...
                cmp     al, 7           ; Is this a valid subfunction?
                jbe     short scct_1    ; yes
                mov     al, 0FFh
                iret
; ---------------------------------------------------------------------------

scct_1:                                 ; ...
                push    ds
                mov     ds, cs:DosDSeg
                push    ax
                push    si
                mov     si, offset CNTCFLAG
                xor     ah, ah
                or      ax, ax          ; Check for subfunction 0
                jnz     short scct_2
                mov     dl, [si]        ; DS:SI --> Ctrl C Status byte
                jmp     short scct_9s
; ---------------------------------------------------------------------------

scct_2:                                 ; ...
                dec     ax
                jnz     short scct_3
                and     dl, 1           ; mask off bit 0 of DL and
                mov     [si], dl        ; save it as new Ctrl C status
                jmp     short scct_9s
; ---------------------------------------------------------------------------

scct_3:                                 ; ...
                dec     ax
                jnz     short scct_4
                and     dl, 1           ; mask off bit 0 of DL and
                xchg    dl, [si]        ; exchange DL with old status byte
                jmp     short scct_9s
; ---------------------------------------------------------------------------

scct_4:                                 ; ...
                cmp     al, 3           ; test for 5 after it was dec twice
                jnz     short scct_5
                mov     dl, ds:BOOTDRIVE ; return boot drive in DL
                jmp     short scct_9s
; ---------------------------------------------------------------------------

scct_5:                                 ; ...
                jb      short scct_9s
                cmp     al, 4           ; test for 6 after it was dec twice
                jnz     short scct_6
                mov     bx, 0A07h       ; 7.10 ; (MINOR_VERSION<<8)+MAJOR_VERSION
                mov     dx, 0           ; DOSREVNM
                cmp     ds:DosHasHMA, dh ; is DOS in HMA? no
                jz      short scct_9s
                mov     dh, 10h         ; yes
                jmp     short scct_9s   ; return version & 'DOS in HMA' status
; ---------------------------------------------------------------------------

scct_6:                                 ; ...
                and     ds:DOS_FLAG, 0DFh ; clear bit 5 of DOS flag
                cmp     dl, 1
                jnz     short scct_9s
                or      ds:DOS_FLAG, 20h ; set bit 5 of DOS flag

scct_9s:                                ; ...
                pop     si
                pop     ax
                pop     ds
                iret
; ---------------------------------------------------------------------------

SetCtrlShortEntry:                      ; ...
                jmp     short $SET_CTRL_C_TRAPPING
; ---------------------------------------------------------------------------

$SET_CURRENT_PDB:                       ; ...
                push    ds
                mov     ds, cs:DosDSeg
                mov     ds:CurrentPDB, bx
                pop     ds
                iret
; ---------------------------------------------------------------------------

$GET_CURRENT_PDB:                       ; ...
                push    ds
                mov     ds, cs:DosDSeg
                mov     bx, ds:CurrentPDB
                pop     ds
                iret
; ---------------------------------------------------------------------------

$SET_PRINTER_FLAG:                      ; ...
                push    ds
                mov     ds, cs:DosDSeg
                mov     ds:PRINTER_FLAG, al
                pop     ds
                iret
; END OF FUNCTION CHUNK FOR STATCHK
; ---------------------------------------------------------------------------

QUIT:                                   ; ...
                xor     ah, ah
                jmp     short SAVREGS
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR STATCHK

BADCALL:                                ; ...
                xor     al, al

irett:                                  ; ...
                iret
; END OF FUNCTION CHUNK FOR STATCHK
; ---------------------------------------------------------------------------

CALL_ENTRY:                             ; ...
                push    ds              ; System call entry point and dispatcher
                                        ; ***
                                        ; An alternative method of entering the system
                                        ; is to perform a CALL 5 in the program segment prefix
                                        ; with the contents of CL indicating what system call
                                        ; the user would like
                mov     ds, cs:DosDSeg
                pop     ds:SAVEDS
                pop     ax
                pop     ax
                pop     ds:USER_SP
                pushf                   ; Re-order the stack
                                        ; to simulate an interrupt 21h.
                cli
                push    ax
                push    ds:USER_SP      ; Stack now ordered as if INT had been used
                push    ds:SAVEDS
                pop     ds
                cmp     cl, 36          ; MAXCALL
                                        ; This entry point doesn't get as many calls
                ja      short BADCALL
                mov     ah, cl
                jmp     short SAVREGS
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR STATCHK

COMMAND:                                ; ...
                cli                     ; This is the normal INT 21h entry point.
                                        ; We first perform a quick test to see if
                                        ; we need to perform expensive DOS-entry
                                        ; functions. Certain system calls are done
                                        ; without interrupts being enabled.
                cmp     ah, 73h
                ja      short BADCALL

SAVREGS:                                ; ...
                cmp     ah, 33h         ; Check Minimum special case number
                jb      short SaveAllRegs
                jz      short SetCtrlShortEntry
                cmp     ah, 64h         ; Check Maximum case number
                ja      short SaveAllRegs
                jz      short $SET_PRINTER_FLAG
                cmp     ah, 51h
                jz      short $GET_CURRENT_PDB
                cmp     ah, 50h
                jz      short $SET_CURRENT_PDB
                cmp     ah, 62h
                jz      short $GET_CURRENT_PDB

SaveAllRegs:                            ; ...
                push    es
                push    ds
                push    bp
                push    di
                push    si
                push    dx
                push    cx
                push    bx
                push    ax
                mov     ax, ds
                mov     ds, cs:DosDSeg
                mov     ds:SAVEDS, ax
                mov     ax, ds:USER_SP
                mov     ds:SAVEBX, bx
                mov     ds:NSP, ax
                mov     ax, ds:USER_SS
                mov     ds:NSS, ax
                xor     ax, ax          ; 0
                test    ds:IsWin386, 1  ; WIN386 patch. Do not update USER_ID
                mov     ds:FSHARING, al ; allow redirection
                jnz     short set_indos_flag ; if win386 present
                mov     ds:USER_ID, ax

set_indos_flag:                         ; ...
                inc     ds:INDOS        ; Flag that we're in the DOS
                inc     ds:INDOS_FLAG   ; duplicated INDOS flag (what for ?)
                mov     ax, ds:CurrentPDB
                mov     ds:USER_SP, sp
                mov     ds:USER_SS, ss
                mov     ds:PROC_ID, ax
                mov     ds, ax
                pop     ax
                push    ax
                mov     word ptr ds:2Eh, sp ; [PDB.USER_STACK]
                mov     word ptr ds:30h, ss ; [PDB.USER_STACK+2]
                mov     ss, cs:DosDSeg

REDISP:                                 ; ...
                mov     sp, offset AUXSTACK
                sti
                mov     bx, ss
                mov     ds, bx
                xchg    ax, bx
                xor     ax, ax
                mov     ds:EXTOPEN_ON, al ; Clear extended open flag
                and     ds:DOS34_FLAG, 800h ; EXEC_AWARE_REDIR
                                        ; clear all bits except bit 11
                mov     ds:CONSWAP, al  ; random clean up of possibly mis-set flags
                mov     ds:NoSetDir, al ; set directories on search
                mov     ds:FAILERR, al  ; FAIL not in progress
                inc     ax
                mov     byte ptr ds:IDLEINT, al ; presume that we can issue INT 28h
                xchg    ax, bx          ; Restore AX and BX = 1
                mov     bl, ah
                add     bx, bx          ; 2 bytes per call in table
                cld
                or      ah, ah
                jz      short DSKROUT
                cmp     ah, 59h         ; GETEXTENDEDERROR
                jz      short DISPCALL
                cmp     ah, 0Ch         ; STD_CON_INPUT_FLUSH ; 12
                ja      short DSKROUT

IOROUT:                                 ;
                cmp     ds:ERRORMODE, 0 ; Are we in an INT 24h
                jnz     short DISPCALL  ; Stay on AUXSTACK if INT 24h
                mov     sp, offset PRINTER_FLAG ; mov sp,IOSTACK
                jmp     short DISPCALL
; ---------------------------------------------------------------------------

DSKROUT:                                ; ...
                mov     ds:USER_IN_AX, ax
                mov     word ptr ds:WPERR, 1FFh
                mov     ds:ERRORMODE, 0
                push    ax
                mov     ah, 82h
                int     2Ah             ; Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7
                pop     ax
                mov     byte ptr ds:IDLEINT, 0
                mov     sp, offset DSKSTACK ; "@#IBM:12.01.2003.build_1.32#@ IBMDOS.CO"...
                test    ds:CNTCFLAG, 0FFh
                jz      short DISPCALL
                push    ax
                call    DSKSTATCHK
                pop     ax

DISPCALL:                               ; ...
                mov     bx, cs:DISPATCH[bx]
                xchg    bx, ds:SAVEBX
                mov     ds, ds:SAVEDS
                call    ss:SAVEBX
                and     ss:DOS_FLAG, 0DBh

LeaveDOS:                               ; ...
                cli
                mov     ds, cs:DosDSeg
                cmp     ds:A20OFF_COUNT, 0
                jnz     short disa20

LeaveA20On:                             ; ...
                dec     ds:INDOS
                dec     ds:INDOS_FLAG
                mov     ss, ds:USER_SS
                mov     sp, ds:USER_SP
                mov     bp, sp
                mov     [bp+0], al
                les     ax, dword ptr ds:NSS
                mov     ds:USER_SS, ax
                mov     ds:USER_SP, es
                pop     ax
                pop     bx
                pop     cx
                pop     dx
                pop     si
                pop     di
                pop     bp
                pop     ds
                pop     es
                iret
; ---------------------------------------------------------------------------

disa20:                                 ; ...
                mov     bx, ds:A20OFF_PSP
                cmp     bx, ds:CurrentPDB
                jnz     short LeaveA20On
                dec     ds:A20OFF_COUNT
                push    ds
                mov     bx, offset disa20_iret
                push    bx
                retf
; END OF FUNCTION CHUNK FOR STATCHK

; =============== S U B R O U T I N E =======================================


restore_world   proc near               ; ...
                mov     es, cs:DosDSeg
                pop     es:RESTORE_TMP
                pop     ax
                pop     bx
                pop     cx
                pop     dx
                pop     si
                pop     di
                pop     bp
                pop     ds
                jmp     es:RESTORE_TMP
restore_world   endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


save_world      proc near               ; ...
                mov     es, cs:DosDSeg
                pop     es:RESTORE_TMP
                push    ds
                push    bp
                push    di
                push    si
                push    dx
                push    cx
                push    bx
                push    ax
                push    es:RESTORE_TMP
                push    bp
                mov     bp, sp
                mov     es, word ptr [bp+20]
                pop     bp
                retn
save_world      endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


Get_User_Stack  proc near               ; ...
                mov     ds, cs:DosDSeg
                lds     si, dword ptr ds:USER_SP
                retn
Get_User_Stack  endp

; ---------------------------------------------------------------------------
ERRIN           db 2                    ; ...
                db 6
                db 0Ch
                db 4
                db 8
                db 0
ERROUT          db 80h
                db 40h
                db 2
                db 10h
                db 4
                db 3

; =============== S U B R O U T I N E =======================================


AbsSetup        proc near               ; ...
                mov     ss:absdrw_extd, ah ; Extended ABS Disk Read/Write flag
                                        ; (AH=1 for INT 21h ax=7305h function)
                or      ah, ah
                jnz     short AbsSetup1 ; INT 21h AX=7305h
                                        ; INT 25h
                inc     ss:INDOS_FLAG   ; Windows DOSBOX's INDOS flag ?
                inc     ss:INDOS

AbsSetup1:                              ; ...
                sti
                cld
                push    ds
                push    ss
                pop     ds
                call    GETBP
                pop     ds
                jb      short errdriv

AbsSetup2:
                mov     ss:HIGH_SECTOR, 0
                call    RW32_CONVERT
                jb      short errdriv
                call    null_sub
                push    ds
                push    si
                push    ax
                push    ss
                pop     ds
                mov     si, offset OPENBUF
                mov     [si], al
                add     byte ptr [si], 41h ; 'A'
                mov     word ptr [si+1], 3Ah ; ':'
                mov     ax, 300h
                clc
                int     2Ah             ; Microsoft Networks - CHECK DIRECT I/O
                                        ; DS:SI -> ASCIZ disk device name (may be full path or only drive
                                        ; specifier--must include the colon)
                                        ; Return: CF clear if absolute disk access allowed
                pop     ax
                pop     si
                pop     ds
                jnb     short AbsSetup_retn

errdriv:                                ; ...
                mov     ss:EXTERR, 32h  ; error_not_supported
                mov     ss:AbsDskErr, 207h ; disk error ? (bad address mark)

AbsSetup_retn:                          ; ...
                retn
AbsSetup        endp

; ---------------------------------------------------------------------------

ABSDRD:                                 ; ...
                xor     ah, ah          ; Interrupt 25h handler (ah=0)
                xor     si, si          ; clear read/write mode flags
                                        ; (used with INT 21h ax=7305h)

FAT32_ABSDRD:                           ; ...
                cli                     ; ah=1
                clc
; START OF FUNCTION CHUNK FOR FAT32_ABSDWRT

absdrd_1:                               ; ...
                push    ax
                mov     ax, ds
                mov     ds, cs:DosDSeg
                mov     ds:TEMPSEG, ax
                pop     ax
                push    es
                jnb     short absdrd_2  ; (not jumped from ABSDWRT) absolute disk read
                                        ; (jumped from ABSDRWT)
                or      ah, ah
                stc                     ; absolute disk write
                jmp     short absdrd_3
; ---------------------------------------------------------------------------

absdrd_2:                               ; ...
                or      ah, ah

absdrd_3:                               ; ...
                jnz     short absdrd_4  ; EXTENDED ABSOLUTE DISK READ/WRITE
                mov     ds:AbsRdWr_SS, ss
                mov     ds:AbsRdWr_SP, sp
                mov     ss, cs:DosDSeg
                mov     sp, offset DSKSTACK ; "@#IBM:12.01.2003.build_1.32#@ IBMDOS.CO"...

absdrd_4:                               ; ...
                mov     ds, ds:TEMPSEG
                push    es
                call    save_world
                push    es
                jnb     short absdrd_5  ; absolute disk read
                jmp     absdrwt_3       ; (jumping back to) absolute disk write
; ---------------------------------------------------------------------------

absdrd_5:                               ; ...
                call    AbsSetup
                jb      short ILEAVE
                call    ECritDisk
                mov     ss:CurSC_DRIVE, 0FFh ; invalidate secondary cache
                call    LCritDisk
                call    DSKREAD
                jnz     short ERR_LEAVE
                mov     cx, di
                mov     ss:TEMP_VAR2, ds
                mov     ss:TEMP_VAR, bx ; CX = # of contiguous sectors read
                                        ; ES:BP -> Drive Parameter Block (DPB)
                                        ; [HIGH_SECTOR]:DX = physical sector # of 1st sector in extent
                                        ; [TEMP_VAR2]:[TEMP_VAR] = Transfer address
                call    DskRdBufScan
                jmp     short ILEAVE
; ---------------------------------------------------------------------------

TLEAVE:                                 ; ...
                jz      short ILEAVE

ERR_LEAVE:                              ; ...
                push    es
                push    cs
                pop     es
                assume es:DOSCODE
                xor     ah, ah
                mov     cx, 6
                mov     di, offset ERRIN
                repne scasb
                jnz     short LEAVECODE
                mov     ah, es:[di+5]   ; [ES:DI+NUMERR-1]

LEAVECODE:                              ; ...
                pop     es
                assume es:nothing
                mov     ss:AbsDskErr, ax
                stc

ILEAVE:                                 ; ...
                pop     es
                call    restore_world
                pop     es
                pushf
                cmp     ss:absdrw_extd, 0 ; FAT32- EXTENDED ABSOLUTE DISK READ/WRITE flag
                jnz     short ILEAVE_EXTD ; INT 21h AX=7305h
                                        ; INT 25h
                popf
                cli
                mov     ax, ss:AbsDskErr
                dec     ss:INDOS
                dec     ss:INDOS_FLAG
                push    ss
                pop     es
                mov     ss, es:AbsRdWr_SS
                assume ss:DOSCODE
                mov     sp, es:AbsRdWr_SP
                pop     es
                sti
                retf
; ---------------------------------------------------------------------------

ILEAVE_EXTD:                            ; ...
                popf
                mov     ax, ss:AbsDskErr
                pop     es
                sti
                retn
; END OF FUNCTION CHUNK FOR FAT32_ABSDWRT
; ---------------------------------------------------------------------------

ABSDWRT:                                ; ...
                xor     ah, ah
                mov     si, 1

; =============== S U B R O U T I N E =======================================


FAT32_ABSDWRT   proc far                ; ...

; FUNCTION CHUNK AT 43CA SIZE 000000AD BYTES

                cmp     al, 2
                jb      short absdrwt_2 ; floppy disk
                                        ; hard disk
                push    bx
                push    ds
                mov     ds, cs:DosDSeg
                xor     bh, bh
                mov     bl, al          ;
                                        ; NOTE: PCDOS 7.1 kernel does not set
                                        ; DOS_FLAG bit 6 or drive_flags bit 7
                                        ; (It appears that these bits are set
                                        ; by Windows or a system utility or
                                        ; driver that knows the addresses of
                                        ; these FLAGs in the DOSDATA segment.)
                                        ; Erdogan Tan - 03/01/2024
                test    ds:drive_flags[bx], 80h ; test bit 7
                                        ; (removable and/or writable disk bit?)
                jnz     short absdwrt_1 ; allowed
                test    ds:DOS_FLAG, 40h ; test bit 6 (large disk support bit?)
                                        ; NOTE: Retro DOS v5 kernel must set this bit.

absdwrt_1:                              ; ...
                pop     ds
                pop     bx
                jnz     short absdrwt_2 ; allowed
                stc
                call    errdriv         ; error
                retf
; ---------------------------------------------------------------------------

absdrwt_2:                              ; ...
                cli
                stc                     ; writable disk
                                        ; ('jumped from ABSDWRT' sign for common r/w code)
                jmp     absdrd_1        ; jump to ABSDRD (common r/w) code
; ---------------------------------------------------------------------------

absdrwt_3:                              ; ...
                call    AbsSetup
                jb      short ILEAVE
                call    chk_set_first_access
                call    ECritDisk
                mov     ss:CurSC_DRIVE, 0FFh ; invalidate secondary cache
                call    Fastxxx_Purge   ; purge fatopen
                call    LCritDisk
                push    ds
                call    DskWrtBufPurge
                pop     ds
                call    DSKWRITE
                jmp     TLEAVE
FAT32_ABSDWRT   endp


; =============== S U B R O U T I N E =======================================


GETBP           proc near               ; ...
                push    ax              ; logical unit number
                add     al, 1           ; no increment; need carry flag
                jb      short SKIPGET
                call    GETTHISDRV
                jnb     short SKIPGET   ; good drive
                xor     ah, ah
                cmp     ax, 1Ah         ; error_not_DOS_disk
                jz      short SKIPGET   ; unknown media
                stc
                mov     ds:EXTERR, ax   ; invalid drive or Non DOS drive
                mov     ds:AbsDskErr, 201h

SKIPGET:                                ; ...
                pop     ax
                jnb     short GETBP_@f
                retn
; ---------------------------------------------------------------------------

GETBP_@f:                               ; ...
                les     bp, ds:THISCDS
                test    byte ptr es:[bp+44h], 80h ; [es:bp+curdir.flags+1],
                                        ; curdir_isnet>>8
                jz      short GETBP_CDS

GETBP_err:                              ; ...
                mov     ds:EXTERR, 32h ; '2' ; error_not_supported
                stc
                retn
; ---------------------------------------------------------------------------

GETBP_CDS:                              ; ...
                les     bp, es:[bp+45h] ; [ES:BP+curdir.devptr]
                push    ax
                mov     ax, es
                or      ax, bp
                pop     ax
                jz      short GETBP_err ; zero address, error
GETBP           endp


; =============== S U B R O U T I N E =======================================


GOTDPB          proc near               ; ...
                mov     word ptr ds:THISDPB, bp
                mov     word ptr ds:THISDPB+2, es
                retn
GOTDPB          endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR $IOCTL

SYS_RET_OK:                             ; ...
                call    Get_User_Stack
                and     word ptr [si+16h], 0FFFEh ; [SI+user_env.user_F],~f_Carry

DO_RET:                                 ; ...
                mov     [si], ax
                retn
; ---------------------------------------------------------------------------

SYS_RET_ERR:                            ; ...
                xor     ah, ah          ; hack to allow for smaller error rets
                call    ETAB_LK         ; Make sure code is OK, EXTERR gets set
                call    ErrorMap

From_GetSet:                            ; ...
                call    Get_User_Stack
                or      word ptr [si+16h], 1 ; [SI+user_env.user_F],f_Carry
                stc
                jmp     short DO_RET
; END OF FUNCTION CHUNK FOR $IOCTL
; ---------------------------------------------------------------------------

NO_OP:                                  ; ...
                xor     al, al          ; obsolete system calls dispatch to here
                retn

; =============== S U B R O U T I N E =======================================


FCB_RET_ERR     proc near               ; ...
                xor     ah, ah
                mov     ss:EXTERR, ax
                call    ErrorMap
                mov     al, 0FFh        ; -1
                retn
FCB_RET_ERR     endp


; =============== S U B R O U T I N E =======================================


ErrorMap        proc near               ; ...
                push    si
                mov     si, offset ERR_TABLE_21
                cmp     ss:FAILERR, 0   ; Check for SPECIAL case.
                jz      short EXTENDED_NORMAL ; All is OK.
                mov     ss:EXTERR, 53h  ; error_FAIL_I24 ; real reason

EXTENDED_NORMAL:                        ; ...
                call    CAL_LK          ; Set CLASS,ACTION,LOCUS for EXTERR
                pop     si
                retn
ErrorMap        endp


; =============== S U B R O U T I N E =======================================


CAL_LK          proc near               ; ...
                push    ds              ; Look up and set CLASS ACTION and LOCUS values
                                        ;  for GetExtendedError
                push    ax
                push    bx
                mov     ds, cs:DosDSeg  ; DOSDATA segment
                mov     bx, ds:EXTERR   ; Get error in BL

TABLK1:                                 ; ...
                lodsb
                cmp     al, 0FFh
                jz      short GOT_VALS  ; End of table
                cmp     al, bl
                jz      short GOT_VALS  ; Got entry
                add     si, 3           ; Next table entry
                jmp     short TABLK1
; ---------------------------------------------------------------------------

GOT_VALS:                               ; ...
                lodsw
                cmp     ah, 0FFh
                jz      short NO_SET_ACT
                mov     ds:EXTERR_ACTION, ah ; Set ACTION

NO_SET_ACT:                             ; ...
                cmp     al, 0FFh
                jz      short NO_SET_CLS
                mov     ds:EXTERR_CLASS, al ; Set CLASS

NO_SET_CLS:                             ; ...
                lodsb                   ; Get LOCUS
                cmp     al, 0FFh
                jz      short NO_SET_LOC
                mov     ds:EXTERR_LOCUS, al

NO_SET_LOC:                             ; ...
                pop     bx
                pop     ax
                pop     ds
                retn
CAL_LK          endp


; =============== S U B R O U T I N E =======================================


ETAB_LK         proc near               ; ...
                push    ds              ; check for appropriate error code
                push    si
                push    cx
                push    bx
                push    ss
                pop     ds
                assume ds:DOSCODE
                mov     EXTERR, ax      ; Set EXTERR with "real" error
                mov     si, offset I21_MAP_E_TAB
                mov     bh, al          ; Real code to BH
                mov     bl, byte ptr USER_IN_AX+1 ; Sys call to BL

TABLK2:                                 ; ...
                lods    word ptr cs:[si]
                cmp     al, 0FFh        ; End of table?
                jz      short NOT_IN_TABLE
                cmp     al, bl          ; Found call?
                jz      short GOT_CALL  ; Yes
                xchg    ah, al
                xor     ah, ah
                add     si, ax          ; Next table entry
                jmp     short TABLK2
; ---------------------------------------------------------------------------

NOT_IN_TABLE:                           ; ...
                mov     al, bh          ; Restore original code
                jmp     short NO_MAP
; ---------------------------------------------------------------------------

GOT_CALL:                               ; ...
                mov     cl, ah
                xor     ch, ch          ; Count of valid err codes to CX

CHECK_CODE:                             ; ...
                lods    byte ptr cs:[si]
                cmp     al, bh          ; Code OK?
                jz      short NO_MAP    ; Yes
                loop    CHECK_CODE

NO_MAP:                                 ; ...
                xor     ah, ah          ; AX is now valid code
                pop     bx
                pop     cx
                pop     si
                pop     ds
                assume ds:nothing
                retn
ETAB_LK         endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


SetBad          proc near               ; ...
                mov     ax, 1           ; error_invalid_function
                push    ds
                mov     ds, cs:DosDSeg
                mov     ds:EXTERR_LOCUS, 1 ; errLOC_Unk
                pop     ds
                stc
                retn
SetBad          endp


; =============== S U B R O U T I N E =======================================


BadCall         proc far                ; ...
                call    SetBad
                retf
BadCall         endp


; =============== S U B R O U T I N E =======================================


OKCall          proc far                ; ...
                clc
                retf
OKCall          endp

; ---------------------------------------------------------------------------

INT2F:                                  ; ...
                sti
                cmp     ah, 11h         ; MultNET
                jnz     short INT2FSHR

TestInstall:                            ; ...
                or      al, al
                jz      short Leave2F

BadFunc:                                ; ...
                call    SetBad

Leave2F:                                ; ...
                retf    2
; ---------------------------------------------------------------------------

INT2FSHR:                               ; ...
                cmp     ah, 10h         ; MultSHARE
                jz      short TestInstall
                cmp     ah, 14h         ; NLSFUNC
                jz      short TestInstall
                cmp     ah, 12h         ; MultDOS
                jnz     short check_win
                jmp     DispatchDOS
; ---------------------------------------------------------------------------

check_win:                              ; ...
                cmp     ah, 16h         ; MultWin386
                jz      short Win386_Msg
                cmp     ah, 46h         ; WINOLDAP
                jnz     short next_i2f
                jmp     Winold_swap
; ---------------------------------------------------------------------------

next_i2f:                               ; ...
                jmp     far ptr 70h:5
; ---------------------------------------------------------------------------

Win386_Msg:                             ; ...
                push    ds
                mov     ds, cs:DosDSeg
                cmp     al, 3           ; win386 2.xx instance data call?
                jnz     short Win386_Msg_exit
                jmp     OldWin386Init   ; yes, return instance data
; ---------------------------------------------------------------------------

Win386_Msg_exit:                        ; ...
                cmp     al, 6           ; Win386_Exit  ; is it an exit call?
                jnz     short Win386_Msg_devcall
                jmp     Win386_Leaving
; ---------------------------------------------------------------------------

Win386_Msg_devcall:                     ; ...
                cmp     al, 7           ; Win386_Devcall ; is it call from DOSMGR?
                jnz     short Win386_Msg_init
                jmp     Win386_Query
; ---------------------------------------------------------------------------

Win386_Msg_init:                        ; ...
                cmp     al, 5           ; Win386_Init ; is it an init call?
                jz      short Win386_Starting
                jmp     win_nexti2f
; ---------------------------------------------------------------------------

Win386_Starting:                        ; ...
                push    ax
                push    cx
                push    di
                push    es
                push    ds
                pop     es
                mov     di, offset INBUF
                mov     cx, 5
                cld

Win386_s_floop:                         ; ...
                mov     ax, 'OC'        ; 4F43h ('CO' in NASM syntax)
                stosw
                mov     ax, ' N'        ; 204Eh ('N ' in NASM syntax)
                stosw
                add     di, 55
                loop    Win386_s_floop
                pop     es
                pop     di
                pop     cx
                pop     ax
                test    dx, 1           ; is this really win386?
                jz      short Win386_vchk ; yes
                jmp     win_nexti2f     ; win 286 dos extender
; ---------------------------------------------------------------------------

Win386_vchk:                            ; ...
                mov     word ptr ds:Win386_Inf_Virt_Dev_Ptr, 0
                mov     word ptr ds:Win386_Inf_Virt_Dev_Ptr+2, 0
                cmp     di, 400h        ; version >= 400
                jnb     short jmp_to_noVxD31

Win386_vxd:
                push    ax
                push    bx
                push    cx
                push    dx
                push    si
                mov     bx, ds:UMB_HEAD
                push    di
                cmp     bx, 0FFFFh
                jz      short Vxd31
                mov     ds:UmbSaveFlag, 1
                push    ds
                push    es
                push    ds
                pop     es
                mov     ds, bx
                xor     si, si
                clc                     ; not necessary (XOR already clears CF)

restore_ubmhead:                        ; ...
                cld                     ; !! PCDOS 7.1 bug !!
                                        ; jump from 'Win386_Leaving' here was/is wrong
                                        ; (DI and SI would be reversed for 'Win386_Leaving')
                                        ; Erdogan Tan - 05/01/2024
                mov     di, offset UmbSave1
                mov     cx, 11
                rep movsb
                mov     di, offset UmbSave2
                mov     cl, 5
                rep movsb
                jnb     short restore_ubmhead_c ; (not jumped from 'Win386_Leaving')
                jmp     restore_ubmhead_ok ; (jumped from 'Win386_Leaving' just after 'stc')
; ---------------------------------------------------------------------------

restore_ubmhead_c:                      ; ...
                pop     es
                pop     ds

Vxd31:                                  ; ...
                test    ds:DOS_FLAG, 2  ; SUPPRESS_WINA20
                jz      short Dont_Supress
                pop     di
                pop     si
                pop     dx
                pop     cx
                pop     bx
                pop     ax

jmp_to_noVxD31:                         ; ...
                jmp     short noVxD31
; ---------------------------------------------------------------------------

Dont_Supress:                           ; ...
                mov     al, ds:BOOTDRIVE
                add     al, 40h ; '@'   ; 'A'-1
                mov     byte ptr ds:VxDpath, al ; "c:\\wina20.386"
                mov     ax, 6C00h       ; ExtOpen<<8
                mov     bx, 2080h       ; read access, compatibility mode
                                        ; no inherit, suppress crit err
                mov     cx, 7           ; hidden,system,read-only attr
                cwd
                inc     dx              ; dx bit 0 = 1 ; fail if file does not exist
                mov     si, offset VxDpath ; "c:\\wina20.386"
                mov     di, 0FFFFh
                int     21h             ; DOS - 4.0 - EXTENDED OPEN/CREATE
                                        ; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
                                        ; BH = flags, CX = create attribute, DL = action if file exists/does not exists
                                        ; DH = 00h (reserved), DS:SI -> ASCIZ file name
                pop     di
                pop     si
                pop     dx
                pop     cx
                jnb     short VxDthere  ; we found the VxD, go ahead
                push    dx
                push    ds
                push    si
                mov     si, offset NoVxDErrMsg ; "You must have the file WINA20.386 in th"...
                push    cs
                pop     ds
                assume ds:DOSCODE
                mov     cx, 99          ; VxDMesLen
                mov     ah, 2           ; write char to console
                cld

vxdlp:                                  ; ...
                lodsb
                xchg    dl, al
                int     21h             ; DOS - DISPLAY OUTPUT
                                        ; DL = character to send to standard output
                loop    vxdlp
                pop     si
                pop     ds
                assume ds:nothing
                pop     dx
                pop     bx
                pop     ax
                inc     cx
                jmp     short jmp_to_win_nexti2f
; ---------------------------------------------------------------------------

VxDthere:                               ; ...
                mov     bx, ax
                mov     ah, 3Eh
                int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
                                        ; BX = file handle
                mov     bx, offset Win386_Info
                mov     word ptr [bx+6], offset VxDpath ; "c:\\wina20.386"
                mov     word ptr [bx+8], ds
                pop     bx
                pop     ax

noVxD31:                                ; ...
                or      ds:IsWin386, 1
                or      ds:redir_patch, 1
                push    dx
                mov     dx, bx
                mov     bx, offset Win386_Info
                mov     [bx+2], dx
                mov     word ptr [bx+4], es
                pop     dx
                push    ds
                pop     es

jmp_to_win_nexti2f:                     ; ...
                jmp     win_nexti2f
; ---------------------------------------------------------------------------

Win386_Leaving:                         ; ...
                test    dx, 1           ; is this really win386?
                jnz     short jmp_to_win_nexti2f ; NO! It's win 286 dos extender!

Win386_Leaving_c:                       ; was umb_arena saved at win start up ?
                cmp     ds:UmbSaveFlag, 1
                jnz     short noumb     ; not saved
                mov     ds:UmbSaveFlag, 0 ; clear UmbSaveFlag
                                        ; and restore previously saved umb_head
                push    ax
                push    es
                push    cx
                push    si
                push    di
                mov     es, ds:UMB_HEAD
                assume es:nothing
                xor     di, di
                stc                     ; CF=1 is a sign to jump 'restore_ubmhead_ok' address
                                        ; from -the common code at- 'restore_ubmhead' address
                                        ; (.. but this is a BUG!)
                                        ; ;
                jmp     restore_ubmhead ; !! PCDOS 7.1 bug !!
                                        ; (jumped code does not restore umbhead,
                                        ; MSDOS 6.22 code was correct, modification is wrong)
                                        ; Erdogan Tan - 05/01/2024
                                        ;
                                        ; Correct code here, would be:
                                        ;    cld
                                        ;    mov  si,UmbSave1
                                        ;    mov  cx,11
                                        ;    rep  movsb
                                        ;    mov  si,UmbSave2
                                        ;    mov  cl,5
                                        ;    rep  movsb
; ---------------------------------------------------------------------------

restore_ubmhead_ok:                     ; ...
                pop     di
                pop     si
                pop     cx
                pop     es
                assume es:nothing
                pop     ax

noumb:                                  ; ...
                and     ds:IsWin386, 0FEh
                and     ds:redir_patch, 0
                jmp     short win_nexti2f
; ---------------------------------------------------------------------------

Win386_Query:                           ; ...
                cmp     bx, 15h         ; Win386_DOSMGR ; is this from DOSMGR?
                jnz     short win_nexti2f ; no, ignore it & chain to next
                or      cx, cx          ; is it an instance query?
                jnz     short dosmgr_func ; no, some DOSMGR query
                inc     cx              ; indicate that data is instanced
                mov     bx, offset Win386_DOSVars
                push    ds
                pop     es              ; es:bx points at offset table
                jmp     short PopIret
; ---------------------------------------------------------------------------

OldWin386Init:                          ; ...
                pop     ax
                mov     si, offset OldInstanceJunk ; ds:si = instance table
                mov     ax, 5248h       ; 'HR' ; indicate instance data present
                jmp     short win_nexti2f2
; ---------------------------------------------------------------------------

dosmgr_func:                            ; ...
                dec     cx
                jz      short win386_patch ; call to patch DOS
                dec     cx
                jz      short PopIret   ; remove DOS patches, ignore
                dec     cx
                jz      short win386_size ; get size of DOS data structures
                dec     cx
                jz      short jmp_to_win386_inst ; instance more data
                loop    PopIret         ; no functions above this
                mov     ax, es          ; Get DOS device driver size
                                        ; ax = device header segment
                dec     ax              ; get arena header
                push    es
                mov     es, ax          ; arena header for device driver
                assume es:nothing
                cmp     byte ptr es:[di], 44h ; 'D' ; is it a device arena?
                jnz     short cantsize  ; no
                inc     ax              ; get back device header segment
                cmp     es:[di+1], ax   ; owner field pointing at driver?
                jnz     short cantsize  ; no
                mov     ax, es:[di+3]   ; get arena size in paragraphs
                pop     es
                assume es:nothing
                mov     bx, 16
                mul     bx
                mov     cx, ax
                mov     bx, dx
                jmp     short win386_done ; return with device driver size
; ---------------------------------------------------------------------------

cantsize:                               ; ...
                pop     es
                xor     ax, ax

win386_inst:                            ; ...
                xor     dx, dx          ; ask DOSMGR to use its methods
                jmp     short PopIret
; ---------------------------------------------------------------------------

win386_patch:                           ; ...
                mov     bx, dx          ; move patch bitfield to bx
                jmp     short win386_done ; done, return
; ---------------------------------------------------------------------------

win386_size:                            ; ...
                test    dl, 1           ; check for CDS size bit
                jz      short PopIret   ; no, unknown structure -- return
                mov     cl, 88          ; cx = CDS size
                jmp     short win386_done ; return with the size
; ---------------------------------------------------------------------------

jmp_to_win386_inst:                     ; ...
                jmp     short win386_inst
; ---------------------------------------------------------------------------

win386_done:                            ; ...
                mov     ax, 0B97Ch      ; WIN_OP_DONE
                mov     dx, 0A2ABh      ; DOSMGR_OP_DONE

PopIret:                                ; ...
                pop     ds
                iret
; ---------------------------------------------------------------------------

win_nexti2f:                            ; ...
                pop     ds

win_nexti2f2:                           ; ...
                jmp     next_i2f

; =============== S U B R O U T I N E =======================================


getwinlast      proc near               ; ...
                mov     si, ds:CurrentPDB
                dec     si
                mov     es, si
                add     si, es:3
                retn
getwinlast      endp

; ---------------------------------------------------------------------------

Winold_swap:                            ; ...
                push    ds
                push    es
                push    si
                push    di
                push    cx
                mov     ds, cs:DosDSeg
                cmp     al, 1           ; swap Windows out call
                jnz     short swapin    ; no, check if Swap in call
                call    getwinlast
                push    ds
                pop     es
                mov     ds, si          ; ds = memory arena of Windows
                xor     si, si
                mov     di, offset WinoldPatch1
                mov     cx, 8
                cld
                rep movsb               ; save first 8 bytes
                mov     cl, 8
                mov     di, offset WinoldPatch2
                rep movsb               ; save next 8 bytes
                jmp     short winold_done
; ---------------------------------------------------------------------------

swapin:                                 ; ...
                cmp     al, 2           ; swap Windows in call?
                jnz     short winold_done ; no, something else, pass it on
                call    getwinlast
                mov     es, si
                xor     di, di
                mov     si, offset WinoldPatch1
                mov     cx, 8
                cld
                rep movsb               ; restore first 8 bytes
                mov     cl, 8
                mov     si, offset WinoldPatch2
                rep movsb               ; restore next 8 bytes

winold_done:                            ; ...
                pop     cx
                pop     di
                pop     si
                pop     es
                pop     ds
                jmp     next_i2f        ; chain on
; ---------------------------------------------------------------------------

int_2Fh_1231h:                          ; ...
                push    ds              ; Windows95 - SET/CLEAR "REPORT WINDOWS TO DOS PROGRAMS" FLAG
                mov     ds, cs:DosDSeg
                xor     ax, ax
                or      dl, dl
                jnz     short not_1231_dl_0
                mov     ds:IsWin386+1, 1 ; set byte after "IsWIN386" to 01h
                jmp     short int_2f_1231h_retn
; ---------------------------------------------------------------------------
                nop

not_1231_dl_0:                          ; ...
                cmp     dl, 1
                jnz     short not_1231_dl_1 ; clear "IsWIN386" bit 1
                or      ds:IsWin386, 2  ; set "IsWIN386" bit 1
                jmp     short int_2f_1231h_retn
; ---------------------------------------------------------------------------
                nop

not_1231_dl_1:                          ; ...
                cmp     dl, 2
                jnz     short not_1231_dl_2
                and     ds:IsWin386, 0FDh ; clear bit 1
                jmp     short int_2f_1231h_retn
; ---------------------------------------------------------------------------

not_1231_dl_2:                          ; ...
                inc     ax              ; return error, ax = 1
                stc

int_2f_1231h_retn:                      ; ...
                pop     ds
                retn
; ---------------------------------------------------------------------------

DispatchDOS:                            ; ...
                push    cs:FOO          ; push return address
                push    cs:DTab         ; push table address
                push    ax              ; push index
                push    bp
                mov     bp, sp          ; stack looks like:
                                        ;  0  BP
                                        ;  2  DISPATCH
                                        ;  4  TABLE
                                        ;  6  RETURN
                                        ;  8  LONG-RETURN
                                        ;  C  FLAGS
                                        ;  E  AX
                mov     ax, [bp+14]     ; get AX value
                pop     bp
                call    TableDispatch
                jmp     BadFunc         ; return indicates invalid function
; ---------------------------------------------------------------------------

DOSGetGroup:                            ; ...
                mov     ds, cs:DosDSeg
                retn
; ---------------------------------------------------------------------------

DOSInstall:                             ; ...
                mov     al, 0FFh
                retn

; =============== S U B R O U T I N E =======================================


RW32_CONVERT    proc near               ; ...
                inc     cx              ; -1 -> 0
                jz      short new32format
                dec     cx
                cmp     word ptr es:[bp+0Fh], 0 ; [es:bp+DPB.FAT_SIZE]
                jz      short rw32_conv_err ; FAT32 fs
                push    ax
                push    dx
                mov     dl, es:[bp+4]   ; [es:bp+DPB.CLUSTER_MASK]
                mov     ax, es:[bp+0Dh] ; [es:bp+DPB.MAX_CLUSTER]
                cmp     dl, 0FEh        ; 254 ; Sectors/cluster - 1
                jz      short letold    ; removable
                inc     dl
                xor     dh, dh
                mul     dx
                or      dx, dx          ; > 32mb ?

letold:                                 ; ...
                pop     dx
                pop     ax
                jz      short old_style ; no

rw32_conv_err:                          ; ...
                stc
                retn
; ---------------------------------------------------------------------------

new32format:                            ; ...
                mov     dx, [bx+2]      ; [BX+ABS_32RW.SECTOR_RBA+2]
                push    ds
                mov     ds, cs:DosDSeg  ; set up ds to DOSDATA
                mov     ds:HIGH_SECTOR, dx
                pop     ds
                mov     dx, [bx]        ; [BX+ABS_32RW.SECTOR_RBA]
                mov     cx, [bx+4]      ; [BX+ABS_32RW.ABS_RW_COUNT]
                lds     bx, [bx+6]      ; [BX+ABS_32RW.BUFFER_ADDR]

old_style:                              ; ...
                clc
                retn
RW32_CONVERT    endp


; =============== S U B R O U T I N E =======================================


Fastxxx_Purge   proc near               ; ...
                push    ax
                push    si
                push    dx
                push    ds
                mov     ds, cs:DosDSeg
                test    ds:FastOpenFlg, 80h ; Fast_yes ; fastopen installed ?
                pop     ds
                jz      short nofast    ; no
                mov     ah, 1           ; FastOpen_ID
                mov     al, 5           ; FONC_purge
                mov     dl, es:[bp+0]   ; set up drive number
                call    Fast_Dispatch   ; call fastopen/seek

nofast:                                 ; ...
                pop     dx
                pop     si
                pop     ax
                retn
Fastxxx_Purge   endp

; ---------------------------------------------------------------------------
DIVMES          db 0Dh,0Ah
                db 'Divide overflow',0Dh,0Ah
DivMesLen       dw 19                   ; ...
NoVxDErrMsg     db 'You must have the file WINA20.386 in the root of your boot drive',0Dh ; ...
                db 0Ah
                db 'to run Windows in Enhanced Mode',0Dh,0Ah
CANCHAR         db 1Bh                  ; ...
                                        ; CANCEL ; Cancel line character
ESCCHAR         db 0                    ; ...
                                        ; ESCCH ; Lead-in character for escape sequences
ESCTAB          db 40h                  ; ...
                                        ; Ctrl-Z - F6
                db 4Dh                  ; Copy one char - -->
                db 3Bh                  ; Copy one char - F1
                db 53h                  ; Skip one char - DEL
                db 3Ch                  ; Copy to char - F2
                db 3Eh                  ; Skip to char - F4
                db 3Dh                  ; Copy line - F3
                db 3Dh                  ; Kill line (no change to template ) - Not used
                db 3Fh                  ; Reedit line (new template) - F5
                db 4Bh                  ; Backspace - <--
                db 52h                  ; Enter insert mode - INS (toggle)
                db 52h                  ; Exit insert mode - INS (toggle)
                db 41h                  ; Escape character - F7
                db 41h                  ; End of table
ESCFUNC         dw offset GETCH         ; ...
                                        ; Ignore the escape sequence
                dw offset TWOESC
                dw offset EXITINS
                dw offset EXITINS       ; ENTERINS
                dw offset BACKSP
                dw offset REEDIT
                dw offset KILNEW
                dw offset COPYLIN
                dw offset SKIPSTR
                dw offset COPYSTR
                dw offset SKIPONE
                dw offset COPYONE
                dw offset COPYONE
                dw offset CTRLZ
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR FINDOLD

OEMFunctionKey:                         ; ...
                call    $STD_CON_INPUT_NO_ECHO
                mov     cl, 14          ; ESCTABLEN
                push    di
                mov     di, offset ESCTAB
                push    es
                push    cs
                pop     es
                assume es:DOSCODE
                repne scasb
                pop     es
                assume es:nothing
                pop     di
                shl     cx, 1
                mov     bp, cx
                jmp     cs:ESCFUNC[bp]
; END OF FUNCTION CHUNK FOR FINDOLD

; =============== S U B R O U T I N E =======================================


$GET_DATE       proc near               ; ...
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    READTIME
                mov     ax, YEAR
                mov     bx, word ptr DAY
                call    Get_User_Stack
                mov     [si+6], bx      ; [SI+user_env.user_DX]
                add     ax, 1980
                mov     [si+4], ax      ; [SI+user_env.user_CX]
                mov     al, ss:WEEKDAY

_RET24:                                 ; ...
                retn
$GET_DATE       endp


; =============== S U B R O U T I N E =======================================


$SET_DATE       proc near               ; ...
                mov     al, 0FFh        ; -1
                sub     cx, 1980        ; Fix bias in year
                jb      short _RET24    ; Error if not big enough
                cmp     cx, 119         ; Year must be less than 2100
                ja      short RET24
                or      dh, dh
                jz      short _RET24
                or      dl, dl
                jz      short _RET24    ; Error if either month or day is 0
                cmp     dh, 12          ; Check against max. month
                ja      short RET24
                push    ss
                pop     ds
                call    DODATE

RET24:                                  ; ...
                retn
$SET_DATE       endp


; =============== S U B R O U T I N E =======================================


$GET_TIME       proc near               ; ...
                push    ss
                pop     ds
                call    READTIME
                call    Get_User_Stack  ; Get pointer to user registers
                mov     [si+6], dx      ; [SI+user_env.user_DX]
                mov     [si+4], cx      ; [SI+user_env.user_CX]

set_time_ok:                            ; ...
                xor     al, al

RET26:                                  ; ...
                retn
$GET_TIME       endp


; =============== S U B R O U T I N E =======================================


$SET_TIME       proc near               ; ...
                mov     al, 0FFh        ; Flag in case of error
                cmp     ch, 24          ; Check hours
                jnb     short RET26
                cmp     cl, 60          ; Check minutes
                jnb     short RET26
                cmp     dh, 60          ; Check seconds
                jnb     short RET26
                cmp     dl, 100         ; Check 1/100's
                jnb     short RET26
                push    cx
                push    dx
                push    ss
                pop     ds
                mov     bx, offset TIMEBUF
                mov     cx, 6
                xor     ax, ax
                cwd
                push    bx
                call    SETREAD
                push    ds
                lds     si, BCLOCK
                assume ds:nothing
                call    DEVIOCALL2      ; Get correct day count
                pop     ds
                pop     bx
                call    SETWRITE
                pop     ds:TIMEBUF+4
                pop     ds:TIMEBUF+2
                lds     si, ds:BCLOCK
                call    DEVIOCALL2      ; Set the time
                jmp     short set_time_ok
$SET_TIME       endp


; =============== S U B R O U T I N E =======================================


DATE16          proc near               ; ...
                mov     ds, cs:DosDSeg
                push    cx
                push    es
                call    READTIME
                pop     es
                add     cl, cl
                add     cl, cl
                add     cx, cx
                add     cx, cx
                add     cx, cx
                shr     dh, 1
                or      cl, dh
                mov     dx, cx
                mov     ax, word ptr ds:MONTH
                mov     cl, 4
                shl     al, cl
                add     ax, ax
                pop     cx
                or      al, ds:DAY

RET21:                                  ; ...
                retn
DATE16          endp


; =============== S U B R O U T I N E =======================================


READTIME        proc near               ; ...
                mov     ds:DATE_FLAG, 0 ; reset date flag for CPMIO
                push    si
                push    bx
                mov     bx, offset TIMEBUF
                mov     cx, 6
                xor     ax, ax
                cwd
                call    SETREAD
                push    ds
                lds     si, ds:BCLOCK
                call    DEVIOCALL2      ; Get correct date and time
                pop     ds
                pop     bx
                pop     si
                mov     ax, ds:TIMEBUF
                mov     cx, ds:TIMEBUF+2
                mov     dx, ds:TIMEBUF+4
                cmp     ax, ds:DAYCNT   ; See if day count is the same
                jz      short RET21
                cmp     ax, 43830       ; FOURYEARS*30 ; Number of days in 120 years
                jnb     short RET22     ; Ignore if too large
                mov     ds:DAYCNT, ax
                push    si
                push    cx
                push    dx
                xor     dx, dx
                mov     cx, 1461        ; FOURYEARS ; Number of days in 4 years
                div     cx
                add     ax, ax
                add     ax, ax
                add     ax, ax          ; Multiply by 8 (no. of half-years)
                mov     cx, ax          ; <240 implies AH=0
                mov     si, offset YRTAB ; Table of days in each year
                call    DSLIDE          ; Find out which of four years we're in
                shr     cx, 1           ; Convert half-years to whole years
                jnb     short SK        ; Extra half-year?
                add     dx, 200

SK:                                     ; ...
                call    SETYEAR
                mov     cl, 1           ; At least at first month in year
                mov     si, offset MONTAB ; Table of days in each month
                call    DSLIDE          ; Find out which month we're in
                mov     ds:MONTH, cl
                inc     dx              ; Remainder is day of month (start with one)
                mov     ds:DAY, dl
                call    WKDAY           ; Set day of week
                pop     dx
                pop     cx
                pop     si

RET22:                                  ; ...
                retn
READTIME        endp


; =============== S U B R O U T I N E =======================================


DSLIDE          proc near               ; ...
                mov     ah, 0           ; (AH is already ZERO here!) 6/1/2024

DSLIDE1:                                ; ...
                lodsb                   ; Get count of days
                cmp     dx, ax          ; See if it will fit
                jb      short RET22
                sub     dx, ax
                inc     cx              ; Count one more month/year
                jmp     short DSLIDE1
DSLIDE          endp


; =============== S U B R O U T I N E =======================================


SETYEAR         proc near               ; ...
                mov     ds, cs:DosDSeg
                mov     byte ptr ds:YEAR, cl

CHKYR:                                  ; ...
                test    cl, 3           ; Check for leap year
                mov     al, 28          ; 28 days if no leap year
                jnz     short SAVFEB
                inc     al              ; Add leap day

SAVFEB:                                 ; ...
                mov     ds:february, al ; [MONTAB+1],AL ; Store for February

RET23:                                  ; ...
                retn
SETYEAR         endp


; =============== S U B R O U T I N E =======================================


DODATE          proc near               ; ...
                call    CHKYR           ; Set Feb. up for new year
                mov     al, dh
                mov     bx, (offset YRTAB+7) ; MONTAB-1
                xlat                    ; Look up days in month
                cmp     al, dl
                mov     al, 0FFh        ; -1
                jb      short RET23     ; Error if too many days
                call    SETYEAR
                mov     word ptr ds:DAY, dx ; Set both day and month
                shr     cx, 1
                shr     cx, 1
                mov     ax, 1461        ; FOURYEARS
                mov     bx, dx
                mul     cx
                mov     cl, byte ptr ds:YEAR
                and     cl, 3
                mov     si, offset YRTAB
                mov     dx, ax
                add     cx, cx          ; Two entries per year, so double count
                call    DSUM            ; Add up the days in each year
                mov     cl, bh          ; Month of year
                mov     si, offset MONTAB
                dec     cx              ; Account for months starting with one
                call    DSUM            ; Add up days in each month
                mov     cl, bl          ; Day of month
                dec     cx              ; Account for days starting with one
                add     dx, cx          ; Add in to day total
                xchg    ax, dx          ; Get day count in AX
                mov     ds:DAYCNT, ax
                push    si
                push    bx
                push    ax
                mov     bx, offset TIMEBUF
                mov     cx, 6
                xor     ax, ax
                cwd
                push    bx
                call    SETREAD
                push    ds
                lds     si, ds:BCLOCK
                call    DEVIOCALL2      ; Get correct date and time
                pop     ds
                pop     bx
                call    SETWRITE
                pop     ds:TIMEBUF
                push    ds
                lds     si, ds:BCLOCK
                call    DEVIOCALL2      ; Set the date
                pop     ds
                pop     bx
                pop     si

WKDAY:                                  ; ...
                mov     ax, ds:DAYCNT
                xor     dx, dx
                mov     cx, 7
                inc     ax
                inc     ax              ; First day was Tuesday
                div     cx              ; Compute day of week
                mov     ds:WEEKDAY, dl
                xor     al, al          ; Flag OK
                retn
DODATE          endp


; =============== S U B R O U T I N E =======================================


DSUM            proc near               ; ...
                mov     ah, 0
                jcxz    short DSUM9

DSUM1:                                  ; ...
                lodsb
                add     dx, ax
                loop    DSUM1

DSUM9:                                  ; ...
                retn
DSUM            endp


; =============== S U B R O U T I N E =======================================


$GET_VERSION    proc near               ; ...
                lds     cx, ss:USERNUM
                mov     bx, ds
                push    ss
                pop     ds
                assume ds:DOSCODE
                cmp     al, 1
                jnz     short Norm_Vers
                xor     bh, bh          ; return 0 (not ROMDOS version)

Norm_Vers:                              ; ...
                mov     ds, CurrentPDB  ; Get the version number from the
                                        ; current app's PSP segment
                assume ds:nothing
                mov     ax, word ptr ds:40h ; [PDB.Version]
                                        ; AX = DOS version number
                call    Get_User_Stack

gdrvfspc_ret:                           ; ...
                mov     [si], ax        ; [SI+user_env.user_AX]
                mov     [si+4], cx      ; [SI+user_env.user_CX]

set_user_bx:                            ; ...
                mov     [si+2], bx      ; [SI+user_env.user_BX]
                retn
$GET_VERSION    endp

; ---------------------------------------------------------------------------

$GET_VERIFY_ON_WRITE:                   ; ...
                mov     al, ss:VDERFLG
                retn
; ---------------------------------------------------------------------------

$SET_VERIFY_ON_WRITE:                   ; ...
                and     al, 1
                mov     ss:VDERFLG, al

RET27:                                  ; ...
                retn

; =============== S U B R O U T I N E =======================================


$INTERNATIONAL  proc near               ; ...

; FUNCTION CHUNK AT 4BE2 SIZE 0000002E BYTES

                cmp     al, 0FFh        ; -1 means country code is in BX
                jz      short BX_HAS_CODE
                mov     bl, al          ; Put AL country code in BX
                xor     bh, bh

BX_HAS_CODE:                            ; ...
                push    ds
                pop     es
                push    dx
                pop     di              ; User buffer to ES:DI
                push    ss
                pop     ds
                assume ds:DOSCODE
                cmp     di, 0FFFFh      ; -1
                jz      short international_set
                or      bx, bx
                jnz     short international_find
                mov     si, offset COUNTRY_CDPG
                jmp     short international_copy
; ---------------------------------------------------------------------------

international_find:                     ; ...
                xor     bp, bp          ; 0 ; flag it for GetCntry only
                call    international_get
                jb      short errtn
                or      bx, bx          ; nlsfunc finished it ?
                jnz     short international_copy ; no, copy by myself
                mov     bx, dx          ; put country back
                jmp     short international_ok3
$INTERNATIONAL  endp


; =============== S U B R O U T I N E =======================================


international_get proc near             ; ...
                mov     si, offset COUNTRY_CDPG
                cmp     bx, ss:[si+68h] ; [SI+DOS_CCDPG.ccDosCountry]
                jz      short RET27     ; = current country id
                mov     dx, bx
                xor     bx, bx          ; bx = 0, default code page
                mov     ax, 1400h
                int     2Fh             ; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
                                        ; Return: AL = 00h not installed, OK to install
                                        ; 01h not installed, not OK
                                        ; FFh installed
                cmp     al, 0FFh        ; not in memory
                jnz     short interr
                mov     ax, 1403h       ; set country info
                or      bp, bp          ; GetCntry ?
                jnz     short stcdpg
                inc     ax              ; AX = 1404h ; get country info

stcdpg:                                 ; ...
                int     2Fh             ; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
                                        ; BX = code page, DX = country code, DS:SI -> internal code page structure
                                        ; ES:DI -> user buffer
                                        ; Return: AL = status
                or      al, al
                jz      short RET27

setcarry:                               ; ...
                stc
                retn
; ---------------------------------------------------------------------------

interr:                                 ; ...
                mov     al, 0FFh
                jmp     short setcarry
international_get endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR $INTERNATIONAL

international_copy:                     ; ...
                mov     bx, ss:[si+68h] ; [ss:SI+DOS_CCDPG.ccDosCountry]
                mov     si, offset COUNTRY_CDPG_108 ; COUNTRY_CDPG+DOS_CCDPG.ccDFormat
                mov     cx, 12          ; OLD_COUNTRY_SIZE/2
                push    ds
                push    ss
                pop     ds
                rep movsw
                pop     ds
                assume ds:nothing

international_ok3:                      ; ...
                call    Get_User_Stack
                call    set_user_bx     ; MOV [SI+user_env.user_BX],BX

international_ok:                       ; ...
                mov     ax, bx
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

international_set:                      ; ...
                mov     bp, 1
                call    international_get
                jnb     short international_ok

errtn:                                  ; ...
                cmp     al, 0FFh
                jz      short errtn2

errtn1:                                 ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

errtn2:                                 ; ...
                mov     al, 1           ; error_invalid_function
                jmp     short errtn1    ; NLSFUNC not existent
; END OF FUNCTION CHUNK FOR $INTERNATIONAL
; ---------------------------------------------------------------------------

$ExtCountryInfo:                        ; ...
                cmp     al, 2           ; INT 21h, AH = 70h (06/01/2024 - Erdogan Tan)
                                        ; GET/SET INTERNATIONALIZATION INFORMATION
                                        ; ****
                                        ; AL = subfunction
                                        ; 00h SET general internationalization info
                                        ;     CX = buffer size (up to 38 bytes)
                                        ;     DS:SI -> buffer containing internationalization info
                                        ;  first three bytes are skipped, the rest is copied to somewhere
                                        ;  in the DOS data segment
                                        ; 01h SET extended internationalization info
                                        ;     CX = number of bytes to set (up to 58 bytes)
                                        ;     DS:SI -> buffer containing internationalization info
                                        ; 02h GET extended internationalization info
                                        ;     CX = buffer size in bytes (up to 58 bytes used)
                                        ;     ES:DI -> buffer
                                        ; ****
                                        ; (Ref: Ralf Brown's Interrupt List) - had some mistakes -
                ja      short errtn2
                push    es
                push    ss
                jnz     short ext_cntry_inf_1
                pop     es              ; AX = GET 35 bytes info (from offset 3 to 37)
                                        ; (38 bytes buffer is used)
                mov     di, offset _COUNTRY_ID
                mov     ax, es:[di-2]   ; NEW_COUNTRY_SIZE = 38
                mov     bx, 3           ; skip the 1st 3 bytes of the buffer
                add     si, bx
                jmp     short ext_cntry_inf_4
; ---------------------------------------------------------------------------

ext_cntry_inf_1:                        ; ...
                dec     al
                jnz     short ext_cntry_inf_2 ; AX = 2
                pop     es              ; AX = 1 (set)
                mov     di, offset _ENU ; "ENU"
                jmp     short ext_cntry_inf_3
; ---------------------------------------------------------------------------

ext_cntry_inf_2:                        ; ...
                pop     ds              ; AX = 2 (get)
                mov     si, offset _ENU ; "ENU"

ext_cntry_inf_3:                        ; ...
                xor     bx, bx          ; 0
                mov     ax, 58          ; 3Ah

ext_cntry_inf_4:                        ; ...
                cmp     cx, ax          ; > 38 ? (58)
                jb      short ext_cntry_inf_5 ; no
                mov     cx, ax          ; yes, decrease size to 38 (58)

ext_cntry_inf_5:                        ; ...
                mov     ax, cx          ; buffer (filled) size
                sub     cx, bx          ; copy byte count
                rep movsb
                pop     es
                jmp     ret_ax_to_user_cx ; ax -> user's cx

; =============== S U B R O U T I N E =======================================


$GetExtCntry    proc near               ; ...
                cmp     al, 20h         ; CAP_ONE_CHAR  ; < 20h
                jb      short notcap
                test    al, 80h         ; UPPER_TABLE
                jnz     short fileupper ; file upper case
                mov     bx, offset UCASE_TAB_2 ; UCASE_TAB+2
                                        ; get normal upper case
                jmp     short capit
; ---------------------------------------------------------------------------

fileupper:                              ; ...
                and     al, 7Fh
                mov     bx, offset FILE_UCASE_TAB_2 ; FILE_UCASE_TAB+2
                                        ; get file upper case

capit:                                  ; ...
                cmp     al, 20h         ; CAP_ONE_CHAR ; cap one char ?
                jnz     short chkyes
                mov     al, dl          ; set up AL
                call    GETLET3         ; upper case it
                call    Get_User_Stack  ; get user stack
                mov     [si+6], al      ; [SI+user_env.user_DX]
                jmp     short nono      ; done
; ---------------------------------------------------------------------------

chkyes:                                 ; ...
                cmp     al, 23h         ; CHECK_YES_NO
                jnz     short capstring ; no
                                        ; Yes/No
                xor     ax, ax          ; presume NO
                cmp     dl, ss:NLS_YES
                jz      short yesyes    ; Y(ES)
                cmp     dl, ss:NLS_yes2
                jz      short yesyes    ; y(es)
                cmp     dl, ss:NLS_NO
                jz      short nono      ; N(O)
                cmp     dl, ss:NLS_no2
                jz      short nono      ; n(o)
                inc     ax              ; not YES or NO

yesyes:                                 ; ...
                inc     ax              ; YES = 1

nono:                                   ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

capstring:                              ; ...
                mov     si, dx
                cmp     al, 21h         ; CAP_STRING
                jnz     short capascii
                jcxz    short nono

concap:                                 ; ...
                lodsb                   ; get char
                call    GETLET3         ; upper case it
                mov     [si-1], al      ; store back
                loop    concap          ; continue
                jmp     short nono      ; done
; ---------------------------------------------------------------------------

capascii:                               ; ...
                cmp     al, 22h         ; CAP_ASCIIZ
                jnz     short capinval

concap2:                                ; ...
                lodsb                   ; get char
                or      al, al          ; end of string ?
                jz      short nono      ; yes
                call    GETLET3         ; upper case it
                mov     [si-1], al      ; store back
                jmp     short concap2   ; continue
; ---------------------------------------------------------------------------

notcap:                                 ; ...
                cmp     cx, 5           ; minimum size is 5
                jb      short capinval  ; sizeerror

GEC_CONT:
                push    ss
                pop     ds
                assume ds:DOSCODE
                mov     si, offset COUNTRY_CDPG
                or      al, al
                jnz     short GETCNTRY  ;
                                        ; AL = 0 (INT 21h, AX=6500h)
                                        ; Set extended country-dependent information
                                        ; (SET GENERAL INTERNATIONALIZATION INFO)
                sub     cx, 7           ; minimum 8 bytes
                jbe     short capinval  ; error_invalid_function
                mov     bx, [si+48h]    ; [SI+DOS_CCDPG.ccSysCodePage]
                lea     si, [si+66h]    ; SI+DOS_CCDPG.ccCountryInfoLen
                mov     ax, [si]
                sub     ax, 4
                cmp     cx, ax
                jbe     short set_inter_info
                mov     cx, ax

set_inter_info:                         ; ...
                mov     ax, cx
                add     ax, 4
                mov     es:[di+1], ax   ; info length/size (will be written)
                add     si, 6           ; DOS_CCDPG.ccDFormat
                add     di, 7           ; points to date format
                call    XCHGP           ; ds:si = user's buffer + 6
                                        ; es:di = country info buffer + 7
                jmp     short OK_RETN
; ---------------------------------------------------------------------------

GETCNTRY:                               ; ...
                cmp     dx, 0FFFFh      ; -1 ; active country ?
                jnz     short GETCDPG
                mov     dx, [si+68h]    ; [SI+DOS_CCDPG.ccDosCountry]

GETCDPG:                                ; ...
                cmp     bx, 0FFFFh      ; -1 ; active code page?
                jnz     short CHKAGAIN
                mov     bx, [si+6Ah]    ; [SI+DOS_CCDPG.ccDosCodePage] ; get active code page

CHKAGAIN:                               ; ...
                cmp     dx, [si+68h]    ; [SI+DOS_CCDPG.ccDosCountry] ; same ?
                jnz     short CHKNLS    ; no
                cmp     bx, [si+6Ah]    ; [SI+DOS_CCDPG.ccDosCodePage] ; same ?
                jnz     short CHKNLS    ; no

CHKTYPE:                                ; yes, same code page and same country id
                mov     bx, [si+48h]    ; [SI+DOS_CCDPG.ccSysCodePage]
                push    cx
                mov     cx, [si+4Ah]    ; [SI+DOS_CCDPG.ccNumber_of_entries]
                mov     si, offset COUNTRY_CDPG_76 ; COUNTRY_CDPG+DOS_CCDPG.ccSetUcase

NXTENTRY:                               ; ...
                cmp     al, [si]        ; compare info type
                jz      short FOUNDIT
                add     si, 5           ; next entry
                loop    NXTENTRY
                pop     cx

capinval:                               ; ...
                jmp     errtn2          ; error_invalid_function
; ---------------------------------------------------------------------------

FOUNDIT:                                ; ...
                movsb                   ; move info id byte
                pop     cx              ; restore char count
                cmp     al, 1           ; SetCountryInfo ; select country info type ?
                jz      short setsize   ; yes
                mov     cx, 4           ; 4 bytes will be moved
                mov     ax, 5           ; 5 bytes will be returned in CX

OK_RETN:                                ; ...
                rep movsb               ; copy info
                mov     cx, ax          ; CX = actual length returned
                mov     ax, bx          ; return sys code page in ax

GETDONE:                                ; ...
                call    Get_User_Stack  ; return actual length to user's CX
                mov     [si+4], cx      ; [SI+user_env.user_CX]

nono_jmp:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

setsize:                                ; ...
                sub     cx, 3           ; size after length field
                cmp     [si], cx        ; less than table size
                jnb     short setsize2  ; no
                mov     cx, [si]        ; truncate to table size

setsize2:                               ; ...
                mov     es:[di], cx     ; copy actual length to user's buffer
                inc     di              ; update index
                inc     di
                inc     si
                inc     si
                mov     ax, cx
                add     ax, 3           ; AX has the actual length
                jmp     short OK_RETN
; ---------------------------------------------------------------------------

CHKNLS:                                 ; ...
                xor     ah, ah
                mov     bp, ax
                mov     ax, 1400h
                int     2Fh             ; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
                                        ; Return: AL = 00h not installed, OK to install
                                        ; 01h not installed, not OK
                                        ; FFh installed
                cmp     al, 0FFh
                jz      short NLSNXT    ; in memory

sizeerror:                              ; ...
                jmp     short capinval
; ---------------------------------------------------------------------------

NLSNXT:                                 ; ...
                mov     ax, 1402h
                int     2Fh             ; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
                                        ; BP = subfunction, BX = code page
                                        ; DX = country code, DS:SI -> internal code page structure
                                        ; ES:DI -> user buffer, CX = size of user buffer
                                        ; Return: AL = status
                                        ; 00h successful
                                        ; else DOS error code
                cmp     al, 0
                jnz     short NLSERROR
                mov     ax, [si+48h]    ; [SI+DOS_CCDPG.ccSysCodePage]
                jmp     short GETDONE
; ---------------------------------------------------------------------------

NLSERROR:                               ; ...
                jmp     SYS_RET_ERR
$GetExtCntry    endp


; =============== S U B R O U T I N E =======================================


$GetSetCdPg     proc near               ; ...
                push    ss
                pop     ds
                mov     si, offset COUNTRY_CDPG
                cmp     al, 1           ; get global code page
                jnz     short setglpg
                mov     bx, [si+6Ah]    ; [SI+DOS_CCDPG.ccDosCodePage]
                mov     dx, [si+48h]    ; [SI+DOS_CCDPG.ccSysCodePage]
                call    Get_User_Stack
                call    set_user_bx
                mov     [si+6], dx      ; [SI+user_env.user_DX]

OK_RETURN:                              ; ...
                jmp     short nono_jmp
; ---------------------------------------------------------------------------

setglpg:                                ; ...
                cmp     al, 2           ; set global codepage
                jnz     short nomem
                mov     dx, [si+68h]    ; [SI+DOS_CCDPG.ccDosCountry]
                mov     ax, 1400h
                int     2Fh             ; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
                                        ; Return: AL = 00h not installed, OK to install
                                        ; 01h not installed, not OK
                                        ; FFh installed
                cmp     al, 0FFh
                jnz     short nomem
                mov     ax, 1401h
                int     2Fh             ; - Multiplex - NLSFUNC.COM - CHANGE CODE PAGE
                                        ; DS:SI -> internal code page structure
                                        ; BX = new code page, DX = country code???
                                        ; Return: AL = status
                                        ; 00h successful
                                        ; else DOS error code
                or      al, al
                jz      short OK_RETURN
                cmp     al, 65          ; set device code page failed
                jnz     short seterr
                cbw
                mov     EXTERR, ax
                mov     EXTERR_ACTION, 6 ; errACT_Ignore
                mov     EXTERR_CLASS, 5 ; errCLASS_HrdFail
                mov     EXTERR_LOCUS, 4 ; errLOC_SerDev
                jmp     From_GetSet
; ---------------------------------------------------------------------------

seterr:                                 ; ...
                jmp     short NLSERROR  ; transfer SYS_RET_ERR
; ---------------------------------------------------------------------------

nomem:                                  ; ...
                jmp     short sizeerror ; function not defined
$GetSetCdPg     endp

; ---------------------------------------------------------------------------

$GET_DRIVE_FREESPACE:                   ; ...
                push    ss
                pop     ds
                mov     al, dl
                call    GETTHISDRV      ; Get drive
                jb      short BADFDRV   ; User FAILed to I 24
                call    DISK_INFO
                jnb     short gdrvfspc_1
                xchg    dx, bx
                jmp     short BADFDRV
; ---------------------------------------------------------------------------

gdrvfspc_1:                             ; ...
                xor     ah, ah          ; Chuck Fat ID byte
                push    di
                call    TestNet
                pop     di
                jb      short gdrvfspc_2
                call    modify_cluster_count ;
                                        ; if hw of total clusters (di) > 0
                                        ; sectors per cluster and cluster counts
                                        ; will be modified (shifted)
                                        ; (but sectors per clust * clust count will be same)
                                        ; /// disk size -calculation- limit = 2 GB ///

gdrvfspc_2:                             ; ...
                xchg    dx, bx          ; bx = free clusters (after xchg)

DoSt:                                   ; ...
                call    Get_User_Stack
                mov     [si+6], dx      ; [SI+user_env.user_DX] ; total clusters
                jmp     gdrvfspc_ret    ; ax = sectors per cluster (modified)
; ---------------------------------------------------------------------------

BADFDRV:                                ; ...
                call    FCB_RET_ERR
                mov     ax, 0FFFFh      ; -1
                jmp     short DoSt
; ---------------------------------------------------------------------------

$GET_DMA:                               ; ...
                mov     bx, word ptr ss:DMAADD ; Get Disk Transfer Address
                mov     cx, word ptr ss:DMAADD+2
                call    Get_User_Stack
                mov     [si+10h], cx
                jmp     set_user_bx
; ---------------------------------------------------------------------------

$SET_DMA:                               ; ...
                mov     word ptr ss:DMAADD, dx ; Set Disk Transfer Address
                mov     word ptr ss:DMAADD+2, ds
                retn
; ---------------------------------------------------------------------------

$GET_DEFAULT_DRIVE:                     ; ...
                mov     al, ss:CURDRV
                retn
; ---------------------------------------------------------------------------

$SET_DEFAULT_DRIVE:                     ; ...
                mov     al, dl
                inc     al              ; A=1, B=2...
                call    GetVisDrv       ; see if visible drive
                jb      short SETRET    ; errors do not set
                mov     ss:CURDRV, al   ; no, set

SETRET:                                 ; ...
                mov     al, ss:CDSCOUNT ; let user see what the count really is
                retn

; =============== S U B R O U T I N E =======================================


$GET_INTERRUPT_VECTOR proc near         ; ...
                call    RECSET
                les     bx, es:[bx]
                call    Get_User_Stack

set_user_es_bx:                         ; ...
                mov     word ptr [si+10h], es ; [SI+user_env.user_ES]
                jmp     set_user_bx
$GET_INTERRUPT_VECTOR endp

; ---------------------------------------------------------------------------

$SET_INTERRUPT_VECTOR:                  ; ...
                call    RECSET
                cli
                mov     es:[bx], dx
                mov     word ptr es:[bx+2], ds
                sti
                test    ss:DOS_FLAG, 4  ; EXECA20OF
                                        ; was the previous call an int 21h exec call ?
                jnz     short siv_1     ; yes
                retn
; ---------------------------------------------------------------------------

siv_1:                                  ; ...
                cmp     ss:A20OFF_COUNT, 0
                jnz     short siv_2
                mov     ss:A20OFF_COUNT, 1 ; indicate to dos dispatcher to
                                        ; turn A20 Off before returning to user

siv_2:                                  ; ...
                retn

; =============== S U B R O U T I N E =======================================


RECSET          proc near               ; ...
                xor     bx, bx
                mov     es, bx
                assume es:DOSCODE
                mov     bl, al
                shl     bx, 1
                shl     bx, 1
                retn
RECSET          endp

; ---------------------------------------------------------------------------

$CHAR_OPER:                             ; ...
                or      al, al          ; get switch?
                mov     dl, '/'         ; assume yes
                jz      short chop_1    ; jump if yes
                cmp     al, 2           ; check device availability?
                mov     dl, 0FFh        ; -1 ; assume yes
                jz      short chop_1    ; jump if yes
                retn                    ; otherwise just quit
; ---------------------------------------------------------------------------

chop_1:                                 ; ...
                call    Get_User_Stack
                mov     [si+6], dx      ; [SI+user_env.user_DX]
                                        ; store value for user
                retn
; ---------------------------------------------------------------------------

$GetExtendedError:                      ; ...
                push    ss
                pop     ds
                mov     ax, EXTERR
                les     di, EXTERRPT
                assume es:nothing
                mov     bx, word ptr EXTERR_ACTION ; BL = Action, BH = Class
                mov     ch, EXTERR_LOCUS
                call    Get_User_Stack
                mov     [si+0Ah], di    ; [SI+user_env.user_DI]
                call    set_user_es_bx
                mov     [si+4], cx      ; [SI+user_env.user_CX]

_jmp_to_SYS_RET_OK:                     ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

$ECS_Call:                              ; ...
                or      al, al
                jnz     short _okok
                call    Get_User_Stack
                mov     word ptr [si+8], offset DBCS_TAB_2 ; [SI+user_env.user_SI],
                                        ; DBCS_TAB+2
                push    es
                mov     es, cs:DosDSeg
                mov     word ptr [si+14], es ; [SI+user_env.user_DS]
                pop     es

_okok:                                  ; ...
                jmp     short _jmp_to_SYS_RET_OK
; ---------------------------------------------------------------------------

$LONGNAME:                              ; ...
                xor     al, al          ; longname functions are not supported

lfn_error:                              ; ...
                call    Get_User_Stack
                or      word ptr [si+16h], 1 ; [SI+user_env.user_F],f_Carry
                stc
                mov     [si], ax        ; [SI+user_env.user_ax]
                retn
; ---------------------------------------------------------------------------

$FAT32EXT:                              ; ...
                cmp     al, 5           ; INT 21h AX = 7305h
                jbe     short valid_fat32_ext_function
                mov     al, 1           ; error_invalid_function

fat32_ext_func_err:                     ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

function_5_invalid_cx:                  ; ...
                mov     al, 57h         ; error_invalid_parameter

fat32_ext_func_err_j:                   ; ...
                jmp     short fat32_ext_func_err
; ---------------------------------------------------------------------------

valid_fat32_ext_function:               ; ...
                jnz     short not_function_5
                cmp     cx, 0FFFFh      ; Function 5 - FAT32 - EXTENDED ABSOLUTE DISK READ/WRITE
                jnz     short function_5_invalid_cx
                test    si, 9FFEh       ; read/write mode flags
                jnz     short function_5_invalid_cx
                mov     al, dl          ; drive number, 1 = A
                dec     al
                mov     ah, 1
                test    si, 1
                jz      short function_5_read
                call    near ptr FAT32_ABSDWRT ; INT 21h AX = 7305h (SI bit 0 = 1)
                jmp     short fat32_absdrw_ret
; ---------------------------------------------------------------------------

function_5_read:                        ; ...
                call    FAT32_ABSDRD    ; INT 21h AX = 7305h (SI bit 0 = 0)

fat32_absdrw_ret:                       ; ...
                jb      short lfn_error
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

not_function_5:                         ; ...
                cmp     al, 3
                jz      short function_73_3 ; Function 3 - FAT32 - GET EXTENDED FREE SPACE ON DRIVE
                cmp     al, 2
                jb      short chk_drive_lock_flush
                jmp     $GET_DPB        ; Function 2 - FAT32 - "Get_ExtDPB" - GET EXTENDED DPB
                                        ; Function 4 - FAT32 - Set DPB TO USE FOR FORMATTING
; ---------------------------------------------------------------------------

chk_drive_lock_flush:                   ; ...
                cmp     dl, 26          ; MSDOS 7 - DRIVE LOCKING AND FLUSHING
                jbe     short drv_lock_flush_1
                mov     al, 0Fh         ; invalid drive number

drv_lock_flush_err:                     ; ...
                jmp     short fat32_ext_func_err_j ; ax = error code
; ---------------------------------------------------------------------------

drv_lock_flush_1:                       ; ...
                dec     dl
                jns     short drv_lock_flush_2
                mov     dl, ss:CURDRV   ; 0 = default/current drive)

drv_lock_flush_2:                       ; ...
                mov     dh, 0
                mov     bx, dx
                cmp     cl, 1           ; which flag to get or set
                jbe     short drv_lock_flush_3
                mov     al, 1           ; error_invalid_function
                jmp     short drv_lock_flush_err
; ---------------------------------------------------------------------------

drv_lock_flush_3:                       ; ...
                mov     ah, ss:drive_flags[bx]
                or      cl, cl
                jz      short get_set_indctd_flag ; use bit 1 and bit 2
                or      al, al          ; get drive's dirty-buffers flag
                jz      short get_dirty_buf_flag ; use bit 3
                and     ah, 0F7h        ; clear bit 3
                and     ch, 8           ; izolate bit 3 of the new flag value
                or      ah, ch          ; set AH bit 3 according to CH bit 3
                mov     ss:drive_flags[bx], ah ; set or reset dirty buffer flag
                test    ah, 8
                jnz     short set_dirty_flag_ok ; bit 3 is set/1
                mov     al, 0FFh
                call    FLUSHBUF

set_dirty_flag_ok:                      ; ...
                jmp     short jmp_to_SYS_RET_OK
; ---------------------------------------------------------------------------

get_dirty_buf_flag:                     ; ...
                and     ah, 8           ; izolate dirty buffers flag
                jmp     short mov_flag_cl_to_al ; AH = new flag and 08h (bit 3 used)
; ---------------------------------------------------------------------------

get_set_indctd_flag:                    ; ...
                or      al, al
                jz      short get_indicated_flag
                and     ah, 0F9h        ; clear bit 1 and bit 2
                test    ch, 2           ; new value for indicated flag
                jz      short reset_indctd_flags ; bit 1 is zero
                or      ah, 6           ; set bit 1 and bit 2

reset_indctd_flags:                     ; ...
                mov     ss:drive_flags[bx], ah
                jmp     short jmp_to_SYS_RET_OK
; ---------------------------------------------------------------------------

get_indicated_flag:                     ; ...
                and     ah, 6           ; AH = new flag and 06h (bits 1 and 2 used)

mov_flag_cl_to_al:                      ; ...
                mov     al, cl          ; value of CL on entry

ret_ax_to_user_cx:                      ; ...
                call    Get_User_Stack
                mov     [si+4], ax      ; [SI+user_env.user_cx] ; requested flag

jmp_to_SYS_RET_OK:                      ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

function_73_3:                          ; ...
                mov     si, dx          ; FAT32 - GET EXTENDED FREE SPACE ON DRIVE
                                        ; AX = 7303h
                                        ; DS:DX -> ASCIZ string for drive ("C:\" or "\\SERVER\Share")
                                        ; ES:DI -> buffer for extended free space structure
                                        ; CX = length of buffer for extended free space
                call    DriveFromText
                xchg    ax, dx
                lodsw
                dec     dl
                cmp     dl, 26
                jnb     short func_73_3_err2
                or      ah, ah
                jnz     short func_73_3_err2
                call    PATHCHRCMP
                jnz     short func_73_3_err2
                inc     dl
                cmp     cx, 44          ; buffer (Structure) size must be 44
                jb      short func_73_3_err4
                cmp     word ptr es:[di+2], 0 ; buffer structure version (must be 0)
                jnz     short func_73_3_err3
                push    ss
                pop     ds
                mov     al, dl
                call    GETTHISDRV
                jnb     short fill_efs_struc_b

func_73_3_err1:                         ; ...
                call    FCB_RET_ERR

func_73_3_err2:                         ; ...
                mov     al, 0Fh         ; error_invalid_drive

jmp_to_SYS_RET_ERR:                     ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

func_73_3_err3:                         ; ...
                mov     al, 57h         ; error_invalid_parameter

jmp_to_jmp_SYS_RET_ERR:                 ; ...
                jmp     short jmp_to_SYS_RET_ERR
; ---------------------------------------------------------------------------

func_73_3_err4:                         ; ...
                mov     al, 18h         ; error_bad_length
                jmp     short jmp_to_jmp_SYS_RET_ERR
; ---------------------------------------------------------------------------

fill_efs_struc_b:                       ; ...
                call    DISK_INFO
                jb      short func_73_3_err1
                xor     ah, ah
                push    si              ; si:dx = free cluster count
                push    di              ; di:bx = number of clusters
                call    Get_User_Stack
                mov     es, word ptr [si+10h] ; user's buffer segment (in ES)
                mov     di, [si+0Ah]    ; user's buffer offset/address (in DI)
                mov     es:[di+10h], bx ; total number of clusters on the drive
                mov     es:[di+20h], bx ; total allocation units, without adjustment for compression
                pop     bx
                mov     es:[di+12h], bx ; total number of clusters on the drive, hw
                mov     es:[di+22h], bx ; total allocation units, hw
                mov     es:[di+0Ch], dx ; number of available clusters
                mov     es:[di+1Ch], dx ; number of available allocation units, without adjustment
                pop     dx
                mov     es:[di+0Eh], dx ; number of available clusters, hw
                mov     es:[di+1Eh], dx ; number of available allocation units, hw
                mov     es:[di+8], cx   ; bytes per sector
                mov     es:[di+4], ax   ; sectors per cluster (with adjustment for compression)
                mov     cx, ax
                mul     bx              ; 32 bit multiplication
                jb      short dsk_cap_calc_overf ; disk capacity calculation overflow error
                mov     bx, ax
                mov     ax, es:[di+20h] ; total allocation units, lw
                mul     cx
                add     dx, bx
                jnb     short dsk_cap_calc_ok

dsk_cap_calc_overf:                     ; ...
                mov     ax, 0FFFFh      ; set to 0FFFFFFFFh
                mov     dx, ax

dsk_cap_calc_ok:                        ; ...
                mov     es:[di+1Ah], dx
                mov     es:[di+18h], ax ; total number of physical sectors on the drive,
                                        ; without adjustment for compression
                mov     ax, cx          ; 32 bit multiplication
                mul     word ptr es:[di+0Eh] ; number of available clusters, hw
                jb      short dsk_free_calc_overf
                mov     bx, ax
                mov     ax, es:[di+0Ch] ; number of available clusters, lw
                mul     cx
                add     dx, bx
                jnb     short dsk_free_calc_ok

dsk_free_calc_overf:                    ; ...
                mov     ax, 0FFFFh
                mov     dx, ax

dsk_free_calc_ok:                       ; ...
                mov     es:[di+16h], dx ; hw
                mov     es:[di+14h], ax ; number of physical sectors available on the drive,
                                        ; without adjustment for compression
                xor     ax, ax          ; 0
                mov     es:[di+0Ah], ax ; number of bytes per sector, high word = 0
                mov     es:[di+6], ax   ; number of sectors per cluster, high word = 0
                mov     es:[di+24h], ax ; reserved, 8 bytes zero
                mov     es:[di+26h], ax
                mov     es:[di+28h], ax
                mov     es:[di+2Ah], ax
                mov     ax, 44
                mov     es:[di], ax     ; size of returned structure = 44
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

Set_DPBforFormat:                       ; ...
                cmp     word ptr [si+4], 24 ; [SI+user_env.user_CX]
                                        ; size of buffer (must be at least 18h)
                jnb     short setdpbf_2
                mov     al, 18h         ; error_bad_length

setdpbf_1:                              ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

setdpbf_2:                              ; ...
                push    es              ; ES:BP = Drive parameter block
                push    bp
                mov     es, word ptr [si+10h] ; [SI+user_env.user_ES]
                mov     di, [si+0Ah]    ; [SI+user_env.user_DI]
                pop     si
                pop     ds
                assume ds:nothing
                mov     ax, es:[di+4]   ; (call) function number
                cmp     word ptr es:[di+2], 0 ; structure version (must be 0)
                jnz     short setdpbf_3
                cmp     word ptr es:[di+6], 0 ; (must be 0)
                jnz     short setdpbf_3
                cmp     ax, 4           ; (max) 5 functions (0 to 4)
                jbe     short setdpbf_4

setdpbf_3:                              ; ...
                mov     al, 57h         ; error_invalid_parameter
                jmp     short setdpbf_1
; ---------------------------------------------------------------------------

setdpbf_4:                              ; ...
                mov     word ptr es:[di], 18h ; (call) size
                or      al, al
                jz      short setdpbf_5 ; invalidate DPB counts
                jmp     setdpbf_18
; ---------------------------------------------------------------------------

setdpbf_5:                              ; ...
                xor     dx, dx          ; 0
                mov     bx, [si+0Dh]    ; DPB.MAX_CLUSTER
                cmp     word ptr [si+0Fh], 0 ; DPB.FAT_SIZE
                jnz     short setdpbf_6 ; not FAT32
                mov     dx, [si+2Fh]
                mov     bx, [si+2Dh]    ; DPB.LAST_CLUSTER

setdpbf_6:                              ; ...
                mov     ax, es:[di+0Ah]
                mov     cx, es:[di+8]   ; new DPB free count
                                        ; (00000000h=no change, FFFFFFFFh=unknown)
                or      ax, ax
                jnz     short setdpbf_7
                jcxz    short setdpbf_11

setdpbf_7:                              ; ...
                cmp     ax, 0FFFFh
                jnz     short setdpbf_8
                cmp     cx, 0FFFFh
                jz      short setdpbf_10 ; (set as UNKNOWN/INITIAL)

setdpbf_8:                              ; ...
                cmp     ax, dx          ; must be < DPB.LAST_CLUSTER
                jnz     short setdpbf_9
                cmp     cx, bx

setdpbf_9:                              ; ...
                jnb     short setdpbf_3

setdpbf_10:                             ; ...
                or      byte ptr [si+18h], 1 ; DPB.FIRST_ACCESS (bit 0 = 1)
                mov     [si+1Fh], cx    ; DPB.FREE_CNT
                cmp     word ptr [si+0Fh], 0 ; DP.FAT_SIZE
                jnz     short setdpbf_11 ; FAT12 or FAT16
                mov     [si+21h], ax    ; DPB.FREE_CNT_HW

setdpbf_11:                             ; ...
                mov     ax, es:[di+0Eh]
                mov     cx, es:[di+0Ch] ; new DPB next-free
                                        ; (00000000h=no change, FFFFFFFFh=unknown)
                or      ax, ax
                jnz     short setdpbf_12
                jcxz    short setdpbf_17

setdpbf_12:                             ; ...
                cmp     ax, 0FFFFh
                jnz     short setdpbf_13
                cmp     cx, 0FFFFh
                jz      short setdpbf_16 ; (set as UNKNOWN/INITIAL)

setdpbf_13:                             ; ...
                cmp     ax, 0           ; must be >= 2
                jnz     short setdpbf_14
                cmp     cx, 2

setdpbf_14:                             ; ...
                jb      short setdpbf_3
                cmp     ax, dx          ; must be < DPB.LAST_CLUSTER
                jnz     short setdpbf_15
                cmp     cx, bx

setdpbf_15:                             ; ...
                ja      short setdpbf_3

setdpbf_16:                             ; ...
                or      byte ptr [si+18h], 1 ; DPB.FIRST_ACCESS (bit 0 = 1)
                mov     [si+1Dh], cx    ; DPB.NEXT_FREE
                cmp     word ptr [si+0Fh], 0 ; DPB.FAT_SIZE
                jnz     short setdpbf_17 ; FAT16 or FAT12
                mov     [si+3Bh], ax
                mov     [si+39h], cx    ; DPB.FAT32_NXTFREE

setdpbf_17:                             ; ...
                mov     ax, 7304h       ; done (successful)
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

setdpbf_18:                             ; ...
                dec     al
                jnz     short setdpbf_19
                push    ds              ; rebuild DPB from BPB
                push    si
                lds     si, es:[di+8]   ; BIOS Parameter Block
                pop     bp
                pop     es
                mov     cx, 4558h       ; 'XE' (NASM syntax)
                mov     dx, 4152h       ; 'RA' (NASM syntax)
                call    $SETDPB
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

setdpbf_19:                             ; ...
                dec     al
                jnz     short setdpbf_20 ;
                                        ; force media change
                                        ; (next access to drive rebuild DPB)
                or      byte ptr [si+18h], 80h ; DPB.FIRST_ACCESS (bit 7 = 1)
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

setdpbf_20:                             ; ...
                cmp     word ptr [si+0Fh], 0 ; DPB.FAT_SIZE
                jz      short setdpbf_22 ; FAT32
                mov     al, 0Fh         ; error_invalid_drive
                                        ; (function 3 or 4 are only for drives with FAT32 fs)

setdpbf_21:                             ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

setdpbf_22:                             ; ...
                dec     al
                jz      short setdpbf_30 ; get/set active FAT number and mirroring
                mov     ax, [si+35h]    ; get/set root directory cluster number
                                        ; DPB.ROOT_CLUSTER
                mov     es:[di+0Ch], ax ; (ret) previous root directory cluster number
                mov     ax, [si+37h]
                mov     es:[di+0Eh], ax
                mov     cx, es:[di+0Ah]
                mov     ax, es:[di+8]   ; (call) new root directory cluster number
                cmp     ax, 0FFFFh      ; -1 --> return only previous root dir cluster number
                jnz     short setdpbf_23
                cmp     cx, 0FFFFh
                jz      short setdpbf_29

setdpbf_23:                             ; ...
                cmp     cx, 0           ; cluster number must be >= 2
                jnz     short setdpbf_24
                cmp     ax, 2

setdpbf_24:                             ; ...
                jnb     short setdpbf_26

setdpbf_25:                             ; ...
                jmp     setdpbf_3       ; error (invalid parameter)
; ---------------------------------------------------------------------------

setdpbf_26:                             ; ...
                cmp     cx, [si+2Fh]    ; must be <= DPB.LAST_CLUSTER
                jnz     short setdpbf_27
                cmp     ax, [si+2Dh]

setdpbf_27:                             ; ...
                ja      short setdpbf_25 ; error
                mov     [si+37h], cx    ; DPB.ROOT_CLUSTER
                mov     [si+35h], ax
                or      byte ptr [si+18h], 2 ; DPB.FIRST_ACCESS (bit 1 = 1)
                push    ds
                push    si
                pop     bp
                pop     es
                call    ECritDisk
                call    update_fat32_fsinfo
                call    LCritDisk
                jnb     short setdpbf_29
                mov     al, 1Fh         ; error_gen_failure

setdpbf_28:                             ; ...
                jmp     short setdpbf_21
; ---------------------------------------------------------------------------

setdpbf_29:                             ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

setdpbf_30:                             ; ...
                and     word ptr [si+23h], 8Fh ; DPB.EXT_FLAGS (clear bit 4-6)
                mov     cx, [si+23h]
                mov     es:[di+0Ch], cx ; (ret) previous active FAT/mirroring state
                mov     word ptr es:[di+0Eh], 0 ;
                                        ; put zero to Set_DPBforFormat struc offset 14
                mov     dx, es:[di+8]   ; (call) new active FAT/mirroring state,
                                        ;  or FFFFFFFFh to get
                cmp     dx, 0FFFFh
                jnz     short setdpbf_31
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

setdpbf_31:                             ; ...
                test    dx, 0FF70h
                jz      short setdpbf_33 ; bit 4-6 of DBP.EXT_FLAGS must be 0
                mov     al, 57h         ; error_invalid_parameter

setdpbf_32:                             ; ...
                jmp     short setdpbf_28
; ---------------------------------------------------------------------------

setdpbf_33:                             ; ...
                mov     al, 1           ; error_invalid_function
                                        ; (modification is not allowed)
                jmp     short setdpbf_32
; ---------------------------------------------------------------------------

$PARSE_FILE_DESCRIPTOR:                 ; ...
                call    MAKEFCB
                push    si
                call    Get_User_Stack
                pop     word ptr [si+8] ; [SI+user_env.user_SI]
                retn

; =============== S U B R O U T I N E =======================================


set_exerr_locus_unk proc near           ; ...
                push    ax
                mov     al, 1           ; errLOC_Unk

set_exerr_locus:                        ; ...
                mov     ss:EXTERR_LOCUS, al
                pop     ax
                retn
set_exerr_locus_unk endp


; =============== S U B R O U T I N E =======================================


set_exerr_locus_disk proc near          ; ...
                push    ax
                mov     al, 2           ; errLOC_Disk
                jmp     short set_exerr_locus
set_exerr_locus_disk endp


; =============== S U B R O U T I N E =======================================


set_exerr_locus_ser proc near           ; ...
                push    ax
                mov     al, 4           ; errLOC_SerDev
                jmp     short set_exerr_locus
set_exerr_locus_ser endp


; =============== S U B R O U T I N E =======================================


set_exerr_locus_mem proc near           ; ...
                push    ax
                mov     al, 5           ; errLOC_Mem
                jmp     short set_exerr_locus
set_exerr_locus_mem endp

; ---------------------------------------------------------------------------

$SLEAZEFUNC:                            ; ...
                mov     dl, 0           ; default drive

$SLEAZEFUNCDL:                          ; ...
                push    ss
                pop     ds
                assume ds:DOSCODE
                mov     al, dl
                call    GETTHISDRV      ; Get CDS structure
                jb      short BADSLDRIVE
                call    DISK_INFO
                jb      short BADSLDRIVE
                mov     byte ptr FATBYTE, ah ; FAT (MEDIA) ID byte
                xor     ah, ah          ; AH = 0
                                        ; AL = sectors per cluster
                push    di              ; di:bx = number of clusters
                call    TestNet
                pop     di
                jb      short sleazefunc1
                push    cx              ; bytes per sector
                call    modify_cluster_count
                pop     cx              ; ax = sectors per cluster (modified)
                                        ; dx = number of clusters (modified)
                                        ; if bytes per cluster > 16384
                                        ;    bx = 0FFFEh (invalidated parms sign)

sleazefunc1:                            ; ...
                mov     di, offset FATBYTE
                call    Get_User_Stack
                mov     [si+4], cx      ; [SI+user_env.user_CX]
                mov     [si+6], bx      ; [SI+user_env.user_DX]
                mov     [si+2], di      ; [SI+user_env.user_BX]
                mov     word ptr [si+0Eh], ss ; [SI+user_env.user_DS]
                                        ; stash correct pointer
                retn
; ---------------------------------------------------------------------------

BADSLDRIVE:                             ; ...
                jmp     FCB_RET_ERR     ; error
; ---------------------------------------------------------------------------

$GET_INDOS_FLAG:                        ; ...
                call    Get_User_Stack
                mov     word ptr [si+2], offset INDOS ; [SI+user_env.user_BX]

getin_segm:                             ; ...
                mov     word ptr [si+10h], ss ; [SI+user_env.user_ES]
                retn
; ---------------------------------------------------------------------------

$GET_IN_VARS:                           ; ...
                call    Get_User_Stack  ; Return Pointer to DOS Variables
                mov     word ptr [si+2], offset DPBHEAD ; [SI+user_env.user_BX],
                                        ; SYSINITVARS
                jmp     short getin_segm
; ---------------------------------------------------------------------------

$GET_DEFAULT_DPB:                       ; ...
                mov     dl, 0

$GET_DPB:                               ; ...
                push    ss
                pop     ds
                mov     al, dl
                call    GETTHISDRV      ; Get CDS structure
                mov     al, 0Fh         ; error_invalid_drive
                jnb     short getdpb_3

getdpb_1:                               ; ...
                call    Get_User_Stack
                cmp     word ptr [si], 7302h ; INT 21h, AX = 7302h ? Get_ExtDPB
                                        ; GET EXTENDED DPB
                jz      short getdpb_2
                cmp     word ptr [si], 7304h ; INT 21h, AX = 7304h ? Set_DPBforFormat
                                        ; Set DPB TO USE FOR FORMATTING
                jnz     short ISNODRV

getdpb_2:                               ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

ISNODRV:                                ; ...
                mov     al, 0FFh        ; -1 ; invalid (or network) drive
                retn
; ---------------------------------------------------------------------------

getdpb_3:                               ; ...
                les     di, THISCDS
                test    byte ptr es:[di+44h], 80h ; [ES:DI+curdir.flags+1],
                                        ; (curdir_isnet>>8)
                jnz     short getdpb_1
                call    ECritDisk
                call    FATREAD_CDS
                call    LCritDisk
                mov     al, 53h         ; error_FAIL_I24
                jb      short getdpb_1
                call    Get_User_Stack
                cmp     word ptr [si], 7304h ; INT 21h, AX = 7304h ?
                jnz     short getdpb_4
                jmp     Set_DPBforFormat
; ---------------------------------------------------------------------------

getdpb_4:                               ; ...
                cmp     word ptr [si], 7302h ; INT 21h, AX = 7302h ?
                jz      short getdpb_5
                cmp     word ptr es:[bp+0Fh], 0
                jz      short getdpb_1
                mov     [si+2], bp
                mov     word ptr [si+0Eh], es
                xor     al, al          ; status = 0 = successful
                retn
; ---------------------------------------------------------------------------

getdpb_5:                               ; ...
                mov     al, 18h         ; error_bad_length
                cmp     word ptr [si+4], 63 ; [SI+user_env.user_CX]
                                        ; length of buffer (must be 63 bytes)
                jb      short getdpb_2  ; error
                push    es              ; ES:BP = Drive parameter block
                push    bp
                mov     es, word ptr [si+16] ; [SI+user_env.user_ES]
                mov     di, [si+10]     ; [SI+user_env.user_DI]
                mov     bx, [si+8]      ; [SI+user_env.user_SI] (!)
                pop     si
                pop     ds
                assume ds:nothing
                mov     ax, 61          ; length of following data (003Dh)
                stosw
                mov     cx, ax
                push    di
                rep movsb
                pop     di
                cmp     bx, 0F1A6h      ; (!) signature (undocumented),
                                        ;  must be 0F1A6h to get device driver
                                        ;  address and next-DBP pointer
                                        ; (Ref: Ralf Brown's Interrupt List)
                jz      short getdpb_6
                xor     ax, ax          ; 0
                dec     ax              ; -1
                mov     es:[di+19h], ax ; pointer to next DPB (invalidated)
                mov     es:[di+1Bh], ax
                mov     es:[di+13h], ax ; pointer to driver address (invalidated)
                mov     es:[di+15h], ax

getdpb_6:                               ; ...
                cmp     word ptr es:[di+0Fh], 0 ; FAT (16 bit) size ?
                jz      short getdpb_8  ; FAT32
                                        ; FAT16 or FAT12
                mov     ax, es:[di+0Dh] ; DPB.MAX_CLUSTER
                mov     es:[di+2Dh], ax ; DPB.LAST_CLUSTER
                mov     ax, es:[di+0Fh] ; DPB.FAT_SIZE
                mov     es:[di+31h], ax ; DPB.FAT32_SIZE
                mov     ax, es:[di+1Dh] ; DPB.NEXT_FREE
                mov     es:[di+39h], ax ; DPB.FAT32_NXTFREE
                mov     ax, es:[di+0Bh] ; DPB.FIRST_SECTOR
                mov     es:[di+29h], ax ; DPB.FCLUS_FSECTOR
                xor     ax, ax          ; 0
                mov     es:[di+2Fh], ax ; DPB.LAST_CLUSTER high word
                mov     es:[di+33h], ax ; DPB.FAT32_SIZE high word
                mov     es:[di+3Bh], ax ; DPB.FAT32_NXTFREE high word
                mov     es:[di+2Bh], ax ; DPB.FCLUS_FSECTOR high word
                mov     es:[di+35h], ax ; DPB.ROOT_CLUSTER
                mov     es:[di+37h], ax ; DPB.ROOT_CLUSTER high word
                mov     es:[di+23h], ax ; DPB.EXT_FLAGS
                dec     ax              ; -1
                mov     es:[di+25h], ax ; DPB.FSINFO_SECTOR (invalidated)
                mov     es:[di+27h], ax ; DPB.BKBOOT_SECTOR (invalidated)
                cmp     ax, es:[di+1Fh] ; DPB.FREE_COUNT (= -1 ?)
                jz      short getdpb_7
                inc     ax              ; -1 -> 0

getdpb_7:                               ; ...
                mov     es:[di+21h], ax ; DPB.PB.FREE_COUNT high word

getdpb_8:                               ; ...
                xor     ax, ax          ; status = 0 = successful
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

$DISK_RESET:                            ; ...
                mov     al, 0FFh        ; -1
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    ECritDisk
                or      byte ptr DOS34_FLAG, 4 ; FROM_DISK_RESET
                call    FLUSHBUF
                and     byte ptr DOS34_FLAG, 0FBh ; NO_FROM_DISK_RESET
                les     bp, DPBHEAD

drst_1:                                 ; ...
                cmp     bp, 0FFFFh      ; -1 ?
                jz      short drst_2    ; yes, it is the last DPB
                call    update_fat32_fsinfo ; update FSINFO (sector) parameters
                les     bp, es:[bp+19h] ; DPB.NEXT_DPB
                jmp     short drst_1
; ---------------------------------------------------------------------------

drst_2:                                 ; ...
                mov     SC_STATUS, 0    ; Throw out secondary cache
                mov     bx, 0FFFFh      ; -1
                mov     word ptr LastBuffer+2, bx ; Invalidate 'last-buffer' used
                mov     word ptr LastBuffer, bx
                call    LCritDisk
                mov     ax, 0FFFFh
                push    ax
                mov     ax, 1120h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
                                        ; DS = DOS CS
                                        ; Return: CF clear (successful)
                pop     ax
                retn
; ---------------------------------------------------------------------------
word3           dw 3                    ; ...

; =============== S U B R O U T I N E =======================================


$SETDPB         proc near               ; ...
                mov     di, bp          ; Buffer address (es:bp)
                inc     di              ; Skip over dpb_drive and dpb_UNIT
                inc     di
                lodsw                   ; dpb_sector_size ; bytes per sector
                stosw                   ; .BPB_BYTESPERSECTOR
                cmp     cx, 4558h       ; 'XE' (NASM syntax)
                                        ; CX = signature 4558h ('EX') for FAT32 extended BPB/DPB
                jnz     short not_fat32_extension
                cmp     dx, 4152h       ; 'RA' (NASM syntax)
                                        ; DX = signature 4152h ('AR') for FAT32 extended BPB/DPB
                jz      short chk_fat32_conditions

not_fat32_extension:                    ; ...
                xor     cx, cx          ; 0 ; (Do not use FAT32 extensions -32 bit parameters-)

chk_fat32_conditions:                   ; ...
                push    cx              ; (*)
                cmp     byte ptr [si+3], 0 ; .BPB_NUMBEROFFATS
                jz      short nofat
                cmp     word ptr [si+9], 0 ; .BPB_SECTORSPERFAT ; BPB_FATSz16
                jnz     short yesfat
                cmp     word ptr [si+29], 0 ; .BPB_FAT32VERSION ; BPB_FSVer
                jz      short yesfat

nofat:                                  ; ...
                xor     ax, ax
                mov     es:[di+4], al   ; DPB.FAT_COUNT = 0
                add     di, 15          ; DPB.DRIVER_ADDR
                add     si, 11          ; .BPB_SECTORSPERTRACK
                mov     es:[bp+15], ax  ; DPB.FAT_SIZE = 0
                jmp     setend
; ---------------------------------------------------------------------------

yesfat:                                 ; ...
                mov     dx, ax          ; bytes per sector
                lodsb                   ; .BPB_SECTORSPERCLUSTER
                xor     ah, ah
                or      ax, ax
                jz      short nofat
                dec     al
                stosb                   ; DPB.CLUSTER_MASK ; Sectors/cluster - 1
                inc     al

LOG2LOOP:                               ; ...
                test    al, 1
                jnz     short SAVLOG
                inc     ah
                shr     al, 1
                jmp     short LOG2LOOP
; ---------------------------------------------------------------------------

SAVLOG:                                 ; ...
                mov     al, ah
                stosb                   ; DPB.CLUSTER_SHIFT ; Log2 of sectors/cluster
                mov     bl, al
                movsw                   ; .BPB_RESERVEDSECTORS -> DPB.FIRST_FAT
                lodsb                   ; .BPB_NUMBEROFFATS
                stosb                   ; DPB.FAT_COUNT
                mov     bh, al
                lodsw                   ; .BPB_ROOTENTRIES
                stosw                   ; DPB.ROOT_ENTRIES
                mov     cl, 5
                shr     dx, cl          ; Directory entries per sector
                dec     ax
                add     ax, dx          ; Round Up
                mov     cx, dx
                xor     dx, dx
                div     cx
                mov     cx, ax          ; Number of root directory sectors
                inc     di
                inc     di
                movsw                   ; .BPB_TOTALSECTORS -> DPB.MAX_CLUSTER (temporary)
                lodsb                   ; .BPB_MEDIADESCRIPTOR
                mov     es:[bp+23], al  ; DPB.MEDIA
                lodsw                   ; .BPB_SECTORSPERFAT
                stosw                   ; DPB.FAT_SIZE
                xor     dx, dx
                or      ax, ax
                jnz     short savlog1   ; 16 bit FAT size
                pop     dx              ; (*) FAT32 extensions
                                        ; (use 32 bit FAT and Root Dir size if >0)
                push    dx              ; (*)
                or      dx, dx
                jz      short savlog1   ; Do not use FAT32 extensions
                                        ; (do not use 32 bit FAT size field)
                mov     ax, [si+12]     ; .BPB_SECTORSPERFAT32 ; BPB_FATSz32
                mov     dx, [si+14]     ; .BPB_SECTORSPERFAT32+2

savlog1:                                ; ...
                push    cx              ; (**) Root directory sectors
                mov     cx, ax          ; 32 bit multiply
                mov     al, bh          ; FAT count
                xor     ah, ah
                mul     dx
                xchg    ax, cx
                mov     dl, bh          ; FAT count
                xor     dh, dh
                mul     dx
                add     dx, cx
                pop     cx              ; (**)
                cmp     ax, dx
                jnz     short savlog2
                or      ax, ax
                jnz     short savlog2
                inc     di
                inc     di
                jmp     short setend
; ---------------------------------------------------------------------------

savlog2:                                ; ...
                add     ax, es:[bp+6]   ; dx:ax = (total) FAT sectors
                                        ; add ax,[es:bp+DPB.FIRST_FAT]
                adc     dx, 0
                stosw                   ; DPB.DIR_SECTOR
                add     ax, cx          ; + root directory size
                mov     es:[bp+11], ax  ; DPB.FIRST_SECTOR ; First data sector
                adc     dx, 0
                pop     cx              ; (*)
                push    cx
                jcxz    short savlog3
                mov     es:[bp+41], ax  ; DPB.BIG_FIRST_SECTOR ; FAT32 first sector field
                mov     es:[bp+43], dx

savlog3:                                ; ...
                mov     cl, bl          ; cluster shift
                cmp     word ptr es:[bp+13], 0 ; DPB.MAX_CLUSTER
                                        ; (contains 16 bit .BPB_TOTALSECTORS as temporary)
                jnz     short normal_dpb
                xor     ch, ch
                push    dx
                mov     bx, [si+8]      ; SI points to .BPB_SECTORSPERTRACK and SI+8 is
                                        ; .BPB_BIGTOTALSECTORS (32 bit total sectors)
                mov     dx, [si+10]
                sub     bx, ax
                pop     ax
                sbb     dx, ax          ; dx:bx = data sectors (for cluster count calc)
                or      cx, cx
                jz      short norot

rott:                                   ; ...
                clc
                rcr     dx, 1
                rcr     bx, 1
                loop    rott

norot:                                  ; ...
                mov     ax, bx          ; dx:ax = cluster count
                jmp     short setend
; ---------------------------------------------------------------------------

normal_dpb:                             ; ...
                sub     ax, es:[bp+13]  ; first sector - total sectors
                xor     dx, dx
                neg     ax              ; data sectors = total sectors - first sector
                shr     ax, cl          ; cluster count

setend:                                 ; ...
                pop     cx              ; (*) 0 = not 32 bit fat sectors
                push    cx              ; (*)
                add     ax, 1
                adc     dx, 0           ; calculated # clusters HW
                mov     bx, ax          ; calculated # clusters LW
                mov     ax, es:[bp+15]  ; FAT size (16 bit)
                jcxz    short setend1   ; Do not use 32 bit FAT sectors field
                xor     cx, cx
                or      ax, ax
                jnz     short setend1
                mov     ax, [si+12]     ; .BPB_SECTORSPERFAT32  ; 32 bit FAT size field.
                mov     cx, [si+14]     ; .BPB_SECTORSPERFAT32+2

setend1:                                ; ...
                push    dx              ; cx:ax = FAT size (in sectors)
                                        ; dx:bx = calculated number of clusters
                xchg    ax, cx
                mul     word ptr es:[bp+2] ; DPB.SECTOR_SIZE
                xchg    ax, cx
                mul     word ptr es:[bp+2]
                add     dx, cx          ; dx:ax = FAT size in bytes
                pop     cx              ; calculated # clusters HW
                or      cx, cx
                jnz     short setend2   ; FAT32
                cmp     bx, 0FF6h
                jb      short setend_fat12 ; FAT12

setend2:                                ; ...
                or      cx, cx          ; HW of calculated cluster count
                jnz     short setend3
                cmp     bx, 0FFF6h
                jb      short setend4   ; FAT16

setend3:                                ; ...
                shr     dx, 1           ; FAT32 ; 4 byte (32 bit) cluster number
                                        ; fatsiz/4 = # of fat entries
                rcr     ax, 1
                shr     dx, 1
                jz      short setend5   ; dx = 0
                rcr     ax, 1
                jmp     short setend_fat16
; ---------------------------------------------------------------------------

setend4:                                ; ...
                shr     dx, 1           ; FAT16 ; 2 byte (16 bit) cluster number
                                        ; fatsiz/2 = # of fat entries
                jnz     short setend_faterr ; dx > 0

setend5:                                ; ...
                rcr     ax, 1           ; FAT16 ; 2 byte (16 bit) cluster number
                                        ; fatsiz/2 = # of fat entries
                cmp     ax, 0FF7h       ; 4096-10+1
                jb      short setend_faterr
                jmp     short setend_fat16
; ---------------------------------------------------------------------------

setend_fat12:                           ; ...
                add     ax, ax          ; FAT12 ; 1.5 byte (12 bit) cluster number
                                        ; (fatsiz*2)/3 = # of fat entries
                adc     dx, dx
                cmp     dx, 3           ; if our fatspace is more than we need
                                        ; use calculated size
                jnb     short setend_faterr
                div     cs:word3

setend_fat16:                           ; ...
                sub     ax, 1
                sbb     dx, 0
                cmp     dx, cx          ; is fat big enough?
                ja      short setend_faterr
                cmp     ax, bx
                jbe     short setend_fat32 ; use max value that'll fit

setend_faterr:                          ; ...
                mov     ax, bx          ; use calculated value
                mov     dx, cx

setend_fat32:                           ; ...
                cmp     word ptr es:[bp+15], 0 ; DPB.FAT_SIZE ; 16 bit FAT size
                jnz     short setend6
                mov     word ptr es:[bp+17], 0FFFFh ; DPB.DIR_SECTOR
                                        ; (16 bit directory sector field)
                mov     word ptr es:[bp+13], 0 ; DPB.MAX_CLUSTER (16 bit)
                jmp     short setend7
; ---------------------------------------------------------------------------

setend6:                                ; ...
                mov     es:[bp+13], ax  ; DPB.MAX_CLUSTER = calculated last cluster number

setend7:                                ; ...
                pop     cx              ; (*) 1 = use FAT32 extensions
                                        ;     0 = don't use FAT32 extensions (32 bit fields)
                jcxz    short setend_fat ; do not use FAT32 extensions
                mov     es:[bp+45], ax  ; DPB.MAX_CLUSTER32 ; dx:ax = last cluster number
                mov     es:[bp+47], dx
                mov     ax, 0FFFFh      ; -1
                lea     di, [bp+33]     ; DPB.FREE_CNT_HW
                                        ; High word of free cluster count
                stosw                   ; -1 ; 0FFFFh
                lea     si, [si+16]     ; FAT32 flags
                movsw                   ; DPB FAT32 flags ; [bp+23h]
                add     si, 6
                lodsw                   ; FSINFO structure sector number
                mov     dx, [si-24h]    ; .BPB_RESERVEDSECTORS ; Number of reserved sectors.
                or      ax, ax
                jz      short setend8
                cmp     ax, dx
                jb      short setend9

setend8:                                ; ...
                mov     ax, 0FFFFh      ; -1 ; invalid

setend9:                                ; ...
                stosw                   ; DPB FSINFO structure sector number
                                        ; [bp+25h]
                lodsw                   ; Sector number of the backup boot sector
                or      ax, ax
                jz      short setend10
                cmp     ax, dx
                jb      short setend11

setend10:                               ; ...
                mov     ax, 0FFFFh      ; -1 ; invalid

setend11:                               ; ...
                stosw                   ; DPB backup boot sector address
                                        ; [bp+27h]
                add     di, 8           ; [bp+31h]
                xor     dx, dx
                mov     ax, es:[di-34]  ; [bp+0Fh] ; DPB.MAX_CLUSTER
                cmp     ax, dx
                jnz     short setend12  ; > 0 (not FAT32)
                mov     ax, [si-16]     ; FAT32 Sectors per FAT ; .BPB_SECTORSPERFAT32
                mov     dx, [si-14]

setend12:                               ; ...
                stosw                   ; DPB FAT32 FAT size in sectors ; [bp+31h]
                mov     ax, dx
                stosw
                sub     si, 8           ; Root directory cluster number
                movsw                   ; DPB Root Dir Cluster ; [bp+35h]
                movsw
                xor     ax, ax          ; DPB reserved ; [bp+39h]
                stosw
                stosw

setend_fat:                             ; ...
                xor     ax, ax
                mov     es:[bp+29], ax  ; DPB.NEXT_FREE ; last allocated cluster #
                dec     ax
                mov     es:[bp+31], ax  ; DPB.FREE_CNT (-1 = unknown)
                retn
$SETDPB         endp


; =============== S U B R O U T I N E =======================================


$DUP_PDB        proc near               ; ...
                mov     ds, cs:DosDSeg
                assume ds:nothing
                mov     ds:CreatePDB, 0FFh ; indicate a new process
                mov     ds, ds:CurrentPDB
                push    si
                jmp     short CreateCopy
; ---------------------------------------------------------------------------

$CREATE_PROCESS_DATA_BLOCK:             ; ...
                call    Get_User_Stack
                mov     ds, word ptr [si+14h] ; [SI+user_env.user_CS]
                push    word ptr ds:2   ; [PDB.BLOCK_LEN]

CreateCopy:                             ; ...
                mov     es, dx
                xor     si, si          ; copy entire PDB
                mov     di, si
                mov     cx, 128
                rep movsw
                mov     cx, 20          ; FILPERPROC
                mov     di, 18h         ; PDB.JFN_TABLE
                push    ds
                lds     si, ds:34h      ; [PDB.JFN_Pointer]
                rep movsb
                pop     ds
                mov     ds, cs:DosDSeg
                cmp     ds:CreatePDB, 0
                jz      short Create_PDB_cont
                mov     ds, cs:DosDSeg
                xor     bx, bx
                mov     cx, 20

Create_dup_jfn:                         ; ...
                push    es
                call    SFFromHandle
                mov     al, 0FFh        ; unassigned JFN
                jb      short CreateStash
                test    byte ptr es:[di+6], 10h ; [ES:DI+SF_ENTRY.sf_flags+1],
                                        ; (sf_no_inherit>>8)
                jnz     short CreateStash ; if no-inherit bit is set, skip dup.
                mov     ah, es:[di+2]   ; [ES:DI+SF_ENTRY.sf_mode]
                and     ah, 0F0h        ; SHARING_MASK
                cmp     ah, 70h         ; SHARING_NET_FCB
                jz      short CreateStash
                mov     word ptr ds:THISSFT, di
                mov     word ptr ds:THISSFT+2, es
                call    DOS_DUP
                call    pJFNFromHandle
                mov     al, es:[di]

CreateStash:                            ; ...
                pop     es
                mov     es:[bx+18h], al ; [ES:BX+PDB.JFN_TABLE]
                inc     bx              ; next jfn
                loop    Create_dup_jfn
                mov     bx, ds:CurrentPDB ; get current process
                mov     es:16h, bx      ; [ES:PDB.PARENT_PID]
                mov     ds:CurrentPDB, es
                mov     ds, bx

Create_PDB_cont:                        ; ...
                push    ds
                mov     ds, cs:DosDSeg
                mov     ds:CreatePDB, 0
                pop     ds
                pop     ax
$DUP_PDB        endp


; =============== S U B R O U T I N E =======================================


SETMEM          proc near               ; ...
                xor     cx, cx
                mov     ds, cx
                assume ds:DOSCODE
                mov     es, dx
                mov     si, 88h         ; addr_int_terminate
                mov     di, 0Ah         ; SAVEXIT
                mov     cl, 6
                rep movsw
                mov     es:2, ax
                sub     ax, dx
                cmp     ax, 0FFFh       ; MAXDIF
                jbe     short HAVDIF
                mov     ax, 0FFFh       ; MAXDIF

HAVDIF:                                 ; ...
                sub     ax, 10h         ; Allow for 100h byte "stack" in .COM files
                mov     bx, 0Ch         ; ENTRYPOINTSEG
                sub     bx, ax
                mov     cl, 4
                shl     ax, cl
                mov     ds, dx
                assume ds:nothing
                mov     ds:6, ax        ; [PDB.CPM_CALL+1]
                mov     ds:8, bx        ; [PDB.CPM_CALL+3]
                cmp     ax, 0FEF0h      ; WRAPOFFSET
                jz      short addr_ok
                mov     word ptr ds:6, 0C0h ; [PDB.CPM_CALL+1],0C0h
                mov     word ptr ds:8, 0 ; [PDB.CPM_CALL+3],0

addr_ok:                                ; ...
                mov     word ptr ds:0, 20CDh ; PDB.EXIT_CALL],(int_abort*256) + mi_INT
                mov     byte ptr ds:5, 9Ah ; [PDB.CPM_CALL],mi_Long_CALL
                mov     word ptr ds:50h, 21CDh ; [PDB.CALL_SYSTEM],(int_command*256) + mi_INT
                mov     byte ptr ds:52h, 0CBh ; [PDB.CALL_SYSTEM+2],mi_Long_RET
                mov     word ptr ds:34h, 18h ; [PDB.JFN_Pointer],PDB.JFN_TABLE
                mov     word ptr ds:36h, ds ; PDB.JFN_Pointer+2],DS
                mov     word ptr ds:32h, 14h ; [PDB.JFN_Length],FILPERPROC
                mov     word ptr ds:38h, 0FFFFh ; [PDB.Next_PDB],-1
                mov     word ptr ds:3Ah, 0FFFFh ; [PDB.Next_PDB+2],-1
                mov     word ptr es:40h, 0A07h ; [ES:PDB.Version],
                                        ; (MINOR_VERSION*256)+MAJOR_VERSION
                retn
SETMEM          endp

; ---------------------------------------------------------------------------

$GSetMediaID:                           ; ...
                push    ds
                push    si
                lds     si, ss:THISCDS
                lds     si, [si+45h]    ; [si+curdir.devptr]
                                        ; local pointer to DPB or net device
                mov     si, [si+0Fh]    ; [si+DPB.FAT_SIZE]
                mov     cx, 866h        ; assume get for IOCTL
                                        ; major function = Generic IOCtl (08h)
                                        ; minor function = GetMediaId (66h)
                cmp     al, 1           ; set ?
                jb      short doioctl1  ; get
                ja      short errorfunc ; invalid
                mov     cl, 46h         ; minor function = SetMediaId (46h)
                or      si, si
                jz      short doioctl2  ; FAT32 fs

doioctl1:                               ; ...
                or      si, si
                jnz     short doioctl   ; FAT fs (FAT12, FAT16)
                pop     ds
                push    ds
                mov     si, dx          ; disk info
                                        ; .................................
                                        ; 00h    WORD    0000h (info level)
                                        ; 02h    DWORD   disk serial number (binary)
                                        ; 06h 11 BYTEs   volume label or "NO NAME    " if none present
                                        ; 11h  8 BYTEs   (AL=00h only) filesystem type
                                        ;     "FAT12   "
                                        ;     "FAT16   "
                                        ;     "FAT32   " ; PCDOS 7.1
                                        ;     "CDROM   "
                                        ;     "CD001   "
                                        ;     "CDAUDIO "
                                        ; .................................
                                        ; ; (ref: Ralf Brown's Interrupt List)
                cmp     word ptr [si+11h], 4146h ; 'FA'
                jnz     short doioctl
                cmp     word ptr [si+13h], 3354h ; 'T3'
                jnz     short doioctl
                cmp     word ptr [si+15h], 2032h ; '2 '
                jnz     short doioctl
                cmp     word ptr [si+17h], 2020h ; '  '
                jnz     short doioctl

doioctl2:                               ; ...
                mov     ch, 48h         ; new generic ioctl function (FAT32)
                                        ; (major function bit 6 is 1)

doioctl:                                ; ...
                pop     si
                pop     ds
                mov     al, 0Dh         ; generic IOCTL
                call    $IOCTL          ; let IOCTL take care of it
                retn
; ---------------------------------------------------------------------------

errorfunc:                              ; ...
                mov     al, 1           ; error_invalid_function
                jmp     SYS_RET_ERR

; =============== S U B R O U T I N E =======================================


StrCmp          proc near               ; ...
                push    si
                push    di
                push    ax

Cmplp:                                  ; ...
                lodsb
                call    UCase           ; convert to upper case
                call    PATHCHRCMP      ; convert '/' to '\'
                mov     ah, al
                mov     al, es:[di]
                inc     di
                call    UCase
                call    PATHCHRCMP
                cmp     ah, al
                jnz     short PopRet    ; Strings dif
                or      al, al
                jnz     short Cmplp     ; More string

PopRet:                                 ; ...
                pop     ax
                pop     di
                pop     si
                retn
StrCmp          endp


; =============== S U B R O U T I N E =======================================


StrCpy          proc near               ; ...
                push    ax

CPYLoop:                                ; ...
                lodsb
                call    UCase           ; convert to upper case
                call    PATHCHRCMP      ; convert / to \
                stosb
                or      al, al
                jnz     short CPYLoop
                pop     ax
                retn
StrCpy          endp


; =============== S U B R O U T I N E =======================================


FStrCpy         proc near               ; ...
                push    ax

FCPYLoop:                               ; ...
                lodsb
                stosb
                or      al, al
                jnz     short FCPYLoop
                pop     ax
                retn
FStrCpy         endp


; =============== S U B R O U T I N E =======================================


StrLen          proc near               ; ...
                push    di
                push    ax
                mov     cx, 65535       ; -1 ; 0FFFFh
                xor     al, al
                repne scasb
                not     cx
                pop     ax
                pop     di
                retn
StrLen          endp


; =============== S U B R O U T I N E =======================================


DStrLen         proc near               ; ...
                call    XCHGP
                call    StrLen
                call    XCHGP
                retn
DStrLen         endp


; =============== S U B R O U T I N E =======================================


XCHGP           proc near               ; ...
                push    ds
                push    es
                pop     ds
                pop     es
                xchg    si, di

xchgp_retn:                             ; ...
                retn
XCHGP           endp


; =============== S U B R O U T I N E =======================================


Idle            proc near               ; ...
                cmp     ss:FSHARING, 0
                jnz     short xchgp_retn
                push    cx
                mov     cx, ss:RetryLoop
                jcxz    short Idle3

Idle1:                                  ; ...
                push    cx
                xor     cx, cx

Idle2:                                  ; ...
                loop    Idle2
                pop     cx
                loop    Idle1

Idle3:                                  ; ...
                pop     cx
                retn
Idle            endp


; =============== S U B R O U T I N E =======================================

; Attributes: bp-based frame

TableDispatch   proc near               ; ...

TFrame.Index    = byte ptr  4
TFrame.Tab      = word ptr  6

                push    bp
                mov     bp, sp
                push    bx
                mov     bx, [bp+TFrame.Tab]
                mov     bl, cs:[bx]
                cmp     [bp+TFrame.Index], bl
                jnb     short TableError
                mov     bl, [bp+TFrame.Index]
                xor     bh, bh
                shl     bx, 1
                inc     bx
                add     bx, [bp+TFrame.Tab]
                mov     bx, cs:[bx]
                mov     [bp+TFrame.Tab], bx
                pop     bx
                pop     bp
                add     sp, 4
                retn
; ---------------------------------------------------------------------------

TableError:                             ; ...
                pop     bx
                pop     bp
                retn    6
TableDispatch   endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


TestNet         proc near               ; ...
                mov     es, cs:DosDSeg
                les     di, es:THISCDS
                cmp     di, 0FFFFh      ; -1
                jz      short CMCRet    ; UNC? carry is clear
                test    byte ptr es:[di+44h], 80h ; [ES:DI+curdir.flags+1],
                                        ; (curdir_isnet>>8)
                jnz     short CMCRet    ; jump has carry clear
                retn                    ; carry is clear
; ---------------------------------------------------------------------------

CMCRet:                                 ; ...
                cmc
                retn
TestNet         endp


; =============== S U B R O U T I N E =======================================


IsSFTNet        proc near               ; ...
                test    byte ptr es:[di+6], 80h ; [ES:DI+SF_ENTRY.sf_flags+1],
                                        ; (sf_isnet>>8)
                retn
IsSFTNet        endp

; ---------------------------------------------------------------------------

FastInit:                               ; ...
                push    es
                mov     es, cs:DosDSeg
                mov     di, offset FastTable_2 ; points to fastxxx entry
                dec     bx              ; decrement index
                mov     dx, bx
                shl     bx, 1
                shl     bx, 1           ; each entry is DWORD
                add     di, bx
                mov     ax, es:[di+2]
                mov     cx, cs          ; get DOS segment
                cmp     ax, cx          ; first time installed ?
                jz      short ok_install ; yes
                or      ax, ax
                stc
                jnz     short FSret     ; already installed !

ok_install:                             ; ...
                cmp     si, 0FFFFh      ; Query only ?
                jz      short FSret     ; yes
                mov     cx, ds          ; get FASTXXX entry segment
                mov     es:[di+2], cx   ; initialize routine entry
                                        ; initialize routine offset
                mov     es:[di], si
                mov     di, offset FastOpenFlg ; FastFlg
                add     di, dx          ; index to a FASTXXX flag
                or      byte ptr es:[di], 80h ; Fast_yes
                                        ; indicate installed

FSret:                                  ; ...
                pop     es
                retn
; ---------------------------------------------------------------------------

FastRet:                                ; ...
                stc
                sbb     ax, ax          ; AX = -1, CF = 1
                retf
; ---------------------------------------------------------------------------

NLS_OPEN:                               ; ...
                mov     al, cl          ; set up correct interface for $OPEN
                call    $OPEN
                retn
; ---------------------------------------------------------------------------

NLS_LSEEK:                              ; ...
                push    ss:USER_SP      ; save user stack
                push    ss:USER_SS
                call    Fake_User_Stack
                mov     ax, bp          ; set up correct interface for $LSEEK
                call    $LSEEK

NLS_SEEK_RET:                           ; ...
                pop     ss:USER_SS      ; restore user stack
                pop     ss:USER_SP
                retn

; =============== S U B R O U T I N E =======================================


Fake_User_Stack proc near               ; ...
                mov     ax, ss:USER_SP_2F ; replace with INT 2Fh stack
                mov     ss:USER_SP, ax
                mov     ax, ss
                mov     ss:USER_SS, ax
                retn
Fake_User_Stack endp

; ---------------------------------------------------------------------------

GetDevList:                             ; ...
                mov     si, offset SysInitTable
                mov     ds, cs:DosDSeg
                lds     si, [si]
                mov     ax, [si+22h]    ; [SI+SYSI.DEV]
                mov     bx, [si+24h]    ; [SI+SYSI.DEV+2]
                retn
; ---------------------------------------------------------------------------

NLS_IOCTL:                              ; ...
                push    ss:USER_SP
                push    ss:USER_SS
                call    Fake_User_Stack
                mov     ax, bp          ; set up correct interface for $IOCTL
                call    $IOCTL
                jmp     short NLS_SEEK_RET
; ---------------------------------------------------------------------------

NLS_GETEXT:                             ; ...
                mov     ax, ss:EXTERR   ; return extended error

MSG_RETRIEVAL:                          ; ...
                retn

; =============== S U B R O U T I N E =======================================


ECritDisk       proc near               ; ...
                push    cx
                mov     ch, 0
                mov     cl, ss:redir_patch
                jcxz    short ECritDisk_3
                pop     cx
                push    ax
                mov     ax, 8001h

ECritDisk_1:                            ; ...
                push    cx
                mov     ch, 0
                mov     cl, ss:IsWin386
                jcxz    short ECritDisk2
                pop     cx
                int     2Ah             ; Microsoft Networks - BEGIN DOS CRITICAL SECTION
                                        ; AL = critical section number (00h-0Fh)
                pop     ax
                retn
; ---------------------------------------------------------------------------

ECritDisk2:                             ; ...
                push    es
                mov     cx, 0
                mov     es, cx
                assume es:DOSCODE
                pushf                   ; simulate INT 2Ah
                call    es:00A8h        ; call far (INT 2Ah vector)
                pop     es
                assume es:nothing
                pop     cx
                pop     ax
                retn
; ---------------------------------------------------------------------------

ECritDisk_3:                            ; ...
                pop     cx
                retn
ECritDisk       endp


; =============== S U B R O U T I N E =======================================


LCritDisk       proc near               ; ...
                push    cx
                mov     ch, 0
                mov     cl, ss:redir_patch
                jcxz    short ECritDisk_3
                pop     cx
                push    ax
                mov     ax, 8101h
                jmp     short ECritDisk_1
LCritDisk       endp


; =============== S U B R O U T I N E =======================================


ECritDevice     proc near               ; ...
                push    cx
                mov     ch, 0
                mov     cl, ss:redir_patch
                jcxz    short ECritDisk_3
                pop     cx
                push    ax
                mov     ax, 8002h
                jmp     short ECritDisk_1
ECritDevice     endp


; =============== S U B R O U T I N E =======================================


LCritDevice     proc near               ; ...
                push    cx
                mov     ch, 0
                mov     cl, ss:redir_patch
                jcxz    short ECritDisk_3
                pop     cx
                push    ax
                mov     ax, 8102h
                jmp     short ECritDisk_1
LCritDevice     endp


; =============== S U B R O U T I N E =======================================


$STD_CON_INPUT_NO_ECHO proc near        ; ...
                push    ds              ; Input character from console, no echo
                push    si

INTEST:                                 ; ...
                call    near ptr STATCHK
                jnz     short GET
                cmp     ss:PRINTER_FLAG, 0 ; is printer idle?
                jnz     short no_sys_wait
                mov     ah, 5           ; get input status with system wait
                call    IOFUNC

no_sys_wait:                            ; ...
                mov     ah, 84h
                int     2Ah             ; Microsoft Networks - KEYBOARD BUSY LOOP
                cmp     byte ptr ss:DATE_FLAG, 0FFh ; date is updated may be every
                jnz     short NoUpdate  ; 255 x ? ms if no one calls
                push    ax
                push    bx
                push    cx
                push    dx
                push    ds
                push    ss
                pop     ds
                assume ds:DOSCODE
                xor     ax, ax
                call    Save_Restore_Packet ; save DEVCALL packet
                call    READTIME
                mov     ax, 1
                call    Save_Restore_Packet ; restore DEVCALL packet
                pop     ds
                assume ds:nothing
                pop     dx
                pop     cx
                pop     bx
                pop     ax

NoUpdate:                               ; ...
                inc     ss:DATE_FLAG
                jmp     short INTEST
; ---------------------------------------------------------------------------

GET:                                    ; ...
                xor     ah, ah
                call    IOFUNC
                pop     si
                pop     ds
                mov     ss:SCAN_FLAG, 0
                cmp     al, 0           ; extended code ?
                jnz     short noscan
                inc     ss:SCAN_FLAG    ; set this flag for ALT_Q key

noscan:                                 ; ...
                retn
$STD_CON_INPUT_NO_ECHO endp

; ---------------------------------------------------------------------------

$STD_CON_STRING_OUTPUT:                 ; ...
                mov     si, dx          ; Console String Output

NEXT_STR1:                              ; ...
                lodsb
                cmp     al, 24h ; '$'
                jz      short noscan
                call    OUTT
                jmp     short NEXT_STR1

; =============== S U B R O U T I N E =======================================


$STD_CON_STRING_INPUT proc near         ; ...
                push    ss              ; Input Line from Console
                pop     es
                assume es:DOSCODE
                mov     si, dx
                xor     ch, ch          ; 0
                lodsw
                or      al, al
                jz      short noscan    ; Buffer is 0 length!!?
                mov     bl, ah          ; Init template counter
                mov     bh, ch
                cmp     al, bl
                jbe     short NOEDIT    ; If length of buffer inconsistent
                                        ;  with contents
                cmp     byte ptr [bx+si], 0Dh ; c_CR
                jz      short EDITON    ; If CR correctly placed EDIT is OK

NOEDIT:                                 ; ...
                mov     bl, ch          ; Reset buffer

EDITON:                                 ; ...
                mov     dl, al
                dec     dx              ; DL is # of bytes we can put in the buffer
$STD_CON_STRING_INPUT endp

; START OF FUNCTION CHUNK FOR FINDOLD

NEWLIN:                                 ; ...
                mov     al, ss:CARPOS
                mov     ss:STARTPOS, al ; Remember position in raw buffer
                push    si
                mov     di, offset INBUF ; Build the new line here
                mov     ss:INSMODE, ch  ; Insert mode off
                mov     bh, ch          ; No chars from template yet
                mov     dh, ch          ; No chars to new line yet
                call    $STD_CON_INPUT_NO_ECHO ; Get first char
                cmp     al, 0Ah         ; Linefeed ; c_LF
                jnz     short GOTCH

GETCH:                                  ; ...
                call    $STD_CON_INPUT_NO_ECHO

GOTCH:                                  ; ...
                cmp     al, 6           ; Ignore ^F
                jz      short GETCH
                cmp     al, cs:ESCCHAR  ; function-key lead byte ?
                jz      short ESCAPE    ; change reserved keyword
                cmp     al, 7Fh         ; c_DEL ; destructive backspace
                jz      short BACKSP
                cmp     al, 8           ; c_BS ; destructive backspaces
                jz      short BACKSP
                cmp     al, 0Dh         ; c_CR ; CR terminates the line.
                jz      short ENDLIN
                cmp     al, 0Ah         ; c_LF ; LF goes to a new line
                jz      short PHYCRLF   ; and keeps on reading.
                cmp     al, cs:CANCHAR  ; ^X (or ESC) deletes the line
                jz      short KILNEW    ;  and starts over

SAVCH:                                  ; ...
                cmp     dh, dl
                jnb     short BUFFUL    ; buffer is full
                stosb                   ; save the input character
                inc     dh              ; increment count in buffer
                call    BUFOUT          ; Print control chars nicely
                cmp     ss:INSMODE, 0
                jnz     short GETCH     ; insertmode => don't advance template
                cmp     bh, bl
                jnb     short GETCH     ; no more characters in template
                inc     si              ; Skip to next char in template
                inc     bh              ; remember position in template
                jmp     short GETCH
; ---------------------------------------------------------------------------

BUFFUL:                                 ; ...
                mov     al, 7           ; Bell to signal full buffer
                call    OUTT
                jmp     short GETCH
; ---------------------------------------------------------------------------

ESCAPE:                                 ; ...
                jmp     OEMFunctionKey  ; let the OEM's handle the key dispatch
; ---------------------------------------------------------------------------

ENDLIN:                                 ; ...
                stosb                   ; Put the CR in the buffer
                call    OUTT            ; Echo it
                pop     di              ; Get start of user buffer
                mov     [di-1], dh      ; Tell user how many bytes
                inc     dh              ; DH is length including CR

COPYNEW:                                ; ...
                push    ds              ; XCHG ES,DS
                push    es
                pop     ds
                assume ds:DOSCODE
                pop     es
                assume es:nothing
                mov     si, offset INBUF
                mov     cl, dh          ; set up count
                rep movsb               ; Copy final line to user buffer
; END OF FUNCTION CHUNK FOR FINDOLD

OLDBAK_RETN:                            ; ...
                retn
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR FINDOLD

PHYCRLF:                                ; ...
                call    CRLF            ; Output a CRLF to the user screen
                                        ; and do NOT store it into the buffer

GETCH_j:                                ; ...
                jmp     short GETCH
; END OF FUNCTION CHUNK FOR FINDOLD
; ---------------------------------------------------------------------------

LineDel:                                ; ...
                or      dh, dh          ; Delete the previous line
                jz      short GETCH
                call    BackSpace
                jmp     short LineDel
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR FINDOLD

KILNEW:                                 ; ...
                mov     al, 5Ch ; '\'
                call    OUTT            ; Print the CANCEL indicator
                pop     si              ; Remember start of edit buffer

PUTNEW:                                 ; ...
                call    CRLF            ; Go to next line on screen
                mov     al, ss:STARTPOS
                call    TAB             ; Tab over
                jmp     NEWLIN          ; Start over again
; ---------------------------------------------------------------------------

BACKSP:                                 ; ...
                call    BackSpace       ; Destructively back up one char position
                jmp     short GETCH_j
; END OF FUNCTION CHUNK FOR FINDOLD

; =============== S U B R O U T I N E =======================================


BackSpace       proc near               ; ...
                or      dh, dh
                jz      short OLDBAK    ; No chars in line,
                                        ;  do nothing to line
                call    BACKUP          ; Do the backup
                mov     al, es:[di]     ; Get the deleted char
                cmp     al, 20h ; ' '   ; Was a normal char
                jnb     short OLDBAK
                cmp     al, 9
                jz      short BAKTAB    ; Was a tab, fix up users display
                cmp     al, 15h         ; "U"-"@" ; ctrl-U is a section symbol
                                        ;  not ^U
                jz      short OLDBAK
                cmp     al, 14h         ; "T"-"@" ; ctrl-T is a paragraphs symbol
                                        ;  not ^T
                jz      short OLDBAK
                call    BACKMES

OLDBAK:                                 ; ...
                cmp     ss:INSMODE, 0
                jnz     short OLDBAK_RETN ; In insert mode, done
                or      bh, bh
                jz      short OLDBAK_RETN ;
                                        ; Not advanced in template,
                                        ;  stay where we are
                dec     bh              ; Go back in template
                dec     si
                retn
; ---------------------------------------------------------------------------

BAKTAB:                                 ; ...
                push    di
                dec     di              ; Back up one char
                std                     ; Go backward
                mov     cl, dh          ; Number of chars currently in line
                mov     al, 20h ; ' '
                push    bx
                mov     bl, 7           ; Max
                jcxz    short FIGTAB    ; At start, do nothing

FNDPOS:                                 ; ...
                scasb                   ; Look back
                jbe     short CHKCNT
                cmp     byte ptr es:[di+1], 9
                jz      short HAVTAB    ; Found a tab
                dec     bl              ; Back one char if non tab control char

CHKCNT:                                 ; ...
                loop    FNDPOS

FIGTAB:                                 ; ...
                sub     bl, ss:STARTPOS

HAVTAB:                                 ; ...
                sub     bl, dh
                add     cl, bl
                and     cl, 7           ; CX has correct number to erase
                cld                     ; Back to normal
                pop     bx
                pop     di
                jz      short OLDBAK    ; Nothing to erase

TABBAK:                                 ; ...
                call    BACKMES
                loop    TABBAK          ; Erase correct number of chars
                jmp     short OLDBAK
BackSpace       endp


; =============== S U B R O U T I N E =======================================


BACKUP          proc near               ; ...
                dec     dh              ; Back up in line
                dec     di
BACKUP          endp


; =============== S U B R O U T I N E =======================================


BACKMES         proc near               ; ...
                mov     al, 8           ; c_BS ; Backspace
                call    OUTT
                mov     al, 20h ; ' '   ; SPACE char ; Erase
                call    OUTT
                mov     al, 8           ; Backspace
                jmp     OUTT            ; Done
BACKMES         endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR FINDOLD

TWOESC:                                 ; ...
                mov     al, cs:ESCCHAR  ; User really wants an ESC character
                                        ;  in his line
                jmp     SAVCH
; ---------------------------------------------------------------------------

COPYLIN:                                ; ...
                mov     cl, bl          ; Total size of template
                sub     cl, bh          ; Minus position in template,
                                        ;  is number to move
                jmp     short COPYEACH
; ---------------------------------------------------------------------------

COPYSTR:                                ; ...
                call    FINDOLD         ; Find the char
                jmp     short COPYEACH  ; Copy up to it
; ---------------------------------------------------------------------------

COPYONE:                                ; ...
                mov     cl, 1

COPYEACH:                               ; ...
                mov     ss:INSMODE, 0   ; All copies turn off insert mode
                cmp     dh, dl
                jz      short GETCH2    ; At end of line, can't do anything
                cmp     bh, bl
                jz      short GETCH2    ; At end of template, can't do anything
                lodsb
                stosb
                call    BUFOUT
                inc     bh              ; Ahead in template
                inc     dh              ; Ahead in line
                loop    COPYEACH

GETCH2:                                 ; ...
                jmp     GETCH
; ---------------------------------------------------------------------------

SKIPONE:                                ; ...
                cmp     bh, bl
                jz      short GETCH2    ; At end of template
                inc     bh              ; Ahead in template
                inc     si
                jmp     short GETCH2
; ---------------------------------------------------------------------------

SKIPSTR:                                ; ...
                call    FINDOLD         ; Find out how far to go
                add     si, cx          ; Go there
                add     bh, cl
                jmp     short GETCH2
; END OF FUNCTION CHUNK FOR FINDOLD

; =============== S U B R O U T I N E =======================================


FINDOLD         proc near               ; ...

; FUNCTION CHUNK AT 4967 SIZE 00000019 BYTES
; FUNCTION CHUNK AT 58F1 SIZE 0000007B BYTES
; FUNCTION CHUNK AT 596D SIZE 00000005 BYTES
; FUNCTION CHUNK AT 597B SIZE 00000018 BYTES
; FUNCTION CHUNK AT 5A04 SIZE 00000042 BYTES

                call    $STD_CON_INPUT_NO_ECHO
                cmp     al, cs:ESCCHAR  ; did he type a function key?
                jnz     short FINDSETUP ; no, set up for scan
                call    $STD_CON_INPUT_NO_ECHO ; eat next char
                jmp     short NOTFND    ; go try again
; ---------------------------------------------------------------------------

FINDSETUP:                              ; ...
                mov     cl, bl
                sub     cl, bh          ; CX is number of chars to end of template
                jz      short NOTFND    ; At end of template
                dec     cx              ; Cannot point past end, limit search
                jz      short NOTFND    ; If only one char in template, forget it
                push    es
                push    ds
                pop     es
                assume es:DOSCODE
                push    di
                mov     di, si          ; Template to ES:DI
                inc     di
                repne scasb             ; Look
                pop     di
                pop     es
                assume es:nothing
                jnz     short NOTFND    ; Didn't find the char
                not     cl              ; Turn how far to go into how far we went
                add     cl, bl          ; Add size of template
                sub     cl, bh          ; Subtract current pos,
                                        ;  result distance to skip

FINDOLD_RETN:                           ; ...
                retn
; ---------------------------------------------------------------------------

NOTFND:                                 ; ...
                pop     bp              ; Chuck return address

GETCH2_j:                               ; ...
                jmp     short GETCH2
; ---------------------------------------------------------------------------

REEDIT:                                 ; ...
                mov     al, 40h ; '@'   ; Output re-edit character
                call    OUTT
                pop     di
                push    di
                push    es
                push    ds
                call    COPYNEW         ; Copy current line into template
                pop     ds
                assume ds:nothing
                pop     es
                pop     si
                mov     bl, dh          ; Size of line is new size template
                jmp     PUTNEW          ; Start over again
; ---------------------------------------------------------------------------

EXITINS:                                ; ...
                not     ss:INSMODE      ; ENTERINS
                jmp     short GETCH2_j
; ---------------------------------------------------------------------------

CTRLZ:                                  ; ...
                mov     al, 1Ah         ; "Z"-"@"
                jmp     SAVCH
FINDOLD         endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


CRLF            proc near               ; ...
                mov     al, 0Dh         ; c_CR
                call    OUTT
                mov     al, 0Ah         ; c_LF
                jmp     OUTT
CRLF            endp

; ---------------------------------------------------------------------------

$RAW_CON_IO:                            ; ...
                mov     al, dl          ; Input/Output raw char from console, no echo
                cmp     al, 0FFh        ; -1 if input
                jnz     short RAWOUT
                les     di, dword ptr ss:USER_SP ; Get pointer to register save area
                xor     bx, bx
                call    GET_IO_SFT
                jb      short FINDOLD_RETN
                mov     ah, 1
                call    IOFUNC
                jnz     short RESFLG
                call    SPOOLINT
                or      byte ptr es:[di+16h], 40h ; [ES:DI+user_env.user_F],40h
                                        ; Set user's zero flag
                xor     al, al

RET17:                                  ; ...
                retn
; ---------------------------------------------------------------------------

RESFLG:                                 ; ...
                and     byte ptr es:[di+16h], 0BFh ; [ES:DI+user_env.user_F],0FFh-40h
                                        ; Reset user's zero flag

rci0:                                   ; ...
                call    SPOOLINT

$RAW_CON_INPUT:                         ; ...
                push    bx
                xor     bx, bx
                call    GET_IO_SFT
                pop     bx
                jb      short RET17
                mov     ah, 1
                call    IOFUNC
                jnz     short rci5
                mov     ah, 84h
                int     2Ah             ; Microsoft Networks - KEYBOARD BUSY LOOP
                jmp     short rci0
; ---------------------------------------------------------------------------

rci5:                                   ; ...
                xor     ah, ah
                call    IOFUNC
                retn

; =============== S U B R O U T I N E =======================================


RAWOUT          proc near               ; ...
                push    bx
                mov     bx, 1
                call    GET_IO_SFT
                jb      short RAWRET1
                mov     bx, [si+5]      ; [SI+SF_ENTRY.sf_flags]
                                        ; DS set up by get_io_sft
                and     bx, 8080h       ; sf_isnet+devid_device
                cmp     bx, 80h         ; devid_device
                jnz     short RAWNORM
                push    ds
                lds     bx, [si+7]      ; [SI+SF_ENTRY.sf_devptr]
                                        ; output to special?
                test    byte ptr [bx+4], 10h ; ISSPEC
                pop     ds
                jz      short RAWNORM   ; if not, do normally
                push    ds
                xor     bx, bx
                mov     ds, bx
                assume ds:DOSCODE
                pushf                   ; simulate INT 29h
                call    ds:00A4h        ; call far [29h*4] ; call far [00A4h]
                pop     ds
                assume ds:nothing

RAWRET:                                 ; ...
                clc

RAWRET1:                                ; ...
                pop     bx

RAWRET2:                                ; ...
                retn
; ---------------------------------------------------------------------------

RAWNORM:                                ; ...
                call    RAWOUT3
                jmp     short RAWRET
RAWOUT          endp


; =============== S U B R O U T I N E =======================================


RAWOUT2         proc near               ; ...
                call    GET_IO_SFT      ; Output the character in AL to handle in BX
                jb      short RAWRET2
RAWOUT2         endp


; =============== S U B R O U T I N E =======================================


RAWOUT3         proc near               ; ...
                push    ax
                jmp     short RAWOSTRT
; ---------------------------------------------------------------------------

ROLP:                                   ; ...
                call    SPOOLINT
                or      ss:DOS34_FLAG, 200h ; [ss:DOS34_FLAG],CTRL_BREAK_FLAG
                call    DSKSTATCHK      ; check control break

RAWOSTRT:                               ; ...
                mov     ah, 3
                call    IOFUNC
                jz      short ROLP
                inc     ax              ; fail on I24 if ax = -1
                pop     ax
                jz      short nosend    ; yes, do not send char
                mov     ah, 2
                call    IOFUNC

nosend:                                 ; ...
                clc                     ; Clear carry indicating successful
                retn
RAWOUT3         endp


; =============== S U B R O U T I N E =======================================


Save_Restore_Packet proc near           ; ...
                push    ds
                push    es
                push    si
                push    di
                mov     di, offset FAKE_STACK_2F
                mov     si, offset DEVCALL_REQLEN ; DEVCALL
                or      ax, ax
                jz      short save_packet
                xchg    si, di

save_packet:                            ; ...
                push    ss
                pop     ds
                assume ds:DOSCODE
                push    ss
                pop     es
                assume es:DOSCODE
                mov     cx, 11
                rep movsw
                pop     di
                pop     si
                pop     es
                assume es:nothing
                pop     ds
                assume ds:nothing
                retn
Save_Restore_Packet endp

; ---------------------------------------------------------------------------

$STD_CON_INPUT:                         ; ...
                call    $STD_CON_INPUT_NO_ECHO
                push    ax
                call    OUTT
                pop     ax

CON_INPUT_RETN:                         ; ...
                retn
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR OUTT

outch2:                                 ; ...
                push    ax
                call    near ptr STATCHK
                pop     ax
                jmp     short OUTSKIP
; END OF FUNCTION CHUNK FOR OUTT
; ---------------------------------------------------------------------------

$STD_CON_OUTPUT:                        ; ...
                mov     al, dl

; =============== S U B R O U T I N E =======================================


OUTT            proc near               ; ...

; FUNCTION CHUNK AT 5B69 SIZE 00000007 BYTES
; FUNCTION CHUNK AT 5BF1 SIZE 00000008 BYTES
; FUNCTION CHUNK AT 5BFC SIZE 00000008 BYTES
; FUNCTION CHUNK AT 5C51 SIZE 00000007 BYTES

                cmp     al, 20h ; ' '
                jb      short CTRLOUT
                cmp     al, 7Fh
                jz      short OUTCH
                inc     ss:CARPOS

OUTCH:                                  ; ...
                push    ds
                push    si
                inc     ss:CHARCO       ; invoke statchk...
                and     ss:CHARCO, 3Fh  ; every 64th character
                jz      short outch2

OUTSKIP:                                ; ...
                call    RAWOUT          ; output the character
                pop     si
                pop     ds
                test    ss:PFLAG, 0FFh  ; -1
                jz      short CON_INPUT_RETN
                push    bx
                push    ds
                push    si
                mov     bx, 1
                call    GET_IO_SFT
                jb      short TRIPOPJ
                mov     bx, [si+5]      ; [SI+SF_ENTRY.sf_flags]
                test    bh, 80h         ; (sf_isnet>>8)
                jnz     short TRIPOPJ
                test    bl, 80h         ; devid_device
                jz      short TRIPOPJ
                mov     bx, 4
                call    GET_IO_SFT      ; GET_IO_SFT will set up DS:SI to sft entry
                jb      short TRIPOPJ
                test    byte ptr [si+6], 8 ; [SI+SF_ENTRY.sf_flags+1],
                                        ; (sf_net_spool>>8) ; StdPrn redirected?
                jz      short LISSTRT2J
                mov     ss:PFLAG, 0     ; If a spool, NEVER echo

TRIPOPJ:                                ; ...
                jmp     TRIPOP
; ---------------------------------------------------------------------------

LISSTRT2J:                              ; ...
                jmp     LISSTRT2
; ---------------------------------------------------------------------------

CTRLOUT:                                ; ...
                cmp     al, 0Dh         ; c_CR
                jz      short ZERPOS
                cmp     al, 8           ; c_BS
                jz      short BACKPOS
                cmp     al, 9           ; c_HT
                jnz     short OUTCH
                mov     al, ss:CARPOS
                or      al, 0F8h
                neg     al
OUTT            endp


; =============== S U B R O U T I N E =======================================


TAB             proc near               ; ...
                push    cx
                mov     cl, al
                mov     ch, 0
                jcxz    short POPTAB

TABLP:                                  ; ...
                mov     al, 20h ; ' '
                call    OUTT
                loop    TABLP

POPTAB:                                 ; ...
                pop     cx
                retn
TAB             endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR OUTT

ZERPOS:                                 ; ...
                mov     ss:CARPOS, 0
                jmp     short OUTCH
; END OF FUNCTION CHUNK FOR OUTT
; ---------------------------------------------------------------------------

j_OUTT:                                 ; ...
                jmp     OUTT
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR OUTT

BACKPOS:                                ; ...
                dec     ss:CARPOS
                jmp     OUTCH
; END OF FUNCTION CHUNK FOR OUTT

; =============== S U B R O U T I N E =======================================


BUFOUT          proc near               ; ...
                cmp     al, 20h ; ' '
                jnb     short j_OUTT    ; Normal char
                cmp     al, 9
                jz      short j_OUTT    ; OUT knows how to expand tabs
                cmp     al, 15h         ; "U"-"@" ; turn ^U to section symbol
                jz      short CTRLU
                cmp     al, 14h         ; "T"-"@" ; turn ^T to paragraph symbol
                jz      short CTRLU
                push    ax
                mov     al, 5Eh ; '^'
                call    OUTT            ; Print '^' before control chars
                pop     ax
                or      al, 40h         ; Turn it into Upper case mate

CTRLU:                                  ; ...
                call    OUTT

BUFOUT_RETN:                            ; ...
                retn
BUFOUT          endp

; ---------------------------------------------------------------------------

$STD_AUX_INPUT:                         ; ...
                call    near ptr STATCHK
                mov     bx, 3
                call    GET_IO_SFT
                jb      short BUFOUT_RETN
                jmp     short TAISTRT
; ---------------------------------------------------------------------------

AUXILP:                                 ; ...
                call    SPOOLINT

TAISTRT:                                ; ...
                mov     ah, 1
                call    IOFUNC
                jz      short AUXILP
                xor     ah, ah
                call    IOFUNC
                retn
; ---------------------------------------------------------------------------

$STD_AUX_OUTPUT:                        ; ...
                push    bx
                mov     bx, 3
                jmp     short SENDOUT
; ---------------------------------------------------------------------------

$STD_PRINTER_OUTPUT:                    ; ...
                push    bx
                mov     bx, 4

SENDOUT:                                ; ...
                mov     al, dl
                push    ax
                call    near ptr STATCHK
                pop     ax
                push    ds
                push    si
; START OF FUNCTION CHUNK FOR OUTT

LISSTRT2:                               ; ...
                call    RAWOUT2

TRIPOP:                                 ; ...
                pop     si
                pop     ds
                pop     bx

SCIS_RETN:                              ; ...
                retn
; END OF FUNCTION CHUNK FOR OUTT
; ---------------------------------------------------------------------------

$STD_CON_INPUT_STATUS:                  ; ...
                call    near ptr STATCHK
                mov     al, 0           ; no xor!!
                jz      short SCIS_RETN
                dec     ax              ; -1
                retn
; ---------------------------------------------------------------------------

$STD_CON_INPUT_FLUSH:                   ; ...
                push    ax
                push    dx
                xor     bx, bx
                call    GET_IO_SFT
                jb      short BADJFNCON
                mov     ah, 4
                call    IOFUNC

BADJFNCON:                              ; ...
                pop     dx
                pop     ax
                mov     ah, al
                cmp     al, 1
                jz      short REDISPJ
                cmp     al, 6
                jz      short REDISPJ
                cmp     al, 7
                jz      short REDISPJ
                cmp     al, 8
                jz      short REDISPJ
                cmp     al, 0Ah
                jz      short REDISPJ
                mov     al, 0
                retn
; ---------------------------------------------------------------------------

REDISPJ:                                ; ...
                cli
                jmp     REDISP
; ---------------------------------------------------------------------------

$GET_FCB_POSITION:                      ; ...
                call    GetExtended     ; point to FCB
                call    GetExtent       ; DX:AX is current record
                mov     [si+21h], ax    ; [SI+SYS_FCB.RR] ; drop in low order piece
                mov     [si+23h], dl    ; [SI+SYS_FCB.RR+2] ; drop in high order piece
                cmp     word ptr [si+0Eh], 64 ; [SI+SYS_FCB.RECSIZ]
                jnb     short GetFCBBye
                mov     [si+24h], dh    ; [SI+SYS_FCB.RR+2+1]
                                        ; Set 4th byte only if record size < 64

GetFCBBye:                              ; ...
                jmp     NO_OP           ; jmp FCB_RET_OK
; ---------------------------------------------------------------------------

$FCB_DELETE:                            ; ...
                mov     di, offset OPENBUF
                call    TransFCB        ; convert FCB to path
                jb      short BadPath   ; signal no deletions
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    DOS_DELETE
                jnb     short GetFCBBye ; do a good return

BadPath:                                ; ...
                jmp     FCB_RET_ERR     ; let someone else signal the error
; ---------------------------------------------------------------------------

$GET_FCB_FILE_LENGTH:                   ; ...
                call    GetExtended     ; get real FCB pointer
                                        ; DX points to Input FCB
                mov     di, offset OPENBUF ; appropriate buffer in DOSDATA
                push    ds              ; save pointer to true FCB
                push    si
                call    TransFCB        ; Trans name DS:DX, sets SATTRIB
                pop     si
                pop     ds
                assume ds:nothing
                jb      short BadPath
                push    ds              ; save pointer
                push    si
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    GET_FILE_INFO   ; grab the info
                pop     si              ; get pointer back
                pop     ds
                assume ds:nothing
                jb      short BadPath   ; invalid something
                mov     dx, bx          ; get high order size
                mov     ax, di          ; get low order size
                mov     bx, [si+0Eh]    ; [SI+SYS_FCB.RECSIZ]
                                        ; get his record size
                or      bx, bx          ; empty record => 0 size for file
                jnz     short GetSize   ; not empty
                mov     bl, 128

GetSize:                                ; ...
                xchg    ax, dx          ; move high order for divide
                xor     dx, dx          ; clear out high
                div     bx
                push    ax              ; save dividend
                mov     ax, di          ; get low order piece
                div     bx
                mov     cx, dx          ; save remainder
                pop     dx              ; get high order dividend
                jcxz    short LengthStore
                add     ax, 1
                adc     dx, 0           ; 32-bit increment

LengthStore:                            ; ...
                mov     [si+21h], ax    ; [SI+SYS_FCB.RR] ; store low order
                mov     [si+23h], dl    ; [SI+SYS_FCB.RR+2] ; store high order
                or      dh, dh
                jz      short GetFCBBye ; not storing insignificant zero
                mov     [si+24h], dh    ; [SI+SYS_FCB.RR+3] ; save that high piece

GoodRet:                                ; ...
                jmp     short GetFCBBye
; ---------------------------------------------------------------------------

$FCB_CLOSE:                             ; ...
                xor     al, al          ; default search attributes
                call    GetExtended     ; DS:SI point to real FCB
                jz      short NoAttr    ; not extended
                mov     al, [si-1]      ; get attributes

NoAttr:                                 ; ...
                mov     ss:ATTRIB, al   ; stash away found attributes
                call    SFTFromFCB
                jb      short GoodRet
                mov     al, es:[di+4]   ; [ES:DI+SF_ENTRY.sf_attr]
                xor     ah, ah
                push    ax
                call    CheckShare
                jnz     short NoStash
                mov     al, ss:ATTRIB
                mov     es:[di+4], al   ; [ES:DI+SF_ENTRY.sf_attr]
                                        ; attempted attribute for close

NoStash:                                ; ...
                push    ds
                lds     ax, [si+14h]    ; [SI+SYS_FCB.FDATE]
                                        ; move in the time and date
                mov     es:[di+0Fh], ax ; [ES:DI+SF_ENTRY.sf_date]
                mov     word ptr es:[di+0Dh], ds ; [ES:DI+SF_ENTRY.sf_time]
                pop     ds
                lds     ax, [si+10h]    ; [SI+SYS_FCB.FILSIZ]
                mov     es:[di+11h], ax ; [ES:DI+SF_ENTRY.sf_size]
                mov     word ptr es:[di+13h], ds ; [ES:DI+SF_ENTRY.sf_size+2]
                or      word ptr es:[di+5], 4000h ; [ES:DI+SF_ENTRY.sf_flags],
                                        ; sf_close_nodate
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    DOS_CLOSE
                les     di, THISSFT
                pop     cx
                mov     es:[di+4], cl   ; [ES:DI+SF_ENTRY.sf_attr]
                                        ; restore SFT attribute
                pushf
                cmp     word ptr es:[di], 0 ; [ES:DI+SF_ENTRY.sf_ref_count],0
                                        ; zero ref count gets blasted
                jnz     short CloseOK
                push    ax
                mov     al, 4Dh ; 'M'
                call    BlastSFT
                pop     ax

CloseOK:                                ; ...
                popf

CloseOK2:                               ; ...
                jnb     short GoodRet
                cmp     al, 6
                jz      short GoodRet
                mov     al, 2

fcb_close_err:                          ; ...
                jmp     FCB_RET_ERR     ; fren90
; ---------------------------------------------------------------------------

$FCB_RENAME:                            ; ...
                call    GetExtended
                push    dx
                mov     al, [si]
                add     si, 10h
                mov     di, offset RENBUF
                push    word ptr [si]
                push    ds
                push    si
                mov     [si], al
                mov     dx, si
                call    TransFCB
                pop     si
                pop     ds
                assume ds:nothing
                pop     word ptr [si]
                pop     dx
                jb      short fcb_close_err
                mov     si, ss:WFP_START
                mov     ss:REN_WFP, si
                mov     di, offset OPENBUF
                call    TransFCB
                jb      short fcb_close_err
                mov     ss:DIRSTRLEN, 67
                call    DOS_RENAME
                jb      short fcb_close_err
                jmp     short CloseOK2

; =============== S U B R O U T I N E =======================================


sub_5DAE        proc near               ; ...
                les     di, ss:THISSFT
                call    IsSFTNet
                jz      short loc_5DC3
                mov     ax, es:[di+0Bh]
                mov     [si+1Ch], ax
                mov     bl, 80h
                jmp     short loc_5E26
; ---------------------------------------------------------------------------

loc_5DC3:                               ; ...
                call    CheckShare
                jnz     short loc_5E21
                test    byte ptr es:[di+5], 80h
                jnz     short loc_5E11
                mov     ax, es:[di+1Bh]
                mov     [si+1Dh], ax
                mov     ax, es:[di+1Dh]
                mov     bl, es:[di+4]
                mov     bh, bl
                ror     bl, 1
                add     bh, bh
                or      bl, bh
                and     bl, 0C0h
                or      al, bl
                mov     [si+18h], al
                mov     al, es:[di+1Fh]
                mov     [si+1Fh], al
                mov     ax, es:[di+2Bh]
                mov     [si+1Bh], ax
                mov     bl, 0

loc_5DFE:                               ; ...
                mov     ax, es:[di+5]
                and     al, 0C0h
                or      al, es:[di+2]
                mov     [si+1Ah], al
                or      bl, bl
                jz      short loc_5E37
                jmp     short loc_5E26
; ---------------------------------------------------------------------------

loc_5E11:                               ; ...
                push    es
                les     ax, es:[di+7]
                mov     [si+1Ah], ax
                mov     word ptr [si+1Ch], es
                pop     es
                mov     bl, 40h ; '@'
                jmp     short loc_5DFE
; ---------------------------------------------------------------------------

loc_5E21:                               ; ...
                call    ss:ShSave

loc_5E26:                               ; ...
                lea     ax, [di-6]
                sub     ax, word ptr ss:SFTFCB
                push    bx
                mov     bl, 3Bh ; ';'
                div     bl
                mov     [si+18h], al
                pop     bx

loc_5E37:                               ; ...
                mov     ax, es:[di+5]
                and     al, 3Fh
                or      al, bl
                mov     [si+19h], al
                mov     ax, ss:FCBLRU
                inc     ax
                mov     es:[di+15h], ax
                jnz     short loc_5E53
                mov     bx, 15h
                call    sub_5E58

loc_5E53:                               ; ...
                mov     ss:FCBLRU, ax
                retn
sub_5DAE        endp


; =============== S U B R O U T I N E =======================================


sub_5E58        proc near               ; ...
                mov     ax, 8000h
                push    es
                push    di
                les     di, ss:SFTFCB
                mov     cx, es:[di+4]
                lea     di, [di+6]

loc_5E69:                               ; ...
                sub     es:[bx+di], ax
                ja      short loc_5E71
                mov     es:[bx+di], ax

loc_5E71:                               ; ...
                add     di, 3Bh ; ';'
                loop    loc_5E69
                pop     di
                pop     es
                mov     es:[bx+di], ax
                retn
sub_5E58        endp


; =============== S U B R O U T I N E =======================================


sub_5E7C        proc near               ; ...
                push    es
                call    save_world
                mov     ds, cs:DosDSeg
                or      al, al
                jnz     short loc_5E9F
                les     di, ds:0F76h
                mov     cx, es
                or      cx, di
                jz      short loc_5E9F

loc_5E93:                               ; ...
                mov     ds:59Eh, di
                mov     word ptr ds:5A0h, es
                clc
                jmp     loc_5F49
; ---------------------------------------------------------------------------

loc_5E9F:                               ; ...
                les     di, ds:40h
                mov     cx, es:[di+4]
                lea     di, [di+6]
                mov     bx, 0FFFFh
                mov     si, bx
                mov     dx, bx
                mov     bp, bx

loc_5EB3:                               ; ...
                or      word ptr es:[di], 0
                jz      short loc_5F06
                cmp     word ptr es:[di], 0FFFFh
                jz      short loc_5F06
                test    word ptr es:[di+5], 8000h
                jnz     short loc_5EF8
                call    CheckShare
                jnz     short loc_5EF8

loc_5ECC:                               ; ...
                mov     ds:0F76h, di
                mov     word ptr ds:0F78h, es
                or      al, al
                jz      short loc_5E93
                cmp     es:[di+15h], bx
                jnb     short loc_5EE4
                mov     bx, es:[di+15h]
                mov     si, di

loc_5EE4:                               ; ...
                add     di, 3Bh ; ';'
                loop    loc_5EB3
                dec     cx
                mov     di, si
                cmp     si, cx
                jnz     short loc_5F06
                mov     di, bp
                cmp     bp, cx
                jnz     short loc_5F23
                jmp     short loc_5F46
; ---------------------------------------------------------------------------

loc_5EF8:                               ; ...
                cmp     es:[di+15h], dx
                jnb     short loc_5EE4
                mov     dx, es:[di+15h]
                mov     bp, di
                jmp     short loc_5EE4
; ---------------------------------------------------------------------------

loc_5F06:                               ; ...
                or      al, al
                jz      short loc_5ECC
                mov     ax, es
                cmp     ds:0F76h, di
                jnz     short loc_5F20
                cmp     ds:0F78h, ax
                jnz     short loc_5F20
                xor     ax, ax
                mov     ds:0F76h, ax
                mov     ds:0F78h, ax

loc_5F20:                               ; ...
                jmp     loc_5E93
; ---------------------------------------------------------------------------

loc_5F23:                               ; ...
                or      al, al
                jnz     short loc_5F2F
                mov     ds:0F76h, di
                mov     word ptr ds:0F78h, es

loc_5F2F:                               ; ...
                mov     ds:59Eh, di
                mov     word ptr ds:5A0h, es

loc_5F37:                               ; ...
                cmp     word ptr es:[di], 0
                jz      short loc_5F49
                call    DOS_CLOSE
                jnb     short loc_5F37
                cmp     al, 6
                jz      short loc_5F37

loc_5F46:                               ; ...
                stc
                jmp     short loc_5F4E
; ---------------------------------------------------------------------------

loc_5F49:                               ; ...
                xor     al, al
                call    BlastSFT

loc_5F4E:                               ; ...
                call    restore_world
                pop     es
                mov     es, cs:DosDSeg
                les     di, es:59Eh
                jb      short loc_5F5F
                retn
; ---------------------------------------------------------------------------

loc_5F5F:                               ; ...
                mov     al, 23h ; '#'
                retn
sub_5E7C        endp


; =============== S U B R O U T I N E =======================================


sub_5F62        proc near               ; ...
                lodsb
                call    UCase
                stosb
                loop    sub_5F62
                retn
sub_5F62        endp


; =============== S U B R O U T I N E =======================================


sub_5F6A        proc near               ; ...

; FUNCTION CHUNK AT 5FFB SIZE 0000006A BYTES

                mov     al, [si+19h]
                test    al, 80h
                jz      short loc_5F8D
                call    CheckShare
                jnz     short loc_5F7F
                mov     ax, 1100h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - INSTALLATION CHECK
                                        ; Return: AL = 00h  not installed, OK to install
                                        ; 01h  not installed, not OK to install
                                        ; FFh  installed
                or      al, al
                jz      short loc_5F8B

loc_5F7F:                               ; ...
                mov     ax, ss:USER_IN_AX
                cmp     ah, 10h
                jz      short loc_5F8B
                call    sub_6122

loc_5F8B:                               ; ...
                stc

locret_5F8C:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_5F8D:                               ; ...
                call    CheckShare
                jnz     short loc_5F7F
                push    ax
                mov     al, 0
                call    sub_5E7C
                pop     ax
                jb      short locret_5F8C
                mov     word ptr es:[di+2], 8002h
                and     al, 3Fh
                cbw
                or      ax, 4000h
                mov     cl, [si+1Ah]
                mov     ch, cl
                and     ch, 0C0h
                or      al, ch
                and     cl, 0Fh
                mov     es:[di+2], cl
                mov     es:[di+5], ax
                mov     ax, ss:PROC_ID
                mov     es:[di+31h], ax
                push    ds
                push    si
                push    es
                push    di
                push    ss
                pop     es
                assume es:DOSCODE
                mov     di, 54Bh
                mov     cx, 8
                inc     si
                call    sub_5F62
                push    ss
                pop     ds
                assume ds:DOSCODE
                mov     ATTRIB, 16h
                call    DEVNAME
                pop     di
                pop     es
                assume es:nothing
                pop     si
                pop     ds
                assume ds:nothing
                jb      short loc_5FFD
                mov     es:[di+5], bh
                mov     byte ptr es:[di+4], 0
                lds     si, ss:DEVPT
sub_5F6A        endp


; =============== S U B R O U T I N E =======================================


sub_5FF2        proc near               ; ...
                mov     es:[di+7], si
                mov     word ptr es:[di+9], ds
                retn
sub_5FF2        endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR sub_5F6A

loc_5FFB:                               ; ...
                jmp     short loc_5F8B
; ---------------------------------------------------------------------------

loc_5FFD:                               ; ...
                mov     ax, es:[di+5]
                and     ax, 3Fh
                push    ds
                push    si
                call    sub_BC7C
                call    sub_5FF2
                pop     si
                pop     ds
                jb      short loc_5FFB
                mov     ax, [si+1Dh]
                mov     es:[di+1Bh], ax
                mov     al, [si+18h]
                and     al, 0C0h
                mov     ah, al
                rol     ah, 1
                shr     al, 1
                or      al, ah
                and     al, 3Fh
                mov     es:[di+4], al
                mov     al, [si+18h]
                and     al, 3Fh
                sub     ah, ah
                mov     es:[di+1Dh], ax
                mov     ax, [si+1Bh]
                mov     es:[di+2Bh], ax
                mov     es:[di+35h], ax
                xor     ax, ax
                mov     es:[di+2Dh], ax
                mov     es:[di+37h], ax
                mov     al, [si+1Fh]
                mov     es:[di+1Fh], al
                inc     word ptr es:[di]
                call    sub_8A90
                lea     si, [si+1]
                lea     di, [di+20h]
                mov     cx, 0Bh
                call    sub_5F62
                clc
                retn
; END OF FUNCTION CHUNK FOR sub_5F6A

; =============== S U B R O U T I N E =======================================


BlastSFT        proc near               ; ...
                call    SFT_FREE
                push    di
                mov     cx, 59          ; SF_ENTRY.size
                rep stosb
                pop     di
                sub     ax, ax          ; 0
                mov     es:[di], ax     ; word [ES:DI+SF_ENTRY.sf_ref_count],0
                mov     es:[di+15h], ax ; word [ES:DI+SF_ENTRY.sf_position],0
                dec     ax
                mov     es:[di+17h], ax ; word [ES:DI+SF_ENTRY.sf_position+2],0
                retn
BlastSFT        endp


; =============== S U B R O U T I N E =======================================


sub_607E        proc near               ; ...
                test    byte ptr [si+19h], 0C0h
                jz      short loc_60CC
                les     di, ss:SFTFCB
                cmp     es:[di+4], al
                jb      short loc_60CC
                mov     bl, 3Bh ; ';'
                mul     bl
                lea     di, [di+6]
                add     di, ax
                mov     ax, ss:PROC_ID
                cmp     es:[di+31h], ax
                jnz     short loc_60CC
                cmp     word ptr es:[di], 0
                jz      short loc_60CC
                mov     al, [si+19h]
                test    al, 80h
                jz      short loc_60D8
                push    ax
                and     al, 0C0h
                cmp     al, 0C0h
                pop     ax
                jnz     short loc_60CE
                call    ss:ShChk
                jb      short loc_60CC

loc_60BE:                               ; ...
                and     al, 3Fh
                mov     ah, es:[di+5]
                and     ah, 3Fh
                cmp     ah, al
                jnz     short loc_60CC

locret_60CB:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_60CC:                               ; ...
                stc
                retn
; ---------------------------------------------------------------------------

loc_60CE:                               ; ...
                mov     ax, [si+1Ch]
                cmp     ax, es:[di+0Bh]
                jnz     short loc_60CC
                retn
; ---------------------------------------------------------------------------

loc_60D8:                               ; ...
                mov     bx, [si+1Ah]
                cmp     bx, es:[di+7]
                jnz     short loc_60CC
                mov     bx, [si+1Ch]
                cmp     bx, es:[di+9]
                jnz     short loc_60CC
                jmp     short loc_60BE
sub_607E        endp


; =============== S U B R O U T I N E =======================================


SFTFromFCB      proc near               ; ...
                push    ax
                push    bx
                mov     al, [si+18h]
                call    sub_607E
                pop     bx
                pop     ax
                mov     word ptr ss:THISSFT, di
                mov     word ptr ss:THISSFT+2, es
                jnb     short loc_6113
                push    es
                call    save_world
                call    sub_5F6A
                call    restore_world
                pop     es
                mov     ax, ss:EXTERR
                jb      short locret_60CB

loc_6113:                               ; ...
                les     di, ss:THISSFT
                push    ss:PROC_ID
                pop     word ptr es:[di+31h]
                retn
SFTFromFCB      endp


; =============== S U B R O U T I N E =======================================


sub_6122        proc near               ; ...
                mov     es, cs:DosDSeg
                mov     ax, 23h ; '#'
                mov     byte ptr es:34Bh, 8
                les     bp, es:58Ah
                mov     di, 1
                mov     cx, di
                xor     dx, dx
                cmp     es:[bp+0Fh], dx
                jz      short loc_614D
                mov     es:607h, dx
                mov     dx, es:[bp+0Bh]
                jmp     short loc_615A
; ---------------------------------------------------------------------------

loc_614D:                               ; ...
                mov     dx, es:[bp+2Bh]
                mov     es:607h, dx
                mov     dx, es:[bp+29h]

loc_615A:                               ; ...
                call    HARDERR
                stc
                retn
sub_6122        endp


; =============== S U B R O U T I N E =======================================


sub_615F        proc near               ; ...
                mov     ax, [si+21h]
                mov     dx, [si+23h]
                cmp     bx, 40h ; '@'
                jb      short nullsub_18
sub_615F        endp

; START OF FUNCTION CHUNK FOR GetExtent

loc_616A:                               ; ...
                xor     dh, dh
; END OF FUNCTION CHUNK FOR GetExtent
; [00000001 BYTES: COLLAPSED FUNCTION nullsub_18. PRESS CTRL-NUMPAD+ TO EXPAND]

; =============== S U B R O U T I N E =======================================


GetExtent       proc near               ; ...

; FUNCTION CHUNK AT 616A SIZE 00000002 BYTES

                mov     al, [si+20h]
                mov     dx, [si+0Ch]
                shl     al, 1
                shr     dx, 1
                rcr     al, 1
                mov     ah, dl
                mov     dl, dh
                jmp     short loc_616A
GetExtent       endp


; =============== S U B R O U T I N E =======================================


sub_617F        proc near               ; ...
                push    ax
                push    dx
                mov     cx, ax
                and     al, 7Fh
                mov     [si+20h], al
                and     cl, 80h
                shl     cx, 1
                rcl     dx, 1
                mov     al, ch
                mov     ah, dl
                mov     [si+0Ch], ax
                pop     dx
                pop     ax
                retn
sub_617F        endp


; =============== S U B R O U T I N E =======================================


GetExtended     proc near               ; ...
                mov     si, dx
                cmp     byte ptr [si], 0FFh
                jnz     short loc_61A3
                add     si, 7

loc_61A3:                               ; ...
                cmp     si, dx

locret_61A5:                            ; ...
                retn
GetExtended     endp


; =============== S U B R O U T I N E =======================================


sub_61A6        proc near               ; ...
                mov     bx, [si+0Eh]
                or      bx, bx
                jnz     short locret_61A5
                mov     bl, 80h
                mov     [si+0Eh], bx
                retn
sub_61A6        endp

; ---------------------------------------------------------------------------

$FCB_RANDOM_WRITE_BLOCK:                ; ...
                mov     al, 0Ah
                jmp     short loc_61C9
; ---------------------------------------------------------------------------

$FCB_RANDOM_READ_BLOCK:                 ; ...
                mov     al, 0Eh
                jmp     short loc_61C9
; ---------------------------------------------------------------------------

$FCB_SEQ_READ:                          ; ...
                mov     al, 4
                jmp     short loc_61C9
; ---------------------------------------------------------------------------

$FCB_SEQ_WRITE:                         ; ...
                mov     al, 0
                jmp     short loc_61C9
; ---------------------------------------------------------------------------

$FCB_RANDOM_READ:                       ; ...
                mov     al, 6
                jmp     short loc_61C9
; ---------------------------------------------------------------------------

$FCB_RANDOM_WRITE:                      ; ...
                mov     al, 2

loc_61C9:                               ; ...
                push    bp
                mov     bp, sp
                sub     sp, 14h
                mov     [bp-14h], al
                mov     byte ptr [bp-1], 0
                call    GetExtended
                test    byte ptr [bp-14h], 8
                jnz     short loc_61E2
                mov     cx, 1

loc_61E2:                               ; ...
                mov     [bp-3], cx
                call    GetExtent
                call    sub_61A6
                mov     [bp-9], bx
                test    byte ptr [bp-14h], 2
                jz      short loc_61F7
                call    sub_615F

loc_61F7:                               ; ...
                mov     [bp-7], ax
                mov     [bp-5], dx
                call    sub_617F
                mov     ax, [bp-5]
                mul     bx
                mov     di, ax
                mov     ax, [bp-7]
                mul     bx
                add     dx, di
                mov     [bp-0Dh], ax
                mov     [bp-0Bh], dx
                mov     ax, [bp-3]
                mul     bx
                mov     [bp-0Fh], ax
                add     ax, word ptr ss:DMAADD
                adc     dx, 0
                jz      short loc_623F
                mov     byte ptr [bp-1], 2
                mov     ax, word ptr ss:DMAADD
                neg     ax
                jnz     short loc_6233
                dec     ax

loc_6233:                               ; ...
                xor     dx, dx
                div     bx
                mov     [bp-3], ax
                mul     bx
                mov     [bp-0Fh], ax

loc_623F:                               ; ...
                xor     bx, bx
                mov     [bp-11h], bx
                cmp     [bp-0Fh], bx
                jnz     short loc_6251
                test    byte ptr [bp-1], 2
                jz      short loc_6251
                jmp     short loc_62BF
; ---------------------------------------------------------------------------

loc_6251:                               ; ...
                call    SFTFromFCB
                jnb     short loc_6265

loc_6256:                               ; ...
                call    FCB_RET_ERR
                mov     word ptr [bp-13h], 0
                mov     byte ptr [bp-1], 1
                jmp     loc_634C
; ---------------------------------------------------------------------------

loc_6265:                               ; ...
                push    ds
                lds     ax, [si+10h]
                mov     es:[di+11h], ax
                mov     word ptr es:[di+13h], ds
                lds     ax, [bp-0Dh]
                mov     dx, ds
                pop     ds
                mov     es:[di+15h], ax
                xchg    dx, es:[di+17h]
                push    dx
                mov     cx, [bp-0Fh]
                mov     di, 7B76h
                test    byte ptr [bp-14h], 4
                jnz     short loc_628F
                mov     di, 7D8Fh

loc_628F:                               ; ...
                push    bp
                push    ds
                push    si
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    di ; DOS_READ
                pop     si
                pop     ds
                assume ds:nothing
                pop     bp
                jb      short loc_6256
                cmp     ss:DISK_FULL, 0
                jz      short loc_62A9
                mov     ss:DISK_FULL, 0

loc_62A9:                               ; ...
                mov     [bp-11h], cx
                call    sub_5DAE
                pop     word ptr es:[di+17h]
                push    es
                les     ax, es:[di+11h]
                mov     [si+10h], ax
                mov     word ptr [si+12h], es
                pop     es

loc_62BF:                               ; ...
                mov     ax, [bp-11h]
                xor     dx, dx
                div     word ptr [bp-9]
                mov     [bp-13h], ax
                add     [bp-7], ax
                adc     word ptr [bp-5], 0
                cmp     ax, [bp-3]
                jz      short loc_62E7
                test    byte ptr [bp-14h], 4
                jnz     short loc_62E3
                test    byte ptr es:[di+5], 80h
                jnz     short loc_62E7

loc_62E3:                               ; ...
                mov     byte ptr [bp-1], 1

loc_62E7:                               ; ...
                or      dx, dx
                jz      short loc_6311
                add     word ptr [bp-7], 1
                adc     word ptr [bp-5], 0
                test    byte ptr [bp-14h], 4
                jz      short loc_6311
                inc     word ptr [bp-13h]
                mov     byte ptr [bp-1], 3
                mov     cx, [bp-9]
                sub     cx, dx
                xor     al, al
                les     di, ss:DMAADD
                add     di, [bp-11h]
                rep stosb

loc_6311:                               ; ...
                mov     dx, [bp-5]
                mov     ax, [bp-7]
                test    byte ptr [bp-14h], 2
                jz      short loc_6323
                test    byte ptr [bp-14h], 8
                jz      short loc_6326

loc_6323:                               ; ...
                call    sub_617F

loc_6326:                               ; ...
                test    byte ptr [bp-14h], 8
                jz      short loc_633B
                mov     [si+21h], ax
                mov     [si+23h], dl
                cmp     word ptr [si+0Eh], 40h ; '@'
                jnb     short loc_633B
                mov     [si+24h], dh

loc_633B:                               ; ...
                test    byte ptr [bp-14h], 4
                jnz     short loc_634C
                push    ds
                call    DATE16
                pop     ds
                mov     [si+14h], ax
                mov     [si+16h], dx

loc_634C:                               ; ...
                test    byte ptr [bp-14h], 8
                jz      short loc_635B
                mov     cx, [bp-13h]
                call    Get_User_Stack
                mov     [si+4], cx

loc_635B:                               ; ...
                mov     al, [bp-1]
                mov     sp, bp
                pop     bp
                retn
; ---------------------------------------------------------------------------

$FCB_OPEN:                              ; ...
                mov     ax, 2
                mov     cx, 71BBh

loc_6368:                               ; ...
                push    ds
                push    dx
                push    cx
                push    ax
                mov     di, 3BEh
                call    TransFCB
                pop     ax
                pop     cx
                pop     dx
                pop     ds
                jnb     short loc_637B

loc_6378:                               ; ...
                jmp     FCB_RET_ERR
; ---------------------------------------------------------------------------

loc_637B:                               ; ...
                call    GetExtended
                push    ax
                mov     al, 1
                call    sub_5E7C
                pop     ax
                jb      short loc_63B1
                mov     word ptr es:[di+2], 8000h
                push    ds
                push    si
                push    bx
                mov     si, cx
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    si
                pop     bx
                pop     si
                pop     ds
                assume ds:nothing
                les     di, ss:THISSFT
                jnb     short loc_63B8

loc_63A0:                               ; ...
                push    ax
                mov     al, 52h ; 'R'
                call    BlastSFT
                pop     ax
                cmp     ax, 4
                jz      short loc_63B1
                cmp     ax, 24h ; '$'
                jnz     short loc_63B6

loc_63B1:                               ; ...
                push    ax
                call    sub_6122
                pop     ax

loc_63B6:                               ; ...
                jmp     short loc_6378
; ---------------------------------------------------------------------------

loc_63B8:                               ; ...
                call    IsSFTNet
                jnz     short loc_63EE
                call    CheckShare
                jnz     short loc_63CC
                mov     word ptr ss:LocalSFT, di
                mov     word ptr ss:LocalSFT+2, es

loc_63CC:                               ; ...
                test    byte ptr es:[di+5], 80h
                jnz     short loc_63EE
                test    byte ptr es:[di+4], 8
                jnz     short loc_63EE
                push    es
                push    di
                les     di, es:[di+7]
                cmp     word ptr es:[di+0Fh], 0
                pop     di
                pop     es
                jnz     short loc_63EE
                mov     ax, 0Fh
                jmp     short loc_63A0
; ---------------------------------------------------------------------------

loc_63EE:                               ; ...
                inc     word ptr es:[di]
                call    sub_8A90
                call    sub_5DAE
                test    byte ptr es:[di+5], 80h
                jnz     short loc_6407
                mov     al, [si]
                call    GETTHISDRV
                inc     al
                mov     [si], al

loc_6407:                               ; ...
                mov     word ptr [si+0Eh], 80h
                push    es
                les     ax, es:[di+0Dh]
                mov     [si+16h], ax
                mov     word ptr [si+14h], es
                pop     es
                push    es
                les     ax, es:[di+11h]
                mov     [si+10h], ax
                mov     word ptr [si+12h], es
                pop     es
                xor     ax, ax
                mov     [si+0Ch], ax
                les     di, ss:SFTFCB
                mov     ah, es:[di+4]

loc_6432:                               ; ...
                cmp     al, [si+18h]
                jz      short loc_643E
                push    ax
                call    sub_607E
                pop     ax
                jnb     short loc_6447

loc_643E:                               ; ...
                inc     al
                cmp     al, ah
                jnz     short loc_6432

loc_6444:                               ; ...
                xor     al, al
                retn
; ---------------------------------------------------------------------------

loc_6447:                               ; ...
                mov     [si+18h], al
                inc     word ptr es:[di]
                call    sub_8A90
                mov     ax, ss:FCBLRU
                mov     es:[di+15h], ax
                push    ss
                pop     ds
                assume ds:DOSCODE
                les     di, THISSFT
                dec     word ptr es:[di]
                call    ShareEnd
                mov     al, 43h ; 'C'
                call    BlastSFT
                jmp     short loc_6444
; ---------------------------------------------------------------------------

$FCB_CREATE:                            ; ...
                mov     cx, offset DOS_CREATE
                xor     ax, ax
                call    GetExtended
                jz      short loc_6478
                mov     al, [si-1]

loc_6478:                               ; ...
                jmp     loc_6368
; ---------------------------------------------------------------------------

$DIR_SEARCH_FIRST:                      ; ...
                mov     word ptr ss:THISFC, dx
                mov     word ptr ss:THISFC+2, ds
                mov     si, dx
                cmp     byte ptr [si], 0FFh
                jnz     short loc_648F
                add     si, 7

loc_648F:                               ; ...
                push    word ptr [si]
                mov     di, ss
                mov     es, di
                assume es:DOSCODE
                mov     di, 3BEh
                call    TransFCB
                jnb     short loc_64A1
                pop     bx

loc_649E:                               ; ...
                jmp     FCB_RET_ERR
; ---------------------------------------------------------------------------

loc_64A1:                               ; ...
                mov     di, ss
                mov     ds, di
                les     di, DMAADD
                assume es:nothing
                push    di
                push    es
                mov     word ptr DMAADD, offset SEARCHBUF
                mov     word ptr DMAADD+2, ds
                or      DOS34_FLAG, 400h
                call    DOS_SEARCH_FIRST
                pop     word ptr DMAADD+2
                pop     word ptr DMAADD
                jnb     short loc_64CB
                pop     bx
                jmp     short loc_649E
; ---------------------------------------------------------------------------

loc_64CB:                               ; ...
                mov     si, offset SEARCHBUF
                les     di, THISFC
                test    EXTFCB, 0FFh
                jz      short loc_64DC
                add     di, 7

loc_64DC:                               ; ...
                pop     bx
                or      bl, bl
                jnz     short loc_64E7
                mov     bl, CURDRV
                inc     bl

loc_64E7:                               ; ...
                lodsb
                xchg    al, bl
                inc     di
                mov     cx, 0Ah
                rep movsw
                xchg    al, bl
                stosb
                les     di, DMAADD
                test    EXTFCB, 0FFh
                jz      short loc_650C
                mov     al, 0FFh
                stosb
                inc     al
                mov     ah, al
                stosb
                stosw
                stosw
                mov     al, SATTRIB
                stosb

loc_650C:                               ; ...
                mov     al, bl
                stosb
                mov     cx, 10h
                rep movsw
                jmp     NO_OP
; ---------------------------------------------------------------------------

$DIR_SEARCH_NEXT:                       ; ...
                mov     word ptr ss:THISFC, dx
                mov     word ptr ss:THISFC+2, ds
                mov     al, 0
                mov     ss:SATTRIB, al
                mov     ss:EXTFCB, al
                mov     di, ss
                mov     es, di
                assume es:DOSCODE
                mov     di, 4BEh
                mov     si, dx
                cmp     byte ptr [si], 0FFh
                jnz     short loc_6546
                add     si, 6
                lodsb
                mov     ss:SATTRIB, al
                dec     ss:EXTFCB

loc_6546:                               ; ...
                lodsb
                push    ax
                mov     al, [si+14h]
                stosb
                mov     cx, 0Ah
                rep movsw
                mov     di, ss
                mov     ds, di
                les     di, DMAADD
                assume es:nothing
                push    di
                push    es
                mov     di, 4BEh
                mov     word ptr DMAADD, di
                mov     word ptr DMAADD+2, ds
                mov     ax, ds
                mov     es, ax
                assume es:DOSCODE
                call    DOS_SEARCH_NEXT
                pop     word ptr DMAADD+2
                pop     word ptr DMAADD
                jb      short loc_657A
                jmp     loc_64CB
; ---------------------------------------------------------------------------

loc_657A:                               ; ...
                les     di, THISFC
                assume es:nothing
                test    EXTFCB, 0FFh
                jz      short loc_6588
                add     di, 7

loc_6588:                               ; ...
                pop     bx
                mov     es:[di], bl
                jmp     FCB_RET_ERR
; ---------------------------------------------------------------------------

loc_658F:                               ; ...
                mov     al, 3

loc_6591:                               ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

$FIND_FIRST:                            ; ...
                mov     si, dx
                mov     ss:SATTRIB, cl
                mov     di, offset OPENBUF
                call    TransPathSet
                jb      short loc_658F
                mov     di, ss
                mov     ds, di
                les     di, DMAADD
                push    di
                push    es
                mov     word ptr DMAADD, offset SEARCHBUF
                mov     word ptr DMAADD+2, ds
                or      DOS34_FLAG, 400h
                call    DOS_SEARCH_FIRST
                pop     word ptr DMAADD+2
                pop     word ptr DMAADD
                jb      short loc_6591

FindSet:                                ; ...
                mov     si, 4BEh
                les     di, DMAADD
                mov     cx, 0Ah
                rep movsw
                movsb
                push    si
                mov     al, [si+0Bh]
                stosb
                add     si, 16h
                movsw
                movsw
                inc     si
                inc     si
                movsw
                movsw
                pop     si
                call    PackName
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

$FIND_NEXT:                             ; ...
                mov     di, ss
                mov     es, di
                assume es:DOSCODE
                mov     di, offset SEARCHBUF
                lds     si, ss:DMAADD
                assume ds:nothing
                mov     cx, 10
                rep movsw
                movsb
                mov     di, ss
                mov     ds, di
                assume ds:DOSCODE
                les     di, DMAADD
                assume es:nothing
                push    di
                push    es
                mov     di, offset SEARCHBUF
                mov     word ptr DMAADD, di
                mov     word ptr DMAADD+2, ds
                mov     ax, ds
                mov     es, ax
                assume es:DOSCODE
                call    DOS_SEARCH_NEXT
                pop     word ptr DMAADD+2
                pop     word ptr DMAADD
                jnb     short FindSet
                jmp     SYS_RET_ERR

; =============== S U B R O U T I N E =======================================


PackName        proc near               ; ...
                mov     cx, 4
                rep movsw

loc_662C:                               ; ...
                cmp     byte ptr es:[di-1], 20h ; ' '
                jnz     short loc_663A
                dec     di
                inc     cx
                cmp     cx, 8
                jb      short loc_662C

loc_663A:                               ; ...
                cmp     word ptr [si], 2020h
                jnz     short loc_6646
                cmp     byte ptr [si+2], 20h ; ' '
                jz      short loc_6655

loc_6646:                               ; ...
                mov     al, 2Eh ; '.'
                stosb
                movsw
                movsb

loc_664B:                               ; ...
                cmp     byte ptr es:[di-1], 20h ; ' '
                jnz     short loc_6655
                dec     di
                jmp     short loc_664B
; ---------------------------------------------------------------------------

loc_6655:                               ; ...
                xor     ax, ax
                stosb
                retn
PackName        endp

; ---------------------------------------------------------------------------
                or      ss:DOS34_FLAG, 400h
                call    DOS_SEARCH_FIRST
                retn
; ---------------------------------------------------------------------------

$CURRENT_DIR:                           ; ...
                call    ECritDisk
                mov     al, dl
                call    GetVisDrv
                jnb     short CurrentValidate

CurdirErr:                              ; ...
                call    LCritDisk
                push    ds
                mov     ds, cs:DosDSeg
                assume ds:nothing
                mov     al, ds:DrvErr
                pop     ds

curdir_errj:                            ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

CurrentValidate:                        ; ...
                push    ds
                push    si
                mov     ds, cs:DosDSeg
                mov     ds:NoSetDir, 0
                mov     di, offset OPENBUF
                call    ValidateCDS
                push    es
                push    di
                pop     si
                pop     ds
                pop     di
                pop     es
                assume es:nothing
                jb      short CurdirErr
                add     si, [si+4Fh]
                cmp     byte ptr [si], 5Ch ; '\'
                jnz     short loc_66A1
                inc     si

loc_66A1:                               ; ...
                push    ax
                lodsb
                or      al, al
                jz      short loc_66BA
                cmp     al, 5
                jz      short loc_66B8
                jmp     short loc_66AE
; ---------------------------------------------------------------------------

loc_66AD:                               ; ...
                lodsb

loc_66AE:                               ; ...
                cmp     al, 5Ch ; '\'
                jnz     short loc_66BA
                stosb
                lodsb
                cmp     al, 5
                jnz     short loc_66BA

loc_66B8:                               ; ...
                mov     al, 0E5h

loc_66BA:                               ; ...
                stosb
                or      al, al
                jnz     short loc_66AD
                pop     ax
                xor     al, al
                call    LCritDisk
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

$RMDIR:                                 ; ...
                push    dx
                push    ds
                mov     si, dx
                mov     di, offset OPENBUF
                push    di
                call    TransPathNoSet
                pop     di
                jnb     short rmlset
                pop     ds
                pop     dx
                mov     al, 3

rmdir_chdir_errj:                       ; ...
                jmp     short curdir_errj
; ---------------------------------------------------------------------------

rmlset:                                 ; ...
                cmp     ss:CMETA, 0FFh
                jnz     short rmerr
                push    ss
                pop     es
                assume es:DOSCODE
                xor     al, al

rmloop:                                 ; ...
                call    GetCDSFromDrv
                jb      short rmcont
                test    word ptr [si+43h], 4000h ; [SI+curdir.flags],curdir_inuse
                jz      short rmdir_nxt
                call    StrCmp
                jz      short rmerr

rmdir_nxt:                              ; ...
                inc     al
                jmp     short rmloop
; ---------------------------------------------------------------------------

rmerr:                                  ; ...
                pop     ds
                pop     dx
                mov     al, 10h

rmdir_chdir_errj2:                      ; ...
                jmp     short rmdir_chdir_errj
; ---------------------------------------------------------------------------

rmcont:                                 ; ...
                pop     ds
                pop     dx
                mov     si, offset DOS_RMDIR
                call    TestNet
                mov     di, 43h ; 'C'
                jnb     short loc_6713
                mov     di, 80h

loc_6713:                               ; ...
                mov     ss:DIRSTRLEN, di
                jmp     loc_67BA
; ---------------------------------------------------------------------------

$CHDIR:                                 ; ...
                mov     ss:DIRSTRLEN, 67
                mov     di, offset OPENBUF
                mov     si, dx
                call    TransPath
                jnb     short ChDirCrack

ChDirErrP:                              ; ...
                mov     al, 3

chdir_errj:                             ; ...
                jmp     short rmdir_chdir_errj2
; ---------------------------------------------------------------------------

ChDirCrack:                             ; ...
                cmp     ds:CMETA, 0FFh
                jnz     short ChDirErrP
                les     di, ds:THISCDS
                assume es:nothing
                cmp     di, 0FFFFh
                jz      short ChDirErrP
                call    DOS_CHDIR
                jb      short chdir_errj
                les     di, ds:THISCDS
                test    word ptr es:[di+43h], 2000h
                mov     dx, ds:DIRSTART_HW
                jz      short GotCDS
                push    es
                push    di
                push    dx
                push    cx
                call    Get_User_Stack
                mov     di, [si+6]
                mov     ds, word ptr [si+0Eh]
                mov     si, offset OPENBUF
                xchg    si, di
                xor     al, al
                push    di
                call    TransPathNoSet
                pop     si
                les     di, ds:THISCDS
                mov     word ptr es:[di+49h], 0FFFFh
                mov     word ptr es:[di+4Bh], 0FFFFh
                pop     cx
                pop     dx
                pop     di
                pop     es

GotCDS:                                 ; ...
                call    Check_PathLen
                ja      short ChDirErrP
                test    word ptr es:[di+43h], 8000h
                jnz     short loc_67A8
                test    word ptr es:[di+43h], 2000h
                jz      short loc_679C
                mov     cx, 0FFFFh
                mov     dx, cx

loc_679C:                               ; ...
                mov     es:[di+49h], cx
                mov     es:[di+4Bh], dx
                les     di, ds:THISCDS

loc_67A8:                               ; ...
                call    FStrCpy
                xor     al, al

loc_67AD:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

$MKDIR:                                 ; ...
                mov     ss:DIRSTRLEN, 67

loc_67B7:                               ; ...
                mov     si, offset DOS_MKDIR

loc_67BA:                               ; ...
                mov     di, offset OPENBUF
                push    si
                mov     si, dx
                call    TransPath
                pop     si
                jnb     short MkDirCrack

loc_67C6:                               ; ...
                mov     al, 3

loc_67C8:                               ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

MkDirCrack:                             ; ...
                cmp     ss:CMETA, 0FFh
                jnz     short loc_67C6
                push    si
                call    Check_PathLen
                pop     si
                jbe     short loc_67DE
                mov     al, 5
                jmp     short loc_67C8
; ---------------------------------------------------------------------------

loc_67DE:                               ; ...
                call    si
                jb      short loc_67C8
                jmp     short loc_67AD

; =============== S U B R O U T I N E =======================================


Check_PathLen   proc near               ; ...
                mov     si, ss:WFP_START
Check_PathLen   endp


; =============== S U B R O U T I N E =======================================


Check_PathLen2  proc near               ; ...
                push    ss
                pop     ds
                assume ds:DOSCODE
                push    cx
                push    dx
                call    DStrLen
                pop     dx
                cmp     cx, DIRSTRLEN
                pop     cx
                retn
Check_PathLen2  endp

; ---------------------------------------------------------------------------
IOCTLJMPTABLE   dw offset ioctl_getset_data ; ...
                dw offset ioctl_getset_data ; 1
                dw offset ioctl_control_string ; 2
                dw offset ioctl_control_string
                dw offset ioctl_get_dev
                dw offset ioctl_get_dev ; 5
                dw offset ioctl_status
                dw offset ioctl_status
                dw offset ioctl_rem_media
                dw offset ioctl_drive_attr ; 9
                dw offset ioctl_handle_redir
                dw offset Set_Retry_Parameters
                dw offset GENERICIOCTLHANDLE ; 0Ch
                dw offset GENERICIOCTL  ; 0Dh
                dw offset ioctl_drive_owner
                dw offset ioctl_drive_owner
                dw offset GENERICIOCTLHANDLE ; query_handle_support
                dw offset GENERICIOCTL  ; query_device_support ; 11h

; =============== S U B R O U T I N E =======================================


$IOCTL          proc near               ; ...

; FUNCTION CHUNK AT 450E SIZE 0000001C BYTES
; FUNCTION CHUNK AT 6AC7 SIZE 0000004A BYTES

                mov     si, ds          ; Stash DS for calls 2,3,4 and 5
                push    ss
                pop     ds
                cmp     al, 11h         ; al must be between 0 & 11h
                ja      short ioctl_bad_funj2
                mov     di, ax
                and     di, 0FFh
                add     di, di
                jmp     cs:IOCTLJMPTABLE[di]
; ---------------------------------------------------------------------------

ioctl_bad_funj2:                        ; ...
                jmp     ioctl_bad_fun
; ---------------------------------------------------------------------------

ioctl_getset_data:                      ; ...
                call    SFFromHandle
                jnb     short loc_683D

loc_6838:                               ; ...
                mov     al, 6

loc_683A:                               ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

loc_683D:                               ; ...
                cmp     al, 0
                mov     al, es:[di+5]
                jz      short loc_685E
                or      dh, dh
                jz      short loc_684D
                mov     al, 0Dh
                jmp     short loc_683A
; ---------------------------------------------------------------------------

loc_684D:                               ; ...
                test    al, 80h
                jz      short ioctl_bad_funj2
                or      dl, 80h
                call    set_exerr_locus_ser
                mov     es:[di+5], dl

loc_685B:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

loc_685E:                               ; ...
                call    set_exerr_locus_disk
                xor     ah, ah
                test    al, 80h
                jz      short loc_6872
                call    set_exerr_locus_ser
                les     di, es:[di+7]
                mov     ah, es:[di+5]

loc_6872:                               ; ...
                mov     dx, ax
                call    Get_User_Stack
                mov     [si+6], dx

loc_687A:                               ; ...
                jmp     short loc_685B
; ---------------------------------------------------------------------------

ioctl_control_string:                   ; ...
                call    SFFromHandle
                jb      short loc_6838
                test    byte ptr es:[di+5], 80h

loc_6886:                               ; ...
                jz      short ioctl_bad_funj2
                call    set_exerr_locus_ser
                les     di, es:[di+7]
                xor     bl, bl
                jmp     loc_6A33
; ---------------------------------------------------------------------------

ioctl_status:                           ; ...
                mov     ah, 1
                sub     al, 6
                jz      short loc_689C
                mov     ah, 3

loc_689C:                               ; ...
                push    ax
                call    GET_IO_SFT
                pop     ax
                jnb     short loc_68A5

loc_68A3:                               ; ...
                jmp     short loc_6838
; ---------------------------------------------------------------------------

loc_68A5:                               ; ...
                call    IOFUNC
                mov     ah, al
                mov     al, 0FFh
                jnz     short loc_68B0
                inc     al

loc_68B0:                               ; ...
                jmp     short loc_687A
; ---------------------------------------------------------------------------

Set_Retry_Parameters:                   ; ...
                mov     RetryLoop, cx
                or      dx, dx
                jz      short loc_6886
                mov     RetryCount, dx
                jmp     short loc_68B0
; ---------------------------------------------------------------------------

GENERICIOCTLHANDLE:                     ; ...
                call    SFFromHandle
                jb      short loc_68A3
                test    byte ptr es:[di+6], 80h
                jnz     short loc_68E7
                call    set_exerr_locus_ser
                les     di, es:[di+7]
                mov     byte_3B1, 0FFh
                jmp     short loc_68F3
; ---------------------------------------------------------------------------

GENERICIOCTL:                           ; ...
                call    set_exerr_locus_disk
                cmp     ch, 48h ; 'H'
                jz      short loc_68EA
                cmp     ch, 8
                jz      short loc_68EA

loc_68E7:                               ; ...
                jmp     ioctl_bad_fun
; ---------------------------------------------------------------------------

loc_68EA:                               ; ...
                mov     byte_3B1, bl
                call    sub_6ABD
                jnz     short loc_68E7

loc_68F3:                               ; ...
                cmp     ch, 48h ; 'H'
                jz      short loc_68FD
                cmp     ch, 8
                jnz     short loc_6935

loc_68FD:                               ; ...
                cmp     cl, 6Ah ; 'j'
                jz      short loc_6907
                cmp     cl, 4Ah ; 'J'
                jnz     short loc_6935

loc_6907:                               ; ...
                cmp     cl, 4Ah ; 'J'
                jnz     short loc_6915
                cmp     bh, 4
                jz      short loc_6915
                or      bh, bh
                jnz     short ioctl_bad_fun

loc_6915:                               ; ...
                mov     bl, byte_3B1
                xor     bh, bh
                dec     bx
                cmp     bl, 1Ah
                jnb     short ioctl_bad_fun
                cmp     cl, 6Ah ; 'j'
                jnz     short loc_692D
                and     byte ptr [bx+1308h], 7Fh
                jmp     short loc_6932
; ---------------------------------------------------------------------------

loc_692D:                               ; ...
                or      byte ptr [bx+1308h], 80h

loc_6932:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

loc_6935:                               ; ...
                test    byte ptr es:[di+4], 40h
                jz      short ioctl_bad_fun
                mov     IOCALL_REQFUNC, 13h
                cmp     al, 10h
                jl      short loc_6951
                test    byte ptr es:[di+4], 80h
                jz      short ioctl_bad_fun
                mov     IOCALL_REQFUNC, 19h

loc_6951:                               ; ...
                push    es
                push    di
                mov     IOCALL, 17h
                mov     IOCALL_REQUNIT, bl
                mov     IOMED, ch
                mov     byte ptr IOXAD, cl
                mov     word ptr IOXAD+1, si
                mov     word ptr IOXAD+3, di
                mov     IOSCNT+1, dx
                mov     IOSSEC+1, si
                mov     bx, 37Ch
                push    ss
                pop     es
                assume es:DOSCODE
                pop     si
                pop     ds
                assume ds:nothing
                jmp     loc_6A6C
; ---------------------------------------------------------------------------

ioctl_bad_fun:                          ; ...
                mov     al, 1           ; error_invalid_function
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------
                jmp     loc_6838
; ---------------------------------------------------------------------------

ioctl_rem_media:                        ; ...
                call    sub_6ABD
                jnz     short ioctl_bad_fun
                test    byte ptr es:[di+5], 8
                jz      short ioctl_bad_fun
                mov     ss:IOCALL_REQFUNC, 0Fh
                mov     al, 0Dh
                mov     ah, bl
                mov     word ptr ss:IOCALL, ax
                xor     ax, ax
                mov     ss:IOCALL_REQSTAT, ax
                push    es
                pop     ds
                assume ds:DOSCODE
                mov     si, di
                push    ss
                pop     es
                mov     bx, 37Ch
                push    ds
                push    si
                call    DEVIOCALL2
                pop     si
                pop     ds
                assume ds:nothing
                mov     ax, ss:IOCALL_REQSTAT
                and     ah, 2
                mov     cl, 9
                shr     ax, cl

loc_69C1:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

ioctl_drive_attr:                       ; ...
                mov     al, bl
                call    GETTHISDRV
                jb      short loc_6A18
                call    sub_6A91
                jb      short loc_6A18
                mov     dx, 942h
                jnz     short loc_69D9
                mov     dx, es:[di+4]

loc_69D9:                               ; ...
                mov     bl, al
                les     di, ss:THISCDS
                assume es:nothing
                test    byte ptr es:[di+44h], 80h
                jz      short loc_69EA
                mov     dx, 1000h

loc_69EA:                               ; ...
                push    ss
                pop     ds
                assume ds:DOSCODE
                mov     si, offset OPENBUF
                add     bl, 41h ; 'A'
                mov     [si], bl
                mov     word ptr [si+1], 3Ah ; ':'
                mov     ax, 300h
                clc
                int     2Ah             ; Microsoft Networks - CHECK DIRECT I/O
                                        ; DS:SI -> ASCIZ disk device name (may be full path or only drive
                                        ; specifier--must include the colon)
                                        ; Return: CF clear if absolute disk access allowed
                jnb     short loc_6A05
                or      dx, 200h

loc_6A05:                               ; ...
                test    byte ptr es:[di+44h], 10h
                jz      short loc_6A10
                or      dx, 8000h

loc_6A10:                               ; ...
                call    Get_User_Stack
                mov     [si+6], dx

loc_6A16:                               ; ...
                jmp     short loc_69C1
; ---------------------------------------------------------------------------

loc_6A18:                               ; ...
                mov     al, 0Fh

loc_6A1A:                               ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

ioctl_handle_redir:                     ; ...
                call    SFFromHandle
                jnb     short loc_6A25
                jmp     loc_6838
; ---------------------------------------------------------------------------

loc_6A25:                               ; ...
                mov     dx, es:[di+5]
                jmp     short loc_6A10
; ---------------------------------------------------------------------------

loc_6A2B:                               ; ...
                jmp     ioctl_bad_fun
; ---------------------------------------------------------------------------

ioctl_get_dev:                          ; ...
                call    sub_6ABD
                jnz     short loc_6A2B

loc_6A33:                               ; ...
                test    byte ptr es:[di+5], 40h
                jz      short loc_6A2B
                mov     IOCALL_REQFUNC, 3
                test    al, 1
                jz      short loc_6A48
                mov     IOCALL_REQFUNC, 0Ch

loc_6A48:                               ; ...
                mov     al, 14h
                mov     ah, bl
                mov     word ptr IOCALL, ax
                xor     ax, ax
                mov     IOCALL_REQSTAT, ax
                mov     IOMED, al
                mov     IOSCNT, cx
                mov     word ptr IOXAD, dx
                mov     word ptr IOXAD+2, si
                push    es
                pop     ds
                assume ds:nothing
                mov     si, di
                push    ss
                pop     es
                assume es:DOSCODE
                mov     bx, offset IOCALL

loc_6A6C:                               ; ...
                call    DEVIOCALL2
                test    byte ptr ss:IOCALL_REQSTAT+1, 80h
                jnz     short loc_6A7D
                mov     ax, ss:IOSCNT
                jmp     short loc_6A16
; ---------------------------------------------------------------------------

loc_6A7D:                               ; ...
                mov     di, ss:IOCALL_REQSTAT
                and     di, 0FFh
                mov     ax, di
                call    sub_A3E5
                mov     ax, ss:EXTERR
                jmp     short loc_6A1A
$IOCTL          endp


; =============== S U B R O U T I N E =======================================


sub_6A91        proc near               ; ...
                push    ax
                mov     al, bl
                call    GETTHISDRV
                jb      short loc_6ABB
                xor     bl, bl
                mov     ds:EXTERR_LOCUS, 3
                les     di, ds:THISCDS
                assume es:nothing
                test    byte ptr es:[di+44h], 80h
                les     di, es:[di+45h]
                jnz     short loc_6ABA
                call    set_exerr_locus_disk
                mov     bl, es:[di+1]
                les     di, es:[di+13h]

loc_6ABA:                               ; ...
                clc

loc_6ABB:                               ; ...
                pop     ax
                retn
sub_6A91        endp


; =============== S U B R O U T I N E =======================================


sub_6ABD        proc near               ; ...
                call    sub_6A91
                jb      short loc_6AC3
                retn
; ---------------------------------------------------------------------------

loc_6AC3:                               ; ...
                pop     ax
                jmp     loc_6A18
sub_6ABD        endp ; sp-analysis failed

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR $IOCTL

loc_6AC7:                               ; ...
                jmp     ioctl_bad_fun
; ---------------------------------------------------------------------------

loc_6ACA:                               ; ...
                jmp     short loc_6A7D
; ---------------------------------------------------------------------------

ioctl_drive_owner:                      ; ...
                call    sub_6ABD
                jnz     short loc_6AC7
                test    byte ptr es:[di+4], 40h
                jz      short loc_6AC7
                mov     byte ptr ds:37Eh, 17h
                cmp     al, 0Eh
                jz      short loc_6AE6
                mov     byte ptr ds:37Eh, 18h

loc_6AE6:                               ; ...
                mov     al, 0Dh
                mov     ah, bl
                mov     ds:37Ch, ax
                xor     ax, ax
                mov     ds:37Fh, ax
                push    es
                pop     ds
                mov     si, di
                push    ss
                pop     es
                assume es:DOSCODE
                mov     bx, 37Ch
                push    ds
                push    si
                call    DEVIOCALL2
                pop     si
                pop     ds
                test    byte ptr ss:IOCALL_REQSTAT+1, 80h
                jnz     short loc_6ACA
                mov     al, ss:IOCALL_REQUNIT
                jmp     SYS_RET_OK
; END OF FUNCTION CHUNK FOR $IOCTL

; =============== S U B R O U T I N E =======================================


DOS_DELETE      proc near               ; ...
                call    TestNet
                jnb     short loc_6B1C
                mov     ax, 1113h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
                                        ; SS = DS = DOS CS, SDA first filename pointer -> fully-qualified filename in DOS CS
                                        ; SDA CDS pointer -> current directory structure for drive with file
                                        ; Return: CF set on error
                retn
; ---------------------------------------------------------------------------

loc_6B1C:                               ; ...
                mov     ds:FOUNDDEL, 0
                call    ECritDisk
                mov     word ptr ds:CREATING, 0E500h
                mov     si, ds:WFP_START

loc_6B2E:                               ; ...
                lodsb
                or      al, al
                jnz     short loc_6B2E
                sub     si, 4
                cmp     word ptr [si], 2E2Ah
                jnz     short loc_6B42
                cmp     byte ptr [si+2], 2Ah ; '*'
                jz      short loc_6B61

loc_6B42:                               ; ...
                sub     si, 9
                xchg    di, si
                push    ss
                pop     es
                mov     ax, 3F3Fh
                mov     cx, 4
                repe scasw
                jnz     short loc_6B6F
                xchg    di, si
                lodsw
                cmp     ax, 3F2Eh
                jnz     short loc_6B6F
                lodsw
                cmp     ax, 3F3Fh
                jnz     short loc_6B6F

loc_6B61:                               ; ...
                mov     al, ds:SATTRIB
                and     al, 1Fh
                cmp     al, 1Fh
                jnz     short loc_6B6F
                mov     ds:DELALL, 0

loc_6B6F:                               ; ...
                mov     ds:NoSetDir, 1
                call    GetPathNoSet
                jnb     short loc_6B8B
                jnz     short loc_6B86
                or      cl, cl
                jz      short loc_6B86

loc_6B7F:                               ; ...
                mov     ax, 2

loc_6B82:                               ; ...
                stc
                jmp     No_Set_Flag
; ---------------------------------------------------------------------------

loc_6B86:                               ; ...
                mov     ax, 3
                jmp     short loc_6B82
; ---------------------------------------------------------------------------

loc_6B8B:                               ; ...
                jnz     short loc_6B99
                cmp     ds:DELALL, 0
                jz      short loc_6B99

loc_6B94:                               ; ...
                mov     ax, 5
                jmp     short loc_6B82
; ---------------------------------------------------------------------------

loc_6B99:                               ; ...
                or      ah, ah
                js      short loc_6B94

DELFILE:                                ; ...
                or      ds:FOUNDDEL, 1
                push    ds
                mov     ah, ds:DELALL
                lds     di, ds:CURBUF
                test    ss:ATTRIB, 1
                jnz     short DoDelete
                test    byte ptr [bx+0Bh], 1
                jz      short DoDelete

loc_6BB9:                               ; ...
                pop     ds
                jmp     short DELNXT
; ---------------------------------------------------------------------------

DoDelete:                               ; ...
                call    REN_DEL_Check
                jb      short loc_6BB9
                test    byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty
                jnz     short loc_6BCE
                call    INC_DIRTY_COUNT
                or      byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty

loc_6BCE:                               ; ...
                mov     [bx], ah
                xor     bx, bx
                cmp     es:[bp+0Fh], bx
                jnz     short loc_6BDB
                mov     bx, [si-6]

loc_6BDB:                               ; ...
                mov     ss:CLUSTNUM_HW, bx
                mov     bx, [si]
                pop     ds
                or      ds:FOUNDDEL, 10h ; FILEDELETED
                cmp     ds:CLUSTNUM_HW, 0
                jnz     short loc_6BF2
                cmp     bx, 2

loc_6BF2:                               ; ...
                jb      short DELNXT
                cmp     word ptr es:[bp+0Fh], 0
                jnz     short loc_6C0D
                push    bx
                mov     bx, ds:CLUSTNUM_HW
                cmp     bx, es:[bp+2Fh]
                pop     bx
                jnz     short loc_6C11
                cmp     bx, es:[bp+2Dh]
                jmp     short loc_6C11
; ---------------------------------------------------------------------------

loc_6C0D:                               ; ...
                cmp     bx, es:[bp+0Dh] ; [ES:BP+DPB.MAX_CLUSTER]

loc_6C11:                               ; ...
                ja      short DELNXT
                call    RELEASE
                jb      short No_fileJ
                call    FastOpen_Delete

DELNXT:                                 ; ...
                les     bp, ds:THISDPB
                assume es:nothing
                call    GETENTRY
                jb      short No_fileJ
                call    NEXTENT
                jb      short DELNXT2
                jmp     DELFILE
; ---------------------------------------------------------------------------

DELNXT2:                                ; ...
                les     bp, ds:THISDPB
                call    update_fat32_fsinfo
                mov     al, es:[bp+0]
                call    FLUSHBUF
                jb      short No_fileJ
                test    ds:FOUNDDEL, 10h ; FILEDELETE
                jz      short DelError
                test    ds:ATTRIB, 8    ; attr_volume_id
                jz      short No_Set_Flag
                push    ax
                push    es
                push    di
                les     di, ds:THISCDS
                xor     bh, bh
                mov     ah, es:[di]     ; Get drive
                sub     ah, 'A'         ; Convert to 0-based
                mov     ds:VOLCHNG_FLAG, ah
                call    Set_Media_ID
                call    FATREAD_CDS
                pop     di
                pop     es
                pop     ax

No_Set_Flag:                            ; ...
                call    LCritDisk
                retn
; ---------------------------------------------------------------------------

DelError:                               ; ...
                test    byte ptr ds:56Fh, 1
                jnz     short loc_6C74

No_fileJ:                               ; ...
                jmp     loc_6B7F
; ---------------------------------------------------------------------------

loc_6C74:                               ; ...
                jmp     loc_6B94
DOS_DELETE      endp


; =============== S U B R O U T I N E =======================================


REN_DEL_Check   proc near               ; ...
                push    ds
                push    di
                push    ax
                push    bx
                push    si
                push    ss
                pop     es
                assume es:DOSCODE
                mov     di, ss:WFP_START
                mov     si, bx
                mov     ds, word ptr ss:CURBUF+2
                assume ds:DOSCODE
                mov     bx, di
                inc     bx
                inc     bx
                call    StrLen
                dec     cx
                add     di, cx
                call    SkipBack
                inc     di
                mov     ss:SAVE_BX, di
                call    PackName
                pop     si
                pop     bx
                push    bx
                push    si
                push    ss
                pop     ds
                push    es
                push    di
                call    ShCloseFile
                cmp     fShare, 0FFh
                jnz     short rdc_1
                mov     word ptr THISSFT+2, es
                mov     word ptr THISSFT, di
                jmp     short rdc_2
; ---------------------------------------------------------------------------

rdc_1:                                  ; ...
                mov     word ptr THISSFT+2, ds
                mov     word ptr THISSFT, 765h ; AUXSTACK-SF_ENTRY.size

rdc_2:                                  ; ...
                pop     di
                pop     es
                assume es:nothing
                xor     ah, ah
                call    DOOPEN
                les     di, THISSFT
                mov     word ptr es:[di+2], 10h
                mov     word ptr es:[di], 1
                call    ShareEnter
                jb      short CheckDone
                les     di, THISSFT
                mov     word ptr es:[di], 0
                call    ShareEnd
                clc

CheckDone:                              ; ...
                les     bp, THISDPB
                pop     si
                pop     bx
                pop     ax
                pop     di
                pop     ds
                assume ds:nothing
                retn
REN_DEL_Check   endp


; =============== S U B R O U T I N E =======================================


FastOpen_Delete proc near               ; ...

; FUNCTION CHUNK AT 6D16 SIZE 0000000B BYTES

                pushf
                push    si
                push    di
                push    bx
                push    ax
                mov     si, ss:WFP_START
                mov     al, 3
                jmp     short fastinvoke
FastOpen_Delete endp

; ---------------------------------------------------------------------------

FastOpen_Rename:                        ; ...
                pushf
                push    si
                push    di
                push    bx
                push    ax
                mov     si, ss:REN_WFP
                mov     di, offset NAME1
                mov     al, 6
; START OF FUNCTION CHUNK FOR FastOpen_Update
;   ADDITIONAL PARENT FUNCTION FastOpen_Delete

fastinvoke:                             ; ...
                mov     bx, offset FastTable_2
                call    dword ptr [bx]
                pop     ax
                pop     bx
                pop     di
                pop     si
                popf
                retn
; END OF FUNCTION CHUNK FOR FastOpen_Update

; =============== S U B R O U T I N E =======================================


FastOpen_Update proc near               ; ...

; FUNCTION CHUNK AT 6D16 SIZE 0000000B BYTES

                pushf
                push    si
                push    di
                push    bx
                push    ax
                mov     al, 4
                jmp     short fastinvoke
FastOpen_Update endp


; =============== S U B R O U T I N E =======================================


Fast_Dispatch   proc near               ; ...
                mov     si, offset FastTable_2
                call    dword ptr ss:[si]
                retn
Fast_Dispatch   endp


; =============== S U B R O U T I N E =======================================


DOS_RENAME      proc near               ; ...
                call    TestNet
                jnb     short LOCAL_RENAME
                mov     ax, 1111h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
                                        ; SS = DS = DOS CS, SDA first filename pointer = offset of fully-qualified old name
                                        ; SDA CDS pointer -> current directory
                                        ; Return: CF set on error
                retn
; ---------------------------------------------------------------------------

LOCAL_RENAME:                           ; ...
                call    set_exerr_locus_disk
                mov     si, ds:WFP_START
                mov     di, ds:REN_WFP
                mov     al, [si]
                mov     ah, [di]
                or      ax, 2020h
                cmp     al, ah
                jz      short SAMEDRV
                mov     ax, 11h
                stc
                retn
; ---------------------------------------------------------------------------

SAMEDRV:                                ; ...
                push    word ptr ds:DMAADD+2
                push    word ptr ds:DMAADD
                mov     word ptr ds:DMAADD+2, ds
                mov     word ptr ds:DMAADD, offset RENAMEDMA
                mov     ds:FOUND_DEV, 0
                call    ECritDisk
                call    DOS_SEARCH_FIRST
                jnb     short Check_Dev
                cmp     ax, 12h         ; error_no_more_files
                jnz     short GOTERR
                mov     ax, 2           ; error_file_not_found

GOTERR:                                 ; ...
                stc

RENAME_POP:                             ; ...
                pop     word ptr ds:DMAADD
                pop     word ptr ds:DMAADD+2
                call    LCritDisk
                retn
; ---------------------------------------------------------------------------

Check_Dev:                              ; ...
                mov     ax, 5           ; error_access_denied
                push    ds
                lds     si, ds:DMAADD
                add     si, 21          ; find_buf.attr
                test    byte ptr [si+0Bh], 10h ; [SI+dir_entry.dir_attr],attr_directory
                jz      short notdir
                mov     si, ds:REN_WFP
                call    Check_PathLen2

notdir:                                 ; ...
                pop     ds
                ja      short GOTERR
                cmp     ds:FOUND_DEV, 0
                jnz     short GOTERR
                mov     si, bx
                add     si, 26          ; dir_entry.dir_first
                call    REN_DEL_Check
                jnb     short REN_OK1
                mov     ax, 20h         ; error_sharing_violation

RENAME_POPJ:                            ; ...
                jmp     short RENAME_POP
; ---------------------------------------------------------------------------

REN_OK1:                                ; ...
                lds     si, ds:DMAADD
                add     si, 15h
                test    byte ptr [si+0Bh], 10h
                jnz     short loc_6DCC
                call    FastOpen_Delete

loc_6DCC:                               ; ...
                mov     ax, ds:WFP_START
                mov     si, ds:REN_WFP
                mov     ds:WFP_START, si
                mov     ds:REN_WFP, ax
                mov     ds:CURR_DIR_END, 0FFFFh
                mov     word ptr ds:CREATING, 0E5FFh
                call    GetPathNoSet
                jb      short NODEST
                or      ah, ah
                jns     short SAVEDEST

BAD_ACC:                                ; ...
                mov     ax, 5           ; error_access_denied
                stc

RENAME_CLEAN:                           ; ...
                pushf
                push    ax
                les     bp, ds:THISDPB
                call    update_fat32_fsinfo
                mov     al, ds:THISDRV
                call    FLUSHBUF
                pop     ax
                cmp     ds:FAILERR, 0
                jnz     short BAD_ERR
                popf
                jmp     short RENAME_POPJ
; ---------------------------------------------------------------------------

BAD_ERR:                                ; ...
                pop     ax
                mov     ax, 3           ; error_path_not_foun
                jmp     GOTERR
; ---------------------------------------------------------------------------

NODEST:                                 ; ...
                jnz     short BAD_PATH
                cmp     ds:FAILERR, 0
                jnz     short BAD_PATH
                or      cl, cl
                jnz     short SAVEDEST

BAD_PATH:                               ; ...
                mov     ax, 3
                stc
                jmp     short RENAME_POPJ
; ---------------------------------------------------------------------------

SAVEDEST:                               ; ...
                push    ss
                pop     es
                assume es:DOSCODE
                mov     di, offset NAME2
                mov     si, offset NAME1
                mov     cx, 11
                rep movsb
                mov     ax, ds:DIRSTART_HW
                mov     ds:DESTSTART_HW, ax
                mov     ax, ds:DIRSTART
                mov     ds:DESTSTART, ax

BUILDDEST:                              ; ...
                push    ss
                pop     es
                mov     bx, (offset RENAMEDMA+15h)
                mov     di, offset NAME1
                mov     si, offset NAME2
                mov     cx, 11
                call    NEW_RENAME
                mov     ds:ATTRIB, 16h  ; attr_all
                mov     ds:CREATING, 0FFh
                call    DEVNAME
                jnb     short BAD_ACC
                mov     bx, ds:DESTSTART_HW
                mov     ds:ROOTCLUST_HW, bx
                mov     bx, ds:DESTSTART
                les     bp, ds:THISDPB
                assume es:nothing
                call    SETDIRSRCH
                jb      short BAD_ACCJ
                call    FINDENTRY
                jnb     short BAD_ACCJ
                cmp     ds:FAILERR, 0
                jnz     short BAD_ACCJ
                mov     ax, ds:DESTSTART
                mov     dx, ds:DESTSTART_HW
                les     bp, ds:THISDPB
                cmp     word ptr es:[bp+0Fh], 0
                jnz     short builddst_1
                cmp     dx, word ptr ds:RENAMEDMA+11h
                jnz     short builddst_2

builddst_1:                             ; ...
                cmp     ax, word ptr ds:RENAMEDMA+0Fh
                jz      short SIMPLE_RENAME

builddst_2:                             ; ...
                mov     al, ds:RENAMEDMA+20h ; RENAMEDMA+21+dir_entry.dir_attr]
                test    al, 10h         ; attr_directory
                jnz     short BAD_ACCJ
                mov     ds:ATTRIB, al
                mov     word ptr ds:THISSFT+2, ds
                mov     si, (offset RENAMEDMA+145h) ; AUXSTACK-SF_ENTRY.size
                                        ; RENAMEDMA+325
                mov     word ptr ds:THISSFT, si
                mov     word ptr [si+2], 2 ; [SI+SF_ENTRY.sf_mode],
                                        ; SHARING_COMPAT+open_for_both
                xor     cx, cx
                call    RENAME_MAKE
                jnb     short GOT_DEST

BAD_ACCJ:                               ; ...
                jmp     BAD_ACC
; ---------------------------------------------------------------------------

GOT_DEST:                               ; ...
                push    bx
                les     di, ds:THISSFT
                call    ShareEnd
                pop     bx
                les     di, ds:CURBUF
                call    SET_BUF_DIRTY
                mov     di, bx
                add     di, 11          ; dir_entry.dir_attr ; skip name
                mov     si, (offset RENAMEDMA+20h) ; RENAMEDMA+21+dir_entry.dir_attr
                mov     cx, 21          ; dir_entry.size-dir_entry.dir_attr
                rep movsb
                call    GET_SOURCE
                jb      short RENAME_OVER
                mov     di, bx
                mov     es, word ptr ds:CURBUF+2
                assume es:DOSCODE
                mov     al, 0E5h        ; DIRFREE
                stosb
                jmp     short DIRTY_IT
; ---------------------------------------------------------------------------

SIMPLE_RENAME:                          ; ...
                call    GET_SOURCE
                jb      short RENAME_OVER
                mov     di, bx
                mov     es, word ptr ds:CURBUF+2
                assume es:nothing
                mov     si, offset NAME1
                mov     cx, 11
                rep movsb

DIRTY_IT:                               ; ...
                mov     di, word ptr ds:CURBUF
                call    SET_BUF_DIRTY
                push    si
                lds     si, ds:DMAADD
                add     si, 21          ; find_buf.attr
                test    byte ptr [si+0Bh], 10h ; [SI+dir_entry.dir_attr],
                                        ; attr_directory
                jz      short NOT_DIR2
                call    FastOpen_Rename

NOT_DIR2:                               ; ...
                pop     si
                mov     si, (offset RENAMEDMA+1)
                call    ECritDisk
                mov     ds:CREATING, 0
                call    RENAME_NEXT
                jb      short RENAME_OVER
                lea     si, [bx+1Ah]
                call    REN_DEL_Check
                jnb     short REN_OK2
                mov     ax, 20h         ; error_sharing_violation

jmp_to_rename_clean:                    ; ...
                jmp     RENAME_CLEAN
; ---------------------------------------------------------------------------

REN_OK2:                                ; ...
                mov     al, ds:RENAMEDMA+20h
                test    al, 10h         ; attr_directory
                jz      short Ren_Directory
                call    FastOpen_Delete

jmp_to_builddest:                       ; ...
                jmp     BUILDDEST
; ---------------------------------------------------------------------------

Ren_Directory:                          ; ...
                call    FastOpen_Rename
                jmp     short jmp_to_builddest
; ---------------------------------------------------------------------------

RENAME_OVER:                            ; ...
                clc
                jmp     short jmp_to_rename_clean
DOS_RENAME      endp


; =============== S U B R O U T I N E =======================================


GET_SOURCE      proc near               ; ...
                les     bp, ds:THISDPB
                xor     bx, bx
                cmp     es:[bp+0Fh], bx ; DPB.FAT_SIZE > 0 ?
                jnz     short gs_cont   ; yes, it is not FAT32
                mov     bx, word ptr ds:RENAMEDMA+11h ; hw of cluster number

gs_cont:                                ; ...
                mov     ds:ROOTCLUST_HW, bx
                mov     bx, word ptr ds:RENAMEDMA+0Fh ; DirStart
                call    SETDIRSRCH
                jb      short gs_ret_label
                call    STARTSRCH
                mov     ax, word ptr ds:RENAMEDMA+0Dh ; Lastent
                call    GETENT

gs_ret_label:                           ; ...
                retn
GET_SOURCE      endp


; =============== S U B R O U T I N E =======================================


NEW_RENAME      proc near               ; ...
                lodsb
                cmp     al, '?'         ; 3Fh
                jnz     short NOCHG
                mov     al, [bx]        ; Get replace char

NOCHG:                                  ; ...
                stosb
                inc     bx              ; Next replace char
                loop    NEW_RENAME
                retn
NEW_RENAME      endp


; =============== S U B R O U T I N E =======================================


GET_FILE_INFO   proc near               ; ...
                call    TestNet
                jnb     short LOCAL_INFO
                mov     ax, 110Fh
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
                                        ; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
                                        ; SDA CDS pointer -> current directory
                                        ; Return: CF set on error, AX = file attributes
                retn
; ---------------------------------------------------------------------------

LOCAL_INFO:                             ; ...
                call    ECritDisk
                mov     ds:NoSetDir, 1  ; if we find a dir, don't change to it
                call    GET_FAST_PATH
                jnb     short info_check_dev

NO_PATH:                                ; ...
                jnz     short bad_path1
                or      cl, cl
                jz      short bad_path1

info_no_file:                           ; ...
                mov     ax, 2           ; error_file_not_found

BadRet:                                 ; ...
                stc

JustRet:                                ; ...
                call    LCritDisk
                retn
; ---------------------------------------------------------------------------

bad_path1:                              ; ...
                mov     ax, 3           ; error_path_not_found
                jmp     short BadRet
; ---------------------------------------------------------------------------

info_check_dev:                         ; ...
                or      ah, ah
                js      short info_no_file ; device
                cmp     word ptr ds:CURBUF, 0FFFFh ; -1 ; is it a root dir?
                jnz     short not_root  ; no, CurBuf ptr is valid
                xor     ah, ah
                mov     al, 10h         ; attr_directory
                clc
                jmp     short JustRet
; ---------------------------------------------------------------------------

not_root:                               ; ...
                push    ds
                mov     ds, word ptr ds:CURBUF+2
                mov     si, bx
                xor     bx, bx          ; Assume size=0 (dir)
                mov     di, bx
                mov     cx, [si+16h]    ; [SI+dir_entry.dir_time]
                mov     dx, [si+18h]    ; [SI+dir_entry.dir_date]
                xor     ah, ah
                mov     al, [si+0Bh]    ; [SI+dir_entry.dir_attr]
                test    al, 10h         ; attr_directory
                jnz     short NO_SIZE
                mov     di, [si+1Ch]    ; [SI+dir_entry.dir_size_l]
                mov     bx, [si+1Eh]    ; [SI+dir_entry.dir_size_h]

NO_SIZE:                                ; ...
                pop     ds
                clc

OK_BYE:                                 ; ...
                jmp     short JustRet
GET_FILE_INFO   endp


; =============== S U B R O U T I N E =======================================


sub_6FE3        proc near               ; ...
                test    ax, 0FFD8h
                jz      short loc_6FFA

loc_6FE8:                               ; ...
                call    set_exerr_locus_unk
                mov     ds:EXTERR_CLASS, 7
                mov     ds:EXTERR_ACTION, 4
                mov     ax, 5
                stc
                retn
; ---------------------------------------------------------------------------

loc_6FFA:                               ; ...
                call    TestNet
                jnb     short loc_7007
                push    ax
                mov     ax, 110Eh
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
                                        ; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
                                        ; SDA CDS pointer -> current directory
                                        ; STACK: WORD new file attributes
                                        ; Return: CF set on error
                pop     bx
                retn
; ---------------------------------------------------------------------------

loc_7007:                               ; ...
                call    ECritDisk
                push    ax
                mov     ds:NoSetDir, 1
                call    GETPATH
                jnb     short loc_7018
                pop     bx
                jmp     short NO_PATH
; ---------------------------------------------------------------------------

loc_7018:                               ; ...
                or      ah, ah
                jns     short loc_7022
                pop     ax
                call    LCritDisk
                jmp     short loc_6FE8
; ---------------------------------------------------------------------------

loc_7022:                               ; ...
                pop     ax
                cmp     word ptr ds:5E2h, 0FFFFh
                jz      short loc_7034
                call    REN_DEL_Check
                jnb     short loc_703A
                mov     ax, 20h ; ' '

loc_7032:                               ; ...
                jmp     short OK_BYE
; ---------------------------------------------------------------------------

loc_7034:                               ; ...
                mov     ax, 5
                stc
                jmp     short OK_BYE
; ---------------------------------------------------------------------------

loc_703A:                               ; ...
                les     di, ds:5E2h
                and     byte ptr es:[bx+0Bh], 0D8h
                or      es:[bx+0Bh], al
                call    SET_BUF_DIRTY
                mov     al, ds:576h
                push    dx
                push    di
                mov     ah, 0
                mov     dl, al
                mov     di, bx
                call    FastOpen_Update
                pop     di
                pop     dx
                call    FLUSHBUF
                jnb     short loc_7032
                jmp     info_no_file
sub_6FE3        endp


; =============== S U B R O U T I N E =======================================


GET_FAST_PATH   proc near               ; ...
                or      ss:FastOpenFlg, 1
                call    GETPATH
                pushf
                and     ss:FastOpenFlg, 80h
                popf
                retn
GET_FAST_PATH   endp


; =============== S U B R O U T I N E =======================================


DOS_DUP         proc near               ; ...
                mov     es, cs:DosDSeg
                les     di, es:59Eh

loc_707E:                               ; ...
                call    IsSFTNet
                jnz     short loc_7086
                call    sub_92CA

loc_7086:                               ; ...
                inc     word ptr es:[di]
                retn
DOS_DUP         endp

; ---------------------------------------------------------------------------

DOS_CREATE:                             ; ...
                xor     ah, ah

loc_708C:                               ; ...
                test    al, 80h
                jnz     short loc_70A1
                test    al, 8
                jz      short loc_709B
                or      byte ptr ds:DOS34_FLAG, 80h
                mov     al, 8

loc_709B:                               ; ...
                or      al, 20h
                test    al, 50h
                jz      short loc_70A9

loc_70A1:                               ; ...
                mov     ax, 5
                call    set_exerr_locus_unk
                jmp     short SET_MKND_ERR
; ---------------------------------------------------------------------------

loc_70A9:                               ; ...
                les     di, ds:THISSFT
                push    es
                les     si, ds:THISCDS
                cmp     si, 0FFFFh
                jnz     short loc_70D2
                pop     es
                test    ds:EXTOPEN_ON, 1
                jz      short loc_70CC

loc_70BF:                               ; ...
                push    ax
                mov     ax, 112Eh

loc_70C3:                               ; ...
                int     2Fh             ; Multiplex - DOS 4 IFSFUNC.EXE - ???
                                        ; SS = DS = DOS CS, STACK: WORD ???   low byte = ???
                                        ; Return: CF set on error
                                        ; CF clear if successful
                pop     bx
                mov     ds:EXTOPEN_ON, 0
                retn
; ---------------------------------------------------------------------------

loc_70CC:                               ; ...
                push    ax
                mov     ax, 1118h
                jmp     short loc_70C3
; ---------------------------------------------------------------------------

loc_70D2:                               ; ...
                test    byte ptr es:[si+44h], 80h
                pop     es
                jz      short loc_70F1
                call    sub_71A7
                jb      short loc_70E4
                or      word ptr es:[di+2], 2

loc_70E4:                               ; ...
                test    ds:EXTOPEN_ON, 1
                jnz     short loc_70BF
                push    ax
                mov     ax, 1117h
                jmp     short loc_70C3
; ---------------------------------------------------------------------------

loc_70F1:                               ; ...
                call    sub_71A7
                jb      short loc_70FB
                or      word ptr es:[di+2], 2

loc_70FB:                               ; ...
                call    ECritDisk
                call    sub_951A
                jnb     short loc_711A
                mov     ds:VOLCHNG_FLAG, 0FFh
                call    LCritDisk

SET_MKND_ERR:                           ; ...
                mov     bx, 7112h
                xlat    byte ptr cs:[bx]
                stc
                retn
; ---------------------------------------------------------------------------
                db    0
                db    5
                db  52h ; R
                db  50h ; P
                db    3
                db    5
                db  20h
                db    2
; ---------------------------------------------------------------------------

loc_711A:                               ; ...
                call    FastOpen_Delete
                mov     al, ds:SATTRIB
                test    al, 8
                jz      short loc_7140
                les     di, ds:THISCDS
                mov     ah, es:[di]
                sub     ah, 41h ; 'A'
                mov     ds:VOLCHNG_FLAG, ah
                mov     bh, 1
                call    Set_Media_ID
                call    ECritDisk
                call    FATREAD_CDS
                call    LCritDisk

loc_7140:                               ; ...
                mov     ax, 2
                les     di, ds:THISSFT
                call    ds:ShSU
                call    LCritDisk
                jmp     SET_SFT_MODE
; ---------------------------------------------------------------------------

DOS_Create_New:                         ; ...
                mov     ah, 1
                jmp     loc_708C

; =============== S U B R O U T I N E =======================================


Set_Media_ID    proc near               ; ...
                push    ax
                push    es
                push    di
                inc     ah
                mov     bl, ah
                mov     al, 0Dh
                mov     cx, 4866h
                mov     dx, offset FAKE_STACK_2F

loc_7165:                               ; ...
                push    cx
                push    bx
                push    dx
                xor     bh, bh
                call    $IOCTL
                pop     dx
                pop     bx
                pop     cx
                jnb     short loc_717C
                cmp     ch, 48h ; 'H'
                stc
                jnz     short loc_71A1
                mov     ch, 8
                jmp     short loc_7165
; ---------------------------------------------------------------------------

loc_717C:                               ; ...
                or      bh, bh
                jz      short loc_7185
                mov     si, offset NAME1
                jmp     short loc_7188
; ---------------------------------------------------------------------------

loc_7185:                               ; ...
                mov     si, 0DC1h

loc_7188:                               ; ...
                mov     di, dx
                add     di, 6
                push    ss
                pop     ds
                assume ds:DOSCODE
                push    ss
                pop     es
                assume es:DOSCODE
                push    cx
                mov     cx, 0Bh
                rep movsb
                pop     cx
                mov     cl, 46h ; 'F'
                mov     al, 0Dh
                xor     bh, bh
                call    $IOCTL

loc_71A1:                               ; ...
                push    ss
                pop     ds
                pop     di
                pop     es
                assume es:nothing
                pop     ax
                retn
Set_Media_ID    endp


; =============== S U B R O U T I N E =======================================


sub_71A7        proc near               ; ...
                test    ss:EXTOPEN_ON, 1
                jz      short locret_71BA
                push    ax
                mov     ax, ss:SAVE_BX
                or      es:[di+2], ax
                pop     ax
                stc

locret_71BA:                            ; ...
                retn
sub_71A7        endp

; ---------------------------------------------------------------------------

DOS_OPEN:                               ; ...
                mov     NoSetDir, 0
                call    sub_72FE
                jb      short locret_71EB
                les     di, THISSFT
                xor     ah, ah
                mov     es:[di+2], al
                push    es
                les     si, THISCDS
                cmp     si, 0FFFFh
                jnz     short loc_7204
                pop     es
                test    EXTOPEN_ON, 1
                jz      short loc_71EC

loc_71E1:                               ; ...
                mov     al, byte ptr SAVE_BX
                push    ax
                mov     ax, 112Eh
                int     2Fh             ; Multiplex - DOS 4 IFSFUNC.EXE - ???
                                        ; SS = DS = DOS CS, STACK: WORD ???   low byte = ???
                                        ; Return: CF set on error
                                        ; CF clear if successful
                pop     bx

locret_71EB:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_71EC:                               ; ...
                test    DOS_FLAG, 1
                jz      short loc_71FC
                test    byte ptr DOS34_FLAG+1, 8
                jz      short loc_71FC
                mov     al, 23h ; '#'

loc_71FC:                               ; ...
                push    ax
                mov     ax, 1116h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE
                                        ; ES:DI -> uninitialized SFT, SS = DOS CS
                                        ; SDA first filename pointer -> fully-qualified name of file to open
                                        ; STACK: WORD file open mode
                                        ; Return: CF set on error
                pop     bx
                retn
; ---------------------------------------------------------------------------

loc_7204:                               ; ...
                test    word ptr es:[si+43h], 8000h
                pop     es
                jz      short loc_7216
                test    EXTOPEN_ON, 1
                jnz     short loc_71E1
                jmp     short loc_71EC
; ---------------------------------------------------------------------------

loc_7216:                               ; ...
                call    ECritDisk
                or      FastOpenFlg, 5
                call    GETPATH
                jnb     short loc_7243
                jnz     short loc_7239
                or      cl, cl
                jz      short loc_7239
                mov     ax, 2

loc_722C:                               ; ...
                and     ss:FastOpenFlg, 80h
                stc
                call    LCritDisk
                jmp     locret_72BF
; ---------------------------------------------------------------------------

loc_7239:                               ; ...
                mov     ax, 3
                jmp     short loc_722C
; ---------------------------------------------------------------------------

loc_723E:                               ; ...
                mov     ax, 5
                jmp     short loc_722C
; ---------------------------------------------------------------------------

loc_7243:                               ; ...
                jz      short loc_723E
                or      ah, ah
                js      short loc_7288
                mov     es, word ptr CURBUF+2
                assume es:DOSCODE
                mov     al, es:[bx+0Bh]
                test    al, 8
                jnz     short loc_723E
                test    al, 1
                jz      short loc_7288
                push    ds
                push    si
                lds     si, THISSFT
                assume ds:nothing
                mov     cx, [si+2]
                test    cx, 8000h
                jnz     short loc_7272
                mov     dl, cl
                and     dl, 0F0h
                cmp     dl, 70h ; 'p'
                jnz     short loc_727A

loc_7272:                               ; ...
                and     cx, 0FFFCh
                mov     [si+2], cx
                jmp     short loc_7286
; ---------------------------------------------------------------------------

loc_727A:                               ; ...
                and     cl, 3
                cmp     cl, 0
                jz      short loc_7286
                pop     si
                pop     ds
                jmp     short loc_723E
; ---------------------------------------------------------------------------

loc_7286:                               ; ...
                pop     si
                pop     ds

loc_7288:                               ; ...
                call    DOOPEN
                and     ss:FastOpenFlg, 80h
                call    sub_72DE
                jnb     short loc_729B
                call    LCritDisk
                jmp     short locret_72BF
; ---------------------------------------------------------------------------

loc_729B:                               ; ...
                mov     ax, 3
                les     di, ds:59Eh
                assume es:nothing
                call    dword ptr ds:0C8h
                call    LCritDisk

SET_SFT_MODE:                           ; ...
                les     di, ds:THISSFT
                call    sub_92CA
                test    word ptr es:[di+2], 8000h
                jz      short locret_72BF
                mov     ax, ds:330h
                mov     es:[di+31h], ax

locret_72BF:                            ; ...
                retn

; =============== S U B R O U T I N E =======================================


SHARE_ERROR     proc near               ; ...
                test    word ptr es:[di+2], 8000h
                jnz     short loc_72D4
                mov     cl, es:[di+2]
                and     cl, 0F0h
                cmp     cl, 0
                jnz     short loc_72D9

loc_72D4:                               ; ...
                call    SHARE_VIOLATION
                jnb     short locret_72BF

loc_72D9:                               ; ...
                mov     ax, 20h ; ' '
                stc
                retn
SHARE_ERROR     endp


; =============== S U B R O U T I N E =======================================


sub_72DE        proc near               ; ...
                call    ECritDisk

loc_72E1:                               ; ...
                mov     cx, ds:1Ah

loc_72E5:                               ; ...
                push    cx
                call    sub_C62A
                pop     cx
                jnb     short loc_72FA
                call    Idle
                loop    loc_72E5
                les     di, ds:59Eh
                call    SHARE_ERROR
                jnb     short loc_72E1

loc_72FA:                               ; ...
                call    LCritDisk
                retn
sub_72DE        endp


; =============== S U B R O U T I N E =======================================


sub_72FE        proc near               ; ...
                mov     ds:56Eh, al
                push    bx
                mov     bl, al
                and     bl, 0F0h
                cmp     byte ptr ds:572h, 0
                jz      short loc_7313
                cmp     bl, 70h ; 'p'
                jz      short loc_7318

loc_7313:                               ; ...
                cmp     bl, 40h ; '@'
                ja      short loc_7325

loc_7318:                               ; ...
                mov     bl, al
                and     bl, 3
                cmp     bl, 2
                ja      short loc_7325
                pop     bx
                clc
                retn
; ---------------------------------------------------------------------------

loc_7325:                               ; ...
                mov     ax, 0Ch
                pop     bx
                stc
                retn
sub_72FE        endp


; =============== S U B R O U T I N E =======================================


DISK_INFO       proc near               ; ...
                call    TestNet
                jnb     short LOCAL_DSK_INFO
                xor     si, si
                xor     di, di
                mov     ax, 110Ch
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
                                        ; ES:DI -> current directory
                                        ; Return: AL = sectors per cluster, BX = total clusters
                                        ; CX = bytes per sector, DX = number of available clusters
                cmp     bx, 0FFFFh
                jnz     short dsk_info_1
                mov     di, bx

dsk_info_1:                             ; ...
                cmp     dx, 0FFFFh
                jnz     short disk_info_retn
                mov     si, dx

disk_info_retn:                         ; ...
                retn
; ---------------------------------------------------------------------------

LOCAL_DSK_INFO:                         ; ...
                call    set_exerr_locus_disk ; mov byte [EXTERR_LOCUS],errLOC_Disk
                call    ECritDisk
                call    FATREAD_CDS
                jb      short CRIT_LEAVE
                xor     ax, ax
                mov     ds:CLUSTNUM_HW, ax ; clear high word of cluster number
                mov     bx, 2           ; Get first FAT sector into CURBUF
                call    UNPACK

CRIT_LEAVE:                             ; ...
                jnb     short dsk_info_2
                jmp     jmp_to_LCritDisk
; ---------------------------------------------------------------------------

dsk_info_2:                             ; ...
                lds     si, ds:CURBUF
                mov     ah, [si+24]     ; [SI+BUFINSIZ] ; get FAT ID BYTE
                push    ss
                pop     ds
                assume ds:DOSCODE
                xor     si, si
                mov     di, si
                mov     dx, es:[bp+1Fh] ; [ES:BP+DPB.FREE_CNT] ; get free count
                cmp     es:[bp+0Fh], si ; FAT32 (16 bit FAT size = 0) ?
                jz      short dsk_info_3 ; yes
                mov     cx, es:[bp+0Dh] ; [ES:BP+DPB.MAX_CLUSTER]
                jmp     short dsk_info_4
; ---------------------------------------------------------------------------

dsk_info_3:                             ; ...
                mov     di, es:[bp+2Fh] ; DPB.LAST_CLUSTER+2
                mov     cx, es:[bp+2Dh] ; DPB.LAST_CLUSTER
                mov     si, es:[bp+21h] ; DPB.FREE_CNT_HW ; hw of free cluster count
                cmp     dx, si          ; same (zero) ?

dsk_info_4:                             ; ...
                jnz     short dsk_info_5 ; not same (not zero)
                inc     dx
                jz      short dsk_info_7 ; 0FFFFh -> 0 (free count is invalid/initial)
                                        ; free count calculation is needed
                dec     dx

dsk_info_5:                             ; ...
                cmp     si, di          ; same hw ?
                jnz     short dsk_info_6 ; no
                cmp     dx, cx          ; same lw ?

dsk_info_6:                             ; ...
                jb      short dsk_info_12 ; free cluster count < last cluster number
                xor     dx, dx          ; 0

dsk_info_7:                             ; ...
                xor     si, si          ; 0
                sub     cx, 1           ; last cluster number - 1 = number of clusters
                sbb     di, si
                or      byte ptr es:[bp+18h], 1 ; DPB.FIRST_ACCESS ; set first access

dsk_info_8:                             ; ...
                push    si
                push    CCONTENT_HW
                push    di
                call    UNPACK
                pop     di
                pop     CCONTENT_HW
                pop     si
                jb      short jmp_to_LCritDisk
                jnz     short NOTFREECLUS
                inc     dx              ; a free one
                jnz     short NOTFREECLUS
                inc     si              ; increase hw of free cluster count

NOTFREECLUS:                            ; ...
                inc     bx              ; next cluster
                jnz     short ReturnVals
                inc     CLUSTNUM_HW     ; increase hw of (next) cluster number

ReturnVals:                             ; ...
                sub     cx, 1           ; decrease remain cluster count for calculation
                sbb     di, 0
                jnz     short dsk_info_8
                jcxz    short dsk_info_9 ; calculation completed
                jmp     short dsk_info_8
; ---------------------------------------------------------------------------

dsk_info_9:                             ; ...
                mov     di, CLUSTNUM_HW
                sub     bx, 1
                sbb     di, 0           ; di:bx = last cluster number

dsk_info_10:                            ; ...
                xor     cx, cx
                sub     bx, 1
                sbb     di, cx          ; di:bx = number of clusters
                mov     al, es:[bp+4]   ; [ES:BP+DPB.CLUSTER_MASK] ; spc -1
                inc     al              ; sectors per cluster
                mov     es:[bp+1Fh], dx ; [ES:BP+DPB.FREE_CNT] ; free cluster count, lw
                cmp     es:[bp+0Fh], cx ; FAT32 (16 bit FAT size = 0) ?
                jnz     short dsk_info_11 ; no
                mov     es:[bp+21h], si ; DPB.FREE_CNT_HW ; hw of free cluster count
                call    update_fat32_fsinfo

dsk_info_11:                            ; ...
                mov     cx, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE] ; bytes per sector
                clc

jmp_to_LCritDisk:                       ; ...
                call    LCritDisk
                retn
; ---------------------------------------------------------------------------

dsk_info_12:                            ; ...
                mov     bx, cx
                jmp     short dsk_info_10
DISK_INFO       endp

; ---------------------------------------------------------------------------

modify_spc:                             ; ...
                push    ax              ; ax = sectors per cluster
                push    dx
                mul     cx              ; bytes per sector
                cmp     dx, 0
                jnz     short mspc_1
                cmp     ax, 16384       ; 16 kilobytes (per cluster)
                                        ; ***
                                        ; actual disk size limit
                                        ; without invalidating cluster counts is
                                        ; 2 GB (512K clusters * 8 sectors per cluster)
                                        ;      (128K clusters * 32 sectors per cluster)

mspc_1:                                 ; ...
                pop     dx
                pop     ax
                jbe     short mspc_3    ; bytes per cluster <= 16 KB
                                        ; ***
                                        ; bytes per cluster > 16 KB
                xor     di, di          ; 0
                mov     bx, 0FFFEh      ; (invalidated)
                or      si, si          ; hw of free cluster count
                jz      short mspc_2    ; si = 0
                mov     si, di          ; si = 0
                mov     dx, bx          ; dx = bx = 0FFFEh (invalidated)

mspc_2:                                 ; ...
                retn
; ---------------------------------------------------------------------------

mspc_3:                                 ; ...
                shl     ax, 1           ; sectors per clust = sectors per clust * 2
                shr     di, 1           ; cluster count = cluster count /2
                                        ; di:bx = modified value of total clusters

mspc_4:
                rcr     bx, 1
                shr     si, 1           ; free clusters = free clusters / 2
                rcr     dx, 1           ; si:dx = modified value of free clusters

modify_cluster_count:                   ; ...
                or      di, di          ; hw of cluster count
                jnz     short modify_spc
                retn

; =============== S U B R O U T I N E =======================================


update_fat32_fsinfo proc near           ; ...
                push    cx
                push    dx
                xor     cx, cx
                mov     dx, es:[bp+25h]
                cmp     es:[bp+0Fh], cx
                jnz     short loc_7449
                cmp     dx, 0FFFFh
                jnz     short loc_7451

loc_7449:                               ; ...
                pop     dx
                pop     cx
                and     byte ptr es:[bp+18h], 0F4h
                retn
; ---------------------------------------------------------------------------

loc_7451:                               ; ...
                push    ax
                push    bx
                push    di
                push    si
                push    ds
                cmp     ss:BuffInHMA, 0
                jz      short loc_7469
                lds     di, ss:LoMemBuff
                assume ds:nothing
                sub     di, 18h
                clc
                jmp     short loc_7475
; ---------------------------------------------------------------------------

loc_7469:                               ; ...
                push    es
                push    bp
                call    GETCURHEAD
                push    dx
                call    BUFWRITE
                pop     dx
                pop     bp
                pop     es

loc_7475:                               ; ...
                jb      short loc_74E1
                xor     cx, cx
                lea     bx, [di+18h]
                mov     ss:ALLOWED, 18h
                mov     ss:HIGH_SECTOR, cx
                inc     cx
                push    bx
                push    dx
                call    DREAD
                pop     dx
                pop     bx
                jb      short loc_74E1
                cmp     word ptr [bx], 5252h
                jnz     short loc_74E1
                cmp     word ptr [bx+2], 4161h
                jnz     short loc_74E1
                cmp     word ptr [bx+1E4h], 7272h
                jnz     short loc_74E1
                cmp     word ptr [bx+1E6h], 6141h
                jnz     short loc_74E1
                cmp     word ptr [bx+1FEh], 0AA55h
                jnz     short loc_74E1
                mov     ax, es:[bp+1Fh]
                mov     [bx+1E8h], ax
                mov     ax, es:[bp+21h]
                mov     [bx+1EAh], ax
                mov     ax, es:[bp+39h]
                mov     [bx+1ECh], ax
                mov     ax, es:[bp+3Bh]
                mov     [bx+1EEh], ax
                xor     cx, cx
                mov     ss:HIGH_SECTOR, cx
                inc     cx
                call    DWRITE

loc_74E1:                               ; ...
                pop     ds
                pop     si
                pop     di
                pop     bx
                pop     ax
                jmp     loc_7449
update_fat32_fsinfo endp


; =============== S U B R O U T I N E =======================================


DOS_SEARCH_FIRST proc near              ; ...
                les     di, ds:THISCDS
                cmp     di, 0FFFFh
                jnz     short loc_74F8
                mov     ax, 1119h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - ???
                retn
; ---------------------------------------------------------------------------

loc_74F8:                               ; ...
                test    byte ptr es:[di+44h], 80h
                jz      short loc_7505
                mov     ax, 111Bh
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - FINDFIRST
                                        ; SS = DS = DOS CS, [DTA] = uninitialized 21-byte findfirst search data
                                        ; SDA first filename pointer -> fully-qualified search template
                                        ; SDA CDS pointer -> current directory
                                        ; Return: CF set on error
                retn
; ---------------------------------------------------------------------------

loc_7505:                               ; ...
                call    ECritDisk
                test    byte ptr ds:612h, 4
                jz      short loc_7514
                or      ds:FastOpenFlg, 1

loc_7514:                               ; ...
                mov     ds:NoSetDir, 1
                mov     si, ss
                mov     ds, si
                assume ds:DOSCODE
                mov     si, WFP_START

loc_7521:                               ; ...
                lodsb
                or      al, al
                jz      short loc_752F
                cmp     al, 3Fh ; '?'
                jnz     short loc_7521
                and     FastOpenFlg, 80h

loc_752F:                               ; ...
                call    GETPATH
                jnb     short loc_754D
                jnz     short loc_7548
                or      cl, cl
                jz      short loc_7548

loc_753A:                               ; ...
                mov     ax, 12h

loc_753D:                               ; ...
                and     ss:FastOpenFlg, 80h
                stc
                call    LCritDisk
                retn
; ---------------------------------------------------------------------------

loc_7548:                               ; ...
                mov     ax, 3
                jmp     short loc_753D
; ---------------------------------------------------------------------------

loc_754D:                               ; ...
                or      ah, ah
                jns     short loc_755B
                mov     LASTENT, 0FFFFh
                inc     FOUND_DEV

loc_755B:                               ; ...
                les     di, DMAADD
                mov     si, WFP_START
                lodsb
                sub     al, 40h ; '@'
                stosb

loc_7567:                               ; ...
                les     di, DMAADD
                inc     di
                push    ds
                test    FastOpenFlg, 10h
                jz      short loc_757C
                mov     si, bx
                mov     ds, word ptr CURBUF+2
                jmp     short loc_757F
; ---------------------------------------------------------------------------

loc_757C:                               ; ...
                mov     si, 54Bh

loc_757F:                               ; ...
                movsb
                cmp     byte ptr es:[di-1], 5
                jnz     short loc_758C
                mov     byte ptr es:[di-1], 0E5h

loc_758C:                               ; ...
                mov     cx, 5
                rep movsw
                pop     ds
                assume ds:nothing
                mov     al, ds:56Bh
                stosb
                push    ax
                mov     ax, ds:348h
                stosw
                mov     ax, ds:5C2h
                stosw
                mov     ax, ds:0ADCh
                stosw
                add     di, 2
                pop     ax
                or      ah, ah
                js      short loc_75C6
                cmp     word ptr ds:5E2h, 0FFFFh
                jnz     short loc_75C2
                test    byte ptr ds:1146h, 10h
                jnz     short loc_75C2
                mov     word ptr es:[di-8], 0FFFFh
                jmp     loc_753A
; ---------------------------------------------------------------------------

loc_75C2:                               ; ...
                mov     ds, word ptr ds:5E4h

loc_75C6:                               ; ...
                mov     si, bx
                mov     cx, 10h
                mov     ax, di
                rep movsw
                mov     di, ax
                cmp     byte ptr es:[di], 5
                jnz     short loc_75DB
                mov     byte ptr es:[di], 0E5h

loc_75DB:                               ; ...
                and     ss:FastOpenFlg, 80h
                push    ss
                pop     ds
                assume ds:DOSCODE
                clc
                call    LCritDisk
                retn
DOS_SEARCH_FIRST endp

; ---------------------------------------------------------------------------
                les     di, DMAADD

; =============== S U B R O U T I N E =======================================


DOS_SEARCH_NEXT proc near               ; ...
                mov     al, es:[di]
                test    al, 80h
                jz      short loc_75F9
                mov     ax, 111Ch
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - FINDNEXT
                                        ; SS = DS = DOS CS, [DTA] = 21-byte findfirst search data
                                        ; Return: CF set on error, AX = DOS error code
                                        ; CF clear if successful
                retn
; ---------------------------------------------------------------------------

loc_75F9:                               ; ...
                mov     EXTERR_LOCUS, 2
                call    ECritDisk
                mov     word ptr THISCDS, offset DUMMYCDS
                mov     word ptr THISCDS+2, ds
                add     al, 40h ; '@'
                call    InitCDS
                jb      short loc_7682
                les     di, THISCDS
                les     bp, es:[di+45h]
                mov     word ptr THISDPB, bp
                mov     word ptr THISDPB+2, es
                mov     al, es:[bp+0]
                mov     THISDRV, al
                mov     word ptr CREATING, 0E500h
                mov     NoSetDir, 1
                lds     si, DMAADD
                assume ds:nothing
                lodsb
DOS_SEARCH_NEXT endp


; =============== S U B R O U T I N E =======================================


RENAME_NEXT     proc near               ; ...
                mov     di, ss
                mov     es, di
                assume es:DOSCODE
                mov     di, 54Bh
                movsb
                mov     cx, 5
                rep movsw
                lodsb
                mov     ss:ATTRIB, al
                lodsw
                or      ax, ax
                js      short loc_7682
                push    ax
                lodsw
                mov     bx, ax
                lodsw
                mov     bp, ss
                mov     ds, bp
                assume ds:DOSCODE
                les     bp, THISDPB
                assume es:nothing
                cmp     word ptr es:[bp+0Fh], 0
                jz      short loc_7666
                xor     ax, ax

loc_7666:                               ; ...
                mov     ROOTCLUST_HW, ax
                call    SETDIRSRCH
                jb      short loc_7681
                call    STARTSRCH
                pop     ax
                call    GETENT
                jb      short loc_7682
                call    NEXTENT
                jb      short loc_7682
                xor     ah, ah
                jmp     loc_7567
; ---------------------------------------------------------------------------

loc_7681:                               ; ...
                pop     ax

loc_7682:                               ; ...
                jmp     loc_753A
RENAME_NEXT     endp


; =============== S U B R O U T I N E =======================================


sub_7685        proc near               ; ...
                mov     es, ss:CurrentPDB
                mov     cx, es:32h

loc_768F:                               ; ...
                mov     bx, cx
                push    cx
                dec     bx
                call    $CLOSE
                pop     cx
                loop    loc_768F
                push    ss
                pop     ds
                mov     ax, 111Dh
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - CLOSE ALL REMOTE FILES FOR PROCESS
                                        ; DS???, SS = DOS CS
                call    MFTCloseP
                les     di, ss:SFTFCB

loc_76A9:                               ; ...
                mov     cx, es
                or      cx, di
                jcxz    short loc_76D4
                push    di
                mov     cx, es:[di+4]
                jcxz    short loc_76CB
                lea     di, [di+6]
                mov     ax, ss:PROC_ID

loc_76BD:                               ; ...
                cmp     es:[di+31h], ax
                jnz     short loc_76C6
                call    SFT_FREE

loc_76C6:                               ; ...
                add     di, 3Bh ; ';'
                loop    loc_76BD

loc_76CB:                               ; ...
                pop     di
                les     di, es:[di]
                cmp     di, 0FFFFh
                jnz     short loc_76A9

loc_76D4:                               ; ...
                xor     bx, bx

loc_76D6:                               ; ...
                push    bx
                call    SFFromSFN
                pop     bx
                jnb     short loc_76DE
                retn
; ---------------------------------------------------------------------------

loc_76DE:                               ; ...
                cmp     word ptr es:[di], 0FFFFh
                jnz     short loc_76FB
                mov     ax, ss:PROC_ID
                cmp     es:[di+31h], ax
                jnz     short loc_76FB
                mov     ax, ss:USER_ID
                sub     ax, es:[di+2Fh]
                jnz     short loc_76FB
                call    SFT_FREE

loc_76FB:                               ; ...
                inc     bx
                jmp     short loc_76D6
sub_7685        endp

; ---------------------------------------------------------------------------

DOS_CLOSE:                              ; ...
                les     di, THISSFT
                mov     bx, es:[di+5]
                test    bh, 80h
                jz      short loc_7711
                mov     ax, 1106h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE FILE
                                        ; ES:DI -> SFT
                                        ; SFT DPB field -> DPB of drive containing file
                                        ; Return: CF set on error, AX = DOS error code
                                        ; CF clear if successful
                retn
; ---------------------------------------------------------------------------

loc_7711:                               ; ...
                call    ECritDisk
                call    sub_78E3
                call    FREE_SFT
                push    ss
                pop     ds
                push    ax
                push    bx
                call    ShareEnd
                pop     bx
                pop     ax

; =============== S U B R O U T I N E =======================================

; Attributes: noreturn

sub_7723        proc near               ; ...
                push    ax
                test    bx, 0C0h
                jz      short loc_772D
                jmp     loc_782D
; ---------------------------------------------------------------------------

loc_772D:                               ; ...
                call    sub_7873
                mov     al, 5
                jb      short loc_7772
                test    word ptr [si+2], 4
                jnz     short loc_7757
                push    ds
                push    bx
                lds     bx, [si+7]
                assume ds:nothing
                mov     bl, [bx]
                xor     bh, bh
                test    byte ptr ss:[bx+1308h], 4
                pop     bx
                jz      short loc_7756
                pop     ds
                push    ds
                call    DATE16
                mov     es:[di+12h], ax

loc_7756:                               ; ...
                pop     ds

loc_7757:                               ; ...
                push    di
                push    si
                lea     si, [si+20h]
                call    XCHGP
                call    sub_8875
                call    XCHGP
                pop     si
                pop     di
                jz      short loc_7775
                mov     di, si
                push    ds
                pop     es
                push    ss
                pop     ds
                assume ds:DOSCODE
                stc
                mov     al, 2

loc_7772:                               ; ...
                jmp     loc_7855
; ---------------------------------------------------------------------------

loc_7775:                               ; ...
                mov     al, [si+4]
                test    word ptr [si+2], 8000h
                jz      short loc_7789
                mov     ch, es:[di+0Bh]
                mov     ss:ATTRIB, al
                jmp     short loc_778D
; ---------------------------------------------------------------------------

loc_7789:                               ; ...
                mov     es:[di+0Bh], al

loc_778D:                               ; ...
                or      byte ptr es:[di+0Bh], 20h
                mov     ax, es:[di+1Ah]
                mov     ss:OLD_FIRSTCLUS, ax
                mov     ax, es:[di+14h]
                mov     ss:OLD_FIRSTCLUS_HW, ax
                mov     ax, [si+2Bh]
                mov     es:[di+1Ah], ax
                mov     ax, [si+2Dh]
                mov     es:[di+14h], ax
                push    ds
                lds     ax, [si+11h]
                assume ds:nothing
                mov     es:[di+1Ch], ax
                mov     word ptr es:[di+1Eh], ds
                pop     ds
                push    ds
                lds     ax, [si+0Dh]
                mov     es:[di+16h], ax
                mov     word ptr es:[di+18h], ds
                pop     ds
                test    byte ptr es:[bx+5], 40h
                jnz     short loc_77D9
                call    INC_DIRTY_COUNT
                or      byte ptr es:[bx+5], 40h

loc_77D9:                               ; ...
                push    ds
                push    si
                mov     cx, [si+2Bh]
                mov     al, ss:THISDRV
                push    dx
                mov     ah, 0
                mov     dl, al
                push    bx
                mov     bx, [si+2Dh]
                or      bx, bx
                jnz     short loc_77FF
                or      cx, cx
                jnz     short loc_77FF
                mov     ah, 3
                mov     dh, [si+1Fh]
                lds     di, [si+1Bh]
                mov     cx, ds
                jmp     short loc_7819
; ---------------------------------------------------------------------------

loc_77FF:                               ; ...
                cmp     bx, ss:OLD_FIRSTCLUS_HW
                jnz     short loc_780D
                cmp     cx, ss:OLD_FIRSTCLUS
                jz      short loc_7819

loc_780D:                               ; ...
                mov     ah, 2
                mov     cx, ss:OLD_FIRSTCLUS
                mov     bx, ss:OLD_FIRSTCLUS_HW

loc_7819:                               ; ...
                push    ss
                pop     ds
                assume ds:DOSCODE
                xchg    bx, si
                call    FastOpen_Update
                xchg    bx, si
                pop     bx
                pop     dx
                call    FLUSHBUF
                pop     di
                pop     es
                mov     al, 5
                jb      short loc_7842

loc_782D:                               ; ...
                test    word ptr es:[di+5], 8080h
                jnz     short loc_7855
                push    es
                push    bp
                les     bp, es:[di+7]
                call    update_fat32_fsinfo
                pop     bp
                pop     es
                jmp     short loc_7855
; ---------------------------------------------------------------------------

loc_7842:                               ; ...
                push    ds
                push    bx
                lds     bx, es:[di+7]
                assume ds:nothing
                mov     bl, [bx]
                xor     bh, bh
                and     ss:drive_flags[bx], 0FBh ; clear bit 2
                pop     bx
                pop     ds
                stc

loc_7855:                               ; ...
                pushf
                call    DEV_CLOSE_SFT
sub_7723        endp

; ---------------------------------------------------------------------------
                popf
                pop     cx
                pushf
                loop    NoFree
                call    SFT_FREE
; START OF FUNCTION CHUNK FOR DOS_COMMIT

NoFree:                                 ; ...
                call    LCritDisk
                popf
                retn
; END OF FUNCTION CHUNK FOR DOS_COMMIT

; =============== S U B R O U T I N E =======================================


FREE_SFT        proc near               ; ...
                pushf
                mov     ax, es:[di]
                dec     ax
                jnz     short loc_786E
                dec     ax

loc_786E:                               ; ...
                xchg    ax, es:[di]
                popf
                retn
FREE_SFT        endp


; =============== S U B R O U T I N E =======================================


sub_7873        proc near               ; ...
                call    set_exerr_locus_disk
                push    es
                push    di
                mov     dx, es:[di+1Dh]
                mov     ds:607h, dx
                push    dx
                mov     dx, es:[di+1Bh]
                push    dx
                call    FATREAD_SFT
                pop     dx
                pop     word ptr ds:607h
                jb      short loc_78B5
                xor     al, al
                mov     byte ptr ds:34Bh, 18h
                call    GETBUFFR
                jb      short loc_78B5
                pop     si
                pop     ds
                les     di, ss:CURBUF
                or      byte ptr es:[di+5], 4
                mov     bx, di
                lea     di, [di+18h]
                mov     al, 20h ; ' '
                mul     byte ptr [si+1Fh]
                add     di, ax
                retn
; ---------------------------------------------------------------------------

loc_78B5:                               ; ...
                pop     di
                pop     es

locret_78B7:                            ; ...
                retn
sub_7873        endp


; =============== S U B R O U T I N E =======================================


DOS_COMMIT      proc near               ; ...

; FUNCTION CHUNK AT 7861 SIZE 00000005 BYTES

                les     di, ds:59Eh
                mov     bx, es:[di+5]
                test    bl, 0C0h
                jnz     short locret_78B7
                test    bh, 80h
                jz      short loc_78D0
                mov     ax, 1107h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
                                        ; ES:DI -> SFT
                                        ; SFT DPB field -> DPB of drive containing file
                                        ; Return: CF set on error, AX = DOS error code
                                        ; CF clear if successful

locret_78CF:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_78D0:                               ; ...
                call    ECritDisk
                call    sub_78E3
                mov     ax, 0FFFFh
                call    sub_7723
; ---------------------------------------------------------------------------
                pushf
                call    sub_92CA
                jmp     NoFree
DOS_COMMIT      endp


; =============== S U B R O U T I N E =======================================


sub_78E3        proc near               ; ...
                test    bx, 40C0h
                jnz     short locret_78CF
                push    ax
                push    bx
                call    DATE16
                mov     es:[di+0Fh], ax
                mov     es:[di+0Dh], dx
                xor     ax, ax
                call    dword ptr ds:0C8h
                pop     bx
                pop     ax
                retn
sub_78E3        endp

; ---------------------------------------------------------------------------

DOS_MKDIR:                              ; ...
                call    TestNet
                jnb     short LOCAL_MKDIR
                mov     ax, 1103h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY
                                        ; SS = DOS CS
                                        ; SDA first filename pointer -> fully-qualified directory name
                                        ; SDA CDS pointer -> current directory
                                        ; Return: CF set on error, AX = DOS error code
                                        ; CF clear if successful
                retn
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR DOS_CHDIR

NODEACCERRJ:                            ; ...
                mov     ax, 5           ; error_access_denied

_BadRet:                                ; ...
                stc

chdir_mkdir_done:                       ; ...
                call    LCritDisk
                retn
; END OF FUNCTION CHUNK FOR DOS_CHDIR
; ---------------------------------------------------------------------------

PATHNFJ:                                ; ...
                call    LCritDisk
                jmp     SET_MKND_ERR
; ---------------------------------------------------------------------------

LOCAL_MKDIR:                            ; ...
                call    ECritDisk
                mov     word ptr ds:THISSFT+2, ss
                mov     word ptr ds:THISSFT, 43Eh
                mov     word ptr ds:RENBUF+33h, 0
                mov     al, 10h
                call    sub_951A
                jb      short PATHNFJ
                cmp     ax, 3
                jz      short NODEACCERRJ
                les     bp, ds:THISDPB
                lds     di, ds:CURBUF
                sub     si, di
                push    si
                lds     ax, [di+6]
                push    ds
                push    ax
                push    ss
                pop     ds
                assume ds:DOSCODE
                xor     ax, ax
                mov     dx, ax
                xchg    dx, DIRSTART_HW
                xchg    ax, DIRSTART
                cmp     word ptr es:[bp+0Fh], 0
                jnz     short loc_796C
                cmp     es:[bp+35h], ax
                jnz     short loc_796C
                cmp     es:[bp+37h], dx
                jnz     short loc_796C
                xor     ax, ax
                xor     dx, dx

loc_796C:                               ; ...
                push    dx
                push    ax
                call    loc_9424
                jb      short loc_79F2
                call    GETENT
                jb      short loc_79F2
                les     di, CURBUF
                call    SET_BUF_DIRTY
                add     di, 18h
                mov     ax, 202Eh
                mov     dx, DIRSTART_HW
                mov     CLUSTERS_HW, dx
                mov     dx, DIRSTART
                call    sub_94F3
                mov     ax, 2E2Eh
                pop     dx
                pop     CLUSTERS_HW
                call    sub_94F3
                les     bp, THISDPB
                mov     ALLOWED, 18h
                pop     dx
                pop     HIGH_SECTOR
                xor     al, al
                call    GETBUFFR
                jb      short loc_7A20
                mov     ax, DIRSTART_HW
                mov     dx, DIRSTART
                lds     di, CURBUF
                assume ds:nothing
                or      byte ptr [di+5], 4
                pop     si
                add     si, di
                mov     [si], dx
                mov     [si-6], ax
                xor     dx, dx
                mov     [si+2], dx
                mov     [si+4], dx

DIRUP:                                  ; ...
                test    byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty
                jnz     short yesdirty6 ; already dirty
                call    INC_DIRTY_COUNT
                or      byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty

yesdirty6:                              ; ...
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    update_fat32_fsinfo
                mov     al, es:[bp+0]
                call    FLUSHBUF
                mov     ax, 5           ; error_access_denied
; START OF FUNCTION CHUNK FOR DOS_CHDIR

lmd_cd_done:                            ; ...
                jmp     chdir_mkdir_done
; END OF FUNCTION CHUNK FOR DOS_CHDIR
; ---------------------------------------------------------------------------

loc_79F2:                               ; ...
                pop     dx
                pop     dx
                pop     dx
                pop     HIGH_SECTOR
                les     bp, THISDPB
                mov     ALLOWED, 18h
                xor     al, al
                call    GETBUFFR
                jb      short loc_7A20
                lds     di, CURBUF
                assume ds:nothing
                or      byte ptr [di+5], 4
                pop     si
                add     si, di
                sub     si, 1Ah
                mov     byte ptr [si], 0E5h
                call    DIRUP

loc_7A1D:                               ; ...
                jmp     NODEACCERRJ
; ---------------------------------------------------------------------------

loc_7A20:                               ; ...
                pop     si
                jmp     short loc_7A1D

; =============== S U B R O U T I N E =======================================


DOS_CHDIR       proc near               ; ...

; FUNCTION CHUNK AT 790A SIZE 00000008 BYTES
; FUNCTION CHUNK AT 79EF SIZE 00000003 BYTES

                call    TestNet
                jnb     short loc_7A2E
                mov     ax, 1105h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - CHDIR
                                        ; SS = DOS CS
                                        ; SDA first filename pointer -> fully-qualified directory name
                                        ; SDA CDS pointer -> current directory
                                        ; Return: CF set on error, AX = DOS error code
                                        ; CF clear if successful
                retn
; ---------------------------------------------------------------------------

loc_7A2E:                               ; ...
                call    ECritDisk
                test    byte ptr es:[di+44h], 20h
                jz      short loc_7A44
                mov     word ptr es:[di+4Bh], 0FFFFh
                mov     word ptr es:[di+49h], 0FFFFh

loc_7A44:                               ; ...
                mov     ds:NoSetDir, 0
                mov     ds:SATTRIB, 16h
                or      ds:FastOpenFlg, 1
                call    GETPATH
                lahf
                and     ds:FastOpenFlg, 80h
                sahf
                mov     ax, 3
                jb      short ChDirDone
                jnz     short NOTDIRPATH
                mov     cx, ds:DIRSTART
                clc

ChDirDone:                              ; ...
                jmp     short lmd_cd_done
; ---------------------------------------------------------------------------

DOS_RMDIR:                              ; ...
                call    TestNet
                jnb     short LOCAL_RMDIR
                mov     ax, 1101h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
                                        ; SS = DOS CS
                                        ; SDA first filename pointer -> fully-qualified directory name
                                        ; SDA CDS pointer -> current directory
                                        ; Return: CF set on error, AX = DOS error code
                                        ; CF clear if successful
                retn
; ---------------------------------------------------------------------------

LOCAL_RMDIR:                            ; ...
                call    ECritDisk
                mov     ds:NoSetDir, 0
                mov     ds:SATTRIB, 16h ; attr_directory+attr_system+attr_hidden
                call    GETPATH
                jb      short NOPATH    ; Path not found
                jnz     short NOTDIRPATH ; Path not a DIR
                mov     di, ds:DIRSTART
                or      di, di          ; Root ?
                jnz     short lrd_chk_fat32 ; No
                cmp     ds:DIRSTART_HW, 0
                jz      short NOTDIRPATH ; root directory

lrd_chk_fat32:                          ; ...
                cmp     word ptr es:[bp+0Fh], 0 ; [es:bp+DPB.FAT_SIZE]
                jnz     short rmdir_get_buf ; not FAT32
                cmp     di, es:[bp+35h] ; [es:bp+DPB.ROOT_CLUSTER]
                jnz     short rmdir_get_buf
                mov     di, ds:DIRSTART_HW
                cmp     di, es:[bp+37h] ; [es:bp+DPB.ROOT_CLUSTER+2]
                jnz     short rmdir_get_buf
                jmp     short NOTDIRPATH
; ---------------------------------------------------------------------------

NOPATH:                                 ; ...
                mov     ax, 3           ; error_path_not_found
                jmp     _BadRet
; ---------------------------------------------------------------------------

NOTDIRPATHPOP:                          ; ...
                pop     ax
                pop     ax

NOTDIRPATHPOP2:                         ; ...
                pop     ax

NOTDIRPATH:                             ; ...
                jmp     NODEACCERRJ
; ---------------------------------------------------------------------------

rmdir_get_buf:                          ; ...
                lds     di, ds:CURBUF
                sub     bx, di          ; Compute true offset
                push    bx              ; Save entry pointer
                les     di, [di+6]      ; [DI+BUFFINFO.buf_sector]
                push    es              ; Save sector number
                push    di
                push    ss
                pop     ds
                assume ds:DOSCODE
                push    ss
                pop     es
                assume es:DOSCODE
                mov     di, offset NAME1
                mov     ax, 3Fh ; '?'
                mov     cx, 10
                rep stosb               ; al = '?'
                stosw                   ; ah = 0 ; Nul terminate it
                call    STARTSRCH       ; Set search
                call    GETENTRY        ; Get start of directory
                jb      short NOTDIRPATHPOP ; Screw up
                mov     ds, word ptr CURBUF+2
                mov     si, bx
                lodsw
                cmp     ax, 202Eh       ; First entry '.'?
                jnz     short NOTDIRPATHPOP ; Nope
                add     si, 30          ; Next entry
                lodsw
                cmp     ax, 2E2Eh       ; Second entry '..'?
                jnz     short NOTDIRPATHPOP ; Nope
                push    ss
                pop     ds
                mov     LASTENT, 2      ; Skip . and ..
                call    GETENTRY        ; Get next entry
                jb      short NOTDIRPATHPOP ; Screw up
                mov     ATTRIB, 16h     ; attr_directory+attr_hidden+attr_system
                call    SRCH            ; Do a search
                jnb     short NOTDIRPATHPOP
                cmp     FAILERR, 0
                jnz     short NOTDIRPATHPOP ; Failure of search due to I 24 FAIL
                les     bp, THISDPB
                assume es:nothing
                mov     bx, DIRSTART_HW
                mov     CLUSTNUM_HW, bx
                mov     bx, DIRSTART
                call    RELEASE         ; Release data in sub dir
                jb      short NOTDIRPATHPOP
                call    update_fat32_fsinfo
                pop     dx
                pop     HIGH_SECTOR
                mov     ALLOWED, 18h
                xor     al, al
                call    GETBUFFR
                jnb     short loc_7B41
                jmp     NOTDIRPATHPOP2
; ---------------------------------------------------------------------------

loc_7B41:                               ; ...
                lds     di, CURBUF
                assume ds:nothing
                or      byte ptr [di+5], 4
                pop     bx
                add     bx, di
                mov     byte ptr [bx], 0E5h
                push    ds
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    FastOpen_Delete
                pop     ds
                assume ds:nothing
                jmp     DIRUP
DOS_CHDIR       endp


; =============== S U B R O U T I N E =======================================


sub_7B59        proc near               ; ...
                mov     ds:CONSWAP, 0
                retn
sub_7B59        endp


; =============== S U B R O U T I N E =======================================


sub_7B5F        proc near               ; ...
                push    ax
                mov     ax, ds:59Eh
                mov     byte ptr ds:357h, 1
                mov     ds:5E6h, ax
                mov     ax, ds:5A0h
                mov     ds:5E8h, ax
                pop     ax
                retn
sub_7B5F        endp


; =============== S U B R O U T I N E =======================================

; Attributes: thunk

sub_7B73        proc near               ; ...
                jmp     sub_8225
sub_7B73        endp


; =============== S U B R O U T I N E =======================================


DOS_READ        proc near               ; ...
                les     di, ds:59Eh
                mov     al, es:[di+2]
                and     al, 3
                cmp     al, 1
                jz      short sub_7B73
                call    SETUP
                jcxz    short loc_7B94
                call    IsSFTNet
                jz      short loc_7B96
                mov     ax, 1108h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - READ FROM REMOTE FILE
                                        ; ES:DI -> SFT
                                        ; SFT DPB field -> DPB of drive containing file
                                        ; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
                                        ; Return: CF set on error, CX = bytes read
                retn
; ---------------------------------------------------------------------------

loc_7B94:                               ; ...
                clc
                retn
; ---------------------------------------------------------------------------

loc_7B96:                               ; ...
                test    byte ptr es:[di+5], 80h
                jnz     short loc_7BAC
                mov     byte ptr ds:323h, 2
                call    ECritDisk
                call    sub_81D5
                call    LCritDisk
                retn
; ---------------------------------------------------------------------------

loc_7BAC:                               ; ...
                mov     byte ptr ds:323h, 4
                mov     bl, es:[di+5]
                les     di, ds:32Ch
                test    bl, 40h
                jz      short loc_7BC5
                test    bl, 4
                jz      short loc_7BC8
                xor     al, al

loc_7BC5:                               ; ...
                jmp     loc_7C9A
; ---------------------------------------------------------------------------

loc_7BC8:                               ; ...
                test    bl, 20h
                jnz     short loc_7BD5
                test    bl, 1
                jz      short loc_7C32
                jmp     loc_7D53
; ---------------------------------------------------------------------------

loc_7BD5:                               ; ...
                push    es
                pop     ds
                test    ss:IsWin386, 1
                jz      short loc_7BE7
                test    bl, 1
                jz      short loc_7BE7
                jmp     loc_7C9D
; ---------------------------------------------------------------------------

loc_7BE7:                               ; ...
                mov     bx, di
                xor     ax, ax
                cwd
                call    SETREAD
                push    ds
                lds     si, ss:THISSFT
                call    DEVIOCALL
                mov     dx, di
                mov     ah, 86h
                mov     di, ss:DEVCALL_REQSTAT
                or      di, di
                jns     short loc_7C28
                call    sub_A173
                mov     di, dx
                sub     cx, ss:CALLBPB
                add     di, ss:CALLBPB
                or      al, al
                jz      short loc_7C28
                cmp     al, 3
                jz      short loc_7C1F
                pop     ds
                jmp     short loc_7BE7
; ---------------------------------------------------------------------------

loc_7C1F:                               ; ...
                pop     di

loc_7C20:                               ; ...
                les     di, ss:THISSFT
                jmp     sub_8223
; ---------------------------------------------------------------------------

loc_7C28:                               ; ...
                pop     di
                mov     di, dx
                add     di, ss:CALLBPB
                jmp     short loc_7BC5
; ---------------------------------------------------------------------------

loc_7C32:                               ; ...
                push    es
                pop     ds
                mov     bx, di
                xor     ax, ax
                cwd
                push    cx
                mov     cx, 1
                call    SETREAD
                pop     cx
                lds     si, ss:THISSFT
                lds     si, [si+7]

loc_7C49:                               ; ...
                call    DSKSTATCHK
                call    DEVIOCALL2
                push    di
                mov     ah, 86h
                mov     di, ss:DEVCALL_REQSTAT
                or      di, di
                jns     short loc_7C72
                call    sub_A173
                pop     di
                mov     ss:CALLBPB, 1
                cmp     al, 1
                jz      short loc_7C49
                cmp     al, 3
                jz      short loc_7C20
                xor     al, al
                jmp     short loc_7C84
; ---------------------------------------------------------------------------

loc_7C72:                               ; ...
                pop     di
                cmp     ss:CALLBPB, 1
                jnz     short loc_7C9A
                push    ds
                mov     ds, ss:CALLXAD_2
                assume ds:DOSCODE
                mov     al, [di]
                pop     ds
                assume ds:nothing

loc_7C84:                               ; ...
                inc     word ptr ss:CALLBR
                mov     ss:DEVCALL_REQSTAT, 0
                inc     di
                cmp     al, 1Ah
                jz      short loc_7C9A
                cmp     al, 0Dh
                loopne  loc_7C49
                inc     ax

loc_7C9A:                               ; ...
                jmp     loc_7D3E
; ---------------------------------------------------------------------------

loc_7C9D:                               ; ...
                mov     bx, di
                xor     ax, ax
                cwd
                call    SETREAD

loc_7CA5:                               ; ...
                mov     byte ptr es:[bx+2], 5
                push    ds
                lds     si, ss:THISSFT
                call    DEVIOCALL
                pop     ds
                test    word ptr es:[bx+3], 8000h
                jz      short loc_7CCF
                push    ds
                mov     dx, di

loc_7CBF:                               ; ...
                call    sub_A173
                mov     di, dx
                or      al, al
                jz      short loc_7D16
                cmp     al, 3
                jz      short loc_7D05
                pop     ds
                jmp     short loc_7CA5
; ---------------------------------------------------------------------------

loc_7CCF:                               ; ...
                test    word ptr es:[bx+3], 200h
                jnz     short loc_7D0E
                mov     byte ptr es:[bx+2], 4
                mov     word ptr es:[bx+12h], 1
                push    ds
                lds     si, ss:THISSFT
                call    DEVIOCALL
                mov     dx, di
                mov     di, es:[bx+3]
                mov     ah, 86h
                test    di, 8000h
                jnz     short loc_7CBF
                pop     ds
                mov     di, dx
                dec     cx
                jz      short loc_7D17
                inc     word ptr es:[bx+0Eh]
                jmp     short loc_7CA5
; ---------------------------------------------------------------------------

loc_7D05:                               ; ...
                pop     di
                les     di, ss:THISSFT
                jmp     sub_8223
; ---------------------------------------------------------------------------

loc_7D0E:                               ; ...
                push    ax
                mov     ah, 84h
                int     2Ah             ; Microsoft Networks - KEYBOARD BUSY LOOP
                pop     ax
                jmp     short loc_7CA5
; ---------------------------------------------------------------------------

loc_7D16:                               ; ...
                pop     ds

loc_7D17:                               ; ...
                add     di, ss:CALLBPB
                jmp     loc_7BC5
; ---------------------------------------------------------------------------

loc_7D1F:                               ; ...
                lodsb
                stosb
                cmp     al, 0Dh
                jnz     short loc_7D28
                mov     byte ptr [si], 0Ah

loc_7D28:                               ; ...
                cmp     al, 0Ah
                loopne  loc_7D1F
                jnz     short loc_7D35
                xor     si, si
                call    OUTT
                or      al, 1

loc_7D35:                               ; ...
                push    ss
                pop     ds
                assume ds:DOSCODE
                call    sub_7B59
                mov     CONTPOS, si

loc_7D3E:                               ; ...
                push    ss
                pop     ds
                mov     NEXTADD, di
                jnz     short loc_7D4F
                les     di, THISSFT
                and     byte ptr es:[di+5], 0BFh

loc_7D4F:                               ; ...
                call    sub_82D7
                retn
; ---------------------------------------------------------------------------

loc_7D53:                               ; ...
                call    sub_7B5F
                mov     si, CONTPOS
                or      si, si
                jnz     short loc_7D1F
                cmp     CONBUF, 80h
                jz      short loc_7D6B
                mov     word ptr CONBUF, 0FF80h

loc_7D6B:                               ; ...
                push    cx
                push    es
                push    di
                mov     dx, 27Bh
                call    $STD_CON_STRING_INPUT
                pop     di
                pop     es
                mov     si, 27Dh
                pop     cx
                cmp     byte ptr [si], 1Ah
                jnz     short loc_7D1F
                mov     al, 1Ah
                stosb
                dec     di
                mov     al, 0Ah
                call    OUTT
                xor     si, si
                jmp     short loc_7D35
DOS_READ        endp


; =============== S U B R O U T I N E =======================================

; Attributes: thunk

sub_7D8C        proc near               ; ...
                jmp     sub_8225
sub_7D8C        endp


; =============== S U B R O U T I N E =======================================


DOS_WRITE       proc near               ; ...

; FUNCTION CHUNK AT 7E22 SIZE 000000BF BYTES

                les     di, THISSFT
                mov     al, es:[di+2]
                and     al, 3
                cmp     al, 0
                jz      short sub_7D8C
                test    byte ptr es:[di+3], 80h
                jz      short loc_7DAB
                test    byte ptr es:[di+4], 1
                jnz     short sub_7D8C

loc_7DAB:                               ; ...
                call    SETUP
                test    byte ptr es:[di+6], 80h
                jz      short loc_7DBB
                mov     ax, 1109h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
                                        ; ES:DI -> SFT
                                        ; SFT DPB field -> DPB of drive containing file
                                        ; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
                                        ; Return: CF set on error, CX = bytes written
                retn
; ---------------------------------------------------------------------------

loc_7DBB:                               ; ...
                test    byte ptr es:[di+5], 80h
                jnz     short loc_7E31
                mov     EXTERR_LOCUS, 2
                call    ECritDisk
                call    _WRITE_OK
                jb      short loc_7DDF
                les     di, THISSFT
                test    byte ptr es:[di+3], 40h
                jz      short loc_7DDF
                push    cx
                call    DOS_COMMIT
                pop     cx

loc_7DDF:                               ; ...
                call    LCritDisk
                retn
; ---------------------------------------------------------------------------

loc_7DE3:                               ; ...
                xor     ax, ax
                call    SETWRITE
                push    ds
                lds     si, ss:THISSFT
                assume ds:nothing
                call    DEVIOCALL
                mov     dx, di
                mov     di, ss:DEVCALL_REQSTAT
                mov     ah, 87h
                or      di, di
                jns     short loc_7E1D
                call    sub_A173
                mov     di, ss:CALLBPB
                mov     bx, dx
                sub     cx, di
                add     bx, di
                mov     di, bx
                or      al, al
                jz      short loc_7E1D
                cmp     al, 3
                jz      short loc_7E19
                pop     ds
                jmp     short loc_7DE3
; ---------------------------------------------------------------------------

loc_7E19:                               ; ...
                pop     ax
                jmp     loc_7C1F
; ---------------------------------------------------------------------------

loc_7E1D:                               ; ...
                pop     ax
                pop     ds
DOS_WRITE       endp

; ---------------------------------------------------------------------------
                db 0A1h
DOSCODE         ends

; ===========================================================================

; Segment type: Regular
DOSCODE         segment byte public 'DOSCODE' use16
                assume cs:DOSCODE
                ;org 7E20h
                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
                db  6Ch ; l
                db    3
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR DOS_WRITE

loc_7E22:                               ; ...
                les     di, ds:59Eh
                mov     cx, ax
                call    sub_8306
                retn
; ---------------------------------------------------------------------------

loc_7E2C:                               ; ...
                mov     dx, cx

loc_7E2E:                               ; ...
                jmp     loc_7EBD
; ---------------------------------------------------------------------------

loc_7E31:                               ; ...
                mov     byte ptr ds:323h, 4
                or      byte ptr es:[di+5], 40h
                mov     bl, es:[di+5]
                xor     ax, ax
                jcxz    short loc_7E22
                push    ds
                mov     al, bl
                lds     bx, ds:32Ch
                mov     di, bx
                cwd
                test    al, 20h
                jnz     short loc_7DE3
                test    al, 2
                jnz     short loc_7EC3
                test    al, 4
                jnz     short loc_7E2C
                mov     ax, dx
                cmp     byte ptr [bx], 1Ah
                jz      short loc_7E2E
                push    cx
                mov     cx, 1
                call    SETWRITE
                lds     si, ss:59Eh
                pop     cx
                lds     si, [si+7]

loc_7E70:                               ; ...
                call    DSKSTATCHK
                call    DEVIOCALL2
                push    di
                mov     di, ss:35Dh
                mov     ah, 87h
                or      di, di
                jns     short loc_7E98
                call    sub_A173
                pop     di
                mov     word ptr ss:36Ch, 1
                cmp     al, 1
                jz      short loc_7E70
                or      al, al
                jz      short loc_7EA1
                jmp     loc_7C1F
; ---------------------------------------------------------------------------

loc_7E98:                               ; ...
                pop     di
                cmp     word ptr ss:36Ch, 0
                jz      short loc_7EBD

loc_7EA1:                               ; ...
                inc     dx
                inc     word ptr ss:368h
                inc     di
                push    ds
                mov     ds, word ptr ss:36Ah
                cmp     byte ptr [di], 1Ah
                pop     ds
                jz      short loc_7EBD
                mov     word ptr ss:35Dh, 0
                loop    loc_7E70

loc_7EBD:                               ; ...
                mov     ax, dx
                pop     ds
                jmp     loc_7E22
; ---------------------------------------------------------------------------

loc_7EC3:                               ; ...
                push    ds
                push    ss
                pop     ds
                call    sub_7B5F
                pop     ds
                mov     si, bx
                push    cx

loc_7ECD:                               ; ...
                lodsb
                cmp     al, 1Ah
                jz      short loc_7ED7
                call    OUTT
                loop    loc_7ECD

loc_7ED7:                               ; ...
                pop     ax
                pop     ds
                sub     ax, cx
                call    sub_7B59
                jmp     loc_7E22
; END OF FUNCTION CHUNK FOR DOS_WRITE

; =============== S U B R O U T I N E =======================================


GET_IO_SFT      proc near               ; ...
                cmp     ss:CONSWAP, 0
                jnz     short loc_7EFB

loc_7EE9:                               ; ...
                push    ss
                pop     ds
                push    es
                push    di
                call    SFFromHandle
                jb      short loc_7EF8
                mov     si, es
                mov     ds, si
                mov     si, di

loc_7EF8:                               ; ...
                pop     di
                pop     es
                retn
; ---------------------------------------------------------------------------

loc_7EFB:                               ; ...
                cmp     bx, 1
                ja      short loc_7EE9
                lds     si, ss:CONSFT
                clc

locret_7F06:                            ; ...
                retn
GET_IO_SFT      endp


; =============== S U B R O U T I N E =======================================


sub_7F07        proc near               ; ...
                xor     dx, dx
                cmp     ds:DIRSTART_HW, dx
                jnz     short loc_7F18
                cmp     ds:DIRSTART, dx
                jnz     short loc_7F18
                xchg    ax, dx
                jmp     short loc_7F24
; ---------------------------------------------------------------------------

loc_7F18:                               ; ...
                mov     dl, al
                mov     cl, es:[bp+5]
                and     dl, es:[bp+4]
                shr     ax, cl

loc_7F24:                               ; ...
                mov     ds:SECCLUSPOS, dl
                mov     cx, ax
                mov     ah, dl
                mov     bx, ds:0ADEh
                mov     ds:0AE0h, bx
                mov     ds:0AE8h, bx
                mov     dx, ds:5C0h
                mov     bx, ds:5BCh
                mov     ds:607h, dx
                mov     dx, ds:5BEh
                add     dl, ah
                adc     dh, 0
                adc     word ptr ds:607h, 0
                mov     ds:5DCh, bx
                jcxz    short sub_7F91

loc_7F58:                               ; ...
                call    UNPACK

loc_7F5B:                               ; ...
                jb      short locret_7F06
                push    ds:CLUSTNUM_HW
                pop     word ptr ds:0AF2h
                push    word ptr ds:0AECh
                pop     ds:CLUSTNUM_HW
                xchg    bx, di
                call    IsEOF
                jnb     short loc_7F76
                loop    loc_7F58

loc_7F76:                               ; ...
                mov     ds:5DCh, bx
                mov     bx, ds:CLUSTNUM_HW
                mov     ds:0AE0h, bx
                mov     dx, di
                mov     bx, ds:0AF2h
                mov     ds:CLUSTNUM_HW, bx
                mov     bl, ah
                call    FIGREC
sub_7F07        endp


; =============== S U B R O U T I N E =======================================


sub_7F91        proc near               ; ...
                mov     ds:ALLOWED, 18h
                xor     al, al
                call    GETBUFFR
                jb      short loc_7F5B
sub_7F91        endp


; =============== S U B R O U T I N E =======================================


sub_7F9D        proc near               ; ...
                push    ds
                push    si
                lds     si, ds:CURBUF
                or      byte ptr [si+5], 4
                pop     si
                pop     ds

dr_ret_label:                           ; ...
                retn
sub_7F9D        endp


; =============== S U B R O U T I N E =======================================


sub_7FAA        proc near               ; ...

; FUNCTION CHUNK AT 8027 SIZE 00000007 BYTES

                mov     ss:ALLOWED, 18h
                mov     di, cx
                mov     cl, es:[bp+8]
                mov     ax, es:[bp+0Fh]
                xor     ch, ch
                or      ax, ax
                jnz     short loc_7FCA
                test    byte ptr es:[bp+23h], 80h
                jz      short loc_7FCA
                mov     cx, 1

loc_7FCA:                               ; ...
                push    ss:HIGH_SECTOR
                push    dx

loc_7FD0:                               ; ...
                push    cx
                push    ax
                push    ss:HIGH_SECTOR
                push    dx
                mov     cx, di
                call    DSKREAD
                pop     dx
                pop     ss:HIGH_SECTOR
                pop     ax
                pop     cx
                jz      short loc_8027
                or      ax, ax
                jnz     short loc_7FFC
                add     dx, es:[bp+31h]
                push    ax
                mov     ax, es:[bp+33h]
                adc     ss:HIGH_SECTOR, ax
                pop     ax
                jmp     short loc_8004
; ---------------------------------------------------------------------------

loc_7FFC:                               ; ...
                add     dx, ax
                adc     ss:HIGH_SECTOR, 0

loc_8004:                               ; ...
                loop    loc_7FD0
                pop     dx
                pop     ss:HIGH_SECTOR
                mov     cx, di
sub_7FAA        endp


; =============== S U B R O U T I N E =======================================


DREAD           proc near               ; ...
                call    DSKREAD
                jz      short dr_ret_label
                mov     ss:READOP, 0    ; Read
                call    HARDERRRW
                cmp     al, 1           ; RETRY
                jz      short DREAD
                cmp     al, 3           ; FAIL
                clc
                jnz     short NO_CAR1   ; IGNORE
                stc

NO_CAR1:                                ; ...
                retn
DREAD           endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR sub_7FAA

loc_8027:                               ; ...
                pop     dx
                pop     word ptr ss:607h
                retn
; END OF FUNCTION CHUNK FOR sub_7FAA

; =============== S U B R O U T I N E =======================================


sub_802E        proc near               ; ...
                test    byte ptr es:[di+4], 8
                jz      short loc_8039
                call    sub_8223
                retn
; ---------------------------------------------------------------------------

loc_8039:                               ; ...
                push    cx
                or      cx, cx
                jnz     short loc_803F
                dec     cx

loc_803F:                               ; ...
                mov     al, 80h
                call    sub_C5C7
                pop     cx
                jnb     short locret_804C
                call    sub_81CE
                jnb     short loc_8039

locret_804C:                            ; ...
                retn
sub_802E        endp


; =============== S U B R O U T I N E =======================================


sub_804D        proc near               ; ...
                test    byte ptr es:[di+4], 8
                jz      short loc_8058
                call    sub_8225
                retn
; ---------------------------------------------------------------------------

loc_8058:                               ; ...
                xor     al, al
                call    sub_C5C7
                jnb     short locret_8064
                call    sub_81A8
                jnb     short loc_8058

locret_8064:                            ; ...
                retn
sub_804D        endp


; =============== S U B R O U T I N E =======================================


DSKREAD         proc near               ; ...
                push    cx              ; DS:BX = Transfer address
                                        ; [HIGH_SECTOR]:DX = Disk sector address
                                        ; CX = Sector count
                                        ; ES:BP = DPB
                mov     ah, es:[bp+17h] ; [ES:BP+DPB.MEDIA]
                mov     al, es:[bp+1]   ; [ES:BP+DPB.UNIT]
                push    bx
                push    es
                call    SETREAD
                jmp     short DODSKOP
DSKREAD         endp


; =============== S U B R O U T I N E =======================================


DWRITE          proc near               ; ...
                call    DSKWRITE
                jnz     short dwrite1
                retn                    ; Carry clear (retz)
; ---------------------------------------------------------------------------

dwrite1:                                ; ...
                mov     ss:READOP, 1    ; Write
                call    HARDERRRW
                cmp     al, 1           ; Check for retry
                jz      short DWRITE
                cmp     al, 3           ; Check for FAIL
                clc
                jnz     short NO_CAR2   ; Ignore
                stc

NO_CAR2:                                ; ...
                retn
DWRITE          endp


; =============== S U B R O U T I N E =======================================


DSKWRITE        proc near               ; ...
                push    cx              ; DS:BX = Transfer address
                                        ; [HIGH_SECTOR]:DX = Disk sector address
                                        ; CX = Sector count
                                        ; ES:BP = DPB
                mov     ah, es:[bp+17h] ; [ES:BP+DPB.MEDIA]
                mov     al, es:[bp+1]   ; [ES:BP+DPB.UNIT]
                push    bx
                push    es
                call    SETWRITE

DODSKOP:                                ; ...
                mov     cx, ds
                pop     ds              ; DS:BP points to DPB
                push    ds
                lds     si, ds:[bp+13h] ; [ds:BP+DPB.DRIVER_ADDR]
                call    DEVIOCALL2
                mov     ds, cx
                pop     es
                pop     bx
                pop     di
                mov     cx, ss:CALLBPB  ; [SS:CALLSCNT] ; Number of sectors transferred
                mov     ax, ss:DEVCALL_REQSTAT
                sub     cx, di
                neg     cx              ; Number of sectors not transferred
                test    ax, 8000h       ; test ah,(STERR>>8)
                retn
DSKWRITE        endp


; =============== S U B R O U T I N E =======================================


HARDERRRW       proc near               ; ...
                cmp     al, 0Fh         ; error_I24_wrong_disk
                jnz     short DO_ERR
                push    ax
                push    es
                les     ax, ss:CALLVIDRW
                mov     word ptr ss:EXTERRPT, ax
                mov     word ptr ss:EXTERRPT+2, es
                pop     es
                pop     ax

DO_ERR:                                 ; ...
                call    HARDERR
                retn
HARDERRRW       endp


; =============== S U B R O U T I N E =======================================


SETUP           proc near               ; ...
                lds     si, es:[di+7]
                mov     word ptr ss:58Ch, ds
                mov     bx, ss
                mov     ds, bx
                mov     bx, ds:32Ch
                mov     ds:58Ah, si
                mov     ds:5B8h, bx
                mov     byte ptr ds:574h, 0
                mov     ax, es:[di+15h]
                mov     dx, es:[di+17h]
                mov     ds:5CEh, ax
                mov     ds:5D0h, dx
                test    word ptr es:[di+5], 8080h
                jnz     short loc_8162
                push    es
                les     bp, ds:58Ah
                mov     bl, es:[bp+0]
                push    cx
                mov     ds:576h, bl
                mov     bx, es:[bp+2]
                call    DIV32
                mov     ds:5CCh, dx
                mov     ds:5C4h, ax
                mov     ds:5C6h, cx
                mov     bx, ax
                mov     dx, cx
                and     bl, es:[bp+4]
                mov     ds:573h, bl
                call    sub_8788
                pop     cx
                cmp     word ptr es:[bp+0Fh], 0
                jnz     short loc_8150
                cmp     dx, es:[bp+2Fh]
                jnz     short loc_8158
                cmp     ax, es:[bp+2Dh]
                jmp     short loc_8158
; ---------------------------------------------------------------------------

loc_8150:                               ; ...
                or      dx, dx
                jnz     short loc_8178
                cmp     ax, es:[bp+0Dh]

loc_8158:                               ; ...
                ja      short loc_8178
                mov     ds:5BCh, ax
                mov     ds:0ADEh, dx
                pop     es

loc_8162:                               ; ...
                mov     ax, cx
                add     ax, ds:32Ch
                jb      short loc_816B
                retn
; ---------------------------------------------------------------------------

loc_816B:                               ; ...
                mov     ax, ds:32Ch
                neg     ax
                jnz     short loc_8173
                dec     ax

loc_8173:                               ; ...
                mov     cx, ax
                jcxz    short loc_817B
                retn
; ---------------------------------------------------------------------------

loc_8178:                               ; ...
                pop     es
                xor     cx, cx

loc_817B:                               ; ...
                pop     bx
                clc
                retn
SETUP           endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


BREAKDOWN       proc near               ; ...
                mov     ax, ds:5CCh
                mov     bx, cx
                or      ax, ax
                jz      short loc_8195
                sub     ax, es:[bp+2]
                neg     ax
                sub     bx, ax
                jnb     short loc_8195
                add     ax, bx
                xor     bx, bx

loc_8195:                               ; ...
                mov     ds:5D2h, ax
                mov     ax, bx
                xor     dx, dx
                div     word ptr es:[bp+2]
                mov     ds:5D6h, ax
                mov     ds:5D4h, dx

locret_81A7:                            ; ...
                retn
BREAKDOWN       endp


; =============== S U B R O U T I N E =======================================


sub_81A8        proc near               ; ...
                mov     byte ptr ds:575h, 0

loc_81AD:                               ; ...
                test    byte ptr es:[di+3], 80h
                jnz     short loc_81C2
                push    cx
                mov     cl, es:[di+2]
                and     cl, 0F0h
                cmp     cl, 0
                pop     cx
                jnz     short loc_81C7

loc_81C2:                               ; ...
                call    sub_C5DD
                jnb     short locret_81A7

loc_81C7:                               ; ...
                xor     cx, cx
                mov     ax, 21h ; '!'
                stc

locret_81CD:                            ; ...
                retn
sub_81A8        endp


; =============== S U B R O U T I N E =======================================


sub_81CE        proc near               ; ...
                mov     byte ptr ds:575h, 1
                jmp     short loc_81AD
sub_81CE        endp


; =============== S U B R O U T I N E =======================================


sub_81D5        proc near               ; ...

; FUNCTION CHUNK AT 821D SIZE 00000006 BYTES
; FUNCTION CHUNK AT 822C SIZE 0000008E BYTES
; FUNCTION CHUNK AT 82BD SIZE 0000001A BYTES

                mov     ax, es:[di+11h]
                mov     bx, es:[di+13h]
                sub     ax, ds:5CEh
                sbb     bx, ds:5D0h
                jb      short loc_8215
                jnz     short loc_81F3
                or      ax, ax
                jz      short loc_8215
                cmp     ax, cx
                jnb     short loc_81F3
                mov     cx, ax

loc_81F3:                               ; ...
                call    sub_804D
                jb      short locret_81CD
                les     bp, ds:58Ah
                call    BREAKDOWN
                mov     cx, ds:5BCh
                mov     dx, ds:0ADEh
                call    FNDCLUS
                jb      short sub_8223
                cmp     word ptr ds:0AF8h, 0
                jnz     short loc_8215
                jcxz    short loc_822C

loc_8215:                               ; ...
                mov     ah, 0Eh
                jmp     loc_8496
sub_81D5        endp


; =============== S U B R O U T I N E =======================================

; Attributes: thunk

sub_821A        proc near               ; ...
                jmp     sub_82D7
sub_821A        endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR sub_81D5

loc_821D:                               ; ...
                pop     cx
                pop     bx
                pop     word ptr ds:0AECh
; END OF FUNCTION CHUNK FOR sub_81D5

; =============== S U B R O U T I N E =======================================


sub_8223        proc near               ; ...
                push    ss
                pop     ds
sub_8223        endp


; =============== S U B R O U T I N E =======================================


sub_8225        proc near               ; ...
                xor     cx, cx
                mov     ax, 5
                stc
                retn
sub_8225        endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR sub_81D5

loc_822C:                               ; ...
                mov     ds:5BAh, dx
                mov     ds:5BCh, bx
                mov     bx, ds:0AE8h
                mov     ds:0ADEh, bx
                cmp     word ptr ds:5D2h, 0
                jz      short loc_8248
                call    sub_990E
                jb      short sub_8223

loc_8248:                               ; ...
                cmp     word ptr ds:5D6h, 0
                jz      short loc_82BD
                call    NEXTSEC
                jb      short sub_821A
                mov     byte ptr ds:574h, 1
                mov     dl, ds:573h
                mov     cx, ds:5D6h
                mov     bx, ds:0ADEh
                mov     ds:0AE8h, bx
                mov     bx, ds:5BCh

loc_826D:                               ; ...
                call    OPTIMIZE
                jb      short sub_8223
                push    word ptr ds:0AECh
                push    di
                push    ax
                push    bx
                mov     byte ptr ds:34Bh, 38h ; '8'
                mov     ds, word ptr ds:32Eh
                push    dx
                push    cx
                call    null_sub
                call    DREAD
                pop     cx
                pop     dx
                pop     word ptr ss:60Ch
                jb      short loc_821D
                mov     word ptr ss:60Eh, ds
                call    DskRdBufScan
                mov     cx, ss
                mov     ds, cx
                pop     cx
                pop     bx
                pop     word ptr ds:0AE8h
                jcxz    short loc_82BD
                call    IsEOF
                jnb     short sub_82D7
                mov     dl, 0
                add     word ptr ds:5BAh, 1
                adc     word ptr ds:0AE2h, 0
                jmp     short loc_826D
; END OF FUNCTION CHUNK FOR sub_81D5

; =============== S U B R O U T I N E =======================================

; Attributes: thunk

sub_82BA        proc near               ; ...
                jmp     sub_8223
sub_82BA        endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR sub_81D5

loc_82BD:                               ; ...
                mov     ax, ds:5D4h
                or      ax, ax
                jz      short sub_82D7
                mov     ds:5D2h, ax
                call    NEXTSEC
                jb      short sub_82D7
                mov     word ptr ds:5CCh, 0
                call    sub_990E
                jb      short sub_82BA
; END OF FUNCTION CHUNK FOR sub_81D5

; =============== S U B R O U T I N E =======================================


sub_82D7        proc near               ; ...
                les     di, ds:59Eh

loc_82DB:                               ; ...
                mov     cx, ds:5B8h
                sub     cx, ds:32Ch
                test    byte ptr es:[di+5], 80h
                jnz     short sub_8306
                mov     ax, ds:0ADEh
                mov     es:[di+37h], ax
                mov     ax, ds:0AE2h
                mov     es:[di+0Bh], ax
                mov     ax, ds:5BCh
                mov     es:[di+35h], ax
                mov     ax, ds:5BAh
                mov     es:[di+19h], ax
sub_82D7        endp


; =============== S U B R O U T I N E =======================================


sub_8306        proc near               ; ...
                jcxz    short loc_8311
                add     es:[di+15h], cx
                adc     word ptr es:[di+17h], 0

loc_8311:                               ; ...
                clc
                retn
sub_8306        endp


; =============== S U B R O U T I N E =======================================


DskRdBufScan    proc near               ; ...
                cmp     ss:DirtyBufferCount, 0
                jz      short locret_8357
                mov     bx, ss:HIGH_SECTOR
                add     cx, dx
                mov     si, bx
                adc     si, 0
                call    GETCURHEAD
                mov     ax, [di+2]
                mov     ss:117Eh, ax
                mov     al, es:[bp+0]

bufq:                                   ; ...
                cmp     al, [di+4]
                jnz     short loc_834E
                cmp     bx, [di+8]
                jnz     short loc_8342
                cmp     dx, [di+6]

loc_8342:                               ; ...
                ja      short loc_834E
                cmp     si, [di+8]
                jnz     short loc_834C
                cmp     cx, [di+6]

loc_834C:                               ; ...
                ja      short loc_8358

loc_834E:                               ; ...
                cmp     di, ss:117Eh
                mov     di, [di]
                jnz     short bufq

locret_8357:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_8358:                               ; ...
                push    ax
                test    byte ptr [di+5], 40h
                jz      short loc_838F
                push    cx
                push    dx
                push    si
                push    di
                push    es
                mov     ax, dx
                sub     ax, [di+6]
                neg     ax
                mov     cx, es:[bp+2]
                lea     si, [di+18h]
                mul     cx
                les     di, ss:60Ch
                add     di, ax
                shr     cx, 1
                cmp     byte ptr ss:6Ah, 0
                jz      short near ptr loc_8387+1
                shr     cx, 1

loc_8387:                               ; ...
                rep movsd
                pop     es
                pop     di
                pop     si
                pop     dx
                pop     cx

loc_838F:                               ; ...
                mov     ax, di
                call    SCANPLACE
                cmp     ax, ss:FIRST_BUFF_ADDR
                pop     ax
                jnz     short bufq
                retn
DskRdBufScan    endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR _WRITE_OK

WRTEOFJ:                                ; ...
                jmp     WRTEOF
; END OF FUNCTION CHUNK FOR _WRITE_OK
; ---------------------------------------------------------------------------

loc_83A0:                               ; ...
                jmp     locret_84A0

; =============== S U B R O U T I N E =======================================


_WRITE_OK       proc near               ; ...

; FUNCTION CHUNK AT 839D SIZE 00000003 BYTES

                call    sub_802E
                jb      short loc_83A0
                and     word ptr es:[di+5], 0BFBFh ; [ES:DI+SF_ENTRY.sf_flags],
                                        ; ~(sf_close_nodate|devid_file_clean)
                les     ax, es:[di+11h] ; [ES:DI+SF_ENTRY.sf_size]
                mov     ds:TEMP_VAR2, es
                mov     ds:TEMP_VAR, ax
                les     bp, ds:THISDPB
                call    BREAKDOWN
                mov     ax, word ptr ds:BYTPOS
                mov     dx, word ptr ds:BYTPOS+2
                jcxz    short WRTEOFJ
                add     ax, cx
                adc     dx, 0
                jnb     short loc_83D3

loc_83D0:                               ; ...
                jmp     SET_ACC_ERRW
; ---------------------------------------------------------------------------

loc_83D3:                               ; ...
                test    byte ptr es:[di+3], 10h
                jnz     short loc_83E5
                cmp     dx, 7FFFh
                jnz     short loc_83E3
                cmp     ax, 0FFFFh

loc_83E3:                               ; ...
                ja      short loc_83D0

loc_83E5:                               ; ...
                mov     bx, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE]
                call    DIV32
                mov     si, ax
                mov     ds:HIGH_SECTOR, cx
                or      dx, dx
                push    dx
                mov     dx, cx
                jnz     short CALCLUS
                sub     ax, 1
                sbb     dx, 0

CALCLUS:                                ; ...
                call    sub_8788
                pop     cx
                xchg    cx, dx
                push    cx
                push    ax
                push    dx
                mov     dx, ds:TEMP_VAR2
                mov     ax, ds:TEMP_VAR
                call    DIV32
                mov     ds:TEMP_VAR2, cx
                mov     ds:VALSEC+2, cx
                mov     cx, ax
                mov     bx, si
                or      dx, dx
                jz      short NORND
                add     ax, 1           ; Round up if any remainder
                adc     ds:VALSEC+2, 0

NORND:                                  ; ...
                mov     ds:VALSEC, ax
                xor     ax, ax
                mov     word ptr ds:GROWCNT, ax
                mov     word ptr ds:GROWCNT+2, ax
                mov     di, ds:HIGH_SECTOR
                pop     ax
                cmp     di, ds:TEMP_VAR2
                jb      short NOGROW
                jz      short lowsec
                sub     bx, cx
                sbb     di, ds:TEMP_VAR2
                jmp     short yesgrow
; ---------------------------------------------------------------------------

lowsec:                                 ; ...
                xor     di, di
                sub     bx, cx
                jb      short NOGROW
                jz      short TESTTAIL

yesgrow:                                ; ...
                mov     cx, dx
                xchg    ax, bx
                mul     word ptr es:[bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
                                        ; Bytes of full sector growth
                mov     ds:HIGH_SECTOR, dx
                mov     ds:TEMP_VAR2, ax
                mov     ax, di
                mul     word ptr es:[bp+2]
                add     ax, ds:HIGH_SECTOR
                xchg    ax, dx
                mov     ax, ds:TEMP_VAR2
                sub     ax, cx
                sbb     dx, 0
                add     ax, bx
                adc     dx, 0
                jmp     short SETGRW
; ---------------------------------------------------------------------------

HAVSTART:                               ; ...
                mov     ds:CLSKIP_HW, si
                mov     cx, ax
                call    SKPCLP
                mov     ax, ds:CLSKIP_HW
                cmp     ax, cx
                jnz     short loc_848C
                jcxz    short loc_84A1

loc_848C:                               ; ...
                mov     ds:word_AF0, ax
                call    ALLOCATE
                jnb     short loc_84A1

loc_8494:                               ; ...
                mov     ah, 0Fh

loc_8496:                               ; ...
                mov     al, ds:THISDRV
                xor     cx, cx
                les     di, ds:THISSFT
                clc

locret_84A0:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_84A1:                               ; ...
                jmp     DOWRT
; ---------------------------------------------------------------------------

TESTTAIL:                               ; ...
                sub     ax, dx
                jbe     short NOGROW
                xor     dx, dx

SETGRW:                                 ; ...
                mov     word ptr ds:GROWCNT, ax
                mov     word ptr ds:GROWCNT+2, dx

NOGROW:                                 ; ...
                mov     cx, ds:CLUSNUM  ; First cluster accessed
                mov     dx, ds:CLUSNUM_HW
                call    FNDCLUS
                pop     ax
                pop     si
                jb      short ACC_ERRWJ
                mov     ds:CLUSNUM, bx
                mov     ds:LASTPOS, dx
                sub     ax, dx          ; Last cluster minus current cluster
                sbb     si, ds:LASTPOS_HW
                mov     dx, ds:CLUSTNUM_HW
                mov     ds:CLUSNUM_HW, dx
                jnz     short NOGROW2
                or      ax, ax
                jz      short DOWRT

NOGROW2:                                ; ...
                cmp     cx, ds:CLSKIP_HW
                jnz     short loc_84E4
                jcxz    short HAVSTART

loc_84E4:                               ; ...
                push    cx
                push    word ptr ds:0AF8h
                mov     ds:0AF0h, si
                mov     cx, ax
                call    ALLOCATE
                pop     word ptr ds:0AF8h
                pop     cx
                jb      short loc_8494
                mov     dx, ds:5BAh
                add     dx, 1
                adc     word ptr ds:0AE2h, 0
                sub     cx, 1
                sbb     word ptr ds:0AF8h, 0
                jnz     short loc_8511
                or      cx, cx

loc_8511:                               ; ...
                jz      short NOSKIP
                call    SKPCLP
                jnb     short NOSKIP

ACC_ERRWJ:                              ; ...
                jmp     SET_ACC_ERRW
; ---------------------------------------------------------------------------

NOSKIP:                                 ; ...
                mov     ds:CLUSNUM, bx
                mov     ax, ds:CLUSTNUM_HW
                mov     ds:CLUSNUM_HW, ax
                mov     ds:LASTPOS, dx

DOWRT:                                  ; ...
                cmp     ds:BYTCNT1, 0
                jz      short WRTMID
                mov     bx, ds:CLUSNUM_HW
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, ds:CLUSNUM
                call    BUFWRT
                jb      short ACC_ERRWJ

WRTMID:                                 ; ...
                mov     ax, ds:SECCNT
                or      ax, ax
                jnz     short WRTMID2
                jmp     WRTLAST
; ---------------------------------------------------------------------------

WRTMID2:                                ; ...
                add     word ptr ds:SECPOS, ax
                adc     word ptr ds:SECPOS+2, 0
                call    NEXTSEC
                jb      short SET_ACC_ERRW
                mov     ds:TRANS, 1
                mov     dl, ds:SECCLUSPOS
                mov     bx, ds:CLUSNUM_HW
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, ds:CLUSNUM
                mov     cx, ds:SECCNT

WRTLP:                                  ; ...
                call    OPTIMIZE
                jb      short SET_ACC_ERRW
                push    ds:CCONTENT_HW
                push    di
                push    ax
                call    DskWrtBufPurge
                mov     ds, word ptr ss:DMAADD+2
                mov     ss:ALLOWED, 38h

loc_858B:                               ; ...
                call    DSKWRITE
                jz      short loc_85A7
                cmp     al, 27h ; '''
                jz      short loc_85C2
                mov     byte ptr ss:575h, 1
                call    HARDERRRW
                cmp     al, 1
                jz      short loc_858B
                cmp     al, 3
                clc
                jnz     short loc_85A7
                stc

loc_85A7:                               ; ...
                pop     cx
                pop     bx
                pop     word ptr ss:0AE8h
                push    ss
                pop     ds
                jb      short SET_ACC_ERRW
                jcxz    short WRTLAST
                mov     dl, 0
                add     word ptr ds:5BAh, 1
                adc     word ptr ds:0AE2h, 0
                jmp     short WRTLP
; ---------------------------------------------------------------------------

loc_85C2:                               ; ...
                push    ss
                pop     ds
                pop     cx
                pop     bx
                pop     word ptr ds:0AE8h
                mov     byte ptr ds:60Bh, 1
                stc
                jmp     loc_8494
; ---------------------------------------------------------------------------

SET_ACC_ERRW:                           ; ...
                jmp     sub_8223
; ---------------------------------------------------------------------------

WRTLAST:                                ; ...
                mov     ax, ds:5D4h
                or      ax, ax
                jz      short loc_85F0
                mov     ds:5D2h, ax
                call    NEXTSEC
                jb      short SET_ACC_ERRW
                mov     word ptr ds:5CCh, 0
                call    BUFWRT

loc_85EE:                               ; ...
                jb      short SET_ACC_ERRW

loc_85F0:                               ; ...
                les     di, ds:59Eh
                mov     ax, ds:5DEh
                mov     cx, ds:5E0h
                or      ax, ax
                jnz     short loc_8601
                jcxz    short loc_8610

loc_8601:                               ; ...
                add     es:[di+11h], ax
                adc     es:[di+13h], cx
                mov     ax, 1
                call    dword ptr ds:0C8h

loc_8610:                               ; ...
                jmp     loc_82DB
; ---------------------------------------------------------------------------

WRTEOF:                                 ; ...
                mov     cx, ax
                or      cx, dx
                jnz     short loc_861C
                jmp     loc_86C6
; ---------------------------------------------------------------------------

loc_861C:                               ; ...
                cmp     dx, 7FFFh
                jnz     short loc_8625
                cmp     ax, 0FFFFh

loc_8625:                               ; ...
                jbe     short loc_8634
                push    es
                les     di, ds:THISSFT
                test    byte ptr es:[di+3], 10h
                pop     es
                jz      short SET_ACC_ERRW

loc_8634:                               ; ...
                sub     ax, 1
                sbb     dx, 0
                push    bx
                mov     bx, es:[bp+2]
                call    DIV32
                pop     bx
                mov     dx, cx
                mov     ds:607h, cx
                call    sub_8788
                mov     cx, ax
                call    FNDCLUS

loc_8651:                               ; ...
                jb      short loc_85EE
                mov     ax, ds:0AF8h
                cmp     ax, cx
                jnz     short loc_865C
                jcxz    short loc_8685

loc_865C:                               ; ...
                mov     ds:0AF0h, ax
                call    ALLOCATE
                jb      short loc_8682

loc_8664:                               ; ...
                mov     ax, ds:5CEh
                les     di, ds:59Eh
                mov     es:[di+11h], ax
                mov     ax, ds:5D0h
                mov     es:[di+13h], ax
                mov     ax, 2
                call    dword ptr ds:0C8h
                xor     cx, cx
                jmp     sub_8306
; ---------------------------------------------------------------------------

loc_8682:                               ; ...
                jmp     loc_8494
; ---------------------------------------------------------------------------

loc_8685:                               ; ...
                push    es
                les     di, ds:59Eh
                push    ax
                mov     ax, ds:0AE2h
                cmp     ax, es:[di+0Bh]
                pop     ax
                jnz     short loc_8699
                cmp     dx, es:[di+19h]

loc_8699:                               ; ...
                jnb     short loc_86B7
                mov     dx, es:[di+2Bh]
                mov     word ptr es:[di+19h], 0
                mov     es:[di+35h], dx
                mov     word ptr es:[di+0Bh], 0
                mov     dx, es:[di+2Dh]
                mov     es:[di+37h], dx

loc_86B7:                               ; ...
                pop     es
                xor     dx, dx
                dec     dx
                mov     ds:0AEAh, dx
                call    RELBLKS

loc_86C2:                               ; ...
                jb      short loc_8651

loc_86C4:                               ; ...
                jmp     short loc_8664
; ---------------------------------------------------------------------------

loc_86C6:                               ; ...
                xor     bx, bx
                push    es
                les     di, ds:THISSFT
                xchg    bx, es:[di+2Dh]
                mov     ds:CLUSTNUM_HW, bx
                xor     bx, bx
                mov     es:[di+0Bh], bx
                mov     es:[di+37h], bx
                mov     es:[di+19h], bx
                mov     es:[di+35h], bx
                xchg    bx, es:[di+2Bh]
                pop     es
                cmp     bx, ds:CLUSTNUM_HW
                jnz     short loc_86F4
                or      bx, bx

loc_86F4:                               ; ...
                jz      short loc_86C4
                push    es
                push    bp
                push    ax
                push    cx
                les     bp, ds:THISDPB
                push    dx
                mov     dl, es:[bp+0]
                mov     cx, bx
                mov     ah, 2
                call    FastOpen_Update
                pop     dx
                pop     cx
                pop     ax
                pop     bp
                pop     es
                call    RELEASE
                jmp     short loc_86C2
_WRITE_OK       endp


; =============== S U B R O U T I N E =======================================


DskWrtBufPurge  proc near               ; ...
                push    bx
                push    cx
                mov     bx, ss:HIGH_SECTOR
                add     cx, dx
                mov     si, bx
                adc     si, 0
                mov     al, es:[bp+0]   ; [es:bp+DPB.DRIVE]
                call    GETCURHEAD

_bufq:                                  ; ...
                cmp     al, [di+4]      ; [di+BUFFINFO.buf_ID] ; Same drive?
                jnz     short bufq5     ; no
                cmp     bx, [di+8]      ; [di+BUFFINFO.buf_sector+2]
                jnz     short bufq04
                cmp     dx, [di+6]      ; [di+BUFFINFO.buf_sector]

bufq04:                                 ; ...
                ja      short bufq5
                cmp     si, [di+8]
                jnz     short bufq05
                cmp     cx, [di+6]

bufq05:                                 ; ...
                jbe     short bufq5
                test    byte ptr [di+5], 40h ; [di+BUFFINFO.buf_flags],buf_dirty
                jz      short bufq4
                call    DEC_DIRTY_COUNT

bufq4:                                  ; ...
                mov     word ptr [di+4], 20FFh ; [di+BUFFINFO.buf_ID],
                                        ; ((buf_visit<<8)|0FFh)
                call    SCANPLACE
                jmp     short bufq6
; ---------------------------------------------------------------------------

bufq5:                                  ; ...
                mov     di, [di]        ; [di+BUFFINFO.buf_next]

bufq6:                                  ; ...
                cmp     di, ss:FIRST_BUFF_ADDR
                jnz     short _bufq     ; go do next buffer.
                pop     cx
                pop     bx
                retn
DskWrtBufPurge  endp


; =============== S U B R O U T I N E =======================================


DIV32           proc near               ; ...
                cmp     bx, 512
                jnz     short loc_877C
                mov     cx, dx
                mov     dx, ax
                and     dx, 1FFh
                mov     al, ah
                mov     ah, cl
                mov     cl, ch
                xor     ch, ch
                shr     cx, 1
                rcr     ax, 1
                retn
; ---------------------------------------------------------------------------

loc_877C:                               ; ...
                mov     cx, ax
                mov     ax, dx
                xor     dx, dx
                div     bx
                xchg    ax, cx
                div     bx
                retn
DIV32           endp


; =============== S U B R O U T I N E =======================================


sub_8788        proc near               ; ...
                mov     cl, es:[bp+5]
                xor     ch, ch
                jcxz    short locret_8796

loc_8790:                               ; ...
                shr     dx, 1
                rcr     ax, 1
                loop    loc_8790

locret_8796:                            ; ...
                retn
sub_8788        endp


; =============== S U B R O U T I N E =======================================


FINDENTRY       proc near               ; ...
                call    STARTSRCH
                mov     al, ds:ATTRIB
                and     al, 9Eh
                cmp     al, 8
                jnz     short loc_87A6
                call    SETDIRSRCH_FAT

loc_87A6:                               ; ...
                call    GETENTRY
                jnb     short SRCH
                jb      short loc_8800

SRCH:                                   ; ...
                mov     word ptr ds:0AA5h, 0

loc_87B3:                               ; ...
                push    ds
                mov     ds, word ptr ds:CURBUF+2
                mov     ah, [bx]
                or      ah, ah
                jz      short loc_8812
                push    ax
                mov     al, [bx+0Bh]
                call    sub_8B94
                pop     ax
                jz      short loc_8802
                cmp     ah, ss:DELALL
                jz      short loc_8812
                test    byte ptr [bx+0Bh], 8
                jz      short loc_87DA
                inc     ss:VOLID

loc_87DA:                               ; ...
                mov     si, ss
                mov     es, si
                mov     si, bx
                mov     di, offset NAME1
                cmp     ss:NAME1, 0E5h
                jnz     short loc_87F1
                mov     ss:NAME1, 5

loc_87F1:                               ; ...
                call    sub_8875
                jz      short loc_882E
                pop     ds
FINDENTRY       endp


; =============== S U B R O U T I N E =======================================


NEXTENT         proc near               ; ...
                les     bp, ds:THISDPB
                call    NEXTENTRY
                jnb     short SRCH

loc_8800:                               ; ...
                jmp     short SETESRET
; ---------------------------------------------------------------------------

loc_8802:                               ; ...
                pop     ds
                inc     word ptr ds:0AA5h

loc_8807:                               ; ...
                les     bp, ds:THISDPB
                call    NEXTENTRY
                jnb     short loc_87B3
                jmp     short SETESRET
; ---------------------------------------------------------------------------

loc_8812:                               ; ...
                pop     ds
                mov     cx, ds:LASTENT
                cmp     cx, ds:ENTFREE
                jnb     short loc_8821
                mov     ds:ENTFREE, cx

loc_8821:                               ; ...
                cmp     ah, ds:DELALL
                jz      short loc_8807
                mov     ds:ENTLAST, cx
                stc
                jmp     short SETESRET
; ---------------------------------------------------------------------------

loc_882E:                               ; ...
                mov     ch, [si]
                pop     ds
                mov     ah, ds:ATTRIB
                and     ah, 9Eh         ; ~attr_ignore
                lea     si, [si+0Fh]    ; [SI+dir_entry.dir_first-dir_entry.dir_attr]
                test    ch, 8           ; attr_volume_id
                jz      short check_one_volume_id
                test    ah, 8           ; attr_volume_id
                jz      short NEXTENT
                xor     ah, ah
                jmp     short RETFF
; ---------------------------------------------------------------------------

check_one_volume_id:                    ; ...
                cmp     ah, 8           ; attr_volume_id
                jz      short NEXTENT
                call    MatchAttributes
                jz      short RETFF
                test    ds:CREATING, 0FFh ; -1
                jz      short NEXTENT

RETFF:                                  ; ...
                les     bp, ds:THISDPB
                mov     ah, es:[bp+0]

SETESRET:                               ; ...
                push    ss
                pop     es
                push    ds:ENTLAST
                pop     word ptr ds:0AB5h
                jnb     short locret_8874
                mov     word ptr ds:0AA5h, 0

locret_8874:                            ; ...
                retn
NEXTENT         endp


; =============== S U B R O U T I N E =======================================


sub_8875        proc near               ; ...
                mov     cx, 0Bh

loc_8878:                               ; ...
                repe cmpsb
                jz      short locret_8883
                cmp     byte ptr es:[di-1], 3Fh ; '?'
                jz      short loc_8878

locret_8883:                            ; ...
                retn
sub_8875        endp


; =============== S U B R O U T I N E =======================================


NEXTENTRY       proc near               ; ...
                mov     ax, ds:LASTENT
                cmp     ax, ds:ENTLAST
                jz      short loc_88D4
                inc     ax
                lea     bx, [bx+20h]
                cmp     bx, dx
                jnz     short loc_88D6
                cmp     ds:DIRSTART, 0
                jnz     short loc_88AB
                cmp     ds:DIRSTART_HW, 0
                jnz     short loc_88AB
                cmp     ax, es:[bp+9]
                jnb     short loc_88D4
                jmp     short GETENT
; ---------------------------------------------------------------------------

loc_88AB:                               ; ...
                mov     bl, ds:SECCLUSPOS
                inc     bl
                cmp     bl, ds:CLUSFAC
                jb      short loc_88DB
                mov     bx, ds:0AE0h
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, ds:5DCh
                call    IsEOF
                jnb     short loc_88D4
                cmp     ds:CLUSTNUM_HW, 0
                jnz     short GETENT
                cmp     bx, 2
                jnb     short GETENT

loc_88D4:                               ; ...
                stc
                retn
; ---------------------------------------------------------------------------

loc_88D6:                               ; ...
                mov     ds:LASTENT, ax
                clc

locret_88DA:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_88DB:                               ; ...
                mov     ds:SECCLUSPOS, bl
                mov     ds:LASTENT, ax
                push    ds
                lds     di, ds:CURBUF
                lds     dx, [di+6]
                mov     ss:HIGH_SECTOR, ds
                add     dx, 1
                adc     ss:HIGH_SECTOR, 0
                pop     ds
                call    sub_7F91
                xor     bx, bx
                jmp     short loc_8924
NEXTENTRY       endp


; =============== S U B R O U T I N E =======================================


GETENTRY        proc near               ; ...
                mov     ax, ds:LASTENT

GETENT:                                 ; ...
                mov     ds:LASTENT, ax
                mov     cl, 5
                rol     ax, cl
                mov     dx, ax
                and     ax, 0FFE0h
                and     dx, 1Fh
                mov     bx, es:[bp+2]
                and     bl, 0E0h
                div     bx
                mov     bx, dx
                push    dx
                call    sub_7F07
                pop     bx
                jb      short locret_88DA

loc_8924:                               ; ...
                mov     dx, word ptr ds:CURBUF
                add     dx, 18h
                add     bx, dx
                add     dx, es:[bp+2]
                clc
                retn
GETENTRY        endp

; ---------------------------------------------------------------------------
sft_fcb_table   db 20 dup(0)            ; ...
sftfcb0_cluster dw 2 dup(0)             ; ...
sftfcb0_direntr dw 0                    ; ...
                db 114 dup(0)
word_89BF       dw 0                    ; ...
word_89C1       dw 0                    ; ...

; =============== S U B R O U T I N E =======================================


SETDIRSRCH      proc near               ; ...
                cmp     ds:ROOTCLUST_HW, 0
                jnz     short SETDIRSRCH_FAT32
                or      bx, bx
                jz      short SETDIRSRCH_FAT

SETDIRSRCH_FAT32:                       ; ...
                mov     ax, ds:ROOTCLUST_HW
                mov     ds:DIRSTART_HW, ax
                mov     ds:CLUSTNUM_HW, ax
                mov     ds:DIRSTART, bx
                mov     al, es:[bp+4]
                inc     al
                mov     ds:CLUSFAC, al
                push    si
                test    ds:FastOpenFlg, 2
                jnz     short loc_89F3
                call    UNPACK
                jnb     short loc_89F3
                pop     si
                retn
; ---------------------------------------------------------------------------

loc_89F3:                               ; ...
                mov     ds:CLUSNUM, di
                mov     dx, ds:CCONTENT_HW
                mov     ds:CLUSNUM_HW, dx
                mov     cs:word_89BF, bx
                mov     dx, ds:CLUSTNUM_HW
                mov     cs:word_89C1, dx
                mov     dx, bx
                xor     bl, bl
                mov     ds:SECCLUSPOS, bl
                call    FIGREC
                mov     si, ds:HIGH_SECTOR
                mov     ds:DIRSEC+2, si
                mov     ds:DIRSEC, dx
                pop     si
                clc
                retn
SETDIRSRCH      endp


; =============== S U B R O U T I N E =======================================


SETDIRSRCH_FAT  proc near               ; ...
                mov     ds:ROOTCLUST_HW, 0
                cmp     word ptr es:[bp+0Fh], 0 ; DPB.FAT_SIZE
                jnz     short loc_8A5E  ; FAT
                                        ; FAT32
                mov     bx, es:[bp+37h] ; DPB.ROOT_CLUSTER+2
                mov     ds:ROOTCLUST_HW, bx
                cmp     bx, es:[bp+2Fh] ; DPB.LAST_CLUSTER+2
                mov     bx, es:[bp+35h] ; DPB.ROOT_CLUSTER
                jnz     short loc_8A4A
                cmp     bx, es:[bp+2Dh] ; DPB.LAST_CLUSTER

loc_8A4A:                               ; ...
                ja      short loc_8A5B
                cmp     ds:ROOTCLUST_HW, 0
                jnz     short loc_8A58
                cmp     bx, 2
                jb      short loc_8A5B

loc_8A58:                               ; ...
                jmp     SETDIRSRCH_FAT32
; ---------------------------------------------------------------------------

loc_8A5B:                               ; ...
                stc
                jmp     short locret_8A8F
; ---------------------------------------------------------------------------

loc_8A5E:                               ; ...
                xor     ax, ax
                mov     ds:DIRSEC+2, ax
                mov     ds:DIRSTART, ax
                mov     ds:DIRSTART_HW, ax
                mov     cs:word_89C1, ax
                inc     ax
                mov     cs:word_89BF, ax
                dec     ax
                mov     ds:SECCLUSPOS, al
                dec     ax
                mov     ds:CLUSNUM, ax
                mov     ds:CLUSNUM_HW, ax
                mov     ax, es:[bp+0Bh] ; [ES:BP+DPB.FIRST_SECTOR]
                mov     dx, es:[bp+11h] ; [ES:BP+DPB.DIR_SECTOR]
                sub     ax, dx
                mov     ds:CLUSFAC, al
                mov     ds:DIRSEC, dx
                clc

locret_8A8F:                            ; ...
                retn
SETDIRSRCH_FAT  endp


; =============== S U B R O U T I N E =======================================


sub_8A90        proc near               ; ...
                push    ax
                push    cx
                push    dx
                push    bx
                push    bp
                push    si
                push    di
                call    find_sft_entry_index
                xor     bx, bx
                mov     cx, 14h

loc_8A9F:                               ; ...
                cmp     word ptr cs:[bx-76B7h], 0
                jnz     short loc_8AAD
                cmp     word ptr cs:[bx-76B9h], 0

loc_8AAD:                               ; ...
                jnz     short loc_8ADF
                push    cx
                mov     cx, cs:word_89BF
                mov     cs:[bx-76B9h], cx
                mov     cx, cs:word_89C1
                mov     cs:[bx-76B9h], cx
                pop     cx
                mov     dx, ss:348h
                mov     cs:[bx-76B5h], dx
                xchg    ax, bx
                xor     dx, dx
                mov     cx, 6
                div     cx
                xchg    ax, bx
                mov     cs:[bx-76CDh], al
                jmp     short loc_8AE4
; ---------------------------------------------------------------------------

loc_8ADF:                               ; ...
                add     bx, 6
                loop    loc_8A9F

loc_8AE4:                               ; ...
                pop     di
                pop     si
                pop     bp
                pop     bx
                pop     dx
                pop     cx
                pop     ax
                retn
sub_8A90        endp


; =============== S U B R O U T I N E =======================================


find_sft_entry_index proc near          ; ...
                push    es              ; es:di = SFT entry
                xor     cx, cx
                mov     dx, es
                mov     es, cs:DosDSeg
                les     bx, es:SFT_ADDR ; address of the first SFT

f_sfte_1:                               ; ...
                mov     ax, es
                cmp     ax, dx          ; same SFT segment ?
                jnz     short f_sfte_2  ; no
                mov     ax, di
                sub     ax, bx          ; ax = entry offset
                sub     ax, 6           ; ax = offset from start of the SFT table
                mov     bx, 59          ; SF_ENTRY.size (SFT entry size)
                xor     dx, dx
                div     bx              ; ax = SFT entry index into the table
                add     ax, cx          ; ax = SFT entry index (from the 1st SFT)
                pop     es
                retn
; ---------------------------------------------------------------------------

f_sfte_2:                               ; ...
                add     cx, es:[bx+4]   ; SFT.SFCount ; number of entries in the table
                les     bx, es:[bx]     ; SFT.SFLink
                cmp     bx, 0FFFFh      ; the last SFT
                jnz     short f_sfte_1
                stc                     ; (not found)
                pop     es
                retn
find_sft_entry_index endp


; =============== S U B R O U T I N E =======================================


int_2Fh_1230h   proc near               ; ...
                call    find_sft_entry_index ; Windows95 - FIND SFT ENTRY IN INTERNAL FILE TABLES
                jb      short find_sfte_i_error
                push    es
                push    di
                push    cs
                pop     es
                assume es:DOSCODE
                mov     cx, 20          ; statically allocated with 20 entries,
                                        ; and used only for FCB calls
                mov     di, offset sft_fcb_table

scan_next_sftfcb:                       ; ...
                repne scasb
                stc
                jnz     short sfte_i_notfound ; not found (cf=1)
                lea     bx, [di-1]      ; offset of the entry in the table
                sub     bx, offset sft_fcb_table ;
                                        ; index into new file system table
                mov     dx, bx
                add     bx, bx          ; 2*bx
                add     bx, dx          ; 3*bx
                add     bx, bx          ; bx = 6*bx
                mov     si, es:(sftfcb0_cluster+2)[bx] ; starting cluster number, hw
                mov     dx, es:sftfcb0_direntr[bx] ; directory entry number
                push    cx
                mov     cx, es:sftfcb0_cluster[bx] ; starting cluster number, lw
                or      cx, cx
                jnz     short sfte_i_found
                or      si, si
                jnz     short sfte_i_found
                pop     cx
                or      cx, cx
                jnz     short scan_next_sftfcb
                stc                     ; not found (cf=1)
                jmp     short sfte_i_notfound
; ---------------------------------------------------------------------------

sfte_i_found:                           ; ...
                pop     ax              ; clear stack
                clc                     ; found (cf=0)

sfte_i_notfound:                        ; ...
                pop     di
                pop     es
                assume es:nothing

find_sfte_i_error:                      ; ...
                mov     ax, 0
                retn
int_2Fh_1230h   endp


; =============== S U B R O U T I N E =======================================


SFT_FREE        proc near               ; ...
                push    ax
                push    cx
                push    dx
                push    bx
                push    bp
                push    si
                push    di
                mov     word ptr es:[di], 0 ; [ES:DI+SF_ENTRY.sf_ref_Count]
                call    int_2Fh_1230h
                jb      short sftf_1
                mov     cs:(sftfcb0_cluster+2)[bx], 0
                mov     cs:sftfcb0_cluster[bx], 0

sftf_1:                                 ; ...
                pop     di
                pop     si
                pop     bp
                pop     bx
                pop     dx
                pop     cx
                pop     ax
                retn
SFT_FREE        endp


; =============== S U B R O U T I N E =======================================


sub_8B94        proc near               ; ...
                and     al, 0Fh
                cmp     al, 0Fh
                retn
sub_8B94        endp


; =============== S U B R O U T I N E =======================================


GETPATH         proc near               ; ...
                mov     word ptr ds:CREATING, 0E500h
GETPATH         endp


; =============== S U B R O U T I N E =======================================


GetPathNoSet    proc near               ; ...

; FUNCTION CHUNK AT 8C9D SIZE 000001B6 BYTES

                call    set_exerr_locus_disk
                mov     word ptr ds:CURBUF, 0FFFFh
                mov     di, ds:WFP_START
                cmp     word ptr [di+1], 5C3Ah ; ':\'
                jz      short loc_8BEA
                add     di, 3
                mov     si, di
                call    sub_8C72
                jb      short loc_8BE8

loc_8BBD:                               ; ...
                mov     al, ds:SATTRIB
                mov     ds:ATTRIB, al
                call    set_exerr_locus_unk
                push    ss
                pop     es
                mov     si, offset NAME1
                mov     di, ds:WFP_START
                mov     dx, di
                mov     cx, 8

loc_8BD4:                               ; ...
                lodsb
                stosb
                cmp     al, 20h ; ' '
                jz      short loc_8BDC
                mov     dx, di

loc_8BDC:                               ; ...
                loop    loc_8BD4
                mov     di, dx
                mov     [di], cl
                call    sub_8ED3
                inc     al
                retn
; ---------------------------------------------------------------------------

loc_8BE8:                               ; ...
                jmp     short loc_8BE8
; ---------------------------------------------------------------------------

loc_8BEA:                               ; ...
                mov     ds:ATTRIB, 16h
                les     di, ds:THISCDS
                mov     ax, 0FFFFh
                mov     bx, es:[di+4Bh]
                mov     ds:ROOTCLUST_HW, bx
                mov     bx, es:[di+49h]
                mov     si, ds:CURR_DIR_END
                cmp     si, ax
                jz      short loc_8C58
                cmp     ds:ROOTCLUST_HW, ax
                jnz     short loc_8C12
                cmp     bx, ax

loc_8C12:                               ; ...
                jz      short loc_8C58
                test    ds:FastOpenFlg, 1
                jz      short loc_8C65
                push    es
                push    di
                push    cx
                push    word ptr [si-1]
                push    si
                push    bx
                push    ds:ROOTCLUST_HW
                mov     byte ptr [si-1], 0
                mov     si, ds:WFP_START
                mov     bx, offset FastOpenTable
                mov     di, 0D7Ch
                mov     cx, 1147h
                mov     al, 1
                push    ds
                pop     es
                call    dword ptr [bx+2]
                jb      short loc_8C49
                cmp     byte ptr [si], 0
                jz      short loc_8C4A
                stc
                jmp     short loc_8C4A
; ---------------------------------------------------------------------------

loc_8C49:                               ; ...
                clc

loc_8C4A:                               ; ...
                pop     word ptr ds:0AEEh
                pop     bx
                pop     si
                pop     word ptr [si-1]
                pop     cx
                pop     di
                pop     es
                jnb     short loc_8C65

loc_8C58:                               ; ...
                mov     si, ds:5B2h
                add     si, 3
                les     bp, ds:58Ah
                jmp     short loc_8C9D
; ---------------------------------------------------------------------------

loc_8C65:                               ; ...
                les     bp, ds:58Ah
                call    SETDIRSRCH
                jnb     short loc_8CAE
                xor     cl, cl
                stc
                retn
GetPathNoSet    endp


; =============== S U B R O U T I N E =======================================


sub_8C72        proc near               ; ...
                mov     si, di
                push    ss
                pop     es
                mov     di, 54Bh
                mov     cx, 9

loc_8C7C:                               ; ...
                call    sub_9EE4
                cmp     al, 2Eh ; '.'
                jz      short loc_8C91
                call    PATHCHRCMP
                jz      short loc_8C8F
                or      al, al
                jz      short loc_8C91
                stosb
                loop    loc_8C7C

loc_8C8F:                               ; ...
                stc
                retn
; ---------------------------------------------------------------------------

loc_8C91:                               ; ...
                inc     cx
                inc     cx
                mov     al, 20h ; ' '
                rep stosb
                push    ss
                pop     ds
                call    DEVNAME
                retn
sub_8C72        endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR GetPathNoSet

loc_8C9D:                               ; ...
                call    SETDIRSRCH_FAT
                cmp     byte ptr [si], 0
                jnz     short loc_8CAE
                mov     al, ds:SATTRIB
                mov     ds:ATTRIB, al
                xor     ah, ah
                retn
; ---------------------------------------------------------------------------

loc_8CAE:                               ; ...
                push    es
                push    si
                mov     di, si
                mov     cx, ds:DIRSTART
                cmp     ds:CURR_DIR_END, 0FFFFh
                jz      short loc_8CD2
                cmp     di, ds:CURR_DIR_END
                jnz     short loc_8CD2
                les     di, ds:THISCDS
                mov     ax, ds:DIRSTART_HW
                mov     es:[di+4Bh], ax
                mov     es:[di+49h], cx

loc_8CD2:                               ; ...
                push    ss
                pop     es
                mov     di, offset NAME1
                mov     ax, 2020h
                stosb
                stosw
                stosw
                stosw
                stosw
                stosw
                mov     di, offset NAME1
                xor     ah, ah

loc_8CE5:                               ; ...
                inc     cl
                lodsb
                cmp     al, 2Eh ; '.'
                jz      short loc_8CFE
                or      al, al
                jz      short loc_8D17
                cmp     al, 5Ch ; '\'
                jz      short loc_8D17
                cmp     al, 3Fh ; '?'
                jnz     short loc_8CFB
                or      ah, 1

loc_8CFB:                               ; ...
                stosb
                jmp     short loc_8CE5
; ---------------------------------------------------------------------------

loc_8CFE:                               ; ...
                mov     di, (offset NAME1+8)

loc_8D01:                               ; ...
                lodsb
                or      al, al
                jz      short loc_8D17
                cmp     al, 5Ch ; '\'
                jz      short loc_8D17
                cmp     al, 3Fh ; '?'
                jnz     short loc_8D11
                or      ah, 1

loc_8D11:                               ; ...
                stosb
                jmp     short loc_8D01
; ---------------------------------------------------------------------------

loc_8D14:                               ; ...
                jmp     loc_8E1B
; ---------------------------------------------------------------------------

loc_8D17:                               ; ...
                dec     si
                mov     cl, ah
                or      cl, 80h
                pop     di
                pop     es
                cmp     si, di
                jz      short loc_8D14
                push    si
                mov     al, [si]
                or      al, al
                jnz     short loc_8D32
                mov     bh, ds:SATTRIB
                mov     ds:ATTRIB, bh

loc_8D32:                               ; ...
                push    es
                push    ss
                pop     es
                call    DEVNAME
                pop     es
                jb      short loc_8D46
                or      al, al
                jnz     short loc_8D6C
                pop     si
                jmp     loc_8BBD
; ---------------------------------------------------------------------------

loc_8D43:                               ; ...
                jmp     loc_8E44
; ---------------------------------------------------------------------------

loc_8D46:                               ; ...
                cmp     ds:NAME1, 0E5h
                jnz     short loc_8D52
                mov     ds:NAME1, 5

loc_8D52:                               ; ...
                push    di
                push    es
                push    cx
                call    sub_9015
                jnb     short loc_8D5D
                call    FINDENTRY

loc_8D5D:                               ; ...
                pop     cx
                pop     es
                pop     di
                jb      short loc_8D43
                lds     di, ds:CURBUF
                test    byte ptr [bx+0Bh], 10h
                jnz     short loc_8D6F

loc_8D6C:                               ; ...
                jmp     loc_8E1F
; ---------------------------------------------------------------------------

loc_8D6F:                               ; ...
                cmp     ss:NoSetDir, 0
                jz      short loc_8D9D
                mov     dx, di
                mov     cx, ds
                push    ss
                pop     ds
                pop     di
                test    ds:FastOpenFlg, 1
                jz      short loc_8D90
                test    ds:FastOpenFlg, 2
                jz      short loc_8D90
                mov     di, ds:0D9Ch

loc_8D90:                               ; ...
                cmp     byte ptr [di], 0
                jnz     short loc_8D98
                jmp     locret_8E3F
; ---------------------------------------------------------------------------

loc_8D98:                               ; ...
                push    di
                mov     di, dx
                mov     ds, cx

loc_8D9D:                               ; ...
                xor     dx, dx
                cmp     es:[bp+0Fh], dx
                jnz     short loc_8DA8
                mov     dx, [si-6]

loc_8DA8:                               ; ...
                mov     ss:ROOTCLUST_HW, dx
                mov     dx, [si]
                push    ds
                push    ss
                pop     ds
                test    ds:FastOpenFlg, 2
                jz      short loc_8DC9
                mov     bx, dx
                mov     di, ds:CLUSNUM
                push    ax
                call    SETDIRSRCH
                pop     ax
                add     sp, 2
                jmp     short loc_8E05
; ---------------------------------------------------------------------------

loc_8DC9:                               ; ...
                pop     ds
                sub     bx, di
                sub     si, di
                push    bx
                push    ax
                push    si
                push    cx
                lds     bx, [di+6]
                push    bx
                push    ds
                mov     bx, dx
                push    ss
                pop     ds
                call    SETDIRSRCH
                pop     ds:HIGH_SECTOR
                pop     dx
                jb      short loc_8DEF
                mov     ds:ALLOWED, 18h
                xor     al, al
                call    GETBUFFR

loc_8DEF:                               ; ...
                pop     cx
                pop     si
                pop     ax
                pop     bx
                jnb     short loc_8DFA
                pop     di
                mov     si, di
                jmp     short loc_8E1B
; ---------------------------------------------------------------------------

loc_8DFA:                               ; ...
                call    sub_7F9D
                mov     di, word ptr ds:CURBUF
                add     si, di
                add     bx, di

loc_8E05:                               ; ...
                pop     di
                call    sub_90DB
                mov     al, [di]
                or      al, al
                jz      short locret_8E3F
                inc     di
                mov     si, di
                call    PATHCHRCMP
                jnz     short loc_8E1A
                jmp     loc_8CAE
; ---------------------------------------------------------------------------

loc_8E1A:                               ; ...
                dec     si

loc_8E1B:                               ; ...
                xor     cl, cl
                jmp     short loc_8E4B
; ---------------------------------------------------------------------------

loc_8E1F:                               ; ...
                pop     di
                push    ss
                pop     ds
                test    byte ptr ds:1146h, 1
                jz      short loc_8E34
                test    byte ptr ds:1146h, 2
                jz      short loc_8E34
                mov     di, ds:0D9Ch

loc_8E34:                               ; ...
                mov     al, [di]
                or      al, al
                jnz     short loc_8E40
                call    sub_90DB
                inc     al

locret_8E3F:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_8E40:                               ; ...
                mov     si, di
                jmp     short loc_8E4B
; ---------------------------------------------------------------------------

loc_8E44:                               ; ...
                pop     si
                mov     al, [si]
                mov     si, di
                or      al, al

loc_8E4B:                               ; ...
                mov     al, ds:56Dh
                mov     ds:56Bh, al
                stc
                retn
; END OF FUNCTION CHUNK FOR GetPathNoSet

; =============== S U B R O U T I N E =======================================


STARTSRCH       proc near               ; ...
                les     bp, ds:58Ah
                xor     ax, ax
                mov     ds:348h, ax
                mov     ds:57Bh, al
                dec     ax
                mov     ds:5D8h, ax
                mov     ds:5DAh, ax
                retn
STARTSRCH       endp


; =============== S U B R O U T I N E =======================================


MatchAttributes proc near               ; ...
                push    ax
                mov     al, ss:56Bh
                not     al
                and     al, ch
                and     al, 16h
                pop     ax
                retn
MatchAttributes endp


; =============== S U B R O U T I N E =======================================


DEVNAME         proc near               ; ...
                push    si
                push    di
                push    cx
                push    ax
                push    word ptr ds:54Bh
                cmp     byte ptr ds:54Bh, 5
                jnz     short loc_8E88
                mov     byte ptr ds:54Bh, 0E5h

loc_8E88:                               ; ...
                test    byte ptr ds:56Bh, 8
                jnz     short loc_8EB0
                mov     si, 48h ; 'H'

loc_8E92:                               ; ...
                test    word ptr [si+4], 8000h
                jz      short loc_8EA9
                mov     ax, si
                add     si, 0Ah
                mov     di, 54Bh
                mov     cx, 4
                repe cmpsw
                xchg    ax, si
                jz      short loc_8EBE

loc_8EA9:                               ; ...
                lds     si, [si]
                cmp     si, 0FFFFh
                jnz     short loc_8E92

loc_8EB0:                               ; ...
                stc

loc_8EB1:                               ; ...
                mov     cx, ss
                mov     ds, cx
                pop     word ptr ds:54Bh
                pop     ax
                pop     cx
                pop     di
                pop     si
                retn
; ---------------------------------------------------------------------------

loc_8EBE:                               ; ...
                mov     word ptr ss:59Ch, ds
                mov     bh, [si+4]
                or      bh, 0C0h
                and     bh, 0DFh
                mov     ss:59Ah, si
                jmp     short loc_8EB1
DEVNAME         endp


; =============== S U B R O U T I N E =======================================


sub_8ED3        proc near               ; ...
                mov     ax, 2020h
                mov     di, 553h
                stosw
                stosb
                mov     al, 40h ; '@'
                stosb
                xor     ax, ax
                mov     cx, 0Ah
                rep stosw
                call    DATE16
                mov     di, 561h
                xchg    ax, dx
                stosw
                xchg    ax, dx
                stosw
                mov     si, di
                mov     ax, ds:59Ah
                stosw
                mov     ax, ds:59Ch
                stosw
                mov     ah, bh
                mov     bx, 54Bh
                xor     al, al
                retn
sub_8ED3        endp


; =============== S U B R O U T I N E =======================================

; Attributes: bp-based frame

ValidateCDS     proc near               ; ...

var_6           = dword ptr -6
var_2           = word ptr -2

                push    bp
                mov     bp, sp
                sub     sp, 6
                mov     [bp+var_2], di
                lds     si, ss:5A2h
                mov     word ptr [bp+var_6], si
                mov     word ptr [bp+var_6+2], ds
                call    ECritDisk
                test    word ptr [si+43h], 8000h
                jz      short loc_8F22
                jmp     loc_8FC6
; ---------------------------------------------------------------------------

loc_8F22:                               ; ...
                xor     dl, dl
                xchg    dl, ss:34Ch
                push    ss
                pop     es
                call    FStrCpy
                mov     si, [bp+var_2]
                push    ss
                pop     ds
                call    sub_C0A6
                push    ss
                pop     ds
                mov     ds:34Ch, dl
                les     di, ds:5A2h
                push    bp
                call    FATREAD_CDS
                pop     bp
                jb      short loc_8FC6
                lds     si, ds:5A2h
                cmp     word ptr [si+4Bh], 0FFFFh
                jnz     short loc_8F55
                cmp     word ptr [si+49h], 0FFFFh

loc_8F55:                               ; ...
                jnz     short loc_8FB8
                push    ss
                pop     es
                push    word ptr ss:5B2h
                cmp     si, word ptr [bp+var_6]
                jnz     short loc_8F6E
                mov     di, [bp+var_2]
                mov     ss:5B2h, di
                call    FStrCpy

loc_8F6E:                               ; ...
                push    ss
                pop     ds
                push    word ptr ds:56Dh
                push    bp
                call    DOS_CHDIR
                pop     bp
                pop     bx
                pop     word ptr ds:5B2h
                mov     ds:56Dh, bl
                mov     di, ds:0ADCh
                lds     si, [bp+var_6]
                jnb     short loc_8F9C
                mov     ss:5A2h, si
                mov     word ptr ss:5A4h, ds
                xor     cx, cx
                xor     di, di
                mov     [si+3], cl

loc_8F9C:                               ; ...
                lds     si, ss:5A2h
                test    word ptr [si+43h], 2000h
                jz      short loc_8FAD
                mov     cx, 0FFFFh
                mov     di, cx

loc_8FAD:                               ; ...
                mov     ss:0ADCh, di
                mov     [si+4Bh], di
                mov     [si+49h], cx

loc_8FB8:                               ; ...
                les     di, [bp+var_6]
                mov     ss:5A2h, di
                mov     word ptr ss:5A4h, es
                clc

loc_8FC6:                               ; ...
                call    LCritDisk
                les     di, [bp+var_6]
                mov     sp, bp
                pop     bp
                retn
ValidateCDS     endp


; =============== S U B R O U T I N E =======================================


sub_8FD0        proc near               ; ...
                push    di
                push    si
                mov     di, si
                mov     al, [si]
                call    PATHCHRCMP
                jnz     short loc_8FF2
                inc     si
                lodsw
                or      ax, 2020h
                cmp     ax, 6564h
                jnz     short loc_9012
                lodsb
                or      al, 20h
                cmp     al, 76h ; 'v'
                jnz     short loc_9012
                lodsb
                call    PATHCHRCMP
                jnz     short loc_9012

loc_8FF2:                               ; ...
                push    ds
                push    si
                call    NameTrans
                cmp     byte ptr [si], 0
                stc
                jnz     short loc_9008
                push    ss
                pop     ds
                mov     al, ds:56Dh
                mov     ds:56Bh, al
                call    DEVNAME

loc_9008:                               ; ...
                pop     si
                pop     ds

loc_900A:                               ; ...
                pop     di
                jnb     short loc_900F
                mov     si, di

loc_900F:                               ; ...
                pop     di
                cmc
                retn
; ---------------------------------------------------------------------------

loc_9012:                               ; ...
                stc
                jmp     short loc_900A
sub_8FD0        endp


; =============== S U B R O U T I N E =======================================


sub_9015        proc near               ; ...
                test    byte ptr ss:1146h, 1
                jnz     short loc_9020

loc_901D:                               ; ...
                jmp     loc_90D9
; ---------------------------------------------------------------------------

loc_9020:                               ; ...
                test    byte ptr ss:1146h, 8
                jnz     short loc_901D
                mov     bx, 113Ch
                mov     si, ss:5B2h
                mov     di, 0D7Ch
                mov     cx, 1147h
                mov     al, 1
                push    ds
                pop     es
                call    dword ptr [bx+2]
                jnb     short loc_9042
                jmp     loc_90C8
; ---------------------------------------------------------------------------

loc_9042:                               ; ...
                lea     bx, [si-2]
                cmp     bx, ss:5B2h
                jz      short loc_90C8
                cmp     byte ptr [si], 0
                jnz     short loc_9083
                push    cx
                mov     cl, ss:56Bh
                mov     ch, ss:56Dh
                mov     ss:56Bh, ch
                mov     ch, es:[di+0Bh]
                call    MatchAttributes
                pop     cx
                jnz     short loc_90D9
                cmp     byte ptr ss:34Ch, 0
                jz      short loc_9083
                cmp     byte ptr [si], 0
                jnz     short loc_9083
                test    byte ptr es:[di+0Bh], 10h
                jz      short loc_9083
                mov     bx, cx
                jmp     short loc_909A
; ---------------------------------------------------------------------------

loc_9083:                               ; ...
                mov     bx, cx
                mov     ax, [bx+0Bh]
                mov     ss:5C2h, ax
                mov     ax, [bx+7]
                mov     ss:0ADEh, ax
                mov     ax, [bx+5]
                mov     ss:5BCh, ax

loc_909A:                               ; ...
                mov     ss:0D9Ch, si
                mov     ax, [bx+9]
                mov     ss:348h, ax
                push    es
                les     bx, ss:58Ah
                mov     ah, es:[bx]
                pop     es
                mov     word ptr ss:5E2h, 0
                mov     word ptr ss:5E4h, es
                mov     bx, di
                lea     si, [di+1Ah]
                or      byte ptr ss:1146h, 12h
                retn
; ---------------------------------------------------------------------------

loc_90C8:                               ; ...
                cmp     ax, 0FFFFh
                jnz     short loc_90D3
                mov     byte ptr ss:1146h, 0

loc_90D3:                               ; ...
                and     byte ptr ss:1146h, 0FBh

loc_90D9:                               ; ...
                stc
                retn
sub_9015        endp


; =============== S U B R O U T I N E =======================================


sub_90DB        proc near               ; ...
                pushf
                test    byte ptr ss:1146h, 1
                jz      short loc_9161
                test    byte ptr ss:1146h, 2
                jz      short loc_90F9
                and     byte ptr ss:1146h, 0FDh
                mov     di, ss:0D9Ch
                jmp     short loc_915B
; ---------------------------------------------------------------------------

loc_90F9:                               ; ...
                push    ds
                push    es
                push    bx
                push    si
                push    di
                push    cx
                push    ax
                lds     di, ss:5E2h
                mov     si, 1147h
                lds     ax, [di+6]
                mov     ss:[si+1], ax
                mov     word ptr ss:[si+3], ds
                push    ss
                pop     ds
                mov     ax, ds:0ADEh
                mov     [si+7], ax
                mov     ax, ds:5BCh
                mov     [si+5], ax
                mov     ax, ds:348h
                mov     [si+9], ax
                mov     ax, ds:5C2h
                mov     [si+0Bh], ax
                mov     ax, bx
                add     di, 18h
                sub     ax, di
                mov     cl, 20h ; ' '
                div     cl
                mov     [si], al
                push    ds
                pop     es
                mov     ds, word ptr ds:5E4h
                mov     di, bx
                cmp     word ptr [di+1Ah], 0
                jz      short loc_9154
                push    si
                pop     bx
                mov     al, 2
                mov     si, 113Ch
                call    dword ptr es:[si+2]
                clc

loc_9154:                               ; ...
                pop     ax
                pop     cx
                pop     di
                pop     si
                pop     bx
                pop     es
                pop     ds

loc_915B:                               ; ...
                or      byte ptr ss:1146h, 8

loc_9161:                               ; ...
                popf
                retn
sub_90DB        endp

; ---------------------------------------------------------------------------
LenTab          db 16h                  ; ...
                db  0Eh
                db  16h
                db  0Dh
                db  0Dh
                db  0Eh
CmdTab          dw 486h                 ; ...
                db  86h
                db    5
                db  87h
                db    8
                db  87h
                db  0Ah
                db  86h
                db    7
                db  86h
                db    5

; =============== S U B R O U T I N E =======================================


IOFUNC          proc near               ; ...
                mov     word ptr ss:IOXAD+2, ss
                mov     word ptr ss:IOXAD, offset DEVIOBUF
                mov     ss:IOSCNT, 1
                mov     ss:DEVIOBUF, ax
                test    byte ptr [si+6], 80h
                jz      short loc_9195
                jmp     loc_923A
; ---------------------------------------------------------------------------

loc_9195:                               ; ...
                test    byte ptr [si+5], 80h
                jnz     short loc_919E
                jmp     loc_923A
; ---------------------------------------------------------------------------

loc_919E:                               ; ...
                push    es
                call    save_world
                mov     dx, ds
                mov     bx, ss
                mov     ds, bx
                mov     es, bx
                xor     bx, bx
                cmp     ah, 5
                jnz     short loc_91B3
                mov     bh, 4

loc_91B3:                               ; ...
                mov     ds:IOCALL_REQSTAT, bx
                xor     bx, bx
                mov     ds:IOMED, bl
                mov     bl, ah
                mov     ah, cs:LenTab[bx]
                add     bx, bx
                mov     cx, cs:CmdTab[bx]
                mov     bx, offset IOCALL
                mov     ds:IOCALL, ah
                mov     ds:IOCALL_REQFUNC, ch
                mov     ds, dx
                call    DEVIOCALL
                mov     di, ss:IOCALL_REQSTAT
                and     di, di
                js      short loc_9219

loc_91E4:                               ; ...
                mov     ax, ss
                mov     ds, ax
                cmp     ch, 5
                jnz     short loc_91F3
                mov     al, ds:IOMED
                mov     byte ptr ds:DEVIOBUF, al

loc_91F3:                               ; ...
                mov     ah, byte ptr ds:IOCALL_REQSTAT+1
                not     ah
                and     ah, 2
                call    restore_world
                pop     es
                pushf
                mov     al, ss:IoStatFail
                cbw
                inc     ax
                jnz     short loc_9213
                dec     ax
                jnz     short loc_9213
                inc     ss:IoStatFail
                popf
                retn
; ---------------------------------------------------------------------------

loc_9213:                               ; ...
                mov     ax, ss:DEVIOBUF
                popf
                retn
; ---------------------------------------------------------------------------

loc_9219:                               ; ...
                mov     ah, cl
                call    sub_A173
                cmp     al, 1
                jnz     short loc_9229
                call    restore_world
                pop     es
                jmp     IOFUNC
; ---------------------------------------------------------------------------

loc_9229:                               ; ...
                and     byte ptr ss:IOCALL_REQSTAT+1, 0FDh
                cmp     al, 3
                jnz     short loc_9238
                dec     ss:IoStatFail

loc_9238:                               ; ...
                jmp     short loc_91E4
; ---------------------------------------------------------------------------

loc_923A:                               ; ...
                or      ah, ah
                jz      short sub_9261
                dec     ah
                jz      short loc_9247
                dec     ah
                jz      short loc_9257
                retn
; ---------------------------------------------------------------------------

loc_9247:                               ; ...
                push    word ptr [si+15h]
                push    word ptr [si+17h]
                call    sub_9261
; ---------------------------------------------------------------------------
                pop     word ptr [si+17h]
                pop     word ptr [si+15h]
                retn
; ---------------------------------------------------------------------------

loc_9257:                               ; ...
                call    sub_9281
                call    DOS_WRITE
                call    sub_92B5
IOFUNC          endp

; ---------------------------------------------------------------------------
                retn

; =============== S U B R O U T I N E =======================================

; Attributes: noreturn

sub_9261        proc near               ; ...
                call    sub_9281
                or      word ptr ss:611h, 40h
                call    DOS_READ
                and     word ptr ss:611h, 0FFBFh
                or      cx, cx
                call    sub_92B5
sub_9261        endp

; ---------------------------------------------------------------------------
                db  36h ; 6
                db 0A0h
                db 0BCh
                db    3
                db  75h ; u
                db 0E2h
                db 0B0h
                db  1Ah
                db 0C3h

; =============== S U B R O U T I N E =======================================


sub_9281        proc near               ; ...
                pop     word ptr ss:36Ch
                push    es
                call    save_world
                mov     word ptr ss:5A0h, ds
                lds     cx, ss:32Ch
                push    cx
                push    ds
                lds     cx, ss:38Ah
                mov     ss:32Ch, cx
                mov     word ptr ss:32Eh, ds
                mov     cx, ss
                mov     ds, cx
                mov     ds:59Eh, si
                mov     cx, ds:38Eh
                jmp     word ptr ds:36Ch
sub_9281        endp


; =============== S U B R O U T I N E =======================================

; Attributes: noreturn

sub_92B5        proc near               ; ...
                pop     word ptr ds:36Ch
                pop     word ptr ds:32Eh
                pop     word ptr ds:32Ch
                call    restore_world
sub_92B5        endp ; sp-analysis failed

                pop     es
                jmp     word ptr ss:36Ch

; =============== S U B R O U T I N E =======================================


sub_92CA        proc near               ; ...
                push    es
                call    save_world
                mov     al, 0Dh
                jmp     short loc_92D8
sub_92CA        endp


; =============== S U B R O U T I N E =======================================

; Attributes: noreturn

DEV_CLOSE_SFT   proc near               ; ...
                push    es
                call    save_world
                mov     al, 0Eh

loc_92D8:                               ; ...
                test    byte ptr es:[di+6], 80h
                jnz     short loc_9343
                xor     ah, ah
                test    byte ptr es:[di+5], 80h
                les     di, es:[di+7]
                jnz     short loc_92FD
                cmp     byte ptr ss:303h, 1
                jbe     short loc_9343
                mov     cx, es:[di]
                mov     ah, ch
                les     di, es:[di+13h]

loc_92FD:                               ; ...
                test    byte ptr es:[di+5], 8
                jz      short loc_9343
                push    es
                pop     ds
                mov     si, di

loc_9308:                               ; ...
                push    ss
                pop     es
                mov     di, 35Ah
                mov     bx, di
                push    ax
                mov     al, 0Dh
                stosb
                pop     ax
                xchg    ah, al
                stosw
                xchg    ah, al
                mov     word ptr es:[di], 0
                push    ax
                call    DEVIOCALL2
                mov     di, es:[bx+3]
                and     di, di
                jns     short loc_9342
                test    byte ptr [si+5], 80h
                jz      short loc_9334
                mov     ah, 86h
                jmp     short loc_9338
; ---------------------------------------------------------------------------

loc_9334:                               ; ...
                mov     al, cl
                mov     ah, 6

loc_9338:                               ; ...
                call    sub_A173
                cmp     al, 1
                jnz     short loc_9342
                pop     ax
                jmp     short loc_9308
; ---------------------------------------------------------------------------

loc_9342:                               ; ...
                pop     ax

loc_9343:                               ; ...
                call    restore_world
DEV_CLOSE_SFT   endp ; sp-analysis failed

                pop     es
                retn

; =============== S U B R O U T I N E =======================================


DEVIOCALL       proc near               ; ...
                lds     si, [si+7]      ; CALLNEWSC, HIGH_SECTOR & CALLDEVAD
DEVIOCALL       endp                    ; LDS SI,[SI+SF_ENTRY.sf_devptr]


; =============== S U B R O U T I N E =======================================


DEVIOCALL2      proc near               ; ...
                call    ECritDevice
                test    byte ptr [si+5], 80h ; [SI+SYSDEV.ATT+1],(DEVTYP>>8)
                jnz     short chardev2
                mov     al, es:[bx+2]   ; [ES:BX+SRHEAD.REQFUNC]
                cmp     al, 4           ; DEVRD
                jz      short chkext
                cmp     al, 8           ; DEVWRT
                jz      short chkext
                cmp     al, 9           ; DEVWRTV
                jnz     short chardev2

chkext:                                 ; ...
                test    byte ptr [si+4], 2 ; [SI+SYSDEV.ATT],EXTDRVR
                jz      short chksector
                mov     ax, 0FFFFh      ; -1 ; old sector
                add     byte ptr es:[bx], 8 ; make length to 30
                xchg    ax, ss:CALLSSEC
                mov     ss:CALLNEWSC, ax
                mov     ax, ss:HIGH_SECTOR
                mov     ss:CALLNEWSC+2, ax
                jmp     short chardev2
; ---------------------------------------------------------------------------

chksector:                              ; ...
                cmp     ss:HIGH_SECTOR, 0 ; if >32mb
                jnz     short chardev3  ; then fake error

chardev2:                               ; ...
                inc     ss:DEVIO_IN_PROGRESS ; lock (deviocall in progress)
                mov     ax, [si+6]      ; [SI+SYSDEV.STRAT]
                mov     word ptr ss:CALLDEVAD, ax
                mov     word ptr ss:CALLDEVAD+2, ds
                call    ss:CALLDEVAD
                mov     ax, [si+8]      ; [SI+SYSDEV.INT]
                mov     word ptr ss:CALLDEVAD, ax
                call    ss:CALLDEVAD
                dec     ss:DEVIO_IN_PROGRESS ; unlock (deviocall completed)

dev_exit:                               ; ...
                call    LCritDevice
                retn
; ---------------------------------------------------------------------------

chardev3:                               ; ...
                mov     word ptr es:[bx+3], 8107h ; [ES:BX+SRHEAD.REQSTAT],
                                        ; STERR+STDON+error_I24_not_DOS_disk
                jmp     short dev_exit
DEVIOCALL2      endp


; =============== S U B R O U T I N E =======================================


SETREAD         proc near               ; ...
                push    di
                push    cx
                push    ax
                mov     cl, 4

loc_93C4:                               ; ...
                mov     al, 22
                mov     di, ss
                mov     es, di
                mov     di, offset DEVCALL_REQLEN
                stosb
                pop     ax
                stosb
                mov     es:[di], cl
                inc     di
                mov     word ptr es:[di], 0
                add     di, 10
                mov     es:[di], ah
                inc     di
                mov     cx, ax
                mov     es:[di], bx
                mov     word ptr es:[di+2], ds
                add     di, 4
                pop     ax
                stosw
                xchg    ax, dx
                stosw
                xchg    ax, cx
                xchg    dx, cx
                pop     di
                mov     bx, offset DEVCALL_REQLEN
                retn
SETREAD         endp


; =============== S U B R O U T I N E =======================================


SETWRITE        proc near               ; ...
                push    di
                push    cx
                push    ax
                mov     cl, 8
                add     cl, ss:VDERFLG
                jmp     short loc_93C4
SETWRITE        endp

; ---------------------------------------------------------------------------
                stc
                retn
; ---------------------------------------------------------------------------
                clc
                retn
; ---------------------------------------------------------------------------
                stc
                retn

; =============== S U B R O U T I N E =======================================


BUILDDIR        proc near               ; ...
                mov     ax, ds:ENTFREE
                cmp     ax, 0FFFFh
                jz      short loc_9414
                clc
                retn
; ---------------------------------------------------------------------------

loc_9414:                               ; ...
                cmp     ds:DIRSTART_HW, 0
                jnz     short loc_9424
                cmp     ds:DIRSTART, 0
                jnz     short loc_9424
                stc

builddir_retn:                          ; ...
                retn
; ---------------------------------------------------------------------------

loc_9424:                               ; ...
                mov     bx, ds:DIRSTART_HW
                mov     ds:CLUSTNUM_HW, bx
                or      bx, bx
                mov     bx, ds:DIRSTART
                jnz     short loc_9438
                or      bx, bx
                jz      short loc_943D

loc_9438:                               ; ...
                call    GETEOF
                jb      short builddir_retn

loc_943D:                               ; ...
                xor     cx, cx
                mov     ds:word_AF0, cx
                inc     cx
                call    ALLOCATE
                jb      short builddir_retn
                mov     dx, ds:DIRSTART
                cmp     dx, ds:DIRSTART_HW
                jnz     short loc_946C
                or      dx, dx
                jnz     short loc_946C
                push    ds:CLUSTNUM_HW
                pop     ds:ROOTCLUST_HW
                call    SETDIRSRCH
                jb      short builddir_retn
                mov     ds:LASTENT, 0FFFFh
                jmp     short loc_94AD
; ---------------------------------------------------------------------------

loc_946C:                               ; ...
                push    bx
                push    ds:CLUSTNUM_HW
                mov     bx, ds:CLUSNUM_HW
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, ds:CLUSNUM
                call    IsEOF
                pop     ds:CLUSTNUM_HW
                pop     bx
                jb      short loc_94A6
                mov     ds:CLUSNUM, bx
                push    cx
                push    ax
                push    bp
                mov     ax, ds:CLUSTNUM_HW
                mov     ds:CLUSNUM_HW, ax
                mov     ah, 1
                mov     dl, es:[bp+0]
                mov     cx, ds:DIRSTART
                mov     bp, bx
                call    FastOpen_Update
                pop     bp
                pop     ax
                pop     cx

loc_94A6:                               ; ...
                mov     dx, bx
                xor     bl, bl
                call    FIGREC

loc_94AD:                               ; ...
                mov     cl, es:[bp+4]
                inc     cx
                xor     ch, ch

loc_94B4:                               ; ...
                push    cx
                mov     byte ptr ds:34Bh, 18h
                mov     al, 0FFh
                call    GETBUFFR
                jnb     short loc_94C3
                pop     cx
                retn
; ---------------------------------------------------------------------------

loc_94C3:                               ; ...
                mov     cx, es:[bp+2]
                push    es
                les     di, ds:5E2h
                or      byte ptr es:[di+5], 4
                push    di
                add     di, 18h
                xor     ax, ax
                shr     cx, 1
                rep stosw
                jnb     short loc_94DE
                stosb

loc_94DE:                               ; ...
                pop     di
                call    SET_BUF_DIRTY
                pop     es
                add     dx, 1
                adc     ds:607h, cx
                pop     cx
                loop    loc_94B4
                mov     ax, ds:348h
                inc     ax
                clc
                retn
BUILDDIR        endp


; =============== S U B R O U T I N E =======================================


sub_94F3        proc near               ; ...
                stosw
                mov     cx, 4
                mov     ax, 2020h
                rep stosw
                stosb
                mov     al, 10h
                stosb
                add     di, 8
                mov     ax, ds:0AF2h
                stosw
                mov     si, ds:59Eh
                mov     ax, [si+0Dh]
                stosw
                mov     ax, [si+0Fh]
                stosw
                mov     ax, dx
                stosw
                xchg    ax, cx
                stosw
                stosw
                retn
sub_94F3        endp


; =============== S U B R O U T I N E =======================================


sub_951A        proc near               ; ...

; FUNCTION CHUNK AT 953B SIZE 00000003 BYTES
; FUNCTION CHUNK AT 955F SIZE 00000040 BYTES
; FUNCTION CHUNK AT 95A3 SIZE 00000009 BYTES
; FUNCTION CHUNK AT 95E9 SIZE 00000030 BYTES

                mov     word ptr ds:CREATING, 0E5FFh
                push    ax
                mov     ds:NoSetDir, 0
                mov     ds:SATTRIB, al
                call    GetPathNoSet
                mov     dl, cl
                xchg    ax, cx
                pop     ax
                jnb     short loc_955F
                jnz     short loc_9539
                cmp     dl, 80h
                jz      short RENAME_MAKE

loc_9539:                               ; ...
                mov     al, 4
sub_951A        endp

; START OF FUNCTION CHUNK FOR RENAME_MAKE
;   ADDITIONAL PARENT FUNCTION sub_951A

loc_953B:                               ; ...
                cbw
                stc
                retn
; END OF FUNCTION CHUNK FOR RENAME_MAKE

; =============== S U B R O U T I N E =======================================


RENAME_MAKE     proc near               ; ...

; FUNCTION CHUNK AT 953B SIZE 00000003 BYTES
; FUNCTION CHUNK AT 959F SIZE 00000004 BYTES
; FUNCTION CHUNK AT 95B8 SIZE 00000031 BYTES

                test    ds:EXTOPEN_ON, 1
                jz      short loc_9556
                or      ds:EXTOPEN_ON, 4
                test    byte ptr ds:EXTOPEN_FLAG, 0F0h
                jnz     short loc_9556
                stc
                mov     ax, 7

locret_9555:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_9556:                               ; ...
                les     di, ds:THISSFT
                xor     ax, ax
                stc
                jmp     short loc_95B8
RENAME_MAKE     endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR sub_951A

loc_955F:                               ; ...
                jz      short loc_95A8
                mov     al, 3
                test    byte ptr ds:56Bh, 18h
                jnz     short loc_95A4
                or      ch, ch
                js      short loc_9588
                or      ah, ah
                jnz     short loc_953B
                push    cx
                mov     es, word ptr ds:5E4h
                mov     ch, es:[bx+0Bh]
                test    ch, 1
                jnz     short loc_95A3
                call    MatchAttributes
                pop     cx
                jnz     short loc_95A4
                xor     al, al

loc_9588:                               ; ...
                cbw
                push    ax
                push    cx
                mov     ah, ch
                call    DOOPEN
                les     di, ds:59Eh
                push    si
                push    bx
                call    ShareEnter
                jnb     short loc_95E9
                pop     bx
                pop     si
                pop     cx
                pop     ax
; END OF FUNCTION CHUNK FOR sub_951A
; START OF FUNCTION CHUNK FOR RENAME_MAKE

loc_959F:                               ; ...
                mov     al, 6
                jmp     short loc_953B
; END OF FUNCTION CHUNK FOR RENAME_MAKE
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR sub_951A

loc_95A3:                               ; ...
                pop     cx

loc_95A4:                               ; ...
                mov     al, 5
                jmp     short loc_953B
; ---------------------------------------------------------------------------

loc_95A8:                               ; ...
                mov     al, 1
                jmp     short loc_953B
; END OF FUNCTION CHUNK FOR sub_951A

; =============== S U B R O U T I N E =======================================


sub_95AC        proc near               ; ...
                push    ax
                mov     ax, cx
                call    sub_961A
                pop     ax
                jnb     short locret_9555
                mov     al, 2

locret_95B7:                            ; ...
                retn
sub_95AC        endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR RENAME_MAKE

loc_95B8:                               ; ...
                call    sub_95AC
                jb      short locret_95B7
                test    byte ptr ds:56Bh, 10h
                jnz     short locret_95B7
                push    ax
                push    bx
                push    si
                call    ShareEnter
                pop     si
                pop     bx
                pop     ax
                jnb     short locret_95B7
                push    ax
                les     di, ds:5E2h
                mov     byte ptr es:[bx], 0E5h
                call    SET_BUF_DIRTY
                les     bp, ds:58Ah
                mov     al, es:[bp+0]
                call    FLUSHBUF
                pop     ax
                jmp     short loc_959F
; END OF FUNCTION CHUNK FOR RENAME_MAKE
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR sub_951A

loc_95E9:                               ; ...
                les     di, ds:59Eh
                xor     ax, ax
                call    ECritDisk
                xchg    ax, es:[di]
                push    ax
                push    di
                push    es
                pushf
                call    ShareEnd
                popf
                pop     es
                pop     di
                pop     word ptr es:[di]
                call    LCritDisk
                pop     bx
                pop     si
                pop     cx
                pop     ax
                call    sub_95AC
                jb      short locret_95B7
                push    ax
                push    bx
                push    si
                pushf
                call    ShareEnter
                popf
                pop     si
                pop     bx
                pop     ax
; END OF FUNCTION CHUNK FOR sub_951A
; [00000001 BYTES: COLLAPSED FUNCTION nullsub_17. PRESS CTRL-NUMPAD+ TO EXPAND]

; =============== S U B R O U T I N E =======================================


sub_961A        proc near               ; ...
                les     bp, ds:58Ah
                jnb     short loc_9636
                cmp     byte ptr ds:34Ah, 0
                stc
                jnz     short nullsub_17
                call    BUILDDIR
                jb      short nullsub_17
                call    GETENT
                jb      short nullsub_17
                jmp     short loc_9642
; ---------------------------------------------------------------------------

loc_9634:                               ; ...
                stc

locret_9635:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_9636:                               ; ...
                or      ah, ah
                jns     short loc_963D
                jmp     DOOPEN
; ---------------------------------------------------------------------------

loc_963D:                               ; ...
                call    sub_9791
                jb      short locret_9635

loc_9642:                               ; ...
                test    byte ptr ds:56Bh, 8
                jz      short loc_9650
                cmp     byte ptr ds:57Bh, 0
                jnz     short loc_9634

loc_9650:                               ; ...
                mov     es, word ptr ds:5E4h
                mov     di, bx
                mov     si, 54Bh
                mov     cx, 5
                rep movsw
                movsb
                mov     al, ds:56Bh
                stosb
                mov     cl, 5
                xor     ax, ax
                rep stosw
                call    DATE16
                xchg    ax, dx
                stosw
                xchg    ax, dx
                mov     es:[di-6], ax
                stosw
                xor     ax, ax
                push    di
                stosw
                stosw
                stosw
                mov     si, ds:5E2h
                test    byte ptr es:[si+5], 40h
                jnz     short loc_968D
                call    INC_DIRTY_COUNT
                or      byte ptr es:[si+5], 40h

loc_968D:                               ; ...
                les     bp, ds:58Ah
                mov     al, es:[bp+0]
                push    ax
                push    bx
                push    es
                push    di
                les     di, ds:59Eh
                test    byte ptr es:[di+5], 80h
                jnz     short loc_96B6
                push    ds
                push    bx
                lds     bx, ds:58Ah
                mov     es:[di+7], bx
                mov     bx, ds
                mov     es:[di+9], bx
                pop     bx
                pop     ds

loc_96B6:                               ; ...
                pop     di
                pop     es
                call    FLUSHBUF
                pop     bx
                pop     ax
                pop     si
                mov     ah, al
                jnb     short DOOPEN
                retn
sub_961A        endp


; =============== S U B R O U T I N E =======================================


DOOPEN          proc near               ; ...
                mov     dh, ah
                xor     dl, dl
                or      ah, ah
                js      short loc_96D8
                les     di, ds:58Ah
                cmp     word ptr es:[di+0Fh], 0
                jz      short loc_96D8
                inc     dl

loc_96D8:                               ; ...
                les     di, ds:59Eh
                add     di, 4
                xor     al, al
                or      dh, dh
                js      short loc_96EC
                mov     ds, word ptr ds:5E4h
                mov     al, [bx+0Bh]

loc_96EC:                               ; ...
                stosb
                xor     ax, ax
                mov     al, dh
                or      al, 40h
                stosw
                push    ds
                lds     ax, [bx+1Ah]
                or      dh, dh
                js      short loc_9701
                lds     ax, ss:58Ah

loc_9701:                               ; ...
                stosw
                mov     ax, ds
                pop     ds
                stosw
                push    si
                add     di, 20h ; ' '
                movsw
                add     si, 0FFF8h
                lodsw
                or      dl, dl
                jz      short loc_9715
                xor     ax, ax

loc_9715:                               ; ...
                stosw
                add     di, 0FFDEh
                movsw
                movsw
                lodsw
                lodsw
                xchg    ax, cx
                lodsw
                or      dh, dh
                jns     short loc_9727
                xor     ax, ax
                mov     cx, ax

loc_9727:                               ; ...
                xchg    ax, cx
                stosw
                xchg    ax, cx
                stosw
                xor     ax, ax
                stosw
                stosw
                or      dh, dh
                js      short loc_9782
                stosw
                add     di, 0FFF0h
                stosw
                add     di, 0Eh
                mov     ax, es:[di+10h]
                mov     es:[di+1Ah], ax
                mov     ax, es:[di+12h]
                mov     es:[di+1Ch], ax
                push    ds
                push    ss
                pop     ds
                test    byte ptr ds:1146h, 4
                jz      short loc_9766
                mov     si, 1147h
                mov     ax, [si+1]
                stosw
                mov     ax, [si+3]
                stosw
                mov     al, [si]
                stosb
                pop     ds
                jmp     short loc_9780
; ---------------------------------------------------------------------------

loc_9766:                               ; ...
                pop     ds
                mov     si, ss:5E2h
                mov     ax, [si+6]
                stosw
                mov     ax, [si+8]
                stosw
                mov     ax, bx
                add     si, 18h
                sub     ax, si
                mov     cl, 20h ; ' '
                div     cl
                stosb

loc_9780:                               ; ...
                jmp     short loc_9785
; ---------------------------------------------------------------------------

loc_9782:                               ; ...
                add     di, 7

loc_9785:                               ; ...
                mov     si, bx
                mov     cx, 0Bh
                rep movsb
                pop     si
                push    ss
                pop     ds
                clc

locret_9790:                            ; ...
                retn
DOOPEN          endp


; =============== S U B R O U T I N E =======================================


sub_9791        proc near               ; ...
                push    ds
                lds     di, ds:5E2h
                mov     cx, [si]
                mov     ax, [si-6]
                mov     dx, [di+8]
                mov     ss:607h, dx
                mov     dx, [di+6]
                pop     ds
                cmp     word ptr es:[bp+0Fh], 0
                jnz     short loc_97C4
                cmp     ax, 0
                jnz     short loc_97B6
                cmp     cx, 2

loc_97B6:                               ; ...
                jb      short loc_97FF
                cmp     ax, es:[bp+2Fh]
                jnz     short loc_97CF
                cmp     cx, es:[bp+2Dh]
                jmp     short loc_97CF
; ---------------------------------------------------------------------------

loc_97C4:                               ; ...
                xor     ax, ax
                cmp     cx, 2
                jb      short loc_97FF
                cmp     cx, es:[bp+0Dh]

loc_97CF:                               ; ...
                ja      short loc_97FF
                sub     bx, di
                push    bx
                push    word ptr ds:607h
                push    dx
                mov     bx, cx
                mov     ds:0AE8h, ax
                call    RELEASE
                pop     dx
                pop     word ptr ds:607h
                jb      short loc_97F2
                mov     byte ptr ds:34Bh, 18h
                xor     al, al
                call    GETBUFFR

loc_97F2:                               ; ...
                pop     bx
                jb      short locret_9790
                call    sub_7F9D
                add     bx, ds:5E2h
                lea     si, [bx+1Ah]

loc_97FF:                               ; ...
                clc
                retn
sub_9791        endp


; =============== S U B R O U T I N E =======================================


FNDCLUS         proc near               ; ...
                push    es              ; DX:CX = No. of clusters to skip
                les     di, ds:THISSFT
                mov     ds:CLSKIP_HW, dx
                mov     bx, es:[di+37h] ;  [ES:DI+SF_ENTRY.sf_lstclus+2]
                mov     ds:CLUSTNUM_HW, bx
                or      bx, bx
                mov     dx, es:[di+0Bh] ; [ES:DI+SF_ENTRY.sf_firclus]
                mov     ds:LASTPOS_HW, dx
                mov     bx, es:[di+35h] ; [ES:DI+SF_ENTRY.sf_lstclus]
                mov     dx, es:[di+19h] ; [ES:DI+SF_ENTRY.sf_cluspos]
                jnz     short fndclus_1
                or      bx, bx
                jnz     short fndclus_1
                jmp     NOCLUS
; ---------------------------------------------------------------------------

fndclus_1:                              ; ...
                sub     cx, dx
                push    ax
                mov     ax, ds:LASTPOS_HW
                sbb     ds:CLSKIP_HW, ax
                pop     ax
                jnb     short FINDIT
                add     cx, dx
                mov     bx, ds:LASTPOS_HW
                adc     ds:CLSKIP_HW, bx
                xor     dx, dx
                mov     ds:LASTPOS_HW, dx
                mov     bx, es:[di+2Dh] ; [ES:DI+SF_ENTRY.sf_chain+2]
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, es:[di+2Bh] ; [ES:DI+SF_ENTRY.sf_chain]

FINDIT:                                 ; ...
                pop     es
                cmp     cx, ds:CLSKIP_HW
                jnz     short SKPCLP
                jcxz    short RET9
FNDCLUS         endp


; =============== S U B R O U T I N E =======================================


SKPCLP          proc near               ; ...
                push    ds:LASTPOS_HW
                push    dx
                push    ds:CLSKIP_HW
                push    cx
                call    UNPACK
                pop     cx
                pop     ds:CLSKIP_HW
                pop     dx
                pop     ds:LASTPOS_HW
                jb      short fndclus_retn
                push    ds:CLUSTNUM_HW
                push    bx
                mov     bx, di
                mov     di, ds:CCONTENT_HW
                mov     ds:CLUSTNUM_HW, di
                call    IsEOF
                jb      short SKPCLP2
                pop     bx
                pop     ds:CLUSTNUM_HW
                jmp     short RET9
; ---------------------------------------------------------------------------

SKPCLP2:                                ; ...
                add     sp, 4
                inc     dx
                jnz     short SKPCLP3
                inc     ds:LASTPOS_HW

SKPCLP3:                                ; ...
                sub     cx, 1
                sbb     ds:CLSKIP_HW, 0
                jnz     short SKPCLP    ; loop
                or      cx, cx
                jnz     short SKPCLP    ; loop

RET9:                                   ; ...
                clc
                retn
; ---------------------------------------------------------------------------

NOCLUS:                                 ; ...
                pop     es
                push    di
                xor     di, di
                add     cx, 1
                adc     ds:CLSKIP_HW, di ; CLSKIP_HW:BX = Last cluster skipped to
                sub     dx, 1
                sbb     ds:LASTPOS_HW, di ; LASTPOS_HW:DX = Position of last cluster
                pop     di
                clc

fndclus_retn:                           ; ...
                retn
SKPCLP          endp


; =============== S U B R O U T I N E =======================================


BUFSEC          proc near               ; ...
                push    ds:CLUSTNUM_HW
                mov     dx, ds:CLUSNUM_HW
                mov     ds:CLUSTNUM_HW, dx
                mov     dx, ds:CLUSNUM
                mov     bl, ds:SECCLUSPOS
                mov     ds:ALLOWED, 38h ; Allowed_FAIL+Allowed_RETRY+Allowed_IGNORE
                call    FIGREC
                call    GETBUFFR
                pop     ds:CLUSTNUM_HW
                jb      short fndclus_retn
                mov     ds:TRANS, 1     ; A transfer is taking place
                mov     si, ds:NEXTADD
                mov     di, si
                mov     cx, ds:BYTCNT1
                add     di, cx
                mov     ds:NEXTADD, di
                les     di, ds:CURBUF
                or      byte ptr es:[di+5], 8 ; [ES:DI+BUFFINFO.buf_flags],
                                        ; buf_isDATA
                lea     di, [di+24]     ; [DI+BUFINSIZ] ; Point to buffer
                add     di, ds:BYTSECPOS
                clc
                retn
BUFSEC          endp


; =============== S U B R O U T I N E =======================================


sub_990E        proc near               ; ...
                push    es
                xor     ax, ax
                call    BUFSEC
                jnb     short loc_9919

loc_9916:                               ; ...
                pop     es
                jmp     short loc_9946
; ---------------------------------------------------------------------------

loc_9919:                               ; ...
                mov     bx, es
                mov     es, word ptr ds:32Eh
                mov     ds, bx
                xchg    di, si
                shr     cx, 1
                rep movsw
                adc     cx, 0
                rep movsb
                pop     es
                lds     di, ss:5E2h
                lea     bx, [di+18h]
                sub     si, bx
                call    PLACEBUF
                cmp     si, es:[bp+2]
                jb      short loc_9945
                mov     ss:6Dh, di

loc_9945:                               ; ...
                clc

loc_9946:                               ; ...
                push    ss
                pop     ds
                retn
sub_990E        endp


; =============== S U B R O U T I N E =======================================


BUFWRT          proc near               ; ...
                add     word ptr ds:SECPOS, 1
                adc     word ptr ds:SECPOS+2, 0
                mov     ax, word ptr ds:SECPOS+2
                cmp     ax, ds:VALSEC+2
                mov     al, 1
                ja      short loc_996D
                jb      short loc_996B
                mov     ax, word ptr ds:SECPOS
                cmp     ax, ds:VALSEC
                mov     al, 1
                ja      short loc_996D

loc_996B:                               ; ...
                xor     al, al

loc_996D:                               ; ...
                push    es
                call    BUFSEC
                jb      short loc_9916
                mov     ds, word ptr ds:32Eh
                shr     cx, 1
                rep movsw
                adc     cx, cx
                rep movsb
                pop     es
                lds     bx, ss:CURBUF
                test    byte ptr [bx+5], 40h
                jnz     short loc_9994
                inc     word ptr ss:71h
                or      byte ptr [bx+5], 40h

loc_9994:                               ; ...
                lea     si, [bx+18h]
                sub     di, si
                cmp     di, es:[bp+2]
                jb      short loc_99A4
                mov     word ptr ss:BufferQueue, bx

loc_99A4:                               ; ...
                clc
                mov     ax, ss
                mov     ds, ax
                retn
BUFWRT          endp


; =============== S U B R O U T I N E =======================================


NEXTSEC         proc near               ; ...
                test    ds:TRANS, 0FFh
                jz      short loc_99EF
                mov     al, ds:SECCLUSPOS
                inc     al
                cmp     al, es:[bp+4]
                jbe     short loc_99EC
                mov     bx, ds:CLUSNUM_HW
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, ds:CLUSNUM
                call    IsEOF
                jnb     short loc_99F1
                call    UNPACK
                jb      short loc_99F1
                push    di
                mov     di, ds:CCONTENT_HW
                mov     ds:CLUSNUM_HW, di
                pop     di
                mov     ds:CLUSNUM, di
                add     ds:LASTPOS, 1
                adc     word ptr ds:0AE2h, 0
                mov     al, 0

loc_99EC:                               ; ...
                mov     ds:SECCLUSPOS, al

loc_99EF:                               ; ...
                clc
                retn
; ---------------------------------------------------------------------------

loc_99F1:                               ; ...
                stc
                retn
NEXTSEC         endp


; =============== S U B R O U T I N E =======================================


OPTIMIZE        proc near               ; ...
                push    dx
                push    word ptr ds:0AE8h
                push    bx
                mov     al, es:[bp+4]
                inc     al
                mov     ah, al
                sub     al, dl
                mov     dx, cx
                xor     cx, cx

loc_9A07:                               ; ...
                call    UNPACK
                jb      short loc_9A76
                add     cl, al
                adc     ch, 0
                cmp     cx, dx
                jnb     short loc_9A7B
                mov     al, ah
                push    di
                xor     di, di
                add     bx, 1
                adc     ds:0AE8h, di
                mov     di, ds:0AECh
                cmp     di, ds:0AE8h
                pop     di
                jnz     short loc_9A30
                cmp     di, bx
                jz      short loc_9A07

loc_9A30:                               ; ...
                sub     bx, 1
                sbb     word ptr ds:0AE8h, 0

loc_9A38:                               ; ...
                push    bx
                add     ds:5BAh, bx
                mov     bx, ds:0AE8h
                adc     ds:0AE2h, bx
                mov     ds:0ADEh, bx
                pop     word ptr ds:5BCh
                sub     dx, cx
                push    dx
                mov     ax, cx
                mul     word ptr es:[bp+2]
                mov     si, ds:5B8h
                add     ax, si
                mov     ds:5B8h, ax
                pop     ax
                pop     dx
                pop     bx
                mov     ds:0AE8h, bx
                sub     ds:5BAh, dx
                sbb     ds:0AE2h, bx
                pop     bx
                call    FIGREC
                mov     bx, si
                clc
                retn
; ---------------------------------------------------------------------------

loc_9A76:                               ; ...
                add     sp, 6
                stc
                retn
; ---------------------------------------------------------------------------

loc_9A7B:                               ; ...
                sub     cx, dx
                sub     ah, cl
                dec     ah
                mov     ds:573h, ah
                mov     cx, dx
                jmp     short loc_9A38
OPTIMIZE        endp


; =============== S U B R O U T I N E =======================================


FIGREC          proc near               ; ...
                push    ax
                push    cx
                xor     cx, cx
                mov     cl, es:[bp+5]
                mov     ax, ss:CLUSTNUM_HW
                sub     dx, 2
                sbb     ax, 0
                jcxz    short loc_9AA4

loc_9A9D:                               ; ...
                clc
                rcl     dx, 1
                rcl     ax, 1
                loop    loc_9A9D

loc_9AA4:                               ; ...
                or      dl, bl
                cmp     word ptr es:[bp+0Fh], 0
                jnz     short loc_9AB7
                add     dx, es:[bp+29h]
                adc     ax, es:[bp+2Bh]
                jmp     short loc_9ABE
; ---------------------------------------------------------------------------

loc_9AB7:                               ; ...
                add     dx, es:[bp+0Bh]
                adc     ax, 0

loc_9ABE:                               ; ...
                mov     ss:HIGH_SECTOR, ax
                pop     cx
                pop     ax

locret_9AC4:                            ; ...
                retn
FIGREC          endp


; =============== S U B R O U T I N E =======================================


sub_9AC5        proc far                ; ...
                push    ds
                push    ss:OffsetMagicPatch
                retf
sub_9AC5        endp ; sp-analysis failed

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR ALLOCATE

loc_9ACC:                               ; ...
                jmp     loc_9CD8
; END OF FUNCTION CHUNK FOR ALLOCATE

; =============== S U B R O U T I N E =======================================


ALLOCATE        proc near               ; ...

; FUNCTION CHUNK AT 9ACC SIZE 00000003 BYTES

                clc
                push    cs
                call    near ptr sub_9AC5
                jb      short loc_9ACC
                push    bx
                xor     bx, bx
                push    ds:CLUSTNUM_HW
                mov     ds:CLUSTNUM_HW, bx
                call    UNPACK
                mov     ds:FATBYT, di
                mov     bx, ds:CCONTENT_HW
                mov     ds:FATBYT_HW, bx
                pop     ds:CLUSTNUM_HW
                pop     bx
                jb      short locret_9AC4
                push    ds:word_AF0
                push    cx
                push    ds:CLUSTNUM_HW
                push    bx
                mov     dx, bx
                xor     bx, bx
                cmp     es:[bp+0Fh], bx
                xchg    bx, ds:CLUSTNUM_HW
                mov     ds:CL0FATENTRY_SIG, bx
                mov     bx, es:[bp+1Dh]
                jnz     short loc_9B28
                mov     bx, es:[bp+3Bh]
                mov     ds:CLUSTNUM_HW, bx
                cmp     bx, 0
                mov     bx, es:[bp+39h]
                jnz     short loc_9B2B

loc_9B28:                               ; ...
                cmp     bx, 2

loc_9B2B:                               ; ...
                ja      short loc_9B4E

loc_9B2D:                               ; ...
                xor     bx, bx
                cmp     es:[bp+0Fh], bx
                jnz     short loc_9B3F
                mov     word ptr es:[bp+39h], 2
                mov     es:[bp+3Bh], bx

loc_9B3F:                               ; ...
                mov     ds:CLUSTNUM_HW, bx
                mov     word ptr es:[bp+1Dh], 2
                inc     bx
                or      es:[bp+18h], bl

loc_9B4E:                               ; ...
                add     bx, 1
                adc     ds:CLUSTNUM_HW, 0
                cmp     word ptr es:[bp+0Fh], 0
                jnz     short loc_9B6F
                push    bx
                mov     bx, ds:CLUSTNUM_HW
                cmp     bx, es:[bp+2Fh]
                pop     bx
                jnz     short loc_9B73
                cmp     bx, es:[bp+2Dh]
                jmp     short loc_9B73
; ---------------------------------------------------------------------------

loc_9B6F:                               ; ...
                cmp     bx, es:[bp+0Dh]

loc_9B73:                               ; ...
                jbe     short loc_9B78
                jmp     loc_9C9B
; ---------------------------------------------------------------------------

loc_9B78:                               ; ...
                push    cx
                push    ds:word_AF0
                push    bx
                push    ds:CLUSTNUM_HW
                push    dx
                push    ds:CL0FATENTRY_SIG
                call    UNPACK
                pop     ds:CL0FATENTRY_SIG
                pop     dx
                pop     ds:CLUSTNUM_HW
                pop     bx
                pop     ds:word_AF0
                pop     cx
                jnb     short loc_9B9E
                jmp     loc_9C54
; ---------------------------------------------------------------------------

loc_9B9E:                               ; ...
                jnz     short loc_9B4E
                mov     es:[bp+1Dh], bx
                cmp     word ptr es:[bp+0Fh], 0
                jnz     short loc_9BB9
                push    bx
                mov     bx, ds:CLUSTNUM_HW
                mov     es:[bp+3Bh], bx
                pop     bx
                mov     es:[bp+39h], bx

loc_9BB9:                               ; ...
                or      byte ptr es:[bp+18h], 1
                push    cx
                push    ds:word_AF0
                push    bx
                push    ds:CLUSTNUM_HW
                push    dx
                push    ds:CL0FATENTRY_SIG
                xor     dx, dx
                mov     ds:CL0FATENTRY_SIG, dx
                inc     dx
                call    PACK
                pop     ds:CLUSTNUM_HW
                pop     bx
                pop     ds:CL0FATENTRY_SIG
                pop     dx
                pop     word ptr ds:0AF0h
                pop     cx
                jb      short loc_9C54
                push    ax
                xor     ax, ax
                cmp     es:[bp+0Fh], ax
                jnz     short loc_9C08
                dec     ax
                cmp     es:[bp+21h], ax
                jnz     short loc_9BFC
                cmp     es:[bp+1Fh], ax

loc_9BFC:                               ; ...
                jz      short loc_9C13
                add     es:[bp+1Fh], ax
                adc     es:[bp+21h], ax
                jmp     short loc_9C13
; ---------------------------------------------------------------------------

loc_9C08:                               ; ...
                dec     ax
                cmp     es:[bp+1Fh], ax
                jz      short loc_9C13
                dec     word ptr es:[bp+1Fh]

loc_9C13:                               ; ...
                pop     ax
                push    cx
                push    word ptr ds:0AF0h
                push    dx
                push    ds:CL0FATENTRY_SIG
                call    PACK
                pop     ds:CLUSTNUM_HW
                pop     bx
                pop     word ptr ds:0AF0h
                pop     cx
                jb      short loc_9C54
                mov     dx, ds:CLUSTNUM_HW
                mov     ds:CL0FATENTRY_SIG, dx
                mov     dx, bx
                sub     cx, 1
                sbb     word ptr ds:0AF0h, 0
                cmp     cx, ds:0AF0h
                jnz     short loc_9C47
                jcxz    short loc_9C4A

loc_9C47:                               ; ...
                jmp     loc_9B4E
; ---------------------------------------------------------------------------

loc_9C4A:                               ; ...
                mov     dx, 0FFFFh
                mov     ds:0AEAh, dx
                call    PACK

loc_9C54:                               ; ...
                pop     bx
                pop     word ptr ds:0AE8h
                pop     cx
                pop     word ptr ds:0AF0h
                jnb     short loc_9C61

locret_9C60:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_9C61:                               ; ...
                call    UNPACK
                jb      short locret_9C60
                call    RESTFATBYT
                jb      short locret_9C60
                push    ax
                mov     ax, ds:0AECh
                xchg    ax, ds:0AE8h
                xchg    bx, di
                or      ax, di
                pop     ax
                jnz     short locret_9C60
                push    dx
                mov     dx, es
                les     di, ds:59Eh
                push    bx
                mov     bx, ds:0AE8h
                mov     es:[di+2Dh], bx
                mov     es:[di+37h], bx
                pop     bx
                mov     es:[di+2Bh], bx
                mov     es:[di+35h], bx
                mov     es, dx
                pop     dx
                retn
; ---------------------------------------------------------------------------

loc_9C9B:                               ; ...
                cmp     word ptr es:[bp+0Fh], 0
                jz      short loc_9CA9
                cmp     word ptr es:[bp+1Dh], 2
                jmp     short loc_9CB5
; ---------------------------------------------------------------------------

loc_9CA9:                               ; ...
                cmp     word ptr es:[bp+3Bh], 0
                jnz     short loc_9CB5
                cmp     word ptr es:[bp+39h], 2

loc_9CB5:                               ; ...
                jz      short loc_9CBA
                jmp     loc_9B2D
; ---------------------------------------------------------------------------

loc_9CBA:                               ; ...
                pop     bx
                mov     dx, 0FFFFh
                mov     ds:0AEAh, dx
                pop     word ptr ds:0AE8h
                call    RELBLKS
                pop     ax
                pop     word ptr ds:0AF2h
                sub     ax, cx
                sbb     word ptr ds:0AF2h, 0
                call    RESTFATBYT

loc_9CD8:                               ; ...
                mov     byte ptr ds:60Bh, 1
                stc
                retn
ALLOCATE        endp


; =============== S U B R O U T I N E =======================================


RESTFATBYT      proc near               ; ...
                push    bx
                push    dx
                push    di
                xor     bx, bx
                push    ds:CLUSTNUM_HW
                push    ds:CL0FATENTRY_SIG
                push    ds:CCONTENT_HW
                mov     ds:CLUSTNUM_HW, bx
                mov     dx, ds:FATBYT_HW
                mov     ds:CL0FATENTRY_SIG, dx
                mov     dx, ds:FATBYT
                call    PACK
                pop     ds:CCONTENT_HW
                pop     ds:CL0FATENTRY_SIG
                pop     ds:CLUSTNUM_HW
                pop     di
                pop     dx
                pop     bx
                retn
RESTFATBYT      endp


; =============== S U B R O U T I N E =======================================


RELEASE         proc near               ; ...
                xor     dx, dx
                mov     ds:CL0FATENTRY_SIG, dx
RELEASE         endp


; =============== S U B R O U T I N E =======================================


RELBLKS         proc near               ; ...
                call    UNPACK
                jbe     short RET12
                mov     ax, di
                push    dx
                push    ax
                call    PACK
                pop     ax
                mov     dx, ds:CCONTENT_HW
                mov     ds:CLUSTNUM_HW, dx
                mov     bx, ax
                pop     dx
                jb      short RET12
                or      dx, dx
                jnz     short NO_DEALLOC ; Was putting EOF mark
                cmp     dx, ds:CL0FATENTRY_SIG
                jnz     short NO_DEALLOC
                cmp     word ptr es:[bp+1Fh], 0FFFFh ; [ES:BP+DPB.FREE_CNT],-1
                                        ; Free count valid?
                jz      short NO_DEALLOC ; No

relblks_ifc:                            ; ...
                inc     word ptr es:[bp+1Fh] ; [ES:BP+DPB.FREE_CNT]
                                        ; Increase free count by 1
                jnz     short loc_9D63
                cmp     es:[bp+0Fh], dx
                jnz     short loc_9D63
                inc     word ptr es:[bp+21h]
                jmp     short loc_9D63
; ---------------------------------------------------------------------------

NO_DEALLOC:                             ; ...
                cmp     es:[bp+0Fh], dx
                jnz     short loc_9D63
                cmp     word ptr es:[bp+21h], 0FFFFh
                jnz     short relblks_ifc

loc_9D63:                               ; ...
                cmp     ds:CLUSTNUM_HW, 0
                jnz     short loc_9D6D
                dec     ax
                jz      short RET12

loc_9D6D:                               ; ...
                call    IsEOF
                jb      short RELEASE

RET12:                                  ; ...
                retn
RELBLKS         endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR GETEOF

GETEOF1:                                ; ...
                mov     di, ax
                mov     ds:CLUSTERS_HW, dx ; CLUSTERS_HW:DI = Cluster Count
                pop     ax
                pop     dx
                retn
; END OF FUNCTION CHUNK FOR GETEOF

; =============== S U B R O U T I N E =======================================


GETEOF          proc near               ; ...

; FUNCTION CHUNK AT 9D73 SIZE 00000009 BYTES

                push    dx
                push    ax
                xor     dx, dx
                xor     ax, ax

GETEOF2:                                ; ...
                call    UNPACK
                jb      short GETEOF1
                inc     ax
                jnz     short GETEOF3
                inc     dx

GETEOF3:                                ; ...
                push    bx
                push    ds:CLUSTNUM_HW
                mov     bx, ds:CCONTENT_HW
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, di
                call    IsEOF
                pop     ds:CLUSTNUM_HW
                pop     bx
                jnb     short GETEOF1   ; EOF
                mov     bx, ds:CCONTENT_HW ; not EOF
                mov     ds:CLUSTNUM_HW, bx
                mov     bx, di
                jmp     short GETEOF2   ; get next cluster
GETEOF          endp


; =============== S U B R O U T I N E =======================================


MAKEFCB         proc near               ; ...
                xor     dl, dl
                mov     ss:SpaceFlag, dl
                test    al, 2
                jnz     short loc_9DBE
                mov     es:[di], dl

loc_9DBE:                               ; ...
                inc     di
                mov     cx, 8
                test    al, 4
                xchg    ax, bx
                mov     al, 20h ; ' '
                jz      short loc_9DCD
                add     di, cx
                xor     cx, cx

loc_9DCD:                               ; ...
                rep stosb
                mov     cl, 3
                test    bl, 8
                jz      short loc_9DDA

loc_9DD6:
                add     di, cx
                xor     cx, cx

loc_9DDA:                               ; ...
                rep stosb
                xchg    ax, cx
                stosw
                stosw
                sub     di, 10h
                test    bl, 1
                jz      short loc_9DF0
                call    sub_9E74
                call    sub_9F0D
                jnz     short loc_9DF3
                inc     si

loc_9DF0:                               ; ...
                call    sub_9E74

loc_9DF3:                               ; ...
                call    sub_9EE4
                jbe     short loc_9E16
                cmp     byte ptr [si], 3Ah ; ':'
                jnz     short loc_9E16
                inc     si
                sub     al, 40h ; '@'
                jbe     short loc_9E11
                push    ax
                call    GetVisDrv
                pop     ax
                jnb     short loc_9E13
                cmp     byte ptr ss:610h, 1Ah
                jz      short loc_9E13

loc_9E11:                               ; ...
                mov     dl, 0FFh

loc_9E13:                               ; ...
                stosb
                inc     si
                dec     di

loc_9E16:                               ; ...
                dec     si
                inc     di
MAKEFCB         endp


; =============== S U B R O U T I N E =======================================


NORMSCAN        proc near               ; ...
                mov     cx, 8
                call    sub_9E42
                cmp     byte ptr [si], 2Eh ; '.'
                jnz     short loc_9E34
                inc     si
                mov     cx, 3
                test    byte ptr ss:612h, 1
                jz      short loc_9E31
                movsb
                dec     cx

loc_9E31:                               ; ...
                call    sub_9E48

loc_9E34:                               ; ...
                mov     al, dl
                and     ss:DOS34_FLAG, 0FEFFh
                retn
NORMSCAN        endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR sub_9E42

loc_9E3E:                               ; ...
                add     di, cx
                dec     si
                retn
; END OF FUNCTION CHUNK FOR sub_9E42

; =============== S U B R O U T I N E =======================================


sub_9E42        proc near               ; ...

; FUNCTION CHUNK AT 9E3E SIZE 00000004 BYTES

                call    sub_9EE4
                jbe     short loc_9E3E
                dec     si
sub_9E42        endp


; =============== S U B R O U T I N E =======================================


sub_9E48        proc near               ; ...
                call    sub_9EE4
                jnz     short loc_9E59
                test    byte ptr ss:34Eh, 0FFh
                jz      short loc_9E6E
                cmp     al, 20h ; ' '
                jnz     short loc_9E6E

loc_9E59:                               ; ...
                jcxz    short sub_9E48
                dec     cx
                cmp     al, 2Ah ; '*'
                jnz     short loc_9E64
                mov     al, 3Fh ; '?'
                rep stosb

loc_9E64:                               ; ...
                stosb
                cmp     al, 3Fh ; '?'
                jnz     short sub_9E48
                or      dl, 1
                jmp     short sub_9E48
; ---------------------------------------------------------------------------

loc_9E6E:                               ; ...
                mov     al, 20h ; ' '
                rep stosb
                dec     si
                retn
sub_9E48        endp


; =============== S U B R O U T I N E =======================================


sub_9E74        proc near               ; ...
                lodsb
                call    sub_9F15
                jz      short sub_9E74
                dec     si

locret_9E7B:                            ; ...
                retn
sub_9E74        endp


; =============== S U B R O U T I N E =======================================


NameTrans       proc near               ; ...
                mov     ss:SpaceFlag, 1
                push    ss
                pop     es
                mov     di, offset NAME1
                push    di
                mov     al, 20h ; ' '
                mov     cx, 11
                rep stosb
                xchg    ax, cx
                cwd
                stosb
                pop     di
                call    NORMSCAN
                cmp     ss:NAME1, 0E5h
                jnz     short locret_9E7B
                mov     ss:NAME1, 5     ; Magic name translation
                retn
NameTrans       endp

; ---------------------------------------------------------------------------
CharType        db  66h, 66h, 66h, 66h,   6, 66h, 66h, 66h ; ...
                db  66h, 66h, 66h, 66h, 66h, 66h, 66h, 66h
                db 0F8h,0F6h,0FFh,0FFh,0FFh, 4Fh,0F4h, 6Eh
                db 0FFh,0FFh,0FFh,0FFh,0FFh, 44h, 44h,0F4h
                db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
                db 0FFh,0FFh,0FFh,0FFh,0FFh, 6Fh, 66h,0FFh
                db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
                db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0F4h

; =============== S U B R O U T I N E =======================================


sub_9EE4        proc near               ; ...
                lodsb
sub_9EE4        endp


; =============== S U B R O U T I N E =======================================


UCase           proc near               ; ...
                push    bx
                mov     bx, offset FILE_UCASE_TAB_2

loc_9EE9:                               ; ...
                cmp     al, 61h ; 'a'
                jb      short loc_9F01
                cmp     al, 7Ah ; 'z'
                ja      short loc_9EF3
                sub     al, 20h ; ' '

loc_9EF3:                               ; ...
                cmp     al, 80h
                jb      short loc_9F01
                sub     al, 80h
                push    ds
                mov     ds, cs:DosDSeg
                xlat
                pop     ds

loc_9F01:                               ; ...
                push    ax
                call    GetCharType
                test    al, 1
                pop     ax
                pop     bx
                retn
UCase           endp


; =============== S U B R O U T I N E =======================================


GETLET3         proc near               ; ...
                push    bx
                jmp     short loc_9EE9
GETLET3         endp


; =============== S U B R O U T I N E =======================================


sub_9F0D        proc near               ; ...
                push    ax
                call    GetCharType
                test    al, 2
                pop     ax
                retn
sub_9F0D        endp


; =============== S U B R O U T I N E =======================================


sub_9F15        proc near               ; ...
                push    ax
                call    GetCharType
                test    al, 4
                pop     ax
                retn
sub_9F15        endp


; =============== S U B R O U T I N E =======================================


GetCharType     proc near               ; ...
                cmp     al, 7Eh         ; CharType_last ; beyond end of table?
                jnb     short gct_90
                push    bx
                mov     bx, offset CharType ; load lookup table
                shr     al, 1           ; adjust for half-byte table entry size
                xlat    byte ptr cs:[bx] ; get flags
                pop     bx
                jnb     short gct_80    ; carry clear, no shift needed
                push    cx
                mov     cl, 4           ; we want high nibble, shift it down
                shr     al, cl
                pop     cx

gct_80:                                 ; ...
                and     al, 0Fh         ; clear the unused nibble
                retn
; ---------------------------------------------------------------------------

gct_90:                                 ; ...
                mov     al, 0Fh         ; set all flags
                retn
GetCharType     endp


; =============== S U B R O U T I N E =======================================


PATHCHRCMP      proc near               ; ...
                cmp     al, 2Fh ; '/'
                jbe     short loc_9F42
                cmp     al, 5Ch ; '\'
                retn
; ---------------------------------------------------------------------------

loc_9F3F:                               ; ...
                mov     al, 5Ch ; '\'
                retn
; ---------------------------------------------------------------------------

loc_9F42:                               ; ...
                jz      short loc_9F3F
                retn
PATHCHRCMP      endp

; ---------------------------------------------------------------------------
LowInt23Addr    dw offset LowInt23      ; ...
LowInt23_SEG    dw 0                    ; ...
LowInt24Addr    dw offset LowInt24      ; ...
LowInt24_SEG    dw 0                    ; ...
LowInt28Addr    dw offset LowInt28      ; ...
LowInt28_SEG    dw 0                    ; ...

; =============== S U B R O U T I N E =======================================


DSKSTATCHK      proc near               ; ...
                cmp     ss:INDOS, 1
                jz      short loc_9F5A
                retn
; ---------------------------------------------------------------------------

loc_9F5A:                               ; ...
                push    cx
                push    es
                push    bx
                push    ds
                push    si
                mov     bx, ss
                mov     es, bx
                mov     ds, bx
                mov     ds:DSKSTCOM, 5
                mov     ds:DSKSTCALL, 0Eh
                mov     ds:DSKSTST, 0
                mov     bx, offset DSKSTCALL
                lds     si, ds:BCON
                call    DEVIOCALL2
                push    ds
                push    ss
                pop     ds
                test    byte ptr ds:DSKSTST+1, 2
                jz      short loc_9F92
                xor     al, al

loc_9F8B:                               ; ...
                pop     si
                pop     si
                pop     ds
                pop     bx
                pop     es
                pop     cx
                retn
; ---------------------------------------------------------------------------

loc_9F92:                               ; ...
                mov     al, ds:DSKCHRET
                cmp     al, 3
                jnz     short loc_9F8B
                mov     ds:DSKSTCOM, 4
                mov     ds:DSKSTCALL, 16h
                mov     ds:DSKCHRET, cl
                mov     ds:DSKSTST, 0
                mov     ds:DSKSTCNT, 1
                pop     ds
                call    DEVIOCALL2
                pop     si
                pop     ds
                pop     bx
                pop     es
                pop     cx
                jmp     loc_A08F
DSKSTATCHK      endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR STATCHK

loc_9FBF:                               ; ...
                cmp     al, 10h
                jnz     short loc_9FCC
                cmp     ss:SCAN_FLAG, 0
                jz      short loc_9FD1
                retn
; ---------------------------------------------------------------------------

loc_9FCC:                               ; ...
                cmp     al, 3
                jz      short loc_9FD1

locret_9FD0:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_9FD1:                               ; ...
                jmp     loc_A079
; END OF FUNCTION CHUNK FOR STATCHK

; =============== S U B R O U T I N E =======================================


SPOOLINT        proc near               ; ...
                pushf
                cmp     byte ptr ss:IDLEINT, 0
                jz      short loc_A000
                cmp     ss:ERRORMODE, 0
                jnz     short loc_A000
                push    ss:IDLEINT
                cmp     ss:DosHasHMA, 0
                jnz     short loc_9FF6
                int     28h             ; DOS 2+ internal - KEYBOARD BUSY LOOP
                jmp     short loc_9FFB
; ---------------------------------------------------------------------------

loc_9FF6:                               ; ...
                call    dword ptr cs:LowInt28Addr

loc_9FFB:                               ; ...
                pop     ss:IDLEINT

loc_A000:                               ; ...
                popf

locret_A001:                            ; ...
                retn
SPOOLINT        endp


; =============== S U B R O U T I N E =======================================


STATCHK         proc far                ; ...

; FUNCTION CHUNK AT 4123 SIZE 00000088 BYTES
; FUNCTION CHUNK AT 41AF SIZE 00000003 BYTES
; FUNCTION CHUNK AT 41D7 SIZE 00000148 BYTES
; FUNCTION CHUNK AT 9FBF SIZE 00000015 BYTES

                call    DSKSTATCHK
                push    bx
                xor     bx, bx
                call    GET_IO_SFT
                pop     bx
                jb      short locret_A001
                mov     ah, 1
                call    IOFUNC
                jz      short SPOOLINT
                cmp     al, 13h
                jnz     short loc_9FBF
                cmp     ss:SCAN_FLAG, 0
                jnz     short locret_9FD0
                xor     ah, ah
                call    IOFUNC
                jmp     short loc_A072
; ---------------------------------------------------------------------------

loc_A028:                               ; ...
                not     ss:PFLAG
                push    bx
                mov     bx, 4
                call    GET_IO_SFT
                pop     bx
                jb      short locret_A001
                push    es
                push    di
                push    ds
                pop     es
                mov     di, si
                test    byte ptr es:[di+6], 8
                jz      short loc_A05C
                push    ax
                mov     ax, 1126h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - ???
                                        ; Return: CF set on error, AX = error code
                                        ; STACK unchanged
                pop     ax
                jnb     short loc_A05C
                mov     ss:PFLAG, 0
                push    ax
                mov     ax, 1124h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - ???
                                        ; ES:DI -> SFT, SS = DOS CS
                pop     ax
                jmp     short loc_A06C
; ---------------------------------------------------------------------------

loc_A05C:                               ; ...
                cmp     ss:PFLAG, 0
                jnz     short loc_A069
                call    DEV_CLOSE_SFT
; ---------------------------------------------------------------------------
                jmp     short loc_A06C
; ---------------------------------------------------------------------------

loc_A069:                               ; ...
                call    sub_92CA

loc_A06C:                               ; ...
                pop     di
                pop     es

locret_A06E:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_A06F:                               ; ...
                call    SPOOLINT

loc_A072:                               ; ...
                mov     ah, 1
                call    IOFUNC
                jz      short loc_A06F

loc_A079:                               ; ...
                push    bx
                xor     bx, bx
                call    GET_IO_SFT
                pop     bx
                jb      short locret_A06E
                xor     ah, ah
                call    IOFUNC
                cmp     al, 10h
                jz      short loc_A028
                cmp     al, 3
                jnz     short locret_A06E

loc_A08F:                               ; ...
                test    byte ptr ss:DOS34_FLAG+1, 2
                jnz     short loc_A09F
                mov     al, 3
                call    BUFOUT
                call    CRLF

loc_A09F:                               ; ...
                push    ss
                pop     ds
                cmp     ds:CONSWAP, 0
                jz      short loc_A0AB
                call    sub_7B59

loc_A0AB:                               ; ...
                cli
                mov     ss, ds:USER_SS
                mov     sp, ds:USER_SP
                call    restore_world
                pop     es
                push    ds
                mov     ds, cs:DosDSeg
                mov     ds:INDOS, 0
                mov     ds:INDOS_FLAG, 0
                mov     ds:ERRORMODE, 0
                mov     ds:ConC_Spsave, sp
                add     ds:ConC_Spsave, 2
                cmp     ds:DosHasHMA, 0
                pop     ds
                jnz     short loc_A0E3
                clc
                int     23h             ; DOS - CONTROL "C" EXIT ADDRESS
                                        ; Return: return via RETF 2 with CF set
                                        ; DOS will abort program with errorlevel 0
                                        ; else
                                        ; interrupted DOS call continues
                jmp     short loc_A0E9
; ---------------------------------------------------------------------------

loc_A0E3:                               ; ...
                clc
                call    dword ptr cs:LowInt23Addr

loc_A0E9:                               ; ...
                cli
                push    ax
                mov     ax, ds
                mov     ds, cs:DosDSeg
                mov     ds:0D63h, ax
                pop     ax
                mov     ds:33Ah, ax
                pushf
                pop     ax
                cmp     sp, ds:332h
                jnz     short loc_A10B

loc_A101:                               ; ...
                mov     ax, ds:33Ah
                mov     ds, word ptr ds:0D63h

loc_A108:                               ; ...
                jmp     COMMAND
; ---------------------------------------------------------------------------

loc_A10B:                               ; ...
                test    al, 1
                pop     ax
                jz      short loc_A101
                mov     ds, word ptr ds:0D63h

loc_A114:                               ; ...
                mov     ax, 4C00h
                push    ds
                mov     ds, cs:DosDSeg
                mov     byte ptr ds:34Dh, 0FFh
                pop     ds
                jmp     short loc_A108
STATCHK         endp ; sp-analysis failed

; ---------------------------------------------------------------------------

DIVOV:                                  ; ...
                mov     si, 48C3h
                mov     bx, cs:DivMesLen
                mov     ss, cs:DosDSeg
                mov     sp, 7A0h
                call    sub_A13A
                jmp     short loc_A114

; =============== S U B R O U T I N E =======================================


sub_A13A        proc near               ; ...
                push    ss
                pop     es
                push    ss
                pop     ds
                mov     byte ptr ds:394h, 8
                mov     byte ptr ds:392h, 16h
                mov     word ptr ds:395h, 0
                mov     ds:3A4h, bx
                mov     bx, 392h
                mov     ds:3A0h, si
                mov     word ptr ds:3A2h, cs
                lds     si, ds:32h
                call    DEVIOCALL2
                mov     word ptr es:3A0h, 3BCh
                mov     word ptr es:3A4h, 1
                retn
sub_A13A        endp


; =============== S U B R O U T I N E =======================================


sub_A173        proc near               ; ...
                cmp     byte ptr ss:320h, 0
                jnz     short loc_A186
                or      ah, 10h
                test    byte ptr ss:2FEh, 0FFh
                jnz     short loc_A189

loc_A186:                               ; ...
                or      ah, 38h

loc_A189:                               ; ...
                mov     ss:34Bh, ah
                mov     word ptr ss:582h, es
                mov     ss:580h, bp
                push    si
                and     di, 0FFh
                mov     bp, ds
                call    near ptr sub_A242
                pop     si
                retn
sub_A173        endp


; =============== S U B R O U T I N E =======================================


HARDERR         proc near               ; ...
                xchg    ax, di
                and     di, 0FFh
                cmp     di, 0
                jnz     short loc_A1B8
                push    ax
                mov     al, es:[bp+0]
                mov     ss:WPERR, al
                pop     ax

loc_A1B8:                               ; ...
                sub     ax, cx
                add     dx, ax
                adc     ss:HIGH_SECTOR, 0
                push    dx
                mul     word ptr es:[bp+2]
                pop     dx
                add     bx, ax
                xor     ah, ah
                cmp     ss:HIGH_SECTOR, 0
                jnz     short loc_A1DA
                cmp     dx, es:[bp+6]
                jb      short loc_A222

loc_A1DA:                               ; ...
                inc     ah
                cmp     word ptr es:[bp+0Fh], 0
                jnz     short loc_A20A
                push    dx
                mov     dx, ss:HIGH_SECTOR
                cmp     dx, es:[bp+2Bh]
                pop     dx
                jnz     short loc_A1F4
                cmp     dx, es:[bp+29h]

loc_A1F4:                               ; ...
                jnb     short loc_A204
                mov     word ptr es:[bp+1Fh], 0FFFFh
                mov     word ptr es:[bp+21h], 0FFFFh
                jmp     short loc_A222
; ---------------------------------------------------------------------------

loc_A204:                               ; ...
                inc     ah
                inc     ah
                jmp     short loc_A222
; ---------------------------------------------------------------------------

loc_A20A:                               ; ...
                cmp     dx, es:[bp+11h]
                jnb     short loc_A218
                mov     word ptr es:[bp+1Fh], 0FFFFh
                jmp     short loc_A222
; ---------------------------------------------------------------------------

loc_A218:                               ; ...
                inc     ah

loc_A21A:
                cmp     dx, es:[bp+0Bh]
                jb      short loc_A222
                inc     ah

loc_A222:                               ; ...
                shl     ah, 1
                or      ah, ss:READOP
                or      ah, ss:ALLOWED
HARDERR         endp


; =============== S U B R O U T I N E =======================================


FATAL           proc near               ; ...
                mov     al, es:[bp+0]
FATAL           endp


; =============== S U B R O U T I N E =======================================


FATAL1          proc near               ; ...
                mov     word ptr ss:582h, es
                mov     ss:580h, bp
                les     si, es:[bp+13h]
                mov     bp, es
FATAL1          endp


; =============== S U B R O U T I N E =======================================


sub_A242        proc far                ; ...

; FUNCTION CHUNK AT B40B SIZE 0000000D BYTES
; FUNCTION CHUNK AT B420 SIZE 00000022 BYTES

                call    sub_A3E5
                cmp     di, 0Ch
                jbe     short NET_I24_ENTRY
                mov     di, 0Ch

NET_I24_ENTRY:                          ; ...
                cmp     ss:ERRORMODE, 0
                jz      short loc_A259
                mov     al, 3
                jmp     short loc_A2CD
; ---------------------------------------------------------------------------

loc_A259:                               ; ...
                mov     ss:588h, sp
                push    ss
                pop     es
                cmp     ss:SFN, 0FFFFh
                jz      short loc_A274
                push    ds
                push    si
                lds     si, ss:5AEh
                mov     byte ptr [si], 0FFh
                pop     si
                pop     ds

loc_A274:                               ; ...
                cli
                inc     ss:ERRORMODE
                dec     ss:INDOS
                dec     ss:INDOS_FLAG
                test    ss:EXTOPEN_ON, 2
                jz      short loc_A290
                mov     al, 3
                jmp     short loc_A2B7
; ---------------------------------------------------------------------------

loc_A290:                               ; ...
                mov     ss, ss:USER_SS
                mov     sp, es:USER_SP
                cmp     es:DosHasHMA, 0
                jnz     short loc_A2A6
                int     24h             ; DOS - FATAL ERROR HANDLER ADDRESS
                                        ; Automatically called upon detection of unrecoverable I/O error.
                jmp     short loc_A2AB
; ---------------------------------------------------------------------------

loc_A2A6:                               ; ...
                call    dword ptr cs:LowInt24Addr

loc_A2AB:                               ; ...
                mov     es:USER_SP, sp
                mov     es:USER_SS, ss
                push    es
                pop     ss

loc_A2B7:                               ; ...
                mov     sp, ss:588h
                inc     ss:INDOS
                inc     ss:INDOS_FLAG
                mov     ss:ERRORMODE, 0
                sti

loc_A2CD:                               ; ...
                les     bp, ss:580h
                cmp     al, 1
                jb      short loc_A314
                jz      short loc_A31E
                cmp     al, 3
                jnz     short loc_A326
                test    ss:ALLOWED, 8
                jz      short loc_A326

loc_A2E4:                               ; ...
                mov     al, 3
                test    ss:EXTOPEN_ON, 2
                jnz     short loc_A2F3
                inc     ss:FAILERR

loc_A2F3:                               ; ...
                mov     ss:WPERR, 0FFh
                cmp     ss:SFN, 0FFFFh
                jnz     short loc_A302
                retn
; ---------------------------------------------------------------------------

loc_A302:                               ; ...
                push    ds
                push    si
                push    ax
                mov     ax, ss:SFN
                lds     si, ss:5AEh
                mov     [si], al
                pop     ax
                pop     si
                pop     ds
                retn
; ---------------------------------------------------------------------------

loc_A314:                               ; ...
                test    ss:ALLOWED, 20h

loc_A31A:                               ; ...
                jz      short loc_A2E4
                jmp     short loc_A2F3
; ---------------------------------------------------------------------------

loc_A31E:                               ; ...
                test    ss:ALLOWED, 10h
                jmp     short loc_A31A
; ---------------------------------------------------------------------------

loc_A326:                               ; ...
                push    ss
                pop     ds
                cmp     ds:CONSWAP, 0
                jz      short loc_A332
                call    sub_7B59

loc_A332:                               ; ...
                cmp     byte ptr ds:359h, 0
                jnz     short loc_A2E4
                mov     byte ptr ds:EXIT_TYPE, 2
                xor     al, al
                jmp     exit_inner
; ---------------------------------------------------------------------------

loc_A343:                               ; ...
                push    ds
                mov     ah, 82h
                int     2Ah             ; Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7
                mov     byte ptr ss:359h, 0FFh
                mov     ax, 1122h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
                                        ; SS = DOS CS
                mov     al, 22h ; '"'
                call    $GET_INTERRUPT_VECTOR
                pop     cx
                push    es
                push    bx
                mov     bx, ss:330h
                mov     ds, bx
                mov     ax, ds:16h
                cmp     ax, bx
                jz      short loc_A381
                cmp     bx, cx
                jnz     short loc_A381
                push    ax
                cmp     byte ptr ss:57Ch, 3
                jz      short loc_A37C
                call    sub_B44A
                call    sub_7685

loc_A37C:                               ; ...
                pop     word ptr ss:330h

loc_A381:                               ; ...
                push    ss
                pop     ds
                mov     al, 0FFh
                call    ECritDisk
                call    FLUSHBUF
                call    LCritDisk
                cli
                mov     byte ptr ds:321h, 0
                mov     byte ptr ds:12B8h, 0
                mov     byte ptr ds:322h, 0FFh
                mov     byte ptr ds:359h, 0
                pop     word ptr ds:580h
                pop     word ptr ds:582h
                mov     ds, word ptr ds:330h
                mov     ss, word ptr ds:30h
                mov     sp, ds:2Eh
                call    restore_world
sub_A242        endp

                pop     es
                push    ax
                mov     ax, ds
                mov     ds, cs:DosDSeg
                mov     ds:0D63h, ax
                pop     ax
                mov     ds:584h, ax
                pop     ax
                pop     ax
                pop     ax
                lahf
                xchg    ah, al
                and     al, 2
                mov     ah, 0F2h
                push    ax
                push    word ptr ds:582h
                push    word ptr ds:580h
                mov     ax, ds:584h
                mov     ds, word ptr ds:0D63h
                iret

; =============== S U B R O U T I N E =======================================


sub_A3E5        proc near               ; ...
                push    ax
                mov     ax, 0EBBh
                sub     ax, 0EABh
                push    ds
                mov     ds, cs:DosDSeg
                cmp     di, ax
                mov     ax, di
                jnb     short loc_A3FE
                mov     al, [di+0EABh]
                xor     ah, ah

loc_A3FE:                               ; ...
                mov     ds:324h, ax
                pop     ds
                pop     ax
                push    si
                mov     si, 0E5Bh
                call    CAL_LK
                pop     si
                retn
sub_A3E5        endp


; =============== S U B R O U T I N E =======================================


IsEOF           proc near               ; ...
                call    IsFAT32
                jnb     short IsEOF_FAT ; 12 or 16 bit compare
                cmp     ss:CLUSTNUM_HW, 0FFFh ; FAT32
                jnz     short IsEOF_other1 ; not EOF
                cmp     bx, 0FFF8h      ; 32 bit compare

IsEOF_other1:                           ; ...
                retn                    ; cf=0 -> EOF, cf=1 -> not EOF
; ---------------------------------------------------------------------------

IsEOF_FAT:                              ; ...
                cmp     word ptr es:[bp+0Dh], 0FF6h ; [es:bp+DPB.MAX_CLUSTER]
                                        ; is this 16 bit fat?
                jnb     short EOF16     ; yes, check for eof there
                cmp     bx, 0FF0h
                jz      short IsEOF_other2
                cmp     bx, 0FF8h       ; do the 12 bit compare

IsEOF_other2:                           ; ...
                retn                    ; cf=0 -> EOF, cf=1 -> not EOF
; ---------------------------------------------------------------------------

EOF16:                                  ; ...
                cmp     bx, 0FFF8h      ; 16 bit compare
                retn                    ; cf=0 -> EOF, cf=1 -> not EOF
IsEOF           endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR UNPACK

up_1:                                   ; ...
                cmp     ds:CLUSTNUM_HW, bx
                jnz     short up_cont
                mov     di, ds:CL0FATENTRY_HW
                or      di, di
                mov     ds:CCONTENT_HW, di
                mov     di, ds:CL0FATENTRY
                jnz     short unpack_retn
                or      di, di

unpack_retn:                            ; ...
                retn
; END OF FUNCTION CHUNK FOR UNPACK

; =============== S U B R O U T I N E =======================================


UNPACK          proc near               ; ...

; FUNCTION CHUNK AT A435 SIZE 00000019 BYTES

                or      bx, bx
                jz      short up_1

up_cont:                                ; ...
                cmp     word ptr es:[bp+0Fh], 0 ; [ES:BP+DPB.FAT_SIZE]
                jnz     short up_fat    ; not FAT32
                mov     si, es:[bp+2Fh] ; [ES:BP+DPB.LAST_CLUSTER+2]
                cmp     ds:CLUSTNUM_HW, si
                jnz     short up_2
                cmp     bx, es:[bp+2Dh] ; [ES:BP+DPB.LAST_CLUSTER]
                jmp     short up_2
; ---------------------------------------------------------------------------

up_fat:                                 ; ...
                cmp     bx, es:[bp+0Dh] ; [ES:BP+DPB.MAX_CLUSTER]

up_2:                                   ; ...
                ja      short HURTFAT   ; error (> cluster count)
                call    MAPCLUSTER
                jb      short _DoContext
                push    word ptr [di+2] ; offset CLUSSAVE+2
                pop     ss:CCONTENT_HW  ; high word of cluster number
                mov     di, [di]        ; offset CLUSSAVE
                jnz     short High12
                call    IsFAT32
                jb      short up_fat32  ; FAT32 volume (drive)
                mov     ss:CCONTENT_HW, 0
                mov     si, es:[bp+0Dh] ; [ES:BP+DPB.MAX_CLUSTER]
                                        ; is this 16-bit fat?
                cmp     si, 0FF6h       ; 4096-10
                jb      short Unpack12  ; No, go 'AND' off bits

up_fat32:                               ; ...
                or      di, di          ; set zero condition code, clears carry
                mov     si, ss
                mov     ds, si
                jnz     short up_retn
                or      ds:CCONTENT_HW, di ; CCONTENT_HW:di = 0 -> zf = 1

up_retn:                                ; ...
                retn
; ---------------------------------------------------------------------------

High12:                                 ; ...
                mov     ss:CCONTENT_HW, 0
                shr     di, 1
                shr     di, 1
                shr     di, 1
                shr     di, 1

Unpack12:                               ; ...
                and     di, 0FFFh

_DoContext:                             ; ...
                mov     si, ss
                mov     ds, si
                retn
; ---------------------------------------------------------------------------

HURTFAT:                                ; ...
                call    chk_set_first_access
                push    ax
                mov     ah, 88h         ; Allowed_FAIL+80h
                mov     ss:ALLOWED, 8   ; Allowed_FAIL
                push    ss:CLUSTNUM_HW
                push    bx
                call    FATAL
                pop     bx
                pop     ss:CLUSTNUM_HW
                xor     di, di
                dec     di              ; 0FFFFh
                mov     ss:CCONTENT_HW, di
                cmp     al, 3
                clc
                jnz     short OKU_RET   ; Try to ignore bad FAT
                stc                     ; User said FAIL

OKU_RET:                                ; ...
                pop     ax

hurtfat_retn:                           ; ...
                retn
UNPACK          endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR PACK

p_clust_0:                              ; ...
                cmp     ds:CLUSTNUM_HW, bx ; 0
                jnz     short p_cont
                push    ax
                mov     ax, ds:CL0FATENTRY_SIG
                mov     ds:CL0FATENTRY_HW, ax
                pop     ax
                mov     ds:CL0FATENTRY, dx
                retn
; END OF FUNCTION CHUNK FOR PACK

; =============== S U B R O U T I N E =======================================


PACK            proc near               ; ...

; FUNCTION CHUNK AT A4E6 SIZE 00000013 BYTES

                or      bx, bx          ; are we packing cluster 0 ?
                jz      short p_clust_0 ; place value in CL0FATENTRY

p_cont:                                 ; ...
                call    MAPCLUSTER
                jb      short _DoContext
                mov     si, [di]
                jz      short ALIGNED
                add     dx, dx
                add     dx, dx
                add     dx, dx
                add     dx, dx
                and     si, 0Fh
                jmp     short PACKIN
; ---------------------------------------------------------------------------

ALIGNED:                                ; ...
                call    IsFAT32
                jnb     short p_fat
                mov     si, ss:CL0FATENTRY_SIG
                xor     si, [di+2]      ; hw of cluster number
                                        ; offset CLUSSAVE+2
                and     si, 0FFFh
                xor     [di+2], si
                mov     [di], dx
                jmp     short PACKIN2
; ---------------------------------------------------------------------------

p_fat:                                  ; ...
                cmp     word ptr es:[bp+0Dh], 0FF6h
                jnb     short Pack16
                and     si, 0F000h
                and     dh, 0Fh
                jmp     short PACKIN
; ---------------------------------------------------------------------------

Pack16:                                 ; ...
                xor     si, si

PACKIN:                                 ; ...
                or      si, dx
                mov     [di], si

PACKIN2:                                ; ...
                lds     si, ss:CURBUF
                test    byte ptr [si+5], 40h ; [SI+BUFFINFO.buf_flags],buf_dirty
                jnz     short yesdirty11
                inc     ss:DirtyBufferCount
                or      byte ptr [si+5], 40h ; [SI+BUFFINFO.buf_flags],buf_dirty

yesdirty11:                             ; ...
                cmp     ss:CLUSSPLIT, 0
                mov     dx, ss
                mov     ds, dx
                jz      short hurtfat_retn
                push    ax
                push    ds:CLUSTNUM_HW
                push    bx
                push    cx
                mov     ax, ds:CLUSSAVE
                add     si, 24          ; BUFINSIZ
                mov     ds, word ptr ds:CURBUF+2
                assume ds:DOSCODE
                mov     [si], ah
                lds     dx, ss:CLUSSEC
                assume ds:nothing
                push    ax
                mov     ss:HIGH_SECTOR, ds
                mov     si, ss
                mov     ds, si
                mov     si, 1
                xor     al, al
                call    GETBUFFRB
                pop     ax
                jb      short POPP_RET
                lds     di, ds:CURBUF
                test    byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty
                jnz     short yesdirty12
                inc     ss:DirtyBufferCount
                or      byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty

yesdirty12:                             ; ...
                add     di, 23          ; BUFINSIZ-1
                add     di, es:[bp+2]   ; [ES:BP+DPB.SECTOR_SIZE]
                clc
                mov     [di], al

POPP_RET:                               ; ...
                mov     cx, ss
                mov     ds, cx
                pop     cx
                pop     bx
                pop     ss:CLUSTNUM_HW
                pop     ax
                retn
PACK            endp


; =============== S U B R O U T I N E =======================================


IsFAT32         proc near               ; ...
                cmp     word ptr es:[bp+0Fh], 1 ; [es:bp+DBP.FAT_SIZE]
                jnb     short isfat32eof_2 ; not FAT32
                cmp     word ptr es:[bp+2Fh], 0 ; [es:bp+DPB.LAST_CLUSTER+2]
                jnz     short isfat32eof_1 ; FAT32
                cmp     word ptr es:[bp+2Dh], 0FFF6h ; [es:bp+DPB.LAST_CLUSTER]

isfat32eof_1:                           ; ...
                cmc                     ; cf=1 -> FAT32

isfat32eof_2:                           ; ...
                retn
IsFAT32         endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR MAPCLUSTER

loc_A5CE:                               ; ...
                xchg    ax, di
                xchg    ax, dx
                div     cx
                xchg    ax, di
                div     cx
                jmp     short loc_A637
; END OF FUNCTION CHUNK FOR MAPCLUSTER

; =============== S U B R O U T I N E =======================================


MAPCLUSTER      proc near               ; ...

; FUNCTION CHUNK AT A5CE SIZE 00000009 BYTES

                mov     ds:CLUSSPLIT, 0
                push    ax
                push    bx
                push    cx
                push    dx
                push    ds:CLUSTNUM_HW
                mov     ax, bx
                mov     dx, ds:CLUSTNUM_HW
                xor     di, di
                call    IsFAT32
                jnb     short loc_A5FF
                shl     ax, 1
                rcl     dx, 1
                rcl     di, 1
                shl     ax, 1
                rcl     dx, 1
                rcl     di, 1
                jmp     short loc_A613
; ---------------------------------------------------------------------------

loc_A5FF:                               ; ...
                cmp     word ptr es:[bp+0Dh], 0FF6h
                jnb     short loc_A60B
                shr     dx, 1
                rcr     ax, 1

loc_A60B:                               ; ...
                add     ax, bx
                adc     dx, ds:CLUSTNUM_HW
                adc     di, di

loc_A613:                               ; ...
                mov     cx, es:[bp+2]
                cmp     cx, 200h
                jnz     short loc_A5CE
                push    ax
                shr     di, 1
                rcr     dx, 1
                rcr     ax, 1
                mov     al, ah
                mov     ah, dl
                mov     dl, dh
                xor     dh, dh
                shr     di, 1
                adc     dh, dh
                xchg    dx, di
                pop     dx
                and     dx, 1FFh

loc_A637:                               ; ...
                add     ax, es:[bp+6]
                adc     di, 0
                dec     cx
                push    di
                push    ax
                push    dx
                push    cx
                mov     dx, ax
                mov     ds:HIGH_SECTOR, di
                xor     al, al
                mov     si, 1
                call    GETBUFFRB
                pop     cx
                pop     ax
                pop     dx
                pop     bx
                jb      short loc_A6BC
                lds     si, ds:CURBUF
                lea     di, [si+18h]
                add     di, ax
                cmp     ax, cx
                jnz     short loc_A69F
                mov     al, [di]
                mov     si, ss
                mov     ds, si
                inc     ds:CLUSSPLIT
                mov     byte ptr ds:CLUSSAVE, al
                mov     word ptr ds:CLUSSEC, dx
                xor     ax, ax
                add     dx, 1
                mov     word ptr ds:CLUSSEC+2, bx
                adc     bx, ax
                mov     ds:HIGH_SECTOR, bx
                mov     si, 1
                call    GETBUFFRB
                jb      short loc_A6BC
                lds     si, ds:CURBUF
                lea     di, [si+18h]
                mov     al, [di]
                mov     di, ss
                mov     ds, di
                mov     byte ptr ds:CLUSSAVE+1, al
                mov     di, offset CLUSSAVE

loc_A69F:                               ; ...
                pop     ss:CLUSTNUM_HW
                pop     dx
                pop     cx
                pop     bx
                xor     ax, ax
                call    IsFAT32
                jb      short loc_A6B8
                cmp     word ptr es:[bp+0Dh], 0FF6h
                jnb     short loc_A6B8
                mov     ax, bx

loc_A6B8:                               ; ...
                test    al, 1
                pop     ax
                retn
; ---------------------------------------------------------------------------

loc_A6BC:                               ; ...
                pop     ss:CLUSTNUM_HW
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                retn
MAPCLUSTER      endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


FATREAD_SFT     proc near               ; ...
                les     bp, es:[di+7]   ; [ES:DI+SF_ENTRY.sf_devptr]

fatread_gotdpb:                         ; ...
                mov     al, es:[bp+0]
                mov     ds:THISDRV, al
                call    GOTDPB          ; Set THISDPB
                call    FAT_GOT_DPB

fatread_sft_retn:                       ; ...
                retn
FATREAD_SFT     endp


; =============== S U B R O U T I N E =======================================


FATREAD_CDS     proc near               ; ...
                push    es
                push    di
                les     bp, es:[di+45h] ; [ES:DI+curdir.devptr]
                call    fatread_gotdpb
                pop     di
                pop     es
                jb      short fatread_sft_retn
                jnz     short NO_CHANGE
                mov     ax, 0FFFFh      ; -1
                push    ds
                mov     cl, ds:CDSCOUNT
                xor     ch, ch          ; CX is number of structures
                lds     si, es:[di+45h] ; Find all CDS with this devptr
                les     di, ss:CDSADDR  ; (es:di) = CDS pointer

frcd20:                                 ; ...
                test    byte ptr es:[di+44h], 80h ; ES:DI+curdir.flags+1],
                                        ; (curdir_isnet>>8)
                jnz     short frcd25
                cmp     si, es:[di+45h] ; [ES:DI+curdir.devptr]
                jnz     short frcd25    ; no match
                mov     bx, ds
                cmp     bx, es:[di+47h] ; [ES:DI+curdir.devptr+2]
                jnz     short frcd25    ; CDS not for this drive
                test    es:[di+49h], ax ; [ES:DI+curdir.ID]
                                        ; If root (0), leave root
                jz      short frcd25    ; = 0
                test    es:[di+4Bh], ax ; [ES:DI+curdir.ID+2]
                jz      short frcd25    ; leave root (= 0)
                mov     es:[di+4Bh], ax ; else invalid (-1)
                mov     es:[di+49h], ax ; -1

frcd25:                                 ; ...
                add     di, 88          ; add di,curdir.size
                                        ; Point to next CDS
                loop    frcd20
                pop     ds

NO_CHANGE:                              ; ...
                les     bp, ds:THISDPB
                clc
                retn
FATREAD_CDS     endp


; =============== S U B R O U T I N E =======================================


chk_set_first_access proc near          ; ...
                cmp     word ptr es:[bp+0Fh], 0 ; DPB.FATSIZE
                jnz     short chk_set_fa_1 ; FAT (FAT12 or FAT16)
                                        ; FAT32
                cmp     word ptr es:[bp+21h], 0FFFFh ; DPB.FREE_CNT_HW
                mov     word ptr es:[bp+21h], 0FFFFh ; High word of free cluster count
                jnz     short chk_set_fa_2

chk_set_fa_1:                           ; ...
                cmp     word ptr es:[bp+1Fh], 0FFFFh ; DPB.FREE_CNT

chk_set_fa_2:                           ; ...
                mov     word ptr es:[bp+1Fh], 0FFFFh ; Count of free clusters, -1 if unknown
                jz      short chk_set_fa_3
                or      byte ptr es:[bp+18h], 1 ; DPB.FIRST_ACCESS

chk_set_fa_3:                           ; ...
                retn
chk_set_first_access endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR FAT_GOT_DPB

FATERR:                                 ; ...
                call    chk_set_first_access ; Err in FAT must force recalc of freespace
                and     di, 0FFh        ; STECODE
                mov     ds:ALLOWED, 18h ; [ALLOWED],Allowed_FAIL+Allowed_RETRY
                mov     ah, 1Ah         ; 2+Allowed_FAIL+Allowed_RETRY
                                        ; (While trying to read FAT)
                mov     al, ds:THISDRV  ; Tell which drive
                call    FATAL1
                les     bp, ds:THISDPB
                cmp     al, 3
                jnz     short FAT_GOT_DPB ; User said retry

FATERR_fail:                            ; ...
                stc                     ; User said FAIL
                retn
; END OF FUNCTION CHUNK FOR FAT_GOT_DPB

; =============== S U B R O U T I N E =======================================


FAT_GOT_DPB     proc near               ; ...

; FUNCTION CHUNK AT A756 SIZE 0000001E BYTES

                push    ss              ; SS is DOSDATA
                pop     ds
                mov     ax, es
                or      ax, bp
                jz      short FATERR_fail
                mov     al, 19
                mov     ah, es:[bp+1]   ; [ES:BP+DPB.UNIT]
                mov     ds:DEVCALL_REQFUNC, 1 ; DEVMDCH
                mov     word ptr ds:DEVCALL_REQLEN, ax
                mov     al, es:[bp+17h] ; [ES:BP+DPB.MEDIA]
                mov     ds:DEVCALL_REQSTAT, 0
                mov     ds:CALLUNIT, al ; [CALLMED]
                push    es
                push    ds
                mov     bx, offset DEVCALL_REQLEN ; offset DEVCALL
                lds     si, es:[bp+13h] ; [ES:BP+DPB.DRIVER_ADDR]
                pop     es
                call    DEVIOCALL2
                push    ss
                pop     ds
                pop     es
                mov     di, ds:DEVCALL_REQSTAT
                or      di, di
                js      short FATERR
                mov     ah, es:[bp+18h] ; [ES:BP+DPB.FIRST_ACCESS]
                mov     al, ds:THISDRV  ; Use physical unit number
                and     ah, 80h         ; izolate (FAT) first access bit
                and     byte ptr es:[bp+18h], 7Fh ; clear first access (FAT) bit 7
                cmp     ds:VOLCHNG_FLAG, al
                jnz     short CHECK_BYT
                mov     ds:VOLCHNG_FLAG, 0FFh
                jmp     GOGETBPB
; ---------------------------------------------------------------------------

CHECK_BYT:                              ; ...
                or      ah, ds:CALLBR   ; [CALLRBYT]
                js      short NEWDSK
                jz      short CHKBUFFDIRT
                clc
                retn                    ; Media not changed (NZ)
; ---------------------------------------------------------------------------

DISK_CHNG_ERR:                          ; ...
                push    es
                push    bp
                les     bp, es:[bp+13h] ; [ES:BP+DPB.DRIVER_ADDR]
                test    byte ptr es:[bp+5], 8 ; [es:bp+SYSDEV.ATT+1],(DEVOPCL>>8)
                pop     bp
                pop     es
                jz      short FAIL_OPJ2
                push    ds
                push    di
                push    ss
                pop     ds
                mov     ds:ALLOWED, 18h ; Allowed_FAIL+Allowed_RETRY
                push    es
                les     di, dword ptr ds:CALLVIDM ; Get volume ID pointer
                mov     word ptr ds:EXTERRPT+2, es
                pop     es
                mov     word ptr ds:EXTERRPT, di
                mov     ax, 0Fh         ; error_I24_wrong_disk
                mov     ds:READOP, 1    ; Write
                call    HARDERR
                pop     di
                pop     ds
                cmp     al, 3

FAIL_OPJ2:                              ; ...
                jz      short FAIL_OP
                jmp     FAT_GOT_DPB     ; Retry
; ---------------------------------------------------------------------------

CHKBUFFDIRT:                            ; ...
                cmp     ss:DirtyBufferCount, 0 ; any dirty buffers ?
                jz      short NEWDSK    ; no, skip the check
                call    GETCURHEAD      ; get pointer to first buffer

nbuffer:                                ; ...
                cmp     [di+4], al      ; [di+BUFFINFO.buf_ID] ; Unit OK ?
                jnz     short lfnxt     ; no
                test    byte ptr [di+5], 40h ; is the buffer dirty ?
                jz      short lfnxt     ; no, go for next buffer
                push    ss
                clc
                pop     ds
                retn
; ---------------------------------------------------------------------------

FAIL_OP:                                ; ...
                push    ss
                stc
                pop     ds
                retn
; ---------------------------------------------------------------------------

jmp_to_DISK_CHNG_ERR:                   ; ...
                jmp     short DISK_CHNG_ERR
; ---------------------------------------------------------------------------

lfnxt:                                  ; ...
                mov     di, [di]        ; [di+BUFFINFO.buf_next] ; get next buffer
                cmp     ss:FIRST_BUFF_ADDR, di ; is this where we started ?
                jnz     short nbuffer   ; no, check this guy also
                                        ; If no dirty buffers, assume Media changed

NEWDSK:                                 ; ...
                mov     word ptr es:[bp+1Fh], 0FFFFh ; [ES:BP+DPB.FREE_CNT],-1
                                        ; Media changed, must recompute
                cmp     word ptr es:[bp+0Fh], 0 ; [ES:BP+DPB.FATSIZE] = 0 for FAT32 fs
                jnz     short newdsk2
                mov     word ptr es:[bp+21h], 0FFFFh ; [ES:BP+DPB.FREE_CNT_HW],-1

newdsk2:                                ; ...
                call    GETCURHEAD

nxbuffer:                               ; ...
                cmp     [di+4], al      ; [DI+BUFFINFO.buf_ID],al ; This drive ?
                jnz     short lfnxt2
                test    byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty
                jnz     short jmp_to_DISK_CHNG_ERR
                mov     word ptr [di+4], 20FFh ; [DI+BUFFINFO.buf_ID],
                                        ; (buf_visit*256)+0FFh ; free up
                call    SCANPLACE
                jmp     short skpbuff
; ---------------------------------------------------------------------------

lfnxt2:                                 ; ...
                mov     di, [di]

skpbuff:                                ; ...
                cmp     di, ss:FIRST_BUFF_ADDR
                jnz     short nxbuffer
                cmp     ss:SC_CACHE_COUNT, 0 ; look ahead buffers ?
                jz      short GOGETBPB  ; no
                cmp     al, ss:CurSC_DRIVE ; same as changed drive ?
                jnz     short GOGETBPB  ; no
                mov     ss:CurSC_DRIVE, 0FFh ; invalidate look ahead buffers

GOGETBPB:                               ; ...
                lds     di, es:[bp+13h] ; [ES:BP+DPB.DRIVER_ADDR]
                test    byte ptr [di+5], 20h ; [DI+SYSDEV.ATT+1],(ISFATBYDEV>>8)
                jnz     short GETFREEBUF
                push    ss
                pop     ds
                mov     word ptr es:[bp+2], 200h ; DPB.SECTORSIZE ; bytes per sector
                mov     word ptr es:[bp+6], 1 ; DPB.FIRST_FAT ; starting sector of FATs
                mov     byte ptr es:[bp+8], 1 ; DPB.FAT_COUNT ; number of FATs
                mov     word ptr es:[bp+0Dh], 3 ; DPB.MAX_CLUSTER ; cluster count + 1
                mov     word ptr es:[bp+0Fh], 1 ; DPB.FAT_SIZE ; FAT sectors (16 bit)
                mov     ds:CLUSTNUM_HW, 0 ; high word of cluster number (for UNPACK)
                mov     bx, 2           ; Read the 1st FAT sector into CURBUF
                call    UNPACK

FAIL_OPJ:                               ; ...
                jnb     short unpack_ok
                jmp     FAIL_OP
; ---------------------------------------------------------------------------

unpack_ok:                              ; ...
                lds     di, ds:CURBUF
                jmp     short GOTGETBUF
; ---------------------------------------------------------------------------

GETFREEBUF:                             ; ...
                xor     dx, dx
                lds     di, ss:LoMemBuff
                sub     di, 24          ; sub di,BUFINSIZ
                cmp     ss:BuffInHMA, dl ; 0
                jnz     short GOTGETBUF ; buffer is in HMA
                                        ; use [LowMemBuff] to transfer at first
                push    es
                push    bp
                mov     ss:HIGH_SECTOR, dx ; 0
                call    GETCURHEAD
                call    BUFWRITE
                pop     bp
                pop     es
                jb      short FAIL_OPJ

GOTGETBUF:                              ; ...
                add     di, 24          ; add di,BUFINSIZ
                mov     ss:CALLXAD_2, ds ; [SS:CALLXAD+2]
                mov     ax, ss
                mov     ds, ax
                mov     word ptr ds:CALLBR, di ; [CALLXAD]
                mov     al, 16h         ; DBPBHL
                mov     ah, es:[bp+1]   ; [ES:BP+DPB.UNIT]
                mov     ds:DEVCALL_REQFUNC, 2 ; DEVBPB
                mov     word ptr ds:DEVCALL_REQLEN, ax
                mov     ds:DEVCALL_REQSTAT, 0
                mov     al, es:[bp+17h] ; [ES:BP+DPB.MEDIA]
                push    es
                push    ds
                mov     ds:CALLUNIT, al ; [CALLMED]
                mov     bx, offset DEVCALL_REQLEN ; offset DEVCALL
                lds     si, es:[bp+13h] ; [ES:BP+DPB.DRIVER_ADDR]
                                        ; DS:SI Points to device header
                pop     es              ; ES:BX Points to call header
                call    DEVIOCALL2
                pop     es
                mov     di, ss
                mov     ds, di
                mov     di, ds:DEVCALL_REQSTAT
                or      di, di
                jns     short gotgetbuf2 ;
                                        ; have error
                lds     di, dword ptr ds:CALLBR ; [CALLXAD] ; Buffer (data) address
                mov     word ptr [di-20], 0FFh ; byte BUFFINFO.buf_ID = 0FFh ; FREE
                                        ; byte BUFFINFO.buf_flags = 0
                jmp     FATERR
; ---------------------------------------------------------------------------

gotgetbuf2:                             ; ...
                lds     si, dword ptr ds:CALLBPB ; Address of the BPB (DEVCALL offset 18)
                xor     cx, cx          ; 0
                mov     es:[bp+1Dh], cx ; [ES:BP+DPB.NEXT_FREE] = 0
                                        ; recycle scanning pointer
                mov     dx, 4152h       ; 'RA' ; FAT32 extended BPB/DPB signature
                cmp     [si+0Bh], cx    ; BPB.fatsecs ; 16 bit FAT size = 0 for FAT32 fs
                jnz     short gotgetbuf3 ; not FAT32
                mov     es:[bp+39h], cx ; clear reserved bytes (DPB.RESERVED)
                mov     es:[bp+3Bh], cx
                dec     cx              ; -1
                mov     es:[bp+1Fh], cx ; (DPB.FREE_CNT) set free count to -1 (unknown)
                mov     es:[bp+21h], cx
                mov     cx, 4558h       ; 'XE' ; FAT32 extended BPB/DPB signature

gotgetbuf3:                             ; ...
                call    $SETDPB
                lds     di, dword ptr ss:CALLBR ; [SS:CALLXAD] ; Get back buffer pointer
                mov     dx, es:[bp+25h] ; [es:bp+DPB.FSINFO_SECTOR]
                xor     cx, cx          ; 0
                cmp     es:[bp+0Fh], cx ; [es:bp+DPB.FAT_SIZE] ; 16 bit FAT size field
                jz      short gotgetbuf4 ; FAT32 fs
                jmp     gotgetbuf12     ; FAT fs
; ---------------------------------------------------------------------------

gotgetbuf4:                             ; ...
                cmp     dx, 0FFFFh      ; invalid ?
                jnz     short gotgetbuf5 ; no
                jmp     gotgetbuf12     ; skip reading FSINFO sector
; ---------------------------------------------------------------------------

gotgetbuf5:                             ; ...
                mov     ss:HIGH_SECTOR, cx ; 0
                mov     bx, di
                cmp     ss:BuffInHMA, 0
                jz      short gotgetbuf6 ; buffer is in conventional (<=640KB) memory
                lds     bx, ss:LoMemBuff ; use a buffer in conventional memory
                mov     di, bx

gotgetbuf6:                             ; ...
                mov     ss:ALLOWED, 18h ; Allowed_FAIL+Allowed_RETRY
                inc     cx
                push    di
                push    bx
                call    DREAD
                pop     bx
                pop     di
                jb      short gotgetbuf11 ;
                                        ; ds:di = (FSINFO sector) buffer
                                        ; FSI_HeadSig = 41615252h
                cmp     word ptr [di], 5252h ; 'RR' ; check if it is a valid FSINFO sector
                jnz     short gotgetbuf11 ; not valid
                cmp     word ptr [di+2], 4161h ; 'aA' ; (NASM syntax)
                jnz     short gotgetbuf11
                cmp     word ptr [di+484], 7272h ; 'rr' ; FSI_StrucSig = 61417272h
                jnz     short gotgetbuf11
                cmp     word ptr [di+486], 6141h ; 'Aa'
                jnz     short gotgetbuf11 ; not valid
                push    dx              ; valid
                push    bx
                push    cx
                mov     bx, es:[bp+2Fh] ; [es:bp+DPB.LASTCLUSTER+2]
                mov     cx, es:[bp+2Dh] ; [es:bp+DPB.LASTCLUSTER]
                mov     ax, [di+488]    ; FSI_FreeCount ; bx:cx = number of clusters + 1
                mov     dx, [di+490]    ; FSI_FreeCount+2
                cmp     dx, bx          ; is Free Count >= (Number of Clusters + 1) ?
                jnz     short gotgetbuf7 ; if yes, it is invalid value (must be 0FFFFFFFFh)
                cmp     ax, cx

gotgetbuf7:                             ; ...
                jnb     short gotgetbuf8 ; yes, invalid value (must be 0FFFFFFFFh)
                mov     es:[bp+1Fh], ax ; no, valid free count
                                        ; save free count into [es:bp+DPB.FREE_CNT]
                mov     es:[bp+21h], dx ; [es:bp+DPB.FREE_CNT+2]

gotgetbuf8:                             ; ...
                mov     ax, [di+492]    ; FSI_Nxt_Free
                mov     dx, [di+494]
                cmp     dx, bx          ; is the next free clust num >= (num of clusters + 1) ?
                jnz     short gotgetbuf9 ; invalid (if dx > bx)
                cmp     ax, cx

gotgetbuf9:                             ; ...
                jnb     short gotgetbuf10 ; invalid
                mov     es:[bp+39h], ax ; save next free (search) cluster number
                mov     es:[bp+3Bh], dx ; into [es:bp+DPB.FAT32_NXTFREE]
                mov     es:[bp+1Dh], ax ; and into [es:bp+DPB.NEXT_FREE] ; low word

gotgetbuf10:                            ; ...
                pop     cx
                pop     bx
                pop     dx

gotgetbuf11:                            ; ...
                cmp     ss:BuffInHMA, 0 ; is buffer in HMA ?
                jnz     short gotgetbuf12 ; yes
                mov     word ptr [di-20], 0FFh ; invalidate buffer (set it as free buffer)

gotgetbuf12:                            ; ...
                cmp     ss:BuffInHMA, 0
                jnz     short gotgetbuf16
                cmp     word ptr es:[bp+6], 1
                jz      short gotgetbuf13
                mov     word ptr [di-20], 0FFh ; invalidate buffer (set it as free buffer)
                                        ; di = buffer header + 4 (BUFINFO.buf_ID)

gotgetbuf13:                            ; ...
                mov     al, es:[bp+8]   ; [es:bp+DPB.FAT_COUNT]
                mov     [di-14], al     ; BUFFINFO.buf_wrtcnt ; buffer header address + 10
                mov     ax, es:[bp+0Fh] ; [es:bp+DPB.FAT_SIZE] ; 16 bit FAT size field
                or      ax, ax
                jnz     short gotgetbuf14 ; FAT (FAT12 or FAT16) fs
                                        ; FAT32 fs
                mov     ax, es:[bp+31h] ; [es:bp+DPB.FAT32_SIZE] ; FAT sectors (per one FAT)
                mov     [di-13], ax     ; BUFFINFO.buf_wrtcntinc ; # sectors between each write
                mov     ax, es:[bp+33h] ; [es:bp+DPB.FAT32_SIZE+2]
                jmp     short gotgetbuf15
; ---------------------------------------------------------------------------

gotgetbuf14:                            ; ...
                mov     [di-13], ax     ; BUFFINFO.buf_wrtcntinc
                xor     ax, ax          ; 0

gotgetbuf15:                            ; ...
                mov     [di-15], ax     ; BUFFINFO.buf_wrtcntinc+2 ; hw of sectors per FAT

gotgetbuf16:                            ; ...
                mov     ax, ss          ; SS is DOSDATA
                mov     ds, ax
                xor     al, al          ; Media changed (Z), Carry clear
                retn
FAT_GOT_DPB     endp


; =============== S U B R O U T I N E =======================================


GETCURHEAD      proc near               ; ...
                lds     di, ss:BufferQueue ; Pointer to the first buffer
                mov     word ptr ss:LastBuffer, 0FFFFh ; -1 ; invalidate last buffer
                mov     ss:FIRST_BUFF_ADDR, di ; save first buffer address
                retn
GETCURHEAD      endp


; =============== S U B R O U T I N E =======================================


SCANPLACE       proc near               ; ...
                push    word ptr [di]
                call    PLACEBUF
                pop     di
                retn
SCANPLACE       endp


; =============== S U B R O U T I N E =======================================


PLACEBUF        proc near               ; ...
                push    ax
                push    bx
                mov     ax, [di]
                mov     bx, ss:6Dh
                cmp     ax, bx
                jz      short loc_AA93
                cmp     di, bx
                jnz     short loc_AA7B
                mov     ss:6Dh, ax
                jmp     short loc_AA93
; ---------------------------------------------------------------------------

loc_AA7B:                               ; ...
                push    si
                mov     si, [di+2]
                mov     [si], ax
                xchg    ax, si
                mov     [si+2], ax
                mov     si, [bx+2]
                mov     [bx+2], di
                mov     [si], di
                mov     [di+2], si
                mov     [di], bx
                pop     si

loc_AA93:                               ; ...
                pop     bx
                pop     ax
                cmp     byte ptr [di+4], 0FFh
                jnz     short locret_AAA0
                mov     ss:6Dh, di

locret_AAA0:                            ; ...
                retn
PLACEBUF        endp

; ---------------------------------------------------------------------------

POINTCOMP:                              ; ...
                cmp     si, di
                jnz     short _ret_label
                push    cx
                push    dx
                mov     cx, ds
                mov     dx, es
                cmp     cx, dx
                pop     dx
                pop     cx

_ret_label:                             ; ...
                retn
; ---------------------------------------------------------------------------

GETBUFFR:                               ; ...
                xor     si, si

GETBUFFRB:                              ; ...
                mov     ds:PREREAD, ax
                or      si, si
                jz      short loc_AAE2
                cmp     word ptr es:[bp+0Fh], 0
                jnz     short loc_AAE2
                mov     ax, es:[bp+23h]
                test    al, 80h
                jz      short loc_AAE2
                and     ax, 0Fh
                jz      short loc_AAE2
                push    dx
                mov     cx, ax
                mul     word ptr es:[bp+33h]
                xchg    ax, cx
                mul     word ptr es:[bp+31h]
                add     cx, dx
                pop     dx
                add     dx, ax
                adc     ds:HIGH_SECTOR, cx

loc_AAE2:                               ; ...
                mov     al, es:[bp+0]
                mov     bx, 0FFFFh
                lds     di, ds:1Eh
                mov     cx, ss:HIGH_SECTOR
                cmp     di, 0FFFFh
                jz      short loc_AB09
                cmp     dx, [di+6]
                jnz     short loc_AB09
                cmp     cx, [di+8]
                jnz     short loc_AB09
                cmp     al, [di+4]
                jnz     short loc_AB09
                jmp     loc_AC1B
; ---------------------------------------------------------------------------

loc_AB09:                               ; ...
                lds     di, ss:BufferQueue
                mov     word ptr ss:LastBuffer, 0FFFFh
                mov     ss:FIRST_BUFF_ADDR, di

loc_AB1A:                               ; ...
                cmp     dx, [di+6]
                jnz     short loc_AB2C
                cmp     cx, [di+8]
                jnz     short loc_AB2C
                cmp     al, [di+4]
                jnz     short loc_AB2C
                jmp     loc_ABD0
; ---------------------------------------------------------------------------

loc_AB2C:                               ; ...
                cmp     byte ptr [di+4], 0FFh
                jnz     short loc_AB34
                mov     bx, di

loc_AB34:                               ; ...
                mov     di, [di]
                cmp     di, ss:FIRST_BUFF_ADDR
                jnz     short loc_AB1A
                cmp     bx, 0FFFFh
                jz      short loc_AB46
                mov     di, bx
                jmp     short loc_AB59
; ---------------------------------------------------------------------------

loc_AB46:                               ; ...
                push    cx
                push    si
                push    dx
                push    bp
                push    es
                call    BUFWRITE
                pop     es
                pop     bp
                pop     dx
                pop     si
                pop     ss:HIGH_SECTOR
                jb      short loc_ABB6

loc_AB59:                               ; ...
                xor     ah, ah
                cmp     byte ptr ss:PREREAD, ah
                jnz     short loc_ABB8
                lea     bx, [di+18h]
                mov     cx, 1
                push    si
                push    di
                push    dx
                push    es
                cmp     ss:BuffInHMA, 0
                jz      short loc_AB7B
                push    ds
                push    bx
                lds     bx, ss:LoMemBuff

loc_AB7B:                               ; ...
                or      si, si
                jz      short loc_AB86
                call    sub_7FAA
                mov     ah, 2
                jmp     short loc_AB8B
; ---------------------------------------------------------------------------

loc_AB86:                               ; ...
                call    DREAD
                mov     ah, 0

loc_AB8B:                               ; ...
                mov     ch, 0
                mov     cl, ss:BuffInHMA
                jcxz    short loc_ABB2
                mov     cx, es:[bp+2]
                mov     si, bx
                pop     di
                pop     es
                pushf
                shr     cx, 1
                cld
                cmp     ss:DDMOVE, 0
                jz      short near ptr loc_ABAA+1
                shr     cx, 1

loc_ABAA:                               ; ...
                rep movsd
                mov     dx, es
                mov     ds, dx
                popf

loc_ABB2:                               ; ...
                pop     es
                pop     dx
                pop     di
                pop     si

loc_ABB6:                               ; ...
                jb      short loc_AC26

loc_ABB8:                               ; ...
                mov     cx, ss:HIGH_SECTOR
                mov     al, es:[bp+0]
                mov     [di+6], dx
                mov     [di+0Fh], bp
                mov     word ptr [di+11h], es
                mov     [di+8], cx
                mov     [di+4], ax

loc_ABD0:                               ; ...
                mov     byte ptr [di+0Ah], 1
                xor     ax, ax
                mov     [di+0Dh], ax
                or      si, si
                jz      short loc_AC0B
                cmp     word ptr es:[bp+0Fh], 0
                jnz     short loc_AC00
                test    word ptr es:[bp+23h], 80h
                jnz     short loc_ABF3
                mov     al, es:[bp+8]
                mov     [di+0Ah], al

loc_ABF3:                               ; ...
                mov     ax, es:[bp+33h]
                mov     [di+0Dh], ax
                mov     ax, es:[bp+31h]
                jmp     short loc_AC0B
; ---------------------------------------------------------------------------

loc_AC00:                               ; ...
                mov     al, es:[bp+8]
                mov     [di+0Ah], al
                mov     ax, es:[bp+0Fh]

loc_AC0B:                               ; ...
                mov     [di+0Bh], ax
                call    PLACEBUF
                mov     word ptr ss:LastBuffer+2, ds
                mov     word ptr ss:LastBuffer, di

loc_AC1B:                               ; ...
                mov     word ptr ss:CURBUF+2, ds
                mov     word ptr ss:CURBUF, di
                clc

loc_AC26:                               ; ...
                mov     ax, ss
                mov     ds, ax

flushbuf_retn:                          ; ...
                retn

; =============== S U B R O U T I N E =======================================


FLUSHBUF        proc near               ; ...
                cmp     al, 0FFh        ; -1
                jnz     short flshbuf_2
                mov     bx, 26

flshbuf_1:                              ; ...
                and     ss:drv_flags_1[bx], 0F7h ; [ss:bx+drv_flags-1],0F7h
                                        ; clear bit 3
                dec     bx              ; backward
                jnz     short flshbuf_1

flshbuf_2:                              ; ...
                call    GETCURHEAD
                test    byte ptr ss:DOS34_FLAG, 4 ; FROM_DISK_RESET
                jnz     short scan_buf_queue
                cmp     ss:DirtyBufferCount, 0
                jz      short end_scan

scan_buf_queue:                         ; ...
                call    CHECKFLUSH
                mov     ah, [di+4]      ; [DI+BUFFINFO.buf_ID]
                cmp     ss:WPERR, ah
                jz      short free_the_buf
                test    byte ptr ss:DOS34_FLAG, 4 ; FROM_DISK_RESET
                jz      short flshbuf_3

free_the_buf:                           ; ...
                mov     word ptr [di+4], 0FFh

flshbuf_3:                              ; ...
                mov     di, [di]        ; [DI+BUFFINFO.buf_next]
                cmp     di, ss:FIRST_BUFF_ADDR
                jnz     short scan_buf_queue

end_scan:                               ; ...
                push    ss
                pop     ds
                cmp     ds:FAILERR, 0
                jz      short flushbuf_retn
                stc

flushbuf_retn:                          ; ...
                retn
FLUSHBUF        endp


; =============== S U B R O U T I N E =======================================


CHECKFLUSH      proc near               ; ...
                mov     ah, 0FFh        ; -1
                cmp     [di+4], ah      ; [DI+BUFFINFO.buf_ID]
                jz      short flushbuf_retn ; Skip free buffer, carry clear
                cmp     ah, al
                jz      short DOBUFFER  ; do this buffer
                cmp     al, [di+4]      ; [DI+BUFFINFO.buf_ID]
                clc
                jnz     short flushbuf_retn ; Buffer not for this unit or SFT
                xor     bx, bx
                mov     bl, al
                test    ss:drive_flags[bx], 8 ; bit 3
                jnz     short flushbuf_retn

DOBUFFER:                               ; ...
                test    byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty
                jz      short flushbuf_retn
                push    ax
                push    word ptr [di+4] ; [DI+BUFFINFO.buf_ID]
                call    BUFWRITE
                pop     ax
                jb      short LEAVE_BUF ; Leave buffer marked free (lost)
                and     ah, 0BFh        ; ~buf_dirty  ; Buffer is clean, clears carry
                mov     [di+4], ax      ; [DI+BUFFINFO.buf_ID]

LEAVE_BUF:                              ; ...
                pop     ax

checkflush_retn:                        ; ...
                retn
CHECKFLUSH      endp


; =============== S U B R O U T I N E =======================================


BUFWRITE        proc near               ; ...
                mov     ax, 0FFh
                xchg    ax, [di+4]
                cmp     al, 0FFh
                jz      short checkflush_retn
                test    ah, 40h
                jz      short checkflush_retn
                call    DEC_DIRTY_COUNT
                cmp     al, ss:322h
                jz      short checkflush_retn
                les     dx, [di+6]
                lea     bx, [di+18h]
                mov     cl, [di+0Ah]
                mov     ch, 0
                mov     word ptr ss:607h, es
                les     bp, [di+0Fh]
                mov     byte ptr ss:34Bh, 18h
                test    ah, 8
                jz      short loc_ACEE
                or      byte ptr ss:34Bh, 20h

loc_ACEE:                               ; ...
                mov     si, [di+0Dh]
                mov     ax, [di+0Bh]
                push    di
                xor     di, di
                push    ds
                push    bx

loc_ACF9:                               ; ...
                push    si
                push    word ptr ss:607h
                push    di
                push    cx
                push    ax
                mov     cx, 1
                push    bx
                push    dx
                push    ds
                cmp     byte ptr ss:79h, 0
                jz      short loc_AD33
                push    cx
                push    es
                mov     si, bx
                mov     cx, es:[bp+2]
                les     di, ss:7Ah
                shr     cx, 1
                mov     bx, di
                cld
                cmp     byte ptr ss:6Ah, 0
                jz      short near ptr loc_AD2C+1
                shr     cx, 1

loc_AD2C:                               ; ...
                rep movsd
                push    es
                pop     ds
                pop     es
                pop     cx

loc_AD33:                               ; ...
                call    DWRITE
                pop     ds
                pop     dx
                pop     bx
                pop     ax
                pop     cx
                pop     di
                pop     word ptr ss:607h
                pop     si
                jb      short loc_AD47
                mov     di, 1

loc_AD47:                               ; ...
                add     dx, ax
                adc     ss:607h, si
                loop    loc_ACF9
                pop     bx
                pop     ds
                sub     di, 1
                pop     di
                retn
BUFWRITE        endp

; ---------------------------------------------------------------------------

null_sub:                               ; ...
                retn
; ---------------------------------------------------------------------------

SET_BUF_DIRTY:                          ; ...
                test    byte ptr es:[di+5], 40h ; [ES:DI+BUFFINFO.buf_flags],buf_dirty
                jnz     short yesdirty2
                or      byte ptr es:[di+5], 40h ; [ES:DI+BUFFINFO.buf_flags],buf_dirty

; =============== S U B R O U T I N E =======================================


INC_DIRTY_COUNT proc near               ; ...
                inc     ss:DirtyBufferCount

yesdirty2:                              ; ...
                retn
INC_DIRTY_COUNT endp


; =============== S U B R O U T I N E =======================================


DEC_DIRTY_COUNT proc near               ; ...
                cmp     ss:DirtyBufferCount, 0
                jz      short ddcx
                dec     ss:DirtyBufferCount

ddcx:                                   ; ...
                retn
DEC_DIRTY_COUNT endp

; ---------------------------------------------------------------------------

$WAIT:                                  ; ...
                xor     ax, ax
                xchg    ax, ss:exit_code
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

$EXEC:                                  ; ...
                mov     ss:A20OFF_COUNT, 0
                cmp     al, 5
                jnz     short Exec_@f
                pop     cx
                mov     cx, offset LeaveDOS
                push    cx

Exec_@f:                                ; ...
                push    bp
                mov     bp, sp
                sub     sp, 29
                cmp     al, 5
                jbe     short Exec_Check_2

Exec_Bad_Fun:                           ; ...
                call    set_exerr_locus_unk
                mov     al, 1

loc_ADA0:                               ; ...
                mov     sp, bp
                pop     bp
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

loc_ADA6:                               ; ...
                call    sub_C697
                jmp     loc_B1C6
; ---------------------------------------------------------------------------

Exec_Check_2:                           ; ...
                cmp     al, 2
                jz      short Exec_Bad_Fun
                cmp     al, 4
                jz      short Exec_Bad_Fun
                cmp     al, 5
                jz      short loc_ADA6
                mov     [bp-4], bx
                mov     word ptr [bp-2], es
                mov     [bp-5], al
                mov     byte ptr [bp-6], 0
                mov     [bp-1Ah], dx
                mov     word ptr [bp-18h], ds
                mov     si, dx
                call    DStrLen
                mov     [bp-16h], cx
                mov     al, ss:302h
                mov     ss:84h, al
                mov     al, 0A0h
                push    bp
                or      byte ptr ss:86h, 1
                push    ds
                push    dx
                call    $OPEN
                pop     dx
                pop     ds
                jnb     short loc_ADF2
                xor     al, al
                call    $OPEN

loc_ADF2:                               ; ...
                pushf
                and     byte ptr ss:86h, 0FEh
                popf
                pop     bp
                jb      short loc_ADA0
                mov     [bp-8], ax
                mov     bx, ax
                xor     al, al
                call    $IOCTL
                jb      short loc_AE10
                test    dl, 80h
                jz      short loc_AE18
                mov     al, 2

loc_AE10:                               ; ...
                jmp     loc_AEDC
; ---------------------------------------------------------------------------

loc_AE13:                               ; ...
                mov     al, 0Ah
                jmp     loc_AEDC
; ---------------------------------------------------------------------------

loc_AE18:                               ; ...
                mov     word ptr [bp-12h], 0
                mov     word ptr [bp-0Eh], 0
                test    byte ptr [bp-5], 2
                jnz     short loc_AE7B
                lds     si, [bp-4]
                mov     ax, [si]
                or      ax, ax
                jnz     short loc_AE3D
                mov     ds, word ptr ss:330h
                mov     ax, ds:2Ch
                or      ax, ax
                jz      short loc_AE7B

loc_AE3D:                               ; ...
                mov     es, ax
                xor     di, di
                mov     cx, 8000h
                xor     al, al

loc_AE46:                               ; ...
                repne scasb
                jnz     short loc_AE13
                dec     cx
                js      short loc_AE13
                scasb
                jnz     short loc_AE46
                push    di
                lea     bx, [di+11h]
                add     bx, [bp-16h]
                mov     cl, 4
                shr     bx, cl
                push    es
                call    $ALLOC
                pop     ds
                pop     cx
                jnb     short loc_AE65
                jmp     short loc_AED6
; ---------------------------------------------------------------------------

loc_AE65:                               ; ...
                mov     es, ax
                mov     [bp-0Eh], ax
                xor     si, si
                mov     di, si
                rep movsb
                xchg    ax, cx
                inc     ax
                stosw
                lds     si, [bp-1Ah]
                mov     cx, [bp-16h]
                rep movsb

loc_AE7B:                               ; ...
                push    ss
                pop     ds
                mov     cx, 1Ah
                mov     dx, 0EC7h
                push    es
                push    ds
                call    ExecRead
                pop     ds
                pop     es
                jb      short loc_AEDA
                or      ax, ax
                jz      short loc_AEDA
                cmp     ax, 1Ah
                jnz     short loc_AEAE
                test    word ptr ds:0ED3h, 0FFFFh
                jnz     short loc_AEA1
                mov     byte ptr [bp-6], 0FFh

loc_AEA1:                               ; ...
                mov     ax, ds:0EC7h
                cmp     ax, 5A4Dh
                jz      short loc_AEB1
                cmp     ax, 4D5Ah
                jz      short loc_AEB1

loc_AEAE:                               ; ...
                jmp     loc_B0A4
; ---------------------------------------------------------------------------

loc_AEB1:                               ; ...
                mov     ax, ds:0ECBh
                mov     cl, 5
                shl     ax, cl
                sub     ax, ds:0ECFh
                mov     [bp-0Ch], ax
                test    byte ptr [bp-5], 2
                jz      short loc_AF0C
                les     di, [bp-4]
                push    es
                les     ax, es:[di]
                mov     [bp-14h], ax
                mov     word ptr [bp-0Ah], es
                pop     es
                jmp     loc_AFB8
; ---------------------------------------------------------------------------

loc_AED6:                               ; ...
                mov     al, 8
                jmp     short loc_AEDC
; ---------------------------------------------------------------------------

loc_AEDA:                               ; ...
                mov     al, 0Bh

loc_AEDC:                               ; ...
                mov     bx, [bp-8]
                call    Exec_Dealloc
                call    LCritDisk
                push    ax
                push    bp
                call    $CLOSE
                pop     bp
                pop     ax
                jmp     loc_ADA0
; ---------------------------------------------------------------------------

loc_AEEF:                               ; ...
                mov     al, ss:302h
                mov     bl, ss:84h
                mov     ss:302h, bl
                test    bl, 40h
                jnz     short loc_AED6
                test    al, 40h
                jz      short loc_AED6
                mov     ax, ss:8Ah
                jmp     short loc_AF34
; ---------------------------------------------------------------------------

loc_AF0C:                               ; ...
                xor     bx, bx
                mov     [bp-1Dh], bl
                cmp     ds:0ED5h, bx
                jnz     short loc_AF28
                cmp     ds:0ED7h, bx
                jnz     short loc_AF28
                inc     byte ptr [bp-1Dh]
                cmp     ax, 0FF0h
                jnb     short loc_AF28
                add     ax, 10h

loc_AF28:                               ; ...
                test    byte ptr ds:302h, 80h
                jz      short loc_AF34
                or      byte ptr ds:302h, 40h

loc_AF34:                               ; ...
                mov     ds:8Ah, ax
                mov     bx, 0FFFFh
                push    ds
                call    $ALLOC
                pop     ds
                mov     ax, ds:8Ah
                add     ax, 10h
                cmp     bx, 11h
                jb      short loc_AEEF
                cmp     ax, bx
                ja      short loc_AEEF
                test    byte ptr [bp-6], 0FFh
                jnz     short loc_AF6C
                add     ax, ds:0ED1h
                jb      short loc_AEEF
                cmp     ax, bx
                ja      short loc_AEEF
                sub     ax, ds:0ED1h
                add     ax, ds:0ED3h
                jb      short loc_AF6C
                cmp     ax, bx
                jbe     short loc_AF6E

loc_AF6C:                               ; ...
                mov     ax, bx

loc_AF6E:                               ; ...
                push    ds
                mov     bx, ax
                mov     [bp-10h], bx
                call    $ALLOC
                pop     ds
                jnb     short loc_AF7D
                jmp     loc_AEEF
; ---------------------------------------------------------------------------

loc_AF7D:                               ; ...
                mov     cl, ds:84h
                mov     ds:302h, cl
                cmp     byte ptr [bp-1Dh], 0
                jz      short loc_AF9D
                cmp     bx, 1000h
                jnb     short loc_AF9D
                mov     cl, 4
                shl     bx, cl
                sub     bx, 100h
                mov     ds:0ED7h, bx

loc_AF9D:                               ; ...
                mov     [bp-12h], ax
                add     ax, 10h
                test    byte ptr [bp-6], 0FFh
                jz      short loc_AFB2
                add     ax, [bp-10h]
                sub     ax, [bp-0Ch]
                sub     ax, 10h

loc_AFB2:                               ; ...
                mov     [bp-0Ah], ax
                mov     [bp-14h], ax

loc_AFB8:                               ; ...
                mov     dx, [bp-14h]
                mov     [bp-1Ch], dx
                mov     dx, ds:0ECFh
                push    dx
                mov     cl, 4
                shl     dx, cl
                pop     ax
                mov     cl, 0Ch
                shr     ax, cl
                mov     cx, ax
                mov     bx, [bp-8]
                push    ds
                xor     al, al
                call    $LSEEK
                pop     ds
                jnb     short loc_AFDD
                jmp     loc_AEDC
; ---------------------------------------------------------------------------

loc_AFDD:                               ; ...
                mov     bx, [bp-0Ch]
                cmp     bx, 1000h
                jb      short loc_AFE9
                mov     bx, 0FE0h

loc_AFE9:                               ; ...
                sub     [bp-0Ch], bx
                push    bx
                mov     cl, 4
                shl     bx, cl
                mov     cx, bx
                push    ds
                mov     ds, word ptr [bp-14h]
                xor     dx, dx
                push    cx
                call    ExecRead
                pop     cx
                pop     ds
                jb      short loc_B049
                cmp     cx, ax
                pop     bx
                jz      short loc_B00E
                sub     cx, ax
                cmp     cx, 200h
                jnb     short loc_B049

loc_B00E:                               ; ...
                add     [bp-14h], bx
                test    word ptr [bp-0Ch], 0FFFFh
                jnz     short loc_AFDD
                mov     cx, [bp-0Ah]
                mov     ax, ds:0ED5h
                add     ax, cx
                mov     ds:0EC1h, ax
                mov     ax, ds:0ED7h
                mov     ds:0EBFh, ax
                les     ax, ds:0EDBh
                mov     ds:0EC3h, ax
                mov     ax, es
                add     ax, cx
                mov     ds:0EC5h, ax
                xor     cx, cx
                mov     dx, ds:0EDFh
                mov     bx, [bp-8]
                push    ds
                xor     ax, ax
                call    $LSEEK
                pop     ds
                jnb     short loc_B04C

loc_B049:                               ; ...
                jmp     loc_AEDA
; ---------------------------------------------------------------------------

loc_B04C:                               ; ...
                mov     dx, ds:0ECDh

loc_B050:                               ; ...
                push    dx
                mov     dx, 3BEh
                mov     cx, 18Ch
                push    ds
                call    ExecRead
                pop     es
                pop     dx
                jb      short loc_B049
                mov     cx, 63h ; 'c'
                mov     di, 3BEh
                mov     si, [bp-0Ah]

loc_B068:                               ; ...
                or      dx, dx
                jz      short loc_B082
                lds     bx, es:[di]
                mov     ax, ds
                add     ax, [bp-1Ch]
                mov     ds, ax
                add     [bx], si
                add     di, 4
                dec     dx
                loop    loc_B068
                push    es
                pop     ds
                jmp     short loc_B050
; ---------------------------------------------------------------------------

loc_B082:                               ; ...
                push    es
                push    ax
                push    cx
                mov     es, word ptr [bp-1Ch]
                mov     ax, ss:0EC5h
                mov     cx, ss:0EC3h
                call    word ptr ss:0D67h
                call    word ptr ss:133Eh
                pop     cx
                pop     ax
                pop     es
                jmp     loc_B17E
; ---------------------------------------------------------------------------

loc_B0A1:                               ; ...
                jmp     loc_AED6
; ---------------------------------------------------------------------------

loc_B0A4:                               ; ...
                test    byte ptr [bp-5], 2
                jz      short loc_B0D7
                lds     si, [bp-4]
                lodsw
                mov     [bp-14h], ax
                mov     ax, 0FFFFh
                jmp     short loc_B119
; ---------------------------------------------------------------------------

loc_B0B6:                               ; ...
                mov     al, ss:302h
                mov     bl, ss:84h
                mov     ss:302h, bl
                test    bl, 40h
                jnz     short loc_B0A1
                test    al, 40h
                jz      short loc_B0A1
                mov     ax, [bp-12h]
                xor     bx, bx
                call    sub_B34B
                jmp     short loc_B0E5
; ---------------------------------------------------------------------------

loc_B0D7:                               ; ...
                test    byte ptr ss:302h, 80h
                jz      short loc_B0E5
                or      byte ptr ss:302h, 40h

loc_B0E5:                               ; ...
                mov     bx, 0FFFFh
                call    $ALLOC
                or      bx, bx
                jz      short loc_B0B6
                mov     [bp-10h], bx
                push    bx
                call    $ALLOC
                pop     bx
                mov     [bp-12h], ax
                add     ax, 10h
                mov     [bp-14h], ax
                xor     ax, ax
                cmp     bx, 1000h
                jnb     short loc_B116
                mov     ax, bx
                mov     cl, 4
                shl     ax, cl
                cmp     ax, 200h
                jbe     short loc_B0B6
                sub     ax, 100h

loc_B116:                               ; ...
                sub     ax, 100h

loc_B119:                               ; ...
                push    ax
                mov     bx, [bp-8]
                xor     cx, cx
                xor     ax, ax
                cwd
                call    $LSEEK
                pop     cx
                mov     ds, word ptr [bp-14h]
                xor     dx, dx
                push    cx
                call    ExecRead
                pop     si
                jnb     short loc_B135
                jmp     loc_AEDA
; ---------------------------------------------------------------------------

loc_B135:                               ; ...
                cmp     ax, si
                jnz     short loc_B13C
                jmp     loc_B0B6
; ---------------------------------------------------------------------------

loc_B13C:                               ; ...
                mov     bl, ss:84h
                mov     ss:302h, bl
                test    byte ptr [bp-5], 2
                jnz     short loc_B17E
                mov     ax, [bp-14h]
                sub     ax, 10h
                mov     ss:0EC5h, ax
                mov     word ptr ss:0EC3h, 100h
                add     si, 0FEh
                cmp     si, 0FFFEh
                jz      short loc_B16A
                add     si, 100h

loc_B16A:                               ; ...
                mov     ss:0EBFh, si
                mov     ss:0EC1h, ax
                mov     ds, ax
                mov     word ptr [si], 0
                call    word ptr ss:61h

loc_B17E:                               ; ...
                mov     bx, [bp-8]
                call    Exec_Dealloc
                push    bp
                call    $CLOSE
                pop     bp
                call    Exec_Alloc
                test    byte ptr [bp-5], 2
                jz      short loc_B1CC
                call    sub_B359
                call    sub_B370
                cmp     byte ptr ss:1322h, 0
                jz      short loc_B1C6
                push    si
                push    es
                les     si, ss:1323h
                cmp     byte ptr es:[si], 0
                jz      short loc_B1BE
                mov     es, word ptr ss:330h
                push    word ptr ss:0EBBh
                pop     word ptr es:40h
                jmp     short loc_B1C4
; ---------------------------------------------------------------------------

loc_B1BE:                               ; ...
                mov     byte ptr ss:1322h, 0

loc_B1C4:                               ; ...
                pop     es
                pop     si

loc_B1C6:                               ; ...
                mov     sp, bp
                pop     bp
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

loc_B1CC:                               ; ...
                mov     dx, [bp-12h]
                mov     si, 1
                mov     ax, [bp-0Eh]
                or      ax, ax
                jz      short loc_B1DE
                dec     ax
                mov     ds, ax
                mov     [si], dx

loc_B1DE:                               ; ...
                mov     ax, [bp-12h]
                dec     ax
                mov     ds, ax
                mov     [si], dx
                push    ds
                pop     es
                mov     di, 8
                call    sub_B359
                push    cx
                push    si

loc_B1F0:                               ; ...
                lodsb
                cmp     al, 2Eh ; '.'
                jz      short loc_B1FD
                stosb
                cmp     di, 10h
                jnb     short loc_B1FD
                loop    loc_B1F0

loc_B1FD:                               ; ...
                xor     al, al
                cmp     di, 10h
                jnb     short loc_B205
                stosb

loc_B205:                               ; ...
                pop     si
                pop     cx
                call    sub_B370
                push    dx
                mov     si, [bp-10h]
                add     si, dx
                call    $DUP_PDB
                pop     dx
                push    word ptr [bp-0Eh]
                pop     word ptr es:2Ch
                push    ss:SPECIAL_VERSION
                pop     word ptr es:40h
                lds     si, [bp-4]
                push    ds
                push    si
                lds     si, [si+6]
                mov     cx, 0Ch
                push    cx
                mov     di, 5Ch ; '\'
                mov     bl, [si]
                rep movsb
                xchg    ax, cx
                stosw
                stosw
                pop     cx
                pop     si
                pop     ds
                push    ds
                push    si
                lds     si, [si+0Ah]
                mov     bh, [si]
                rep movsb
                stosw
                stosw
                pop     si
                pop     ds
                lds     si, [si+2]
                or      cl, 80h
                mov     di, cx
                rep movsb
                dec     cl
                mov     al, bh
                xor     bh, bh
                call    GetVisDrv
                jnb     short Exec_BL
                mov     bh, cl

Exec_BL:                                ; ...
                mov     al, bl
                xor     bl, bl
                call    GetVisDrv
                jnb     short Exec_Set_Return
                mov     bl, cl

Exec_Set_Return:                        ; ...
                call    Get_User_Stack
                lds     ax, [si+12h]
                push    ds
                push    ax
                mov     es:0Ah, ax
                mov     word ptr es:0Ch, ds
                xor     ax, ax
                mov     ds, ax
                assume ds:DOSCODE
                pop     UNPACK_OFFSET+1
                pop     word_8A
                mov     word ptr ss:DMAADD, 80h
                mov     ds, ss:CurrentPDB
                assume ds:nothing
                mov     word ptr ss:DMAADD+2, ds
                test    byte ptr [bp-5], 1
                jz      short exec_go
                lds     si, ss:exec_init_SP
                les     di, [bp-4]
                mov     word ptr es:[di+10h], ds
                dec     si
                dec     si
                mov     [si], bx
                mov     es:[di+0Eh], si
                lds     ax, ss:exec_init_IP
                mov     word ptr es:[di+14h], ds
                mov     es:[di+12h], ax
                mov     sp, bp
                pop     bp
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

exec_go:                                ; ...
                lds     si, ss:exec_init_IP
                les     di, ss:exec_init_SP
                mov     ax, es
                cmp     ss:DosHasHMA, 0
                jz      short Xfer_To_User
                push    ds
                mov     ds, cs:DosDSeg
                or      ds:DOS_FLAG, 4
                mov     ds:A20OFF_PSP, dx
                mov     ax, ds
                pop     ds
                push    ax
                mov     ax, offset disa20_xfer
                push    ax
                mov     ax, es
                retf
; ---------------------------------------------------------------------------

Xfer_To_User:                           ; ...
                cli
                mov     ss:INDOS, 0
                mov     ss:INDOS_FLAG, 0
                mov     ss, ax
                mov     sp, di
                sti
                push    ds
                push    si
                mov     es, dx
                mov     ds, dx
                mov     ax, bx
                retf

; =============== S U B R O U T I N E =======================================


ExecRead        proc near               ; ...
                call    Exec_Dealloc
                mov     bx, [bp-8]
                push    bp
                call    $READ
                pop     bp
                call    Exec_Alloc
                retn
ExecRead        endp


; =============== S U B R O U T I N E =======================================


Exec_Dealloc    proc near               ; ...
                push    bx
                sub     bx, bx
                call    ECritDisk
                call    sub_B33A
                pop     bx
                retn
Exec_Dealloc    endp


; =============== S U B R O U T I N E =======================================


Exec_Alloc      proc near               ; ...
                push    bx
                mov     bx, ss:330h
                call    sub_B33A
                call    LCritDisk
                pop     bx
                retn
Exec_Alloc      endp


; =============== S U B R O U T I N E =======================================


sub_B33A        proc near               ; ...
                pushf
                push    ax
                mov     ax, [bp-0Eh]
                call    sub_B34B
                mov     ax, [bp-12h]
                call    sub_B34B
                pop     ax
                popf

locret_B34A:                            ; ...
                retn
sub_B33A        endp


; =============== S U B R O U T I N E =======================================


sub_B34B        proc near               ; ...
                or      ax, ax
                jz      short locret_B34A
                dec     ax
                push    ds
                mov     ds, ax
                mov     ds:1, bx
                pop     ds
                retn
sub_B34B        endp


; =============== S U B R O U T I N E =======================================


sub_B359        proc near               ; ...
                lds     si, [bp-1Ah]
sub_B359        endp


; =============== S U B R O U T I N E =======================================


sub_B35C        proc near               ; ...
                mov     cx, si

loc_B35E:                               ; ...
                lodsb
                cmp     al, 3Ah ; ':'
                jz      short sub_B35C
                cmp     al, 5Ch ; '\'
                jz      short sub_B35C
                cmp     al, 0
                jnz     short loc_B35E
                sub     si, cx
                xchg    si, cx
                retn
sub_B35C        endp


; =============== S U B R O U T I N E =======================================


sub_B370        proc near               ; ...
                dec     cx
                mov     word ptr ss:0EBBh, 0A07h
                les     di, ss:5Dh
                mov     ax, es
                or      ax, di
                jz      short locret_B3AA

loc_B383:                               ; ...
                mov     al, es:[di]
                or      al, al
                jz      short locret_B3AA
                mov     ss:60Eh, di
                cmp     al, cl
                jnz     short loc_B3AE
                inc     di
                push    cx
                push    si
                push    ax

loc_B397:                               ; ...
                lodsb
                call    UCase
                scasb
                jnz     short loc_B3AB
                loop    loc_B397
                mov     ax, es:[di]
                mov     ss:0EBBh, ax
                pop     ax
                pop     si
                pop     cx

locret_B3AA:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_B3AB:                               ; ...
                pop     ax
                pop     si
                pop     cx

loc_B3AE:                               ; ...
                mov     di, ss:60Eh
                xor     ah, ah
                add     di, ax
                add     di, 3
                jmp     short loc_B383
sub_B370        endp

; ---------------------------------------------------------------------------

$KEEP_PROCESS:                          ; ...
                push    ax
                mov     byte ptr ss:EXIT_TYPE, 3
                mov     es, ss:CurrentPDB
                cmp     dx, 6
                jnb     short Keep_Shrink
                mov     dx, 6

Keep_Shrink:                            ; ...
                mov     bx, dx
                push    bx
                push    es
                call    $SETBLOCK
                pop     ds
                pop     bx
                jb      short Keep_Done
                mov     ax, ds
                add     ax, bx
                mov     ds:2, ax

Keep_Done:                              ; ...
                pop     ax
                jmp     short exit_inner
; ---------------------------------------------------------------------------

stay_resident:                          ; ...
                mov     ax, 3100h
                add     dx, 0Fh
                rcr     dx, 1
                mov     cl, 3
                shr     dx, cl
                jmp     COMMAND
; ---------------------------------------------------------------------------

$EXIT:                                  ; ...
                xor     ah, ah
                xchg    ah, ss:DidCTRLC
                or      ah, ah
                mov     byte ptr ss:EXIT_TYPE, 0
                jz      short exit_inner
                mov     byte ptr ss:EXIT_TYPE, 1
; START OF FUNCTION CHUNK FOR sub_A242

exit_inner:                             ; ...
                call    Get_User_Stack
                push    ss:CurrentPDB
                pop     word ptr [si+14h]
                jmp     short abort_inner
; END OF FUNCTION CHUNK FOR sub_A242
; ---------------------------------------------------------------------------

$ABORT:                                 ; ...
                xor     al, al
                mov     byte ptr ss:57Ch, 0
; START OF FUNCTION CHUNK FOR sub_A242

abort_inner:                            ; ...
                mov     ah, ss:57Ch
                mov     ss:334h, ax
                call    Get_User_Stack
                mov     ds, word ptr [si+14h]
                xor     ax, ax
                mov     es, ax
                assume es:DOSCODE
                mov     si, 0Ah
                mov     di, 88h
                movsw
                movsw
                movsw
                movsw
                movsw
                movsw
                jmp     loc_A343
; END OF FUNCTION CHUNK FOR sub_A242
; ---------------------------------------------------------------------------

RetExePatch:                            ; ...
                retn

; =============== S U B R O U T I N E =======================================


sub_B443        proc near               ; ...
                test    byte ptr ss:89h, 1
                retn
sub_B443        endp


; =============== S U B R O U T I N E =======================================


sub_B44A        proc near               ; ...
                mov     ax, ss:arena_head

loc_B44E:                               ; ...
                mov     di, 0
                call    check_signature

loc_B454:                               ; ...
                jb      short check_signature_ok
                push    es
                pop     ds
                assume ds:DOSCODE
                cmp     word ptr byte_0+1, bx
                jnz     short loc_B462
                mov     word ptr byte_0+1, di

loc_B462:                               ; ...
                cmp     byte ptr [di], 5Ah ; 'Z'
                jz      short loc_B46C
                call    sub_B47C
                jmp     short loc_B454
; ---------------------------------------------------------------------------

loc_B46C:                               ; ...
                mov     ax, ss:8Ch
                cmp     ax, 0FFFFh
                jz      short check_signature_ok
                mov     di, ds
                cmp     di, ax
                jb      short loc_B44E
                retn
sub_B44A        endp


; =============== S U B R O U T I N E =======================================


sub_B47C        proc near               ; ...
                mov     ax, ds
                add     ax, word ptr byte_0+3
                inc     ax
sub_B47C        endp


; =============== S U B R O U T I N E =======================================


check_signature proc near               ; ...
                mov     es, ax
                assume es:nothing
                cmp     byte ptr es:[di], 4Dh ; 'M'
                jz      short check_signature_ok
                cmp     byte ptr es:[di], 5Ah ; 'Z'
                jz      short check_signature_ok
                stc

check_signature_ok:                     ; ...
                retn
check_signature endp


; =============== S U B R O U T I N E =======================================


sub_B493        proc near               ; ...
                cmp     byte ptr [di], 5Ah ; 'Z'
                jz      short check_signature_ok
                call    sub_B47C
                jb      short check_signature_ok
                cmp     es:1, di
                jnz     short check_signature_ok
                mov     cx, es:3
                inc     cx
                add     word ptr byte_0+3, cx
                mov     cl, es:[di]
                mov     [di], cl
                jmp     short sub_B493
sub_B493        endp


; =============== S U B R O U T I N E =======================================


$ALLOC          proc near               ; ...

; FUNCTION CHUNK AT B52B SIZE 00000024 BYTES
; FUNCTION CHUNK AT B54F SIZE 0000000E BYTES
; FUNCTION CHUNK AT B55D SIZE 00000076 BYTES
; FUNCTION CHUNK AT B5D3 SIZE 0000003A BYTES

                call    ECritDisk
                mov     ax, ss:arena_head
                test    ss:AllocMethod, 0C0h
                mov     ss:START_ARENA, ax
                jz      short loc_B4D5
                call    sub_B443
                jz      short loc_B4D5
                mov     ax, ss:UMB_HEAD
                mov     ss:START_ARENA, ax

loc_B4D5:                               ; ...
                xor     ax, ax
                mov     di, ax
                mov     ss:FirstArena, ax
                mov     ss:BestArena, ax
                mov     ss:LastArena, ax
                push    ax

loc_B4E6:                               ; ...
                mov     ax, ss:START_ARENA
                call    check_signature
                jb      short loc_B522

loc_B4EF:                               ; ...
                push    es
                pop     ds
                assume ds:nothing
                cmp     ds:1, di
                jz      short loc_B55D

loc_B4F7:                               ; ...
                call    sub_B443
                jz      short loc_B518
                test    byte ptr ss:302h, 80h
                jz      short loc_B518
                mov     ax, ss:8Eh
                cmp     ax, ss:24h
                jnz     short loc_B518
                mov     ax, ds
                cmp     ax, ss:8Ch
                jmp     short loc_B51B
; ---------------------------------------------------------------------------

loc_B518:                               ; ...
                cmp     byte ptr [di], 5Ah ; 'Z'

loc_B51B:                               ; ...
                jz      short loc_B52B
                call    sub_B47C
                jnb     short loc_B4EF

loc_B522:                               ; ...
                pop     ax
$ALLOC          endp

; START OF FUNCTION CHUNK FOR $SETBLOCK

loc_B523:                               ; ...
                call    LCritDisk

loc_B526:                               ; ...
                mov     al, 7

loc_B528:                               ; ...
                jmp     SYS_RET_ERR
; END OF FUNCTION CHUNK FOR $SETBLOCK
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR $ALLOC

loc_B52B:                               ; ...
                cmp     word ptr ss:340h, 0
                jz      short loc_B536
                jmp     loc_B5BA
; ---------------------------------------------------------------------------

loc_B536:                               ; ...
                mov     ax, ss:24h
                cmp     ax, ss:8Eh
                jz      short loc_B54F
                test    byte ptr ss:302h, 40h
                jnz     short loc_B54F
                mov     ss:8Eh, ax
                jmp     short loc_B4E6
; END OF FUNCTION CHUNK FOR $ALLOC
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR $SETBLOCK
;   ADDITIONAL PARENT FUNCTION $ALLOC

loc_B54F:                               ; ...
                call    Get_User_Stack
                pop     bx
                mov     [si+2], bx
                call    LCritDisk
                mov     al, 8
                jmp     short loc_B528
; END OF FUNCTION CHUNK FOR $SETBLOCK
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR $ALLOC

loc_B55D:                               ; ...
                call    sub_B493
                jb      short loc_B522
                mov     cx, ds:3
                pop     dx
                cmp     cx, dx
                jbe     short loc_B56D
                mov     dx, cx

loc_B56D:                               ; ...
                push    dx
                cmp     bx, cx
                ja      short loc_B4F7
                cmp     word ptr ss:340h, 0
                jnz     short loc_B57F
                mov     word ptr ss:340h, ds

loc_B57F:                               ; ...
                cmp     word ptr ss:342h, 0
                jz      short loc_B595
                push    es
                mov     es, word ptr ss:342h
                cmp     es:3, cx
                pop     es
                jbe     short loc_B59A

loc_B595:                               ; ...
                mov     word ptr ss:342h, ds

loc_B59A:                               ; ...
                mov     word ptr ss:344h, ds
                jmp     loc_B4F7
; ---------------------------------------------------------------------------

loc_B5A2:                               ; ...
                mov     ds, word ptr ss:344h
                mov     cx, ds:3
                sub     cx, bx
                mov     dx, ds
                jz      short loc_B5FA
                add     dx, cx
                mov     es, dx
                dec     cx
                xchg    bx, cx
                jmp     short loc_B5E5
; ---------------------------------------------------------------------------

loc_B5BA:                               ; ...
                mov     cl, ss:302h
                and     cl, 3Fh
                cmp     cl, 1
                ja      short loc_B5A2
                mov     ds, word ptr ss:340h
                jb      short loc_B5D3
                mov     ds, word ptr ss:342h
; END OF FUNCTION CHUNK FOR $ALLOC
; START OF FUNCTION CHUNK FOR $SETBLOCK
;   ADDITIONAL PARENT FUNCTION $ALLOC

loc_B5D3:                               ; ...
                mov     cx, ds:3
                mov     ax, ds
                sub     cx, bx
                mov     dx, ax
                jz      short loc_B5FA
                add     ax, bx
                inc     ax
                mov     es, ax
                dec     cx

loc_B5E5:                               ; ...
                mov     ds:3, bx
                mov     bl, 4Dh ; 'M'
                mov     es:3, cx
                xchg    bl, [di]
                mov     es:1, di
                mov     es:[di], bl

loc_B5FA:                               ; ...
                mov     ds, dx
                mov     ax, ss:330h
                mov     ds:1, ax
                mov     ax, ds
                inc     ax
                pop     bx
                call    LCritDisk

loc_B60A:                               ; ...
                jmp     SYS_RET_OK
; END OF FUNCTION CHUNK FOR $SETBLOCK

; =============== S U B R O U T I N E =======================================


$SETBLOCK       proc near               ; ...

; FUNCTION CHUNK AT B523 SIZE 00000008 BYTES
; FUNCTION CHUNK AT B54F SIZE 0000000E BYTES
; FUNCTION CHUNK AT B5D3 SIZE 0000003A BYTES

                call    ECritDisk
                mov     di, 0
                mov     ax, es
                dec     ax
                call    check_signature
                jnb     short loc_B61E

loc_B61B:                               ; ...
                jmp     loc_B523
; ---------------------------------------------------------------------------

loc_B61E:                               ; ...
                mov     ds, ax
                call    sub_B493
                jb      short loc_B61B
                mov     cx, ds:3
                push    cx
                cmp     bx, cx
                jbe     short loc_B5D3
                jmp     loc_B54F
$SETBLOCK       endp


; =============== S U B R O U T I N E =======================================


$DEALLOC        proc near               ; ...
                call    ECritDisk
                test    ss:DOS_FLAG, 4
                jz      short loc_B649
                cmp     ss:A20OFF_COUNT, 0
                jnz     short loc_B649
                inc     ss:A20OFF_COUNT

loc_B649:                               ; ...
                mov     di, 0
                mov     ax, es
                dec     ax
                call    check_signature
                jb      short loc_B65E
                mov     es:1, di
                call    LCritDisk

loc_B65C:                               ; ...
                jmp     short loc_B60A
; ---------------------------------------------------------------------------

loc_B65E:                               ; ...
                call    LCritDisk
                mov     al, 9

loc_B663:                               ; ...
                jmp     SYS_RET_ERR
$DEALLOC        endp

; ---------------------------------------------------------------------------

$ALLOCOPER:                             ; ...
                or      al, al
                jz      short loc_B67D
                cmp     al, 1
                jz      short loc_B685
                cmp     al, 2
                jz      short loc_B696
                cmp     al, 3
                jz      short loc_B69E

loc_B676:                               ; ...
                call    set_exerr_locus_mem
                mov     al, 1
                jmp     short loc_B663
; ---------------------------------------------------------------------------

loc_B67D:                               ; ...
                mov     al, ss:AllocMethod
                xor     ah, ah

loc_B683:                               ; ...
                jmp     short loc_B65C
; ---------------------------------------------------------------------------

loc_B685:                               ; ...
                push    bx
                and     bl, 3Fh
                cmp     bx, 2
                pop     bx
                ja      short loc_B676
                mov     ss:302h, bl
                jmp     short loc_B683
; ---------------------------------------------------------------------------

loc_B696:                               ; ...
                mov     al, ss:89h
                and     al, 1
                jmp     short loc_B683
; ---------------------------------------------------------------------------

loc_B69E:                               ; ...
                mov     cx, ss:8Ch
                inc     cx
                jz      short loc_B676
                dec     cx
                dec     bx
                jz      short loc_B6C4
                inc     bx
                jz      short loc_B6AF
                jmp     short loc_B676
; ---------------------------------------------------------------------------

loc_B6AF:                               ; ...
                call    sub_B443
                jz      short loc_B6C2
                call    sub_B6D9
                mov     byte ptr ds:0, 5Ah ; 'Z'
                and     byte ptr ss:89h, 0FEh

loc_B6C2:                               ; ...
                jmp     short loc_B683
; ---------------------------------------------------------------------------

loc_B6C4:                               ; ...
                call    sub_B443
                jnz     short loc_B6D7
                call    sub_B6D9
                mov     byte ptr ds:0, 4Dh ; 'M'
                or      byte ptr ss:89h, 1

loc_B6D7:                               ; ...
                jmp     short loc_B683

; =============== S U B R O U T I N E =======================================


sub_B6D9        proc near               ; ...
                push    ax
                mov     ax, ss:24h
                mov     es, ax
                xor     di, di
                cmp     byte ptr es:[di], 5Ah ; 'Z'
                jz      short loc_B6FE

loc_B6E8:                               ; ...
                mov     ds, ax
                call    sub_B47C
                jb      short loc_B711
                call    sub_B443
                jnz     short loc_B6FA
                cmp     byte ptr es:[di], 5Ah ; 'Z'
                jmp     short loc_B6FC
; ---------------------------------------------------------------------------

loc_B6FA:                               ; ...
                cmp     ax, cx

loc_B6FC:                               ; ...
                jnz     short loc_B6E8

loc_B6FE:                               ; ...
                call    sub_B443
                jnz     short loc_B70E
                mov     ds, ax
                call    sub_B47C
                jb      short loc_B711
                cmp     ax, cx
                jnz     short loc_B711

loc_B70E:                               ; ...
                clc
                pop     ax
                retn
; ---------------------------------------------------------------------------

loc_B711:                               ; ...
                stc
                pop     ax
                pop     ax
                call    set_exerr_locus_mem
                jmp     loc_B526
sub_B6D9        endp ; sp-analysis failed

; ---------------------------------------------------------------------------
word_B71A       dw 0B71Eh               ; ...
word_B71C       dw 0B76Dh               ; ...
                db  0Bh
                db 0D4h
                db 0B7h
                db  6Eh ; n
                db 0B7h
                db 0A5h
                db 0B7h
                db 0AEh
                db 0B7h
                db 0B5h
                db 0B7h
                db 0BCh
                db 0B7h
                db  15h
                db 0B8h
                db  39h ; 9
                db 0B8h
                db  39h ; 9
                db 0B8h
                db  39h ; 9
                db 0B8h
                db  45h ; E
                db 0B8h
; ---------------------------------------------------------------------------

$ServerCall:                            ; ...
                cmp     al, 7
                jb      short loc_B73D
                cmp     al, 9
                jbe     short loc_B757

loc_B73D:                               ; ...
                mov     si, dx
                mov     bx, [si+12h]
                test    ss:IsWin386, 1
                jnz     short loc_B74F
                mov     ss:USER_ID, bx

loc_B74F:                               ; ...
                mov     bx, [si+14h]
                mov     ss:PROC_ID, bx

loc_B757:                               ; ...
                push    cs:word_B71C
                push    cs:word_B71A
                push    ax
                call    TableDispatch
                call    set_exerr_locus_unk
                mov     al, 1

loc_B76A:                               ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------
                retn
; ---------------------------------------------------------------------------
                xor     bx, bx
                push    ss
                pop     ds
                call    ECritDisk

loc_B775:                               ; ...
                push    bx
                call    SFFromSFN
                jb      short loc_B79E
                cmp     word ptr es:[di], 0
                jz      short loc_B79A
                cmp     word ptr es:[di], 0FFFFh
                jz      short loc_B79A
                test    word ptr es:[di+5], 8000h
                jnz     short loc_B79A
                mov     word ptr ds:THISSFT, di
                mov     word ptr ds:THISSFT+2, es
                call    DOS_COMMIT

loc_B79A:                               ; ...
                pop     bx
                inc     bx
                jmp     short loc_B775
; ---------------------------------------------------------------------------

loc_B79E:                               ; ...
                call    LCritDisk
                pop     bx

loc_B7A2:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------
                call    dword ptr ss:0A4h

loc_B7AA:                               ; ...
                jnb     short loc_B7A2

loc_B7AC:                               ; ...
                jmp     short loc_B76A
; ---------------------------------------------------------------------------
                call    dword ptr ss:9Ch
                jmp     short loc_B7AA
; ---------------------------------------------------------------------------
                call    dword ptr ss:0A0h
                jmp     short loc_B7AA
; ---------------------------------------------------------------------------
                call    dword ptr ss:0B4h
                jb      short loc_B7AC
                call    Get_User_Stack
                mov     [si+2], bx
                mov     [si+0Ah], di
                mov     word ptr [si+10h], es

loc_B7CF:                               ; ...
                mov     [si+4], cx

loc_B7D2:                               ; ...
                jmp     short loc_B7A2
; ---------------------------------------------------------------------------
                pop     ax
                push    ds
                push    si
                call    Get_User_Stack
                pop     di
                pop     es
                call    XCHGP
                push    si
                mov     cx, 6
                rep movsw
                inc     di
                inc     di
                movsw
                movsw
                pop     si
                mov     ax, [si]
                mov     bx, [si+2]
                mov     cx, [si+4]
                mov     dx, [si+6]
                mov     di, [si+0Ah]
                mov     es, word ptr [si+0Eh]
                push    word ptr [si+8]
                mov     ds, word ptr [si+0Ch]
                pop     si
                mov     ss:SAVEDS, ds
                mov     ss:SAVEBX, bx
                mov     ss:FSHARING, 0FFh
                jmp     REDISP
; ---------------------------------------------------------------------------
                push    ss
                pop     es
                mov     di, offset ERRORMODE
                mov     cx, 0AFAh
                mov     dx, offset USER_IN_AX
                sub     cx, di
                sub     dx, di
                shr     cx, 1
                adc     cx, 0
                add     cx, cx
                call    Get_User_Stack
                mov     word ptr [si+0Eh], es
                mov     [si+8], di
                mov     [si+6], dx
                jmp     short loc_B7CF
; ---------------------------------------------------------------------------
                push    ax
                mov     ax, 1125h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
                                        ; STACK: WORD subfunction
                                        ; Return: CF set on error, AX = error code
                                        ; STACK unchanged
                pop     bx
                jnb     short loc_B7D2
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------
                mov     ax, [si]
                mov     ss:EXTERR, ax
                mov     ax, [si+0Ah]
                mov     word ptr ss:EXTERRPT, ax
                mov     ax, [si+0Eh]
                mov     word ptr ss:EXTERRPT+2, ax
                mov     ax, [si+2]
                mov     word ptr ss:EXTERR_ACTION, ax
                mov     ax, [si+4]
                mov     ss:EXTERR_LOCUS, ah
                retn

; =============== S U B R O U T I N E =======================================


pJFNFromHandle  proc near               ; ...
                mov     es, cs:DosDSeg
                mov     es, es:CurrentPDB
                cmp     bx, es:32h
                jnb     short loc_B882
                les     di, es:34h
                add     di, bx
                retn
; ---------------------------------------------------------------------------

loc_B882:                               ; ...
                mov     al, 6

loc_B884:                               ; ...
                stc

locret_B885:                            ; ...
                retn
pJFNFromHandle  endp


; =============== S U B R O U T I N E =======================================


SFFromHandle    proc near               ; ...
                call    pJFNFromHandle
                jb      short locret_B885
                cmp     byte ptr es:[di], 0FFh
                jz      short loc_B89C
                push    bx
                mov     bl, es:[di]
                xor     bh, bh
                call    SFFromSFN
                pop     bx
                retn
; ---------------------------------------------------------------------------

loc_B89C:                               ; ...
                mov     al, 6
                jmp     short loc_B884
SFFromHandle    endp


; =============== S U B R O U T I N E =======================================


SFFromSFN       proc near               ; ...
                mov     es, cs:DosDSeg
                les     di, es:2Ah

loc_B8AA:                               ; ...
                cmp     bx, es:[di+4]
                jb      short loc_B8BE
                sub     bx, es:[di+4]
                les     di, es:[di]
                cmp     di, 0FFFFh
                jnz     short loc_B8AA
                stc
                retn
; ---------------------------------------------------------------------------

loc_B8BE:                               ; ...
                push    ax
                mov     ax, 3Bh ; ';'
                mul     bl
                add     di, ax
                pop     ax
                add     di, 6
                retn
SFFromSFN       endp


; =============== S U B R O U T I N E =======================================


JFNFree         proc near               ; ...
                xor     bx, bx

loc_B8CD:                               ; ...
                call    pJFNFromHandle
                jb      short loc_B8DB
                cmp     byte ptr es:[di], 0FFh
                jz      short locret_B8DD
                inc     bx
                jmp     short loc_B8CD
; ---------------------------------------------------------------------------

loc_B8DB:                               ; ...
                mov     al, 4

locret_B8DD:                            ; ...
                retn
JFNFree         endp


; =============== S U B R O U T I N E =======================================


SFNFree         proc near               ; ...
                push    ax
                xor     bx, bx

loc_B8E1:                               ; ...
                push    bx
                call    SFFromSFN
                pop     bx
                jb      short loc_B923
                cmp     word ptr es:[di], 0
                jz      short loc_B90B
                cmp     word ptr es:[di], 0FFFFh
                jz      short loc_B8F7

loc_B8F4:                               ; ...
                inc     bx
                jmp     short loc_B8E1
; ---------------------------------------------------------------------------

loc_B8F7:                               ; ...
                mov     ax, ss:33Eh
                cmp     es:[di+2Fh], ax
                jnz     short loc_B8F4
                mov     ax, ss:33Ch
                cmp     es:[di+31h], ax
                jnz     short loc_B8F4

loc_B90B:                               ; ...
                mov     word ptr es:[di], 0FFFFh
                mov     ax, ss:33Eh
                mov     es:[di+2Fh], ax
                mov     ax, ss:33Ch
                mov     es:[di+31h], ax
                pop     ax
                clc
                retn
; ---------------------------------------------------------------------------

loc_B923:                               ; ...
                pop     ax
                jmp     short loc_B8DB
SFNFree         endp


; =============== S U B R O U T I N E =======================================


$CLOSE          proc near               ; ...
                call    CheckOwner
                jb      short CloseError
                push    ss
                pop     ds
                mov     word ptr ds:THISSFT, di
                mov     word ptr ds:5A0h, es
                cmp     word ptr es:[di], 1
                jz      short FreeJFN
                mov     al, es:[di+2]
                and     al, 0F0h
                cmp     al, 70h
                jz      short PostFree

FreeJFN:                                ; ...
                call    pJFNFromHandle
                mov     byte ptr es:[di], 0FFh

PostFree:                               ; ...
                call    DOS_CLOSE
                jb      short CloseError
                mov     ah, 3Eh ; '>'

loc_B953:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

CloseError:                             ; ...
                jmp     SYS_RET_ERR
$CLOSE          endp

; ---------------------------------------------------------------------------

$COMMIT:                                ; ...
                call    CheckOwner
                jb      short CommitError
                push    ss
                pop     ds
                mov     word ptr ds:THISSFT, di
                mov     word ptr ds:THISSFT+2, es
                call    DOS_COMMIT
                jb      short CommitError
                mov     ah, 68h
                jmp     short loc_B953
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR $READ

CommitError:                            ; ...
                jmp     short CloseError
; END OF FUNCTION CHUNK FOR $READ
; ---------------------------------------------------------------------------

$ExtHandle:                             ; ...
                xor     bp, bp
                cmp     bx, 20
                jnb     short loc_B97D
                mov     bx, 20

loc_B97D:                               ; ...
                mov     es, ss:CurrentPDB
                mov     cx, word ptr es:BCON
                cmp     bx, cx
                jz      short loc_B953
                ja      short loc_B9AB
                inc     bp
                mov     ds, es:MAXSEC
                mov     si, bx
                sub     cx, bx

loc_B997:                               ; ...
                cmp     byte ptr [si], 0FFh
                jnz     short loc_B9D5
                inc     si
                loop    loc_B997
                cmp     bx, 14h
                ja      short loc_B9AB
                inc     bp
                mov     di, 18h
                push    bx
                jmp     short loc_B9C6
; ---------------------------------------------------------------------------

loc_B9AB:                               ; ...
                inc     bx
                jz      short loc_BA2A
                dec     bx
                clc
                push    bx
                add     bx, 0Fh
                mov     cl, 4
                rcr     bx, cl
                and     bh, 1Fh
                push    bp
                call    $ALLOC
                pop     bp
                jb      short loc_BA25
                mov     es, ax
                xor     di, di

loc_B9C6:                               ; ...
                mov     ds, word ptr ss:330h
                test    bp, 3
                jz      short loc_B9D9
                pop     cx
                push    cx
                jmp     short loc_B9DD
; ---------------------------------------------------------------------------

loc_B9D5:                               ; ...
                mov     al, 4
; START OF FUNCTION CHUNK FOR $READ

loc_B9D7:                               ; ...
                jmp     short CommitError
; END OF FUNCTION CHUNK FOR $READ
; ---------------------------------------------------------------------------

loc_B9D9:                               ; ...
                mov     cx, ds:32h

loc_B9DD:                               ; ...
                mov     dx, cx
                lds     si, ds:34h
                rep movsb
                pop     cx
                push    cx
                sub     cx, dx
                mov     al, 0FFh
                rep stosb
                mov     ds, word ptr ss:330h
                cmp     word ptr ds:34h, 0
                jnz     short loc_BA06
                push    bp
                push    ds
                push    es
                mov     es, word ptr ds:36h
                call    $DEALLOC
                pop     es
                pop     ds
                pop     bp

loc_BA06:                               ; ...
                test    bp, 2
                jz      short loc_BA14
                mov     word ptr ds:34h, 18h
                jmp     short loc_BA1A
; ---------------------------------------------------------------------------

loc_BA14:                               ; ...
                mov     word ptr ds:34h, 0

loc_BA1A:                               ; ...
                mov     word ptr ds:36h, es
                pop     word ptr ds:32h
; START OF FUNCTION CHUNK FOR $READ

loc_BA22:                               ; ...
                jmp     SYS_RET_OK
; END OF FUNCTION CHUNK FOR $READ
; ---------------------------------------------------------------------------

loc_BA25:                               ; ...
                pop     bx
                mov     al, 8
                jmp     short loc_B9D7
; ---------------------------------------------------------------------------

loc_BA2A:                               ; ...
                mov     al, 1
; START OF FUNCTION CHUNK FOR $READ

loc_BA2C:                               ; ...
                jmp     short loc_B9D7
; END OF FUNCTION CHUNK FOR $READ

; =============== S U B R O U T I N E =======================================


$READ           proc near               ; ...

; FUNCTION CHUNK AT B971 SIZE 00000002 BYTES
; FUNCTION CHUNK AT B9D7 SIZE 00000002 BYTES
; FUNCTION CHUNK AT BA22 SIZE 00000003 BYTES
; FUNCTION CHUNK AT BA2C SIZE 00000002 BYTES

                mov     si, offset DOS_READ

ReadDO:                                 ; ...
                call    pJFNFromHandle
                jb      short loc_BA8A
                mov     al, es:[di]
                call    CheckOwner
                jb      short loc_BA8A
                mov     word ptr ss:THISSFT, di
                mov     word ptr ss:THISSFT+2, es
                test    byte ptr es:[di+3], 20h
                jz      short loc_BA55
                or      ss:EXTOPEN_ON, 2

loc_BA55:                               ; ...
                mov     ax, ds
                lds     bx, ss:DMAADD
                push    bx
                push    ds
                mov     bx, dx
                shr     bx, 1
                shr     bx, 1
                shr     bx, 1
                shr     bx, 1
                add     ax, bx
                and     dx, 0Fh
                mov     word ptr ss:DMAADD, dx
                mov     word ptr ss:DMAADD+2, ax
                mov     ax, ss
                mov     ds, ax
                call    si ; DOS_READ
                pop     word ptr ds:DMAADD+2
                pop     word ptr ds:DMAADD
                jb      short loc_BA8A
                mov     ax, cx

loc_BA88:                               ; ...
                jmp     short loc_BA22
; ---------------------------------------------------------------------------

loc_BA8A:                               ; ...
                jmp     short loc_BA2C
$READ           endp

; ---------------------------------------------------------------------------

$WRITE:                                 ; ...
                mov     si, offset DOS_WRITE
                jmp     short ReadDO

; =============== S U B R O U T I N E =======================================


$LSEEK          proc near               ; ...
                call    CheckOwner

loc_BA94:                               ; ...
                jb      short loc_BA8A
                cmp     al, 2
                ja      short loc_BAED
                cmp     al, 1
                jb      short loc_BAA8
                ja      short loc_BABB
                add     dx, es:[di+15h]
                adc     cx, es:[di+17h]

loc_BAA8:                               ; ...
                mov     ax, cx
                xchg    ax, dx

loc_BAAB:                               ; ...
                mov     es:[di+15h], ax
                mov     es:[di+17h], dx
                call    Get_User_Stack
                mov     [si+6], dx
                jmp     short loc_BA88
; ---------------------------------------------------------------------------

loc_BABB:                               ; ...
                test    byte ptr es:[di+6], 80h
                jnz     short loc_BACC

loc_BAC2:                               ; ...
                add     dx, es:[di+11h]
                adc     cx, es:[di+13h]
                jmp     short loc_BAA8
; ---------------------------------------------------------------------------

loc_BACC:                               ; ...
                test    byte ptr es:[di+3], 80h
                jnz     short loc_BAC2
                mov     ax, es:[di+2]
                and     ax, 0F0h
                cmp     ax, 40h ; '@'
                jz      short loc_BAE4
                cmp     ax, 30h ; '0'
                jnz     short loc_BAC2

loc_BAE4:                               ; ...
                mov     ax, 1121h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE
                                        ; CX:DX = offset (in bytes) from end
                                        ; ES:DI -> SFT, SFT DPB field -> DPB of drive with file
                                        ; SS = DOS CS
                                        ; Return: CF set on error
                                        ; CF clear if successful, DX:AX = new file position
                jnb     short loc_BAAB

loc_BAEB:                               ; ...
                jmp     short loc_BA8A
; ---------------------------------------------------------------------------

loc_BAED:                               ; ...
                call    set_exerr_locus_unk
                mov     al, 1

loc_BAF2:                               ; ...
                jmp     SYS_RET_ERR
$LSEEK          endp

; ---------------------------------------------------------------------------

$FILE_TIMES:                            ; ...
                cmp     al, 7
                jnb     short loc_BAED
                cmp     al, 4
                jnb     short loc_BB01
                cmp     al, 2
                jnb     short loc_BAED

loc_BB01:                               ; ...
                call    CheckOwner
                jb      short loc_BA94
                cmp     al, 1
                ja      short loc_BB42
                or      al, al
                jnz     short ft_set_time
                lds     cx, es:[di+0Dh]
                mov     dx, ds
                call    Get_User_Stack
                mov     [si+4], cx
                mov     [si+6], dx
                jmp     short loc_BB3F
; ---------------------------------------------------------------------------

ft_set_time:                            ; ...
                call    ECritDisk
                mov     es:[di+0Dh], cx
                mov     es:[di+0Fh], dx
                xor     ax, ax
                call    dword ptr ss:0C8h
                and     word ptr es:[di+5], 0FFBFh
                or      word ptr es:[di+5], 4000h
                call    LCritDisk

loc_BB3F:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

loc_BB42:                               ; ...
                test    byte ptr es:[di+5], 80h
                jnz     short loc_BB4C
                call    IsSFTNet

loc_BB4C:                               ; ...
                jz      short loc_BB61
                test    al, 1
                jnz     short loc_BB5F
                mov     dx, es:[di+0Fh]

loc_BB56:                               ; ...
                call    Get_User_Stack
                mov     [si+4], cx
                mov     [si+6], dx

loc_BB5F:                               ; ...
                jmp     short loc_BB3F
; ---------------------------------------------------------------------------

loc_BB61:                               ; ...
                push    ss
                pop     ds
                push    ax
                push    dx
                push    cx
                call    sub_7873
                pop     cx
                pop     dx
                jnb     short loc_BB70
                pop     cx

loc_BB6E:                               ; ...
                jmp     short loc_BAF2
; ---------------------------------------------------------------------------

loc_BB70:                               ; ...
                pop     ax
                test    al, 1
                jnz     short loc_BB89
                xor     cx, cx
                mov     dx, es:[di+12h]
                cmp     al, 6
                jnz     short loc_BB87
                mov     cx, es:[di+0Eh]
                mov     dx, es:[di+10h]

loc_BB87:                               ; ...
                jmp     short loc_BB56
; ---------------------------------------------------------------------------

loc_BB89:                               ; ...
                test    dl, 1Fh
                jnz     short loc_BB92

loc_BB8E:                               ; ...
                mov     al, 0Dh

loc_BB90:                               ; ...
                jmp     short loc_BB6E
; ---------------------------------------------------------------------------

loc_BB92:                               ; ...
                test    dx, 1E0h
                jz      short loc_BB8E
                push    dx
                and     dx, 1E0h
                cmp     dx, 180h
                pop     dx
                ja      short loc_BB8E
                cmp     al, 5
                jnz     short loc_BBAE
                mov     es:[di+12h], dx
                jmp     short loc_BBCE
; ---------------------------------------------------------------------------

loc_BBAE:                               ; ...
                mov     ax, cx
                and     ax, 0F81Fh
                cmp     ah, 0B8h
                ja      short loc_BB8E
                cmp     al, 1Dh
                ja      short loc_BB8E
                mov     ax, cx
                and     ax, 7E0h
                cmp     ax, 760h
                ja      short loc_BB8E
                mov     es:[di+10h], dx
                mov     es:[di+0Eh], cx

loc_BBCE:                               ; ...
                test    byte ptr es:[bx+5], 40h
                jnz     short loc_BBDD
                call    INC_DIRTY_COUNT
                or      byte ptr es:[bx+5], 40h

loc_BBDD:                               ; ...
                push    es
                pop     ds
                mov     di, bx
                mov     al, 0FFh
                call    CHECKFLUSH
                jb      short loc_BB6E

loc_BBE8:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

$DUP:                                   ; ...
                mov     ax, bx
                call    JFNFree

loc_BBF0:                               ; ...
                jnb     short loc_BBF5
                jmp     loc_BAEB
; ---------------------------------------------------------------------------

loc_BBF5:                               ; ...
                push    es
                push    di
                pop     si
                pop     ds
                xchg    ax, bx
                call    CheckOwner
                jnb     short loc_BC01
                jmp     short loc_BB90
; ---------------------------------------------------------------------------

loc_BC01:                               ; ...
                call    loc_707E
                call    pJFNFromHandle
                mov     bl, es:[di]
                mov     [si], bl
                jmp     short loc_BBE8
; ---------------------------------------------------------------------------

$DUP2:                                  ; ...
                push    bx
                push    cx
                mov     bx, cx
                call    $CLOSE
                pop     bx
                pop     ax
                call    pJFNFromHandle
                jmp     short loc_BBF0

; =============== S U B R O U T I N E =======================================


CheckOwner      proc near               ; ...
                call    SFFromHandle
                jb      short locret_BC40
                push    ax
                test    ss:IsWin386, 1
                jz      short loc_BC32
                xor     ax, ax
                pop     ax
                jnz     short loc_BC30

locret_BC2F:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_BC30:                               ; ...
                jmp     short loc_BC3D
; ---------------------------------------------------------------------------

loc_BC32:                               ; ...
                mov     ax, ss:USER_ID
                cmp     ax, es:[di+2Fh]
                pop     ax
                jz      short locret_BC2F

loc_BC3D:                               ; ...
                mov     al, 6
                stc

locret_BC40:                            ; ...
                retn
CheckOwner      endp

; ---------------------------------------------------------------------------

$AssignOper:                            ; ...
                cmp     al, 7
                jnz     short loc_BC69

loc_BC45:                               ; ...
                push    ax
                mov     al, dl
                call    GetCDSFromDrv
                pop     ax
                jb      short loc_BC64
                cmp     word ptr [si+45h], 0
                jz      short loc_BC64
                cmp     al, 7
                jnz     short loc_BC5E
                or      byte ptr [si+44h], 40h
                jmp     short loc_BC76
; ---------------------------------------------------------------------------

loc_BC5E:                               ; ...
                and     byte ptr [si+44h], 0BFh
                jmp     short loc_BC76
; ---------------------------------------------------------------------------

loc_BC64:                               ; ...
                mov     ax, 0Fh
                jmp     short loc_BC79
; ---------------------------------------------------------------------------

loc_BC69:                               ; ...
                cmp     al, 8
                jz      short loc_BC45
                push    ax
                mov     ax, 111Eh
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
                                        ; SS = DOS CS
                                        ; STACK: WORD function to execute
                                        ; Return: CF set on error, AX = error code
                                        ; STACK unchanged
                pop     bx
                jb      short loc_BC79

loc_BC76:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

loc_BC79:                               ; ...
                jmp     SYS_RET_ERR

; =============== S U B R O U T I N E =======================================


sub_BC7C        proc near               ; ...
                lds     si, ss:26h

loc_BC81:                               ; ...
                cmp     si, 0FFFFh
                jz      short loc_BC8F
                cmp     al, [si]
                jz      short locret_BC90
                lds     si, [si+19h]
                jmp     short loc_BC81
; ---------------------------------------------------------------------------

loc_BC8F:                               ; ...
                stc

locret_BC90:                            ; ...
                retn
sub_BC7C        endp


; =============== S U B R O U T I N E =======================================


InitCDS         proc near               ; ...
                push    ax
                les     di, ss:5A2h
                mov     word ptr es:[di+43h], 0
                sub     al, 40h ; '@'
                cmp     ss:46h, al
                jb      short loc_BCDC
                dec     ax
                push    ax
                add     al, 41h ; 'A'
                mov     ah, 3Ah ; ':'
                mov     es:[di], ax
                mov     word ptr es:[di+2], 5Ch ; '\'
                or      byte ptr es:[di+44h], 40h
                sub     ax, ax
                mov     es:[di+49h], ax
                mov     es:[di+4Bh], ax
                mov     al, 2
                mov     es:[di+4Fh], ax
                pop     ax
                push    ds
                push    si
                call    sub_BC7C
                jb      short loc_BCDA
                mov     es:[di+45h], si
                mov     word ptr es:[di+47h], ds

loc_BCDA:                               ; ...
                pop     si
                pop     ds

loc_BCDC:                               ; ...
                pop     ax

locret_BCDD:                            ; ...
                retn
InitCDS         endp

; ---------------------------------------------------------------------------

$UserOper:                              ; ...
                cmp     al, 1
                jb      short loc_BCEF
                jz      short loc_BD0E
                cmp     al, 5
                jbe     short loc_BD21
                call    set_exerr_locus_unk
                mov     al, 1

loc_BCED:                               ; ...
                jmp     short loc_BC79
; ---------------------------------------------------------------------------

loc_BCEF:                               ; ...
                push    ds
                pop     es
                mov     di, dx
                mov     cx, ss:0Eh
                call    Get_User_Stack
                mov     [si+4], cx
                push    ss
                pop     ds
                mov     si, offset MYNAME

loc_BD03:                               ; ...
                mov     cx, 0Fh
                rep movsb
                xor     ax, ax
                stosb

loc_BD0B:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

loc_BD0E:                               ; ...
                mov     ss:0Eh, cx
                mov     si, dx
                push    ss
                pop     es
                mov     di, 305h
                inc     byte ptr ss:304h
                jmp     short loc_BD03
; ---------------------------------------------------------------------------

loc_BD21:                               ; ...
                push    ax
                mov     ax, 111Fh
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
                                        ; STACK: WORD function
                                        ; Return: CF set on error, AX = error code
                                        ; STACK unchanged
                pop     dx
                jnb     short loc_BD0B
                jmp     short loc_BCED

; =============== S U B R O U T I N E =======================================


GetVisDrv       proc near               ; ...
                call    GETTHISDRV
                jb      short locret_BCDD
                push    ds
                push    si
                lds     si, ss:5A2h
                test    byte ptr [si+44h], 20h
                pop     si
                pop     ds
                jz      short locret_BCDD
                mov     ss:DrvErr, 0Fh
                stc
                retn
GetVisDrv       endp


; =============== S U B R O U T I N E =======================================


GETTHISDRV      proc near               ; ...
                or      al, al
                jnz     short loc_BD51
                mov     al, ss:CURDRV
                inc     ax

loc_BD51:                               ; ...
                dec     ax
                push    ds
                push    si
                call    set_exerr_locus_disk
                cmp     ss:FSHARING, 0
                jz      short loc_BD7F
                push    ax
                push    es
                push    di
                mov     word ptr ss:THISCDS, (offset dword_613 - (offset SFT0_SFTable+4Eh))
                mov     word ptr ss:THISCDS+2, ss
                add     al, 41h ; 'A'
                call    InitCDS
                test    byte ptr es:[di+44h], 40h
                pop     di
                pop     es
                pop     ax
                jz      short loc_BD8A
                jmp     short loc_BD94
; ---------------------------------------------------------------------------

loc_BD7F:                               ; ...
                call    GetCDSFromDrv
                jb      short loc_BD8A
                test    byte ptr [si+44h], 40h
                jnz     short loc_BD94

loc_BD8A:                               ; ...
                mov     al, 0Fh
                mov     ss:DrvErr, al
                call    set_exerr_locus_unk
                stc

loc_BD94:                               ; ...
                pop     si
                pop     ds
                retn
GETTHISDRV      endp


; =============== S U B R O U T I N E =======================================


GetCDSFromDrv   proc near               ; ...
                cmp     al, ss:47h
                jnb     short loc_BDB9
                push    bx
                push    ax
                lds     si, ss:3Ch
                mov     bl, 58h ; 'X'
                mul     bl
                add     si, ax
                mov     ss:5A2h, si
                mov     word ptr ss:5A4h, ds
                pop     ax
                pop     bx
                clc
                retn
; ---------------------------------------------------------------------------

loc_BDB9:                               ; ...
                stc
                retn
GetCDSFromDrv   endp


; =============== S U B R O U T I N E =======================================

; Attributes: bp-based frame

TransFCB        proc near               ; ...

FCBTmp          = byte ptr -10h

                push    bp
                mov     bp, sp
                sub     sp, 10h
                push    ss
                pop     es
                push    es
                push    di
                lea     di, [bp+FCBTmp] ; point to FCB temp area
                mov     ss:EXTFCB, 0    ; no extended FCB found
                mov     ss:SATTRIB, 0   ; default search attributes
                call    GetExtended     ; get FCB, extended or not
                jz      short GetDrive  ; not an extended FCB, get drive
                mov     al, [si-1]      ; get attributes
                mov     ss:SATTRIB, al  ; store search attributes
                mov     ss:EXTFCB, 0FFh ; -1 ; signal extended FCB

GetDrive:                               ; ...
                lodsb                   ; get drive byte
                call    GETTHISDRV
                jb      short BadPack
                call    TextFromDrive   ; convert 0-based drive to text
                mov     cx, 11
                push    si              ; back over name, ext

FCBScan:                                ; ...
                lodsb                   ; get a byte
                call    GetCharType
                test    al, 8
                jz      short BadPack
                loop    FCBScan
                pop     si
                mov     bx, di
                call    PackName
                pop     di
                pop     es
                push    ss
                pop     ds
                lea     si, [bp+FCBTmp]
                cmp     byte ptr [bx], 0
                jz      short BadPack
                push    bp
                call    TransPathSet
                pop     bp
                jnb     short FCBRet

BadPack:                                ; ...
                stc
                mov     al, 3

FCBRet:                                 ; ...
                mov     sp, bp
                pop     bp

TransPath_retn:                         ; ...
                retn
TransFCB        endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


TransPath       proc near               ; ...
                xor     al, al
                jmp     short loc_BE23
TransPath       endp


; =============== S U B R O U T I N E =======================================


TransPathSet    proc near               ; ...

; FUNCTION CHUNK AT BEF1 SIZE 000000A5 BYTES

                mov     al, 0FFh

loc_BE23:                               ; ...
                mov     ss:NoSetDir, al
                mov     al, 0FFh

TransPathNoSet:                         ; ...
                mov     ss:FSPLICE, al
                mov     ss:CMETA, 0FFh
                mov     ss:WFP_START, di
                mov     ss:CURR_DIR_END, 0FFFFh
                push    ss
                pop     es
                lea     bp, [di+86h]
                cmp     byte ptr ss:572h, 0
                jz      short loc_BE82
                call    DriveFromText
                call    GETTHISDRV
                jb      short loc_BE7F
                call    TextFromDrive
                lea     bx, [di+1]
                call    sub_BF96
                jb      short TransPath_retn
                push    ss
                pop     ds
                mov     si, ds:WFP_START
                test    ds:FSPLICE, 0FFh
                jz      short loc_BE70
                call    sub_C0A6

loc_BE70:                               ; ...
                push    ss
                pop     ds
                les     di, ds:THISCDS
                call    ECritDisk
                call    FATREAD_CDS
                call    LCritDisk

loc_BE7F:                               ; ...
                mov     al, 3
                retn
; ---------------------------------------------------------------------------

loc_BE82:                               ; ...
                mov     word ptr ss:THISCDS, 0FFFFh
                mov     ax, 1123h
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
                                        ; DS:SI -> ASCIZ filename to canonicalize
                                        ; ES:DI -> 128-byte buffer for qualified name
                                        ; Return: CF set if not resolved
                jnb     short loc_BEB9
                call    DriveFromText
                push    ax
                mov     ax, [si]
                call    PATHCHRCMP
                xchg    ah, al
                call    PATHCHRCMP
                jnz     short loc_BEBF
                cmp     ah, al
                jnz     short loc_BEBF
                pop     ax
                movsw

loc_BEA6:                               ; ...
                lodsb
                call    UCase
                or      al, al
                jz      short loc_BEBC
                call    PATHCHRCMP
                mov     bx, di
                stosb
                jnz     short loc_BEA6
                call    sub_BF96

loc_BEB9:                               ; ...
                push    ss
                pop     ds
                retn
; ---------------------------------------------------------------------------

loc_BEBC:                               ; ...
                stosb
                jmp     short loc_BEB9
; ---------------------------------------------------------------------------

loc_BEBF:                               ; ...
                pop     ax
                cmp     byte ptr [si], 0
                jnz     short loc_BEC9
                mov     al, 2
                stc
                retn
; ---------------------------------------------------------------------------

loc_BEC9:                               ; ...
                push    ax
                push    bp
                call    sub_BEEE
                pop     bp
                pop     ax
                jnb     short loc_BEF1
                mov     ss:FSHARING, 0FFh
                call    GETTHISDRV
                mov     ss:FSHARING, 0
                call    TextFromDrive
                mov     al, 2Fh ; '/'
                stosb
                call    StrCpy
                clc
                push    ss
                pop     ds

locret_BEED:                            ; ...
                retn
TransPathSet    endp


; =============== S U B R O U T I N E =======================================

; Attributes: thunk

sub_BEEE        proc near               ; ...
                jmp     sub_8FD0
sub_BEEE        endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR TransPathSet

loc_BEF1:                               ; ...
                call    GetVisDrv
                mov     al, 3
                jb      short locret_BEED
                push    ds
                push    si
                push    es
                push    di
                call    ValidateCDS
                pop     di
                pop     es
                pop     si
                pop     ds
                mov     al, 3
                jb      short locret_BEED
                push    ds
                push    si
                lds     si, ss:THISCDS
                mov     bx, di
                add     bx, [si+4Fh]
                lea     bp, [di+86h]
                call    FStrCpy
                dec     di
                mov     al, 5Ch ; '\'
                cmp     es:[di-1], al
                jz      short loc_BF24
                stosb

loc_BF24:                               ; ...
                dec     di
                pop     si
                pop     ds
                call    sub_BFFB
                jnz     short loc_BF3D
                or      al, al
                jz      short loc_BF40
                mov     di, bx

loc_BF32:                               ; ...
                lodsb
                call    PATHCHRCMP
                jz      short loc_BF32
                dec     si
                or      al, al
                jz      short loc_BF40

loc_BF3D:                               ; ...
                mov     al, 5Ch ; '\'
                stosb

loc_BF40:                               ; ...
                call    sub_BF96
                jb      short locret_BEED
                push    ss
                pop     ds
                mov     di, ds:WFP_START
                lds     si, ds:THISCDS
                call    sub_C171
                jnz     short loc_BF68
                mov     al, [si-1]
                call    PATHCHRCMP
                jz      short loc_BF68
                cmp     byte ptr es:[di], 0
                jz      short loc_BF68
                inc     di
                mov     ss:CURR_DIR_END, di

loc_BF68:                               ; ...
                push    ss
                pop     ds
                mov     si, ds:WFP_START
                xor     cx, cx
                test    ds:FSPLICE, 0FFh
                jz      short loc_BF7A
                call    sub_C0A6

loc_BF7A:                               ; ...
                push    ss
                pop     ds
                les     di, ds:THISCDS
                test    word ptr es:[di+43h], 8000h
                jnz     short locret_BF95
                jcxz    short locret_BF95
                call    ECritDisk
                call    FATREAD_CDS
                call    LCritDisk
                mov     al, 3

locret_BF95:                            ; ...
                retn
; END OF FUNCTION CHUNK FOR TransPathSet

; =============== S U B R O U T I N E =======================================


sub_BF96        proc near               ; ...
                lodsb
                call    PATHCHRCMP
                jnz     short loc_BFA3
                cmp     di, bp
                jnb     short loc_BFB9
                stosb
                jmp     short sub_BF96
; ---------------------------------------------------------------------------

loc_BFA3:                               ; ...
                dec     si

loc_BFA4:                               ; ...
                xor     ax, ax
                cmp     [si], al
                jnz     short loc_BFC4
                cmp     byte ptr es:[di-1], 3Ah ; ':'
                jnz     short loc_BFB6
                mov     al, 5Ch ; '\'
                stosb
                mov     al, ah

loc_BFB6:                               ; ...
                stosb
                clc
                retn
; ---------------------------------------------------------------------------

loc_BFB9:                               ; ...
                call    sub_C18A
                mov     al, 3
                jz      short loc_BFC2
                mov     al, 2

loc_BFC2:                               ; ...
                stc

locret_BFC3:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_BFC4:                               ; ...
                call    sub_C018
                jb      short locret_BFC3
                cmp     word ptr es:[di], 2Eh ; '.'
                jz      short loc_BFD7
                cmp     word ptr es:[di], 2E2Eh
                jnz     short loc_BFE0
                dec     di

loc_BFD7:                               ; ...
                call    SkipBack
                mov     al, 3
                jb      short locret_BFC3
                jmp     short loc_BFE2
; ---------------------------------------------------------------------------

loc_BFE0:                               ; ...
                add     di, cx

loc_BFE2:                               ; ...
                call    sub_BFFB
                jnz     short loc_BFB9
                lodsb
                call    PATHCHRCMP
                jnz     short loc_BFA3
                cmp     di, bp
                jnb     short loc_BFB9
                stosb

loc_BFF2:                               ; ...
                lodsb
                call    PATHCHRCMP
                jz      short loc_BFF2
                dec     si
                jmp     short loc_BFA4
sub_BF96        endp


; =============== S U B R O U T I N E =======================================


sub_BFFB        proc near               ; ...
                mov     al, [si]
sub_BFFB        endp


; =============== S U B R O U T I N E =======================================


sub_BFFD        proc near               ; ...
                or      al, al
                jz      short locret_BFC3
                call    PATHCHRCMP
                retn
sub_BFFD        endp


; =============== S U B R O U T I N E =======================================


SkipBack        proc near               ; ...
                cmp     di, bx
                jb      short loc_C014
                dec     di
                mov     al, es:[di]
                call    PATHCHRCMP
                jnz     short SkipBack
                clc
                retn
; ---------------------------------------------------------------------------

loc_C014:                               ; ...
                mov     al, 3
                stc
                retn
SkipBack        endp


; =============== S U B R O U T I N E =======================================


sub_C018        proc near               ; ...
                sub     sp, 0Eh
                push    ds
                push    si
                push    es
                push    di
                push    bp
                mov     bp, sp
                mov     ah, 2Eh ; '.'
                lodsb
                stosb
                cmp     al, ah
                jnz     short loc_C042
                call    sub_BFFB
                jz      short loc_C03A
                lodsb
                stosb
                cmp     al, ah
                jnz     short loc_C08C
                call    sub_BFFB
                jnz     short loc_C08C

loc_C03A:                               ; ...
                xor     al, al
                stosb
                mov     [bp+6], si
                jmp     short loc_C089
; ---------------------------------------------------------------------------

loc_C042:                               ; ...
                mov     si, [bp+6]
                call    NameTrans
                cmp     si, [bp+6]
                jz      short loc_C08C
                cmp     ss:FSHARING, 0
                jnz     short loc_C065
                and     dl, 1
                add     ss:CMETA, dl
                jg      short loc_C08C
                jnz     short loc_C065
                or      dl, dl
                jz      short loc_C094

loc_C065:                               ; ...
                mov     [bp+6], si
                push    ss
                pop     ds
                mov     si, offset NAME1
                lea     di, [bp+0Ah]
                push    di
                call    PackName
                pop     di
                call    StrLen
                dec     cx
                add     cx, [bp+2]
                cmp     cx, [bp+0]
                jnb     short loc_C08C
                mov     si, di
                les     di, [bp+2]
                call    FStrCpy

loc_C089:                               ; ...
                clc
                jmp     short loc_C097
; ---------------------------------------------------------------------------

loc_C08C:                               ; ...
                stc
                call    sub_C18A
                mov     al, 2
                jnz     short loc_C097

loc_C094:                               ; ...
                stc
                mov     al, 3

loc_C097:                               ; ...
                pop     bp
                pop     di
                pop     es
                pop     si
                pop     ds
                lahf
                add     sp, 0Eh
                call    StrLen
                dec     cx
                sahf
                retn
sub_C018        endp


; =============== S U B R O U T I N E =======================================


sub_C0A6        proc near               ; ...
                test    ss:SPLICES, 0FFh
                jz      short loc_C118
                push    word ptr ss:THISCDS
                push    word ptr ss:THISCDS+2
                push    ds
                push    si
                pop     di
                pop     es
                xor     ax, ax

loc_C0BE:                               ; ...
                call    GetCDSFromDrv
                jb      short loc_C10E
                inc     al
                test    word ptr [si+43h], 2000h
                jz      short loc_C0BE
                push    di
                call    sub_C171
                jz      short loc_C0D5

loc_C0D2:                               ; ...
                pop     di
                jmp     short loc_C0BE
; ---------------------------------------------------------------------------

loc_C0D5:                               ; ...
                cmp     byte ptr es:[di], 0
                jnz     short loc_C0E3
                test    ss:NoSetDir, 0FFh
                jnz     short loc_C0D2

loc_C0E3:                               ; ...
                mov     si, di
                push    es
                pop     ds
                pop     di
                call    loc_C16B
                mov     ax, ss:CURR_DIR_END
                or      ax, ax
                js      short loc_C0FB
                add     ax, di
                sub     ax, si
                mov     ss:CURR_DIR_END, ax

loc_C0FB:                               ; ...
                cmp     byte ptr [si], 0
                jnz     short loc_C103
                mov     al, 5Ch ; '\'
                stosb

loc_C103:                               ; ...
                call    FStrCpy
                add     sp, 4
                or      cl, 1
                jmp     short loc_C11A
; ---------------------------------------------------------------------------

loc_C10E:                               ; ...
                pop     word ptr ss:THISCDS+2
                pop     word ptr ss:THISCDS

loc_C118:                               ; ...
                xor     cx, cx

loc_C11A:                               ; ...
                lds     si, ss:THISCDS
                les     di, [si+45h]
                mov     word ptr ss:THISDPB, di
                mov     word ptr ss:THISDPB+2, es
sub_C0A6        endp


; =============== S U B R O U T I N E =======================================


DrvFromTxt_ret  proc near               ; ...
                retn
DrvFromTxt_ret  endp

; ---------------------------------------------------------------------------

$NameTrans:                             ; ...
                push    ds
                push    si
                push    es
                push    di
                push    cx
                mov     ch, 16h
                call    SetAttrib
                mov     di, 3BEh
                call    TransPath
                pop     cx
                pop     di
                pop     es
                pop     si
                pop     ds
                jnb     short loc_C147
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

loc_C147:                               ; ...
                mov     si, 3BEh
                push    ss
                pop     ds
                call    FStrCpy
                jmp     SYS_RET_OK

; =============== S U B R O U T I N E =======================================


DriveFromText   proc near               ; ...
                xor     al, al          ; 0
                cmp     byte ptr [si], 0
                jz      short DrvFromTxt_ret
                cmp     byte ptr [si+1], 3Ah ; ':'
                jnz     short DrvFromTxt_ret
                lodsw
                or      al, 20h         ; to lowercase
                sub     al, 60h
                jnz     short DrvFromTxt_ret ; al = drv number
                mov     al, 0FFh
                retn
DriveFromText   endp


; =============== S U B R O U T I N E =======================================


TextFromDrive   proc near               ; ...
                inc     al

loc_C16B:                               ; ...
                add     al, 40h ; '@'
                mov     ah, 3Ah ; ':'
                stosw

locret_C170:                            ; ...
                retn
TextFromDrive   endp


; =============== S U B R O U T I N E =======================================


sub_C171        proc near               ; ...
                call    DStrLen
                dec     cx
                repe cmpsb
                jnz     short locret_C170
                push    ax
                mov     al, [si-1]
                call    PATHCHRCMP
                jz      short loc_C188
                mov     al, es:[di]
                call    sub_BFFD

loc_C188:                               ; ...
                pop     ax
                retn
sub_C171        endp


; =============== S U B R O U T I N E =======================================


sub_C18A        proc near               ; ...
                lodsb
                call    sub_BFFD
                jnz     short sub_C18A
                call    PATHCHRCMP
                retn
sub_C18A        endp


; =============== S U B R O U T I N E =======================================


$OPEN           proc near               ; ...
                xor     ah, ah

$Open2:                                 ; ...
                mov     ch, 16h
                call    SetAttrib
                mov     cx, offset DOS_OPEN
                push    ax

AccessFile:                             ; ...
                call    ECritDisk
                call    SFNFree
                call    LCritDisk
                jb      short OpenFailJ
                mov     ss:SFN, bx
                mov     word ptr ss:THISSFT, di
                mov     word ptr ss:THISSFT+2, es
                call    JFNFree

OpenFailJ:                              ; ...
                jb      short loc_C1F2
                mov     ss:5AEh, di
                mov     word ptr ss:5B0h, es
                mov     ss:5ACh, bx
                mov     bx, ss:5AAh
                mov     si, dx
                mov     es:[di], bl
                mov     di, 3BEh
                push    cx
                call    TransPath
                pop     bx
                lds     si, ss:59Eh
                jb      short loc_C24D
                cmp     byte ptr ss:57Ah, 0FFh
                jz      short loc_C1F6
                mov     al, 2
                jmp     short loc_C24D
; ---------------------------------------------------------------------------

loc_C1F2:                               ; ...
                sti
                pop     cx
                jmp     short loc_C25A
; ---------------------------------------------------------------------------

loc_C1F6:                               ; ...
                pop     ax
                xor     cx, cx
                cmp     bx, 71BBh
                mov     [si+2], cx
                mov     [si+33h], cx
                jnz     short loc_C20E
                test    al, 80h
                jz      short loc_C20E
                and     al, 7Fh
                mov     cx, 1000h

loc_C20E:                               ; ...
                push    di
                push    es
                push    ds
                pop     es
                push    si
                pop     di
                call    sub_71A7
                pop     es
                pop     di
                push    ss
                pop     ds
                push    cx
                call    bx
                pop     cx
                lds     si, ds:59Eh
                jb      short loc_C246
                mov     word ptr [si], 1
                or      [si+5], cx
                push    ds
                pop     es
                mov     di, si
                call    sub_8A90
                mov     ax, ss:5ACh
                call    dword ptr ss:0C0h
                mov     word ptr ss:5AAh, 0FFFFh
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

loc_C246:                               ; ...
                cmp     ax, 57h ; 'W'
                jnz     short loc_C24E
                jmp     short loc_C25A
; ---------------------------------------------------------------------------

loc_C24D:                               ; ...
                pop     bx

loc_C24E:                               ; ...
                mov     word ptr [si], 0
                lds     si, ss:5AEh
                mov     byte ptr [si], 0FFh

loc_C25A:                               ; ...
                mov     word ptr ss:5AAh, 0FFFFh
                cmp     word ptr ss:324h, 25h ; '%'
                jnz     short loc_C26C
                jmp     From_GetSet
; ---------------------------------------------------------------------------

loc_C26C:                               ; ...
                jmp     SYS_RET_ERR
$OPEN           endp


; =============== S U B R O U T I N E =======================================


$CREAT          proc near               ; ...
                push    cx
                mov     cx, offset DOS_CREATE
$CREAT          endp ; sp-analysis failed

; START OF FUNCTION CHUNK FOR $CreateNewFile

AccessSet:                              ; ...
                mov     ss:SATTRIB, 6
                jmp     AccessFile
; END OF FUNCTION CHUNK FOR $CreateNewFile
; ---------------------------------------------------------------------------

$CHMOD:                                 ; ...
                cmp     al, 0FFh
                jnz     short loc_C2A0
                cmp     bp, 5053h
                jnz     short loc_C29C
                mov     ah, cl
                mov     word ptr ss:1154h, 80h
                cmp     cl, 39h ; '9'
                jnz     short loc_C297
                jmp     loc_67B7
; ---------------------------------------------------------------------------

loc_C297:                               ; ...
                cmp     cl, 56h ; 'V'
                jz      short rename1

loc_C29C:                               ; ...
                mov     al, 1
                jmp     short loc_C26C
; ---------------------------------------------------------------------------

loc_C2A0:                               ; ...
                mov     di, offset OPENBUF
                push    ax
                push    cx
                mov     si, dx
                call    TransPathSet
                pop     cx
                pop     ax
                jb      short NotFound
                push    ss
                pop     ds
                cmp     byte ptr ds:57Ah, 0FFh
                jnz     short NotFound
                mov     byte ptr ds:56Dh, 16h
                sub     al, 1
                jb      short loc_C2C9
                jz      short loc_C2D7
                call    set_exerr_locus_unk
                mov     al, 1

loc_C2C7:                               ; ...
                jmp     short loc_C26C
; ---------------------------------------------------------------------------

loc_C2C9:                               ; ...
                call    GET_FILE_INFO
                jb      short loc_C2E2
                call    Get_User_Stack
                mov     [si+4], ax

loc_C2D4:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

loc_C2D7:                               ; ...
                mov     ax, cx
                call    sub_6FE3
                jb      short loc_C2E2
                jmp     short UnLinkOK
; ---------------------------------------------------------------------------

NotFound:                               ; ...
                mov     al, 3

loc_C2E2:                               ; ...
                jmp     short loc_C2C7
; ---------------------------------------------------------------------------

$UNLINK:                                ; ...
                push    cx
                mov     si, dx
                mov     di, offset OPENBUF
                call    TransPathSet
                pop     cx
                jb      short NotFound
                cmp     ss:CMETA, 0FFh
                jnz     short NotFound
                push    ss
                pop     ds
                mov     ch, 6
                call    SetAttrib
                call    DOS_DELETE

UnlinkE:                                ; ...
                jb      short loc_C2E2

UnLinkOK:                               ; ...
                jmp     short loc_C2D4
; ---------------------------------------------------------------------------

$RENAME:                                ; ...
                mov     ss:DIRSTRLEN, 67

rename1:                                ; ...
                push    cx
                push    ds
                push    dx
                push    es
                pop     ds
                mov     si, di
                mov     di, offset RENBUF
                call    TransPathSet
                push    ss:WFP_START
                pop     ss:REN_WFP
                pop     si
                pop     ds
                pop     cx

epjc2:                                  ; ...
                jb      short NotFound
                cmp     ss:CMETA, 0FFh
                jnz     short NotFound
                push    cx
                mov     di, offset OPENBUF
                call    TransPathSet
                pop     cx
                jb      short epjc2
                push    ss
                pop     ds
                cmp     ds:CMETA, 0FFh
                jb      short NotFound
                les     di, ds:THISCDS
                push    di
                push    es
                mov     di, offset OPENBUF
                push    ss
                pop     es
                xor     al, al

rnloop:                                 ; ...
                call    GetCDSFromDrv
                jb      short dorn
                call    StrCmp
                jz      short rnerr
                inc     al
                jmp     short rnloop
; ---------------------------------------------------------------------------

rnerr:                                  ; ...
                pop     ax
                pop     ax
                mov     al, 10h
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

dorn:                                   ; ...
                pop     word ptr ss:THISCDS+2
                pop     word ptr ss:THISCDS
                push    ss
                pop     ds
                mov     ch, 16h
                call    SetAttrib
                call    DOS_RENAME
                jb      short UnlinkE
                jmp     short UnLinkOK

; =============== S U B R O U T I N E =======================================


$CreateNewFile  proc near               ; ...

; FUNCTION CHUNK AT C273 SIZE 00000009 BYTES

                push    cx
                mov     cx, offset DOS_Create_New
                jmp     AccessSet
$CreateNewFile  endp


; =============== S U B R O U T I N E =======================================


BinToAscii      proc near               ; ...
                push    ax
                xchg    ah, al
                aam     10h
                add     ax, 4141h       ; 'AA'
                stosw
                pop     ax
                aam     10h
                add     ax, 4141h
                stosw
                retn
BinToAscii      endp

; ---------------------------------------------------------------------------

$CreateTempFile:                        ; ...
                push    bp
                mov     bp, sp
                sub     sp, 10
                test    cx, 0FFD8h
                jz      short OKatts
                mov     ax, 5
                jmp     short SETTMPERR
; ---------------------------------------------------------------------------

OKatts:                                 ; ...
                mov     [bp-0Ah], cx
                mov     [bp-8], dx
                mov     word ptr [bp-6], ds
                mov     word ptr [bp-2], ds
                push    ds
                pop     es
                mov     di, dx
                mov     cx, di
                neg     cx
                or      cx, cx
                jnz     short loc_C3C0
                dec     cx

loc_C3C0:                               ; ...
                xor     ax, ax
                repne scasb
                dec     di
                mov     al, es:[di-1]
                call    PATHCHRCMP
                jz      short loc_C3D1
                mov     al, 5Ch ; '\'
                stosb

loc_C3D1:                               ; ...
                mov     [bp-4], di

loc_C3D4:                               ; ...
                push    ss
                pop     ds
                push    bp
                call    READTIME
                pop     bp
                les     di, [bp-4]
                mov     ax, cx
                call    BinToAscii
                mov     ax, dx
                call    BinToAscii
                xor     al, al
                stosb
                lds     dx, [bp-8]
                mov     cx, [bp-0Ah]
                push    bp
                call    $CreateNewFile
                pop     bp
                jnb     short loc_C423
                cmp     al, 50h ; 'P'
                jz      short loc_C3D4
                cmp     al, 5
                jnz     short SETTMPERR
                mov     al, ss:324h
                cmp     al, 41h ; 'A'
                jz      short SETTMPERR
                cmp     al, 53h ; 'S'
                jz      short SETTMPERR
                cmp     al, 50h ; 'P'
                jz      short loc_C3D4
                les     di, ss:5A2h
                cmp     di, 0FFFFh
                jz      short loc_C3D4
                test    word ptr es:[di+43h], 8000h
                jnz     short loc_C3D4

SETTMPERR:                              ; ...
                stc

loc_C423:                               ; ...
                mov     sp, bp
                pop     bp
                jb      short CreateFail
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

CreateFail:                             ; ...
                jmp     SYS_RET_ERR

; =============== S U B R O U T I N E =======================================


SetAttrib       proc near               ; ...
                cmp     byte ptr ss:572h, 0
                jnz     short loc_C438
                mov     cl, ch

loc_C438:                               ; ...
                mov     ss:56Dh, cl
                retn
SetAttrib       endp

; ---------------------------------------------------------------------------

$Extended_Open:                         ; ...
                mov     ss:EXTOPEN_FLAG, dx
                mov     ss:EXTOPEN_IO_MODE, 0
                test    dh, 0FEh
                jnz     short ext_inval2
                mov     ah, dl
                cmp     dl, 0
                jz      short ext_inval2
                and     dl, 0Fh
                cmp     dl, 2
                ja      short ext_inval2
                and     ah, 0F0h
                cmp     ah, 10h
                ja      short ext_inval2
                mov     ss:SAVE_ES, es
                mov     ss:SAVE_DI, di
                push    ss:EXTOPEN_FLAG
                pop     ss:SAVE_DX
                mov     ss:SAVE_CX, cx
                mov     ss:SAVE_BX, bx
                mov     ss:SAVE_DS, ds
                mov     ss:SAVE_SI, si
                mov     dx, si
                mov     ax, bx
                jmp     short goopen2
; ---------------------------------------------------------------------------

ext_inval2:                             ; ...
                mov     al, 1
                jmp     short CreateFail
; ---------------------------------------------------------------------------

goopen2:                                ; ...
                test    bh, 20h
                jz      short loc_C4A3
                or      byte ptr ss:5F6h, 2

loc_C4A3:                               ; ...
                or      byte ptr ss:5F6h, 1
                mov     byte ptr ss:5F5h, 0
                cmp     byte ptr ss:5F4h, 10h
                jnz     short loc_C4D1
                call    $CreateNewFile
                jb      short locret_C4FF
                cmp     byte ptr ss:5F6h, 0
                jz      short loc_C4CE
                mov     word ptr ss:5F4h, 2
                jmp     loc_C551
; ---------------------------------------------------------------------------

loc_C4CE:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

loc_C4D1:                               ; ...
                test    byte ptr ss:5F4h, 1
                jnz     short loc_C500
                call    $CREAT
                jb      short locret_C4FF
                cmp     byte ptr ss:5F6h, 0
                jz      short loc_C4CE
                mov     word ptr ss:5F4h, 2
                test    byte ptr ss:5F6h, 4
                jnz     short loc_C551
                mov     word ptr ss:5F4h, 3
                jmp     short loc_C551
; ---------------------------------------------------------------------------

loc_C4FE:                               ; ...
                stc

locret_C4FF:                            ; ...
                retn
; ---------------------------------------------------------------------------

loc_C500:                               ; ...
                cmp     byte ptr ss:572h, 0
                jz      short loc_C50A
                mov     cl, ch

loc_C50A:                               ; ...
                call    $Open2
                jnb     short loc_C542
                cmp     byte ptr ss:5F6h, 0
                jz      short loc_C4FE
                cmp     ax, 2
                jnz     short loc_C4FE
                test    word ptr ss:5F4h, 10h
                jnz     short loc_C528

loc_C525:                               ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

loc_C528:                               ; ...
                mov     cx, ss:5FFh
                lds     si, ss:603h
                mov     dx, si
                call    $CREAT
                jb      short loc_C525
                mov     word ptr ss:5F4h, 2
                jmp     short loc_C551
; ---------------------------------------------------------------------------

loc_C542:                               ; ...
                cmp     byte ptr ss:5F6h, 0
                jz      short loc_C55F
                mov     word ptr ss:5F4h, 1

loc_C551:                               ; ...
                push    ax
                call    Get_User_Stack
                mov     ax, ss:5F4h
                mov     [si+4], ax
                pop     ax
                mov     [si], ax

loc_C55F:                               ; ...
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

$LockOper:                              ; ...
                cmp     al, 1
                ja      short loc_C572
                push    di
                call    SFFromHandle
                jnb     short loc_C579
                pop     di
                mov     al, 6

loc_C56F:                               ; ...
                jmp     SYS_RET_ERR
; ---------------------------------------------------------------------------

loc_C572:                               ; ...
                call    set_exerr_locus_unk
                mov     al, 1

loc_C577:                               ; ...
                jmp     short loc_C56F
; ---------------------------------------------------------------------------

loc_C579:                               ; ...
                mov     bx, ax
                mov     bp, offset Lock_Buffer
                mov     [bp+0], dx
                mov     [bp+2], cx
                pop     word ptr [bp+4]
                mov     [bp+6], si
                mov     cx, 1
                push    ss
                pop     ds
                mov     dx, bp
                test    al, 1
                jnz     short loc_C597
                jmp     short loc_C5B3
; ---------------------------------------------------------------------------

loc_C597:                               ; ...
                test    byte ptr es:[di+6], 80h
                jz      short loc_C5A5
                mov     ax, 110Ah
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
                                        ; BX = file handle, CX:DX = starting offset, SI = high word of size
                                        ; STACK: WORD low word of size, ES:DI -> SFT
                                        ; SFT DPB field -> DPB of drive containing file, SS = DOS CS
                                        ; Return: CF set error
                jmp     short loc_C5A9
; ---------------------------------------------------------------------------

loc_C5A5:                               ; ...
                call    ds:clr_block

loc_C5A9:                               ; ...
                jnb     short loc_C5AD
                jmp     short loc_C577
; ---------------------------------------------------------------------------

loc_C5AD:                               ; ...
                mov     ax, ds:TEMP_VAR
                jmp     SYS_RET_OK
; ---------------------------------------------------------------------------

loc_C5B3:                               ; ...
                test    byte ptr es:[di+6], 80h
                jz      short loc_C5C1
                mov     ax, 110Ah
                int     2Fh             ; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
                                        ; BX = file handle, CX:DX = starting offset, SI = high word of size
                                        ; STACK: WORD low word of size, ES:DI -> SFT
                                        ; SFT DPB field -> DPB of drive containing file, SS = DOS CS
                                        ; Return: CF set error
                jmp     short loc_C5A9
; ---------------------------------------------------------------------------

loc_C5C1:                               ; ...
                call    ds:set_block
                jmp     short loc_C5A9

; =============== S U B R O U T I N E =======================================


sub_C5C7        proc near               ; ...
                mov     bx, ds:RetryCount

loc_C5CB:                               ; ...
                push    bx
                push    ax
                call    ds:chk_block
                pop     ax
                pop     bx
                jnb     short locret_C5DC
                call    Idle
                dec     bx
                jnz     short loc_C5CB
                stc

locret_C5DC:                            ; ...
                retn
sub_C5C7        endp


; =============== S U B R O U T I N E =======================================


sub_C5DD        proc near               ; ...
                push    ds
                push    es
                push    di
                push    cx
                mov     ax, 21h ; '!'
                mov     ds:ALLOWED, 18h
                les     bp, ds:THISDPB
                mov     di, 1
                mov     cx, di
                xor     dx, dx
                cmp     es:[bp+0Fh], dx
                jnz     short loc_C608
                mov     dx, es:[bp+2Bh]
                mov     ds:HIGH_SECTOR, dx
                mov     dx, es:[bp+29h]
                jmp     short loc_C610
; ---------------------------------------------------------------------------

loc_C608:                               ; ...
                mov     ds:HIGH_SECTOR, dx
                mov     dx, es:[bp+0Bh]

loc_C610:                               ; ...
                call    HARDERR
                pop     cx
                pop     di
                pop     es
                pop     ds
                cmp     al, 1
                jz      short locret_C5DC
                stc
                retn
sub_C5DD        endp


; =============== S U B R O U T I N E =======================================


CheckShare      proc near               ; ...
                push    ds
                mov     ds, cs:DosDSeg
                cmp     ds:fShare, 0
                pop     ds
                retn
CheckShare      endp


; =============== S U B R O U T I N E =======================================


sub_C62A        proc near               ; ...
                call    ds:MFT_enter

locret_C62E:                            ; ...
                retn
sub_C62A        endp


; =============== S U B R O U T I N E =======================================


SHARE_VIOLATION proc near               ; ...
                push    ds
                push    es
                push    di
                mov     ds:READOP, 0
                mov     ds:ALLOWED, 18h
                les     bp, ds:THISDPB
                mov     di, 1
                mov     cx, di
                cmp     word ptr es:[bp+0Fh], 0
                jz      short loc_C658
                mov     word ptr ds:607h, 0
                mov     dx, es:[bp+11h]
                jmp     short loc_C664
; ---------------------------------------------------------------------------

loc_C658:                               ; ...
                mov     dx, es:[bp+2Bh]
                mov     ds:HIGH_SECTOR, dx
                mov     dx, es:[bp+29h]

loc_C664:                               ; ...
                call    HARDERR
                pop     di
                pop     es
                pop     ds
                cmp     al, 1
                jz      short locret_C62E
                stc
                retn
SHARE_VIOLATION endp


; =============== S U B R O U T I N E =======================================


ShareEnd        proc near               ; ...
                call    ds:MFTClose
                retn
ShareEnd        endp


; =============== S U B R O U T I N E =======================================


ShareEnter      proc near               ; ...
                push    cx

loc_C676:                               ; ...
                mov     cx, ds:1Ah

loc_C67A:                               ; ...
                les     di, ds:59Eh
                xor     ax, ax
                push    cx
                mov     es:[di+33h], ax
                call    sub_C62A
                pop     cx
                jnb     short loc_C695
                call    Idle
                loop    loc_C67A
                call    SHARE_VIOLATION
                jnb     short loc_C676

loc_C695:                               ; ...
                pop     cx
                retn
ShareEnter      endp


; =============== S U B R O U T I N E =======================================


sub_C697        proc near               ; ...
                mov     si, dx
                test    word ptr [si+2], 1
                jz      short loc_C6B8
                mov     ax, [si+8]
                add     ax, 10h
                mov     es, ax
                mov     cx, [si+0Ah]
                mov     ax, [si+0Ch]
                call    word ptr ss:0D67h
                call    word ptr ss:133Eh

loc_C6B8:                               ; ...
                test    word ptr [si+2], 2
                jnz     short loc_C6D7
                push    ds
                push    si
                lds     si, [si+4]
                call    sub_B35C
                call    sub_B370
                pop     si
                pop     ds
                mov     es, word ptr [si+8]
                mov     ax, ss:0EBBh
                mov     es:40h, ax

loc_C6D7:                               ; ...
                cmp     byte ptr ss:0D66h, 0
                jz      short loc_C6FF
                mov     ax, [si+8]
                or      byte ptr ss:86h, 4
                test    word ptr [si+2], 1
                jnz     short loc_C6F6
                push    ds
                mov     ds, ax
                call    IsCopyProt
                pop     ds

loc_C6F6:                               ; ...
                inc     byte ptr ss:85h
                mov     ss:63h, ax

loc_C6FF:                               ; ...
                xor     ax, ax
                retn
sub_C697        endp

; ---------------------------------------------------------------------------
                db 0FAh
                db 0E4h
                db  21h ; !
                db  60h ; `
                db  33h ; 3
                db 0C0h
                db 0E6h
                db  43h ; C
                db  8Bh
                db  16h
                db 0B0h
                db  0Eh
                db 0E6h
                db  37h ; 7
                db  33h ; 3
                db 0C0h
                db 0E6h
                db 0F2h
                db  0Fh
                db  20h
                db 0C0h
                db  0Fh
                db  22h ; "
                db 0C0h
                db 0EAh
                db  66h ; f
                db  50h ; P
                db  51h ; Q
                db  0Fh
                db  20h
                db 0C0h
                db  8Eh
                db 0D3h
                db  59h ; Y
                db  66h ; f
                db  58h ; X
                db  93h
                db  58h ; X
                db  8Bh
                db 0CCh
                db 0B8h
                db  0Ch
                db 0DEh
                db 0CDh
                db  67h ; g
                db  8Bh
                db 0E1h
                db 0FFh
                db 0E3h
                db  93h
                db  58h ; X
                db  8Bh
                db 0CCh
                db  2Eh ; .
                db  66h ; f
                db 0A3h
                db    0
                db    0
                db  2Eh ; .
                db  66h ; f
                db  89h
                db  36h ; 6
                db    0
                db    0
                db  8Bh
                db 0E1h
                db  2Eh ; .
                db  66h ; f
                db 0A1h
                db    0
                db    0
                db  2Eh ; .
                db  66h ; f
                db  8Bh
                db  36h ; 6
                db    0
                db    0
                db 0FFh
                db 0E3h
                db 0FAh, 52h, 51h
                db 0B8h, 0Ch, 0DEh, 66h, 26h, 0FFh, 1Eh
                db 59h, 5Ah, 5Bh
                db 0FAh, 66h, 50h, 66h, 53h, 66h, 51h, 66h, 52h
                db 66h, 5Ah, 66h, 59h, 66h, 5Bh, 66h, 58h, 5Bh
                db 60h, 6, 1Eh, 0B8h, 0, 0, 8Eh, 0D8h
                db 1Fh, 7, 61h
                db 66h, 60h, 6, 1Eh
                db 1Fh, 7, 66h, 61h, 0C3h
                dw 0C714h
                dw 3
                dw 0C717h
                dw 4
                dw 20h
                dw 0C726h
                dw 4
                dw 0C72Ah
                dw 9
                dw 80h
                dw 0C751h
                dw 3
                dw 0C754h
                dw 7
                dw 80h
                dw 0C770h
                dw 4
                dw 0C778h
                dw 3
                dw 80h
; ---------------------------------------------------------------------------

Rational386Patch:                       ; ...
                cmp     word ptr es:0, 395
                jnb     short locret_C7D7
                cmp     word ptr es:0Ch, 20h ; ' '
                jnz     short locret_C7D7
                push    ax
                mov     ax, 18h
                cmp     es:18h, ax
                jnz     short loc_C7D6
                cmp     es:1Ch, ax
                jnz     short loc_C7D6
                cmp     es:24h, ax
                jz      short rp3Maybe

loc_C7D6:                               ; ...
                pop     ax

locret_C7D7:                            ; ...
                retn
; ---------------------------------------------------------------------------

rp3Maybe:                               ; ...
                cld
                pusha
                push    es
                push    ds
                sub     sp, 6
                mov     bp, sp
                push    cs
                pop     ds
                assume ds:DOSCODE
                mov     ax, es:0
                mov     [bp+0], ax
                call    sub_C986
                jnz     short loc_C810
                mov     cx, 4500h
                mov     [bp+2], cx
                mov     es, word ptr es:20h
                mov     si, 0C702h
                mov     dx, 0Ah
                call    ScanCodeSeq
                jz      short loc_C813
                mov     si, 0C70Ch
                mov     dx, 8
                call    ScanCodeSeq
                jz      short loc_C813

loc_C810:                               ; ...
                jmp     loc_C911
; ---------------------------------------------------------------------------

loc_C813:                               ; ...
                mov     [bp+4], di
                cmp     word ptr [bp+0], 17Dh
                jnb     short loc_C865
                mov     bx, 0C784h
                call    FindBadCode
                jb      short loc_C865
                push    di
                mov     di, si
                mov     dx, 3
                cmp     byte ptr es:[di-1], 51h ; 'Q'
                jnz     short loc_C834
                dec     di
                inc     dx

loc_C834:                               ; ...
                mov     si, 0C71Bh
                mov     cx, 6
                call    GenPatch
                pop     di
                cmp     byte ptr es:[di-1], 59h ; 'Y'
                jnz     short loc_C84A
                mov     byte ptr es:[di-1], 90h

loc_C84A:                               ; ...
                mov     ax, [bp+4]
                mov     es:[di+4], ax
                push    di
                mov     si, 0C721h
                mov     cx, 5
                call    CopyPatch
                pop     bx
                add     bx, 8
                call    GenJump
                mov     [bp+4], di

loc_C865:                               ; ...
                mov     bx, 0C78Eh
                call    FindBadCode
                jb      short loc_C8AF
                push    word ptr [bp+4]
                push    di
                mov     di, si
                mov     dx, 4
                mov     si, 0C733h
                mov     cx, 0Fh
                call    GenPatch
                pop     di
                add     di, 5
                mov     bx, [bp+4]
                push    bx
                call    GenJump
                mov     si, 0C742h
                mov     cx, 0Fh
                call    CopyPatch
                pop     di
                pop     si
                mov     ax, [bp+4]
                mov     es:[si+7], ax
                mov     es:[di+5], ax
                add     ax, 4
                mov     es:[si+0Dh], ax
                mov     es:[di+0Bh], ax
                add     word ptr [bp+4], 8

loc_C8AF:                               ; ...
                mov     bx, 0C798h
                call    FindBadCode
                jb      short loc_C8E3
                add     di, 9
                push    si
                mov     si, 0C75Bh
                mov     dx, 3
                call    ScanCodeSeq_di
                pop     si
                jnz     short loc_C8E3
                push    di
                mov     di, si
                mov     dx, 3
                mov     si, 0C75Eh
                mov     cx, 9
                call    GenPatch
                pop     di
                mov     dx, 3
                mov     si, 0C767h
                mov     cx, 9
                call    GenPatch

loc_C8E3:                               ; ...
                cmp     word ptr [bp+0], 168h
                jbe     short loc_C911
                mov     bx, 0C7A2h
                call    FindBadCode
                jb      short loc_C911
                push    di
                mov     di, si
                mov     dx, 3
                mov     si, 0C77Bh
                mov     cx, 4
                call    GenPatch
                pop     di
                mov     bx, [bp+4]
                call    GenJump
                mov     si, 0C77Fh
                mov     cx, 5
                call    CopyPatch

loc_C911:                               ; ...
                add     sp, 6
                pop     ds
                assume ds:nothing
                pop     es
                popa
                pop     ax
                retn

; =============== S U B R O U T I N E =======================================


FindBadCode     proc near               ; ...
                mov     cx, [bp+2]
                mov     si, [bx]
                mov     dx, [bx+2]
                call    ScanCodeSeq
                jnz     short fbc_error
                push    di
                mov     si, [bx+4]
                mov     dx, [bx+6]
                call    ScanCodeSeq_di
                pop     si
                jnz     short fbc_error
                mov     ax, di
                sub     ax, si
                jb      short fbc_error
                cmp     ax, [bx+8]
                ja      short fbc_error
                clc
                retn
; ---------------------------------------------------------------------------

fbc_error:                              ; ...
                stc
                retn
FindBadCode     endp


; =============== S U B R O U T I N E =======================================


GenPatch        proc near               ; ...
                push    di
                mov     bx, [bp+4]
                call    GenJump
                call    CopyPatch
                pop     bx
                add     bx, dx
                call    GenJump
                mov     [bp+4], di
                retn
GenPatch        endp


; =============== S U B R O U T I N E =======================================


CopyPatch       proc near               ; ...
                push    cx
                mov     di, [bp+4]
                cld
                rep movsb
                pop     cx
                mov     [bp+4], di
                retn
CopyPatch       endp


; =============== S U B R O U T I N E =======================================


GenJump         proc near               ; ...
                mov     al, 0E9h
                stosb
                mov     ax, bx
                sub     ax, di
                sub     ax, 2
                stosw
                retn
GenJump         endp


; =============== S U B R O U T I N E =======================================


ScanCodeSeq     proc near               ; ...
                mov     di, 200h

ScanCodeSeq_di:                         ; ...
                push    cx
                sub     cx, dx
                inc     cx

scsagain:                               ; ...
                push    si
                push    di
                push    cx
                mov     cx, dx
                repe cmpsb
                pop     cx
                pop     di
                pop     si
                jz      short scsfound
                inc     di
                loop    scsagain

scsfound:                               ; ...
                pop     cx
                retn
ScanCodeSeq     endp


; =============== S U B R O U T I N E =======================================


sub_C986        proc near               ; ...
                mov     si, es:2Ah
                mov     bl, 0Ah
                add     si, 3
                call    sub_C9A5
                jnz     short locret_C9A4
                call    sub_C9A5
                jnz     short locret_C9A4
                cmp     byte ptr es:[si], 2Eh ; '.'
                jnz     short locret_C9A4
                dec     si
                call    sub_C9A5

locret_C9A4:                            ; ...
                retn
sub_C986        endp


; =============== S U B R O U T I N E =======================================


sub_C9A5        proc near               ; ...
                div     bl
                add     ah, 30h ; '0'
                dec     si
                cmp     es:[si+1], ah
                mov     ah, 0
                retn
sub_C9A5        endp

; ---------------------------------------------------------------------------

exepatch_start:                         ; ...
                push    es
                mov     ax, ds
                sub     ax, dx
                mov     ds, ax
                mov     es, ax
                mov     di, 0Fh
                push    di
                mov     cx, 10h
                mov     al, 0FFh
                repe scasb
                inc     di
                mov     si, di
                pop     di
                pop     ax
                sub     ax, dx
                mov     es, ax

loc_C9CF:                               ; ...
                mov     cx, 204h

loc_C9D2:                               ; ...
                mov     ax, si
                not     ax
                shr     ax, cl
                jz      short loc_C9ED
                mov     dx, ds
                or      si, 0FFF0h
                sub     dx, ax
                jnb     short loc_C9EB
                neg     dx
                shl     dx, cl
                sub     si, dx
                xor     dx, dx

loc_C9EB:                               ; ...
                mov     ds, dx
                assume ds:DOSCODE

loc_C9ED:                               ; ...
                xchg    si, di
                push    ds
                push    es
                pop     ds
                assume ds:nothing
                pop     es
                dec     ch
                jnz     short loc_C9D2
                lodsb
                xchg    ax, dx
                dec     si
                lodsw
                mov     cx, ax
                inc     si
                mov     al, dl
                and     al, 0FEh
                cmp     al, 0B0h
                jnz     short loc_CA0B
                lodsb
                rep stosb
                jmp     short loc_CA11
; ---------------------------------------------------------------------------

loc_CA0B:                               ; ...
                cmp     al, 0B2h
                jnz     short near ptr loc_CA7A+1
                rep movsb

loc_CA11:                               ; ...
                xchg    ax, dx
                test    al, 1
                jz      short loc_C9CF
                nop
                nop
                mov     bx, es
                mov     ax, ds
                sub     ax, dx
                mov     ds, ax
                mov     es, ax
                mov     di, 0Fh
                mov     cx, 10h
                mov     al, 0FFh
                repe scasb
                inc     di
                mov     si, di
                mov     ax, bx
                sub     ax, dx
                mov     es, ax
                mov     di, 0Fh
                mov     cl, 4
                mov     ax, si
                not     ax
                shr     ax, cl
                jz      short loc_CA4B
                mov     dx, ds
                sub     dx, ax
                mov     ds, dx
                assume ds:nothing
                or      si, 0FFF0h

loc_CA4B:                               ; ...
                mov     ax, di
                not     ax
                shr     ax, cl
                jz      short loc_CA5C
                mov     dx, es
                sub     dx, ax
                mov     es, dx
                assume es:nothing
                or      di, 0FFF0h

loc_CA5C:                               ; ...
                mov     bx, es
                mov     ax, ds
                dec     ax
                mov     ds, ax
                assume ds:nothing
                mov     es, ax
                mov     di, 0Fh
                mov     cx, 10h
                mov     al, 0FFh
                repe scasb
                inc     di
                mov     si, di
                mov     ax, bx
                dec     ax
                mov     es, ax
                assume es:nothing
                mov     di, 0Fh

loc_CA7A:                               ; ...
                mov     cl, 4
                mov     ax, si
                not     ax
                shr     ax, cl
                jz      short loc_CA8E
                mov     dx, ds
                sub     dx, ax
                mov     ds, dx
                assume ds:nothing
                or      si, 0FFF0h

loc_CA8E:                               ; ...
                mov     ax, di
                not     ax
                shr     ax, cl
                jz      short loc_CAA0
                mov     dx, es
                sub     dx, ax
                mov     es, dx
                assume es:nothing
                or      di, 0FFF0h

loc_CAA0:                               ; ...
                mov     bx, es
                mov     ax, ds
                dec     ax
                mov     ds, ax
                assume ds:nothing
                mov     es, ax
                assume es:nothing
                mov     di, 0Fh
                mov     cx, 10h
                mov     al, 0FFh
                repe scasb
                inc     di
                mov     si, di
                mov     ax, bx
                dec     ax
                mov     es, ax
                assume es:nothing
                mov     di, 0Fh
                mov     cl, 4
                mov     ax, si
                not     ax
                shr     ax, cl
                jz      short loc_CAD1
                mov     dx, ds
                sub     dx, ax
                mov     ds, dx
                assume ds:nothing
                or      si, 0FFF0h

loc_CAD1:                               ; ...
                mov     ax, di
                not     ax
                shr     ax, cl
                jz      short scan_com
                mov     dx, es
                sub     dx, ax
                mov     es, dx
                assume es:nothing
                or      di, 0FFF0h

scan_com:                               ; ...
                lodsb
                mov     dl, al
                dec     si
                lodsw
                mov     cx, ax
                inc     si
                mov     al, dl
                and     al, 0FEh
                cmp     al, 0B0h
                jnz     short loc_CAF8
                lodsb
                rep stosb
                jmp     short loc_CAFE
; ---------------------------------------------------------------------------
                nop

loc_CAF8:                               ; ...
                cmp     al, 0B2h
                jnz     short near ptr loc_CB66+1
                rep movsb

loc_CAFE:                               ; ...
                mov     al, dl
                test    al, 1
                call    sub_CB0B
                call    word ptr ss:0D69h
                retn

; =============== S U B R O U T I N E =======================================


sub_CB0B        proc near               ; ...
                push    bx
                mov     bx, es
                cmp     bx, 0FFFh
                jbe     short loc_CB16
                pop     bx
                retn
; ---------------------------------------------------------------------------

loc_CB16:                               ; ...
                push    ds
                push    es
                push    ax
                push    cx
                push    si
                push    di
                sub     cx, 2
                jnb     short loc_CB24
                jmp     loc_CBDA
; ---------------------------------------------------------------------------

loc_CB24:                               ; ...
                mov     di, cx
                mov     es, ax
                assume es:nothing
                mov     ss:87h, di
                cmp     word ptr es:[di], 4252h
                jz      short loc_CB37
                jmp     loc_CBDA
; ---------------------------------------------------------------------------

loc_CB37:                               ; ...
                push    cs
                pop     ds
                assume ds:DOSCODE
                add     di, 6Ch ; 'l'
                call    sub_CBE2
                jnz     short loc_CB63
                mov     si, 0CA18h
                mov     di, ss:87h
                add     di, 28h ; '('
                mov     cl, 44h ; 'D'
                mov     bx, 8Eh
                mov     ax, 0EF4Eh
                call    chk_patchsum
                jb      short loc_CB60
                mov     si, 0C9B2h
                mov     cl, 66h ; 'f'
                rep movsb

loc_CB60:                               ; ...
                jmp     short loc_CBDA
; ---------------------------------------------------------------------------
                nop

loc_CB63:                               ; ...
                mov     di, 76h ; 'v'

loc_CB66:                               ; ...
                call    sub_CBE2
                jnz     short loc_CBA8
                mov     si, 0CA5Ch
                mov     di, 32h ; '2'
                mov     cl, 44h ; 'D'
                mov     bx, 8Ch
                mov     ax, 78B2h
                call    chk_patchsum
                jnb     short loc_CB8E
                mov     si, 0CA5Ch
                mov     cl, 44h ; 'D'
                mov     bx, 81h
                mov     ax, 1C47h
                call    chk_patchsum
                jb      short loc_CBDA

loc_CB8E:                               ; ...
                mov     si, 0C9B2h
                mov     cl, 3
                rep movsb
                mov     ax, 4890h
                stosw
                inc     si
                inc     si
                mov     cl, 14h
                rep movsb
                stosw
                inc     si
                inc     si
                mov     cl, 4Bh ; 'K'
                rep movsb
                jmp     short loc_CBDA
; ---------------------------------------------------------------------------

loc_CBA8:                               ; ...
                mov     di, 74h ; 't'
                call    sub_CBE2
                jnz     short loc_CBDA
                mov     si, 0CAA0h
                mov     di, 32h ; '2'
                mov     cl, 42h ; 'B'
                mov     bx, 8Bh
                mov     ax, 4EDEh
                call    chk_patchsum
                jb      short loc_CBDA
                mov     si, 0C9B2h
                mov     cl, 3
                rep movsb
                mov     al, 48h ; 'H'
                stosb
                inc     si
                inc     si
                mov     cl, 14h
                rep movsb
                stosb
                inc     si
                inc     si
                mov     cl, 4Bh ; 'K'
                rep movsb

loc_CBDA:                               ; ...
                pop     di
                pop     si
                pop     cx
                pop     ax
                pop     es
                pop     ds
                assume ds:nothing
                pop     bx
                retn
sub_CB0B        endp


; =============== S U B R O U T I N E =======================================


sub_CBE2        proc near               ; ...
                mov     si, offset scan_com
                mov     cx, 32
                repe cmpsb
                jz      short ccs_done
                cmp     byte ptr es:[di-1], 56h ; 'V'
                jnz     short ccs_done
                repe cmpsb

ccs_done:                               ; ...
                retn
sub_CBE2        endp


; =============== S U B R O U T I N E =======================================


chk_patchsum    proc near               ; ...
                push    di
                repe cmpsb
                jnz     short loc_CC14
                mov     di, ss:87h
                mov     cx, bx
                mov     bx, ax
                xor     ax, ax

loc_CC06:                               ; ...
                add     ax, es:[di]
                inc     di
                inc     di
                loop    loc_CC06
                pop     di
                cmp     ax, bx
                jnz     short loc_CC14
                clc
                retn
; ---------------------------------------------------------------------------

loc_CC14:                               ; ...
                stc
                retn
chk_patchsum    endp ; sp-analysis failed

; ---------------------------------------------------------------------------
RScanPattern1   db 0, 0, 20h, 0, 0, 0, 40h, 0
                db 1, 0
                db 8Bh, 0Eh, 10h, 0, 90h, 0E2h, 0FEh, 0E8h
                db 8Bh, 0Eh, 10h, 0, 0E2h, 0FEh, 0E8h
; ---------------------------------------------------------------------------

RationalPatch:
                cld
                pusha
                push    es
                push    ds
                mov     di, 0Ah
                push    cs
                pop     ds
                assume ds:DOSCODE
                mov     si, 0CC16h
                mov     cx, 0Ah
                repe cmpsb
                jnz     short loc_CC8C
                mov     ax, es:0
                cmp     ax, 15Ch
                jb      short loc_CC8C
                cmp     ax, 17Fh
                ja      short loc_CC8C
                call    sub_C986
                jnz     short loc_CC8C
                mov     cx, es:16h
                sub     cx, 200h
                mov     es, word ptr es:20h
                mov     si, 0CC20h
                mov     dx, 8
                call    ScanCodeSeq
                jz      short loc_CC79
                mov     si, 0CC28h
                mov     dx, 0Fh
                call    ScanCodeSeq
                jnz     short loc_CC8C

loc_CC79:                               ; ...
                mov     al, 9Ah
                stosb
                mov     ax, 1126h
                stosw
                mov     ax, ss
                stosw
                mov     cx, dx
                sub     cx, 6
                mov     al, 90h
                rep stosb

loc_CC8C:                               ; ...
                pop     ds
                assume ds:nothing
                pop     es
                popa
                retn
; ---------------------------------------------------------------------------
                db 89h, 26h, 48h, 1
                db 8Ch, 0Eh, 4Ch, 1
                db 0C7h, 6, 4Ah, 1, 0, 1
                db 8Ch, 0Eh, 13h, 1
                db 0B8h, 20h, 1
                db 0BEh, 0, 1

; =============== S U B R O U T I N E =======================================


IsCopyProt      proc near               ; ...
                cmp     word ptr ds:11Bh, 5343h
                jnz     short CP_done
                cmp     word ptr ds:173h, 5044h
                jnz     short CP_done
                cmp     word ptr ds:146h, 0F413h
                jnz     short CP_done
                cmp     word ptr ds:124h, 8000h
                jnz     short CP_done
                push    cs
                pop     es
                assume es:DOSCODE
                mov     di, 0CC90h
                mov     si, 175h
                mov     cx, 18h
                repe cmpsb
                jnz     short CP_done
                mov     byte ptr ss:85h, 0Ah

CP_done:                                ; ...
                retn
IsCopyProt      endp

; ---------------------------------------------------------------------------

initiret:                               ; ...
                iret
; ---------------------------------------------------------------------------
InitBioDataSeg  dw 70h                  ; ...

; =============== S U B R O U T I N E =======================================


ParaRound       proc near               ; ...
                add     ax, 0Fh
                rcr     ax, 1
                shr     ax, 1
                shr     ax, 1
                shr     ax, 1
                retn
ParaRound       endp


; =============== S U B R O U T I N E =======================================


WhatCPUType     proc near               ; ...
                pushf
                push    bx
                xor     bx, bx
                xor     ax, ax
                push    ax
                popf
                pushf
                pop     ax
                and     ax, 0F000h
                cmp     ax, 0F000h
                jz      short loc_CD0D
                mov     ax, 0F000h
                push    ax
                popf
                pushf
                pop     ax
                and     ax, 0F000h
                jz      short loc_CD0C
                inc     bx

loc_CD0C:                               ; ...
                inc     bx

loc_CD0D:                               ; ...
                mov     ax, bx
                pop     bx
                popf
                retn
WhatCPUType     endp

; ---------------------------------------------------------------------------

DOSINIT:                                ; ...
                cli
                cld
                push    dx              ; top of memory (memory size in paragraphs)
                push    si              ; 0
                push    ds              ; IBMDOS.SYS loading segment
                push    di              ; 0
                mov     bx, es          ; CURRENT_DOS_LOCATION (segment)
                mov     ax, 0D20Fh      ; MEMSTRT ; get offset of end of init code
                add     ax, 0Fh         ; round up
                and     ax, 0FFF0h
                mov     si, ax          ; DOSDATA segment offset in IBMDOS.SYS
                push    cs
                pop     ds              ; DOSCODE segment
                assume ds:DOSCODE
                mov     es, cs:InitBioDataSeg ; BIOSDATA segment (always 0070h)
                assume es:nothing
                mov     es, word ptr es:3 ; DOSDATA segment ptr
                assume es:DOSCODE
                xor     di, di          ; offset 0
                mov     cx, 1346h       ; DOSDATA size (4934 bytes)
                rep movsb
                pop     di
                pop     ds
                assume ds:nothing
                pop     si
                pop     dx
                push    es
                push    ds
                pop     es
                assume es:nothing
                pop     ds
                mov     ds:BiosComBlockPtr, di ; CURRENT_DOS_LOCATION (offset = 0)
                mov     ds:BiosComBlockPtr+2, bx ; CURRENT_DOS_LOCATION (segment)
                mov     cs:DosDSeg, ds
                mov     cs:LowInt23_SEG, ds
                mov     cs:LowInt24_SEG, ds
                mov     cs:LowInt28_SEG, ds
                mov     ds:ENDMEM, dx
                mov     ds:USER_SP, sp
                mov     ds:USER_SS, ss
                push    ds
                pop     ss
                mov     sp, offset DSKSTACK ; "@#IBM:12.01.2003.build_1.32#@ IBMDOS.CO"...
                mov     ax, offset RetExePatch
                mov     ds:FixExePatch, ax
                mov     ds:UnknownPatch, ax
                mov     ds:ChkCopyProt, ax
                call    WhatCPUType
                cmp     al, 2
                mov     ax, offset Rational386Patch
                jnb     short di_set_patch
                mov     ax, offset RetExePatch

di_set_patch:                           ; ...
                mov     ds:Rational386PatchPtr, ax
                mov     ax, cs
                mov     ds:TEMP_DOSLOC, ax
                mov     ds:NULDEV+2, es
                mov     ds:NULDEV, si
                mov     ds:Instance_Data_Ptr+2, ds
                push    si
                mov     cx, 7
                mov     si, offset InsTBL_CONTPOS_seg

Instance_init_loop:                     ; ...
                mov     word ptr [si], ds
                add     si, 6
                loop    Instance_init_loop
                mov     cx, 5
                mov     si, offset OldInstanceJunk_6

OldInstance_init_loop:                  ; ...
                mov     word ptr [si], ds
                add     si, 6
                loop    OldInstance_init_loop
                pop     si
                push    es
                pop     ds
                push    ds
                xor     ax, ax
                mov     ds, ax
                assume ds:DOSCODE
                mov     ax, 0CCDEh
                mov     word ptr 0:0A8h, ax
                mov     ax, cs
                mov     word ptr 0:0A8+2, ax
                pop     ds
                assume ds:nothing
                call    CHARINIT
                push    si
                push    ss
                pop     es
                mov     di, offset SFT0_SFTable
                mov     ax, 3
                stosw                   ; SF_ENTRY.sf_ref_count
                dec     al
                stosw                   ; .sf_mode
                xor     al, al
                stosb                   ; .sf_attr
                mov     al, 0C3h
                stosw                   ; .sf_flags
                mov     ax, si
                stosw                   ; .sf_devptr
                mov     ax, ds
                stosw                   ; SFT0_SFTable + 9 ; .sf_devptr_hw
                xor     ax, ax          ; 0
                add     di, 32
                stosw                   ; SFT0_SFTable + 43 ; .sf_position
                stosw                   ; .sf_position_hw
                add     di, -34         ; 0FFDEh
                stosw                   ; SFT0_SFTable + 13 ; .sf_firclus
                stosw                   ; .sf_firclus_hw
                dec     ax              ; -1
                stosw                   ; SFT0_SFTable + 17 ; .sf_time
                stosw                   ; .sf_date
                inc     ax              ; 0
                stosw                   ; SFT0_SFTable + 21 ; .sf_size
                stosw                   ; .sf_size_hw
                add     di, 7           ; SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
                                        ; SFT0_SFTable + 32
                add     si, 10          ; SYSDEV.NAME
                mov     cx, 4
                rep movsw
                mov     cl, 3
                mov     al, 20h ; ' '
                rep stosb               ; SFT0_SFTable + 40
                pop     si
                or      byte ptr [si+4], 3 ; ISCIN|ISCOUT
                mov     word ptr ss:BCON, si
                mov     word ptr ss:BCON+2, ds

CHAR_INIT_LOOP:                         ; ...
                lds     si, [si]
                call    CHARINIT
                test    byte ptr [si+4], 8
                jz      short CHAR_INIT_LOOP
                mov     word ptr ss:BCLOCK, si
                mov     word ptr ss:BCLOCK+2, ds
                mov     bp, 1346h       ; MEMSTRT ; ES:BP points to DPB
                mov     word ptr ss:DPBHEAD, bp
                mov     word ptr ss:DPBHEAD+2, es

PERDRV:                                 ; ...
                lds     si, [si]
                cmp     si, 0FFFFh
                jnz     short PERDRV2
                jmp     CONTINIT
; ---------------------------------------------------------------------------

PERDRV2:                                ; ...
                call    CHARINIT
                test    word ptr [si+4], 8000h ; [SI+SYSDEV.ATT],DEVTYP
                jnz     short PERDRV
                mov     cl, ss:CALLUNIT
                xor     ch, ch
                mov     [si+10], cl     ; [si+SYSDEV.NAME]
                mov     dl, ss:NUMIO
                xor     dh, dh
                add     ss:NUMIO, cl
                push    ds
                push    si
                lds     bx, dword ptr ss:CALLBPB

PERUNIT:                                ; ...
                mov     si, [bx]        ; DS:SI Points to BPB
                inc     bx
                inc     bx
                mov     es:[bp+0], dl   ; DPB.DRIVE
                mov     es:[bp+1], dh   ; DPB.UNIT
                push    bx
                push    cx
                push    dx
                mov     dx, 4152h       ; 'RA'
                xor     cx, cx          ; 0
                mov     es:[bp+29], cx
                cmp     [si+11], cx     ; BPB_FATSz16
                jnz     short PERUNIT2  ; FAT (FAT12 or FAT16) -old DPB-
                mov     es:[bp+57], cx  ; FAT32 -new- DPB
                mov     es:[bp+59], cx
                dec     cx
                mov     es:[bp+31], cx
                mov     es:[bp+33], cx
                mov     cx, 4558h       ; 'XE'

PERUNIT2:                               ; ...
                call    $SETDPB
                mov     ax, es:[bp+2]
                cmp     ax, ss:MAXSEC
                jbe     short NOTMAX
                mov     ss:MAXSEC, ax

NOTMAX:                                 ; ...
                mov     ax, bp
                add     ax, 61          ; next DPB (PCDOS 7.1 DPB size = 61)
                mov     es:[bp+25], ax  ; DPB.NEXT_DPB offset
                mov     word ptr es:[bp+27], es ; DPB.NEXT_DPB segment
                mov     byte ptr es:[bp+24], 0FFh ; DPB.FIRST_ACCESS = -1
                pop     dx
                pop     cx
                pop     bx
                mov     ax, ds
                pop     si
                pop     ds
                mov     es:[bp+19], si  ; DPB.DRIVER_ADDR offset
                mov     word ptr es:[bp+21], ds ; DPB.DRIVER_ADDR segment
                push    ds
                push    si
                inc     dh
                inc     dl
                mov     ds, ax
                add     bp, 61          ; DPBSIZ
                loop    PERUNIT
                pop     si
                pop     ds
                jmp     PERDRV
; ---------------------------------------------------------------------------

CONTINIT:                               ; ...
                sub     bp, 61          ; sub bp,DPBSIZ ; back up to last dpb
                mov     ax, 0FFFFh
                mov     [bp+25], ax     ; [bp+DPB.NEXT_DPB],-1
                mov     [bp+27], ax
                add     bp, 61
                push    ss
                pop     ds
                mov     ax, bp
                call    ParaRound
                mov     dx, ds
                add     dx, ax
                mov     bx, 0Fh
                mov     cx, ds:ENDMEM
                mov     ds:DOSSEG_INIT, ds ; [DSKCHRET+3]
                push    dx
                mov     ax, ds:TEMP_DOSLOC
                mov     es, ax
                mov     ds:TEMP_DOSLOC, 0FFFFh
                call    patch_vec_segments
                call    patch_misc_segments
                mov     ds:TEMP_DOSLOC, es
                pop     dx
                xor     ax, ax
                mov     ds, ax
                assume ds:DOSCODE
                mov     es, ax          ; 0
                assume es:DOSCODE
                mov     di, 90h         ; INT 24h vector
                                        ; addr_int_fatal_abort
                mov     ax, ss:TEMP_DOSLOC
                mov     [di+2], ax      ; segment
                mov     di, 82h         ; INTBASE+2
                mov     word ptr 0, offset DIVOV
                mov     di, 80h         ; INTBASE
                mov     ax, offset irett
                mov     cx, 9

iset1:                                  ; ...
                stosw
                inc     di
                inc     di
                loop    iset1
                add     di, 4
                mov     cx, 6

iset2:                                  ; ...
                stosw
                inc     di
                inc     di
                loop    iset2
                add     di, 8
                mov     cx, 14

iset3:                                  ; ...
                stosw
                inc     di
                inc     di
                loop    iset3
                mov     word ptr 00BCh, offset INT2F ; mov word [02Fh*4],INT2F
                mov     ax, ss:TEMP_DOSLOC
                mov     word ptr 00BEh, ax
                mov     byte ptr 00C0h, 0EAh ; mov byte [ENTRYPOINT],mi_long_jmp
                mov     word ptr 00C1h, offset CALL_ENTRY ; mov word [ENTRYPOINT+1],CALL_ENTRY
                mov     word ptr 0080h, offset QUIT ; mov word [addr_int_abort],QUIT
                mov     word ptr 0084h, offset COMMAND ; mov word [addr_int_command],COMMAND
                mov     word ptr 0088h, 100h ; mov word [addr_int_terminate],100h
                mov     word ptr 008Ah, dx ; mov word [addr_int_terminate+2],dx
                mov     word ptr 0094h, offset ABSDRD ; mov word [addr_int_disk_read],ABSDRD
                mov     word ptr 0098h, offset ABSDWRT ; mov word [addr_int_disk_write],ABSDWRT
                mov     word ptr 009Ch, offset stay_resident ; mov word [addr_int_keep_process],STAY_RESIDENT
                push    ss
                pop     ds
                assume ds:nothing
                push    ss
                pop     es
                assume es:nothing
                push    dx
                inc     dx
                mov     ds:CurrentPDB, dx
                xor     di, di
                mov     es, dx
                xor     ax, ax
                mov     cx, 128
                rep stosw
                mov     ax, ds:ENDMEM
                call    SETMEM
                push    ss
                pop     ds
                mov     di, 24          ; PDB.JFN_TABLE
                xor     ax, ax
                stosw
                stosb
                mov     al, 0FFh
                mov     cx, 17          ; FILPERPROC-3
                rep stosb
                push    ss
                pop     es
                mov     word ptr ds:SFT_ADDR+2, ds
                mov     si, offset SysInitTable
                mov     word ptr es:[si+6], es ; [es:si+SYSI_EXT.Country_Tab+2]
                mov     word ptr es:[si+2], es ; [es:si+SYSI_EXT.SysInitVars+2]
                mov     word ptr es:BUFFHEAD+2, es
                mov     si, offset BufferQueue
                mov     word ptr es:BUFFHEAD, si
                pop     dx
                mov     word ptr ds:DMAADD+2, dx
                mov     es:arena_head, dx
                mov     ds, dx
                mov     byte ptr ds:0, 5Ah ; 'Z' ; [ARENA.SIGNATURE],arena_signature_end
                mov     word ptr ds:1, 0 ; [ARENA.OWNER],arena_owner_system
                mov     ax, ss:ENDMEM
                sub     ax, dx
                dec     ax
                mov     ds:3, ax
                mov     di, offset SFT0_SFTable ; SFTABL+SFT.SFTable
                mov     ax, 3
                stosw
                mov     di, offset SysInitTable
                inc     dx
                mov     ds, dx
                mov     dx, offset _seg_reinit
                mov     cx, offset exepatch_start
                sub     cx, offset $STARTCODE ; sub cx, 3F10h
                                        ; cx = (doscode - exepatch) - dosinit
                mov     ax, offset initiret ; SYSBUF
                sub     ax, offset $STARTCODE ; sub ax, 3F10h
                                        ; ax = size of doscode - dosinit
                mov     sp, ss:USER_SP
                mov     ss, ss:USER_SS
                retf

; =============== S U B R O U T I N E =======================================


CHARINIT        proc near               ; ...
                mov     ss:DEVCALL_REQLEN, 25 ; 19h
                mov     ss:DEVCALL_REQUNIT, 0
                mov     ss:DEVCALL_REQFUNC, 0
                mov     ss:DEVCALL_REQSTAT, 0
                push    es
                push    bx
                push    ax
                mov     bx, offset DEVCALL_REQLEN ; offset DEVCALL
                push    ss
                pop     es
                call    DEVIOCALL2
                pop     ax
                pop     bx
                pop     es
                retn
CHARINIT        endp


; =============== S U B R O U T I N E =======================================


check_XMM       proc near               ; ...
                push    ax
                mov     ax, 4300h
                int     2Fh             ; - Multiplex - XMS - INSTALLATION CHECK
                                        ; Return: AL = 80h XMS driver installed
                                        ; AL <> 80h no driver
                cmp     al, 80h
                jnz     short cXMM_no_driver
                push    bx
                push    dx
                push    ds
                push    es
                mov     ax, 4310h
                int     2Fh             ; - Multiplex - XMS - GET DRIVER ADDRESS
                                        ; Return: ES:BX -> driver entry point
                mov     ds, cs:DosDSeg
                mov     word ptr ds:XMMcontrol, bx
                mov     word ptr ds:XMMcontrol+2, es

cXMMexit:
                clc
                pop     es
                pop     ds
                pop     dx
                pop     bx
                pop     ax
                retn
; ---------------------------------------------------------------------------

cXMM_no_driver:                         ; ...
                stc
                pop     ax
                retn
check_XMM       endp

; ---------------------------------------------------------------------------
byte_D07D       db 0                    ; ...
; ---------------------------------------------------------------------------

_seg_reinit:                            ; ...
                push    ds
                mov     ds, cs:DosDSeg
                call    patch_misc_segments
                or      ax, ax
                jnz     short loc_D0D6
                cmp     cs:byte_D07D, al
                jnz     short loc_D09A
                mov     ax, ds
                call    patch_vec_segments
                call    patch_offset

loc_D09A:                               ; ...
                mov     ax, es
                mov     di, 0F7Ah
                mov     cx, 8
                push    ds
                pop     es

loc_D0A4:                               ; ...
                inc     di
                inc     di
                stosw
                loop    loc_D0A4
                cmp     ax, 0F000h
                jb      short loc_D0DB
                call    check_XMM
                jb      short loc_D0DB
                call    patch_in_nops
                mov     byte ptr ds:0D66h, 1
                mov     word ptr ds:0D67h, 0CB02h
                mov     word ptr ds:61h, 0CCA8h
                call    WhatCPUType
                cmp     al, 1
                jnz     short loc_D0DB
                mov     word ptr ds:0D69h, 0CC2Fh
                jmp     short loc_D0DB
; ---------------------------------------------------------------------------

loc_D0D6:                               ; ...
                mov     ax, es
                call    patch_vec_segments

loc_D0DB:                               ; ...
                mov     cs:byte_D07D, 1
                pop     ds
                retf

; =============== S U B R O U T I N E =======================================


patch_vec_segments proc near            ; ...
                push    es
                xor     cx, cx
                mov     es, cx
                assume es:DOSCODE
                mov     di, 82h
                mov     word ptr es:byte_0+2, ax
                inc     cx
                inc     cx

loc_D0F1:                               ; ...
                stosw
                inc     di
                inc     di
                loop    loc_D0F1
                add     di, 4
                stosw
                add     di, 6
                mov     cx, 4

loc_D100:                               ; ...
                stosw
                inc     di
                inc     di
                loop    loc_D100
                add     di, 4
                mov     cx, 6

loc_D10B:                               ; ...
                stosw
                inc     di
                inc     di
                loop    loc_D10B
                add     di, 8
                mov     cx, 0Eh

loc_D116:                               ; ...
                stosw
                inc     di
                inc     di
                loop    loc_D116
                mov     word ptr es:ShCol+3, ax
                pop     es
                assume es:nothing
                retn
patch_vec_segments endp


; =============== S U B R O U T I N E =======================================


patch_misc_segments proc near           ; ...
                push    bx
                push    es
                push    ax
                mov     ax, es
                push    ds
                pop     es
                mov     di, 90h
                mov     bx, ds:0AA3h
                mov     cx, 0Fh

loc_D132:                               ; ...
                inc     di
                inc     di
                cmp     bx, 0FFFFh
                jz      short loc_D13E
                cmp     bx, es:[di]
                jnz     short loc_D13F

loc_D13E:                               ; ...
                stosw

loc_D13F:                               ; ...
                loop    loc_D132
                mov     si, 122Ah
                mov     word ptr [si+4Fh], ds
                mov     word ptr [si+54h], ds
                mov     word ptr [si+59h], ds
                mov     word ptr [si+5Eh], ds
                mov     word ptr [si+80h], ds
                mov     word ptr [si+63h], ds
                mov     si, offset FastOpenTable
                cmp     ds:TEMP_DOSLOC, 0FFFFh
                jz      short loc_D16A
                mov     cx, ds:TEMP_DOSLOC
                cmp     cx, [si+4]
                jnz     short loc_D16D

loc_D16A:                               ; ...
                mov     [si+4], ax

loc_D16D:                               ; ...
                pop     ax
                pop     es
                pop     bx
                retn
patch_misc_segments endp


; =============== S U B R O U T I N E =======================================


patch_offset    proc near               ; ...
                push    es
                xor     ax, ax
                mov     es, ax
                assume es:DOSCODE
                mov     word ptr es:byte_0, offset ldivov
                mov     di, 80h
                mov     ax, offset lirett
                mov     cx, 2

po_iset1:                               ; ...
                stosw
                inc     di
                inc     di
                loop    po_iset1
                add     di, 4
                stosw
                add     di, 6
                mov     cx, 4

po_iset2:                               ; ...
                stosw
                inc     di
                inc     di
                loop    po_iset2
                add     di, 4
                mov     cx, 6

po_iset3:                               ; ...
                stosw
                inc     di
                inc     di
                loop    po_iset3
                add     di, 8
                mov     cx, 14

po_iset4:                               ; ...
                stosw
                inc     di
                inc     di
                loop    po_iset4
                mov     word ptr es:0BCh, offset lint2f
                mov     byte ptr es:0C0h, 0EAh
                mov     word ptr es:0C1h, offset lcall_entry
                mov     word ptr es:80h, offset lquit
                mov     word ptr es:84h, offset lcommand
                mov     word ptr es:94h, offset labsdrd
                mov     word ptr es:98h, offset labsdwrt
                mov     word ptr es:9Ch, offset lstay_resident
                pop     es
                assume es:nothing
                retn
patch_offset    endp

; ---------------------------------------------------------------------------
patch_table     dw offset ldivov        ; ...
                dw offset lquit
                dw offset lcommand
                dw offset labsdrd
                dw offset labsdwrt
                dw offset lstay_resident
                dw offset lint2f
                dw offset lcall_entry

; =============== S U B R O U T I N E =======================================


patch_in_nops   proc near               ; ...
                push    ax
                push    si
                mov     si, offset patch_table
                mov     ax, 9090h
                mov     cx, 8

pin_loop:                               ; ...
                mov     di, cs:[si]
                stosw
                inc     si
                inc     si
                loop    pin_loop
                pop     si
                pop     ax
                retn
patch_in_nops   endp

; ---------------------------------------------------------------------------
                db    0
DOSCODE         ends


                end
