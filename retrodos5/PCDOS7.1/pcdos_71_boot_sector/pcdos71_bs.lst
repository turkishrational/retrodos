seg000:7C00 ;
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
seg000:7C00 ; |           Copyright (c) 2018 Hex-Rays, <support@hex-rays.com>           |
seg000:7C00 ; |                            Freeware version                             |
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ;
seg000:7C00 ; Input SHA256 : 2264920B57D2B9B8C3C5F28AAA7FEE11A9C30C173429C0CE2CC6C8C734F7F866
seg000:7C00 ; Input MD5    : 7636CC73FF4B44BA4E3687793130EC7D
seg000:7C00 ; Input CRC32  : 2C9C7474
seg000:7C00
seg000:7C00 ; ---------------------------------------------------------------------------
seg000:7C00 ; File Name   : C:\Users\HİTEK\Desktop\BOOTSECT.DAT
seg000:7C00 ; Format      : Binary file
seg000:7C00 ; Base Address: 0000h Range: 0000h - 0200h Loaded length: 0200h
seg000:7C00
seg000:7C00                 .386
seg000:7C00                 .model flat
seg000:7C00
seg000:7C00 ; ===========================================================================
seg000:7C00
seg000:7C00 ; Segment type: Pure code
seg000:7C00 seg000          segment byte public 'CODE' use16
seg000:7C00                 assume cs:seg000
seg000:7C00                 ;org 7C00h
seg000:7C00                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:7C00
seg000:7C00 BS_jmpBoot:                             ; Disassembled by Erdogan Tan - June 2023
seg000:7C00                 jmp     short Main
seg000:7C02 ; ---------------------------------------------------------------------------
seg000:7C02                 nop
seg000:7C02 ; ---------------------------------------------------------------------------
seg000:7C03 BS_OEMName      db 'IBM  '              ; Ref: "Microsoft Extensible Firmware Initiative
seg000:7C03                                         ; FAT32 File System Specification"
seg000:7C03                                         ;             fatgen103.doc (fatgen103.pdf)
seg000:7C03                                         ; & PCDOS 7.1 Bootsector file:
seg000:7C03                                         ;             BOOTSECT.DAT - 22/04/2008 19:41
seg000:7C03                                         ; & MSDOS 6.0 Boot Sector source code:
seg000:7C03                                         ;             MSBOOT.ASM - 1991 (31/10/1999 18:26)
seg000:7C08 OSVersion       db '7.1'
seg000:7C0B BPB_BytsPerSec  dw 200h
seg000:7C0D BPB_SecPerClus  db 8
seg000:7C0E BPB_RsvdSecCnt  dw 32
seg000:7C10 BPB_NumFATs     db 2
seg000:7C11 BPB_RootEntCnt  dw 0
seg000:7C13 BPB_TotSec16    dw 0
seg000:7C15 BPB_Media       db 0F8h
seg000:7C16 BPB_FATSz16     dw 0
seg000:7C18 BPB_SecPerTrk   dw 63
seg000:7C1A BPB_NumHeads    dw 255
seg000:7C1C BPB_HiddSec     dd 63
seg000:7C20 BPB_TotSec32    dd 8369802
seg000:7C24 BPB_FATSz32     dd 8166                 ; FAT32 Structure Starting at Offset 36
seg000:7C28 BPB_ExtFlags    dw 0
seg000:7C2A BPB_FSVer       dw 0
seg000:7C2C BPB_RootClus    dd 2
seg000:7C30 BPB_FSInfo      dw 1
seg000:7C32 BPB_BkBootSec   dw 6
seg000:7C34 BPB_Reserved    db 12 dup(  0)
seg000:7C40 BS_DrvNum       db 80h
seg000:7C41 BS_Reserved1    db 0
seg000:7C42 BS_BootSig      db 29h
seg000:7C43 BS_VolID        dd 184607F9h
seg000:7C47 BS_VolLab       db 'NO NAME    '
seg000:7C52 BS_FilSysType   db 'FAT32   '
seg000:7C5A ; ---------------------------------------------------------------------------
seg000:7C5A
seg000:7C5A Main:                                   ; ...
seg000:7C5A                 cli
seg000:7C5B                 xor     ax, ax
seg000:7C5D                 mov     ss, ax
seg000:7C5F                 mov     sp, 7BECh       ; STACK (BootSectorOffset-20)
seg000:7C62                 push    ss
seg000:7C63                 pop     es
seg000:7C64                 mov     bp, sp
seg000:7C66                 mov     bx, 78h         ; INT 1Eh ; DSK_PARMS
seg000:7C69                 lds     si, ss:[bx]
seg000:7C6C                 push    ds              ; Save original INT 1Eh table & vector
seg000:7C6C                                         ; (*)
seg000:7C6D                 push    si              ; (**)
seg000:7C6E                 push    ss              ; (***)
seg000:7C6F                 push    bx              ; (****)
seg000:7C70                 mov     di, bp          ; 7BECh
seg000:7C72                 mov     cx, 16
seg000:7C75                 push    di              ; (*****)
seg000:7C76                 cld
seg000:7C77                 rep movsb
seg000:7C79                 push    es
seg000:7C7A                 pop     ds
seg000:7C7B                 mov     byte ptr [di-7], 0Fh ; Set the head settle time to 15ms
seg000:7C7B                                         ; because we don't have room to do a disk retry
seg000:7C7B                                         ; and then set sectors per from the value
seg000:7C7B                                         ; in the BPB
seg000:7C7F                 mov     cx, [bp+2Ch]    ; BPB_SecPerTrk
seg000:7C82                 mov     [di-12], cl     ; End of Track
seg000:7C85                 mov     [bx+2], ax      ; Place in new disk parameter table vector
seg000:7C88                 pop     word ptr [bx]   ; 0:7BECh
seg000:7C88                                         ; (*****)
seg000:7C8A                 sti
seg000:7C8B                 call    disk_io         ; ax = 0 ; disk reset
seg000:7C8E                 mov     cx, [bp+27h]    ; BPB_TotSec16
seg000:7C91                 jcxz    short Dir_Cont
seg000:7C93                 mov     [bp+34h], cx    ; BPB_TotSec32
seg000:7C96
seg000:7C96 Dir_Cont:                               ; ...
seg000:7C96                 mov     al, [bp+24h]    ; BPB_NumFATs
seg000:7C99                 cwd
seg000:7C9A                 mov     bx, [bp+2Ah]    ; BPB_FATSz16
seg000:7C9D                 or      bx, bx
seg000:7C9F                 jnz     short Dir_Cont_fat
seg000:7CA1
seg000:7CA1 Dir_Cont_fat32:
seg000:7CA1                 xchg    ax, bx
seg000:7CA2                 mov     ax, [bp+38h]    ; BPB_FATSz32
seg000:7CA5                 mov     dx, [bp+3Ah]    ; BPB_FATSz32+2
seg000:7CA8
seg000:7CA8 Dir_Cont_fat:                           ; ...
seg000:7CA8                 call    mul32           ; dx:ax = NumFats * NumFatSecs
seg000:7CAB                 add     ax, [bp+30h]    ; BPB_HiddSec
seg000:7CAE                 adc     dx, [bp+32h]    ; BPB_HiddSec+2
seg000:7CB1                 add     ax, [bp+22h]    ; BPB_RsvdSecCnt
seg000:7CB4                 adc     dx, 0           ; dx:ax = NumFats * NumFatSecs
seg000:7CB4                                         ;         + ReservedSecs + cSecHid
seg000:7CB7                 push    dx              ; (5*)
seg000:7CB8                 push    ax              ; (6*)
seg000:7CB9                 stosw                   ; [0:7BFCh] = ax
seg000:7CBA                 xchg    ax, dx
seg000:7CBB                 stosw                   ; [0:7BFEh] = dx
seg000:7CBC                 mov     ax, 32          ; DIR_ENTRY_SIZE
seg000:7CBF                 mul     word ptr [bp+25h] ; BPB_RootEntCnt
seg000:7CC2                 mov     bx, [bp+1Fh]    ; BPB_BytsPerSec (= 512)
seg000:7CC5                 dec     bx              ; 511
seg000:7CC6                 add     ax, bx          ; add ax, 511
seg000:7CC8                 adc     dx, 0
seg000:7CCB                 inc     bx              ; 512
seg000:7CCC                 div     bx
seg000:7CCE                 xor     dx, dx
seg000:7CD0                 add     [bp+10h], ax    ; add [0:7BFCh], ax
seg000:7CD3                 adc     [bp+12h], dx    ; adc [0:7BFEh], dx
seg000:7CD6                 xor     ax, ax
seg000:7CD8                 cmp     ax, [bp+2Ah]    ; BPB_FATSz16
seg000:7CDB                 jnz     short not_fat32_fs
seg000:7CDD                 mov     dx, [bp+42h]    ; BPB_RootClus+2
seg000:7CE0                 mov     ax, [bp+40h]    ; BPB_RootClus
seg000:7CE3                 mov     cx, ax
seg000:7CE5                 or      cx, dx
seg000:7CE7                 jcxz    short not_fat32_fs
seg000:7CE9                 call    calc_dir_sector_offset ; calculate sector index/offset
seg000:7CE9                                         ;         of the root directory
seg000:7CEC
seg000:7CEC not_fat32_fs:                           ; ...
seg000:7CEC                 pop     bx              ; (6*)
seg000:7CED                 add     ax, bx
seg000:7CEF                 pop     bx              ; (5*)
seg000:7CF0                 adc     dx, bx          ; dx:ax = start sector # of root directory
seg000:7CF2                 mov     bx, 500h        ; DIR_OFF (buffer address)
seg000:7CF5                 call    disk_read       ; read root directory
seg000:7CF8                 jb      short Load_Failure
seg000:7CFA                 mov     di, bx
seg000:7CFC                 mov     cx, 11
seg000:7CFF                 mov     si, offset IbmbioCom ; Scan for the presence of BIOS file.
seg000:7D02                 push    cx              ; check if the 1st entry is "IBMBIO  COM"
seg000:7D03                 repe cmpsb
seg000:7D05                 pop     cx
seg000:7D06                 jnz     short Load_Failure ; it is not 'IBMBIO.COM'
seg000:7D08                 lea     di, [bx+20h]    ; check if the 2nd entry is "IBMDOS  COM"
seg000:7D0B                 repe cmpsb
seg000:7D0D                 jz      short root_dir_ok ; 1st 2 root dir entries are PCDOS bios and kernel files
seg000:7D0F
seg000:7D0F Load_Failure:                           ; ...
seg000:7D0F                 mov     si, offset BootFailure ; "\r\nBoot failure"
seg000:7D12                 lodsb
seg000:7D13
seg000:7D13 write_message:                          ; ...
seg000:7D13                 mov     ah, 0Eh
seg000:7D15                 mov     bx, 7
seg000:7D18                 int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
seg000:7D18                                         ; AL = character, BH = display page (alpha modes)
seg000:7D18                                         ; BL = foreground color (graphics modes)
seg000:7D1A                 lodsb
seg000:7D1B                 or      al, al
seg000:7D1D                 jnz     short write_message
seg000:7D1F                 cbw
seg000:7D20                 int     16h             ; KEYBOARD -
seg000:7D22                 pop     si              ; (****) ; restore INT 1Eh vector
seg000:7D23                 pop     ds              ; (***)
seg000:7D24                 pop     word ptr [si]   ; (**)
seg000:7D26                 pop     word ptr [si+2] ; (*)
seg000:7D29                 int     19h             ; DISK BOOT
seg000:7D29                                         ; causes reboot of disk system
seg000:7D2B
seg000:7D2B root_dir_ok:                            ; ...
seg000:7D2B                 mov     dx, [bx+14h]    ; High word of cluster number
seg000:7D2E                 mov     ax, [bx+1Ah]    ; Low word of cluster number
seg000:7D31                 cmp     [bp+2Ah], cx    ; BPB_FATSz16 ; cx = 0
seg000:7D34                 jz      short it_is_big_fat
seg000:7D36                 xor     dx, dx          ; HW of cluster number is (must be) zero
seg000:7D38
seg000:7D38 it_is_big_fat:                          ; ...
seg000:7D38                 call    calc_dir_sector_offset ; calculate sector index/offset
seg000:7D38                                         ;         of the file
seg000:7D38                                         ; dx:ax = sector offset from start of data
seg000:7D3B                 add     ax, [bp+10h]    ; [0:7BFCh] = start sector # of data
seg000:7D3E                 adc     dx, [bp+12h]    ; dx:ax = start sector # of the file
seg000:7D41                 mov     bx, 700h        ; [0:700h] = IBMBIO.COM loading address
seg000:7D44                 mov     cl, 4           ; load 4 sectors (MSLOAD code size)
seg000:7D46
seg000:7D46 load_file_sector:                       ; ...
seg000:7D46                 push    ax
seg000:7D47                 push    dx
seg000:7D48                 push    cx
seg000:7D49                 call    disk_read
seg000:7D4C                 pop     cx
seg000:7D4D                 pop     dx
seg000:7D4E                 pop     ax
seg000:7D4F                 jb      short Load_Failure
seg000:7D51                 inc     ax
seg000:7D52                 jnz     short load_next_file_sector
seg000:7D54                 inc     dx
seg000:7D55
seg000:7D55 load_next_file_sector:                  ; ...
seg000:7D55                 add     bx, [bp+1Fh]    ; BPB_BytsPerSec
seg000:7D58                 loop    load_file_sector
seg000:7D5A                 mov     ch, [bp+29h]    ; BPB_Media
seg000:7D5D                 mov     dl, [bp+54h]    ; BS_DrvNum
seg000:7D60                 les     bx, [bp+10h]    ; start sector # of data
seg000:7D63                 mov     ax, es          ; es:bx = ax:bx = dword/far ptr [0:7BFCh]
seg000:7D65                 lds     si, [bp-4]      ; ds:si = DSK_PARMS INT 1Eh table address
seg000:7D65                                         ;         also in stack [at 0:7BE8h] ; (*) (**)
seg000:7D68                 jmp     far ptr 70h:0   ; far jump to MSLOAD (IBMBIO.COM start) code
seg000:7D68                                         ;
seg000:7D68                                         ; Stack:
seg000:7D68                                         ;  ss:sp = Original INT 1Eh vector address (ss:bx)
seg000:7D68                                         ;  ss:sp+4 = Original INT 1Eh disk table addr (ds:si)
seg000:7D6D
seg000:7D6D ; =============== S U B R O U T I N E =======================================
seg000:7D6D
seg000:7D6D
seg000:7D6D disk_read       proc near               ; ...
seg000:7D6D                 test    byte ptr [bp+54h], 80h ; BS_DrvNum
seg000:7D71                 jz      short chs_read
seg000:7D73
seg000:7D73 lba_read:                               ; 0
seg000:7D73                 xor     si, si
seg000:7D75                 mov     cx, sp
seg000:7D77                 push    si
seg000:7D78                 push    si              ; zero dword
seg000:7D79                 push    dx
seg000:7D7A                 push    ax              ; disk LBA address (8 bytes)
seg000:7D7B                 push    es
seg000:7D7C                 push    bx              ; transfer buffer address (es:bx)
seg000:7D7D                 inc     si
seg000:7D7E                 push    si              ; 1 ; number of sectors to read
seg000:7D7F                 mov     si, 10h
seg000:7D82                 push    si              ; Packet size (16)
seg000:7D83                 mov     si, sp          ; LBA Packet buffer address
seg000:7D85                 push    ax
seg000:7D86                 push    dx
seg000:7D87                 mov     ah, 42h         ; LBA Read
seg000:7D89                 call    disk_io
seg000:7D8C                 pop     dx
seg000:7D8D                 pop     ax
seg000:7D8E                 mov     sp, cx
seg000:7D90                 jnb     short disk_read_ok
seg000:7D92
seg000:7D92 chs_read:                               ; ...
seg000:7D92                 mov     cx, [bp+2Ch]    ; BPB_SecPerTrk
seg000:7D95                 cmp     cx, dx
seg000:7D97                 jb      short disk_read_ok ; out of CHS read capacity !
seg000:7D99                 div     cx
seg000:7D9B                 inc     dx
seg000:7D9C                 mov     ch, dl          ; sector
seg000:7D9E                 xor     dx, dx
seg000:7DA0                 div     word ptr [bp+2Eh] ; BPB_NumHeads
seg000:7DA3                 mov     dh, dl          ; head
seg000:7DA5                 mov     cl, 6
seg000:7DA7                 shl     ah, cl          ; cylinder bits 8 and 9
seg000:7DA9                 or      ah, ch          ; AH bits 0 to 5 are sector bits,
seg000:7DA9                                         ; bits 6 and 7 are cylinder bits 8 and 9
seg000:7DAB                 xchg    al, ah
seg000:7DAD                 xchg    ax, cx          ; CL contains sector (6 bits) number
seg000:7DAD                                         ; and high two bits of cylinder number
seg000:7DAD                                         ; CH contains low 8 bits of cylinder number
seg000:7DAE                 mov     ax, 201h        ; Read 1 sector
seg000:7DB1
seg000:7DB1 disk_io:                                ; ...
seg000:7DB1                 mov     dl, [bp+54h]    ; BS_DrvNum
seg000:7DB4                 push    di
seg000:7DB5                 mov     di, 5           ; retry count
seg000:7DB8
seg000:7DB8 try_again:                              ; ...
seg000:7DB8                 push    ax
seg000:7DB9                 int     13h             ; DISK - READ SECTORS INTO MEMORY
seg000:7DB9                                         ; AL = number of sectors to read, CH = track, CL = sector
seg000:7DB9                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
seg000:7DB9                                         ; Return: CF set on error, AH = status, AL = number of sectors read
seg000:7DBB                 pop     ax
seg000:7DBC                 dec     di
seg000:7DBD                 jz      short no_retry
seg000:7DBF                 jb      short try_again
seg000:7DC1
seg000:7DC1 no_retry:                               ; ...
seg000:7DC1                 pop     di
seg000:7DC2
seg000:7DC2 disk_read_ok:                           ; ...
seg000:7DC2                 retn
seg000:7DC2 disk_read       endp
seg000:7DC2
seg000:7DC3
seg000:7DC3 ; =============== S U B R O U T I N E =======================================
seg000:7DC3
seg000:7DC3
seg000:7DC3 calc_dir_sector_offset proc near        ; ...
seg000:7DC3                 xor     bx, bx
seg000:7DC5                 sub     ax, 2
seg000:7DC8                 sbb     dx, bx
seg000:7DCA                 mov     bl, [bp+21h]    ; BPB_SecPerClus
seg000:7DCD
seg000:7DCD mul32:                                  ; ...
seg000:7DCD                 push    ax
seg000:7DCE                 xchg    ax, dx
seg000:7DCF                 mul     bx
seg000:7DD1                 xchg    ax, bx
seg000:7DD2                 pop     dx
seg000:7DD3                 mul     dx
seg000:7DD5                 add     dx, bx
seg000:7DD7                 retn
seg000:7DD7 calc_dir_sector_offset endp
seg000:7DD7
seg000:7DD7 ; ---------------------------------------------------------------------------
seg000:7DD8 IbmbioCom       db 'IBMBIO  COM'        ; ...
seg000:7DE3 IbmdosCom       db 'IBMDOS  COM'
seg000:7DEE BootFailure     db 0Dh,0Ah              ; ...
seg000:7DEE                 db 'Boot failure',0,0
seg000:7DFE                 dw 0AA55h
seg000:7DFE seg000          ends
seg000:7DFE
seg000:7DFE
seg000:7DFE                 end
