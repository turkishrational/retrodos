

;
; +-------------------------------------------------------------------------+
; |   This file has been generated by The Interactive Disassembler (IDA)    |
; |           Copyright (c) 2018 Hex-Rays, <support@hex-rays.com>           |
; |                            Freeware version                             |
; +-------------------------------------------------------------------------+
;
; Input SHA256 : D1C9E34AAFA2A65B8F74EEACE701B273E16D6B7FAE1368C1BA7A768B39EB4558
; Input MD5    : D31B3F077E548791544DF2070469836E
; Input CRC32  : 88D352C3

; ---------------------------------------------------------------------------
; File Name   : C:\Yedek\pcdos_7_1\IBMBIO.COM
; Format      : Binary file
; Base Address: 0000h Range: 0000h - AE70h Loaded length: AE70h

                .386
                .model flat

; ===========================================================================

; Segment type: Pure code
MSLOAD          segment byte public 'CODE' use16
                assume cs:MSLOAD
                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

START$:
                jmp     short SaveInputValues
; ---------------------------------------------------------------------------
                db 90h
SysVersionMajor db 7
SysVersionMinor db 10
NumHeads        dw 0                    ; DATA XREF: MSLOAD:00BB↓w
                                        ; ReadSectors+9C↓r ...
ClusterSize     dw 0                    ; DATA XREF: MSLOAD:CalcFatSize↓w
                                        ; MSLOAD:02A9↓r ...
StartSecL       dw 0                    ; DATA XREF: MSLOAD:0268↓w
                                        ; MSLOAD:0278↓w ...
StartSecH       dw 0                    ; DATA XREF: MSLOAD:0270↓w
                                        ; MSLOAD:027C↓w ...
TempH           dw 0                    ; DATA XREF: MSLOAD:0215↓w
                                        ; MSLOAD:0224↓r ...
TempCluster     dw 0                    ; DATA XREF: GetNextFatEntry+57↓w
                                        ; GetNextFatEntry+6E↓r ...
LastFatSectorL  dw 0FFFFh               ; DATA XREF: GetFatSector+1D↓r
                                        ; GetFatSector+23↓w
LastFatSectorH  dw 0FFFFh               ; DATA XREF: GetFatSector+17↓r
                                        ; GetFatSector+26↓w
SectorCount     dw 0                    ; DATA XREF: MSLOAD:02B9↓w
                                        ; MSLOAD:02EF↓w ...
FATSectorsL     dw 0                    ; DATA XREF: MSLOAD:00C4↓w
                                        ; MSLOAD:not_big↓r ...
FATSectorsH     dw 0                    ; DATA XREF: MSLOAD:013A↓w
                                        ; MSLOAD:01E0↓r
HiddenSectorsL  dw 0                    ; DATA XREF: MSLOAD:00F4↓w
                                        ; GetFatSector+2D↓r
HiddenSectorsH  dw 0                    ; DATA XREF: MSLOAD:010E↓w
                                        ; GetFatSector+31↓r
BytesPerSec     dw 0                    ; DATA XREF: MSLOAD:00A0↓w
                                        ; MSLOAD:0180↓r ...
ReservSectors   dw 0                    ; DATA XREF: MSLOAD:00EB↓w
                                        ; MSLOAD:01D5↓r ...
CurrentClusterL dw 0                    ; DATA XREF: MSLOAD:0252↓w
                                        ; MSLOAD:02C2↓w ...
CurrentClusterH dw 0                    ; DATA XREF: MSLOAD:024E↓w
                                        ; MSLOAD:02C6↓w ...
NextBioLocation dw 0                    ; DATA XREF: MSLOAD:02E4↓w
                                        ; MSLOAD:032F↓r ...
FirstSectorL    dw 0                    ; DATA XREF: MSLOAD:SaveInputValues↓w
                                        ; MSLOAD:0264↓r ...
FirstSectorH    dw 0                    ; DATA XREF: MSLOAD:0107↓w
                                        ; MSLOAD:026C↓r ...
TotalSectorsL   dw 0                    ; DATA XREF: MSLOAD:00FD↓w
                                        ; MSLOAD:011A↓w ...
TotalSectorsH   dw 0                    ; DATA XREF: MSLOAD:0121↓w
                                        ; MSLOAD:01CE↓r
SecPerTrack     dw 0                    ; DATA XREF: MSLOAD:00B2↓w
                                        ; ReadSectors+42↓r ...
BootDrive       db 0                    ; DATA XREF: MSLOAD:0053↓w
                                        ; MSLOAD:034E↓r ...
FatType         db 0                    ; DATA XREF: MSLOAD:01C9↓w
                                        ; MSLOAD:021F↓w ...
MediaByte       db 0                    ; DATA XREF: MSLOAD:004E↓w
                                        ; MSLOAD:GoToBioInit↓r
EndOfFile       db 0                    ; DATA XREF: MSLOAD:0304↓r
                                        ; GetNextFatEntry+6↓w ...
OrgDasdPtr      dd 0                    ; DATA XREF: MSLOAD:loc_5C↓w
                                        ; MSLOAD:0359↓r ...
FatSegment      dw 0                    ; DATA XREF: MSLOAD:018A↓w
                                        ; GetNextFatEntry+1↓r
SecPerCluster   db 0                    ; DATA XREF: MSLOAD:00A9↓w
                                        ; MSLOAD:01B9↓r ...
NumFats         db 0                    ; DATA XREF: MSLOAD:00D9↓w
                                        ; MSLOAD:01E6↓r
RootEntCnt      dw 0                    ; DATA XREF: MSLOAD:00E2↓w
                                        ; MSLOAD:01FB↓r ...
RootClusterL    dw 0                    ; DATA XREF: MSLOAD:0143↓w
RootClusterH    dw 0                    ; DATA XREF: MSLOAD:014C↓w
                                        ; BIOSDATA:1DF3↓r ...
FirstCluster    dw 2 dup(0)             ; DATA XREF: MSLOAD:008E↓w
                                        ; MSLOAD:ReadInFirstCluster↓r ...
; ---------------------------------------------------------------------------

SaveInputValues:                        ; CODE XREF: MSLOAD:START$↑j
                                        ; DATA XREF: check_int13h_extensions+1F↓r ...
                mov     cs:FirstSectorL, bx ; Start sector # of data
                                        ; (high word in ax and also in es)
                mov     cs:MediaByte, ch
                                        ; DATA XREF: aux_init+7↓r
                                        ; BPB_Media
                mov     cs:BootDrive, dl
                                        ; DATA XREF: BIOSDATA:1E64↓r
                                        ; BIOSDATA:2002↓r ...
                                        ; BS_DrvNum

loc_58:                                 ; DATA XREF: ReadSectors+5C↓r
                                        ; BIOSDATA:1B8A↓r ...
                pop     si              ; from BS code..
                                        ; ss:sp = 0:7BE4h, bp = 7BECh
                                        ; Clear stack and load disk parameters table in ds:si
                                        ;
                                        ; pop.. Original INT 1Eh vector address
                pop     ds
                pop     si              ; pop.. Original INT 1Eh disk table address
                pop     ds

loc_5C:                                 ; DATA XREF: print_init+5↓r
                mov     word ptr cs:OrgDasdPtr, si
                push    ds
                pop     word ptr cs:OrgDasdPtr+2
                                        ; DATA XREF: ReadSectors+6F↓r
                                        ; BIOSDATA:SkipVDisk↓r
                xor     cx, cx          ; DATA XREF: BIOSDATA:1865↓r
                                        ; read_real_date+5↓r ...
                mov     ds, cx          ; 0
                mov     es, cx          ; 0
                mov     si, word ptr ds:78h ; INT 1Eh disk parameters table address
                                        ; (it is set by boot sector code)
                mov     ds, word ptr ds:78h+2

loc_75:                                 ; Sec9 ; new location of DSK_PARMS
                mov     di, 522h
                mov     cx, 14          ; (11+3 bytes for IBM rombios)
                cld
                rep movsb
                push    es
                pop     ds
                mov     word ptr ds:78h, 522h
                                        ; DATA XREF: SYSINIT:05D8↓r
                                        ; SYSINIT:05DC↓r ...
                                        ; Offset Sec9
                mov     word ptr ds:78h+2, ds
                mov     cx, word ptr ds:51Ah ; LW of IBMBIO.COM (IO.SYS) first cluster
                mov     cs:FirstCluster, cx
                mov     cx, word ptr ds:514h ; HW of IBMBIO.COM (IO.SYS) first cluster
                mov     cs:FirstCluster+2, cx
                mov     cx, ds:7C0Bh    ; BPB_BytsPerSec ; 512
                mov     cs:BytesPerSec, cx
                                        ; DATA XREF: con_writ+6↓r
                                        ; swpdsk:wrmsg_loop↓r
                mov     cl, ds:7C0Dh    ; BPB_SecPerClus
                mov     cs:SecPerCluster, cl
                mov     cx, ds:7C18h    ; BPB_SecPerTrk
                mov     cs:SecPerTrack, cx
                mov     cx, ds:7C1Ah    ; BPB_NumHeads
                mov     cs:NumHeads, cx ; DATA XREF: MSLOAD:017A↓r
                                        ; BIOSDATA:0821↓r ...
                mov     cx, ds:7C16h    ; BPB_FATSz16
                mov     cs:FATSectorsL, cx
                mov     bl, ds:7C26h    ; BS_BootSig ; (FAT12 and FAT16)
                or      cx, cx
                jnz     short not_fat32
                mov     bl, ds:7C42h    ; BS_BootSig ; (FAT32)

not_fat32:                              ; CODE XREF: MSLOAD:00CF↑j
                mov     cl, ds:7C10h    ; BPB_NumFATs
                mov     cs:NumFats, cl
                mov     cx, ds:7C11h    ; BPB_RootEntCnt
                mov     cs:RootEntCnt, cx
                mov     cx, ds:7C0Eh    ; BPB_RsvdSecCnt
                mov     cs:ReservSectors, cx
                mov     cx, ds:7C1Ch    ; BPB_HiddSec
                mov     cs:HiddenSectorsL, cx
                mov     cx, ds:7C13h    ; BPB_TotSec16
                mov     cs:TotalSectorsL, cx
                cmp     bl, 29h
                jnz     short Relocate  ; old boot sector,
                                        ; no need to copy high words
                mov     cs:FirstSectorH, ax ; Start sector # of data, high word
                mov     ax, ds:7C1Eh    ; BPB_HiddSec+2
                mov     cs:HiddenSectorsH, ax
                cmp     cx, 0
                jnz     short not_big
                mov     ax, ds:7C20h    ; BPB_TotSec32
                mov     cs:TotalSectorsL, ax
                mov     ax, ds:7C22h    ; BPB_TotSec32+2
                mov     cs:TotalSectorsH, ax

not_big:                                ; CODE XREF: MSLOAD:0115↑j
                cmp     cs:FATSectorsL, 0
                jnz     short Relocate  ; FAT12 or FAT16 fs
                mov     cx, ds:7C24h    ; BPB_FATSz32 ; FAT32 fs
                mov     cs:FATSectorsL, cx
                mov     cx, ds:7C26h    ; BPB_FATSz32+2
                mov     cs:FATSectorsH, cx
                mov     cx, ds:7C2Ch    ; BPB_RootClus
                mov     cs:RootClusterL, cx
                mov     cx, ds:7C2Eh    ; BPB_RootClus+2
                mov     cs:RootClusterH, cx

Relocate:                               ; CODE XREF: MSLOAD:0105↑j
                                        ; MSLOAD:012B↑j
                cld                     ; copy code from start to top of memory
                                        ; the length to copy is EndOfLoader
                                        ; jump to relocated code
                xor     si, si
                mov     di, si
                int     12h             ; MEMORY SIZE -
                                        ; Return: AX = number of contiguous 1K blocks of memory
                mov     cl, 6
                shl     ax, cl
                xor     bx, bx          ; Check if an RPL program is present at TOM
                                        ;  and do not tromp over it
                mov     ds, bx
                mov     bx, word ptr ds:0BCh ; 2Fh*4
                mov     ds, word ptr ds:0BEh ; 2Fh*4+2
                cmp     word ptr [bx+3], 5052h ; 'RP' ; 'RPL'
                jnz     short Skip_RPL
                cmp     byte ptr [bx+5], 4Ch ; 'L'
                jnz     short Skip_RPL
                mov     dx, ax          ; get TOM into DX
                mov     ax, 4A06h
                int     2Fh             ; Get new TOM from any RPL
                mov     ax, dx

Skip_RPL:                               ; CODE XREF: MSLOAD:016D↑j
                                        ; MSLOAD:0173↑j
                mov     cl, 4
                mov     dx, cs:BytesPerSec
                shr     dx, cl
                inc     dx
                sub     ax, dx
                mov     cs:FatSegment, ax
                mov     dx, 5F0h        ; Offset EndOfLoader (1520)
                shr     dx, cl
                inc     dx
                sub     ax, dx
                mov     es, ax
                push    cs
                pop     ds
                mov     cx, 1520        ; Loader size = EndofLoader - 0
                rep movsb
                push    es              ; Far jump to relocated MSLOAD code
                                        ; (via retf, far return)
                mov     ax, offset SetupStack
                push    ax
                retf
; ---------------------------------------------------------------------------

SetupStack:                             ; DATA XREF: MSLOAD:01A0↑o
                mov     ax, cs
                sub     ax, 40h         ; move ss to 400h backward for stack space
                                        ; then set sp to the end of this stack space
                mov     ss, ax
                assume ss:nothing
                mov     sp, 400h
                add     ax, 40h         ; ax = cs
                mov     ds, ax

FindClusterSize:
                mov     ax, ds:BytesPerSec
                xor     bx, bx
                mov     bl, ds:SecPerCluster
                mul     bx
                or      dx, dx
                jz      short CalcFatSize
                jmp     ErrorOut
; ---------------------------------------------------------------------------

CalcFatSize:                            ; CODE XREF: MSLOAD:01C1↑j
                mov     ds:ClusterSize, ax ; cluster size in bytes
                mov     ds:FatType, 1   ; FAT12
                mov     dx, ds:TotalSectorsH
                mov     ax, ds:TotalSectorsL
                sub     ax, ds:ReservSectors
                sbb     dx, 0           ; dx:ax = Total available sectors
                mov     bx, ds:FATSectorsL
                mov     cx, ds:FATSectorsH
                push    ax
                push    dx
                mov     al, ds:NumFats  ; calculate total FAT sectors
                xor     ah, ah
                xchg    ax, cx
                mul     cx
                xchg    ax, cx
                mul     bx
                add     cx, dx
                mov     bx, ax
                pop     dx
                pop     ax
                sub     ax, bx
                sbb     dx, cx          ; dx:ax = Total sectors - FAT sectors
                mov     bx, ds:RootEntCnt
                mov     cl, 4
                shr     bx, cl          ; 16 directory entries per sector
                sub     ax, bx
                sbb     dx, 0           ; dx:ax = data sectors
                                        ; (Note: [RootEntCnt] is 0 for FAT32 fs)
                xor     cx, cx          ;
                                        ; 32 bit divide by sectors per
                                        ;  cluster to find total number
                                        ;  of clusters.
                mov     cl, ds:SecPerCluster
                push    ax
                mov     ax, dx
                xor     dx, dx
                div     cx
                mov     ds:TempH, ax
                pop     ax
                div     cx
                mov     dx, ds:FirstCluster+2
                mov     ds:FatType, 0Bh ; set FAT type to FAT32 (CHS type disk R/W)
                cmp     ds:TempH, 0     ; is cluster count > 65535 ?
                jnz     short ReadInFirstCluster ; yes, it is (it must be) FAT32 fs
                cmp     ax, 0FFF6h      ; FAT16 limit (65536-10)
                jnb     short ReadInFirstCluster
                xor     dx, dx
                mov     ds:FirstCluster+2, dx ; clear HW of FirstCluster
                mov     ds:FatType, 1   ; set FAT type fo FAT12
                cmp     ax, 0FF6h       ; 4086 ; (4096-10)
                jb      short ReadInFirstCluster
                mov     ds:FatType, 4   ; set FAT type to FAT16

ReadInFirstCluster:                     ; CODE XREF: MSLOAD:0229↑j
                                        ; MSLOAD:022E↑j ...
                mov     ax, ds:FirstCluster ; dx:ax = BIOS starting cluster
                sub     ax, 2           ; First cluster is 2 so
                                        ; decrement to make 0 based
                sbb     dx, 0
                mov     ds:CurrentClusterH, dx ; Initialize to this cluster
                mov     ds:CurrentClusterL, ax
                mov     ax, 3           ; (Note: PCDOS 7.1 bs loads 1st 4 sectors of IBMBIO.COM)
                                        ; If cluster size > 3, al = 0, ah <> 0
                                        ; If cluster size = 2, al = 1, ah = 1
                                        ; If cluster size = 1, al = 3, ah = 0
                                        ; If ah = 0, nothing remaining in last cluster
                div     ds:SecPerCluster
                cmp     ah, 0
                jz      short SetNextClusterNum
                xor     ah, ah          ; Calculate sector to start reading from
                                        ; in StartSecH and StartSecL
                push    ax              ; (*)
                mov     cx, ds:FirstSectorL
                mov     ds:StartSecL, cx
                mov     cx, ds:FirstSectorH
                mov     ds:StartSecH, cx
                mul     ds:SecPerCluster
                add     ds:StartSecL, ax
                adc     ds:StartSecH, 0 ; Add number of sectors already loaded
                                        ;    to start sector
                mov     dx, ds:FirstCluster+2
                mov     ax, ds:FirstCluster
                sub     ax, 2
                sbb     dx, 0
                xor     bx, bx
                mov     bl, ds:SecPerCluster
                push    ax
                mov     ax, dx
                mul     bx
                xchg    ax, bx
                pop     dx
                mul     dx
                add     dx, bx
                add     ds:StartSecL, ax
                adc     ds:StartSecH, dx
                pop     ax              ; (*) number of clusters already loaded
                                        ; (0 or 1)
                                        ; (Note: if al=0, the 1st 4 sectors of the 1st cluster
                                        ;  will be loaded again! -PCDOS 7.1-)
                push    ax
                mul     ds:ClusterSize
                mov     di, 700h        ; IBMBIO.COM (IO.SYS) loading address (segment = 0)
                add     di, ax
                xor     ax, ax
                mov     es, ax
                mov     al, ds:SecPerCluster ; read 1 cluster
                mov     ds:SectorCount, ax
                call    ReadSectors
                pop     ax
                inc     ax              ; +1 cluster loaded

SetNextClusterNum:                      ; CODE XREF: MSLOAD:025F↑j
                inc     ax              ; ax = total clusters read in based 2
                add     ds:CurrentClusterL, ax ; CurrentCluster = Last cluster read
                adc     ds:CurrentClusterH, 0
                dec     ax              ; ax = number of clusters loaded

SaveLoadedBios:
                push    ds
                mul     ds:ClusterSize  ; Get total bytes loaded by this is always < 64k,
                                        ; so lower 16 bits ok
                sub     ax, 5F0h        ; get portion of iosys loaded
                                        ; EndOfLoader ; (Offset EndOfLoader)-(Offset Start)
                mov     cx, ax
                mov     ax, 70h         ; Segment at 70h
                mov     ds, ax
                assume ds:nothing
                mov     es, ax
                assume es:nothing
                mov     si, 5F0h        ; EndOfLoader
                xor     di, di
                rep movsb
                mov     cs:NextBioLocation, di ; Save where location for next read
                pop     ds
                assume ds:nothing

GetContigClusters:                      ; CODE XREF: MSLOAD:0348↓j
                xor     ah, ah          ; go find clusters as long as they are contiguous
                mov     al, ds:SecPerCluster
                mov     ds:SectorCount, ax
                push    ds:SectorCount
                call    GetNextFatEntry ; Returns next cluster to read in di:ax
                pop     ds:SectorCount
                mov     ds:CurrentClusterL, ax
                mov     ds:CurrentClusterH, di
                cmp     ds:EndOfFile, 0FFh
                jz      short GoToBioInit
                xor     dx, dx
                sub     ax, 2           ; Zero base the cluster (32 bit as di:ax)
                sbb     di, dx
                xchg    ax, di          ; 32 bit multiplication
                                        ; (dx:ax)*cx
                xor     ch, ch
                mov     cl, ds:SecPerCluster
                mul     cx
                xchg    ax, di
                mul     cx
                add     dx, di
                add     ax, ds:FirstSectorL
                adc     dx, ds:FirstSectorH
                mov     ds:StartSecL, ax
                mov     ds:StartSecH, dx
                mov     di, ds:NextBioLocation
                push    ds:SectorCount
                mov     ax, 70h
                mov     es, ax
                call    ReadSectors
                pop     ax
                mul     ds:BytesPerSec
                add     ds:NextBioLocation, ax
                jmp     short GetContigClusters
; ---------------------------------------------------------------------------

GoToBioInit:                            ; CODE XREF: MSLOAD:0309↑j
                mov     ch, ds:MediaByte ; Set up required registers for iosys,
                                        ;  then jump to it (70:0)
                                        ;
                                        ; Restore regs required for msint
                mov     dl, ds:BootDrive ; Physical drv number we booted from
                mov     bx, ds:FirstSectorL
                mov     ax, ds:FirstSectorH ; bx:ax = first data sector of disk
                lds     si, ds:OrgDasdPtr ; Set ds:si to Original INT 1Eh disk(ette) table address
                                        ; and then push disk table address and INT 1Eh vector to stack
                                        ; (set stack content just as at the start of MSLOAD)
                push    ds              ; INT 1Eh original table segment
                push    si              ; INT 1Eh original table offset
                xor     di, di          ; 0  ; INT 1Eh vector segment
                push    di
                mov     di, 78h         ; 1Eh*4 = 78h
                push    di              ; INT 1Eh vector offset
                jmp     far ptr 70h:0   ; Far jump to IoSysAddr (DOSBIOS)

; =============== S U B R O U T I N E =======================================


check_int13h_extensions proc near       ; CODE XREF: ReadSectors+C↓p
                push    ax
                push    dx
                xor     ax, ax
                push    ax              ; zero (buffer offset 24)
                                        ; (bytes per sector)
                mov     bx, sp
                sub     sp, 20
                push    ax              ; info flags
                mov     ax, 26          ; Result buffer size
                push    ax
                mov     si, sp
                mov     dl, ds:BootDrive
                mov     ah, 48h
                push    ds
                push    ss
                pop     ds
                assume ds:nothing
                cmp     dl, 0
                jge     short not_hard_disk
                int     13h             ; DISK - IBM/MS Extension - GET DRIVE PARAMETERS
                                        ; (DL - drive, DS:SI - buffer)

not_hard_disk:                          ; CODE XREF: check_int13h_extensions+1D↑j
                pop     ds
                assume ds:nothing
                mov     sp, bx
                pop     ax              ; bytes per sector, buffer offset 24
                jb      short int13h_ext_err
                cmp     ax, 512
                jz      short int13h_ext_err
                stc

int13h_ext_err:                         ; CODE XREF: check_int13h_extensions+25↑j
                                        ; check_int13h_extensions+2A↑j
                pop     dx
                pop     ax
                retn
check_int13h_extensions endp


; =============== S U B R O U T I N E =======================================


ReadSectors     proc near               ; CODE XREF: MSLOAD:02BC↑p
                                        ; MSLOAD:033C↑p ...
                mov     cx, 5

TryRead:                                ; CODE XREF: ReadSectors+D8↓j
                                        ; ReadSectors+DE↓j
                push    cx              ; (*)
                mov     ax, ds:StartSecL
                mov     dx, ds:StartSecH
                push    ax              ; (**)
                call    check_int13h_extensions
                jb      short chs_read
                xor     si, si          ; LBA read
                push    si              ; 0
                push    si              ; 0
                push    dx
                push    ax              ; 0:0:dx:ax = start sector (8 bytes)
                push    es
                push    di              ; memory buffer address (seg:off)
                push    ds:SectorCount  ; number of sectors to read
                mov     bx, 16          ; size of DAP
                push    bx
                mov     si, sp
                mov     ah, 42h
                push    dx
                mov     dl, ds:BootDrive
                push    ds
                push    ss
                pop     ds
                assume ds:nothing
                int     13h             ; DISK - IBM/MS Extension - EXTENDED READ
                                        ; (DL - drive, DS:SI - disk address packet)
                pop     ds
                assume ds:nothing
                pop     dx              ; sector number, hw
                jb      short lba_read_err
                pop     ax              ; size of DAP (disk address packet) = 16
                pop     ax              ; number of sectors to read
                push    ax              ; (**) discard ax on stack (StartSectorL)
                add     sp, bx          ; sp points to cx (*)
                pop     cx              ; remaining retry count value
                jmp     ReadOk
; ---------------------------------------------------------------------------

lba_read_err:                           ; CODE XREF: ReadSectors+31↑j
                add     sp, bx

chs_read:                               ; CODE XREF: ReadSectors+F↑j
                mov     ax, dx          ; start sector, hw
                xor     dx, dx
                cmp     ds:SecPerTrack, ax ; hw of disk (LBA) address
                                        ; (must not be > sectors per track)
                jnb     short DoDivide

ErrorOut:                               ; CODE XREF: MSLOAD:01C3↑j
                                        ; ReadSectors:ReadError↓j
                push    cs
                pop     ds
                mov     si, offset NonSystemDiskMsg ; "\r\nNon-System disk or disk error\r\nRe"...

WriteTTY:                               ; CODE XREF: ReadSectors+58↓j
                lodsb
                or      al, al
                jz      short wait_key_reboot
                mov     ah, 0Eh
                mov     bl, 7
                int     10h             ; - VIDEO -
                jmp     short WriteTTY
; ---------------------------------------------------------------------------

wait_key_reboot:                        ; CODE XREF: ReadSectors+50↑j
                xor     ah, ah
                int     16h             ; KEYBOARD -
                xor     bx, bx
                mov     ds, bx
                les     bx, cs:OrgDasdPtr
                assume es:nothing
                mov     si, 78h ; 'x'
                mov     [si], bx
                mov     word ptr [si+2], es
                int     19h             ; DISK BOOT
                                        ; causes reboot of disk system

DoDivide:                               ; CODE XREF: ReadSectors+46↑j
                div     ds:SecPerTrack  ; 32 bit division
                mov     ds:TempH, ax
                pop     ax              ; start sector, lw
                div     ds:SecPerTrack
                mov     bx, ds:SecPerTrack
                sub     bx, dx          ; dx = start sector on (same) track
                mov     si, bx          ; sectors to read on (same) track (remain sectors)
                cmp     ds:SectorCount, si
                jnb     short GotLength
                mov     si, ds:SectorCount

GotLength:                              ; CODE XREF: ReadSectors+89↑j
                inc     dl              ; Sector numbers are 1-based
                mov     bl, dl
                mov     dx, ds:TempH    ; dx:ax = Track
                push    ax
                mov     ax, dx
                xor     dx, dx
                div     ds:NumHeads     ; Start cyl in ax, head in dl
                mov     ds:TempH, ax
                pop     ax
                div     ds:NumHeads     ; [TempH]:ax = Cylinder, dx = Head
                                        ;
                                        ; At this moment, we assume that TempH = 0,
                                        ; ax <= 1024, dx <= 255
                mov     dh, dl          ;
                                        ; Issue one read request.
                                        ; es:bx have the transfer address,
                                        ; al is the number of sectors.
                mov     cl, 6
                shl     ah, cl          ; Shift cyl high bits up
                or      ah, bl          ; Mix in with sector bits
                mov     ch, al          ; Setup cyl low
                mov     cl, ah          ; Setup cyl/high - sector
                mov     bx, di          ; Get back OFFSET
                mov     dl, ds:BootDrive ; Get drive
                mov     ax, si          ; Get number of sectors to read (al)
                mov     ah, 2           ; Read
                push    ax              ; Save read count
                push    di
                int     13h             ; DISK - READ SECTORS INTO MEMORY
                                        ; AL = number of sectors to read, CH = track, CL = sector
                                        ; DH = head, DL = drive, ES:BX -> buffer to fill
                                        ; Return: CF set on error, AH = status, AL = number of sectors read
                pop     di
                pop     ax
                pop     cx
                jnb     short ReadOk
                mov     bx, di
                xor     ah, ah
                push    cx
                mov     dl, ds:BootDrive
                push    di
                int     13h             ; DISK - RESET DISK SYSTEM
                                        ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
                pop     di
                pop     cx
                dec     cx              ; Get retry count back
                jz      short ReadError
                jmp     TryRead         ; DATA XREF: BIOSDATA:1712↓w
                                        ; BIOSDATA:1720↓w ...
; ---------------------------------------------------------------------------

ReadError:                              ; CODE XREF: ReadSectors+D6↑j
                jmp     ErrorOut
; ---------------------------------------------------------------------------
                jmp     TryRead
; ---------------------------------------------------------------------------

ReadOk:                                 ; CODE XREF: ReadSectors+39↑j
                                        ; ReadSectors+C5↑j
                xor     ah, ah          ;  Mask out read command, just get # read
                sub     ds:SectorCount, ax ; Bump number down
                jz      short EndRead
                add     ds:StartSecL, ax ; Where to start next time
                adc     ds:StartSecH, 0
                xor     bx, bx          ; Get number sectors read
                mov     bl, al
                mov     ax, ds:BytesPerSec
                mul     bx              ; Get total bytes read
                add     di, ax          ; Add it to offset
                jmp     ReadSectors
; ---------------------------------------------------------------------------

EndRead:                                ; CODE XREF: ReadSectors+E7↑j
                retn
ReadSectors     endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


GetNextFatEntry proc near               ; CODE XREF: MSLOAD:02F6↑p
                push    es
                mov     ax, ds:FatSegment
                mov     es, ax
                mov     ds:EndOfFile, 0FFh ; END_OF_FILE ; Assume last cluster
                mov     ax, ds:CurrentClusterL ; Get last cluster
                mov     di, ds:CurrentClusterH

chk_fat32_type:                         ; FAT32 (CHS) fs ?
                cmp     ds:FatType, 0Bh
                jnz     short chk_fat_type ; no

Got32Bit:                               ; Multiply cluster number by 4
                add     ax, ax
                adc     di, di
                add     ax, ax
                adc     di, di          ; Get the FAT offset (di:si)
                mov     si, ax
                call    GetFatSector
                mov     ax, es:[bx]
                mov     di, es:[bx+2]
                cmp     di, 0FFFh       ; FAT32 cluster numbers are 28 bit numbers
                                        ; (higher 4 bits are -must be- zero)
                jnz     short GotFAT32ClusterDone
                cmp     ax, 0FFF8h

GotFAT32ClusterDone:                    ; CODE XREF: GetNextFatEntry+31↑j
                jmp     short GotClusterDoneJ
; ---------------------------------------------------------------------------

chk_fat_type:                           ; CODE XREF: GetNextFatEntry+17↑j
                cmp     ds:FatType, 1
                jnz     short Got16Bit

Got12Bit:
                mov     si, ax
                mov     dx, di
                shr     dx, 1
                rcr     ax, 1
                add     si, ax
                adc     di, dx          ; di:si = dx:ax * 1.5 = dx:ax + dx:ax/2
                push    dx
                xor     dx, dx
                call    GetFatSector
                pop     dx
                jnz     short ClusterOk
                mov     al, es:[bx]     ; Spitted cluster number,
                                        ;  read next FAT sector
                mov     byte ptr ds:TempCluster, al
                add     si, 1
                adc     di, 0
                push    dx
                xor     dx, dx
                call    GetFatSector    ; Read next fat sector
                pop     dx
                mov     al, byte ptr es:0
                mov     byte ptr ds:TempCluster+1, al
                mov     ax, ds:TempCluster
                jmp     short EvenOdd
; ---------------------------------------------------------------------------

ClusterOk:                              ; CODE XREF: GetNextFatEntry+52↑j
                mov     ax, es:[bx]

EvenOdd:                                ; CODE XREF: GetNextFatEntry+71↑j
                test    cs:CurrentClusterL, 1
                jnz     short OddResult
                and     ax, 0FFFh
                jmp     short TestEOF
; ---------------------------------------------------------------------------

OddResult:                              ; CODE XREF: GetNextFatEntry+7D↑j
                mov     cl, 4
                shr     ax, cl

TestEOF:                                ; CODE XREF: GetNextFatEntry+82↑j
                xor     di, di
                cmp     ax, 0FF8h
                jnb     short GotClusterDone
                jmp     short NotLastCluster
; ---------------------------------------------------------------------------

Got16Bit:                               ; CODE XREF: GetNextFatEntry+3D↑j
                push    dx
                xor     dx, dx
                shl     ax, 1           ; Multiply cluster by 2
                adc     di, di

loc_534:                                ; Get the FAT offset (di:si)
                mov     si, ax
                call    GetFatSector
                pop     dx
                xor     di, di          ; HW of cluster number is 0
                mov     ax, es:[bx]
                cmp     ax, 0FFF8h

GotClusterDoneJ:                        ; CODE XREF: GetNextFatEntry:GotFAT32ClusterDone↑j
                jnb     short GotClusterDone

NotLastCluster:                         ; CODE XREF: GetNextFatEntry+8F↑j
                mov     cs:EndOfFile, 0 ; NOT END_OF_FILE ; Assume not last cluster

GotClusterDone:                         ; CODE XREF: GetNextFatEntry+8D↑j
                                        ; GetNextFatEntry:GotClusterDoneJ↑j
                pop     es
                retn
GetNextFatEntry endp


; =============== S U B R O U T I N E =======================================


GetFatSector    proc near               ; CODE XREF: GetNextFatEntry+23↑p
                                        ; GetNextFatEntry+4E↑p ...
                push    ax              ; di:si = byte offset in (entire) FAT
                push    si
                push    di
                mov     ax, di          ; 32 bit division (dx:ax/512)
                xor     dx, dx
                mov     cx, ds:BytesPerSec
                div     cx
                mov     bx, ax
                mov     ax, si
                mov     cx, ds:BytesPerSec
                div     cx              ; dx = byte offset in the FAT sector
                cmp     bx, ds:LastFatSectorH ; FAT32 (32 bit cluster numbers)
                jnz     short not_same_fat_sector
                cmp     ax, ds:LastFatSectorL ; The same fat sector?

not_same_fat_sector:                    ; CODE XREF: GetFatSector+1B↑j
                jz      short SplitChk  ; Don't need to read it again.
                mov     ds:LastFatSectorL, ax
                mov     ds:LastFatSectorH, bx
                push    dx
                mov     dx, bx
                add     ax, ds:HiddenSectorsL
                adc     dx, ds:HiddenSectorsH
                add     ax, ds:ReservSectors
                adc     dx, 0
                mov     ds:StartSecL, ax
                mov     ds:StartSecH, dx
                mov     ds:SectorCount, 1
                xor     di, di          ; buffer address: es:0
                call    ReadSectors
                pop     dx
                mov     cx, ds:BytesPerSec

SplitChk:                               ; CODE XREF: GetFatSector:not_same_fat_sector↑j
                dec     cx              ; cx = sector size - 1  (= 511)
                cmp     dx, cx          ; If last byte of sector, splitted entry.
                mov     bx, dx          ; set bx to dx
                pop     di
                pop     si
                pop     ax
                retn                    ; If zf = 1, it is splitted
GetFatSector    endp                    ;  (next FAT12 sector will be read)

; ---------------------------------------------------------------------------
NonSystemDiskMsg db 0Dh,0Ah             ; DATA XREF: ReadSectors+4A↑o
                db 'Non-System disk or disk error',0Dh,0Ah ; EndOfLoader (MSLOAD:05F0h)
                db 'Replace and press any key when ready',0Dh,0Ah,0
MSLOAD          ends

; ---------------------------------------------------------------------------
; ===========================================================================

; Segment type: Regular
BIOSDATA        segment byte public 'BIOSDATA' use16
                assume cs:BIOSDATA
                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

hdrv_pat:                               ; CODE XREF: BIOSDATA:0202↓j
                                        ; DATA XREF: BIOSDATA:1FCC↓w
                jmp     init            ; BData_start
; ---------------------------------------------------------------------------
DosDataSg       dw 0                    ; DATA XREF: cdev_entry+9↓r
                                        ; BIOSDATA:232E↓w
bios_i2f        db 0EAh                 ; far jump to int_2f
                dw offset i2f_handler
bios_i2f_seg    dw 364h                 ; DATA XREF: BIOSCODE:0042↓w
                                        ; IOSYSCODESEG (IBMBIO.COM code segment)
                                        ; BIOSCODE (2F4h+070h) segment
romstartaddr    dw 0
altah           db 0                    ; DATA XREF: BIOSDATA:cbreak↓w
                                        ; BIOSDATA:07FC↓o ...
inHMA           db 0                    ; DATA XREF: cdev_entry↓r
                                        ; block13↓r ...
xms             dd 0                    ; DATA XREF: EnsureA20On+9↓r
                                        ; AllocHMA+10↓w ...
ptrsav          dd 0                    ; DATA XREF: BIOSDATA:strategy↓w
                                        ; BIOSCODE:0065↓r ...
auxbuf          db 4 dup(0)             ; DATA XREF: getbx+4↓o
zeroseg         dw 0                    ; DATA XREF: checksingle+45↓r
                                        ; checksingle+5F↓r ...
i13_ds          dw 0                    ; DATA XREF: block13:skipa20↓w
                                        ; block13+16↓r ...
prevoper        dw 0                    ; DATA XREF: BIOSCODE:ps2_special_stuff↓r
                                        ; BIOSCODE:18CD↓r ...
number_of_sec   db 0                    ; DATA XREF: BIOSCODE:1950↓w
                                        ; BIOSCODE:ok11_op↓w
auxnum          dw 0                    ; DATA XREF: BIOSCODE:005E↓w
                                        ; prnop↓r ...
res_dev_list    dw offset auxdev2       ; DATA XREF: BIOSDATA:1F71↓o
                                        ; CONHeader
                                        ; HEADER FOR DEVICE "CON"
                dw 70h
                dw 8013h
                dw offset strategy
                dw offset con_entry
                db 'CON     '
auxdev2         dw offset prndev2       ; DATA XREF: BIOSDATA:res_dev_list↑o
                                        ; HEADER FOR DEVICE "AUX"
                dw 70h
                dw 8000h
                dw offset strategy
                dw offset aux0_entry
                db 'AUX     '
prndev2         dw offset timdev        ; DATA XREF: BIOSDATA:auxdev2↑o
                                        ; HEADER FOR DEVICE "PRN"
                dw 70h
                dw 0A0C0h
                dw offset strategy
                dw offset prn0_entry
                db 'PRN     '
timdev          dw offset dskdev        ; DATA XREF: BIOSDATA:prndev2↑o
                                        ; HEADER FOR DEVICE "CLOCK$"
                dw 70h
                dw 8008h
                dw offset strategy
                dw offset tim_entry
                db 'CLOCK$  '
dskdev          dw offset com1dev       ; DATA XREF: BIOSDATA:timdev↑o
                                        ; HEADER FOR DISK DEVICES
                dw 70h
                dw 48C2h
                dw offset strategy
                dw offset dsk_entry
drvmax          db 4                    ; DATA XREF: BIOSDATA:1FD5↓w
                                        ; BIOSDATA:loop_drive↓r ...
                                        ; maximum number of drives
step_drv        db 0FEh                 ; DATA XREF: read_sector:okret2↓w
                                        ; disk+50↓r ...
                                        ; -2 ; last drive accessed
fhave96         db 0                    ; DATA XREF: BIOSDATA:20CF↓w
                                        ; BIOSDATA:212B↓w ...
                                        ; 96tpi support
single          db 0                    ; DATA XREF: BIOSDATA:settwodrive↓w
                                        ; BIOSDATA:219C↓r ...
                                        ; used to detect single drive systems
fhavek09        db 0                    ; DATA XREF: BIOSDATA:2302↓w
                                        ; con_rdnd+F↓r
                                        ; indicates if this is a k09 or not
                                        ; used by console driver.
fsetowner       db 0                    ; DATA XREF: checksingle+32↓r
                                        ; ioctl_getown+21↓w ...
                                        ; = 1 if we are setting the owner of a drive.
                                        ; (examined by checksingle)
com1dev         dw offset lpt1dev       ; DATA XREF: BIOSDATA:dskdev↑o
                                        ; Device Header for device "COM1"
                dw 70h
                dw 8000h
                dw offset strategy
                dw offset aux0_entry
                db 'COM1    '
lpt1dev         dw offset lpt2dev       ; DATA XREF: BIOSDATA:com1dev↑o
                                        ; Device Header for device LPT1
                dw 70h
                dw 0A0C0h
                dw offset strategy
                dw offset prn1_entry
                db 'LPT1    '
lpt2dev         dw offset lpt3dev       ; DATA XREF: BIOSDATA:lpt1dev↑o
                                        ; Device Header for device LPT2
                dw 70h
                dw 0A0C0h
                dw offset strategy
                dw offset prn2_entry
                db 'LPT2    '
                db 3 dup(0)
Orig13          dd 0                    ; DATA XREF: call_orig13+5↓r
                                        ; BIOSDATA:1DB0↓w ...
                                        ; to make Orig13 offset 0B4h
lpt3dev         dw offset com2dev       ; DATA XREF: BIOSDATA:lpt2dev↑o
                                        ; Device Header for device LPT3
                dw 70h
                dw 0A0C0h
                dw offset strategy
                dw offset prn3_entry
                db 'LPT3    '
com2dev         dw offset com3dev       ; DATA XREF: BIOSDATA:lpt3dev↑o
                                        ; Device Header for device "COM2"
                dw 70h
                dw 8000h
                dw offset strategy
                dw offset aux1_entry
                db 'COM2    '
com3dev         dw offset com4dev       ; DATA XREF: BIOSDATA:com2dev↑o
                                        ; Device Header for device "COM3"
                dw 70h
                dw 8000h
                dw offset strategy
                dw offset aux2_entry
                db 'COM3    '
com4dev         dw 0FFFFh               ; DATA XREF: BIOSDATA:com3dev↑o
                                        ; Device Header for device "COM4"
                dw 70h
                dw 8000h
                dw offset strategy
                dw offset aux3_entry
                db 'COM4    '
RomVectors      db 10h                  ; DATA XREF: BIOSDATA:0761↓o
                                        ; BIOSDATA:1D94↓o
Old10           dd 0
                db 13h
Old13           dd 0                    ; DATA XREF: BIOSDATA:atd1↓r
                                        ; BIOSDATA:no_hookit↓r ...
                db 15h
Old15           dd 0                    ; DATA XREF: BIOSDATA:Old15_j↓r
                db 19h
Old19           dd 0
                db 1Bh
Old1B           dd 0                    ; ;
                                        ; EndRomVectors equ $
                                        ; NUMROMVECTORS equ ((EndRomVectors - RomVectors)/5)
                                        ; ;
start_bds       dw offset bds1          ; DATA XREF: BIOSDATA:2024↓o
                                        ; remap↓r ...
                                        ; Start of linked list of BDS's
                dw 70h                  ; BIOSDATA segment
accesscount     db 0                    ; DATA XREF: Check_Time_Of_Access+12↓r
                                        ; Check_Time_Of_Access:timecheck_ret↓w ...
tim_drv         db 0FFh                 ; DATA XREF: BIOSCODE:05D4↓w
                                        ; BIOSCODE:0600↓r ...
medbyt          db 0                    ; DATA XREF: diskio+D↓w
                                        ; fat_check+3↓r
rflag           db 2                    ; DATA XREF: BIOSCODE:dsk_writv↓w
                                        ; BIOSCODE:dsk_writ↓w ...
                                        ; 2 for read, 3 for write
verify          db 0                    ; 1 if verify after write
seccnt          dw 0                    ; DATA XREF: diskio+19↓w
                                        ; diskio+BF↓r ...
                db 0                    ; -- pad where hardnum was
dsktnum         db 1                    ; DATA XREF: BIOSDATA:1FD8↓w
                                        ; BIOSDATA:2245↓r ...
                                        ; number of diskette drives
motorstartup    db 0                    ; DATA XREF: BIOSDATA:1F13↓w
                                        ; iosetup+20↓w ...
                                        ; value from table
settlecurrent   db 0                    ; DATA XREF: iosetup+40↓w
                                        ; done+1F↓r
                                        ; value from table
settleslow      db 0                    ; DATA XREF: iosetup+45↓w
                                        ; normspeed+9↓r
                                        ; slow settle value
nextspeed       db 0                    ; value of speed to be used
save_head_sttl  db 0                    ; DATA XREF: read_sector+37↓w
                                        ; read_sector+4D↓r
                                        ; used by read_sector routine
save_eot        db 0                    ; DATA XREF: iosetup+23↓w
                                        ; done+18↓r
                                        ; saved eot from the default DPT
eot             db 9                    ; DATA XREF: BIOSDATA:201F↓w
                                        ; BIOSDATA:20AC↓r ...
dpt             dd 0                    ; DATA XREF: read_sector+2B↓r
                                        ; read_sector+51↓r ...
                                        ; pointer to Disk Parameter Table
cursec          db 0                    ; DATA XREF: diskio+157↓w
                                        ; block+1D↓r ...
                                        ; current sector
curhd           db 0                    ; DATA XREF: diskio+173↓w
                                        ; disk+41↓r ...
                                        ; current head
curtrk          dw 0                    ; DATA XREF: diskio+177↓w
                                        ; disk+1F↓r ...
                                        ; current track
spsav           dw 0                    ; DATA XREF: diskio+1D↓w
                                        ; disk+13E↓r ...
                                        ; save the stack pointer
formt_eot       db 8                    ; DATA XREF: SetDasd+5B↓w
                                        ; ToRom+21↓r
                                        ; eot used for format
hdnum           db 0                    ; DATA XREF: BIOSCODE:110D↓w
                                        ; ToRom+47↓r
                                        ; head number
trknum          dw 0                    ; DATA XREF: BIOSCODE:110A↓w
                                        ; ToRom:GotValidDpt↓r
                                        ; track being manipulated
gap_patch       db 50h                  ; DATA XREF: SetDasd+1A↓w
                                        ; SetDasd+3A↓w ...
                                        ; format gap patched into dpt
errin           db 0CCh                 ; DATA XREF: maperror+C↓o
                                        ; write fault (hard disk)
                db 80h                  ; timeout (not ready)
                db 40h                  ; seek failed
                db 10h                  ; uncorrectable CRC or ECC error on read
                db 8                    ; DMA overrun
                db 6                    ; disk changed (floppy)
                db 4                    ; sector not found/read error
                db 3                    ; disk write-protected
                db 1                    ; invalid function in AH or invalid parameter
                db 0B2h                 ; volume not removable
lsterr          db 0                    ; DATA XREF: maperror+6↓w
errout          db 10                   ; write fault error
                db 2                    ; no response (timeout)
                db 6                    ; seek failure
                db 4                    ; bad crc
                db 4                    ; dma overrun
                db 15                   ; invalid media change
                db 8                    ; sector not found
                db 0                    ; write attempt to write-protect disk
                db 3                    ; unknown command error
                db 3                    ; unknown command error
                db 12                   ; general error
disksector      db 174 dup(0)           ; DATA XREF: BIOSDATA:1C54↓o
                                        ; sethard+19A↓o ...
                                        ; 512 byte buffer
; ---------------------------------------------------------------------------

JB_sign:                                ; 'BJ' (nasm) ; dw 424Ah
                dec     dx
                inc     dx
                jmp     hdrv_pat        ; jmp BData_start
; ---------------------------------------------------------------------------
IBMBIOCOM$      db '@#IBM:12.01.2003.build_1.32#@ IBMBIO.COM(USA)',0
                db 287 dup(0)
bds1            dw offset bds2          ; DATA XREF: BIOSDATA:start_bds↑o
                                        ; dword link to next structure
                dw 70h
                db 0                    ; int 13h drive number
                db 0                    ; logical drive letter
fdrive1         dw 512                  ; DATA XREF: BIOSDATA:dskdrvs↓o
                                        ; physical sector size in bytes
                db 0FFh                 ; sectors/allocation unit
                dw 1                    ; reserved sectors for dos
                db 2                    ; no of file allocation tables
                dw 64                   ; number of root directory entries
                dw 360                  ; number of sectors (at 512 bytes each)
                db 0                    ; media descriptor, initially 0
                dw 2                    ; number of fat sectors
                dw 9                    ; sector limit (sectors per track)
                dw 1                    ; head limit (number of heads - 1)
                dd 0                    ; hidden sector count
                dd 0                    ; number of sectors (32 bit)
                dd 0                    ; BPB_FATSz32 ; FAT32 FAT size in sectors ; 4 bytes
                                        ;   BS_DrvNum ; FAT INT 13h drive number ; 1 byte
                                        ;   BS_Reserved1 ; FAT reserved byte = 0 ; 1 byte
                                        ;   BS_BootSig ; FAT Extended boot signature = 29h ; 1 byte
                                        ;   BS_VolID ; FAT Volume serial number ; 4 bytes
                dw 0                    ; BPB_ExtFlags ; FAT32 Extended Flags
                dw 0                    ; BPB_FSVer ; FAT32 fs/volume version
                dd 0                    ; BPB_RootClus ; FAT32 root directory's first cluster number
                dw 0FFFFh               ; BPB_FSInfo ; FAT32 FSINFO sector number = -1 (initial)
                dw 0FFFFh               ; BPB_BkBootSec ; FAT32 backup boot sector number = -1 (initial)
                db 12 dup(0)            ; BPB_Reserved  ; FAT32 reserved field = 0, 12 bytes
                db 0                    ; true => large fats
                dw 0                    ; open ref. count
                db 3                    ; form factor
                dw 20h                  ; various flags
                dw 40                   ; number of cylinders
recommended_bps dw 512                  ; recommended bps for this drive
                                        ; recbpb1
                db 1
                dw 1
                db 2
                dw 224                  ; number of root directory entries
                dw 360
                db 0F0h                 ; media descriptor, initially 0F0h
                dw 2
                dw 9
                dw 2
                dd 0
                dd 0
                dd 0
                dd 0
                dd 0
                dd 0FFFFFFFFh
                dd 0
                dd 0
                dd 0
                db 0FFh                 ; last track accessed on this drive
                dd 0FFFFFFFFh           ; keep these two contiguous (?)
                db 'NO NAME    ',0      ; volume id for this disk
                dd 0                    ; current volume serial from boot record
                db 'FAT12   ',0         ; current file system id from boot record
bds2            dw 0FFFFh               ; DATA XREF: BIOSDATA:bds1↑o
                dw 70h
                db 0
                db 0
fdrive2         dw 512                  ; DATA XREF: BIOSDATA:053E↓o
                db 0FFh
                dw 1
                db 2
                dw 64
                dw 360
                db 0
                dw 2
                dw 9
                dw 1
                dd 0
                dd 0
                dd 0
                dd 0
                dd 0
                dd 0FFFFFFFFh
                dd 0
                dd 0
                dd 0
                db 0
                dw 0
                db 3
                dw 20h
                dw 40
recbpb2         dw 512
                db 1
                dw 1
                db 2
                dw 224
                dw 360
                db 0F0h
                dw 2
                dw 9
                dw 2
                dd 0
                dd 0
                dd 0
                dd 0
                dd 0
                dd 0FFFFFFFFh
                dd 0
                dd 0
                dd 0
                db 0FFh
                dd 0FFFFFFFFh
                db 'NO NAME    ',0
                dd 0
                db 'FAT12   ',0
keyrd_func      db 0                    ; DATA XREF: BIOSDATA:1FB9↓w
                                        ; chrin↓r ...
keysts_func     db 1                    ; DATA XREF: BIOSDATA:1FBF↓w
                                        ; con_rdnd+7↓r ...
printdev        db 0                    ; DATA XREF: BIOSCODE:0061↓w
                                        ; BIOSCODE:029D↓r ...
                                        ; printer device index
wait_count      dw 50h                  ; DATA XREF: BIOSCODE:02A3↓r
                                        ; BIOSCODE:02E1↓r ...
                                        ; retry counts for printers
                dw 50h
                dw 50h
                dw 50h
daycnt          dw 0                    ; DATA XREF: BIOSDATA:185A↓w
                                        ; cmos_clock_read+33↓w ...
                                        ; flag for updating daycnt
t_switch        db 0                    ; DATA XREF: GetTickCnt+6↓r
                                        ; doconf+A46↓w
havecmoscloc    db 0                    ; DATA XREF: cmos_clock_read:clock_present↓w
                                        ; BIOSCODE:03EE↓r ...
base_century    db 19                   ; DATA XREF: daycnttoday+C↓w
                                        ; daycnttoday:century20↓w ...
base_year       db 80                   ; DATA XREF: daycnttoday+32↓w
                                        ; daycnttoday+42↓w ...
month_table     db 31                   ; DATA XREF: read_real_date+9D↓o
                                        ; daycnttoday+6F↓o
february        db 28                   ; DATA XREF: daycnttoday:leapyear↓w
                                        ; daycnttoday:month_done↓w
                db 31
                db 30
                db 31
                db 30
                db 31
                db 31
                db 30
                db 31
                db 30
                db 31
set_id_flag     db 0                    ; DATA XREF: get_bpb+10↓w
                                        ; get_bpb+1A↓r ...
                                        ; flag for getbp routine
start_sec_h     dw 0                    ; DATA XREF: getclus+F9↓w
                                        ; get_fat_sector+35↓w ...
                                        ; starting sector number high word
saved_word      dw 0                    ; DATA XREF: sethard+174↓w
                                        ; sethard+185↓r ...
                                        ; tempory saving place for a word
multrk_flag     dw 0                    ; DATA XREF: block+B↓r
                                        ; disk+88↓r ...
ec35_flag       db 0                    ; DATA XREF: BIOSCODE:18AA↓r
                                        ; BIOSCODE:format_special_stuff_done↓r ...
                                        ; flags for 3.5 inch disk drives
vretry_cnt      dw 0                    ; DATA XREF: diskio+C9↓w
                                        ; diskio+128↓w ...
soft_ecc_cnt    dw 0                    ; DATA XREF: diskio+CD↓w
                                        ; diskio:set_lbarw_5↓w ...
multitrk_format_flag db 0               ; DATA XREF: disk:dskerr_nochangeline↓r
                                        ; disk+108↓w ...
                                        ; multi track format request flag
xfer_seg        dw 0                    ; DATA XREF: diskio+2↓w
                                        ; diskio+B8↓r ...
                                        ; temp for transfer segment
sectorspertrack dw 36                   ; DATA XREF: BIOSCODE:106D↓w
                                        ; BIOSCODE:1116↓r ...
tracktable      db 0, 0, 1, 2           ; DATA XREF: BIOSCODE:1088↓o
                                        ; BIOSCODE:1113↓o ...
                db 0, 0, 2, 2
                db 0, 0, 3, 2
                db 0, 0, 4, 2
                db 0, 0, 5, 2
                db 0, 0, 6, 2
                db 0, 0, 7, 2
                db 0, 0, 8, 2
                db 0, 0, 9, 2
                db 0, 0, 10, 2
                db 0, 0, 11, 2
                db 0, 0, 12, 2
                db 0, 0, 13, 2
                db 0, 0, 14, 2
                db 0, 0, 15, 2
                db 0, 0, 16, 2
                db 0, 0, 17, 2
                db 0, 0, 18, 2
                db 0, 0, 19, 2
                db 0, 0, 20, 2
                db 0, 0, 21, 2
                db 0, 0, 22, 2
                db 0, 0, 23, 2
                db 0, 0, 24, 2
                db 0, 0, 25, 2
                db 0, 0, 26, 2
                db 0, 0, 27, 2
                db 0, 0, 28, 2
                db 0, 0, 29, 2
                db 0, 0, 30, 2
                db 0, 0, 31, 2
                db 0, 0, 32, 2
                db 0, 0, 33, 2
                db 0, 0, 34, 2
                db 0, 0, 35, 2
                db 0, 0, 36, 2
dskdrvs         dw offset fdrive1       ; DATA XREF: BIOSDATA:last_dskdrv_table↓o
                                        ; BIOSDATA:2050↓o ...
                dw offset fdrive2
                dw 52 dup(0)            ; times (((4*63)-144)-4) db 0
                                        ; 4*max_sectors_curr_sup-($-tracktable)-4 dup (0)
mediatype       db 0                    ; DATA XREF: BIOSCODE:1011↓w
                                        ; SetDasd+32↓r
media_set_for_format db 0               ; DATA XREF: read_sector+22↓r
                                        ; read_sector+45↓r ...
                                        ; 1 if we have done an int 13h set media
                                        ; type for format call
had_format_error db 0                   ; DATA XREF: BIOSCODE:1151↓w
                                        ; BIOSCODE:FormatFailed↓w ...
                                        ; 1 if the previous format operation failed.
tempdpt         dd 0FFFFFFFFh           ; DATA XREF: SetMediaForFormat+60↓w
                                        ; RestoreOldDpt+11↓r ...
                                        ; -1 ; temp disk base table
model_byte      db 0FFh                 ; DATA XREF: BIOSDATA:1E71↓w
                                        ; BIOSDATA:1E88↓w ...
                                        ; model byte set at init time
secondary_model_byte db 0               ; DATA XREF: BIOSDATA:1E79↓w
                                        ; cmosck+9↓r ...
int19sem        db 0                    ; DATA XREF: BIOSDATA:076F↓r
                                        ; stackinit+37A↓w
                                        ; indicate that all int 19h initialization is complete
                                        ;
                                        ; irp    aa,<02,08,09,0a,0b,0c,0d,0e,70,72,73,74,76,77>
                                        ; public int19old&aa
                                        ; db     aa&h       ; store the number as a byte
                                        ; int19old&aa dd -1 ; original hardware int. vectors for int 19h.
                                        ; endm
i19_lst         db 2                    ; DATA XREF: BIOSDATA:0775↓o
int19old02      dd 0FFFFFFFFh           ; DATA XREF: stackinit+A9↓o
                                        ; Int19old&aa
                                        ; db aa&h
                                        ; dd -1 ; original hardware int. vectors for int 19h
                db 8
int19old08      dd 0FFFFFFFFh           ; DATA XREF: stackinit+B8↓o
                db 9
int19old09      dd 0FFFFFFFFh           ; DATA XREF: stackinit+C7↓o
                db 0Ah
int19old0A      dd 0FFFFFFFFh           ; DATA XREF: stackinit+113↓o
                db 0Bh
int19old0B      dd 0FFFFFFFFh           ; DATA XREF: stackinit+153↓o
                db 0Ch
int19old0C      dd 0FFFFFFFFh           ; DATA XREF: stackinit+193↓o
                db 0Dh
int19old0D      dd 0FFFFFFFFh           ; DATA XREF: stackinit+1D3↓o
                db 0Eh
int19old0E      dd 0FFFFFFFFh           ; DATA XREF: stackinit+213↓o
                db 70h
int19old70      dd 0FFFFFFFFh           ; DATA XREF: stackinit+D6↓o
                db 72h
int19old72      dd 0FFFFFFFFh           ; DATA XREF: stackinit+253↓o
                db 73h
int19old73      dd 0FFFFFFFFh           ; DATA XREF: stackinit+293↓o
                db 74h
int19old74      dd 0FFFFFFFFh           ; DATA XREF: stackinit+2D3↓o
                db 76h
int19old76      dd 0FFFFFFFFh           ; DATA XREF: stackinit+313↓o
                db 77h
int19old77      dd 0FFFFFFFFh           ; DATA XREF: stackinit+353↓o
int6c_ret_addr  dd 0                    ; DATA XREF: BIOSDATA:184D↓w
                                        ; BIOSDATA:1868↓r ...
bin_date_time   db 0, 0, 0, 0           ; DATA XREF: read_real_date:read_ok↓w
                                        ; read_real_date+50↓r ...
daycnt2         dw 0                    ; DATA XREF: read_real_date+E↓w
                                        ; read_real_date+2D↓w ...
cdev            dw offset chardev_entry ; DATA XREF: cdev_entry:ce_enter_codeseg↓r
cdev_2          dw 364h                 ; DATA XREF: BIOSDATA:1B79↓r
                                        ; BIOSCODE:0037↓o
                                        ; BIOSCODE segment = 364h (for PCDOS 7.1 IBMBIO.COM)
ttticks         dw offset time_to_ticks ; DATA XREF: read_real_time+34↓r
                                        ; BIOSCODE:0420↓r
                dw 364h                 ; BIOSCODE segment (70h+2F4h)
i13x            dw offset i13z          ; DATA XREF: block13+11↓r
                dw 364h                 ; BIOSCODE segment
; ---------------------------------------------------------------------------

cbreak:                                 ; DATA XREF: BIOSDATA:1EE1↓o
                mov     cs:altah, 3     ; indicate break key set

intret:                                 ; DATA XREF: BIOSDATA:1EF6↓o
                                        ; BIOSDATA:resetintf↓o
                iret
; ---------------------------------------------------------------------------

strategy:                               ; DATA XREF: BIOSDATA:0029↑o
                                        ; BIOSDATA:003B↑o ...
                mov     word ptr cs:ptrsav, bx ; store es:bx (device driver request packet)
                                        ;      away at [ptrsav] for next driver function call
                mov     word ptr cs:ptrsav+2, es
                retf
; ---------------------------------------------------------------------------

con_entry:                              ; DATA XREF: BIOSDATA:002B↑o
                call    cdev_entry
; ---------------------------------------------------------------------------
                dw offset con_table
; ---------------------------------------------------------------------------

prn0_entry:                             ; DATA XREF: BIOSDATA:004F↑o
                call    cdev_entry
; ---------------------------------------------------------------------------
                dw offset prn_table
                db 0, 0
; ---------------------------------------------------------------------------

prn1_entry:                             ; DATA XREF: BIOSDATA:0095↑o
                call    cdev_entry
; ---------------------------------------------------------------------------
                dw offset prn_table
                db 0, 1
; ---------------------------------------------------------------------------

prn2_entry:                             ; DATA XREF: BIOSDATA:00A7↑o
                call    cdev_entry
; ---------------------------------------------------------------------------
                dw offset prn_table     ; 364h:0FBh = BIOSCODE:0FBh = 70h:303Bh
                db 1, 2
; ---------------------------------------------------------------------------

prn3_entry:                             ; DATA XREF: BIOSDATA:00C0↑o
                call    cdev_entry
; ---------------------------------------------------------------------------
                dw offset prn_table
                db 2, 3
; ---------------------------------------------------------------------------

aux0_entry:                             ; DATA XREF: BIOSDATA:003D↑o
                                        ; BIOSDATA:0083↑o
                call    cdev_entry
; ---------------------------------------------------------------------------
                dw offset aux_table
                db 0
; ---------------------------------------------------------------------------

aux1_entry:                             ; DATA XREF: BIOSDATA:00D2↑o
                call    cdev_entry
; ---------------------------------------------------------------------------
                dw offset aux_table     ; 364h:130h = BIOSCODE:130h = 70h:3070h
                db 1
; ---------------------------------------------------------------------------

aux2_entry:                             ; DATA XREF: BIOSDATA:00E4↑o
                call    cdev_entry
; ---------------------------------------------------------------------------
                dw offset aux_table
                db 2
; ---------------------------------------------------------------------------

aux3_entry:                             ; DATA XREF: BIOSDATA:00F6↑o
                call    cdev_entry
; ---------------------------------------------------------------------------
                dw offset aux_table
                db 3
; ---------------------------------------------------------------------------

tim_entry:                              ; DATA XREF: BIOSDATA:0061↑o
                call    cdev_entry
; ---------------------------------------------------------------------------
                dw offset tim_table     ; 364h:147h ; BIOSCODE:147h ; 70h:3087h
; ---------------------------------------------------------------------------

dsk_entry:                              ; DATA XREF: BIOSDATA:0073↑o
                call    cdev_entry
; ---------------------------------------------------------------------------
                dw offset DSKTBL        ; 364h:579h ; BIOSCODE:579h ; 70h:34B9h

; =============== S U B R O U T I N E =======================================


cdev_entry      proc near               ; CODE XREF: BIOSDATA:con_entry↑p
                                        ; BIOSDATA:prn0_entry↑p ...
                cmp     cs:inHMA, 0
                jz      short ce_enter_codeseg ; optimized for DOS in HMA
                push    ax
                mov     ax, cs:DosDataSg
                cmp     word ptr cs:ptrsav+2, ax
                pop     ax
                jnz     short not_from_dos ; jump is coded this way to fall thru
                                        ; in 99.99% of the cases

ce_enter_codeseg:                       ; CODE XREF: cdev_entry+6↑j
                                        ; cdev_entry+1D↓j
                jmp     dword ptr cs:cdev ; jmp far [cs:cdev]
; ---------------------------------------------------------------------------

not_from_dos:                           ; CODE XREF: cdev_entry+13↑j
                call    EnsureA20On
                jmp     short ce_enter_codeseg
cdev_entry      endp


; =============== S U B R O U T I N E =======================================


outchr          proc far                ; DATA XREF: BIOSDATA:1EEA↓o
                push    ax              ; INT 29h handler
                push    si
                push    di
                push    bp
                push    bx
                push    ds
                xor     bx, bx          ; 0
                cmp     cs:IsWin386, bl ; (are we in) windows ?
                mov     ds, bx
                assume ds:nothing
                mov     ah, 0Eh
                mov     bl, 7
                jnz     short win_outchr ; Running on Windows
                pushf                   ; far call (simulate INT)
                cli
                call    dword ptr ds:40h ; far call to INT 10h vector
                jmp     short outchr_ok
; ---------------------------------------------------------------------------

win_outchr:                             ; CODE XREF: outchr+13↑j
                int     10h             ; - VIDEO -

outchr_ok:                              ; CODE XREF: outchr+1B↑j
                pop     ds
                assume ds:nothing
                pop     bx
                pop     bp
                pop     di
                pop     si
                pop     ax
                iret
outchr          endp

; ---------------------------------------------------------------------------
                db  50h ; P             ; 'PCI' signature
                db  43h ; C
                db  49h ; I
Orig1A          dd 0                    ; DATA XREF: Int1A+5↓r
                                        ; Int1A+F↓r ...

; =============== S U B R O U T I N E =======================================


Int1A           proc far                ; DATA XREF: BIOSDATA:1DD4↓o
                cmp     ah, 4           ; (Y2K-fix)
                jz      short int1a_1   ; Reads the date from the computer's real-time clock
                jmp     cs:Orig1A       ; jmp far [cs:Orig1A]
; ---------------------------------------------------------------------------

int1a_1:                                ; CODE XREF: Int1A+3↑j
                push    bp

int1a_2:
                mov     bp, sp
                push    bp
                pushf
                call    cs:Orig1A
                jb      short int1a_4
                cmp     cl, 0           ; Year (BCD)
                jnz     short int1a_3
                cmp     ch, 19h         ; Century (BCD)
                jnz     short int1a_3
                mov     ch, 20h
                mov     ah, 5           ; Sets the date on the computer's real-time clock
                push    cx
                push    dx              ; dh = Month (BCD), dl = Day (BCD)
                pushf
                call    cs:Orig1A       ; call far [cs:Orig1A]
                pop     dx
                pop     cx
                jb      short int1a_4

int1a_3:                                ; CODE XREF: Int1A+19↑j
                                        ; Int1A+1E↑j
                pop     bp
                and     byte ptr [bp+6], 0FEh ; clear carry flag
                jmp     short int1a_5
; ---------------------------------------------------------------------------

int1a_4:                                ; CODE XREF: Int1A+14↑j
                                        ; Int1A+2E↑j
                pop     bp
                or      byte ptr [bp+6], 1 ; set carry flag

int1a_5:                                ; CODE XREF: Int1A+35↑j
                pop     bp
                iret
Int1A           endp


; =============== S U B R O U T I N E =======================================


block13         proc far                ; DATA XREF: BIOSDATA:1DBC↓o
                cmp     cs:inHMA, 0
                jz      short skipa20
                call    EnsureA20On     ; assure a20 enabled

skipa20:                                ; CODE XREF: block13+6↑j
                mov     cs:i13_ds, ds   ; save caller's ds for call-through
                pushf                   ; fake interrupt
                call    dword ptr cs:i13x ; call through Bios_Code entry table
                mov     ds, cs:i13_ds
                retf    2
block13         endp


; =============== S U B R O U T I N E =======================================


call_orig13     proc far
                mov     ds, ds:i13_ds   ; get caller's ds register
                pushf
                call    cs:Orig13
                mov     cs:i13_ds, ds
                push    cs
                pop     ds              ; restore ds -> Bios_Data before return
                assume ds:BIOSDATA
                pushf
                cmp     cs:inHMA, 0
                jz      short corig13_popf_retf
                call    EnsureA20On

corig13_popf_retf:                      ; CODE XREF: call_orig13+18↑j
                popf

re_init:
                retf
call_orig13     endp


; =============== S U B R O U T I N E =======================================


EnsureA20On     proc near               ; CODE XREF: cdev_entry:not_from_dos↑p
                                        ; block13+8↑p ...
                call    IsA20Off
                jnz     short enable_A20_ok

EnableA20:                              ; A20 line is OFF
                push    ax
                push    bx
                mov     ah, 5           ; local enable A20
                call    cs:xms
                pop     bx
                pop     ax

enable_A20_ok:                          ; CODE XREF: EnsureA20On+3↑j
                retn
EnsureA20On     endp


; =============== S U B R O U T I N E =======================================


IsA20Off        proc near               ; CODE XREF: EnsureA20On↑p
                push    ds
                push    es
                push    cx
                push    si
                push    di
                xor     di, di
                mov     es, di
                assume es:nothing
                dec     di
                mov     si, 90h
                mov     ds, di          ; 0FFFFh:0090h ; HiMem
                assume ds:nothing
                mov     di, 80h         ; 0000h:0080h ; LoMem

cpu386_cmpsd:                           ; DATA XREF: SYSINIT:0506↓o
                nop
                mov     cx, 8
                repe cmpsw              ;
                                        ; zf = 0 -> A20 line is ON
                                        ; zf = 1 -> A20 line is OFF
                pop     di
                pop     si
                pop     cx
                pop     es
                assume es:nothing
                pop     ds
                retn
IsA20Off        endp

; ---------------------------------------------------------------------------

int19:                                  ; DATA XREF: BIOSDATA:1DE8↓o
                push    cs
                pop     ds
                assume ds:BIOSDATA
                xor     cx, cx
                mov     es, cx
                assume es:nothing
                mov     cl, 5
                mov     si, offset RomVectors

_next_int:                              ; CODE XREF: BIOSDATA:076D↓j
                lodsb                   ; get int number
                cbw                     ; assume < 128
                shl     ax, 1
                shl     ax, 1           ; int * 4
                xchg    ax, di
                movsw
                movsw                   ; install the saved vector
                loop    _next_int
                cmp     int19sem, cl    ; 0
                jz      short doint19
                mov     si, offset i19_lst ; stacks code has changed these hardware interrupt vectors
                                        ; stkinit in sysinit1 will initialize int19oldxx values
                mov     cl, 14          ; num_i19

i19_restore_loop:                       ; CODE XREF: BIOSDATA:i19_restor_1↓j
                lodsb                   ; get interrupt number
                cbw                     ; assume < 128
                xchg    ax, di
                lodsw                   ; get original vector offset
                xchg    ax, bx          ; save it
                lodsw
                inc     bx              ; check for 0ffffh (unlikely segment)
                jz      short i19_restor_1 ; opt no need to check selector too
                dec     bx
                add     di, di
                add     di, di
                xchg    ax, bx
                stosw
                xchg    ax, bx
                stosw                   ; put the vector back

i19_restor_1:                           ; CODE XREF: BIOSDATA:0781↑j
                loop    i19_restore_loop

doint19:                                ; CODE XREF: BIOSDATA:0773↑j
                cmp     inHMA, cl       ; Is dos running from HMA ?
                jz      short SkipVDisk ; no
                call    EraseVDiskHead  ; Then erase our VDISK header at 1MB boundary
                                        ; Some m/c's (AST 386 & HP QS/16 do not clear
                                        ; the memory above 1MB during a warm boot.

SkipVDisk:                              ; CODE XREF: BIOSDATA:0792↑j
                int     19h             ; DISK BOOT
                                        ; causes reboot of disk system

Int15:                                  ; DATA XREF: BIOSDATA:1DDE↓o
                cmp     ax, 4F53h       ; del keystroke ?  (4F00h+DELKEY)
                jz      short int15_1

Old15_j:                                ; CODE XREF: BIOSDATA:07BF↓j
                jmp     cs:Old15
; ---------------------------------------------------------------------------

int15_1:                                ; CODE XREF: BIOSDATA:079C↑j
                push    ds
                push    ax
                xor     ax, ax
                mov     ds, ax
                assume ds:nothing
                mov     al, byte ptr ds:417h ; [KBFLAG]
                and     al, 0Ch         ; (CTRLSTATE | ALTSTATE)
                cmp     al, 0Ch         ; (CTRLSTATE | ALTSTATE)
                jnz     short int15_2
                cmp     cs:inHMA, ah    ; is DOS running from HMA ?
                jz      short int15_2   ; no
                call    EraseVDiskHead

int15_2:                                ; CODE XREF: BIOSDATA:07B0↑j
                                        ; BIOSDATA:07B7↑j
                pop     ax
                pop     ds
                assume ds:nothing
                stc
                jmp     short Old15_j

; =============== S U B R O U T I N E =======================================


EraseVDiskHead  proc near               ; CODE XREF: BIOSDATA:0794↑p
                                        ; BIOSDATA:07B9↑p
                push    cx
                push    di
                push    es
                call    EnsureA20On
                push    0FFFFh          ; HMA seg
                pop     es
                assume es:nothing
                mov     di, 10h         ; point to VDISK header
                mov     cx, di          ; size of vdisk header = 16
                xor     ax, ax
                rep stosw               ; clear it
                pop     es
                assume es:nothing
                pop     di
                pop     cx
                retn
EraseVDiskHead  endp

; ---------------------------------------------------------------------------
FreeHMAPtr      dw 0FFFFh               ; DATA XREF: BIOSCODE:1799↓w
                                        ; BIOSCODE:179F↓w ...
MoveDOSIntoHMA  dw offset FTRYTOMOVDOSHI
                                        ; DATA XREF: HMAptr+15↓r
                                        ; SYSINITSEG:FTRYTOMOVDOSHI
MoveDOSIntoHMA_2 dw 544h                ; DATA XREF: SYSINIT:0518↓w
                                        ; SYSINITSEG
SysinitPresent  db 0                    ; DATA XREF: HMAptr+E↓r
                                        ; SYSINIT:BiosComBlock↓o ...
Win386_SI       db 3, 0                 ; DATA XREF: BIOSCODE:1754↓o
SI_Next         dd 0                    ; DATA XREF: BIOSCODE:174C↓w
                                        ; BIOSCODE:1750↓w
                dd 0
                dd 0
                dw offset Instance_Table
                dw 70h
Instance_Table  dw 0                    ; DATA XREF: BIOSDATA:07EC↑o
                                        ; print screen status
                dw 50h
                dw 2                    ; 2 bytes
                dw 0Eh                  ; ROM Basic data
                dw 50h
                dw 14h                  ; 20 bytes
                dw offset altah         ; a con device buffer
                dw 70h
                dw 1
NextStack       dw 2 dup(0)             ; DATA XREF: endfile+297↓w
                                        ; endfile+29D↓w
                                        ; pointer to next stack to be used
                dw 2                    ; 2 bytes
IT_StackLoc     dd 0                    ; DATA XREF: endfile+2A9↓w
                                        ; endfile+2B4↓w
                                        ; location of hardware stacks
IT_StackSize    dw 0                    ; DATA XREF: endfile+2C4↓w
                                        ; size of hardware stacks
                dd 0                    ; terminate the instance table
IsWin386        db 0                    ; DATA XREF: outchr+8↑r
                                        ; BIOSCODE:173A↓w ...
                                        ; Flag to indicate whether
                                        ; Win386 is running or not
; ---------------------------------------------------------------------------

V86_Crit_SetFocus:
                push    di
                push    es
                push    bx
                push    ax
                xor     di, di
                mov     es, di
                assume es:nothing

offset_081Bh:                           ; CODE XREF: doint+13↓P
                                        ; BIOSCODE:18D7↓P ...
                mov     bx, 15h         ; Device ID of DOSMGR device
                mov     ax, 1684h
                int     2Fh             ; - Multiplex - MS WINDOWS - GET DEVICE API ENTRY POINT
                                        ; BX = virtual device (VxD) ID, ES:DI = 0000h:0000h
                                        ; Return: ES:DI -> VxD API entry point, or 0:0 if the VxD does not support an API
                mov     ax, es
                or      ax, di
                jz      short Skip
                push    cs
                push    offset Skip
                push    es
                push    di              ; API far call address
                mov     ax, 1           ; SetFocus function number
                retf                    ; do the call
; ---------------------------------------------------------------------------

Skip:                                   ; CODE XREF: BIOSDATA:0827↑j
                                        ; DATA XREF: BIOSDATA:082A↑o
                pop     ax
                pop     bx
                pop     es
                assume es:nothing
                pop     di
                retf
; ---------------------------------------------------------------------------
endfloppy       db 0                    ; DATA XREF: BIOSDATA:2263↓o
offset_0839h    db 7 dup(0)             ; CODE XREF: SYSINIT:06EB↓P
tmp_vid         db 'NO NAME    '        ; DATA XREF: read_volume_id+8↓o
                                        ; read_volume_id+7B↓o ...
harddrv         db 80h                  ; DATA XREF: BIOSDATA:1FCC↓o
                                        ; BIOSDATA:2259↓o
bdss            dw 0FFFFh               ; DATA XREF: BIOSDATA:end_of_bdss↓o
                                        ; BIOSDATA:2253↓o
                                        ; max_mini_dsk_num equ 23
                                        ; BDS_STRUC (2+max_mini_dsk_num) dup (<>)
                                        ; currently max. 25
                                        ; (MSDOS 6 BDS structure size = 100 bytes)
                                        ; (PCDOS 7.1 BDS structure size = 150 bytes)
                                        ; BDS.link
                dw 0
                db 80                   ; BDS.drivenum
                db 3                    ; BDS.drivelet
                dw 512                  ; BDS.BPB (BDS offset 6)
                                        ; 53 bytes BPB for FAT32 fs
                                        ; 25 bytes BPB for FAT16 and FAT12 fs
                                        ; .bytespersec
                db 1                    ; .secperclus
                dw 1                    ; .resectors
                db 2                    ; .fats
                dw 16                   ; .direntries
                dw 0                    ; .totalsec16
                db 0F8h                 ; .media
                dw 1                    ; .fatsecs16
                dw 0                    ; .secpertrack
                dw 0                    ; .heads
                dd 0                    ; .hiddensectors
                dd 0                    ; .totalsecs32
                                        ; (End of FAT12/FAT16 BPB)
                                        ;
                                        ; FAT32 extensions to BDS
                dd 0                    ; .fatsecs32 ; BPB_FATSz32 (BDS offset 31)
                dw 0                    ; .extflags ; BPB_ExtFlags
                dw 0                    ; .fsver ; BPB_FSVer
                dd 0                    ; .rootdirclust ; BPB_RootClus (BDS offset 39)
                dw 0FFFFh               ; .fsinfo ; BPB_FSInfo ; initialized to -1
                dw 0FFFFh               ; .bkbootsec ; BPB_BkBootSec ; initialized to -1
                db 12 dup(0)            ; .reserved ; BPB_Reserved (12 zero bytes)
                db 0                    ; BDS.fatsiz (BDS offset 59)
                dw 0                    ; BDS.opcnt
                db 3
                dw 20h                  ; BDS.flags (BDS offset 63)
                dw 40
                db 37 dup(0)
                dd 0FFFFFFFFh
                db 12 dup(0)
                db -1                   ; BDS.track (BDS offset 120)
                dw 1                    ; BDS.tim_lo ; BDS.bdsm_ismini
                dw 0                    ; BDS.tim_hi
                db 'NO NAME    ',0      ; BDS.volid
                dd 0                    ; BDS.vol_serial (BDS offset 137)
                db 'FAT12   ',0         ; BDS.filesys_id
bds_1           dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
bds_2           dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
bds_3           dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
bds_4           dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
                dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
bds_24          dw 0FFFFh
                db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
                db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
                db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
                db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
                db 54h, 31h, 32h, 20h, 20h, 20h, 0
; ---------------------------------------------------------------------------

ibm_disk_io:                            ; DATA XREF: BIOSDATA:228E↓o
                cmp     dl, 80h         ; main routine, fixes at rom bug
                                        ; pass through floppy disk calls
                jb      short atd1
                cmp     ah, 2
                jz      short atd2      ; intercept call 02h (read sectors)
                cmp     ah, 0Ah         ; and call 0Ah (read long)
                jz      short atd2

atd1:                                   ; CODE XREF: BIOSDATA:16F5↑j
                jmp     cs:Old13        ; use rom int 13h handler
; ---------------------------------------------------------------------------

atd2:                                   ; CODE XREF: BIOSDATA:16FA↑j
                                        ; BIOSDATA:16FF↑j
                push    bx
                push    cx
                push    dx
                push    di
                push    ds
                push    es
                push    ax
                mov     ax, 40h         ; rombios data segment
                mov     ds, ax
                assume ds:nothing
                mov     byte ptr ds:74h, 0 ; [disk_status1]
                                        ; initially no error code
                and     dl, 7Fh         ; mask to hard disk number
                cmp     dl, ds:75h      ; [hf_num] ; 40h:75h
                jb      short atd3      ; disk number in range
                mov     byte ptr ds:74h, 1 ; [disk_status1]
                jmp     short atd4      ; disk number out of range error, return
; ---------------------------------------------------------------------------

atd3:                                   ; CODE XREF: BIOSDATA:171E↑j
                push    bx
                mov     ax, es
                shr     bx, 4           ; make es:bx to seg:000x form
                add     ax, bx
                mov     es, ax
                pop     bx
                and     bx, 0Fh
                push    cs
                call    check_dma
; ---------------------------------------------------------------------------
                jb      short atd4      ; abort if dma across segment boundary
                pop     ax
                push    ax
                call    setcmd          ; set up command block for disk op
; ---------------------------------------------------------------------------
                mov     dx, 3F6h        ; hf_reg_port
                out     dx, al          ; AT only. Fixed disk register
                call    docmd           ; carry out command
; ---------------------------------------------------------------------------

atd4:                                   ; CODE XREF: BIOSDATA:1725↑j
                                        ; BIOSDATA:1739↑j
                pop     ax
                mov     ah, ds:74h      ; [disk_status1]
                or      ah, ah
                jz      short atd5
                stc

atd5:                                   ; CODE XREF: BIOSDATA:174E↑j
                pop     es
                pop     ds
                assume ds:nothing
                pop     di
                pop     dx
                pop     cx
                pop     bx
                retf    2

; =============== S U B R O U T I N E =======================================

; Attributes: noreturn

setcmd          proc near               ; CODE XREF: BIOSDATA:173D↑p
                mov     ds:43h, al      ; [cmd_block+sec_cnt]
                mov     byte ptr ds:48h, 20h
                cmp     ah, 2           ; cmd_reg = 20h if function 02h (read)
                jz      short setc1
                mov     byte ptr ds:48h, 22h ; [cmd_block+cmd_reg]
                                        ; cmd_reg = 22h if function 0Ah (read long)

setc1:                                  ; CODE XREF: setcmd+B↑j
                mov     al, cl
                and     al, 3Fh         ; mask sector number
                mov     ds:44h, al      ; [cmd_block+sec_num]
                mov     ds:45h, ch      ; [cmd_block+cyl_low]
                mov     al, cl
                shr     al, 6           ; get two high bits of cylinder number
                mov     ds:46h, al      ; [cmd_block+cyl_high]
                mov     ax, dx
                shl     al, 4           ; drive number
                and     ah, 0Fh
                or      al, ah          ; head number
                or      al, 0A0h        ; set ecc and 512 bytes per sector
                mov     ds:47h, al      ; [cmd_block+drv_head]
                push    es
                push    bx
                push    cs
                call    get_vec
; ---------------------------------------------------------------------------
                mov     ax, es:[bx+5]   ; [es:bx+fdp_precomp]
                                        ; write pre-comp from disk parameters
                shr     ax, 2
                mov     ds:42h, al      ; [cmd_block+pre_comp]
                mov     al, es:[bx+8]   ; [es:bx+fdp_control]
                                        ; control byte modifier
                pop     bx
                pop     es
                mov     ah, ds:76h      ; [control_byte]
                and     ah, 0C0h        ; keep disable retry bits
                or      ah, al
                mov     ds:76h, ah
                retn
setcmd          endp


; =============== S U B R O U T I N E =======================================

; Attributes: noreturn

docmd           proc near               ; CODE XREF: BIOSDATA:1744↑p
                mov     di, bx
                push    cs
                call    command
; ---------------------------------------------------------------------------
                jnz     short doc3

doc1:                                   ; CODE XREF: docmd+3B↓j
                push    cs
                call    waitt           ; wait for controller to complete read
; ---------------------------------------------------------------------------
                jnz     short doc3
                mov     cx, 256
                mov     dx, 1F0h        ; hf_port
                cld
                cli

rsct_loop:                              ; CODE XREF: docmd+17↓j
                insw                    ; read in sector
                loop    rsct_loop
                sti
                test    byte ptr ds:48h, 2 ; [cmd_block+cmd_reg]
                jz      short doc2
                push    cs
                call    wait_drq
; ---------------------------------------------------------------------------
                jb      short doc3
                mov     cx, 4           ; 4 bytes of ecc
                mov     dx, 1F0h
                cli
                rep insb                ; read in ecc
                sti

doc2:                                   ; CODE XREF: docmd+1F↑j
                push    cs
                call    check_status
; ---------------------------------------------------------------------------
                jnz     short doc3
                dec     byte ptr ds:43h ; [cmd_block+sec_cnt]
                jnz     short doc1

doc3:                                   ; CODE XREF: docmd+6↑j
                                        ; docmd+C↑j ...
                retn
docmd           endp


; =============== S U B R O U T I N E =======================================

; Attributes: noreturn

get_vec         proc near               ; CODE XREF: setcmd+37↑p
                push    0FF65h          ; get pointer to hard disk parameters
                jmp     far ptr 0F000h:2F8Eh
get_vec         endp


; =============== S U B R O U T I N E =======================================

; Attributes: noreturn

command         proc near               ; CODE XREF: docmd+3↑p
                push    0FF65h          ; send contents of cmd_block to disk controller
                jmp     far ptr 0F000h:2E1Eh
command         endp


; =============== S U B R O U T I N E =======================================

; Attributes: noreturn

waitt           proc near               ; CODE XREF: docmd+9↑p
                push    0FF65h          ; wait for disk interrupt
                jmp     far ptr 0F000h:2E7Fh
waitt           endp


; =============== S U B R O U T I N E =======================================

; Attributes: noreturn

wait_drq        proc near               ; CODE XREF: docmd+22↑p
                push    0FF65h          ; wait for data request
                jmp     far ptr 0F000h:2EE2h
wait_drq        endp


; =============== S U B R O U T I N E =======================================

; Attributes: noreturn

check_status    proc near               ; CODE XREF: docmd+32↑p
                push    0FF65h          ; check hard disk status
                jmp     far ptr 0F000h:2EF8h
check_status    endp


; =============== S U B R O U T I N E =======================================

; Attributes: noreturn

check_dma       proc near               ; CODE XREF: BIOSDATA:1736↑p
                push    0FF65h          ; check for dma overrun 64k segment
                jmp     far ptr 0F000h:2F69h
check_dma       endp

; ---------------------------------------------------------------------------

endatrom:                               ; DATA XREF: BIOSDATA:228B↓o
                                        ; BIOSDATA:22E3↓o
                cmp     ah, 15h         ; compaq_disk_io
                ja      short mebbe_hookit

no_hookit:                              ; CODE XREF: BIOSDATA:182D↓j
                jmp     cs:Old13
; ---------------------------------------------------------------------------

mebbe_hookit:                           ; CODE XREF: BIOSDATA:1823↑j
                cmp     dl, 80h
                jb      short no_hookit
                push    ds
                push    40h
                pop     ds
                assume ds:nothing
                pushf
                call    cs:Old13
                pop     ds
                assume ds:nothing
                retf    2
; ---------------------------------------------------------------------------
end_compaq_i13hook db 0                 ; DATA XREF: BIOSDATA:do_compaq_patch↓o
; ---------------------------------------------------------------------------

int_6Ch:                                ; DATA XREF: BIOSDATA:2315↓o
                cmp     cs:inHMA, 0     ; The K09 requires the routines for reading the clock
                                        ; because of the suspend/resume facility.
                jz      short int6c
                mov     bx, offset EnsureA20On
                call    bx ; EnsureA20On

int6c:                                  ; CODE XREF: BIOSDATA:1844↑j
                push    cs
                pop     ds
                assume ds:BIOSDATA
                pop     word ptr int6c_ret_addr
                pop     word ptr int6c_ret_addr+2
                popf
                call    read_real_date  ; get the date from the clock
                cli
                mov     daycnt, si      ; update dos copy of date
                sti
                call    read_real_time  ; get the time from the   rtc
                cli
                mov     ah, 1
                int     1Ah             ; CLOCK - SET TIME OF DAY
                                        ; CX:DX = clock count
                                        ; Return: time of day set
                sti
                jmp     int6c_ret_addr  ; jmp far [int6c_ret_addr] ; long jump

; =============== S U B R O U T I N E =======================================


read_real_date  proc near               ; CODE XREF: BIOSDATA:1856↑p
                                        ; cmos_clock_read+2F↓p
                push    ax
                push    cx
                push    dx
                xor     ah, ah          ; throw away clock roll over
                int     1Ah             ; CLOCK - GET TIME OF DAY
                                        ; Return: CX:DX = clock count
                                        ; AL = 00h if clock was read or written (via AH=0,1) since the previous
                                        ; midnight
                                        ; Otherwise, AL > 0
                pop     dx
                pop     cx
                pop     ax
                push    ax
                push    bx
                push    cx
                push    dx
                mov     daycnt2, 1
                mov     ah, 4
                int     1Ah             ; CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
                                        ; Return: DL = day in BCD
                                        ; DH = month in BCD
                                        ; CL = year in BCD
                                        ; CH = century (19h or 20h)
                jnb     short read_ok
                jmp     r_d_ret
; ---------------------------------------------------------------------------

read_ok:                                ; CODE XREF: read_real_date+18↑j
                mov     bin_date_time, ch
                mov     bin_date_time+1, cl
                mov     bin_date_time+2, dh
                mov     bin_date_time+3, dl
                mov     daycnt2, 2      ; READ OF R-T CLOCK SUCCESSFUL
                call    bcd_verify      ; verify bcd values in range
                jb      short r_d_ret   ; some value out of range
                mov     daycnt2, 3
                call    date_verify
                jb      short r_d_ret
                mov     daycnt2, 0
                call    in_bin
                mov     al, bin_date_time+1
                cbw
                cmp     bin_date_time, 20 ; 20th century?
                jnz     short century_19
                add     ax, 100         ; add in a century

century_19:                             ; CODE XREF: read_real_date+55↑j
                sub     ax, 80          ; subtract off 1-1-80
                mov     cl, 4           ; leap year every 4
                div     cl              ; al= # leap year blocks, ah= remainder
                mov     bl, ah          ; save odd years
                cbw                     ; zero ah
                mov     cx, 1461        ; 366+(3*365)
                                        ; # of days in leap year blocks
                mul     cx
                mov     daycnt2, ax     ; SAVE COUNT OF DAYS
                mov     al, bl          ; get odd years count
                cbw
                or      ax, ax
                jz      short leap_year
                mov     cx, 365         ; days in year
                mul     cx
                add     daycnt2, ax     ; ADD ON DAYS IN ODD YEARS
                jmp     short leap_adjustment ; account for leap year
                                        ; possibly account for a leap day
; ---------------------------------------------------------------------------

leap_year:                              ; CODE XREF: read_real_date+71↑j
                cmp     bin_date_time+2, 2 ; is month february?
                jbe     short no_leap_adjustment ; jan or feb. no leap day yet

leap_adjustment:                        ; CODE XREF: read_real_date+7C↑j
                inc     daycnt2         ; account for leap day

no_leap_adjustment:                     ; CODE XREF: read_real_date+83↑j
                mov     cl, bin_date_time+3 ; get days of month
                xor     ch, ch
                dec     cx              ; because of offset from day 1, not day 0
                add     daycnt2, cx     ; GET DAYS IN MONTHS PRECEEDING
                mov     cl, bin_date_time+2 ; get month
                dec     cx              ; january starts at offset 0
                jz      short r_d_ret
                mov     ah, 0
                mov     si, offset month_table

r_d_sum_loop:                           ; CODE XREF: read_real_date+A5↓j
                lodsb
                add     daycnt2, ax
                loop    r_d_sum_loop

r_d_ret:                                ; CODE XREF: read_real_date+1A↑j
                                        ; read_real_date+36↑j ...
                mov     si, daycnt2
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                retn
read_real_date  endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR read_real_time

r_t_retj:                               ; CODE XREF: read_real_time+4↓j
                                        ; read_real_time+1A↓j ...
                xor     cx, cx
                xor     dx, dx
                jmp     short r_t_ret
; END OF FUNCTION CHUNK FOR read_real_time

; =============== S U B R O U T I N E =======================================


read_real_time  proc near               ; CODE XREF: BIOSDATA:185F↑p

; FUNCTION CHUNK AT 191C SIZE 00000006 BYTES

                mov     ah, 2
                int     1Ah             ; CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)
                                        ; Return: CH = hours in BCD
                                        ; CL = minutes in BCD
                                        ; DH = seconds in BCD
                jb      short r_t_retj
                mov     bin_date_time, ch
                mov     bin_date_time+1, cl
                mov     bin_date_time+2, dh
                mov     bin_date_time+3, 0 ; unused for time
                call    bcd_verify
                jb      short r_t_retj
                call    time_verify
                jb      short r_t_retj
                call    in_bin          ; from bcd to bin
                mov     ch, bin_date_time
                mov     cl, bin_date_time+1
                mov     dh, bin_date_time+2
                mov     dl, bin_date_time+3
                call    dword ptr ttticks ; call far [ttticks]
                                        ; note: indirect far call
                                        ; cx:dx = number of ticks
                                        ; (at 18.2 ticks per sec.)

r_t_ret:                                ; CODE XREF: read_real_time-2↑j
                retn
read_real_time  endp


; =============== S U B R O U T I N E =======================================


in_bin          proc near               ; CODE XREF: read_real_date+49↑p
                                        ; read_real_time+21↑p
                mov     al, bin_date_time ; century or hours
                call    bcd_to_bin
                mov     bin_date_time, al
                mov     al, bin_date_time+1 ; years or minutes
                call    bcd_to_bin
                mov     bin_date_time+1, al
                mov     al, bin_date_time+2 ; months or seconds
                call    bcd_to_bin
                mov     bin_date_time+2, al
                mov     al, bin_date_time+3 ; days (not used for time)
                call    bcd_to_bin
                mov     bin_date_time+3, al
                retn
in_bin          endp


; =============== S U B R O U T I N E =======================================


bcd_to_bin      proc near               ; CODE XREF: in_bin+3↑p
                                        ; in_bin+C↑p ...
                mov     ah, al          ; bcd_to_bin converts two bcd nibbles in al
                                        ; (value <= 99.) to a binary representation in al
                and     al, 0Fh
                mov     cl, 4
                shr     ah, cl
                aad
                retn
bcd_to_bin      endp


; =============== S U B R O U T I N E =======================================


date_verify     proc near               ; CODE XREF: read_real_date+3E↑p
                cmp     bin_date_time, 20h ; century check
                ja      short date_error
                jz      short century_20 ; jmp in 21th century
                cmp     bin_date_time, 19h ; century check
                jb      short date_error
                cmp     bin_date_time+1, 80h ; year check
                jb      short date_error

century_20:                             ; CODE XREF: date_verify+7↑j
                cmp     bin_date_time+1, 99h ; year check
                ja      short date_error
                cmp     bin_date_time+2, 12h ; month check
                ja      short date_error
                cmp     bin_date_time+2, 0
                jbe     short date_error
                cmp     bin_date_time+3, 31h ; day check
                ja      short date_error
                cmp     bin_date_time+3, 0
                jbe     short date_error
                clc
                retn
; ---------------------------------------------------------------------------

date_error:                             ; CODE XREF: date_verify+5↑j
                                        ; date_verify+E↑j ...
                stc
                retn
date_verify     endp


; =============== S U B R O U T I N E =======================================


time_verify     proc near               ; CODE XREF: read_real_time+1C↑p
                cmp     bin_date_time, 24h ; hour check
                ja      short time_error
                cmp     bin_date_time+1, 59h ; minute check
                ja      short time_error
                cmp     bin_date_time+2, 59h ; second check
                ja      short time_error
                clc
                retn
; ---------------------------------------------------------------------------

time_error:                             ; CODE XREF: time_verify+5↑j
                                        ; time_verify+C↑j ...
                stc
                retn
time_verify     endp


; =============== S U B R O U T I N E =======================================


bcd_verify      proc near               ; CODE XREF: read_real_date+33↑p
                                        ; read_real_time+17↑p
                mov     cx, 4           ; 4 bytes to check
                mov     bx, offset bin_date_time

bv_loop:                                ; CODE XREF: bcd_verify+23↓j
                mov     al, [bx]        ; get a bcd number (0..99)
                mov     ah, al
                and     ax, 0F00Fh      ; 10's place in high ah, 1's in al
                                        ; is 1's place in range?
                cmp     al, 10
                ja      short bv_error  ; jmp out of range
                shr     ah, 1
                shr     ah, 1
                shr     ah, 1
                shr     ah, 1
                and     ah, 0Fh         ; get rid of any erroneous bits
                cmp     ah, 10          ; is 10's place in range
                ja      short bv_error  ; jmp out of range
                inc     bx              ; next byte
                dec     cx
                jnz     short bv_loop
                clc                     ; set success flag
                retn
; ---------------------------------------------------------------------------

bv_error:                               ; CODE XREF: bcd_verify+F↑j
                                        ; bcd_verify+1F↑j
                stc                     ; set error flag
                retn
bcd_verify      endp

; ---------------------------------------------------------------------------
endk09          db 90h
drvfat          dw 0                    ; DATA XREF: BIOSDATA:1F31↓w
                                        ; BIOSDATA:2332↓r ...
First_Data_Sector dw 2 dup(0)           ; DATA XREF: BIOSDATA:1CEF↓w
                                        ; BIOSDATA:2377↓w ...
doscnt          dw 0                    ; DATA XREF: getclus+2↓w
                                        ; getclus+D2↓w ...
fbigfat         db 0                    ; DATA XREF: BIOSDATA:236C↓w
                                        ; BIOSDATA:2397↓r ...
fatloc          dw 0                    ; DATA XREF: BIOSDATA:1F60↓w
                                        ; getclus+38↓r
init_bootseg    dw 0                    ; DATA XREF: BIOSDATA:1F67↓w
                                        ; getboot↓r
rom_drv_num     db 80h                  ; DATA XREF: sethard:set2↓w
                                        ; sethard+1BB↓r ...
md_sectorsize   dw 200h                 ; DATA XREF: BIOSDATA:2364↓w
                                        ; get_fat_sector+8↓r ...
temp_cluster    dw 0                    ; DATA XREF: getclus+79↓w
                                        ; getclus+8C↓r ...
last_fat_sec_num dw 0FFFFh              ; DATA XREF: get_fat_sector+29↓r
                                        ; get_fat_sector+30↓w
num_heads       dw 2                    ; DATA XREF: BIOSDATA:209D↓w
                                        ; BIOSDATA:20EB↓w ...
sec_trk         db 9                    ; DATA XREF: BIOSDATA:20A9↓w
                                        ; BIOSDATA:20F3↓w ...
num_cyln        dw 40                   ; DATA XREF: BIOSDATA:2063↓w
                                        ; BIOSDATA:20A3↓w ...
fakefloppydrv   db 0                    ; DATA XREF: BIOSDATA:_set_fake_flpdrv↓w
                                        ; BIOSDATA:2027↓r ...
Orig_Int1Eh_Table dw 2 dup(0)           ; DATA XREF: BIOSDATA:1C85↓r
                                        ; BIOSDATA:1CE0↓w ...
                                        ;
                                        ; 08/08/2023
                                        ; ; disktable.totalsectors: resd 1
                                        ; ; disktable.shiftcount:   resb 1
                                        ; ; disktable.secperclus:   resb 1
                                        ; ; disktable.rdirentries:  resw 1
                                        ; ; disktable.bigflag:      resw 1
disktable2      dw 0                    ; DATA XREF: copybpb_fat+10C↓o
                dw 32680
                dw 803h
                dw 512
                dw 0                    ; for compatibility. (32680 sectors, 16340 KB)
                dw 4
                dw 0
                dw 402h
                dw 512
                dw 40h                  ; covers upto 134 mb media. ; fbig = 40h
                                        ; (40000h sectors = 128 MB)
                dw 8
                dw 0
                dw 803h
                dw 512
                dw 40h                  ; upto 268 mb (80000h sectors = 256 MB)
                dw 16
                dw 0
                dw 1004h
                dw 512
                dw 40h                  ; upto 536 mb (100000h sectors = 512 MB)
                dw 32
                dw 0
                dw 2005h
                dw 512
                dw 40h                  ; upto 1072 mb (200000h sectors = 1024 MB)
                dw 64
                dw 0
                dw 4006h
                dw 512
                dw 40h                  ; upto 2144 mb (400000h sectors = 2048 MB)
                dw 0FFFFh               ; if fs size > 2144 MB, it is FAT32 file system
                dw 0FFFFh
                dw 803h                 ; cluster shift 3, sec per clust = 8
                dw 0
                dw 60h                  ; > 2144 MB ; FAT32 (fbigbig = 20h)
                                        ; (fbig and fbigbig flags are set)
                                        ; ;
rom_minidisk_num db 0                   ; DATA XREF: domini+1E↓w
                                        ; domini+37↓r ...
hnum            db 0                    ; DATA XREF: BIOSDATA:2017↓w
                                        ; BIOSDATA:dohard↓r ...
last_dskdrv_table dw offset dskdrvs     ; DATA XREF: BIOSDATA:1FDD↓w
                                        ; BIOSDATA:2053↓w ...
end_of_bdss     dw offset bdss          ; DATA XREF: BIOSDATA:2056↓r
                                        ; BIOSDATA:21F7↓r ...
mini_hdlim      dw 0                    ; DATA XREF: domini+2B↓w
                                        ; find_mini_partition+4A↓r
mini_seclim     dw 0                    ; DATA XREF: domini+33↓w
                                        ; find_mini_partition:fmpgot1↓r
ld_p_number     dw 2BADh                ; DATA XREF: find_mini_partition+4↓w
                                        ; find_mini_partition:fmpnext↓w ...
bios_date       db '01/10/84',0         ; DATA XREF: BIOSDATA:227D↓o
                db 90h
bpb48t          dw 512                  ; DATA XREF: BIOSDATA:bpbtable↓o
                db 2
                dw 1
                db 2
                dw 112
                dw 720
                db 0FDh
                dw 2
                dw 9
                dw 2
                dw 0
                dw 0
                dw 0
                dw 0
                db 28 dup(0)            ; FAT32 extensions (to BDS)
                db 90h
bpb96t          dw 512                  ; DATA XREF: BIOSDATA:1B60↓o
                db 1
                dw 1
                db 2
                dw 224
                dw 2400
                db 0F9h
                dw 7
                dw 15
                dw 2
                dw 0
                dw 0
                db 0
                db 0
                db 0
                db 0
                db 28 dup(0)
                db 90h
bpb35           dw 512                  ; DATA XREF: BIOSDATA:1B62↓o
                                        ; BIOSDATA:1B64↓o ...
                db 2
                dw 1
                db 2
                dw 112
                dw 1440
                db 0F9h
                dw 3
                dw 9
                dw 2
                dw 0
                dw 0
                dd 0
                db 28 dup(0)
                db 90h
bpb288          dw 512                  ; DATA XREF: BIOSDATA:1B70↓o
                db 2
                dw 1
                db 2
                dw 240
                dw 5760
                db 0F0h
                dw 9
                dw 36
                dw 2
                dw 0
                dw 0
                dd 0
                db 28 dup(0)
                db 90h
bpbtable        dw offset bpb48t        ; DATA XREF: setdrvparms+A0↓o
                dw offset bpb96t
                dw offset bpb35
                dw offset bpb35
                dw offset bpb35
                dw offset bpb35
                dw offset bpb35
                dw offset bpb35
                dw offset bpb35
                dw offset bpb288
addr_of_bcretf  dw offset bc_retf       ; DATA XREF: BIOSDATA:call_bios_code↓r
; ---------------------------------------------------------------------------

call_bios_code:                         ; CODE XREF: BIOSDATA:2339↓p
                                        ; BIOSDATA:2340↓p ...
                push    cs:addr_of_bcretf ; set up near return to far return
                push    cs:cdev_2       ; [cs:cdev+2] ; push Bios_Code segment
                push    bp
                retf
; ---------------------------------------------------------------------------
flp_drvs        db 0                    ; DATA XREF: BIOSDATA:1E10↓w
                                        ; BIOSDATA:1E1D↓r ...
firstcluster_hw dw 0                    ; DATA XREF: BIOSDATA:1ED4↓w
                                        ; BIOSDATA:2390↓r
Boot_Drv        db 0                    ; DATA XREF: BIOSDATA:1CF4↓w
                                        ; BIOSDATA:1E51↓w ...
; ---------------------------------------------------------------------------

cd_boot_option:                         ; CODE XREF: BIOSDATA:1D36↓p
                push    ax
                push    ds
                push    es
                push    dx

cdbo_1:                                 ; CODE XREF: BIOSDATA:1B92↓j
                mov     ah, 1
                int     16h             ; KEYBOARD -
                jz      short cdbo_2
                xor     ah, ah
                int     16h             ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
                                        ; Return: AH = scan code, AL = character
                jmp     short cdbo_1
; ---------------------------------------------------------------------------

cdbo_2:                                 ; CODE XREF: BIOSDATA:1B8C↑j
                push    cs
                pop     ds
                mov     si, offset cd_boot_msg ; "\r\nPress the ENTER key to boot from CD"...
                lodsb

cdbo_3:                                 ; CODE XREF: BIOSDATA:1BA4↓j
                mov     bx, 7
                mov     ah, 0Eh
                int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
                                        ; AL = character, BH = display page (alpha modes)
                                        ; BL = foreground color (graphics modes)
                lodsb
                or      al, al
                jnz     short cdbo_3
                mov     ax, 40h
                mov     ds, ax
                assume ds:nothing
                mov     bx, ds:6Ch      ; 0:46Ch = Daily timer counter (4 bytes)
                mov     si, ds:6Eh

wait_for_key:                           ; CODE XREF: BIOSDATA:1BFF↓j
                push    bx
                mov     bx, 7
                mov     ax, 0E08h
                int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
                                        ; AL = character, BH = display page (alpha modes)
                                        ; BL = foreground color (graphics modes)
                mov     ax, 0E20h
                int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
                                        ; AL = character, BH = display page (alpha modes)
                                        ; BL = foreground color (graphics modes)
                mov     ax, 0E08h
                int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
                                        ; AL = character, BH = display page (alpha modes)
                                        ; BL = foreground color (graphics modes)
                pop     bx
                add     bx, 18          ; 18.2 ticks per second
                adc     si, 0           ; next second (if carry flag is 1)

continue_to_wait:                       ; CODE XREF: BIOSDATA:cdb0_6↓j
                mov     ah, 1
                int     16h             ; KEYBOARD -
                jz      short cdbo_5
                mov     ah, 0
                int     16h             ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
                                        ; Return: AH = scan code, AL = character
                cmp     ax, 11Bh
                jz      short cdb0_7

cdbo_4:                                 ; CODE XREF: BIOSDATA:cdbo_8↓j
                mov     bx, 7
                mov     ax, 0E0Dh
                int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
                                        ; AL = character, BH = display page (alpha modes)
                                        ; BL = foreground color (graphics modes)
                mov     ax, 0E0Ah
                int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
                                        ; AL = character, BH = display page (alpha modes)
                                        ; BL = foreground color (graphics modes)
                pop     dx
                pop     es
                pop     ds
                assume ds:nothing
                pop     ax
                retn
; ---------------------------------------------------------------------------

cdbo_5:                                 ; CODE XREF: BIOSDATA:1BD1↑j
                cmp     si, ds:6Eh
                jnz     short cdb0_6
                cmp     bx, ds:6Ch

cdb0_6:                                 ; CODE XREF: BIOSDATA:1BF2↑j
                jnb     short continue_to_wait
                dec     cs:time_counter
                jnz     short wait_for_key

cdb0_7:                                 ; CODE XREF: BIOSDATA:1BDA↑j
                mov     bx, 7
                mov     ax, 0E0Dh
                int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
                                        ; AL = character, BH = display page (alpha modes)
                                        ; BL = foreground color (graphics modes)
                mov     ax, 0E0Ah
                int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
                                        ; AL = character, BH = display page (alpha modes)
                                        ; BL = foreground color (graphics modes)
                push    cs
                pop     ds
                assume ds:BIOSDATA
                mov     ax, 4B00h
                xor     dl, dl          ; disk drive = 0 (fd)
                mov     si, offset empty_dap_buff
                int     13h             ; DISK - Bootable CD-ROM - AL = TERMINATE DISK EMULATION
                mov     dx, 80h         ; DS:SI = Specification packet filled
                xor     ax, ax
                mov     byte ptr [si], 13h
                mov     [si+1], al
                mov     [si+2], dx
                mov     [si+4], ax
                mov     [si+6], ax
                mov     [si+8], ax
                mov     [si+0Ah], ax
                mov     [si+0Ch], ax
                mov     [si+0Eh], ax
                mov     [si+10h], al
                mov     [si+11h], al
                mov     [si+12h], al
                mov     ax, 4B00h       ; disk drive = 80h (hd)
                int     13h             ; DISK - Bootable CD-ROM - AL = TERMINATE DISK EMULATION
                xor     ax, ax
                mov     dx, 80h
                int     13h             ; DISK - RESET DISK SYSTEM
                                        ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
                push    cs
                pop     es
                assume es:BIOSDATA
                mov     ax, 201h
                mov     bx, offset disksector
                mov     cx, 1
                mov     dx, 80h
                int     13h             ; DISK - READ SECTORS INTO MEMORY
                                        ; AL = number of sectors to read, CH = track, CL = sector
                                        ; DH = head, DL = drive, ES:BX -> buffer to fill
                                        ; Return: CF set on error, AH = status, AL = number of sectors read
                jb      short cdbo_8
                cmp     word ptr es:[bx+1FEh], 0AA55h
                jz      short cdbo_9

cdbo_8:                                 ; CODE XREF: BIOSDATA:1C5F↑j
                jmp     cdbo_4
; ---------------------------------------------------------------------------

cdbo_9:                                 ; CODE XREF: BIOSDATA:1C68↑j
                push    cs
                pop     ds
                xor     ax, ax
                mov     di, 7C00h
                mov     es, ax
                assume es:nothing
                mov     si, bx
                push    es
                push    di
                mov     cx, 100h        ; 256
                cld
                rep movsw
                mov     ds, ax
                assume ds:nothing
                mov     si, 78h
                mov     ax, cs:Orig_Int1Eh_Table
                mov     [si], ax
                mov     ax, cs:Orig_Int1Eh_Table+2
                mov     [si+2], ax
                retf
; ---------------------------------------------------------------------------
empty_dap_buff  db 19                   ; DATA XREF: BIOSDATA:1C15↑o
                db 18 dup(0)
time_counter    db 5                    ; DATA XREF: BIOSDATA:1BFA↑w
                                        ; 5 seconds
cd_boot_msg     db 0Dh,0Ah              ; DATA XREF: BIOSDATA:1B96↑o
                db 'Press the ENTER key to boot from CD or DVD......',0
; ---------------------------------------------------------------------------

init:                                   ; CODE XREF: BIOSDATA:hdrv_pat↑j
                cli
                mov     cs:Orig_Int1Eh_Table+2, ds ; DS:SI from MSLOAD (not boot sector)
                mov     cs:Orig_Int1Eh_Table, si
                push    ax
                xor     ax, ax
                mov     ds, ax
                pop     ax
                mov     cs:First_Data_Sector+2, ax ; AX:BX from MSLOAD
                mov     cs:First_Data_Sector, bx
                mov     cs:Boot_Drv, dl ; Boot Drive from MSLOAD ;;; [BootDrive]
                push    cs
                pop     es
                assume es:BIOSDATA
                push    cx
                push    di
                cld
                push    ds
                mov     ax, 544h        ; SYSINIT segment
                                        ; SYSINITSEG (= IOSYSCODESEG+(SYSINITOFFSET>>4)
                xor     si, si
                mov     ds, si          ; check (1st sector) of the root directory -of BOOT CD-
                                        ; for special names (as boot option signature)
                mov     si, 540h        ; ROOT DIRECTORY BUFFER offset 40h
                                        ; (BOOT DRV's root directory the 3rd entry)

chk_boot_hdnoz:                         ; CODE XREF: BIOSDATA:1D42↓j
                cmp     byte ptr [si], 0
                jz      short chk_no_logo_noz
                cmp     word ptr [si], 425Fh ; '_BOOT_HDNOZ'
                jnz     short chk_next_1
                cmp     word ptr [si+2], 4F4Fh ; 'OO'
                jnz     short chk_next_1
                cmp     word ptr [si+4], 5F54h
                jnz     short chk_next_1
                cmp     word ptr [si+6], 4448h ; 'HD'
                jnz     short chk_next_1
                cmp     word ptr [si+8], 4F4Eh
                jnz     short chk_next_1
                cmp     byte ptr [si+0Ah], 5Ah ; 'Z'
                jnz     short chk_next_1
                call    cd_boot_option
                jmp     short chk_no_logo_noz
; ---------------------------------------------------------------------------

chk_next_1:                             ; CODE XREF: BIOSDATA:1D12↑j
                                        ; BIOSDATA:1D19↑j ...
                add     si, 32          ; (next entry)
                cmp     si, 700h
                jb      short chk_boot_hdnoz

chk_no_logo_noz:                        ; CODE XREF: BIOSDATA:1D0C↑j
                                        ; BIOSDATA:1D39↑j
                mov     si, 540h        ; (BOOT DRV's root directory the 3rd entry)

chk_no_logo_noz2_nxt:                   ; CODE XREF: BIOSDATA:1D7B↓j
                cmp     byte ptr [si], 0
                jz      short write_start_msg
                cmp     word ptr [si], 4F4Eh ; 'NO_LOGO NOZ'
                jnz     short chk_next_2
                cmp     word ptr [si+2], 4C5Fh
                jnz     short chk_next_2
                cmp     word ptr [si+4], 474Fh
                jnz     short chk_next_2
                cmp     word ptr [si+6], 204Fh
                jnz     short chk_next_2
                cmp     word ptr [si+8], 4F4Eh
                jnz     short chk_next_2
                cmp     byte ptr [si+0Ah], 5Ah
                jz      short startmsg_ok

chk_next_2:                             ; CODE XREF: BIOSDATA:1D50↑j
                                        ; BIOSDATA:1D57↑j ...
                add     si, 32          ; (next entry)
                cmp     si, 700h
                jb      short chk_no_logo_noz2_nxt

write_start_msg:                        ; CODE XREF: BIOSDATA:1D4A↑j
                mov     ds, ax          ; SYSINIT segment
                assume ds:nothing
                mov     si, offset StartMsg ; "Starting PC DOS...\r\n\n"

startmsg_nxt_chr:                       ; CODE XREF: BIOSDATA:1D8E↓j
                lodsb
                or      al, al
                jz      short startmsg_ok
                mov     ah, 0Eh
                mov     bx, 7
                int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
                                        ; AL = character, BH = display page (alpha modes)
                                        ; BL = foreground color (graphics modes)
                jmp     short startmsg_nxt_chr
; ---------------------------------------------------------------------------

startmsg_ok:                            ; CODE XREF: BIOSDATA:1D72↑j
                                        ; BIOSDATA:1D85↑j
                pop     ds
                mov     cx, 5
                mov     si, offset RomVectors

next_int:                               ; CODE XREF: BIOSDATA:1DA8↓j
                lods    byte ptr cs:[si]
                cbw
                shl     ax, 1
                shl     ax, 1
                mov     di, ax
                xchg    si, di
                lodsw
                stosw
                lodsw
                stosw
                xchg    si, di
                loop    next_int
                pop     di
                pop     cx
                mov     ax, word ptr cs:Old13
                mov     word ptr cs:Orig13, ax
                mov     ax, word ptr cs:Old13+2
                mov     word ptr cs:Orig13+2, ax
                mov     word ptr ds:4Ch, offset block13
                mov     word ptr ds:4Eh, cs
                mov     ax, ds:68h
                mov     word ptr cs:Orig1A, ax
                mov     ax, ds:6Ah
                mov     word ptr cs:Orig1A+2, ax
                mov     word ptr ds:68h, offset Int1A
                mov     word ptr ds:6Ah, cs
                mov     word ptr ds:54h, offset Int15
                mov     word ptr ds:56h, cs
                mov     word ptr ds:64h, offset int19
                mov     word ptr ds:66h, cs ; 19h*4+2
                sti
                int     11h             ; EQUIPMENT DETERMINATION
                                        ; Return: AX = equipment flag bits
                jmp     short chk_fd_count
; ---------------------------------------------------------------------------
                push    dx              ; 52h ; 'R'
                push    ax              ; 50h ; 'P'
                push    bx              ; 53h ; 'S'

chk_fd_count:                           ; CODE XREF: BIOSDATA:1DF5↑j
                or      ax, 1
                test    ax, 1
                jnz     short normalfloppydrv
                push    ax
                push    bx
                push    cx
                push    dx
                push    di
                push    es
                mov     ah, 8
                mov     dl, 0
                int     13h             ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
                                        ; DL = drive number
                                        ; Return: CF set on error, AH = status code, BL = drive type
                                        ; DL = number of consecutive drives
                                        ; DH = maximum value for head number, ES:DI -> drive parameter
                jb      short _gdskp_error
                mov     cs:flp_drvs, dl

_gdskp_error:                           ; CODE XREF: BIOSDATA:1E0E↑j
                pop     es
                assume es:nothing
                pop     di
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                jb      short normalfloppydrv
                cmp     cs:flp_drvs, 0
                jz      short _set_fake_flpdrv
                mov     al, cs:flp_drvs
                dec     al
                jmp     short got_num_flp_drvs
; ---------------------------------------------------------------------------

_set_fake_flpdrv:                       ; CODE XREF: BIOSDATA:1E23↑j
                mov     cs:fakefloppydrv, 1
                mov     ax, 1
                jmp     short settwodrive
; ---------------------------------------------------------------------------

normalfloppydrv:                        ; CODE XREF: BIOSDATA:1E00↑j
                                        ; BIOSDATA:1E1B↑j
                rol     al, 1
                rol     al, 1

got_num_flp_drvs:                       ; CODE XREF: BIOSDATA:1E2B↑j
                and     ax, 3
                jnz     short notsingle
                inc     ax

settwodrive:                            ; CODE XREF: BIOSDATA:1E36↑j
                inc     cs:single

notsingle:                              ; CODE XREF: BIOSDATA:1E3F↑j
                inc     ax
                mov     cl, al
                test    dl, 80h
                jnz     short gothrd
                xor     ax, ax
                mov     cs:Boot_Drv, al

gothrd:                                 ; CODE XREF: BIOSDATA:1E4D↑j
                xor     dx, dx
                cli
                mov     ss, dx
                assume ss:nothing
                mov     sp, 700h
                sti
                push    cx
                mov     ah, ch          ; [MediaByte]
                push    ax
                mov     ah, 0C0h
                int     15h             ; SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
                jb      short no_rom_system_conf
                cmp     ah, 0
                jnz     short no_rom_system_conf
                mov     al, es:[bx+2]
                mov     cs:model_byte, al
                mov     al, es:[bx+3]
                mov     cs:secondary_model_byte, al
                jmp     short turn_timer_on
; ---------------------------------------------------------------------------

no_rom_system_conf:                     ; CODE XREF: BIOSDATA:1E66↑j
                                        ; BIOSDATA:1E6B↑j
                mov     si, 0FFFFh
                mov     es, si
                assume es:nothing
                mov     al, es:0Eh
                mov     cs:model_byte, al

turn_timer_on:                          ; CODE XREF: BIOSDATA:1E7D↑j
                mov     al, 20h
                out     20h, al         ; Interrupt controller, 8259A.
                cmp     cs:model_byte, 0
                jnz     short not_olivetti_m24
                in      al, 66h
                test    al, 20h
                jz      short not_olivetti_m24
                mov     al, 0Fh
                out     50h, al
                in      al, 50h
                test    al, 1
                jz      short skip_aux_port_init

not_olivetti_m24:                       ; CODE XREF: BIOSDATA:1E96↑j
                                        ; BIOSDATA:1E9C↑j
                mov     al, 3
                call    aux_init
                mov     al, 2
                call    aux_init
                mov     al, 1
                call    aux_init
                xor     al, al
                call    aux_init

skip_aux_port_init:                     ; CODE XREF: BIOSDATA:1EA6↑j
                mov     al, 2
                call    print_init
                mov     al, 1
                call    print_init
                xor     al, al
                call    print_init
                xor     dx, dx
                mov     ds, dx
                assume ds:nothing
                mov     es, dx
                assume es:nothing
                mov     ax, word ptr ds:534h ; initspot
                                        ; IBMDOS.COM's first cluster - high word
                                        ; 520h (the 2nd entry of root dir) + 14h
                mov     cs:firstcluster_hw, ax
                xor     ax, ax          ; 0
                mov     di, 534h        ; INITSPOT (0000h:0534h)
                                        ; IBM wants 4 zeros here
                stosw
                stosw
                mov     ax, cs
                mov     word ptr ds:6Ch, offset cbreak ; INT 1Bh vector
                mov     word ptr ds:6Eh, ax
                mov     word ptr ds:0A4h, offset outchr ; INT 29h vector
                mov     word ptr ds:0A6h, ax
                mov     di, 4
                mov     bx, offset intret
                xchg    ax, bx
                stosw                   ; int 1
                xchg    ax, bx
                stosw
                add     di, 4           ; skip int 2
                xchg    ax, bx
                stosw                   ; int 3
                xchg    ax, bx
                stosw
                xchg    ax, bx
                stosw                   ; int 4
                xchg    ax, bx
                stosw
                mov     word ptr ds:500h, dx ; set print screen & break = 0
                mov     word ptr ds:504h, dx ; clean out last drive spec
                mov     al, byte ptr ds:52Ch ; SEC9+DISK_PARMS.DISK_MOTOR_STRT
                                        ; motor start time in 1/8 seconds
                mov     cs:motorstartup, al
                cmp     cs:model_byte, 0FDh ; is this an old rom?
                jb      short no_diddle ; no
                mov     word ptr ds:52Bh, 20Fh ; [SEC9+DISK_PARMS.DISK_HEAD_STTL]
                                        ; head settle time in milliseconds
                mov     byte ptr ds:522h, 0DFh ; [SEC9+DISK_PARMS.DISK_SPECIFY_1]
                                        ; set 1st specify byte on pc-1 pc-2 pc-xt hal0

no_diddle:                              ; CODE XREF: BIOSDATA:1F1D↑j
                int     12h             ; MEMORY SIZE -
                                        ; Return: AX = number of contiguous 1K blocks of memory
                mov     cl, 6
                shl     ax, cl
                pop     cx
                mov     cs:drvfat, cx
                push    ax
                push    ds
                push    bx
                xor     bx, bx
                mov     ds, bx
                mov     bx, word ptr ds:0BCh ; INT 2Fh handler ; [2Fh*4]
                mov     ds, word ptr ds:0BEh ; [2Fh*4+2]
                assume ds:nothing
                cmp     word ptr [bx+3], 5052h ; 'RP' ; 'RPL'
                jnz     short SkipRPL
                cmp     byte ptr [bx+5], 4Ch ; 'L'
                jnz     short SkipRPL
                mov     dx, ax          ; get TOM into dx
                mov     ax, 4A06h       ; (multMULT shl 8) + multMULTRPLTOM
                int     2Fh             ; Get new TOM from any RPL
                mov     ax, dx

SkipRPL:                                ; CODE XREF: BIOSDATA:1F4A↑j
                                        ; BIOSDATA:1F50↑j
                pop     bx
                pop     ds
                sub     ax, 40h
                mov     cs:fatloc, ax   ; location to read fat
                sub     ax, 40h
                mov     cs:init_bootseg, ax
                pop     ax
                mov     dx, 544h        ; SYSINITSEG ; SYSINIT segment
                mov     ds, dx
                assume ds:nothing
                mov     word ptr ds:DEVICE_LIST, offset res_dev_list
                mov     word ptr ds:DEVICE_LIST+2, cs
                mov     ds:MEMORY_SIZE, ax
                inc     cl
                mov     ds:DEFAULT_DRIVE, cl
                mov     ds:CURRENTDOSLOCATION, 0AF8h ; DOSLOADSEG
                                        ; DOSLOADSEG  = SYSINITSEG+((SYSINITSIZE+15)/16)
                mov     ax, 544h        ; SYSINITSEG
                mov     es, ax
                assume es:nothing
                xor     ax, ax
                mov     ds, ax
                assume ds:nothing
                mov     ax, word ptr ds:3Eh ; INT 0Fh vector, segment
                cmp     ax, es:MEMORY_SIZE
                jbe     short resetintf
                cmp     ax, 0F000h
                jnz     short keepintf

resetintf:                              ; CODE XREF: BIOSDATA:1F9B↑j
                mov     ds:3Ch, offset intret
                mov     word ptr ds:3Eh, cs

keepintf:                               ; CODE XREF: BIOSDATA:1FA0↑j
                xor     cx, cx
                mov     ds, cx
                mov     cl, byte ptr ds:496h ; get keyboard flag
                test    cl, 10h         ; extended keyboard ?
                jz      short org_key   ; no
                mov     cs:keyrd_func, 10h ; extended keyboard function
                mov     cs:keysts_func, 11h ; extended keyboard function

org_key:                                ; CODE XREF: BIOSDATA:1FB7↑j
                push    cs
                pop     ds
                assume ds:BIOSDATA
                push    cs
                pop     es
                assume es:BIOSDATA
                call    cmos_clock_read ; If cmos clock exists,
                                        ; then set the system time according to that.
                                        ; also, reset the cmos clock rate.
                                        ; ;
                mov     word ptr hdrv_pat, offset harddrv ; BData_start
                pop     ax              ; number of floppies and FAT ID
                xor     ah, ah          ; chuck fat id byte
                mov     drvmax, al      ; remember which drive is hard disk
                mov     dsktnum, al     ; and set initial number of drives
                shl     ax, 1
                add     last_dskdrv_table, ax
                push    ds
                mov     ax, 0F000h
                mov     ds, ax
                assume ds:nothing
                cmp     word ptr ds:0FFEAh, 'OC' ; 'COMPAQ'
                jnz     short skip_mode2
                cmp     word ptr ds:0FFECh, 'PM'
                jnz     short skip_mode2
                cmp     word ptr ds:0FFEEh, 'QA'
                jnz     short skip_mode2
                mov     ax, 0E400h
                int     15h
                jb      short skip_mode2
                or      bx, 0           ; or bx,40h ; enable mode 2
                                        ; (MSDOS 6.0)
                mov     ax, 0E480h      ; set advanced system info
                int     15h

skip_mode2:                             ; CODE XREF: BIOSDATA:1FED↑j
                                        ; BIOSDATA:1FF5↑j ...
                pop     ds
                assume ds:nothing
                mov     dl, 80h
                mov     ah, 8
                int     13h             ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
                                        ; DL = drive number
                                        ; Return: CF set on error, AH = status code, BL = drive type
                                        ; DL = number of consecutive drives
                                        ; DH = maximum value for head number, ES:DI -> drive parameter
                jb      short enddrv
                mov     ds:hnum, dl     ; save number of hard drives

enddrv:                                 ; CODE XREF: BIOSDATA:2015↑j
                xor     dl, dl          ; drive number = 0
                push    cs
                pop     ds
                assume ds:BIOSDATA
                mov     eot, 9
                mov     di, offset start_bds
                cmp     fakefloppydrv, 1
                jnz     short loop_drive
                mov     di, [di]        ; [di+BDS.link]
                mov     di, [di]        ;  di <- second bds link
                mov     word ptr [di], 0FFFFh ; -1 ; set end of link
                jmp     dohard          ; allocate/initialise bds for harddrives
; ---------------------------------------------------------------------------

loop_drive:                             ; CODE XREF: BIOSDATA:202C↑j
                                        ; BIOSDATA:21E5↓j
                cmp     dl, drvmax
                jb      short got_more
                jmp     done_drives
; ---------------------------------------------------------------------------

got_more:                               ; CODE XREF: BIOSDATA:203D↑j
                xor     cx, cx          ; zero all flags
                mov     di, [di]        ; [di+BDS.link] ; get next bds
                cmp     di, 0FFFFh      ; end of link ?
                jnz     short not_last_bds
                mov     al, dl          ; drive number (0 based)
                cbw
                add     ax, ax
                add     ax, offset dskdrvs
                mov     last_dskdrv_table, ax
                mov     di, end_of_bdss
                call    xinstall_bds
                dec     drvmax

not_last_bds:                           ; CODE XREF: BIOSDATA:2049↑j
                mov     dh, 0           ; ff48tpi ; set form factor to 48 tpi
                mov     num_cyln, 40    ; 40 tracks per side
                push    ds
                push    di
                push    dx
                push    cx
                push    es
                xor     bx, bx
                xor     cx, cx
                push    dx
                mov     ah, 8
                int     13h             ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
                                        ; DL = drive number
                                        ; Return: CF set on error, AH = status code, BL = drive type
                                        ; DL = number of consecutive drives
                                        ; DH = maximum value for head number, ES:DI -> drive parameter
                pop     ax
                jnb     short chk_drv_type
                jmp     noparmsfromrom
; ---------------------------------------------------------------------------

chk_drv_type:                           ; CODE XREF: BIOSDATA:2078↑j
                cmp     bl, 10h         ; ATAPI Removable Media Device
                jnz     short not_atapi_removable
                push    ds
                push    si
                mov     dl, al
                sub     sp, 26
                xor     ax, ax
                push    ax
                mov     ax, 30
                push    ax
                mov     si, sp          ; DS:SI = segment:offset pointer to Result Buffer
                push    ss
                pop     ds
                assume ds:nothing
                mov     ah, 48h
                int     13h             ; DISK - IBM/MS Extension
                                        ; GET DRIVE PARAMETERS (DL - drive, DS:SI - buffer)
                jb      short ext_gdp_err
                mov     ax, [si+8]      ; physical number of heads
                mov     ds:num_heads, ax
                mov     ax, [si+4]      ; physical number of cylinders
                mov     ds:num_cyln, ax
                mov     al, [si+0Ch]    ; physical number of sectors per track
                mov     ds:sec_trk, al
                cmp     al, ds:eot
                jbe     short _eotok
                mov     ds:eot, al

_eotok:                                 ; CODE XREF: BIOSDATA:20B0↑j
                xor     al, al
                test    byte ptr [si+2], 10h ; information flags
                                        ; bit 4 = Device has change line support
                jz      short not_chgline_sup
                or      al, 2           ; change line support

not_chgline_sup:                        ; CODE XREF: BIOSDATA:20BB↑j
                add     sp, 30
                pop     si
                pop     ds
                assume ds:nothing
                pop     es
                assume es:nothing
                pop     cx
                pop     dx
                pop     di
                pop     ds
                test    al, 2
                jz      short gotother_j
                or      cl, al
                mov     ds:fhave96, 1   ; Device has change line support

gotother_j:                             ; CODE XREF: BIOSDATA:20CB↑j
                jmp     short gotother
; ---------------------------------------------------------------------------

ext_gdp_err:                            ; CODE XREF: BIOSDATA:2098↑j
                add     sp, 30
                pop     si
                pop     ds

not_atapi_removable:                    ; CODE XREF: BIOSDATA:2080↑j
                cmp     ch, 0           ; if ch=0, then cl,dh=0 too.
                jnz     short pfr_ok    ;
                                        ; rom gave wrong info.
                                        ; let's default to 360k.
                mov     ch, 39
                mov     cl, 9
                mov     dh, 1

pfr_ok:                                 ; CODE XREF: BIOSDATA:20DE↑j
                xchg    dl, dh
                xor     dh, dh
                inc     dx              ; make number of heads 1-based
                mov     ds:num_heads, dx
                push    cx
                and     cl, 3Fh
                mov     ds:sec_trk, cl
                pop     cx
                xchg    cl, ch
                rol     ch, 1
                rol     ch, 1
                and     ch, 3
                inc     cx              ; make number of cylinders 1-based
                mov     ds:num_cyln, cx
                mov     cl, ds:sec_trk
                cmp     cl, ds:eot
                jbe     short eotok
                mov     ds:eot, cl

eotok:                                  ; CODE XREF: BIOSDATA:210E↑j
                pop     es
                pop     cx
                pop     dx
                pop     di
                pop     ds
                push    dx
                push    cx
                mov     ah, 15h
                int     13h             ; DISK - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)
                                        ; DL = drive ID
                                        ; Return: CF set on error, AH = disk type (3 = hard drive)
                                        ; CX:DX = number of sectors on the media
                pop     cx
                pop     dx
                jb      short changeline_done
                cmp     ah, 2
                jnz     short changeline_done
                or      cl, 2           ; fchangeline ; change line support
                mov     ds:fhave96, 1   ; remember that we have 96tpi disks

changeline_done:                        ; CODE XREF: BIOSDATA:2121↑j
                                        ; BIOSDATA:2126↑j
                cmp     ds:num_cyln, 40
                jnz     short try_80
                cmp     ds:sec_trk, 9
                jbe     short nextdrive

gotother:                               ; CODE XREF: BIOSDATA:gotother_j↑j
                                        ; BIOSDATA:2147↓j ...
                mov     dh, 7           ; ffOther ; we have a "strange" medium
                jmp     short nextdrive
; ---------------------------------------------------------------------------

try_80:                                 ; CODE XREF: BIOSDATA:2135↑j
                cmp     ds:num_cyln, 80
                jnz     short gotother
                mov     dh, 9           ; ff288 ; assume 2.88 MB drive
                cmp     ds:sec_trk, 36  ; is it ?
                jz      short nextdrive ; yes, go update
                cmp     ds:sec_trk, 15
                jz      short got96
                cmp     ds:sec_trk, 9
                jnz     short gotother
                mov     dh, 2           ; ffSmall
                jmp     short nextdrive
; ---------------------------------------------------------------------------

got96:                                  ; CODE XREF: BIOSDATA:2157↑j
                mov     dh, 1           ; ff96tpi
                jmp     short nextdrive
; ---------------------------------------------------------------------------

noparmsfromrom:                         ; CODE XREF: BIOSDATA:207A↑j
                pop     es
                pop     cx
                pop     dx
                pop     di
                pop     ds
                push    dx
                push    cx
                mov     ah, 15h
                int     13h             ; DISK - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)
                                        ; DL = drive ID
                                        ; Return: CF set on error, AH = disk type (3 = hard drive)
                                        ; CX:DX = number of sectors on the media
                pop     cx
                pop     dx
                jb      short nextdrive
                cmp     ah, 2           ; is there changeline?
                jnz     short nextdrive
                or      cl, 2           ; yes, this drive has change line supoort
                mov     ds:fhave96, 1   ; remember that we have 96tpi drives
                                        ; (change line support)
                mov     ds:num_cyln, 80
                mov     dh, 1           ; ff96tpi
                mov     al, 15
                cmp     al, ds:eot
                jbe     short nextdrive
                mov     ds:eot, al

nextdrive:                              ; CODE XREF: BIOSDATA:213C↑j
                                        ; BIOSDATA:2140↑j ...
                or      cl, 20h         ; fi_own_physical
                                        ; set this true for all drives
                mov     bh, dl          ; save int13 drive number
                cmp     ds:single, 2
                jb      short not_special
                dec     bh              ; int13 drive number same for logical drive
                xor     cl, 20h         ; fi_own_physical
                                        ; reset ownership flag for logical drive

not_special:                            ; CODE XREF: BIOSDATA:21A1↑j
                mov     ax, ds:num_heads
                mov     [di+52h], ax    ; [di+BDS.rheads]
                xor     ax, ax
                mov     al, ds:sec_trk
                mov     [di+50h], ax    ; [di+BDS.rsecpertrack]
                mov     [di+3Fh], cx    ; [di+BDS.flags]
                mov     [di+3Eh], dh    ; [di+BDS.formfactor]
                mov     [di+5], dl      ; [di+BDS.drivelet]
                mov     [di+4], bh      ; [di+BDS.drivenum]
                push    bx
                mov     bx, ds:num_cyln
                mov     [di+41h], bx    ; [di+BDS.cylinders]
                pop     bx
                cmp     ds:single, 1    ; Special case for single drive system
                jnz     short no_single
                mov     ds:single, 2    ; Don't forget we have single drive system
                or      cx, 10h         ; fi_am_mult
                                        ; set that this is one of several drives
                or      [di+3Fh], cx    ; [di+BDS.flags] ; save flags
                mov     di, [di]        ; [di+BDS.link] ; move to next BDS in list
                inc     dl              ; add a number
                jmp     short nextdrive ; Use same info for BDS as previous
; ---------------------------------------------------------------------------

no_single:                              ; CODE XREF: BIOSDATA:21D0↑j
                inc     dl
                jmp     loop_drive
; ---------------------------------------------------------------------------

done_drives:                            ; CODE XREF: BIOSDATA:203F↑j
                mov     word ptr [di], 0FFFFh ; -1

dohard:                                 ; CODE XREF: BIOSDATA:2036↑j
                mov     dh, ds:hnum
                or      dh, dh
                jz      short static_configure
                mov     dl, 80h

dohard1:                                ; CODE XREF: BIOSDATA:2213↓j
                push    dx
                mov     di, ds:end_of_bdss
                mov     bl, ds:drvmax
                mov     bh, 0
                call    sethard
                jb      short hardfile_err
                call    dmax_check
                jnb     short hardfile_err
                call    xinstall_bds

hardfile_err:                           ; CODE XREF: BIOSDATA:2204↑j
                                        ; BIOSDATA:2209↑j
                pop     dx
                inc     dl
                dec     dh
                jnz     short dohard1
                call    domini
                mov     dh, ds:hnum
                mov     dl, 80h

dohardx1:                               ; CODE XREF: BIOSDATA:2243↓j
                mov     bh, 1

dohardx2:                               ; CODE XREF: BIOSDATA:223B↓j
                push    dx
                push    bx
                mov     di, ds:end_of_bdss
                mov     bl, ds:drvmax
                call    sethard
                jb      short dohardx4
                call    dmax_check
                jnb     short dohardx4
                call    xinstall_bds
                pop     bx
                pop     dx
                inc     bh
                jmp     short dohardx2
; ---------------------------------------------------------------------------

dohardx4:                               ; CODE XREF: BIOSDATA:222D↑j
                                        ; BIOSDATA:2232↑j
                pop     bx
                pop     dx
                inc     dl
                dec     dh
                jnz     short dohardx1
                cmp     ds:dsktnum, 2
                jbe     short static_configure
                call    remap

static_configure:                       ; CODE XREF: BIOSDATA:21F2↑j
                                        ; BIOSDATA:224A↑j
                mov     di, ds:end_of_bdss
                cmp     di, offset bdss
                jnz     short dynamic_configure
                mov     di, offset harddrv ; offset end96tpi
                cmp     ds:fhave96, 0
                jnz     short dynamic_configure
                mov     di, offset endfloppy

dynamic_configure:                      ; CODE XREF: BIOSDATA:2257↑j
                                        ; BIOSDATA:2261↑j
                push    cs
                pop     es
                assume es:BIOSDATA
                cld
                cmp     ds:model_byte, 0FCh ; AT?
                jnz     short checkcompaqbug ; no
                cmp     ds:hnum, 0      ; No hard file?
                jz      short checkcompaqbug
                xchg    ax, di          ; save allocation pointer in ax
                mov     si, 0F000h
                mov     es, si
                assume es:nothing
                mov     si, offset bios_date ; "01/10/84"
                mov     di, 0FFF5h      ; ROM BIOS string is at F000:FFF5
                mov     cx, 9           ; Only patch ROM for bios 01/10/84
                repe cmpsb              ; check for date + zero on end
                xchg    ax, di          ; restore allocation pointer
                jnz     short checkcompaqbug
                mov     cx, offset endatrom
                mov     si, offset ibm_disk_io
                jmp     short install_int13_patch
; ---------------------------------------------------------------------------

checkcompaqbug:                         ; CODE XREF: BIOSDATA:226E↑j
                                        ; BIOSDATA:2275↑j ...
                mov     ax, 0F000h
                mov     es, ax
                cmp     word ptr es:0FFEAh, 4F43h ; 'CO'
                jnz     short checkk09
                cmp     word ptr es:0FFECh, 504Dh ; 'MP'
                jnz     short checkk09
                cmp     word ptr es:0FFEEh, 5141h ; 'AQ'
                jnz     short checkk09
                mov     ax, es:0FFFBh
                xchg    ah, al
                cmp     ax, 3836h       ; '68' (NASM syntax) (('86' in MASM syntax))
                ja      short checkk09
                jz      short chkcompaqbug1
                cmp     ax, 3739h       ; '97'
                jbe     short checkk09
                stc

chkcompaqbug1:                          ; CODE XREF: BIOSDATA:22BE↑j
                jb      short do_compaq_patch
                mov     ax, es:0FFF5h
                xchg    ah, al
                cmp     ax, 3038h       ; '80'
                ja      short checkk09
                jb      short do_compaq_patch
                mov     ax, es:0FFF8h
                xchg    ah, al
                cmp     ax, 3034h       ; '40'
                jnb     short checkk09

do_compaq_patch:                        ; CODE XREF: BIOSDATA:chkcompaqbug1↑j
                                        ; BIOSDATA:22D3↑j
                mov     cx, offset end_compaq_i13hook
                mov     si, offset endatrom

install_int13_patch:                    ; CODE XREF: BIOSDATA:2291↑j
                push    cs
                pop     es
                assume es:BIOSDATA
                mov     word ptr ds:Orig13, di
                mov     word ptr ds:Orig13+2, cs
                sub     cx, si
                rep movsb

checkk09:                               ; CODE XREF: BIOSDATA:229F↑j
                                        ; BIOSDATA:22A8↑j ...
                push    cs
                pop     es
                push    di
                mov     ax, 4100h       ; wait for any external event (al=0)
                mov     bl, 4           ; wait for 4 clock ticks
                stc
                int     15h             ; SYSTEM - WAIT ON EXTERNAL EVENT (CONVERTIBLE)
                                        ; AL = condition type, BH = condition compare or mask value
                                        ; BL = timeout value times 55 milliseconds, 00h means no timeout
                                        ; DX = I/O port address if AL bit 4 set
                pop     di
                jb      short configdone
                mov     ds:fhavek09, 1  ; remember we have a k09 type
                push    ds
                xor     ax, ax
                mov     ds, ax
                assume ds:nothing
                mov     word ptr ds:1B0h, di ; [6Ch*4]
                                        ; new int 6ch handler
                mov     word ptr ds:1B2h, cs
                pop     ds
                assume ds:nothing
                mov     si, offset int_6Ch
                mov     cx, 461         ; endk09-int_6Ch (size of k09 routine)
                rep movsb

configdone:                             ; CODE XREF: BIOSDATA:2300↑j
                push    cs
                pop     ds              ; di is final ending address of msbio.
                assume ds:BIOSDATA
                add     di, 15          ; round (up) to paragraph
                shr     di, 1
                shr     di, 1
                shr     di, 1
                shr     di, 1
                add     di, 70h
                mov     DosDataSg, di   ; where the dos data segment will be
                mov     ax, drvfat
                mov     bp, offset SetDrive
                push    cs
                call    call_bios_code
                mov     bp, offset GetBp
                push    cs
                call    call_bios_code
                push    es
                pop     ds
                xor     di, di
                mov     al, es:[di]
                mov     byte ptr es:drvfat+1, al
                mov     ax, es:drvfat
                push    es
                push    ds
                pop     es
                push    cs
                pop     ds
                mov     bp, offset SetDrive
                push    cs
                call    call_bios_code
                push    es
                pop     ds
                pop     es
                assume es:nothing
                mov     bx, [di+6]
                mov     cs:md_sectorsize, bx
                mov     bl, [di+3Bh]
                mov     es:fbigfat, bl
                mov     cl, [di+8]
                mov     ax, [di+17h]
                sub     es:First_Data_Sector, ax
                mov     ax, [di+19h]
                sbb     es:First_Data_Sector+2, ax
                xor     ch, ch
                push    di
                push    ds
                xor     di, di
                mov     ds, di
                assume ds:nothing
                mov     bx, word ptr ds:53Ah ; clus=*53Ah
                                        ; (First cluster field of 2nd dir entry
                                        ; of root directory in the buffer at 500h)
                mov     si, cs:firstcluster_hw
                pop     ds
                assume ds:nothing
                pop     di
                mov     al, es:fbigfat
                push    ax              ; (*) save fbigfat flags
                mov     al, byte ptr es:drvfat
                or      al, es:Boot_Drv
                jnz     short boot_drv_fixed ; hard disk

boot_drv_removable:                     ; calculate cluster count and set fbig or fbigbig flag
                push    bx              ; for removable drives
                push    cx
                push    dx
                mov     ax, [di+0Eh]    ; [di+BDS.totalsecs16]
                xor     dx, dx
                or      ax, ax
                jnz     short prep_totalsecs_ok
                mov     ax, [di+1Bh]    ; [di+BDS.totalsecs32]
                mov     dx, [di+1Dh]

prep_totalsecs_ok:                      ; CODE XREF: BIOSDATA:23B1↑j
                sub     ax, [di+9]      ; [di+BDS.resectors]
                sbb     dx, 0
                push    ax
                push    dx
                mov     bx, [di+11h]    ; [di+BDS.fatsecs16]
                xor     ax, ax
                or      bx, bx
                jnz     short prep_fatsecs_ok
                mov     bx, [di+1Fh]    ; [di+BDS.fatsecs32]
                mov     ax, [di+21h]

prep_fatsecs_ok:                        ; CODE XREF: BIOSDATA:23C8↑j
                mov     cl, [di+0Bh]    ; ax:bx = 32 bit count of FAT sectors
                                        ; [di+BDS.fats]
                xor     ch, ch
                mul     cx
                xchg    ax, cx
                mul     bx
                add     cx, dx
                mov     bx, ax          ; cx:bx = total (2*) fat sectors
                pop     dx
                pop     ax              ; dx:ax = totals sectors - reserved sectors
                sub     ax, bx
                sbb     dx, cx          ; dx:ax = data sectors (includes root dir sectors)
                mov     bx, [di+0Ch]    ; [di+BDS.direntries]
                add     bx, 15          ; 16 directory entries per sector
                                        ; (round up sector count by adding 15)
                mov     cl, 4           ; (rounded) dir entries / 16
                shr     bx, cl
                xor     cx, cx
                sub     ax, bx
                sbb     dx, cx          ; dx:ax = data sectors (except root directory sectors)
                                        ; (will be used for cluster count calculation)
                mov     cl, [di+8]      ; [di+BDS.secperclus]
                push    ax              ; 32 bit division (data sectors / sector per cluster)
                mov     ax, dx
                xor     dx, dx
                div     cx
                mov     bx, ax
                pop     ax
                div     cx
                or      bx, bx          ; 32 bit cluster count if bx > 0
                jnz     short set_fbigbig_flag ; too big cluster number
                cmp     ax, 0FFF6h
                jb      short set_fbig_flag

set_fbigbig_flag:                       ; CODE XREF: BIOSDATA:2405↑j
                or      es:fbigfat, 20h ; FAT32  ; fbigbig
                jmp     short set_fbig_flag_ok
; ---------------------------------------------------------------------------

set_fbig_flag:                          ; CODE XREF: BIOSDATA:240A↑j
                cmp     ax, 0FF6h       ; 4096-10
                                        ; is this 16-bit fat?
                jb      short set_fbig_flag_ok ; no, small fat
                or      es:fbigfat, 40h ; FAT16 ; fbig

set_fbig_flag_ok:                       ; CODE XREF: BIOSDATA:2412↑j
                                        ; BIOSDATA:2417↑j
                pop     dx
                pop     cx
                pop     bx

boot_drv_fixed:                         ; CODE XREF: BIOSDATA:23A5↑j
                xor     di, di

loadit:                                 ; CODE XREF: BIOSDATA:iseofx↓j
                mov     ax, 544h        ; Load DOS kernel (IBMDOS.COM)
                                        ; SYSINIT segment = 544h
                mov     es, ax
                assume es:nothing
                mov     es, es:CURRENTDOSLOCATION
                assume es:nothing
                call    getclus
                test    cs:fbigfat, 20h ; fbigbig ; FAT32 fs flag
                jz      short iseof

eofbigbig:                              ; si:bx = 32 bit cluster number
                cmp     si, 0FFFh
                jnz     short iseofx
                cmp     bx, 0FFF7h
                jmp     short iseofx
; ---------------------------------------------------------------------------

iseof:                                  ; CODE XREF: BIOSDATA:2437↑j
                test    cs:fbigfat, 40h ; fbig ; FAT16 fs flag
                jnz     short eofbig
                cmp     bx, 0FF7h
                jmp     short iseofx
; ---------------------------------------------------------------------------

eofbig:                                 ; CODE XREF: BIOSDATA:244A↑j
                cmp     bx, 0FFF7h

iseofx:                                 ; CODE XREF: BIOSDATA:243D↑j
                                        ; BIOSDATA:2442↑j ...
                jb      short loadit
                pop     ax              ; (*) restore fbigfat flags
                                        ; (after loading DOS kernel)
                mov     cs:fbigfat, al
                call    setdrvparms
                jmp     far ptr 544h:269h ; SYSNIT:_SYSINIT

; =============== S U B R O U T I N E =======================================


remap           proc near               ; CODE XREF: BIOSDATA:224C↑p
                mov     di, cs:start_bds ; get first bds

drive_loop:                             ; CODE XREF: remap+10↓j
                cmp     byte ptr [di+4], 80h ; [di+BDS.drivenum] ; first hard disk??
                jz      short fdrv_found ; yes, continue
                mov     di, [di]        ; [di+BDS.link] ; get next bds, assume segment
                cmp     di, 0FFFFh      ; last bds?
                jnz     short drive_loop
                jmp     short rmap_exit ; yes, no hard drive on system
; ---------------------------------------------------------------------------

fdrv_found:                             ; CODE XREF: remap+9↑j
                mov     al, 2           ; start with logical drv num=2

fdrv_loop:                              ; CODE XREF: remap+20↓j
                mov     [di+5], al      ; [di+BDS.drivelet]
                mov     di, [di]        ; [di+BDS.link] ; ds:di--> next bds
                inc     al              ; set num for next drive
                cmp     di, 0FFFFh      ; last hard drive ?
                jnz     short fdrv_loop ; no - assign more disk drives
                mov     di, cs:start_bds
                mov     di, [di]        ; [di+BDS.link] ; ds:di-->bds2
                mov     ah, cs:dsktnum  ; get number of floppies to remap
                sub     ah, 2           ; adjust for a: & b:

remap_loop1:                            ; CODE XREF: remap+3A↓j
                mov     di, [di]        ; [di+BDS.link] ; set new num to next floppy
                mov     [di+5], al      ; [di+BDS.drivelet]
                inc     al              ; new number for next floppy
                dec     ah              ; count down extra floppies
                jnz     short remap_loop1
                mov     al, byte ptr cs:drvfat ; boot drive
                cmp     al, 2           ; is it a: or b: ?
                jb      short rmap_exit
                sub     al, cs:dsktnum  ; is it one of the other floppies?
                jb      short remap_boot_flop ; brif so
                add     al, 2           ; bootdrv -= (dsktnum-2)
                jmp     short remap_change_boot_drv
; ---------------------------------------------------------------------------

remap_boot_flop:                        ; CODE XREF: remap+49↑j
                add     al, cs:drvmax   ; bootdrv += (drvmax-dsktnum)

remap_change_boot_drv:                  ; CODE XREF: remap+4D↑j
                mov     byte ptr cs:drvfat, al
                inc     al
                push    ds
                mov     di, 544h        ; SYSINIT segment
                mov     ds, di
                assume ds:nothing
                mov     ds:DEFAULT_DRIVE, al
                pop     ds
                assume ds:nothing

rmap_exit:                              ; CODE XREF: remap+12↑j
                                        ; remap+42↑j
                retn
remap           endp


; =============== S U B R O U T I N E =======================================


getboot         proc near               ; CODE XREF: sethard+30↓p
                                        ; domini+3B↓p
                mov     ax, cs:init_bootseg
                mov     es, ax
                mov     bx, 200h        ; bootbias
                mov     ax, 201h
                xor     dh, dh
                mov     cx, 1
                int     13h             ; DISK - READ SECTORS INTO MEMORY
                                        ; AL = number of sectors to read, CH = track, CL = sector
                                        ; DH = head, DL = drive, ES:BX -> buffer to fill
                                        ; Return: CF set on error, AH = status, AL = number of sectors read
                jb      short erret
                cmp     word ptr es:3FEh, 0AA55h ; [es:bootbias+1FEh]
                                        ; Dave Litton magic word?
                jz      short norm_ret  ; yes

erret:                                  ; CODE XREF: getboot+13↑j
                stc

norm_ret:                               ; CODE XREF: getboot+1C↑j
                retn
getboot         endp


; =============== S U B R O U T I N E =======================================


sethard         proc near               ; CODE XREF: BIOSDATA:2201↑p
                                        ; BIOSDATA:222A↑p
                push    di              ; inputs:
                                        ;     dl is rom drive number (80h...)
                                        ;     bh is partition number (0....)
                                        ;     ds:di points to bds
                                        ; outputs:
                                        ;     carry clear -> bpb is filled in
                                        ;     carry set -> bpb is left uninitialized due to error
                push    bx
                push    ds
                push    es
                mov     [di+5], bl      ; [di+BDS.drivelet]
                mov     [di+4], dl      ; [di+BDS.drivenum]
                or      byte ptr [di+3Fh], 1 ; [di+BDS.flags], fnon_removable
                mov     byte ptr [di+3Eh], 5 ; [di+BDS.formfactor], ffHardFile
                mov     ds:fbigfat, 0   ; assume 12 bit FAT
                mov     dh, bh
                push    dx
                mov     ah, 8
                int     13h             ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
                                        ; DL = drive number
                                        ; Return: CF set on error, AH = status code, BL = drive type
                                        ; DL = number of consecutive drives
                                        ; DH = maximum value for head number, ES:DI -> drive parameter
                mov     dl, dh
                mov     dh, 0
                inc     dx
                mov     [di+15h], dx    ; [di+BDS.heads]
                pop     dx
                jb      short setret_j  ; error if no hard disk
                and     cx, 3Fh
                mov     [di+13h], cx    ; [di+BDS.secpertrack]
                push    dx
                call    getboot
                pop     dx              ; restore partition number
                jnb     short chk_act_part

setret_j:                               ; CODE XREF: sethard+27↑j
                jmp     setret
; ---------------------------------------------------------------------------

chk_act_part:                           ; CODE XREF: sethard+34↑j
                xor     bx, bx
                mov     cs:ep_start_sector, bx
                mov     cs:ep_start_sector+2, bx
                mov     cs:ep_hidden_secs, bx
                mov     cs:ep_hidden_secs+2, bx
                mov     bx, 3C2h        ; 1C2h+bootbias

act_part:                               ; CODE XREF: sethard+8A↓j
                test    byte ptr es:[bx-4], 80h
                jz      short no_act
                cmp     byte ptr es:[bx], 1 ; FAT12
                jz      short got_good_act
                cmp     byte ptr es:[bx], 4 ; FAT16 CHS (<= 32MB)
                jz      short got_good_act
                cmp     byte ptr es:[bx], 0Bh ; FAT32 CHS
                jz      short got_good_act
                cmp     byte ptr es:[bx], 0Ch ; FAT32 LBA
                jz      short got_good_act
                cmp     byte ptr es:[bx], 0Eh ; FAT16 LBA
                jz      short got_good_act
                cmp     byte ptr es:[bx], 6 ; FAT16 BIG CHS (> 32MB)
                jnz     short no_act

got_good_act:                           ; CODE XREF: sethard+5D↑j
                                        ; sethard+63↑j ...
                or      dh, dh
                jz      short set2
                dec     dh

no_act:                                 ; CODE XREF: sethard+57↑j
                                        ; sethard+7B↑j
                add     bx, 16
                cmp     bx, 402h        ; 202h+bootbias
                                        ; last entry done?
                jnz     short act_part
                mov     bx, 3C2h        ; 1C2h+bootbias
                                        ; restore original value of bx

get_primary:                            ; CODE XREF: sethard+C7↓j
                test    byte ptr es:[bx-4], 80h
                jnz     short not_prim  ; we've already scanned
                                        ; the ACTIVE ones
                cmp     byte ptr es:[bx], 1 ; FAT12 fs
                jz      short got_prim
                cmp     byte ptr es:[bx], 4 ; FAT16 fs
                jz      short got_prim
                cmp     byte ptr es:[bx], 0Bh ; FAT32 CHS file system
                jz      short got_prim
                cmp     byte ptr es:[bx], 0Ch ; FAT32 LBA file system
                jz      short got_prim
                cmp     byte ptr es:[bx], 0Eh ; FAT16 LBA file system
                jz      short got_prim
                cmp     byte ptr es:[bx], 6 ; FAT16 big fs (> 32 MB)
                jnz     short not_prim

got_prim:                               ; CODE XREF: sethard+9A↑j
                                        ; sethard+A0↑j ...
                or      dh, dh
                jz      short set2
                dec     dh

not_prim:                               ; CODE XREF: sethard+94↑j
                                        ; sethard+B8↑j
                add     bx, 16
                cmp     bx, 402h        ; 202h+bootbias
                jnz     short get_primary ; loop till we've gone through table

setret:                                 ; CODE XREF: sethard:setret_j↑j
                                        ; sethard:set3_err↓j
                stc
                jmp     ret_hard_err
; ---------------------------------------------------------------------------
ep_start_sector dw 2 dup(0)             ; DATA XREF: sethard+3B↑w
                                        ; domini+D↓w ...
ep_hidden_secs  dw 2 dup(0)             ; DATA XREF: sethard+45↑w
                                        ; sethard:okdrive↓r ...
; ---------------------------------------------------------------------------

set2:                                   ; CODE XREF: sethard+7F↑j
                                        ; sethard+BC↑j ...
                mov     cs:rom_drv_num, dl
                mov     ax, es:[bx+4]   ; start sector (LBA) of the partition
                mov     dx, es:[bx+6]
                sub     ax, 1
                sbb     dx, 0           ; zero based sector count
                add     ax, es:[bx+8]   ; start LBA + partition size in sectors
                adc     dx, es:[bx+0Ah]
                jnb     short okdrive
                or      ds:fbigfat, 80h ; ftoobig

okdrive:                                ; CODE XREF: sethard+F0↑j
                add     ax, cs:ep_hidden_secs
                adc     dx, cs:ep_hidden_secs+2
                jnb     short okdrive_1
                or      ds:fbigfat, 80h ; ftoobig

okdrive_1:                              ; CODE XREF: sethard+101↑j
                cmp     byte ptr es:[bx], 0Ch ; FAT32 LBA partition ID
                jz      short set_lba_flag
                cmp     byte ptr es:[bx], 0Eh ; FAT16 LBA partition ID
                jz      short set_lba_flag
                cmp     dx, [di+13h]    ; if dx > [di+BDS.secpertrack] then
                jnb     short set_lba_flag ; set LBA r/w flag
                div     word ptr [di+13h]
                xor     dx, dx
                div     word ptr [di+15h]
                cmp     ax, 400h        ; if ax (cylinder number) >= 1024
                                        ;  set LBA r/w flag
                jb      short set3

set_lba_flag:                           ; CODE XREF: sethard+10C↑j
                                        ; sethard+112↑j ...
                or      byte ptr [di+40h], 4 ; fLBArw ; LBA r/w flag

set3:                                   ; CODE XREF: sethard+124↑j
                mov     ax, es:[bx+4]   ; start sector (LBA) of the partition
                mov     dx, es:[bx+6]
                add     ax, cs:ep_hidden_secs ; + hidden secs of the extd dos partion
                adc     dx, cs:ep_hidden_secs+2
                mov     [di+17h], ax    ; [di+BDS.hiddensectors]
                mov     [di+19h], dx
                xor     ax, ax
                mov     [di+7Bh], ax
                mov     [di+0Eh], ax
                mov     dx, es:[bx+10]  ; totals sectors (size) of the partition
                mov     ax, es:[bx+8]
                mov     [di+1Dh], dx
                mov     [di+1Bh], ax    ; [di+BDS.totalsecs32]
                cmp     dx, 0
                ja      short set3_read
                cmp     ax, 64
                jb      short set3_err

set3_read:                              ; CODE XREF: sethard+15B↑j
                mov     dx, [di+19h]    ; [di+BDS.hiddensectors+2]
                mov     ax, [di+17h]    ; [di+BDS.hiddensectors]
                xor     bx, bx
                mov     bl, [di+13h]    ; [di+BDS.secpertrack]
                push    ax
                mov     ax, dx
                xor     dx, dx
                div     bx
                mov     cs:saved_word, ax
                pop     ax
                div     bx
                mov     cl, dl
                inc     cl
                mov     bx, [di+15h]    ; [di+BDS.heads]
                push    ax
                xor     dx, dx
                mov     ax, cs:saved_word
                div     bx
                mov     cs:saved_word, ax
                pop     ax
                div     bx
                test    byte ptr [di+40h], 4 ; fLBArw ; LBA read/write flag
                jz      short set3_chs_read

set3_lba_read:
                push    cs
                pop     es
                assume es:BIOSDATA
                mov     bx, offset disksector
                push    ds
                push    si
                xor     ax, ax          ; 0
                push    ax
                push    ax
                mov     ax, [di+19h]    ; [di+BDS.hiddensectors+2]
                push    ax
                mov     ax, [di+17h]    ; [di+BDS.hiddensectors]
                push    ax
                push    es              ; buffer address
                push    bx
                mov     ax, 1           ; sector (read) count
                push    ax
                mov     ax, 16          ; DAP size
                push    ax
                mov     ax, ss
                mov     ds, ax
                assume ds:nothing
                mov     si, sp
                mov     dl, cs:rom_drv_num
                mov     ah, 42h
                int     13h             ; DISK - IBM/MS Extension
                                        ; EXTENDED READ (DL - drive, DS:SI - disk address packet)
                jnb     short set3_lba_read_ok
                add     sp, 16
                pop     si
                pop     ds
                assume ds:nothing

set3_err:                               ; CODE XREF: sethard+160↑j
                                        ; sethard+1FA↓j
                jmp     setret
; ---------------------------------------------------------------------------

set3_lba_read_ok:                       ; CODE XREF: sethard+1C4↑j
                add     sp, 16
                pop     si
                pop     ds
                jmp     short set3_read_ok
; ---------------------------------------------------------------------------

set3_chs_read:                          ; CODE XREF: sethard+196↑j
                cmp     word ptr [di+79h], 1 ; [di+BDS.bdsm_ismini] ; check for mini disk
                jnz     short oknotmini
                add     ax, [di+7Bh]    ; [di+BDS.bdsm_hidden_trks]

oknotmini:                              ; CODE XREF: sethard+1D9↑j
                ror     ah, 1           ; move high two bits of cyl to high
                ror     ah, 1           ; two bits of upper byte
                and     ah, 0C0h        ; turn off remainder of bits
                or      cl, ah          ; move two bits to correct spot
                mov     ch, al          ; ch is cylinder (low 8 bits)
                                        ; cl is sector + 2 high bits of cylinder
                mov     dh, dl          ; dh is head
                mov     dl, cs:rom_drv_num ; dl is drive number
                push    cs
                pop     es
                mov     bx, offset disksector
                mov     ax, 201h
                int     13h             ; DISK - READ SECTORS INTO MEMORY
                                        ; AL = number of sectors to read, CH = track, CL = sector
                                        ; DH = head, DL = drive, ES:BX -> buffer to fill
                                        ; Return: CF set on error, AH = status, AL = number of sectors read
                jb      short set3_err

set3_read_ok:                           ; CODE XREF: sethard+1D3↑j
                mov     bx, offset disksector
                push    bx
                push    ax
                cmp     word ptr es:[bx+1FEh], 0AA55h
                jnz     short invalid_boot_record
                cmp     word ptr es:[bx+16h], 0 ; [bx+BPB_FATSz16] ; 16 bit FAT size is 0 if it is FAT32 bs
                jz      short check_1   ; FAT32
                push    ds
                push    si
                push    di
                push    es
                pop     ds
                assume ds:BIOSDATA
                mov     cx, 28
                lea     si, [bx+24h]    ; move offset 36 to 63
                                        ;      to offset offset 64 (28 bytes)
                lea     di, [bx+40h]    ; boot sector offset 64
                cld
                rep movsb
                pop     di
                pop     si
                pop     ds
                assume ds:nothing

check_1:                                ; CODE XREF: sethard+20F↑j
                cmp     byte ptr cs:[bx], 0E9h ; is it a near jump?
                jz      short check_1_ok ; yes
                cmp     byte ptr cs:[bx], 0EBh ; is it a short jump?
                jnz     short invalid_boot_record ; no
                cmp     byte ptr cs:[bx+2], 90h ; yes, is the next one a nop?
                jnz     short invalid_boot_record ; no

check_1_ok:                             ; CODE XREF: sethard+229↑j
                mov     bx, (offset disksector+0Bh) ;  disksector+EXT_BOOT.BPB ; disksector+11
                mov     al, cs:[bx+10]  ; [bx+EBPB.MEDIADESCRIPTOR]
                and     al, 0F0h        ; mask off low nibble
                cmp     al, 0F0h        ; is high nibble = 0Fh?
                jnz     short invalid_boot_record
                cmp     word ptr cs:[bx], 512 ; [bx+EBPB.BYTESPERSECTOR]
                jnz     short invalid_boot_record ; invalidate non 512 byte sectors
                mov     al, cs:[bx+2]   ; now make sure that
                                        ; the sectorspercluster is a power of 2
                or      al, al          ; is it zero?
                jz      short invalid_boot_record ; yes, invalid boot record

ck_power_of_two:                        ; CODE XREF: sethard+256↓j
                shr     al, 1           ; shift until first bit emerges
                jnb     short ck_power_of_two
                jz      short valid_boot_record

invalid_boot_record:                    ; CODE XREF: sethard+208↑j
                                        ; sethard+22F↑j ...
                pop     ax
                pop     bx
                jmp     unknown         ; jump to invalid boot record
                                        ; unformatted or illegal media.
; ---------------------------------------------------------------------------

valid_boot_record:                      ; CODE XREF: sethard+258↑j
                pop     ax
                pop     bx              ;
                                        ; Signature found. Now check version.
                cmp     word ptr cs:[bx+8], 2E32h ; '2.' (NASM syntax)
                jnz     short try5
                cmp     byte ptr cs:[bx+0Ah], 30h ; '0'
                jnz     short try5
                jmp     short copybpb
; ---------------------------------------------------------------------------

unknown3_0_j:                           ; CODE XREF: sethard+293↓j
                                        ; sethard+29C↓j
                jmp     unknown3_0
; ---------------------------------------------------------------------------

try5:                                   ; CODE XREF: sethard+267↑j
                                        ; sethard+26E↑j
                call    cover_fdisk_bug
                cmp     word ptr cs:[bx+8], 2E30h ; '0.' (NASM syntax)
                jnz     short no_os2
                mov     al, cs:[bx+7]
                sub     al, 31h ; '1'
                and     al, 0FEh
                jz      short copybpb   ; accept either '1' or '2'
                jmp     unknown
; ---------------------------------------------------------------------------

no_os2:                                 ; CODE XREF: sethard+27E↑j
                cmp     word ptr cs:[bx+8], 2E33h ; '3.' (NASM syntax)
                jb      short unknown3_0_j
                jnz     short copybpb
                cmp     byte ptr cs:[bx+0Ah], 31h ; '1'
                jb      short unknown3_0_j

copybpb:                                ; CODE XREF: sethard+270↑j
                                        ; sethard+288↑j ...
                cmp     word ptr cs:disksector+4Dh, 0 ; BPB_SecPerClus (at 0Dh)
                jnz     short check_2   ; NOTE: This check is not propfer for FAT32 boot sector (standard spec)
                                        ; (after PCDOS 7.1). So, it is not existing in Windows ME IO.SYS
                                        ; Erdogan Tan - 01/09/2023
                cmp     cs:disksector+42h, 29h ; BS_BootSig (FAT32)
                jmp     short check_3
; ---------------------------------------------------------------------------

check_2:                                ; CODE XREF: sethard+2A4↑j
                cmp     cs:disksector+26h, 29h ; BS_BootSig (FAT16/FAT12)

check_3:                                ; CODE XREF: sethard+2AC↑j
                jnz     short copybpb_fat
                cmp     cs:disksector+10h, 0 ; BPB.fats
                jnz     short copybpb_fat
                push    di
                push    ds
                push    ds
                pop     es
                assume es:nothing
                push    cs
                pop     ds
                assume ds:BIOSDATA
                mov     si, (offset disksector+0Bh) ; BIOSDATA:015Dh
                add     di, 6           ; add di,BDS.BPB
                cmp     word ptr cs:[si+8], 0 ; [BPB.totalsecs16]
                jnz     short already_nonz
                cmp     word ptr cs:[si+15h], 0 ; [BPB.totalsecs32]
                jnz     short already_nonz
                cmp     word ptr cs:[si+17h], 0 ; [BPB.totalsecs32+2]
                jnz     short already_nonz
                mov     ax, [di+8]      ; .. empty BPB (size) fields ..
                                        ; fill boot sector's BPB fields
                                        ;           with correct values
                mov     cs:[si+8], ax
                mov     ax, [di+15h]
                mov     cs:[si+15h], ax
                mov     ax, [di+17h]
                mov     cs:[si+17h], ax

already_nonz:                           ; CODE XREF: sethard+2CF↑j
                                        ; sethard+2D6↑j ...
                mov     cx, 53          ; copy contents of the bootsector's BPB
                                        ;                      to the BDS's BPB
                rep movsb
                pop     ds
                assume ds:nothing
                pop     di
                push    es
                push    ds
                pop     es
                push    cs
                pop     ds
                assume ds:BIOSDATA
                mov     bp, offset mov_media_ids
                push    cs
                call    call_bios_code
                push    es
                pop     ds
                assume ds:nothing
                pop     es
                jmp     goodret
sethard         endp


; =============== S U B R O U T I N E =======================================


copybpb_fat     proc near               ; CODE XREF: sethard:check_3↑j
                                        ; sethard+2BC↑j
                mov     si, (offset disksector+0Bh) ; BIOSDATA:015Dh
                                        ; disksector+11
                                        ; disksector+EXT_BOOT.BPB
                xor     dx, dx
                mov     ax, cs:[si+8]   ; BPB.totalsecs16
                or      ax, ax          ; get totsec from boot sec
                jnz     short copy_totsec
                mov     ax, cs:[si+15h] ; BPB.totalsecs32
                mov     dx, cs:[si+17h] ; BPB.totalsecs32+2
                mov     cx, dx          ; get the big version
                or      cx, ax          ; see if it is a big zero
                jz      short fat_big_small ; screw it. it was bogus.

copy_totsec:                            ; CODE XREF: copybpb_fat+B↑j
                mov     [di+1Bh], ax    ; [di+BDS.totalsecs32]
                mov     [di+1Dh], dx    ; [di+BDS.totalsecs32+2]

fat_big_small:                          ; CODE XREF: copybpb_fat+19↑j
                mov     ax, [di+1Bh]
                mov     dx, [di+1Dh]
                mov     bx, cs:[si+3]   ; BPB.resectors
                mov     [di+9], bx      ; [di+BDS.resectors]
                sub     ax, bx
                sbb     dx, 0
                mov     bx, cs:[si+0Bh] ; BPB.fatsecs
                mov     [di+11h], bx    ; [di+BDS.fatsecs]
                push    bx
                or      bx, bx
                jnz     short fat_16bit
                sub     ax, cs:[si+19h] ; FAT32 file system (BUG!)
                                        ; BPB.FATSz32
                sbb     dx, cs:[si+1Bh] ; BPB.FATSz32+2 (BUG!)
                mov     bx, cs:[si+19h] ; BPB.FATSz32
                mov     [di+1Fh], bx    ; [di+BDS.fatsecs32]
                mov     bx, cs:[si+1Bh] ; BPB.FATSz32+2
                mov     [di+21h], bx    ; [di+BDS.fatsecs32+2]
                mov     bx, cs:[si+1Dh] ; BPB.BPB_ExtFlags
                mov     [di+23h], bx    ; [di+BDS.extflags]
                mov     bx, cs:[si+1Fh] ; BPB.FSVer
                mov     [di+25h], bx    ; [di+BDS.fsver]
                mov     bx, cs:[si+21h] ; BPB.RootClus
                mov     [di+27h], bx    ; [di+BDS.rootdirclust]
                mov     bx, cs:[si+23h] ; BPB.RootClus+2
                mov     [di+29h], bx    ; [di+BDS.rootdirclust+2]
                mov     bx, cs:[si+25h] ; BPB.FSInfo
                mov     [di+2Bh], bx    ; [di+BDS.fsinfo]
                mov     bx, cs:[si+27h] ; BPB.FSInfo+2
                mov     [di+2Dh], bx    ; [di+BDS.fsinfo+2]
                jmp     short fat_32bit ; BUG! Erdogan Tan - 8/8/2023
                                        ; correct code (would be):
                                        ;   mov cl, [cs:si+05h] ; BPB_NumFATs
                                        ; sub_fat32_size:
                                        ;   sub ax, [cs:si+19h] ; BPB_FATSz32
                                        ;   sbb dx, [cs:si+1Bh] ; BPB_FATSz32+2
                                        ;   dec cl
                                        ;   jg short sub_fat32_size
                                        ;   jmp short fat_32bit
; ---------------------------------------------------------------------------

fat_16bit:                              ; CODE XREF: copybpb_fat+3D↑j
                shl     bx, 1           ; always 2 fats ! BUG!
                sub     ax, bx          ; sub # fat sectors
                sbb     dx, 0           ; BUG! Erdogan Tan - 8/8/2023
                                        ; correct code (would be):
                                        ;   mov cl, [cs:si+05h] ; BPB_NumFATs
                                        ; sub_fat_size:
                                        ;   sub ax, bx ; BPB.fatsecs
                                        ;   sbb dx, 0
                                        ;   dec cl
                                        ;   jg short sub_fat_size

fat_32bit:                              ; CODE XREF: copybpb_fat+7F↑j
                mov     bx, cs:[si+6]   ; BPB.direntries
                mov     [di+0Ch], bx    ; [di+BDS.direntries]
                mov     cl, 4
                shr     bx, cl
                sub     ax, bx          ; - root dir sectors
                sbb     dx, 0           ; dx:ax = # of data sectors
                xor     cx, cx
                mov     cl, cs:[si+2]   ; BPB.secperclus
                mov     [di+8], cl      ; [di+BDS.secperclus]
                push    ax
                mov     ax, dx
                xor     dx, dx
                div     cx              ; 32 bit division
                mov     cs:saved_word, ax ; hw of cluster number
                pop     ax
                div     cx
                pop     bx
                or      bx, bx
                jnz     short chk_clnum_hw ; 16 bit fat sectors > 0 ; FAT12 or FAT16 fs
                cmp     cs:saved_word, 0FFFh
                jnz     short fat32_clust_limit
                cmp     ax, 0FFF6h      ; FAT32 cluster number limit: 0FFFFFF6h

fat32_clust_limit:                      ; CODE XREF: copybpb_fat+BB↑j
                ja      short toobig_ret
                cmp     cs:saved_word, bx
                jnz     short fat16_clust_limit
                cmp     ax, 0FFF6h      ; FAT16 cluster number limit: 0FFF6h

fat16_clust_limit:                      ; CODE XREF: copybpb_fat+C7↑j
                jbe     short fat12_clust_limit
                or      ds:fbigfat, 20h ; fbigbig ; FAT32 fs
                jmp     short copymediaid
; ---------------------------------------------------------------------------

chk_clnum_hw:                           ; CODE XREF: copybpb_fat+B2↑j
                cmp     cs:saved_word, 0
                ja      short toobig_ret

fat12_clust_limit:                      ; CODE XREF: copybpb_fat:fat16_clust_limit↑j
                cmp     ax, 0FF6h       ; FAT12 cluster number limit: 0FF6h
                jb      short copymediaid ; FAT12 fs
                or      ds:fbigfat, 40h ; fbig ; FAT16 fs

copymediaid:                            ; CODE XREF: copybpb_fat+D3↑j
                                        ; copybpb_fat+E0↑j
                push    es
                push    ds
                pop     es
                push    cs
                pop     ds
                assume ds:BIOSDATA
                mov     bp, offset mov_media_ids ;
                                        ; MOVMEDIAIDS equ mov_media_ids - DOSBIOSEG
                push    cs
                call    call_bios_code
                push    es
                pop     ds
                assume ds:nothing
                pop     es
                jmp     massage_bpb
; ---------------------------------------------------------------------------

toobig_ret:                             ; CODE XREF: copybpb_fat:fat32_clust_limit↑j
                                        ; copybpb_fat+DB↑j
                or      cs:fbigfat, 80h ; ftoobig ; too big (32 bit cluster #) for FAT16
                jmp     goodret         ; still drive letter is assigned
                                        ; but useless. to big for
                                        ; current pc dos fat file system
; ---------------------------------------------------------------------------

unknown:                                ; CODE XREF: sethard+25C↑j
                                        ; sethard+28A↑j
                or      byte ptr [di+40h], 2 ; [di+BDS.flags+1] ; unformatted_media
                                        ; Set unformatted media flag.

unknown3_0:                             ; CODE XREF: sethard:unknown3_0_j↑j
                mov     dx, [di+1Dh]    ; skip setting unformatted_media bit
                                        ; [di+BDS.totalsecs32+2]
                mov     ax, [di+1Bh]    ; [di+BDS.totalsecs32]
                mov     si, offset disktable2

scan:                                   ; CODE XREF: copybpb_fat+11F↓j
                cmp     dx, cs:[si]     ; total sectors hw
                jb      short gotparm
                ja      short scan_next
                cmp     ax, cs:[si+2]   ; total sectors lw
                jbe     short gotparm

scan_next:                              ; CODE XREF: copybpb_fat+114↑j
                add     si, 10
                jmp     short scan
; ---------------------------------------------------------------------------

gotparm:                                ; CODE XREF: copybpb_fat+112↑j
                                        ; copybpb_fat+11A↑j
                mov     cl, [si+8]      ; bigfat flags
                                        ; (FAT16 fbig=40h, FAT32 fbigbig=20h)
                or      ds:fbigfat, cl
                mov     cx, cs:[si+4]   ; shift count (cl) -log base 2 of ch-
                                        ; sector per cluster (ch)
                mov     dx, cs:[si+6]   ; root directory entries
                mov     [di+0Ch], dx    ; [di+BDS.direntries]
                mov     dx, [di+1Dh]    ; [di+BDS.totalsecs32]
                mov     ax, [di+1Bh]
                mov     [di+8], ch      ; [di+BDS.secperclus]
                test    ds:fbigfat, 60h ; fbig+fbigbig ; FAT16 or FAT32
                jnz     short dobig
                xor     bx, bx          ; 12 bit fat (FAT12 fs)
                mov     bl, ch
                dec     bx
                add     bx, ax
                shr     bx, cl
                inc     bx              ; bx = 1+(bpb->maxsec+BDS.secperclus-1)
                                        ;      / BDS.secperclus
                and     bl, 0FEh        ; bx &= ~1; (=number of clusters)
                mov     si, bx
                shr     bx, 1
                add     bx, si          ; number of FAT bytes
                add     bx, 511         ; bx += 511 + bx/2
                shr     bh, 1           ; bh >>= 1; (=bx/512)
                mov     [di+11h], bh    ; [di+BDS.fatsecs]
                                        ; save number of fat sectors
                jmp     short massage_bpb
; ---------------------------------------------------------------------------

dobig:                                  ; CODE XREF: copybpb_fat+141↑j
                mov     cl, 4           ; 16 (2^4) directory entries per sector
                push    dx              ; save total sectors (high)
                mov     dx, [di+0Ch]    ; [di+BDS.direntries]
                shr     dx, cl          ; root dir sectors = BDS.direntries / 16;
                sub     ax, dx
                pop     dx              ; restore total sectors (high)
                sbb     dx, 0           ; dx:ax = total sectors - root dir sectors
                sub     ax, 1           ; - reserved sectors (1 for FAT16 fs)
                sbb     dx, 0           ; dx:ax = t - r - d
                                        ; total secs - reserved secs - root dir secs
                mov     bl, 2
                mov     bh, [di+8]      ; [di+BDS.secperclus]
                                        ; bx = 256 * BDS.secperclus + 2
                                        ;
                                        ; ; 29/12/2018 - Erdogan Tan (Retro DOS v4.0)
                                        ; ; 27/09/2022
                                        ; ; (Microsoft FAT32 File System Specification,
                                        ; ; December 2000, Page 21)
                                        ; ; TmpVal1 = DskSize - (BPB_ResvdSecCnt+RootrDirSectors)
                                        ; ; TmpVal2 = (256*BPB_SecPerClus)+BPB_NumFATs
                                        ; ; 8/8/2023 (Retro DOS v5.0)
                                        ; ; If(FATType == FAT32)
                                        ; ;   TmpVal2 = TmpVal2 / 2;
                                        ; ; FATsz = (TmpVal1+(TmpVal2-1))/TmpVal2
                                        ; ; 8/8/2023 (Retro DOS v5.0)
                                        ; ; If(FATType == FAT32) {
                                        ; ;   BPB_FATSz16 = 0;
                                        ; ;   BPB_FATSz32 = FATSz;
                                        ; ;} else {
                                        ; ;   BPB_FATSz16 = LOWORD(FATSz);
                                        ; ;/* there is no BPB_FATSz32 in a FAT16 BPB */
                                        ; ;}
                                        ;
                                        ; dx:ax = TmpVal1, bx = TmpVal2
                add     ax, bx
                adc     dx, 0           ; dx:ax = TmpVal1+TmpVal2
                sub     ax, 1
                sbb     dx, 0           ; dx:ax = TmpVal1+TmpVal2-1
                test    ds:fbigfat, 20h ; fbigbig (FAT32) flag
                jz      short dobig1
                shr     bx, 1           ; TmpVal2 = TmpVal2 / 2
                                        ; dx:ax = TmpVal1+(2*TmpVal2)-1
                sub     ax, 31          ; reserved sectors = 32 (for FAT32 fs) /// 1+31 = 32
                sbb     dx, 0
                sub     ax, bx
                sbb     dx, 0           ; dx:ax = TmpVal1+(2*TmpVal2)-TmpVal2-1
                                        ;       = TmpVal1+(TmpVal2-1)

dobig1:                                 ; CODE XREF: copybpb_fat+18A↑j
                push    ax              ; save lw of dividend
                mov     ax, dx          ; divide hw of dx:ax at first (as 1st stage)
                xor     dx, dx
                div     bx              ; 32 bit division, dx:ax/bx
                                        ; remainder in dx is hw of 2nd stage dividend
                mov     bp, ax          ; hw of quotient
                pop     ax              ; restore lw of dividend (of 1st stage)
                div     bx
                mov     [di+11h], ax    ; [di+BDS.fatsecs] ; number of fat sectors
                                        ; lw of quotient
                mov     bl, ds:fbigfat
                mov     [di+3Bh], bl    ; [di+BDS.fatsiz] ; fat size flag
                test    bl, 20h         ; fbigbig (FAT32) flag
                jz      short dobig2    ; not FAT32
                mov     [di+1Fh], ax    ; [di+BDS.fatsecs32]
                mov     [di+21h], bp    ; [di+BDS.fatsecs32+2]
                mov     word ptr [di+11h], 0 ; [di+BDS.fatsecs] = 0
                                        ; clear 16 bit FAT size field
                mov     word ptr [di+9], 32 ; [di+BDS.resectors]
                                        ; set reserved sectors to 32 (FAT32 de facto)

dobig2:                                 ; CODE XREF: copybpb_fat+1B2↑j
                push    ds              ; set the default filesys_id,
                                        ;     volume label, serial number
                push    ds
                pop     es
                push    cs
                pop     ds
                assume ds:BIOSDATA
                mov     bp, offset clear_ids
                push    cs
                call    call_bios_code
                pop     ds
                assume ds:nothing

massage_bpb:                            ; CODE XREF: copybpb_fat+F6↑j
                                        ; copybpb_fat+15F↑j
                mov     dx, [di+1Dh]    ; [di+BDS.totalsecs32+2]
                mov     ax, [di+1Bh]    ; [di+BDS.totalsecs32]
                cmp     dx, 0
                ja      short goodret
                cmp     word ptr [di+19h], 0 ; [di+BDS.hiddensecs+2]
                ja      short goodret
                add     ax, [di+17h]    ; [di+BDS.hiddensecs]
                jb      short goodret
                mov     ax, [di+1Bh]    ; [di+BDS.totalsecs32]
                mov     [di+0Eh], ax    ; [di+BDS.totalsecs16]
                mov     word ptr [di+1Bh], 0

goodret:                                ; CODE XREF: sethard+30A↑j
                                        ; copybpb_fat+FF↑j ...
                mov     bl, ds:fbigfat
                mov     [di+3Bh], bl    ; [di+BDS.fatsiz]
                                        ; set size of fat on media
                clc

ret_hard_err:                           ; CODE XREF: sethard+CA↑j
                pop     es
                pop     ds
                pop     bx
                pop     di
                retn
copybpb_fat     endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


cover_fdisk_bug proc near               ; CODE XREF: sethard:try5↑p
                push    ax              ; fdisk of pc dos 3.3 and below, os2 1.0 has a bug.
                                        ; the maximum number of sector that can be handled by pc dos 3.3
                                        ; ibmbio should be 0ffffh. instead, sometimes fdisk use 10000h to
                                        ; calculate the maximum number. so, we are going to check that if
                                        ; BPB_TOTALSECTORS + hidden sector = 10000h then subtract 1 from
                                        ; BPB_TOTALSECTORS.
                push    dx
                push    si
                cmp     word ptr cs:disksector+16h, 0 ; BPB_FATSz16
                jz      short cfb_retit ; FAT32 boot sector
                cmp     cs:disksector+26h, 29h ; ')' ;
                                        ; [disksector+EXT_BOOT.SIG], EXT_BOOT_SIGNATURE
                jz      short cfb_retit ; if extended bpb, then >= pc dos 4.00
                cmp     word ptr cs:[bx+7], 3031h ; '10' ; os2 1.0 = ibm 10.0
                jnz     short cfb_chk_totalsecs
                cmp     byte ptr cs:[bx+0Ah], 30h ; '0'
                jnz     short cfb_retit

cfb_chk_totalsecs:                      ; CODE XREF: cover_fdisk_bug+19↑j
                mov     si, (offset disksector+0Bh) ; 15Dh
                                        ; disksector+EXT_BOOT.BPB
                cmp     word ptr cs:[si+8], 0 ; [cs:si+EBPB.TOTALSECTORS]
                jz      short cfb_retit ; just to make sure.
                mov     ax, cs:[si+8]
                add     ax, cs:[si+11h] ; [cs:si+EBPB.HIDDENSECTORS]
                jnb     short cfb_retit
                jnz     short cfb_retit ;
                                        ; if carry set and ax=0
                dec     word ptr cs:[si+8] ; then decrease BPB_TOTALSECTORS by 1
                sub     word ptr [di+1Bh], 1 ; [di+BDS.totalsecs32]
                sbb     word ptr [di+1Dh], 0 ; [di+BDS.totalsecs32+2]

cfb_retit:                              ; CODE XREF: cover_fdisk_bug+9↑j
                                        ; cover_fdisk_bug+11↑j ...
                pop     si
                pop     dx
                pop     ax
                retn
cover_fdisk_bug endp

; ---------------------------------------------------------------------------
word2           dw 2                    ; DATA XREF: setdrvparms+8C↓r
word3           dw 3                    ; DATA XREF: setdrvparms+87↓r
word512         dw 200h                 ; DATA XREF: setdrvparms+93↓r

; =============== S U B R O U T I N E =======================================


setdrvparms     proc near               ; CODE XREF: BIOSDATA:245C↑p
                xor     bx, bx          ; setdrvparms sets up the recommended bpb in each bds
                                        ; in the system based on the form factor.
                                        ; it is assumed that the bpbs for the various form factors
                                        ; are present in the bpbtable. for hard files,
                                        ; the recommended bpb is the same as the bpb on the drive.
                les     di, dword ptr ds:start_bds ; get first bds in list

_next_bds:                              ; CODE XREF: setdrvparms+B7↓j
                push    es
                push    di
                mov     bl, es:[di+3Eh] ; [es:di+BDS.formfactor]
                cmp     bl, 5           ; ffHardFile
                jnz     short nothardff
                xor     dx, dx
                mov     ax, es:[di+0Eh] ; [es:di+BDS.totalsecs16]
                or      ax, ax
                jnz     short get_ccyl
                mov     dx, es:[di+1Dh] ; [es:di+BDS.totalsecs32+2]
                mov     ax, es:[di+1Bh] ; [es:di+BDS.totalsecs32]

get_ccyl:                               ; CODE XREF: setdrvparms+19↑j
                push    dx
                push    ax
                mov     ax, es:[di+15h] ; [es:di+BDS.heads]
                mul     word ptr es:[di+13h] ; [es:di+BDS.secpertrack]
                                        ; assume sectors per cyl. < 64k.
                mov     cx, ax          ; cx has # sectors per cylinder
                pop     ax
                pop     dx              ; dx:ax = total sectors
                push    ax
                mov     ax, dx
                xor     dx, dx
                div     cx
                mov     cs:saved_word, ax
                pop     ax
                div     cx              ; div #sec by sec/cyl to get # cyl.
                or      dx, dx
                jz      short no_cyl_rnd
                inc     ax              ; round up

no_cyl_rnd:                             ; CODE XREF: setdrvparms+41↑j
                mov     es:[di+41h], ax ; [es:di+BDS.cylinders]
                push    es
                pop     ds
                lea     si, [di+6]      ; [di+BDS.bytespersec]
                                        ; ds:si -> bpb for hard file
                jmp     short set_recbpb
; ---------------------------------------------------------------------------

nothardff:                              ; CODE XREF: setdrvparms+F↑j
                push    cs
                pop     ds              ; if fake floppy drive variable is set
                                        ; then we don't have to handle this bds.
                                        ; we can just go and deal with the next bds
                                        ; at label go_to_next_bds.
                assume ds:BIOSDATA
                cmp     cs:fakefloppydrv, 1
                jz      short go_to_next_bds
                cmp     bl, 7           ; ffother
                                        ; special case "other" type of medium
                jnz     short not_process_other
                xor     dx, dx
                mov     ax, [di+41h]    ; [di+BDS.cylinders]
                mul     word ptr [di+52h] ; [di+BDS.rheads]
                mul     word ptr [di+50h] ; [di+BDS.rsecpertrack]
                mov     [di+4Bh], ax    ; [di+BDS.rtotalsecs16]
                                        ; have the total number of sectors
                dec     ax
                mov     dl, 1

_again:                                 ; CODE XREF: setdrvparms+78↓j
                cmp     ax, 0FF6h       ; 4096-10
                jb      short _@@
                shr     ax, 1
                shl     dl, 1
                jmp     short _again
; ---------------------------------------------------------------------------

_@@:                                    ; CODE XREF: setdrvparms+72↑j
                cmp     dl, 1           ; is it a small disk ?
                jz      short __@@      ; yes, 224 root entries is enuf
                mov     word ptr [di+49h], 240 ; [di+BDS.rdirentries]

__@@:                                   ; CODE XREF: setdrvparms+7D↑j
                mov     [di+45h], dl    ; [di+BDS.rsecperclus]
                mul     cs:word3        ; * 3
                div     cs:word2        ; / 2
                xor     dx, dx
                div     cs:word512      ; / 512
                inc     ax              ; + 1
                mov     [di+4Eh], ax    ; [di+BDS.rfatsecs]
                jmp     short go_to_next_bds
; ---------------------------------------------------------------------------

not_process_other:                      ; CODE XREF: setdrvparms+5C↑j
                shl     bx, 1           ; bx is word index into table of bpbs
                mov     si, offset bpbtable
                mov     si, [bx+si]     ; get address of bpb

set_recbpb:                             ; CODE XREF: setdrvparms+4D↑j
                lea     di, [di+43h]    ; [di+BDS.R_BPB]
                                        ; es:di -> recbpb
                mov     cx, 53          ; bpbx.size
                rep movsb               ; move (size bpbx) bytes

go_to_next_bds:                         ; CODE XREF: setdrvparms+57↑j
                                        ; setdrvparms+9C↑j
                pop     di
                pop     es              ; restore pointer to bds
                les     di, es:[di]     ; [es:di+BDS.link]
                cmp     di, 0FFFFh      ; -1
                jz      short got_end_of_bds_chain
                jmp     _next_bds
; ---------------------------------------------------------------------------

got_end_of_bds_chain:                   ; CODE XREF: setdrvparms+B5↑j
                retn
setdrvparms     endp


; =============== S U B R O U T I N E =======================================


print_init      proc near               ; CODE XREF: BIOSDATA:1EBE↑p
                                        ; BIOSDATA:1EC3↑p ...
                cbw
                mov     dx, ax
                mov     ah, 1
                int     17h             ; PRINTER - INITIALIZE
                                        ; DX = printer port (0-3)
                                        ; Return: AH = status
                retn
print_init      endp


; =============== S U B R O U T I N E =======================================


aux_init        proc near               ; CODE XREF: BIOSDATA:1EAA↑p
                                        ; BIOSDATA:1EAF↑p ...
                cbw
                mov     dx, ax
                mov     al, 0A3h        ; RSINIT ; 0A3h
                                        ; 2400,n,1,8 (msequ.inc)
                mov     ah, 0
                int     14h             ; SERIAL I/O - INITIALIZE USART
                                        ; AL = initializing parameters, DX = port number (0-3)
                                        ; Return: AH = RS-232 status code bits, AL = modem status bits
                retn
aux_init        endp


; =============== S U B R O U T I N E =======================================


domini          proc near               ; CODE XREF: BIOSDATA:2215↑p
                mov     dh, hnum        ; mini disk initialization routine
                                        ; get number of hardfiles
                cmp     dh, 0
                jz      short dominiret ; no hard file? then exit.
                mov     dl, 80h         ; start with hardfile 80h

domini_loop:                            ; CODE XREF: domini+49↓j
                xor     ax, ax
                mov     cs:ep_start_sector, ax
                mov     cs:ep_start_sector+2, ax
                mov     cs:ep_hidden_secs, ax
                mov     cs:ep_hidden_secs+2, ax
                push    dx
                mov     rom_minidisk_num, dl
                mov     ah, 8
                int     13h             ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
                                        ; DL = drive number
                                        ; Return: CF set on error, AH = status code, BL = drive type
                                        ; DL = number of consecutive drives
                                        ; DH = maximum value for head number, ES:DI -> drive parameter
                xor     ax, ax
                mov     al, dh          ; <= 255
                inc     ax              ; (0FFh -> 100h)
                mov     mini_hdlim, ax  ; # of heads
                mov     al, cl
                and     ax, 3Fh
                mov     mini_seclim, ax ; # of sectors/track
                push    es
                mov     dl, rom_minidisk_num
                call    getboot         ; read master boot record into
                                        ; initbootsegment:bootbias
                jb      short domininext
                call    find_mini_partition

domininext:                             ; CODE XREF: domini+3E↑j
                pop     es
                pop     dx
                inc     dl              ; next hard file
                dec     dh
                jnz     short domini_loop

dominiret:                              ; CODE XREF: domini+7↑j
                retn
domini          endp


; =============== S U B R O U T I N E =======================================


find_mini_partition proc near           ; CODE XREF: domini+40↑p
                add     bx, 1C2h        ; tries to find every extended partition on a disk
                                        ; bx -> file system id
                mov     ld_p_number, 26

fmpnext:                                ; CODE XREF: find_mini_partition+2A↓j
                                        ; find_mini_partition:fmpnextchain↓j
                add     ld_p_number, 16
                cmp     ld_p_number, 4122 ; 64 logical disk partitions (64 EBRs)
                                        ; (64*4 = 256 pte's, 256*16 = 4096, + 26 = 4122)
                jg      short fmpnextfound
                cmp     byte ptr es:[bx], 5 ; Extended DOS CHS
                jz      short fmpgot
                cmp     byte ptr es:[bx], 0Fh ; Extended DOS LBA
                jz      short fmpgot
                add     bx, 16
                cmp     bx, 402h        ; 202h+bootbias
                jnz     short fmpnext

fmpnextfound:                           ; CODE XREF: find_mini_partition+15↑j
                                        ; find_mini_partition+32↓j ...
                jmp     _fmpnextfound   ; extended partition not found
; ---------------------------------------------------------------------------

fmpgot:                                 ; CODE XREF: find_mini_partition+1B↑j
                                        ; find_mini_partition+21↑j
                call    dmax_check      ; check for drvmax already 26
                jnb     short fmpnextfound ; done if too many
                mov     di, end_of_bdss ; get next free bds
                mov     word ptr [di+79h], 1 ; [di+BDS.bdsm_ismini]
                or      byte ptr [di+3Fh], 1 ; [di+BDS.flags],fNon_Removable
                mov     byte ptr [di+3Eh], 5 ; [di+BDS.formfactor],ffHardFile
                mov     fbigfat, 0      ; assume 12 bit fat.
                mov     ax, mini_hdlim
                mov     [di+15h], ax    ; [di+BDS.heads]

fmpgot1:
                mov     ax, mini_seclim
                mov     [di+13h], ax    ; [di+BDS.secpertrack]
                mov     al, rom_minidisk_num
                mov     [di+4], al      ; [di+BDS.drivenum] ; set physical number
                mov     al, drvmax
                mov     [di+5], al      ; [di+BDS.drivelet] ; set logical number
                cmp     word ptr es:[bx+10], 0
                ja      short fmpgot2
                cmp     word ptr es:[bx+8], 64 ; minimum 64 sectors
                jb      short fmpnextfound

fmpgot2:                                ; CODE XREF: find_mini_partition+67↑j
                sub     bx, 4           ; let bx point to the start of the entry
                mov     dh, es:[bx+2]   ; cylinder
                and     dh, 0C0h        ; get higher bits of cyl
                rol     dh, 1
                rol     dh, 1
                mov     dl, es:[bx+3]   ; cyl byte
                mov     [di+7Bh], dx    ; [di+BDS.bdsm_hidden_trks] ; set hidden trks
                push    bx
                mov     cx, es:[bx+8]   ; partition size, lw
                mov     ax, es:[bx+10]  ; partition size, hw
                add     cx, ep_start_sector
                adc     ax, ep_start_sector+2
                cmp     ep_start_sector, 0
                jnz     short fmpgot3
                cmp     ep_start_sector+2, 0
                jnz     short fmpgot3
                mov     ep_start_sector, cx
                mov     ep_start_sector+2, ax

fmpgot3:                                ; CODE XREF: find_mini_partition+9B↑j
                                        ; find_mini_partition+A2↑j
                mov     ep_hidden_secs, cx
                mov     ep_hidden_secs+2, ax ;
                                        ; convert start sector address to CHS
                mov     bx, [di+13h]    ; [di+BDS.secpertrack]
                xor     dx, dx
                div     bx
                xchg    ax, cx
                div     bx
                mov     bx, [di+15h]    ; [di+BDS.heads]
                xchg    ax, cx
                xor     dx, dx
                div     bx
                xchg    ax, cx
                div     bx
                pop     bx
                or      cx, cx
                jnz     short fmpgot_lba_rd
                cmp     ax, 1024        ; cylinder number < 1024, CHS read is proper
                jb      short fmpgot_chs_rd

fmpgot_lba_rd:                          ; CODE XREF: find_mini_partition+CA↑j
                or      byte ptr [di+40h], 4 ; set fLBArw flag ; LBA read/write ok/ready
                mov     dl, rom_minidisk_num
                push    ds
                push    si
                xor     ax, ax          ; push bp
                                        ; mov bp, sp ; (*)
                push    ax              ; 0
                push    ax              ; 0
                push    ep_hidden_secs+2
                push    ep_hidden_secs
                mov     ax, 200h        ; bootbias (buffer offset)
                push    es              ; buffer segment
                push    ax
                mov     ax, 1
                push    ax              ; read count
                mov     ax, 10h         ; DAP size = 16
                push    ax
                mov     ax, ss
                mov     ds, ax
                assume ds:nothing
                mov     si, sp          ; ds:si = Disk Address Packet
                mov     ah, 42h         ; LBA read
                int     13h             ; DISK - IBM/MS Extension
                                        ; EXTENDED READ (DL - drive, DS:SI - disk address packet)
                pushf                   ; BUG! Erdogan Tan - 08/08/2023
                add     sp, 16
                popf                    ; BUG!
                                        ; mov sp, bp ; (*)
                                        ; pop bp
                pop     si
                pop     ds
                assume ds:nothing
                jmp     short fmpgot_cont
; ---------------------------------------------------------------------------

fmpgot_chs_rd:                          ; CODE XREF: find_mini_partition+CF↑j
                mov     cx, es:[bx+2]   ; cylinder,cylinder/sector
                mov     dh, es:[bx+1]   ; head
                mov     dl, ds:rom_minidisk_num
                mov     bx, 200h        ; bootbias
                mov     ax, 201h
                int     13h             ; DISK - READ SECTORS INTO MEMORY
                                        ; AL = number of sectors to read, CH = track, CL = sector
                                        ; DH = head, DL = drive, ES:BX -> buffer to fill
                                        ; Return: CF set on error, AH = status, AL = number of sectors read

fmpgot_cont:                            ; CODE XREF: find_mini_partition+105↑j
                jb      short _fmpnextfound
                mov     bx, 3C2h        ; 1C2h+bootbias
                cmp     word ptr es:[bx+3Ch], 0AA55h ; 03C2h+03Ch = 3FEh
                jnz     short _fmpnextfound ; not a valid boot sector !
                push    es
                call    setmini         ; install a mini disk.
                                        ; bx value saved.
                pop     es
                jb      short fmpnextchain
                call    xinstall_bds    ; -- install the bdsm into table

fmpnextchain:                           ; CODE XREF: find_mini_partition+12D↑j
                jmp     fmpnext
; ---------------------------------------------------------------------------

_fmpnextfound:                          ; CODE XREF: find_mini_partition:fmpnextfound↑j
                                        ; find_mini_partition:fmpgot_cont↑j ...
                retn
find_mini_partition endp


; =============== S U B R O U T I N E =======================================


setmini         proc near               ; CODE XREF: find_mini_partition+129↑p
                push    di
                push    bx
                push    ds
                push    es

setmini_1:                              ; CODE XREF: setmini+2F↓j
                cmp     byte ptr es:[bx], 1 ; FAT12 partition
                jz      short setmini_2
                cmp     byte ptr es:[bx], 4 ; FAT16 (CHS) partition
                jz      short setmini_2
                cmp     byte ptr es:[bx], 6 ; FAT16 Big (CHS) partition
                jz      short setmini_2
                cmp     byte ptr es:[bx], 0Bh ; FAT32 (CHS) partition
                jz      short setmini_2
                cmp     byte ptr es:[bx], 0Ch ; FAT32 (LBA) partition
                jz      short setmini_2
                cmp     byte ptr es:[bx], 0Eh ; FAT16 (LBA) partition
                jz      short setmini_2
                add     bx, 16
                cmp     bx, 402h        ; 202h+bootbias
                jnz     short setmini_1
                stc
                pop     es
                pop     ds
                pop     bx
                pop     di
                retn
; ---------------------------------------------------------------------------

setmini_2:                              ; CODE XREF: setmini+8↑j
                                        ; setmini+E↑j ...
                jmp     set2            ; branch into middle of sethard
setmini         endp


; =============== S U B R O U T I N E =======================================


dmax_check      proc near               ; CODE XREF: BIOSDATA:2206↑p
                                        ; BIOSDATA:222F↑p ...
                cmp     ds:drvmax, 26   ; checks for drvmax < 26
                jb      short dmax_ok   ; returns with carry if okay
                push    es
                mov     ax, 544h        ; SYSINIT segment
                mov     es, ax
                assume es:nothing
                mov     es:toomanydrivesflag, 1
                pop     es
                assume es:nothing

dmax_ok:                                ; CODE XREF: dmax_check+5↑j
                retn
dmax_check      endp


; =============== S U B R O U T I N E =======================================


xinstall_bds    proc near               ; CODE XREF: BIOSDATA:205A↑p
                                        ; BIOSDATA:220B↑p ...
                push    si              ; link next bds (at ds:di) into the chain.
                                        ; assume that the chain is entirely within ds == datagrp.
                                        ; also update drvmax, dskdrv_table, and end_of_bdss.
                push    bx
                mov     si, ds:start_bds ; get first bds

xinstall_bds_1:                         ; CODE XREF: xinstall_bds+D↓j
                cmp     word ptr [si], 0FFFFh ; is this the last one?
                jz      short xinstall_bds_2
                mov     si, [si]        ; [si+BDS.link] ; chain through list
                jmp     short xinstall_bds_1
; ---------------------------------------------------------------------------

xinstall_bds_2:                         ; CODE XREF: xinstall_bds+9↑j
                mov     [si], di        ; [si+BDS.link]
                mov     word ptr [si+2], ds ; [si+BDS.link+2]
                mov     word ptr [di], 0FFFFh ; -1 ; make sure it is a null ptr.
                mov     word ptr [di+2], ds ; might as well plug segment
                lea     bx, [di+6]      ; [di+BDS.BPB]
                mov     si, ds:last_dskdrv_table
                mov     [si], bx
                add     ds:last_dskdrv_table, 2
                inc     ds:drvmax
                add     ds:end_of_bdss, 150 ; BDS.size = 150
                pop     bx
                pop     si
                retn
xinstall_bds    endp


; =============== S U B R O U T I N E =======================================


cmos_clock_read proc near               ; CODE XREF: BIOSDATA:1FC9↑p
                push    ax
                push    cx
                push    dx
                push    bp
                xor     bp, bp

loop_clock:                             ; CODE XREF: cmos_clock_read+23↓j
                xor     cx, cx
                xor     dx, dx
                mov     ah, 2
                int     1Ah             ; CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)
                                        ; Return: CH = hours in BCD
                                        ; CL = minutes in BCD
                                        ; DH = seconds in BCD
                cmp     cx, 0
                jnz     short clock_present
                cmp     dx, 0
                jnz     short clock_present
                cmp     bp, 1           ; read again after a slight delay, in case clock
                jz      short no_readdate ; was at zero setting.
                inc     bp              ; only perform delay once.
                mov     cx, 4000h       ; 16384

delay:                                  ; CODE XREF: cmos_clock_read:delay↓j
                loop    delay
                jmp     short loop_clock
; ---------------------------------------------------------------------------

clock_present:                          ; CODE XREF: cmos_clock_read+11↑j
                                        ; cmos_clock_read+16↑j
                mov     cs:havecmoscloc, 1 ; set the flag for cmos clock
                call    cmosck          ; reset cmos clock rate that may be
                                        ; possibly destroyed by cp dos and
                                        ; post routine did not restore that.
                push    si
                call    read_real_date  ; read real-time clock for date
                cli
                mov     ds:daycnt, si   ; set system date
                sti
                pop     si

no_readdate:                            ; CODE XREF: cmos_clock_read+1B↑j
                pop     bp
                pop     dx
                pop     cx
                pop     ax
                retn
cmos_clock_read endp


; =============== S U B R O U T I N E =======================================


cmosck          proc near               ; CODE XREF: cmos_clock_read+2B↑p
                push    ax              ; check and reset rtc rate bits
                                        ;
                                        ; the following code is written by jack gulley in engineering group.
                                        ; cp dos (CP/DOS, OS/2) is changing cmos clock rate for its own purposes
                                        ; and if the use cold boot the system to use pc dos while running cp dos,
                                        ; the cmos clock rate are still slow which slow down disk operations
                                        ; of pc dos which uses cmos clock. pc dos is put this code in msinit
                                        ; to fix this problem at the request of cp dos.
                cmp     cs:model_byte, 0FCh
                jnz     short cmosck9   ; Exit if not an AT model
                cmp     cs:secondary_model_byte, 6 ; Is it 06 for the industral AT ?
                jz      short cmosck4   ; Go reset CMOS periodic rate if 06
                cmp     cs:secondary_model_byte, 4 ; Is it 00, 01, 02, or 03 ?
                jnb     short cmosck9   ; EXIT if problem fixed by POST
                                        ; Also,Secondary_model_byte = 0
                                        ; when AH=0C0h, int 15h failed.
                                        ; RESET THE CMOS PERIODIC RATE
                                        ; Model=FC submodel=00,01,02,03 or 06

cmosck4:                                ; CODE XREF: cmosck+F↑j
                mov     al, 8Ah         ; cmos_reg_a|nmi
                                        ; NMI disabled on return
                mov     ah, 26h         ; 00100110b
                                        ; Set divider & rate selection
                call    cmos_write
                mov     al, 8Bh         ; cmos_reg_b|nmi
                                        ; NMI disabled on return
                call    cmos_read
                and     al, 7           ; 00000111b
                                        ; clear SET,PIE,AIE,UIE,SQWE
                mov     ah, al
                mov     al, 0Bh         ; cmos_reg_b
                                        ; NMI enabled on return
                call    cmos_write

cmosck9:                                ; CODE XREF: cmosck+7↑j
                                        ; cmosck+17↑j
                pop     ax
                retn
cmosck          endp


; =============== S U B R O U T I N E =======================================


cmos_read       proc near               ; CODE XREF: cmosck+22↑p
                pushf                   ; read location (al) into (al)
                                        ; bit 7 = 0 for nmi enabled and 1 for nmi disabled on exit
                cli
                push    bx
                push    ax
                or      al, 80h
                out     70h, al         ; CMOS Memory/RTC Index Register:
                                        ; RTC Seconds
                nop
                in      al, 71h         ; CMOS Memory/RTC Data Register
                mov     bx, ax
                pop     ax
                and     al, 80h
                or      al, 0Fh
                out     70h, al         ; CMOS Memory/RTC Index Register:
                                        ; RTC Seconds
                nop
                in      al, 71h         ; CMOS Memory/RTC Data Register
                mov     ax, bx
                pop     bx
                push    cs
                call    near ptr cmos_popf
                retn
cmos_read       endp


; =============== S U B R O U T I N E =======================================


cmos_popf       proc far                ; CODE XREF: cmos_read+1B↑p
                                        ; cmos_write+19↓p
                iret                    ; popf for level b- parts
cmos_popf       endp                    ; return far and restore flags


; =============== S U B R O U T I N E =======================================


cmos_write      proc near               ; CODE XREF: cmosck+1D↑p
                                        ; cmosck+2B↑p
                pushf                   ; write (ah) to location (al)
                                        ; bit 7 = 0 for nmi enabled and 1 for nmi disabled on exit
                push    ax
                cli
                push    ax
                or      al, 80h
                out     70h, al         ; CMOS Memory/RTC Index Register:
                                        ; RTC Seconds
                nop
                mov     al, ah
                out     71h, al         ; CMOS Memory/RTC Data Register
                pop     ax
                and     al, 80h
                or      al, 0Fh
                out     70h, al         ; CMOS Memory/RTC Index Register:
                                        ; RTC Seconds
                nop
                in      al, 71h         ; CMOS Memory/RTC Data Register
                pop     ax
                push    cs              ; *place code segment in stack and
                call    near ptr cmos_popf ; *handle popf for b- level 80286
                retn
cmos_write      endp

; ---------------------------------------------------------------------------
ClusterH        dw 0                    ; DATA XREF: getclus+9↓w
                                        ; getclus+11↓w ...

; =============== S U B R O U T I N E =======================================


getclus         proc near               ; CODE XREF: BIOSDATA:242E↑p
                push    cx              ; 1*
                                        ; si:bx = (32 bit) cluster to read
                                        ; cx = sectors per cluster
                                        ; es:di = load location
                push    di              ; 2*
                mov     cs:doscnt, cx
                mov     ax, bx
                mov     cs:ClusterH, si ; high word of cluster number
                sub     ax, 2
                sbb     cs:ClusterH, 0
                xchg    ax, cs:ClusterH
                mul     cx
                xchg    ax, cs:ClusterH
                mul     cx
                add     dx, cs:ClusterH ; convert to logical sector
                                        ; dx:ax = matching logical sector number
                                        ; starting from the data sector
                add     ax, cs:First_Data_Sector
                adc     dx, cs:First_Data_Sector+2 ;
                                        ; dx:ax = first logical sector to read

unpack:                                 ; CODE XREF: getclus+D7↓j
                push    ds              ; 3*
                push    ax              ; 4*
                push    si              ; 5*
                push    bx              ; 6*
                mov     ax, cs:fatloc
                mov     ds, ax
                test    cs:fbigfat, 20h ; fbigbig
                                        ; FAT32 ?
                jz      short not_32bit_cluster ; no

unpack32:                               ; yes
                push    dx              ; 7*
                mov     dx, si
                mov     si, bx
                add     si, si
                adc     dx, dx
                add     si, si
                adc     dx, dx          ; dx:si = 4*(si:bx)
                call    get_fat_sector
                mov     si, [bx+2]      ; byte 16-31 of the FAT32 cluster number
                mov     bx, [bx]        ; byte 0-15 of the FAT32 cluster number
                pop     dx              ; 7*
                jmp     short getcl1
; ---------------------------------------------------------------------------

not_32bit_cluster:                      ; CODE XREF: getclus+44↑j
                mov     si, bx          ; next cluster
                test    cs:fbigfat, 40h ; fbig
                                        ; FAT16 ?
                jnz     short unpack16  ; yes

unpack12:
                shr     si, 1
                add     si, bx          ; 12 bit fat. si=si/2
                                        ; si = clus + clus/2
                                        ; (si = byte offset of the cluster in the FAT)
                push    dx
                xor     dx, dx
                call    get_fat_sector
                pop     dx
                mov     ax, [bx]        ; save cluster number into ax
                jnz     short even_odd  ; if not a splitted fat, check even-odd
                mov     al, [bx]        ; (not needed!) Erdogan Tan - 2023
                mov     byte ptr cs:temp_cluster, al ; splitted fat
                inc     si              ; (next byte)
                push    dx
                xor     dx, dx
                call    get_fat_sector
                pop     dx
                mov     al, ds:0        ; mov ah,[0]
                mov     byte ptr cs:temp_cluster+1, al
                mov     ax, cs:temp_cluster ; mov al,[cs:temp_cluster]

even_odd:                               ; CODE XREF: getclus+75↑j
                pop     bx              ; restore old fat entry value
                push    bx              ; 6*
                shr     bx, 1           ; was it even or odd?
                jnb     short havclus   ; it was even
                shr     ax, 1           ; odd. massage fat value and keep
                                        ; the highest 12 bits.
                shr     ax, 1
                shr     ax, 1
                shr     ax, 1

havclus:                                ; CODE XREF: getclus+94↑j
                mov     bx, ax          ; now bx = new fat entry
                and     bx, 0FFFh       ; keep low 12 bits
                jmp     short unpackx
; ---------------------------------------------------------------------------

unpack16:                               ; CODE XREF: getclus+66↑j
                push    dx
                xor     dx, dx          ; extend to 32 bit offset
                shl     si, 1           ; cluster number * 2
                adc     dx, 0
                call    get_fat_sector
                pop     dx
                mov     bx, [bx]        ; bx = new fat entry

unpackx:                                ; CODE XREF: getclus+A4↑j
                xor     si, si          ; high word of cluster number = 0
                                        ; (FAT12 or FAT16)

getcl1:                                 ; CODE XREF: getclus+5C↑j
                pop     ax              ; 6* - cluster number lw
                pop     cs:ClusterH     ; 5* - cluster number hw
                sub     ax, bx          ; previous - current (or current - new)
                sbb     cs:ClusterH, si
                cmp     cs:ClusterH, -1 ; one apart? (current = previous+1)
                jnz     short not_consenquental
                cmp     ax, -1          ; 0FFFFh ; is [ClusterH]:ax = -1 ?

not_consenquental:                      ; CODE XREF: getclus+C9↑j
                pop     ax              ; 4* - low word of first logical sector
                pop     ds              ; 3*
                jnz     short getcl2
                add     cs:doscnt, cx   ; consequental cluster read, +1 cluster sectors
                                        ; (cx = sectors per cluster)
                jmp     unpack
; ---------------------------------------------------------------------------

getcl2:                                 ; CODE XREF: getclus+D0↑j
                push    bx
                push    si
                push    dx              ; sector to read (high)
                push    ax              ; sector to read (low)
                mov     ax, cs:drvfat   ; get drive and fat spec
                mov     cx, di          ; dma and segment (64K boundary) overrun precaution
                                        ; (sector count will be decreased if it is required)
                not     cx              ; cx = 65535 - cx
                shr     cx, 1           ; cx = cx/2
                xor     cl, cl
                xchg    cl, ch          ; cx = cx/256
                cmp     cx, cs:doscnt   ; if sector read count > cx, decrease it to cx
                jbe     short getcl3
                mov     cx, cs:doscnt

getcl3:                                 ; CODE XREF: getclus+F1↑j
                pop     dx              ; sector to read for diskrd (low)
                pop     cs:start_sec_h  ; sector to read for diskrd (high)
                push    cx
                push    ds
                push    cs
                pop     ds
                assume ds:BIOSDATA
                push    cs              ; simulate far call
                mov     bp, offset DISKRD ; BIOSCODE:0A2Bh ; 364h:0A2Bh
                call    call_bios_code
                pop     ds
                assume ds:nothing
                pop     ax              ; sector count
                pop     si
                pop     bx
                pop     di              ; 2* - load location (es:di)
                xchg    ah, al
                shl     ax, 1           ; ax = ax * 512 ; byte count
                add     di, ax          ; update load location
                pop     cx              ; 1* - restore sectors/cluster
                retn
getclus         endp


; =============== S U B R O U T I N E =======================================


get_fat_sector  proc near               ; CODE XREF: getclus+53↑p
                                        ; getclus+6F↑p ...
                push    ax              ; dx:si = offset value (starting from fat entry 0)
                                        ;         of fat entry to find
                push    cx
                push    di
                push    si
                push    es
                push    ds
                mov     ax, si
                mov     cx, cs:md_sectorsize ; 512
                div     cx
                nop                     ; ax = sector number, dx = offset
                push    es
                push    ds
                push    di
                push    ax
                push    cs
                pop     ds
                assume ds:BIOSDATA
                mov     ax, cs:drvfat   ; get drive # and FAT id
                mov     bp, offset SetDrive ; BIOSCODE:05AEh
                push    cs              ; simulate far call
                call    call_bios_code  ; get bds for drive
                pop     ax              ; (sector number -without reserved and hidden sectors-)
                add     ax, es:[di+9]   ; [es:di+BDS.resectors]
                                        ; add #reserved_sectors
                pop     di
                pop     ds
                assume ds:nothing
                pop     es
                cmp     ax, cs:last_fat_sec_num
                jz      short gfs_split_chk ; don't need to read it again
                mov     cs:last_fat_sec_num, ax ; sector number
                                        ; (in the partition, without hidden sectors)
                push    dx
                mov     cs:start_sec_h, 0 ; prepare to read the fat sector
                                        ; start_sec_h is always 0 for fat sector
                mov     dx, ax
                mov     cx, 1           ; 1 sector read
                mov     ax, cs:drvfat
                push    ds
                pop     es
                xor     di, di          ; es:di -> fatloc segment:0
                push    ds
                push    cs
                pop     ds
                assume ds:BIOSDATA
                push    cs              ; simulate far call
                mov     bp, offset DISKRD ; BIOSCODE:0A2Bh ; 364h:0A2Bh
                call    call_bios_code
                pop     ds
                assume ds:nothing
                pop     dx
                mov     cx, cs:md_sectorsize ; 512

gfs_split_chk:                          ; CODE XREF: get_fat_sector+2E↑j
                dec     cx              ; 511
                cmp     dx, cx          ; if offset points to the last byte of this sector,
                                        ; then splitted entry.
                mov     bx, dx          ; offset value from fatloc segment
                pop     ds
                pop     es
                pop     si
                pop     di
                pop     cx
                pop     ax
                retn
get_fat_sector  endp

BIOSDATA        ends

; ===========================================================================

; Segment type: Regular
BIOSCODE        segment byte public 'BIOSCODE' use16
                assume cs:BIOSCODE
                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
BCode_start     db 30h dup(0)
Bios_Data_Word  dw 70h                  ; DATA XREF: BIOSCODE:_seg_reinit↓r
                                        ; BIOSCODE:0055↓r ...
                                        ; BIOSDATA segment
; ---------------------------------------------------------------------------

_seg_reinit:                            ; DATA XREF: SYSINIT:_seg_reinit_ptr↓o
                mov     es, cs:Bios_Data_Word
                assume es:nothing
                mov     di, offset cdev_2 ; (offset cdev+2)
                mov     cx, 3           ; (it was 4 in MSDOS 6.21 IO.SYS)
                                        ; ('bcode_i2f: dw i2f_handler, IOSYSCODESEG' is removed)

_seg_reinit_1:                          ; CODE XREF: BIOSCODE:0040↓j
                stosw                   ; ax = new code (BIOSCODE) segment value
                inc     di
                inc     di
                loop    _seg_reinit_1
                mov     es:bios_i2f_seg, ax ; (direct jump to i2f_handler
                                        ;  from BIOSDATA:bios_i2f)
                                        ; (instead of 'bcode_i2f: dw i2f_handler, IOSYSCODESEG'
                                        ;  in MSDOS 6.21 IO.SYS)
                retf
; ---------------------------------------------------------------------------

chardev_entry:                          ; DATA XREF: BIOSDATA:cdev↑o
                push    si
                push    ax
                push    cx
                push    dx
                push    di
                push    bp
                push    ds
                push    es
                push    bx
                mov     bp, sp
                mov     si, [bp+18]     ; get return address (dispatch table)
                mov     ds, cs:Bios_Data_Word ; BIOSDATA segment
                assume ds:nothing
                les     si, [si]        ; get the device number if present
                                        ; si points to the device dispatch table
                assume es:nothing
                mov     ax, es
                mov     byte ptr ds:auxnum, al
                mov     ds:printdev, ah
                les     bx, ds:ptrsav   ; get pointer to i/o packet
                mov     al, es:[bx+1]   ; [es:bx+unit] ; al = unit code
                mov     ah, es:[bx+13]  ; [es:bx+media] ; ah = media descrip

loc_35A1:                               ; [es:bx+count] ; cx = count
                mov     cx, es:[bx+18]

loc_35A5:                               ; [es:bx+start] ; dx = start sector
                mov     dx, es:[bx+20]
                cmp     si, offset DSKTBL ; BIOSCODE:579h
                jnz     short no_sector32_mapping
                mov     ds:start_sec_h, 0
                cmp     dx, 0FFFFh
                jnz     short no_sector32_mapping
                mov     dx, es:[bx+28]  ; [es:bx+start_h]
                                        ; 32 bit dsk req
                mov     ds:start_sec_h, dx ; start_sec_h = packet.start_h
                mov     dx, es:[bx+26]  ; [es:bx+start_l]
                                        ; dx = packet.start_l

no_sector32_mapping:                    ; CODE XREF: BIOSCODE:007D↑j
                                        ; BIOSCODE:0088↑j
                xchg    ax, di
                mov     al, es:[bx+2]   ; [es:bx+cmd]
                cmp     al, cs:[si]
                jnb     short command_error
                cbw
                shl     ax, 1
                add     si, ax
                xchg    ax, di
                les     di, es:[bx+14]  ; [es:bx+trans]
                cld
                call    word ptr cs:[si+1]
                jb      short already_got_ah_status
                mov     ah, 1

already_got_ah_status:                  ; CODE XREF: BIOSCODE:00AF↑j
                                        ; BIOSCODE:00CE↓j
                mov     ds, cs:Bios_Data_Word
                lds     bx, ds:ptrsav
                assume ds:nothing
                mov     [bx+3], ax      ; [bx+status]
                                        ; mark operation complete
                pop     bx
                pop     es
                pop     ds
                pop     bp
                pop     di
                pop     dx
                pop     cx
                pop     ax
                pop     si
                inc     sp              ; get rid of fake return address
                inc     sp

bc_retf:                                ; DATA XREF: BIOSDATA:addr_of_bcretf↑o
                retf
; ---------------------------------------------------------------------------

command_error:                          ; CODE XREF: BIOSCODE:009E↑j
                call    bc_cmderr
                jmp     short already_got_ah_status
; ---------------------------------------------------------------------------
_offset_D0h     db 5 dup(0)             ; 5 bytes from 0:C0h will be copied onto here
                                        ; which is the CP/M call 5 entry point

; =============== S U B R O U T I N E =======================================


bc_cmderr       proc near               ; CODE XREF: BIOSCODE:command_error↑p
                                        ; BIOSCODE:prnfuncerr↓j ...
                mov     al, 3           ; unknown command error

bc_err_cnt:                             ; CODE XREF: BIOSCODE:prn_input↓p
                                        ; BIOSCODE:pmessg↓j ...
                les     bx, ds:ptrsav
                mov     ah, 81h         ; mark error return
                sub     es:[bx+18], cx  ; [es:bx+count]
                                        ; # of successful i/o's
                stc                     ; indicate abnormal end
                retn
bc_cmderr       endp

; ---------------------------------------------------------------------------
                db    0
con_table       db 11                   ; DATA XREF: BIOSDATA:0623↑o
                                        ; ((con_table_end - con_table)-1)/2 = 11
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset bc_cmderr
                dw offset con_read
                dw offset con_rdnd
                dw offset bc_exvec
                dw offset con_flush
                dw offset con_writ
                dw offset con_writ
                dw offset bc_exvec
prn_table       db 26                   ; DATA XREF: BIOSDATA:0628↑o
                                        ; BIOSDATA:062F↑o ...
                                        ; ((prn_table_end - prn_table)-1)/2 = 26
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset bc_cmderr
                dw offset prn_input
                dw offset z_bus_exit
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset prn_writ
                dw offset prn_writ
                dw offset prn_stat
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset prn_tilbusy
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset prn_genioctl
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset prn_ioctl_query
aux_table       db 11                   ; DATA XREF: BIOSDATA:0644↑o
                                        ; BIOSDATA:064A↑o ...
                                        ; ((aux_table_end - aux_table)-1)/2 = 11
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset bc_cmderr
                dw offset aux_read
                dw offset aux_rdnd
                dw offset bc_exvec
                dw offset aux_flsh
                dw offset aux_writ
                dw offset aux_writ
                dw offset aux_wrst
tim_table       db 10                   ; DATA XREF: BIOSDATA:065C↑o
                                        ; ((tim_table_end - tim_table)-1)/2 = 10
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset bc_cmderr
                dw offset tim_read
                dw offset z_bus_exit
                dw offset bc_exvec
                dw offset bc_exvec
                dw offset tim_writ
                dw offset tim_writ

; =============== S U B R O U T I N E =======================================


con_read        proc near               ; DATA XREF: BIOSCODE:00ED↑o
                jcxz    short con_exit  ; read cx bytes from keyboard into buffer

con_loop:                               ; CODE XREF: con_read+6↓j
                call    chrin           ; get char in al
                stosb                   ; store char at es:di
                loop    con_loop

con_exit:                               ; CODE XREF: con_read↑j
                clc
                retn
con_read        endp


; =============== S U B R O U T I N E =======================================


chrin           proc near               ; CODE XREF: con_read:con_loop↑p
                                        ; chrin+12↓j
                mov     ah, ds:keyrd_func ; set by msinit. 0 or 10h
                xor     al, al
                xchg    al, ds:altah    ; get character & zero altah
                or      al, al
                jnz     short keyret
                int     16h             ; KEYBOARD -
                or      ax, ax
                jz      short chrin
                cmp     ax, 7200h       ; check for ctrl-prtsc
                jnz     short alt_ext_chk
                mov     al, 10h
                jmp     short keyret
; ---------------------------------------------------------------------------

alt_ext_chk:                            ; CODE XREF: chrin+17↑j
                cmp     ds:keyrd_func, 0
                jz      short not_ext
                cmp     al, 0E0h
                jnz     short not_ext
                or      ah, ah
                jz      short keyret
                xor     al, al
                jmp     short alt_save
; ---------------------------------------------------------------------------

not_ext:                                ; CODE XREF: chrin+22↑j
                                        ; chrin+26↑j
                or      al, al          ; special case?
                jnz     short keyret

alt_save:                               ; CODE XREF: chrin+2E↑j
                mov     ds:altah, ah    ; store special key

keyret:                                 ; CODE XREF: chrin+C↑j
                                        ; chrin+1B↑j ...
                retn
chrin           endp


; =============== S U B R O U T I N E =======================================


con_rdnd        proc near               ; CODE XREF: con_rdnd+37↓j
                                        ; DATA XREF: BIOSCODE:00EF↑o
                mov     al, ds:altah    ; keyboard non destructive read, no wait
                or      al, al
                jnz     short rdexit
                mov     ah, ds:keysts_func
                int     16h             ; KEYBOARD -
                jnz     short gotchr
                cmp     ds:fhavek09, 0
                jz      short z_bus_exit
                les     bx, ds:ptrsav
                test    word ptr es:[bx+3], 400h ; [es:bx+status]
                jz      short z_bus_exit
                mov     ax, 4100h
                xor     bl, bl
                int     15h             ; SYSTEM - WAIT ON EXTERNAL EVENT (CONVERTIBLE)
                                        ; AL = condition type, BH = condition compare or mask value
                                        ; BL = timeout value times 55 milliseconds, 00h means no timeout
                                        ; DX = I/O port address if AL bit 4 set

z_bus_exit:                             ; CODE XREF: con_rdnd+14↑j
                                        ; con_rdnd+20↑j ...
                stc
                mov     ah, 3           ; indicate busy status
                retn
; ---------------------------------------------------------------------------

gotchr:                                 ; CODE XREF: con_rdnd+D↑j
                or      ax, ax
                jnz     short notbrk    ; check for null after break
                mov     ah, ds:keyrd_func ; issue keyboard read function
                int     16h             ; KEYBOARD -
                jmp     short con_rdnd  ; get a real status
; ---------------------------------------------------------------------------

notbrk:                                 ; CODE XREF: con_rdnd+2F↑j
                cmp     ax, 7200h       ; check for ctrl-prtsc
                jnz     short rd_ext_chk
                mov     al, 10h         ; ('P' & 1Fh) ; return control p
                jmp     short rdexit
; ---------------------------------------------------------------------------

rd_ext_chk:                             ; CODE XREF: con_rdnd+3C↑j
                cmp     ds:keyrd_func, 0 ; extended keyboard function?
                jz      short rdexit
                cmp     al, 0E0h        ; extended key value or greek alpha?
                jnz     short rdexit
                cmp     ah, 0           ; scan code exist?
                jz      short rdexit    ; yes. greek alpha char.
                mov     al, 0           ; no. extended key stroke.
                                        ; change it for compatibility

rdexit:                                 ; CODE XREF: con_rdnd+5↑j
                                        ; con_rdnd+40↑j ...
                les     bx, ds:ptrsav
                mov     es:[bx+13], al  ; [es:bx+media]
                                        ; return keyboard character here

bc_exvec:                               ; CODE XREF: con_writ↓j
                                        ; DATA XREF: BIOSCODE:00E5↑o ...
                clc                     ; indicate normal termination
                retn
con_rdnd        endp


; =============== S U B R O U T I N E =======================================


con_writ        proc near               ; DATA XREF: BIOSCODE:00F5↑o
                                        ; BIOSCODE:00F7↑o
                jcxz    short bc_exvec  ; console write routine

con_lp:                                 ; CODE XREF: con_writ+8↓j
                mov     al, es:[di]
                inc     di
                int     29h             ; DOS 2+ internal - FAST PUTCHAR
                                        ; AL = character to display
                loop    con_lp
con_writ        endp

; START OF FUNCTION CHUNK FOR con_flush

cc_ret:                                 ; CODE XREF: con_flush+9↓j
                clc
                retn
; END OF FUNCTION CHUNK FOR con_flush

; =============== S U B R O U T I N E =======================================


con_flush       proc near               ; CODE XREF: swpdsk+37↓p
                                        ; DATA XREF: BIOSCODE:00F3↑o

; FUNCTION CHUNK AT 0207 SIZE 00000002 BYTES

                mov     ds:altah, 0     ; flush out keyboard queue
                                        ; clear out holding buffer

flloop:                                 ; CODE XREF: con_flush+F↓j
                mov     ah, 1           ; while (charavail()) charread();
                int     16h             ; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
                                        ; Return: ZF clear if character in buffer
                                        ; AH = scan code, AL = character
                                        ; ZF set if no character in buffer
                jz      short cc_ret
                xor     ah, ah
                int     16h             ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
                                        ; Return: AH = scan code, AL = character
                jmp     short flloop
con_flush       endp

; ---------------------------------------------------------------------------

prn_input:                              ; DATA XREF: BIOSCODE:0104↑o
                call    bc_err_cnt      ; reset count to zero
                                        ; (sub reqpkt.count,cx)
                clc                     ; but return with carry   reset for no error
                retn
; ---------------------------------------------------------------------------

prn_writ:                               ; DATA XREF: BIOSCODE:010C↑o
                                        ; BIOSCODE:010E↑o
                jcxz    short prn_done  ; write cx bytes from es:di to printer device

prn_loop:                               ; CODE XREF: BIOSCODE:024D↓j
                mov     bx, 2           ; retry count

prn_out:                                ; CODE XREF: BIOSCODE:0247↓j
                call    prnstat         ; get status
                jnz     short TestPrnError
                mov     al, es:[di]     ; get character to print
                xor     ah, ah
                call    prnop           ; print to printer
                jz      short prn_con   ; no error - continue
                cmp     ah, 0FFh        ; MODE_CTRLBRK
                jnz     short _prnwf
                mov     al, 0Ch         ; error_I24_gen_failure
                mov     ds:altah, 0
                jmp     short pmessg
; ---------------------------------------------------------------------------

_prnwf:                                 ; CODE XREF: BIOSCODE:0236↑j
                test    ah, 1           ; timeoutstatus
                jz      short prn_con

TestPrnError:                           ; CODE XREF: BIOSCODE:0227↑j
                dec     bx              ; retry until count is exhausted
                jnz     short prn_out

pmessg:                                 ; CODE XREF: BIOSCODE:023F↑j
                                        ; BIOSCODE:0254↓j
                jmp     bc_err_cnt
; ---------------------------------------------------------------------------

prn_con:                                ; CODE XREF: BIOSCODE:0231↑j
                                        ; BIOSCODE:0244↑j
                inc     di              ; point to next char and continue
                loop    prn_loop

prn_done:                               ; CODE XREF: BIOSCODE:prn_writ↑j
                                        ; BIOSCODE:0259↓j
                clc
                retn
; ---------------------------------------------------------------------------

prn_stat:                               ; DATA XREF: BIOSCODE:0110↑o
                call    prnstat         ; device in dx
                jnz     short pmessg
                test    ah, 80h         ; notbusystatus
                jnz     short prn_done
                jmp     z_bus_exit

; =============== S U B R O U T I N E =======================================


prnstat         proc near               ; CODE XREF: BIOSCODE:prn_out↑p
                                        ; BIOSCODE:prn_stat↑p ...
                mov     ah, 2           ; PRINTER - GET STATUS
prnstat         endp                    ; set command for get status
                                        ; DX = printer port (0-3)
                                        ; Return: AH = status

; =============== S U B R O U T I N E =======================================


prnop           proc near               ; CODE XREF: BIOSCODE:022E↑p
                                        ; BIOSCODE:02B9↓p
                mov     dx, ds:auxnum   ; get printer number
                push    ds
                push    di
                xor     di, di
                mov     ds, di
                assume ds:nothing
                pop     di
                pushf                   ; simulate int 17h
                cli
                call    dword ptr ds:5Ch ; 0:5Ch = INT 17h vector
                pop     ds
                assume ds:nothing
                push    ax
                and     ah, 30h
                cmp     ah, 30h         ; noprinter error
                pop     ax
                jnz     short NextTest
                and     ah, 0DFh        ; ~nopaperstatus
                or      ah, 8           ; ioerrstatus

NextTest:                               ; CODE XREF: prnop+1A↑j
                test    ah, 28h         ; (ioerrstatus+nopaperstatus)
                                        ; i/o error?
                jz      short checknotready ; no, try not ready
                mov     al, 9           ; error_I24_out_of_paper
                                        ;  first, assume out of paper
                test    ah, 20h         ; out of paper set?
                jnz     short ret1      ; yes, error is set
                inc     al              ; return al=10 (i/o error)

ret1:                                   ; CODE XREF: prnop+2C↑j
                retn
; ---------------------------------------------------------------------------

checknotready:                          ; CODE XREF: prnop+25↑j
                mov     al, 2           ; assume not-ready
                test    ah, 1
                retn
prnop           endp

; ---------------------------------------------------------------------------

prn_tilbusy:                            ; DATA XREF: BIOSCODE:011C↑o
                mov     si, di

prn_tilbloop:                           ; CODE XREF: BIOSCODE:02BE↓j
                push    cx
                push    bx
                xor     bh, bh
                mov     bl, ds:printdev
                shl     bx, 1
                mov     cx, ds:wait_count[bx] ; wait count times to come ready
                pop     bx

prn_getstat:                            ; CODE XREF: BIOSCODE:02B0↓j
                call    prnstat         ; get status
                jnz     short prn_bperr ; error
                test    ah, 80h         ; ready yet?
                loope   prn_getstat     ; no, go for more
                pop     cx              ; get original count
                jz      short prn_berr  ; still not ready => done
                lods    byte ptr es:[si]
                xor     ah, ah
                call    prnop
                jnz     short prn_berr
                loop    prn_tilbloop
                clc                     ; normal no-error return
                retn
; ---------------------------------------------------------------------------

prn_bperr:                              ; CODE XREF: BIOSCODE:02AB↑j
                pop     cx

prn_berr:                               ; CODE XREF: BIOSCODE:02B3↑j
                                        ; BIOSCODE:02BC↑j
                jmp     bc_err_cnt
; ---------------------------------------------------------------------------

prn_genioctl:                           ; DATA XREF: BIOSCODE:0122↑o
                les     di, ds:ptrsav
                cmp     byte ptr es:[di+13], 5 ; [es:di+IOCTL_REQ.MAJORFUNCTION]
                                        ; ioc_pc
                jnz     short prnfuncerr
                mov     al, es:[di+14]  ; [es:di+IOCTL_REQ.MINORFUNCTION]
                les     di, es:[di+19]  ; [es:di+IOCTL_REQ.GENERICIOCTL_PACKET]
                xor     bh, bh
                mov     bl, ds:printdev
                shl     bx, 1
                mov     cx, ds:wait_count[bx] ; pull out retry count for device
                cmp     al, 65h         ; get_retry_count
                jz      short prngetcount
                cmp     al, 45h         ; set_retry_count
                jnz     short prnfuncerr
                mov     cx, es:[di]

prngetcount:                            ; CODE XREF: BIOSCODE:02E7↑j
                mov     ds:wait_count[bx], cx
                mov     es:[di], cx     ; [es:di+A_RETRYCOUNT.RC_COUNT]
                                        ; return current retry count

IOCtlSupported:                         ; CODE XREF: BIOSCODE:030A↓j
                                        ; BIOSCODE:030E↓j
                clc
                retn
; ---------------------------------------------------------------------------

prn_ioctl_query:                        ; DATA XREF: BIOSCODE:012E↑o
                les     di, ds:ptrsav
                cmp     byte ptr es:[di+13], 5 ; [es:di+IOCTL_REQ.MAJORFUNCTION]
                                        ; ioc_pc
                jnz     short prn_query_err
                mov     al, es:[di+14]  ; [es:di+IOCTL_REQ.MINORFUNCTION]
                cmp     al, 65h         ; GET_RETRY_COUNT
                jz      short IOCtlSupported
                cmp     al, 45h         ; SET_RETRY_COUNT
                jz      short IOCtlSupported

prn_query_err:                          ; CODE XREF: BIOSCODE:0302↑j
                stc

prnfuncerr:                             ; CODE XREF: BIOSCODE:02CF↑j
                                        ; BIOSCODE:02EB↑j
                jmp     bc_cmderr
; ---------------------------------------------------------------------------

aux_read:                               ; DATA XREF: BIOSCODE:0139↑o
                jcxz    short exvec2
                call    getbx           ; put address of auxbuf   in bx
                xor     al, al
                xchg    al, [bx]
                or      al, al
                jnz     short aux2

aux1:                                   ; CODE XREF: BIOSCODE:0325↓j
                call    auxin           ; get character from port
                                        ; won't return if error

aux2:                                   ; CODE XREF: BIOSCODE:031F↑j
                stosb
                loop    aux1            ; if more characters, go around again

exvec2:                                 ; CODE XREF: BIOSCODE:aux_read↑j
                                        ; BIOSCODE:aux_writ↓j
                clc                     ; all done, successful exit

auxin_ok:                               ; CODE XREF: BIOSCODE:0331↓j
                retn
; ---------------------------------------------------------------------------

auxin:                                  ; CODE XREF: BIOSCODE:aux1↑p
                                        ; BIOSCODE:034D↓p
                mov     ah, 2
                call    auxop
                test    ah, 0Eh         ; flag_frame|flag_parity|flag_overrun
                jz      short auxin_ok

arbad:
                pop     ax
                mov     al, 0B0h        ; flag_rec_sig|flag_dsr|flag_cts
                jmp     short bc_err_cnt_j
; ---------------------------------------------------------------------------

aux_rdnd:                               ; DATA XREF: BIOSCODE:013B↑o
                call    getbx           ; non-destructive aux port read
                mov     al, [bx]
                or      al, al
                jnz     short auxrdx    ; if al is non-zero (char in buffer)
                                        ; then return character
                call    auxstat         ; if not, get status of   aux device
                test    ah, 1           ; flag_data_ready - test data ready
                jz      short auxbus    ; then device is busy (not ready)
                test    al, 20h         ; flag_dsr - test data set ready
                jz      short auxbus    ; then device is busy (not ready)
                call    auxin           ; else aux is ready, get character
                mov     [bx], al

auxrdx:                                 ; CODE XREF: BIOSCODE:033F↑j
                jmp     rdexit          ; return busy status
; ---------------------------------------------------------------------------

auxbus:                                 ; CODE XREF: BIOSCODE:0347↑j
                                        ; BIOSCODE:034B↑j ...
                jmp     z_bus_exit
; ---------------------------------------------------------------------------

aux_wrst:                               ; DATA XREF: BIOSCODE:0145↑o
                call    auxstat         ; return aux port write status
                test    al, 20h         ; test data set ready
                jz      short auxbus    ; then device is busy (not ready)
                test    ah, 20h         ; flag_tranhol_emp - test transmit hold reg
                jz      short auxbus    ; then device is busy (not ready)

loc_3894:
                clc
                retn

; =============== S U B R O U T I N E =======================================


auxstat         proc near               ; CODE XREF: BIOSCODE:0341↑p
                                        ; BIOSCODE:aux_wrst↑p
                mov     ah, 3           ; auxfunc_status
auxstat         endp


; =============== S U B R O U T I N E =======================================


auxop           proc near               ; CODE XREF: BIOSCODE:032B↑p
                                        ; BIOSCODE:038B↓p
                mov     dx, ds:auxnum   ; ah=function code
                                        ; 0=init, 1=send, 2=receive, 3=status
                                        ; get port number
                push    ds
                push    di
                xor     di, di
                mov     ds, di
                assume ds:nothing
                pop     di
                pushf                   ; simulate INT 14h
                cli
                call    dword ptr ds:50h ; INT 14h vector (14h*4 = 50h)
                                        ; SERIAL I/O - GET USART STATUS
                                        ; DX = port number (0-3)
                                        ; Return: AX = port status code
                pop     ds
                assume ds:nothing
                retn
auxop           endp

; ---------------------------------------------------------------------------

aux_flsh:                               ; DATA XREF: BIOSCODE:013F↑o
                call    getbx           ; flush aux input buffer
                                        ; get bx to point to auxbuf
                                        ; zero out buffer
                                        ; all done, successful return
                mov     byte ptr [bx], 0
                clc
                retn
; ---------------------------------------------------------------------------

aux_writ:                               ; DATA XREF: BIOSCODE:0141↑o
                                        ; BIOSCODE:0143↑o
                jcxz    short exvec2    ; write to aux device (if cx > 0)

aux_loop:                               ; CODE XREF: BIOSCODE:awok↓j
                mov     al, es:[di]     ; get character to be written
                inc     di              ; move di pointer to next character
                mov     ah, 1           ; auxfunc_send - indicates a write
                call    auxop           ; send character over aux port
                test    ah, 80h         ; check for error
                jz      short awok      ; then no error
                mov     al, 10          ; else indicate write fault

bc_err_cnt_j:                           ; CODE XREF: BIOSCODE:0336↑j
                jmp     bc_err_cnt      ; call error routines
; ---------------------------------------------------------------------------

awok:                                   ; CODE XREF: BIOSCODE:0391↑j
                loop    aux_loop        ; move di pointer to next character
                clc
                retn

; =============== S U B R O U T I N E =======================================


getbx           proc near               ; CODE XREF: BIOSCODE:0316↑p
                                        ; BIOSCODE:aux_rdnd↑p ...
                mov     bx, ds:auxnum   ; return bx -> single byte input buffer
                                        ; for selected aux port ([auxnum])
                add     bx, offset auxbuf
                retn
getbx           endp

; ---------------------------------------------------------------------------

time_to_ticks:                          ; DATA XREF: BIOSDATA:ttticks↑o
                mov     al, 60          ; convert time to ticks
                                        ; input : time in cx and dx
                                        ; output: ticks returned in cx:dx
                                        ;
                                        ; the clock ticks at the rate of:
                                        ; 1193180/65536 ticks/second
                                        ; (about 18.2 ticks per second)
                mul     ch              ; hours to minutes ///
                                        ; first convert from hour,min,sec,hund. to
                                        ; total number of 100th of seconds
                mov     ch, 0
                add     ax, cx          ; total minutes
                mov     cx, 6000        ; 60*100
                mov     bx, dx
                mul     cx              ; convert to 1/100 sec
                mov     cx, ax
                mov     al, 100
                mul     bh              ; convert seconds to 1/100 sec
                add     cx, ax          ; combine seconds with hours and min
                adc     dx, 0
                mov     bh, 0
                add     cx, bx          ; combine 1/100 sec
                adc     dx, 0           ; dx:cx is time in 1/100 sec
                xchg    ax, dx
                xchg    ax, cx          ; now time is in cx:ax
                mov     bx, 59659
                mul     bx              ; multiply low half
                xchg    dx, cx
                xchg    ax, dx          ; cx->ax, ax->dx, dx->cx
                mul     bx              ; multiply high half
                add     ax, cx          ; combine overlapping products
                adc     dx, 0
                xchg    ax, dx          ; ax:dx=time*59659
                mov     bx, 5
                div     bl              ; divide high half by 5
                mov     cl, al
                mov     ch, 0
                mov     al, ah          ; remainder of divide-by-5
                cbw
                xchg    ax, dx          ; use it to extend low half
                div     bx              ; divide low half by 5
                mov     dx, ax          ; cx:dx is now number of ticks in time
                retf
; ---------------------------------------------------------------------------

tim_writ:                               ; DATA XREF: BIOSCODE:0158↑o
                                        ; BIOSCODE:015A↑o
                mov     ax, es:[di]     ; sets the current time
                push    ax              ; daycnt. we need to set this at the very
                                        ; end to avoid tick windows
                cmp     ds:havecmoscloc, 0
                jz      short no_cmos_1
                mov     al, es:[di+3]   ; get binary hours
                                        ; convert to bcd
                call    bintobcd
                mov     ch, al          ; ch = bcd hours
                mov     al, es:[di+2]   ; get binary minutes
                call    bintobcd
                mov     cl, al          ; cl = bcd minutes
                mov     al, es:[di+5]   ; get binary seconds
                call    bintobcd
                mov     dh, al          ; dh = bcd seconds
                mov     dl, 0           ; dl = 0 (st) or 1 (dst)
                cli
                mov     ah, 3
                int     1Ah             ; CLOCK - SET REAL TIME CLOCK (AT,XT286,CONV,PS)
                                        ; CH = hours in BCD, CL = minutes in BCD
                                        ;  DH = seconds in BCD,DL = 01h if daylight savings, 00h if standard time
                                        ; Return: CMOS clock set
                sti

no_cmos_1:                              ; CODE XREF: BIOSCODE:03F3↑j
                push    ds
                lds     cx, es:[di+2]
                mov     dx, ds
                pop     ds
                call    dword ptr ds:ttticks ; convert time to ticks
                                        ; cx:dx now has time in ticks
                cli                     ; turn off timer
                mov     ah, 1
                int     1Ah             ; CLOCK - SET TIME OF DAY
                                        ; CX:DX = clock count
                                        ; Return: time of day set
                pop     ds:daycnt
                sti
                cmp     ds:havecmoscloc, 0
                jz      short no_cmos_2
                call    daycnttoday
                cli
                mov     ah, 5
                int     1Ah             ; CLOCK - SET DATE IN REAL TIME CLOCK (AT,XT286,CONV,PS)
                                        ; DL = day in BCD, DH = month in BCD, CL = year in BCD
                                        ; CH = century (19h or 20h)
                                        ; Return: CMOS clock set
                sti

no_cmos_2:                              ; CODE XREF: BIOSCODE:0433↑j
                clc
                retn

; =============== S U B R O U T I N E =======================================


daycnttoday     proc near               ; CODE XREF: BIOSCODE:0435↑p
                push    ds:daycnt       ; entry: [daycnt] = number of days since 1-1-80
                                        ; return: ch - century in bcd
                                        ;         cl - year in bcd
                                        ;         dh - month in bcd
                                        ;         dl - day in bcd
                cmp     ds:daycnt, 7305 ; (365*20+(20/4))
                                        ; # days from 1-1-1980 to 1-1-2000
                jnb     short century20
                mov     word ptr ds:base_century, 5013h ; base century = 19
                                        ; base year = 80
                jmp     short years
; ---------------------------------------------------------------------------

century20:                              ; CODE XREF: daycnttoday+A↑j
                mov     word ptr ds:base_century, 20 ; base century = 20
                                        ; base year = 0
                sub     ds:daycnt, 7305 ; 365*20+(20/4))
                                        ; adjust daycnt

years:                                  ; CODE XREF: daycnttoday+12↑j
                xor     dx, dx
                mov     ax, ds:daycnt
                mov     bx, 1461        ; 366+365*3)
                                        ; # of days in a Leap year block
                div     bx              ; ax = # of leap block, dx = daycnt
                mov     ds:daycnt, dx   ; save daycnt left
                mov     bl, 4
                mul     bl
                add     ds:base_year, al ; ax = # of years. Less than 100
                inc     ds:daycnt
                cmp     ds:daycnt, 366  ; daycnt = remainder of leap year block
                                        ; within 366+355+355+355 days
                jbe     short leapyear
                inc     ds:base_year    ; if daycnt <= 366, then leap year
                                        ; else daycnt -= 366, base_year++
                sub     ds:daycnt, 366
                mov     cx, 3           ; And next three years are normal

regularyear:                            ; CODE XREF: daycnttoday+61↓j
                cmp     ds:daycnt, 365  ; for(i=1; i>3 or daycnt <=365; i++)
                jbe     short yeardone  ; {if (daycnt > 365)
                inc     ds:base_year    ; { daycnt -= 365

loc_39CB:                               ; }
                sub     ds:daycnt, 365
                loop    regularyear     ; }
                                        ; should never fall through loop

leapyear:                               ; CODE XREF: daycnttoday+40↑j
                mov     ds:february, 29 ; leap year.
                                        ; change month table.

yeardone:                               ; CODE XREF: daycnttoday+55↑j
                xor     bx, bx
                xor     dx, dx
                mov     ax, ds:daycnt
                mov     si, offset month_table
                mov     cx, 12

months:                                 ; CODE XREF: daycnttoday+80↓j
                inc     bl
                mov     dl, [si]
                cmp     ax, dx          ; cmp daycnt for each month till fit
                                        ; dh=0
                jbe     short month_done
                inc     si              ; next month
                sub     ax, dx          ; adjust daycnt
                loop    months          ;
                                        ; should never fall through loop

month_done:                             ; CODE XREF: daycnttoday+7B↑j
                mov     ds:february, 28 ; restore month table value
                mov     dl, bl
                mov     dh, ds:base_year
                mov     cl, ds:base_century ; al=day,dl=month,dh=year,cl=cntry
                call    bintobcd        ; convert "day" to bcd
                                        ; dl = bcd day, al = month
                xchg    dl, al
                call    bintobcd        ; dh = bcd month, al = year
                xchg    dh, al
                call    bintobcd        ; cl = bcd year, al = century
                xchg    cl, al
                call    bintobcd        ; ch = bcd century
                mov     ch, al
                pop     ds:daycnt       ; restore original value
                retn
daycnttoday     endp


; =============== S U B R O U T I N E =======================================


bintobcd        proc near               ; CODE XREF: BIOSCODE:03F9↑p
                                        ; BIOSCODE:0402↑p ...
                aam                     ; convert a binary input in al
                                        ; (less than 63h or 99 decimal)
                                        ; into a bcd value in al. ah destroyed
                                        ;
                                        ; AH = AL/10, AL = AL MOD 10
                aad     10h             ; db 0D5h,10h
                                        ; AL = (AH*10H)+AL, AH = 0
                retn
bintobcd        endp

; ---------------------------------------------------------------------------

tim_read:                               ; DATA XREF: BIOSCODE:0150↑o
                call    GetTickCnt      ; gettime reads date and time
                                        ;
                                        ; 65,536 seconds = 1,193,180 ticks
                                        ;
                                        ; time in 100th of seconds
                                        ;    = ticks from clock  * 65,536 * 100 / 1,193,180
                                        ;    = ticks from clock * 5 * 65,536 / 59,659
                mov     si, ds:daycnt
                mov     ax, cx
                mov     bx, dx          ; start with ticks in cx:dx
                                        ; multiply by 5
                shl     dx, 1
                rcl     cx, 1
                shl     dx, 1
                rcl     cx, 1
                add     dx, bx
                adc     ax, cx
                xchg    ax, dx
                mov     cx, 59659       ; multiply by 65536 and divide by 59659
                div     cx              ; dx has remainder
                                        ; ax has high word of final quotient
                xchg    ax, bx          ; put high word in safe place
                xor     ax, ax          ; multiply by 65536
                div     cx              ; bx:ax has time in 100th of seconds
                mov     dx, bx
                mov     cx, 200         ; division by 200 is necessary
                                        ; to ensure no overflow--max result
                                        ; is number of seconds in a day/2 = 43200.
                div     cx
                cmp     dl, 100         ; remainder over 100?
                jb      short noadj
                sub     dl, 100         ; keep 1/100's less than 100

noadj:                                  ; CODE XREF: BIOSCODE:051B↑j
                cmc                     ; if we subtracted 100, carry is now set
                mov     bl, dl          ; save 1/100's
                rcl     ax, 1           ; multiply by two
                mov     dl, 0
                rcl     dx, 1
                mov     cl, 60          ; divide out seconds
                div     cx
                mov     bh, dl          ; save the seconds
                div     cl              ; break into hours and minutes
                xchg    al, ah          ; time is now in ax:bx
                                        ; (hours, minutes, seconds, 1/100 sec)
                xchg    ax, si          ; daycnt
                stosw
                xchg    ax, si          ; al = hours, ah = minutes
                stosw
                mov     ax, bx
                stosw
                clc                     ; [es:di] = count of days since 1-1-80
                                        ;    [es:di+2] = hours
                                        ;    [es:di+3] = minutes
                                        ;    [es:di+4] = seconds
                                        ;    [es:di+5] = hundredths of seconds
                retn

; =============== S U B R O U T I N E =======================================


GetTickCnt      proc near               ; CODE XREF: BIOSCODE:tim_read↑p
                                        ; Check_Time_Of_Access+3↓p ...
                xor     ah, ah          ; Returns the tick count in cx:dx
                                        ; Takes care of DayCnt in case of rollover
                                        ; if ( rollover ) {
                                        ;     if ( t_switch )
                                        ;            daycnt++ ;
                                        ;     else
                                        ;            daycnt += rollover ;
                                        ;     }
                int     1Ah             ; CLOCK - GET TIME OF DAY
                                        ; Return: CX:DX = clock count
                                        ; AL = 00h if clock was read or written (via AH=0,1) since the previous
                                        ; midnight
                                        ; Otherwise, AL > 0
                xor     ah, ah
                cmp     ds:t_switch, ah ; use old method ? (>0 is yes)
                jnz     short inc_case  ; old method assumes that Int 1Ah returns rollover flag
                add     ds:daycnt, ax   ; new method assumes that Int 1Ah returns roll over count
                                        ; and not flag
                retn
; ---------------------------------------------------------------------------

inc_case:                               ; CODE XREF: GetTickCnt+A↑j
                or      al, al
                jz      short no_rollover
                inc     ds:daycnt

no_rollover:                            ; CODE XREF: GetTickCnt+13↑j
                retn
GetTickCnt      endp

; ---------------------------------------------------------------------------
fat_12_id       db 'FAT12   '           ; DATA XREF: clear_ids+2C↓o
fat_16_id       db 'FAT16   '           ; DATA XREF: clear_ids+27↓o
fat_32_id       db 'FAT32   '           ; DATA XREF: clear_ids+1D↓o
nul_vid         db 'NO NAME    '        ; DATA XREF: clear_ids+F↓o
                                        ; read_volume_id+B↓o
DSKTBL          db 26                   ; DATA XREF: BIOSDATA:0661↑o
                                        ; BIOSCODE:0079↑o
                dw offset dsk_init
                dw offset media_chk
                dw offset get_bpb
                dw offset ioctl_input   ; PCDOS 7
                dw offset dsk_read
                dw offset x_bus_exit
                dw offset ret_carry_clear
                dw offset ret_carry_clear
                dw offset dsk_writ
                dw offset dsk_writv
                dw offset ret_carry_clear
                dw offset ret_carry_clear
                dw offset ioctl_output  ; PCDOS 7
                dw offset dsk_open
                dw offset dsk_close
                dw offset dsk_rem
                dw offset ret_carry_clear
                dw offset ret_carry_clear
                dw offset ret_carry_clear
                dw offset Do_Generic_IOCtl
                dw offset ret_carry_clear
                dw offset ret_carry_clear
                dw offset ret_carry_clear
                dw offset ioctl_getown
                dw offset ioctl_setown
                dw offset ioctl_support_query

; =============== S U B R O U T I N E =======================================


SetDrive        proc near               ; CODE XREF: BIOSCODE:media_chk↓p
                                        ; get_bpb+3↓p ...
                les     di, dword ptr ds:start_bds ; Point es:di to first bds

X_Scan_Loop:                            ; CODE XREF: SetDrive+10↓j
                cmp     es:[di+5], al   ; logical drive number (BDS.drivelet)
                jz      short X_SetDrv
                les     di, es:[di]     ; [es:di+BDS.link] ; Go to next bds
                cmp     di, 0FFFFh
                jnz     short X_Scan_Loop
                stc

X_SetDrv:                               ; CODE XREF: SetDrive+8↑j
                retn
SetDrive        endp

; ---------------------------------------------------------------------------

media_chk:                              ; DATA XREF: BIOSCODE:057C↑o
                call    SetDrive
                mov     si, 1
                test    byte ptr es:[di+40h], 1 ; [es:di+BDS.flags+1], fchanged_by_format
                jz      short WeAreNotFakingIt
                and     byte ptr es:[di+40h], 0FEh ; [es:di+BDS.flags+1],
                                        ; ~fchanged_by_format ; reset flag
                mov     ds:tim_drv, 0FFh ; -1
                                        ; Ensure that we ask the rom if media has changed
                test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
                jz      short wehaveafloppy
                neg     si
                jmp     short Media_Done
; ---------------------------------------------------------------------------

WeAreNotFakingIt:                       ; CODE XREF: BIOSCODE:05CD↑j
                test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
                jnz     short Media_Done

wehaveafloppy:                          ; CODE XREF: BIOSCODE:05DE↑j
                dec     si              ; 0 ; Presume "I don't know"
                cmp     ds:fhave96, 0   ; Do we have changeline support?
                jz      short mChk_NoChangeLine ; Brif not
                call    mediacheck      ; Call into removable routine
                jb      short err_exitj
                call    haschange
                jnz     short Media_Done

mChk_NoChangeLine:                      ; CODE XREF: BIOSCODE:05F1↑j
                mov     si, 1           ; Presume no change
                mov     al, ds:tim_drv  ; Last drive accessed
                cmp     al, es:[di+4]   ; [es:di+BDS.drivenum]
                                        ; Is drive of last access the same?
                jnz     short Media_Unk ; No, then "i don't know"
                call    Check_Time_Of_Access
                jmp     short Media_Done
; ---------------------------------------------------------------------------

Media_Unk:                              ; CODE XREF: BIOSCODE:0607↑j
                dec     si              ; 0 ; Return "I don't know"

Media_Done:                             ; CODE XREF: BIOSCODE:05E2↑j
                                        ; BIOSCODE:05E9↑j ...
                push    es
                les     bx, ds:ptrsav
                mov     es:[bx+14], si  ; [es:bx+trans]
                pop     es
                or      si, si
                jns     short ret_carry_clear ; volidok
                cmp     ds:fhave96, 0
                jz      short mChk1_NoChangeLine
                call    media_set_vid

mChk1_NoChangeLine:                     ; CODE XREF: BIOSCODE:0622↑j
                mov     ds:tim_drv, 0FFh ; -1
                                        ; Make sure we ask rom for media check

ret_carry_clear:                        ; CODE XREF: BIOSCODE:061B↑j
                                        ; DATA XREF: BIOSCODE:0586↑o ...
                clc                     ; volidok
                retn
; ---------------------------------------------------------------------------

err_exitj:                              ; CODE XREF: BIOSCODE:05F6↑j
                                        ; BIOSCODE:0663↓j ...
                call    maperror        ; guaranteed to set carry
; START OF FUNCTION CHUNK FOR get_bpb

ret81:                                  ; CODE XREF: get_bpb+18↓j
                mov     ah, 81h         ; return error status
                retn                    ; return with carry set
; END OF FUNCTION CHUNK FOR get_bpb

; =============== S U B R O U T I N E =======================================


Check_Time_Of_Access proc near          ; CODE XREF: BIOSCODE:0609↑p
                                        ; mediacheck+30↓p
                mov     si, 1           ; presume no change
                call    GetTickCnt      ; cx:dx is the elapsed time
                mov     ax, es:[di+79h] ; [es:di+BDS.tim_lo]
                                        ; get stored time
                sub     dx, ax
                mov     ax, es:[di+7Bh] ; [es:di+BDS.tim_hi]
                sbb     cx, ax
                mov     al, ds:accesscount
                jnz     short timecheck_unk ; cx<>0 => >1 hour
                or      dx, dx          ; time must pass
                jnz     short timepassed ; yes, examine max value
                inc     al
                cmp     al, 5
                jb      short timecheck_ret ; if count is less than threshold, ok
                dec     al
                jmp     short timecheck_unk
; ---------------------------------------------------------------------------

timepassed:                             ; CODE XREF: Check_Time_Of_Access+19↑j
                cmp     dx, 36          ; 18*2 ; 18.2 tics per second.
                                        ; min elapsed time? (2 seconds)
                jbe     short timecheck_ret

timecheck_unk:                          ; CODE XREF: Check_Time_Of_Access+15↑j
                                        ; Check_Time_Of_Access+23↑j
                dec     si              ; presume i don't know

timecheck_ret:                          ; CODE XREF: Check_Time_Of_Access+1F↑j
                                        ; Check_Time_Of_Access+28↑j
                mov     ds:accesscount, al
                retn
Check_Time_Of_Access endp

; ---------------------------------------------------------------------------
                jmp     short err_exitj

; =============== S U B R O U T I N E =======================================


get_bpb         proc near               ; DATA XREF: BIOSCODE:057E↑o

; FUNCTION CHUNK AT 0631 SIZE 00000003 BYTES

                mov     ah, es:[di]     ; Build a valid bpb for the disk in the drive.
                                        ; get fat id byte read by dos
                call    SetDrive        ; get the correct bds for the drive
                test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
                jnz     short already_gotbpb ; no need to build for fixed disks
                call    clear_ids
                mov     ds:set_id_flag, 1 ; indicate to set system id in bds
                call    GetBp           ; build a bpb if necessary
                jb      short ret81
                cmp     ds:set_id_flag, 2 ; already, volume_label set from boot
                mov     ds:set_id_flag, 0 ; record to bds table?
                jz      short already_gotbpb ; do not set it again from root dir
                                        ; otherwise, conventional boot record
                cmp     ds:fhave96, 0   ; do we have changeline support?
                jz      short already_gotbpb ; brif not
                call    set_volume_id

already_gotbpb:                         ; CODE XREF: get_bpb+B↑j
                                        ; get_bpb+24↑j ...
                add     di, 6           ; BDS.BPB (BDS offset 6)

SetPtrSav:                              ; CODE XREF: dsk_init+9↓j
                push    ds              ; return point for dsk_init
                lds     bx, ds:ptrsav
                mov     [bx+0Dh], ah    ; [bx+media]
                mov     [bx+12h], di    ; [bx+count]
                mov     word ptr [bx+14h], es ; [bx+count+2]
                push    ds
                pop     es
                pop     ds
                clc
                retn
get_bpb         endp


; =============== S U B R O U T I N E =======================================


clear_ids       proc near               ; CODE XREF: get_bpb+D↑p
                                        ; DATA XREF: copybpb_fat+1C9↑o
                push    di
                xor     cx, cx          ; 0
                mov     es:[di+89h], cx ; [es:di+BDS.vol_serial]
                mov     es:[di+8Bh], cx ; [es:di+BDS.vol_serial+2]
                mov     cl, 11
                mov     si, offset nul_vid ; "NO NAME    "
                add     di, 125         ; BDS.volid
                rep movs byte ptr es:[di], byte ptr cs:[si] ; cs rep movsb
                test    byte ptr es:[di+59], 20h ; (here, es:di points to the BDS offset +136)
                                        ; [es:di+BDS.fatsiz], fbigbig
                                        ;
                                        ; ! NOTE - 26/06/2023 - Erdogan Tan
                                        ; Microsoft/IBM code has a bug here because the BDS's
                                        ; .volid and .filesys_id fields will be reset
                                        ; (to their default text) according to 'BDS.fatsiz' flags
                                        ; at the BDS offset 59 but current (this) code checks flags
                                        ; at ES:DI+59 while DI points the BDS offset 136!?
                                        ;
                                        ; Correct Code:
                                        ; test byte [ES:DI+59-136],20h or
                                        ; DI_POSITION equ BDS.volid + size_of_EXT_BOOT_VOL_LABEL
                                        ; test byte [ES:DI:BDS.fatsiz-DI_POSITION],20h ; fbigbig
                                        ;
                                        ; (Why this bug did not affect MSDOS and PCDOS 7.x applications:
                                        ; 'clear_ids' is used for floppy disks only and the default
                                        ; option of 'clear_ids' is FAT12 volid and filesys_id text
                                        ; when the flag bit has wrong value for FAT16/40h or FAT32/20h.)
                mov     si, offset fat_32_id ; "FAT32   "
                jnz     short ci_big_fat
                test    byte ptr es:[di+59], 40h ; [es:di+BDS.fatsiz], fbig
                mov     si, offset fat_16_id ; "FAT16   "
                jnz     short ci_big_fat
                mov     si, offset fat_12_id ; "FAT12   "

ci_big_fat:                             ; CODE XREF: clear_ids+20↑j
                                        ; clear_ids+2A↑j
                mov     cl, 8           ; size_of_EXT_SYSTEM_ID
                add     di, 5           ; (BDS.filesys_id-BDS.volid)-size_of_EXT_BOOT_VOL_LABEL
                                        ; BDS.filesys_id (BDS offset 141)
                rep movs byte ptr es:[di], byte ptr cs:[si] ; 0F3h,2Eh,0A4h
                                        ; cs rep movsb
                pop     di              ; restore bds pointer

getret_exit:                            ; CODE XREF: GetBp+5↓j
                retn
clear_ids       endp


; =============== S U B R O U T I N E =======================================


GetBp           proc near               ; CODE XREF: get_bpb+15↑p
                                        ; BIOSCODE:0F92↓p ...
                test    byte ptr es:[di+3Fh], 5 ; [es:di+BDS.flags],
                                        ; return_fake_bpb|fnon_removable
                jnz     short getret_exit
                push    cx
                push    dx
                push    bx
                call    readbootsec
                jb      short getbp_err_ret_brdg
                or      bx, bx          ; bx is 0 if boot sector is valid
                jnz     short dofatbpb
                call    movbpb          ; move bpb into registers
                jmp     getret
; ---------------------------------------------------------------------------

getbp_err_ret_brdg:                     ; CODE XREF: GetBp+D↑j
                                        ; GetBp+1F↓j
                jmp     getbp_err_ret
; ---------------------------------------------------------------------------

dofatbpb:                               ; CODE XREF: GetBp+11↑j
                call    readfat         ; puts media descriptor byte in ah
                jb      short getbp_err_ret_brdg
                cmp     ds:fhave96, 0   ; changeline support available?
                jz      short bpb_nochangeline ; brif not
                call    hidensity

bpb_nochangeline:                       ; CODE XREF: GetBp+26↑j
                cmp     byte ptr es:[di+3Eh], 2 ; [es:di+BDS.formfactor], ffSmall
                jnz     short is_floppy
                cmp     ah, 0F9h        ; is it a valid fat id byte for 3.5" ?
                jz      short Has720K   ; yes
                jmp     got_unknown_medium
; ---------------------------------------------------------------------------

Has720K:                                ; CODE XREF: GetBp+35↑j
                                        ; hidensity+30↓j
                mov     al, 3           ; bpbtype.sbf = 3
                mov     cx, 1440        ; bpbtype.csec = 1440
                mov     dx, 202h        ; dl = bpbtype.spau = 2
                                        ; dh = bpbtype.chead = 2
                mov     bx, 7009h       ; bl = bpbtype.spt = 9
                                        ; bh = bpbtype.dire = 112
                jmp     short Has1
; ---------------------------------------------------------------------------

is_floppy:                              ; CODE XREF: GetBp+30↑j
                cmp     ah, 0F8h
                jnb     short chk_160K
                jmp     got_unknown_medium
; ---------------------------------------------------------------------------

chk_160K:                               ; CODE XREF: GetBp+4A↑j
                mov     al, 1           ; bpbtype.sbf = 1
                mov     bx, 4008h       ; bl = bpbtype.spt = 8
                                        ; bh = bpbtype.dire = 64
                mov     cx, 320         ; bpbtype.csec = 320
                mov     dx, 101h        ; dl = bpbtype.spau = 1
                                        ; dh = bpbtype.chead = 1
                test    ah, 2
                jnz     short has8
                inc     ax              ; bpbtype.sbf = 2
                inc     bx              ; bpbtype.spt = 9
                add     cx, 40          ; 180K (360 sectors)

has8:                                   ; CODE XREF: GetBp+5D↑j
                test    ah, 1           ; bpbtype.sbf = 1
                jz      short Has1
                add     cx, cx
                mov     bh, 112         ; bh = bpbtype.dire = 112
                inc     dh              ; bpbtype.chead = 2
                inc     dx              ; bpbtype.spau = 2

Has1:                                   ; CODE XREF: GetBp+45↑j
                                        ; GetBp+67↑j ...
                push    ds
                push    es
                pop     ds
                mov     [di+8], dh      ; [di+BDS.secperclus]
                xor     dh, dh          ; 0
                mov     [di+15h], dx    ; [di+BDS.heads]
                mov     dl, bh
                mov     [di+0Ch], dx    ; [di+BDS.direntries]
                mov     [di+0Eh], cx    ; [di+BDS.totalsecs16]
                mov     [di+1Bh], cx    ; [di+BDS.totalsecs32]
                mov     [di+10h], ah    ; [di+BDS.media]
                mov     dl, al
                mov     [di+11h], dx    ; [di+BDS.fatsecs]
                mov     dl, bl
                mov     [di+13h], dx    ; [di+BDS.secpertrack]
                xor     bx, bx          ; 0
                mov     [di+19h], bx    ; [di+BDS.hiddensecs+2]
                mov     [di+17h], bx    ; [di+BDS.hiddensecs]
                mov     [di+1Dh], bx    ; [di+BDS.totalsecs32+2]
                mov     [di+1Fh], bx    ; [di+BDS.fatsecs32] ; BPB_FATSz32
                mov     [di+21h], bx    ; [di+BDS.fatsecs32+2]
                mov     [di+27h], bx    ; [di+BDS.rootdirclust]
                mov     [di+29h], bx    ; [di+BDS.rootdirclust+2]
                mov     [di+2Fh], bx    ; [di+BDS.reserved]
                                        ;     BPB_Reserved (12 zero bytes)
                mov     [di+31h], bx
                mov     [di+33h], bx
                mov     [di+35h], bx
                mov     [di+37h], bx
                mov     [di+39h], bx
                mov     [di+23h], bx    ; [di+BDS.extflags] ; BPB_ExtFlags
                mov     [di+25h], bx    ; [di+BDS.fsver] ; BPB_FSVer
                dec     bx              ; -1 ; 0FFFFFFFFh
                mov     [di+2Bh], bx    ; [di+BDS.fsinfo] ; BPB_FSInfo
                mov     [di+2Dh], bx    ; [di+BDS.bkbootsec] ; BPB_BkBootSec
                pop     ds

getret:                                 ; CODE XREF: GetBp+16↑j
                                        ; GetBp+D6↓j ...
                pop     bx
                pop     dx
                pop     cx
                retn
; ---------------------------------------------------------------------------

getbp_err_ret:                          ; CODE XREF: GetBp:getbp_err_ret_brdg↑j
                mov     ds:set_id_flag, 0
                call    maperror
                jmp     short getret
; ---------------------------------------------------------------------------

got_unknown_medium:                     ; CODE XREF: GetBp+37↑j
                                        ; GetBp+4C↑j
                mov     ds:set_id_flag, 0
                mov     al, 7
                stc
                jmp     short getret
GetBp           endp


; =============== S U B R O U T I N E =======================================


readbootsec     proc near               ; CODE XREF: GetBp+A↑p
                mov     dh, 0           ; head 0
                mov     cx, 1           ; cylinder 0, sector 1
                call    read_sector
                jb      short err_ret
                xor     bx, bx          ; bx = 0
                mov     al, ds:disksector
                cmp     al, 69h         ; is it a direct jump?
                jz      short check_bpb_mediabyte ; don't need to find a nop
                cmp     al, 0E9h        ; dos 2.0 jump?
                jz      short check_bpb_mediabyte ; no need for nop
                cmp     al, 0EBh        ; how about a short jump?
                jnz     short invalidbootsec
                cmp     ds:disksector+2, 90h ; is next one a nop?
                jnz     short invalidbootsec

check_bpb_mediabyte:                    ; CODE XREF: readbootsec+11↑j
                                        ; readbootsec+15↑j
                mov     al, ds:disksector+15h ;
                                        ; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
                push    ax
                and     al, 0F0h
                cmp     al, 0F0h        ; allow for strange media
                pop     ax
                jnz     short invalidbootsec
                cmp     al, 0F0h
                jz      short gooddsk
                test    al, 1
                jnz     short gooddsk
                cmp     word ptr ds:disksector+8, 2E33h ; '3.'
                jnz     short mustbeearlier
                cmp     ds:disksector+0Ah, 32h ; '2' ; 2
                jnb     short gooddsk

mustbeearlier:                          ; CODE XREF: readbootsec+3B↑j
                mov     ds:disksector+0Dh, 1 ; we must have a pre-3.20 diskette.
                                        ; set the sec/clus field to 1
                                        ; [disksector+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER]
                jmp     short gooddsk
; ---------------------------------------------------------------------------

invalidbootsec:                         ; CODE XREF: readbootsec+19↑j
                                        ; readbootsec+20↑j ...
                inc     bx              ; indicate that boot sector invalid (bx = 1)

gooddsk:                                ; CODE XREF: readbootsec+2F↑j
                                        ; readbootsec+33↑j ...
                clc

err_ret:                                ; CODE XREF: readbootsec+8↑j
                retn
readbootsec     endp


; =============== S U B R O U T I N E =======================================


movbpb          proc near               ; CODE XREF: GetBp+13↑p
                push    di
                add     di, 6           ; BDS+6 = BDS.BPB
                lea     si, disksector+0Bh
                mov     cx, 53          ; copy bios parameters block
                                        ; from BPB_BytsPerSec to (FAT32) BS_DrvNum (excluded)
                cld
                rep movsb
                mov     cx, [si-45]     ; si = disksector+64 -> 64-45 = 19
                                        ; disksektor+19 = BPB_TotSec16
                xor     ax, ax
                jcxz    short movbpb_bigdisk
                mov     es:[di-32], cx  ; write 16 bit total sectors
                                        ; to 32 bit total sectors field
                mov     es:[di-30], ax  ; BPB_TotalSec32+2 (BDS offset 29, BPB offset 23)

movbpb_bigdisk:                         ; CODE XREF: movbpb+13↑j
                cmp     [si-42], ax     ; BPB_FATSz16 = disksector+22
                jz      short movbpb_fat32

movbpb_fat:                             ;
                sub     di, 28          ; di = BDS offset 31 (BPB offset 25)
                mov     cx, 12          ; clear 12 byte extended BDS (FAT32) fields
                                        ; (which are used only for FAT32 disks)
                rep stosb
                dec     ax              ; -1 ; 0FFFFh
                stosw                   ; set BDS offset 43 (dword) to -1
                                        ; dword [BDS.BPB_FSInfo] = 0FFFFFFFFh
                stosw
                inc     ax              ; ax = 0
                mov     cx, 12          ; clear BDS offset 47 to 59
                                        ; (BPB offset 41 to 53) (disksector offset 52 to 64)
                rep stosb

movbpb_fat32:                           ; CODE XREF: movbpb+20↑j
                pop     di
                cmp     ds:set_id_flag, 1 ; called by get_bpb?
                jnz     short movbpb_ret
                call    mov_media_ids
                jb      short movbpb_conv ; conventional boot record?
                mov     ds:set_id_flag, 2 ; signals that volume id is set

movbpb_conv:                            ; CODE XREF: movbpb+3E↑j
                cmp     ds:fhave96, 1
                jnz     short movbpb_ret
                call    resetchanged    ; reset flags in bds to not fchanged

movbpb_ret:                             ; CODE XREF: movbpb+39↑j
                                        ; movbpb+4A↑j
                clc
                retn
movbpb          endp


; =============== S U B R O U T I N E =======================================


mov_media_ids   proc near               ; CODE XREF: movbpb+3B↑p
                                        ; BIOSCODE:1501↓p
                                        ; DATA XREF: ...
                cmp     word ptr ds:disksector+16h, 0 ; BPB.FATSz16
                jnz     short mmi_chk_fat
                cmp     ds:disksector+42h, 29h ; [disksector+FAT32_EXT_BOOT.SIG],
                                        ;                     EXT_BOOT_SIGNATURE
                jmp     short mmi_chk_fat32
; ---------------------------------------------------------------------------

mmi_chk_fat:                            ; CODE XREF: mov_media_ids+5↑j
                cmp     ds:disksector+26h, 29h ; [disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE

mmi_chk_fat32:                          ; CODE XREF: mov_media_ids+C↑j
                jnz     short mmi_not_ext
                push    cx
                push    ax
                push    di
                push    si
                push    ds
                cmp     word ptr ds:disksector+16h, 0 ; BPB.FATSz16
                jnz     short mmi_fat

mmi_fat32:                              ; FAT32 system
                lds     cx, dword ptr ds:disksector+43h ; BS_FAT32_VolID
                mov     si, (offset disksector+47h) ; BS_FAT32_VolLab
                mov     ax, (offset disksector+52h) ; BS_FAT32_FilSysType
                jmp     short mmi_do
; ---------------------------------------------------------------------------

mmi_fat:                                ; CODE XREF: mov_media_ids+1F↑j
                lds     cx, dword ptr ds:disksector+27h ; BS_VolID
                mov     si, (offset disksector+2Bh) ; BS_VolLab
                mov     ax, (offset disksector+36h) ; BS_FilSysType

mmi_do:                                 ; CODE XREF: mov_media_ids+2B↑j
                mov     es:[di+89h], cx ; [es:di+BDS.vol_serial]
                                        ; (BDS offset 137)
                mov     word ptr es:[di+8Bh], ds ; [es:di+BDS.vol_serial+2]
                pop     ds
                mov     cx, 11
                add     di, 125         ; di = di+125 = BDS.volid
                rep movsb
                mov     cl, 8           ; di = di+136
                mov     si, ax          ; BS_FilSysType or BS_FAT32_FilSysType
                add     di, 5           ; di = di+141 = BDS.filesys_id
                rep movsb
                pop     si
                pop     di
                pop     ax
                pop     cx
                clc                     ; this clc is not required (16/06/2019 - Erdogan Tan)
                                        ; (20/09/2022 - 27/06/2023) MSDOS 6.21 .. PCDOS 7.1
                retn
; ---------------------------------------------------------------------------

mmi_not_ext:                            ; CODE XREF: mov_media_ids:mmi_chk_fat32↑j
                stc
                retn
mov_media_ids   endp


; =============== S U B R O U T I N E =======================================


readfat         proc near               ; CODE XREF: GetBp:dofatbpb↑p
                mov     dh, 0           ; head 0
                mov     cx, 2           ; cylinder 0, sector 2
                call    read_sector
                jb      short bad_fat_ret
                mov     ah, [bx]        ; media byte

bad_fat_ret:                            ; CODE XREF: readfat+8↑j
                retn
readfat         endp


; =============== S U B R O U T I N E =======================================


read_sector     proc near               ; CODE XREF: readbootsec+5↑p
                                        ; readfat+5↑p ...
                push    bp
                mov     bp, 3           ; make 3 attempts
                mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
                mov     bx, offset disksector ; BIOSDATA:0152h

rd_ret:                                 ; CODE XREF: read_sector+20↓j
                push    es
                push    ds
                pop     es
                mov     ax, 201h
                int     13h             ; DISK - READ SECTORS INTO MEMORY
                                        ; AL = number of sectors to read, CH = track, CL = sector
                                        ; DH = head, DL = drive, ES:BX -> buffer to fill
                                        ; Return: CF set on error, AH = status, AL = number of sectors read
                pop     es
                jnb     short okret2

rd_rty:                                 ; CODE XREF: read_sector+5D↓j
                call    again           ; reset disk, decrement bp
                jz      short err_rd_ret
                test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
                                        ; (BDS offset 63)
                jnz     short rd_ret
                cmp     ds:media_set_for_format, 0
                jnz     short rd_skip1_dpt
                push    ax
                push    ds              ; for retry, set the head settle time to 0Fh
                lds     si, ds:dpt
                mov     al, [si+9]      ; [si+DISK_PARMS.DISK_HEAD_STTL]
                mov     byte ptr [si+9], 15 ; NORMSETTLE
                pop     ds
                mov     ds:save_head_sttl, al
                pop     ax

rd_skip1_dpt:                           ; CODE XREF: read_sector+27↑j
                push    es
                push    ds
                pop     es
                mov     ax, 201h
                int     13h             ; DISK - READ SECTORS INTO MEMORY
                                        ; AL = number of sectors to read, CH = track, CL = sector
                                        ; DH = head, DL = drive, ES:BX -> buffer to fill
                                        ; Return: CF set on error, AH = status, AL = number of sectors read
                pop     es
                pushf
                cmp     ds:media_set_for_format, 0
                jnz     short rd_skip2_dpt
                push    ax
                mov     al, ds:save_head_sttl
                push    ds
                lds     si, ds:dpt
                mov     [si+9], al      ; [si+DISK_PARMS.DISK_HEAD_STTL]
                pop     ds
                pop     ax

rd_skip2_dpt:                           ; CODE XREF: read_sector+4A↑j
                popf
                jnb     short okret2
                jmp     short rd_rty
; ---------------------------------------------------------------------------

err_rd_ret:                             ; CODE XREF: read_sector+19↑j
                mov     dl, 0FFh        ; make sure we ask rom if media has changed
                stc                     ; return error

okret2:                                 ; CODE XREF: read_sector+14↑j
                                        ; read_sector+5B↑j
                mov     ds:step_drv, dl
                mov     ds:tim_drv, dl
                mov     es:[di+78h], ch ; [es:di+BDS.track]
                                        ; (BDS offset 120)
                                        ; save last track accessed on this drive
                pushf
                call    set_tim
                popf                    ; restore flags
                pop     bp
                retn
read_sector     endp


; =============== S U B R O U T I N E =======================================


dsk_open        proc near               ; DATA XREF: BIOSCODE:0594↑o
                cmp     ds:fhave96, 0
                jz      short dsk_open_exit ; done if no changeline support
                call    SetDrive        ; get bds for drive
                inc     word ptr es:[di+3Ch] ; [es:di+BDS.opcnt]
                                        ; (BDS offset 60)

dsk_open_exit:                          ; CODE XREF: dsk_open+5↑j
                clc                     ; CF is already ZERO here - Erdogan Tan
                retn
dsk_open        endp


; =============== S U B R O U T I N E =======================================


dsk_close       proc near               ; DATA XREF: BIOSCODE:0596↑o
                cmp     ds:fhave96, 0
                jz      short exitjx    ; done if no changeline support
                call    SetDrive        ; get bds for drive
                cmp     word ptr es:[di+3Ch], 0 ; [es:di+BDS.opcnt]
                jz      short exitjx    ; watch out for wrap
                dec     word ptr es:[di+3Ch]

exitjx:                                 ; CODE XREF: dsk_close+5↑j
                                        ; dsk_close+F↑j ...
                clc                     ; CF is already ZERO here - Erdogan Tan
                retn
dsk_close       endp


; =============== S U B R O U T I N E =======================================


dsk_rem         proc near               ; DATA XREF: BIOSCODE:0598↑o
                call    SetDrive
                test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
                jz      short exitjx

x_bus_exit:                             ; DATA XREF: BIOSCODE:0584↑o
                mov     ah, 3           ; non_rem
                                        ; return busy status
                stc

dsk_ret:                                ; CODE XREF: BIOSCODE:dsk_io↓j
                retn
dsk_rem         endp

; ---------------------------------------------------------------------------

dsk_writv:                              ; DATA XREF: BIOSCODE:058C↑o
                mov     word ptr ds:rflag, 103h ; write and verify
                jmp     short dsk_cl
; ---------------------------------------------------------------------------

dsk_writ:                               ; DATA XREF: BIOSCODE:058A↑o
                mov     word ptr ds:rflag, 3 ; romwrite

dsk_cl:                                 ; CODE XREF: BIOSCODE:097D↑j
                call    diskio          ; prepare for rombios read/write

dsk_io:                                 ; CODE XREF: BIOSCODE:0990↓j
                jnb     short dsk_ret
                jmp     bc_err_cnt
; ---------------------------------------------------------------------------

dsk_read:                               ; DATA XREF: BIOSCODE:0582↑o
                call    DISKRD
                jmp     short dsk_io

; =============== S U B R O U T I N E =======================================


checksingle     proc near               ; CODE XREF: diskio+77↓p
                                        ; BIOSCODE:0F8F↓p ...
                push    ax
                push    bx
                mov     bx, es:[di+3Fh] ; [es:di+BDS.flags]
                test    bl, 21h         ; fnon_removable|fi_own_physical
                jnz     short singleret
                test    bl, 10h         ; fi_am_mult
                                        ; is there a drive sharing this physical drive?
                jz      short singleret
                mov     al, es:[di+4]   ; [es:di+BDS.drivenum]
                                        ; get physical drive number
                push    es              ; preserve pointer to current bds
                push    di
                les     di, dword ptr ds:start_bds ; get first bds

scan_list:                              ; CODE XREF: checksingle+79↓j
                cmp     es:[di+4], al
                jnz     short scan_skip ; Not our drive. Try next bds.
                mov     bl, 20h         ; fi_own_physical ; test ownership flag
                test    es:[di+3Fh], bl
                jz      short scan_skip ; he doesn't own it either. continue
                xor     es:[di+3Fh], bl ; reset ownership flag
                pop     di
                pop     es
                or      es:[di+3Fh], bl
                cmp     ds:fsetowner, 1
                jnz     short not_fsetowner
                cmp     byte ptr es:[di+4], 0 ; are we handling drive number 0 ?
                jnz     short singleret
                mov     al, es:[di+5]   ; [es:di+BDS.drivelet]
                                        ; get the DOS drive letter
                push    es
                mov     es, ds:zeroseg
                assume es:nothing
                mov     byte ptr es:504h, al ; [es:LSTDRV]
                                        ; set up sdsb
                pop     es              ; restore bds pointer
                assume es:nothing
                jmp     short singleret
; ---------------------------------------------------------------------------

not_fsetowner:                          ; CODE XREF: checksingle+37↑j
                cmp     ds:single, 2    ; if (single_drive_system)
                jnz     short ignore_sdsb
                push    ax
                mov     al, es:[di+5]   ; if (curr_drv == req_drv)
                mov     ah, al
                push    es
                mov     es, ds:zeroseg
                assume es:nothing
                xchg    al, byte ptr es:504h ; [es:LSTDRV]
                                        ; then swap(curr_drv,req_drv)
                pop     es
                assume es:nothing
                cmp     ah, al          ; else
                pop     ax              ; swap(curr_drv,req_drv)
                jz      short singleret ; issue swap_dsk_msg

ignore_sdsb:                            ; CODE XREF: checksingle+55↑j
                call    swpdsk
                jmp     short singleret
; ---------------------------------------------------------------------------

scan_skip:                              ; CODE XREF: checksingle+1E↑j
                                        ; checksingle+26↑j
                les     di, es:[di]
                cmp     di, 0FFFFh      ; -1  ; end of list?
                jnz     short scan_list ; continue until hit end of list
                stc
                pop     di              ; restore current bds
                pop     es

singleret:                              ; CODE XREF: checksingle+9↑j
                                        ; checksingle+E↑j ...
                pop     bx
                pop     ax
                retn
checksingle     endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR diskio

baddrive:                               ; CODE XREF: diskio+32↓j
                                        ; diskio+38↓j ...
                mov     al, 8           ; sector not found
                jmp     short baddrive_ret
; ---------------------------------------------------------------------------

unformatteddrive:                       ; CODE XREF: diskio+17↓j
                mov     al, 7           ; unknown media

baddrive_ret:                           ; CODE XREF: diskio-1B↑j
                stc
; END OF FUNCTION CHUNK FOR diskio

ioret:                                  ; CODE XREF: diskio+10↓j
                retn
; ---------------------------------------------------------------------------
LBA_Packet      db 16                   ; DATA XREF: diskio+E1↓o
                                        ; DAP buffer
                db 0
dap_block_cnt   dw 0                    ; DATA XREF: diskio+C2↓w
dap_trans_buf   dw 2 dup(0)             ; DATA XREF: diskio+B3↓w
                                        ; diskio+BB↓w
dap_lba_value   dw 2 dup(0)             ; DATA XREF: diskio:set_lbarw_2↓w
                                        ; diskio+AE↓w
                db 4 dup(0)

; =============== S U B R O U T I N E =======================================


DISKRD          proc near               ; CODE XREF: BIOSCODE:dsk_read↑p
                                        ; DATA XREF: getclus+103↑o ...
                mov     ds:rflag, 2     ; romread
DISKRD          endp


; =============== S U B R O U T I N E =======================================


diskio          proc near               ; CODE XREF: BIOSCODE:dsk_cl↑p
                                        ; BootIo+11↓p

; FUNCTION CHUNK AT 0A13 SIZE 00000007 BYTES

                mov     bx, di          ; al = drive number
                                        ; cx = sector count
                                        ; dx = first sector (low)
                                        ; [start_sec_h] = first sector (high)
                                        ;
                                        ; es:bx = transfer address
                mov     ds:xfer_seg, es ; save transfer segment
                call    SetDrive
                mov     al, es:[di+10h] ; [es:di+BDS.media]
                mov     ds:medbyt, al
                jcxz    short ioret
                test    byte ptr es:[di+40h], 2 ; [es:di+BDS.flags+1]
                                        ;  unformatted_media
                jnz     short unformatteddrive
                mov     ds:seccnt, cx   ; save sector count
                mov     ds:spsav, sp    ; save sp
                mov     ax, dx
                xor     si, si
                add     dx, cx
                rcl     si, 1
                cmp     word ptr es:[di+0Eh], 0 ; [es:di+BDS.totalsecs16]
                                        ; > 32 bit sector ?
                jz      short sanity32
                or      si, si
                jnz     short baddrive
                cmp     dx, es:[di+0Eh] ; [es:di+BDS.totalsecs16]
                ja      short baddrive
                jmp     short sanityok
; ---------------------------------------------------------------------------

sanity32:                               ; CODE XREF: diskio+2E↑j
                add     si, ds:start_sec_h
                cmp     si, es:[di+1Dh] ; [es:di+BDS.totalsecs32+2]
                jb      short sanityok
                ja      short baddrive
                cmp     dx, es:[di+1Bh] ; [es:di+BDS.totalsecs32]
                ja      short baddrive

sanityok:                               ; CODE XREF: diskio+3A↑j
                                        ; diskio+44↑j
                mov     dx, ds:start_sec_h
                add     ax, es:[di+17h] ; [es:di+BDS.hiddensecs]
                adc     dx, es:[di+19h] ; [es:di+BDS.hiddensecs+2]
                mov     ds:saved_word, ax ; save the sector number (low)
                push    es
                xor     si, si          ; 0
                mov     es, si
                assume es:nothing
                les     si, dword ptr es:78h ; INT 1Eh vector address
                                        ; [es:DSKADR] - current disk parm table
                assume es:nothing
                mov     word ptr ds:dpt, si
                mov     word ptr ds:dpt+2, es
                pop     es
                test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
                jnz     short chk_13h_ext_flag
                call    checksingle
                cmp     ds:fhave96, 0   ; do we have changeline support?
                jz      short diskio_nochangeline ; brif not
                call    checklatchio

diskio_nochangeline:                    ; CODE XREF: diskio+7F↑j
                call    iosetup

chk_13h_ext_flag:                       ; CODE XREF: diskio+75↑j
                test    byte ptr es:[di+40h], 4 ; [es:di+BDS.flags+1], fLBArw
                                        ; LBA read/write flag
                jnz     short set_lbarw_1
                jmp     skip_setup
; ---------------------------------------------------------------------------

set_lbarw_1:                            ; CODE XREF: diskio+8C↑j
                mov     ax, ds:saved_word ; check for mini disk (logical dos drive/partition)
                cmp     word ptr es:[di+79h], 1 ; [di+BDS.bdsm_ismini] ; logical dos partition
                jnz     short set_lbarw_2 ; not a logical dos partition/drive
                cmp     word ptr es:[di+7Bh], 0 ; [di+BDS.bdsm_hidden_trks] (> 0)
                jz      short set_lbarw_2
                add     ax, es:[di+17h] ; [es:di+BDS.hiddensecs]
                adc     dx, es:[di+19h] ; [es:di+BDS.hiddensecs+2]

set_lbarw_2:                            ; CODE XREF: diskio+99↑j
                                        ; diskio+A0↑j
                mov     cs:dap_lba_value, ax
                mov     cs:dap_lba_value+2, dx
                mov     cs:dap_trans_buf, bx
                mov     ax, ds:xfer_seg
                mov     cs:dap_trans_buf+2, ax
                mov     ax, ds:seccnt
                mov     cs:dap_block_cnt, ax
                mov     bp, 5
                mov     ds:vretry_cnt, bp ; verify op. retry cnt for write-verify
                mov     ds:soft_ecc_cnt, bp ; soft ecc error retry count

set_lbarw_3:                            ; CODE XREF: diskio:set_lbarw_6↓j
                                        ; diskio:set_lbarw_11↓j
                mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
                mov     ah, ds:rflag    ; get read/write indicator
                add     ah, 40h
                xor     al, al
                push    ds
                push    cs
                pop     ds
                assume ds:BIOSCODE
                mov     si, offset LBA_Packet
                int     13h             ; DISK -
                pop     ds
                assume ds:nothing
                jnb     short set_lbarw_7
                call    again
                jnz     short set_lbarw_4
                jmp     harderr
; ---------------------------------------------------------------------------

set_lbarw_4:                            ; CODE XREF: diskio+EC↑j
                cmp     ah, 0CCh        ; Write fault (hard disk)
                jnz     short set_lbarw_5
                mov     bp, 1
                jmp     short set_lbarw_6
; ---------------------------------------------------------------------------

set_lbarw_5:                            ; CODE XREF: diskio+F4↑j
                mov     ds:soft_ecc_cnt, 5

set_lbarw_6:                            ; CODE XREF: diskio+F9↑j
                jmp     short set_lbarw_3
; ---------------------------------------------------------------------------

set_lbarw_7:                            ; CODE XREF: diskio+E7↑j
                cmp     word ptr ds:rflag, 103h
                jnz     short set_lbarw_12
                mov     ah, 44h
                push    ds
                push    cs
                pop     ds
                assume ds:BIOSCODE
                int     13h             ; DISK - IBM/MS Extension - VERIFY SECTORS
                                        ;  (DL - drive, DS:SI - disk address packet)
                pop     ds
                assume ds:nothing
                jnb     short set_lbarw_12
                cmp     ah, 11h         ; ECC corrected data error (soft error - retried OK )
                jnz     short set_lbarw_8
                dec     ds:soft_ecc_cnt

set_lbarw_8:                            ; CODE XREF: diskio+118↑j
                jz      short set_lbarw_12
                call    ResetDisk
                cmp     ah, 11h
                jz      short set_lbarw_11
                dec     ds:vretry_cnt
                jnz     short set_lbarw_9
                jmp     harderr
; ---------------------------------------------------------------------------

set_lbarw_9:                            ; CODE XREF: diskio+12C↑j
                cmp     ah, 0CCh
                jnz     short set_lbarw_10
                mov     bp, 1
                jmp     short set_lbarw_11
; ---------------------------------------------------------------------------

set_lbarw_10:                           ; CODE XREF: diskio+134↑j
                mov     ds:soft_ecc_cnt, 5 ; soft ecc error retry count

set_lbarw_11:                           ; CODE XREF: diskio+126↑j
                                        ; diskio+139↑j
                jmp     short set_lbarw_3
; ---------------------------------------------------------------------------

set_lbarw_12:                           ; CODE XREF: diskio+109↑j
                                        ; diskio+113↑j ...
                xor     ax, ax
                retn
; ---------------------------------------------------------------------------

skip_setup:                             ; CODE XREF: diskio+8E↑j
                push    bp
                xchg    ax, dx
                xor     dx, dx
                mov     cx, es:[di+13h] ; [es:di+BDS.secpertrack]
                                        ; divide by sec per track
                div     cx
                xchg    ax, bp
                mov     ax, ds:saved_word
                div     cx              ; [es:di+BDS.secpertrack]
                                        ; now, bp:ax = track #, dx = sector
                                        ; sector number is 1 based.
                inc     dx
                mov     ds:cursec, dl   ; save current sector
                mov     cx, es:[di+15h] ; [es:di+BDS.heads]
                                        ; get number of heads
                push    ax
                xor     dx, dx
                xchg    ax, bp          ; divide tracks by heads per cylinder
                div     cx
                xchg    ax, bp
                pop     ax
                div     cx              ; now, bp:ax = cylinder #, dx = head
                or      bp, bp
                pop     bp
                jnz     short baddrive_brdg
                cmp     ax, 1024        ; 2^10 currently maxium for track #.
                jnb     short baddrive_brdg
                mov     ds:curhd, dl    ; save current head
                mov     ds:curtrk, ax   ; save current track
                mov     ax, ds:seccnt
                call    block
                call    done
                retn
; ---------------------------------------------------------------------------

baddrive_brdg:                          ; CODE XREF: diskio+16C↑j
                                        ; diskio+171↑j
                jmp     baddrive
diskio          endp


; =============== S U B R O U T I N E =======================================


iosetup         proc near               ; CODE XREF: diskio:diskio_nochangeline↑p
                                        ; TrackIo+10↓p
                mov     al, es:[di+4]   ; [es:di+BDS.drivenum]
                mov     ds:tim_drv, al  ; save drive letter
                cmp     ds:media_set_for_format, 0
                jnz     short skip_dpt_setting
                mov     al, ds:eot      ; fetch up eot before changing ds
                push    ds
                lds     si, ds:dpt      ; get pointer to disk base table
                mov     [si+4], al
                mov     al, [si+10]     ; [si+DISK_PARMS.DISK_MOTOR_STRT]
                mov     ah, [si+4]      ; [si+DISK_PARMS.DISK_EOT]
                pop     ds
                mov     ds:motorstartup, al
                mov     ds:save_eot, ah
                push    ds
                lds     si, ds:dpt      ; get pointer to disk base table
                cmp     byte ptr es:[di+62], 2 ; [es:di+BDS.formfactor], ffSmall
                jnz     short motor_start_ok
                mov     al, 4
                xchg    al, [si+10]     ; [si+DISK_PARMS.DISK_MOTOR_STRT]

motor_start_ok:                         ; CODE XREF: iosetup+31↑j
                xor     al, al
                inc     al              ; ibm wants fast settle to be 1
                xchg    al, [si+9]      ; [si+DISK_PARMS.DISK_HEAD_STTL]
                                        ; get settle and set up for fast
                pop     ds
                mov     ds:settlecurrent, al
                mov     al, 15          ; NORMSETTLE
                                        ; someone has diddled the settle
                mov     ds:settleslow, al

skip_dpt_setting:                       ; CODE XREF: iosetup+C↑j
                retn
iosetup         endp


; =============== S U B R O U T I N E =======================================


done            proc near               ; CODE XREF: diskio+180↑p
                                        ; TrackIo+83↓p
                test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
                jnz     short ddbx      ; do not set for non-removable media
                call    set_tim

diddle_back:                            ; CODE XREF: disk+142↓j
                pushf
                cmp     ds:media_set_for_format, 0
                jnz     short nodiddleback
                push    ax
                push    es
                les     si, ds:dpt
                mov     al, ds:save_eot
                mov     es:[si+4], al   ; [es:si+DISK_PARMS.DISK_EOT]
                mov     al, ds:settlecurrent
                mov     ah, ds:motorstartup
                mov     es:[si+9], al   ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
                mov     byte ptr es:[si+3], 2 ; [es:si+DISK_PARMS.DISK_SECTOR_SIZ]
                mov     es:[si+0Ah], ah ; [es:si+DISK_PARMS.DISK_MOTOR_STRT]
                pop     es
                pop     ax

nodiddleback:                           ; CODE XREF: done+10↑j
                popf

ddbx:                                   ; CODE XREF: done+5↑j
                                        ; block+2↓j
                retn
done            endp


; =============== S U B R O U T I N E =======================================


block           proc near               ; CODE XREF: diskio+17D↑p
                                        ; block+38↓j
                or      ax, ax
                jz      short ddbx
                test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
                jz      short block_floppy
                test    byte ptr ds:multrk_flag, 80h ; multrk_on
                jz      short block_floppy
                call    disk
                xor     ax, ax
                retn
; ---------------------------------------------------------------------------

block_floppy:                           ; CODE XREF: block+9↑j
                                        ; block+10↑j
                mov     cl, es:[di+19]  ; [es:di+BDS.secpertrack]
                inc     cx
                sub     cl, ds:cursec
                xor     ch, ch
                cmp     ax, cx
                jnb     short gotmin
                mov     cx, ax

gotmin:                                 ; CODE XREF: block+25↑j
                push    ax
                push    cx
                mov     ax, cx
                call    disk
                pop     cx
                pop     ax
                sub     ax, cx          ; reduce sectors-remaining by last i/o
                add     cl, cl
                add     bh, cl          ; adjust transfer address
                jmp     short block
block           endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR disk

dskerr_brdg:                            ; CODE XREF: disk:testerr↓j
                                        ; disk+6E↓j
                jmp     dskerr
; END OF FUNCTION CHUNK FOR disk

; =============== S U B R O U T I N E =======================================


disk            proc near               ; CODE XREF: block+12↑p
                                        ; block+2D↑p ...

; FUNCTION CHUNK AT 0C71 SIZE 00000003 BYTES

                mov     bp, 5           ; al = number of sectors (1-8, all on one track)
                                        ; es:di point to drive parameters
                                        ; xfer_seg:bx = transfer address
                                        ;      (must not cross a 64k physical boundary)
                                        ; [rflag] = 2 if read, 3 if write
                                        ; [verify] = 0 for normal, 1 for verify after write
                                        ;
                                        ; bp = MAXERR
                                        ;      retry_count
                test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
                jz      short GetRdWrInd
                cmp     ah, 4           ; romverify ; Is this a track verify?
                jz      short GetRdWrInd
                mov     bp, 2           ; This is not verify so only 1 retry

GetRdWrInd:                             ; CODE XREF: disk+8↑j
                                        ; disk+D↑j
                mov     ds:vretry_cnt, bp ; verify op. retry cnt for write-verify
                mov     ds:soft_ecc_cnt, bp ; soft ecc error retry count
                mov     ah, ds:rflag    ; get read/write indicator

_retry:                                 ; CODE XREF: disk+12A↓j
                push    ax
                mov     dx, ds:curtrk
                test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.bdsm_ismini]
                                        ; is this a mini disk? ((logical dos partition))
                jz      short disk_not_mini ; no. continue to next
                cmp     word ptr es:[di+79h], 1
                jnz     short disk_not_mini
                add     dx, es:[di+7Bh] ; [es:di+BDS.bdsm_hidden_trks]
                                        ; add hidden tracks

disk_not_mini:                          ; CODE XREF: disk+28↑j
                                        ; disk+2F↑j
                ror     dh, 1
                ror     dh, 1
                or      dh, ds:cursec
                mov     cl, dh
                mov     ch, dl          ; cl = sector, ch = cylinder
                mov     dh, ds:curhd    ; load current head number and
                mov     dl, es:[di+4]   ; physical drive number
                                        ; [es:di+BDS.drivenum]
                cmp     byte ptr es:[di+3Eh], 5 ; [es:di+BDS.formfactor], ffHardFile
                jz      short do_fast   ; hard files use fast speed
                cmp     ds:step_drv, 0FFh ; -1
                jz      short do_write
                cmp     ah, 2           ; romread
                jz      short do_fast
                cmp     ah, 4           ; romverify
                jnz     short do_write

do_fast:                                ; CODE XREF: disk+4E↑j
                                        ; disk+5A↑j ...
                call    fastspeed

testerr:                                ; CODE XREF: disk+D0↓j
                jb      short dskerr_brdg
                cmp     bp, 5           ; is there retry ?
                jnz     short testerror ; yes
                cmp     ah, 0BBh        ; Undefined error (hard disk)
                jz      short dskerr_brdg

testerror:                              ; CODE XREF: disk+69↑j
                mov     ds:step_drv, dl
                mov     es:[di+78h], ch ; [es:di+BDS.track]
                cmp     word ptr ds:rflag, 103h ; check for write and verify
                jz      short doverify

noverify:                               ; CODE XREF: disk+D9↓j
                                        ; disk+E4↓j
                pop     ax
                test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
                jz      short its_removable
                test    byte ptr ds:multrk_flag, 80h ; multrk_on
                jnz     short disk_ret

its_removable:                          ; CODE XREF: disk+86↑j
                and     cl, 3Fh         ; eliminate cylinder bits from sector
                xor     ah, ah
                sub     ds:seccnt, ax   ; reduce count of sectors to go next sector
                add     cl, al
                mov     ds:cursec, cl
                cmp     cl, es:[di+13h] ; [es:di+BDS.secpertrack]
                                        ; see if sector/track limit reached
                jbe     short disk_ret
                mov     ds:cursec, 1
                mov     dh, ds:curhd
                inc     dh
                cmp     dh, es:[di+15h] ; [es:di+BDS.heads]
                                        ; see if head limit reached
                jb      short noxor
                xor     dh, dh          ; head 0
                inc     ds:curtrk       ; next track

noxor:                                  ; CODE XREF: disk+B3↑j
                mov     ds:curhd, dh

disk_ret:                               ; CODE XREF: disk+8D↑j
                                        ; disk+A2↑j
                clc
                retn
; ---------------------------------------------------------------------------

do_write:                               ; CODE XREF: disk+55↑j
                                        ; disk+5F↑j
                cmp     dl, ds:step_drv
                jnz     short do_norm   ; we have changed drives
                cmp     ch, es:[di+78h] ; [es:di+BDS.track]
                jz      short do_fast   ; we are still on the same track

do_norm:                                ; CODE XREF: disk+C5↑j
                call    normspeed
                jmp     short testerr
; ---------------------------------------------------------------------------

doverify:                               ; CODE XREF: disk+7E↑j
                pop     ax
                push    ax
                mov     ah, 4
                call    fastspeed
                jnb     short noverify
                cmp     ah, 11h         ; soft ecc error ?
                jnz     short not_softecc_err
                dec     ds:soft_ecc_cnt
                jz      short noverify  ; no more retry
                call    ResetDisk
                jmp     short diskerr1  ; retry
; ---------------------------------------------------------------------------

not_softecc_err:                        ; CODE XREF: disk+DE↑j
                call    ResetDisk
                dec     ds:vretry_cnt
                jmp     short dskerr0
; ---------------------------------------------------------------------------

dskerr:                                 ; CODE XREF: disk:dskerr_brdg↑j
                cmp     ds:fhave96, 0   ; do we have changeline support?
                jz      short dskerr_nochangeline ; brif not
                call    checkio

dskerr_nochangeline:                    ; CODE XREF: disk+F9↑j
                cmp     ds:multitrk_format_flag, 1 ; multi trk format request?
                jnz     short dochkagain ; no more retry
                mov     bp, 1
                mov     ds:multitrk_format_flag, 0 ; clear the flag

dochkagain:                             ; CODE XREF: disk+103↑j
                call    again

dskerr0:                                ; CODE XREF: disk+F2↑j
                jz      short harderr
                test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
                jnz     short skip_timeout_chk
                cmp     ah, 80h         ; timeout?
                jz      short harderr

skip_timeout_chk:                       ; CODE XREF: disk+117↑j
                cmp     ah, 0CCh        ; write fault error?
                jz      short write_fault_err ; then, don't retry.
                mov     ds:soft_ecc_cnt, 5 ; MAXERR
                                        ; set soft_ecc_cnt back   to maxerr

diskerr1:                               ; CODE XREF: disk+E9↑j
                                        ; disk+130↓j
                pop     ax              ; restore sector count
                jmp     _retry
; ---------------------------------------------------------------------------

write_fault_err:                        ; CODE XREF: disk+121↑j
                mov     bp, 1           ; just retry only once
                                        ; for write fault error
                jmp     short diskerr1
; ---------------------------------------------------------------------------

harderr:                                ; CODE XREF: diskio+EE↑j
                                        ; diskio+12E↑j ...
                call    maperror

harderr2:                               ; CODE XREF: checkio:no_error_map↓j
                mov     ds:tim_drv, 0FFh ; force a media check through rom
                mov     cx, ds:seccnt   ; get count of sectors to go
                mov     sp, ds:spsav    ; recover entry stack pointer
                jmp     diddle_back
disk            endp


; =============== S U B R O U T I N E =======================================


normspeed       proc near               ; CODE XREF: disk:do_norm↑p
                cmp     ds:media_set_for_format, 0
                jnz     short fastspeed
                push    es
                push    ax
                mov     al, ds:settleslow
                les     si, ds:dpt      ; current disk parm table
                mov     es:[si+9], al   ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
                pop     ax
                pop     es
                call    fastspeed
                push    ds
                lds     si, ds:dpt
                mov     byte ptr [si+9], 1 ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
                                        ; 1 is fast settle value
                pop     ds
                retn
normspeed       endp


; =============== S U B R O U T I N E =======================================


fastspeed       proc near               ; CODE XREF: disk:do_fast↑p
                                        ; disk+D6↑p ...
                push    es
                mov     es, ds:xfer_seg
                int     13h             ; DISK -
                mov     ds:xfer_seg, es
                pop     es
                retn
fastspeed       endp


; =============== S U B R O U T I N E =======================================


maperror        proc near               ; CODE XREF: BIOSCODE:err_exitj↑p
                                        ; GetBp+D3↑p ...
                push    cx
                push    es
                push    ds
                pop     es              ; set es=Bios_Data
                mov     al, ah
                mov     ds:lsterr, al   ; terminate list with error code
                mov     cx, 11          ; numerr (= errout-errin)
                                        ; number of possible error conditions
                mov     di, offset errin
                repne scasb
                mov     al, [di+10]     ; [di+numerr-1]
                                        ; get translation
                pop     es
                pop     cx
                stc                     ; flag error condition
                retn
maperror        endp


; =============== S U B R O U T I N E =======================================


set_tim         proc near               ; CODE XREF: read_sector+6F↑p
                                        ; done+7↑p
                push    ax              ; set the time of last access for this drive.
                                        ; this is done only for removable media.
                                        ; es:di -> bds
                call    GetTickCnt      ; Does INT 1A ah=0 & updates daycnt
                cmp     dx, es:[di+79h] ; [es:di+BDS.tim_lo]
                jnz     short setaccess
                cmp     cx, es:[di+7Bh] ; [es:di+BDS.tim_hi]
                jz      short done_set

setaccess:                              ; CODE XREF: set_tim+8↑j
                mov     ds:accesscount, 0 ; the time has passed
                                        ; reset the threshold counter
                mov     es:[di+79h], dx
                mov     es:[di+7Bh], cx

done_set:                               ; CODE XREF: set_tim+E↑j
                clc
                pop     ax
                retn
set_tim         endp


; =============== S U B R O U T I N E =======================================


again           proc near               ; CODE XREF: read_sector:rd_rty↑p
                                        ; diskio+E9↑p ...
                call    ResetDisk
                cmp     ah, 6           ; If it is a media change error
                                        ; do not decrement retry count
                jz      short dont_dec_retry_count
                dec     bp              ; decrement retry count
                retn
; ---------------------------------------------------------------------------

dont_dec_retry_count:                   ; CODE XREF: again+6↑j
                or      ah, ah
                retn
again           endp

; ---------------------------------------------------------------------------
ioctl_drvnum    db 0                    ; DATA XREF: BIOSCODE:0E3C↓w
                                        ; BIOSCODE:ioctl_output_1↓r

; =============== S U B R O U T I N E =======================================


get_phy_drv_num proc near               ; CODE XREF: BIOSCODE:ioctl_output↓p
                                        ; BIOSCODE:ioctl_input↓p
                call    SetDrive        ; get physcial drive number
                                        ; INPUT: al = logical drive number (BDS.drivelet)
                                        ; OUTPUT: physical drive number (BDS.drivenum
                mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
                retn
get_phy_drv_num endp

; ---------------------------------------------------------------------------

ioctl_output:                           ; DATA XREF: BIOSCODE:0592↑o
                call    get_phy_drv_num
                mov     cs:ioctl_drvnum, dl
                mov     ah, 41h
                mov     bx, 55AAh
                int     13h             ; DISK - Check for INT 13h Extensions
                                        ; BX = 55AAh, DL = drive number
                                        ; Return: CF set if not supported
                                        ; AH = extensions version
                                        ; BX = AA55h
                                        ; CX = Interface support bit map
                jb      short int13h_exts_err

ioctl_input_1:                          ; CODE XREF: BIOSCODE:0E91↓j
                les     di, ds:ptrsav
                les     di, es:[di+14]  ; [es:di+IOCTL_REQ.MINORFUNCTION]
                jb      short ioctl_input_2
                mov     ax, 4600h       ; Eject removable media
                cmp     es:[di], al     ; al = 0 ; disk ioctl function = 0
                jz      short ioctl_output_1
                cmp     byte ptr es:[di], 1 ; al = 1 ; disk ioctl function = 1
                jnz     short ioctl_output_2
                mov     ax, 4501h       ; Lock/unlock media
                                        ; (al, 0 = lock, 1 = unlock)
                cmp     byte ptr es:[di+1], 0 ; unlock (reverse of INT 13h ah=45h)
                jz      short ioctl_output_1
                cmp     es:[di+1], al   ; lock (reverse of INT 13h ah=45h)
                jnz     short ioctl_output_2
                dec     ax

ioctl_output_1:                         ; CODE XREF: BIOSCODE:0E5A↑j
                                        ; BIOSCODE:0E6A↑j
                mov     dl, cs:ioctl_drvnum
                int     13h             ; DISK - IBM/MS Extension - LOCK/UNLOCK DRIVE (DL - drive, DS:SI - disk address packet)
                jb      short int13h_exts_err

ioctl_lock_err:                         ; CODE XREF: BIOSCODE:0E83↓j
                                        ; BIOSCODE:0E88↓j ...
                clc
                retn
; ---------------------------------------------------------------------------

ioctl_output_2:                         ; CODE XREF: BIOSCODE:0E60↑j
                                        ; BIOSCODE:0E70↑j ...
                mov     ah, 1

int13h_exts_err:                        ; CODE XREF: BIOSCODE:0E48↑j
                                        ; BIOSCODE:0E7A↑j ...
                cmp     ah, 0B0h        ; volume not locked in drive
                jz      short ioctl_lock_err
                cmp     ah, 0B4h        ; lock count exceeded
                jz      short ioctl_lock_err
                jmp     err_exitj
; ---------------------------------------------------------------------------

ioctl_input:                            ; DATA XREF: BIOSCODE:0580↑o
                call    get_phy_drv_num
                stc
                jmp     short ioctl_input_1
; ---------------------------------------------------------------------------

ioctl_input_2:                          ; CODE XREF: BIOSCODE:0E52↑j
                cmp     byte ptr es:[di], 6 ; disk ioctl function = 6
                jnz     short ioctl_output_2
                mov     ax, 4502h       ; get lock status
                int     13h             ; DISK - IBM/MS Extension - LOCK/UNLOCK DRIVE (DL - drive, DS:SI - disk address packet)
                jb      short int13h_exts_err
                mov     bx, 0Ch         ; bit 1 lock bit
                cmp     al, 0           ; not locked
                jz      short ioctl_input_3
                mov     bl, 0Eh

ioctl_input_3:                          ; CODE XREF: BIOSCODE:0EA5↑j
                push    bx
                mov     ah, 4
                mov     cx, 101h
                mov     dh, 1
                int     13h             ; DISK - VERIFY SECTORS
                                        ; AL = number of sectors to verify, CH = track, CL = sector
                                        ; DH = head, DL = drive
                                        ; Return: CF set on error, AH = status
                                        ; AL = number of sectors verified
                pop     bx
                cmp     ah, 31h         ; no media in drive (IBM/MS INT 13 extensions)
                jz      short ioctl_input_5
                cmp     ah, 80h         ; timeout (not ready)
                jz      short ioctl_input_5

ioctl_input_4:                          ; CODE XREF: BIOSCODE:0EC8↓j
                mov     es:[di+1], bx
                jmp     short ioctl_lock_err
; ---------------------------------------------------------------------------

ioctl_input_5:                          ; CODE XREF: BIOSCODE:0EB7↑j
                                        ; BIOSCODE:0EBC↑j
                or      bx, 801h        ; bit 0 error bit (1 = error, 31h or 80h)
                                        ; bit 11 (not ready -removable media error- bit)
                                        ; if bit 11 = 0, another error (except 31h and 80h)
                jmp     short ioctl_input_4
; ---------------------------------------------------------------------------
IoReadJumpTable db 15                   ; DATA XREF: BIOSCODE:0F35↓o
                dw offset GetDeviceParameters ; 60h
                dw offset ReadTrack     ; 61h
                dw offset VerifyTrack   ; 62h
                dw offset Cmd_Error_Proc ; 63h
                dw offset Cmd_Error_Proc ; 64h
                dw offset Cmd_Error_Proc ; 65h
                dw offset GetMediaId    ; 66h
                dw offset GetAccessFlag ; 67h
                dw offset SenseMediaType ; 68h
                dw offset Cmd_Error_Proc ; 69h
                dw offset Cmd_Error_Proc ; 6Ah
                dw offset Cmd_Error_Proc ; 6Bh
                dw offset Cmd_Error_Proc ; 6Ch
                dw offset Cmd_Error_Proc ; 6Dh
                dw offset Cmd_Error_Proc ; 6Eh
                dw offset GetDrvMapInfo ; 6Fh
IoWriteJumpTable db 9                   ; DATA XREF: BIOSCODE:0F3C↓o
                dw offset SetDeviceParameters ; 40h
                dw offset WriteTrack    ; 41h
                dw offset FormatTrack   ; 42h
                dw offset Cmd_Error_Proc ; 43h
                dw offset Cmd_Error_Proc ; 44h
                dw offset Cmd_Error_Proc ; 45h
                dw offset SetMediaId    ; 46h
                dw offset SetAccessFlag ; 47h
                dw offset SetLockState  ; 48h
                dw offset EjectMedia    ; 49h
IOC_DC_Table    db 60h, 40h, 61h, 41h, 62h, 42h, 66h, 46h, 67h, 47h, 68h
                                        ; DATA XREF: ioctl_support_query+16↓o
                db 48h, 49h, 6Fh
new_genioctl    db 0                    ; DATA XREF: BIOSCODE:0F12↓w
                                        ; BIOSCODE:0F24↓w ...
; ---------------------------------------------------------------------------

Do_Generic_IOCtl:                       ; DATA XREF: BIOSCODE:05A0↑o
                call    SetDrive        ; es:di points to bds for drive
                mov     cs:new_genioctl, 0 ; 0, old generic ioctl function
                push    es
                les     bx, ds:ptrsav   ; es:bx points to request header
                cmp     byte ptr es:[bx+0Dh], 8 ; [es:bx+IOCTL_REQ.MAJORFUNCTION],
                                        ; RAWIO
                jz      short chk_genioctl_minor
                inc     cs:new_genioctl ; 1, new generic ioctl function (FAT32)
                cmp     byte ptr es:[bx+0Dh], 48h ; Generic IOCtl Request support
                                        ; (called only if bit 6 of attribute is set to 1)

chk_genioctl_minor:                     ; CODE XREF: BIOSCODE:0F22↑j
                mov     al, es:[bx+0Eh] ; [es:bx+IOCTL_REQ.MINORFUNCTION]
                pop     es
                jnz     short IoctlFuncErr
                mov     si, offset IoReadJumpTable
                test    al, 20h         ; GEN_IOCTL_FN_TST ; test of req. function
                jnz     short NotGenericWrite
                mov     si, offset IoWriteJumpTable

NotGenericWrite:                        ; CODE XREF: BIOSCODE:0F3A↑j
                and     al, 0DFh        ; ~GEN_IOCTL_FN_TST ; get rid of read/write
                sub     al, 40h         ; offset for base function
                cmp     al, cs:[si]
                ja      short IoctlFuncErr
                cbw
                add     ax, ax
                inc     si
                add     si, ax
                call    word ptr cs:[si]
                mov     ds, cs:Bios_Data_Word
                assume ds:nothing
                mov     ah, 81h         ; Return this status in case of carry
                retn
; ---------------------------------------------------------------------------

Cmd_Error_Proc:                         ; DATA XREF: BIOSCODE:0ED1↑o
                                        ; BIOSCODE:0ED3↑o ...
                pop     dx

IoctlFuncErr:                           ; CODE XREF: BIOSCODE:0F33↑j
                                        ; BIOSCODE:0F46↑j
                jmp     bc_cmderr
; ---------------------------------------------------------------------------

GetDeviceParameters:                    ; DATA XREF: BIOSCODE:0ECB↑o
                lds     bx, ds:ptrsav   ; ds:bx points to request header
                assume ds:nothing
                lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
                                        ; (ds:bx) = return buffer
                mov     al, es:[di+3Eh] ; [es:di+BDS.formfactor]
                mov     [bx+1], al      ; [bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
                mov     ax, es:[di+3Fh] ; [es:di+BDS.flags]
                and     ax, 3           ; fnon_removable+fchangeline
                                        ; Mask off other bits
                mov     [bx+2], ax      ; [bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
                mov     ax, es:[di+41h] ; [es:di+BDS.cylinders]
                mov     [bx+4], ax      ; [bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
                xor     al, al          ; Set media type to default
                mov     [bx+6], al      ; [bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
                lea     si, [di+43h]    ; [di+BDS.rbytespersec] = [di+BDS.R_BPB]
                                        ; (copy recommended bpb)
                test    byte ptr [bx], 1 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
                                        ; BUILD_DEVICE_BPB
                jz      short UseBpbPresent
                push    ds
                mov     ds, cs:Bios_Data_Word ; Point back to BIOSDATA
                assume ds:nothing
                call    checksingle
                call    GetBp           ; Build the bpb from scratch
                pop     ds
                assume ds:nothing
                jb      short GetParmRet
                lea     si, [di+6]      ; [di+BDS.bytespersec] = [di+BSD.DP_BPB]
                                        ; Use this subfield of bds instead

UseBpbPresent:                          ; CODE XREF: BIOSCODE:0F87↑j
                lea     di, [bx+7]      ; [bx+A_DEVICEPARAMETERS.DP_BPB]
                                        ; This is where the result goes
                xor     dx, dx
                mov     cx, 31          ; A_BPB.size = 31
                cmp     cs:new_genioctl, dl
                jz      short gdp_1     ; old type (FAT12 & FAT16) structure
                mov     cx, 53          ; FAT32 BPB size
                mov     dx, 32          ; 53+32 = 85 bytes (A_BPB_FAT32.size)

gdp_1:                                  ; CODE XREF: BIOSCODE:0FA8↑j
                push    ds              ; reverse segments for copy
                push    es
                pop     ds
                pop     es
                rep movsb
                mov     cx, dx          ; 0 or 32
                jcxz    short gdp_2
                xor     al, al          ; 32 zeros
                rep stosb

gdp_2:                                  ; CODE XREF: BIOSCODE:0FB8↑j
                clc

GetParmRet:                             ; CODE XREF: BIOSCODE:0F96↑j
                retn
; ---------------------------------------------------------------------------

SetDeviceParameters:                    ; DATA XREF: BIOSCODE:0EEC↑o
                lds     bx, ds:ptrsav   ; ds:bx points to request header
                lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
                or      word ptr es:[di+3Fh], 140h ; [es:di+BDS.flags],
                                        ;  fchanged_by_format|fchanged
                test    byte ptr [bx], 2 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
                                        ;  ONLY_SET_TRACKLAYOUT
                jz      short sdp_1
                jmp     setTrackTable
; ---------------------------------------------------------------------------

sdp_1:                                  ; CODE XREF: BIOSCODE:0FD0↑j
                mov     al, [bx+1]      ; [bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
                mov     es:[di+3Eh], al ; [es:di+BDS.formfactor]
                mov     ax, [bx+4]      ; [bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
                mov     es:[di+41h], ax ; [es:di+BDS.cylinders]
                mov     ax, [bx+2]      ; [bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
                push    ds
                mov     ds, cs:Bios_Data_Word ; BIOSDATA segment
                assume ds:nothing
                cmp     ds:fhave96, 0
                pop     ds
                assume ds:nothing
                jnz     short HaveChange ; we have changeline support
                and     ax, 0FFFDh

HaveChange:                             ; CODE XREF: BIOSCODE:0FF2↑j
                and     ax, 3           ; Ignore all bits except non_removable and changeline
                                        ; fnon_removable|fchangeline
                mov     cx, es:[di+3Fh] ; [es:di+BDS.flags]
                and     cx, 0FDF4h      ; ~(fnon_removable|fchangeline|good_tracklayout|unformatted_media)
                or      ax, cx
                mov     es:[di+3Fh], ax ; [es:di+BDS.flags]
                mov     al, [bx+6]      ; [bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
                                        ; Set media type
                push    ds
                mov     ds, cs:Bios_Data_Word
                assume ds:nothing
                mov     ds:mediatype, al
                mov     cx, 53          ; FAT32 BPB size
                cmp     cs:new_genioctl, 0
                jnz     short sdp_2     ; new type (FAT32) structure
                mov     cx, 31          ; A_BPB.size = 31

sdp_2:                                  ; CODE XREF: BIOSCODE:101D↑j
                pop     ds
                assume ds:nothing
                or      word ptr es:[di+3Fh], 80h ; [es:di+BDS.flags],
                                        ; set_dasd_true (the next time we format a track)
                push    di
                test    byte ptr [bx], 1 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
                                        ;  INSTALL_FAKE_BPB
                jnz     short InstallFakeBpb
                test    word ptr es:[di+3Fh], 4 ; [es:di+BDS.flags], return_fake_bpb
                                        ; were we returning a fake bpb when asked to build a bpb?
                jz      short InstallRecommendedBpb
                and     word ptr es:[di+3Fh], 0FFFBh ; [es:di+BDS.flags], ~return_fake_bpb
                                        ; we were returning a fake bpb but we can stop now

InstallRecommendedBpb:                  ; CODE XREF: BIOSCODE:1035↑j
                lea     di, [di+43h]    ; [di+BDS.R_BPB] = [di+BDS.rbytespersec]
                jmp     short CopyTheBpb
; ---------------------------------------------------------------------------

InstallFakeBpb:                         ; CODE XREF: BIOSCODE:102D↑j
                or      word ptr es:[di+3Fh], 4 ; byte [es:di+BDS.flags], return_fake_bpb
                lea     di, [di+6]      ; [es:di+BDS.BPB] = [es:di+BDS.bytespersec]

CopyTheBpb:                             ; CODE XREF: BIOSCODE:103F↑j
                lea     si, [bx+7]      ; [bx+A_DEVICEPARAMETERS.DP_BPB]
                rep movsb
                push    ds              ; Save packet segment
                mov     ds, cs:Bios_Data_Word ; BIOSDATA segment
                assume ds:nothing
                call    RestoreOldDpt
                pop     ds
                assume ds:nothing
                pop     di

setTrackTable:                          ; CODE XREF: BIOSCODE:0FD2↑j
                mov     cx, [bx+5Ch]    ; [bx+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]
                                        ; offset 85+7 (A_BPB.size+7) (FAT32)
                cmp     cs:new_genioctl, 0
                jnz     short sdp_3     ; new type (FAT32) structure
                mov     cx, [bx+26h]    ; [bx+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]
                                        ; offset 31+7 (A_BPB.size+7)

sdp_3:                                  ; CODE XREF: BIOSCODE:1062↑j
                push    ds
                mov     ds, cs:Bios_Data_Word
                assume ds:nothing
                mov     ds:sectorspertrack, cx
                pop     ds
                assume ds:nothing
                and     word ptr es:[di+3Fh], 0FFF7h ; [es:di+BDS.flags], ~good_tracklayout
                test    byte ptr [bx], 4 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
                                        ;  TRACKLAYOUT_IS_GOOD
                jz      short UglyTrackLayOut
                or      word ptr es:[di+3Fh], 8 ; [es:di+BDS.flags], good_tracklayout

UglyTrackLayOut:                        ; CODE XREF: BIOSCODE:107A↑j
                cmp     cx, 63          ; MAX_SECTORS_IN_TRACK
                ja      short TooManyPerTrack
                jcxz    short SectorInfoSaved
                mov     di, offset tracktable
                lea     si, [bx+5Eh]    ; [bx+A_DEVICEPARAMETERS.DP_SECTORTABLE]
                                        ; offset 85+9 (A_BPB.size+9) (FAT32)
                cmp     cs:new_genioctl, 0
                jnz     short sdp_4     ; new type (FAT32) structure
                lea     si, [bx+28h]    ; [bx+A_DEVICEPARAMETERS.DP_SECTORTABLE]
                                        ; offset 31+9 (A_BPB.size+9)

sdp_4:                                  ; CODE XREF: BIOSCODE:1094↑j
                mov     es, cs:Bios_Data_Word ; BIOSDATA segment
                                        ; Trash our bds pointer
                assume es:nothing

StoreSectorInfo:                        ; CODE XREF: BIOSCODE:10AF↓j
                inc     di
                inc     di              ; Skip over cylinder and head
                lodsw                   ; Get sector id
                stosb                   ; Copy it
                lodsw                   ; Get sector size
                                        ;
                                        ; SectSizeToSectIndex:
                                        ;     Input:  ax contains sector size in bytes
                                        ;     Output: al contains index
                cmp     ah, 2           ; > 512 bytes per sector ?
                ja      short OneK      ; yes
                mov     al, ah          ; set index to 2 or 1 (256 bps) or 0 (128 bps)
                jmp     short sdp_5
; ---------------------------------------------------------------------------

OneK:                                   ; CODE XREF: BIOSCODE:10A6↑j
                mov     al, 3           ; 1024 bytes per sector
                                        ; set index to 3

sdp_5:                                  ; CODE XREF: BIOSCODE:10AA↑j
                stosb
                loop    StoreSectorInfo

SectorInfoSaved:                        ; CODE XREF: BIOSCODE:1086↑j
                clc
                retn
; ---------------------------------------------------------------------------

TooManyPerTrack:                        ; CODE XREF: BIOSCODE:1084↑j
                mov     al, 0Ch
                stc
                retn
; ---------------------------------------------------------------------------

FormatTrack:                            ; DATA XREF: BIOSCODE:0EF0↑o
                lds     bx, ds:ptrsav
                lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
                test    byte ptr [bx], 1 ; bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
                                        ;  STATUS_FOR_FORMAT
                jz      short DoFormatTrack
                push    ds
                mov     ds, cs:Bios_Data_Word
                assume ds:nothing
                call    SetMediaForFormat ; Also moves current Dpt to TempDpt
                pop     ds
                assume ds:nothing
                mov     [bx], al        ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
                clc
                retn
; ---------------------------------------------------------------------------

DoFormatTrack:                          ; CODE XREF: BIOSCODE:10C1↑j
                cmp     byte ptr es:[di+3Eh], 5 ; [es:di+BDS.formfactor], DEV_HARDDISK
                jnz     short DoFormatDiskette
                mov     ds, cs:Bios_Data_Word
                assume ds:nothing
                jmp     VerifyTrack
; ---------------------------------------------------------------------------

DoFormatDiskette:                       ; CODE XREF: BIOSCODE:10D6↑j
                mov     cx, [bx+1]      ; [bx+A_FORMATPACKET.FP_HEAD]
                mov     dx, [bx+3]      ; [bx+A_FORMATPACKET.FP_CYLINDER]
                test    byte ptr [bx], 2 ; [bx+A_FORMATPACKET.FP_SPECIALFUNCTIONS]
                                        ;     FP_TRACKCOUNT is only meaningful
                                        ;     when FP_SPECIALFUNCTIONS bit 1 = 1
                mov     ds, cs:Bios_Data_Word
                jz      short DoFormatDiskette_1
                jmp     VerifyTrack_Err
; ---------------------------------------------------------------------------

DoFormatDiskette_1:                     ; CODE XREF: BIOSCODE:10EE↑j
                call    SetMediaForFormat ; Also moves current Dpt to TempDpt
                cmp     al, 1
                jz      short NeedToSetDasd ; Old rom
                cmp     al, 3           ; Time out error?
                jnz     short NoSetDasd ; No,fine. (at this point, don't care
                                        ; about the illegal combination)
                jmp     short FormatFailed
; ---------------------------------------------------------------------------

NeedToSetDasd:                          ; CODE XREF: BIOSCODE:10F8↑j
                push    dx
                call    SetDasd         ; INT 13h, ah=17h
                pop     dx

NoSetDasd:                              ; CODE XREF: BIOSCODE:10FC↑j
                call    checksingle     ; Do any needed diskette swapping
                mov     ax, dx          ; Get track from packet
                mov     ds:trknum, ax
                mov     ds:hdnum, cl
                mov     ah, cl
                mov     bx, offset tracktable
                mov     cx, ds:sectorspertrack
                jcxz    short set_fmt_retry_count

StoreCylinderHead:                      ; CODE XREF: BIOSCODE:1121↓j
                mov     [bx], ax        ; Store into TrackTable
                add     bx, 4           ; Skip to next sector field
                loop    StoreCylinderHead

set_fmt_retry_count:                    ; CODE XREF: BIOSCODE:111A↑j
                mov     cl, 5           ; MAXERR - Set up retry count

FormatRetry:                            ; CODE XREF: BIOSCODE:1166↓j
                push    cx              ; Now verify the sectors just formatted.
                                        ; NOTE: because of bug in some BIOSes
                                        ;       we have to set ES:BX to 00:00
                mov     bx, offset tracktable
                mov     al, byte ptr ds:sectorspertrack
                mov     ah, 5           ; romformat
                mov     ds:xfer_seg, ds
                call    ToRom
                pop     cx
                jb      short FormatError
                push    cx
                push    bx
                xor     bx, bx
                mov     ds:xfer_seg, bx
                mov     al, byte ptr ds:sectorspertrack
                mov     ah, 4           ; romverify
                mov     cl, 1
                call    ToRom
                pop     bx
                pop     cx
                jnb     short FormatOk

FormatError:                            ; CODE XREF: BIOSCODE:1136↑j
                call    ResetDisk
                mov     ds:had_format_error, 1
                push    ax
                push    cx
                push    dx
                call    SetMediaForFormat
                cmp     al, 1
                jnz     short WhileErr
                call    SetDasd

WhileErr:                               ; CODE XREF: BIOSCODE:115E↑j
                pop     dx
                pop     cx
                pop     ax
                loop    FormatRetry

FormatFailed:                           ; CODE XREF: BIOSCODE:10FE↑j
                mov     ds:had_format_error, 1 ; Set the format error flag
                cmp     ah, 6           ; DSK_CHANGELINE_ERR
                                        ; convert change line error to time out error
                jnz     short DoMapIt
                mov     ah, 80h         ; DSK_TIMEOUT_ERR

DoMapIt:                                ; CODE XREF: BIOSCODE:1170↑j
                jmp     maperror
; ---------------------------------------------------------------------------

FormatOk:                               ; CODE XREF: BIOSCODE:114C↑j
                mov     ds:had_format_error, 0 ; reset the format error flag
                retn
; ---------------------------------------------------------------------------

VerifyTrack:                            ; CODE XREF: BIOSCODE:10DD↑j
                                        ; DATA XREF: BIOSCODE:0ECF↑o
                push    ds
                lds     bx, ds:ptrsav   ; ds:bx points to request header.
                assume ds:nothing
                lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
                mov     cx, [bx+3]      ; [bx+A_VERIFYPACKET.VP_CYLINDER]
                mov     ax, [bx+1]      ; [bx+A_VERIFYPACKET.VP_HEAD]
                mov     dx, [bx+5]      ; [bx+A_FORMATPACKET.FP_TRACKCOUNT]
                mov     bl, [bx]        ; [bx+A_FORMATPACKET.FP_SPECIALFUNCTIONS]
                pop     ds
                mov     ds:rflag, 4     ; romverify
                mov     ds:curtrk, cx
                mov     ds:curhd, al    ; assume heads < 256
                mov     cx, ds:sectorspertrack
                test    bl, 2           ; DO_FAST_FORMAT
                jz      short NormVerifyTrack
                mov     ax, dx          ; Get ax = number of trks to verify
                or      ah, ah
                jnz     short VerifyTrack_Err ; #tracks > 255
                mul     cl
                or      ah, ah
                jnz     short VerifyTrack_Err
                mov     cx, ax
                test    word ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
                jz      short NormVerifyTrack
                test    ds:multrk_flag, 80h ; MULTI_TRK_ON
                jz      short NormVerifyTrack
                mov     ds:multitrk_format_flag, 1

NormVerifyTrack:                        ; CODE XREF: BIOSCODE:11A4↑j
                                        ; BIOSCODE:11BA↑j ...
                xor     ax, ax          ; 1st sector
                xor     bx, bx
                mov     ds:xfer_seg, bx ; Use 0:0 as the transfer address for verify
                call    TrackIo
                mov     ds:multitrk_format_flag, 0
                retn
; ---------------------------------------------------------------------------

VerifyTrack_Err:                        ; CODE XREF: BIOSCODE:10F0↑j
                                        ; BIOSCODE:11AA↑j ...
                mov     ah, 1
                jmp     maperror
; ---------------------------------------------------------------------------

ReadTrack:                              ; DATA XREF: BIOSCODE:0ECD↑o
                mov     ds:rflag, 2     ; romread
                jmp     short ReadWriteTrack
; ---------------------------------------------------------------------------

WriteTrack:                             ; DATA XREF: BIOSCODE:0EEE↑o
                mov     ds:rflag, 3

ReadWriteTrack:                         ; CODE XREF: BIOSCODE:11E4↑j
                push    es
                les     bx, ds:ptrsav   ; es:bx -> to request header
                assume es:nothing
                les     bx, es:[bx+13h] ; [es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
                mov     ax, es:[bx+3]   ; [es:bx+A_TRACKREADWRITEPACKET.TRWP_CYLINDER]
                mov     ds:curtrk, ax
                mov     ax, es:[bx+1]   ; [es:bx+A_TRACKREADWRITEPACKET.TRWP_HEAD]
                mov     ds:curhd, al    ; Assume heads < 256 !
                mov     ax, es:[bx+5]   ; [es:bx+A_TRACKREADWRITEPACKET.TRWP_FIRSTSECTOR]
                mov     cx, es:[bx+7]   ; [es:bx+A_TRACKREADWRITEPACKET.TRWP_SECTORSTOREADWRITE]
                les     bx, es:[bx+9]   ; [es:bx+A_TRACKREADWRITEPACKET.TRWP_TRANSFERADDRESS]
                                        ; Get transfer address
                mov     ds:xfer_seg, es ; Pass transfer segment
                pop     es

; =============== S U B R O U T I N E =======================================


TrackIo         proc near               ; CODE XREF: BIOSCODE:11D1↑p
                mov     ds:spsav, sp    ; performs track read/write/verify
                                        ;
                                        ;  input:
                                        ;   rFlag - 2 = read
                                        ;           3 = write
                                        ;           4 = verify
                                        ;   ax - Index into track table of first sector to io
                                        ;   cx - Number of sectors to io
                                        ;   Xfer_Seg:bx - Transfer address
                                        ;   es:di - Pointer to bds
                                        ;   CurTrk - Current cylinder
                                        ;   CurHd - Current head
                call    checksingle
                cmp     ds:media_set_for_format, 1 ; See if we have already set disk
                jz      short Dptalreadyset
                push    ax              ; set up tables and variables for i/o
                push    cx
                call    iosetup
                pop     cx
                pop     ax

Dptalreadyset:                          ; CODE XREF: TrackIo+C↑j
                mov     si, offset tracktable ; Point si at the table entry of the
                                        ; first sector to be io'd
                add     ax, ax
                add     ax, ax
                add     si, ax
                mov     dx, 1
                test    word ptr es:[di+3Fh], 8 ; [es:di+BDS.flags], good_tracklayout
                jz      short ionextsector
                xchg    dx, cx          ; We can read all secs in one blow

ionextsector:                           ; CODE XREF: TrackIo+27↑j
                                        ; TrackIo+7A↓j
                push    cx
                push    dx
                inc     si
                inc     si              ; Skip over the cylinder and head in
                                        ; the track table
                lodsb                   ; Get sector ID from track table
                mov     ds:cursec, al
                test    word ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
                                        ; Fixed disk?
                jz      short IoRemovable ; No
                test    ds:multrk_flag, 80h ; MULTI_TRK_ON
                jz      short IoRemovable ; No,don't do that.
                mov     ds:seccnt, dx
                mov     ax, dx
                call    disk
                pop     dx
                pop     cx
                clc
                retn
; ---------------------------------------------------------------------------

IoRemovable:                            ; CODE XREF: TrackIo+39↑j
                                        ; TrackIo+41↑j
                lodsb                   ; Get sector size index from track
                                        ; table and save it
                push    ax
                push    si
                push    ds              ; Save BIOSDATA
                push    ax
                mov     ah, ds:eot      ; Preserve whatever might be in ah
                                        ; Fetch EOT while ds-> BIOSDATA
                lds     si, ds:dpt
                mov     [si+3], al      ; [si+DISK_PARMS.DISK_SECTOR_SIZ]
                mov     [si+4], ah      ; [si+DISK_PARMS.DISK_EOT]
                pop     ax
                pop     ds
                mov     al, dl
                mov     ds:seccnt, ax
                call    disk
                pop     si              ; Advance buffer pointer by adding
                                        ; sector size
                pop     ax
                mov     cl, al          ; SectorSizeIndexToSectorSize
                mov     ax, 80h
                shl     ax, cl
                add     bx, ax
                pop     dx
                pop     cx
                loop    ionextsector
                cmp     ds:media_set_for_format, 1
                jz      short NoNeedDone
                call    done            ; set time of last access, and reset
                                        ; entries in Dpt.

NoNeedDone:                             ; CODE XREF: TrackIo+81↑j
                clc
                retn
TrackIo         endp


; =============== S U B R O U T I N E =======================================


SetDasd         proc near               ; CODE XREF: BIOSCODE:1101↑p
                                        ; BIOSCODE:1160↑p
                cmp     ds:had_format_error, 1 ; See if we've previously set dasd type
                jz      short DoSetDasd
                test    word ptr es:[di+3Fh], 80h ; [es:di+BDS.flags], set_dasd_true
                jz      short DasdHasBeenSet
                and     word ptr es:[di+3Fh], 0FF7Fh ; [es:di+BDS.flags], ~set_dasd_true

DoSetDasd:                              ; CODE XREF: SetDasd+5↑j
                mov     ds:had_format_error, 0 ; Reset it
                mov     ds:gap_patch, 50h ; Format gap for 48tpi disks
                mov     al, 4
                mov     ah, es:[di+3Eh] ; [es:di+BDS.formfactor]
                cmp     ah, 2           ; DEV_3INCH720KB
                jz      short DoSet
                cmp     ah, 1           ; DEV_5INCH96TPI
                mov     al, 1
                jnz     short DoSet
                inc     ax              ; mov al, 2
                                        ; 160/320k in a 1.2 meg drive
                cmp     ds:mediatype, 0
                jnz     short DoSet
                inc     ax              ; mov al, 3
                                        ; 1.2meg in a 1.2meg drive
                mov     ds:gap_patch, 54h ; Format gap for 96 tpi, 1.2MB diskette

DoSet:                                  ; CODE XREF: SetDasd+28↑j
                                        ; SetDasd+2F↑j ...
                push    ds
                push    si
                xor     si, si
                mov     ds, si          ; 0
                assume ds:nothing
                lds     si, dword ptr ds:78h ; [DSKADR] (Int 1Eh)
                assume ds:nothing
                mov     byte ptr [si+9], 0Fh ; [si+DISK_PARMS.DISK_HEAD_STTL]
                pop     si
                pop     ds
                mov     ah, 17h
                mov     dl, es:[di+4]
                int     13h             ; DISK - SET TYPE (AT,XT2,XT286,CONV,PS
                                        ; AL = disk type

DasdHasBeenSet:                         ; CODE XREF: SetDasd+D↑j
                mov     ah, es:[di+13h] ; [es:di+BDS.secpertrack]
                mov     ds:formt_eot, ah
                retn
SetDasd         endp


; =============== S U B R O U T I N E =======================================


SetMediaForFormat proc near             ; CODE XREF: BIOSCODE:10C9↑p
                                        ; BIOSCODE:DoFormatDiskette_1↑p ...
                push    cx
                push    dx
                cmp     ds:had_format_error, 1
                jz      short SkipSaveDskAdr
                xor     al, al          ; If already done return 0
                cmp     ds:media_set_for_format, 1
                jnz     short DoSetMediaForFormat
                jmp     SetMediaRet     ; Media already set
; ---------------------------------------------------------------------------

DoSetMediaForFormat:                    ; CODE XREF: SetMediaForFormat+10↑j
                push    es
                push    si
                xor     si, si
                mov     es, si          ; 0 ; Point to interrupt vectors
                assume es:nothing
                les     si, dword ptr es:78h ; [es:DSKADR]
                                        ; Get pointer to disk base table
                assume es:nothing
                mov     word ptr ds:dpt, si
                mov     word ptr ds:dpt+2, es
                mov     byte ptr es:[si+9], 0Fh ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
                pop     si
                pop     es

SkipSaveDskAdr:                         ; CODE XREF: SetMediaForFormat+7↑j
                mov     cx, es:[di+41h] ; [es:di+BDS.cylinders]
                dec     cx
                and     ch, 3
                ror     ch, 1
                ror     ch, 1
                xchg    ch, cl
                or      cl, es:[di+13h] ; [es:di+BDS.secpertrack]
                mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
                push    es
                push    ds
                push    si
                push    di
                mov     ah, 18h
                int     13h             ; DISK - SET MEDIA TYPE FOR FORMAT (AT model 3x9,XT2,XT286,PS)
                                        ; DL = drive number, CH = lower 8 bits of number of tracks,
                                        ; CL = sectors per track
                jb      short FormaStatErr
                cmp     ds:had_format_error, 1
                jz      short skip_disk_base_setting
                push    es
                xor     si, si
                mov     es, si
                assume es:nothing
                les     si, dword ptr es:78h ; [es:DSKADR] (Int 1Eh)
                                        ; Get current disk base table
                assume es:nothing
                mov     word ptr ds:tempdpt, si
                mov     word ptr ds:tempdpt+2, es ; Save it
                xor     si, si
                mov     es, si          ; 0
                assume es:nothing
                mov     word ptr es:78h, di ; replace with one returned by rom
                pop     word ptr es:78h+2
                mov     ds:media_set_for_format, 1

skip_disk_base_setting:                 ; CODE XREF: SetMediaForFormat+54↑j
                xor     al, al          ; Legal combination + rom support code
                mov     ds:had_format_error, al ; Reset the flag
                jmp     short PopStatRet
; ---------------------------------------------------------------------------

FormaStatErr:                           ; CODE XREF: SetMediaForFormat+4D↑j
                cmp     ah, 0Ch         ; DSK_ILLEGAL_COMBINATION
                                        ; Illegal combination = 0Ch
                jz      short FormatStatIllegalComb
                cmp     ah, 80h         ; DSK_TIMEOUT_ERR
                jz      short FormatStatTimeOut
                mov     al, 1           ; Function not supported.
                jmp     short PopStatRet
; ---------------------------------------------------------------------------

FormatStatIllegalComb:                  ; CODE XREF: SetMediaForFormat+85↑j
                mov     al, 2           ; Function supported, but
                                        ; Illegal sect/trk,trk combination.
                jmp     short PopStatRet
; ---------------------------------------------------------------------------

FormatStatTimeOut:                      ; CODE XREF: SetMediaForFormat+8A↑j
                mov     al, 3           ; Function supported, but
                                        ; Media not present

PopStatRet:                             ; CODE XREF: SetMediaForFormat+80↑j
                                        ; SetMediaForFormat+8E↑j ...
                pop     di
                pop     si
                pop     ds
                pop     es
                assume es:nothing

SetMediaRet:                            ; CODE XREF: SetMediaForFormat+12↑j
                pop     dx
                pop     cx
                retn
SetMediaForFormat endp


; =============== S U B R O U T I N E =======================================


ResetDisk       proc near               ; CODE XREF: diskio+120↑p
                                        ; disk+E6↑p ...
                push    ax
                mov     ax, 1           ; Reset while formatting?
                cmp     ds:media_set_for_format, al
                jnz     short ResetDisk_cont
                mov     ds:had_format_error, al ; Then verify operation in "fmt & vrfy"
                                        ; Might have failed.
                                        ; So signals that we had a format error.

ResetDisk_cont:                         ; CODE XREF: ResetDisk+8↑j
                int     13h             ; DISK - RESET DISK SYSTEM
                                        ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
                mov     ds:step_drv, 0FFh ; -1
                                        ; Zap up the speed
                pop     ax
                retn
ResetDisk       endp


; =============== S U B R O U T I N E =======================================


ToRom           proc near               ; CODE XREF: BIOSCODE:1132↑p
                                        ; BIOSCODE:1147↑p
                push    bx
                push    si
                test    ds:media_set_for_format, 1
                jnz     short GotValidDpt
                push    ax
                push    es              ; Save bds segment
                cmp     byte ptr es:[di+3Eh], 2 ; [es:di+BDS.formfactor], ffSmall
                                        ; is it a 3.5" drive?
                mov     es, ds:zeroseg  ; 0
                assume es:nothing
                les     si, dword ptr es:78h ; Get pointer to disk base table
                assume es:nothing
                mov     word ptr ds:dpt, si ; Save pointer to table
                mov     word ptr ds:dpt+2, es
                mov     al, ds:formt_eot
                mov     es:[si+4], al   ; [es:si+DISK_PARMS.DISK_EOT]
                mov     al, ds:gap_patch
                mov     es:[si+7], al   ; [es:si+DISK_PARMS.DISK_FORMT_GAP]
                                        ; Important for format
                mov     byte ptr es:[si+9], 0Fh ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
                                        ; Assume we are doing a seek operation
                                        ; Setup motor start correctly for 3.5" drives
                jnz     short MotorStrtOK
                mov     byte ptr es:[si+0Ah], 4 ; [es:si+DISK_PARMS.DISK_MOTOR_STRT]

MotorStrtOK:                            ; CODE XREF: ToRom+34↑j
                pop     es              ; Restore bds segment
                pop     ax

GotValidDpt:                            ; CODE XREF: ToRom+7↑j
                mov     dx, ds:trknum   ; Set track number
                mov     ch, dl          ; Set low 8 bits in ch
                mov     dl, es:[di+4]   ; Set drive number
                mov     dh, ds:hdnum    ; Set head number
                push    es              ; Save bds segment
                mov     es, ds:xfer_seg
                int     13h             ; DISK -
                pop     es              ; Restore bds segment
                pop     si
                pop     bx
                retn
ToRom           endp


; =============== S U B R O U T I N E =======================================


ioctl_getown    proc near               ; DATA XREF: BIOSCODE:05A8↑o
                call    SetDrive
                mov     al, es:[di+4]   ; [es:di+BDS.drivenum]
                                        ; Get physical drive number
                les     di, dword ptr ds:start_bds ; Get start of bds chain

ownloop:                                ; CODE XREF: ioctl_getown+1C↓j
                cmp     es:[di+4], al   ; [es:di+BDS.drivenum]
                jnz     short getnextBDS
                test    word ptr es:[di+3Fh], 20h ; [es:di+BDS.flags], fi_own_physical
                jnz     short exitown

getnextBDS:                             ; CODE XREF: ioctl_getown+F↑j
                les     di, es:[di]     ; [es:di+BDS.link]
                jmp     short ownloop
; ---------------------------------------------------------------------------

ioctl_setown:                           ; DATA XREF: BIOSCODE:05AA↑o
                call    SetDrive
                mov     ds:fsetowner, 1 ; set flag for CheckSingle to look at.
                call    checksingle
                dec     ds:fsetowner    ; 0 ; set ownership of drive reset flag

exitown:                                ; CODE XREF: ioctl_getown+17↑j
                xor     cl, cl
                test    word ptr es:[di+3Fh], 10h ; [es:di+BDS.flags], fi_am_mult
                jz      short ExitNoMult
                mov     cl, es:[di+5]   ; [es:di+BDS.drivelet]
                                        ; Get logical drive number
                inc     cx              ; Get it 1-based

ExitNoMult:                             ; CODE XREF: ioctl_getown+35↑j
                lds     bx, ds:ptrsav
                mov     [bx+1], cl      ; [bx+unit]
                                        ; Exit normal termination
                clc
                retn
ioctl_getown    endp


; =============== S U B R O U T I N E =======================================


RestoreOldDpt   proc near               ; CODE XREF: BIOSCODE:1054↑p
                push    ax
                xor     al, al
                mov     ds:had_format_error, al ; Reset flag and
                xchg    al, ds:media_set_for_format ; get current flag setting
                or      al, al
                jz      short DontRestore
                push    si
                push    ds
                push    es
                lds     si, ds:tempdpt
                mov     es, cs:Bios_Data_Word
                assume es:nothing
                mov     es, es:zeroseg  ; es = 0
                assume es:nothing
                mov     word ptr es:78h, si ; [es:DSKADR] (Int 1Eh)
                mov     word ptr es:78h+2, ds ; [es:DSKADR+2]
                pop     es
                assume es:nothing
                pop     ds
                pop     si

DontRestore:                            ; CODE XREF: RestoreOldDpt+C↑j
                pop     ax
                clc
                retn
RestoreOldDpt   endp


; =============== S U B R O U T I N E =======================================


GetMediaId      proc near               ; DATA XREF: BIOSCODE:0ED7↑o
                call    ChangeLineChk   ; get volume serial number
                mov     al, es:[di+5]   ; [es:di+BDS.drivelet] ; Logical drive number
                mov     ds:rflag, 2     ; Read operation
                call    BootIo          ; Read boot sector into DiskSector
                jb      short IOCtl_If1
                cmp     ds:disksector+15h, 0F0h ; Valid? (0F0h-0FFh?)
                jb      short IOCtl_If2 ; brif not valid (0F0h - 0FFh)
                mov     si, (offset disksector+43h) ; BS_FAT32_VolID
                cmp     word ptr ds:disksector+16h, 0 ; BPB.FATSz16
                jz      short IOCtl_If3 ; FAT32 fs
                sub     si, 1Ch         ; FAT (12-16) fs ; 43h-1Ch = 27h ; BS_VolID

IOCtl_If3:                              ; CODE XREF: GetMediaId+20↑j
                cmp     byte ptr [si-1], 29h ; si-1 = offset disksector+26h (FAT)
                                        ;       or  = offset disksector+42h (FAT32)
                                        ;             disksector+EXT_BOOT.SIG
                                        ; BS_BootSig
                jnz     short IOCtl_If2
                les     di, ds:ptrsav
                les     di, es:[bx+19]  ; [es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
                add     di, 2           ; A_MEDIA_ID_INFO.MI_SERIAL

IOCtl_If4:                              ; CODE XREF: BIOSCODE:14FA↓p
                mov     cx, 23          ; size_of_EXT_BOOT_SERIAL
                                        ; + size_of_EXT_BOOT_VOL_LABEL
                                        ; + size_of_EXT_SYSTEM_ID
                rep movsb
                clc
                retn
; ---------------------------------------------------------------------------

IOCtl_If2:                              ; CODE XREF: GetMediaId+16↑j
                                        ; GetMediaId+29↑j
                mov     al, 7
                stc

IOCtl_If1:                              ; CODE XREF: GetMediaId+F↑j
                retn
GetMediaId      endp

; ---------------------------------------------------------------------------

SetMediaId:                             ; DATA XREF: BIOSCODE:0EF8↑o
                call    ChangeLineChk
                mov     al, es:[di+5]   ; [es:di+BDS.drivelet]
                                        ; Logical drive number
                mov     dl, al
                mov     ds:rflag, 2     ; romread
                push    dx
                call    BootIo          ; Read boot sector to BIOSDATA:DiskSector
                pop     dx
                jb      short IOCtl_If6
                cmp     ds:disksector+15h, 0F0h ; Valid? (0F0h-0FFh?)
                                        ; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
                jb      short IOCtl_If7 ; Brif not
                push    es
                push    di
                push    ds
                pop     es
                mov     di, (offset disksector+43h) ; disksector+EXT_BOOT.SERIAL
                cmp     word ptr ds:disksector+16h, 0 ; BPB.FATSz16
                jz      short IOCtl_If5 ; FAT32 fs
                sub     di, 1Ch         ; 67-28 ; offset disksektor+27h

IOCtl_If5:                              ; CODE XREF: BIOSCODE:14E1↑j
                cmp     byte ptr [di-1], 29h ; [disksector+EXT_BOOT.SIG], EXT_BOOT_SIGNATURE
                jz      short IOCtl_If8
                pop     di              ; not extended boot record
                pop     es
                jmp     short IOCtl_If7
; ---------------------------------------------------------------------------

IOCtl_If8:                              ; CODE XREF: BIOSCODE:14EA↑j
                lds     si, ds:ptrsav
                lds     si, [si+13h]    ; [si+IOCTL_REQ.GENERICIOCTL_PACKET]
                add     si, 2           ; A_MEDIA_ID_INFO.MI_SERIAL
                call    IOCtl_If4       ; copy volume serial, label and system id
                push    es              ; point ds back to BIOSDATA
                pop     ds
                pop     di              ; restore bds pointer
                pop     es
                call    mov_media_ids   ; update the bds media id info.
                mov     al, dl
                mov     ds:rflag, 3     ; romwrite
                call    BootIo          ; write it back
                mov     ds:tim_drv, 0FFh ; make sure chk_media check the driver
                                        ; return with error code from BootIo
                retn
; ---------------------------------------------------------------------------

IOCtl_If7:                              ; CODE XREF: BIOSCODE:14D3↑j
                                        ; BIOSCODE:14EE↑j
                mov     al, 7           ; error_unknown_media
                stc

IOCtl_If6:                              ; CODE XREF: BIOSCODE:14CC↑j
                retn

; =============== S U B R O U T I N E =======================================


BootIo          proc near               ; CODE XREF: GetMediaId+C↑p
                                        ; BIOSCODE:14C8↑p ...
                push    es
                push    di
                push    bx
                push    ds
                pop     es
                mov     di, offset disksector ; es:di -> transfer address
                xor     dx, dx          ; First sector (h) -> 0
                mov     ds:start_sec_h, dx ; Start sector (h) -> 0
                mov     cx, 1
                call    diskio
                pop     bx
                pop     di
                pop     es
                retn
BootIo          endp


; =============== S U B R O U T I N E =======================================


ChangeLineChk   proc near               ; CODE XREF: GetMediaId↑p
                                        ; BIOSCODE:SetMediaId↑p
                mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
                or      dl, dl          ; Fixed disk?
                js      short ChangeLnChkRet
                test    word ptr es:[di+3Fh], 4 ; [es:di+BDS.flags], return_fake_bpb
                jnz     short ChangeLnChkRet
                cmp     ds:fhave96, 1   ; This rom support change line?
                jnz     short ChangeLnChkRet ; no
                call    haschange
                jz      short ChangeLnChkRet ; Do nothing
                mov     ah, 16h
                int     13h             ; DISK - FLOPPY DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
                                        ; DL = drive to check
                                        ; Return: AH = disk change status
                jnb     short ChangeLnChkRet
                push    bx
                mov     bx, 40h         ; fchanged
                                        ; Update flag in BDS for this physical drive
                call    Set_Changed_DL
                pop     bx

ChangeLnChkRet:                         ; CODE XREF: ChangeLineChk+6↑j
                                        ; ChangeLineChk+E↑j ...
                retn
ChangeLineChk   endp


; =============== S U B R O U T I N E =======================================


GetAccessFlag   proc near               ; DATA XREF: BIOSCODE:0ED9↑o
                lds     bx, ds:ptrsav   ; ds:bx points to request header
                lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
                mov     al, 0           ; Assume result is unformatted
                test    word ptr es:[di+3Fh], 200h ; [es:di+BDS.flags], unformatted_media
                jnz     short GafDone   ; Done if unformatted
                inc     ax              ; Return true for formatted

GafDone:                                ; CODE XREF: GetAccessFlag+F↑j
                mov     [bx+1], al      ; [bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]
                retn
GetAccessFlag   endp


; =============== S U B R O U T I N E =======================================


SetAccessFlag   proc near               ; DATA XREF: BIOSCODE:0EFA↑o
                lds     bx, ds:ptrsav   ; ds:bx points to request header
                lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
                and     word ptr es:[di+3Fh], 0FDFFh ; [es:di+BDS.flags], ~unformatted_media
                cmp     byte ptr [bx+1], 0 ; [bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]
                jnz     short saf_Done
                or      word ptr es:[di+3Fh], 200h ; [es:di+BDS.flags], unformatted_media

saf_Done:                               ; CODE XREF: SetAccessFlag+11↑j
                retn
SetAccessFlag   endp


; =============== S U B R O U T I N E =======================================


ioctl_support_query proc near           ; DATA XREF: BIOSCODE:05AC↑o
                push    es
                les     bx, ds:ptrsav   ; es:bx points to request header.
                mov     ax, es:[bx+0Dh] ; [es:bx+IOCTL_REQ.MAJORFUNCTION]
                                        ; al == Major, ah == Minor
                cmp     al, 48h         ; IOC_NEW_DC
                                        ; new generic ioctl function (FAT32)
                jz      short ioctl_support
                cmp     al, 8           ; IOC_DC
                                        ; (old) generic ioctl function (FAT12-FAT16)
                jnz     short nosupport

ioctl_support:                          ; CODE XREF: ioctl_support_query+B↑j
                push    cs
                pop     es
                assume es:BIOSCODE
                mov     cx, 14          ; IOC_DC_TABLE_LEN
                mov     di, offset IOC_DC_Table
                xchg    al, ah
                repne scasb
                jnz     short nosupport
                mov     ax, 100h
                pop     es
                assume es:nothing
                clc
                retn
; ---------------------------------------------------------------------------

nosupport:                              ; CODE XREF: ioctl_support_query+F↑j
                                        ; ioctl_support_query+1D↑j
                pop     es
                jmp     bc_cmderr
ioctl_support_query endp

; ---------------------------------------------------------------------------

SenseMediaType:                         ; DATA XREF: BIOSCODE:0EDB↑o
                lds     bx, ds:ptrsav   ; ds:bx points to request header.
                lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
                xor     dx, dx          ; 0 ; Initialize the 2 packet bytes
                mov     [bx], dx        ; invalidate drive type (byte 1)
                                        ; and default type flag (byte 0)
                mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
                mov     ah, 20h
                int     13h             ; Compaq, ATAPI Removable Media Device
                                        ; GET CURRENT MEDIA FORMAT
                                        ;   AH = 20h
                                        ;   DL = drive number (00h,01h)
                                        ; Return: CF clear if successful
                                        ;   AL = media type
                                        ;   AH = 00h
                                        ;   CF set on error
                                        ;      AH = error code
                                        ;
                                        ; (Ref: Ralf Brown's Interrupt List, INTERRUP.B)
                jb      short MediaSenseErr
                inc     byte ptr [bx]   ; [bx+A_MEDIA_SENSE.MS_ISDEFAULT]
                                        ; 1 = default media type

DetermineMediaType:                     ; CODE XREF: BIOSCODE:15E3↓j
                dec     al              ; 3 -> 2, 4 -> 3, 6 -> 5
                cmp     al, 2           ; 3.5 inch, 720 KB
                jz      short GotMediaType
                add     al, 4           ; 3 -> 6, 4 -> 7, 6 -> 9
                cmp     al, 7           ; 3.5 inch, 1.44 MB
                jz      short GotMediaType
                cmp     al, 9           ; 3.5 inch, 2.88 MB
                jnz     short UnknownMediaType ; Just didn't recognize media type

GotMediaType:                           ; CODE XREF: BIOSCODE:15CF↑j
                                        ; BIOSCODE:15D5↑j
                mov     [bx+1], al      ; [bx+A_MEDIA_SENSE.MS_DEVICETYPE]
                clc
                retn
; ---------------------------------------------------------------------------

MediaSenseErr:                          ; CODE XREF: BIOSCODE:15C7↑j
                cmp     ah, 32h         ; non-default media /
                                        ; drive does not support media type
                jz      short DetermineMediaType
                mov     al, 2           ; function supported but, drive not ready
                cmp     ah, 31h         ; no such drive / media not present
                jz      short SenseErrExit

UnknownMediaType:                       ; CODE XREF: BIOSCODE:15D9↑j
                mov     al, 7           ; error_unknown_media

SenseErrExit:                           ; CODE XREF: BIOSCODE:15EA↑j
                mov     ah, 81h         ; Return this status in case of carry
                stc
                retn

; =============== S U B R O U T I N E =======================================


SetLockState    proc near               ; DATA XREF: BIOSCODE:0EFC↑o
                lds     bx, ds:ptrsav   ; set media lock state
                lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
                mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
                call    check_int13h_exts_present
                mov     al, 3           ; unknown command error
                jb      short setlockst_ret
                mov     al, [bx]        ; [bx+A_LOCKSTATE_CONTROL.LOCKSTATE_FUNCTIONS]
                mov     ah, 45h
                int     13h             ; DISK - IBM/MS Extension - LOCK/UNLOCK DRIVE
                                        ; (DL - drive, DS:SI - disk address packet)
                mov     [bx+1], al      ; 1 = locked, 0 = not locked
                                        ; [bx+A_LOCKSTATE_CONTROL.LOCKSTATE_FLAG]
                jnb     short setlockst_ret
                mov     al, ah
                call    maperror

setlockst_ret:                          ; CODE XREF: SetLockState+10↑j
                                        ; SetLockState+1B↑j
                mov     ah, 81h         ; Return this status in case of carry
                retn
SetLockState    endp


; =============== S U B R O U T I N E =======================================


EjectMedia      proc near               ; DATA XREF: BIOSCODE:0EFE↑o
                mov     dl, es:[di+4]   ; eject media in drive
                                        ; [es:di+BDS.drivenum]
                call    check_int13h_exts_present
                mov     al, 3           ; unknown command error
                jb      short ejectm_ret
                mov     ax, 4600h
                int     13h             ; DISK - IBM/MS Extension - EJECT MEDIA
                                        ; (DL - drive)
                jnb     short ejectm_ret
                mov     al, ah
                call    maperror

ejectm_ret:                             ; CODE XREF: EjectMedia+9↑j
                                        ; EjectMedia+10↑j
                mov     ah, 81h         ; Return this status in case of carry
                retn
EjectMedia      endp


; =============== S U B R O U T I N E =======================================


check_int13h_exts_present proc near     ; CODE XREF: SetLockState+B↑p
                                        ; EjectMedia+4↑p
                mov     ah, 41h
                push    bx
                mov     bx, 55AAh
                int     13h             ; DISK - Check for INT 13h Extensions
                                        ; BX = 55AAh, DL = drive number
                                        ; Return: CF set if not supported
                                        ; AH = extensions version
                                        ; BX = AA55h
                                        ; CX = Interface support bit map
                cmp     bx, 0AA55h
                pop     bx
                jnz     short exts_notsupported
                test    cl, 2           ; bit 1 - drive locking and ejecting subset
                jnz     short exts_supported

exts_notsupported:                      ; CODE XREF: check_int13h_exts_present+D↑j
                stc

exts_supported:                         ; CODE XREF: check_int13h_exts_present+12↑j
                retn
check_int13h_exts_present endp

; ---------------------------------------------------------------------------

GetDrvMapInfo:                          ; DATA XREF: BIOSCODE:0EE9↑o
                mov     cx, ds          ; get drive map information
                                        ;
                                        ; es:di points to BDS which belongs to
                                        ;       the requested logical/dos drive number
                                        ;
                                        ; Format of parameter block:
                                        ; Offset  Description (Table 01570)
                                        ;  00h    (call) length of this buffer (in bytes)
                                        ;  01h    (ret) number of bytes in parameter block
                                        ;         actually used
                                        ;  02h    (ret) drive flags
                                        ;  03h    (ret) physical drive number
                                        ;         00h-7Fh floppy
                                        ;         80h-FEh hard
                                        ;         FFh no physical drive
                                        ;  04h    (ret) bitmap of logical drives associated with
                                        ;         physical drive
                                        ;         bit 0 = drive A:, etc.
                                        ;  08h    (ret) relative block address of partition start
                                        ;         qword
                                        ;
                                        ; Ref: Ralf Brown's Interrupt List, INTERRUP.G
                lds     bx, ds:ptrsav
                lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
                mov     ax, 8103h       ; ah = generic ioctl error code (81h)
                                        ; al = unknown command error (03h)
                cmp     byte ptr [bx], 10h ; parameter buffer length = 16 bytes
                jb      short gdmi_4
                mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
                mov     [bx+3], dl      ; parameter block - offset 3 - physical drive number
                mov     byte ptr [bx+1], 10h ; parameter block - actually used length
                mov     ax, es:[di+17h] ; [es:di+BDS.hiddensectors]
                mov     [bx+8], ax      ; parameter block - offset 8 - partition start LBA
                mov     ax, es:[di+19h] ; [es:di+BDS.hiddensectors+2]
                mov     [bx+0Ah], ax    ; parameter block - offset 10
                xor     ax, ax
                mov     [bx+2], al      ; drive flags = 0 (protected mode flags etc.)
                mov     [bx+0Ch], ax    ; high dword of partition start address (LBA) is 0
                mov     [bx+0Eh], ax
                mov     [bx+4], ax      ; logical drive bitmap of same physical drive
                                        ; initialized as 0
                mov     [bx+6], ax
                mov     es, cx
                les     di, dword ptr es:start_bds ; 1st BDS
                mov     cx, 1           ; bit 0 (drive A:)

gdmi_1:                                 ; CODE XREF: BIOSCODE:16A4↓j
                cmp     di, 0FFFFh      ; last BDS ?
                jz      short gdmi_3    ; yes
                cmp     es:[di+4], dl   ; [es:di+BDS.drivenum], dl
                                        ; is it same physical drive ?
                jnz     short gdmi_2    ; no
                or      [bx+4], cx      ; set bit for logical drive index of this BDS
                                        ; (previously) shifted bit (which is 1/ON) is in ax:cx
                or      [bx+6], ax

gdmi_2:                                 ; CODE XREF: BIOSCODE:1695↑j
                shl     cx, 1           ; shift one left for setting the next drive's bit
                rcl     ax, 1           ; set high word of the bit select (set) value
                les     di, es:[di]     ; next BDS
                jmp     short gdmi_1    ; loop until di = -1 (last BDS sign)
; ---------------------------------------------------------------------------

gdmi_3:                                 ; CODE XREF: BIOSCODE:168F↑j
                mov     ax, 100h        ; success

gdmi_4:                                 ; CODE XREF: BIOSCODE:1656↑j
                retn
; ---------------------------------------------------------------------------

i2f_handler:                            ; DATA XREF: BIOSDATA:0006↑o
                cmp     ah, 13h
                jz      short int2f_replace_int13
                cmp     ah, 8
                jz      short mine
                cmp     ah, 16h         ; MultWin386
                jz      short win386call
                cmp     ah, 4Ah         ; multMULT
                jnz     short i2f_handler_iret
                jmp     handle_multmult
; ---------------------------------------------------------------------------

i2f_handler_iret:                       ; CODE XREF: BIOSCODE:16BC↑j
                iret
; ---------------------------------------------------------------------------

int2f_replace_int13:                    ; CODE XREF: BIOSCODE:16AD↑j
                cli
                push    ax
                mov     ax, ds
                mov     ds, cs:Bios_Data_Word
                assume ds:nothing
                push    word ptr ds:Orig13+2
                push    word ptr ds:Old13+2
                xchg    dx, word ptr ds:Orig13
                mov     word ptr ds:Orig13+2, ax
                xchg    bx, word ptr ds:Old13
                mov     word ptr ds:Old13+2, es
                pop     es
                pop     ds
                assume ds:nothing
                pop     ax

i2f_iret:                               ; CODE XREF: BIOSCODE:16E8↓j
                iret
; ---------------------------------------------------------------------------

mine:                                   ; CODE XREF: BIOSCODE:16B2↑j
                cmp     al, 0F8h        ; iret on reserved functions
                jnb     short i2f_iret
                or      al, al          ; a get installed state request?
                jnz     short disp_func
                mov     al, 0FFh
                iret
; ---------------------------------------------------------------------------

disp_func:                              ; CODE XREF: BIOSCODE:16EC↑j
                cmp     al, 1           ; request for installing bds?
                jz      short do_subfun_01
                cmp     al, 3           ; get bds vector?
                jz      short do_get_bds_vector
                push    ds
                mov     ds, cs:Bios_Data_Word
                assume ds:nothing
                mov     word ptr ds:ptrsav, bx
                mov     word ptr ds:ptrsav+2, es
                pop     ds
                assume ds:nothing
                jmp     far ptr 70h:65Eh ; BIOSDATA:dsk_entry
                                        ;
                                        ; NOTE: jump to a FAR function, not an
                                        ; IRET type function. Callers of
                                        ; this int2f subfunction will have
                                        ; to be careful to do a popf
; ---------------------------------------------------------------------------

do_subfun_01:                           ; CODE XREF: BIOSCODE:16F3↑j
                push    es
                push    ds
                push    ds
                pop     es
                mov     ds, cs:Bios_Data_Word ; BIOSDATA segment
                assume ds:nothing
                call    install_bds
                pop     ds
                assume ds:nothing
                pop     es
                iret
; ---------------------------------------------------------------------------

do_get_bds_vector:                      ; CODE XREF: BIOSCODE:16F7↑j
                mov     ds, cs:Bios_Data_Word
                assume ds:nothing
                lds     di, dword ptr ds:start_bds
                assume ds:nothing
                iret
; ---------------------------------------------------------------------------

win386call:                             ; CODE XREF: BIOSCODE:16B7↑j
                push    ds
                mov     ds, cs:Bios_Data_Word ; BIOSDATA segment
                assume ds:nothing
                cmp     al, 5           ; Win386_Init
                                        ; is it win386 initializing?
                jz      short Win386Init
                cmp     al, 6           ; Win386_Exit
                                        ; is it win386 exiting?
                jnz     short win_iret
                test    dx, 1           ; is it win386 or win286 dos extender?
                jnz     short win_iret  ; if not win386, then continue
                and     ds:IsWin386, 0  ; indicate that win386 is not present
                jmp     short win_iret
; ---------------------------------------------------------------------------

Win386Init:                             ; CODE XREF: BIOSCODE:172E↑j
                test    dx, 1           ; is it win386 or win286 dos extender?
                jnz     short win_iret  ; if not win386, then continue
                or      ds:IsWin386, 1
                mov     word ptr ds:SI_Next, bx
                mov     word ptr ds:SI_Next+2, es ; Hook our structure into chain
                mov     bx, offset Win386_SI ; point es:bx to Win386_SI
                push    ds
                pop     es
                assume es:nothing

win_iret:                               ; CODE XREF: BIOSCODE:1732↑j
                                        ; BIOSCODE:1738↑j ...
                pop     ds
                assume ds:nothing
                iret                    ; return back up the chain
; ---------------------------------------------------------------------------

handle_multmult:                        ; CODE XREF: BIOSCODE:16BE↑j
                cmp     al, 1
                jnz     short try_2
                push    ds
                call    HMAptr          ; get offset of free HMA
                mov     bx, 0FFFFh
                mov     es, bx          ; seg of HMA
                assume es:nothing
                mov     bx, di
                not     bx
                or      bx, bx
                jz      short try_1
                inc     bx

try_1:                                  ; CODE XREF: BIOSCODE:176E↑j
                pop     ds
                iret
; ---------------------------------------------------------------------------

try_2:                                  ; CODE XREF: BIOSCODE:175D↑j
                cmp     al, 2           ; multMULTALLOCHMA
                jnz     short try_3
                push    ds
                mov     di, 0FFFFh      ; assume not enough space
                mov     es, di
                call    HMAptr          ; get offset of free HMA
                cmp     di, 0FFFFh
                jz      short InsuffHMA
                neg     di              ; free space in HMA
                cmp     bx, di
                jbe     short try_4
                mov     di, 0FFFFh
                pop     ds
                iret
; ---------------------------------------------------------------------------

try_4:                                  ; CODE XREF: BIOSCODE:1789↑j
                call    get_FreeHMAPtr
                add     bx, 15
                and     bl, 0F0h
                add     ds:FreeHMAPtr, bx ; update the free pointer
                jnz     short InsuffHMA
                mov     ds:FreeHMAPtr, 0FFFFh ; -1
                                        ; no more HMA if we have wrapped

InsuffHMA:                              ; CODE XREF: BIOSCODE:1783↑j
                                        ; BIOSCODE:179D↑j
                pop     ds

try_3:                                  ; CODE XREF: BIOSCODE:1775↑j
                iret

; =============== S U B R O U T I N E =======================================


HMAptr          proc near               ; CODE XREF: BIOSCODE:1760↑p
                                        ; BIOSCODE:177D↑p
                mov     ds, cs:Bios_Data_Word
                assume ds:nothing
                mov     di, ds:FreeHMAPtr
                cmp     di, 0FFFFh
                jnz     short HMAPtr_retn
                cmp     ds:SysinitPresent, 0
                jz      short HMAPtr_retn
                call    dword ptr ds:MoveDOSIntoHMA ; call far [MoveDOSIntoHMA]
HMAptr          endp


; =============== S U B R O U T I N E =======================================


get_FreeHMAPtr  proc near               ; CODE XREF: BIOSCODE:try_4↑p
                mov     di, ds:FreeHMAPtr

HMAPtr_retn:                            ; CODE XREF: HMAptr+C↑j
                                        ; HMAptr+13↑j
                retn
get_FreeHMAPtr  endp


; =============== S U B R O U T I N E =======================================


move_sector     proc near               ; CODE XREF: BIOSCODE:199F↓p
                                        ; BIOSCODE:1A0F↓p ...
                cld
                push    cx
                mov     cx, 256
                cmp     si, 0FE00h
                ja      short movsec_bytes
                cmp     di, 0FE00h
                ja      short movsec_bytes
                rep movsw
                pop     cx
                retn
; ---------------------------------------------------------------------------

movsec_bytes:                           ; CODE XREF: move_sector+9↑j
                                        ; move_sector+F↑j
                shl     cx, 1
                rep movsb
                pop     cx
                retn
move_sector     endp


; =============== S U B R O U T I N E =======================================


check_wrap      proc near               ; CODE XREF: BIOSCODE:1956↓p
                                        ; BIOSCODE:1A56↓p ...
                push    ax
                push    bx
                push    es
                push    di
                call    find_bds        ; get pointer to bds for drive in dl
                jb      short no_wrap
                test    word ptr es:[di+3Fh], 1 ; [es:di+BDS.flags],fnon_removable
                jz      short no_wrap   ; no wrapping for removable media
                mov     bx, es:[di+13h] ; [es:di+BDS.secpertrack]
                mov     ax, cx
                and     ax, 3Fh         ; extract sector number
                cmp     ax, bx          ; are we going to wrap?
                jbe     short no_wrap
                div     bl              ; ah=new sector #, al=# of head wraps
                or      ah, ah
                jnz     short not_on_bound
                mov     ah, bl          ; set sector=BDS_BPB.BPB_SECTORSPERTRACK
                dec     al              ; if on boundary
                                        ; also decrement # of head wrap

not_on_bound:                           ; CODE XREF: check_wrap+22↑j
                and     cl, 0C0h        ; zero out sector #
                or      cl, ah          ; or in new sector #
                xor     ah, ah          ; ax = # of head wraps
                inc     ax
                add     al, dh          ; add in starting head #
                adc     ah, 0           ; catch any carry
                cmp     ax, es:[di+15h] ; [es:di+BDS.heads]
                                        ; are we going to wrap around a head?
                jbe     short no_wrap_head
                push    dx              ; preserve drive number and head number
                xor     dx, dx
                mov     bx, es:[di+15h] ; [es:di+BDS.heads]
                                        ; dx = new head #, ax = # of cylinder wraps
                div     bx
                or      dx, dx          ; if new head # is 0, then we are on the last head
                jnz     short no_head_bound
                mov     dx, bx          ; on boundary. set to BDS_BPB.BPB_HEADS
                or      ax, ax          ; if we had some cylinder wraps,
                                        ; we need to reduce them by on
                jz      short no_head_bound
                dec     ax              ; reduce number of cylinder wraps

no_head_bound:                          ; CODE XREF: check_wrap+46↑j
                                        ; check_wrap+4C↑j
                mov     bh, dl          ; bh has new head number
                pop     dx              ; restore drive number and head number
                dec     bh
                mov     dh, bh
                mov     bh, cl
                and     bh, 3Fh         ; preserve sector number
                mov     bl, 6
                xchg    cl, bl
                shr     bl, cl          ; get ms cylinder bits to ls end
                add     ch, al          ; add in cylinder wrap
                adc     bl, ah          ; add in high byte
                shl     bl, cl          ; move up to ms end
                xchg    bl, cl          ; restore cylinder bits into cl
                or      cl, bh          ; or in sector number

no_wrap:                                ; CODE XREF: check_wrap+7↑j
                                        ; check_wrap+F↑j ...
                clc
                pop     di
                pop     es
                assume es:nothing
                pop     bx
                pop     ax
                retn
; ---------------------------------------------------------------------------

no_wrap_head:                           ; CODE XREF: check_wrap+39↑j
                mov     dh, al          ; do not lose new head number
                dec     dh              ; get it 0-based
                jmp     short no_wrap
check_wrap      endp


; =============== S U B R O U T I N E =======================================


find_bds        proc near               ; CODE XREF: check_wrap+4↑p
                                        ; BIOSCODE:1A1D↓p
                les     di, dword ptr ds:start_bds ; point es:di to first bds

fbds_1:                                 ; CODE XREF: find_bds+10↓j
                cmp     es:[di+4], dl   ; [es:di+BDS.drivenum]
                jz      short fdbs_2
                les     di, es:[di]     ; [es:di+BDS.link]
                                        ; go to next bds
                cmp     di, 0FFFFh
                jnz     short fbds_1
                stc

fdbs_2:                                 ; CODE XREF: find_bds+8↑j
                retn
find_bds        endp


; =============== S U B R O U T I N E =======================================


doint           proc near               ; CODE XREF: BIOSCODE:19E4↓p
                                        ; BIOSCODE:doblockdoint↓p ...
                mov     dl, [bp+8]      ; [bp+INT13FRAME.olddx]
                                        ; get physical drive number
                xor     ah, ah
                or      al, al
                jz      short dointdone ; if zero sectors, return ax=0
                mov     ah, [bp+3]      ; [bp+INT13FRAME.oldax+1]
                                        ; get request code
                push    word ptr [bp+10h] ; [bp+INT13FRAME.oldf]
                popf
                call    70h:70Bh        ; call BIOSDATA:call_orig13
                                        ; call DOSBIOSSEG:call_orig13
                pushf
                pop     word ptr [bp+10h] ; [bp+INT13FRAME.oldf]

dointdone:                              ; CODE XREF: doint+8↑j
                retn
doint           endp

; ---------------------------------------------------------------------------
dtype_array     dd 400090h              ; DATA XREF: BIOSCODE:18B4↓r
                                        ; 40h:90h is drive type array
; ---------------------------------------------------------------------------

format_special_stuff:                   ; CODE XREF: BIOSCODE:18EB↓j
                cmp     ds:fhave96, 0   ; do we have changeline support?
                jz      short format_special_stuff_done ; brif not
                push    bx
                mov     bx, 140h        ; fchanged_by_format+fchanged
                call    Set_Changed_DL  ; indicate that media changed by format
                pop     bx
                jmp     short format_special_stuff_done
; ---------------------------------------------------------------------------

ec35_special_stuff:                     ; CODE XREF: BIOSCODE:18F2↓j
                test    dl, dl          ; floppy or hard disk?
                js      short ec35_special_stuff_done ; if hard drive, we're done
                push    ax              ; see if this PARTICULAR drive is ec35
                push    cx
                mov     cl, dl          ; turn drive number into bit map
                mov     al, 1           ; assume drive 0
                shl     al, cl          ; shift over correct number of times
                test    ds:ec35_flag, al ; electrically compatible 3.5 incher?
                pop     cx
                pop     ax
                jz      short ec35_special_stuff_done ; done if this floppy is not an ec35
                push    bx              ; free up a far pointer (es:bx)
                push    es
                les     bx, cs:dtype_array
                add     bl, dl
                adc     bh, 0           ; find entry for this drive
                mov     byte ptr es:[bx], 93h ; establish drive type as:
                                        ; (360k disk in 360k drive,
                                        ; no double-stepping, 250 kbs transfer rate)
                pop     es
                pop     bx
                jmp     short ec35_special_stuff_done
; ---------------------------------------------------------------------------

ps2_special_stuff:                      ; CODE XREF: BIOSCODE:18FF↓j
                cmp     ds:prevoper, 8  ; (ps2_30)
                                        ; read driver parm?
                jz      short ps2_30_problem
                cmp     ds:prevoper, 15h ; apparently function 15h fails, too
                jnz     short ps2_special_stuff_done

ps2_30_problem:                         ; CODE XREF: BIOSCODE:18CB↑j
                push    ax
                mov     ah, 1
                call    70h:70Bh        ; call BIOSDATA:call_orig13
                pop     ax
                jmp     short ps2_special_stuff_done
; ---------------------------------------------------------------------------

i13z:                                   ; DATA XREF: BIOSDATA:i13x↑o
                push    ds
                mov     ds, cs:Bios_Data_Word
                mov     ds:prevoper, ax ; save request
                cmp     ah, 5           ; romformat
                jz      short format_special_stuff

format_special_stuff_done:              ; CODE XREF: BIOSCODE:1892↑j
                                        ; BIOSCODE:189C↑j
                cmp     ds:ec35_flag, 0 ; any electrically compat 3.5 inchers?
                jnz     short ec35_special_stuff ; go handle it out of line if so

ec35_special_stuff_done:                ; CODE XREF: BIOSCODE:18A0↑j
                                        ; BIOSCODE:18B0↑j ...
                call    70h:70Bh        ; call BIOSDATA:call_orig13
                pushf
                cmp     ds:model_byte, 0FAh ; is this a ps2/30?
                                        ; mdl_ps2_30
                jz      short ps2_special_stuff ; exit mainline to address special

ps2_special_stuff_done:                 ; CODE XREF: BIOSCODE:18D2↑j
                                        ; BIOSCODE:18DD↑j
                popf
                jb      short goterr13  ; error on original orig13 call-thru?

ret_from_i13:                           ; CODE XREF: BIOSCODE:i13ret_ck_chglinerr↓j
                                        ; BIOSCODE:1923↓j ...
                pop     ds
                assume ds:nothing
                retf    2               ; restore ds & iret w/flags
; ---------------------------------------------------------------------------

i13ret_ck_chglinerr:                    ; CODE XREF: BIOSCODE:197E↓j
                                        ; BIOSCODE:19FE↓j
                jnb     short ret_from_i13 ; done if not an error termination

i13_ret_error:                          ; CODE XREF: BIOSCODE:192D↓j
                                        ; BIOSCODE:1934↓j ...
                cmp     ah, 6           ; did i see a change event?
                jnz     short int13b    ; skip if wrong error
                or      dl, dl          ; is this for the hard disk?
                js      short int13b    ; yes, ignore
                cmp     ds:fhave96, 0
                jz      short int13b    ; just in case ROM returned this
                                        ; error even though it told us it
                                        ; never would
                push    bx
                mov     bx, 40h         ; fchanged
                call    Set_Changed_DL
                pop     bx

int13b:                                 ; CODE XREF: BIOSCODE:190D↑j
                                        ; BIOSCODE:1911↑j ...
                stc                     ; now return the error
                jmp     short ret_from_i13
; ---------------------------------------------------------------------------

goterr13:                               ; CODE XREF: BIOSCODE:1902↑j
                cmp     ah, 9           ; dma error?
                jz      short gotdmaerr

goterr13_xxxx:                          ; CODE XREF: BIOSCODE:xgoterr13_xxxx↓j
                cmp     ah, 11h         ; ecc error?
                jnz     short i13_ret_error ; other error. just return back.
                cmp     ds:media_set_for_format, 1 ; formatting?
                jz      short i13_ret_error
                cmp     byte ptr ds:prevoper+1, 2 ; ecc-corrected error
                                        ; (2 = romread)
                                        ; ECC correction only applies to reads
                jnz     short i13_ret_error
                xor     ah, ah
                call    70h:70Bh        ; call BIOSDATA:call_orig13
                                        ; call DOSBIOSSEG:call_orig13
                mov     ax, ds:prevoper
                xor     ah, ah          ; return code = no error
                cmp     al, 1           ; if request for one sector, assume ok
                jz      short ret_from_i13 ; return with carry clear
                push    bx
                push    cx
                push    dx
                mov     ds:number_of_sec, al

loop_ecc:                               ; CODE XREF: BIOSCODE:1978↓j
                mov     ax, 201h        ; read one sector
                call    check_wrap      ; get correct parameters for int 13
                call    70h:70Bh        ; call BIOSDATA:call_orig13
                                        ; call DOSBIOSSEG:call_orig13
                jnb     short ok11_op
                cmp     ah, 9           ; DMA error during ECC read?
                jz      short handle_dma_during_ecc
                cmp     ah, 11h         ; only allow ecc errors
                jnz     short ok11_exit_err
                xor     ax, ax          ; ecc error. reset the system again.
                                        ; clear the error code so that if this
                                        ; was the last sector, no error code
                                        ; will be returned for the corrected read.
                                        ; (clear carry too.)

ok11_op:                                ; CODE XREF: BIOSCODE:195E↑j
                                        ; BIOSCODE:19A4↓j
                dec     ds:number_of_sec
                jz      short ok11_exit ; all done?
                inc     cl              ; advance sector number
                                        ; add 200h to address
                inc     bh
                inc     bh
                jmp     short loop_ecc
; ---------------------------------------------------------------------------

ok11_exit_err:                          ; CODE XREF: BIOSCODE:1968↑j
                                        ; BIOSCODE:1996↓j
                stc                     ; set carry bit again.

ok11_exit:                              ; CODE XREF: BIOSCODE:1970↑j
                pop     dx
                pop     cx
                pop     bx
                jmp     short i13ret_ck_chglinerr
; ---------------------------------------------------------------------------

handle_dma_during_ecc:                  ; CODE XREF: BIOSCODE:1963↑j
                push    es
                push    bx
                mov     bx, offset disksector ; BIOSDATA:0152h
                push    ds
                pop     es              ; point es:bx to buffer
                mov     ax, 201h        ; read one sector
                call    70h:70Bh        ; call BIOSDATA:call_orig13
                pop     bx
                pop     es
                jnb     short handle_dma_during_ecc_noerr
                cmp     ah, 11h
                jnz     short ok11_exit_err

handle_dma_during_ecc_noerr:            ; CODE XREF: BIOSCODE:1991↑j
                push    si
                push    di
                mov     di, bx
                mov     si, offset disksector
                call    move_sector
                pop     di
                pop     si
                jmp     short ok11_op
; ---------------------------------------------------------------------------

gotdmaerr:                              ; CODE XREF: BIOSCODE:1928↑j
                mov     ax, ds:prevoper
                sti
                cmp     ah, 2           ; romread
                jb      short i13_done_dmaerr
                cmp     ah, 4           ; romverify
                jz      short intverify
                cmp     ah, 5           ; romformat
                jz      short intformat
                ja      short i13_done_dmaerr
                push    dx              ; set up stack frame here!
                push    cx
                push    bx
                push    ax
                push    bp
                mov     bp, sp
                mov     dx, es          ; check for 64k boundary error
                add     dx, dx
                add     dx, dx
                add     dx, dx
                add     dx, dx          ; dx = dx*16
                add     dx, bx
                add     dx, 511
                jnb     short no_skip_first
                jmp     bufferx         ; restore dh=head & do buffer
; ---------------------------------------------------------------------------

no_skip_first:                          ; CODE XREF: BIOSCODE:19D2↑j
                shr     dh, 1           ; dh = number of sectors before address
                mov     ah, 128         ; ah = max number of sectors in segment
                sub     ah, dh
                cmp     ah, al          ; can we fit it in?
                jb      short doblock   ; no, perform blocking.
                                        ; yes, the request fits. let it happen
                mov     dh, [bp+9]      ; [bp+INT13FRAME.olddx+1]
                                        ; set up head number
                call    doint
                jmp     bad13           ; and return from this place
; ---------------------------------------------------------------------------

i13_done_dmaerr:                        ; CODE XREF: BIOSCODE:19AD↑j
                                        ; BIOSCODE:19B9↑j
                mov     ah, 9           ; pass dma error thru to caller
                stc
                jmp     ret_from_i13    ; return with error,
                                        ; we know it's not a changeline error
; ---------------------------------------------------------------------------

intverify:                              ; CODE XREF: BIOSCODE:19B2↑j
                push    es              ; save caller's dma address
                push    bx
                push    ds
                pop     es              ; es:bx -> BIOSDATA:disksector

dosimple:                               ; CODE XREF: BIOSCODE:1A15↓j
                mov     bx, offset disksector
                call    70h:70Bh        ; call DOSBIOSSEG:call_orig13
                                        ; call BIOSDATA:call_orig13
                pop     bx
                pop     es
                jmp     i13ret_ck_chglinerr
; ---------------------------------------------------------------------------

intformat:                              ; CODE XREF: BIOSCODE:19B7↑j
                push    es
                push    bx
                push    si
                push    di
                push    ds
                push    es
                push    ds
                pop     es
                pop     ds
                mov     si, bx
                mov     di, offset disksector
                call    move_sector     ; user's data into BIOSDATA:disksector
                pop     ds
                pop     di
                pop     si              ; do the i/o from
                jmp     short dosimple  ; BIOSDATA:disksector
; ---------------------------------------------------------------------------

doblock:                                ; CODE XREF: BIOSCODE:19DF↑j
                mov     dx, [bp+8]      ; [bp+INT13FRAME.olddx]
                                        ; get head #, drive #
                push    cx
                push    es
                push    di              ; ah - # of sectors before dma boundary
                                        ; al - requested # of sectors for i/o.
                call    find_bds
                mov     cx, es:[di+13h] ; [es:di+BDS.secpertrack]
                test    word ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
                pop     di
                pop     es
                mov     al, ah          ; set al=ah for floppies
                jz      short doblockflop ; they are track by track operation
                mov     ah, 63          ; ah = 63-secpt (# safe sectors??)
                sub     ah, cl          ; al - # of sectors before dma boundary

doblockflop:                            ; CODE XREF: BIOSCODE:1A2E↑j
                pop     cx

doblockcontinue:                        ; CODE XREF: BIOSCODE:1A59↓j
                cmp     ah, al          ; if safe_# >= #_of_sectors_to_go_before dma,
                jnb     short doblocklast ; then #_of_sectors_to_go as it is for doint.
                push    ax
                mov     al, ah          ; otherwise, set al to ah to operate.
                jmp     short doblockdoint
; ---------------------------------------------------------------------------

doblocklast:                            ; CODE XREF: BIOSCODE:1A37↑j
                mov     ah, al
                push    ax

doblockdoint:                           ; CODE XREF: BIOSCODE:1A3C↑j
                call    doint           ; let ah = al = # of sectors for this shot
                jb      short bad13     ; something happened, bye!
                pop     ax
                sub     [bp+2], ah      ; sub [bp+INT13FRAME.oldax], ah
                                        ; decrement by the successful operation
                add     cl, ah          ; advance sector #. safety gauranteed.
                add     bh, ah          ; advance dma address
                add     bh, ah          ; twice for 512 byte sectors
                cmp     ah, al          ; check the previous value
                jz      short buffer    ; if #_of_sectors_to_go < safe_#,
                                        ; then we are done already.
                sub     al, ah          ; otherwise,
                                        ; #_sector_to_go = #_of_sector_to_go - safe_#
                call    check_wrap      ; get new cx, dh for the next operation.
                jmp     short doblockcontinue ; handles next sectors left.
; ---------------------------------------------------------------------------

bufferx:                                ; CODE XREF: BIOSCODE:19D4↑j
                mov     dh, [bp+9]      ; [bp+INT13FRAME.olddx+1]
                                        ; set up head number

buffer:                                 ; CODE XREF: BIOSCODE:1A52↑j
                push    bx
                mov     ah, [bp+3]      ; [bp+INT13FRAME.oldax+1]
                cmp     ah, 3           ; romwrite
                jnz     short doread
                push    es
                push    ds
                push    si
                push    di
                push    ds              ; exchange segment registers
                push    es
                pop     ds
                pop     es
                mov     di, offset disksector ; where to move
                push    di              ; save it
                mov     si, bx          ; source
                call    move_sector     ; move sector into local buffer
                pop     bx              ; new transfer address
                                        ; (es:bx = BIOSDATA:disksector)
                pop     di              ; restore caller's di & si
                pop     si
                pop     ds              ; restore BIOSDATA
                mov     al, 1
                mov     dl, [bp+8]      ; [bp+INT13FRAME.olddx]
                                        ; get drive number
                call    check_wrap      ; sets up registers if wrap-around
                                        ;
                                        ; ah is function
                                        ; al is 1 for single sector transfer
                                        ; es:bx is local transfer addres
                                        ; cx is track/sector number
                                        ; dx is head/drive number
                                        ; si, di unchanged
                call    doint
                pop     es              ; restore caller's dma segment
                jb      short bad13     ; go clean up
                jmp     short dotail
; ---------------------------------------------------------------------------

doread:                                 ; CODE XREF: BIOSCODE:1A65↑j
                push    es
                push    bx
                push    ds
                pop     es              ; es = BIOSCODE segment
                mov     bx, offset disksector
                mov     al, 1
                mov     dl, [bp+8]      ; [bp+INT13FRAME.olddx]
                                        ; get drive number
                call    check_wrap      ; ah = function
                                        ; al = 1 for single sector
                                        ; es:bx points to local   buffer
                                        ; cx, dx are track/sector, head/drive
                call    doint
                pop     bx
                pop     es
                jb      short bad13
                push    si
                push    di
                mov     di, bx
                mov     si, offset disksector
                call    move_sector
                pop     di
                pop     si

dotail:                                 ; CODE XREF: BIOSCODE:1A8A↑j
                pop     bx              ; retrieve new dma area
                add     bh, 2           ; advance over sector
                inc     cx
                mov     al, [bp+2]      ; [bp+INT13FRAME.oldax]
                clc
                dec     al
                jz      short bad13     ; no more i/o
                mov     dl, [bp+8]      ; [bp+INT13FRAME.olddx]
                call    check_wrap
                call    doint

bad13:                                  ; CODE XREF: BIOSCODE:19E7↑j
                                        ; BIOSCODE:1A44↑j ...
                mov     sp, bp
                pop     bp
                pop     bx
                pop     bx
                pop     cx
                pop     dx
                jb      short xgoterr13_xxxx ; go handle ECC errors
                jmp     ret_from_i13    ; non-error exit
; ---------------------------------------------------------------------------

xgoterr13_xxxx:                         ; CODE XREF: BIOSCODE:1ACB↑j
                jmp     goterr13_xxxx
; ---------------------------------------------------------------------------
                db    0

; =============== S U B R O U T I N E =======================================


dsk_init        proc near               ; DATA XREF: BIOSCODE:057A↑o
                mov     ah, ds:drvmax
                mov     di, offset dskdrvs ; pass result in es:di
                push    ds
                pop     es
                jmp     SetPtrSav
dsk_init        endp


; =============== S U B R O U T I N E =======================================


install_bds     proc near               ; CODE XREF: BIOSCODE:1716↑p
                push    ds              ; save Bios_Data (BIOSDATA) segment
                mov     si, offset start_bds ; beginning of chain

loop_next_bds:                          ; CODE XREF: install_bds+2C↓j
                lds     si, [si]        ; [si+BDS.link]
                                        ; fetch next bds
                mov     al, es:[di+4]   ; [es:di+BDS.drivenum]
                cmp     [si+4], al      ; does this one share a physical
                                        ; drive with new one?
                jnz     short next_bds
                mov     bl, 10h         ; fi_am_mult
                or      es:[di+3Fh], bl ; [es:di+BDS.flags]
                                        ; set both of them to i_am_mult if so
                or      [si+3Fh], bl    ; [si+BDS.flags]
                and     byte ptr es:[di+3Fh], 0DFh ; [es:di+BDS.flags],~fi_own_physical
                                        ; we don't own it
                mov     bl, [si+3Fh]    ; [si+BDS.flags]
                                        ; determine if changeline available
                and     bl, 2           ; fchangeline
                or      es:[di+3Fh], bl ; [es:di+BDS.flags]

next_bds:                               ; CODE XREF: install_bds+D↑j
                mov     ax, 0FFFFh
                cmp     [si], ax        ; [si+BDS.link],-1
                                        ; are we at end of list?
                jnz     short loop_next_bds
                mov     word ptr [si+2], es ; [si+BDS.link+2], es
                                        ; install bds
                mov     [si], di
                mov     es:[di], ax     ; [es:di+BDS.link],-1
                                        ; set next pointer to null
                pop     ds
                mov     al, es:[di+50h] ; [es:di+BDS.rsecpertrack]
                cmp     al, ds:eot
                jbe     short _eot_ok
                mov     ds:eot, al

_eot_ok:                                ; CODE XREF: install_bds+3F↑j
                retn
install_bds     endp


; =============== S U B R O U T I N E =======================================


swpdsk          proc near               ; CODE XREF: checksingle:ignore_sdsb↑p
                test    ds:IsWin386, 1  ; Is win386 present?
                jz      short no_win386 ; no, skip SetFocus
                call    far ptr 70h:813h ; call DOSBIOSSEG:V86_Crit_SetFocus
                                        ; call BIOSDATA:V86_Crit_SetFocus

no_win386:                              ; CODE XREF: swpdsk+5↑j
                push    cx
                push    dx
                mov     dl, es:[di+5]   ; [es:di+BDS.drivelet]
                                        ; get the drive letter
                mov     dh, dl
                xor     dh, 1
                sub     cx, cx          ; nobody has handled swap disk
                mov     ax, 4A00h       ; multMULT<<8)|multMULTSWPDSK
                                        ; broadcast code for swap disk
                                        ; Broadcast it
                int     2Fh
                inc     cx
                jz      short swpdsk9
                add     dl, 'A'
                mov     byte ptr cs:drvlet, dl ; "A: and press any key when ready\r\n\n"
                mov     si, offset sngmsg ; "\r\nInsert diskette for drive "
                push    bx
                lods    byte ptr cs:[si] ; get the next character of the message

wrmsg_loop:                             ; CODE XREF: swpdsk+35↓j
                int     29h             ; DOS 2+ internal - FAST PUTCHAR
                                        ; AL = character to display
                lods    byte ptr cs:[si] ; cs lodsb
                                        ; get the next character of the message
                or      al, al
                jnz     short wrmsg_loop
                call    con_flush       ; flush out keyboard queue
                                        ; call rom-bios
                xor     ah, ah
                int     16h             ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
                                        ; Return: AH = scan code, AL = character
                pop     bx

swpdsk9:                                ; CODE XREF: swpdsk+1F↑j
                pop     dx
                pop     cx
                retn
swpdsk          endp

; ---------------------------------------------------------------------------
sngmsg          db 0Dh,0Ah              ; DATA XREF: swpdsk+29↑o
                db 'Insert diskette for drive '
drvlet          db 'A: and press any key when ready',0Dh,0Ah
                                        ; DATA XREF: swpdsk+24↑w
                db 0Ah,0

; =============== S U B R O U T I N E =======================================


mediacheck      proc near               ; CODE XREF: BIOSCODE:05F3↑p
                call    checksingle     ; make sure correct disk is in place
                xor     si, si
                call    haschange
                jz      short mediaret
                test    word ptr es:[di+3Fh], 40h ; [es:di+BDS.flags], fchanged ; 40h
                                        ; (BDS offset 63)
                jnz     short mediadovolid ; media changed
                push    ax
                push    dx
                mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
                mov     ah, 16h
                int     13h             ; DISK - FLOPPY DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
                                        ; DL = drive to check
                                        ; Return: AH = disk change status
                pop     dx
                pop     ax
                jb      short mediadovolid
                mov     si, 1
                mov     bl, ds:tim_drv  ; get last drive accessed
                cmp     es:[di+4], bl   ; [es:di+BDS.drivenum]
                                        ; (If the last drive accessed is not current drive
                                        ; media change status may be incorrect. So,
                                        ; "I don't now" will be returned even if it is indicated
                                        ; as media is not changed.)
                jz      short mediaret  ; (same drive, media changeline indication is reliable)
                push    ax
                push    cx
                push    dx
                call    Check_Time_Of_Access
                pop     dx
                pop     cx
                pop     ax
                or      si, si
                jz      short mediadovolid ; check_time says ">= 2 secs passed"
                                        ; (volume id will be checked)
                xor     si, si          ; return "i don't know"

mediaret:                               ; CODE XREF: mediacheck+8↑j
                                        ; mediacheck+2B↑j ...
                retn
; ---------------------------------------------------------------------------

mediadovolid:                           ; CODE XREF: mediacheck+10↑j
                                        ; mediacheck+1E↑j ...
                call    GetBp           ; build a new bpb in current bds
                jb      short mediaret
                call    check_vid
                jnb     short mediaret
                jmp     maperror        ; fix up al for return to dos
mediacheck      endp


; =============== S U B R O U T I N E =======================================


checklatchio    proc near               ; CODE XREF: diskio+81↑p
                cmp     word ptr es:[di+3Ch], 0 ; [di+BDS.opcnt]
                jz      short checkret  ; done if zero
                test    word ptr es:[di+3Fh], 40h ; test [es:di+BDS.flags], fchanged ; 40h
                jz      short checkret  ; not changed
                call    GetBp           ; build bpb in current bds
                jb      short ret_no_error_map ; disk error trying to read in
                call    check_vid
                jb      short checklatchret ; disk error trying to read in
                or      si, si          ; is changed for sure?
                jns     short checkret  ; no
                call    returnvid       ; yes

checklatchret:                          ; CODE XREF: checklatchio+17↑j
                call    maperror        ; fix up al for return to dos

ret_no_error_map:                       ; CODE XREF: checklatchio+12↑j
                stc
                pop     si              ; pop off return address

checkret:                               ; CODE XREF: checklatchio+5↑j
                                        ; checklatchio+D↑j ...
                retn
checklatchio    endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


checkfatvid     proc near               ; CODE XREF: checkio+11↓p
                call    fat_check       ; check the fat and the vid
                or      si, si
                js      short changed_drv ;
checkfatvid     endp                    ; fall into check_vid


; =============== S U B R O U T I N E =======================================


check_vid       proc near               ; CODE XREF: mediacheck+42↑p
                                        ; checklatchio+14↑p
                cmp     word ptr ds:disksector+16h, 0 ; BPB_FATSz16
                jnz     short chk_vid_1
                cmp     ds:disksector+42h, 29h ; BS_FAT32_BootSig
                                        ; [disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE
                jmp     short chk_vid_2
; ---------------------------------------------------------------------------

chk_vid_1:                              ; CODE XREF: check_vid+5↑j
                cmp     ds:disksector+26h, 29h ; BS_FAT_BootSig ; BS_BootSig
                                        ; [disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE

chk_vid_2:                              ; CODE XREF: check_vid+C↑j
                jz      short do_ext_check_id
                call    haschange
                jz      short checkret
                xor     si, si
                cmp     ds:disksector+10h, 0 ; BPB_NumFATs
                                        ; [disksector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS]
                jz      short checkfatret ; don't read vol id if not fat system
                call    read_volume_id
                jb      short checkfatret
                call    check_volume_id
                mov     si, 0FFFFh      ; -1
                                        ; definitely changed
                jnz     short changed_drv
                inc     si

vid_no_changed:                         ; CODE XREF: check_vid+5A↓j
                call    resetchanged
                clc

checkfatret:                            ; CODE XREF: check_vid+21↑j
                                        ; check_vid+26↑j ...
                retn
; ---------------------------------------------------------------------------

changed_drv:                            ; CODE XREF: checkfatvid+5↑j
                                        ; check_vid+2E↑j ...
                clc                     ; cas -- return no error
                mov     ds:tim_drv, 0FFh ; ensure that we ask rom for media
                                        ;   check next time round
                retn
; ---------------------------------------------------------------------------

do_ext_check_id:                        ; CODE XREF: check_vid:chk_vid_2↑j
                push    ax
                push    di
                mov     si, (offset disksector+43h) ; BS_FAT32_VolID
                                        ; [DiskSector+EXT_BOOT.SERIAL]
                cmp     word ptr ds:disksector+16h, 0 ; BPB_FATSz16
                jz      short chk_vid_3
                sub     si, 28          ; offset disksector+27h ; BS_VolID

chk_vid_3:                              ; CODE XREF: check_vid+47↑j
                add     di, 137         ; BDS.vol_serial
                cmpsw                   ; [DiskSector+EXT_BOOT.SERIAL] = [di+BDS.vol_serial] ?
                jnz     short chk_vid_4
                cmpsw                   ; [DiskSector+EXT_BOOT.SERIAL+2] =
                                        ;          [di+BDS.vol_serial+2] ?

chk_vid_4:                              ; CODE XREF: check_vid+51↑j
                pop     di
                pop     ax
                jnz     short ext_changed ; not equal/same
                xor     si, si          ; 0 ; don't know
                jmp     short vid_no_changed ; reset the flag
; ---------------------------------------------------------------------------

ext_changed:                            ; CODE XREF: check_vid+56↑j
                mov     si, 0FFFFh      ; -1
                                        ; disk changed!
                clc
                jmp     short changed_drv
check_vid       endp


; =============== S U B R O U T I N E =======================================


checkio         proc near               ; CODE XREF: disk+FB↑p
                cmp     ah, 6
                jnz     short checkfatret
                cmp     word ptr es:[di+3Ch], 0
                jz      short checkfatret
                call    GetBp
                jb      short no_error_map
                call    checkfatvid
                jb      short checkioret ; disk error trying to read in.
                or      si, si          ; is changed for sure?
                js      short checkioerr ; yes changed
                inc     bp              ; allow a retry
                retn
; ---------------------------------------------------------------------------

checkioerr:                             ; CODE XREF: checkio+18↑j
                call    returnvid

checkioret:                             ; CODE XREF: checkio+14↑j
                stc                     ; make sure carry gets passed through
                jmp     harderr
; ---------------------------------------------------------------------------

no_error_map:                           ; CODE XREF: checkio+F↑j
                jmp     harderr2
checkio         endp


; =============== S U B R O U T I N E =======================================


returnvid       proc near               ; CODE XREF: checklatchio+1D↑p
                                        ; checkio:checkioerr↑p
                mov     si, 22          ; trans+8
                                        ; offset into pointer to return value
                call    vid_into_packet
                mov     ah, 6
                stc
                retn
returnvid       endp


; =============== S U B R O U T I N E =======================================


media_set_vid   proc near               ; CODE XREF: BIOSCODE:0624↑p
                mov     si, 15          ; trans+1

vid_into_packet:                        ; CODE XREF: returnvid+3↑p
                push    ds
                lds     bx, ds:ptrsav
                add     di, 125         ; BDS.volid (BDS offset 125)
                mov     [bx+si], di
                sub     di, 125         ; BDS start (BDS offset 0)
                mov     word ptr [bx+si+2], es
                pop     ds

dofloppy:                               ; CODE XREF: hidensity+6↓j
                                        ; hidensity+D↓j ...
                retn
media_set_vid   endp


; =============== S U B R O U T I N E =======================================


hidensity       proc near               ; CODE XREF: GetBp+28↑p
                test    word ptr es:[di+3Fh], 2 ; check for correct drive
                                        ; is it special?
                                        ; [es:di+BDS.flags], fchangeline
                jz      short dofloppy  ; no, do normal floppy test
                cmp     byte ptr es:[di+3Eh], 2 ; is it single-media?
                jz      short dofloppy  ; [es:di+BDS.formfactor], ffSmall
                                        ; yes, use fatid.
                cmp     ah, 0F9h
                jnz     short dofloppy
                mov     al, es:[di+3Eh] ; [es:di+BDS.formfactor]
                cmp     al, 7           ; ffOther ?
                jz      short Is720K
                cmp     al, 9
                jz      short Is720K
                mov     al, 7           ; seven sectors / fat
                mov     bx, 0E00Fh      ; 224*256+0Fh (57359)
                                        ; 224 root dir entries & 0Fh sector max
                mov     cx, 2400        ; 80*15*2
                                        ; 80 tracks, 15 sectors/track, 2 sides
                pop     dx              ; pop off return address
                mov     dx, 258         ; 1*256+2
                                        ; sectors/allocation unit & head max
                jmp     Has1            ; return to tail of getbp
; ---------------------------------------------------------------------------

Is720K:                                 ; CODE XREF: hidensity+1A↑j
                                        ; hidensity+1E↑j
                pop     bx              ; pop off return address
                jmp     Has720K         ; return to 720K code
hidensity       endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


Set_Changed_DL  proc near               ; CODE XREF: ChangeLineChk+26↑p
                                        ; BIOSCODE:1898↑p ...
                push    es
                push    di
                les     di, dword ptr ds:start_bds

scan_bds:                               ; CODE XREF: Set_Changed_DL+16↓j
                cmp     es:[di+4], dl   ; [es:di+BDS.drivenum]
                jnz     short get_next_bds
                or      es:[di+3Fh], bx ; [es:di+BDS.flags]
                                        ; signal change on other drive

get_next_bds:                           ; CODE XREF: Set_Changed_DL+A↑j
                les     di, es:[di]     ; [es:di+BDS.link]
                                        ; go to next bds
                cmp     di, 0FFFFh
                jnz     short scan_bds  ; loop unless end of chain
                pop     di
                pop     es
                retn
Set_Changed_DL  endp


; =============== S U B R O U T I N E =======================================


resetchanged    proc near               ; CODE XREF: movbpb+4C↑p
                                        ; check_vid:vid_no_changed↑p ...
                and     word ptr es:[di+3Fh], 0FFBFh ; [es:di+BDS.flags], ~fchanged
                retn
resetchanged    endp


; =============== S U B R O U T I N E =======================================


haschange       proc near               ; CODE XREF: BIOSCODE:05F8↑p
                                        ; ChangeLineChk+17↑p ...
                test    word ptr es:[di+3Fh], 2 ; [es:di+BDS.flags], fchangeline
                retn
haschange       endp


; =============== S U B R O U T I N E =======================================


set_volume_id   proc near               ; CODE XREF: get_bpb+2D↑p
                push    dx
                push    ax
                call    haschange       ; does drive have changeline support?
                jz      short setvret   ; no, get out
                call    read_volume_id
                jb      short seterr
                call    transfer_volume_id ; copy the volume id to special drive
                call    resetchanged    ; restore value of change line

setvret:                                ; CODE XREF: set_volume_id+5↑j
                clc
                pop     ax
                pop     dx
                retn
; ---------------------------------------------------------------------------

seterr:                                 ; CODE XREF: set_volume_id+A↑j
                pop     dx              ; pop stack but don't overwrite ax
                pop     dx
                retn
set_volume_id   endp

; ---------------------------------------------------------------------------
root_sec        dw 0                    ; DATA XREF: read_volume_id+24↓w
                                        ; read_volume_id+32↓r ...
                                        ; root sector #

; =============== S U B R O U T I N E =======================================


read_volume_id  proc near               ; CODE XREF: check_vid+23↑p
                                        ; set_volume_id+7↑p
                push    dx
                push    cx
                push    bx
                push    ax
                push    es              ; stack the bds last
                push    di
                push    ds              ; point es to Bios_Data (BIOSDATA)
                pop     es
                mov     di, offset tmp_vid ; "NO NAME    "
                mov     si, offset nul_vid ; "NO NAME    "
                mov     cx, 11          ; (cx = 12 in MSDOS 6 IO:SYS)
                                        ; initialize tmp_vid to null vi_id
                rep movs byte ptr es:[di], byte ptr cs:[si]
                pop     di
                pop     es
                mov     al, es:[di+0Bh] ; [es:di+BDS.fats]
                                        ; # of fats
                mov     cx, es:[di+11h] ; [es:di+BDS.fatsecs]
                                        ; sectors / fat
                mul     cl
                add     ax, es:[di+9]   ; [es:di+BDS.resectors]
                                        ; add on reserved sectors
                                        ; now, ax is sector # (0 based)
                mov     cs:root_sec, ax
                mov     ax, es:[di+0Ch] ; [es:di+BDS.direntries]
                                        ; # root dir entries
                mov     cl, 4           ; 16 entries/sector
                shr     ax, cl          ; divide by 16
                xchg    ax, cx          ; cx is # of sectors to scan

next_sec:                               ; CODE XREF: read_volume_id+6E↓j
                push    cx
                mov     ax, cs:root_sec ; get sector #
                mov     cx, es:[di+13h] ; [es:di+BDS.secpertrack]
                                        ; sectors / track
                xor     dx, dx
                div     cx
                inc     dx              ; dx = sectors into track
                                        ; ax = track count from 0
                mov     cl, dl          ; sector to read
                xor     dx, dx
                div     word ptr es:[di+15h] ; [es:di+BDS.heads]
                                        ; # heads on this disc
                mov     dh, dl          ; head number
                mov     ch, al          ; track #
                call    read_sector     ; get first sector of the root directory,
                                        ; ds:bx -> directory sector
                jb      short readviderr
                mov     cx, 16          ; # of dir entries in a block of root
                mov     al, 8           ; volume label bit

fvid_loop:                              ; CODE XREF: read_volume_id+66↓j
                cmp     [bx], ch        ; 0 ; end of dir?
                jz      short no_vid    ; yes, no vol id
                cmp     byte ptr [bx], 0E5h ; empty entry?
                jz      short ent_loop  ; yes, skip
                test    [bx+0Bh], al    ; is volume label bit set in fcb?
                jnz     short found_vid ; yes

ent_loop:                               ; CODE XREF: read_volume_id+5C↑j
                add     bx, 32          ; add length of directory entry
                loop    fvid_loop
                pop     cx              ; outer loop
                inc     cs:root_sec     ; inc word [root_sec]
                                        ; next sector
                loop    next_sec        ; continue

notfound:                               ; CODE XREF: read_volume_id+8F↓j
                xor     si, si
                jmp     short fvid_ret
; ---------------------------------------------------------------------------

found_vid:                              ; CODE XREF: read_volume_id+61↑j
                pop     cx              ; clean stack of outer loop counter
                mov     si, bx          ; point to volume_id
                push    es              ; preserve current bds
                push    di
                push    ds              ; point es to Bios_Data (BIOSDATA)
                pop     es
                mov     di, offset tmp_vid ; "NO NAME    "
                mov     cx, 11          ; VOLID_SIZ-1
                                        ; length of string minus nul
                rep movsb
                xchg    ax, cx
                stosb                   ; null terminate
                xchg    ax, si
                pop     di              ; restore current bds
                pop     es

fvid_ret:                               ; CODE XREF: read_volume_id+72↑j
                pop     ax
                clc

rvidret:                                ; CODE XREF: read_volume_id+93↓j
                pop     bx
                pop     cx
                pop     dx
                retn
; ---------------------------------------------------------------------------

no_vid:                                 ; CODE XREF: read_volume_id+57↑j
                pop     cx              ; clean stack of outer loop counter
                jmp     short notfound
; ---------------------------------------------------------------------------

readviderr:                             ; CODE XREF: read_volume_id+4E↑j
                pop     si              ; trash the outer loop counter
                pop     si              ; caller's ax, return error code instead
                jmp     short rvidret
read_volume_id  endp


; =============== S U B R O U T I N E =======================================


preset_volid_addr proc near             ; CODE XREF: BIOSCODE:1DDD↓p
                                        ; check_volume_id+2↓p
                mov     si, offset tmp_vid ; "NO NAME    "
                add     di, 125         ; BDS.volid
                mov     cx, 11          ; VOLID_SIZ (12 for MSDOS 5.0-6.22 versions)
                cld
                retn
preset_volid_addr endp

; ---------------------------------------------------------------------------

transfer_volume_id:                     ; CODE XREF: set_volume_id+C↑p
                push    di
                push    cx
                push    si
                call    preset_volid_addr
                rep movsb
                pop     si
; START OF FUNCTION CHUNK FOR check_volume_id

chk_volid_ok:                           ; CODE XREF: check_volume_id+7↓j
                pop     cx
                pop     di
                retn
; END OF FUNCTION CHUNK FOR check_volume_id

; =============== S U B R O U T I N E =======================================


check_volume_id proc near               ; CODE XREF: check_vid+28↑p

; FUNCTION CHUNK AT 1DE3 SIZE 00000003 BYTES

                push    di
                push    cx
                call    preset_volid_addr
                repe cmpsb
                jmp     short chk_volid_ok
check_volume_id endp


; =============== S U B R O U T I N E =======================================


fat_check       proc near               ; CODE XREF: checkfatvid↑p
                push    ax
                xor     si, si          ; say fat id's are same.
                mov     al, ds:medbyt
                cmp     al, es:[di+10h] ; [es:di+BDS.media]
                                        ; compare it with the bds medbyte
                jz      short okret1
                dec     si

okret1:                                 ; CODE XREF: fat_check+A↑j
                pop     ax
                retn
fat_check       endp

; ---------------------------------------------------------------------------
                db 2 dup(0)
BIOSCODE        ends

; ===========================================================================

; Segment type: Regular
SYSINIT         segment byte public 'SYSINIT' use16
                assume cs:SYSINIT
                assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
SYSINIT$        dw 0
stackcount      dw 0                    ; DATA XREF: stackinit+D↓w
                                        ; stackinit+35↓r ...
stackat         dw 0                    ; DATA XREF: stackinit+3E↓w
                                        ; stackinit+47↓r
stacksize       dw 0                    ; DATA XREF: stackinit+14↓w
                                        ; stackinit+4C↓r ...
stacks          dw 2 dup(0)             ; DATA XREF: SYSINIT:firstentry↓o
                                        ; stackinit+1C↓w ...
firstentry      dw offset stacks        ; DATA XREF: do_int_stacks:foundbad02↓r
                                        ; longpath:inuse↓r ...
lastentry       dw 48h                  ; DATA XREF: longpath↓r
                                        ; stackinit+87↓w
                                        ; stacks+(defaultcount*entrysize)-entrysize
nextentry       dw 48h                  ; DATA XREF: do_int_stacks+8↓r
                                        ; do_int_stacks+17↓w ...
                                        ; stacks+(defaultcount*entrysize)-entrysize
old02           dd 0                    ; DATA XREF: SYSINIT:002D↓r
                                        ; SYSINIT:0036↓o ...
; ---------------------------------------------------------------------------

int02:                                  ; DATA XREF: stackinit+AF↓o
                push    ax
                push    es
                mov     ax, 0F000h
                mov     es, ax
                assume es:nothing
                cmp     byte ptr es:0FFFEh, 0F9h ; mdl_convert ; check if convertible
                pop     es
                assume es:nothing
                jnz     short normal02
                in      al, 62h         ; PC/XT PPI port C. Bits:
                                        ; 0-3: values of DIP switches
                                        ; 5: 1=Timer 2 channel out
                                        ; 6: 1=I/O channel check
                                        ; 7: 1=RAM parity check error occurred.
                test    al, 80h
                jz      short normal02
                pop     ax
                jmp     cs:old02
; ---------------------------------------------------------------------------

normal02:                               ; CODE XREF: SYSINIT:0024↑j
                                        ; SYSINIT:002A↑j
                pop     ax
                call    near ptr do_int_stacks
; ---------------------------------------------------------------------------
                dw offset old02
old08           dd 0                    ; DATA XREF: SYSINIT:003F↓o
                                        ; stackinit+BB↓o
; ---------------------------------------------------------------------------

int08:                                  ; DATA XREF: stackinit+BE↓o
                call    near ptr do_int_stacks
; ---------------------------------------------------------------------------
                dw offset old08
old09           dd 0                    ; DATA XREF: SYSINIT:004C↓o
                                        ; stackinit+CA↓o
; ---------------------------------------------------------------------------

int09:                                  ; DATA XREF: stackinit+CD↓o
                jmp     short keyboard_lbl
; ---------------------------------------------------------------------------
                nop
; ---------------------------------------------------------------------------
                db 0
; ---------------------------------------------------------------------------

keyboard_lbl:                           ; CODE XREF: SYSINIT:int09↑j
                call    near ptr do_int_stacks
; ---------------------------------------------------------------------------
                dw offset old09
old70           dd 0                    ; DATA XREF: SYSINIT:0055↓o
                                        ; stackinit+D9↓o
; ---------------------------------------------------------------------------

int70:                                  ; DATA XREF: stackinit+DC↓o
                call    near ptr do_int_stacks
; ---------------------------------------------------------------------------
                dw offset old70
; ---------------------------------------------------------------------------

int0A:                                  ; DATA XREF: stackinit+119↓o
                jmp     short entry_int0A_stk
; ---------------------------------------------------------------------------
old0A           dd 0                    ; DATA XREF: SYSINIT:006C↓o
                                        ; stackinit+116↓o
                dw 424Bh
firstflag0A     db 0
; ---------------------------------------------------------------------------
                jmp     short intret_0A
; ---------------------------------------------------------------------------
byte_5392       db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int0A_stk:                        ; CODE XREF: SYSINIT:int0A↑j
                call    near ptr do_int_stacks
; ---------------------------------------------------------------------------
                dw offset old0A
; ---------------------------------------------------------------------------

intret_0A:                              ; CODE XREF: SYSINIT:0060↑j
                iret
; ---------------------------------------------------------------------------

int0B:                                  ; DATA XREF: stackinit+159↓o
                jmp     short entry_int0B_stk
; ---------------------------------------------------------------------------
old0B           dd 0                    ; DATA XREF: SYSINIT:0084↓o
                                        ; stackinit+156↓o
                dw 424Bh
firstflag0B     db 0
; ---------------------------------------------------------------------------
                jmp     short intret_0B
; ---------------------------------------------------------------------------
                db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int0B_stk:                        ; CODE XREF: SYSINIT:int0B↑j
                call    near ptr do_int_stacks
; ---------------------------------------------------------------------------
                dw offset old0B
; ---------------------------------------------------------------------------

intret_0B:                              ; CODE XREF: SYSINIT:0078↑j
                iret
; ---------------------------------------------------------------------------

int0C:                                  ; DATA XREF: stackinit+199↓o
                jmp     short entry_int0C_stk
; ---------------------------------------------------------------------------
old0C           dd 0                    ; DATA XREF: SYSINIT:009C↓o
                                        ; stackinit+196↓o
                dw 424Bh
firstflag0C     db 0
; ---------------------------------------------------------------------------
                jmp     short intret_0C
; ---------------------------------------------------------------------------
                db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int0C_stk:                        ; CODE XREF: SYSINIT:int0C↑j
                call    near ptr do_int_stacks
; ---------------------------------------------------------------------------
                dw offset old0C
; ---------------------------------------------------------------------------

intret_0C:                              ; CODE XREF: SYSINIT:0090↑j
                iret
; ---------------------------------------------------------------------------

int0D:                                  ; DATA XREF: stackinit+1D9↓o
                jmp     short int0D_stk
; ---------------------------------------------------------------------------
old0D           dd 0                    ; DATA XREF: SYSINIT:00B4↓o
                                        ; stackinit+1D6↓o
                dw 424Bh
firstflag0D     db 0
; ---------------------------------------------------------------------------
                jmp     short intret_0D
; ---------------------------------------------------------------------------
                db 7 dup(0)
; ---------------------------------------------------------------------------

int0D_stk:                              ; CODE XREF: SYSINIT:int0D↑j
                call    near ptr do_int_stacks
; ---------------------------------------------------------------------------
                dw offset old0D
; ---------------------------------------------------------------------------

intret_0D:                              ; CODE XREF: SYSINIT:00A8↑j
                iret
; ---------------------------------------------------------------------------

int0E:                                  ; DATA XREF: stackinit+219↓o
                jmp     short entry_int0E_stk
; ---------------------------------------------------------------------------
old0E           dd 0                    ; DATA XREF: SYSINIT:00CC↓o
                                        ; stackinit+216↓o
                dw 424Bh
firstflag0E     db 0
; ---------------------------------------------------------------------------
                jmp     short intret_0E
; ---------------------------------------------------------------------------
                db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int0E_stk:                        ; CODE XREF: SYSINIT:int0E↑j
                call    near ptr do_int_stacks
; ---------------------------------------------------------------------------
                dw offset old0E
; ---------------------------------------------------------------------------

intret_0E:                              ; CODE XREF: SYSINIT:00C0↑j
                iret
; ---------------------------------------------------------------------------

int72:                                  ; DATA XREF: stackinit+259↓o
                jmp     short entry_int72_stk
; ---------------------------------------------------------------------------
old72           dd 0                    ; DATA XREF: SYSINIT:00E4↓o
                                        ; stackinit+256↓o
                dw 424Bh
firstflag72     db 0
; ---------------------------------------------------------------------------
                jmp     short intret_72
; ---------------------------------------------------------------------------
                db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int72_stk:                        ; CODE XREF: SYSINIT:int72↑j
                call    near ptr do_int_stacks
; ---------------------------------------------------------------------------
                dw offset old72
; ---------------------------------------------------------------------------

intret_72:                              ; CODE XREF: SYSINIT:00D8↑j
                iret
; ---------------------------------------------------------------------------

int73:                                  ; DATA XREF: stackinit+299↓o
                jmp     short entry_int73_stk
; ---------------------------------------------------------------------------
old73           dd 0                    ; DATA XREF: SYSINIT:00FC↓o
                                        ; stackinit+296↓o
                dw 424Bh
firstflag73     db 0
; ---------------------------------------------------------------------------
                jmp     short intret_73
; ---------------------------------------------------------------------------
                db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int73_stk:                        ; CODE XREF: SYSINIT:int73↑j
                call    near ptr do_int_stacks
; ---------------------------------------------------------------------------
                dw offset old73
; ---------------------------------------------------------------------------

intret_73:                              ; CODE XREF: SYSINIT:00F0↑j
                iret
; ---------------------------------------------------------------------------

int74:                                  ; DATA XREF: stackinit+2D9↓o
                jmp     short entry_int74_stk
; ---------------------------------------------------------------------------
old74           dd 0                    ; DATA XREF: SYSINIT:0114↓o
                                        ; stackinit+2D6↓o
                dw 424Bh
firstflag74     db 0
; ---------------------------------------------------------------------------
                jmp     short intret_74
; ---------------------------------------------------------------------------
                db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int74_stk:                        ; CODE XREF: SYSINIT:int74↑j
                call    near ptr do_int_stacks
; ---------------------------------------------------------------------------
                dw offset old74
; ---------------------------------------------------------------------------

intret_74:                              ; CODE XREF: SYSINIT:0108↑j
                iret
; ---------------------------------------------------------------------------

int76:                                  ; DATA XREF: stackinit+319↓o
                jmp     short entry_int76_stk
; ---------------------------------------------------------------------------
old76           dd 0                    ; DATA XREF: SYSINIT:012C↓o
                                        ; stackinit+316↓o
                dw 424Bh
firstflag76     db 0
; ---------------------------------------------------------------------------
                jmp     short intret_76
; ---------------------------------------------------------------------------
                db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int76_stk:                        ; CODE XREF: SYSINIT:int76↑j
                call    near ptr do_int_stacks
; ---------------------------------------------------------------------------
                dw offset old76
; ---------------------------------------------------------------------------

intret_76:                              ; CODE XREF: SYSINIT:0120↑j
                iret
; ---------------------------------------------------------------------------

int77:                                  ; DATA XREF: stackinit+359↓o
                jmp     short entry_int77_stk
; ---------------------------------------------------------------------------
old77           dd 0                    ; DATA XREF: SYSINIT:0144↓o
                                        ; stackinit+356↓o
                dw 424Bh
firstflag77     db 0
; ---------------------------------------------------------------------------
                jmp     short intret_77
; ---------------------------------------------------------------------------
                db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int77_stk:                        ; CODE XREF: SYSINIT:int77↑j
                call    near ptr do_int_stacks
; ---------------------------------------------------------------------------
                dw offset old77
; ---------------------------------------------------------------------------

intret_77:                              ; CODE XREF: SYSINIT:0138↑j
                iret

; =============== S U B R O U T I N E =======================================


do_int_stacks   proc far                ; CODE XREF: SYSINIT:0033↑p
                                        ; SYSINIT:int08↑p ...
                push    ax
                push    bp
                push    es
                mov     es, cs:stacks+2 ; Get segment of stacks
                assume es:nothing
                mov     bp, cs:nextentry ; get most likely candidate
                mov     al, 1           ; allocated
                xchg    al, es:[bp+0]   ; grab the entry
                cmp     al, 0           ; free ; still avail?
                jnz     short notfree02
                sub     cs:nextentry, 8 ; entrysize ; set for next interrupt

found02:                                ; CODE XREF: do_int_stacks+73↓j
                mov     es:[bp+2], sp   ; [es:bp+savedsp],sp ; save sp value
                mov     word ptr es:[bp+4], ss ; [es:bp+savedss],ss ; save ss also
                mov     ax, bp          ; temp save of table offset
                mov     bp, es:[bp+6]   ; [es:bp+newsp] ; get new SP value
                cmp     es:[bp+0], ax   ; check for offset into table
                jnz     short foundbad02
                mov     ax, es          ; point ss,sp to the new stack
                mov     es, bp
                assume es:nothing
                mov     bp, sp
                mov     bp, [bp+6]
                mov     ss, ax
                assume ss:nothing
                mov     sp, es
                mov     es, ax
                assume es:nothing
                mov     bp, cs:[bp+0]
                pushf                   ; go execute the real interrupt handler
                call    dword ptr cs:[bp+0] ; which will iret back to here
                                        ; call far [cs:bp]
                mov     bp, sp          ; retrieve the table offset for us
                mov     bp, es:[bp+0]   ; but leave it on the stack
                mov     ss, word ptr es:[bp+4] ; [es:bp+savedss] ; get old stack back
                assume ss:nothing
                mov     sp, es:[bp+2]   ; [es:bp+savedsp]
                mov     byte ptr es:[bp+0], 0 ; [es:bp+allocbyte],free ; free the entry
                mov     cs:nextentry, bp ; setup to use next time
                pop     es              ; saved on entry
                assume es:nothing
                pop     bp              ; saved on entry
                pop     ax              ; saved on entry
                add     sp, 2           ; (skip near call return addr)
                iret                    ; done with this interrupt
; ---------------------------------------------------------------------------

notfree02:                              ; CODE XREF: do_int_stacks+15↑j
                cmp     al, 1           ; allocated ; error flag
                jz      short findnext02 ; no, continue
                xchg    al, es:[bp+0]   ; [es:bp+allocbyte] ; yes, restore error value

findnext02:                             ; CODE XREF: do_int_stacks+6A↑j
                                        ; do_int_stacks+7A↓j ...
                call    longpath
                jmp     short found02
; ---------------------------------------------------------------------------

foundbad02:                             ; CODE XREF: do_int_stacks+2F↑j
                cmp     bp, cs:firstentry
                jb      short findnext02
                mov     bp, ax          ; flag this entry
                mov     byte ptr es:[bp+0], 3 ; clobbered
                jmp     short findnext02 ; keep looking
do_int_stacks   endp


; =============== S U B R O U T I N E =======================================


longpath        proc near               ; CODE XREF: do_int_stacks:findnext02↑p
                mov     bp, cs:lastentry ; start with last entry in table

lploopp:                                ; CODE XREF: longpath+28↓j
                cmp     byte ptr es:[bp+0], 0 ; free ?
                jnz     short inuse     ; no, try next one
                mov     al, 1
                xchg    al, es:[bp+0]   ; [es:bp+allocbyte] ; allocate entry
                cmp     al, 0           ; is it still free?
                jz      short found     ; yes, go use it
                cmp     al, 1           ; allocated ?
                                        ; is it other than Allocated or Free?
                jz      short inuse     ; no, check the next one
                mov     es:[bp+0], al   ; yes, put back the error state

inuse:                                  ; CODE XREF: longpath+A↑j
                                        ; longpath+18↑j
                cmp     bp, cs:firstentry
                jz      short fatal
                sub     bp, 8
                jmp     short lploopp
; ---------------------------------------------------------------------------

found:                                  ; CODE XREF: longpath+14↑j
                retn
; ---------------------------------------------------------------------------

fatal:                                  ; CODE XREF: longpath+23↑j
                push    ds
                mov     ax, 0F000h      ; look at the model byte
                mov     ds, ax
                assume ds:nothing
                cmp     byte ptr ds:0FFFEh, 0F9h ; mdl_convert ; convertible?
                pop     ds
                assume ds:nothing
                jnz     short skip_nmis
                mov     al, 7           ; disable pc convertible nmis
                out     72h, al         ; CMOS Memory/RTC Index Register (Extended RAM)

skip_nmis:                              ; CODE XREF: longpath+37↑j
                cli                     ; disable and mask
                mov     al, 0FFh        ; all other ints
                out     21h, al         ; Interrupt controller, 8259A.
                out     0A1h, al        ; Interrupt Controller #2, 8259A
                mov     si, cs
                mov     ds, si
                assume ds:SYSINIT
                mov     si, offset fatal_msg ; "\r\n\a\r\nInternal stack overflow\r\nSy"...
                push    ax
                push    ds
                mov     ax, 70h         ; DOSBIODATASEG (BIOSDATA segment)
                mov     ds, ax
                assume ds:nothing
                test    ds:IsWin386, 1  ; BIOSDATA:0812h
                pop     ds
                assume ds:nothing
                pop     ax
                jz      short fatal_loop
                call    far ptr 70h:813h ; call DOSBIODATASEG:V86_Crit_SetFocus

fatal_loop:                             ; CODE XREF: longpath+59↑j
                                        ; longpath+6B↓j
                lodsb
                cmp     al, 24h ; '$'
                jz      short fatal_done
                mov     bl, 7
                mov     ah, 0Eh
                int     10h             ; (whoops, this enables ints)
                                        ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
                                        ; AL = character, BH = display page (alpha modes)
                                        ; BL = foreground color (graphics modes)
                jmp     short fatal_loop
; ---------------------------------------------------------------------------

fatal_done:                             ; CODE XREF: longpath+63↑j
                                        ; longpath:fatal_done↓j
                jmp     short fatal_done
longpath        endp

; ---------------------------------------------------------------------------
fatal_msg       db 0Dh,0Ah              ; DATA XREF: longpath+48↑o
                db 7,0Dh,0Ah
                db 'Internal stack overflow',0Dh,0Ah
                db 'System halted',0Dh,0Ah,'$'
; ---------------------------------------------------------------------------

_SYSINIT:                               ; DATA XREF: endfile+285↓o
                jmp     goinit
; ---------------------------------------------------------------------------
runhigh         db 0                    ; DATA XREF: SYSINIT:0823↓r
                                        ; SYSINIT:dolast↓r ...
DOSINFO         dd 0                    ; DATA XREF: SYSINIT:05A5↓w
                                        ; SYSINIT:NoRPLArena↓r ...
                                        ; address of the DOS Sysini Variables
dosinit         dw 0                    ; DATA XREF: SYSINIT:0543↓w
                                        ; SYSINIT:058A↓r ...
CURRENTDOSLOCATION dw 0                 ; DATA XREF: BIOSDATA:1F84↑w
                                        ; BIOSDATA:2429↑r ...
DEVICE_LIST     dd 0                    ; DATA XREF: BIOSDATA:1F71↑w
                                        ; SYSINIT:0577↓r ...
sysi_country    dd 0                    ; DATA XREF: SYSINIT:05B5↓w
                                        ; doconf:tryq_set_for_dos↓r ...
                                        ; pointer to country table in dos
dos_segreinit   dd 0                    ; DATA XREF: SYSINIT:059D↓w
                                        ; SYSINIT:0832↓r ...
                                        ; room for dword
lo_doscod_size  dw 0                    ; DATA XREF: SYSINIT:0598↓w
                                        ; MovDOSLo+8↓r ...
                                        ; dos code size when in low mem
hi_doscod_size  dw 0                    ; DATA XREF: SYSINIT:0594↓w
                                        ; MovDOSHi+D↓r
                                        ; dos code size when in HMA
def_php         dw 0                    ; DATA XREF: SYSINIT:058F↓w
                                        ; SYSINIT:06E6↓r
_seg_reinit_ptr dw offset _seg_reinit   ; DATA XREF: SYSINIT:056D↓r
                                        ; MovBIOS+1B↓r
                                        ; BIOSCODE:0032h
temp_bcode_seg  dw 364h                 ; DATA XREF: SYSINIT:0556↓w
                                        ; MovBIOS↓r
                                        ; DOSBIOCODESEG (BIOSCODE)
fake_floppy_drv db 0                    ; DATA XREF: SYSINIT:0466↓w
                                        ; fooset+1F↓r
                                        ; set to 1 if this machine
                                        ; does not have any floppies!!!
stack_count     dw 9                    ; DATA XREF: endfile:doinstallstack↓r
                                        ; endfile+2BF↓r ...
                                        ; defaultcount ; 9
stack_size      dw 128                  ; DATA XREF: endfile+2BA↓r
                                        ; stackinit+11↓r ...
                                        ; defaultsize  ; 128
stack_addr      dw 2 dup(0)             ; DATA XREF: endfile+256↓r
                                        ; endfile+2A5↓w ...
MEMORY_SIZE     dw 1                    ; DATA XREF: BIOSDATA:1F7B↑w
                                        ; BIOSDATA:1F96↑r ...
RPLMemTop       dw 0                    ; DATA XREF: SYSINIT:04A5↓w
                                        ; SYSINIT:05CB↓r ...
DEFAULT_DRIVE   db 0                    ; DATA XREF: BIOSDATA:1F80↑w
                                        ; remap+60↑w ...
                                        ; initialized by ibminit
buffers         dw 0FFFFh               ; DATA XREF: endfile+102↓r
                                        ; endfile+112↓w ...
                                        ; initialized during buffer allocation
h_buffers       dw 0                    ; DATA XREF: endfile:dodefaultbuff↓w
                                        ; endfile+1AF↓r ...
                                        ; # of the heuristic buffers. initially 0.
singlebuffersize dw 0                   ; DATA XREF: SYSINIT:0643↓w
                                        ; SYSINIT:068A↓r ...
                                        ; maximum sector size + buffer head
FILES           db 8                    ; DATA XREF: endfile+31↓r
                                        ; endfile:dosdata_noumb↓r ...
                                        ; enough files for pipe
FCBS            db 4                    ; DATA XREF: endfile+95↓r
                                        ; doconf+9B5↓w
                                        ; performance for recycling
KEEP            db 0                    ; DATA XREF: endfile+B0↓r
                                        ; doconf+9B9↓w
                                        ; keep original set
NUM_CDS         db 5                    ; DATA XREF: endfile+211↓r
                                        ; endfile+218↓r ...
                                        ; 5 net drives
CONFBOT         dw 0                    ; DATA XREF: SYSINIT:06A9↓w
                                        ; endfile+14↓r ...
ALLOCLIM        dw 0                    ; DATA XREF: SYSINIT:06A5↓w
                                        ; endfile+18↓w ...
top_of_cdss     dw 0                    ; DATA XREF: SYSINIT:069A↓w
                                        ; TempCDS+17↓r
DirStrng        db 'A:\',0              ; DATA XREF: fooset↓r
                                        ; fooset+D↓w ...
                                        ; string for the root directory of a drive
ZERO            db 0                    ; DATA XREF: SYSINIT:EXEC0_6C_FCB↓o
sepchr          db 0                    ; DATA XREF: check_switch+3F↓w
                                        ; check_switch+48↓w ...
linecount       dw 0                    ; DATA XREF: multi_pass+1C↓w
                                        ; doconf+CB↓w ...
                                        ; line count in config.sys
showcount       db '     ',0Dh,0Ah,'$'  ; DATA XREF: showlinenum+7↓o
                                        ; used to convert linecount to ascii.
buffer_linenum  dw 0                    ; DATA XREF: doconf+22D↓w
                                        ; line count for "buffers=" command if entered.
sys_model_byte  db 0FFh                 ; DATA XREF: SYSINIT:0428↓w
                                        ; SYSINIT:043E↓w ...
                                        ; model byte used in sysinit
sys_scnd_model_byte db 0                ; DATA XREF: SYSINIT:0430↓w
                                        ; endfile+25D↓r
                                        ; secondary model byte used in sysinit
buf_prev_off    dw 0                    ; DATA XREF: set_buffer_info↓r
                                        ; set_buffer_info+9↓w
EXEC0_ENVIRON   dw 0                    ; DATA XREF: SYSINIT:09D6↓o
                                        ; COMEXE  ; seg addr of environment
EXEC0_COM_LINE  dw offset command_line  ; pointer to asciz command line
                dw 544h                 ; SYSINIT segment
EXEC0_5C_FCB    dw offset DEFAULT_DRIVE
                dw 544h                 ; SYSINIT segment
EXEC0_6C_FCB    dw offset ZERO
                dw 544h                 ; SYSINIT segment
multi_pass_id   db 0                    ; DATA XREF: SYSINIT:skip_magicbackdoor↓w
                                        ; SYSINIT:0873↓w ...
                                        ; parameter passed to multi_pass
                                        ; indicating the pass number
                                        ;  0 - do scan for DOS=HIGH/LOW
                                        ;  1 - load device drivers
                                        ;  2 - was to load IFS
                                        ;      now it is unused
                                        ;  3 - do install=
                                        ; >3 - nop
install_flag    dw 0                    ; DATA XREF: SYSINIT:08A4↓r
                                        ; SYSINIT:08DA↓r ...
                                        ; bit 0 - config.sys has install= commands
                                        ; bit 1 - sysinit_base installed
config_size     dw 0                    ; DATA XREF: sum_up+B↓r
                                        ; doconf+3F↓w
                                        ; size of config.sys file
sysinit_base_ptr dd 0                   ; DATA XREF: endfile+40E↓w
                                        ; do_install_exec+70↓r ...
                                        ; pointer to sysinit_base
sysinit_ptr     dw 2 dup(0)             ; DATA XREF: endfile+427↓w
                                        ; SYSINIT:sysinit_base_end↓r ...
                                        ; returning address from sysinit_base
checksum        dw 0                    ; DATA XREF: do_install_exec+63↓w
                                        ; SYSINIT:1458↓r
                                        ; used by sum_up
ldexec_fcb      db 14h dup(20h)         ; DATA XREF: SYSINIT:iexec_ldexec_5c_fcb↓o
                                        ; SYSINIT:iexec_ldexec_6c_fcb↓o
                                        ; db 20 dup (' ') ; big enough
ldexec_line     db 0                    ; DATA XREF: SYSINIT:iexec_ldexec_line↓o
                                        ; do_install_exec:done_installparm↓w
                                        ; # of parm characters
ldexec_start    db ' '                  ; DATA XREF: do_install_exec+A↓w
                                        ; do_install_exec+31↓w
ldexec_parm     db 80 dup(  0)          ; DATA XREF: do_install_exec+10↓o
                                        ; times 80 db 0
iexec_environ   dw 0                    ; DATA XREF: do_install_exec:no_envdata2↓w
                                        ; do_install_exec+6B↓o
                                        ; instexe ; seg addr of environment
iexec_ldexec_line dw offset ldexec_line ; pointer to asciiz command line
iexec_ldexec_line_seg dw 544h           ; DATA XREF: do_install_exec+54↓w
iexec_ldexec_5c_fcb dw offset ldexec_fcb ; default fcb at 5Ch
iexec_ldexec_5c_fcb_seg dw 544h         ; DATA XREF: do_install_exec+58↓w
iexec_ldexec_6c_fcb dw offset ldexec_fcb ; default fcb at 6Ch
iexec_ldexec_6c_fcb_seg dw 544h         ; DATA XREF: do_install_exec+5C↓w
com_level       db 0                    ; DATA XREF: organize+D↓w
                                        ; organize+26↓w ...
                                        ; level of " " in command line
cmmt            db 0                    ; DATA XREF: organize+151↓w
                                        ; organize+16E↓w ...
                                        ; length of comment string token
cmmt1           db 0                    ; DATA XREF: organize+14D↓w
                                        ; skip_comment+15↓r
                                        ; token
cmmt2           db 0                    ; DATA XREF: organize+16A↓w
                                        ; skip_comment+28↓r
                                        ; token
cmd_indicator   db 0                    ; DATA XREF: organize+99↓w
                                        ; organize:org3↓r ...
donotshownum    db 0                    ; DATA XREF: SYSINIT:ConfigDone↓w
                                        ; badfil+22↓r
count           dw 0                    ; DATA XREF: doconf+2E↓w
                                        ; doconf+3C↓r ...
org_count       dw 0                    ; DATA XREF: multi_pass+E↓r
                                        ; SYSINIT:44BD↓w ...
chrptr          dw 0                    ; DATA XREF: multi_pass+18↓w
                                        ; doconf:multi_pass_adjust↓w ...
cntryfilehandle dw 0                    ; DATA XREF: doconf+748↓w
                                        ; doconf:coffj4↓r
old_area        dw 0                    ; DATA XREF: SYSINIT:08E5↓r
                                        ; endfile+440↓w
impossible_owner_size dw 0              ; DATA XREF: SYSINIT:08EA↓r
                                        ; endfile+3F9↓w
                                        ; paragraph
memlo           dw 0                    ; DATA XREF: endfile+42↓r
                                        ; endfile+5B↓r ...
                                        ; bufptr, bucketptr (dword)
memhi           dw 0                    ; DATA XREF: SYSINIT:wfk2s_8↓r
                                        ; AllocFreeMem+F↓w ...
                                        ; prmblk (word)
ldoff           dw 0
area            dw 0                    ; DATA XREF: SYSINIT:07E3↓r
                                        ; SYSINIT:07F1↓r ...
prev_memhi      dw 0                    ; DATA XREF: endfile+22↓w
                                        ; endfile+313↓r ...
prev_alloclim   dw 0                    ; DATA XREF: endfile+2A↓w
                                        ; endfile+35F↓r
dosdata_umb     db 0                    ; DATA XREF: endfile+2DE↓r
                                        ; endfile+352↓w ...
packet          db 25                   ; DATA XREF: MagicPreload+4D↓o
                                        ; calldev+15↓o
                                        ; was 24 (in MSDOS 6.21)
                db 0
                db 0                    ; initialize code
                dw 0
                db 8 dup(0)
unitcount       db 0                    ; DATA XREF: MagicPreload:_isblock↓r
                                        ; doconf:isblock↓r
break_addr      dw 2 dup(0)             ; DATA XREF: MagicPreload+50↓w
                                        ; MagicPreload:magic_is_resident↓r ...
bpb_addr        dd 0                    ; DATA XREF: MagicPreload+11D↓r
                                        ; MagicPostload+24↓w ...
devdrivenum     db 0                    ; DATA XREF: MagicPreload+63↓w
                                        ; doconf+476↓w
configmsgflag   db 0                    ; DATA XREF: doconf+481↓w
                                        ; doconf+4E0↓r ...
                                        ; used to control "error in config.sys line #" message
                                        ; (configmsgflag is the last word of the 25 byte packet)
                                        ; ((default value is 0, device driver init may change? it))
                db 0
drivenumber     db 0                    ; DATA XREF: SYSINIT:0681↓w
                                        ; MagicPreload+5F↓r ...
toomanydrivesflag db 0                  ; DATA XREF: dmax_check+D↑w
                                        ; SYSINIT:0716↓r
                                        ; >24 fixed disk partitions flag
BCodeSeg        dw 364h                 ; DATA XREF: MovBIOS+17↓w
                                        ; DOSBIOCODESEG (BIOSCODE segment)
_timer_lw_      dw 0                    ; DATA XREF: SYSINIT:073C↓w
                                        ; kbd_read+1D↓r
F5_key          db 0                    ; DATA XREF: SYSINIT:07C7↓w
                                        ; SYSINIT:084E↓r ...
F8_key          db 0                    ; DATA XREF: SYSINIT:wfk2s_5↓w
                                        ; SYSINIT:0856↓r ...
MagicBackdoor   dd 0                    ; DATA XREF: SYSINIT:0747↓w
                                        ; SYSINIT:0860↓r ...
; ---------------------------------------------------------------------------

NullBackdoor:                           ; DATA XREF: SYSINIT:0747↓o
                                        ; MagicPreload+88↓o
                retf
; ---------------------------------------------------------------------------
BiosComBlock    dw offset SysinitPresent
                                        ; DATA XREF: SYSINIT:0572↓r
                                        ; BIOSDATA:07DDh
                dw 70h                  ; BIOSDATA segment
tempstack       db 128 dup(0)
; ---------------------------------------------------------------------------

goinit:                                 ; CODE XREF: SYSINIT:_SYSINIT↑j
                mov     ah, 0C0h
                int     15h             ; SYSTEM - GET CONFIGURATION
                                        ; (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
                jb      short no_rom_config
                cmp     ah, 0
                jnz     short no_rom_config
                mov     al, es:[bx+2]   ; [es:bx+ROMBIOS_DESC.bios_sd_modelbyte]
                mov     cs:sys_model_byte, al
                mov     al, es:[bx+3]   ; [es:bx+ROMBIOS_DESC.bios_sd_scnd_modelbyte]
                mov     cs:sys_scnd_model_byte, al
                jmp     short move_myself
; ---------------------------------------------------------------------------

no_rom_config:                          ; CODE XREF: SYSINIT:041D↑j
                                        ; SYSINIT:0422↑j
                mov     ax, 0F000h
                mov     ds, ax
                assume ds:nothing
                mov     al, ds:0FFFEh
                mov     cs:sys_model_byte, al
                int     11h             ; EQUIPMENT DETERMINATION
                                        ; Return: AX = equipment flag bits
                jmp     short check_for_fake_floppy
; ---------------------------------------------------------------------------
                db  52h ; R             ; 'RPS' sign
                db  50h ; P
                db  53h ; S
; ---------------------------------------------------------------------------

check_for_fake_floppy:                  ; CODE XREF: SYSINIT:0444↑j
                or      ax, 1           ; (nonsense! this may be overwritten/disabled
                                        ; by using 'RPS' sign position) 03/07/2023 - Erdogan Tan
                test    ax, 1           ; have any floppies?
                jnz     short move_myself ; yes,normal system
                push    es
                xor     cl, cl
                mov     ah, 8           ; get disk parameters
                mov     dl, 0
                int     13h             ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
                                        ; DL = drive number
                                        ; Return: CF set on error, AH = status code, BL = drive type
                                        ; DL = number of consecutive drives
                                        ; DH = maximum value for head number, ES:DI -> drive parameter
                pop     es
                jb      short move_myself ; if error lets assume that the ROM BIOS lied
                cmp     cl, 0           ; double check (max sec no cannot be 0)
                jz      short move_myself
                or      dl, dl          ; number of flp drvs == 0?
                jnz     short move_myself
                mov     cs:fake_floppy_drv, 1 ; set fake flag

move_myself:                            ; CODE XREF: SYSINIT:0434↑j
                                        ; SYSINIT:044F↑j ...
                cld                     ; set up move
                xor     si, si
                mov     di, si
                mov     cx, cs:MEMORY_SIZE
                push    cs
                pop     ds
                assume ds:SYSINIT
                dec     cx
                xor     bx, bx
                mov     es, bx          ; 0
                assume es:nothing
                mov     bx, word ptr es:0BCh ; Int 2Fh vector (4*2Fh)
                mov     es, word ptr es:0BEh
                assume es:nothing
                cmp     word ptr es:[bx+3], 5052h ; 'RP'
                jnz     short NoRPL
                cmp     byte ptr es:[bx+5], 4Ch ; 'L'
                jnz     short NoRPL
                mov     dx, cx          ; get TOM into DX
                push    dx
                mov     ax, 4A06h       ; (multMULT<<8)+multMULTRPLTOM

loc_57CC:                               ; Get new TOM from any RPL
                int     2Fh
                pop     ax
                mov     cx, dx
                cmp     dx, ax
                jz      short NoRPL
                mov     cs:RPLMemTop, dx
                dec     cx

NoRPL:                                  ; CODE XREF: SYSINIT:048D↑j
                                        ; SYSINIT:0494↑j ...
                mov     ax, 5B40h       ; SI_end ; need this much room for sysinit
                                        ; (SI_end == sysinit code size)
                call    _off_to_para
                sub     cx, ax
                sub     cx, 0B00h       ; DOSSIZE/16 (2816)
                                        ; leave this much room for DOS
                mov     ax, 1E00h       ; BCODE_END
                call    _off_to_para    ; leave this much room for BIOS code
                sub     cx, ax
                mov     es, cx          ; offset where sysinit will be located
                mov     cx, 5B40h       ; SI_end ; (sysinit code size)
                shr     cx, 1           ; divide by 2 to get words
                rep movsw               ; relocate sysinit
                push    es              ; push relocated segment
                mov     ax, offset SYSIN ; SYSINIT:04F3h
                push    ax              ; push relocated entry point
                retf                    ; far jump to relocated sysinit

; =============== S U B R O U T I N E =======================================


get_cpu_type    proc near               ; CODE XREF: SYSINIT:04FB↓p
                pushf
                push    bx
                xor     bx, bx
                xor     ax, ax
                push    ax
                popf
                pushf
                pop     ax
                and     ax, 0F000h
                cmp     ax, 0F000h
                jz      short cpu_8086
                mov     ax, 0F000h
                push    ax
                popf
                pushf
                pop     ax
                and     ax, 0F000h
                jz      short cpu_286

cpu_386:
                inc     bx

cpu_286:                                ; CODE XREF: get_cpu_type+1C↑j
                inc     bx

cpu_8086:                               ; CODE XREF: get_cpu_type+10↑j
                mov     ax, bx
                pop     bx
                popf
                retn
get_cpu_type    endp

; ---------------------------------------------------------------------------

SYSIN:                                  ; DATA XREF: SYSINIT:04C9↑o
                mov     ax, 70h
                mov     ds, ax          ; DOSBIODATASEG
                assume ds:nothing
                push    es
                push    ax              ; not needed (*) E.TAN - 03/07/2023
                push    di
                call    get_cpu_type    ; determine if 386 system
                cmp     ax, 2           ; 0 = 8086, 1 = 286, 2 = 386
                jnz     short not_386_system
                cld                     ; 80386
                push    ds
                pop     es              ; change A20 line on/off check code
                assume es:nothing
                mov     di, offset cpu386_cmpsd
                mov     ax, 4B9h        ; mov cx,4 ; B90400
                stosw
                mov     ax, 0F300h      ; repz  ; F3
                stosw
                mov     ax, 0A766h      ; cmpsd ; 66A7
                stosw

not_386_system:                         ; CODE XREF: SYSINIT:0501↑j
                pop     di
                pop     ax              ; not needed (*) E.TAN - 03/07/2023
                pop     es
                assume es:nothing
                mov     ds:MoveDOSIntoHMA_2, cs ; set seg of routine to move DOS
                                        ; update SYSINITSEG field
                                        ; MoveDOSIntoHMA+2
                mov     ds:SysinitPresent, 1 ; flag that MoveDOSIntoHMA can be called
                mov     ax, 5B40h       ; SI_end ; how big is sysinitseg?
                call    _off_to_para
                mov     cx, cs          ; pick a buffer for msdos above us
                add     ax, cx
                mov     es, ax
                xor     si, si
                mov     di, si
                mov     ds, cs:CURRENTDOSLOCATION ; where it is (set by msinit)
                assume ds:nothing
                mov     cx, 5800h       ; DOSSIZE/2 (22528)
                rep movsw
                mov     cs:CURRENTDOSLOCATION, es
                mov     ax, ds:3        ; get offset of dos
                                        ; ax = 3F10h for IBMDOS 7.1 kernel
                                        ;  (IBMDOS.SYS, offset 3)
                mov     cs:dosinit, ax
                call    _off_to_para    ; subtract this much from segment
                sub     cs:CURRENTDOSLOCATION, ax ; FINAL_DOS_LOCATION
                mov     ax, es
                add     ax, 0B00h       ; DOSSIZE/16 ; DOSSIZE = 0B000h = 45056
                mov     es, ax
                assume es:nothing
                xchg    ax, cs:temp_bcode_seg ; swap with original home of Bios_Code
                mov     ds, ax          ; point to loaded image of Bios_Code
                assume ds:nothing
                mov     si, offset Bios_Data_Word ; BCODESTART (= BiosDataWord)
                                        ; BIOSCODE:BCODESTART (BIOSCODE:0030h)
                mov     di, si
                mov     cx, 1E00h       ; BCODE_END = (SYSINITSEG-DOSBIOCODESEG)*16
                                        ; (544h-364h)*10h = 1E00h (for PCDOS 7.1 IBMBIO.COM)
                sub     cx, si
                shr     cx, 1
                rep movsw               ; move Bios_Code into place
                mov     ax, es          ; tell it what segment it's in
                call    dword ptr cs:_seg_reinit_ptr
                les     di, dword ptr cs:BiosComBlock
                assume es:nothing
                lds     si, cs:DEVICE_LIST
                assume ds:nothing
                mov     dx, cs:MEMORY_SIZE
                cli
                mov     ax, cs
                mov     ss, ax
                assume ss:SYSINIT

locstack:                               ; DATA XREF: SYSINIT:locstack↓o
                                        ; sum_up:sum_sys_code↓o
                mov     sp, offset locstack ; set stack
                                        ; mov sp, 586h ; mov sp, locstack
                                        ; %define locstack ($ - SYSINIT$) & 0FFFEh
                                        ; locstack = $ & 0FFFEh (SYSINIT:SYSINITŞ=544h:0)
                sti
                call    dword ptr cs:dosinit ; call dosinit
                                        ; es:di -> sysinitvars_ext
                mov     cs:def_php, ds  ; save pointer to PSP
                mov     cs:hi_doscod_size, ax ; size of doscode (including exepatch)
                mov     cs:lo_doscod_size, cx ; (as exepatch excluded)
                mov     word ptr cs:dos_segreinit, dx ; save offset of segreinit
                mov     ax, es:[di]     ; [es:di+SysInitVars_Ext.SYSI_InitVars]
                mov     word ptr cs:DOSINFO, ax
                mov     ax, es:[di+2]
                mov     word ptr cs:DOSINFO+2, ax
                mov     ax, es:[di+4]   ; [es:di+SysInitVars_Ext.SYSI_Country_Tab]
                mov     word ptr cs:sysi_country, ax
                mov     ax, es:[di+6]   ; [es:di+SysInitVars_Ext.SYSI_Country_Tab+2]
                mov     word ptr cs:sysi_country+2, ax
                mov     es, cs:CURRENTDOSLOCATION ; = [FINAL_DOS_LOCATION]
                mov     word ptr cs:dos_segreinit+2, es
                cmp     cs:RPLMemTop, 0
                jz      short NoRPLArena
                mov     bx, 0FFFFh
                mov     ah, 48h
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                mov     ah, 48h
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                mov     es, ax
                push    es              ; resize upto RPL mem
                sub     ax, cs:RPLMemTop
                neg     ax
                dec     ax
                mov     bx, ax
                mov     ah, 4Ah
                int     21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
                                        ; ES = segment address of block to change
                                        ; BX = new size in paragraphs
                mov     bx, 0FFFFh
                mov     ah, 48h
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                mov     ah, 48h
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                dec     ax
                mov     es, ax
                mov     word ptr es:1, 8 ; [es:arena_owner]
                mov     word ptr es:8, 5052h ; [es:arena_name],'RP'
                mov     word ptr es:10, 4Ch ; 'L' ; [es:arena_name+2],'L'
                mov     word ptr es:12, 0 ; [es:arena_name+4]
                mov     word ptr es:14, 0 ; [es:arena_name+6]
                pop     es
                mov     ah, 49h         ; Dealloc
                int     21h             ; DOS - 2+ - FREE MEMORY
                                        ; ES = segment address of area to be freed

NoRPLArena:                             ; CODE XREF: SYSINIT:05D1↑j
                les     di, cs:DOSINFO
                clc
                mov     ah, 88h
                int     15h             ; Get Extended Memory Size
                                        ; Return: CF clear on success
                                        ; AX = size of memory above 1M in K
                jb      short no_ext_memory
                mov     es:[di+45h], ax ; [es:di+SYSI_EXT_MEM]
                or      ax, ax
                jz      short no_ext_memory
                call    ClrVDISKHeader

no_ext_memory:                          ; CODE XREF: SYSINIT:062F↑j
                                        ; SYSINIT:0637↑j
                mov     ax, es:[di+10h] ; [es:di+SYSI_MAXSEC]
                add     ax, 24          ; bufinsiz
                                        ; size of buffer header = 24 (PCDOS v7.1 IBMBIO.COM)
                                        ; (it was 20 in MSDOS 6.21 IO:SYS)
                mov     cs:singlebuffersize, ax ; total size for a buffer
                mov     al, cs:DEFAULT_DRIVE
                mov     es:[di+43h], al ; [es:di+SYSI_BOOT_DRIVE]

_get_cpu_type:
                pushf
                push    bx
                xor     bx, bx
                xor     ax, ax
                push    ax
                popf
                pushf
                pop     ax
                and     ax, 0F000h
                cmp     ax, 0F000h
                jz      short _cpu_8086
                mov     ax, 0F000h
                push    ax
                popf
                pushf
                pop     ax
                and     ax, 0F000h
                jz      short _cpu_286

_cpu_386:
                inc     bx

_cpu_286:                               ; CODE XREF: SYSINIT:066B↑j
                inc     bx

_cpu_8086:                              ; CODE XREF: SYSINIT:065F↑j
                mov     ax, bx
                pop     bx
                popf
                cmp     ax, 2
                jnz     short _not_386_cpu
                mov     byte ptr es:[di+44h], 1 ; [es:di+SYSI_DWMOVE],1
                                        ; set doubleword moving flag

_not_386_cpu:                           ; CODE XREF: SYSINIT:0676↑j
                mov     al, es:[di+20h] ; [es:di+SYSI_NUMIO]
                mov     cs:drivenumber, al ; save start of installable block drvs
                mov     ax, cs
                sub     ax, 11h         ; room for PSP we will copy shortly
                mov     cx, cs:singlebuffersize ; temporary single buffer area
                shr     cx, 1
                shr     cx, 1
                shr     cx, 1
                shr     cx, 1           ; divide size by 16..
                                        ; ...to get paragraphs...
                inc     cx              ; ... and round up
                sub     ax, cx
                mov     cs:top_of_cdss, ax ; temp "unsafe" location
                push    es
                push    di
                mov     cx, ax          ; save pointer for buffer
                sub     ax, 143         ; sub ax,((26 *(curdirlen))+15)/16
                                        ; (curdirlen=88)
                mov     cs:ALLOCLIM, ax
                mov     cs:CONFBOT, ax
                les     di, es:[di+12h] ; [es:di+SYSI_BUF]
                mov     word ptr es:[di+4], 0 ; [es:di+BUFFINF.Dirty_Buff_Count]
                mov     word ptr es:[di], 0 ; [es:di+BUFFINF.Buff_Queue]
                mov     es:[di+2], cx   ; [es:di+BUFFINF.Buff_Queue+2]
                                        ; cx = [top_of_cdss]
                mov     es, cx
                xor     ax, ax
                mov     di, ax
                mov     es:[di], ax     ; [es:di+buffinfo.buf_next],0
                mov     es:[di+2], ax   ; [es:di+buffinfo.buf_prev],0
                mov     word ptr es:[di+4], 0FFh ; [es:di+buffinfo.buf_ID],00FFh
                                        ; free buffer,clear flag
                mov     word ptr es:[di+6], 0 ; [es:di+buffinfo.buf_sector]
                mov     word ptr es:[di+8], 0 ; [es:di+buffinfo.buf_sector+2]
                pop     di
                pop     es
                push    cs
                pop     ds
                assume ds:SYSINIT
                call    TempCDS         ; set up cdss so re_init and sysinit
                                        ; can make disk system calls
                                        ; tempcds trashes ds
                mov     ds, cs:def_php  ; retrieve pointer to PSP returned by DOSINIT
                assume ds:nothing
                call    far ptr 70h:729h ; call DOSBIODATASEG:re_init
                sti
                cld
                mov     bx, cs
                sub     bx, 10h
                mov     es, bx
                assume es:nothing
                xor     si, si
                mov     di, si
                mov     cx, 128
                rep movsw
                mov     word ptr es:36h, es ; [es:PDB.JFN_POINTER+2],es ; Relocate
                mov     ah, 50h
                int     21h             ; DOS - 2+ internal - SET PSP SEGMENT
                                        ; BX = segment address of new PSP
                push    ds
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     dx, offset int24 ; set up int 24h handler
                mov     ax, 2524h
                int     21h             ; DOS - SET INTERRUPT VECTOR
                                        ; AL = interrupt number
                                        ; DS:DX = new vector to be used for specified interrupt
                cmp     toomanydrivesflag, 0
                jz      short no_err
                mov     dx, offset TooManyDrivesMsg ; "WARNING! Logical drives past Z: exist a"...
                call    print

no_err:                                 ; CODE XREF: SYSINIT:071B↑j
                pop     ds
                assume ds:nothing
                mov     dl, cs:DEFAULT_DRIVE
                or      dl, dl
                jz      short nodrvset
                dec     dl
                mov     ah, 0Eh
                int     21h             ; DOS - SELECT DISK
                                        ; DL = new default drive number (0 = A, 1 = B, etc.)
                                        ; Return: AL = number of logical drives

nodrvset:                               ; CODE XREF: SYSINIT:072B↑j
                push    ds
                sub     ax, ax
                mov     ds, ax          ; 0  ; ROMBIOS data area
                assume ds:nothing
                mov     ax, word ptr ds:46Ch ; Counter for Interrupt 1Ah
                                        ; timer tick count (18.2 ticks per second)
                pop     ds
                assume ds:nothing
                mov     cs:_timer_lw_, ax
                push    cs
                pop     es
                assume es:SYSINIT
                mov     word ptr cs:MagicBackdoor+2, cs
                mov     word ptr cs:MagicBackdoor, offset NullBackdoor

set_drvspc_size:                        ; CODE XREF: SYSINIT:0778↓j
                mov     si, offset MagicDDName ; "\\DBLSPACE.BIN"

set_dblspc_size:                        ; CODE XREF: SYSINIT:0767↓j
                                        ; SYSINIT:0783↓j
                call    SizeDevice
                jnb     short wait_for_key_2s
                cmp     byte ptr cs:[si], 'C'
                jz      short set_drvspc_name
                cmp     cs:DEFAULT_DRIVE, 3
                jz      short set_drvspc_name
                sub     si, 2
                jmp     short set_dblspc_size
; ---------------------------------------------------------------------------

set_drvspc_name:                        ; CODE XREF: SYSINIT:075A↑j
                                        ; SYSINIT:0762↑j
                cmp     byte ptr cs:MagicDDName+2, 'R' ; "BLSPACE.BIN"
                jz      short set_stacker_name
                mov     word ptr cs:MagicDDName+2, 'VR' ; 'RV' ; DRVSPACE.BIN
                jmp     short set_drvspc_size
; ---------------------------------------------------------------------------

set_stacker_name:                       ; CODE XREF: SYSINIT:076F↑j
                cmp     si, offset StackerName ; "C:\\STACKER.BIN"
                jnb     short wfk2s_4
                mov     si, (offset StackerName+2) ; "\\STACKER.BIN"
                jmp     short set_dblspc_size
; ---------------------------------------------------------------------------

wait_for_key_2s:                        ; CODE XREF: SYSINIT:0754↑j
                mov     cs:MagicDDNamePtr, si
                push    ds
                sub     ax, ax
                mov     ds, ax          ; 0 ; ROMBIOS data area
                assume ds:nothing
                mov     dx, word ptr ds:46Ch ; Counter for Interrupt 1Ah

wfk2s_1:                                ; CODE XREF: SYSINIT:07A8↓j
                mov     ah, 1
                int     16h             ; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
                                        ; Return: ZF clear if character in buffer
                                        ; AH = scan code, AL = character
                                        ; ZF set if no character in buffer
                jnz     short wfk2s_2
                mov     ah, 2
                int     16h             ; KEYBOARD - GET SHIFT STATUS
                                        ; AL = shift status bits
                test    al, 3
                jnz     short wfk2s_2
                mov     ax, word ptr ds:46Ch ; tick count
                sub     ax, dx
                cmp     al, 37          ; 2 seconds
                jb      short wfk2s_1   ; wait for user's key press

wfk2s_2:                                ; CODE XREF: SYSINIT:0797↑j
                                        ; SYSINIT:079F↑j
                pop     ds              ; read/check the pressed key
                assume ds:nothing
                sub     bx, bx          ; bx = 0
                mov     ah, 2
                int     16h             ; KEYBOARD - GET SHIFT STATUS
                                        ; AL = shift status bits
                test    al, 3           ; Left or Right SHIFT key pressed ?
                jz      short wfk2s_3   ; no
                inc     bx
                inc     bx              ; bx = 2

wfk2s_3:                                ; CODE XREF: SYSINIT:07B3↑j
                mov     ah, 1
                int     16h             ; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
                                        ; Return: ZF clear if character in buffer
                                        ; AH = scan code, AL = character
                                        ; ZF set if no character in buffer
                jz      short wfk2s_6
                cmp     ah, 65h         ; F8 key pressed ?
                jz      short wfk2s_5
                cmp     ah, 62h         ; F5 key pressed ?
                jnz     short wfk2s_6
                mov     cs:F5_key, 1

wfk2s_4:                                ; CODE XREF: SYSINIT:077E↑j
                jmp     short ProcessConfig ; continue (as normal/default state)
; ---------------------------------------------------------------------------

wfk2s_5:                                ; CODE XREF: SYSINIT:07C0↑j
                mov     cs:F8_key, 1
                jmp     short ProcessConfig
; ---------------------------------------------------------------------------

wfk2s_6:                                ; CODE XREF: SYSINIT:07BB↑j
                                        ; SYSINIT:07C5↑j
                call    AllocFreeMem    ; get the largest free block from DOS
                call    MagicPreload    ; **** PRE-LOAD MAGICDRV!!! ****

wfk2s_7:                                ; error?
                or      ax, ax
                jz      short wfk2s_8

PreloadFailed:                          ; Dealloc ; free the block if no load
                mov     ah, 49h
                mov     es, cs:area
                assume es:nothing
                int     21h             ; DOS - 2+ - FREE MEMORY
                                        ; ES = segment address of area to be freed
                jmp     short ProcessConfig
; ---------------------------------------------------------------------------

wfk2s_8:                                ; CODE XREF: SYSINIT:07DF↑j
                mov     bx, cs:memhi
                mov     es, cs:area
                sub     bx, cs:area     ; get desired block size in paras
                mov     ah, 4Ah
                int     21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
                                        ; ES = segment address of block to change
                                        ; BX = new size in paragraphs
                mov     ax, es
                dec     ax
                mov     es, ax          ; get Magicdrv arena
                assume es:nothing
                mov     word ptr es:1, 8 ; [es:arena_owner], 8 ; set impossible owner
                mov     word ptr es:8, 4453h ; [es:arena_name],'SD' ; System Data
                add     ax, es:3        ; get MCB length
                lds     si, cs:DOSINFO  ; get to arena header
                inc     ax              ; get addr of next MCB
                mov     [si-2], ax      ; store that

ProcessConfig:                          ; CODE XREF: SYSINIT:wfk2s_4↑j
                                        ; SYSINIT:07D5↑j ...
                call    doconf
                cmp     cs:runhigh, 0   ; Did user choose to run low ?
                jz      short dont_install_stub ; yes, don't install dos low mem stub
                mov     es, cs:CURRENTDOSLOCATION
                assume es:nothing
                xor     ax, ax          ; ax = 0 --> install stub
                call    cs:dos_segreinit ; call far [dos_segreinit]
                jmp     short do_multi_pass
; ---------------------------------------------------------------------------

dont_install_stub:                      ; CODE XREF: SYSINIT:0829↑j
                xor     bx, bx
                call    MovDOSLo
                mov     ax, 1
                mov     es, cs:CURRENTDOSLOCATION
                call    cs:dos_segreinit ; call far [cs:dos_segreinit]
                                        ; inform dos about new seg

do_multi_pass:                          ; CODE XREF: SYSINIT:0837↑j
                call    AllocFreeMem    ; allocate all the free mem & update [memhi]
                                        ; & [area] start of free memory.
                cmp     cs:F5_key, 1
                jz      short skip_magicbackdoor
                cmp     cs:F8_key, 1
                jz      short skip_magicbackdoor
                xor     bx, bx          ; bx=0 ; magic backdoor to place int hooks
                call    cs:MagicBackdoor

skip_magicbackdoor:                     ; CODE XREF: SYSINIT:0854↑j
                                        ; SYSINIT:085C↑j
                inc     cs:multi_pass_id ; multi_pass_id = 1
                call    multi_pass      ; load device drivers
                call    ShrinkUMB
                call    UnlinkUMB       ; unlink all UMBs
                inc     cs:multi_pass_id ; multi_pass_id = 2
                call    multi_pass
                cmp     cs:F5_key, 1
                jz      short skip_magicpostload
                cmp     cs:F8_key, 1
                jz      short skip_magicpostload
                call    MagicPostload   ; make sure Magicdrv is final placed
                call    endfile         ; setup fcbs, files, buffers etc
                call    MagicSetCdss    ; disable CDSs of reserved drives
                jmp     short _@_
; ---------------------------------------------------------------------------

skip_magicpostload:                     ; CODE XREF: SYSINIT:0881↑j
                                        ; SYSINIT:0889↑j
                call    endfile

_@_:                                    ; CODE XREF: SYSINIT:0894↑j
                mov     ax, 70h         ; DOSBIODATASEG
                mov     es, ax          ; BIOSDATA segment
                assume es:nothing
                mov     es:SysinitPresent, 0 ; clear SysinitPresent flag
                test    cs:install_flag, 1 ; have_install_cmd
                                        ; are there install commands?
                jz      short dolast
                inc     cs:multi_pass_id
                call    multi_pass

dolast:                                 ; CODE XREF: SYSINIT:08AB↑j
                cmp     cs:runhigh, 0FFh ; are we still waiting to be moved?
                jnz     short _@@_      ; no, our job is over
                call    LoadDOSHiOrLo

_@@_:                                   ; CODE XREF: SYSINIT:08BB↑j
                cmp     cs:runhigh, 0   ; are we running low
                jz      short ConfigDone ; yes, no CPM hack needed
                call    CPMHack         ; make ffff:d0 same as 0:c0

ConfigDone:                             ; CODE XREF: SYSINIT:08C6↑j
                mov     cs:donotshownum, 1
                mov     es, cs:area
                assume es:nothing
                mov     ah, 49h         ; DEALLOC ; free allocated memory for command.com
                int     21h             ; DOS - 2+ - FREE MEMORY
                                        ; ES = segment address of area to be freed
                test    cs:install_flag, 2 ; has_installed
                jz      short skip_free_sysinitbase ; no
                push    es
                push    bx
                mov     es, cs:old_area
                mov     bx, cs:impossible_owner_size
                mov     ah, 4Ah
                int     21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
                                        ; ES = segment address of block to change
                                        ; BX = new size in paragraphs
                mov     ax, es
                dec     ax
                mov     es, ax          ; point to arena
                assume es:nothing
                mov     word ptr es:1, 8 ; [es:ARENA.OWNER],8 ; set impossible owner
                mov     word ptr es:8, 4453h ; [es:ARENA.NAME],'SD' ; System Data
                pop     bx
                pop     es
                assume es:nothing

skip_free_sysinitbase:                  ; CODE XREF: SYSINIT:08E1↑j
                cmp     cs:runhigh, 0
                jz      short _@@@_
                call    InstVDiskHeader ; Install VDISK header (allocates some mem from DOS)

_@@@_:                                  ; CODE XREF: SYSINIT:090E↑j
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     config_cmd, 0   ; set special code for query_user
                call    query_user      ; to issue the AUTOEXEC prompt
                pushf
                test    bDisableUI, 1   ; Note: This flag is useless because it is not set before
                                        ; E.TAN 04/07/2023
                jnz     short _@@@@_    ; F5 clean/interactive boot option (has been) disabled
                cmp     F5_key, 1
                jz      short _@@@@@_   ; F5 key pressed, bypass AUTOEXEC.BAT (clean boot)

_@@@@_:                                 ; CODE XREF: SYSINIT:0923↑j
                popf
                jnb     short process_autoexec ; we should process autoexec normally
                jmp     short bypass_autoexec
; ---------------------------------------------------------------------------

_@@@@@_:                                ; CODE XREF: SYSINIT:092A↑j
                popf                    ; cf status at the return from 'query_user' call

bypass_autoexec:                        ; CODE XREF: SYSINIT:092F↑j
                or      bQueryOpt, 4    ; set "skip all" flag
                call    disable_autoexec ; no, we should disable it

process_autoexec:                       ; CODE XREF: SYSINIT:092D↑j
                call    CheckQueryOpt
                mov     cl, byte ptr command_line ; "\x02/P"
                mov     ch, 0
                inc     cx
                mov     si, offset command_line ; "\x02/P"
                add     si, cx          ; retry-4
                mov     byte ptr [si], 0Dh ; cr-terminate command line

retry:                                  ; CODE XREF: SYSINIT:do_exec↓j
                                        ; DATA XREF: SYSINIT:098E↓t ...
                mov     dx, offset commnd ; "\\COMMAND.COM"
                push    dx              ; save pointer to file name
                mov     bx, 0FFFFh      ; get biggest piece (second time gets it)
                mov     ah, 48h
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                mov     ah, 48h
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                jb      short memerrjx  ; oooops!
                mov     es, ax
                mov     ah, 49h
                int     21h             ; DOS - 2+ - FREE MEMORY
                                        ; ES = segment address of area to be freed
                mov     bp, bx
                mov     bx, MEMORY_SIZE ; get location of end of memory
                mov     ax, cs          ; get location of beginning of sysinit
                mov     cx, config_envlen
                jcxz    short no_env    ; use config_wrkseg only if there's env data
                mov     ax, config_wrkseg

no_env:                                 ; CODE XREF: SYSINIT:096F↑j
                sub     bx, ax
                add     bx, 11h         ; add the sysinit php
                sub     bp, bx          ; sub sysinit size from amount of free memory
                jb      short memerrjx  ; if there isn't even this much memory, give up
                mov     ax, 3D00h
                stc
                int     21h             ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
                                        ; DS:DX -> ASCIZ filename
                                        ; AL = access mode
                                        ; 0 - read
                jb      short comerr
                mov     bx, ax
                cmp     newcmd, 0       ; was a new shell selected?
                jnz     short skip_validation ; yes
                mov     dx, offset retry-4 ; SYSINIT:0948h
                mov     cx, 4
                mov     ah, 3Fh
                int     21h             ; DOS - 2+ - READ FROM FILE WITH HANDLE
                                        ; BX = file handle, CX = number of bytes to read
                                        ; DS:DX -> buffer
                cmp     byte ptr retry-4, 0E9h
                jnz     short comerr
                cmp     byte ptr retry-1, 7Ah ; COMMAND.COM Version 7.10
                                        ; ((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
                jnz     short comerr

skip_validation:                        ; CODE XREF: SYSINIT:098C↑j
                xor     cx, cx
                xor     dx, dx
                mov     ax, 4202h
                stc
                int     21h             ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
                                        ; AL = method: offset from end of file
                jb      short comerr
                add     ax, 0Fh         ; convert size in dx:ax to para in ax
                adc     dx, 0           ; round up size for conversion to para
                call    _off_to_para
                mov     cl, 12
                shl     dx, cl          ; low nibble of dx to high nibble
                or      ax, dx          ; ax is now # of para for file
                add     ax, 10h         ; 100h byte php
                cmp     ax, bp          ; will command fit in available mem?
                jb      short okld      ; jump if yes.

memerrjx:                               ; CODE XREF: SYSINIT:095B↑j
                                        ; SYSINIT:097B↑j
                mov     dx, offset badmem ; "\r\nConfiguration too large for memory"...
                call    print
                jmp     short continue
; ---------------------------------------------------------------------------

okld:                                   ; CODE XREF: SYSINIT:09C6↑j
                mov     ah, 3Eh
                int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
                                        ; BX = file handle
                push    cs
                pop     es
                assume es:SYSINIT
                mov     bx, offset EXEC0_ENVIRON ; offset COMEXE
                                        ; point to exec block
                pop     dx
                mov     cx, config_envlen
                jcxz    short no_envdata
                mov     cx, config_wrkseg

no_envdata:                             ; CODE XREF: SYSINIT:09DE↑j
                mov     [bx], cx        ; set segments
                                        ; [bx+EXEC0.ENVIRON],cx
                mov     word ptr [bx+4], cs ; [bx+EXEC0.COM_LINE+2],cs
                mov     word ptr [bx+8], cs ; [bx+EXEC0.5C_FCB+2],cs
                mov     word ptr [bx+0Ch], cs ; [bx+EXEC0.6C_FCB+2],cs
                mov     ax, 4B00h       ; (EXEC<<8)
                stc
                int     21h             ; DOS - 2+ - LOAD OR EXECUTE (EXEC)
                                        ; DS:DX -> ASCIZ filename
                                        ; ES:BX -> parameter block
                                        ; AL = subfunc: load & execute program
                push    cs
                pop     ds
                push    dx

comerr:                                 ; CODE XREF: SYSINIT:0983↑j
                                        ; SYSINIT:099D↑j ...
                cmp     byte ptr commnd4, 0 ; "\\DOS\\COMMAND.COM"
                jz      short comerr2   ; all defaults exhausted, print err msg
                cmp     newcmd, 0
                jz      short continue  ; don't print err msg for defaults just yet

comerr2:                                ; CODE XREF: SYSINIT:09FD↑j
                mov     dx, offset badcom ; "Command Interpreter"
                call    badfil

continue:                               ; CODE XREF: SYSINIT:09CE↑j
                                        ; SYSINIT:0A04↑j
                pop     dx
                mov     ah, 19h
                int     21h             ; DOS - GET DEFAULT DISK NUMBER
                add     al, 'A'
                mov     dl, al          ; dl == default drive letter
                mov     si, offset commnd2 ; "\\COMMAND.COM"
                cmp     newcmd, 0       ; if a SHELL= was given
                jnz     short do_def2   ; then try the 2nd alternate;
                mov     byte ptr [si], 0 ; otherwise, the default SHELL= was tried,
                jmp     short do_def3   ; which is the same as our 2nd alt, so skip it
; ---------------------------------------------------------------------------

do_def2:                                ; CODE XREF: SYSINIT:0A1D↑j
                cmp     byte ptr [si], 0 ; has 2nd alternate been tried?
                jnz     short do_alt    ; no

do_def3:                                ; CODE XREF: SYSINIT:0A22↑j
                mov     si, offset commnd3 ; "\\MSDOS\\COMMAND.COM"
                cmp     byte ptr [si], 0 ; has 3rd alternate been tried?
                jnz     short do_alt    ; no
                mov     si, offset commnd4 ; "\\DOS\\COMMAND.COM"
                cmp     byte ptr [si], 0 ; has 4th alternate been tried?
                jnz     short do_alt    ; no
                push    dx
                mov     dx, offset badcomprmpt ; "Enter correct name of Command Interpret"...
                call    print
                pop     dx              ; recover default drive letter in dl

request_input:                          ; CODE XREF: SYSINIT:0A69↓j
                mov     ah, 2           ; STD_CON_OUTPUT
                int     21h             ; DOS - DISPLAY OUTPUT
                                        ; DL = character to send to standard output
                push    dx
                mov     dl, '>'         ; 3Eh
                int     21h             ; DOS -
                mov     bl, tmplate+1   ; [tmplate] = max. chars buffer can hold = 64
                mov     bh, 0
                mov     byte ptr commnd[bx], 0Dh ; "\\COMMAND.COM"
                mov     dx, offset tmplate
                mov     ah, 0Ah         ; STD_CON_STRING_INPUT
                int     21h             ; DOS - BUFFERED KEYBOARD INPUT
                                        ; DS:DX -> buffer
                mov     dx, offset crlfm ; "\r\n$"
                call    print
                pop     dx
                mov     bl, tmplate+1
                or      bl, bl          ; was anything typed?
                jz      short request_input
                mov     newcmd, 1       ; disable validation for user-specified binaries
                mov     byte ptr commnd[bx], 0 ; NULL-terminate it before execing it
                mov     word ptr command_line, 0D00h ; "\x02/P"
                jmp     short do_exec
; ---------------------------------------------------------------------------

do_alt:                                 ; CODE XREF: SYSINIT:0A27↑j
                                        ; SYSINIT:0A2F↑j ...
                push    ds
                pop     es
                mov     newcmd, 0       ; force validation for alternate binaries
                mov     di, offset commnd ; "\\COMMAND.COM"

do_alt1:                                ; CODE XREF: SYSINIT:0A8F↓j
                lodsb                   ; copy the alternate, zapping it as we go
                mov     byte ptr [si-1], 0 ; so that we know it's been tried
                stosb
                or      al, al
                jnz     short do_alt1
                mov     di, offset command_line ; "\x02/P"
                cmp     byte ptr [si+2], ':'
                jnz     short do_alt2
                mov     [si+1], dl      ; stuff default drive into alt. command line

do_alt2:                                ; CODE XREF: SYSINIT:0A98↑j
                                        ; SYSINIT:0AA1↓j
                lodsb
                stosb
                or      al, al
                jnz     short do_alt2
                mov     byte ptr [di-1], 0Dh ; cr
                mov     dae_flag, 0
                call    disable_autoexec
                call    CheckQueryOpt

do_exec:                                ; CODE XREF: SYSINIT:0A7B↑j
                jmp     retry

; =============== S U B R O U T I N E =======================================


AllocFreeMem    proc near               ; CODE XREF: SYSINIT:wfk2s_6↑p
                                        ; SYSINIT:do_multi_pass↑p
                mov     bx, 0FFFFh
                mov     ah, 48h
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                mov     ah, 48h
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                mov     cs:area, ax
                mov     cs:memhi, ax
                retn
AllocFreeMem    endp

; ---------------------------------------------------------------------------
DOSLOMSG        db 'HMA not available: Loading DOS low',0Dh,0Ah,'$'
                                        ; DATA XREF: SYSINIT:0B26↓o
FEmsg           db 'Fatal Error: Cannot allocate Memory for DOS',0Dh,0Ah,'$'
                                        ; DATA XREF: AllocMemForDOS+70↓o
; ---------------------------------------------------------------------------

LoadDOSHiOrLo:                          ; CODE XREF: SYSINIT:08BD↑p
                call    TryToMovDOSHi   ; Try moving it into HMA
                jb      short LdngLo    ; If that don't work...
                retn
; ---------------------------------------------------------------------------

LdngLo:                                 ; CODE XREF: SYSINIT:0B1F↑j
                push    cs
                pop     ds
                mov     ah, 9
                mov     dx, offset DOSLOMSG ; "HMA not available: Loading DOS low\r\n$"
                int     21h             ; DOS - PRINT STRING
                                        ; DS:DX -> string terminated by "$"
                mov     bx, 1           ; use int 21 alloc for mem
                call    MovDOSLo
                mov     es, cs:CURRENTDOSLOCATION ; give dos its temporary loc.
                assume es:nothing
                xor     ax, ax
                call    cs:dos_segreinit
                mov     cs:runhigh, 0   ; mark that we are running lo
                retn

; =============== S U B R O U T I N E =======================================


TryToMovDOSHi   proc near               ; CODE XREF: SYSINIT:LoadDOSHiOrLo↑p
                                        ; SYSINIT:0CAF↓p ...
                call    MovDOSHi
                jb      short ttldhx
                mov     es, cs:CURRENTDOSLOCATION ; give dos its temporary loc.
                xor     ax, ax          ; ax = 0 --> install stub
                call    cs:dos_segreinit
                mov     cs:runhigh, 1
                clc

ttldhx:                                 ; CODE XREF: TryToMovDOSHi+3↑j
                retn
TryToMovDOSHi   endp


; =============== S U B R O U T I N E =======================================


MovDOSHi        proc near               ; CODE XREF: TryToMovDOSHi↑p

arg_B86         = word ptr  0B88h

                call    AllocHMA        ; did we get HMA?
                jb      short mdhx      ; no
                mov     ax, 0FFFFh      ; yes, HMA seg = 0ffffh
                mov     es, ax
                assume es:nothing
                call    MovBIOS         ; First move BIOS into HMA
                mov     cx, cs:hi_doscod_size ; when it is in HMA
                call    MovDOS          ; and move it
                call    SaveFreeHMAPtr
                clc

mdhx:                                   ; CODE XREF: MovDOSHi+3↑j
                retn
MovDOSHi        endp


; =============== S U B R O U T I N E =======================================


MovDOSLo        proc near               ; CODE XREF: SYSINIT:083B↑p
                                        ; SYSINIT:0B2E↑p
                call    AllocMemForDOS  ; incestuosly!
                mov     es, ax          ; pass the segment to MovBIOS
                assume es:nothing
                call    MovBIOS
                mov     cx, cs:lo_doscod_size ; DOS code size when loaded
                call    MovDOS
                retn
MovDOSLo        endp


; =============== S U B R O U T I N E =======================================


MovBIOS         proc near               ; CODE XREF: MovDOSHi+A↑p
                                        ; MovDOSLo+5↑p
                mov     ds, cs:temp_bcode_seg
                assume ds:nothing
                mov     si, 30h         ; BCODE_START
                mov     di, si
                mov     cx, 1E00h       ; BCODE_END
                sub     cx, si          ; size of BIOS
                shr     cx, 1           ; Both the labels are para aligned
                rep movsw
                push    es
                push    di              ; save end of BIOS
                mov     ax, es
                mov     cs:BCodeSeg, ax ; save it for later use
                call    dword ptr cs:_seg_reinit_ptr ; far call to seg_reinit
                                        ; call far [cs:seg_reinit_ptr]
                pop     di              ; get back end of BIOS
                pop     es
                retn
MovBIOS         endp


; =============== S U B R O U T I N E =======================================


MovDOS          proc near               ; CODE XREF: MovDOSHi+12↑p
                                        ; MovDOSLo+D↑p
                push    es
                push    di
                lds     si, dword ptr cs:dosinit
                rep movsb
                pop     bx              ; get back offset into which DOS was moved
                mov     ax, cs:dosinit  ; get the offset at which DOS wants to run
                sub     ax, bx
                call    _off_to_para
                pop     bx              ; get the segment at which we moved DOS into
                sub     bx, ax          ; Adjust segment
                mov     cs:CURRENTDOSLOCATION, bx ; and save it
                retn
MovDOS          endp


; =============== S U B R O U T I N E =======================================


AllocMemForDOS  proc near               ; CODE XREF: MovDOSLo↑p

; FUNCTION CHUNK AT 1468 SIZE 00000001 BYTES

                mov     ax, 1E00h       ; BCODE_END
                sub     ax, 30h         ; BCODE_START
                                        ; BCODE_END-BCODE_START = BIOS code size
                add     ax, cs:lo_doscod_size
                add     ax, 15
                call    _off_to_para    ; convert to para
                or      bx, bx          ; can we use int 21h for alloc ?
                mov     bx, ax
                jz      short update_arena ; no
                mov     ah, 48h
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                jb      short FatalErr
                sub     ax, 3           ; Take care ORG 30h of BIOS code
                mov     es, ax
                mov     word ptr es:21h, 8 ; [es:20h+ARENA.OWNER],08h
                mov     word ptr es:28h, 4353h ; 'SC' ; mark it as system code area
                retn
; ---------------------------------------------------------------------------

update_arena:                           ; CODE XREF: AllocMemForDOS+15↑j
                push    ds
                push    di
                push    cx
                push    dx
                lds     di, cs:DOSINFO  ; get ptr to DOS var
                dec     di
                dec     di              ; Arena head is immediately before sysvar
                mov     es, word ptr [di] ; es = arena head
                mov     cx, es:3        ; [es:ARENA.SIZE] ; total low mem size
                cmp     cx, bx          ; is it sufficient ?
                jb      short FatalErr  ; no, fatal error
                mov     dl, es:0        ; [es:ARENA.SIGNATURE]
                mov     ax, es
                add     ax, bx          ; ax = new arena head
                mov     [di], ax        ; store it in DOS data area
                mov     ds, ax
                mov     ds:0, dl        ; [ARENA.SIGNATURE] ; type of arena
                mov     word ptr ds:1, 0 ; [ARENA.OWNER],0 ; free
                sub     cx, bx          ; size of the new block
                mov     ds:3, cx        ; [ARENA.SIZE],cx ; store it in the arena
                mov     ax, es          ; return seg to the caller
                sub     ax, 3           ; Take care ORG 30h of BIOS code
                pop     dx
                pop     cx
                pop     di
                pop     ds
                retn
; ---------------------------------------------------------------------------

FatalErr:                               ; CODE XREF: AllocMemForDOS+1B↑j
                                        ; AllocMemForDOS+45↑j
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     dx, offset FEmsg ; "Fatal Error: Cannot allocate Memory for"...
                mov     ah, 9
                int     21h             ; DOS - PRINT STRING
                                        ; DS:DX -> string terminated by "$"
                jmp     stall
AllocMemForDOS  endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


AllocHMA        proc near               ; CODE XREF: MovDOSHi↑p
                push    ds
                mov     ax, 70h         ; DOSBIODATASEG ; BIOSDATA segment
                mov     ds, ax
                assume ds:nothing
                call    IsXMSLoaded
                jnz     short grabhma_error
                mov     ax, 4310h
                int     2Fh             ; - Multiplex - XMS - GET DRIVER ADDRESS
                                        ; Return: ES:BX -> driver entry point
                mov     word ptr ds:xms, bx
                mov     word ptr ds:xms+2, es
                mov     ah, 1           ; request HMA
                mov     dx, 0FFFFh
                call    ds:xms          ; call far [xms]
                dec     ax
                jz      short allocHMA_1 ; error if not able to allocate HMA
                mov     ah, 88h
                int     15h             ; Get Extended Memory Size
                                        ; Return: CF clear on success
                                        ; AX = size of memory above 1M in K
                cmp     ax, 64          ; less than 64 K of hma ?
                jb      short grabhma_error

allocHMA_1:                             ; CODE XREF: AllocHMA+22↑j
                mov     ah, 5           ; localenableA20
                call    ds:xms
                dec     ax
                jnz     short grabhma_error ; error if couldn't enable A20
                call    IsVDiskInstalled
                jz      short grabhma_error ; yes, we cant use HMA
                mov     ax, 0FFFFh
                mov     es, ax
                assume es:nothing
                mov     word ptr es:10h, 1234h ; see if we can really read/write there
                cmp     word ptr es:10h, 1234h
                jnz     short grabhma_error ; don't try to load there if XMS lied
                clc
                pop     ds
                assume ds:nothing
                retn
; ---------------------------------------------------------------------------

grabhma_error:                          ; CODE XREF: AllocHMA+9↑j
                                        ; AllocHMA+2B↑j ...
                stc
                pop     ds
                retn
AllocHMA        endp


; =============== S U B R O U T I N E =======================================


IsXMSLoaded     proc near               ; CODE XREF: AllocHMA+6↑p
                                        ; InitAllocUMB↓p
                mov     ax, 4300h
                int     2Fh             ; - Multiplex - XMS - INSTALLATION CHECK
                                        ; Return: AL = 80h XMS driver installed
                                        ; AL <> 80h no driver
                cmp     al, 80h         ; XMS installed?
                retn
IsXMSLoaded     endp

; ---------------------------------------------------------------------------

FTRYTOMOVDOSHI:                         ; DATA XREF: BIOSDATA:MoveDOSIntoHMA↑o
                push    ax
                push    bx
                push    cx
                push    dx
                push    si
                push    di
                push    ds
                push    es
                cmp     cs:runhigh, 0FFh
                jnz     short _ftymdh_1
                call    TryToMovDOSHi

_ftymdh_1:                              ; CODE XREF: SYSINIT:0CAD↑j
                pop     es
                assume es:nothing
                pop     ds
                pop     di
                pop     si
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                retf
; ---------------------------------------------------------------------------
                db 0
StartVDHead     dd 0                    ; DATA XREF: InstVDiskHeader+3A↓o
                                        ; link to next device driver
                dw 8000h                ; device attribute
                dw 0                    ; strategy routine offset
                dw 0                    ; interrupt routine offset
                db 1
                db 7 dup(0)             ; reserved area
VDiskSig1       db 'VDISK'              ; DATA XREF: IsVDiskInstalled+10↓o
                db '  V3.3'             ; vdisk label ; VLEN1 equ ($-VDiskSig1)
                db 15 dup(0)            ; pad
                dw 0                    ; bits 0-15 of free HMA
                db 11h                  ; bits 16-23 of free HMA (1M + 64K)
VDInt19         db 0EAh                 ; jmp to old vector
OldVDInt19      dw 2 dup(0)             ; DATA XREF: InstVDiskHeader+7↓w
                                        ; InstVDiskHeader+E↓w
VDiskHMAHead    db 0, 0, 0              ; DATA XREF: InstVDiskHeader+52↓o
                                        ; EndVDHead
                                        ; non-bootable disk
VDiskSig2       db 'VDISK'              ; DATA XREF: IsVDiskInstalled+1F↓o
                db '3.3'                ; VLEN2 equ ($-VDiskSig2)
                                        ; OEM - signature
                dw 128                  ; number of bytes/sector
                db 1                    ; sectors/cluster
                dw 1                    ; reserved sectors
                db 1                    ; number of FAT copies
                dw 64                   ; number of root dir entries
                dw 512                  ; number of sectors
                db 0FEh                 ; media descriptor
                dw 6                    ; number of sectors/FAT
                dw 8                    ; sectors per track
                dw 1                    ; number of heads
                dw 0                    ; number of hidden sectors
                dw 440h                 ; Start of free HMA in K (1M+64K)

; =============== S U B R O U T I N E =======================================


InstVDiskHeader proc near               ; CODE XREF: SYSINIT:0910↑p
                xor     ax, ax          ; EndVDiskHMAHead (SYSINIT:0D10h)
                mov     ds, ax          ; seg of int vect table
                                        ; save old int 19 vector
                assume ds:nothing
                mov     ax, word ptr ds:64h ; [19h*4]
                mov     cs:OldVDInt19, ax
                mov     ax, word ptr ds:66h ; [19h*4+2]
                mov     cs:OldVDInt19+2, ax
                mov     ah, 48h
                mov     bx, 4
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                dec     ax
                mov     es, ax
                mov     word ptr es:1, 8 ; [es:ARENA.OWNER],8 ; owner = System
                mov     word ptr es:8, 4353h ; [es:ARENA.NAME],'SC' ; System Code
                inc     ax
                mov     es, ax          ; get back to allocated memory
                cli                     ; no reboots at this time
                                        ; install new int 19 vector
                mov     word ptr ds:64h, 47 ; (VDInt19-StartVDHead)
                                        ; 0CEBh-0CBCh = 2Fh = 47
                mov     word ptr ds:66h, ax
                mov     cx, 52          ; (EndVDHead-StartVDHead)
                mov     si, offset StartVDHead ; SYSINIT:0CBCh
                xor     di, di
                push    cs
                pop     ds
                assume ds:SYSINIT
                cld
                rep movsb
                sti                     ; mov the HMA VDisk head into HMA
                push    di
                push    es
                mov     ax, 0FFFFh
                mov     es, ax
                assume es:nothing
                mov     di, 10h
                mov     cx, 32          ; (EndVDiskHMAHead-VDiskHMAHead)
                mov     si, offset VDiskHMAHead ; SYSINIT:0CF0h
                rep movsb
                pop     di
                pop     es
                assume es:nothing
                retn
InstVDiskHeader endp

; ---------------------------------------------------------------------------
dummy           db 8 dup(0)             ; DATA XREF: ClrVDISKHeader+3A↓o
                                        ; bmove
gdt             db 8 dup(0)             ; times desc.size db 0
src_desc        dw 0FFFFh               ; des <0ffffh,0,0,93h,0>
desc_lo_word    dw 0                    ; DATA XREF: ClrVDISKHeader+2C↓w
desc_hi_byte    db 0                    ; DATA XREF: ClrVDISKHeader+30↓w
                db 93h
                dw 0
tgt_desc        dw 0FFFFh               ; desc <0ffffh,0,10h,93h,0>  ; 1MB
                                        ; desc.seg_lim
                dw 0                    ; desc.lo_word
                db 10h                  ; desc.hi_byte
                db 93h                  ; desc.acc_rights
                dw 0                    ; desc.reserved
rombios_code    db 8 dup(0)             ; times desc.size db 0
temp_stack      db 8 dup(0)
ClrdVDISKHead   db 32 dup(0)            ; DATA XREF: ClrVDISKHeader+26↓o

; =============== S U B R O U T I N E =======================================


ClrVDISKHeader  proc near               ; CODE XREF: SYSINIT:0639↑p
                in      al, 64h         ; 8042 keyboard controller status register
                                        ; 7:  PERR    1=parity error in data received from keyboard
                                        ;    +----------- AT Mode ----------+------------ PS/2 Mode ------------+
                                        ; 6: |RxTO    receive (Rx) timeout  | TO      general timeout (Rx or Tx)|
                                        ; 5: |TxTO    transmit (Tx) timeout | MOBF    mouse output buffer full  |
                                        ;    +------------------------------+-----------------------------------+
                                        ; 4:  INH     0=keyboard communications inhibited
                                        ; 3:  A2      0=60h was the port last written to, 1=64h was last
                                        ; 2:  SYS     distinguishes reset types: 0=cold reboot, 1=warm reboot
                                        ; 1:  IBF     1=input buffer full (keyboard can't accept data)
                                        ; 0:  OBF     1=output buffer full (data from keyboard is available)
                test    al, 10h         ; test bit 4 - Is keyboard inhibited?
                jnz     short ClrVDISKok ; No, go do block move
                cmp     word ptr cs:sys_model_byte, 19F8h ; check for TORTUGA models
                jz      short ClrVDISKno ; do not use INT 15h block move code
                                        ; (while 8042 is disabled)
                cmp     word ptr cs:sys_model_byte, 9FCh ; Check for PS/2 30-286 model
                jnz     short ClrVDISKok

ClrVDISKno:                             ; CODE XREF: ClrVDISKHeader+D↑j
                retn
; ---------------------------------------------------------------------------

ClrVDISKok:                             ; CODE XREF: ClrVDISKHeader+4↑j
                                        ; ClrVDISKHeader+16↑j
                push    es
                mov     ax, cs
                mov     dx, ax
                mov     cl, 12
                shr     dx, cl          ; dx = higher 4 bits of the segment number
                                        ;    = segment number / 4096 (= byte address / 65536)
                mov     cl, 4
                shl     ax, cl          ; ax = (lower 12 bits of the segment number)*16
                add     ax, offset ClrdVDISKHead
                adc     dl, 0           ; dl:ax = 24 bit linear address
                mov     cs:desc_lo_word, ax
                mov     cs:desc_hi_byte, dl
                mov     cx, 16          ; 16 words
                push    cs
                pop     es
                assume es:SYSINIT
                mov     si, offset dummy ; offset bmove
                mov     ah, 87h
                int     15h             ; EXTENDED MEMORY - BLOCK MOVE (AT,XT286,PS)
                                        ; CX = number of words to move, ES:SI -> global descriptor table
                                        ; Return: CF set on error, AH = status
                pop     es
                assume es:nothing
                retn
ClrVDISKHeader  endp


; =============== S U B R O U T I N E =======================================


SaveFreeHMAPtr  proc near               ; CODE XREF: MovDOSHi+15↑p
                mov     bx, es
                mov     ax, 0FFFFh      ; HMA segment
                sub     ax, bx
                add     di, 15          ; para round
                and     di, 0FFF0h
                mov     cl, 4
                shl     ax, cl
                sub     di, ax
                push    ds
                mov     ax, 70h         ; DOSBIODATASEG ; BIOSDATA segment
                mov     ds, ax
                assume ds:nothing
                mov     ds:FreeHMAPtr, di ; BIOSDATA:07D7h
                mov     ds:inHMA, 0FFh  ; BIOSDATA:000Dh
                pop     ds
                assume ds:nothing
                retn
SaveFreeHMAPtr  endp


; =============== S U B R O U T I N E =======================================


IsVDiskInstalled proc near              ; CODE XREF: AllocHMA+36↑p
                xor     ax, ax
                mov     ds, ax
                assume ds:nothing
                mov     ds, word ptr ds:4Eh ; [13h*4+2]
                assume ds:nothing
                mov     si, 12h         ; VDiskSig1-StartVDHead
                mov     cx, 5           ; VLEN1
                push    cs
                pop     es
                assume es:SYSINIT
                mov     di, offset VDiskSig1 ; "VDISK"
                repe cmpsb
                jz      short ivdins_retn
                mov     ax, 0FFFFh
                mov     ds, ax
                assume ds:nothing
                mov     si, 13h         ; 10h+(VDiskSig2-VDiskHMAHead)
                mov     di, offset VDiskSig2 ; "VDISK"
                mov     cx, 5
                repe cmpsb

ivdins_retn:                            ; CODE XREF: IsVDiskInstalled+15↑j
                retn
IsVDiskInstalled endp


; =============== S U B R O U T I N E =======================================


CPMHack         proc near               ; CODE XREF: SYSINIT:08C8↑p
                push    ds
                mov     cx, 0FFFFh
                mov     es, cx
                assume es:nothing
                xor     cx, cx
                mov     ds, cx          ; 0
                assume ds:nothing
                mov     si, 0C0h
                mov     di, 0D0h
                mov     cx, 5
                cld
                rep movsb               ; move 5 bytes from 0:C0h to FFFFh:D0h
                pop     ds
                assume ds:nothing
                retn
CPMHack         endp


; =============== S U B R O U T I N E =======================================


_off_to_para    proc near               ; CODE XREF: SYSINIT:04AE↑p
                                        ; SYSINIT:04BA↑p ...
                shr     ax, 1
                shr     ax, 1
                shr     ax, 1
                shr     ax, 1
                retn
_off_to_para    endp


; =============== S U B R O U T I N E =======================================


TempCDS         proc near               ; CODE XREF: SYSINIT:06E3↑p
                                        ; MagicPreload+1C9↓p ...
                les     di, ds:DOSINFO
                assume es:nothing
                mov     cl, es:[di+20h] ; [es:di+SYSI_NUMIO]
                xor     ch, ch          ; (cx) = # of block devices
                mov     es:[di+21h], cl ; [es:di+SYSI_NCDS] ; one CDS per device
                mov     al, cl
                mov     ah, 88          ; curdirlen ; curdir_list.size
                mul     ah
                call    ParaRound
                mov     si, ds:top_of_cdss
                sub     si, ax
                mov     es:[di+18h], si ; [es:di+SYSI_CDS+2]
                mov     ax, si
                mov     word ptr es:[di+16h], 0 ; [es:di+SYSI_CDS]
                                        ; set address of CDS list
                lds     si, es:[di]     ; lds si,[es:di+SYSI_DPB]
                                        ; (ds:si) = address of first DPB
                mov     es, ax
                xor     di, di          ; (es:di) = address of 1st CDS
TempCDS         endp


; =============== S U B R O U T I N E =======================================


fooset          proc near               ; CODE XREF: fooset+5B↓j
                                        ; endfile+251↓p
                mov     ax, word ptr cs:DirStrng ; "A:\"
                stosw                   ; setup the root as the curdir
                call    get_dpb_for_drive_al ; get dpb for drive in dpb
                                        ; (ds:si) = address of DPB
                                        ;    (si) = -1 if no drive
                mov     ax, word ptr cs:DirStrng+2 ; "\",0
                stosw
                inc     byte ptr cs:DirStrng ; "A:\"
                xor     ax, ax          ; 0
                push    cx
                mov     cx, 63          ; curdir_list.cdir_flags - 4
                rep stosb               ; zero out rest of CURDIR_TEXTs
                                        ; (ax) = 0
                                        ; (es:di) = CURDIR_FLAGS in the CDS records
                                        ; (ds:si) = Next DPB (-1 if none)
                cmp     si, 0FFFFh      ; -1
                jz      short fooset_zero
                cmp     cs:fake_floppy_drv, 1
                jnz     short normcds   ; machine has floppy drives
                cmp     byte ptr [si], 1 ; cmp [si+DPB.drive],1
                                        ; if dpb_drive = 0 (A) or 1 (B).
                ja      short normcds
                mov     cl, 3           ; the next dbp pointer
                rep stosw               ; ax should be zero here
                pop     cx
                jmp     short get_next_dpb
; ---------------------------------------------------------------------------

fooset_zero:                            ; CODE XREF: fooset+1D↑j
                mov     cl, 3
                rep stosw
                pop     cx
                jmp     short get_next_dpb ; jmp short fincds
; ---------------------------------------------------------------------------

normcds:                                ; CODE XREF: fooset+25↑j
                                        ; fooset+2A↑j
                pop     cx
                cmp     byte ptr [si+8], 0 ; [si+DPB.FAT_COUNT] ; non fat system?
                jz      short setnormcds ; yes. set curdir_flags to 0. ax = 0 now.
                mov     ax, 4000h       ; curdir_inuse ; else,fat system.
                                        ; set the flag to curdir_inuse.

setnormcds:                             ; CODE XREF: fooset+3F↑j
                stosw                   ; curdir_flags
                mov     ax, si
                stosw                   ; curdir_devptr
                mov     ax, ds
                stosw

get_next_dpb:                           ; CODE XREF: fooset+31↑j
                                        ; fooset+38↑j
                mov     ax, 0FFFFh      ; entry point for fake_fooset_zero
                                        ; mov ax,-1
                stosw                   ; curdir_id
                stosw                   ; curdir_id
                stosw                   ; curdir_user_word
                mov     ax, 2           ; curdir_end
                stosw
                mov     al, 0           ; clear out 7 bytes (curdir_type,
                stosb
                stosw                   ; curdir_ifs_hdr,curdir_fsda)
                stosw
                stosw
                loop    fooset
                mov     byte ptr cs:DirStrng, 'A' ; "A:\",0
                retn
fooset          endp


; =============== S U B R O U T I N E =======================================


get_dpb_for_drive_al proc near          ; CODE XREF: fooset+5↑p
                lds     si, cs:DOSINFO  ; point to first DPB
                lds     si, [si]        ; (ds:si) = address of first DPB
                sub     al, 'A'

get_dpb_for_drive_1:                    ; CODE XREF: get_dpb_for_drive_al+13↓j
                cmp     al, [si]        ; cmp al,[si+DPB.DRIVE] ; match?
                jz      short got_dpb_for_drive
                lds     si, [si+19h]    ; lds si,[si+DPB.NEXT_DPB]
                cmp     si, 0FFFFh
                jnz     short get_dpb_for_drive_1 ; loop until hit end of DPBs

got_dpb_for_drive:                      ; CODE XREF: get_dpb_for_drive_al+B↑j
                retn
get_dpb_for_drive_al endp


; =============== S U B R O U T I N E =======================================


endfile         proc near               ; CODE XREF: SYSINIT:088E↑p
                                        ; SYSINIT:skip_magicpostload↑p
                push    ds              ; Build DOS structures
                mov     ax, 70h         ; DOSBIODATASEG
                mov     ds, ax
                assume ds:nothing
                cmp     ds:multrk_flag, 0 ; multrk_off1
                                        ; multrack= command entered?
                jnz     short multrk_flag_done
                or      ds:multrk_flag, 80h ; or [multrk_flag],multrk_on

multrk_flag_done:                       ; CODE XREF: endfile+B↑j
                pop     ds
                assume ds:nothing
                mov     ax, cs:CONFBOT
                mov     cs:ALLOCLIM, ax
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     ax, cs:memhi
                mov     cs:prev_memhi, ax
                mov     ax, cs:ALLOCLIM
                mov     cs:prev_alloclim, ax

dosfts:                                 ; CODE XREF: endfile+356↓j
                call    round
                mov     al, cs:FILES
                sub     al, 5
                jbe     short dofcbs
                push    ax
                mov     al, 'F'         ; devmark_files
                call    setdevmark      ; set devmark for sfts (files)
                pop     ax
                xor     ah, ah          ; do not use cbw instruction!
                                        ; it does sign extend.
                mov     bx, cs:memlo
                mov     dx, cs:memhi
                lds     di, cs:DOSINFO  ; get pointer to dos data
                assume ds:nothing
                lds     di, [di+4]      ; lds di,[di+SYSI_SFT] ; ds:di points to sft
                mov     [di], bx        ; [di+SF.SFLink],bx
                mov     [di+2], dx      ; [di+SF.SFLink+2],dx ; set pointer to new sft
                push    cs
                pop     ds
                assume ds:SYSINIT
                les     di, dword ptr cs:memlo ; point to new sft
                mov     word ptr es:[di], 0FFFFh ; mov word [es:di+SF.SFLink],-1
                mov     es:[di+4], ax   ; mov [es:di+SF.SFCount],ax
                mov     bl, 59          ; SF_ENTRY.size
                mul     bl
                mov     cx, ax          ; ax = number of bytes to clear
                add     cs:memlo, ax    ; allocate memory
                mov     ax, 6
                add     cs:memlo, ax    ; remember the header too
                or      cs:setdevmarkflag, 2 ; for_devmark
                call    round           ; check for mem error before the stosb
                add     di, ax          ; ax = 6
                xor     ax, ax
                rep stosb               ; clean out the stuff

dofcbs:                                 ; CODE XREF: endfile+37↑j
                push    cs
                pop     ds
                call    round
                mov     al, 'X'         ; devmark_fcbs
                call    setdevmark
                mov     al, cs:FCBS
                xor     ah, ah          ; do not use cbw instruction!
                                        ; it does sign extend.
                mov     bx, cs:memlo
                mov     dx, cs:memhi
                lds     di, cs:DOSINFO  ; get pointer to dos data
                assume ds:nothing
                mov     [di+1Ah], bx    ; [di+SYSI_FCB]
                mov     [di+1Ch], dx    ; [di+SYSI_FCB+2] ; set pointer to new table
                mov     bl, cs:KEEP
                xor     bh, bh
                mov     [di+1Eh], bx    ; [di+SYSI_KEEP]
                push    cs
                pop     ds
                assume ds:SYSINIT
                les     di, dword ptr memlo ; point to new table
                mov     word ptr es:[di], 0FFFFh ; [es:di+SF.SFLink],-1
                mov     es:[di+4], ax   ; [es:di+SF.SFCount]
                mov     bl, 59          ; SF_ENTRY.size
                mov     cx, ax
                mul     bl
                add     memlo, ax       ; ax = number of bytes to clear
                mov     ax, 6           ; SF.size-2
                add     memlo, ax       ; remember the header too
                or      setdevmarkflag, 2 ; for_devmark
                call    round           ; check for mem error before the stosb
                add     di, ax          ; skip over header
                mov     al, 'A'

fillloop:                               ; CODE XREF: endfile+100↓j
                push    cx              ; save count
                mov     cx, 59          ; number of bytes to fill
                cld
                rep stosb               ; filled
                mov     word ptr es:[di-3Bh], 0 ; [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_ref_count]
                mov     word ptr es:[di-26h], 0 ; [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position]
                mov     word ptr es:[di-24h], 0 ; [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position+2]
                pop     cx
                loop    fillloop
                cmp     buffers, 0FFFFh ; -1 ; has buffers been already set?
                jz      short dodefaultbuff
                jmp     dobuff          ; the user entered the buffers=.
; ---------------------------------------------------------------------------

dodefaultbuff:                          ; CODE XREF: endfile+107↑j
                mov     h_buffers, 0    ; default is no heuristic (secondary) buffers.
                mov     buffers, 2      ; default to 2 buffers
                push    ax
                push    ds
                les     bp, cs:DOSINFO  ; search through the dpb's
                les     bp, es:[bp+0]   ; [es:bp+SYSI_DPB] ; get first dpb
                push    cs
                pop     ds

nextdpb:                                ; CODE XREF: endfile+175↓j
                mov     bl, es:[bp+0]   ; [es:bp+DPB.drive]
                inc     bl
                mov     ax, 4408h
                int     21h             ; DOS - 2+ - IOCTL -
                or      ax, ax          ; 0 = removable disk, 1 = fixed disk
                jnz     short nosetbuf  ; ax is nonzero if disk is nonremoveable
                xor     bx, bx          ; get parameters of (removable) drive
                mov     bl, es:[bp+0]   ; [es:bp+DPB.drive]
                inc     bl
                mov     dx, offset devp_specialfunc
                mov     ax, 440Dh       ; (IOCTL<<8)|GENERIC_IOCTL
                mov     cx, 860h        ; (RAWIO<<8)|GET_DEVICE_PARAMETERS
                int     21h             ; DOS - 2+ - IOCTL -
                jb      short nosetbuf  ; get next dpb if driver doesn't support
                                        ; generic ioctl
                mov     bx, devp_totalsecs ; [deviceparameters+15]
                                        ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
                mov     ax, devp_bps    ; [deviceparameters+7]
                                        ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_BYTESPERSECTOR]
                xor     dx, dx
                mov     cx, 512         ; scale sector size in factor of 512 bytes
                div     cx
                mul     bx              ; ax = #sectors * size factor
                or      dx, dx          ; just in case of large floppies
                jnz     short setbuf
                cmp     ax, 720         ; 720 sectors * size factor of 1
                jbe     short nosetbuf

setbuf:                                 ; CODE XREF: endfile+15B↑j
                mov     buffers, 3
                jmp     short chk_memsize_for_buffers ; now check the memory size
                                        ; for default buffer count
; ---------------------------------------------------------------------------

nosetbuf:                               ; CODE XREF: endfile+132↑j
                                        ; endfile+147↑j ...
                cmp     word ptr es:[bp+19h], 0FFFFh ; [es:bp+DPB.NEXT_DPB],-1
                jz      short chk_memsize_for_buffers
                les     bp, es:[bp+19h] ; les bp,[es:bp+DPB.NEXT_DPB]
                jmp     short nextdpb
; ---------------------------------------------------------------------------

chk_memsize_for_buffers:                ; CODE XREF: endfile+168↑j
                                        ; endfile+16F↑j
                cmp     MEMORY_SIZE, 2000h ; 128kb
                jbe     short bufset
                mov     buffers, 5
                cmp     MEMORY_SIZE, 4000h ; 256kb
                jbe     short bufset
                mov     buffers, 10
                cmp     MEMORY_SIZE, 8000h ; 512kb
                jbe     short bufset
                mov     buffers, 15

bufset:                                 ; CODE XREF: endfile+17D↑j
                                        ; endfile+18B↑j ...
                pop     ds
                assume ds:nothing
                pop     ax

dobuff:                                 ; CODE XREF: endfile+109↑j
                lds     bx, cs:DOSINFO  ; ds:bx -> sysinitvar
                mov     ax, cs:buffers
                mov     [bx+3Fh], ax    ; [bx+SYSI_BUFFERS] ; set sysi_buffers
                mov     ax, cs:h_buffers
                mov     [bx+41h], ax    ; [bx+SYSI_BUFFERS+2]
                lds     bx, [bx+12h]    ; [bx+SYSI_BUF] ; now, ds:bx -> buffinfo
                call    round           ; get [memhi]:[memlo]
                mov     al, 'B'         ; devmark_buf
                call    setdevmark
                push    ds              ; save buffer info. ptr.
                push    bx
                call    set_buffer
                pop     bx              ; restore buffer info. ptr.
                pop     ds
                cmp     cs:h_buffers, 0 ; set the secondary buffer if specified
                jz      short xif16
                call    round
                mov     cx, cs:memlo
                mov     [bx+6], cx      ; [bx+BUFFINF.Cache_ptr]
                mov     cx, cs:memhi
                mov     [bx+8], cx      ; [bx+BUFFINF.Cache_ptr+2]
                mov     cx, cs:h_buffers
                mov     [bx+0Ah], cx    ; [bx+BUFFINF.Cache_count]
                mov     ax, 512         ; 512 bytes
                mul     cx
                mov     cs:memlo, ax
                or      cs:setdevmarkflag, 2 ; for_devmark
                call    round

xif16:                                  ; CODE XREF: endfile+1CE↑j
                call    round           ; buf1
                push    ax
                mov     ax, 'L'         ; devmark_cds
                call    setdevmark
                pop     ax
                les     di, cs:DOSINFO
                mov     cl, es:[di+20h] ; [es:di+SYSI_NUMIO]
                cmp     cl, cs:NUM_CDS
                jnb     short gotncds   ; user setting must be at least numio
                mov     cl, cs:NUM_CDS

gotncds:                                ; CODE XREF: endfile+216↑j
                xor     ch, ch
                mov     es:[di+21h], cl ; [es:di+SYSI_NCDS]
                mov     ax, cs:memhi
                mov     es:[di+18h], ax ; [es:di+SYSI_CDS+2]
                mov     ax, cs:memlo
                mov     es:[di+16h], ax ; [es:di+SYSI_CDS]
                mov     al, cl
                mov     ah, 88          ; curdirlen ; curdir_list.size
                mul     ah
                call    ParaRound
                add     cs:memhi, ax
                or      cs:setdevmarkflag, 2 ; for_devmark
                call    round           ; check for mem error before initializing
                lds     si, es:[di]     ; lds si,[es:di+SYSI_DPB] ; [es:di+0]
                les     di, es:[di+16h] ; les di,[es:di+SYSI_CDS] ; [es:di+22]
                call    fooset          ; Initialize temporary CDSs.
                push    cs
                pop     ds
                assume ds:SYSINIT
                cmp     stack_addr, 0FFFFh ; -1 ; has the user entered "stacks=" command?
                jz      short doinstallstack ; then install as specified by the user
                cmp     sys_scnd_model_byte, 0 ; pc1,xt has the secondary model byte = 0
                jnz     short doinstallstack ; other model should have default stack of 9,128
                cmp     sys_model_byte, 0FEh ; pc1, pc/xt or pc portable ?
                jnb     short skipstack

doinstallstack:                         ; CODE XREF: endfile+25B↑j
                                        ; endfile+262↑j
                mov     ax, stack_count ; stack_count = 0?
                or      ax, ax          ; then, stack size must be 0 too.
                jz      short skipstack ; don't install stack.
                call    round           ; dynamic relocation of stack code.
                mov     al, 'S'         ; devmark_stk
                call    setdevmark
                mov     ax, memhi
                mov     es, ax          ; es -> seg. the stack code is going to move.
                push    cs
                pop     ds
                xor     si, si          ; ! we know that stack code is at the beginning of sysinit.
                xor     di, di
                mov     cx, offset _SYSINIT ; offset endstackcode = offset _SYSINIT
                                        ; SYSINIT:0269h
                mov     memlo, cx
                call    round           ; have enough space for relocation?
                rep movsb
                push    ds
                mov     ax, 70h         ; DOSBIODATASEG
                mov     ds, ax
                assume ds:nothing
                mov     ds:NextStack, offset nextentry ; [BIOSDATA:NextStack],
                                        ;  offset SYSINIT:nextentry (SYSINIT:0010h)
                mov     ds:NextStack+2, es
                mov     ax, cs:memlo
                mov     cs:stack_addr, ax ; set for stack area initialization
                mov     word ptr ds:IT_StackLoc, ax ; pass it as Instance Data, too
                mov     ax, cs:memhi    ; this will be used by stack_init routine.
                mov     cs:stack_addr+2, ax
                mov     word ptr ds:IT_StackLoc+2, ax
                mov     ax, 8           ; entrysize
                add     ax, cs:stack_size
                mul     cs:stack_count
                mov     ds:IT_StackSize, ax ; pass through to Instance Table
                pop     ds
                assume ds:nothing
                call    ParaRound
                add     cs:memhi, ax
                or      cs:setdevmarkflag, 2 ; for_devmark
                                        ; to set the devmark_size for stack by round routine.
                call    round           ; check for memory error before continuing
                call    stackinit       ; initialize hardware stack.
                                        ; cs=ds=sysinitseg,es=relocated stack code & data

skipstack:                              ; CODE XREF: endfile+269↑j
                                        ; endfile+270↑j
                push    cs
                pop     ds
                assume ds:SYSINIT
                cmp     dosdata_umb, 1  ; PCDOS 7 feature - DOSDATA=UMB/NOUMB configuration
                                        ; 1 = DOSDATA=UMB, 2 = (UMB) done, 0 = NOUMB
                ja      short dosdata_umb_done ; 2 - done
                jb      short dosdata_noumb ; 0 - DOSDATA=NOUMB
                cmp     byte ptr setdevmark, 0EAh
                jz      short dosdata_noumb
                mov     ax, 5802h
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: (DOS 5beta) get UMB link state
                cbw
                mov     di, ax          ; al = 01h -> UMBs in DOS memory chain
                                        ; save current (previous) UMB link state
                mov     bx, 1           ; bx = 01h -> add UMBs to DOS memory chain
                mov     ax, 5803h
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: (DOS 5beta) set UMB link state
                jb      short dosdata_noumb
                mov     ax, 5800h
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: get allocation strategy
                mov     si, ax          ; ax = current strategy
                                        ; save current (previous) allocation strategy
                mov     bx, 40h         ; bl = new strategy = 40h - high memory first fit
                mov     ax, 5801h
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: set allocation strategy
                mov     bx, memhi
                sub     bx, prev_memhi
                mov     ah, 48h
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                mov     cx, ax          ; ax = segment of allocated block
                mov     bx, di          ; restore previous UMB link state
                mov     ax, 5803h
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: (DOS 5beta) set UMB link state
                mov     bx, si          ; restore previous allocation strategy
                mov     ax, 5801h
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: set allocation strategy
                cmp     cx, 0A000h      ; Is the allocated memory block (segment) a UMB?
                jb      short dosdata_noumb ; no
                mov     ALLOCLIM, 0FFFFh
                mov     memlo, 0
                mov     memhi, cx
                dec     cx
                mov     es, cx          ; point to arena/mcb
                mov     word ptr es:1, 8 ; [es:arena_owner], 8 ; set impossible owner
                mov     word ptr es:8, 4453h ; [es:arena_name],'SD' ; System Data
                inc     dosdata_umb     ; 1 -> 2 ; DOSDATA=UMB done.
                jmp     dosfts
; ---------------------------------------------------------------------------

dosdata_umb_done:                       ; CODE XREF: endfile+2E3↑j
                mov     ax, prev_memhi  ; (recent memory block/segment before UMBs)
                mov     memhi, ax
                mov     ax, prev_alloclim
                mov     ALLOCLIM, ax

dosdata_noumb:                          ; CODE XREF: endfile+2E5↑j
                                        ; endfile+2EC↑j ...
                mov     al, FILES
                xor     ah, ah          ; do not use cbw instruction!
                                        ; it does sign extend.
                mov     cx, ax
                xor     bx, bx          ; close standard input
                mov     ah, 3Eh
                int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
                                        ; BX = file handle
                mov     bx, 2           ; close everybody but standard output
                                        ; need output so we can print message
                                        ;  in case we can't get new one open.

rcclloop:                               ; CODE XREF: endfile+37A↓j
                mov     ah, 3Eh
                int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
                                        ; BX = file handle
                inc     bx
                loop    rcclloop
                mov     dx, offset condev ; "CON"
                mov     al, 2
                mov     ah, 3Dh         ; open con for read/write
                stc                     ; set for possible int 24
                int     21h             ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
                                        ; DS:DX -> ASCIZ filename
                                        ; AL = access mode
                                        ; 2 - read & write
                jnb     short goaux
                call    badfil
                jmp     short goaux2
; ---------------------------------------------------------------------------

goaux:                                  ; CODE XREF: endfile+386↑j
                push    ax
                mov     bx, 1           ; close standard output
                mov     ah, 3Eh
                int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
                                        ; BX = file handle
                pop     ax
                mov     bx, ax          ; new device handle
                mov     ah, 45h         ; XDUP ; dup to 1, stdout
                int     21h             ; DOS - 2+ - CREATE DUPLICATE HANDLE (DUP)
                                        ; BX = file handle to duplicate
                mov     ah, 45h         ; XDUP ; dup to 2, stderr
                int     21h             ; DOS - 2+ - CREATE DUPLICATE HANDLE (DUP)
                                        ; BX = file handle to duplicate

goaux2:                                 ; CODE XREF: endfile+38B↑j
                mov     dx, offset auxdev ; "AUX"
                mov     al, 2           ; read/write access
                call    open_dev
                mov     dx, offset prndev ; "PRN"
                mov     al, 1           ; write only
                call    open_dev
                push    ax
                push    bx
                push    dx
                push    es
                mov     al, 0FFh        ; reset h/w by writing to port
                mov     dx, 2F2h        ; get starting address
                out     dx, al          ; out 02f2h,0ffh
                inc     dx
                out     dx, al
                inc     dx
                out     dx, al
                inc     dx
                out     dx, al
                inc     dx
                out     dx, al
                inc     dx
                out     dx, al          ; out 02f7h,0ffh
                mov     ax, 0F000h      ; get machine type
                mov     es, ax
                assume es:nothing
                cmp     byte ptr es:0FFFEh, 0FCh ; is it a AT type machine
                jz      short startrearm ; *if AT no need to check
                mov     ah, 0C0h
                int     15h             ; SYSTEM - GET CONFIGURATION
                                        ; (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
                jb      short finishrearm ; *jmp if old rom
                test    byte ptr es:[bx+5], 40h ; [es:bx+ROMBIOS_DESC.bios_sd_featurebyte1],
                                        ; ScndIntController
                jz      short finishrearm

startrearm:                             ; CODE XREF: endfile+3CF↑j
                mov     al, 0FFh        ; write any pattern to port
                mov     dx, 6F2h        ; get starting address
                out     dx, al
                inc     dx
                out     dx, al          ; out 06f3h,0ffh
                inc     dx
                out     dx, al          ; out 06f4h,0ffh
                inc     dx
                inc     dx
                out     dx, al          ; out 06f6h,0ffh
                inc     dx
                out     dx, al          ; out 06f7h,0ffh

finishrearm:                            ; CODE XREF: endfile+3D5↑j
                                        ; endfile+3DC↑j
                pop     es
                assume es:nothing
                pop     dx
                pop     bx
                pop     ax

set_sysinit_base:                       ; sysinit_base will be established
                push    ax              ; in the secure area of lower memory
                                        ; when it handles the first install= command.
                                        ; if sysinit module (in high memory) has been broken,
                                        ; then "memory error..." message is displayed
                                        ; by sysinit_base
                mov     ax, memhi
                sub     ax, area
                mov     impossible_owner_size, ax ; remember the size in case.
                mov     al, 'T'         ; devmark_inst
                call    setdevmark
                pop     ax
                mov     di, memhi
                mov     es, di
                mov     word ptr sysinit_base_ptr+2, di ; save this entry for the next use.
                xor     di, di
                mov     word ptr sysinit_base_ptr, di ; es:di -> destination.
                mov     si, offset sysinit_base ; ds:si -> source code to be relocated.
                mov     cx, 129         ; end_sysinit_base-sysinit_base ; 129
                add     memlo, cx
                or      cs:setdevmarkflag, 2 ; for_devmark
                call    round
                rep movsb
                mov     sysinit_ptr, offset sysinitptr ; returning address from
                                        ; sysinit_base back to sysinit
                mov     sysinit_ptr+2, cs
                or      install_flag, 2 ; for_devmark
                call    round
                mov     bx, memhi
                mov     ax, area
                mov     old_area, ax    ; save [area]
                mov     es, ax          ; calc what we needed
                sub     bx, ax
                mov     ah, 4Ah         ; SETBLOCK
                int     21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
                                        ; ES = segment address of block to change
                                        ; BX = new size in paragraphs
                push    es
                mov     ax, es
                dec     ax
                mov     es, ax          ; point to arena
                assume es:nothing
                mov     word ptr es:1, 8 ; [es:ARENA.OWNER],8 ; set impossible owner
                mov     word ptr es:8, 4453h ; [es:ARENA.NAME],'SD' ; System Data
                pop     es
                assume es:nothing
                mov     bx, 0FFFFh
                mov     ah, 48h
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                mov     ah, 48h         ; allocate the rest of the memory
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                mov     memhi, ax       ; start of the allocated memory
                mov     memlo, 0        ; to be used next.
                mov     es, ax
                mov     bx, CONFBOT
                sub     bx, ax          ; confbot - memhi
                dec     bx              ; make a room for the memory block id.
                dec     bx              ; make sure!
                mov     ah, 4Ah         ; this will free (confbot to top of memory)
                int     21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
                                        ; ES = segment address of block to change
                                        ; BX = new size in paragraphs
                mov     bx, 0FFFFh
                mov     ah, 48h
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                mov     ah, 48h         ; allocate (confbot to top of memory)
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                mov     area, ax        ; save allocated memory segment.
                                        ; need this to free this area for command.com.
                mov     es, memhi
                mov     ah, 49h         ; free allocated memory
                                        ; free (memhi to confbot(=area))
                int     21h             ; DOS - 2+ - FREE MEMORY
                                        ; ES = segment address of area to be freed
                retn
endfile         endp


; =============== S U B R O U T I N E =======================================


do_install_exec proc near               ; CODE XREF: doconf+16F↓p
                                        ; doconf+19F↓p
                push    si              ; EXEC a program being loaded via the
                                        ; "install=" mechanism in config.sys
                push    es
                push    ds
                pop     es
                assume es:SYSINIT
                pop     ds              ; es->sysinitseg,ds->confbot seg
                assume ds:nothing
                mov     dx, si          ; ds:dx->file name,0 in config.sys image.
                xor     cx, cx
                cld
                mov     cs:ldexec_start, 20h ; ' ' ; clear out the parm area
                mov     di, offset ldexec_parm

installfilename:                        ; CODE XREF: do_install_exec+18↓j
                lodsb                   ; skip the file name
                                        ; al = ds:si; si++
                cmp     al, 0
                jz      short got_installparm
                jmp     short installfilename
; ---------------------------------------------------------------------------

got_installparm:                        ; CODE XREF: do_install_exec+16↑j
                                        ; do_install_exec+25↓j
                lodsb                   ; copy the parameters to ldexec_parm
                mov     es:[di], al
                cmp     al, 0Ah         ; lf ; line feed?
                jz      short done_installparm
                inc     cl              ; # of char. in the parm.
                inc     di
                jmp     short got_installparm
; ---------------------------------------------------------------------------

done_installparm:                       ; CODE XREF: do_install_exec+20↑j
                mov     cs:ldexec_line, cl ; length of the parm.
                cmp     cl, 0           ; if no parm,then
                jnz     short install_seg_set ; let the parm area
                mov     cs:ldexec_start, 0Dh ; cr ; starts with cr.

install_seg_set:                        ; CODE XREF: do_install_exec+2F↑j
                mov     cs:0, 0         ; make a null environment segment
                mov     ax, cs          ; by overlap jmp instruction of sysinitseg.
                mov     cx, ax
                cmp     cs:config_envlen, 0
                jz      short no_envdata2
                mov     cx, cs:config_wrkseg

no_envdata2:                            ; CODE XREF: do_install_exec+48↑j
                mov     cs:iexec_environ, cx ; [cs:instexe.exec0_environ]
                                        ; set the environment seg.
                mov     cs:iexec_ldexec_line_seg, ax ; [cs:instexe.exec0_com_line+2]
                                        ; set the seg.
                mov     cs:iexec_ldexec_5c_fcb_seg, ax ; [cs:instexe.exec0_5c_fcb+2
                mov     cs:iexec_ldexec_6c_fcb_seg, ax ; [cs:instexe.exec0_6c_fcb+2]]
                call    sum_up
                mov     es:checksum, ax ; save the value of the sum
                xor     ax, ax
                mov     ah, 4Bh         ; EXEC ; load/exec
                mov     bx, offset iexec_environ ; instexe ; es:bx -> parm block.
                push    es              ; save es,ds for load/exec
                push    ds              ; these registers will be restored in sysinit_base.
                jmp     cs:sysinit_base_ptr ; jmp to sysinit_base to execute
do_install_exec endp                    ; load/exec function and check sum.

; ---------------------------------------------------------------------------

sysinitptr:                             ; DATA XREF: endfile+427↑o
                pop     si              ; returning far address from sysinit_base
                                        ; restore si for config.sys file.
                push    es
                push    ds
                pop     es
                assume es:nothing
                pop     ds              ; now ds - sysinitseg, es - confbot
                jnb     short install_exit_ret
                push    si              ; error in loading the file for install=.
                call    badload         ; es:si-> path,filename,0.
                pop     si

install_exit_ret:                       ; CODE XREF: SYSINIT:1427↑j
                retn

; =============== S U B R O U T I N E =======================================


ParaRound       proc near               ; CODE XREF: TempCDS+14↑p
                                        ; endfile+239↑p ...
                add     ax, 15          ; round up length in paragraphs
                                        ; 0Fh
                rcr     ax, 1
                shr     ax, 1
                shr     ax, 1
                shr     ax, 1
                retn
ParaRound       endp

; ---------------------------------------------------------------------------

sysinit_base:                           ; DATA XREF: endfile+412↑o
                mov     word ptr cs:sysinit_base_ss, ss ; sysinit_base module
                mov     word ptr cs:sysinit_base_sp, sp
                int     21h             ; load/exec dos call.
                mov     ss, word ptr cs:sysinit_base_ss ; restore stack
                assume ss:nothing
                mov     sp, word ptr cs:sysinit_base_sp
                pop     ds
                pop     es
                jb      short sysinit_base_end
                call    sum_up
                cmp     es:checksum, ax
                jz      short sysinit_base_end
                mov     ah, 9           ; memory broken.
                                        ; show "memory allocation error" message and stall.
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     dx, 102         ; mem_alloc_err_msgx-sysinit_base ; 66h
                int     21h             ; DOS - PRINT STRING
                                        ; DS:DX -> string terminated by "$"
; START OF FUNCTION CHUNK FOR AllocMemForDOS
;   ADDITIONAL PARENT FUNCTION round

stall:                                  ; CODE XREF: AllocMemForDOS+77↑j
                                        ; SYSINIT:1469↓j ...
                hlt                     ; use HLT to minimize energy consumption
; END OF FUNCTION CHUNK FOR AllocMemForDOS
; ---------------------------------------------------------------------------
                jmp     short stall
; ---------------------------------------------------------------------------

sysinit_base_end:                       ; CODE XREF: SYSINIT:1453↑j
                                        ; SYSINIT:145D↑j
                jmp     dword ptr es:sysinit_ptr ; return back to sysinit module

; =============== S U B R O U T I N E =======================================


sum_up          proc near               ; CODE XREF: do_install_exec+60↑p
                                        ; SYSINIT:1455↑p
                push    ds
                mov     ax, es:CONFBOT
                mov     ds, ax
                assume ds:nothing
                xor     si, si
                xor     ax, ax
                mov     cx, es:config_size ; if config_size has been broken, then this
                                        ; whole test better fail.
                shr     cx, 1
                jz      short sum_sys_code ; when config.sys file not exist.

sum1:                                   ; CODE XREF: sum_up+18↓j
                add     ax, [si]
                inc     si
                inc     si
                loop    sum1

sum_sys_code:                           ; CODE XREF: sum_up+12↑j
                mov     si, offset locstack ; 586h
                                        ; starting after the stack.
                                        ; this does not cover the possible stack code!
                mov     cx, 5B40h       ; SI_end (23360)
                                        ; SI_end is the label at the end of sysinit
                                        ; from after_checksum to SI_end
                sub     cx, si
                shr     cx, 1

sum2:                                   ; CODE XREF: sum_up+29↓j
                add     ax, es:[si]
                inc     si
                inc     si
                loop    sum2
                pop     ds
                retn
sum_up          endp

; ---------------------------------------------------------------------------
sysinit_base_ssx dw 0                   ; sysinit_base_ss equ $-sysinit_base ; 62
sysinit_base_spx dw 0                   ; sysinit_base_sp equ $-sysinit_base ; 64
mem_alloc_err_msgx db 0Dh,0Ah
                db 'Memory allocation error $'

; =============== S U B R O U T I N E =======================================


set_buffer      proc near               ; CODE XREF: endfile+1C3↑p
                xor     dl, dl          ; input:
                                        ;   ds:bx -> buffinfo.
                                        ;   [memhi]:[memlo=0] = available space for the hash bucket.
                                        ;   singlebuffersize = buff header size + sector size
                                        ; output:
                                        ;   buffers Queue established.
                                        ;   [memhi]:[memlo] = addr of the next available free space.
                                        ;
                                        ; assume buffers not in HMA
                call    GetBufferAddr
                jz      short set_buff_1
                mov     dl, 1           ; buffers in HMA

set_buff_1:                             ; CODE XREF: set_buffer+5↑j
                mov     [bx], di        ; [bx+BUFFINF.Buff_Queue] ; head of Buff Q
                mov     word ptr [bx+2], es ; [bx+BUFFINF.Buff_Queue+2]
                mov     word ptr [bx+4], 0 ; [bx+BUFFINF.Dirty_Buff_Count] ; set dirty_count to 0.
                mov     ax, di
                mov     cx, cs:buffers
                push    di              ; remember first buffer

nxt_buff:                               ; CODE XREF: set_buffer+20↓j
                call    set_buffer_info ; set buf_link,buf_id...
                mov     di, ax
                loop    nxt_buff
                sub     di, cs:singlebuffersize ; point to last buffer
                pop     cx              ; get first buffer
                mov     es:[di], cx     ; [es:di+buffinfo.buf_next] ; last->next = first
                xchg    cx, di
                mov     es:[di+2], cx   ; [es:di+buffinfo.buf_prev] ; first->prev = last
                or      dl, dl          ; In HMa ?
                jz      short set_buff_2 ; no
                mov     byte ptr [bx+0Ch], 1 ; mov byte [bx+BUFFINF.Buff_In_HMA],1
                mov     ax, cs:memhi    ; seg of scratch buff
                mov     word ptr [bx+0Dh], 0 ; [bx+BUFFINF.Lo_Mem_Buff] ; offset of scratch buff is 0
                mov     [bx+0Fh], ax    ; mov [bx+BUFFINF.Lo_Mem_Buff+2],ax
                mov     ax, cs:singlebuffersize ; size of scratch buff
                sub     ax, 24          ; bufinsiz ; 24 ; buffer head not required
                                        ; (bufinsiz is 20 in MSDOS 6.21 IO.SYS)

set_buff_2:                             ; CODE XREF: set_buffer+33↑j
                add     cs:memlo, ax
                or      cs:setdevmarkflag, 2 ; for_devmark = 2
                call    round
                retn
set_buffer      endp


; =============== S U B R O U T I N E =======================================


GetBufferAddr   proc near               ; CODE XREF: set_buffer+2↑p
                push    bx
                push    dx
                cmp     cs:dosdata_umb, 2 ; is dosdata moved to UMB ? (DOSDATA=UMB done)
                jnz     short gba_1     ; no
                cmp     word ptr [bx+2], 0FFFFh ; is the buffer (already) in HMA ?
                jz      short gba_2     ; yes

gba_1:                                  ; CODE XREF: GetBufferAddr+8↑j
                mov     ax, cs:singlebuffersize
                mul     cs:buffers
                add     ax, 0Fh         ; 15
                and     ax, 0FFF0h      ; ~15 ; not 0Fh
                mov     bx, ax
                mov     ax, 4A02h       ; ((multMULT<<8)+multMULTALLOCHMA)
                int     2Fh             ; DOS 5+ - ALLOCATE HMA SPACE
                                        ;     AX = 4A02h
                                        ;     BX = number of bytes
                                        ; Return:
                                        ;     ES:DI -> start of allocated HMA block or FFFFh:FFFFh
                                        ;     BX = number of bytes actually allocated (rounded up to next
                                        ;          paragraph for DOS 5.0 and 6.0)
                                        ; Notes:
                                        ;     this call is not valid unless DOS is loaded in the HMA (DOS=HIGH)
                                        ;
                                        ;     called by Windows 3.1 DOSX.EXE
                                        ;     supported by Novell DOS 7
                cmp     di, 0FFFFh
                jnz     short got_hma
                mov     di, 0           ; dont xor di,di Z flag needed
                                        ;
                                        ; 05/09/2023 - Erdogan Tan
                                        ; (above msdos source code comment is wrong
                                        ; because ZF is already 1 here and
                                        ; 'xor di,di' sets ZF to 1 again;
                                        ; 'inc di' would be most proper instruction here)
                mov     es, cs:memhi

got_hma:                                ; CODE XREF: GetBufferAddr+29↑j
                pop     dx
                pop     bx
                retn
; ---------------------------------------------------------------------------

gba_2:                                  ; CODE XREF: GetBufferAddr+E↑j
                les     di, [bx]
                or      di, di
                pop     dx
                pop     bx
                retn
GetBufferAddr   endp


; =============== S U B R O U T I N E =======================================


set_buffer_info proc near               ; CODE XREF: set_buffer:nxt_buff↑p
                push    cs:buf_prev_off ; es:di -> buffer header to be set.
                                        ; ax = di
                pop     word ptr es:[di+2] ; [es:di+buffinfo.buf_prev]
                mov     cs:buf_prev_off, ax
                add     ax, cs:singlebuffersize ; adjust ax
                mov     es:[di], ax     ; [es:di+buffinfo.buf_next]
                mov     word ptr es:[di+4], 0FFh ; [es:di+buffinfo.buf_ID]
                                        ; new buffer free
                mov     word ptr es:[di+6], 0 ; [es:di+buffinfo.buf_sector]
                mov     word ptr es:[di+8], 0 ; [es:di+buffinfo.buf_sector+2]
                retn
set_buffer_info endp


; =============== S U B R O U T I N E =======================================


stackinit       proc near               ; CODE XREF: endfile+2D9↑p
                push    ax              ; ibmstack initialization routine
                                        ; in - cs, ds -> sysinitseg,
                                        ;      es -> relocated stack code & data.
                push    ds
                push    es
                push    bx
                push    cx
                push    dx
                push    di
                push    si
                push    bp
                mov     ax, cs:stack_count
                mov     es:stackcount, ax
                mov     ax, ds:stack_size
                mov     es:stacksize, ax
                mov     ax, cs:stack_addr ; offset
                mov     es:stacks, ax
                mov     ax, cs:stack_addr+2 ; segment
                mov     es:stacks+2, ax
                mov     bp, es:stacks   ; "firstentry" will always be at stacks
                                        ; the stacks will always immediately follow the table entries
                mov     es:firstentry, bp
                mov     ax, 8           ; entrysize
                mov     cx, es:stackcount
                mul     cx
                add     ax, bp
                mov     es:stackat, ax
                mov     bx, ax
                sub     bx, 2
                mov     di, es:stackat  ; zero the entire stack area to start with
                mov     ax, es:stacksize
                mul     cx
                mov     cx, ax
                xor     ax, ax
                push    es
                pop     ds              ; ds = relocated stack code seg.
                mov     es, ds:stacks+2 ; get segment of stack area.
                cld
                rep stosb               ; 0
                mov     cx, ds:stackcount ; loop for "count" times, building a table entry
                                        ; cs = sysinitseg, ds = relocated stack code seg,
                                        ; es = segment of stack space
                                        ; cx = number of entries
                                        ; es:bp => base of stacks - 2
                                        ; es:bx => first table entry

buildloop:                              ; CODE XREF: stackinit+82↓j
                mov     byte ptr es:[bp+0], 0 ; [es:bp+allocbyte],free
                mov     es:[bp+1], al   ; [es:bp+intlevel]
                                        ; ax = 0
                mov     es:[bp+2], ax   ; [es:bp+savedsp]
                mov     es:[bp+4], ax   ; [es:bp+savedss]
                add     bx, ds:stacksize
                mov     es:[bp+6], bx   ; [es:bp+newsp]
                mov     es:[bx], bp
                add     bp, 8           ; entrysize
                loop    buildloop
                sub     bp, 8           ; entrysize
                mov     ds:lastentry, bp
                mov     ds:nextentry, bp
                push    ds
                mov     ax, 0F000h      ; look at the model byte
                mov     ds, ax
                assume ds:nothing
                cmp     byte ptr ds:0FFFEh, 0F9h ; mdl_convert ; convertible?
                pop     ds
                assume ds:nothing
                jnz     short skip_disablenmis
                mov     al, 7           ; disable convertible nmis
                out     72h, al         ; CMOS Memory/RTC Index Register (Extended RAM)

skip_disablenmis:                       ; CODE XREF: stackinit+9B↑j
                xor     ax, ax
                mov     es, ax
                assume es:nothing
                cli

stkinit_02:                             ; Int 02h vector table offset
                mov     si, 8
                mov     di, offset int19old02
                mov     bx, offset old02
                mov     dx, offset int02
                call    new_init_loop

stkinit_08:                             ; Int 08h vector table offset
                mov     si, 32
                mov     di, offset int19old08
                mov     bx, offset old08
                mov     dx, offset int08
                call    new_init_loop

stkinit_09:                             ; Int 09h vector table offset
                mov     si, 36
                mov     di, offset int19old09
                mov     bx, offset old09
                mov     dx, offset int09
                call    new_init_loop

stkinit_70:                             ; Int 70h vector table offset
                mov     si, 448
                mov     di, offset int19old70
                mov     bx, offset old70
                mov     dx, offset int70
                call    new_init_loop

stkinit_0A:                             ; 0Ah*4 ; 40
                mov     si, 28h         ; Int 0Ah vector table offset
                push    ds              ; save relocated stack code segment
                lds     bx, es:[si]     ; ds:bx -> original interrupt handler
                push    ds
                pop     dx              ; dx = segment value
                cmp     dx, 0
                jz      short int_0A_first
                cmp     byte ptr [bx], 0CFh ; does vector point to an iret?
                jz      short int_0A_first
                cmp     word ptr [bx+6], 424Bh ; magic offset (see int&aa, msstack.inc)
                jz      short int_0A_not_first
                cmp     dx, 0F000h      ; rom bios segment
                jnz     short int_0A_not_first
                push    es
                push    dx
                mov     dx, 0F000h
                mov     es, dx
                assume es:nothing
                cmp     bx, es:0FF01h
                pop     dx
                pop     es
                assume es:nothing
                jz      short int_0A_first

int_0A_not_first:                       ; CODE XREF: stackinit+FA↑j
                                        ; stackinit+100↑j
                pop     ds              ; not the first. we are going to hook vector.
                mov     di, offset int19old0A ; we have to set old&aa for int19 handler too.
                mov     bx, offset old0A ; pass where to save original owner pointer
                mov     dx, offset int0A ; pass where new handler is
                call    new_init_loop   ; adjust the vector to new handler,
                                        ; saving pointer to original owner.
                jmp     short stkinit_0B
; ---------------------------------------------------------------------------

int_0A_first:                           ; CODE XREF: stackinit+EE↑j
                                        ; stackinit+F3↑j ...
                pop     ds              ; the first. don't have to hook stack code.

stkinit_0B:                             ; CODE XREF: stackinit+11F↑j
                mov     si, 2Ch         ; Int 0Bh vector table offset
                push    ds
                lds     bx, es:[si]
                push    ds
                pop     dx
                cmp     dx, 0
                jz      short int_0B_first
                cmp     byte ptr [bx], 0CFh
                jz      short int_0B_first
                cmp     word ptr [bx+6], 424Bh
                jz      short int_0B_not_first
                cmp     dx, 0F000h
                jnz     short int_0B_not_first
                push    es
                push    dx
                mov     dx, 0F000h
                mov     es, dx
                assume es:nothing
                cmp     bx, es:0FF01h
                pop     dx
                pop     es
                assume es:nothing
                jz      short int_0B_first

int_0B_not_first:                       ; CODE XREF: stackinit+13A↑j
                                        ; stackinit+140↑j
                pop     ds
                mov     di, offset int19old0B
                mov     bx, offset old0B
                mov     dx, offset int0B
                call    new_init_loop
                jmp     short stkinit_0C
; ---------------------------------------------------------------------------

int_0B_first:                           ; CODE XREF: stackinit+12E↑j
                                        ; stackinit+133↑j ...
                pop     ds

stkinit_0C:                             ; CODE XREF: stackinit+15F↑j
                mov     si, 30h         ; Int 0Ch vector table offset
                push    ds
                lds     bx, es:[si]
                push    ds
                pop     dx
                cmp     dx, 0
                jz      short int_0C_first
                cmp     byte ptr [bx], 0CFh
                jz      short int_0C_first
                cmp     word ptr [bx+6], 424Bh
                jz      short int_0C_not_first
                cmp     dx, 0F000h
                jnz     short int_0C_not_first
                push    es
                push    dx
                mov     dx, 0F000h
                mov     es, dx
                assume es:nothing
                cmp     bx, es:0FF01h
                pop     dx
                pop     es
                assume es:nothing
                jz      short int_0C_first

int_0C_not_first:                       ; CODE XREF: stackinit+17A↑j
                                        ; stackinit+180↑j
                pop     ds
                mov     di, offset int19old0C
                mov     bx, offset old0C
                mov     dx, offset int0C
                call    new_init_loop
                jmp     short stkinit_0D
; ---------------------------------------------------------------------------

int_0C_first:                           ; CODE XREF: stackinit+16E↑j
                                        ; stackinit+173↑j ...
                pop     ds

stkinit_0D:                             ; CODE XREF: stackinit+19F↑j
                mov     si, 34h         ; Int 0Dh vector table offset
                push    ds
                lds     bx, es:[si]
                push    ds
                pop     dx
                cmp     dx, 0
                jz      short int_0D_first
                cmp     byte ptr [bx], 0CFh
                jz      short int_0D_first
                cmp     word ptr [bx+6], 424Bh
                jz      short int_0D_not_first
                cmp     dx, 0F000h
                jnz     short int_0D_not_first
                push    es
                push    dx
                mov     dx, 0F000h
                mov     es, dx
                assume es:nothing
                cmp     bx, es:0FF01h
                pop     dx
                pop     es
                assume es:nothing
                jz      short int_0D_first

int_0D_not_first:                       ; CODE XREF: stackinit+1BA↑j
                                        ; stackinit+1C0↑j
                pop     ds
                mov     di, offset int19old0D
                mov     bx, offset old0D
                mov     dx, offset int0D
                call    new_init_loop
                jmp     short stkinit_0E
; ---------------------------------------------------------------------------

int_0D_first:                           ; CODE XREF: stackinit+1AE↑j
                                        ; stackinit+1B3↑j ...
                pop     ds

stkinit_0E:                             ; CODE XREF: stackinit+1DF↑j
                mov     si, 38h         ; 0Eh*4 ; Int 0Eh vector table offset
                push    ds
                lds     bx, es:[si]
                push    ds
                pop     dx
                cmp     dx, 0
                jz      short int_0E_first
                cmp     byte ptr [bx], 0CFh
                jz      short int_0E_first
                cmp     word ptr [bx+6], 424Bh
                jz      short int_0E_not_first
                cmp     dx, 0F000h
                jnz     short int_0E_not_first
                push    es
                push    dx
                mov     dx, 0F000h
                mov     es, dx
                assume es:nothing
                cmp     bx, es:0FF01h
                pop     dx
                pop     es
                assume es:nothing
                jz      short int_0E_first

int_0E_not_first:                       ; CODE XREF: stackinit+1FA↑j
                                        ; stackinit+200↑j
                pop     ds
                mov     di, offset int19old0E
                mov     bx, offset old0E
                mov     dx, offset int0E
                call    new_init_loop
                jmp     short stkinit_72
; ---------------------------------------------------------------------------

int_0E_first:                           ; CODE XREF: stackinit+1EE↑j
                                        ; stackinit+1F3↑j ...
                pop     ds

stkinit_72:                             ; CODE XREF: stackinit+21F↑j
                mov     si, 1C8h        ; 72h*4 ; 456
                                        ; Int 72h vector table offset
                push    ds
                lds     bx, es:[si]
                push    ds
                pop     dx
                cmp     dx, 0
                jz      short int_72_first
                cmp     byte ptr [bx], 0CFh
                jz      short int_72_first
                cmp     word ptr [bx+6], 424Bh
                jz      short int_72_not_first
                cmp     dx, 0F000h
                jnz     short int_72_not_first
                push    es
                push    dx
                mov     dx, 0F000h
                mov     es, dx
                assume es:nothing
                cmp     bx, es:0FF01h
                pop     dx
                pop     es
                assume es:nothing
                jz      short int_72_first

int_72_not_first:                       ; CODE XREF: stackinit+23A↑j
                                        ; stackinit+240↑j
                pop     ds
                mov     di, offset int19old72
                mov     bx, offset old72
                mov     dx, offset int72
                call    new_init_loop
                jmp     short stkinit_73
; ---------------------------------------------------------------------------

int_72_first:                           ; CODE XREF: stackinit+22E↑j
                                        ; stackinit+233↑j ...
                pop     ds

stkinit_73:                             ; CODE XREF: stackinit+25F↑j
                mov     si, 1CCh        ; 73h*4 ; 460
                push    ds
                lds     bx, es:[si]
                push    ds
                pop     dx
                cmp     dx, 0
                jz      short int_73_first
                cmp     byte ptr [bx], 0CFh
                jz      short int_73_first
                cmp     word ptr [bx+6], 424Bh
                jz      short int_73_not_first
                cmp     dx, 0F000h
                jnz     short int_73_not_first
                push    es
                push    dx
                mov     dx, 0F000h
                mov     es, dx
                assume es:nothing
                cmp     bx, es:0FF01h
                pop     dx
                pop     es
                assume es:nothing
                jz      short int_73_first

int_73_not_first:                       ; CODE XREF: stackinit+27A↑j
                                        ; stackinit+280↑j
                pop     ds
                mov     di, offset int19old73
                mov     bx, offset old73
                mov     dx, offset int73
                call    new_init_loop
                jmp     short stkinit_74
; ---------------------------------------------------------------------------

int_73_first:                           ; CODE XREF: stackinit+26E↑j
                                        ; stackinit+273↑j ...
                pop     ds

stkinit_74:                             ; CODE XREF: stackinit+29F↑j
                mov     si, 1D0h
                push    ds
                lds     bx, es:[si]
                push    ds
                pop     dx
                cmp     dx, 0
                jz      short int_74_first
                cmp     byte ptr [bx], 0CFh
                jz      short int_74_first
                cmp     word ptr [bx+6], 424Bh
                jz      short int_74_not_first
                cmp     dx, 0F000h
                jnz     short int_74_not_first
                push    es
                push    dx
                mov     dx, 0F000h
                mov     es, dx
                assume es:nothing
                cmp     bx, es:0FF01h
                pop     dx
                pop     es
                assume es:nothing
                jz      short int_74_first

int_74_not_first:                       ; CODE XREF: stackinit+2BA↑j
                                        ; stackinit+2C0↑j
                pop     ds
                mov     di, offset int19old74
                mov     bx, offset old74
                mov     dx, offset int74
                call    new_init_loop
                jmp     short stkinit_76
; ---------------------------------------------------------------------------

int_74_first:                           ; CODE XREF: stackinit+2AE↑j
                                        ; stackinit+2B3↑j ...
                pop     ds

stkinit_76:                             ; CODE XREF: stackinit+2DF↑j
                mov     si, 1D8h        ; 76h*4 ; 472
                push    ds
                lds     bx, es:[si]
                push    ds
                pop     dx
                cmp     dx, 0
                jz      short int_76_first
                cmp     byte ptr [bx], 0CFh
                jz      short int_76_first
                cmp     word ptr [bx+6], 424Bh
                jz      short int_76_not_first
                cmp     dx, 0F000h
                jnz     short int_76_not_first
                push    es
                push    dx
                mov     dx, 0F000h
                mov     es, dx
                assume es:nothing
                cmp     bx, es:0FF01h
                pop     dx
                pop     es
                assume es:nothing
                jz      short int_76_first

int_76_not_first:                       ; CODE XREF: stackinit+2FA↑j
                                        ; stackinit+300↑j
                pop     ds
                mov     di, offset int19old76
                mov     bx, offset old76
                mov     dx, offset int76
                call    new_init_loop
                jmp     short stkinit_77
; ---------------------------------------------------------------------------

int_76_first:                           ; CODE XREF: stackinit+2EE↑j
                                        ; stackinit+2F3↑j ...
                pop     ds

stkinit_77:                             ; CODE XREF: stackinit+31F↑j
                mov     si, 1DCh        ; mov si,77h*4 ; 476
                                        ; Int 77h vector table offset
                push    ds              ; save relocated stack code segment
                lds     bx, es:[si]     ; ds:bx -> original interrupt handler
                push    ds
                pop     dx              ; dx = segment value
                cmp     dx, 0
                jz      short int_77_first
                cmp     byte ptr [bx], 0CFh ; does vector point to an iret?
                jz      short int_77_first
                cmp     word ptr [bx+6], 424Bh ; magic offset (see int&aa, msstack.inc)
                jz      short int_77_not_first
                cmp     dx, 0F000h      ; rom bios segment
                jnz     short int_77_not_first
                push    es
                push    dx
                mov     dx, 0F000h
                mov     es, dx
                assume es:nothing
                cmp     bx, es:0FF01h
                pop     dx
                pop     es
                assume es:nothing
                jz      short int_77_first

int_77_not_first:                       ; CODE XREF: stackinit+33A↑j
                                        ; stackinit+340↑j
                pop     ds              ; not the first. we are going to hook vector.
                mov     di, offset int19old77 ; we have to set old&aa for int19 handler too.
                mov     bx, offset old77 ; pass where to save original owner pointer
                mov     dx, offset int77 ; pass where new handler is
                call    new_init_loop   ; adjust the vector to new handler,
                                        ; saving pointer to original owner.
                jmp     short int_77_end
; ---------------------------------------------------------------------------

int_77_first:                           ; CODE XREF: stackinit+32E↑j
                                        ; stackinit+333↑j ...
                pop     ds              ; the first. don't have to hook stack code.

int_77_end:                             ; CODE XREF: stackinit+35F↑j
                push    ds
                mov     ax, 0F000h
                mov     ds, ax
                assume ds:nothing
                cmp     byte ptr ds:0FFFEh, 0F9h ; mdl_convert ; pc convertible?
                pop     ds
                assume ds:nothing
                jnz     short skip_enablenmis
                mov     al, 27h         ; enable convertible nmis
                out     72h, al         ; CMOS Memory/RTC Index Register (Extended RAM)

skip_enablenmis:                        ; CODE XREF: stackinit+36E↑j
                sti
                mov     ax, 70h         ; DOSBIODATASEG
                mov     ds, ax
                assume ds:nothing
                mov     ds:int19sem, 1  ; indicate that int 19h
                                        ; initialization is complete
                pop     bp
                pop     si
                pop     di
                pop     dx
                pop     cx
                pop     bx
                pop     es
                pop     ds
                assume ds:nothing
                pop     ax
                retn
stackinit       endp


; =============== S U B R O U T I N E =======================================


new_init_loop   proc near               ; CODE XREF: stackinit+B2↑p
                                        ; stackinit+C1↑p ...
                cmp     cs:dosdata_umb, 2 ; is DOSDATA=UMB done ? (DOSDATA is in UMB)
                jnz     short new_init_loop_1st
                push    ds              ; restore original/previous interrupt handler
                                        ; (from int19old?? field in BIOSDATA)
                mov     ax, 70h
                mov     ds, ax
                assume ds:nothing
                lds     ax, [di]        ; restore original Int ?? handler addr from int19old?? field
                assume ds:nothing
                mov     es:[si], ax     ; copy the original int handler addr to its int vector addr
                mov     word ptr es:[si+2], ds
                pop     ds

new_init_loop_1st:                      ; CODE XREF: new_init_loop+6↑j
                mov     ax, es:[si]     ; new stack initialization
                                        ; (dx = new handler offset,
                                        ;  bx = original handler saving addr,
                                        ;  si = int vector table offset
                                        ;  di = int19old?? field offset -in DOSBIOSDATASEG-
                                        ;  es = zero, segid of vector table
                                        ;  ds = relocated stack code segment)
                mov     [bx], ax
                mov     ax, es:[si+2]
                mov     [bx+2], ax
                push    ds
                mov     ax, 70h         ; DOSBIODATASEG
                mov     ds, ax
                assume ds:nothing
                mov     ax, es:[si]
                mov     [di], ax
                mov     ax, es:[si+2]
                mov     [di+2], ax
                pop     ds
                assume ds:nothing
                mov     es:[si], dx
                mov     word ptr es:[si+2], ds
                retn
new_init_loop   endp


; =============== S U B R O U T I N E =======================================


setdevmark      proc near               ; CODE XREF: endfile+3C↑p
                                        ; endfile+92↑p ...
                push    es              ; set the devmark for mem command.
                                        ; in:
                                        ;   [memhi] - the address to place devmark
                                        ;   [memlo] = 0
                                        ;   al = id for devmark_id
                                        ; out:
                                        ;   devmark established.
                                        ;   the address saved in cs:[devmark_addr]
                                        ;   [memhi] increase by 1.
                push    cx
                mov     cx, cs:memhi
                mov     cs:devmark_addr, cx
                mov     es, cx
                mov     es:0, al        ; [es:devmark.id]
                inc     cx
                mov     es:1, cx        ; [es:devmark.seg]
                pop     cx
                pop     es
                inc     cs:memhi
                retn
setdevmark      endp

; ---------------------------------------------------------------------------
MagicDDNamePtr  dw offset MagicDDName   ; DATA XREF: SYSINIT:wait_for_key_2s↑w
                                        ; MagicPreload+28↓r
                                        ; "\\DBLSPACE.BIN"
                db 'C:'
MagicDDName     db '\DBLSPACE.BIN',0    ; DATA XREF: SYSINIT:set_drvspc_size↑o
                                        ; SYSINIT:MagicDDNamePtr↑o ...
StackerName     db 'C:\STACKER.BIN',0   ; DATA XREF: SYSINIT:set_stacker_name↑o
                                        ; SYSINIT:0780↑o
tiny_stub_start dw 0FFFFh               ; DATA XREF: MagicPostload+38↓o
                                        ; phony device driver link
                dw 0FFFFh               ; dw -1, -1
                dw 8000h                ; mark as character device for MEM display
                dw 2 dup(0)             ; strat and irpt
                db 'DBLSBIN$'           ; magic default load
                                        ; (tiny_stub_end-tiny_stub_start = 18)

; =============== S U B R O U T I N E =======================================


MagicPreload    proc near               ; CODE XREF: SYSINIT:07DA↑p
                mov     cs:setdevmarkflag, 0 ; not for devmark
                call    round
                push    cs
                pop     es
                assume es:SYSINIT
                mov     cs:DeviceHi, 0  ; not to be loaded in UMB
                call    InitDevLoad
                mov     ax, cs:DevLoadAddr
                add     ax, cs:DevSize  ; calculate seg after DD load
                jb      short pre_exit_err ; choke if overflows address space
                cmp     ax, cs:DevLoadEnd ; does it overflow available space?
                ja      short pre_exit_err

_LoadDev:                               ; we're golden if not
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     dx, cs:MagicDDNamePtr
                call    ExecDev         ; load device driver using exec call
                jb      short pre_exit_err
                les     bx, cs:DevEntry ; point to the Magic DD header
                assume es:nothing
                cmp     word ptr es:[bx+12h], 2E2Ch ; is it our stamp? ; ',.'
                jnz     short pre_exit_err
                mov     word ptr cs:MagicBackdoor, 14h ; save the backdoor entry.
                                        ; (initial IP -EXE header offset 20-)
                mov     word ptr cs:MagicBackdoor+2, es
                push    cs
                pop     es
                assume es:SYSINIT
                mov     bx, offset packet
                mov     cs:break_addr, 0
                mov     ax, cs:DevLoadEnd
                mov     cs:break_addr+2, ax
                mov     al, cs:drivenumber ; pass drive number to DBLSPACE as if
                mov     cs:devdrivenum, al ; it is a normal block device driver
                mov     ax, 10          ; DS_INTERNAL_REVISION
                                        ; tell it what revision we expect
                call    cs:MagicBackdoor ; first time call is init entry point
                                        ; with a standard device driver
                                        ; init packet at es:bx
                jnb     short no_driver_version_fail ; skip if not a version failure
                mov     ax, 6           ; DS_INTERNAL_REVISION_6 ; (Stacker ?)
                                        ; tell it what revision we expect
                call    cs:MagicBackdoor
                jnb     short no_driver_version_fail
                push    cs
                pop     ds
                mov     dx, offset baddblspace ; "Required system component is not instal"...
                call    print           ; display the message

fail_driver_load:                       ; CODE XREF: MagicPreload+95↓j
                mov     word ptr cs:MagicBackdoor+2, cs
                mov     word ptr cs:MagicBackdoor, offset NullBackdoor

pre_exit_err:                           ; CODE XREF: MagicPreload+1D↑j
                                        ; MagicPreload+24↑j ...
                mov     ax, 40h         ; SYSPRE_BADFILE_ERROR
                                        ; (problem loading dblspace.bin)
                retn
; ---------------------------------------------------------------------------

no_driver_version_fail:                 ; CODE XREF: MagicPreload+6F↑j
                                        ; MagicPreload+79↑j
                or      ax, ax          ; error code returned?
                jnz     short fail_driver_load

magic_is_resident:
                mov     ax, cs:break_addr
                call    ParaRound       ; convert to paragraphs
                add     ax, cs:break_addr+2
                mov     word ptr cs:DevBrkAddr+2, ax
                mov     word ptr cs:DevBrkAddr, 0 ; store normalized end here
                mov     bx, 4           ; inquire how many paragraphs it wants
                call    cs:MagicBackdoor
                mov     bx, cs:ALLOCLIM ; get top of free memory
                sub     bx, ax          ; see how much we'll lower it
                cmp     bx, word ptr cs:DevBrkAddr+2 ; is there that much room free?
                jb      short cant_move_driver
                sub     cs:ALLOCLIM, ax ; (mov [cs:ALLOCLIM],bx)
                mov     es, cs:ALLOCLIM
                assume es:nothing
                mov     bx, 6           ; tell the driver to move itself
                call    cs:MagicBackdoor
                mov     word ptr cs:DevBrkAddr+2, ax ; save end of low stub

cant_move_driver:                       ; CODE XREF: MagicPreload+C2↑j
                mov     ax, word ptr cs:DevBrkAddr+2 ; get terminate segment
                cmp     ax, cs:DevLoadEnd ; terminate size TOO big?
                ja      short pre_exit_err ; error out if so

_isblock:                               ; if no units found, erase the device
                mov     al, cs:unitcount
                or      al, al
                jz      short pre_exit_err
                xor     ah, ah
                lds     si, cs:DevEntry ; set ds:si to header
                assume ds:nothing
                mov     [si+10], al     ; mov [si+SYSDEV.NAME],al
                                        ; number of units in name field
                                        ; device drivers are *supposed*
                                        ; to do this for themselves.
                mov     cx, ax
                les     di, cs:DOSINFO  ; es:di point to dos info
                mov     ah, es:[di+20h] ; [es:di+SYSI_NUMIO]
                                        ; get number of devices
                mov     dl, ah
                add     ah, al          ; check for too many devices
                cmp     ah, 26          ; 'A' - 'Z' is 26 devices
                ja      short pre_exit_err
                or      cs:setdevmarkflag, 2
                call    DevSetBreak
                jnb     short _ok_block
                jmp     pre_exit_err
; ---------------------------------------------------------------------------

_ok_block:                              ; CODE XREF: MagicPreload+114↑j
                mov     es:[di+20h], ah ; [es:di+SYSI_NUMIO] ; update the amount
                lds     bx, cs:bpb_addr ; point to bpb array (*)
                xor     dh, dh

_perunit:
                les     bp, cs:DOSINFO
                les     bp, es:[bp+0]   ; es:[bp.sysi_dpb]
                                        ; get first dpb
                                        ; [es:bp+SysInitvars.SYSI_DPB] ; [es:bp+0]

_scandpb:                               ; CODE XREF: MagicPreload+138↓j
                cmp     word ptr es:[bp+19h], 0FFFFh ; -1 ; es:[bp.dpb_next_dpb]
                jz      short _foundpb
                les     bp, es:[bp+19h] ; les bp,es:[bp.dpb_next_dpb]
                                        ; [es:bp+DPB.NEXT_DPB]
                jmp     short _scandpb
; ---------------------------------------------------------------------------

_foundpb:                               ; CODE XREF: MagicPreload+132↑j
                                        ; MagicPreload+1C4↓j
                mov     ax, word ptr cs:DevBrkAddr
                mov     es:[bp+19h], ax ; es:[bp.dpb_next_dpb] ; DPB.NEXT_DPB
                mov     ax, word ptr cs:DevBrkAddr+2
                mov     es:[bp+1Bh], ax ; es:[bp.dpb_next_dpb+2] ; DPB.NEXT_DPB+2
                les     bp, cs:DevBrkAddr
                mov     word ptr es:[bp+19h], 0FFFFh ; -1
                mov     byte ptr es:[bp+18h], 0FFh ; es:[bp.dpb_first_access],-1
                                        ; DPB.FIRST_ACCESS
                add     word ptr cs:DevBrkAddr, 61 ; DPBSIZ ; 3Dh
                call    RoundBreakAddr
                mov     si, [bx]        ; ds:si points to bpb (*)
                                        ; (mov si,[bx] ..and then.. add bx,2)
                                        ; Note: If unit count > 1, bx points to a BPB in the BPB array,
                                        ; the array address is in [bpb_addr] (*)
                                        ; Erdogan Tan - 07/07/2023
                mov     es:[bp+0], dl   ; mov word ptr es:[bp.dpb_drive],dx
                                        ; [es:bp+DPB.DRIVE],dl
                mov     es:[bp+1], dh   ; [es:bp+DPB.UNIT],dh
                push    dx
                push    cx
                mov     dx, 4152h       ; DX = signature 4152h ('AR') for FAT32 extended BPB/DPB
                xor     cx, cx          ; 0
                mov     es:[bp+1Dh], cx ; DPB.NEXT_FREE ; last allocated cluster #
                cmp     [si+0Bh], cx    ; BPB.fatsecs16 ; [si+A_BPB.BPB_SECTORSPERFAT]
                jnz     short _setdpb   ; FAT DPB (33 bytes)
                                        ; FAT32 DPB (61 bytes)
                mov     es:[bp+39h], cx ; DPB.RESERVED = 0
                mov     es:[bp+3Bh], cx ; DPB.RESERVED+2 = 0
                dec     cx              ; 0FFFFh ; -1
                mov     es:[bp+1Fh], cx ; DPB.FREE_CNT (-1 = unknown)
                mov     es:[bp+21h], cx ; DPB.FREE_CNT+2 (-1 = unknown)
                mov     cx, 4558h       ; CX = signature 4558h ('EX') for FAT32 extended BPB/DPB

_setdpb:                                ; CODE XREF: MagicPreload+17B↑j
                mov     ah, 53h         ; SETDPB ; hidden system call
                int     21h             ; DOS - 2+ internal - TRANSLATE BIOS PARAMETER BLOCK
                                        ; DS:SI -> BPB (BIOS Parameter Block)
                                        ; ES:BP -> buffer for DOS Drive Parameter Block
                                        ; (if CX=4558h & DX=4152h, FAT32 Extended DPB will be set)
                pop     cx
                pop     dx
                mov     ax, es:[bp+2]   ; es:[bp.dpb_sector_size]  ; [es:bp+DPB.SECTOR_SIZE]
                push    es
                les     di, cs:DOSINFO
                cmp     ax, es:[di+10h] ; es:[di.sysi_maxsec] ; [es:di+SysInitvars.SYSI_MAXSEC]
                pop     es
                jbe     short _iblk_1
                mov     ax, 40h         ; SYSPRE_BADFILE_ERROR ; (pre_exit_err)
                                        ; (problem loading dblspace.bin)
                retn
; ---------------------------------------------------------------------------

_iblk_1:                                ; CODE XREF: MagicPreload+1A6↑j
                push    ds
                lds     ax, cs:DevEntry
                mov     es:[bp+13h], ax ; [es:bp+DPB.DRIVER_ADDR]
                mov     word ptr es:[bp+15h], ds ; [es:bp+DPB.DRIVER_ADDR+2]
                pop     ds
                inc     dl              ; increment drive number
                inc     dh              ; increment unit number
                inc     bx
                inc     bx              ; point to next BPB
                                        ; (in the BPB array) (*) -add bx,2-
                dec     cx              ; loop _foundpb
                jz      short _linkit
                jmp     _foundpb
; ---------------------------------------------------------------------------

_linkit:                                ; CODE XREF: MagicPreload+1C2↑j
                push    cs
                pop     ds
                assume ds:SYSINIT
                call    TempCDS         ; set cds for new drives
                les     di, cs:DOSINFO  ; es:di = dos table (SysInitVars)
                mov     ax, es:[di+22h] ; [es:di+SYSI_DEV] ; dx:cx = head of list
                mov     bx, es:[di+24h] ; [es:di+SYSI_DEV+2]
                lds     si, cs:DevEntry ; ds:si = device location
                assume ds:nothing
                mov     [si], ax        ; link in the driver
                mov     [si+2], bx
                mov     es:[di+22h], si ; [es:di+SYSI_DEV] ; set head of list in dos
                mov     word ptr es:[di+24h], ds ; [es:di+SYSI_DEV+2]
                call    DevBreak        ; mark successful install
                mov     cx, word ptr cs:DevBrkAddr+2 ; pass it a work buffer
                mov     dx, cs:ALLOCLIM ; address in cx (segment)
                sub     dx, cx          ; for len dx (paragraphs)
                mov     ax, 5500h       ; we're shuffle aware, but don't move
                                        ; any drives at this point.
                mov     bx, 2           ; switch what we can now
                call    cs:MagicBackdoor

pre_exit:                               ; no errors!
                xor     ax, ax          ; zf=1
                retn
MagicPreload    endp


; =============== S U B R O U T I N E =======================================


MagicPostload   proc near               ; CODE XREF: SYSINIT:088B↑p
                call    get_dblspace_version ; is it there?
                jnz     short no_magic  ; done if not
                test    dx, 8000h       ; is it already permanent?
                jz      short no_magic  ; no, done if so (not in final position)
                mov     bx, 0FFFFh      ; -1 ; how much space does it want?
                mov     ax, 4A11h       ; multMagicdrv
                                        ; DBLSPACE.BIN - GET RELOCATION SIZE
                int     2Fh             ; get paragraphs into ax
                inc     ax              ; extra 2 paragraphs for the stub
                inc     ax              ; ((tiny_stub_end-tiny_stub_start)+15)/16
                                        ; (18+15)/16 = 2
                mov     cs:DevSize, ax  ; store that (**)
                mov     cs:DeviceHi, 0  ; not to be loaded in UMB
                mov     word ptr cs:bpb_addr+2, cs ; pass name so that
                                        ; arena header can be set
                mov     word ptr cs:bpb_addr, offset MagicDDName ; "\\DBLSPACE.BIN"
                call    round           ; normalize memhi:memlo
                call    InitDevLoad     ; set up sub-arena, DevLoadAddr,
                                        ; DevLoadEnd, and DevEntry
                                        ; gets arena name from bpb_addr
                mov     es, cs:DevLoadAddr ; (**) (InitDevload sets this)
                xor     di, di          ; move a little header in place
                                        ; so that this looks to the mem command
                                        ; like a legitimate driver load
                mov     si, offset tiny_stub_start
                mov     cx, 18          ; (tiny_stub_end-tiny_stub_start)
                rep movsb               ; move it!
                mov     ax, es          ; advance es appropriately
                inc     ax              ; add ax,((tiny_stub_end-tiny_stub_start)+15)/16
                inc     ax
                mov     es, ax
                assume es:MSLOAD
                mov     bx, 0FFFEh      ; -2 ; final placement!
                mov     ax, 4A11h       ; multMagicdrv
                int     2Fh             ; DBLSPACE.BIN - RELOCATE
                                        ; es = segment to which to relocate DBLSPACE.BIN
                mov     ax, cs:DevLoadAddr ; (**)
                add     ax, cs:DevSize  ; calculate seg after DD load
                mov     word ptr cs:DevBrkAddr+2, ax ; save as ending address!
                mov     word ptr cs:DevBrkAddr, 0
                call    DevSetBreak     ; go ahead and alloc mem for device
                call    DevBreak

no_magic:                               ; CODE XREF: MagicPostload+3↑j
                                        ; MagicPostload+9↑j
                retn
MagicPostload   endp


; =============== S U B R O U T I N E =======================================


MagicSetCdss    proc near               ; CODE XREF: SYSINIT:0891↑p
                call    get_dblspace_version ; is it there?
                jnz     short magic_set_exit ; done if not
                                        ; ...
                                        ; cl = first DblSpace drive in ASCII
                                        ; ch = number of DblSpace drive letters
                lds     si, cs:DOSINFO  ; point to DOS data area (SysInitVars)
                lds     si, [si+16h]    ; lds si,[si+SYSI_CDS] ; fetch CDSs
                mov     ah, 88          ; curdirLen
                sub     cl, 'A'         ; make it zero based.
                mov     al, cl          ; get first DblSpace drive letter
                mul     ah              ; find first DblSpace CDS
                add     si, ax          ; cds pointer
                mov     dl, cl          ; save for drive testing loop
                mov     cl, ch          ; get DblSpace drive count into cx
                xor     ch, ch

magic_set_cdss_1:                       ; CODE XREF: MagicSetCdss+3C↓j
                push    cx
                push    dx
                push    ds
                push    si
                mov     ax, 4A11h       ; multMagicdrv
                mov     bx, 1           ; MD_DRIVE_MAP ; inquire drive map
                int     2Fh             ; DBLSPACE.BIN - "GetDriveMapping"
                                        ; see if this is an unused DblSpace drive
                pop     si
                pop     ds
                pop     dx
                pop     cx
                cmp     dl, bl          ; if mapped to itself, it is vacant
                jnz     short magic_set_cdss_2 ; skip if used
                and     word ptr [si+43h], 0BFFFh ; reset the bit in flags (curdir_inuse bit)
                                        ; [si+curdir_list.cdir_flags],~curdir_inuse ; word
                                        ; (.. [si+1+curdir_list.cdir_flags],0BFh ; byte)

magic_set_cdss_2:                       ; CODE XREF: MagicSetCdss+30↑j
                add     si, 88          ; curdirLen
                inc     dl              ; next drive
                loop    magic_set_cdss_1

magic_set_exit:                         ; CODE XREF: MagicSetCdss+3↑j
                retn
MagicSetCdss    endp


; =============== S U B R O U T I N E =======================================


get_dblspace_version proc near          ; CODE XREF: MagicPostload↑p
                                        ; MagicSetCdss↑p ...
                mov     ax, 4A11h       ; multMagicdrv
                                        ; DBLSPACE.BIN - "GetVersion" - INSTALLATION CHECK
                                        ; (BX = 0)
                xor     bx, bx          ; MD_VERSION = 0
                int     2Fh             ; Return:
                                        ;  AX = 0000h (successful)
                                        ;  BX = 444Dh ("DM")
                                        ;  CL = first drive letter used by DBLSPACE (41h = A:)
                                        ;  CH = number of drive letters used by DBLSPACE
                                        ;  DX = internal DBLSPACE.BIN version number (bits 14-0)
                                        ;  bit 15 set if DBLSPACE.BIN has not yet been relocated
                                        ;  to final position in memory (i.e. DBLSPACE.SYS /MOVE)
                or      ax, ax          ; ax = 0 (successful, zf=1)
                retn
get_dblspace_version endp

; ---------------------------------------------------------------------------
                db 0
config_envlen   dw 0                    ; DATA XREF: SYSINIT:096B↑r
                                        ; SYSINIT:09DA↑r ...
                                        ; when config_wrkseg is being used as
                                        ; a scratch env, this is its length
config_wrkseg   dw 0                    ; DATA XREF: SYSINIT:0971↑r
                                        ; SYSINIT:09E0↑r ...
                                        ; config work area (above confbot)
                                        ; segment of work area
config_cmd      db 0                    ; DATA XREF: SYSINIT:0915↑w
                                        ; doconf+DD↓w ...
                                        ; current config cmd
                                        ; (with CONFIG_OPTION_QUERY bit intact)
config_multi    db 0                    ; DATA XREF: doconf+E2↓r
                                        ; copy_block+52↓r ...
                                        ; non-zero if multi-config config.sys
multdeviceflag  db 0                    ; DATA XREF: doconf+CF↓w
                                        ; doconf+453↓r ...
devmark_addr    dw 0                    ; DATA XREF: setdevmark+7↑w
                                        ; round+29↓r
                                        ; segment address for devmark.
setdevmarkflag  db 0                    ; DATA XREF: endfile+7C↑w
                                        ; endfile+DA↑w ...
                                        ; flag used for devmark
drivers_units   db 0                    ; DATA XREF: doconf+3B1↓w
                                        ; doconf+54C↓w ...
                                        ; total unitcount for driver
ems_stub_installed db 0                 ; (not used)
badparm_ptr     dd 0                    ; DATA XREF: doconf+30A↓w
                                        ; doconf+327↓w ...
                                        ; badparm_off equ badparm_ptr
                                        ; badparm_seg equ badparm_ptr+2
_$P_ORDINAL     dw 0                    ; DATA XREF: SysParse+8↓w
                                        ; SysParse+DC↓r ...
                                        ; Operand ordinal save area
_$P_RC          dw 0                    ; DATA XREF: SysParse+D↓w
                                        ; SysParse:_$P_Too_Many_Error↓w ...
                                        ; Return code from parser
_$P_SI_Save     dw 0                    ; DATA XREF: SysParse:_$P_Pack_End↓w
                                        ; SysParse+162↓r ...
                                        ; Pointer of command buffer
_$P_DX          dw 0                    ; DATA XREF: SysParse+1B↓w
                                        ; SysParse+167↓r ...
                                        ; Return result buffer address
_$P_Terminator  db 0                    ; DATA XREF: SysParse+16C↓r
                                        ; _$P_File_Format:_$P_FileF00↓w ...
                                        ; Terminator code (ASCII)
_$P_DBCSEV_OFF  dw 0                    ; DATA XREF: _$P_Chk_DBCS+28↓w
                                        ; _$P_Chk_DBCS:_$P_DBCS00↓r
                                        ; Offset of DBCS EV
_$P_DBCSEV_SEG  dw 0                    ; DATA XREF: _$P_Chk_DBCS+3↓r
                                        ; _$P_Chk_DBCS+2D↓w
                                        ; Segment of DBCS EV
_$P_Flags       db 0                    ; DATA XREF: SysParse↓w
                                        ; Parser internal flags
                                        ; %define _$P_Flags1 _$P_Flags
                                        ;         to reference 1st byte flags
                                        ; %define _$P_Flags2 _$P_Flags+1
                                        ;         to reference 2nd byte flags only
_$P_Flags2      db 0                    ; DATA XREF: SysParse+62↓r
                                        ; SysParse+7A↓r ...
_$P_SaveSI_Cmpx dw 0                    ; DATA XREF: SysParse:_$P_Start↓w
                                        ; _$P_Chk_SW_Control+18↓w ...
                                        ; save si for later use by complex
_$P_KEYorSW_Ptr dw 0                    ; DATA XREF: _$P_Chk_SW_Control+12↓r
                                        ; _$P_Chk_SW_Control+1E↓r ...
                                        ; points next to "=" or ":" code
_$P_Save_EOB    dw 0                    ; DATA XREF: SysParse+B6↓w
                                        ; save pointer to EOB
_$P_Found_SYNONYM dw 0                  ; DATA XREF: SysParse+14↓w
                                        ; _$P_Search_KEYorSW:_$P_KEYorSW_Found↓w ...
                                        ; es:@ points to found synonym
_$P_STRING_BUF  db 128 dup(0)           ; DATA XREF: SysParse+5E↓o
                                        ; SysParse+BE↓o ...
                                        ; Pick a operand from command line
_$P_Char_CAP_Ptr db 0FFh                ; DATA XREF: _$P_Do_CAPS_Char+12↓o
                                        ; info id
                dw 0                    ; offset of char case map table
                dw 0                    ; segment of char case map table
_$P_FileSp_Char db '[]|<>+=;"'          ; DATA XREF: SysParse+22↓w
                                        ; _$P_FileSp_Chk+2↓o ...
                                        ; delimitters of file spec
                                        ; _$P_FileSp_Len equ $-_$P_FileSp_Char
_$P_err_flag    db 0                    ; DATA XREF: _$P_Check_Match_Flags↓w
                                        ; _$P_Check_Match_Flags:_$P_Match_Exit↓r ...
                                        ; flag set if filespec parsing error
                                        ; was detected.

; =============== S U B R O U T I N E =======================================


SysParse        proc near               ; CODE XREF: sysinit_parse+13↓p

; FUNCTION CHUNK AT 1E12 SIZE 00000069 BYTES

                mov     word ptr cs:_$P_Flags, 0 ; Clear all internal flags
                cld                     ; confirm forward direction
                mov     cs:_$P_ORDINAL, cx ; save operand ordinal
                mov     cs:_$P_RC, 0    ; _$P_No_Error ; assume no error
                mov     cs:_$P_Found_SYNONYM, 0 ; initalize synonym pointer
                mov     cs:_$P_DX, 0    ; The table of special chars _$P_FileSp_Char
                                        ; should be initialized on every entry to SysParse
                mov     word ptr cs:_$P_FileSp_Char, 5D5Bh ; "[]|<>+=;\""
                mov     word ptr cs:_$P_FileSp_Char+2, 3C7Ch ; "|<>+=;\""
                mov     word ptr cs:_$P_FileSp_Char+4, 2B3Eh ; ">+=;\""
                mov     word ptr cs:_$P_FileSp_Char+6, 3B3Dh ; "=;\""
                call    _$P_Skip_Delim  ; Move si to 1st non white space
                jnb     short _$P_Start ; If EOL is not encountered, do parse
                mov     ax, 0FFFFh      ; _$P_RC_EOL  ; set exit code to -1
                push    bx
                mov     bx, es:[di]     ; [es:di+_$P_PARMS_Blk.PARMSX_Address]
                                        ; Get the PARMSX address to
                cmp     cl, es:[bx]     ; [es:bx+_$P_PARMSX_Blk.MinP]
                                        ; check ORDINAL to see if the minimum
                jnb     short _$P_Fin   ; positional found.
                mov     ax, 2           ; $P_Op_Missing ; If no, set exit code to missing operand

_$P_Fin:                                ; CODE XREF: SysParse+4D↑j
                pop     bx
                jmp     _$P_Single_Exit ; return to the caller
; ---------------------------------------------------------------------------

_$P_Start:                              ; CODE XREF: SysParse+41↑j
                mov     cs:_$P_SaveSI_Cmpx, si ; save ptr to command line for later use
                                        ; by complex quoted string or file spec.
                push    bx
                push    di
                push    bp
                lea     bx, _$P_STRING_BUF ; set buffer to copy from command string
                test    cs:_$P_Flags2, 20h ; _$P_Extra ; 3/9 extra delimiter encountered ?
                jnz     short _$P_Pack_End ; 3/9 if yes, no need to copy

_$P_Pack_Loop:                          ; CODE XREF: SysParse+A3↓j
                                        ; SysParse+AA↓j
                lodsb                   ; Pick a operand from buffer
                call    _$P_Chk_Switch  ; Check switch character
                jb      short _$P_Pack_End_BY_EOL ; if carry set found delimiter type slash,
                                        ; need backup si, else continue
                call    _$P_Chk_EOL     ; Check EOL character
                jz      short _$P_Pack_End_BY_EOL ; need backup si
                call    _$P_Chk_Delim   ; Check delimiter
                jnz     short _$P_PL01  ; If no, process next byte
                test    cs:_$P_Flags2, 20h ; _$P_Extra ; 3/9 If yes and white spec,
                jnz     short _$P_Pack_End_backup_si ; 3/9 then
                call    _$P_Skip_Delim  ; skip subsequent white space,too
                jmp     short _$P_Pack_End ; finish copy by placing NUL at end
; ---------------------------------------------------------------------------

_$P_Pack_End_backup_si:                 ; CODE XREF: SysParse+80↑j
                test    cs:_$P_Flags2, 41h ; _$P_SW+_$P_equ
                jz      short _$P_Pack_End
                dec     si
                jmp     short _$P_Pack_End
; ---------------------------------------------------------------------------

_$P_PL01:                               ; CODE XREF: SysParse+78↑j
                mov     cs:[bx], al     ; move byte to STRING_BUF
                cmp     al, 3Dh ; '='   ; _$P_Keyword ; if it is equal character,
                jnz     short _$P_PL00  ; then
                or      cs:_$P_Flags2, 1 ; _$P_equ ; remember it in flag

_$P_PL00:                               ; CODE XREF: SysParse+97↑j
                inc     bx              ; ready to see next byte
                call    _$P_Chk_DBCS    ; was it 1st byte of DBCS ?
                jnb     short _$P_Pack_Loop ; if no, process to next byte
                lodsb
                mov     cs:[bx], al     ; if yes, store 2nd byte of DBCS
                inc     bx              ; update pointer
                jmp     short _$P_Pack_Loop ; process to next byte
; ---------------------------------------------------------------------------

_$P_Pack_End_BY_EOL:                    ; CODE XREF: SysParse+6E↑j
                                        ; SysParse+73↑j
                dec     si              ; backup si pointer

_$P_Pack_End:                           ; CODE XREF: SysParse+68↑j
                                        ; SysParse+85↑j ...
                mov     cs:_$P_SI_Save, si ; save next pointer, SI
                mov     byte ptr cs:[bx], 0 ; _$P_NULL ; put NULL at the end
                mov     cs:_$P_Save_EOB, bx ; keep the address for later use of complex
                mov     bx, es:[di]     ; [es:di+_$P_PARMS_Blk.PARMSX_Address]
                                        ; get PARMSX address
                lea     si, _$P_STRING_BUF
                cmp     byte ptr cs:[si], 2Fh ; '/' ; the operand begins w/ switch char ?
                                        ; _$P_Switch
                jz      short _$P_SW_Manager ; if yes, process as switch
                cmp     byte ptr cs:[si], 22h ; '"' ; _$P_DQuote  ; is it a string?
                jz      short _$P_Positional_Manager ; if so, process as one!
                test    cs:_$P_Flags2, 1 ; $P_equ ; the operand includes equal
                jnz     short _$P_Key_Manager ; if yes, process as keyword

_$P_Positional_Manager:                 ; CODE XREF: SysParse+CC↑j
                mov     al, es:[bx+1]   ; else process as positional
                                        ; get maxp
                xor     ah, ah          ; ax = maxp
                cmp     cs:_$P_ORDINAL, ax ; too many positional ?
                jnb     short _$P_Too_Many_Error ; if yes, set exit code to too many
                mov     ax, cs:_$P_ORDINAL ; see what the current ordinal
                shl     ax, 1           ; ax = ax*2
                inc     bx
                inc     bx              ; add '2' to bx reg
                                        ; now bx points to 1st CONTROL
                add     bx, ax          ; now bx points to specified CONTROL address
                mov     bx, es:[bx]     ; now bx points to specified CONTROL itself
                call    _$P_Chk_Pos_Control ; Do process for positional
                jmp     short _$P_Return_to_Caller ; and return to the caller
; ---------------------------------------------------------------------------

_$P_Too_Many_Error:                     ; CODE XREF: SysParse+E1↑j
                mov     cs:_$P_RC, 1    ; set exit code
                jmp     short _$P_Return_to_Caller ; and return to the caller
SysParse        endp


; =============== S U B R O U T I N E =======================================


get_maxp        proc near               ; CODE XREF: SysParse:_$P_SW_Manager↓p
                                        ; SysParse:_$P_Key_Manager↓p
                mov     al, es:[bx+1]   ; [es:bx+_$P_PARMSX_Blk.MaxP] ; get maxp
                xor     ah, ah
                inc     ax
                shl     ax, 1
                add     bx, ax          ; now bx points to maxs
                retn
get_maxp        endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR SysParse

_$P_SW_Manager:                         ; CODE XREF: SysParse+C6↑j
                call    get_maxp
                mov     cl, es:[bx]
                xor     ch, ch          ; cx = maxs
                                        ; at least one switch ?
                jcxz    short _$P_SW_Not_Found ; no
                inc     bx              ; now bx points to 1st CONTROL address

_$P_SW_Mgr_Loop:                        ; CODE XREF: SysParse+121↓j
                push    bx
                mov     bx, es:[bx]     ; bx points to Switch CONTROL itself
                call    _$P_Chk_SW_Control
                pop     bx
                jnb     short _$P_Return_to_Caller ;
                                        ; if the CONTROL is for the switch, exit
                inc     bx
                inc     bx              ;    add '2' to bx reg
                                        ; else bx points to the next CONTROL
                loop    _$P_SW_Mgr_Loop ; and loop

_$P_SW_Not_Found:                       ; CODE XREF: SysParse+112↑j
                mov     cs:_$P_RC, 3    ; _$P_Not_In_SW
                                        ; here no CONTROL for the switch has
                jmp     short _$P_Return_to_Caller
; ---------------------------------------------------------------------------

_$P_Key_Manager:                        ; CODE XREF: SysParse+D4↑j
                call    get_maxp
                mov     al, es:[bx]
                xor     ah, ah          ; ax = maxs
                shl     ax, 1
                inc     ax              ; ax = ax*2+1
                add     bx, ax          ; now bx points to maxk
                mov     cl, es:[bx]     ; cx = maxk
                xor     ch, ch          ; at least one keyword ?
                jcxz    short _$P_Key_Not_Found ; no
                inc     bx              ; now bx points to 1st CONTROL

_$P_Key_Mgr_Loop:                       ; CODE XREF: SysParse+14D↓j
                push    bx
                mov     bx, es:[bx]     ; bx points to keyword CONTROL itself
                call    _$P_Chk_Key_Control ; do process for keyword
                pop     bx
                jnb     short _$P_Return_to_Caller ;
                                        ; if the CONTROL is for the keyword, exit
                inc     bx
                inc     bx              ;    add '2' to bx reg
                                        ; else bx points to the next CONTROL
                loop    _$P_Key_Mgr_Loop ; and loop

_$P_Key_Not_Found:                      ; CODE XREF: SysParse+13E↑j
                mov     cs:_$P_RC, 4    ; _$P_Not_In_Key
                                        ; here no CONTROL for the keyword has

_$P_Return_to_Caller:                   ; CODE XREF: SysParse+F3↑j
                                        ; SysParse+FC↑j ...
                pop     bp
                pop     di
                pop     bx
                mov     cx, cs:_$P_ORDINAL ; return next ordinal
                mov     ax, cs:_$P_RC   ; return exit code
                mov     si, cs:_$P_SI_Save ; return next operand pointer
                mov     dx, cs:_$P_DX   ; return result buffer address
                mov     bl, cs:_$P_Terminator ; return delimiter code found

_$P_Single_Exit:                        ; CODE XREF: SysParse+53↑j
                clc
                retn
; END OF FUNCTION CHUNK FOR SysParse

; =============== S U B R O U T I N E =======================================


_$P_Chk_Pos_Control proc near           ; CODE XREF: SysParse+F0↑p
                push    ax
                mov     ax, es:[bx]     ; [es:bx+_$P_Control_Blk.Match_Flag]
                test    ax, 2           ; $P_Repeat ; repeat allowed ?
                jnz     short _$P_CPC00 ; then do not increment ORDINAL
                inc     cs:_$P_ORDINAL  ; update the ordinal

_$P_CPC00:                              ; CODE XREF: _$P_Chk_Pos_Control+7↑j
                cmp     byte ptr cs:[si], 0 ; _$P_NULL ; no data ?
                jnz     short _$P_CPC01
                test    ax, 1           ; _$P_Optional ; yes, then is it optional ?
                jnz     short _$P_CPC02
                mov     cs:_$P_RC, 2    ; _$P_Op_Missing ; no, then error
                jmp     short _$P_CPC_Exit
; ---------------------------------------------------------------------------

_$P_CPC02:                              ; CODE XREF: _$P_Chk_Pos_Control+17↑j
                push    ax
                mov     ax, 0FF03h      ; (_$P_No_Tag<<8)|_$P_String
                                        ; if it is optional return NULL
                                        ; no item tag indication
                call    _$P_Fill_Result
                pop     ax
                jmp     short _$P_CPC_Exit
; ---------------------------------------------------------------------------

_$P_CPC01:                              ; CODE XREF: _$P_Chk_Pos_Control+12↑j
                call    _$P_Check_Match_Flags

_$P_CPC_Exit:                           ; CODE XREF: _$P_Chk_Pos_Control+20↑j
                                        ; _$P_Chk_Pos_Control+2A↑j
                pop     ax
                retn
_$P_Chk_Pos_Control endp


; =============== S U B R O U T I N E =======================================


_$P_Chk_Key_Control proc near           ; CODE XREF: SysParse+145↑p
                stc                     ; this logic works
                                        ; when the KeySW is reset.
                retn
_$P_Chk_Key_Control endp


; =============== S U B R O U T I N E =======================================


_$P_Search_KEYorSW proc near            ; CODE XREF: _$P_Chk_SW_Control+6↓p
                push    bp
                push    cx
                mov     cl, es:[bx+8]   ; [es:bx+_$P_Control_Blk.nid] ; Get synonym count
                xor     ch, ch          ; and set it to cx
                jcxz    short _$P_KEYorSW_Not_Found ; No synonyms specified ?
                                        ; then indicate not found by CY
                lea     bp, [bx+9]      ; [bx+_$P_Control_Blk.KEYorSW]

_$P_KEYorSW_Loop:                       ; CODE XREF: _$P_Search_KEYorSW+15↓j
                call    _$P_String_Comp ; compare string in buffer w/ the synonym
                jnb     short _$P_KEYorSW_Found ; If match, set it to synonym pointer
                call    _$P_MoveBP_NUL  ; else, bp points to the next string
                loop    _$P_KEYorSW_Loop ; loop nid times

_$P_KEYorSW_Not_Found:                  ; CODE XREF: _$P_Search_KEYorSW+8↑j
                stc                     ; indicate not found in synonym list
                jmp     short _$P_KEYorSW_Exit ; and exit
; ---------------------------------------------------------------------------

_$P_KEYorSW_Found:                      ; CODE XREF: _$P_Search_KEYorSW+10↑j
                mov     cs:_$P_Found_SYNONYM, bp ; set synonym pointer
                clc                     ; indicate found

_$P_KEYorSW_Exit:                       ; CODE XREF: _$P_Search_KEYorSW+18↑j
                pop     cx
                pop     bp
                retn
_$P_Search_KEYorSW endp


; =============== S U B R O U T I N E =======================================


_$P_MoveBP_NUL  proc near               ; CODE XREF: _$P_Search_KEYorSW+12↑p
                                        ; _$P_MoveBP_NUL+8↓j
                cmp     byte ptr es:[bp+0], 0 ; _$P_NULL
                                        ; Increment BP that points
                jz      short _$P_MBP_Exit ; to the synomym list
                inc     bp              ; until
                jmp     short _$P_MoveBP_NUL ; NULL encountered.
                                        ; _$P_MBP_Loop
; ---------------------------------------------------------------------------

_$P_MBP_Exit:                           ; CODE XREF: _$P_MoveBP_NUL+5↑j
                inc     bp              ; bp points to next to NULL
                retn
_$P_MoveBP_NUL  endp


; =============== S U B R O U T I N E =======================================


_$P_Chk_SW_Control proc near            ; CODE XREF: SysParse+119↑p
                or      cs:_$P_Flags2, 10h ; (Check if switch is supported)
                                        ; _$P_SW_Cmp
                                        ; Indicate switch for later string comparison
                call    _$P_Search_KEYorSW ; Search the switch in the CONTROL block
                jb      short _$P_Chk_SW_Err0 ; not found, then try next CONTROL
                and     cs:_$P_Flags2, 0EFh ; and byte [cs:_$P_Flags2],0FFh-_$P_SW_Cmp
                                        ; reset the indicator previously set /switch
                push    ax
                mov     ax, cs:_$P_KEYorSW_Ptr
                sub     ax, si          ; [si] = KEY or SW
                add     cs:_$P_SaveSI_Cmpx, ax ; update for complex list
                pop     ax
                mov     si, cs:_$P_KEYorSW_Ptr ; set si at the end or colon
                cmp     byte ptr cs:[si], 0 ; _$P_NULL ; any data after colon ?
                jnz     short _$P_CSW00 ; if yes, process match flags
                cmp     byte ptr cs:[si-1], ':' ; _$P_Colon
                                        ; if no, the switch terminated by colon ?
                jnz     short _$P_Chk_if_data_required ;
                                        ; if yes,
                mov     cs:_$P_RC, 9    ; _$P_Syntax ; return syntax error
                jmp     short _$P_Chk_SW_Exit
; ---------------------------------------------------------------------------

_$P_Chk_if_data_required:               ; CODE XREF: _$P_Chk_SW_Control+2E↑j
                cmp     word ptr es:[bx], 0 ; [es:bx+_$P_Control_Blk.Match_Flag]
                                        ; should have data?
                                        ; zero match flag means switch followed by nothing is OK
                jz      short _$P_Chk_SW_Exit ; match flags not zero so
                                        ; should have something if optional bit is not on
                test    word ptr es:[bx], 1 ; _$P_Optional ; see if no value is valid
                jnz     short _$P_Chk_SW_Exit ; if so, then leave, else yell
                mov     cs:_$P_RC, 2    ; _$P_Op_Missing
                                        ; return required operand missing
                jmp     short _$P_Chk_SW_Exit
; ---------------------------------------------------------------------------

_$P_CSW00:                              ; CODE XREF: _$P_Chk_SW_Control+27↑j
                call    _$P_Check_Match_Flags ; process match flag
                clc                     ; indicate match
                jmp     short _$P_Chk_SW_Single_Exit
; ---------------------------------------------------------------------------

_$P_Chk_SW_Err0:                        ; CODE XREF: _$P_Chk_SW_Control+9↑j
                stc                     ; not found in switch synonym list
                retn
; ---------------------------------------------------------------------------

_$P_Chk_SW_Exit:                        ; CODE XREF: _$P_Chk_SW_Control+37↑j
                                        ; _$P_Chk_SW_Control+3D↑j ...
                push    ax
                mov     ax, 0FF03h      ; (_$P_No_Tag<<8)|_$P_String
                call    _$P_Fill_Result ; set result buffer
                pop     ax
                clc

_$P_Chk_SW_Single_Exit:                 ; CODE XREF: _$P_Chk_SW_Control+53↑j
                retn
_$P_Chk_SW_Control endp


; =============== S U B R O U T I N E =======================================


_$P_Fill_Result proc near               ; CODE XREF: _$P_Chk_Pos_Control+26↑p
                                        ; _$P_Chk_SW_Control+5B↑p ...
                push    di
                mov     di, es:[bx+4]   ; [es:bx+_$P_Control_Blk.Result_Buf]
                                        ; di points to result buffer
                mov     cs:_$P_DX, di   ; set returned result address
                mov     es:[di], al     ; [es:di+_$P_Result_Blk.Type] ; store type
                mov     es:[di+1], ah   ; [es:di+_$P_Result_Blk.Item_Tag] ; store item tag
                push    ax
                mov     ax, cs:_$P_Found_SYNONYM
                mov     es:[di+2], ax   ; [es:di+_$P_Result_Blk.SYNONYM_Ptr]
                pop     ax

_$P_RLT04:                              ;
                cmp     al, 1           ; _$P_Number ; if number
                jnz     short _$P_RLT00 ;
                                        ; then store 32 bit

_$P_RLT02:                              ; CODE XREF: _$P_Fill_Result+35↓j
                                        ; _$P_Fill_Result+39↓j
                mov     es:[di+4], dx   ; [es:di+_$P_Result_Blk.Picked_Val]
                mov     es:[di+6], cx   ; [es:di+_$P_Result_Blk.Picked_Val+2]
                jmp     short _$P_RLT_Exit
; ---------------------------------------------------------------------------

_$P_RLT00:                              ; CODE XREF: _$P_Fill_Result+1D↑j
                cmp     al, 2           ; _$P_List_Idx ; if list index
                jnz     short _$P_RLT01 ;
                                        ; then store list index
                mov     es:[di+4], dx   ; [es:di+_$P_Result_Blk.Picked_Val]
                jmp     short _$P_RLT_Exit
; ---------------------------------------------------------------------------

_$P_RLT01:                              ; CODE XREF: _$P_Fill_Result+2B↑j
                cmp     al, 7           ; _$P_Date_F ; Date format ?
                jz      short _$P_RLT02
                cmp     al, 8           ; _$P_Time_F ; Time format ?
                jz      short _$P_RLT02
                cmp     al, 6           ; _$P_Drive ; drive format ?
                jnz     short _$P_RLT03
                mov     es:[di+4], dl   ; [es:di+_$P_Result_Blk.Picked_Val]
                                        ; store drive number
                jmp     short _$P_RLT_Exit
; ---------------------------------------------------------------------------

_$P_RLT03:                              ; CODE XREF: _$P_Fill_Result+3D↑j
                cmp     al, 4           ; _$P_Complex ; complex format ?
                jnz     short _$P_RLT05
                mov     ax, cs:_$P_SaveSI_Cmpx ;
                                        ; then get pointer in command buffer
                inc     ax              ; skip left Parentheses
                mov     es:[di+4], ax   ; [es:di+_$P_Result_Blk.Picked_Val]
                                        ; store offset
                mov     word ptr es:[di+6], ds ; [es:di+_$P_Result_Blk.Picked_Val+2]
                                        ; store segment
                jmp     short _$P_RLT_Exit
; ---------------------------------------------------------------------------

_$P_RLT05:                              ; CODE XREF: _$P_Fill_Result+47↑j
                mov     es:[di+4], si   ; AL = 3, 5, or 9
                                        ; [es:di+_$P_Result_Blk.Picked_Val]
                                        ; store offset of STRING_BUF
                mov     word ptr es:[di+6], cs ; [es:di+_$P_Result_Blk.Picked_Val+2]
                                        ; store segment of STRING_BUF
                push    ax
                test    byte ptr es:[bx+2], 1 ; [es:bx+_$P_Control_Blk.Function_Flag],
                                        ; _$P_CAP_File
                                        ; need CAPS by file table?
                jz      short _$P_RLT_CAP00
                mov     al, 4           ; _$P_DOSTBL_File ; use file upper case table
                jmp     short _$P_RLT_CAP02
; ---------------------------------------------------------------------------

_$P_RLT_CAP00:                          ; CODE XREF: _$P_Fill_Result+66↑j
                test    byte ptr es:[bx+2], 2 ; [es:bx+_$P_Control_Blk.Function_Flag],
                                        ; _$P_CAP_Char
                                        ; need CAPS by char table
                jz      short _$P_RLT_CAP01
                mov     al, 2           ; _$P_DOSTBL_Char
                                        ; use character upper case table

_$P_RLT_CAP02:                          ; CODE XREF: _$P_Fill_Result+6A↑j
                call    _$P_Do_CAPS_String ; process CAPS along the table

_$P_RLT_CAP01:                          ; CODE XREF: _$P_Fill_Result+71↑j
                pop     ax
                test    byte ptr es:[bx+2], 10h ; [es:bx+_$P_Control_Blk.Function_Flag],
                                        ; _$P_Rm_Colon
                                        ; removing colon at end ?
                jz      short _$P_RLT_Exit
                call    _$P_Remove_Colon ; then process it.

_$P_RLT_Exit:                           ; CODE XREF: _$P_Fill_Result+27↑j
                                        ; _$P_Fill_Result+31↑j ...
                pop     di
                retn
_$P_Fill_Result endp


; =============== S U B R O U T I N E =======================================


_$P_Check_Match_Flags proc near         ; CODE XREF: _$P_Chk_Pos_Control:_$P_CPC01↑p
                                        ; _$P_Chk_SW_Control:_$P_CSW00↑p
                mov     cs:_$P_err_flag, 0 ; _$P_NULL ; clear filespec error flag.
                push    ax
                mov     ax, es:[bx]     ; [es:bx+_$P_Control_Blk.Match_Flag]
                                        ; load match flag (16bit) to ax
                or      ax, ax          ; test ax for zero
                jnz     short _$P_Mat
                push    ax
                push    bx
                push    dx
                push    di
                mov     cs:_$P_RC, 9    ; _$P_Syntax
                mov     ax, 0FF03h
                call    _$P_Fill_Result
                pop     di
                pop     dx
                pop     bx
                pop     ax
                jmp     short _$P_Bridge
; ---------------------------------------------------------------------------

_$P_Mat:                                ; CODE XREF: _$P_Check_Match_Flags+C↑j
                jmp     short _$P_Match03
; ---------------------------------------------------------------------------

_$P_Bridge:                             ; CODE XREF: _$P_Check_Match_Flags+23↑j
                jmp     short _$P_Match_Exit
; ---------------------------------------------------------------------------
                nop                     ; 90h

_$P_Match03:                            ; CODE XREF: _$P_Check_Match_Flags:_$P_Mat↑j
                test    ax, 8000h       ; _$P_Num_Val ; Numeric value
                jz      short _$P_Match04
                mov     cs:_$P_RC, 0    ; _$P_No_Error ; assume no error
                call    _$P_Value       ; do process
                cmp     cs:_$P_RC, 9    ; _$P_Syntax ; if error, examine the next type
                jnz     short _$P_Match_Exit

_$P_Match04:                            ; CODE XREF: _$P_Check_Match_Flags+2D↑j
                test    ax, 4000h       ; _$P_SNum_Val ; Signed numeric value
                jz      short _$P_Match05
                mov     cs:_$P_RC, 0    ; _$P_No_Error ; assume no error
                call    _$P_SValue      ; do process
                cmp     cs:_$P_RC, 9    ; _$P_Syntax ; if error, examine the next type
                jnz     short _$P_Match_Exit

_$P_Match05:                            ; CODE XREF: _$P_Check_Match_Flags+44↑j
                test    ax, 100h        ; _$P_Drv_Only ; Drive only
                jz      short _$P_Match06
                mov     cs:_$P_RC, 0    ; _$P_No_Error ; assume no error
                call    _$P_File_Format ; 1st, call file format
                call    _$P_Drive_Format ; check drive format, next
                cmp     cs:_$P_RC, 9    ; _$P_Syntax ; if error, examine the next type
                jnz     short _$P_Match_Exit

_$P_Match06:                            ; CODE XREF: _$P_Check_Match_Flags+5B↑j
                test    ax, 200h        ; _$P_File_Spc ; File spec
                jz      short _$P_Match07
                mov     cs:_$P_RC, 0    ; _$P_No_Error ; assume no error
                call    _$P_File_Format ; do process
                cmp     cs:_$P_RC, 9    ; _$P_Syntax ; if error, examine the next type
                jnz     short _$P_Match_Exit

_$P_Match07:                            ; CODE XREF: _$P_Check_Match_Flags+75↑j
                test    ax, 2000h       ; _$P_Simple_S ; Simple string
                jz      short _$P_Match_Exit
                mov     cs:_$P_RC, 0    ; _$P_No_Error ; assume no error
                call    _$P_Simple_String ; do process

_$P_Match_Exit:                         ; CODE XREF: _$P_Check_Match_Flags:_$P_Bridge↑j
                                        ; _$P_Check_Match_Flags+3F↑j ...
                cmp     cs:_$P_err_flag, 1 ; _$P_error_filespec ; bad filespec ?
                jnz     short _$P_Match2_Exit ; no, continue
                cmp     cs:_$P_RC, 0    ; _$P_No_Error ; check for other errors ?
                jnz     short _$P_Match2_Exit ; no, continue
                mov     cs:_$P_RC, 9    ; _$P_Syntax ; set error flag

_$P_Match2_Exit:                        ; CODE XREF: _$P_Check_Match_Flags+9E↑j
                                        ; _$P_Check_Match_Flags+A6↑j
                pop     ax
                retn
_$P_Check_Match_Flags endp


; =============== S U B R O U T I N E =======================================


_$P_Remove_Colon proc near              ; CODE XREF: _$P_Fill_Result+80↑p
                push    ax
                push    si

_$P_RCOL_Loop:                          ; CODE XREF: _$P_Remove_Colon+21↓j
                mov     al, cs:[si]     ; get character
                or      al, al          ; end of string ?
                jz      short _$P_RCOL_Exit ; if yes, just exit
                cmp     al, ':'         ; _$P_Colon ; is it colon ?
                jnz     short _$P_RCOL00
                cmp     byte ptr cs:[si+1], 0 ; _$P_NULL
                                        ; if so, next is NULL ?
                jnz     short _$P_RCOL00 ; no, then next char
                mov     byte ptr cs:[si], 0 ; _$P_NULL ; yes, remove colon
                jmp     short _$P_RCOL_Exit ; and exit.
; ---------------------------------------------------------------------------

_$P_RCOL00:                             ; CODE XREF: _$P_Remove_Colon+B↑j
                                        ; _$P_Remove_Colon+12↑j
                call    _$P_Chk_DBCS    ; if not colon, then check if
                                        ; DBCS leading byte.
                jnb     short _$P_RCOL01
                inc     si              ; if yes, skip trailing byte

_$P_RCOL01:                             ; CODE XREF: _$P_Remove_Colon+1D↑j
                inc     si              ; si points to next byte
                jmp     short _$P_RCOL_Loop ; loop until NULL encountered
; ---------------------------------------------------------------------------

_$P_RCOL_Exit:                          ; CODE XREF: _$P_Remove_Colon+7↑j
                                        ; _$P_Remove_Colon+18↑j
                pop     si
                pop     ax
                retn
_$P_Remove_Colon endp


; =============== S U B R O U T I N E =======================================


_$P_Do_CAPS_String proc near            ; CODE XREF: _$P_Fill_Result:_$P_RLT_CAP02↑p
                push    si
                push    dx
                mov     dl, al          ; save info id

_$P_DCS_Loop:                           ; CODE XREF: _$P_Do_CAPS_String+1A↓j
                mov     al, cs:[si]     ; load charater and
                call    _$P_Chk_DBCS    ; check if DBCS leading byte
                jb      short _$P_DCS00 ; if yes, do not need CAPS
                or      al, al          ; end of string ?
                jz      short _$P_DCS_Exit ; then exit.
                call    _$P_Do_CAPS_Char ; Here a SBCS char need to be CAPS
                mov     cs:[si], al     ; stored upper case char to buffer
                jmp     short _$P_DCS01 ; process next
; ---------------------------------------------------------------------------

_$P_DCS00:                              ; CODE XREF: _$P_Do_CAPS_String+A↑j
                inc     si              ; skip DBCS leading and trailing byte

_$P_DCS01:                              ; CODE XREF: _$P_Do_CAPS_String+16↑j
                inc     si              ; si points to next byte
                jmp     short _$P_DCS_Loop ; loop until NULL encountered
; ---------------------------------------------------------------------------

_$P_DCS_Exit:                           ; CODE XREF: _$P_Do_CAPS_String+E↑j
                pop     dx
                pop     si
                retn
_$P_Do_CAPS_String endp


; =============== S U B R O U T I N E =======================================


_$P_Do_CAPS_Char proc near              ; CODE XREF: _$P_Do_CAPS_String+10↑p
                                        ; _$P_String_Comp+E↓p
                cmp     al, 80h         ; _$P_ASCII80 ; need upper case table ?
                jnb     short _$P_DCC_Go ; no
                cmp     al, 'a'         ; check if  "a" <= AL <= "z"
                jb      short _$P_CAPS_Ret
                cmp     al, 'z'
                ja      short _$P_CAPS_Ret
                and     al, 0DFh        ; _$P_Make_Upper ; make CAPS
                retn
; ---------------------------------------------------------------------------

_$P_DCC_Go:                             ; CODE XREF: _$P_Do_CAPS_Char+2↑j
                push    bx
                push    es
                push    di
                lea     di, _$P_Char_CAP_Ptr ; or use char CAPS table ?
                cmp     cs:[di], dl     ; already got table address ?
                jz      short _$P_DCC01 ; no
                push    ax
                push    cx
                push    dx
                push    cs
                pop     es
                assume es:SYSINIT
                xchg    ax, dx
                mov     ah, 65h         ; _$P_DOS_Get_TBL
                mov     bx, 0FFFFh      ; _$P_DOSTBL_Def = -1
                mov     cx, 5           ; _$P_DOSTBL_BL
                mov     dx, bx          ; _$P_DOSTBL_Def
                int     21h             ; DOS - 4.x internal
                                        ; COUNTRY-DEPENDENT FILENAME CAPITALIZATION
                                        ; AL = function -
                                        ;
                                        ; DI already set to point to buffer
                pop     dx
                pop     cx
                pop     ax

_$P_DCC01:                              ; CODE XREF: _$P_Do_CAPS_Char+19↑j
                les     bx, cs:[di+1]   ; bx = [cs:di+_$P_DOS_TBL.Off] ; [cs:di+1]
                                        ; es = [cs:di+_$P_DOS_TBL.Seg] ; [cs:di+3]
                assume es:nothing
                inc     bx
                inc     bx              ; add 2 to bx reg
                sub     al, 80h         ; _$P_ASCII80 ; make char to index
                xlat    byte ptr es:[bx] ; perform case map
                pop     di
                pop     es
                pop     bx

_$P_CAPS_Ret:                           ; CODE XREF: _$P_Do_CAPS_Char+6↑j
                                        ; _$P_Do_CAPS_Char+A↑j
                retn
_$P_Do_CAPS_Char endp


; =============== S U B R O U T I N E =======================================


_$P_SValue      proc near               ; CODE XREF: _$P_Check_Match_Flags+4D↑p
                push    ax
                or      cs:_$P_Flags2, 80h ; _$P_Signed ; indicate a signed numeric
                and     cs:_$P_Flags2, 0FDh ; 0FFh-_$P_Neg ; assume positive value
                                        ; and byte [cs:$_Flags2],~_$P_Neg ; ~2
                mov     al, cs:[si]     ; get sign
                cmp     al, '+'         ; _$P_Plus
                jz      short _$P_SVal00
                cmp     al, '-'         ; _$P_Minus
                jnz     short _$P_Sval01
                or      cs:_$P_Flags2, 2 ; _$P_Neg
                                        ; set this is negative value

_$P_SVal00:                             ; CODE XREF: _$P_SValue+12↑j
                inc     si              ; skip sign char

_$P_Sval01:                             ; CODE XREF: _$P_SValue+16↑j
                call    _$P_Value       ; and process value
                pop     ax
                retn
_$P_SValue      endp


; =============== S U B R O U T I N E =======================================


_$P_Value       proc near               ; CODE XREF: _$P_Check_Match_Flags+36↑p
                                        ; _$P_SValue:_$P_Sval01↑p
                push    ax
                push    cx
                push    dx
                push    si
                xor     cx, cx          ; cx = higher 16 bits
                xor     dx, dx          ; dx = lower 16 bits
                push    bx

_$P_Value_Loop:                         ; CODE XREF: _$P_Value+36↓j
                mov     al, cs:[si]     ; get character
                or      al, al          ; end of line ?
                jz      short _$P_Value00
                call    _$P_0099        ; make asc(0..9) to bin(0..9)
                jb      short _$P_Value_Err0
                xor     ah, ah
                mov     bp, ax          ; save binary number
                call    _$P_Value_2x_OVF ; multiply cx:dx by 2 and then check overflow
                mov     bx, dx          ; ax:bx = 2*(cx:dx)
                mov     ax, cx
                call    _$P_Value_2x_OVF ; multiply cx:dx by 2 and then check overflow
                call    _$P_Value_2x_OVF ; multiply cx:dx by 2 and then check overflow
                add     dx, bx          ; 8*(cx:dx)+2*(cx:dx) = 10*(cx:dx)
                adc     cx, ax
                call    _$P_Value_Chk_Add_OVF
                add     dx, bp          ; Add the current one degree decimal
                                        ; if carry, add 1 to high 16bit
                adc     cx, 0
                call    _$P_Value_Chk_Add_OVF ; Overflow occurred ?
                                        ; then error, exit (without return here)
                inc     si              ; update pointer
                jmp     short _$P_Value_Loop
; ---------------------------------------------------------------------------

_$P_Value_2x_OVF:                       ; CODE XREF: _$P_Value+19↑p
                                        ; _$P_Value+20↑p ...
                shl     dx, 1           ; to have 2*x
                rcl     cx, 1           ; shift left w/ carry

_$P_Value_Chk_Add_OVF:                  ; CODE XREF: _$P_Value+2A↑p
                                        ; _$P_Value+32↑p
                call    _$P_Check_OVF   ; check overflow (for the last shift or add)
                jb      short _$P_Value_OVF
                retn
; ---------------------------------------------------------------------------

_$P_Value_OVF:                          ; CODE XREF: _$P_Value+3F↑j
                inc     sp              ; skip "call" return address to the caller
                inc     sp

_$P_Value_Err0:                         ; CODE XREF: _$P_Value+13↑j
                pop     bx
                jmp     _$P_Value_Err   ; bridge
; ---------------------------------------------------------------------------

_$P_Value00:                            ; CODE XREF: _$P_Value+E↑j
                pop     bx              ; restore control pointer
                                        ; here cx,dx = 32bit value
                test    cs:_$P_Flags2, 2 ; _$P_Neg ; was it negative ?
                jz      short _$P_Value01
                not     cx              ; | Make 2's complement
                not     dx              ; |
                add     dx, 1           ; |
                adc     cx, 0           ; |

_$P_Value01:                            ; CODE XREF: _$P_Value+4F↑j
                mov     si, es:[bx+6]   ; [es:bx+_$P_Control_Blk.Value_List]
                                        ; si points to value list
                mov     al, es:[si]     ; get nval
                cmp     al, 0           ; _$P_nval_None ; no value list ?
                jnz     short _$P_Value02
                mov     ax, 0FF01h      ; (_$P_No_Tag<<8)|_$P_Number
                                        ; No ITEM_TAG set
                jmp     short _$P_Value_Exit
; ---------------------------------------------------------------------------
                nop

_$P_Value02:                            ; CODE XREF: _$P_Value+64↑j
                inc     si
                mov     al, es:[si]     ; al = number of range
                cmp     al, 0           ; _$P_No_nrng
                jz      short _$P_Value_Err ; _$P_Value03
                inc     si              ; si points to 1st item_tag

_$P_Val02_Loop:                         ; CODE XREF: _$P_Value+BE↓j
                test    cs:_$P_Flags2, 80h ; _$P_Signed
                jnz     short _$P_Val02_Sign
                cmp     cx, es:[si+3]   ; [es:si+_$P_Val_List.Val_XH]
                                        ; comp cx with XH
                jb      short _$P_Val02_Next
                ja      short _$P_Val_In
                cmp     dx, es:[si+1]   ; [es:si+_$P_Val_List.Val_XL]
                                        ; comp dx with XL
                jb      short _$P_Val02_Next

_$P_Val_In:                             ; CODE XREF: _$P_Value+83↑j
                cmp     cx, es:[si+7]   ; [es:si+_$P_Val_List.Val_YH]
                                        ; comp cx with YH
                ja      short _$P_Val02_Next
                jb      short _$P_Val_Found
                cmp     dx, es:[si+5]   ; [es:si+_$P_Val_List.Val_YL]
                                        ; comp dx with YL
                ja      short _$P_Val02_Next
                jmp     short _$P_Val_Found
; ---------------------------------------------------------------------------

_$P_Val02_Sign:                         ; CODE XREF: _$P_Value+7B↑j
                cmp     cx, es:[si+3]   ; [es:si+_$P_Val_List.Val_XH]
                                        ; comp cx with XH
                jl      short _$P_Val02_Next
                jg      short _$P_SVal_In
                cmp     dx, es:[si+1]   ; [es:si+_$P_Val_List.Val_XL]
                                        ; comp dx with XL
                jl      short _$P_Val02_Next

_$P_SVal_In:                            ; CODE XREF: _$P_Value+A1↑j
                cmp     cx, es:[si+7]   ; [es:si+_$P_Val_List.Val_YH]
                                        ; comp cx with YH
                jg      short _$P_Val02_Next
                jl      short _$P_Val_Found
                cmp     dx, es:[si+5]   ; [es:si+_$P_Val_List.Val_YL]
                                        ; comp dx with YL
                jg      short _$P_Val02_Next
                jmp     short _$P_Val_Found
; ---------------------------------------------------------------------------

_$P_Val02_Next:                         ; CODE XREF: _$P_Value+81↑j
                                        ; _$P_Value+89↑j ...
                add     si, 9           ; _$P_Len_Range
                dec     al              ; loop nrng times in AL
                jnz     short _$P_Val02_Loop
                mov     cs:_$P_RC, 6    ; _$P_Out_Of_Range
                mov     ax, 0FF01h      ; (_$P_No_Tag<<8)|_$P_Number
                jmp     short _$P_Value_Exit
; ---------------------------------------------------------------------------

_$P_Val_Found:                          ; CODE XREF: _$P_Value+91↑j
                                        ; _$P_Value+99↑j ...
                mov     al, 1           ; _$P_Number
                mov     ah, es:[si]     ; found ITEM_TAG set
                jmp     short _$P_Value_Exit
; ---------------------------------------------------------------------------

_$P_Value_Err:                          ; CODE XREF: _$P_Value+45↑j
                                        ; _$P_Value+72↑j
                mov     cs:_$P_RC, 9    ; _$P_Syntax
                mov     ax, 0FF03h      ; (_$P_No_Tag<<8)|_$P_String
                                        ; No ITEM_TAG set

_$P_Value_Exit:                         ; CODE XREF: _$P_Value+69↑j
                                        ; _$P_Value+CA↑j ...
                call    _$P_Fill_Result
                pop     si
                pop     dx
                pop     cx
                pop     ax
                retn
_$P_Value       endp


; =============== S U B R O U T I N E =======================================


_$P_Check_OVF   proc near               ; CODE XREF: _$P_Value:_$P_Value_Chk_Add_OVF↑p
                pushf
                test    cs:_$P_Flags2, 2 ; _$P_Neg ; is it negative value ?
                jnz     short _$P_COVF
                popf                    ; if no, check overflow by the CY bit
                retn
; ---------------------------------------------------------------------------

_$P_COVF:                               ; CODE XREF: _$P_Check_OVF+7↑j
                popf                    ; else, check overflow by the OF
                jo      short _$P_COVF00
                clc                     ; indicate it with CY bit
                                        ; CY=0 means no overflow
                retn
; ---------------------------------------------------------------------------

_$P_COVF00:                             ; CODE XREF: _$P_Check_OVF+C↑j
                stc                     ; and CY=1 means overflow
                retn
_$P_Check_OVF   endp


; =============== S U B R O U T I N E =======================================


_$P_0099        proc near               ; CODE XREF: _$P_Value+10↑p
                cmp     al, '0'         ; must be 0 =< al =< 9
                jb      short _$P_0099Err
                cmp     al, '9'
                ja      short _$P_0099Err
                sub     al, '0'         ; sub al,30h ; make char -> bin
                clc                     ; indicate no error
                                        ; (clc is not required here, cf=0)
                retn
; ---------------------------------------------------------------------------

_$P_0099Err:                            ; CODE XREF: _$P_0099+2↑j
                                        ; _$P_0099+6↑j
                stc                     ; indicate error (cf=1)
                retn
_$P_0099        endp


; =============== S U B R O U T I N E =======================================


_$P_Simple_String proc near             ; CODE XREF: _$P_Check_Match_Flags+95↑p
                push    ax
                push    bx
                push    dx
                push    di
                mov     di, es:[bx+6]   ; [es:bx+_$P_Control_Blk.Value_List]
                                        ; di points to value list
                mov     al, es:[di]     ; get nval
                or      al, al          ; no value list ?
                jnz     short _$P_Sim00
                mov     ah, 0FFh        ; _$P_No_Tag ; then, No ITEM_TAG set
                jmp     short _$P_Sim_Exit ; and set result buffer
; ---------------------------------------------------------------------------

_$P_Sim00:                              ; CODE XREF: _$P_Simple_String+D↑j
                cmp     al, 3           ; Check if keyword or value list id #3 is supported
                                        ; _$P_nval_String ; String choice list provided ?
                jnz     short _$P_Sim01 ; if no, syntax error
                inc     di
                mov     al, es:[di]     ; al = nrng
                mov     ah, 9           ; _$P_Len_Range
                mul     ah              ; Skip nrng field
                inc     ax              ; ax = (nrng*9)+1
                add     di, ax          ; di points to nnval
                mov     al, es:[di]     ; get nnval
                mov     ah, 5           ; _$P_Len_Value
                mul     ah              ; skip nnval field
                inc     ax              ; ax = (nnval*5)+1
                add     di, ax          ; di points to nstrval
                mov     al, es:[di]     ; get nstrval c
                inc     di
                inc     di              ; add '2' to di reg
                                        ; di points to 1st string in list

_$P_Sim_Loop:                           ; CODE XREF: _$P_Simple_String+3E↓j
                mov     bp, es:[di]     ; get string pointer
                call    _$P_String_Comp ; compare it with operand
                jnb     short _$P_Sim_Found ; found on list
                add     di, 3           ; _$P_Len_String ; if no, point to next choice
                dec     al              ; loop nstval times in AL
                jnz     short _$P_Sim_Loop
                mov     cs:_$P_RC, 8    ; / Not found ; _$P_Not_In_Str
                mov     ah, 0FFh        ; _$P_No_Tag  ; No ITEM_TAG set
                jmp     short _$P_Sim_Exit
; ---------------------------------------------------------------------------

_$P_Sim_Found:                          ; CODE XREF: _$P_Simple_String+37↑j
                mov     ah, es:[di-1]   ; set item_tag
                mov     al, 2           ; _$P_List_Idx
                mov     dx, es:[di]     ; get address of STRING
                jmp     short _$P_Sim_Exit0
; ---------------------------------------------------------------------------

_$P_Sim01:                              ; CODE XREF: _$P_Simple_String+15↑j
                mov     cs:_$P_RC, 9    ; _$P_Syntax
                mov     ah, 0FFh        ; _$P_No_Tag

_$P_Sim_Exit:                           ; CODE XREF: _$P_Simple_String+11↑j
                                        ; _$P_Simple_String+49↑j
                mov     al, 3           ; _$P_String ; Set type

_$P_Sim_Exit0:                          ; CODE XREF: _$P_Simple_String+54↑j
                call    _$P_Fill_Result
                pop     di
                pop     dx
                pop     bx
                pop     ax
                retn
_$P_Simple_String endp


; =============== S U B R O U T I N E =======================================


_$P_String_Comp proc near               ; CODE XREF: _$P_Search_KEYorSW:_$P_KEYorSW_Loop↑p
                                        ; _$P_Simple_String+34↑p
                push    ax
                push    bp
                push    dx
                push    si
                mov     dl, 2           ; _$P_DOSTBL_Char ; use character case map table

_$P_SCOM_Loop:                          ; CODE XREF: _$P_String_Comp:_$P_SCOM01↓j
                mov     al, cs:[si]     ; get command character
                call    _$P_Chk_DBCS    ; DBCS ?
                jb      short _$P_SCOM00 ; yes
                call    _$P_Do_CAPS_Char ; else, upper case map before comparison
                test    cs:_$P_Flags2, 8 ; Check if keyword or switch is supported
                                        ; _$P_Key_Cmp ; keyword search ?
                jz      short _$P_SCOM04
                cmp     al, '='         ; _$P_Keyword  ; "=" is delimiter
                jnz     short _$P_SCOM03 ; IF "=" on command line AND
                                        ; (bp+1=> char after the "=" in synonym list)
                cmp     byte ptr es:[bp+1], 0 ; _$P_NULL ; at end of keyword string
                                        ;                  in the control block THEN
                jnz     short _$P_SCOM_Differ
                jmp     short _$P_SCOM05 ; keyword found in synonym list
; ---------------------------------------------------------------------------

_$P_SCOM04:                             ; CODE XREF: _$P_String_Comp+17↑j
                test    cs:_$P_Flags2, 10h ; _$P_SW_Cmp ; switch search ?
                jz      short _$P_SCOM03
                cmp     al, ':'         ; _$P_Colon ; ":" is delimiter,
                                        ;            at end of switch on command line
                jnz     short _$P_SCOM03
                cmp     byte ptr es:[bp+0], 0 ; _$P_NULL
                                        ; IF at end of switch on command AND
                jnz     short _$P_SCOM_Differ ;
                                        ; at end of switch string
                                        ; in the control block THEN

_$P_SCOM05:                             ; CODE XREF: _$P_String_Comp+24↑j
                inc     si              ; found a match
                                        ; si points to just after "=" or ":"
                jmp     short _$P_SCOM_Same ; exit
; ---------------------------------------------------------------------------

_$P_SCOM03:                             ; CODE XREF: _$P_String_Comp+1B↑j
                                        ; _$P_String_Comp+2C↑j ...
                cmp     al, es:[bp+0]   ; compare operand w/ a synonym
                jnz     short _$P_SCOM_Differ0 ; if different,
                                        ; check ignore colon option
                or      al, al          ; end of line ?
                jz      short _$P_SCOM_Same ; if so, exit
                inc     si              ; update operand pointer
                inc     bp              ; and synonym pointer
                jmp     short _$P_SCOM01 ; loop until NULL or "=" or ":"
                                        ;  found in case
; ---------------------------------------------------------------------------

_$P_SCOM00:                             ; CODE XREF: _$P_String_Comp+C↑j
                cmp     al, es:[bp+0]   ; Here al is DBCS leading byte
                                        ; compare leading byte
                jnz     short _$P_SCOM_Differ ; if not match, say different
                inc     si              ; else, load next byte
                mov     al, cs:[si]
                inc     bp
                cmp     al, es:[bp+0]   ; and compare 2nd byte
                jnz     short _$P_SCOM_Differ ; if not match, say different, too
                inc     si              ; else update operand pointer
                inc     bp              ; and synonym pointer

_$P_SCOM01:                             ; CODE XREF: _$P_String_Comp+48↑j
                jmp     short _$P_SCOM_Loop ; loop until NULL or "="
                                        ; or "/" found in case
; ---------------------------------------------------------------------------

_$P_SCOM_Differ0:                       ; CODE XREF: _$P_String_Comp+40↑j
                test    cs:_$P_Flags2, 40h ; _$P_SW
                jz      short _$P_not_applicable
                test    word ptr es:[bx+2], 20h ; [es:bx+_$P_Control_Blk.Function_Flag],
                                        ; _$P_colon_is_not_necessary
                jz      short _$P_not_applicable
                cmp     byte ptr es:[bp+0], 0 ; _$P_NULL
                jz      short _$P_SCOM_Same

_$P_not_applicable:                     ; CODE XREF: _$P_String_Comp+65↑j
                                        ; _$P_String_Comp+6D↑j
                test    word ptr es:[bx], 10h ; [es:bx+_$P_Control_Blk.Match_Flag],
                                        ; _$P_Ig_Colon
                                        ; ignore colon option specified ?
                jz      short _$P_SCOM_Differ
                cmp     al, ':'         ; _$P_Colon ; End up with ":" and subseqently
                jnz     short _$P_SCOM02
                cmp     byte ptr es:[bp+0], 0 ; _$P_NULL ; null ?
                jnz     short _$P_SCOM_Differ ; if no, say different
                jmp     short _$P_SCOM_Same ; else, say same
; ---------------------------------------------------------------------------

_$P_SCOM02:                             ; CODE XREF: _$P_String_Comp+7F↑j
                cmp     al, 0           ; _$P_NULL ; end up NULL and :
                jnz     short _$P_SCOM_Differ
                cmp     byte ptr es:[bp+0], ':' ; _$P_Colon ; if no, say different
                jz      short _$P_SCOM_Same ; else, say same

_$P_SCOM_Differ:                        ; CODE XREF: _$P_String_Comp+22↑j
                                        ; _$P_String_Comp+37↑j ...
                stc                     ; indicate not found
                jmp     short _$P_SCOM_Exit
; ---------------------------------------------------------------------------

_$P_SCOM_Same:                          ; CODE XREF: _$P_String_Comp+3A↑j
                                        ; _$P_String_Comp+44↑j ...
                mov     cs:_$P_KEYorSW_Ptr, si ; for later use by keyword or switch
                clc                     ; indicate found
                                        ; (cf is already 0 here.. clc is not needed)

_$P_SCOM_Exit:                          ; CODE XREF: _$P_String_Comp+96↑j
                pop     si
                pop     dx
                pop     bp
                pop     ax
                retn
_$P_String_Comp endp


; =============== S U B R O U T I N E =======================================


_$P_File_Format proc near               ; CODE XREF: _$P_Check_Match_Flags+64↑p
                                        ; _$P_Check_Match_Flags+7E↑p
                push    ax
                push    di
                push    si
                mov     di, cs:_$P_SaveSI_Cmpx ; get user buffer address

_$P_FileF_Loop0:                        ; / skip special characters
                mov     al, cs:[si]     ; load character
                or      al, al          ; end of line ?
                jz      short _$P_FileF_Err ; if yes, error exit
                call    _$P_FileSp_Chk  ; else, check if file special character
                jnz     short _$P_FileF03
                mov     cs:_$P_err_flag, 1 ; $P_error_filespec
                                        ; set error flag - bad char.
                pop     si
                mov     byte ptr cs:[si], 0 ; _$P_NULL
                pop     di
                jmp     short _$P_FileF02
; ---------------------------------------------------------------------------

_$P_FileF_Err:                          ; CODE XREF: _$P_File_Format+D↑j
                pop     si
                mov     byte ptr cs:[si], 0 ; _$P_NULL
                pop     di
                test    word ptr es:[bx], 1 ; [es:bx+_$P_Control_Blk.Match_Flag],
                                        ; _$P_Optional
                jnz     short _$P_FileF02
                mov     cs:_$P_RC, 2    ; _$P_Op_Missing
                jmp     short _$P_FileF02
; ---------------------------------------------------------------------------

_$P_FileF03:                            ; CODE XREF: _$P_File_Format+12↑j
                pop     ax              ; discard si on top of stack
                push    si              ; save new si

_$P_FileF_Loop1:                        ; CODE XREF: _$P_File_Format+4F↓j
                mov     al, cs:[si]     ; load character (not special char)
                or      al, al          ; end of line ?
                jz      short _$P_FileF_RLT
                call    _$P_FileSp_Chk  ; File special character ?
                jz      short _$P_FileF00
                call    _$P_Chk_DBCS    ; no, then DBCS ?
                jnb     short _$P_FileF01
                inc     di              ; if yes, skip next byte
                inc     si

_$P_FileF01:                            ; CODE XREF: _$P_File_Format+49↑j
                inc     di
                inc     si
                jmp     short _$P_FileF_Loop1
; ---------------------------------------------------------------------------

_$P_FileF00:                            ; CODE XREF: _$P_File_Format+44↑j
                mov     cs:_$P_Terminator, al
                mov     byte ptr cs:[si], 0 ; _$P_NULL ; update end of string
                inc     di
                mov     cs:_$P_SI_Save, di ; update next pointer in command line

_$P_FileF_RLT:                          ; CODE XREF: _$P_File_Format+3F↑j
                pop     si
                pop     di

_$P_FileF02:                            ; CODE XREF: _$P_File_Format+20↑j
                                        ; _$P_File_Format+2D↑j ...
                pop     ax
                test    ax, 200h        ; _$P_File_Spc
                jz      short _$P_Drv_Only_Exit
                push    ax
                mov     ax, 0FF05h      ; (_$P_No_Tag<<8)|_$P_File_Spec
                                        ; set result buffer to file spec
                call    _$P_Fill_Result
                pop     ax

_$P_Drv_Only_Exit:                      ; CODE XREF: _$P_File_Format+65↑j
                retn
_$P_File_Format endp


; =============== S U B R O U T I N E =======================================


_$P_FileSp_Chk  proc near               ; CODE XREF: _$P_File_Format+F↑p
                                        ; _$P_File_Format+41↑p
                push    bx
                push    cx
                lea     bx, _$P_FileSp_Char ; "[]|<>+=;\""
                mov     cx, 9           ; _$P_FileSp_Len
                                        ; load length of special character table
                                        ; at SYSINIT:1CFEh (for PCDOS 7.1 IBMBIO.COM)

_$P_FileSp_Loop:                        ; CODE XREF: _$P_FileSp_Chk+F↓j
                cmp     al, cs:[bx]     ; is it one of special character ?
                jz      short _$P_FileSp_Exit
                inc     bx
                loop    _$P_FileSp_Loop
                inc     cx              ; reset ZF

_$P_FileSp_Exit:                        ; CODE XREF: _$P_FileSp_Chk+C↑j
                pop     cx
                pop     bx
                retn
_$P_FileSp_Chk  endp


; =============== S U B R O U T I N E =======================================


_$P_Drive_Format proc near              ; CODE XREF: _$P_Check_Match_Flags+67↑p
                push    ax
                push    dx
                mov     al, cs:[si]
                or      al, al          ; if null string
                jz      short _$P_Drv_Exit ; do nothing
                call    _$P_Chk_DBCS    ; is it leading byte ?
                jb      short _$P_Drv_Err ; yes, error
                cmp     word ptr cs:[si+1], 3Ah ; ':' ; _$P_Colon
                                        ; "d", ":", 0 ?
                jz      short _$P_DrvF00
                test    word ptr es:[bx], 10h ; [es:bx+_$P_Control_Blk.Match_Flag],
                                        ; _$P_Ig_Colon
                                        ; colon can be ignored?
                jz      short _$P_Drv_Err
                cmp     byte ptr cs:[si+1], 0 ; _$P_NULL ; "d", 0 ?
                jnz     short _$P_Drv_Err

_$P_DrvF00:                             ; CODE XREF: _$P_Drive_Format+13↑j
                or      al, 20h         ; _$P_Make_Lower ; lower case
                cmp     al, 61h ; 'a'   ; drive letter must
                jb      short _$P_Drv_Err ; in range of
                cmp     al, 7Ah ; 'z'   ; "a"-"z"
                ja      short _$P_Drv_Err ; if no, error
                sub     al, 60h         ; "a"-1 ; make text drive to binary drive
                mov     dl, al
                mov     ah, 0FFh        ; _$P_No_Tag
                mov     al, 6           ; _$P_Drive
                                        ; mov ax,(_$P_No_Tag<<8)|_$P_Drive ; 0FF06h
                call    _$P_Fill_Result ; set result buffer to drive
                jmp     short _$P_Drv_Exit
; ---------------------------------------------------------------------------

_$P_Drv_Err:                            ; CODE XREF: _$P_Drive_Format+C↑j
                                        ; _$P_Drive_Format+1A↑j ...
                mov     cs:_$P_RC, 9    ; _$P_Syntax

_$P_Drv_Exit:                           ; CODE XREF: _$P_Drive_Format+7↑j
                                        ; _$P_Drive_Format+38↑j
                pop     dx
                pop     ax
                retn
_$P_Drive_Format endp


; =============== S U B R O U T I N E =======================================


_$P_Skip_Delim  proc near               ; CODE XREF: SysParse+3E↑p
                                        ; SysParse+82↑p ...
                lodsb
                call    _$P_Chk_EOL     ; is it EOL character ?
                jz      short _$P_Skip_Delim_CY ; if yes, exit w/ CY on
                call    _$P_Chk_Delim   ; is it one of delimiters ?
                jnz     short _$P_Skip_Delim_NCY ; if no, exit w/ CY off
                test    cs:_$P_Flags2, 20h ; _$P_Extra ; extra delim or comma found
                jz      short _$P_Skip_Delim ; _$P_Skip_Delim_Loop
                                        ; if no, loop
                test    cs:_$P_Flags2, 41h ; _$P_SW+_$P_equ ; /x , or xxx=zzz ,
                jz      short _$P_Exit_At_Extra ; no switch, no keyword
                dec     si
                jmp     short _$P_Exit_At_Extra
; ---------------------------------------------------------------------------

_$P_Skip_Delim_CY:                      ; CODE XREF: _$P_Skip_Delim+4↑j
                stc                     ; indicate EOL
                jmp     short _$P_Skip_Delim_Exit
; ---------------------------------------------------------------------------

_$P_Skip_Delim_NCY:                     ; CODE XREF: _$P_Skip_Delim+9↑j
                clc                     ; indicate non delim

_$P_Skip_Delim_Exit:                    ; CODE XREF: _$P_Skip_Delim+1F↑j
                dec     si              ; in this case, need backup index pointer
                retn
; ---------------------------------------------------------------------------

_$P_Exit_At_Extra:                      ; CODE XREF: _$P_Skip_Delim+19↑j
                                        ; _$P_Skip_Delim+1C↑j
                clc                     ; indicate extra delim
                retn
_$P_Skip_Delim  endp


; =============== S U B R O U T I N E =======================================


_$P_Chk_EOL     proc near               ; CODE XREF: SysParse+70↑p
                                        ; _$P_Skip_Delim+1↑p
                push    bx
                push    cx
                cmp     al, 0Dh         ; _$P_CR ; Carriage return ?
                jz      short _$P_Chk_EOL_Exit
                cmp     al, 0           ; _$P_NULL ; zero ?
                jz      short _$P_Chk_EOL_Exit
                cmp     al, 0Ah         ; _$P_LF ; Line feed ?
                jz      short _$P_Chk_EOL_Exit
                cmp     byte ptr es:[di+2], 2 ; [es:di+_$P_PARMS_Blk.Num_Extra],
                                        ; _$P_I_Have_EOL
                jb      short _$P_Chk_EOL_Exit
                xor     bx, bx
                mov     bl, es:[di+3]   ; [es:di+_$P_PARMS_Blk.Len_Extra_Delim]
                                        ; get length of delimiter list
                add     bx, 4           ; _$P_Len_PARMS ; skip it
                cmp     byte ptr es:[bx+di], 0 ; _$P_I_Use_Default
                                        ; No extra EOL character ?
                jz      short _$P_Chk_EOL_NZ
                xor     cx, cx          ; Get number of extra character
                mov     cl, es:[bx+di]

_$P_Chk_EOL_Loop:                       ; CODE XREF: _$P_Chk_EOL+2F↓j
                inc     bx
                cmp     al, es:[bx+di]  ; Check extra EOL character
                jz      short _$P_Chk_EOL_Exit
                loop    _$P_Chk_EOL_Loop

_$P_Chk_EOL_NZ:                         ; CODE XREF: _$P_Chk_EOL+22↑j
                cmp     al, 0Dh         ; _$P_CR ; reset ZF

_$P_Chk_EOL_Exit:                       ; CODE XREF: _$P_Chk_EOL+4↑j
                                        ; _$P_Chk_EOL+8↑j ...
                pop     cx
                pop     bx
                retn
_$P_Chk_EOL     endp


; =============== S U B R O U T I N E =======================================


_$P_Chk_Delim   proc near               ; CODE XREF: SysParse+75↑p
                                        ; _$P_Skip_Delim+6↑p
                push    bx
                push    cx
                mov     cs:_$P_Terminator, 20h ; ' ' ; _$P_Space
                                        ; assume terminated by space
                and     cs:_$P_Flags2, 0DFh ; 0FFh-_$P_Extra ; ~$P_Extra ; ~20h
                cmp     al, 20h ; ' '   ; _$P_Space ; Space ?
                jz      short _$P_Chk_Delim_Exit
                cmp     al, 9           ; _$P_TAB ; TAB ?
                jz      short _$P_Chk_Delim_Exit
                cmp     al, 2Ch ; ','   ; _$P_Comma ; Comma ?
                jz      short _$P_Chk_Delim_Exit0

_$P_Chk_Delim00:                        ; Note: _$P_Chk_Delim00 part of code is nonsense
                cmp     al, 20h ; ' '   ;       here because _$P_Space = _$P_DBSP1 = 20h
                                        ;       Erdogan Tan - 08/07/2023
                                        ;
                                        ; _$P_DBSP1 ; 1st byte of DBCS Space ?
                jnz     short _$P_Chk_Delim01
                cmp     byte ptr [si], 20h ; ' ' ; _$P_DBSP2 ; 2nd byte of DBCS Space ?
                jnz     short _$P_Chk_Delim01
                mov     al, 20h ; ' '   ; _$P_Space
                inc     si              ; make si point to next character
                cmp     al, al          ; Set ZF
                jmp     short _$P_Chk_Delim_Exit
; ---------------------------------------------------------------------------

_$P_Chk_Delim01:                        ; CODE XREF: _$P_Chk_Delim+1C↑j
                                        ; _$P_Chk_Delim+21↑j
                cmp     byte ptr es:[di+2], 1 ; [es:di-_$P_PARMS_Blk.Num_Extra],
                                        ; _$P_I_Have_Delim
                                        ; delimiter character specified ?
                jb      short _$P_Chk_Delim_Exit ; no
                xor     cx, cx
                mov     cl, es:[di+3]   ; [es:di+_$P_PARMS_Blk.Len_Extra_Delim]
                                        ; get length of delimiter list
                jcxz    short _$P_Chk_Delim_NZ ; no extra delim character
                mov     bx, 3           ; _$P_Len_PARMS-1
                                        ; set bx to 1st extra delimiter

_$P_Chk_Delim_Loop:                     ; CODE XREF: _$P_Chk_Delim+42↓j
                inc     bx
                cmp     al, es:[bx+di]  ; check extra delim character
                jz      short _$P_Chk_Delim_Exit0
                loop    _$P_Chk_Delim_Loop ; examine all extra delimiter

_$P_Chk_Delim_NZ:                       ; CODE XREF: _$P_Chk_Delim+37↑j
                cmp     al, 20h ; ' '   ; _$P_Space ; reset ZF

_$P_Chk_Delim_Exit:                     ; CODE XREF: _$P_Chk_Delim+10↑j
                                        ; _$P_Chk_Delim+14↑j ...
                pop     cx
                pop     bx
                retn
; ---------------------------------------------------------------------------

_$P_Chk_Delim_Exit0:                    ; CODE XREF: _$P_Chk_Delim+18↑j
                                        ; _$P_Chk_Delim+40↑j
                mov     cs:_$P_Terminator, al ; keep terminated delimiter
                test    cs:_$P_Flags2, 1 ; _$P_equ ; if terminating a key=
                jnz     short _$P_No_Set_Extra ; then do not set the EXTRA bit
                or      cs:_$P_Flags2, 20h ; _$P_Extra
                                        ; flag terminated extra delim or comma

_$P_No_Set_Extra:                       ; CODE XREF: _$P_Chk_Delim+53↑j
                cmp     al, al          ; set ZF
                jmp     short _$P_Chk_Delim_Exit
_$P_Chk_Delim   endp


; =============== S U B R O U T I N E =======================================


_$P_Chk_Switch  proc near               ; CODE XREF: SysParse+6B↑p
                lea     bp, _$P_STRING_BUF ; BP = Offset of _$P_String_Buf
                                        ; (mov bp, offset _$P_STRING_BUF)
                cmp     bx, bp          ; IF not first char THEN
                jz      short _$P_STRUC_L2
                cmp     al, 2Fh ; '/'   ; _$P_Switch ; see if a slash
                jnz     short _$P_STRUC_L5
                stc                     ; not in first position and is slash
                retn
; ---------------------------------------------------------------------------

_$P_STRUC_L5:                           ; CODE XREF: _$P_Chk_Switch+A↑j
                clc                     ; not a slash
                retn
; ---------------------------------------------------------------------------

_$P_STRUC_L2:                           ; CODE XREF: _$P_Chk_Switch+6↑j
                cmp     al, 2Fh ; '/'   ; _$P_Switch
                jnz     short _$P_STRUC_L12 ; not a slash
                or      cs:_$P_Flags2, 40h ; _$P_SW
                                        ; could be valid switch,
                                        ; first char and is slash

_$P_STRUC_L12:                          ; CODE XREF: _$P_Chk_Switch+12↑j
                clc                     ; is first char in the buffer, ZF=0
                                        ; (CF=0 indicating first char)
                retn
_$P_Chk_Switch  endp


; =============== S U B R O U T I N E =======================================


_$P_Chk_DBCS    proc near               ; CODE XREF: SysParse+A0↑p
                                        ; _$P_Remove_Colon:_$P_RCOL00↑p ...
                push    ds
                push    si
                push    bx
                cmp     cs:_$P_DBCSEV_SEG, 0 ; already set ?
                jnz     short _$P_DBCS00 ; yes
                push    ax
                push    ds
                push    cx
                push    dx
                push    di
                push    bp
                push    es
                xor     si, si
                mov     ds, si
                assume ds:nothing
                mov     ax, 6300h       ; _$P_DOS_GetEV ; GET DBCS EV CALL
                int     21h             ; DOS - 3.2+ only
                                        ; GET DOUBLE BYTE CHARACTER SET LEAD TABLE
                mov     bx, ds
                or      bx, bx
                pop     es
                pop     bp
                pop     di
                pop     dx
                pop     cx
                pop     ds
                assume ds:nothing
                pop     ax
                jz      short _$P_NON_DBCS
                mov     cs:_$P_DBCSEV_OFF, si ; save EV offset
                mov     cs:_$P_DBCSEV_SEG, bx ; save EV segment

_$P_DBCS00:                             ; CODE XREF: _$P_Chk_DBCS+9↑j
                lds     si, dword ptr cs:_$P_DBCSEV_OFF ; load EV offset and segment

_$P_DBCS_LOOP:                          ; CODE XREF: _$P_Chk_DBCS+4A↓j
                cmp     word ptr [si], 0 ; zero vector ?
                jz      short _$P_NON_DBCS ; then exit
                cmp     al, [si]        ; Check if AL is in range of the vector
                jb      short _$P_DBCS01
                cmp     al, [si+1]
                ja      short _$P_DBCS01
                stc                     ; if yes, indicate DBCS and exit
                jmp     short _$P_DBCS_EXIT
; ---------------------------------------------------------------------------

_$P_DBCS01:                             ; CODE XREF: _$P_Chk_DBCS+3E↑j
                                        ; _$P_Chk_DBCS+43↑j
                inc     si              ; add 2 to si reg
                inc     si              ; get next vector
                jmp     short _$P_DBCS_LOOP ; loop until zero vector found
; ---------------------------------------------------------------------------

_$P_NON_DBCS:                           ; CODE XREF: _$P_Chk_DBCS+26↑j
                                        ; _$P_Chk_DBCS+3A↑j
                clc                     ; indicate SBCS
                                        ; (note: cf is already 0 here)

_$P_DBCS_EXIT:                          ; CODE XREF: _$P_Chk_DBCS+46↑j
                pop     bx
                pop     si
                pop     ds
                retn
_$P_Chk_DBCS    endp

; ---------------------------------------------------------------------------
buf_parms       dw offset buf_parmsx    ; DATA XREF: doconf+1DA↓o
                                        ; buffer = [n | n,m] {/e}
                db 1                    ; an extra delimiter list
                db 1                    ; length is 1
                db ';'                  ; delimiter
buf_parmsx      db 1                    ; DATA XREF: SYSINIT:buf_parms↑o
                db 2                    ; min 1, max 2 positionals
                dw offset buf_pos1
                dw offset buf_pos2
                db 1                    ; one switch
                dw offset sw_x_ctrl
                db 0                    ; no keywords
                                        ;
                                        ; buf_pos1 p_pos <8000h,0,result_val,buf_range_1>
                                        ; numeric
buf_pos1        dw 8000h                ; DATA XREF: SYSINIT:2524↑o
                                        ; match_flags - numeric value
                dw 0                    ; function flags
                dw offset result_val    ; result value buffer
                dw offset buf_range_1   ; value list
                db 0                    ; no switches/keywords
buf_range_1     db 1                    ; DATA XREF: SYSINIT:2532↑o
                                        ; range definition
                db 1                    ; 1 definition of range
                db 1                    ; item tag for this range
                dd 1                    ; numeric min
                dd 99                   ; numeric max
                                        ;
                                        ; buf_pos2 p_pos <8001h,0,result_val,buf_range_2>
                                        ; optional num.
buf_pos2        dw 8001h                ; DATA XREF: SYSINIT:2526↑o
                dw 0
                dw offset result_val
                dw offset buf_range_2
                db 0                    ;
                                        ; buf_range_2 p_range <,,,0,8>
buf_range_2     db 1                    ; DATA XREF: SYSINIT:2546↑o
                db 1
                db 1
                dd 0
                dd 8                    ;
                                        ; sw_x_ctrl p_pos <0,0,result_val,noval,1>
                                        ; followed by one switch
sw_x_ctrl       dw 0                    ; DATA XREF: SYSINIT:2529↑o
                dw 0
                dw offset result_val
                dw offset noval
                db 1                    ; 1 switch
switch_x        db '/X',0               ; DATA XREF: doconf+1F0↓o
p_buffers       dw 0                    ; DATA XREF: doconf+202↓w
                                        ; doconf:en7↓r ...
p_h_buffers     dw 0                    ; DATA XREF: doconf:if13↓w
                                        ; doconf+216↓w ...
p_buffer_slash_x db 0                   ; DATA XREF: doconf+1D5↓w
                                        ;
                                        ; common definitions
noval           db 0                    ; DATA XREF: SYSINIT:255A↑o
                                        ; SYSINIT:25C6↓o ...
result_val      db 0                    ; DATA XREF: SYSINIT:2530↑o
                                        ; SYSINIT:2544↑o ...
                                        ; type returned
result_val_itag db 0                    ; DATA XREF: doconf+253↓r
                                        ; doconf+295↓r ...
                                        ; item tag returned
result_val_swoff dw 0                   ; DATA XREF: doconf+1F0↓r
                                        ; doconf+9E6↓r ...
                                        ; es:offset of the switch defined
rv_dword        dd 0                    ; DATA XREF: doconf:if11↓r
                                        ; doconf+6F2↓r ...
                                        ; rv_byte
                                        ; value if number, or seg:offset to string.
                                        ; ;;
brk_parms       dw offset brk_parmsx    ; DATA XREF: doconf+23D↓o
                                        ; break = [ on | off ]
                db 1                    ; an extra delimiter list
                db 1                    ; length is 1
                db ';'                  ; delimiter
brk_parmsx      db 1                    ; DATA XREF: SYSINIT:brk_parms↑o
                                        ; min,max = 1 positional
                db 1
                dw offset brk_pos
                db 0                    ; no switches
                db 0                    ; no keywords
brk_pos         dw 2000h                ; DATA XREF: SYSINIT:2575↑o
                dw 0
                dw offset result_val
                dw offset on_off_string
                db 0
on_off_string   db 3                    ; DATA XREF: SYSINIT:257F↑o
                                        ; SYSINIT:2683↓o
                                        ; signals that there is a string choice
                db 0                    ; no range definition
                db 0                    ; no numeric values choice
                db 2                    ; 2 strings for choice
                db 1                    ; the 1st string tag
                dw offset _on_string    ; "ON"
                db 2                    ; the 2nd string tag
                dw offset _off_string   ; "OFF"
_on_string      db 'ON',0               ; DATA XREF: SYSINIT:2587↑o
_off_string     db 'OFF',0              ; DATA XREF: SYSINIT:258A↑o
p_ctrl_break    db 0                    ; DATA XREF: doconf+25A↓w
                                        ; doconf:if26↓w ...
                                        ; local variable
                                        ; ;;
cntry_parms     dw offset cntry_parmsx  ; DATA XREF: doconf+6CD↓o
                                        ; country = n {m {path}}
                                        ; or country = n,,path
                db 1
                db 1
                db ';'
cntry_parmsx    db 1                    ; DATA XREF: SYSINIT:cntry_parms↑o
                                        ; min 1, max 3 pos.
                db 3
                dw offset cntry_pos1
                dw offset cntry_pos2
                dw offset cntry_pos3
                db 0                    ; no switches
                db 0                    ; no keywords
cntry_pos1      dw 8000h                ; DATA XREF: SYSINIT:259B↑o
                                        ; cntry_pos1 p_pos <8000h,0,result_val,cc_range>
                                        ; numeric value
                dw 0
                dw offset result_val
                dw offset cc_range
                db 0
cc_range        db 1                    ; DATA XREF: SYSINIT:25A9↑o
                                        ; SYSINIT:25BD↓o
                                        ; cc_range p_range <,,,1,999>
                db 1
                db 1
                dd 1
                dd 999
cntry_pos2      dw 8001h                ; DATA XREF: SYSINIT:259D↑o
                                        ; cntry_pos2 p_pos <8001h,0,result_val,cc_range>
                                        ; optional num.
                dw 0
                dw offset result_val
                dw offset cc_range
                db 0
cntry_pos3      dw 201h                 ; DATA XREF: SYSINIT:259F↑o
                                        ; cntry_pos3 p_pos <201h,0,result_val,noval>
                                        ; optional filespec
                dw 0
                dw offset result_val
                dw offset noval
                db 0
p_cntry_code    dw 0                    ; DATA XREF: doconf+6DC↓w
                                        ; doconf+6FB↓w ...
                                        ; local variable
p_code_page     dw 0                    ; DATA XREF: doconf+6C6↓w
                                        ; doconf:if57↓w ...
                                        ; local variable
                                        ; ;;
files_parms     dw offset files_parmsx  ; DATA XREF: doconf+7ED↓o
                                        ; files = n
                db 1
                db 1
                db ';'
files_parmsx    db 1                    ; DATA XREF: SYSINIT:files_parms↑o
                db 1                    ; min,max 1 positional
                dw offset files_pos
                db 0                    ; no switches
                db 0                    ; no keywords
files_pos       dw 8000h                ; DATA XREF: SYSINIT:25D4↑o
                                        ; files_pos p_pos <8000h,0,result_val,files_range,0>
                                        ; numeric value
                dw 0
                dw offset result_val
                dw offset files_range
                db 0
files_range     db 1                    ; DATA XREF: SYSINIT:25DE↑o
                                        ; files_range p_range <,,,8,255>
                db 1
                db 1
                dd 8
                dd 255
p_files         db 0                    ; DATA XREF: doconf+807↓w
                                        ; doconf:en67↓r
                                        ; local variable
                                        ; ;;
fcbs_parms      dw offset fcbs_parmsx   ; DATA XREF: doconf+986↓o
                                        ; fcbs = n,m
                db 1
                db 1
                db ';'
fcbs_parmsx     db 1                    ; DATA XREF: SYSINIT:fcbs_parms↑o
                db 2
                dw offset fcbs_pos_1
                dw offset fcbs_pos_2
                db 0                    ; no switches
                db 0                    ; no keywords
fcbs_pos_1      dw 8000h                ; DATA XREF: SYSINIT:25F4↑o
                                        ; fcbs_pos_1 p_pos <8000h,0,result_val,fcbs_range>
                                        ; numeric value
                dw 0
                dw offset result_val
                dw offset fcbs_range
                db 0
fcbs_range      db 1                    ; DATA XREF: SYSINIT:2600↑o
                                        ; fcbs_range p_range <,,,1,255>
                db 1
                db 1
                dd 1
                dd 255
fcbs_pos_2      dw 8000h                ; DATA XREF: SYSINIT:25F6↑o
                                        ; fcbs_pos_2 p_pos <8000h,0,result_val,fcbs_keep_range>
                                        ; numeric value
                dw 0
                dw offset result_val
                dw offset fcbs_keep_range
                db 0
fcbs_keep_range db 1                    ; DATA XREF: SYSINIT:2614↑o
                                        ; fcbs_keep_range p_range <,,,0,255>
                db 1
                db 1
                dd 0
                dd 255
p_fcbs          db 0                    ; DATA XREF: doconf+9A5↓w
                                        ; doconf:en98↓r
                                        ; local variable
p_keep          db 0                    ; DATA XREF: doconf:if102↓w
                                        ; local variable
                                        ; ;;
ldrv_parms      dw offset ldrv_parmsx   ; DATA XREF: doconf+822↓o
                                        ; lastdrive = x
                db 1
                db 1
                db ';'
ldrv_parmsx     db 1                    ; DATA XREF: SYSINIT:ldrv_parms↑o
                db 1                    ; min,max = 1 positional
                dw offset ldrv_pos
                db 0                    ; no switches
                db 0                    ; no keywords
ldrv_pos        dw 110h                 ; DATA XREF: SYSINIT:262B↑o
                                        ; ldrv_pos p_pos <110h,10h,result_val,noval>
                                        ; drive only, ignore colon at end
                dw 10h
                dw offset result_val
                dw offset noval
                db 0
p_ldrv          db 0                    ; DATA XREF: doconf+83C↓w
                                        ; doconf:en73↓r
                                        ; local variable
                                        ; ;;
stks_parms      dw offset stks_parmsx   ; DATA XREF: doconf+875↓o
                                        ; stacks = n,m
                db 1
                db 1
                db ';'
stks_parmsx     db 2                    ; DATA XREF: SYSINIT:stks_parms↑o
                db 2                    ; min,max = 2 positionals
                dw offset stks_pos_1
                dw offset stks_pos_2
                db 0                    ; no switches
                db 0                    ; no keywords
stks_pos_1      dw 8000h                ; DATA XREF: SYSINIT:2640↑o
                                        ; stks_pos_1 p_pos <8000h,0,result_val,stks_range>
                                        ; numeric value
                dw 0
                dw offset result_val
                dw offset stks_range
                db 0
stks_range      db 1                    ; DATA XREF: SYSINIT:264C↑o
                                        ; stks_range p_range <,,,0,64>
                db 1
                db 1
                dd 0
                dd 64
stks_pos_2      dw 8000h                ; DATA XREF: SYSINIT:2642↑o
                                        ; stks_pos_2 p_pos <8000h,0,result_val,stk_size_range>
                                        ; numeric value
                dw 0
                dw offset result_val
                dw offset stk_size_range
                db 0
stk_size_range  db 1                    ; DATA XREF: SYSINIT:2660↑o
                                        ; stk_size_range p_range <,,,0,512>
                db 1
                db 1
                dd 0
                dd 512
p_stack_count   dw 0                    ; DATA XREF: doconf+89B↓w
                                        ; doconf:en79↓r ...
                                        ; local variable
p_stack_size    dw 0                    ; DATA XREF: doconf:if83↓w
                                        ; doconf+8B7↓r ...
                                        ; local variable
                                        ; ;;
mtrk_parms      dw offset mtrk_parmsx   ; DATA XREF: doconf+27F↓o
                                        ; multitrack = [ on | off ]
                db 1
                db 1
                db ';'
mtrk_parmsx     db 1                    ; DATA XREF: SYSINIT:mtrk_parms↑o
                                        ; min,max = 1 positional
                db 1
                dw offset mtrk_pos
                db 0                    ; no switches
                db 0                    ; no keywords
mtrk_pos        dw 2000h                ; DATA XREF: SYSINIT:2679↑o
                                        ; mtrk_pos p_pos <2000h,0,result_val,on_off_string>
                                        ; simple string
                dw 0
                dw offset result_val
                dw offset on_off_string
                db 0
p_mtrk          db 0                    ; DATA XREF: doconf+29C↓w
                                        ; doconf:if35↓w ...
                                        ; local variable
                                        ; ;;
swit_parms      dw offset swit_parmsx   ; DATA XREF: doconf+9CF↓o
                                        ; switches=/k
                db 1
                db 1
                db ';'
swit_parmsx     dw 0                    ; DATA XREF: SYSINIT:swit_parms↑o
                                        ; no positionals
                db 6                    ; # of switches (6 for PCDOS 7.1 IBMBIO.COM)
                                        ;  (5 for MSDOS 6.21 IO.SYS)
                dw offset swit_k_ctrl   ; /k control
                dw offset swit_n_ctrl   ; /n control (for MULTI_CONFIG only)
                dw offset swit_f_ctrl   ; /f control (for MULTI_CONFIG only)
                dw offset swit_t_ctrl   ; /t control
                dw offset swit_w_ctrl   ; /w control
                dw offset swit_i_ctrl   ; /i control
                                        ; (6th switch for PCDOS 7.1 IBMBIO.COM)
                db 0                    ; no keywords
swit_k_ctrl     dw 0                    ; DATA XREF: SYSINIT:268F↑o
                                        ; swit_k_ctrl p_pos <0,0,result_val,noval,1>
                                        ; switch string follows
                dw 0
                dw offset result_val
                dw offset noval
                db 1
swit_k          db '/K',0               ; DATA XREF: doconf+9E6↓o
swit_n_ctrl     dw 0                    ; DATA XREF: SYSINIT:2691↑o
                                        ; swit_n_ctrl p_pos <0,0,result_val,noval,1>
                                        ; switch string follows
                dw 0
                dw offset result_val
                dw offset noval
                db 1
swit_n          db '/N',0               ; DATA XREF: menu_check+36↓r
swit_f_ctrl     dw 0                    ; DATA XREF: SYSINIT:2693↑o
                                        ; swit_f_ctrl p_pos <0,0,result_val,noval,1>
                                        ; switch string follows
                dw 0
                dw offset result_val
                dw offset noval
                db 1
swit_f          db '/F',0               ; DATA XREF: menu_check:swchk_scan2↓r
swit_t_ctrl     dw 0                    ; DATA XREF: SYSINIT:2695↑o
                                        ; swit_t_ctrl p_pos <0,0,result_val,noval,1>
                                        ; switch string follows
                dw 0
                dw offset result_val
                dw offset noval
                db 1
swit_t          db '/T',0               ; DATA XREF: doconf:if115↓o
swit_w_ctrl     dw 0                    ; DATA XREF: SYSINIT:2697↑o
                                        ; swit_w_ctrl p_pos <0,0,result_val,noval,1>
                                        ; switch string follows
                dw 0
                dw offset result_val
                dw offset noval
                db 1
swit_w          db '/W',0               ; DATA XREF: doconf:if116↓o
swit_i_ctrl     dw 0                    ; DATA XREF: SYSINIT:2699↑o
                                        ; swit_i_ctrl p_pos <0,0,result_val,noval,1>
                                        ; switch string follows
                dw 0
                dw offset result_val
                dw offset noval
                db 1
swit_i          db '/I',0               ; DATA XREF: doconf:if118↓o
swit_c_ctrl     dw 0                    ; ! (/C, /D, /E switches are not used) !
                                        ; Erdogan Tan - 09/07/2023
                dw 0
                dw offset result_val
                dw offset noval
                db 1
swit_c          db '/C',0
swit_d_ctrl     dw 0
                dw 0
                dw offset result_val
                dw offset noval
                db 1
swit_d          db '/D',0
swit_e_ctrl     dw 0
                dw 0
                dw offset result_val
                dw offset noval
                db 1
swit_e          db '/E',0
                db 0
                db 0
                db 0
p_swit_k        db 0                    ; DATA XREF: doconf+9EF↓w
                                        ; doconf:en110↓r
                                        ; local variable
p_swit_t        db 0                    ; DATA XREF: doconf+A00↓w
                                        ; doconf:if117↓r
                                        ; local variable
p_swit_w        db 0                    ; DATA XREF: doconf+A22↓w
                                        ; doconf+A49↓r
                                        ; local variable
p_swit_i        db 0                    ; DATA XREF: doconf+A11↓w
                                        ; doconf:if119↓r
                                        ; local variable
                                        ; ;;
dos_parms       dw offset dos_parmsx    ; DATA XREF: doconf+2D7↓o
                                        ; DOS = [ high | low ]
                                        ; DOS = HIGH|LOW[,UMB|,NOUMB]
                db 1
                db 1
                db ';'
dos_parmsx      db 1                    ; DATA XREF: SYSINIT:dos_parms↑o
                                        ; min parameters
                db 2                    ; max parameters
                dw offset dos_pos
                dw offset dos_pos
                db 0                    ; no switches
                db 0                    ; no keywords
dos_pos         dw 2000h                ; DATA XREF: SYSINIT:2716↑o
                                        ; SYSINIT:2718↑o
                dw 0
                dw offset result_val
                dw offset dos_strings
                db 0
dos_pos2        dw 2000h                ; dos_pos p_pos <2000h,0,result_val,dos_strings>
                                        ; simple string
                                        ; (this is not needed) - E.TAN - 08/07/2023
                dw 0
                dw offset result_val
                dw offset dos_strings
                db 0
dos_strings     db 3                    ; DATA XREF: SYSINIT:2722↑o
                                        ; SYSINIT:272B↑o
                                        ; signals that there is a string choice
                db 0                    ; no range definition
                db 0                    ; no numeric values choice
                db 4                    ; 4 strings for choice
                db 1                    ; the 1st string tag
                dw offset hi_string     ; "HIGH"
                db 2                    ; the 2nd string tag
                dw offset lo_string     ; "LOW"
                db 3
                dw offset umb_string    ; "UMB"
                db 4
                dw offset noumb_string  ; "NOUMB"
dosdata_parms   dw offset dosdata_parmsx
                                        ; DATA XREF: doconf+AA8↓o
                                        ; DOSDATA = UMB|NOUMB
                db 1
                db 1
                db ';'
dosdata_parmsx  db 1                    ; DATA XREF: SYSINIT:dosdata_parms↑o
                db 1                    ; min,max = 1 positional
                dw offset dosdata_pos
                db 0                    ; no switches
                db 0                    ; no keywords
dosdata_pos     dw 2000h                ; DATA XREF: SYSINIT:2745↑o
                                        ; dosdata_pos p_pos <2000h,0,result_val,dosdata_strings>
                                        ; simple string
                dw 0
                dw offset result_val
                dw offset dosdata_strings
                db 0
dosdata_strings db 3                    ; DATA XREF: SYSINIT:274F↑o
                                        ; signals that there is a string choice
                db 0                    ; no range definition
                db 0                    ; no numeric values choice
                db 2                    ; 4 strings for choice
                db 1                    ; the 1st string tag
                dw offset umb_string    ; "UMB"
                db 2                    ; the 2nd string tag
                dw offset noumb_string  ; "NOUMB"
hi_string       db 'HIGH',0             ; DATA XREF: SYSINIT:2733↑o
lo_string       db 'LOW',0              ; DATA XREF: SYSINIT:2736↑o
umb_string      db 'UMB',0              ; DATA XREF: SYSINIT:2739↑o
                                        ; SYSINIT:2757↑o
noumb_string    db 'NOUMB',0            ; DATA XREF: SYSINIT:273C↑o
                                        ; SYSINIT:275A↑o
p_dos_hi        db 0                    ; local variable (parser does not use this)
                db 0                    ;
                                        ; for LoadHigh and DeviceHigh:
                                        ;    fInHigh  - Is set to 1 during HideUMBs(), and back to zero in
                                        ;               UnHideUMBs().
                                        ;    fUmbTiny - Is set to 1 iff the user has specified /S on the
                                        ;               command line.
                                        ;    SegLoad  - Segment address for first UMB specified; set
                                        ;               automatically.
                                        ;    UmbLoad  - The load UMB number; for example, this is 3 if the
                                        ;               user has given a command-line like "/L:3,500;4"
                                        ;    fm_umb   - Set to the old UMB link-state (0x80 or 0x00)
                                        ;    fm_strat - Set to the old memory-allocation strategy (0$00000???)
                                        ;    fm_argc  - Number of arguments received by ParseVar()
fInHigh         db 0                    ; DATA XREF: InitVar+C↓w
                                        ; HideUMBs+12↓w ...
fUmbTiny        db 0                    ; DATA XREF: InitVar+8↓w
                                        ; ParseVar+21↓w ...
SegLoad         dw 0                    ; DATA XREF: InitVar+10↓w
UmbLoad         db 0                    ; DATA XREF: InitVar+14↓w
                                        ; unMarkUMB+10↓r ...
                                        ; UmbUsed - An array of characters, each of which is 1 if the UMB
                                        ;           matching its index number was specified on the
                                        ;           command line;
                                        ;        for example, after "/L:3,500;4;7", UmbUsed[3],[4] & [7]
                                        ;        will be set to 1. All others will be set to 0.
                                        ; UmbSize - An array of words, each of which is interpereted as a
                                        ;           size specified by the user for a UMB (in the above
                                        ;           example, all elements would be zero save UmbSize[3],
                                        ;           which would be 500.
UmbUsed         db 16 dup(0)            ; DATA XREF: InitVar+22↓o
                                        ; unMarkUMB+A↓w ...
                                        ; times MAXUMB db 0
UmbSize         dw 16 dup(0)            ; DATA XREF: InitVar+2A↓o
                                        ; stowSiz+B↓w ...
                                        ; times MAXUMB dw 0
fm_umb          db 0                    ; DATA XREF: fm_link+8↓w
                                        ; fm_unlink+5↓r ...
fm_strat        db 0
fm_argc         db 0                    ; DATA XREF: InitVar+1A↓w
                                        ; incArgc+4↓r ...
DevSize         dw 0                    ; DATA XREF: MagicPreload+18↑r
                                        ; MagicPostload+15↑w ...
                                        ; size of the device driver being loaded (paras)
DevLoadAddr     dw 0                    ; DATA XREF: MagicPreload+14↑r
                                        ; MagicPostload+31↑r ...
                                        ; Mem addr where the device driver is 2 b loaded
DevLoadEnd      dw 0                    ; DATA XREF: MagicPreload+1F↑r
                                        ; MagicPreload+57↑r ...
                                        ; MaxAddr to which device can be loaded
DevEntry        dd 0                    ; DATA XREF: MagicPreload+32↑r
                                        ; MagicPreload+EF↑r ...
                                        ; Entry point to the device driver
DevBrkAddr      dd 0                    ; DATA XREF: MagicPreload+A7↑w
                                        ; MagicPreload:_foundpb↑r ...
                                        ; Break address of the device driver
ConvLoad        db 0                    ; DATA XREF: doconf+3BE↓w
                                        ; doconf+3D4↓w ...
                                        ; Use conventional (dos 5 style) InitDevLoad?
DevUMB          db 0                    ; DATA XREF: doconf+36F↓r
                                        ; doconf+4B5↓r ...
                                        ; byte indicating whether to load DDs in UMBs
DevUMBAddr      dw 0                    ; DATA XREF: InitDevLoad+36↓r
                                        ; SpaceInUMB+4↓r ...
                                        ; current UMB used for loading devices (paras)
DevUMBSize      dw 0                    ; DATA XREF: InitDevLoad+3B↓r
                                        ; SpaceInUMB↓r ...
                                        ; Size of the current UMB being used (paras)
DevUMBFree      dw 0                    ; DATA XREF: InitDevLoad:InitForHi↓r
                                        ; SpaceInUMB+9↓r ...
                                        ; Start of free mem blk in the current UMB (paras)
DevXMSAddr      dd 0                    ; DATA XREF: InitAllocUMB+13↓w
                                        ; umb_allocate+6↓r ...
DevExecAddr     dw 0                    ; DATA XREF: ExecDev+5↓w
                                        ; ExecDev+13↓o
                                        ; Device load address parameter to Exec call
DevExecReloc    dw 0                    ; DATA XREF: ExecDev+A↓w
                                        ; Device load relocation factor
DeviceHi        db 0                    ; DATA XREF: MagicPreload+B↑w
                                        ; MagicPostload+19↑w ...
                                        ; Flag indicating whether the current device
                                        ; is being loaded into UMB
DevSizeOption   dw 0                    ; DATA XREF: doconf:tryu_1↓r
                                        ; doconf+392↓w ...
                                        ; SIZE= option
Int12Lied       db 0                    ; DATA XREF: SetInt12Mem+16↓w
                                        ; TrueInt12Mem↓r ...
                                        ; did we trap int 12h ?
OldInt12Mem     dw 0                    ; DATA XREF: SetInt12Mem+A↓w
                                        ; TrueInt12Mem+14↓r
                                        ; value in 40:13h (int 12h ram)
ThreeComName    db 'PROTMAN$'           ; DATA XREF: IsIt3Com+D↓o
                                        ; 3Com Device name
FirstUMBLinked  db 0                    ; DATA XREF: InitAllocUMB+1D↓r
                                        ; InitAllocUMB+2A↓w ...
DevDOSData      dw 0                    ; DATA XREF: InitAllocUMB+9↓w
                                        ; umb_insert+1↓r ...
                                        ; segment of DOS Data
DevCmdLine      dw 2 dup(0)             ; DATA XREF: doconf+3A9↓w
                                        ; ParseSize+A↓w ...
                                        ; Current Command line
DevSavedDelim   db 0                    ; DATA XREF: doconf:tryu_5↓w
                                        ; doconf+399↓w ...
                                        ; The delimiter which was replaced with null
                                        ; to use the file name in the command line
MagicHomeFlag   db 0                    ; DATA XREF: doconf:CheckDoubleSpace↓r
                                        ; doconf:set_magichomeflag↓w
                                        ; set non-zero when MagicDrv is final placed

; =============== S U B R O U T I N E =======================================


doconf          proc near               ; CODE XREF: SYSINIT:ProcessConfig↑p

; FUNCTION CHUNK AT 28A1 SIZE 0000003A BYTES
; FUNCTION CHUNK AT 28EF SIZE 0000001D BYTES
; FUNCTION CHUNK AT 290E SIZE 0000069F BYTES
; FUNCTION CHUNK AT 2FC1 SIZE 00000317 BYTES
; FUNCTION CHUNK AT 3326 SIZE 0000000C BYTES

                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     ax, 3700h       ; (CHAR_OPER<<8)
                int     21h             ; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
                                        ; Return: AL = FFh unsupported subfunction
                                        ; DL = current switch character
                mov     byte ptr command_line+1, dl ; "/P"
                mov     def_swchr, dl   ; save default switchchar
                mov     dx, offset config ; "\\CONFIG.SYS"
                mov     ax, 3D00h       ; OPEN<<8
                stc                     ; (in case of int 24h)
                int     21h             ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
                                        ; DS:DX -> ASCIZ filename
                                        ; AL = access mode
                                        ; 0 - read
                jnb     short noprob    ; brif opened okay
                                        ;
                                        ; config.sys file open error
                call    kbd_read        ; we still want to give the guy
                                        ; a chance to select clean boot!
                                        ; (ie, no autoexec.bat processing)
                mov     multi_pass_id, 11 ; set it to unreasonable number
                retn
; ---------------------------------------------------------------------------

noprob:                                 ; CODE XREF: doconf+18↑j
                mov     bx, ax          ; get file size (note < 64k!!)
                                        ; File handle
                xor     cx, cx
                xor     dx, dx
                mov     ax, 4202h       ; (LSEEK<<8)|2
                int     21h             ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
                                        ; AL = method: offset from end of file
                mov     count, ax
                xor     dx, dx          ; reset pointer to beginning of file
                mov     ax, 4200h
                int     21h             ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
                                        ; AL = method: offset from beginning of file
                mov     dx, ALLOCLIM    ; use current alloclim value
                mov     ax, count
                mov     config_size, ax ; save the size of config.sys file.
                call    ParaRound
                sub     dx, ax
                dec     dx              ; reserve 1 additional paragraph
                mov     config_wrkseg, dx ; this is the segment to be used for
                sub     dx, ax          ; rebuilding the config.sys memory image
                sub     dx, 11h         ; room for header
                mov     ALLOCLIM, dx    ; config starts here. new alloclim value.
                mov     CONFBOT, dx
                mov     ds, dx
                assume ds:nothing
                mov     es, dx
                xor     dx, dx
                mov     cx, cs:count
                mov     ah, 3Fh
                stc                     ; (in case of int 24h)
                int     21h             ; DOS - 2+ - READ FROM FILE WITH HANDLE
                                        ; BX = file handle, CX = number of bytes to read
                                        ; DS:DX -> buffer
                pushf
                push    ax              ; find the eof mark in the file.
                                        ; if present,then trim length.
                push    di
                push    cx
                mov     al, 1Ah         ; eof mark
                mov     di, dx          ; point to buffer
                jcxz    short puteol    ; no chars
                repne scasb             ; find end
                jnz     short puteol    ; none found and count exhausted
                dec     di              ; backup past 1Ah

puteol:                                 ; CODE XREF: doconf+71↑j
                                        ; doconf+75↑j
                mov     al, 0Dh         ; cr,lf
                stosb
                mov     al, 0Ah
                stosb
                sub     di, dx          ; difference moved
                mov     cs:count, di    ; new count
                pop     cx
                pop     di
                pop     ax
                push    cs
                pop     ds
                assume ds:SYSINIT
                push    ax
                mov     ah, 3Eh
                int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
                                        ; BX = file handle
                pop     ax
                popf
                jb      short conferr   ; we've got a problem
                cmp     cx, ax
                jz      short getcom    ; if ax <(>) cx
                                        ; couldn't read the file

conferr:                                ; CODE XREF: doconf+91↑j
                mov     dx, offset config ; "\\CONFIG.SYS"
                call    badfil          ; print config error

endconv:                                ; CODE XREF: multi_pass:jae_endconv↓j
                                        ; doconf:conflp↓j
                retn
doconf          endp


; =============== S U B R O U T I N E =======================================


multi_pass      proc near               ; CODE XREF: SYSINIT:086A↑p
                                        ; SYSINIT:0878↑p ...
                push    cs
                pop     ds
                cmp     multi_pass_id, 10 ; do nothing. just return.

jae_endconv:                            ; CODE XREF: doconf+11D↓j
                jnb     short endconv
                push    CONFBOT
                pop     es              ; es = [confbot] (CONFIG.SYS image seg)
                mov     si, org_count
                mov     count, si       ; set count
                xor     si, si          ; 0
                mov     chrptr, si      ; reset chrptr
                mov     linecount, si   ; reset linecount
                call    getchr
                jmp     short conflp
multi_pass      endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR doconf

getcom:                                 ; CODE XREF: doconf+95↑j
                call    organize        ; organize the file
                call    getchr

conflp:                                 ; CODE XREF: multi_pass+23↑j
                                        ; doconf+127↓j ...
                jb      short endconv
                inc     linecount       ; increase linecount
                mov     multdeviceflag, 0 ; reset multdeviceflag.
                mov     setdevmarkflag, 0 ; reset setdevmarkflag.
                cmp     al, 0Ah         ; lf ; linefeed?
                jz      short blank_line ; then ignore this line.
                                        ;
                                        ; If this is a genuine CONFIG.SYS command,
                                        ; then there should be a line number
                                        ; immediately following it
                mov     config_cmd, al  ; save original command code
                and     al, 7Fh         ; ~CONFIG_OPTION_QUERY
                cmp     config_multi, 0 ; is this a multi-config config.sys?
                jz      short not_final ; no, line number is not embedded
                push    ax
                call    getchr          ; ignore end-of-image errors
                mov     ah, al          ; because if there's an error
                call    getchr          ; fetching the line number that's
                xchg    al, ah          ; supposed to be there, the next
                mov     linecount, ax   ; getchr call will get the same error
                pop     ax
                cmp     multi_pass_id, 2 ; final pass?
; END OF FUNCTION CHUNK FOR doconf
                jb      short not_final ; no
                test    install_flag, 1 ; DATA XREF: MSLOAD:00E7↑r
                                        ; MSLOAD:not_fat32↑r ...
                                        ; have_install_cmd
                                        ; are there install commands?
                jz      short final     ; no install cmds, yes it is
                cmp     multi_pass_id, 3
                                        ; DATA XREF: MSLOAD:00C0↑r
                                        ; MSLOAD:00AE↑r
                                        ; final pass?
                jb      short not_final ; no

final:                                  ; CODE XREF: SYSINIT:28E3↑j
                                        ; DATA XREF: MSLOAD:00F0↑r ...
                mov     es:[si], al     ; save backward-compatible command code
; START OF FUNCTION CHUNK FOR doconf

not_final:                              ; CODE XREF: doconf+E7↑j
                                        ; SYSINIT:28DB↑j ...
                mov     ah, al
                call    getchr          ; DATA XREF: MSLOAD:011E↑r
                jnb     short tryi
                cmp     multi_pass_id, 2
                jnb     short jae_endconv ; it would be 'jnb short endconv'
                                        ; (E.TAN - 09/07/2023)
                                        ; do not show badop again for multi_pass.
                jmp     badop
; ---------------------------------------------------------------------------

coff:                                   ; CODE XREF: doconf:multi_pass_coff2↓j
                                        ; doconf+163↓j ...
                push    cs
                pop     ds
                call    newline
                jmp     short conflp
; ---------------------------------------------------------------------------

blank_line:                             ; CODE XREF: doconf+DB↑j
                call    getchr
                jmp     short conflp
; END OF FUNCTION CHUNK FOR doconf
; ---------------------------------------------------------------------------
                push    cs
                pop     ds
; START OF FUNCTION CHUNK FOR doconf

tryi:                                   ; CODE XREF: doconf+116↑j
                                        ; DATA XREF: MSLOAD:00D1↑r
                cmp     multi_pass_id, 0 ; the initial pass for DOS=HI
                jnz     short not_init_pass
                jmp     multi_try_doshi
; ---------------------------------------------------------------------------

not_init_pass:                          ; CODE XREF: doconf+135↑j
                cmp     multi_pass_id, 2 ; the second pass was for ifs=
                jz      short multi_pass_coff2 ; now it is NOPs
                                        ;
                                        ; This pass can be made use of if
                                        ; we want do some config.sys process
                                        ; after device drivers are loaded and
                                        ; before install= commands are processed
                cmp     multi_pass_id, 3 ; the third pass for install= ?
                jz      short multi_try_i
                cmp     ah, 48h ; 'H'   ; CONFIG_DOS
                jz      short multi_pass_coff2
                cmp     ah, 49h ; 'I'   ; CONFIG_INSTALL ; install= command?
                jnz     short precheck_installhigh ;
                                        ; the first pass is for normal operation.
                or      install_flag, 1 ; have_install_cmd ; set the flag

multi_pass_coff2:                       ; CODE XREF: doconf+13F↑j
                                        ; doconf+14B↑j
                jmp     short coff      ; and handles the next command
; ---------------------------------------------------------------------------

precheck_installhigh:                   ; CODE XREF: doconf+150↑j
                cmp     ah, 57h ; 'W'   ; CONFIG_INSTALLHIGH ; signifier for INSTALLHIGH
                jnz     short tryb      ; carry on with normal processing
                or      install_flag, 1 ; have_install_cmd
                jmp     short coff
; ---------------------------------------------------------------------------

multi_try_i:                            ; CODE XREF: doconf+146↑j
                cmp     ah, 49h ; 'I'   ; CONFIG_INSTALL ; install= command?
                jnz     short multi_try_n ; no, check for installhigh
                call    query_user      ; query the user if config_cmd
                jb      short multi_pass_filter ; has the CONFIG_OPTION_QUERY bit set
                call    do_install_exec ; install it.
                jmp     short coff      ; to handle next install= command.
; ---------------------------------------------------------------------------

multi_try_n:                            ; CODE XREF: doconf+168↑j
                cmp     ah, 57h ; 'W'   ; CONFIG_INSTALLHIGH ; installhigh= command?
                jnz     short multi_pass_filter
                call    query_user      ; query the user if config_cmd
                jb      short multi_pass_filter ; has the CONFIG_OPTION_QUERY bit set
                mov     ax, 5800h
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: get allocation strategy
                mov     bx, ax
                push    bx              ; save for the return
                or      bx, 80h         ; HIGH_FIRST ; set alloc to HighFirst
                mov     ax, 5801h       ; (ALLOCOPER<<8)|1
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: set allocation strategy
                mov     ax, 5802h
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: (DOS 5beta) get UMB link state
                xor     ah, ah
                push    ax              ; save for the return
                mov     ax, 5803h       ; (ALLOCOPER<<8)|3
                mov     bx, 1           ; link in UMBs
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: (DOS 5beta) set UMB link state
                call    do_install_exec ; install it.
                mov     ax, 5803h
                pop     bx              ; recover original link state
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: (DOS 5beta) set UMB link state
                pop     bx              ; recover original alloc strategy
                mov     ax, 5801h
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: set allocation strategy
                jmp     coff            ; to handle next install= commands.
; ---------------------------------------------------------------------------

multi_pass_filter:                      ; CODE XREF: doconf+16D↑j
                                        ; doconf+177↑j ...
                cmp     ah, 59h ; 'Y'   ; CONFIG_COMMENT ; comment?
                jz      short multi_pass_adjust
                cmp     ah, 5Ah ; 'Z'   ; CONFIG_UNKNOWN ; bad command?
                jz      short multi_pass_adjust
                cmp     ah, 30h ; '0'   ; CONFIG_REM ; rem?
                jnz     short multi_pass_coff ; ignore the rest of the commands.

multi_pass_adjust:                      ; CODE XREF: doconf+1B4↑j
                                        ; doconf+1B9↑j
                dec     chrptr          ; these commands need to
                                        ; adjust chrptr,count
                inc     count           ; for newline proc.

multi_pass_coff:                        ; CODE XREF: doconf+1BE↑j
                jmp     coff            ; to handle next install= commands.
; ---------------------------------------------------------------------------

tryb:                                   ; CODE XREF: doconf+15C↑j
                cmp     ah, 42h ; 'B'   ; CONFIG_BUFFERS
                jnz     short tryc
                call    query_user      ; query the user if config_cmd
                                        ; has the CONFIG_OPTION_QUERY bit set
                jb      short tryc
                mov     p_buffer_slash_x, 0
                mov     di, offset buf_parms
                xor     cx, cx
                mov     dx, cx

do7:                                    ; CODE XREF: doconf:en11↓j
                call    sysinit_parse
                jnb     short if7       ;
                                        ; parse error,
                                        ; and show messages and end the search
                call    badparm_p
                jmp     short sr7
; ---------------------------------------------------------------------------

if7:                                    ; CODE XREF: doconf+1E4↑j
                cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
                jz      short en7       ; then jmp to $endloop for semantic check
                cmp     result_val_swoff, offset switch_x ; (/X switch)
                                        ; [result_val+_$P_Result_Blk.SYNONYM_Ptr]
                jnz     short if11
                jmp     short en11
; ---------------------------------------------------------------------------

if11:                                   ; CODE XREF: doconf+1F6↑j
                mov     ax, word ptr rv_dword ; [result_val+_$P_Result_Blk.Picked_Val]
                cmp     cx, 1
                jnz     short if13
                mov     p_buffers, ax
                jmp     short en11
; ---------------------------------------------------------------------------

if13:                                   ; CODE XREF: doconf+200↑j
                mov     p_h_buffers, ax

en11:                                   ; CODE XREF: doconf+1F8↑j
                                        ; doconf+205↑j
                jmp     short do7
; ---------------------------------------------------------------------------

en7:                                    ; CODE XREF: doconf+1EE↑j
                cmp     p_buffers, 99
                jbe     short if18
                call    badparm_p
                mov     p_h_buffers, 0
                jmp     short sr7
; ---------------------------------------------------------------------------

if18:                                   ; CODE XREF: doconf+211↑j
                mov     ax, p_buffers   ; we don't have any problem.
                mov     buffers, ax     ; now,let's set it really.
                mov     ax, p_h_buffers
                mov     h_buffers, ax
                mov     ax, linecount
                mov     buffer_linenum, ax ; save the line number
                                        ; for the future use

sr7:                                    ; CODE XREF: doconf+1E9↑j
                                        ; doconf+21C↑j
                jmp     coff
; ---------------------------------------------------------------------------

tryc:                                   ; CODE XREF: doconf+1CE↑j
                                        ; doconf+1D3↑j
                cmp     ah, 43h ; 'C'   ; CONFIG_BREAK
                jnz     short trym
                call    query_user      ; query the user if config_cmd
                                        ; has the CONFIG_OPTION_QUERY bit set
                jb      short trym
                mov     di, offset brk_parms
                xor     cx, cx
                mov     dx, cx

do22:                                   ; CODE XREF: doconf:en26↓j
                call    sysinit_parse
                jnb     short if22      ;
                                        ; parse error
                call    badparm_p
                jmp     short sr22
; ---------------------------------------------------------------------------

if22:                                   ; CODE XREF: doconf+247↑j
                cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
                jz      short en22      ; then end the $endloop
                cmp     result_val_itag, 1 ; [result_val+_$P_Result_Blk.Item_Tag]
                jnz     short if26
                mov     p_ctrl_break, 1 ; turn it on
                jmp     short en26
; ---------------------------------------------------------------------------

if26:                                   ; CODE XREF: doconf+258↑j
                mov     p_ctrl_break, 0 ; turn it off

en26:                                   ; CODE XREF: doconf+25F↑j
                jmp     short do22      ; we actually set the ctrl break
; ---------------------------------------------------------------------------

en22:                                   ; CODE XREF: doconf+251↑j
                mov     ah, 33h         ; SET_CTRL_C_TRAPPING
                                        ; if we don't have any parse error.
                mov     al, 1
                mov     dl, p_ctrl_break
                int     21h             ; DOS - EXTENDED CONTROL-BREAK CHECKING
                                        ; AL = 00h get state / 01h set state / 02h set AND get
                                        ; DL = 00h for OFF or 01h for ON

sr22:                                   ; CODE XREF: doconf+24C↑j
                jmp     coff
; ---------------------------------------------------------------------------

trym:                                   ; CODE XREF: doconf+236↑j
                                        ; doconf+23B↑j
                cmp     ah, 4Dh ; 'M'   ; CONFIG_MULTITRACK
                jnz     short tryu
                call    query_user      ; query the user if config_cmd
                                        ; has the CONFIG_OPTION_QUERY bit set
                jb      short tryu
                mov     di, offset mtrk_parms
                xor     cx, cx
                mov     dx, cx

do31:                                   ; CODE XREF: doconf:en35↓j
                call    sysinit_parse
                jnb     short if31      ;
                                        ; parse_error
                call    badparm_p       ; show message and end the search loop.
                jmp     short sr31
; ---------------------------------------------------------------------------

if31:                                   ; CODE XREF: doconf+289↑j
                cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
                jz      short en31
                cmp     result_val_itag, 1 ; [result_val+_$P_Result_Blk.Item_Tag]
                jnz     short if35
                mov     p_mtrk, 1       ; turn it on temporarily.
                jmp     short en35
; ---------------------------------------------------------------------------

if35:                                   ; CODE XREF: doconf+29A↑j
                mov     p_mtrk, 0       ; turn it off temporarily.

en35:                                   ; CODE XREF: doconf+2A1↑j
                jmp     short do31      ; we actually set the multrk_flag here
; ---------------------------------------------------------------------------

en31:                                   ; CODE XREF: doconf+293↑j
                push    ds
                mov     ax, 70h         ; DOSBIODATASEG ; BIOSDATA segment
                mov     ds, ax
                assume ds:nothing
                cmp     cs:p_mtrk, 0
                jnz     short if39
                mov     ds:multrk_flag, 1 ; multrk_off2
                jmp     short en39
; ---------------------------------------------------------------------------

if39:                                   ; CODE XREF: doconf+2B6↑j
                mov     ds:multrk_flag, 80h ; multrk_on

en39:                                   ; CODE XREF: doconf+2BE↑j
                pop     ds
                assume ds:nothing

sr31:                                   ; CODE XREF: doconf+28E↑j
                jmp     coff
; ---------------------------------------------------------------------------

multi_try_doshi:                        ; CODE XREF: doconf+137↑j
                cmp     ah, 48h ; 'H'   ; CONFIG_DOS
                jz      short it_is_h

skip_it:                                ; CODE XREF: doconf+2D5↓j
                jmp     multi_pass_filter
; ---------------------------------------------------------------------------

it_is_h:                                ; CODE XREF: doconf+2CD↑j
                call    query_user      ; query the user if config_cmd
                                        ; has the CONFIG_OPTION_QUERY bit set
                jb      short skip_it
                mov     di, offset dos_parms
                xor     cx, cx
                mov     dx, cx

h_do_parse:                             ; CODE XREF: doconf+2F0↓j
                call    sysinit_parse
                jnb     short h_parse_ok

h_badparm:                              ; parse error
                call    badparm_p       ; show message and end the search loop.
                jmp     short h_end
; ---------------------------------------------------------------------------

h_parse_ok:                             ; CODE XREF: doconf+2E1↑j
                cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
                jz      short h_end     ; then end the $endloop
                call    ProcDOS
                jmp     short h_do_parse
; ---------------------------------------------------------------------------

h_end:                                  ; CODE XREF: doconf+2E6↑j
                                        ; doconf+2EB↑j
                jmp     coff
; ---------------------------------------------------------------------------

tryu:                                   ; CODE XREF: doconf+278↑j
                                        ; doconf+27D↑j
                cmp     ah, 'U'         ; CONFIG_DEVICEHIGH
                jz      short tryu_0
                jmp     tryd
; ---------------------------------------------------------------------------

tryu_0:                                 ; CODE XREF: doconf+2F8↑j
                call    query_user      ; query the user if config_cmd
                                        ; has the CONFIG_OPTION_QUERY bit set
                jb      short tryd
                call    InitVar
                call    ParseSize       ; process the size= option
                jnb     short tryu_1    ;
                                        ; stash it there in case of an error
                mov     word ptr cs:badparm_ptr, si
                mov     word ptr cs:badparm_ptr+2, es
                call    badparm_p
                jmp     coff
; ---------------------------------------------------------------------------

tryu_1:                                 ; CODE XREF: doconf+308↑j
                mov     ax, cs:DevSizeOption
                or      ax, ax
                jnz     short tryu_2
                call    ParseVar
                jnb     short tryu_2
                mov     word ptr cs:badparm_ptr, si ;
                                        ; If ParseVar up there failed, then
                                        ; ES:SI points to its problem area..
                mov     word ptr cs:badparm_ptr+2, es
                call    badparm_p       ; so all we have to do is choke and
                                        ; die, rather verbosely.
                jmp     coff
; ---------------------------------------------------------------------------

tryu_2:                                 ; CODE XREF: doconf+320↑j
                                        ; doconf+325↑j
                push    si
                push    es

tryu_3:                                 ; CODE XREF: doconf+34A↓j
                mov     al, es:[si]
                cmp     al, 0Dh         ; cr
                jz      short tryu_4    ; (_tryu_4) (*)
                cmp     al, 0Ah         ; lf
                jz      short tryu_4    ; (*) this would be 'jz short tryu_5'
                                        ; Erdogan Tan - 10/07/2023
                call    delim
                jz      short tryu_4    ; (*) al <> cr
                                        ;     this would be 'jz short tryu_5'
                inc     si
                jmp     short tryu_3
; ---------------------------------------------------------------------------

tryu_4:                                 ; CODE XREF: doconf+33E↑j
                                        ; doconf+342↑j ...
                cmp     al, 0Dh         ; (*) cr ? (this 2nd check woul not be
                                        ; needed because al value would be 0Dh here)
                jnz     short tryu_5

_tryu_4:                                ;
                mov     al, 20h ; ' '   ; blank instead of cr

tryu_5:                                 ; CODE XREF: doconf+34E↑j
                mov     cs:DevSavedDelim, al ; Save the delimiter
                                        ; before replacing it with null
                mov     byte ptr es:[si], 0
                pop     es
                pop     si
                call    UmbTest         ; See if UMBs are around...
                jnb     short NrmTst    ; yep. So do that normal thang.
                mov     cs:DeviceHi, 0  ; nope... so load low.
                jmp     short LoadDevice
; ---------------------------------------------------------------------------

NrmTst:                                 ; CODE XREF: doconf+35F↑j
                mov     cs:DeviceHi, 0
                cmp     cs:DevUMB, 0    ; do we support UMBs ?
                jz      short LoadDevice ; no, we don't
                mov     cs:DeviceHi, 1
                jmp     short LoadDevice
; ---------------------------------------------------------------------------

tryd:                                   ; CODE XREF: doconf+2FA↑j
                                        ; doconf+300↑j
                cmp     ah, 44h ; 'D'   ; CONFIG_DEVICE
                jz      short gotd

skip_it2:                               ; CODE XREF: doconf+38A↓j
                jmp     tryq
; ---------------------------------------------------------------------------

gotd:                                   ; CODE XREF: doconf+382↑j
                call    query_user      ; query the user if config_cmd
                                        ; has the CONFIG_OPTION_QUERY bit set
                jb      short skip_it2
                mov     cs:DeviceHi, 0  ; not to be loaded in UMB
                mov     cs:DevSizeOption, 0
                mov     cs:DevSavedDelim, 20h ; ' ' ; In case of DEVICE=
                                        ; the null has to be replaced with a ' '

LoadDevice:                             ; CODE XREF: doconf+367↑j
                                        ; doconf+375↑j ...
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     word ptr bpb_addr, si ;
                                        ; pass the command line to the device
                mov     word ptr bpb_addr+2, es
                mov     DevCmdLine, si  ; save it for ourself
                mov     DevCmdLine+2, es
                mov     drivers_units, 0 ; clear total block units for driver
                call    round
                call    SizeDevice
                jb      short BadFile
                mov     ConvLoad, 1     ; Doesn't matter if DeviceHi==0
                mov     al, DeviceHi    ; If not using upper memory,
                                        ; ('mov al, [DeviceHi]' is not needed here
                                        ;  because al value is not used after here)
                or      DeviceHi, 0     ; (or al, al) - Erdogan Tan - 10/07/2023
                jz      short DevConvLoad ; Skip all this and go on
                                        ; to the actual load.

loc_7EDB:                               ; ('mov al, [UmbLoad]' would be better here)
                call    GetLoadUMB
                cmp     al, 0FFh        ; -1 ; If umb0 not specified, it's old style
                jz      short DevConvLoad ; so load high even if SIZE= is smaller
                dec     ConvLoad        ; 0 ; They specified /L, so use new loader
                call    GetLoadSize     ; Returns size of first UMB specified
                or      ax, ax
                jz      short tryd_1    ; If size is not specified..
                cmp     ax, DevSize     ; /L:...,Size < DevSize?
                jge     short DevConvLoad

tryd_1:                                 ; CODE XREF: doconf+3DD↑j
                mov     ax, DevSize     ; Size < DevSize, so write DevSize as
                call    StoLoadSize     ; minsize for load UMB.

DevConvLoad:                            ; CODE XREF: doconf+3CB↑j
                                        ; doconf+3D2↑j ...
                call    InitDevLoad
                mov     ax, DevLoadAddr
                add     ax, DevSize
                jb      short NoMem
                cmp     DevLoadEnd, ax
                jnb     short LoadDev

NoMem:                                  ; CODE XREF: doconf+3F5↑j
                jmp     mem_err
; ---------------------------------------------------------------------------

BadFile:                                ; CODE XREF: doconf+3BC↑j
                                        ; doconf+41D↓j ...
                call    RetFromUM       ; Does nothing if didn't call HideUMBs
                cmp     byte ptr es:[si], 20h ; ' ' ; blank/space
                jnb     short tryd_2
                jmp     badop
; ---------------------------------------------------------------------------

tryd_2:                                 ; CODE XREF: doconf+407↑j
                call    badload
                jmp     coff
; ---------------------------------------------------------------------------

LoadDev:                                ; CODE XREF: doconf+3FB↑j
                push    es
                pop     ds
                assume ds:nothing
                mov     dx, si          ; ds:dx points to file name
                call    ExecDev         ; load device driver using exec call
                push    ds
                pop     es              ; es:si back to config.sys
                push    cs
                pop     ds              ; ds back to sysinit
                assume ds:SYSINIT
                jb      short BadFile

goodld:                                 ; CODE XREF: doconf+655↓j
                push    es
                push    si
                call    RemoveNull
                push    es
                push    si
                push    cs
                pop     es
                assume es:SYSINIT
                push    ds
                push    si
                lds     si, cs:DevEntry
                assume ds:nothing
                test    word ptr [si+4], 8000h ; [si+SYSDEV.ATT],DEVTYP
                                        ; block device driver?
                jnz     short got_device_com_cont ; no.
                lds     si, cs:DOSINFO  ; ds:si -> sys_var
                cmp     byte ptr [si+20h], 26 ; [si+SYSI_NUMIO]
                                        ; no more than 26 drive number
                jb      short got_device_com_cont
                pop     si
                pop     ds
                pop     si              ; clear the stack
                pop     es
                assume es:nothing
                call    RetFromUM       ; Do this before we leave
                jmp     badnumblock
; ---------------------------------------------------------------------------

got_device_com_cont:                    ; CODE XREF: doconf+434↑j
                                        ; doconf+43F↑j
                pop     si
                pop     ds
                call    LieInt12Mem
                call    UpdatePDB       ; update the PSP:2 value
                cmp     cs:multdeviceflag, 0 ; Pass limit only for
                                        ; the 1st device driver in the file
                jnz     short skip_pass_limit
                mov     cs:break_addr, 0 ; pass the limit to the DD
                mov     bx, cs:DevLoadEnd
                mov     cs:break_addr+2, bx

skip_pass_limit:                        ; CODE XREF: doconf+459↑j
                push    ds
                lds     bx, cs:DOSINFO  ; ds:bx -> sys_var
                mov     al, cs:drivenumber ; temporarily use this next drv value
                mov     cs:devdrivenum, al ; pass drive number in packet to driver
                mov     ah, al
                xchg    ax, [bx+20h]    ; [bx+SYSI_NUMIO]
                                        ; swap with existing values
                pop     ds
                push    ax              ; save real sysi_numio/ncds in ax
                mov     word ptr cs:configmsgflag, 0 ; disable (reset msg option)
                                        ; "error in config.sys line #" msg
                                        ; (before loading -next- device driver)
                mov     bx, 6           ; SYSDEV.STRAT
                call    calldev         ; calldev (sdevstrat);
                mov     bx, 8           ; SYSDEV.INT
                call    calldev         ; calldev (sdevint);
                pop     ax              ; get real sysi_numio value
                push    ds
                lds     bx, cs:DOSINFO  ; ds:bx -> sys_var
                mov     [bx+20h], ax    ; [bx+SYSI_NUMIO]
                                        ; restore previous/real value
                pop     ds
                call    TrueInt12Mem
                mov     ax, cs:break_addr ; move break addr from the req packet
                mov     word ptr cs:DevBrkAddr, ax
                mov     ax, cs:break_addr+2
                mov     word ptr cs:DevBrkAddr+2, ax
                call    RetFromUM       ; There we go... all done.
                cmp     cs:DevUMB, 0
                jz      short tryd_3
                call    AllocUMB

tryd_3:                                 ; CODE XREF: doconf+4BB↑j
                cmp     cs:runhigh, 0FFh
                jnz     short tryd_4
                call    TryToMovDOSHi   ; move DOS into HMA if requsted

tryd_4:                                 ; CODE XREF: doconf+4C6↑j
                pop     si
                pop     ds
                mov     byte ptr [si], 0 ; *p = 0;
                push    cs
                pop     ds
                assume ds:SYSINIT
                jmp     short was_device_com
; ---------------------------------------------------------------------------

badnumblock:                            ; CODE XREF: doconf+448↑j
                                        ; doconf+563↓j
                push    cs
                pop     ds
                mov     dx, offset badblock ; "\r\nToo many block devices\r\n$"
                call    print

erase_dev_do:                           ; CODE XREF: doconf:jc_edd↓j
                                        ; doconf+547↓j
                pop     si
                pop     es
                push    cs
                pop     ds
                cmp     word ptr cs:configmsgflag, 0 ; is error_line msg disabled ?
                jz      short no_error_line_msg ; yes
                call    error_line      ; show "error in config.sys ..." message.
                mov     word ptr cs:configmsgflag, 0 ; set the default value again.

no_error_line_msg:                      ; CODE XREF: doconf+4E6↑j
                jmp     coff
; ---------------------------------------------------------------------------

was_device_com:                         ; CODE XREF: doconf+4D2↑j
                mov     ax, word ptr cs:DevBrkAddr+2
                cmp     ax, cs:DevLoadEnd
                jbe     short breakok
                pop     si
                pop     es
                jmp     BadFile
; ---------------------------------------------------------------------------

breakok:                                ; CODE XREF: doconf+4FE↑j
                lds     dx, cs:DevEntry ; set ds:dx to header
                assume ds:nothing
                mov     si, dx
                les     di, cs:DOSINFO  ; es:di point to dos info
                mov     ax, [si+4]      ; [si+SYSDEV.ATT] ; get attributes
                test    ax, 8000h       ; DEVTYP ; test if block dev
                jz      short isblock
                or      cs:setdevmarkflag, 2 ; for_devmark
                call    DevSetBreak     ; go ahead and alloc mem for device

jc_edd:                                 ; CODE XREF: doconf+56F↓j
                jb      short erase_dev_do ; device driver's init routine failed.
                test    ax, 1           ; ISCIN ; is it a console in?
                jz      short tryclk
                mov     es:[di+0Ch], dx ; [es:di+SYSI_CON]
                mov     word ptr es:[di+0Eh], ds ; [es:di+SYSI_CON+2]

tryclk:                                 ; CODE XREF: doconf+527↑j
                test    ax, 8           ; ISCLOCK ; is it a clock device?
                jz      short golink
                mov     es:[di+8], dx   ; [es:di+SYSI_CLOCK]
                mov     word ptr es:[di+0Ah], ds ; [es:di+SYSI_CLOCK+2]

golink:                                 ; CODE XREF: doconf+534↑j
                jmp     linkit
; ---------------------------------------------------------------------------

isblock:                                ; CODE XREF: doconf+517↑j
                mov     al, cs:unitcount
                or      al, al          ; if no units found, erase the device
                jz      short erase_dev_do
                mov     [si+0Ah], al    ; [si+SYSDEV.NAME]
                                        ; number of units in name field
                add     cs:drivers_units, al ; keep total for all drivers in file

perdrv:                                 ; warning no device > 127 units
                cbw
                mov     cx, ax
                mov     dh, ah
                mov     dl, es:[di+20h] ; [es:di+SYSI_NUMIO]
                                        ; get number of devices
                mov     ah, dl
                add     ah, al          ; check for too many devices
                cmp     ah, 26          ; 'A' - 'Z' is 26 devices
                jbe     short ok_block
                jmp     badnumblock
; ---------------------------------------------------------------------------

ok_block:                               ; CODE XREF: doconf+561↑j
                or      cs:setdevmarkflag, 2 ; for_devmark
                call    DevSetBreak     ; alloc the device
                jb      short jc_edd
                add     es:[di+20h], al ; [es:di+SYSI_NUMIO]
                                        ; update the amount
                add     cs:drivenumber, al ; remember amount for next device
                lds     bx, cs:bpb_addr ; point to bpb array

perunit:                                ; CODE XREF: doconf+61B↓j
                les     bp, cs:DOSINFO
                les     bp, es:[bp+0]   ; [es:bp+SYSI_DPB] ; get first dpb

scandpb:                                ; CODE XREF: doconf+593↓j
                cmp     word ptr es:[bp+19h], 0FFFFh ; [es:bp+DPB.NEXT_DPB],-1
                jz      short foundpb
                les     bp, es:[bp+19h] ; [es:bp+DPB.NEXT_DPB] ; [es:bp+25]
                jmp     short scandpb
; ---------------------------------------------------------------------------

foundpb:                                ; CODE XREF: doconf+58D↑j
                mov     ax, word ptr cs:DevBrkAddr
                mov     es:[bp+19h], ax ; [es:bp+DPB.NEXT_DPB]
                mov     ax, word ptr cs:DevBrkAddr+2
                mov     es:[bp+1Bh], ax ; [es:bp+DPB.NEXT_DPB+2]
                les     bp, cs:DevBrkAddr
                add     word ptr cs:DevBrkAddr, 61 ; DPBSIZ = 61
                                        ; (33 in MSDOS 6.21 IO.SYS)
                call    RoundBreakAddr
                mov     word ptr es:[bp+19h], 0FFFFh ; [es:bp+DPB.NEXT_DPB],-1
                mov     byte ptr es:[bp+18h], 0FFh ; [es:bp+DPB.FIRST_ACCESS],-1 ; byte
                mov     si, [bx]        ; ds:si points to bpb
                inc     bx
                inc     bx              ; point to next bpb
                mov     es:[bp+0], dx   ; [es:bp+DPB.DRIVE]
                push    dx
                push    cx              ; initialize FAT32 extended DPB parameters/fields
                mov     dx, 4152h       ; 'AR' signature for FAT32 extended DPB
                xor     cx, cx          ; 0
                mov     es:[bp+1Dh], cx ; DPB.NEXT_FREE ; last allocated cluster #
                cmp     [si+0Bh], cx    ; BPB.fatsecs16 ; [si+A_BPB.BPB_SECTORSPERFAT]
                jnz     short setdpb    ; FAT DPB (33 bytes)   -jnz-
                                        ; FAT32 DPB (61 bytes) -jz-
                mov     es:[bp+39h], cx ; DPB.RESERVED = 0
                mov     es:[bp+3Bh], cx ; DPB.RESERVED+2 = 0
                dec     cx              ; 0FFFFh ; -1
                mov     es:[bp+1Fh], cx ; DPB.FREE_CNT (-1 = unknown)
                mov     es:[bp+21h], cx ; DPB.FREE_CNT+2 (-1 = unknown)
                mov     cx, 4558h       ; 'EX' signature for FAT32 extended DPB

setdpb:                                 ; CODE XREF: doconf+5D4↑j
                mov     ah, 53h         ; SETDPB ; hidden system call
                int     21h             ; DOS - 2+ internal - TRANSLATE BIOS PARAMETER BLOCK
                                        ; DS:SI -> BPB (BIOS Parameter Block)
                                        ; ES:BP -> buffer for DOS Drive Parameter Block
                                        ; (if CX=4558h & DX=4152h, FAT32 Extd/PCDOS7.1 DPB will be set)
                                        ; ((if DX=4152h but CX<>4558h, FAT Extd/PCDOS7.1 DPB will be set))
                pop     cx
                pop     dx
                mov     ax, es:[bp+2]   ; [es:bp+DPB.SECTOR_SIZE]
                push    es
                les     di, cs:DOSINFO  ; es:di point to dos info
                cmp     ax, es:[di+10h] ; [es:di+SYSI_MAXSEC]
                pop     es
                jbe     short iblk_1
                jmp     bad_bpb_size_sector
; ---------------------------------------------------------------------------

iblk_1:                                 ; CODE XREF: doconf+5FF↑j
                push    ds
                push    dx
                lds     dx, cs:DevEntry
                mov     es:[bp+13h], dx ; [es:bp+DPB.DRIVER_ADDR]
                mov     word ptr es:[bp+15h], ds ; [es:bp+DPB.DRIVER_ADDR+2]
                pop     dx
                pop     ds
                inc     dx
                inc     dh
                dec     cx              ; cx = cx - 1
                                        ; cx = remain count from [cs:unitcount]
                jz      short iblk_2    ; cx = 0 -> done
                jmp     perunit         ; loop until cx is 0
; ---------------------------------------------------------------------------

iblk_2:                                 ; CODE XREF: doconf+619↑j
                push    cs
                pop     ds
                assume ds:SYSINIT
                call    TempCDS         ; set cds for new drives

linkit:                                 ; CODE XREF: doconf:golink↑j
                les     di, cs:DOSINFO  ; es:di = dos table
                mov     cx, es:[di+22h] ; [es:di+SYSI_DEV] ; dx:cx = head of list
                mov     dx, es:[di+24h] ; [es:di+SYSI_DEV+2]
                lds     si, cs:DevEntry ; ds:si = device location
                assume ds:nothing
                mov     es:[di+22h], si ; set head of list in dos
                                        ; [es:di+SYSI_DEV]
                mov     word ptr es:[di+24h], ds ; [es:di+SYSI_DEV+2]
                mov     ax, [si]        ; get pointer to next device
                mov     word ptr cs:DevEntry, ax ; and save it
                mov     [si], cx        ; link in the driver
                mov     [si+2], dx
                pop     si
                pop     es
                inc     ax              ; ax = 0FFFFh (no more devs if yes)?
                jz      short coffj3
                inc     cs:multdeviceflag ; possibly multiple device driver.
                call    DevBreak
                jmp     goodld          ; otherwise pretend we loaded it in
; ---------------------------------------------------------------------------

coffj3:                                 ; CODE XREF: doconf+64B↑j
                mov     cs:multdeviceflag, 0 ; reset the flag
                call    DevBreak
                call    CheckProtmanArena

CheckDoubleSpace:                       ; inquire of MagicDrv whether it is present,
                test    cs:MagicHomeFlag, 1 ; and final located
                jnz     short no_more_magic_calls ; already home?
                                        ; nothing more to do if so
                call    get_dblspace_version ; is it there?
                jnz     short set_magichomeflag ; done if not
                test    dx, 8000h       ; is it final placed?
                jnz     short magic_not_yet_home
                add     cs:drivenumber, ch ; add number of MagicDrv volumes to
                                        ; the drive number we'll pass to the
                                        ; next loadable block device.

set_magichomeflag:                      ; CODE XREF: doconf+66F↑j
                mov     cs:MagicHomeFlag, 1 ; set the flag!
                jmp     coff
; ---------------------------------------------------------------------------

magic_not_yet_home:                     ; CODE XREF: doconf+675↑j
                push    es
                push    si
                mov     ax, cs:memhi    ; pass it a work buffer
                mov     dx, cs:ALLOCLIM ; address in cx (segment)
                sub     dx, ax          ; for len dx (paragraphs)
                mov     bx, 2
                mov     al, cs:drivers_units ; shuffle magicdrives and new drives
                                        ; by this many units
                mov     ah, 55h         ; backdoor won't shuffle unless it
                                        ; sees this, to prevent bad things
                                        ; from happening if people run the
                                        ; new driver with an old (dos) BIOS
                call    cs:MagicBackdoor
                pop     si
                pop     es

no_more_magic_calls:                    ; CODE XREF: doconf+66A↑j
                jmp     coff
; ---------------------------------------------------------------------------

bad_bpb_size_sector:                    ; CODE XREF: doconf+601↑j
                pop     si
                pop     es
                mov     dx, offset badsiz_pre ; "\r\nSector size too large in file $"
                mov     bx, offset crlfm ; "\r\n$"
                call    prnerr
                jmp     coff
; ---------------------------------------------------------------------------

tryq:                                   ; CODE XREF: doconf:skip_it2↑j
                cmp     ah, 51h ; 'Q'   ; CONFIG_COUNTRY
                jz      short tryq_cont

skip_it3:                               ; CODE XREF: doconf+6BE↓j
                jmp     tryf
; ---------------------------------------------------------------------------

tryq_cont:                              ; CODE XREF: doconf+6B6↑j
                call    query_user      ; query the user if config_cmd
                                        ; has the CONFIG_OPTION_QUERY bit set
                jb      short skip_it3
                mov     byte ptr cs:cntry_drv, 0 ;
                                        ; reset the drive,path to default value.
                mov     cs:p_code_page, 0
                mov     di, offset cntry_parms
                xor     cx, cx
                mov     dx, cx

do52:                                   ; CODE XREF: doconf:en56↓j
                call    sysinit_parse
                jnb     short if52      ; parse error,check error code and
                call    cntry_error     ; show message and end the search loop.
                mov     cs:p_cntry_code, 0FFFFh ; -1 ; signals that parse error.
                jmp     short sr52
; ---------------------------------------------------------------------------

if52:                                   ; CODE XREF: doconf+6D7↑j
                cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
                jz      short sr52
                cmp     cs:result_val, 1 ; _$P_Number
                jnz     short if56
                mov     ax, word ptr cs:rv_dword ;
                                        ; [cs:result_val+_$P_Result_Blk.Picked_Val]
                cmp     cx, 1
                jnz     short if57
                mov     cs:p_cntry_code, ax
                jmp     short en57
; ---------------------------------------------------------------------------

if57:                                   ; CODE XREF: doconf+6F9↑j
                mov     cs:p_code_page, ax

en57:                                   ; CODE XREF: doconf+6FF↑j
                jmp     short en56      ; path entered
; ---------------------------------------------------------------------------

if56:                                   ; CODE XREF: doconf+6F0↑j
                push    ds
                push    es
                push    si
                push    di
                push    cs
                pop     es
                assume es:SYSINIT
                lds     si, cs:rv_dword ; move the path to known place.
                mov     di, offset cntry_drv ; "A:"
                call    move_asciiz
                pop     di
                pop     si
                pop     es
                assume es:nothing
                pop     ds

en56:                                   ; CODE XREF: doconf:en57↑j
                jmp     short do52
; ---------------------------------------------------------------------------

sr52:                                   ; CODE XREF: doconf+6E3↑j
                                        ; doconf+6E8↑j
                cmp     cs:p_cntry_code, 0FFFFh ; -1 ; had a parse error?
                jnz     short tryq_open
                jmp     coff
; ---------------------------------------------------------------------------

tryqbad:                                ; CODE XREF: doconf+78F↓j
                stc
                mov     dx, offset badcountry ; "\r\nInvalid country code or code page\r"...
                jmp     tryqchkerr
; ---------------------------------------------------------------------------

tryq_open:                              ; CODE XREF: doconf+724↑j
                cmp     byte ptr cs:cntry_drv, 0 ; "A:"
                jz      short tryq_def
                mov     dx, offset cntry_drv ; "A:"
                jmp     short tryq_openit
; ---------------------------------------------------------------------------

tryq_def:                               ; CODE XREF: doconf+736↑j
                mov     dx, offset cntry_root

tryq_openit:                            ; CODE XREF: doconf+73B↑j
                mov     ax, 3D00h       ; open a file
                stc
                int     21h             ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
                                        ; DS:DX -> ASCIZ filename
                                        ; AL = access mode
                                        ; 0 - read
                jb      short tryqfilebad
                mov     cs:cntryfilehandle, ax ; save file handle
                mov     bx, ax
                mov     ax, cs:p_cntry_code
                mov     dx, cs:p_code_page ; ax=country id, bx=filehandle
                mov     cx, cs:memhi
                add     cx, 384         ; need 6k buffer to handle country.sys
                                        ; (384*16 bytes)
                cmp     cx, cs:ALLOCLIM
                ja      short tryqmemory ; cannot allocate the buffer for country.sys
                mov     si, offset cntry_drv ; "A:"
                cmp     byte ptr [si], 0 ; default path?
                jnz     short tryq_set_for_dos ; no
                inc     si
                inc     si              ; ds:si -> cntry_root

tryq_set_for_dos:                       ; CODE XREF: doconf+76D↑j
                les     di, cs:sysi_country ; es:di -> country info tab in dos
                push    di              ; save di
                add     di, 8           ; country_cdpg_info.ccPath_CountrySys
                call    move_asciiz     ; set the path to country.sys in dos.
                pop     di              ; es:di -> country info tab again.
                mov     cx, cs:memhi
                mov     ds, cx
                xor     si, si          ; ds:si -> 2k buffer to be used.
                call    setdoscountryinfo ; now do the job!
                jnb     short tryqchkerr ; read error or could not find country,
                                        ; code page combination
                cmp     cx, 0FFFFh      ; -1
                                        ; could not find matching country_id, code page?
                jz      short tryqbad   ; then "invalid country code or code page"

tryqfilebad:                            ; CODE XREF: doconf+746↑j
                push    cs
                pop     es
                assume es:SYSINIT
                cmp     byte ptr cs:cntry_drv, 0 ; is the default file used?
                jz      short tryqdefbad
                mov     si, offset cntry_drv ; "A:"
                jmp     short tryqbadload
; ---------------------------------------------------------------------------

tryqdefbad:                             ; CODE XREF: doconf+799↑j
                mov     si, offset cntry_root ; default file has been used.
                                        ; es:si -> \country.sys in sysinit_seg

tryqbadload:                            ; CODE XREF: doconf+79E↑j
                call    badload
                mov     cx, cs:CONFBOT
                mov     es, cx          ; restore es -> confbot.
                assume es:nothing
                jmp     short coffj4
; ---------------------------------------------------------------------------

tryqmemory:                             ; CODE XREF: doconf+765↑j
                mov     dx, offset insufmemory ; "\r\nInsufficient memory for COUNTRY.SYS"...

tryqchkerr:                             ; CODE XREF: doconf+72D↑j
                                        ; doconf+78A↑j
                mov     cx, cs:CONFBOT
                mov     es, cx          ; restore es -> confbot seg
                push    cs
                pop     ds              ; restore ds to sysinit_seg
                assume ds:SYSINIT
                jnb     short coffj4    ; if no error,then exit
                call    print           ; else show error message
                call    error_line

coffj4:                                 ; CODE XREF: doconf+7AD↑j
                                        ; doconf+7BB↑j
                mov     bx, cs:cntryfilehandle ; close a file.
                                        ; don't care even if it fails.
                mov     ah, 3Eh
                int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
                                        ; BX = file handle
                jmp     coff
; END OF FUNCTION CHUNK FOR doconf

; =============== S U B R O U T I N E =======================================


cntry_error     proc near               ; CODE XREF: doconf+6D9↑p
                cmp     ax, 6           ; _$P_Out_Of_Range
                jnz     short if64
                mov     dx, offset badcountry ; "\r\nInvalid country code or code page\r"...
                jmp     short en64
; ---------------------------------------------------------------------------

if64:                                   ; CODE XREF: cntry_error+3↑j
                mov     dx, offset badcountrycom ; "\r\nError in COUNTRY command\r\n$"

en64:                                   ; CODE XREF: cntry_error+8↑j
                call    print
                call    error_line
                retn
cntry_error     endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR doconf

tryf:                                   ; CODE XREF: doconf:skip_it3↑j
                cmp     ah, 46h ; 'F'   ; CONFIG_FILES
                jnz     short tryl
                call    query_user      ; query the user if config_cmd
                                        ; has the CONFIG_OPTION_QUERY bit set
                jb      short tryl
                mov     di, offset files_parms
                xor     cx, cx
                mov     dx, cx

do67:                                   ; CODE XREF: doconf+80B↓j
                call    sysinit_parse
                jnb     short if67      ;
                                        ; parse error
                                        ; show messages and end the search loop.
                call    badparm_p
                jmp     short sr67
; ---------------------------------------------------------------------------

if67:                                   ; CODE XREF: doconf+7F7↑j
                cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
                jz      short en67      ; then end the $endloop
                mov     al, byte ptr cs:rv_dword ;
                                        ; [result_val+_$P_Result_Blk.Picked_Val]
                mov     cs:p_files, al  ; save it temporarily
                jmp     short do67
; ---------------------------------------------------------------------------

en67:                                   ; CODE XREF: doconf+801↑j
                mov     al, cs:p_files
                mov     cs:FILES, al    ; no error. really set the value now.

sr67:                                   ; CODE XREF: doconf+7FC↑j
                jmp     coff
; ---------------------------------------------------------------------------

tryl:                                   ; CODE XREF: doconf+7E6↑j
                                        ; doconf+7EB↑j
                cmp     ah, 4Ch ; 'L'   ; CONFIG_LASTDRIVE
                jnz     short tryp
                call    query_user      ; query the user if config_cmd
                                        ; has the CONFIG_OPTION_QUERY bit set
                jb      short tryp
                mov     di, offset ldrv_parms
                xor     cx, cx
                mov     dx, cx

do73:                                   ; CODE XREF: doconf+840↓j
                call    sysinit_parse
                jnb     short if73      ;
                                        ; parse error
                                        ; show messages and end the search loop.
                call    badparm_p
                jmp     short badparm_p_coff
; ---------------------------------------------------------------------------

if73:                                   ; CODE XREF: doconf+82C↑j
                cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
                jz      short en73      ; then end the $endloop
                mov     al, byte ptr cs:rv_dword ; [rv_byte]
                                        ; pick up the drive number
                mov     cs:p_ldrv, al   ; save it temporarily
                jmp     short do73
; ---------------------------------------------------------------------------

en73:                                   ; CODE XREF: doconf+836↑j
                mov     al, cs:p_ldrv
                mov     cs:NUM_CDS, al  ; no error.
                                        ; really set the value now.

badparm_p_coff:                         ; CODE XREF: doconf+831↑j
                jmp     coff
; ---------------------------------------------------------------------------

tryp:                                   ; CODE XREF: doconf+81B↑j
                                        ; doconf+820↑j
                cmp     ah, 50h ; 'P'   ; CONFIG_DRIVPARM
                jnz     short tryk
                call    query_user      ; query the user if config_cmd
                                        ; has the CONFIG_OPTION_QUERY bit set
                jb      short tryk
                call    parseline
                jb      short trypbad
                call    setparms
                call    diddleback
                jmp     coff
; ---------------------------------------------------------------------------

trypbad:                                ; CODE XREF: doconf+85A↑j
                jmp     badop
; ---------------------------------------------------------------------------

tryk:                                   ; CODE XREF: doconf+850↑j
                                        ; doconf+855↑j
                cmp     ah, 4Bh ; 'K'   ; CONFIG_STACKS
                jz      short do_tryk

skip_it4:                               ; CODE XREF: doconf+873↓j
                jmp     trys
; ---------------------------------------------------------------------------

do_tryk:                                ; CODE XREF: doconf+86B↑j
                call    query_user      ; query the user if config_cmd
                                        ; has the CONFIG_OPTION_QUERY bit set
                jb      short skip_it4
                mov     di, offset stks_parms
                xor     cx, cx
                mov     dx, cx

do79:                                   ; CODE XREF: doconf:en83↓j
                call    sysinit_parse
                jnb     short if79      ; parse error
                mov     dx, offset badstack ; "\r\nInvalid STACK parameters\r\n$"
                call    print           ; show messages and end the search loop.
                call    error_line
                jmp     sr79            ; (jmp coff)
; ---------------------------------------------------------------------------

if79:                                   ; CODE XREF: doconf+87F↑j
                cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
                jz      short en79      ; then end the $endloop
                mov     ax, word ptr cs:rv_dword ;
                                        ; [cs:result_val+_$P_Result_Blk.Picked_Val]
                cmp     cx, 1
                jnz     short if83
                mov     cs:p_stack_count, ax
                jmp     short en83
; ---------------------------------------------------------------------------

if83:                                   ; CODE XREF: doconf+899↑j
                mov     cs:p_stack_size, ax

en83:                                   ; CODE XREF: doconf+89F↑j
                jmp     short do79
; ---------------------------------------------------------------------------

en79:                                   ; CODE XREF: doconf+890↑j
                cmp     cs:p_stack_count, 0
                jz      short if87
                cmp     cs:p_stack_count, 8 ; mincount
                jb      short ll88
                cmp     cs:p_stack_size, 32 ; minsize
                jnb     short if88

ll88:                                   ; CODE XREF: doconf+8B5↑j
                mov     cs:p_stack_count, 0FFFFh ; -1 ; invalid

if88:                                   ; CODE XREF: doconf+8BD↑j
                jmp     short en87
; ---------------------------------------------------------------------------

if87:                                   ; CODE XREF: doconf+8AD↑j
                cmp     cs:p_stack_size, 0
                jz      short en87
                mov     cs:p_stack_count, 0FFFFh ; -1 ; invalid

en87:                                   ; CODE XREF: doconf:if88↑j
                                        ; doconf+8CE↑j
                cmp     cs:p_stack_count, 0FFFFh ; -1 ; invalid?
                jnz     short if94
                mov     cs:stack_count, 9 ; defaultcount
                                        ; reset to default value.
                mov     cs:stack_size, 128 ; defaultsize
                mov     cs:stack_addr, 0 ; stacks= been accepted.
                mov     dx, offset badstack ; "\r\nInvalid STACK parameters\r\n$"
                call    print
                call    error_line
                jmp     short sr79
; ---------------------------------------------------------------------------

if94:                                   ; CODE XREF: doconf+8DD↑j
                mov     ax, cs:p_stack_count
                mov     cs:stack_count, ax
                mov     ax, cs:p_stack_size
                mov     cs:stack_size, ax
                mov     cs:stack_addr, 0FFFFh ; -1 ; stacks= been accepted.

sr79:                                   ; CODE XREF: doconf+88A↑j
                                        ; doconf+8FD↑j
                jmp     coff
; ---------------------------------------------------------------------------

trys:                                   ; CODE XREF: doconf:skip_it4↑j
                cmp     ah, 53h ; 'S'   ; CONFIG_SHELL
                jnz     short tryx
                call    query_user      ; query the user if config_cmd
                                        ; has the CONFIG_OPTION_QUERY bit set
                jb      short tryx
                mov     cs:newcmd, 1
                mov     word ptr cs:command_line, 0 ;
                                        ; zap length, first byte of command-line
                mov     di, (offset commnd+1) ; we already have the first char
                mov     [di-1], al      ; of the new shell in AL, save it now

storeshell:                             ; CODE XREF: doconf+948↓j
                call    getchr
                or      al, al          ; this is the normal case: "organize"
                jz      short getshparms ; put a ZERO right after the filename
                cmp     al, 20h ; ' '   ; this may happen if there are no args
                jb      short endofshell ; I suppose...
                mov     [di], al
                inc     di
                cmp     di, offset commnd_63 ; commnd+63
                                        ; this makes sure we don't overflow
                                        ; commnd (the filename)
                jb      short storeshell
                jmp     short endofshell
; ---------------------------------------------------------------------------

getshparms:                             ; CODE XREF: doconf+93B↑j
                mov     byte ptr [di], 0 ; zero-terminate the filename
                mov     di, (offset command_line+1) ;
                                        ; prepare to process the command-line

parmloop:                               ; CODE XREF: doconf+960↓j
                call    getchr
                cmp     al, 20h ; ' '
                jb      short endofparms
                mov     [di], al
                inc     di
                cmp     di, offset command_line_126 ; command_line+126
                jb      short parmloop

endofparms:                             ; CODE XREF: doconf+957↑j
                mov     cx, di
                sub     cx, (offset command_line+1) ; "/P"
                mov     byte ptr cs:command_line, cl ; "\x02/P"

endofshell:                             ; CODE XREF: doconf+93F↑j
                                        ; doconf+94A↑j
                mov     byte ptr [di], 0 ; zero-terminate the filename
                                        ; (or the command-line as the case may be)

skipline:                               ; CODE XREF: doconf+977↓j
                cmp     al, 0Ah         ; lf ; the safest way to eat the rest of
                jz      short endofline ; the line: watch for ever-present LF
                call    getchr
                jnb     short skipline

endofline:                              ; CODE XREF: doconf+972↑j
                jmp     conflp
; ---------------------------------------------------------------------------

tryx:                                   ; CODE XREF: doconf+91C↑j
                                        ; doconf+921↑j
                cmp     ah, 58h ; 'X'   ; CONFIG_FCBS
                jnz     short try1
                call    query_user      ; query the user if config_cmd
                                        ; has the CONFIG_OPTION_QUERY bit set
                jb      short try1
                mov     di, offset fcbs_parms
                xor     cx, cx
                mov     dx, cx

do98:                                   ; CODE XREF: doconf:en102↓j
                call    sysinit_parse
                jnb     short if98
                call    badparm_p       ; parse error
                                        ; show messages and end the search loop.
                jmp     short sr98
; ---------------------------------------------------------------------------

if98:                                   ; CODE XREF: doconf+990↑j
                cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
                jz      short en98      ; then end the $endloop
                mov     al, byte ptr cs:rv_dword ;
                                        ; [cs:result_val+_$P_Result_Blk.Picked_Val]
                cmp     cx, 1           ; the first positional?
                jnz     short if102
                mov     cs:p_fcbs, al
                jmp     short en102
; ---------------------------------------------------------------------------

if102:                                  ; CODE XREF: doconf+9A3↑j
                mov     cs:p_keep, al

en102:                                  ; CODE XREF: doconf+9A9↑j
                jmp     short do98
; ---------------------------------------------------------------------------

en98:                                   ; CODE XREF: doconf+99A↑j
                mov     al, cs:p_fcbs
                mov     cs:FCBS, al
                mov     cs:KEEP, 0

sr98:                                   ; CODE XREF: doconf+995↑j
                jmp     coff
; ---------------------------------------------------------------------------

try1:                                   ; CODE XREF: doconf+97F↑j
                                        ; doconf+984↑j
                cmp     ah, 31h ; '1'   ; CONFIG_SWITCHES
                                        ; switches= command entered?
                jz      short do_try1   ; yes

skip_it5:                               ; CODE XREF: doconf+9CD↓j
                jmp     tryv
; ---------------------------------------------------------------------------

do_try1:                                ; CODE XREF: doconf+9C5↑j
                call    query_user      ; query the user if config_cmd
                                        ; has the CONFIG_OPTION_QUERY bit set
                jb      short skip_it5
                mov     di, offset swit_parms
                xor     cx, cx
                mov     dx, cx

do110:                                  ; CODE XREF: doconf+9F5↓j
                                        ; doconf+A06↓j ...
                call    sysinit_parse
                jnb     short if110     ;
                                        ; parse error
                                        ; show messages and end the search loop.
                call    badparm_p
                jmp     sr110
; ---------------------------------------------------------------------------

if110:                                  ; CODE XREF: doconf+9D9↑j
                cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
                jz      short en110     ; then jmp to $endloop for semantic check
                cmp     cs:result_val_swoff, offset swit_k ; offset "/K"
                                        ; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
                jnz     short if115
                mov     cs:p_swit_k, 1  ; set the flag
                jmp     short do110
; ---------------------------------------------------------------------------

if115:                                  ; CODE XREF: doconf+9ED↑j
                cmp     cs:result_val_swoff, offset swit_t ; offset "/T"
                                        ; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
                jnz     short if118
                mov     cs:p_swit_t, 1  ; set the flag
                jmp     short do110
; ---------------------------------------------------------------------------

if118:                                  ; CODE XREF: doconf+9FE↑j
                cmp     cs:result_val_swoff, offset swit_i ; offset "/I"
                                        ; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
                jnz     short if116
                mov     cs:p_swit_i, 1  ; set the flag
                jmp     short do110
; ---------------------------------------------------------------------------

if116:                                  ; CODE XREF: doconf+A0F↑j
                cmp     cs:result_val_swoff, offset swit_w ; offset "/W"
                                        ; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
                jnz     short do110
                mov     cs:p_swit_w, 1  ; set the flag
                jmp     short do110
; ---------------------------------------------------------------------------

en110:                                  ; CODE XREF: doconf+9E4↑j
                cmp     cs:p_swit_k, 1  ; if /k entered,
                push    ds
                mov     ax, 70h         ; DOSBIODATASEG ; BIOSDATA segment
                mov     ds, ax
                assume ds:nothing
                jnz     short if117
                mov     ds:keyrd_func, 0 ; BIOSDATA:047Eh
                                        ; use the conventional keyboard functions
                mov     ds:keysts_func, 1 ; BIOSDATA:047Fh

if117:                                  ; CODE XREF: doconf+A36↑j
                mov     al, cs:p_swit_t
                mov     ds:t_switch, al
                cmp     cs:p_swit_w, 0
                jz      short if119
                push    es
                push    bx
                mov     ah, 52h         ; GET_IN_VARS
                int     21h             ; DOS - 2+ internal - GET LIST OF LISTS
                                        ; Return: ES:BX -> DOS list of lists
                or      byte ptr es:86h, 2 ; [es:DOS_FLAG_OFFSET], SUPPRESS_WINA20
                pop     bx
                pop     es

if119:                                  ; CODE XREF: doconf+A4F↑j
                cmp     cs:p_swit_i, 0  ; if /i entered ; new switch for PCDOS 7.1
                jz      short skip_dos_flag
                push    es
                push    bx
                mov     ah, 52h
                int     21h             ; DOS - 2+ internal - GET LIST OF LISTS
                                        ; Return: ES:BX -> DOS list of lists
                or      byte ptr es:86h, 40h ; set DOS_FLAG bit 6
                pop     bx
                pop     es

skip_dos_flag:                          ; CODE XREF: doconf+A65↑j
                pop     ds
                assume ds:nothing

sr110:                                  ; CODE XREF: doconf+9DE↑j
                                        ; doconf+A86↓j ...
                jmp     coff
; ---------------------------------------------------------------------------

tryv:                                   ; CODE XREF: doconf:skip_it5↑j
                cmp     ah, 56h ; 'V'   ; CONFIG_SET ; set var=value<cr/lf>
                jnz     short tryn
                call    query_user      ; query the user if config_cmd
                                        ; has the CONFIG_OPTION_QUERY bit set
                jb      short tryn
                call    copy_envvar     ; copy var at ES:SI to "config_wrkseg"
                jnb     short sr110     ; no error

err:                                    ; CODE XREF: doconf+A9A↓j
                call    error_line      ; whoops, display error in line XXX
                jmp     short sr110     ; jump to coff (to skip to next line)
; ---------------------------------------------------------------------------

tryn:                                   ; CODE XREF: doconf+A7C↑j
                                        ; doconf+A81↑j
                cmp     ah, 4Eh ; 'N'   ; CONFIG_NUMLOCK ; numlock=on|off
                jnz     short tryt
                call    query_user      ; query the user if config_cmd
                                        ; has the CONFIG_OPTION_QUERY bit set
                jb      short tryt
                call    set_numlock
                jb      short err
                jmp     short sr110     ; all done
; ---------------------------------------------------------------------------

tryt:                                   ; CODE XREF: doconf+A90↑j
                                        ; doconf+A95↑j
                cmp     ah, 54h ; 'T'   ; CONFIG_DOSDATA ; PCDOS 7 new config cmd
                jnz     short tryy
                call    query_user
                jb      short tryy
                mov     di, offset dosdata_parms
                xor     cx, cx
                mov     dx, cx

do120:                                  ; CODE XREF: doconf:sr120↓j
                call    sysinit_parse
                jnb     short if120
                call    badparm_p
                jmp     short en120
; ---------------------------------------------------------------------------

if120:                                  ; CODE XREF: doconf+AB2↑j
                cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
                jz      short en120
                cmp     ds:result_val_itag, 1 ; tag 1 (UMB)
                                        ; [result_val+_$P_Result_Blk.Item_Tag]
                jnz     short if121
                mov     ds:dosdata_umb, 1 ; DOSDATA=UMB (1) NOUMB (0)
                jmp     short sr120
; ---------------------------------------------------------------------------

if121:                                  ; CODE XREF: doconf+AC3↑j
                mov     ds:dosdata_umb, 0 ; DOSDATA=UMB (1) NOUMB (0)

sr120:                                  ; CODE XREF: doconf+ACA↑j
                jmp     short do120
; ---------------------------------------------------------------------------

en120:                                  ; CODE XREF: doconf+AB7↑j
                                        ; doconf+ABC↑j
                jmp     coff
; ---------------------------------------------------------------------------

tryy:                                   ; CODE XREF: doconf+AA1↑j
                                        ; doconf+AA6↑j
                cmp     ah, 59h ; 'Y'   ; CONFIG_COMMENT
                                        ; (do nothing with this line.)
                jnz     short try0

donothing:                              ; CODE XREF: doconf+AE9↓j
                                        ; doconf+AEE↓j
                dec     ds:chrptr
                inc     ds:count
                jmp     coff
; ---------------------------------------------------------------------------

try0:                                   ; CODE XREF: doconf+AD9↑j
                cmp     ah, 30h ; '0'   ; CONFIG_REM
                                        ; (do nothing with this line.)
                jz      short donothing
                cmp     ah, 0FFh        ; null/bogus command?
                jz      short donothing
                dec     ds:chrptr
                inc     ds:count
                jmp     short badop
; END OF FUNCTION CHUNK FOR doconf

; =============== S U B R O U T I N E =======================================


CheckProtmanArena proc near             ; CODE XREF: doconf+661↑p
                push    es              ; adjusts alloclim if Protman$
                                        ; reduced our arena through a manual hack
                mov     ax, cs:area     ; get our arena header
                dec     ax
                mov     es, ax
                add     ax, es:3        ; [es:ARENA.SIZE] ; find end of arena
                inc     ax
                cmp     ax, cs:ALLOCLIM
                ja      short CheckProtmanDone
                mov     cs:ALLOCLIM, ax

CheckProtmanDone:                       ; CODE XREF: CheckProtmanArena+13↑j
                pop     es
                retn
CheckProtmanArena endp


; =============== S U B R O U T I N E =======================================


sysinit_parse   proc near               ; CODE XREF: doconf:do7↑p
                                        ; doconf:do22↑p ...
                push    es              ; set up registers for sysparse
                                        ; in:
                                        ;    es:si -> command line in confbot
                                        ;       di -> offset of the parse control definition.
                                        ; out:
                                        ;    calls sysparse.
                                        ;    carry will set if parse error.
                                        ;    *** the caller should check the eol condition by looking at ax
                                        ;    *** after each call.
                                        ;    *** if no parameters are found,then ax will contain a error code.
                                        ;    *** if the caller needs to look at the synomym@ of the result,
                                        ;    *** the caller should use cs:@ instead of es:@.
                                        ;    cx should be set to 0 at the 1st time the caller calls this proc.
                                        ;    ax - exit code
                                        ;    bl - terminated delimeter code
                                        ;    cx - new positional ordinal
                                        ;    si - set to pase scanned operand
                                        ;    dx - selected result buffer
                push    ds
                push    es              ; now ds:si -> command line
                pop     ds
                push    cs
                pop     es              ; now es:di -> control definition
                assume es:SYSINIT
                mov     word ptr cs:badparm_ptr+2, ds ; save the pointer to the parm
                mov     word ptr cs:badparm_ptr, si ; we are about to parse for badparm msg.
                mov     dx, 0
                call    SysParse
                cmp     ax, 0           ; _$P_No_Error ; no error
                jz      short ll4       ; cf=0
                cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
                jnz     short if4       ; or the end of line?

ll4:                                    ; CODE XREF: sysinit_parse+19↑j
                clc
                jmp     short en4
; ---------------------------------------------------------------------------

if4:                                    ; CODE XREF: sysinit_parse+1E↑j
                stc

en4:                                    ; CODE XREF: sysinit_parse+21↑j
                pop     ds
                pop     es
                assume es:nothing
                retn
sysinit_parse   endp

; ---------------------------------------------------------------------------

badop_p:                                ; 'badop_p' is not used in
                push    cs              ; MSDOS 6.21 IO.SYS and PCDOS 7.1 IBMBIO.COM
                                        ; (but it was/is not removed)
                                        ; Erdogan Tan - 11/07/2023
                pop     ds
                assume ds:SYSINIT
                mov     dx, offset badopm ; "\r\nUnrecognized command in CONFIG.SYS"
                call    print
                call    error_line
                retn
; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR doconf

badop:                                  ; CODE XREF: doconf+11F↑j
                                        ; doconf+409↑j ...
                mov     dx, offset badopm ; "\r\nUnrecognized command in CONFIG.SYS"
                call    print
                call    error_line
                jmp     coff
; END OF FUNCTION CHUNK FOR doconf

; =============== S U B R O U T I N E =======================================


badparm_p       proc near               ; CODE XREF: doconf+1E6↑p
                                        ; doconf+213↑p ...
                push    ds
                push    dx
                push    si
                push    cs
                pop     ds
                mov     dx, offset badparm ; "\r\nBad command or parameters - $"
                call    print
                lds     si, badparm_ptr
                assume ds:nothing

do1:                                    ; CODE XREF: badparm_p+1B↓j
                mov     dl, [si]        ; print "xxxx" until cr.
                cmp     dl, 0Dh         ; cr ?
                jz      short en1       ; yes
                mov     ah, 2           ; display character
                int     21h             ; DOS - DISPLAY OUTPUT
                                        ; DL = character to send to standard output
                inc     si
                jmp     short do1
; ---------------------------------------------------------------------------

en1:                                    ; CODE XREF: badparm_p+14↑j
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     dx, offset crlfm ; "\r\n$"
                call    print
                call    error_line
                pop     si
                pop     dx
                pop     ds
                assume ds:nothing
                retn
badparm_p       endp


; =============== S U B R O U T I N E =======================================


getchr          proc near               ; CODE XREF: multi_pass+20↑p
                                        ; doconf+C6↑p ...
                push    cx
                mov     cx, ds:count
                jcxz    short nochar
                mov     si, ds:chrptr
                mov     al, es:[si]
                dec     ds:count
                inc     ds:chrptr
                clc

get_ret:                                ; CODE XREF: getchr+1A↓j
                pop     cx
                retn
; ---------------------------------------------------------------------------

nochar:                                 ; CODE XREF: getchr+5↑j
                stc
                jmp     short get_ret
getchr          endp

; ---------------------------------------------------------------------------

incorrect_order:                        ; 'incorrect_order' is not used in
                mov     dx, offset badorder ; MSDOS 6.21 IO.SYS and PCDOS 7.1 IBMBIO.COM
                                        ; (but it was/is not removed)
                                        ; Erdogan Tan - 11/07/2023
                call    print
                call    showlinenum
                retn

; =============== S U B R O U T I N E =======================================


error_line      proc near               ; CODE XREF: doconf+4E8↑p
                                        ; doconf+7C0↑p ...
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     dx, offset errorcmd ; "Error in CONFIG.SYS line $"
                call    print
                call    showlinenum
                retn
error_line      endp


; =============== S U B R O U T I N E =======================================


showlinenum     proc near               ; CODE XREF: SYSINIT:3380↑p
                                        ; error_line+8↑p
                push    es
                push    ds
                push    di
                push    cs
                pop     es
                assume es:SYSINIT
                push    cs
                pop     ds
                mov     di, (offset showcount+4) ;
                                        ; di -> the least significant decimal field.
                mov     cx, 10
                mov     ax, cs:linecount ; (ds = cs !)

sln_loop:                               ; CODE XREF: showlinenum+20↓j
                cmp     ax, 10          ; < 10 ?
                jb      short sln_last  ; yes
                xor     dx, dx
                div     cx              ; cx = 10
                or      dl, 30h         ; convert to ascii numeric char ("0" to "9")
                mov     [di], dl
                dec     di
                jmp     short sln_loop
; ---------------------------------------------------------------------------

sln_last:                               ; CODE XREF: showlinenum+14↑j
                or      al, 30h         ; convert to ascii numeric char ("0" to "9")
                mov     [di], al
                mov     dx, di
                call    print           ; show it
                pop     di
                pop     ds
                assume ds:nothing
                pop     es
                assume es:nothing
                retn
showlinenum     endp


; =============== S U B R O U T I N E =======================================


ProcDOS         proc near               ; CODE XREF: doconf+2ED↑p
                xor     ah, ah
                mov     al, cs:result_val_itag ;
                                        ; [cs:result_val+_$P_Result_Blk.Item_Tag]
                                        ;
                                        ; result_val._$P_item_tag
                                        ;          = 1 for DOS=HIGH
                                        ;          = 2 for DOS=LOW
                                        ;          = 3 for DOS=UMB
                                        ;          = 4 for DOS=NOUMB
                dec     ax
                jz      short pd_hi
                dec     ax
                jz      short pd_lo
                dec     ax
                jz      short pd_umb
                mov     cs:DevUMB, 0
                retn
; ---------------------------------------------------------------------------

pd_umb:                                 ; CODE XREF: ProcDOS+D↑j
                mov     cs:DevUMB, 0FFh
                retn
; ---------------------------------------------------------------------------

pd_lo:                                  ; CODE XREF: ProcDOS+A↑j
                mov     cs:runhigh, 0
                retn
; ---------------------------------------------------------------------------

pd_hi:                                  ; CODE XREF: ProcDOS+7↑j
                mov     cs:runhigh, 0FFh
                retn
ProcDOS         endp


; =============== S U B R O U T I N E =======================================


LieInt12Mem     proc near               ; CODE XREF: doconf+44D↑p
                mov     ax, cs:ALLOCLIM ; lie INT 12h as alloclim
                                        ; assuming that it is 3Com
                call    IsIt3Com        ; Is it 3Com driver?
                jz      short lim_set   ; yes, lie to him differently
                cmp     cs:DeviceHi, 0  ; Is the DD being loaded in UMB
                jz      short limx      ; no, don't lie
                mov     ax, cs:DevLoadEnd ; lie INT 12h as end of UMB

lim_set:                                ; CODE XREF: LieInt12Mem+7↑j
                call    SetInt12Mem

limx:                                   ; CODE XREF: LieInt12Mem+F↑j
                retn
LieInt12Mem     endp


; =============== S U B R O U T I N E =======================================


SetInt12Mem     proc near               ; CODE XREF: LieInt12Mem:lim_set↑p
                push    ds
                mov     bx, 40h         ; ROMBIOS data area segment
                mov     ds, bx
                assume ds:nothing
                mov     bx, ds:13h      ; memory size (KB)
                mov     cs:OldInt12Mem, bx
                mov     cl, 6           ; 16*64 = 1024
                shr     ax, cl          ; convert paragraphs to kilobyte
                mov     ds:13h, ax
                mov     cs:Int12Lied, 0FFh ; mark that we are lying
                pop     ds
                assume ds:nothing
                retn
SetInt12Mem     endp


; =============== S U B R O U T I N E =======================================


TrueInt12Mem    proc near               ; CODE XREF: doconf+49F↑p
                cmp     cs:Int12Lied, 0 ; were we lying so far?
                mov     cs:Int12Lied, 0
                jz      short timx      ; yes
                                        ; no, we weren't
                push    ds
                mov     ax, 40h
                mov     ds, ax
                assume ds:nothing
                mov     ax, cs:OldInt12Mem
                mov     ds:13h, ax      ; restore INT 12h memory
                pop     ds
                assume ds:nothing

timx:                                   ; CODE XREF: TrueInt12Mem+C↑j
                retn
TrueInt12Mem    endp


; =============== S U B R O U T I N E =======================================


IsIt3Com        proc near               ; CODE XREF: LieInt12Mem+4↑p
                push    ds
                push    es
                push    si
                lds     si, cs:DevEntry ; ptr to device header
                add     si, 10          ; SYSDEV.NAME ; ptr device name
                push    cs
                pop     es
                assume es:SYSINIT
                mov     di, offset ThreeComName ; "PROTMAN$"
                mov     cx, 8           ; name length
                repe cmpsb
                pop     si
                pop     es
                assume es:nothing
                pop     ds
                retn
IsIt3Com        endp


; =============== S U B R O U T I N E =======================================


UpdatePDB       proc near               ; CODE XREF: doconf+450↑p
                push    ds
                mov     ah, 62h
                int     21h             ; DOS - 3+ - GET PSP ADDRESS
                mov     ds, bx
                mov     bx, cs:ALLOCLIM
                mov     ds:2, bx        ; [PDB.BLOCK_LEN]
                pop     ds
                retn
UpdatePDB       endp


; =============== S U B R O U T I N E =======================================


InitVar         proc near               ; CODE XREF: doconf+302↑p
                push    ax
                push    cx
                push    di
                push    es
                push    cs
                pop     es
                assume es:SYSINIT
                xor     ax, ax          ; 0
                mov     es:fUmbTiny, al ; Shrink UMBs? (made 1 if /S given)
                mov     es:fInHigh, al  ; Set to 1 when DH/LH has been called
                mov     es:SegLoad, ax  ; Load Address (seg), used for DH only
                mov     es:UmbLoad, 0FFh ; UNSPECIFIED
                                        ; Later is the # of the 1st spec'd UMB
                mov     es:fm_argc, al  ; Start with zero args having been read
                cld
                mov     cx, 16          ; MAXUMB
                mov     di, offset UmbUsed ;
                                        ; For each entry on the UmbUsed array,
                rep stosb               ; Store 0
                mov     cx, 16          ; MAXUMB
                mov     di, offset UmbSize ; Okay...
                                        ; for each entry on the UmbSize array,
                rep stosw               ; Store 0
                pop     es
                assume es:nothing
                pop     di
                pop     cx
                pop     ax
                retn
InitVar         endp


; =============== S U B R O U T I N E =======================================


FixMem          proc near               ; CODE XREF: HideUMBs+9↓p
                push    ax              ; scans the upper memory chain
                                        ; and concatenates adjacent free MCBs
                push    bx
                push    cx
                push    dx
                push    es
                call    fm_link         ; Link in UMBs
                call    UmbHead         ; Get first upper-memory MCB address (0x9FFF)
                jb      short fmX       ; (if couldn't get it, leave now).
                mov     es, ax          ; It returns in AX, so move it to ES.
                xor     dx, dx          ; We're keeping the address of the last MCB
                mov     cx, dx          ; in CX... and the last owner
                inc     dx              ; in dx as we go through the loop

fm10:                                   ; CODE XREF: FixMem+4C↓j
                mov     al, es:0        ; [es:ARENA.SIGNATURE]
                                        ; if 'Z', don't repeat loop
                mov     bx, es:1        ; [es:ARENA.OWNER] ; if not zero, do nothing
                or      bx, dx          ; dx was owner of previous MCB
                jnz     short fm30      ; If not both zero, don't cat.

fm20:                                   ; [es:ARENA.SIZE]
                mov     bx, es:3        ; Grab this block's Size,
                mov     es, cx          ; Go back to prev MCB's address
                assume es:nothing
                mov     byte ptr es:0, al ; [es:ARENA.SIGNATURE]
                                        ; & move the SECOND sig here
                add     bx, word ptr es:3 ; [es:ARENA.SIZE]
                                        ; Size += first MCB's size
                add     bx, 1           ; And add one for the header
                mov     word ptr es:3, bx ; [es:ARENA.SIZE] ; Write the size

fm30:                                   ; CODE XREF: FixMem+1F↑j
                mov     cx, es          ; Save MCB address
                mov     dx, word ptr es:1 ; [es:ARENA.OWNER] ; And remember its owner
                mov     bx, es          ; Move to the next MCB
                add     bx, word ptr es:3 ; [es:ARENA.SIZE]
                inc     bx
                mov     es, bx
                assume es:nothing
                cmp     al, 5Ah ; 'Z'   ; arena_signature_end
                jnz     short fm10      ; If signature != 'Z', there are more.

fmX:                                    ; CODE XREF: FixMem+B↑j
                call    fm_unlink       ; Unlink UMBs
                pop     es
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                retn
FixMem          endp


; =============== S U B R O U T I N E =======================================


fm_link         proc near               ; CODE XREF: FixMem+5↑p
                                        ; SYSINIT:378C↓p ...
                mov     ax, 5802h       ; DOS_CHECK_UMBLINK
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: (DOS 5beta) get UMB link state
                push    es
                push    cs
                pop     es
                assume es:SYSINIT
                mov     es:fm_umb, al   ; store current link-state (to use/set later)
                pop     es
                assume es:nothing
                mov     ax, 5803h       ; DOS_SET_UMBLINK
                mov     bx, 1
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: (DOS 5beta) set UMB link state
                retn
fm_link         endp


; =============== S U B R O U T I N E =======================================


fm_unlink       proc near               ; CODE XREF: FixMem:fmX↑p
                                        ; UmbTest+B↓p
                xor     bx, bx
                push    ds
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     bl, fm_umb      ; old link-state (to set again)
                pop     ds
                assume ds:nothing
                mov     ax, 5803h       ; DOS_SET_UMBLINK
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: (DOS 5beta) set UMB link state
                retn
fm_unlink       endp


; =============== S U B R O U T I N E =======================================


ParseVar        proc near               ; CODE XREF: doconf+322↑p
                push    di              ; parses [/S][/L:umb[,size][;umb[,size]]*]
                                        ;   and builds the table laid out in highvar.inc
                                        ; ENTRY:
                                        ;   ES:SI points to command tail of LoadHigh/DeviceHigh
                                        ;       (whitespace ok)
                                        ; EXIT:
                                        ;   ES:SI points to first character in child program name
                push    ds
                push    es
                push    es              ; Make DS:SI point to it, as well as ES:SI
                pop     ds              ; (regardless if we're in devhigh or loadhigh)
                cld

pv10:                                   ; CODE XREF: ParseVar+A↓j
                                        ; ParseVar+28↓j ...
                lodsb                   ; here, ES:SI=="  /L..."--must eat whitespace
                call    isWhite
                jz      short pv10      ; ES:SI==" /L..."--keep eating.
                cmp     al, 2Fh ; '/'   ; SWTCH ; ES:SI=="/L..."--go process a switch
                jz      short pv20
                dec     si              ; Backup--it's now "odule options", and we need
                clc                     ; that "m" we just read (or whatever it is).
                jmp     short pvX       ; Then return with carry clear == we're done.
; ---------------------------------------------------------------------------

pv20:                                   ; CODE XREF: ParseVar+E↑j
                lodsb                   ; Just read 'S' or 'L', hopefully
                and     al, 0DFh        ; So we make it upper-case, and...
                cmp     al, 53h ; 'S'   ; just read 'S'?
                jnz     short pv30
                call    incArgc         ; If it's /S, it's another arg for LH to skip.
                                        ;
                                        ; Note: 'inc byte [cs:fm_argc]' would be enough here
                                        ; Erdogan Tan - 19/04/2019 (Retro DOS v4) - 11/07/2023
                push    es
                push    cs
                pop     es
                assume es:SYSINIT
                mov     es:fUmbTiny, 1  ; /S, so ES:SI=="  /L..." or " module opts", or
                pop     es
                assume es:nothing
                jmp     short pv10      ; possibly even "/L...".
; ---------------------------------------------------------------------------

pv30:                                   ; CODE XREF: ParseVar+19↑j
                cmp     al, 4Ch ; 'L'   ; If it's not 'L' either, then it's a bad switch!
                jnz     short pvE1
                call    incArgc
                call    parseL
                jnb     short pv10      ; If no carry, go back and look for more
                dec     si              ; Else, back up and exit.
                jmp     short pvErr
; ---------------------------------------------------------------------------

pvE1:                                   ; CODE XREF: ParseVar+2C↑j
                mov     ax, 3           ; PV_InvSwt ; Unrecognized switch passed

pvErr:                                  ; CODE XREF: ParseVar+37↑j
                dec     si
                dec     si
                stc

pvX:                                    ; CODE XREF: ParseVar+12↑j
                pop     es
                pop     ds
                pop     di
                retn
ParseVar        endp


; =============== S U B R O U T I N E =======================================


parseL          proc near               ; CODE XREF: ParseVar+31↑p
                lodsb
                cmp     al, 3Ah ; ':'   ; Make sure they did /L:
                jnz     short plE1      ; If they didn't, return with carry set.

pl10:                                   ; CODE XREF: parseL+1A↓j
                                        ; parseL+3F↓j
                call    GetXNum         ; After this, it's ",size" or ";umb" or " mod"
                jb      short plE2      ; And error if it's a bad number.
                call    convUMB         ; Convert any address to a UMB number
                mov     cl, al          ; Remember the UMB number
                call    stowUMB         ; Mark this UMB # as used;
                jb      short plE2      ; If it was already marked, it'll error
                call    incArgc         ; Each UMB number is another arg for LH to skip
                                        ; ('inc byte [cs:fm_argc]' would be enough)
                                        ; Erdogan Tan - 08/04/2019 (Retro DOS v4) - 11/07/2023
                lodsb
                cmp     al, 3Bh ; ';'   ; Did "umb;" ?
                jz      short pl10      ; Yep: go back and get another UMB.
                call    isWhite         ; Did "umb " ?
                jz      short plX       ; Yep: return (it'll go back to whitespace)
                call    isEOL           ; Did "umb" ?
                jz      short plSwX     ; If so, backup and exit like everything's ok
                cmp     al, 2Fh ; '/'   ; Did "umb/" ? (as in, "/L:1,100;2/S")
                jz      short plSwX     ; If so, back up ES:SI one character and return
                cmp     al, 2Ch ; ','   ; Did "umb," ?
                jnz     short plE1      ; Just what the heck DID they do? Return error.
                call    GetXNum         ; Stop on "size;" or "size " or anything else
                jb      short plE1      ; And error if it's a bad size.
                call    toPara          ; Convert from bytes to paragraphs
                call    stowSiz         ; CL still has the UMB number for this routine
                call    incArgc         ; Each UMB size is another arg for LH to skip
                                        ; ('inc byte [cs:fm_argc]')
                lodsb
                cmp     al, 3Bh ; ';'   ; They did "umb,size;", so get another UMB.
                jz      short pl10
                call    isWhite         ; Did it end with whitespace?
                jz      short plX       ; If so, we're done here--go back.
                call    isEOL           ; Did they do "umb,size" and end??? (stupid)
                jz      short plSwX     ; If so, backup and exit like everything's ok
                cmp     al, 2Fh ; '/'   ; SWTCH ; Did they do "umb,size/" ?
                jz      short plSwX     ; If so, again, we're done here.

plE1:                                   ; CODE XREF: parseL+3↑j
                                        ; parseL+2C↑j ...
                mov     ax, 1           ; PV_InvArg ; If not, we don't know WHAT they did.
                dec     si
                stc
                retn
; ---------------------------------------------------------------------------

plE2:                                   ; CODE XREF: parseL+8↑j
                                        ; parseL+12↑j
                mov     ax, 2           ; In this case, they've specified a UMB twice
                stc
                retn
; ---------------------------------------------------------------------------

plSwX:                                  ; CODE XREF: parseL+24↑j
                                        ; parseL+28↑j ...
                dec     si              ; If we hit a '/' character, back up one char
                                        ; so the whitespace checker will see it too.

plX:                                    ; CODE XREF: parseL+1F↑j
                                        ; parseL+44↑j
                clc                     ; Then just return with carry clear, so
                                        ; ParseVar will go about its business.
                retn
parseL          endp


; =============== S U B R O U T I N E =======================================


incArgc         proc near               ; CODE XREF: ParseVar+1B↑p
                                        ; ParseVar+2E↑p ...
                push    ax              ; increments fm_argc,
                                        ; for use with LoadHigh command-line parsing
                                        ; ***
                                        ; ('inc byte [cs:fm_argc]' would be enough)
                                        ; Erdogan Tan - 11/07/2023
                push    ds
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     al, fm_argc     ; Obtain previous value of fm_argc,
                pop     ds
                assume ds:nothing
                inc     al              ; Increment it,
                push    es
                push    cs
                pop     es
                assume es:SYSINIT
                mov     es:fm_argc, al  ; And store it right back.
                pop     es
                assume es:nothing
                pop     ax
                retn
incArgc         endp


; =============== S U B R O U T I N E =======================================


isEOL           proc near               ; CODE XREF: parseL+21↑p
                                        ; parseL+46↑p
                cmp     al, 0           ; Null-terminator
                jz      short ieX
                cmp     al, 0Dh         ; CR ; Carriage Return
                jz      short ieX
                cmp     al, 0Ah         ; LF ; LineFeed

ieX:                                    ; CODE XREF: isEOL+2↑j
                                        ; isEOL+6↑j
                retn                    ; zf=1 if AL contains EOL character
isEOL           endp


; =============== S U B R O U T I N E =======================================


isWhite         proc near               ; CODE XREF: ParseVar+7↑p
                                        ; parseL+1C↑p ...
                cmp     al, 20h ; ' '   ; Space
                jz      short iwX
                cmp     al, 3Dh ; '='   ; Equals (treat as whitespace)
                jz      short iwX
                cmp     al, 9           ; Tab

iwX:                                    ; CODE XREF: isWhite+2↑j
                                        ; isWhite+6↑j
                retn                    ; zf=1 if AL contains space,
isWhite         endp                    ;         tab or equals character


; =============== S U B R O U T I N E =======================================


unMarkUMB       proc near               ; CODE XREF: _hideUMB_+22↓p
                push    ax              ; marks a given UMB as unused
                                        ; AL contains UMB number
                push    bx
                push    di
                push    es
                push    cs
                pop     es
                assume es:SYSINIT
                xor     ah, ah
                mov     bx, ax
                mov     es:UmbUsed[bx], 0
                cmp     es:UmbLoad, al
                jnz     short umu10     ; If unmarked the load UMB,
                                        ; load into convent.
                mov     es:UmbLoad, 0

umu10:                                  ; CODE XREF: unMarkUMB+15↑j
                pop     es
                assume es:nothing
                pop     di
                pop     bx
                pop     ax
                retn
unMarkUMB       endp


; =============== S U B R O U T I N E =======================================


stowUMB         proc near               ; CODE XREF: parseL+F↑p
                cmp     al, 16          ; MAXUMB
                jb      short su10
                stc                     ; Ooops-- UMB # >= MAXUMB
                retn
; ---------------------------------------------------------------------------

su10:                                   ; CODE XREF: stowUMB+2↑j
                push    bx
                push    di
                push    si
                push    ds
                push    es
                push    cs
                pop     es
                assume es:SYSINIT
                push    cs
                pop     ds
                assume ds:SYSINIT
                cmp     UmbLoad, 0FFh   ; UNSPECIFIED
                                        ; If this, we haven't been here before
                jnz     short su20
                mov     UmbLoad, al     ; So remember this UMB as the load UMB slot.

su20:                                   ; CODE XREF: stowUMB+14↑j
                or      al, al          ; If they gave UMB 0, there's really nothing
                jz      short su30      ; that we should do here.
                mov     bl, al
                xor     bh, bh
                mov     ax, 1           ; Now, AX = 1, and BX = UMB Number
                xchg    al, es:UmbUsed[bx]
                or      al, al          ; If it was already 1,
                                        ; then al==1... and that means an error.
                jz      short su30
                stc                     ; OOOPS! This one's been used before. :(

su30:                                   ; CODE XREF: stowUMB+1B↑j
                                        ; stowUMB+2B↑j
                pop     es
                assume es:nothing
                pop     ds
                assume ds:nothing
                pop     si
                pop     di
                pop     bx
                retn
stowUMB         endp


; =============== S U B R O U T I N E =======================================


stowSiz         proc near               ; CODE XREF: parseL+36↑p
                                        ; StoLoadSize+E↓p
                push    bx
                push    di
                push    es
                push    cs
                pop     es              ; mov [cs:bx+UmbSize],ax !!! ; 08/09/2023
                assume es:SYSINIT
                mov     bl, cl          ; Now bl==UMB number, AX==size
                mov     bh, 0           ; bx==UMB number, AX==size
                shl     bl, 1           ; bx==offset into array
                mov     es:UmbSize[bx], ax ; Store the size
                pop     es
                assume es:nothing
                pop     di
                pop     bx
                retn
stowSiz         endp

; ---------------------------------------------------------------------------
gnradix         dw 0                    ; DATA XREF: toDigit↓r
                                        ; GetXNum+C↓w ...
                                        ; Must be a word--16x16 multiplication

; =============== S U B R O U T I N E =======================================


toDigit         proc near               ; CODE XREF: GetXNum+16↓p
                                        ; GetXNum+3A↓p
                cmp     cs:gnradix, 10h
                jnz     short td10      ; Don't check hex digits if radix isn't 16
                cmp     cl, 61h ; 'a'
                jb      short td20
                cmp     cl, 66h ; 'f'
                ja      short tdE       ; Nothing valid above 'f' at all...
                sub     cl, 57h         ; 'a'-10 ; 87 ; Make 'a'==10 and return.
                retn
; ---------------------------------------------------------------------------

td20:                                   ; CODE XREF: toDigit+B↑j
                cmp     cl, 41h ; 'A'   ; Below 'A'? Not a letter...
                jb      short td10
                cmp     cl, 46h ; 'F'   ; Above 'F'? Not a digit.
                ja      short tdE
                sub     cl, 37h         ; 'A'-10 ; 55 ; Make 'A'==10 and return.
                retn
; ---------------------------------------------------------------------------

td10:                                   ; CODE XREF: toDigit+6↑j
                                        ; toDigit+19↑j
                cmp     cl, 30h ; '0'   ; If less than zero,
                jb      short tdE       ; Done.
                cmp     cl, 39h ; '9'   ; Or, if greater than nine,
                ja      short tdE       ; Done.
                sub     cl, 30h ; '0'   ; Okay--make '0'==0 and return.
                retn
; ---------------------------------------------------------------------------

tdE:                                    ; CODE XREF: toDigit+10↑j
                                        ; toDigit+1E↑j ...
                stc
                retn
toDigit         endp


; =============== S U B R O U T I N E =======================================


GetXNum         proc near               ; CODE XREF: parseL:pl10↑p
                                        ; parseL+2E↑p
                push    bx              ; reads a 32-bit ASCII number at ES:SI
                                        ; and returns it in DX:AX
                push    cx
                push    ds
                cld
                xor     ax, ax
                xor     bx, bx
                xor     cx, cx
                xor     dx, dx          ; Start with 0 (makes sense)
                mov     cs:gnradix, 10  ; And default to a radix of 10 (dec)
                mov     cl, es:[si]
                call    toDigit
                jb      short gxnE      ; If it's not a digit, leave now.
                or      cl, cl
                jnz     short gxn20     ; Doesn't have '0x'
                mov     cl, es:[si+1]
                cmp     cl, 'x'         ; Either 'x'...
                jz      short gxn10
                cmp     cl, 'X'
                jnz     short gxn20

gxn10:                                  ; CODE XREF: GetXNum+26↑j
                mov     cs:gnradix, 16
                inc     si              ; Since we read "0x", march over it.
                inc     si

gxn20:                                  ; CODE XREF: GetXNum+1D↑j
                                        ; GetXNum+2B↑j ...
                mov     cl, es:[si]     ; Now DX:AX=current total, CH=0/CL=char
                inc     si
                call    toDigit         ; Accepts only valid digits, A-F -> 10-16
                jb      short gxnQ      ; <- Ah... wasn't a digit. Stop.
                call    mul32
                jb      short gxnX
                add     ax, cx
                adc     dx, bx
                jb      short gxnX
                jmp     short gxn20
; ---------------------------------------------------------------------------

gxnE:                                   ; CODE XREF: GetXNum+19↑j
                stc
                jmp     short gxnX
; ---------------------------------------------------------------------------

gxnQ:                                   ; CODE XREF: GetXNum+3D↑j
                dec     si
                clc

gxnX:                                   ; CODE XREF: GetXNum+42↑j
                                        ; GetXNum+48↑j ...
                pop     ds
                pop     cx
                pop     bx
                retn
GetXNum         endp


; =============== S U B R O U T I N E =======================================


mul32           proc near               ; CODE XREF: GetXNum+3F↑p
                push    ax              ; multiplies the number in DX:AX by gnradix
                                        ; DX=old:hi, AX=old:lo, TOS=old:lo, BX=0
                mov     ax, dx
                mul     cs:gnradix      ; DX=?, AX=new:hi, TOS=old:lo, BX=0
                jb      short m32E      ; Too big?
                mov     dx, ax          ; DX=new:hi, AX=new:hi, TOS=old:lo, BX=0
                pop     ax              ; DX=new:hi, AX=old:lo, TOS=orig, BX=0
                xchg    dx, bx          ; DX=0, AX=old:lo, TOS=orig, BX=new:hi
                mul     cs:gnradix      ; DX=carry, AX=new:lo, TOS=orig, BX=new:hi
                xchg    dx, bx
                add     dx, bx          ; DX=new:hi, AX=new:lo, TOS=orig, BX=carry
                xor     bx, bx          ; BX=0
                retn
; ---------------------------------------------------------------------------

m32E:                                   ; CODE XREF: mul32+8↑j
                pop     ax
                retn
mul32           endp


; =============== S U B R O U T I N E =======================================


toPara          proc near               ; CODE XREF: parseL+33↑p
                push    cx              ; divides DX:AX by 16; result in AX only
                mov     cl, 4           ; DX:AX=HHHH hhhh hhhh hhhh:LLLL llll llll llll
                shr     ax, cl          ; DX:AX=HHHH hhhh hhhh hhhh:0000 LLLL llll llll
                xchg    ax, dx          ; DX:AX=0000 LLLL llll llll:HHHH hhhh hhhh hhhh
                mov     cl, 12
                shl     ax, cl          ; DX:AX=0000 LLLL llll llll:hhhh 0000 0000 0000
                or      ax, dx          ; AX=hhhh LLLL llll llll
                pop     cx
                retn
toPara          endp


; =============== S U B R O U T I N E =======================================


UmbHead         proc near               ; CODE XREF: FixMem+8↑p
                                        ; AddrToUmb+5↓p ...
                push    si
                push    ds
                push    es
                mov     ah, 52h         ; GET_IN_VARS
                int     21h             ; DOS - 2+ internal - GET LIST OF LISTS
                                        ; Return: ES:BX -> DOS list of lists
                mov     ax, es:8Ch      ; [es:DOS_UMB_HEAD]
                cmp     ax, 0FFFFh
                jz      short uhE
                clc
                jmp     short uhX
; ---------------------------------------------------------------------------

uhE:                                    ; CODE XREF: UmbHead+E↑j
                stc

uhX:                                    ; CODE XREF: UmbHead+11↑j
                pop     es
                pop     ds
                pop     si
                retn
UmbHead         endp


; =============== S U B R O U T I N E =======================================


isSysMCB        proc near               ; CODE XREF: AddrToUmb+14↓p
                                        ; hideUMB:hu10↓p ...
                push    ax              ; sets ZF if ES points to an MCB owned by "SC"
                mov     ax, es:1        ; [es:ARENA.OWNER]
                cmp     ax, 8           ; SystemPSPOwner ; 8 (for US or Japan) is valid
                jz      short ism10
                cmp     ax, 9           ; JapanPSPOwner ; 9 (for Japan) is valid
                jz      short ism10
                jmp     short ismX
; ---------------------------------------------------------------------------

ism10:                                  ; CODE XREF: isSysMCB+8↑j
                                        ; isSysMCB+D↑j
                mov     ax, es:8        ; [es:ARENA.NAME]
                cmp     ax, 4353h       ; 'SC'

ismX:                                   ; CODE XREF: isSysMCB+F↑j
                pop     ax
                retn
isSysMCB        endp


; =============== S U B R O U T I N E =======================================


AddrToUmb       proc near               ; CODE XREF: convUMB+8↓p
                push    cx              ; converts a segment address in AX
                                        ; to its appropriate UMB number
                push    dx
                push    es
                mov     dx, ax          ; DX = address to search for
                call    UmbHead         ; AX = first segment
                jb      short atuE      ; If it couldn't get it, error out
                mov     es, ax
                xor     cx, cx          ; 0

atu10:                                  ; CODE XREF: AddrToUmb+2C↓j
                mov     ax, es
                cmp     ax, dx          ; Present segment >= given segment?
                jnb     short atuX      ; yes, done.
                call    isSysMCB        ; Returns with ZF set if this is a system MCB
                jnz     short atu20
                inc     cx              ; If it _was_ a system MCB, we're in a new UMB.

atu20:                                  ; CODE XREF: AddrToUmb+17↑j
                mov     al, es:0        ; [es:ARENA.SIGNATURE]
                cmp     al, 5Ah ; 'Z'
                jz      short atu30     ; 'Z' means this was the last MCB... that's it.
                mov     ax, es
                add     ax, es:3        ; [es:ARENA.SIZE]
                inc     ax
                mov     es, ax
                jmp     short atu10
; ---------------------------------------------------------------------------

atu30:                                  ; CODE XREF: AddrToUmb+20↑j
                mov     ax, es
                add     ax, es:3        ; [es:ARENA.SIZE]
                cmp     ax, dx          ; Present >= given?
                jnb     short atuX      ; Yep! It _was_ inside.

atuE:                                   ; CODE XREF: AddrToUmb+8↑j
                xor     cx, cx
                dec     cx              ; Address is above UM Range,
                                        ; AX will return as 0FFFFh.

atuX:                                   ; CODE XREF: AddrToUmb+12↑j
                                        ; AddrToUmb+37↑j
                mov     ax, cx          ; Return the UMB number in AX (0==conv)
                pop     es
                pop     dx
                pop     cx
                retn
AddrToUmb       endp


; =============== S U B R O U T I N E =======================================


convUMB         proc near               ; CODE XREF: parseL+A↑p
                cmp     cs:gnradix, 10h ; convert address to UMB number after GetXNum
                                        ; (GetXNum has read a hex number)
                jnz     short cu10      ; GetXNum didn't read in hex, it is not an addr
                call    AddrToUmb       ; convert the address to a UMB number
                cmp     ax, 0FFFFh
                jnz     short cu10
                inc     ax              ; If too high, ignore it (make it conventional)

cu10:                                   ; CODE XREF: convUMB+6↑j
                                        ; convUMB+E↑j
                retn
convUMB         endp

; ---------------------------------------------------------------------------

setUMBs:                                ; CODE XREF: HideUMBs+C↓p
                push    ax
                push    bx
                call    fm_link
                pop     bx
                pop     ax
                retn
; ---------------------------------------------------------------------------

loadLow:                                ; loadLow subroutine is not used anywhere
                push    ds              ; of PCDOS 7.1 IBMBIO.COM (& MSDOS 6.21 IO.SYS)
                                        ; Erdogan Tan - 18/07/2023
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     al, UmbLoad
                cmp     al, 0FFh        ; UNSPECIFIED ; -1
                jnz     short ll10
                mov     al, 1
                stc
                jmp     short llx
; ---------------------------------------------------------------------------

ll10:                                   ; CODE XREF: SYSINIT:379A↑j
                or      al, al
                jz      short llx
                mov     al, 1
                clc

llx:                                    ; CODE XREF: SYSINIT:379F↑j
                                        ; SYSINIT:37A3↑j
                pop     ds
                assume ds:nothing
                retn

; =============== S U B R O U T I N E =======================================


HideUMBs        proc near               ; CODE XREF: InitDevLoad+13↓p
                push    ax              ; links UMBs and hides upper-memory as appropriate
                push    cx
                push    ds
                push    es
                call    UmbTest         ; cf=0 if UMBs are available
                jb      short husX      ; there is nothing to do.
                call    FixMem          ; Concatenate adjacent free MCBs in upper mem
                call    setUMBs         ; Link UMBs and set memory-allocation strategy
                push    es
                push    cs
                pop     es
                assume es:SYSINIT
                mov     es:fInHigh, 1   ; Remember that we're now running high
                pop     es
                assume es:nothing
                call    GetLoadUMB      ; See if they gave us a list to leave free
                cmp     al, 0FFh        ; UNSPECIFIED ; If they didn't,
                jz      short husX      ; then we shouldn't do this loop:
                xor     cx, cx          ; 0

hus10:                                  ; CODE XREF: HideUMBs+34↓j
                inc     cx              ; +1 for each UMB
                cmp     cx, 16          ; MAXUMB
                jnb     short hus20
                mov     al, cl
                push    es
                call    findUMB         ; ES:0 points to first MCB in UMB
                                        ; Carry set if couldn't reach UMB
                pop     es
                jb      short hus20     ; outside of the valid range of UMBs
                call    _hideUMB_       ; hide what we need to hide.
                jmp     short hus10
; ---------------------------------------------------------------------------

hus20:                                  ; CODE XREF: HideUMBs+26↑j
                                        ; HideUMBs+2F↑j
                call    GetLoadUMB      ; mov al,[cs:UmbLoad]
                or      al, al          ; or byte [cs:UmbLoad],0
                                        ; Is the load UMB 0? (-1==unspecified)
                jnz     short husX      ; no, done.
                call    hl_unlink       ; fix UMBs and strategy.

husX:                                   ; CODE XREF: HideUMBs+7↑j
                                        ; HideUMBs+1E↑j ...
                pop     es
                pop     ds
                pop     cx
                pop     ax
                retn
HideUMBs        endp


; =============== S U B R O U T I N E =======================================


GetLoadUMB      proc near               ; CODE XREF: doconf:loc_7EDB↑p
                                        ; HideUMBs+19↑p ...
                push    ds              ; Returns the load UMB number in AL
                                        ;  (-1 if not specified)
                                        ;
                                        ; Instead of calling this subroutine
                                        ; "or byte [cs:UmbLoad],0" then "jz/jnz .."
                                        ; would be enough. Erdogan Tan - 18/07/2023
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     al, UmbLoad
                pop     ds
                assume ds:nothing
                retn
GetLoadUMB      endp


; =============== S U B R O U T I N E =======================================


GetLoadSize     proc near               ; CODE XREF: doconf+3D8↑p
                push    bx              ; Returns the load UMB minimum size
                                        ;  (0 if not specified)
                push    si
                push    ds
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     al, UmbLoad
                xor     ah, ah
                mov     bx, offset UmbSize ; array
                shl     al, 1
                add     ax, bx
                mov     si, ax
                lodsw                   ; ax==size
                pop     ds
                assume ds:nothing
                pop     si
                pop     bx
                retn
GetLoadSize     endp


; =============== S U B R O U T I N E =======================================


GetSize         proc near               ; CODE XREF: _hideUMB_+14↓p
                push    bx              ; Returns the UMB in AL's minimum size
                                        ;  (0 if not specified)
                push    si
                push    ds
                push    cs
                pop     ds
                assume ds:SYSINIT
                xor     ah, ah
                mov     bx, offset UmbSize ; array
                shl     al, 1
                add     ax, bx
                mov     si, ax
                lodsw                   ; ax==size
                pop     ds
                assume ds:nothing
                pop     si
                pop     bx
                retn
GetSize         endp

; ---------------------------------------------------------------------------

StoLoadUMB:                             ; StoLoadUMB subroutine is not used anywhere
                push    es              ; of PCDOS 7.1 IBMBIO.COM (& MSDOS 6.21 IO.SYS)
                                        ; Erdogan Tan - 18/07/2023
                push    cs
                pop     es              ; mov [cs:UmbLoad], al !!!! ; 08/09/2023
                assume es:SYSINIT
                mov     es:UmbLoad, al  ; Overrides the load UMB number with what's in AL
                pop     es
                assume es:nothing
                retn

; =============== S U B R O U T I N E =======================================


StoLoadSize     proc near               ; CODE XREF: doconf+3E8↑p
                push    dx              ; Overrides the load UMB min. size with what's in AX
                push    ds
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     dl, UmbLoad     ; Put UMB# in DL
                                        ;
                                        ; BUG ! CL would/must be used here instead of DL (*)
                                        ; 18/07/2023
                pop     ds
                assume ds:nothing
                cmp     dl, 0FFh        ; UNSPECIFIED ?
                jz      short sls10
                call    stowSiz         ; We've got a function to do just this
                                        ;
                                        ; BUG ! stowSiz uses CL instead of DL !
                                        ; (CL is set in ParseL which calls stowSiz)
                                        ; (This BUG existing in MSDOS 6.21 IO.SYS also)
                                        ; Erdogan Tan - 18/07/2023

sls10:                                  ; CODE XREF: StoLoadSize+C↑j
                pop     dx
                retn
StoLoadSize     endp


; =============== S U B R O U T I N E =======================================


hideUMB         proc near               ; CODE XREF: _hideUMB_+40↓p
                push    ax              ; marks as HIDDEN all FREE elements in UMB passed as AL
                push    es
                call    findUMB         ; Returns with carry if err, else ES == MCB
                jb      short huX

hu10:                                   ; CODE XREF: hideUMB+26↓j
                call    isSysMCB        ; Returns with ZF set if owner is SYSTEM
                jz      short huX
                call    isFreeMCB       ; or word [es:ARENA.OWNER],0
                jnz     short hu20
                call    hideMCB

hu20:                                   ; CODE XREF: hideUMB+F↑j
                mov     al, es:0        ; [es:ARENA.SIGNATURE]
                cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
                jz      short huX
                mov     ax, es          ; Go on forward.
                add     ax, es:3        ; [es:ARENA.SIZE]
                inc     ax
                mov     es, ax
                jmp     short hu10
; ---------------------------------------------------------------------------

huX:                                    ; CODE XREF: hideUMB+5↑j
                                        ; hideUMB+A↑j ...
                pop     es
                pop     ax
                retn
hideUMB         endp


; =============== S U B R O U T I N E =======================================


isTiny          proc near               ; CODE XREF: _hideUMB_:hu_10↓p
                push    ax              ; returns with ZF set if user didn't specify /S
                push    ds
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     al, fUmbTiny
                pop     ds
                assume ds:nothing
                or      al, al
                pop     ax
                retn
isTiny          endp


; =============== S U B R O U T I N E =======================================


isFreeMCB       proc near               ; CODE XREF: hideUMB+C↑p
                                        ; BigFree+10↓p ...
                or      word ptr es:1, 0 ; or word [es:ARENA.OWNER],0
                retn
isFreeMCB       endp


; =============== S U B R O U T I N E =======================================


hideMCB         proc near               ; CODE XREF: hideUMB+11↑p
                mov     word ptr es:1, 8 ; marks as HIDDEN the MCB at ES:0
                mov     word ptr es:8, 4948h ; 'HI'
                mov     word ptr es:0Ah, 4444h ; 'DD'
                mov     word ptr es:0Ch, 4E45h ; 'EN'
                mov     word ptr es:0Eh, 2020h ; '  '
                retn
hideMCB         endp


; =============== S U B R O U T I N E =======================================


unHideMCB       proc near               ; CODE XREF: _hideUMB_+49↓p
                                        ; UnFreeze+E↓p
                push    ax              ; marks as FREE the MCB at ES:0
                mov     word ptr es:1, 0 ; [es:ARENA.OWNER],FreePSPOwner
                mov     ax, 2020h       ; '  '
                mov     es:8, ax        ; [es:ARENA.NAME+0]
                mov     es:0Ah, ax      ; [es:ARENA.NAME+2]
                mov     es:0Ch, ax      ; [es:ARENA.NAME+4]
                mov     es:0Eh, ax      ; [es:ARENA.NAME+6]
                pop     ax
                retn
unHideMCB       endp


; =============== S U B R O U T I N E =======================================


findUMB         proc near               ; CODE XREF: HideUMBs+2B↑p
                                        ; hideUMB+2↑p ...
                push    ax              ; makes ES:0 point to the first MCB in UMB given as AL
                push    cx
                push    dx
                xor     ah, ah
                mov     dx, ax          ; Store the to-be-found UMB number in DX
                call    UmbHead         ; Returns first UMB segment in AX
                mov     es, ax
                xor     cx, cx          ; Pretend we're on UMB 0 for now...

fu10:                                   ; CODE XREF: findUMB+2A↓j
                cmp     cx, dx          ; If CX==DX, the UMB is found
                jz      short fuX
                call    isSysMCB        ; Returns with ZF set if owner is SYSTEM
                jnz     short fu20
                inc     cx

fu20:                                   ; CODE XREF: findUMB+15↑j
                mov     al, es:0
                cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
                jz      short fuE       ; 'Z' means this was the last MCB
                mov     ax, es          ; Go on forward.
                add     ax, es:3        ; [es:ARENA.SIZE]
                inc     ax
                mov     es, ax
                jmp     short fu10
; ---------------------------------------------------------------------------

fuE:                                    ; CODE XREF: findUMB+1E↑j
                stc

fuX:                                    ; CODE XREF: findUMB+10↑j
                pop     dx
                pop     cx
                pop     ax              ; The address is already in ES.
                retn
findUMB         endp


; =============== S U B R O U T I N E =======================================


BigFree         proc near               ; CODE XREF: _hideUMB_+C↓p
                push    bx              ; makes ES:0 point to the largest free MCB
                                        ; in UMB given as AL
                push    cx
                call    findUMB         ; Returns with CF if err, else ES==MCB
                jb      short bfX
                xor     bx, bx          ; Segment address of largest free MCB
                xor     cx, cx          ; Size of largest free MCB

bf10:                                   ; CODE XREF: BigFree+35↓j
                call    isSysMCB        ; If we've left the MCB, we're done.
                jz      short bf30
                call    isFreeMCB       ; or word [es:ARENA.OWNER],0
                jnz     short bf20
                cmp     cx, es:3        ; [es:ARENA.SIZE] ; Compare sizes..
                jg      short bf20
                mov     bx, es          ; Unless we're bigger,
                mov     cx, es:3        ; Store this new element's addr and size.

bf20:                                   ; CODE XREF: BigFree+13↑j
                                        ; BigFree+1A↑j
                mov     al, es:0
                cmp     al, 5Ah ; 'Z'   ; [es:ARENA.SIGNATURE],arena_signature_end
                jz      short bf30
                mov     ax, es          ; NextMCB es,ax ; (macro) ; Go on forward.
                add     ax, es:3        ; es:ARENA.SIZE]
                inc     ax
                mov     es, ax
                jmp     short bf10
; ---------------------------------------------------------------------------

bf30:                                   ; CODE XREF: BigFree+E↑j
                                        ; BigFree+29↑j
                mov     es, bx          ; Return the address
                mov     ax, cx          ; Return the size
                or      bx, bx
                jnz     short bfX
                stc                     ; (if size==0, there's nothing free)

bfX:                                    ; CODE XREF: BigFree+5↑j
                                        ; BigFree+3D↑j
                pop     cx
                pop     bx
                retn
BigFree         endp


; =============== S U B R O U T I N E =======================================


isSpecified     proc near               ; CODE XREF: _hideUMB_+5↓p
                                        ; _hideUMB_+37↓p
                push    ax              ; sets ZF if UMB in AL wasn't specified in DH/LH line.
                xor     bh, bh
                mov     bl, al
                push    ds
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     al, UmbUsed[bx]
                pop     ds
                assume ds:nothing
                or      al, al          ; ets ZF if al==0 (ie, if unspecified)
                pop     ax
                retn
isSpecified     endp


; =============== S U B R O U T I N E =======================================


shrinkMCB       proc near               ; CODE XREF: _hideUMB_+2C↓p
                push    bx              ; breaks an MCB into two pieces, the lowest one's size==AX
                                        ; AX == new size, ES:0 == current MCB
                push    cx
                push    es
                mov     bx, ax          ; requested size (lowest one)
                mov     ax, es
                mov     cx, es:3        ; [es:ARENA.SIZE]
                sub     cx, 32          ; MIN_SPLIT_SIZE = 32
                cmp     bx, cx          ; {New size} vs {Current Size-20h}
                ja      short smE       ; if wanted_size > cur-20h, abort.
                mov     dl, es:0        ; [es:ARENA.SIGNATURE]
                mov     cx, es:3
                mov     es:3, bx        ; [es:ARENA.SIZE]
                mov     byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],'M'
                add     ax, bx
                inc     ax
                mov     es, ax          ; Move to new arena area
                mov     ax, cx
                sub     ax, bx
                dec     ax              ; And prepare the new size
                mov     es:0, dl        ; [es:ARENA.SIGNATURE],dl
                mov     word ptr es:1, 0 ; [es:ARENA.OWNER]
                mov     es:3, ax        ; [es:ARENA.SIZE]
                mov     ax, 2020h       ; '  '
                mov     es:8, ax        ; [es:ARENA.NAME+0]
                mov     es:0Ah, ax      ; [es:ARENA.NAME+2]
                mov     es:0Ch, ax      ; [es:ARENA.NAME+4]
                mov     es:0Eh, ax      ; [es:ARENA.NAME+6]
                clc
                jmp     short smX
; ---------------------------------------------------------------------------

smE:                                    ; CODE XREF: shrinkMCB+11↑j
                stc

smX:                                    ; CODE XREF: shrinkMCB+56↑j
                pop     es
                pop     cx
                pop     bx
                retn
shrinkMCB       endp


; =============== S U B R O U T I N E =======================================


_hideUMB_       proc near               ; CODE XREF: HideUMBs+31↑p
                push    bx              ; hides as appropriate the UMB in CL
                push    dx
                push    es
                mov     al, cl
                call    isSpecified     ; Returns ZF set if al's umb was NOT specified
                jz      short hu_20
                mov     al, cl
                call    BigFree         ; Retrieve the size of the largest free element
                                        ; in AX, put its address in ES.
                jb      short hu_20
                push    ax              ; TOS==size of BigFree in UMB
                mov     al, cl          ; Retrieve the user's specified
                call    GetSize         ; minimum size for this umb (into AX)
                pop     bx              ; BX==BigFree, AX==Specified Size
                or      ax, ax          ; If they didn't specify one,
                                        ; skip over all this.
                jz      short hu_20
                cmp     ax, bx          ; if (specified > max free)
                jbe     short hu_10
                mov     al, cl          ; then mark that UMB as unused.
                call    unMarkUMB
                jmp     short hu_20
; ---------------------------------------------------------------------------

hu_10:                                  ; CODE XREF: _hideUMB_+1E↑j
                call    isTiny          ; or byte [cs:fUmbTiny],0
                jz      short hu_20
                call    shrinkMCB       ; They specified /S, so shrink the MCB to AX
                jb      short hu_20
                mov     dx, es
                jmp     short hu_30     ; Skip the spec check.. we wanna hide this one.
; ---------------------------------------------------------------------------

hu_20:                                  ; CODE XREF: _hideUMB_+8↑j
                                        ; _hideUMB_+F↑j ...
                mov     ax, cx
                call    isSpecified     ; If they specified this UMB, we're done.
                jnz     short hu_X      ; so leave.
                xor     dx, dx          ; 0

hu_30:                                  ; CODE XREF: _hideUMB_+33↑j
                mov     al, cl
                call    hideUMB         ; Hides everything in UMB #al
                or      dx, dx          ; Did we shrink a UMB? If not, DX==0,
                jz      short hu_X      ; So we should leave.
                mov     es, dx          ; Ah, but if it isn't, DX==the MCB's address;
                call    unHideMCB       ; Un-hides the lower portion of that MCB.

hu_X:                                   ; CODE XREF: _hideUMB_+3A↑j
                                        ; _hideUMB_+45↑j
                pop     es
                pop     dx
                pop     bx
                retn
_hideUMB_       endp


; =============== S U B R O U T I N E =======================================


UnFreeze        proc near               ; CODE XREF: InitDevLoad+1D↓p
                push    ax              ; Marks FROZEN elements as FREE
                push    es
                call    UmbHead         ; Returns with carry if err, else ES == MCB
                jb      short ufX
                mov     es, ax

uf10:                                   ; CODE XREF: UnFreeze+23↓j
                call    isFrozMCB       ; Returns with ZF set if MCB is FROZEN
                jnz     short uf20
                call    unHideMCB

uf20:                                   ; CODE XREF: UnFreeze+C↑j
                mov     al, es:0
                cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
                jz      short ufX
                mov     ax, es
                add     ax, es:3        ; [es:ARENA.SIZE]
                inc     ax
                mov     es, ax
                jmp     short uf10
; ---------------------------------------------------------------------------

ufX:                                    ; CODE XREF: UnFreeze+5↑j
                                        ; UnFreeze+17↑j
                pop     es
                pop     ax
                retn
UnFreeze        endp


; =============== S U B R O U T I N E =======================================


isFrozMCB       proc near               ; CODE XREF: UnFreeze:uf10↑p
                push    ax
                mov     ax, es:1        ; [es:ARENA.OWNER] ; Check the owner..
                cmp     ax, 8           ; 8 (for US OR Japan) is valid
                jnz     short ifmX
                mov     ax, es:8        ; [es:ARENA.NAME+0]
                cmp     ax, 5246h       ; 'FR'
                jnz     short ifmX
                mov     ax, es:0Ah      ; [es:ARENA.NAME+2]
                cmp     ax, 5A4Fh       ; 'OZ'
                jnz     short ifmX
                mov     ax, es:0Ch      ; [es:ARENA.NAME+4]
                cmp     ax, 4E45h       ; 'EN'
                jnz     short ifmX
                mov     ax, es:0Eh      ; [es:ARENA.NAME+6]
                cmp     ax, 2020h       ; '  '

ifmX:                                   ; CODE XREF: isFrozMCB+8↑j
                                        ; isFrozMCB+11↑j ...
                pop     ax
                retn
isFrozMCB       endp


; =============== S U B R O U T I N E =======================================


frezMCB         proc near               ; CODE XREF: FreezeUM+21↓p
                mov     word ptr es:1, 8 ; marks as 8+FROZEN the MCB at ES:0
                                        ; mov word [es:ARENA.OWNER],SystemPSPOwner
                mov     word ptr es:8, 5246h ; [es:ARENA.NAME+0],'FR'
                mov     word ptr es:0Ah, 5A4Fh ; [es:ARENA.NAME+2],'OZ'
                mov     word ptr es:0Ch, 4E45h ; [es:ARENA.NAME+4],'EN'
                mov     word ptr es:0Eh, 2020h ; [es:ARENA.NAME+6],'  '
                retn
frezMCB         endp


; =============== S U B R O U T I N E =======================================


FreezeUM        proc near               ; CODE XREF: InitDevLoad+16↓p
                push    ax              ; Marks FROZEN all UM elements now FREE,
                                        ; save those in load UMB
                push    cx
                push    dx
                push    es
                call    GetLoadUMB      ; mov al,[cs:UmbLoad]
                xor     ah, ah          ; 0
                mov     dx, ax          ; Store the load UMB in DX, so we can skip it
                call    UmbHead         ; Returns first UMB segment in AX
                mov     es, ax
                xor     cx, cx          ; Pretend we're on UMB 0 for now..

fum10:                                  ; CODE XREF: FreezeUM+36↓j
                call    isSysMCB        ; Returns with ZF set if owner is SYSTEM
                jnz     short fum20
                inc     cx              ; If it _was_ SYSTEM, we're in a new UMB.

fum20:                                  ; CODE XREF: FreezeUM+15↑j
                cmp     cx, dx          ; DX - UMB number to skip (load UMB)
                                        ;
                                        ; If this is the load UMB, we don't want to
                                        ; freeze anything.. so skip that section.
                jz      short fum30
                call    isFreeMCB       ; or word [es:ARENA.OWNER],0
                                        ; If it's not free, we can't freeze it
                jnz     short fum30
                call    frezMCB

fum30:                                  ; CODE XREF: FreezeUM+1A↑j
                                        ; FreezeUM+1F↑j
                mov     al, es:0
                cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
                jz      short fumX
                mov     ax, es          ; NextMCB es, ax (macro) ; Go on forward.
                add     ax, es:3        ; [es:ARENA.SIZE]
                inc     ax
                mov     es, ax
                jmp     short fum10
; ---------------------------------------------------------------------------

fumX:                                   ; CODE XREF: FreezeUM+2A↑j
                pop     es
                pop     dx
                pop     cx
                pop     ax
                retn
FreezeUM        endp


; =============== S U B R O U T I N E =======================================


UmbTest         proc near               ; CODE XREF: doconf+35C↑p
                                        ; HideUMBs+4↑p
                push    ax              ; returns with carry set if UMBs are not available,
                                        ;  else CF==false
                push    bx
                push    ds
                push    es
                call    fm_link         ; Link in UMBs (if not already linked)
                call    WalkMem         ; Check to see if they're really linked
                pushf                   ; And remember what we found out
                call    fm_unlink       ; Unlink UMBs (if we have linked 'em)
                popf                    ; And restore what we found out.
                pop     es
                pop     ds
                pop     bx
                pop     ax
                retn
UmbTest         endp


; =============== S U B R O U T I N E =======================================


WalkMem         proc near               ; CODE XREF: UmbTest+7↑p
                push    ax              ; WalkMem - travels memory chain and
                                        ; returns carry clear if UMBs are linked
                push    bx
                push    es
                mov     ah, 52h
                int     21h             ; DOS - 2+ internal - GET LIST OF LISTS
                                        ; Return: ES:BX -> DOS list of lists
                mov     ax, es:[bx-2]
                mov     es, ax          ; ES = Current MCB pointer

um10:                                   ; CODE XREF: WalkMem+1F↓j
                mov     al, es:0
                cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
                jz      short um20
                mov     bx, es          ; Move to the next MCB
                add     bx, es:3        ; [es:ARENA.SIZE]
                inc     bx
                mov     es, bx
                jmp     short um10
; ---------------------------------------------------------------------------

um20:                                   ; CODE XREF: WalkMem+13↑j
                mov     ax, es
                cmp     ax, 9FFFh       ; This sets CF if ax < 9FFFh.
                pop     es
                pop     bx
                pop     ax
                retn
WalkMem         endp


; =============== S U B R O U T I N E =======================================


hl_unlink       proc near               ; CODE XREF: HideUMBs+3D↑p
                xor     bh, bh          ; unlinks UMBs if fm_umb is set to 0;
                                        ;  restores strategy too
                push    ds
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     bl, fm_umb
                pop     ds
                assume ds:nothing
                mov     ax, 5803h       ; DOS_SET_UMBLINK
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: (DOS 5beta) set UMB link state
                retn
hl_unlink       endp


; =============== S U B R O U T I N E =======================================


UnHideUMBs      proc near               ; CODE XREF: RetFromUM+7↓p
                push    ax              ; Marks HIDDEN elements as FREE
                push    ds
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     al, fInHigh     ; mov al,[cs:fInHigh]
                pop     ds
                assume ds:nothing
                or      al, al
                jnz     short uhu10     ; If didn't call loadhigh/devicehigh earlier,
                pop     ax              ; then there's nothing to do here.
                stc
                retn
; ---------------------------------------------------------------------------

uhu10:                                  ; CODE XREF: UnHideUMBs+A↑j
                call    linkumb         ; Make sure UMBs are linked in.
                call    FreeUMBs
                push    es
                push    cs
                pop     es
                assume es:SYSINIT
                mov     es:fInHigh, 0   ; We're leaving, so update fInHigh.
                pop     es
                assume es:nothing
                call    he_unlink       ; Unlink UMBs
                pop     ax
                clc
                retn
UnHideUMBs      endp


; =============== S U B R O U T I N E =======================================


he_unlink       proc near               ; CODE XREF: UnHideUMBs+1F↑p
                xor     bh, bh          ; unlinks UMBs if fm_umb is set to 0
                push    ds
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     bl, fm_umb
                pop     ds
                assume ds:nothing
                mov     ax, 5803h
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: (DOS 5beta) set UMB link state
                retn
he_unlink       endp


; =============== S U B R O U T I N E =======================================


FreeUMBs        proc near               ; CODE XREF: UnHideUMBs+12↑p
                push    ax              ; frees all HIDDEN memory elements in upper-memory
                push    es
                call    HeadUmb         ; Returns with carry if err, else ES == MCB
                jb      short fusX

fus10:                                  ; CODE XREF: FreeUMBs+21↓j
                mov     es, ax          ; Prepare for the loop; ES = current MCB addr.
                call    isHideMCB       ; Returns with ZF set if owner is 0
                jnz     short fus20
                call    freeMCB

fus20:                                  ; CODE XREF: FreeUMBs+C↑j
                mov     al, es:0
                cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
                jz      short fusX
                mov     ax, es
                add     ax, es:3        ; [es:ARENA.SIZE]
                inc     ax
                jmp     short fus10     ; Go on forward.
; ---------------------------------------------------------------------------

fusX:                                   ; CODE XREF: FreeUMBs+5↑j
                                        ; FreeUMBs+17↑j
                pop     es
                pop     ax
                retn
FreeUMBs        endp


; =============== S U B R O U T I N E =======================================


isHideMCB       proc near               ; CODE XREF: FreeUMBs+9↑p
                push    ax              ; returns with ZF set if current MCB (ES:0) is HIDDEN
                cmp     word ptr es:1, 8 ; [es:ARENA.OWNER],SystemPSPOwner
                                        ; If the owner's SYSTEM then check for HIDDEN
                jnz     short ihm_x
                mov     ax, es:8
                cmp     ax, 4948h       ; cmp word [es:ARENA.NAME+0],'HI'
                jnz     short ihm_x
                mov     ax, es:0Ah
                cmp     ax, 4444h       ; cmp word [es:ARENA.NAME+2],'DD'
                jnz     short ihm_x
                mov     ax, es:0Ch
                cmp     ax, 4E45h       ; cmp word [es:ARENA.NAME+4],'EN'
                jnz     short ihm_x
                mov     ax, es:0Eh
                cmp     ax, 2020h       ; [es:ARENA.NAME+6],'  '

ihm_x:                                  ; CODE XREF: isHideMCB+7↑j
                                        ; isHideMCB+10↑j ...
                pop     ax
                retn
isHideMCB       endp


; =============== S U B R O U T I N E =======================================


freeMCB         proc near               ; CODE XREF: FreeUMBs+E↑p
                mov     word ptr es:1, 0 ; marks as free the MCB at ES:0
                mov     ax, 2020h       ; '  '
                mov     es:8, ax        ; mov word [es:ARENA.NAME+0],'  '
                mov     es:0Ah, ax
                mov     es:0Ch, ax
                mov     es:0Eh, ax      ; [es:ARENA.NAME+6]
                retn
freeMCB         endp


; =============== S U B R O U T I N E =======================================


HeadUmb         proc near               ; CODE XREF: FreeUMBs+2↑p
                push    es              ; returns in AX the addr of the 1st UMB block (0x9FFF)
                mov     ah, 52h
                int     21h             ; DOS - 2+ internal - GET LIST OF LISTS
                                        ; Return: ES:BX -> DOS list of lists
                mov     ax, es:8Ch      ; [es:UMB_HeadIdx]
                cmp     ax, 0FFFFh
                jz      short xhu_e     ; If it's 0xFFFF, it's an error...
                clc                     ; AX contains 0x9FFF for most systems
                jmp     short xhu_x
; ---------------------------------------------------------------------------

xhu_e:                                  ; CODE XREF: HeadUmb+C↑j
                stc                     ; error

xhu_x:                                  ; CODE XREF: HeadUmb+F↑j
                pop     es
                retn
HeadUmb         endp


; =============== S U B R O U T I N E =======================================


linkumb         proc near               ; CODE XREF: UnHideUMBs:uhu10↑p
                mov     ax, 5802h       ; DOS_GET_UMBLINK
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: (DOS 5beta) get UMB link state
                or      al, al          ; Current link-state is now in al
                                        ; al = 01h -> UMBs in DOS memory chain
                jnz     short lumbX     ; Jumps if UMBs already linked in
                mov     ax, 5803h       ; DOS_SET_UMBLINK
                mov     bx, 1           ; bx = 01h -> add UMBs to DOS memory chain
                int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
                                        ; AL = function code: (DOS 5beta) set UMB link state

lumbX:                                  ; CODE XREF: linkumb+7↑j
                retn
linkumb         endp


; =============== S U B R O U T I N E =======================================


InitDevLoad     proc near               ; CODE XREF: MagicPreload+11↑p
                                        ; MagicPostload+2E↑p ...
                cmp     cs:DeviceHi, 0  ; Are we loading in UMB ?
                jz      short InitForLo ; no, init for lo mem
                cmp     cs:ConvLoad, 1  ; Are we loading as per Dos 5?
                jz      short InitForConv
                call    ShrinkUMB       ; Stop using the old device arena
                call    HideUMBs        ; Mark up the UM area as we see fit
                call    FreezeUM        ; Hide everything BUT the load area
                call    GetUMBForDev    ; And grab that load area as needed
                pushf
                call    UnFreeze        ; Then unhide everything frozen
                popf
                jb      short InitForLo ;  (if carry, it's loading low)
                jmp     short InitForHi
; ---------------------------------------------------------------------------

InitForConv:                            ; CODE XREF: InitDevLoad+E↑j
                call    SpaceInUMB      ; Do we have space left in the current UMB ?
                jnb     short InitForHi ; yes, we have
                call    ShrinkUMB       ; shrink the current UMB in use
                call    GetUMBForDev    ; else try to allocate new UMB
                jb      short InitForLo ; we didn't succeed, so load in low memory

InitForHi:                              ; CODE XREF: InitDevLoad+23↑j
                                        ; InitDevLoad+28↑j
                mov     ax, cs:DevUMBFree ; get Para addr of free mem
                mov     dx, cs:DevUMBAddr ; UMB start addr
                add     dx, cs:DevUMBSize ; dx = UMB End addr
                jmp     short idl1
; ---------------------------------------------------------------------------

InitForLo:                              ; CODE XREF: InitDevLoad+6↑j
                                        ; InitDevLoad+21↑j ...
                mov     cs:DeviceHi, 0  ; in case we failed to load into UMB
                                        ; indicate that we are loading low
                mov     ax, cs:memhi    ; start of Low memory
                mov     dx, cs:ALLOCLIM ; end of Low memory

idl1:                                   ; CODE XREF: InitDevLoad+40↑j
                call    DevSetMark      ; setup a sub-arena for DD
                mov     cs:DevLoadAddr, ax ; init the Device load address
                mov     cs:DevLoadEnd, dx ; init the limit of the block
                mov     word ptr cs:DevEntry, 0 ; init Entry point to DD
                mov     word ptr cs:DevEntry+2, ax
                retn
InitDevLoad     endp


; =============== S U B R O U T I N E =======================================


SpaceInUMB      proc near               ; CODE XREF: InitDevLoad:InitForConv↑p
                mov     ax, cs:DevUMBSize
                add     ax, cs:DevUMBAddr ; End of UMB
                sub     ax, cs:DevUMBFree ; - Free = Remaining space
                or      ax, ax          ; Nospace ?
                jnz     short spcinumb1
                stc
                retn
; ---------------------------------------------------------------------------

spcinumb1:                              ; CODE XREF: SpaceInUMB+10↑j
                dec     ax              ; space for sub-arena
                cmp     ax, cs:DevSize  ; do we have space ?
                retn
SpaceInUMB      endp


; =============== S U B R O U T I N E =======================================


PrepareMark     proc near               ; CODE XREF: GetUMBForDev+1D↓p
                push    ds
                mov     ds, ax
                mov     word ptr ds:1, 8 ; [ARENA.OWNER]
                mov     word ptr ds:8, 4453h ; [ARENA.NAME],'SD'
                pop     ds
                inc     ax
                mov     cs:DevUMBAddr, ax
                mov     cs:DevUMBFree, ax
                mov     cs:DevUMBSize, bx ; update the UMB Variables
                retn
PrepareMark     endp


; =============== S U B R O U T I N E =======================================


GetUMBForDev    proc near               ; CODE XREF: InitDevLoad+19↑p
                                        ; InitDevLoad+2D↑p
                mov     bx, 0FFFFh
                mov     ax, 4800h
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                or      bx, bx
                jz      short gufd_err
                dec     bx
                cmp     cs:DevSize, bx
                ja      short gufd_err
                inc     bx
                mov     ax, 4800h
                int     21h             ; DOS - 2+ - ALLOCATE MEMORY
                                        ; BX = number of 16-byte paragraphs desired
                jb      short gufd_err
                dec     ax
                call    PrepareMark
                clc
                retn
; ---------------------------------------------------------------------------

gufd_err:                               ; CODE XREF: GetUMBForDev+A↑j
                                        ; GetUMBForDev+12↑j ...
                xor     ax, ax          ; 0
                mov     cs:DevUMBSize, ax ; erase the previous values
                mov     cs:DevUMBAddr, ax
                mov     cs:DevUMBFree, ax
                stc
                retn
GetUMBForDev    endp


; =============== S U B R O U T I N E =======================================


DevSetMark      proc near               ; CODE XREF: InitDevLoad:idl1↑p
                push    es              ; Input :
                                        ; AX - Free segment were device is going to be loaded
                                        ; Output :
                                        ; AX - Segment at which device can be loaded (AX=AX+1)
                                        ;
                                        ; Creates a sub-arena for the device driver
                                        ; puts 'D' marker in the sub-arena
                push    di
                push    ds
                push    si
                mov     es, ax
                mov     byte ptr es:0, 44h ; 'D' ; [es:devmark.id],devmark_device ; 'D'
                inc     ax
                mov     es:1, ax        ; [es:devmark.seg]
                push    ax              ; save load address
                lds     si, cs:bpb_addr ; command line is still there
                mov     di, si
                cld

dsm_again:                              ; CODE XREF: DevSetMark+21↓j
                                        ; DevSetMark+29↓j ...
                lodsb
                cmp     al, 3Ah ; ':'
                jnz     short isit_slash
                mov     di, si
                jmp     short dsm_again
; ---------------------------------------------------------------------------

isit_slash:                             ; CODE XREF: DevSetMark+1D↑j
                cmp     al, 5Ch ; '\'
                jnz     short isit_null
                mov     di, si
                jmp     short dsm_again
; ---------------------------------------------------------------------------

isit_null:                              ; CODE XREF: DevSetMark+25↑j
                or      al, al
                jnz     short dsm_again
                mov     si, di
                mov     di, 8           ; devmark.filename ; 8
                mov     cx, 8           ; maximum 8 characters

dsm_next_char:                          ; CODE XREF: DevSetMark+41↓j
                lodsb
                or      al, al
                jz      short blankout
                cmp     al, 2Eh ; '.'
                jz      short blankout
                stosb
                loop    dsm_next_char

blankout:                               ; CODE XREF: DevSetMark+3A↑j
                                        ; DevSetMark+3E↑j
                jcxz    short dsm_exit
                mov     al, 20h ; ' '
                rep stosb               ; blank out the rest

dsm_exit:                               ; CODE XREF: DevSetMark:blankout↑j
                pop     ax              ; restore load address
                pop     si
                pop     ds
                pop     di
                pop     es
                retn
DevSetMark      endp


; =============== S U B R O U T I N E =======================================


SizeDevice      proc near               ; CODE XREF: SYSINIT:set_dblspc_size↑p
                                        ; doconf+3B9↑p
                push    ds              ; Calculates the size of the device file in paras
                                        ; and stores it in DevSize
                push    es
                pop     ds
                mov     dx, si
                mov     ax, 3D00h
                int     21h             ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
                                        ; DS:DX -> ASCIZ filename
                                        ; AL = access mode
                                        ; 0 - read
                jb      short sd_err
                mov     bx, ax          ; BX - file handle
                mov     ax, 4202h
                xor     cx, cx
                mov     dx, cx
                int     21h             ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
                                        ; AL = method: offset from end of file
                jb      short sd_close
                add     ax, 15
                adc     dx, 0
                test    dx, 0FFF0h      ; size > 0ffffh paras ?
                jz      short sd_ctp    ; no
                mov     cs:DevSize, 0FFFFh ; invalid device size
                                        ; assuming that we fail later
                jmp     short sd_close
; ---------------------------------------------------------------------------

sd_ctp:                                 ; CODE XREF: SizeDevice+23↑j
                mov     cl, 4           ; convert it to paras
                shr     ax, cl
                mov     cl, 12
                shl     dx, cl
                or      ax, dx
                mov     cs:DevSize, ax  ; save file size (in paragraphs)
                clc                     ; CLC is not needed here
                                        ; (OR instruction clears CF) - E.TAN 22/07/2023

sd_close:                               ; CODE XREF: SizeDevice+17↑j
                                        ; SizeDevice+2C↑j
                pushf                   ; save carry flag
                mov     ax, 3E00h
                int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
                                        ; BX = file handle
                popf                    ; restore carry flag
                                        ; (we are not checking for 'close file' err)

sd_err:                                 ; CODE XREF: SizeDevice+A↑j
                pop     ds
                retn
SizeDevice      endp


; =============== S U B R O U T I N E =======================================


ExecDev         proc near               ; CODE XREF: MagicPreload+2D↑p
                                        ; doconf+416↑p
                mov     bx, cs:DevLoadAddr
                mov     cs:DevExecAddr, bx ; Load the parameter block
                mov     cs:DevExecReloc, bx ; block for exec with Load address
                mov     bx, cs
                mov     es, bx
                assume es:SYSINIT
                mov     bx, offset DevExecAddr ; es:bx points to parameters
                mov     al, 3           ; (load program only)
                mov     ah, 4Bh         ; load in the device driver
                int     21h             ; DOS - 2+ - LOAD OR EXECUTE (EXEC)
                                        ; DS:DX -> ASCIZ filename
                                        ; ES:BX -> parameter block
                                        ; AL = type of load
                retn
ExecDev         endp


; =============== S U B R O U T I N E =======================================


RetFromUM       proc near               ; CODE XREF: doconf:BadFile↑p
                                        ; doconf+445↑p ...
                pushf
                mov     cs:ConvLoad, 1  ; ConvLoad set if didn't previously call HideUMBs
                call    UnHideUMBs
                jb      short rfUM1
                mov     cs:ConvLoad, 0  ; ConvLoad clear if did.

rfUM1:                                  ; CODE XREF: RetFromUM+A↑j
                popf
                retn
RetFromUM       endp


; =============== S U B R O U T I N E =======================================


RemoveNull      proc near               ; CODE XREF: doconf+421↑p
                                        ; RemoveNull+8↓j
                mov     bl, es:[si]
                or      bl, bl          ; null ?
                jz      short rn_gotnull
                inc     si              ; advance the pointer
                jmp     short RemoveNull
; ---------------------------------------------------------------------------

rn_gotnull:                             ; CODE XREF: RemoveNull+5↑j
                mov     bl, cs:DevSavedDelim
                mov     es:[si], bl     ; replace null with blank
                retn
RemoveNull      endp


; =============== S U B R O U T I N E =======================================


RoundBreakAddr  proc near               ; CODE XREF: MagicPreload+160↑p
                                        ; doconf+5B0↑p ...
                mov     ax, word ptr cs:DevBrkAddr ; Rounds DevBrkAddr to a para addr
                                        ; so that it is of the form xxxx:0
                call    ParaRound
                add     word ptr cs:DevBrkAddr+2, ax
                mov     word ptr cs:DevBrkAddr, 0
                mov     ax, cs:DevLoadEnd
                cmp     word ptr cs:DevBrkAddr+2, ax
                jbe     short rba_ok
                jmp     mem_err
; ---------------------------------------------------------------------------

rba_ok:                                 ; CODE XREF: RoundBreakAddr+1C↑j
                retn
RoundBreakAddr  endp


; =============== S U B R O U T I N E =======================================


DevSetBreak     proc near               ; CODE XREF: MagicPreload+111↑p
                                        ; MagicPostload+62↑p ...
                push    ax
                mov     ax, word ptr cs:DevBrkAddr+2 ; remove the init code
                cmp     cs:multdeviceflag, 0
                jnz     short set_break_continue ; do not check it.
                cmp     ax, cs:DevLoadAddr
                jnz     short set_break_continue ; if not same, then o.k.
                cmp     word ptr cs:DevBrkAddr, 0
                jz      short break_failed ; [DevBrkAddr+2]=[memhi] & [DevBrkAddr]=0

set_break_continue:                     ; CODE XREF: DevSetBreak+B↑j
                                        ; DevSetBreak+12↑j
                call    RoundBreakAddr
                pop     ax
                clc
                retn
; ---------------------------------------------------------------------------

break_failed:                           ; CODE XREF: DevSetBreak+1A↑j
                pop     ax
                stc
                retn
DevSetBreak     endp


; =============== S U B R O U T I N E =======================================


DevBreak        proc near               ; CODE XREF: MagicPreload+1EB↑p
                                        ; MagicPostload+65↑p ...
                push    ds              ; Marks a succesful install of a device driver
                                        ; Sets device size field in sub-arena &
                                        ; Updates Free ptr in UMB or adjusts memhi
                mov     ax, cs:DevLoadAddr
                mov     bx, word ptr cs:DevBrkAddr+2
                dec     ax              ; seg of sub-arena
                mov     ds, ax
                inc     ax              ; Back to Device segment
                sub     ax, bx
                neg     ax              ; size of device in paras
                mov     ds:3, ax        ; [devmark.size]
                                        ; store it in sub-arena
                cmp     cs:DeviceHi, 0
                jz      short db_lo
                mov     cs:DevUMBFree, bx ; update Free ptr in UMB
                jmp     short db_exit
; ---------------------------------------------------------------------------

db_lo:                                  ; CODE XREF: DevBreak+1B↑j
                mov     cs:memhi, bx
                mov     cs:memlo, 0

db_exit:                                ; CODE XREF: DevBreak+22↑j
                pop     ds
                retn
DevBreak        endp


; =============== S U B R O U T I N E =======================================


ParseSize       proc near               ; CODE XREF: doconf+305↑p
                push    bx              ; Parses the command line for SIZE= command
                mov     bx, si
                mov     cs:DevSizeOption, 0 ; init the value
                mov     cs:DevCmdLine, si
                mov     cs:DevCmdLine+2, es
                call    SkipDelim
                cmp     word ptr es:[si], 4953h ; 'SI'
                jnz     short ps_no_size
                cmp     word ptr es:[si+2], 455Ah ; 'ZE'
                jnz     short ps_no_size
                mov     al, es:[si+4]
                call    delim
                jnz     short ps_no_size ; cf=0 here
                add     si, 5
                call    GetHexNum
                jb      short ps_err
                mov     cs:DevSizeOption, ax
                call    SkipDelim
                mov     bx, si          ; cf=0 here

ps_no_size:                             ; CODE XREF: ParseSize+1C↑j
                                        ; ParseSize+24↑j ...
                mov     si, bx
                pop     bx
                clc                     ; cf=0 here (clc is not needed)
                                        ; 22/07/2023 - Erdogan Tan
                retn
; ---------------------------------------------------------------------------

ps_err:                                 ; CODE XREF: ParseSize+35↑j
                pop     bx
                stc
                retn
ParseSize       endp


; =============== S U B R O U T I N E =======================================


SkipDelim       proc near               ; CODE XREF: ParseSize+14↑p
                                        ; ParseSize+3B↑p ...
                mov     al, es:[si]     ; Skips delimiters in the string pointed to by ES:SI
                                        ; Returns ptr to first non-delimiter character in ES:SI
                call    delim
                jnz     short sd_ret
                inc     si
                jmp     short SkipDelim
; ---------------------------------------------------------------------------

sd_ret:                                 ; CODE XREF: SkipDelim+6↑j
                retn
SkipDelim       endp


; =============== S U B R O U T I N E =======================================


GetHexNum       proc near               ; CODE XREF: ParseSize+32↑p
                xor     ax, ax          ; Converts an ascii string
                                        ; terminated by a delimiter into binary.
                                        ; Assumes that the ES:SI
                                        ; points to a Hexadecimal string
                xor     dx, dx

ghn_next:                               ; CODE XREF: GetHexNum+2B↓j
                mov     bl, es:[si]
                cmp     bl, 0Dh         ; cr
                jz      short ghn_err
                cmp     bl, 0Ah         ; lf
                jz      short ghn_err
                push    ax
                mov     al, bl
                call    delim
                pop     ax
                jz      short ghn_into_paras
                call    GetNibble
                jb      short ghn_err
                mov     cx, 4

ghn_shift1:                             ; CODE XREF: GetHexNum+26↓j
                shl     ax, 1
                rcl     dx, 1
                loop    ghn_shift1
                or      al, bl
                inc     si
                jmp     short ghn_next
; ---------------------------------------------------------------------------

ghn_into_paras:                         ; CODE XREF: GetHexNum+18↑j
                add     ax, 15
                adc     dx, 0
                test    dx, 0FFF0h
                jnz     short ghn_err
                mov     cx, 4

ghn_shift2:                             ; CODE XREF: GetHexNum+41↓j
                clc
                rcr     dx, 1
                rcr     ax, 1
                loop    ghn_shift2
                clc                     ; AX = number of paras equivalent to the
                                        ; hex number of bytes specified
                                        ; by the hexadecimal string.
                retn
; ---------------------------------------------------------------------------

ghn_err:                                ; CODE XREF: GetHexNum+A↑j
                                        ; GetHexNum+F↑j ...
                stc                     ; encountered a non-hex character or crlf
                retn
GetHexNum       endp


; =============== S U B R O U T I N E =======================================


GetNibble       proc near               ; CODE XREF: GetHexNum+1A↑p
                cmp     bl, 30h ; '0'   ; Convert one nibble (hex digit) in BL into binary
                jb      short gnib_err
                cmp     bl, 39h ; '9'
                ja      short is_it_hex
                sub     bl, 30h ; '0'
                retn
; ---------------------------------------------------------------------------

is_it_hex:                              ; CODE XREF: GetNibble+8↑j
                cmp     bl, 41h ; 'A'
                jb      short gnib_err
                cmp     bl, 46h ; 'F'
                ja      short gnib_err
                sub     bl, 37h ; '7'   ; 'A'- 10
                retn
; ---------------------------------------------------------------------------

gnib_err:                               ; CODE XREF: GetNibble+3↑j
                                        ; GetNibble+11↑j ...
                stc
                retn
GetNibble       endp


; =============== S U B R O U T I N E =======================================


AllocUMB        proc near               ; CODE XREF: doconf+4BD↑p
                call    InitAllocUMB    ; Allocate all UMBs and link it to DOS arena chain
                                        ; link in the first UMB
                jb      short au_exit   ; quit on error

au_next:                                ; CODE XREF: AllocUMB+D↓j
                call    umb_allocate    ; allocate
                jb      short au_coalesce
                call    umb_insert      ; & insert till no UMBs
                jmp     short au_next
; ---------------------------------------------------------------------------

au_coalesce:                            ; CODE XREF: AllocUMB+8↑j
                call    umb_coalesce    ; coalesce all UMBs

au_exit:                                ; CODE XREF: AllocUMB+3↑j
                retn
AllocUMB        endp


; =============== S U B R O U T I N E =======================================


InitAllocUMB    proc near               ; CODE XREF: AllocUMB↑p
                call    IsXMSLoaded
                jnz     short iau_err   ; quit on no XMS driver
                mov     ah, 52h
                int     21h             ; DOS - 2+ internal - GET LIST OF LISTS
                                        ; Return: ES:BX -> DOS list of lists
                mov     cs:DevDOSData, es ; save dos data segment
                mov     ax, 4310h
                int     2Fh             ; - Multiplex - XMS - GET DRIVER ADDRESS
                                        ; Return: ES:BX -> driver entry point
                mov     word ptr cs:DevXMSAddr, bx ; get XMS driver address
                mov     word ptr cs:DevXMSAddr+2, es
                cmp     cs:FirstUMBLinked, 0 ; have we already linked a UMB?
                jnz     short ia_1      ; quit if we already did it
                call    LinkFirstUMB    ; else link the first UMB
                jb      short iau_err
                mov     cs:FirstUMBLinked, 0FFh ; mark that 1st UMB linked

ia_1:                                   ; CODE XREF: InitAllocUMB+23↑j
                clc                     ; (cf is already zero here)
                                        ; Erdogan tan - 27/07/2023
                retn
; ---------------------------------------------------------------------------

iau_err:                                ; CODE XREF: InitAllocUMB+3↑j
                                        ; InitAllocUMB+28↑j
                stc
                retn
InitAllocUMB    endp


; =============== S U B R O U T I N E =======================================


umb_allocate    proc near               ; CODE XREF: AllocUMB:au_next↑p
                                        ; LinkFirstUMB↓p
                push    ax
                mov     ah, 16          ; XMM_REQUEST_UMB
                mov     dx, 0FFFFh      ; try to allocate largest possible
                call    cs:DevXMSAddr
                or      dx, dx
                jz      short ua_err
                mov     ah, 16
                call    cs:DevXMSAddr
                cmp     ax, 1           ; Q: was the reqst successful
                jnz     short ua_err    ; N: error
                clc

ua_done:                                ; CODE XREF: umb_allocate+1F↓j
                pop     ax
                retn
; ---------------------------------------------------------------------------

ua_err:                                 ; CODE XREF: umb_allocate+D↑j
                                        ; umb_allocate+19↑j
                stc
                jmp     short ua_done
umb_allocate    endp


; =============== S U B R O U T I N E =======================================


umb_insert      proc near               ; CODE XREF: AllocUMB+A↑p
                push    ds              ; links the UMB into the arena chain
                mov     ds, cs:DevDOSData
                mov     ds, word ptr ds:8Ch ; [UMB_ARENA]  ; ds = UMB_HEAD
                mov     ax, ds
                mov     es, ax
                assume es:nothing

ui_next:                                ; CODE XREF: umb_insert+1F↓j
                cmp     ax, bx          ; BX = seg address of UMB to be linked in
                ja      short ui_insert ; current block above new block, insert it
                cmp     byte ptr es:0, 5Ah ; 'Z' ; [es:ARENA.SIGNATURE],arena_signature_end
                jz      short ui_append ; if current block is the last,
                                        ; append new block to chain
                mov     ds, ax
                call    get_next
                jmp     short ui_next   ; ax = es = next block
; ---------------------------------------------------------------------------

ui_insert:                              ; CODE XREF: umb_insert+10↑j
                mov     cx, ds          ; ds = previous arena
                inc     cx              ; top of previous block
                sub     cx, bx
                neg     cx              ; cx = size of used block
                mov     byte ptr ds:0, 4Dh ; 'M' ; [ARENA.SIGNATURE],arena_signature_normal
                mov     word ptr ds:1, 8 ; [ARENA.OWNER],8 ; mark as system owned
                mov     ds:3, cx        ; [ARENA.SIZE],cx
                mov     word ptr ds:8, 4353h ; [ARENA.NAME],'SC'
                mov     es, bx          ; prepare the arena at start of new block
                mov     byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
                mov     word ptr es:1, 0 ; [es:ARENA.OWNER],arena_owner_system ; mark as free
                sub     dx, 2           ; DX = size of UMB to be linked in paras
                                        ; make room for arena at start & end of new block
                mov     es:3, dx        ; [es:ARENA.SIZE],dx
                add     bx, dx          ; prepare arena at end of new block
                inc     bx
                mov     es, bx          ; es = arena at top of new block
                inc     bx              ; bx = top of new block
                sub     ax, bx          ; ax contains arena just above this block
                                        ; result: ax = size of used block
                mov     byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
                mov     word ptr es:1, 8 ; [es:ARENA.OWNER],8 ; mark as system owned
                mov     es:3, ax        ; [es:ARENA.SIZE],ax
                mov     word ptr es:8, 4353h ; [es:ARENA.NAME],'SC'
                jmp     short ui_done
; ---------------------------------------------------------------------------

ui_append:                              ; CODE XREF: umb_insert+18↑j
                add     ax, es:3        ; es = arena of last block
                                        ; [es:ARENA.SIZE] ; ax=top of last block-1 para
                sub     word ptr es:3, 1 ; reserve space on top of this
                                        ; block for the next arena.
                mov     byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
                mov     cx, ax          ; cx = top of prev block-1
                inc     ax
                sub     ax, bx          ; ax = top of prev block - seg. addr of new block
                neg     ax
                mov     es, cx          ; es = arena of unused block
                mov     byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
                mov     word ptr es:1, 8 ; [es:ARENA.OWNER],8 ; mark as system owned
                mov     es:3, ax        ; mov [es:ARENA.SIZE],ax
                mov     word ptr es:8, 4353h ; mov word [es:ARENA.NAME],'SC'
                mov     es, bx          ; prepare the arena at start of new block
                mov     byte ptr es:0, 5Ah ; 'Z' ; [es:ARENA.SIGNATURE],arena_signature_end
                mov     word ptr es:1, 0 ; [es:ARENA.OWNER],arena_owner_system
                                        ; mark as free
                dec     dx              ; make room for arena
                mov     es:3, dx        ; mov [es:ARENA.SIZE],dx

ui_done:                                ; CODE XREF: umb_insert+74↑j
                pop     ds
                retn
umb_insert      endp


; =============== S U B R O U T I N E =======================================


umb_coalesce    proc near               ; CODE XREF: AllocUMB:au_coalesce↑p
                xor     di, di          ; Combine free blocks ahead with current block
                mov     es, cs:DevDOSData
                mov     es, word ptr es:8Ch ; [es:UMB_ARENA] ; es = UMB_HEAD

uc_nextfree:                            ; CODE XREF: umb_coalesce+1C↓j
                                        ; umb_coalesce+28↓j
                mov     ax, es
                mov     ds, ax
                cmp     es:1, di        ; [es:ARENA.OWNER],di
                                        ; Q: is current arena free
                jz      short uc_again  ; Y: try to coalesce with next block
                                        ; N: get next arena
                call    get_next        ; es, ax = next arena
                jb      short uc_done
                jmp     short uc_nextfree
; ---------------------------------------------------------------------------

uc_again:                               ; CODE XREF: umb_coalesce+15↑j
                                        ; umb_coalesce+39↓j
                call    get_next        ; es, ax = next arena
                jb      short uc_done
                cmp     es:1, di        ; [es:ARENA.OWNER],di
                                        ; Q: is arena free
                jnz     short uc_nextfree ; N: get next free arena
                                        ; Y: coalesce
                mov     cx, es:3        ; [es:ARENA.SIZE]
                                        ; cx = next block size
                inc     cx              ; cx = cx + 1 (for header size)
                add     ds:3, cx        ; [ARENA.SIZE],cx
                                        ; current size = current size + cx
                mov     cl, es:[di]     ; move up signature
                mov     [di], cl
                jmp     short uc_again  ; try again
; ---------------------------------------------------------------------------

uc_done:                                ; CODE XREF: umb_coalesce+1A↑j
                                        ; umb_coalesce+21↑j
                retn
umb_coalesce    endp


; =============== S U B R O U T I N E =======================================


get_next        proc near               ; CODE XREF: umb_insert+1C↑p
                                        ; umb_coalesce+17↑p ...
                cmp     byte ptr ds:0, 5Ah ; 'Z' ; Find Next item in Arena
                                        ; cmp byte [ARENA.SIGNATURE],arena_signature_end
                jz      short gn_err
                mov     ax, ds          ; ax = current block
                add     ax, ds:3        ; add ax,[ARENA.SIZE]
                                        ; ax = ax + current block length
                inc     ax              ; remember that header!
                mov     es, ax
                clc
                retn
; ---------------------------------------------------------------------------

gn_err:                                 ; CODE XREF: get_next+5↑j
                stc
                retn
get_next        endp


; =============== S U B R O U T I N E =======================================


LinkFirstUMB    proc near               ; CODE XREF: InitAllocUMB+25↑p
                call    umb_allocate
                jb      short lfu_er
                int     12h             ; MEMORY SIZE -
                                        ; Return: AX = number of contiguous 1K blocks of memory
                mov     cl, 6
                shl     ax, cl          ; ax = size in paragraphs
                mov     cx, ax
                sub     ax, bx          ; bx = segment of allocated UMB
                                        ; ax = - size of unused block
                neg     ax
                sub     cx, 1           ; cx = first umb_arena
                mov     es, cx          ; es = first umb_arena
                mov     byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
                mov     word ptr es:1, 8 ; [es:ARENA.OWNER],8 ; mark as system owned
                mov     es:3, ax        ; mov [es:ARENA.SIZE],ax
                mov     word ptr es:8, 4353h ; [es:ARENA.NAME],'SC'
                mov     es, bx          ; put in the arena for the first UMB
                                        ; es has first free umb seg
                mov     byte ptr es:0, 5Ah ; 'Z' ; [es:ARENA.SIGNATURE],arena_signature_end
                mov     word ptr es:1, 0 ; es:ARENA.OWNER],arena_owner_system
                                        ; mark as free
                dec     dx              ; dx = size of UMB
                                        ; make room for arena
                mov     es:3, dx        ; [es:ARENA.SIZE],dx
                mov     es, cs:DevDOSData
                mov     di, 8Ch         ; UMB_ARENA
                mov     es:[di], cx     ; initialize umb_head in DOS data segment
                                        ; with the arena just below Top of Memory
                                        ;
                                        ; we must now scan the arena chain and
                                        ; update the size of the last arena
                mov     di, 24h         ; DOS_ARENA
                mov     es, word ptr es:[di] ; es = start arena
                xor     di, di

scannext:                               ; CODE XREF: LinkFirstUMB+66↓j
                cmp     byte ptr es:[di], 5Ah ; 'Z' ; arena_signature_end
                jz      short got_last
                mov     ax, es
                add     ax, es:3        ; [es:ARENA.SIZE]
                inc     ax
                mov     es, ax
                jmp     short scannext
; ---------------------------------------------------------------------------

got_last:                               ; CODE XREF: LinkFirstUMB+5A↑j
                sub     word ptr es:3, 1 ; sub word [es:ARENA.SIZE],1
                mov     byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
                clc
                retn
; ---------------------------------------------------------------------------

lfu_er:                                 ; CODE XREF: LinkFirstUMB+3↑j
                stc
                retn
LinkFirstUMB    endp


; =============== S U B R O U T I N E =======================================


ShrinkUMB       proc near               ; CODE XREF: SYSINIT:086D↑p
                                        ; InitDevLoad+10↑p ...
                cmp     cs:DevUMBAddr, 0 ; Shrinks the current UMB in use,
                                        ; so that the unused portions of the UMB
                                        ; is given back to the DOS free mem pool
                jz      short su_exit
                push    es
                push    bx
                mov     bx, cs:DevUMBFree
                sub     bx, cs:DevUMBAddr
                mov     es, cs:DevUMBAddr
                mov     ax, 4A00h
                int     21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
                                        ; ES = segment address of block to change
                                        ; BX = new size in paragraphs
                mov     ax, es
                dec     ax
                mov     es, ax
                assume es:nothing
                mov     word ptr es:1, 8 ; [es:ARENA.OWNER]
                pop     bx
                pop     es
                assume es:nothing

su_exit:                                ; CODE XREF: ShrinkUMB+6↑j
                retn
ShrinkUMB       endp


; =============== S U B R O U T I N E =======================================


UnlinkUMB       proc near               ; CODE XREF: SYSINIT:0870↑p
                push    ds              ; Unlinks the UMBs from the DOS arena chain
                push    es
                cmp     cs:FirstUMBLinked, 0
                jz      short ulu_x     ; nothing to unlink
                mov     es, cs:DevDOSData ; get DOS data seg
                mov     ds, word ptr es:24h ; [es:DOS_ARENA]
                mov     di, es:8Ch      ; [es:UMB_ARENA]

ulu_next:                               ; CODE XREF: UnlinkUMB+24↓j
                call    get_next
                jb      short ulu_x
                cmp     di, ax          ; is the next one UMB ?
                jz      short ulu_found
                mov     ds, ax
                jmp     short ulu_next
; ---------------------------------------------------------------------------

ulu_found:                              ; CODE XREF: UnlinkUMB+20↑j
                mov     byte ptr ds:0, 5Ah ; 'Z' ; [ARENA.SIGNATURE],arena_signature_end

ulu_x:                                  ; CODE XREF: UnlinkUMB+8↑j
                                        ; UnlinkUMB+1C↑j
                pop     es
                pop     ds
                retn
UnlinkUMB       endp

; ---------------------------------------------------------------------------
                db 2 dup(0)

; =============== S U B R O U T I N E =======================================


setparms        proc near               ; CODE XREF: doconf+85C↑p
                push    ds
                push    ax
                push    bx
                push    cx
                push    dx
                push    cs
                pop     ds
                assume ds:SYSINIT
                xor     bx, bx
                mov     bl, drive
                inc     bl              ; get it correct for ioctl call
                                        ; (1=A,2=A...)
                mov     dx, offset devp_specialfunc ; offset deviceparameters
                mov     ah, 44h         ; IOCTL
                mov     al, 0Dh         ; GENERIC_IOCTL
                mov     ch, 8           ; RAWIO
                mov     cl, 40h         ; SET_DEVICE_PARAMETERS
                int     21h             ; DOS - 2+ - IOCTL -
                mov     ax, 70h         ; DOSBIODATASEG ; BIOSDATA segment
                mov     ds, ax
                assume ds:nothing
                test    cs:switches, 4  ; flagec35
                jz      short not_ec35
                mov     cl, cs:drive    ; which drive was this for?
                mov     al, 1           ; assume drive 0
                shl     al, cl          ; set proper bit depending on drive
                or      ds:ec35_flag, al ; set the bit in the permanent flags

not_ec35:                               ; CODE XREF: setparms+28↑j
                mov     al, byte ptr cs:devp_spt ; mov al,[cs:deviceparameters+20]
                                        ; [cs:deviceparameters+A_DEVICEPARAMETERS.DP_BPB
                                        ; +A_BPB.BPB_SECTORSPERTRACK]
                cmp     al, ds:eot
                jbe     short eot_ok
                mov     ds:eot, al

eot_ok:                                 ; CODE XREF: setparms+3F↑j
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                pop     ds
                assume ds:nothing
                retn
setparms        endp


; =============== S U B R O U T I N E =======================================


diddleback      proc near               ; CODE XREF: doconf+85F↑p
                push    ds              ; replace default values for further drivparm commands
                push    cs
                pop     ds
                assume ds:SYSINIT
                mov     devp_cylinders, 80 ; [deviceparameters+4],80
                                        ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],80
                mov     devp_devtype, 2 ; [deviceparameters+1],2
                                        ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_3INCH720KB
                mov     devp_devattr, 0 ; [deviceparameters+2],0
                                        ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],0
                mov     switches, 0     ; zero all switches
                pop     ds
                assume ds:nothing
                retn
diddleback      endp


; =============== S U B R O U T I N E =======================================


parseline       proc near               ; CODE XREF: doconf+857↑p
                push    ds
                push    cs
                pop     ds
                assume ds:SYSINIT

nextswtch:                              ; CODE XREF: parseline+24↓j
                cmp     al, 0Dh         ; al contains the first character in command line.
                jz      short done_line ; cr
                cmp     al, 0Ah
                jz      short put_back  ; lf ; put it back and done
                cmp     al, 20h ; ' '
                jbe     short getnext   ; skip over space
                cmp     al, 2Fh ; '/'
                jz      short getparm
                stc                     ; mark error invalid-character-in-input
                jmp     short exitpl
; ---------------------------------------------------------------------------

getparm:                                ; CODE XREF: parseline+11↑j
                call    check_switch
                mov     switches, bx    ; save switches read so far
                jb      short swterr

getnext:                                ; CODE XREF: parseline+D↑j
                call    getchr
                jb      short done_line
                jmp     short nextswtch
; ---------------------------------------------------------------------------

swterr:                                 ; CODE XREF: parseline+1D↑j
                jmp     short exitpl    ; exit if error
; ---------------------------------------------------------------------------

done_line:                              ; CODE XREF: parseline+5↑j
                                        ; parseline+22↑j ...
                test    switches, 8     ; flagdrive ; see if drive specified
                jnz     short okay
                stc                     ; mark error no-drive-specified
                jmp     short exitpl
; ---------------------------------------------------------------------------

okay:                                   ; CODE XREF: parseline+2E↑j
                mov     ax, switches
                and     ax, 3           ; get flag bits for changeline and non-rem
                mov     devp_devattr, ax ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
                mov     devp_trktblents, 0 ; [deviceparameters+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]
                clc                     ; everything is fine
                call    setdeviceparameters

exitpl:                                 ; CODE XREF: parseline+14↑j
                                        ; parseline:swterr↑j ...
                pop     ds
                assume ds:nothing
                retn
; ---------------------------------------------------------------------------

put_back:                               ; CODE XREF: parseline+9↑j
                inc     ds:count        ; one more char to scan
                dec     ds:chrptr       ; back up over linefeed
                jmp     short done_line
parseline       endp


; =============== S U B R O U T I N E =======================================


check_switch    proc near               ; CODE XREF: parseline:getparm↑p
                call    getchr
                jb      short err_chk
                and     al, 0DFh        ; convert it to upper case
                cmp     al, 41h ; 'A'
                jb      short err_chk
                cmp     al, 5Ah ; 'Z'
                ja      short err_chk
                push    es
                push    cs
                pop     es
                assume es:SYSINIT
                mov     cl, byte ptr ds:switchlist ; get number of valid switches
                mov     ch, 0           ; point to string of valid switches
                mov     di, (offset switchlist+1) ; "FHSTDICN"
                repne scasb
                pop     es
                assume es:nothing
                jnz     short err_chk
                mov     ax, 1
                shl     ax, cl          ; set bit to indicate switch
                mov     bx, ds:switches ; get switches so far
                or      bx, ax          ; save this with other switches
                mov     cx, ax
                test    ax, 0F8h        ; switchnum ; 0F8h
                                        ; test against switches that require number to follow
                jz      short done_swtch
                call    getchr
                jb      short err_swtch
                cmp     al, ':'
                jnz     short err_swtch
                call    getchr
                push    bx              ; preserve switches
                mov     cs:sepchr, 20h ; ' ' ; allow space separators
                call    getnum
                mov     cs:sepchr, 0
                pop     bx              ; restore switches
                call    process_num

done_swtch:                             ; CODE XREF: check_switch+30↑j
                clc
                retn
; ---------------------------------------------------------------------------

err_swtch:                              ; CODE XREF: check_switch+35↑j
                                        ; check_switch+39↑j
                xor     bx, cx          ; remove this switch from the records

err_chk:                                ; CODE XREF: check_switch+3↑j
                                        ; check_switch+9↑j ...
                stc
                retn
check_switch    endp


; =============== S U B R O U T I N E =======================================


process_num     proc near               ; CODE XREF: check_switch+4F↑p
                test    ds:switches, cx ; if this switch has been done before,
                jnz     short done_ret  ; ignore this one.
                test    cx, 8           ; flagdrive
                jz      short try_f
                mov     ds:drive, al
                jmp     short done_ret
; ---------------------------------------------------------------------------

try_f:                                  ; CODE XREF: process_num+A↑j
                test    cx, 80h         ; flagff
                jz      short try_t
                mov     ds:devp_devtype, al
                jmp     short done_ret
; ---------------------------------------------------------------------------

try_t:                                  ; CODE XREF: process_num+15↑j
                or      ax, ax          ; if number entered was 0, assume default value
                jz      short done_ret
                test    cx, 10h         ; flagcyln
                jz      short try_s
                mov     ds:devp_cylinders, ax ; [deviceparameters+4],ax
                                        ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
                jmp     short done_ret
; ---------------------------------------------------------------------------

try_s:                                  ; CODE XREF: process_num+24↑j
                test    cx, 20h         ; flagseclim
                jz      short try_h     ; must be for number of heads
                mov     ds:slim, ax
                jmp     short done_ret
; ---------------------------------------------------------------------------

try_h:                                  ; CODE XREF: process_num+2F↑j
                mov     ds:hlim, ax

done_ret:                               ; CODE XREF: process_num+4↑j
                                        ; process_num+F↑j ...
                clc                     ; (test instruction resets cf)
                retn
process_num     endp


; =============== S U B R O U T I N E =======================================


setdeviceparameters proc near           ; CODE XREF: parseline+43↑p
                push    es
                push    cs
                pop     es
                assume es:SYSINIT
                xor     bx, bx
                mov     bl, ds:devp_devtype ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE]
                cmp     bl, 0           ; DEV_5INCH
                jnz     short got_80
                mov     ds:devp_cylinders, 40 ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
                                        ; 48 tpi = 40 cyl

got_80:                                 ; CODE XREF: setdeviceparameters+C↑j
                shl     bx, 1           ; get index into bpb table
                mov     si, ds:_bpbtable[bx] ; get address of bpb
                mov     di, offset devp_bps ; deviceparameters+7
                                        ; deviceparameters+A_DEVICEPARAMETERS.DP_BPB
                                        ; es:di -> bpb
                mov     cx, 59          ; A_BPB.size
                cld
                rep movsb
                pop     es
                assume es:nothing
                test    ds:switches, 20h ; flagseclim
                jz      short see_heads
                mov     ax, ds:slim
                mov     ds:devp_spt, ax ; [deviceparameters+20]
                                        ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
                                        ;  +A_BPB.BPB_SECTORSPERTRACK]

see_heads:                              ; CODE XREF: setdeviceparameters+2A↑j
                test    ds:switches, 40h ; flagheads
                jz      short heads_not_altered
                mov     ax, ds:hlim
                mov     ds:devp_heads, ax ; [deviceparameters+22]
                                        ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]

heads_not_altered:                      ; CODE XREF: setdeviceparameters+38↑j
                mov     ds:devp_secperclus, 2 ; [deviceparameters+9],2
                                        ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
                                        ;  +A_BPB.BPB_SECTORSPERCLUSTER]
                mov     bl, 0F0h        ; get default mediabyte
                mov     bh, ds:devp_mediaid ; [deviceparameters+17]
                                        ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR]
                cmp     ds:devp_heads, 2
                ja      short got_correct_mediaid ; just use default if heads>2
                jnz     short only_one_head ; one head, do one head stuff
                mov     bl, bh
                cmp     ds:devp_spt, 18 ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
                                        ;  +A_BPB.BPB_SECTORSPERTRACK]
                jnz     short not_144m
                cmp     ds:devp_cylinders, 80 ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
                jnz     short not_144m
                jmp     short got_one_secperclus_drive ; cyl=80, heads=2, secpertrack=18.
                                        ;  Set cluster size to 1.
; ---------------------------------------------------------------------------

not_144m:                               ; CODE XREF: setdeviceparameters+5B↑j
                                        ; setdeviceparameters+62↑j
                cmp     ds:devp_cylinders, 40 ; check for 320K
                jnz     short got_correct_mediaid
                cmp     ds:devp_spt, 8
                jnz     short got_correct_mediaid
                mov     bl, 0FCh
                jmp     short got_correct_mediaid
; ---------------------------------------------------------------------------

only_one_head:                          ; CODE XREF: setdeviceparameters+52↑j
                cmp     ds:devp_devtype, 0 ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_5INCH
                jnz     short got_one_secperclus_drive
                mov     bl, 0FCh        ; single sided 9 sector media id
                cmp     ds:devp_spt, 8  ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
                                        ; +A_BPB.BPB_SECTORSPERTRACK],8
                jnz     short got_one_secperclus_drive ; okay if anything besides 8
                mov     bl, 0FEh        ; 160K mediaid

got_one_secperclus_drive:               ; CODE XREF: setdeviceparameters+64↑j
                                        ; setdeviceparameters+7D↑j ...
                mov     ds:devp_secperclus, 1 ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
                                        ;  +A_BPB.BPB_SECTORSPERCLUSTER],1

got_correct_mediaid:                    ; CODE XREF: setdeviceparameters+50↑j
                                        ; setdeviceparameters+6B↑j ...
                mov     ds:devp_mediaid, bl ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
                                        ;  +A_BPB.BPB_MEDIADESCRIPTOR],bl
                mov     ax, ds:devp_cylinders ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
                mul     ds:devp_heads   ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]
                mul     ds:devp_spt     ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
                mov     ds:devp_totalsecs, ax ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
                clc
                retn
setdeviceparameters endp


; =============== S U B R O U T I N E =======================================


organize        proc near               ; CODE XREF: doconf:getcom↑p
                mov     cx, cs:count
                jcxz    short nochar1
                xor     si, si
                mov     di, si
                xor     ax, ax
                mov     cs:com_level, 0

org1:                                   ; CODE XREF: organize+21↓j
                                        ; organize+2C↓j ...
                call    skip_comment
                jz      short end_commd_line ; found a comment string and skipped.
                call    get2            ; not a comment string. then get a char.
                cmp     al, 0Ah         ; lf
                jz      short end_commd_line ; starts with a blank line.
                cmp     al, 20h ; ' '
                jbe     short org1      ; skip leading control characters
                jmp     short findit
; ---------------------------------------------------------------------------

end_commd_line:                         ; CODE XREF: organize+16↑j
                                        ; organize+1D↑j ...
                stosb                   ; store line feed char in buffer for the linecount.
                mov     cs:com_level, 0 ; reset the command level.
                jmp     short org1
; ---------------------------------------------------------------------------

nochar1:                                ; CODE XREF: organize+5↑j
                stc
                retn
; ---------------------------------------------------------------------------

findit:                                 ; CODE XREF: organize+23↑j
                push    cx              ; prepare to search command table
                push    si
                push    di
                mov     bp, si
                dec     bp
                mov     si, offset comtab ; "\x01[["
                mov     ch, 0

findcom:                                ; CODE XREF: organize+59↓j
                                        ; organize+80↓j
                mov     di, bp
                mov     cl, [si]
                inc     si
                jcxz    short nocom
                cmp     byte ptr es:[di], 3Bh ; ';' ; CONFIG_SEMICOLON
                jz      short semicolon

loopcom:                                ; CODE XREF: organize+52↓j
                mov     al, es:[di]
                inc     di
                and     al, 0DFh        ; ~20h ; force upper case
                inc     si
                cmp     al, [si-1]      ; compare to byte @es:di
                loope   loopcom
                lahf
                add     si, cx          ; bump to next position without affecting flags
                sahf
                lodsb
                jnz     short findcom
                cmp     byte ptr es:[di], 0Dh ; the next char might be cr,lf
                jz      short gotcom0
                cmp     byte ptr es:[di], 0Ah ; such as in "rem",cr,lf case.
                jz      short gotcom0
                cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
                jz      short gotcom0
                push    ax
                mov     al, es:[di]     ; now the next char. should be a delim.
                cmp     al, 3Fh ; '?'   ; explicit interactive command?
                jnz     short no_query  ; no
                pop     ax              ; yes, so retrieve the original code
                or      al, 80h         ; CONFIG_OPTION_QUERY ; and set the QUERY bit
                jmp     short gotcom0
; ---------------------------------------------------------------------------

semicolon:                              ; CODE XREF: organize+46↑j
                mov     al, 30h ; '0'   ; CONFIG_REM
                jmp     short gotcom0
; ---------------------------------------------------------------------------

no_query:                               ; CODE XREF: organize+71↑j
                call    delim
                pop     ax
                jnz     short findcom

gotcom0:                                ; CODE XREF: organize+5F↑j
                                        ; organize+65↑j ...
                pop     di
                pop     si
                pop     cx
                jmp     short gotcom
; ---------------------------------------------------------------------------

nocom:                                  ; CODE XREF: organize+40↑j
                pop     di
                pop     si
                pop     cx
                mov     al, 5Ah ; 'Z'   ; CONFIG_UNKNOWN
                stosb                   ; save indicator char.

_skipline:                              ; CODE XREF: organize+92↓j
                call    get2
                cmp     al, 0Ah         ; lf ; skip this bad command line
                jnz     short _skipline
                jmp     short end_commd_line
; ---------------------------------------------------------------------------

gotcom:                                 ; CODE XREF: organize+85↑j
                stosb                   ; save indicator char in buffer
                and     al, 7Fh         ; ~CONFIG_OPTION_QUERY
                mov     cs:cmd_indicator, al ; save it for the future use.
                cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
                jz      short org31
                cmp     al, 4Fh ; 'O'   ; CONFIG_SUBMENU
                jz      short org2
                cmp     al, 45h ; 'E'   ; CONFIG_MENUITEM
                jz      short org2
                cmp     al, 41h ; 'A'   ; CONFIG_MENUDEFAULT
                jz      short org2
                cmp     al, 4Ah ; 'J'   ; CONFIG_INCLUDE
                jz      short org2
                call    mapcase         ; map case of rest of line to UPPER

org2:                                   ; CODE XREF: organize+A3↑j
                                        ; organize+A7↑j ...
                call    get2            ; skip the command name until delimiter
                cmp     al, 0Ah         ; lf
                jz      short org21
                cmp     al, 0Dh         ; cr
                jz      short org21
                cmp     al, 2Fh ; '/'   ; Added to allow DEVHIGH/L:...
                jz      short org21     ; to be parsed properly
                call    delim
                jnz     short org2
                jmp     short org3
; ---------------------------------------------------------------------------

org21:                                  ; CODE XREF: organize+B9↑j
                                        ; organize+BD↑j ...
                dec     si              ; if cr or lf then
                inc     cx              ; undo si, cx register and continue

org3:                                   ; CODE XREF: organize+C8↑j
                cmp     cs:cmd_indicator, 59h ; 'Y' ; CONFIG_COMMENT
                jz      short get_cmt_token
                cmp     cs:cmd_indicator, 44h ; 'D' ; CONFIG_DEVICE
                jz      short org_file
                cmp     cs:cmd_indicator, 49h ; 'I' ; CONFIG_INSTALL
                jz      short org_file
                cmp     cs:cmd_indicator, 57h ; 'W' ; CONFIG_INSTALLHIGH
                jz      short org_file
                cmp     cs:cmd_indicator, 53h ; 'S' ; CONFIG_SHELL
                jz      short org_file
                cmp     cs:cmd_indicator, 31h ; '1' ; CONFIG_SWITCHES
                jz      short org_switch

org31:                                  ; CODE XREF: organize+9F↑j
                jmp     org4
; ---------------------------------------------------------------------------

org_switch:                             ; CODE XREF: organize+FA↑j
                                        ; organize+10A↓j
                call    skip_comment
                jz      short end_commd_line_brdg
                call    get2
                call    org_delim
                jz      short org_switch
                stosb
                jmp     org5
; ---------------------------------------------------------------------------

org_file:                               ; CODE XREF: organize+DA↑j
                                        ; organize+E2↑j ...
                call    skip_comment    ; get the filename and put 0 at end
                jz      short org_put_zero
                call    get2            ; not a comment
                call    delim
                jz      short org_file  ; skip the possible delimiters
                stosb                   ; copy the first non delim char found in buffer

org_copy_file:                          ; CODE XREF: organize+132↓j
                call    skip_comment    ; comment char in the filename?
                jz      short org_put_zero ; then stop copying filename at that point
                call    get2
                cmp     al, 2Fh ; '/'   ; a switch char? (device=filename/xxx)
                jz      short end_file_slash ; this will be the special case.
                stosb                   ; save the char. in buffer
                call    delim
                jz      short end_copy_file
                cmp     al, 20h ; ' '
                ja      short org_copy_file ; keep copying
                jmp     short end_copy_file ; otherwise, assume end of the filename.
; ---------------------------------------------------------------------------

get_cmt_token:                          ; CODE XREF: organize+D2↑j
                                        ; organize+13B↓j ...
                call    get2            ; get the token. just max. 2 char.
                cmp     al, 20h ; ' '   ; skip white spaces or "=" char.
                jz      short get_cmt_token ; (we are allowing the other special
                cmp     al, 9           ; characters can used for comment id.
                jz      short get_cmt_token ; character.)
                cmp     al, 3Dh ; '='   ; = is special in this case.
                jz      short get_cmt_token
                cmp     al, 0Dh
                jz      short get_cmt_end ; cannot accept the carriage return
                cmp     al, 0Ah
                jz      short get_cmt_end
                mov     cs:cmmt1, al    ; store it
                mov     cs:cmmt, 1      ; 1 char. so far.
                call    get2
                cmp     al, 20h ; ' '   ; space
                jz      short get_cmt_end
                cmp     al, 9           ; tab
                jz      short get_cmt_end
                cmp     al, 0Dh         ; cr
                jz      short get_cmt_end
                cmp     al, 0Ah         ; lf
                jz      short end_commd_line_brdg
                mov     cs:cmmt2, al
                inc     cs:cmmt

get_cmt_end:                            ; CODE XREF: organize+147↑j
                                        ; organize+14B↑j ...
                call    get2
                cmp     al, 0Ah         ; lf
                jnz     short get_cmt_end ; skip it.

end_commd_line_brdg:                    ; CODE XREF: organize+102↑j
                                        ; organize+168↑j ...
                jmp     end_commd_line  ; else jmp to end_commd_line
; ---------------------------------------------------------------------------

org_put_zero:                           ; CODE XREF: organize+113↑j
                                        ; organize+121↑j
                mov     byte ptr es:[di], 0 ; make the filename in front of
                                        ; the comment string to be an asciiz.
                inc     di
                jmp     end_commd_line  ; (maybe null if device=/*)
; ---------------------------------------------------------------------------

end_file_slash:                         ; CODE XREF: organize+128↑j
                mov     byte ptr es:[di], 0 ; al = "/" option char.
                                        ; make a filename an asciiz
                inc     di              ; and
                stosb                   ; store "/" after that.
                jmp     short org5      ; continue with the rest of the line
; ---------------------------------------------------------------------------

end_copy_file:                          ; CODE XREF: organize+12E↑j
                                        ; organize+134↑j
                mov     byte ptr es:[di-1], 0 ; make it an asciiz and handle the next char.
                cmp     al, 0Ah         ; lf
                jz      short end_commd_line_brdg
                jmp     short org5
; ---------------------------------------------------------------------------

org4:                                   ; CODE XREF: organize:org31↑j
                                        ; organize+1A3↓j
                call    skip_comment    ; org4 skips all delimiters
                                        ; after the command name except for '/'
                jz      short end_commd_line_brdg
                call    get2
                call    org_delim       ; skip delimiters except '/'
                jz      short org4
                jmp     short org51
; ---------------------------------------------------------------------------

org5:                                   ; CODE XREF: organize+10D↑j
                                        ; organize+18B↑j ...
                call    skip_comment    ; rest of the line is
                jz      short end_commd_line_brdg ; comment.
                call    get2            ; not a comment.

org51:                                  ; CODE XREF: organize+1A5↑j
                stosb                   ; copy the character
                cmp     al, 22h ; '"'   ; a quote ?
                jz      short at_quote
                cmp     al, 20h ; ' '   ; cmp al,0Ah
                                        ; jne short org5
                                        ; jmp org1 (Erdogan Tan - 28/07/2023)
                ja      short org5
                cmp     al, 0Ah         ; cmp al,lf
                jz      short org1_brdg
                jmp     short org5
; ---------------------------------------------------------------------------

org1_brdg:                              ; CODE XREF: organize+1BA↑j
                jmp     org1
; ---------------------------------------------------------------------------

at_quote:                               ; CODE XREF: organize+1B2↑j
                cmp     cs:com_level, 0
                jz      short up_level
                mov     cs:com_level, 0 ; reset it
                jmp     short org5
; ---------------------------------------------------------------------------

up_level:                               ; CODE XREF: organize+1C7↑j
                inc     cs:com_level    ; set it
                jmp     short org5
organize        endp

; ---------------------------------------------------------------------------

get2:                                   ; CODE XREF: organize+18↑p
                                        ; organize:_skipline↑p ...
                jcxz    short noget
                lods    byte ptr es:[si]
                dec     cx
                retn
; ---------------------------------------------------------------------------

noget:                                  ; CODE XREF: SYSINIT:get2↑j
                                        ; skip_comment↓j ...
                pop     cx              ; This was the rather kludgy way
                                        ; out of procedure "organize",
                                        ; but instead of returning to doconf,
                                        ; we now want to check config.sys BEGIN/END blocks
                                        ; and the new boot menu stuff
                mov     cs:count, di
                mov     cs:org_count, di
                xor     si, si
                mov     cs:chrptr, si
                mov     cx, di
                jmp     menu_check

; =============== S U B R O U T I N E =======================================


skip_comment    proc near               ; CODE XREF: organize:org1↑p
                                        ; organize:org_switch↑p ...
                jcxz    short noget     ; get out of the organize routine.
                                        ; ...
                                        ; skip the commented string until lf,
                                        ; if current es:si-> a comment string.
                                        ; ...
                cmp     cs:com_level, 0 ; only check it if parameter level is 0.
                jnz     short no_commt  ; (not inside quotations)
                cmp     cs:cmmt, 1
                jb      short no_commt
                mov     al, es:[si]
                cmp     cs:cmmt1, al
                jnz     short no_commt
                cmp     cs:cmmt, 2
                jnz     short skip_cmmt
                mov     al, es:[si+1]
                cmp     cs:cmmt2, al
                jnz     short no_commt

skip_cmmt:                              ; CODE XREF: skip_comment+22↑j
                                        ; skip_comment+38↓j
                jcxz    short noget     ; get out of organize routine.
                mov     al, es:[si]
                inc     si
                dec     cx
                cmp     al, 0Ah         ; lf ; line feed ?
                jnz     short skip_cmmt

no_commt:                               ; CODE XREF: skip_comment+8↑j
                                        ; skip_comment+10↑j ...
                retn
skip_comment    endp


; =============== S U B R O U T I N E =======================================


kbd_read        proc near               ; CODE XREF: doconf+1A↑p
                                        ; menu_check+5E↓p
                test    ds:bDisableUI, 2 ; wait for keystroke
                jnz     short kbd_nodelay ;
                                        ; the bios timer tick count is incremented
                                        ; 18.2 times per second;
                                        ; watch the timer tick count for 37 transitions
                                        ; get initial value
                push    ds
                sub     ax, ax
                mov     ds, ax
                assume ds:nothing

kbd_loop:                               ; CODE XREF: kbd_read+25↓j
                mov     ah, 1           ; peek the keyboard
                int     16h             ; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
                                        ; Return: ZF clear if character in buffer
                                        ; AH = scan code, AL = character
                                        ; ZF set if no character in buffer
                jnz     short kbd_loopdone
                mov     ah, 2
                int     16h             ; KEYBOARD - GET SHIFT STATUS
                                        ; AL = shift status bits
                test    al, 3           ; either right or left shift key bits set?
                jnz     short kbd_loopdone ; yes
                mov     ax, ds:046Ch    ; system timer, lw
                sub     ax, cs:_timer_lw_ ; get difference
                cmp     ax, 37          ; reached limit? ; (2 seconds)
                jb      short kbd_loop

kbd_loopdone:                           ; CODE XREF: kbd_read+10↑j
                                        ; kbd_read+18↑j
                pop     ds              ; delay complete!
                assume ds:nothing

kbd_nodelay:                            ; CODE XREF: kbd_read+5↑j
                sub     bx, bx          ; assume clean boot
                mov     ah, 2           ; peek the shift states
                int     16h             ; KEYBOARD - GET SHIFT STATUS
                                        ; AL = shift status bits
                test    al, 3           ; either right or left shift key bits set?
                jz      short kbd_notshift ; no
                inc     bx              ; yes
                inc     bx
                or      ds:bQueryOpt, 4

kbd_notshift:                           ; CODE XREF: kbd_read+30↑j
                mov     ah, 1           ; peek the keyboard
                int     16h             ; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
                                        ; Return: ZF clear if character in buffer
                                        ; AH = scan code, AL = character
                                        ; ZF set if no character in buffer
                jz      short kbd_test  ; no key present
                or      al, al          ; is it a function key?
                jnz     short kbd_test  ; no
                cmp     ah, 62h         ; CTRL F5
                jz      short kbd_cfg_bypass
                cmp     ah, 3Fh         ; F5 function key?
                jnz     short kbd_notf5 ; no

kbd_cfg_bypass:                         ; CODE XREF: kbd_read+46↑j
                mov     dx, offset _$CleanMsg ; "PC DOS is bypassing your CONFIG.SYS and"...
                call    print
                or      ds:bQueryOpt, 4
                jmp     short kbd_eat   ; yes, clean boot selected
; ---------------------------------------------------------------------------

kbd_notf5:                              ; CODE XREF: kbd_read+4B↑j
                cmp     ah, 65h         ; CTRL F8
                jz      short kbd_cfg_confirm
                cmp     ah, 42h         ; F8
                jnz     short kbd_exit

kbd_cfg_confirm:                        ; CODE XREF: kbd_read+5D↑j
                mov     dx, offset _$InterMsg ; "PC DOS will prompt you to confirm each "...
                call    print
                mov     bl, 1           ; yes, interactive-boot option enabled
                mov     ds:bQueryOpt, bl ; change default setting

kbd_eat:                                ; CODE XREF: kbd_read+58↑j
                mov     ah, 0           ; eat the key we assumed was a signal
                int     16h             ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
                                        ; Return: AH = scan code, AL = character
                mov     ds:secElapsed, 0FFh ; -1
                or      bx, bx
                jz      short kbd_clean

kbd_test:                               ; CODE XREF: kbd_read+3D↑j
                                        ; kbd_read+41↑j
                cmp     bl, 2
                jb      short kbd_exit

kbd_clean:                              ; CODE XREF: kbd_read+7B↑j
                call    disable_autoexec ; yes, tell COMMAND to skip autoexec.bat
                stc                     ; set carry to indicate abort
                retn
; ---------------------------------------------------------------------------

kbd_exit:                               ; CODE XREF: kbd_read+62↑j
                                        ; kbd_read+80↑j
                clc                     ; clear carry to indicate success
                retn
kbd_read        endp


; =============== S U B R O U T I N E =======================================


set_numlock     proc near               ; CODE XREF: doconf+A97↑p
                                        ; menu_check+18↓p ...
                push    ax              ; set numlock LED
                push    ds
                in      al, 64h         ; 8042 keyboard controller status register
                                        ; 7:  PERR    1=parity error in data received from keyboard
                                        ;    +----------- AT Mode ----------+------------ PS/2 Mode ------------+
                                        ; 6: |RxTO    receive (Rx) timeout  | TO      general timeout (Rx or Tx)|
                                        ; 5: |TxTO    transmit (Tx) timeout | MOBF    mouse output buffer full  |
                                        ;    +------------------------------+-----------------------------------+
                                        ; 4:  INH     0=keyboard communications inhibited
                                        ; 3:  A2      0=60h was the port last written to, 1=64h was last
                                        ; 2:  SYS     distinguishes reset types: 0=cold reboot, 1=warm reboot
                                        ; 1:  IBF     1=input buffer full (keyboard can't accept data)
                                        ; 0:  OBF     1=output buffer full (data from keyboard is available)
                test    al, 10h
                jz      short set_done  ; keyboard communications inhibited
                sub     ax, ax
                mov     ds, ax
                assume ds:nothing
                mov     ax, es:[si]     ; get 1st 2 bytes of value (ON or OF)
                cmp     ax, word ptr cs:OnOff2 ; "OFF"
                jnz     short not_off
                and     byte ptr ds:0417h, 0DFh ; ~20h ; turn it off
                jmp     short set_done
; ---------------------------------------------------------------------------

not_off:                                ; CODE XREF: set_numlock+14↑j
                cmp     ax, word ptr cs:OnOff ; "ON"
                stc
                jnz     short set_done
                or      byte ptr ds:0417h, 20h ; turn it on

set_done:                               ; CODE XREF: set_numlock+6↑j
                                        ; set_numlock+1B↑j ...
                pop     ds
                assume ds:nothing
                pop     ax
                retn
set_numlock     endp


; =============== S U B R O U T I N E =======================================


menu_check      proc near               ; CODE XREF: SYSINIT:44CB↑j
                push    cx              ; Search for SWITCHES,
                                        ; determine if /N or /F are present;
                                        ; if so, then disable clean/interactive boot options
                push    si
                sub     bx, bx          ; remains ZERO until first block

swchk_loop:                             ; CODE XREF: menu_check+53↓j
                call    get_char        ; get first char of current line
                jb      short swchk_end ; hit eof
                cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
                jnz     short swchk_next1
                inc     bx              ; remember that we've seen a block
                jmp     short swchk_nextline
; ---------------------------------------------------------------------------

swchk_next1:                            ; CODE XREF: menu_check+B↑j
                cmp     al, 4Eh ; 'N'   ; CONFIG_NUMLOCK
                jnz     short swchk_next2
                or      bx, bx          ; only do NUMLOCK commands that exist
                jnz     short swchk_nextline ; before the first block
                call    set_numlock     ; REM it out so we don't act on it later, too
                mov     byte ptr es:[si-1], 30h ; '0' ; CONFIG_REM
                jmp     short swchk_nextline
; ---------------------------------------------------------------------------

swchk_next2:                            ; CODE XREF: menu_check+12↑j
                cmp     al, 31h ; '1'   ; CONFIG_SWITCHES
                jnz     short swchk_nextline ; this line ain't it

swchk_scan:                             ; CODE XREF: menu_check+2F↓j
                                        ; menu_check+41↓j ...
                call    get_char        ; look for /N or /F

swchk_scan1:                            ; CODE XREF: menu_check+47↓j
                cmp     al, 0Ah         ; LF ; end of line ?
                jz      short swchk_nextline
                cmp     al, 2Fh ; '/'   ; switch-char?
                jnz     short swchk_scan ; no
                call    get_char
                and     al, 0DFh        ; ~20h ; convert to upper case
                cmp     al, byte ptr ds:swit_n+1 ; "N"
                jnz     short swchk_scan2 ; no
                or      ds:bDisableUI, 1
                jmp     short swchk_scan ; continue looking for switches of interest
; ---------------------------------------------------------------------------

swchk_scan2:                            ; CODE XREF: menu_check+3A↑j
                cmp     al, byte ptr ds:swit_f+1 ; "F"
                jnz     short swchk_scan1 ; no
                or      ds:bDisableUI, 2
                jmp     short swchk_scan ; continue looking for switches of interest
; ---------------------------------------------------------------------------

swchk_nextline:                         ; CODE XREF: menu_check+E↑j
                                        ; menu_check+16↑j ...
                call    skip_opt_line
                jmp     short swchk_loop
; ---------------------------------------------------------------------------

swchk_end:                              ; CODE XREF: menu_check+7↑j
                pop     si
                pop     cx              ;
                                        ; Do the keyboard tests for clean/interactive boot now,
                                        ; but only if the DisableUI flag is still clear
                test    ds:bDisableUI, 1
                jnz     short menu_search ;
                                        ; Wait for 2 seconds first,
                                        ; UNLESS the /F bit was set in bDisableUI, or
                                        ; there is anything at all in the keyboard buffer
                call    kbd_read
                jnb     short menu_search
                jmp     menu_abort
; ---------------------------------------------------------------------------

menu_search:                            ; CODE XREF: menu_check+5C↑j
                                        ; menu_check+61↑j ...
                sub     bx, bx          ; Search for MENU block;
                                        ; it is allowed to be anywhere in config.sys
                mov     di, offset szMenu ; "MENU"
                call    find_block      ; find the MENU block
                                        ; if no MENU, default to zero for no_selection
                jnb     short menu_found
                mov     byte ptr ds:szBoot, 0 ; "CONFIG="
                jmp     no_selection    ; not found
; ---------------------------------------------------------------------------

menu_color:                             ; CODE XREF: menu_check+E3↓j
                push    cx              ; Process the requested menu color(s)
                push    dx
                mov     dx, 7           ; default color setting
                call    get_number      ; get first number
                and     bl, 0Fh         ; first # is foreground color (for low nibble)
                mov     ch, bl          ; save it in CH
                and     dl, 0F0h
                or      dl, bl
                call    delim           ; did we hit a delimiter
                jnz     short check_color ; no, all done
                call    get_number      ; get next number
                and     bl, 0Fh         ; second # is background color (for high nibble)
                mov     dh, bl          ; save it in DH
                and     dl, 0Fh
                mov     cl, 4
                shl     bl, cl
                or      dl, bl

check_color:                            ; CODE XREF: menu_check+8D↑j
                cmp     ch, dh          ; are foreground/background the same?
                jnz     short set_color ; no
                xor     dl, 8           ; yes, so modify the fgnd intensity

set_color:                              ; CODE XREF: menu_check+A2↑j
                mov     ds:bMenuColor, dl
                pop     dx
                pop     cx
                jmp     menu_nextitem
; ---------------------------------------------------------------------------

menu_found:                             ; CODE XREF: menu_check+6E↑j
                                        ; menu_check+286↓j
                mov     ds:bDefBlock, 1
                mov     ds:offDefBlock, 0
                mov     ds:secTimeOut, 0FFh ; -1
                and     ds:bQueryOpt, 0FDh ; ~2
                call    skip_opt_line   ; skip to next line
                sub     dx, dx          ; initialize total block count (0 => none yet)

menu_process:                           ; CODE XREF: menu_check+15E↓j
                call    get_char        ; get first char of current line
                jb      short to_menu_getdefault ; could happen if menu block at end (rare)
                and     al, 7Fh         ; ~CONFIG_OPTION_QUERY
                cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
                jz      short to_menu_getdefault ; BEGIN implies END
                cmp     al, 4Fh ; 'O'   ; CONFIG_SUBMENU
                jz      short menu_item ; go process sub-menu
                cmp     al, 45h ; 'E'   ; CONFIG_MENUITEM
                jz      short menu_item ; go process menu item
                cmp     al, 41h ; 'A'   ; CONFIG_MENUDEFAULT
                jz      short menu_default ; go process menu default
                cmp     al, 52h ; 'R'   ; CONFIG_MENUCOLOR
                jz      short menu_color ; go process menu color
                cmp     al, 4Eh ; 'N'   ; CONFIG_NUMLOCK
                jz      short menu_numlock
                cmp     al, 30h ; '0'   ; CONFIG_REM
                jz      short menu_nextitem ; allow remarks in menu block
                call    any_delim       ; allow blank lines and such
                jz      short menu_nextitem
                stc
                call    print_error     ; non-MENU command!
                jmp     short menu_nextitem
; ---------------------------------------------------------------------------

menu_numlock:                           ; CODE XREF: menu_check+E7↑j
                call    set_numlock
                jmp     short menu_nextitem
; ---------------------------------------------------------------------------

to_menu_getdefault:                     ; CODE XREF: menu_check+CD↑j
                                        ; menu_check+D3↑j
                jmp     short menu_getdefault
; ---------------------------------------------------------------------------

menu_default:                           ; CODE XREF: menu_check+DF↑j
                mov     ds:offDefBlock, si ; save address of default block name
                cmp     ds:secElapsed, 0
                jnz     short timeout_skip ; secElapsed is only zero for the FIRST menu,
                call    skip_token      ; and for subsequent menus IF nothing was typed;
                jb      short menu_nextitem ; secElapsed becomes -1 forever as soon as
                call    skip_delim      ; something is typed
                jb      short menu_nextitem
                mov     si, bx
                call    get_number      ; get number (of seconds for timeout)
                cmp     bl, 90          ; limit it to a reasonable number
                jb      short timeout_ok ; (besides, 99 is the largest # my simple
                mov     bl, 90

timeout_ok:                             ; CODE XREF: menu_check+11C↑j
                mov     ds:secTimeOut, bl

timeout_skip:                           ; CODE XREF: menu_check+108↑j
                jmp     short menu_nextitem
; ---------------------------------------------------------------------------

menu_item:                              ; CODE XREF: menu_check+D7↑j
                                        ; menu_check+DB↑j
                cmp     dl, 9           ; MAX_MULTI_CONFIG
                                        ; have we reached the max # of items yet?
                jnb     short menu_nextitem
                mov     di, si          ; DS:DI -> block name to search for
                call    srch_block
                jz      short menu_itemfound ; srch_block, having succeeded,
                                        ; returns DI -> past the token that it just matched,
                                        ; which in this case should be a descriptive string;
                                        ; ES:SI and CX are unmodified
                stc
                call    print_error     ; print error and pause
                jmp     short menu_nextitem ; if not found, ignore this menu item
; ---------------------------------------------------------------------------

menu_itemfound:                         ; CODE XREF: menu_check+130↑j
                inc     dx              ; otherwise, increment total block count
                mov     bx, dx          ; and use it to index the arrays of offsets
                mov     ds:abBlockType[bx], al
                add     bx, bx          ; of recorded block names and descriptions
                mov     ds:aoffBlockName[bx], si ;
                                        ; There should be a description immediately following
                                        ; the block name on MENUITEM line; failing that,
                                        ; we'll just use the block name as the description...
                mov     ds:aoffBlockDesc[bx], si
                mov     di, bx          ; skip_delim modifies BX, so stash it in DI
                call    skip_token
                jb      short menu_nextitem ; hit eol/eof
                call    skip_delim
                jb      short menu_nextitem ; hit eol/eof
                xchg    bx, di
                mov     ds:aoffBlockDesc[bx], di

menu_nextitem:                          ; CODE XREF: menu_check+AD↑j
                                        ; menu_check+EB↑j ...
                call    skip_opt_line
                jmp     menu_process    ; go back for more lines
; ---------------------------------------------------------------------------

menu_getdefault:                        ; CODE XREF: menu_check:to_menu_getdefault↑j
                or      dl, dl          ; Display menu items now,
                                        ; after determining which one is default
                                        ;
                                        ; where there any valid blocks at all?
                jnz     short menu_valid ; yes
                sub     bx, bx          ; no, so force autoselect of 0
                jmp     menu_autoselect ; (meaning: process common blocks only)
; ---------------------------------------------------------------------------

menu_valid:                             ; CODE XREF: menu_check+163↑j
                sub     bx, bx
                mov     ds:bMaxBlock, dl ; first, record how many blocks we found
                mov     di, ds:offDefBlock
                or      di, di          ; does a default block exist?
                jz      short menu_nodefault ; no
                inc     bx              ; yes, walk name table, looking for default

menu_chkdefault:                        ; CODE XREF: menu_check+192↓j
                push    bx
                add     bx, bx
                mov     si, ds:aoffBlockName[bx]
                mov     cx, 128         ; arbitrary maximum length of a name
                push    ds
                push    es
                pop     ds
                call    comp_names      ; is this block the same as the default?
                pop     ds
                pop     bx
                jz      short menu_setdefault ; yes
                inc     bx
                cmp     bl, ds:bMaxBlock ; all done searching?
                jbe     short menu_chkdefault ; not yet

menu_nodefault:                         ; CODE XREF: menu_check+176↑j
                mov     bl, 1           ; if no default, force default to #1

menu_setdefault:                        ; CODE XREF: menu_check+18B↑j
                mov     ds:bDefBlock, bl ; yes, this will be the initial current block
                                        ;
                                        ; If the timeout was explicitly set to 0 (or technically,
                                        ; anything that failed to resolve to a number, like "NONE"
                                        ; or "EAT POTATOES"), then we're supposed to skip menu display
                                        ; and run with the specified default block; however,
                                        ; if the user hit Enter prior to boot, thereby requesting fully
                                        ; INTERACTIVE boot, then we shall display the menu block anyway
                                        ; (though still with no timeout)
                cmp     ds:secTimeOut, 0 ; is timeout zero? (ie, assume default)
                jnz     short menu_display ; no
                test    ds:bQueryOpt, 1 ; yes, but was INTERACTIVE requested?
                jnz     short menu_display ; yes, so *don't* assume default after all
                jmp     not_topmenu
; ---------------------------------------------------------------------------

menu_display:                           ; CODE XREF: menu_check+19F↑j
                                        ; menu_check+1A6↑j
                mov     ah, 0Fh         ; Reset the mode,
                                        ; so that we know screen is clean and cursor is home
                                        ; ;
                int     10h             ; - VIDEO - GET CURRENT VIDEO MODE
                                        ; Return: AH = number of columns on screen
                                        ; AL = current video mode
                                        ; BH = current active display page
                mov     ah, 0
                int     10h             ; - VIDEO - SET VIDEO MODE
                                        ; AL = mode
                push    es
                mov     ax, 40h         ; reach down into the ROM BIOS data area
                mov     es, ax          ; and save the current (default) video page
                assume es:nothing
                mov     ax, es:4Eh      ; start address and page #, in case the
                mov     ds:wCRTStart, ax ; undocumented QUIET option was enabled
                mov     al, es:62h
                mov     ds:bCRTPage, al
                mov     ax, word ptr ds:bMenuPage ; select new page for menu
                int     10h             ; - VIDEO -
                mov     ax, 600h        ; clear entire screen
                mov     bh, ds:bMenuColor ; using this color
                sub     cx, cx          ; upper left row/col
                mov     dl, es:4Ah      ; [es:CRT_Cols]
                dec     dl
                mov     dh, es:84h      ; [es:CRT_Rows]
                or      dh, dh          ; # of rows valid?
                jnz     short menu_clear ; hopefully
                mov     dh, ds:bLastRow ; no, use a default

menu_clear:                             ; CODE XREF: menu_check+1E3↑j
                int     10h             ; clear the screen using the req. attribute
                                        ;
                                        ; - VIDEO - SCROLL PAGE UP
                                        ; AL = number of lines to scroll window (0 = blank whole window)
                                        ; BH = attributes to be used on blanked lines
                                        ; CH,CL = row,column of upper left corner of window to scroll
                                        ; DH,DL = row,column of lower right corner of window
                pop     es
                assume es:nothing
                mov     ds:bLastRow, dh ; save DH
                mov     dx, offset _$MenuHeader ; "\r\n  PC DOS 7.1 Startup Menu\r\n  "
                call    print           ; cursor now on row 3 (numbered from 0)
                test    ds:bDisableUI, 1
                jnz     short menu_nostatus
                mov     bh, ds:bMenuPage
                mov     dh, ds:bLastRow ; restore DH
                mov     dl, 0           ; print the status line on row DH, col 0,
                mov     ah, 2           ; now that we can trash the cursor position
                int     10h             ; - VIDEO - SET CURSOR POSITION
                                        ; DH,DL = row, column (0,0 = upper left)
                                        ; BH = page number
                mov     dx, offset _$StatusLine ; "F5=Bypass startup files F8=Confirm each"...
                call    print
                mov     ah, 3           ; get cursor position
                int     10h             ; - VIDEO - READ CURSOR POSITION
                                        ; BH = page number
                                        ; Return: DH,DL = row,column, CH = cursor start line, CL = cursor end line
                sub     dl, 2
                mov     ds:bLastCol, dl ; save column where status char will go

menu_nostatus:                          ; CODE XREF: menu_check+1FB↑j
                mov     bx, 1           ; now prepare to display all the menu items

menu_disploop:                          ; CODE XREF: menu_check+227↓j
                call    print_item      ; print item #BL
                inc     bx              ; why "inc bx"? because it's a 1-byte opcode
                cmp     bl, ds:bMaxBlock ; all done?
                jbe     short menu_disploop ; not yet
                mov     dl, 0           ; Set cursor position to just below the menu items
                                        ; column 0
                mov     dh, bl
                add     dh, 4           ; select row below menu
                mov     bh, ds:bMenuPage
                mov     ah, 2           ; set cursor position beneath the block list
                int     10h             ; - VIDEO - SET CURSOR POSITION
                                        ; DH,DL = row, column (0,0 = upper left)
                                        ; BH = page number
                mov     dx, offset _$MenuPrmpt ; "  Enter a choice: $"
                call    print
                call    select_item     ; make a selection, return # in BX
                mov     dx, offset crlfm ; "\r\n$"
                call    print
                push    word ptr ds:bDisableUI
                or      ds:bDisableUI, 1
                call    show_status     ; clear the status line now
                pop     word ptr ds:bDisableUI ;
                                        ; Now begins the "re-organization" process...

menu_autoselect:                        ; CODE XREF: menu_check+167↑j
                cmp     bx, 0FFFFh      ; -1 ; clean boot requested?
                jnz     short normal_boot
                call    disable_autoexec

menu_abort:                             ; CODE XREF: menu_check+63↑j
                sub     cx, cx
                jmp     menu_exit
; ---------------------------------------------------------------------------

normal_boot:                            ; CODE XREF: menu_check+25A↑j
                cmp     bx, 0FFFEh      ; -2 ; back to top-level menu?
                jnz     short not_topmenu ; no
                mov     cx, ds:count    ; yes, start all over
                sub     si, si
                jmp     menu_search
; ---------------------------------------------------------------------------

not_topmenu:                            ; CODE XREF: menu_check+1A8↑j
                                        ; menu_check+267↑j
                cmp     ds:abBlockType[bx], 4Fh ; CONFIG_SUBMENU
                jnz     short not_submenu
                add     bx, bx
                mov     di, ds:aoffBlockName[bx]
                call    srch_block      ; THIS CANNOT FAIL!
                mov     si, di
                mov     cx, bx          ; ES:SI and CX are ready for another round
                jmp     menu_found
; ---------------------------------------------------------------------------

not_submenu:                            ; CODE XREF: menu_check+277↑j
                add     bx, bx          ; get BX -> name of selected block
                mov     bx, ds:aoffBlockName[bx] ;
                                        ; BX should now either be ZERO
                                        ; (meaning no block has been selected) or the offset
                                        ; relative to ES of the block name to be processed
                                        ; (along with all the "common" lines of course)

no_selection:                           ; CODE XREF: menu_check+75↑j
                mov     ds:offDefBlock, bx ; save selection
                mov     cx, ds:count    ; reset ES:SI and CX for reprocessing
                sub     si, si
                push    ds
                mov     ds, ds:config_wrkseg ; this is where we'll store new config.sys image
                sub     di, di          ;
                                        ; ES:SI-> config.sys, DS:DI -> new config.sys workspace
                                        ;
                                        ; Work our way through the config.sys image again, this time copying
                                        ; all lines that are (A) "common" lines outside any block or (B) lines
                                        ; within the requested block. Lines inside INCLUDEd blocks are
                                        ; transparently copied by copy_block in a recursive fashion;
                                        ; the amount of recursion is limited by the fact INCLUDE statements are
                                        ; REMed by copy_block as they are processed and by the number of unique
                                        ; INCLUDE stmts in config.sys...

copyblock_loop:                         ; CODE XREF: menu_check+2D1↓j
                push    bx              ; save selected block name
                call    copy_block      ; process (named or common) block
                pop     bx
                jb      short move_config ; hit eof

copyblock_begin:                        ; CODE XREF: menu_check+2DF↓j
                push    ax              ; copy_block can only return for two reasons:
                                        ;  it hit eof or a new block
                push    cx
                push    si
                push    di              ; always do "common" blocks
                mov     di, offset szCommon ; "COMMON"
                push    ds
                push    cs
                pop     ds
                assume ds:SYSINIT
                call    comp_names
                pop     ds
                assume ds:nothing
                pop     di
                pop     si
                pop     cx
                pop     ax
                jz      short copyblock_check
                or      bx, bx          ; is there a block name to check?
                jz      short copyblock_skip ; no
                push    di
                mov     di, bx          ; check block against given block name
                push    ds
                push    es
                pop     ds
                call    comp_names      ; is this the block we really want to do?
                pop     ds
                pop     di

copyblock_check:                        ; CODE XREF: menu_check+2B9↑j
                jb      short move_config ; hit eof
                jnz     short copyblock_skip
                call    skip_opt_line
                jmp     short copyblock_loop
; ---------------------------------------------------------------------------

copyblock_skip:                         ; CODE XREF: menu_check+2BD↑j
                                        ; menu_check+2CC↑j ...
                call    skip_opt_line   ; this ain't the block we wanted, so skip it
                call    get_char
                jb      short move_config ; hit eof
                and     al, 7Fh         ; ~CONFIG_OPTION_QUERY
                cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
                jz      short copyblock_begin
                jmp     short copyblock_skip ; anything else is just skipped
; ---------------------------------------------------------------------------

move_config:                            ; CODE XREF: menu_check+2A5↑j
                                        ; menu_check:copyblock_check↑j ...
                mov     cx, di          ; To create as little risk to the rest of SysInit
                                        ; as little as possible, and to free the workspace
                                        ; at "config_wrkseg" for creating an environment,
                                        ; copy the new config.sys image to "confbot".
                                        ;
                                        ; now copy workspace at DS:DI to "confbot"
                push    cx              ;
                                        ; But first, copy the CONFIG=<configuration><0> string
                                        ; to the workspace, since the configuration name only
                                        ; currently exists in the "confbot" area.
                                        ; ;
                mov     cx, 7           ; szMenu-szBoot-1
                                        ; first copy the CONFIG= part
                mov     si, offset szBoot ; "CONFIG="
                inc     di              ; skip a byte, in case absolutely nothing
                                        ; was copied to the workspace, because we always
                                        ; zero the first byte of the workspace (below)

copy_boot:                              ; CODE XREF: menu_check+2F2↓j
                lods    byte ptr cs:[si]
                mov     [di], al
                inc     di
                loop    copy_boot
                push    es              ; then copy the configuration name
                mov     cx, 121         ; 128-7 ; put an upper limit on the name, to be safe
                mov     si, cs:offDefBlock ; ES:SI -> default block name
                or      si, si          ; valid?
                jnz     short l1        ; yes
                push    cs
                pop     es
                assume es:SYSINIT
                mov     si, offset szCommon ; "COMMON"

l1:                                     ; CODE XREF: menu_check+2FF↑j
                                        ; menu_check+312↓j
                mov     al, es:[si]
                call    any_delim
                jz      short l2
                mov     [di], al
                inc     si
                inc     di
                loop    l1

l2:                                     ; CODE XREF: menu_check+30C↑j
                mov     byte ptr [di], 0Ah ; terminate the configuration string
                pop     es
                assume es:nothing
                sub     di, di          ; Now we can copy "config_wrkseg" (DS) to "confbot" (ES)
                mov     cs:config_envlen, di
                sub     si, si
                pop     cx              ; recover the size of "config_wrkseg"
                push    cx
                rep movsb               ; moved!
                pop     cx
                mov     ax, ds
                pop     ds              ; Now that the config_wrkseg is available once again,
                                        ; we shall use it to create an environment. The first
                                        ; thing to go in will be the "CONFIG=configuration" thing.
                                        ; It is also important to zero the first byte of the workspace,
                                        ; so that copy_envvar knows the buffer is empty.
                push    es
                mov     es, ax
                inc     si              ; ES:SI -> "CONFIG=configuration"
                mov     byte ptr es:0, 0 ; empty the environment block
                call    copy_envvar     ; copy envvar at ES:SI to "config_wrkseg"
                pop     es              ;
                                        ; Before returning, restore the default video page setting
                                        ; but do NOT do it using INT 10h's Set Active Page function,
                                        ; because if the menu was displayed on a different page,
                                        ; then it's because we don't want to see all the device
                                        ; driver/TSR goop (which goes to the default page)
                cmp     ds:bMenuPage, 0
                jz      short menu_exit
                push    es
                mov     ax, 40h
                mov     es, ax
                assume es:nothing
                mov     ax, ds:wCRTStart
                mov     es:4Eh, ax
                mov     al, ds:bCRTPage
                mov     es:62h, al
                pop     es
                assume es:nothing

menu_exit:                              ; CODE XREF: menu_check+261↑j
                                        ; menu_check+33C↑j
                mov     ds:count, cx
                mov     ds:org_count, cx
                retn
menu_check      endp


; =============== S U B R O U T I N E =======================================


copy_envvar     proc near               ; CODE XREF: doconf+A83↑p
                                        ; menu_check+333↑p
                push    cx              ; copy the envvar at ES:SI to "config_wrkseg"
                                        ; ES:SI -> environment variable
                                        ;          (in the form "var=string<cr/lf>")
                push    si
                push    ds
                push    es
                push    es
                mov     es, ds:config_wrkseg ; ES:DI to point to next available byte
                pop     ds              ; DS:SI to point to envvar
                sub     cx, cx

copy_varlen:                            ; CODE XREF: copy_envvar+1F↓j
                lodsb
                or      al, al          ; NULL?
                stc
                jz      short copy_envexit ; yes, abort
                cmp     al, 0Dh         ; cr
                stc
                jz      short copy_envexit
                cmp     al, 0Ah         ; lf
                stc
                jz      short copy_envexit
                inc     cx
                cmp     al, 3Dh ; '='
                jnz     short copy_varlen
                mov     al, 0
                mov     ah, [si]        ; save char after '='
                sub     si, cx          ; back up to given varname
                dec     cx              ; CX == # of bytes in varname
                sub     di, di          ; start looking for DS:SI at ES:0

copy_varsrch:                           ; CODE XREF: copy_envvar+67↓j
                cmp     es:[di], al
                jz      short copy_envprep ; search failed, just copy var
                mov     bx, di          ; ES:BX -> start of this varname
                push    cx
                push    si
                repe cmpsb
                pop     si
                pop     cx
                jnz     short copy_varnext ; no match, skip to next varname
                cmp     byte ptr es:[di], '='
                jnz     short copy_varnext ; no match, there's more characters
                                        ;
                                        ; Previous occurrence of variable has been found;
                                        ; determine the entire length and then destroy it
                mov     cx, 0FFFFh      ; -1
                repne scasb             ; guaranteed to get null (since we put it there)
                push    si
                mov     si, di
                mov     di, bx
                mov     cx, cs:config_envlen
                sub     cx, si          ; destroy variable now
                rep movs byte ptr es:[di], byte ptr es:[si]
                pop     si

copy_envprep:                           ; CODE XREF: copy_envvar+2D↑j
                cmp     ah, 0Dh         ; if there is nothing after the '='
                jz      short copy_envdel
                cmp     ah, 0Ah
                jz      short copy_envdel
                jmp     short copy_envloop
; ---------------------------------------------------------------------------

copy_varnext:                           ; CODE XREF: copy_envvar+37↑j
                                        ; copy_envvar+3D↑j
                push    cx
                mov     cx, 0FFFFh      ; -1
                repne scasb
                pop     cx
                jmp     short copy_varsrch
; ---------------------------------------------------------------------------

copy_envloop:                           ; CODE XREF: copy_envvar+5E↑j
                                        ; copy_envvar+73↓j
                lodsb
                cmp     al, 0Dh         ; cr
                jz      short copy_envdone
                cmp     al, 0Ah         ; lf
                jz      short copy_envdone
                stosb
                jmp     short copy_envloop
; ---------------------------------------------------------------------------

copy_envdone:                           ; CODE XREF: copy_envvar+6C↑j
                                        ; copy_envvar+70↑j
                sub     al, al          ; do SUB to clear carry as well
                stosb                   ; always null-terminate these puppies

copy_envdel:                            ; CODE XREF: copy_envvar+57↑j
                                        ; copy_envvar+5C↑j
                mov     es:[di], al     ; and stick another null to terminate the env.
                mov     cs:config_envlen, di

copy_envexit:                           ; CODE XREF: copy_envvar+10↑j
                                        ; copy_envvar+15↑j ...
                pop     es
                pop     ds
                pop     si
                pop     cx
                retn
copy_envvar     endp


; =============== S U B R O U T I N E =======================================


copy_block      proc near               ; CODE XREF: menu_check+2A1↑p
                                        ; copy_block+3B↓p ...
                call    get_char        ; copy the current block to the new config.sys workspace
                                        ;
                                        ; CX == remaining bytes in "organized" config.sys memory image
                                        ; ES:SI -> remaining bytes in "organized" config.sys memory image
                                        ; DS:DI -> new config.sys workspace (equal in size to the original
                                        ;        config.sys image) where the current block is to be copied
                                        ;
                                        ; check for include
                jb      short copy_done
                and     al, 7Fh         ; ~CONFIG_OPTION_QUERY
                cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
                                        ; another BEGIN implies END as well
                jz      short copy_done
                cmp     al, 4Ah ; 'J'   ; CONFIG_INCLUDE ; 'J'
                mov     al, ah          ; AL == the original line code
                jnz     short copy_line ; not an "include" line
                                        ;
                                        ; We have hit an "INCLUDE" line; first, REM out the line
                                        ; so that we never try to include the block again
                                        ; (no infinite include loops please), then search for
                                        ; the named block and call copy_block again.
                mov     byte ptr es:[si-1], 30h ; '0' ; CONFIG_REM
                push    di
                mov     di, offset szMenu ; "MENU"
                call    comp_names_safe ; don't allow INCLUDE MENU
                jz      short copy_skip
                mov     di, offset szCommon ; "COMMON"
                call    comp_names_safe ; don't allow INCLUDE COMMON
                jz      short copy_skip
                mov     di, si          ; try to find the block
                call    srch_block
                mov     dx, di
                pop     di
                jnz     short copy_error ; no such block
                push    cx
                mov     cx, bx
                push    si
                dec     dx
                mov     si, dx
                call    skip_line       ; skip the rest of the "block name" line
                call    copy_block      ; and copy in the rest of that block
                pop     si
                pop     cx
                sub     al, al          ; force skip_opt_line to skip...
                jmp     short copy_nextline
; ---------------------------------------------------------------------------

copy_skip:                              ; CODE XREF: copy_block+1D↑j
                                        ; copy_block+25↑j
                pop     di

copy_error:                             ; CODE XREF: copy_block+2F↑j
                clc
                call    print_error     ; note that carry is clear, no pause
                jmp     short copy_nextline
; ---------------------------------------------------------------------------

copy_line:                              ; CODE XREF: copy_block+F↑j
                mov     [di], al        ; Copy the line at ES:SI
                                        ;  to the current location at DS:DI
                inc     di
                cmp     al, 20h ; ' '   ; is this is a "real" line with a "real" code?
                jb      short copy_nextline ; no
                cmp     cs:config_multi, 0
                jz      short copy_loop ; not a multi-config config.sys, don't embed #s
                call    get_linenum     ; BX == line # of line @ES:SI
                mov     [di], bx        ; stash it immediately following the line code
                inc     di
                inc     di
                jmp     short copy_next
; ---------------------------------------------------------------------------

copy_loop:                              ; CODE XREF: copy_block+58↑j
                                        ; copy_block+6D↓j
                call    get_char
                jb      short copy_done ; end of file
                mov     [di], al
                inc     di

copy_next:                              ; CODE XREF: copy_block+61↑j
                cmp     al, 0Ah         ; lf ; done with line?
                jnz     short copy_loop ; nope

copy_nextline:                          ; CODE XREF: copy_block+42↑j
                                        ; copy_block+49↑j ...
                call    skip_opt_line
                jmp     short copy_block
; ---------------------------------------------------------------------------

copy_done:                              ; CODE XREF: copy_block+3↑j
                                        ; copy_block+9↑j ...
                retn
copy_block      endp


; =============== S U B R O U T I N E =======================================


get_linenum     proc near               ; CODE XREF: copy_block+5A↑p
                                        ; print_error+8↓p
                push    ax              ; return line # (in BX) of current line (@ES:SI)
                sub     bx, bx          ; BX == line # (to be returned)
                push    cx
                mov     dx, si          ; DX == the offset we're looking for
                push    si
                mov     cx, cs:count
                sub     si, si          ; prepare to scan entire file

get_linenum_loop:                       ; CODE XREF: get_linenum+16↓j
                call    skip_line
                jb      short get_linenum_done
                inc     bx
                cmp     si, dx          ; have we exceeded the desired offset yet?
                jb      short get_linenum_loop ; no

get_linenum_done:                       ; CODE XREF: get_linenum+11↑j
                pop     si
                pop     cx
                pop     ax
                retn
get_linenum     endp


; =============== S U B R O U T I N E =======================================


srch_block      proc near               ; CODE XREF: menu_check+12D↑p
                                        ; menu_check+27F↑p ...
                push    ax              ; searches entire config.sys
                                        ; for block name @ES:DI
                push    cx
                mov     cx, cs:count
                push    si
                sub     si, si
                push    ds
                push    es
                pop     ds
                call    find_block
                mov     di, si          ; ES:DI -> just past the name in the block heading, if found
                mov     bx, cx          ; BX == # bytes remaining from that point, if found
                pop     ds
                pop     si
                pop     cx
                pop     ax
                retn
srch_block      endp


; =============== S U B R O U T I N E =======================================


find_block      proc near               ; CODE XREF: menu_check+6B↑p
                                        ; srch_block+D↑p ...
                call    get_char        ; searches rest of config.sys for block name @DS:DI
                                        ; get line code
                jb      short find_exit ; end of file
                and     al, 7Fh         ; ~CONFIG_OPTION_QUERY
                cmp     al, 5Bh ; '['   ; CONFIG_BEGIN ; beginning of a block?
                jz      short check_line ; no
                cmp     al, 4Ah ; 'J'   ; CONFIG_INCLUDE
                jnz     short next_line
                or      cs:config_multi, 1
                jmp     short next_line
; ---------------------------------------------------------------------------

check_line:                             ; CODE XREF: find_block+9↑j
                or      cs:config_multi, 1
                call    comp_names      ; compare block names
                jbe     short find_exit ; end of file, or names matched

next_line:                              ; CODE XREF: find_block+D↑j
                                        ; find_block+15↑j
                call    skip_opt_line   ; no, so skip to next line
                jmp     short find_block
; ---------------------------------------------------------------------------

find_exit:                              ; CODE XREF: find_block+3↑j
                                        ; find_block+20↑j
                retn
find_block      endp


; =============== S U B R O U T I N E =======================================


comp_names      proc near               ; CODE XREF: menu_check+186↑p
                                        ; menu_check+2B1↑p ...
                push    di              ; compares keyword @DS:DI
                                        ;  to position in config.sys @ES:SI

comp_loop:                              ; CODE XREF: comp_names+13↓j
                call    get_char
                jb      short comp_exit
                call    any_delim       ; is next character a delimiter?
                mov     ah, [di]        ; (get next character we're supposed to match)
                jz      short comp_almost ; yes, it *could* be a match
                inc     di
                and     ax, 0DFDFh      ; ~2020h
                cmp     al, ah          ; match?
                jz      short comp_loop ; yes, keep looking at the characters
                clc                     ; prevent erroneous eof indication: clear carry

comp_exit:                              ; CODE XREF: comp_names+4↑j
                                        ; comp_names+1F↓j
                pop     di
                retn
; ---------------------------------------------------------------------------

comp_almost:                            ; CODE XREF: comp_names+B↑j
                xchg    al, ah          ; we don't know for sure if it's a match
                call    any_delim       ; until we verify that the second string
                xchg    al, ah          ; has been exhausted also...
                jmp     short comp_exit ; if we are, this call to any_delim will tell...
comp_names      endp


; =============== S U B R O U T I N E =======================================


comp_names_safe proc near               ; CODE XREF: copy_block+1A↑p
                                        ; copy_block+22↑p
                push    ax
                push    cx
                push    si
                push    ds
                push    cs
                pop     ds
                assume ds:SYSINIT
                call    comp_names
                pop     ds
                assume ds:nothing
                pop     si
                pop     cx
                pop     ax
                retn
comp_names_safe endp


; =============== S U B R O U T I N E =======================================


print_item      proc near               ; CODE XREF: menu_check:menu_disploop↑p
                                        ; select_item+BC↓p ...
                push    ax              ; display menu item #BL
                push    bx
                push    cx
                push    dx
                push    si
                mov     ah, 3           ; get cursor position
                mov     bh, ds:bMenuPage ; always page zero
                int     10h             ; - VIDEO - READ CURSOR POSITION
                                        ; BH = page number
                                        ; Return: DH,DL = row,column, CH = cursor start line, CL = cursor end line
                push    dx
                mov     ah, 2           ; set cursor position for correct row/col
                mov     dh, bl
                add     dh, 3
                mov     dl, 5
                int     10h             ; - VIDEO - SET CURSOR POSITION
                                        ; DH,DL = row, column (0,0 = upper left)
                                        ; BH = page number
                mov     al, bl
                add     al, 30h ; '0'   ; convert menu item # to ASCII digit
                mov     ah, ds:bMenuColor ; normal attribute
                cmp     bl, ds:bDefBlock ; are we printing the current block?
                jnz     short print_other ; no
                or      ah, 70h         ; yes, set bgnd color to white
                mov     ch, ah
                mov     cl, 4
                rol     ch, cl
                cmp     ch, ah          ; are fgnd/bgnd the same?
                jnz     short print_other ; no
                xor     ah, 8           ; yes, so modify the fgnd intensity

print_other:                            ; CODE XREF: print_item+25↑j
                                        ; print_item+32↑j
                mov     bh, 0
                add     bx, bx
                mov     di, ds:aoffBlockDesc[bx]
                mov     bl, ah          ; put the attribute in the correct register now
                mov     bh, ds:bMenuPage ; get correct video page #
                mov     ah, 9           ; write char/attr
                mov     cx, 1
                int     10h             ; - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION
                                        ; AL = character, BH = display page
                                        ; BL = attributes of character (alpha modes) or color (graphics modes)
                                        ; CX = number of times to write character
                inc     dl              ; increment column
                mov     ah, 2
                int     10h             ; - VIDEO - SET CURSOR POSITION
                                        ; DH,DL = row, column (0,0 = upper left)
                                        ; BH = page number
                mov     ax, 92Eh        ; display '.'
                int     10h             ; - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION
                                        ; AL = character, BH = display page
                                        ; BL = attributes of character (alpha modes) or color (graphics modes)
                                        ; CX = number of times to write character
                inc     dl              ; increment column
                mov     ah, 2
                int     10h             ; - VIDEO - SET CURSOR POSITION
                                        ; DH,DL = row, column (0,0 = upper left)
                                        ; BH = page number
                mov     ax, 920h        ; display ' '
                int     10h             ; - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION
                                        ; AL = character, BH = display page
                                        ; BL = attributes of character (alpha modes) or color (graphics modes)
                                        ; CX = number of times to write character
                inc     dl              ; increment column
                mov     ah, 2
                int     10h             ; - VIDEO - SET CURSOR POSITION
                                        ; DH,DL = row, column (0,0 = upper left)
                                        ; BH = page number
                push    es

print_loop:                             ; CODE XREF: print_item+8A↓j
                mov     al, es:[di]     ; get a character of the description
                inc     di
                cmp     al, 9           ; TAB ; substitute spaces for tabs
                jnz     short print_nontab
                mov     al, 20h ; ' '

print_nontab:                           ; CODE XREF: print_item+6F↑j
                cmp     al, 20h ; ' '
                jb      short print_done ; stop at the 1st character < space
                cmp     al, 24h ; '$'
                jz      short print_done ; also stop on $
                mov     ah, 9
                int     10h             ; - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION
                                        ; AL = character, BH = display page
                                        ; BL = attributes of character (alpha modes) or color (graphics modes)
                                        ; CX = number of times to write character
                inc     dl              ; increment column
                cmp     dl, 78          ; far enough?
                jnb     short print_done ; yes
                mov     ah, 2
                int     10h             ; - VIDEO - SET CURSOR POSITION
                                        ; DH,DL = row, column (0,0 = upper left)
                                        ; BH = page number
                jmp     short print_loop
; ---------------------------------------------------------------------------

print_done:                             ; CODE XREF: print_item+75↑j
                                        ; print_item+79↑j ...
                pop     es
                pop     dx
                mov     ah, 2           ; restore previous row/col
                int     10h             ; - VIDEO - SET CURSOR POSITION
                                        ; DH,DL = row, column (0,0 = upper left)
                                        ; BH = page number
                pop     si
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                retn
print_item      endp


; =============== S U B R O U T I N E =======================================


select_item     proc near               ; CODE XREF: menu_check+23E↑p
                mov     bl, ds:bDefBlock ; wait for user to select menu item, with time-out
                                        ;
                                        ; returns digit value in BX (trashes AX/CX/DX)
                mov     al, bl          ; BL will be the default block #
                call    disp_num
                call    show_status     ; display current interactive status
                cmp     ds:secTimeOut, 0FFh ; -1
                jz      short input_key ; no time-out, just go to input
                mov     ah, 2Ch         ; GET_TIME
                int     21h             ; DOS - GET CURRENT TIME
                                        ; Return: CH = hours, CL = minutes, DH = seconds
                                        ; DL = hundredths of seconds
                                        ; ;
                mov     bh, dh          ; BH = initial # of seconds

check_time:                             ; CODE XREF: select_item+8A↓j
                mov     al, ds:secTimeOut
                sub     al, ds:secElapsed
                jnb     short show_time
                or      ds:bQueryOpt, 2 ; disable all further prompting
                mov     ds:secElapsed, 0
                jmp     select_done     ; time's up!
; ---------------------------------------------------------------------------

show_time:                              ; CODE XREF: select_item+20↑j
                push    bx
                mov     bl, al          ; save # in BL
                mov     bh, ds:bMenuPage
                mov     ah, 3
                int     10h             ; - VIDEO - READ CURSOR POSITION
                                        ; BH = page number
                                        ; Return: DH,DL = row,column, CH = cursor start line, CL = cursor end line
                push    dx
                add     dl, 8           ; move cursor to the right
                mov     ah, 2
                int     10h             ; - VIDEO - SET CURSOR POSITION
                                        ; DH,DL = row, column (0,0 = upper left)
                                        ; BH = page number
                mov     dx, offset _$TimeOut ; "Time remaining: $"
                call    print           ; print the "Time remaining: " prompt
                mov     al, bl          ; recover # from BL
                cbw                     ; this works because AL is always <= 90
                mov     cl, 10
                div     cl              ; AL = tens digit, AH = ones digit
                mov     cl, ah
                add     al, '0'         ; write TTY tens digit
                mov     ah, 0Eh
                int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
                                        ; AL = character, BH = display page (alpha modes)
                                        ; BL = foreground color (graphics modes)
                mov     al, cl
                add     al, '0'         ; write TTY ones digit
                mov     ah, 0Eh
                int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
                                        ; AL = character, BH = display page (alpha modes)
                                        ; BL = foreground color (graphics modes)
                pop     dx
                mov     ah, 2           ; set cursor position back to where it was
                int     10h             ; - VIDEO - SET CURSOR POSITION
                                        ; DH,DL = row, column (0,0 = upper left)
                                        ; BH = page number
                pop     bx

input_key:                              ; CODE XREF: select_item+11↑j
                                        ; select_item+72↓j ...
                mov     ah, 6           ; RAW_CON_IO
                mov     dl, 0FFh        ; input request
                int     21h             ; DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
                                        ; DL = character <> FFh
                                        ;  Return: ZF set = no character
                                        ;   ZF clear = character recieved, AL = character
                jnz     short got_key
                cmp     ds:secTimeOut, 0FFh ; -1 ; is there a time-out?
                jz      short input_key ; no, just go back to input
                mov     ah, 2Ch         ; GET_TIME
                int     21h             ; DOS - GET CURRENT TIME
                                        ; Return: CH = hours, CL = minutes, DH = seconds
                                        ; DL = hundredths of seconds
                mov     ah, dh
                sub     dh, bh          ; should generally be zero or one
                mov     bh, ah
                jnb     short got_time
                mov     dh, 1           ; it wrapped back to zero, so assume one

got_time:                               ; CODE XREF: select_item+7E↑j
                or      dh, dh          ; any change?
                jz      short input_key ; no
                add     ds:secElapsed, dh
                jmp     short check_time
; ---------------------------------------------------------------------------

got_key:                                ; CODE XREF: select_item+6B↑j
                push    ax
                mov     ax, 0FFFFh      ; -1 ; zap both secTimeOut and secElapsed
                xchg    ax, word ptr ds:secTimeOut
                cmp     al, 0FFh        ; -1 ; was time-out already disabled?
                jz      short timeout_disabled ; yes
                push    bx              ; let's disable # seconds display
                mov     ax, 0A20h       ; write multiple spaces
                mov     bx, word ptr ds:bMenuColor
                mov     cx, 80          ; 80 of them, to be safe
                                        ; to completely obliterate # seconds display
                int     10h             ; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
                                        ; AL = character, BH = display page - alpha mode
                                        ; BL = color of character (graphics mode, PCjr only)
                                        ; CX = number of times to write character
                pop     bx

timeout_disabled:                       ; CODE XREF: select_item+96↑j
                pop     ax
                or      al, al          ; extended key pressed?
                jnz     short normal_key ; no
                int     21h             ; get the next part of the key then
                jz      short input_key ; what happened to the second part!?
                cmp     al, 48h         ; up arrow?
                jnz     short not_up    ; no
                cmp     bl, 1           ; are we as up as up can get?
                jbe     short input_key ; yes, ignore it
                dec     ds:bDefBlock
                call    print_item      ; re-print the current item
                dec     bl              ; and then print the new current item
                jmp     short print1
; ---------------------------------------------------------------------------

not_up:                                 ; CODE XREF: select_item+B1↑j
                cmp     al, 50h ; 'P'   ; down arrow?
                jnz     short not_down  ; no
                cmp     bl, ds:bMaxBlock ; are we as down as down can get?
                jnb     short to_input_key ; yes, ignore it
                inc     ds:bDefBlock
                call    print_item      ; re-print the current item
                inc     bx              ; and then print the new current item

print1:                                 ; CODE XREF: select_item+C1↑j
                mov     al, bl

print2:                                 ; CODE XREF: select_item+123↓j
                call    print_item
                call    disp_num

to_input_key:                           ; CODE XREF: select_item+CB↑j
                                        ; select_item+E4↓j ...
                jmp     short input_key
; ---------------------------------------------------------------------------

not_down:                               ; CODE XREF: select_item+C5↑j
                test    ds:bDisableUI, 1
                jnz     short to_input_key ; don't allow F8 or F5
                cmp     al, 42h         ; F8 function key?
                jnz     short not_f8    ; no
                xor     ds:bQueryOpt, 1
                call    show_status
                jmp     input_key
; ---------------------------------------------------------------------------

not_f8:                                 ; CODE XREF: select_item+E8↑j
                cmp     al, 3Fh         ; F5 function key?
                jnz     short to_input_key ; no
                or      ds:bQueryOpt, 4 ; no more queries
                mov     bx, 0FFFFh      ; special return code (-1) indicating clean boot
                mov     al, 20h ; ' '   ; don't want to display anything really;
                jmp     short disp_input
; ---------------------------------------------------------------------------

normal_key:                             ; CODE XREF: select_item+A9↑j
                cmp     al, 0Dh         ; Enter?
                jz      short select_done ; yes
                cmp     al, 8           ; backspace?
                jnz     short not_backspace ; no
                mov     bx, 0FFFEh      ; -2 ; yes, special return code
                retn
; ---------------------------------------------------------------------------

not_backspace:                          ; CODE XREF: select_item+10B↑j
                sub     al, 30h ; '0'   ; is greater than '0'?
                jbe     short to_input_key ; no
                cmp     al, ds:bMaxBlock ; is less than or equal to the maximum digit?
                ja      short to_input_key ; no
                mov     ds:bDefBlock, al
                call    print_item      ; redisplay the current selection
                mov     bl, al          ; set new selection
                jmp     short print2
; ---------------------------------------------------------------------------

select_done:                            ; CODE XREF: select_item+2C↑j
                                        ; select_item+107↑j
                mov     bh, 0           ; return a full 16-bit value (for indexing)
                mov     al, bl
                add     al, 30h ; '0'   ; convert it into a digit, then display it
select_item     endp


; =============== S U B R O U T I N E =======================================


disp_input      proc near               ; CODE XREF: select_item+103↑j
                                        ; query_user:legal_char↓p
                push    ax
                cmp     al, 20h ; ' '
                jnb     short disp_ok
                mov     al, 20h ; ' '

disp_ok:                                ; CODE XREF: disp_input+3↑j
                mov     dl, al
                mov     ah, 2           ; STD_CON_OUTPUT
                int     21h             ; DOS - DISPLAY OUTPUT
                                        ; DL = character to send to standard output
                mov     dx, offset crlfm ; "\r\n$"
                call    print
                pop     ax
                retn
disp_input      endp


; =============== S U B R O U T I N E =======================================


disp_num        proc near               ; CODE XREF: select_item+6↑p
                                        ; select_item+DA↑p
                push    bx              ; display a single character + cr/lf
                add     al, '0'
                mov     ah, 0Ah
                mov     bx, word ptr ds:bMenuColor
                mov     cx, 1
                int     10h             ; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
                                        ; AL = character, BH = display page - alpha mode
                                        ; BL = color of character (graphics mode, PCjr only)
                                        ; CX = number of times to write character
                pop     bx
                retn
disp_num        endp


; =============== S U B R O U T I N E =======================================


show_status     proc near               ; CODE XREF: menu_check+250↑p
                                        ; select_item+9↑p ...
                push    bx              ; display current interactive mode setting (on/off/none)
                mov     bx, word ptr ds:bMenuColor
                mov     ah, 3
                int     10h             ; - VIDEO - READ CURSOR POSITION
                                        ; BH = page number
                                        ; Return: DH,DL = row,column, CH = cursor start line, CL = cursor end line
                push    dx
                mov     ah, 2
                mov     dx, word ptr ds:bLastCol ; set correct row/col
                test    ds:bDisableUI, 1
                jz      short show_onoff ; just show on/off
                mov     dl, 0
                int     10h             ; - VIDEO - SET CURSOR POSITION
                                        ; DH,DL = row, column (0,0 = upper left)
                                        ; BH = page number
                mov     ax, 0A20h       ; write multiple spaces
                mov     cx, 80          ; 80 of them, to be exact to obliterate the status line
                int     10h             ; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
                                        ; AL = character, BH = display page - alpha mode
                                        ; BL = color of character (graphics mode, PCjr only)
                                        ; CX = number of times to write character
                jmp     short show_done
; ---------------------------------------------------------------------------

show_onoff:                             ; CODE XREF: show_status+15↑j
                int     10h             ; - VIDEO -
                mov     al, byte ptr ds:_$NO ; "NO $"
                cmp     ds:bQueryOpt, 1 ; is interactive mode on?
                jnz     short show_noton ; no
                mov     al, byte ptr ds:_$YES ; "YES$"

show_noton:                             ; CODE XREF: show_status+2F↑j
                mov     ah, 0Eh
                int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
                                        ; AL = character, BH = display page (alpha modes)
                                        ; BL = foreground color (graphics modes)

show_done:                              ; CODE XREF: show_status+23↑j
                pop     dx              ; restore original cursor position
                mov     ah, 2
                int     10h             ; - VIDEO - SET CURSOR POSITION
                                        ; DH,DL = row, column (0,0 = upper left)
                                        ; BH = page number
                pop     bx
                retn
show_status     endp


; =============== S U B R O U T I N E =======================================


skip_token      proc near               ; CODE XREF: menu_check+10A↑p
                                        ; menu_check+14B↑p ...
                call    get_char        ; advances ES:SI/CX past the current token
                jb      short skip_token_done
                call    any_delim
                jnz     short skip_token

skip_check_eol:                         ; CODE XREF: skip_delim+D↓j
                cmp     al, 0Dh         ; CR
                jz      short skip_token_eol
                cmp     al, 0Ah         ; LF
                jz      short skip_token_eol
                clc
                jmp     short skip_token_done
; ---------------------------------------------------------------------------

skip_token_eol:                         ; CODE XREF: skip_token+C↑j
                                        ; skip_token+10↑j
                stc

skip_token_done:                        ; CODE XREF: skip_token+3↑j
                                        ; skip_token+13↑j ...
                retn
skip_token      endp


; =============== S U B R O U T I N E =======================================


skip_delim      proc near               ; CODE XREF: menu_check+10F↑p
                                        ; menu_check+150↑p ...
                call    get_char        ; advances ES:SI/CX past the current delimiter
                lea     bx, [si-1]
                jb      short skip_token_done
                call    delim
                jz      short skip_delim
                jmp     short skip_check_eol
skip_delim      endp


; =============== S U B R O U T I N E =======================================


skip_opt_line   proc near               ; CODE XREF: menu_check:swchk_nextline↑p
                                        ; menu_check+C5↑p ...
                cmp     al, 0Ah         ; LF
                jz      short skip_line_done
skip_opt_line   endp


; =============== S U B R O U T I N E =======================================


skip_line       proc near               ; CODE XREF: copy_block+38↑p
                                        ; get_linenum:get_linenum_loop↑p ...
                call    get_char
                jb      short skip_line_done

_skip_opt_line_:                        ; skip_opt_line: (Erdogan Tan - 03/08/2023)
                cmp     al, 0Ah         ; LF
                jnz     short skip_line

skip_line_done:                         ; CODE XREF: skip_opt_line+2↑j
                                        ; skip_line+3↑j
                retn
skip_line       endp


; =============== S U B R O U T I N E =======================================


get_number      proc near               ; CODE XREF: menu_check+7D↑p
                                        ; menu_check+8F↑p ...
                sub     bx, bx          ; return binary equivalent of numeric string
                                        ; BX = result

num_loop:                               ; CODE XREF: get_number+1F↓j
                call    get_char
                jb      short num_done
                cmp     al, 30h ; '0'   ; convert to value
                jb      short num_done  ; no more number
                cmp     al, 39h ; '9'
                ja      short num_done
                push    ax
                mov     ax, 10
                push    dx
                mul     bx
                pop     dx
                mov     bx, ax
                pop     ax
                sub     al, 30h ; '0'
                cbw
                add     bx, ax
                jmp     short num_loop
; ---------------------------------------------------------------------------

num_done:                               ; CODE XREF: get_number+5↑j
                                        ; get_number+9↑j ...
                retn
get_number      endp


; =============== S U B R O U T I N E =======================================


get_char        proc near               ; CODE XREF: menu_check:swchk_loop↑p
                                        ; menu_check:swchk_scan↑p ...
                sub     cx, 1           ; return next character,
                                        ; advance ES:SI, and decrement CX
                                        ; (use SUB to set carry,zero)
                jb      short get_fail  ; out of data
                lods    byte ptr es:[si] ; es
                                        ; lodsb
                mov     ah, al
                retn
; ---------------------------------------------------------------------------

get_fail:                               ; CODE XREF: get_char+3↑j
                mov     cx, 0           ; restore CX to zero
                                        ; leave carry set, zero not set

nearby_ret:                             ; CODE XREF: query_user+F↓j
                retn
get_char        endp


; =============== S U B R O U T I N E =======================================


query_user      proc near               ; CODE XREF: SYSINIT:091A↑p
                                        ; doconf+16A↑p ...
                test    ds:bQueryOpt, 4 ; ask user whether to execute current config.sys command
                                        ; answer no to everything?
                jz      short qu_1      ; no
                jmp     skip_all        ; yes
; ---------------------------------------------------------------------------

qu_1:                                   ; CODE XREF: query_user+5↑j
                test    ds:bQueryOpt, 2 ; answer yes to everything?
                jnz     short nearby_ret ; yes (and return carry clear!)
                push    ax
                mov     al, ds:config_cmd
                test    ds:bQueryOpt, 1 ; query every command?
                jnz     short query_all ; yes
                test    al, 80h         ; CONFIG_OPTION_QUERY
                jnz     short query_all
                jmp     do_cmd
; ---------------------------------------------------------------------------

query_all:                              ; CODE XREF: query_user+1A↑j
                                        ; query_user+1E↑j
                push    si              ; save pointer to rest of CONFIG.SYS line
                mov     dx, offset _$AutoPrmpt ; "Process AUTOEXEC.BAT [Y,N]?$"
                and     al, 7Fh         ; ~CONFIG_OPTION_QUERY
                jz      short generic_prompt ; config_cmd must have been 0
                mov     dh, al          ; save config_cmd in DH
                sub     bx, bx          ; 0
                mov     di, offset comtab ; "\x01[["

find_match:                             ; CODE XREF: query_user+40↓j
                mov     bl, [di]        ; get size of current keyword
                or      bl, bl
                jz      short line_print ; end of table
                inc     di
                cmp     al, [bx+di]     ; match?
                jz      short cmd_match ; yes
                lea     di, [bx+di+1]   ; otherwise, skip this command code
                jmp     short find_match ; loop
; ---------------------------------------------------------------------------

cmd_match:                              ; CODE XREF: query_user+3B↑j
                mov     cl, [di-1]
                mov     ch, 0
                mov     ah, 2           ; STD_CON_OUTPUT

cmd_print:                              ; CODE XREF: query_user+50↓j
                mov     al, [di]
                inc     di
                mov     dl, al
                int     21h             ; DOS - DISPLAY OUTPUT
                                        ; DL = character to send to standard output
                loop    cmd_print
                mov     dl, '='         ; '=' looks funny on SET commands
                cmp     dh, 'V'         ; CONFIG_SET
                jnz     short cmd_notset
                mov     dl, 20h ; ' '   ; for SET commands, don't display a '='

cmd_notset:                             ; CODE XREF: query_user+57↑j
                int     21h             ; DOS - DISPLAY OUTPUT
                                        ; DL = character to send to standard output

line_print:                             ; CODE XREF: query_user+36↑j
                                        ; query_user+77↓j
                lods    byte ptr es:[si]
                or      al, al
                jnz     short non_null
                mov     al, 20h ; ' '

non_null:                               ; CODE XREF: query_user+61↑j
                cmp     al, 20h ; ' '   ; control code?
                jb      short prompt_user ; yes, assume end of line
                jnz     short non_space
                cmp     byte ptr es:[si], 20h ; ' '
                jb      short prompt_user

non_space:                              ; CODE XREF: query_user+69↑j
                mov     dl, al
                mov     ah, 2
                int     21h             ; DOS - DISPLAY OUTPUT
                                        ; DL = character to send to standard output
                jmp     short line_print
; ---------------------------------------------------------------------------

prompt_user:                            ; CODE XREF: query_user+67↑j
                                        ; query_user+6F↑j
                mov     dx, offset _$InterPrmpt ; " [Y,N,ESC]?$"

generic_prompt:                         ; CODE XREF: query_user+29↑j
                call    print

input_loop:                             ; CODE XREF: query_user+8A↓j
                                        ; query_user+A9↓j ...
                mov     ah, 0
                int     16h             ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
                                        ; Return: AH = scan code, AL = character
                or      al, al          ; is it a function key?
                jnz     short not_func  ; no
                cmp     ah, 3Fh         ; F5 function key?
                jnz     short input_loop ; no
                mov     al, byte ptr ds:_$NO ; "NO $"
                or      ds:bQueryOpt, 4 ; no more queries
                jmp     short legal_char
; ---------------------------------------------------------------------------

not_func:                               ; CODE XREF: query_user+85↑j
                and     al, 0DFh        ; ~20h ; converting to upper case
                                        ; converting to upper case
                                        ; verify character is legal
                cmp     al, byte ptr ds:_$NO ; "NO $"
                jz      short legal_char
                cmp     al, byte ptr ds:_$YES ; "YES$"
                jz      short legal_char
                cmp     ds:config_cmd, 0
                jz      short input_loop ; don't allow Esc on this query
                cmp     al, 1Bh         ; Esc?
                jnz     short input_loop
                or      ds:bQueryOpt, 2 ; no more interactive boot prompts
                mov     al, byte ptr ds:_$YES ; "YES$"

legal_char:                             ; CODE XREF: query_user+94↑j
                                        ; query_user+9C↑j ...
                call    disp_input
                pop     si              ; restore pointer to rest of CONFIG.SYS line
                                        ; process line?
                cmp     al, byte ptr ds:_$NO ; "NO $"
                jz      short skip_cmd  ; no

do_cmd:                                 ; CODE XREF: query_user+20↑j
                pop     ax
                clc                     ; just do the command
                retn
; ---------------------------------------------------------------------------

skip_cmd:                               ; CODE XREF: query_user+BF↑j
                pop     ax

skip_all:                               ; CODE XREF: query_user+7↑j
                mov     ah, 30h ; '0'   ; CONFIG_REM ; fake out the rest of sysinit's processing
                stc
                retn
query_user      endp


; =============== S U B R O U T I N E =======================================


print_error     proc near               ; CODE XREF: menu_check+F3↑p
                                        ; menu_check+133↑p ...
                push    ax              ; displays multi-config error conditions
                push    bx
                push    cx
                push    dx
                push    ds
                push    cs
                pop     ds
                assume ds:SYSINIT
                pushf
                call    get_linenum
                mov     linecount, bx
                call    error_line
                popf
                jnb     short pe_ret
                mov     dx, offset _$PauseMsg ; "Press any key to continue...\r\n$"
                call    print
                mov     ax, 0C07h       ; flush input buffer, then wait for key
                int     21h             ; DOS - CLEAR KEYBOARD BUFFER
                                        ; AL must be 01h, 06h, 07h, 08h, or 0Ah.
                or      al, al          ; extended key?
                jnz     short pe_1      ; no
                mov     ah, 7           ; yes, eat it too
                int     21h             ; DOS - DIRECT STDIN INPUT, NO ECHO

pe_1:                                   ; CODE XREF: print_error+22↑j
                mov     dx, offset crlfm ; "\r\n$"
                call    print

pe_ret:                                 ; CODE XREF: print_error+13↑j
                pop     ds
                assume ds:nothing
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                retn
print_error     endp


; =============== S U B R O U T I N E =======================================


disable_autoexec proc near              ; CODE XREF: SYSINIT:0937↑p
                                        ; SYSINIT:0AAC↑p ...
                test    ds:bQueryOpt, 4 ; This function is very simple:
                                        ; it merely prepends a "/D" to the command-line for the shell;
                                        ; this (undocumented) switch disables AUTOEXEC.BAT processing
                                        ; and the date/time prompt that is usually displayed
                                        ; when there's no AUTOEXEC.BAT.
                jz      short disable_exit
                test    ds:dae_flag, 1
                jnz     short disable_exit
                or      ds:dae_flag, 1
                or      word ptr ds:bQueryOpt, 102h ; [bDefBlock] = 1
                mov     dx, ' D'        ; 2044h ; 'D ' (NASM syntax)

dae_1:                                  ; CODE XREF: CheckQueryOpt+16↓j
                mov     al, ds:def_swchr ; get default switchchar
                or      al, al
                jz      short disable_exit
                mov     bl, byte ptr ds:command_line ; "\x02/P"
                mov     bh, 0           ; BX == command-line length
                mov     cx, bx
                add     bl, 3
                cmp     bl, 126
                ja      short disable_exit ;
                                        ; update length
                mov     byte ptr ds:command_line, bl ; "\x02/P"
                add     bx, (offset command_line+1) ;
                                        ; make sure we move the NULL too
                inc     cx              ; (just for consistency sake)

disable_loop:                           ; CODE XREF: disable_autoexec+42↓j
                mov     ah, [bx-3]
                mov     [bx], ah
                dec     bx
                loop    disable_loop
                mov     [bx-2], al
                mov     [bx-1], dx      ; 'D ' ; /D is stuffed into place now

disable_exit:                           ; CODE XREF: disable_autoexec+5↑j
                                        ; disable_autoexec+C↑j ...
                retn
disable_autoexec endp


; =============== S U B R O U T I N E =======================================


CheckQueryOpt   proc near               ; CODE XREF: SYSINIT:process_autoexec↑p
                                        ; SYSINIT:0AAF↑p
                cmp     ds:bQueryOpt, 1
                jnz     short disable_exit
                test    ds:dae_flag, 2
                jnz     short disable_exit
                or      ds:dae_flag, 2
                mov     dx, ' Y'        ; 'Y ' ; 2059h
                jmp     short dae_1
CheckQueryOpt   endp


; =============== S U B R O U T I N E =======================================


any_delim       proc near               ; CODE XREF: menu_check+ED↑p
                                        ; menu_check+309↑p ...
                cmp     al, 0Dh         ; cr
                jz      short delim_ret
                cmp     al, 0Ah         ; lf
                jz      short delim_ret
                cmp     al, '['
                jz      short delim_ret
                cmp     al, ']'
                jz      short delim_ret
any_delim       endp


; =============== S U B R O U T I N E =======================================


delim           proc near               ; CODE XREF: doconf+344↑p
                                        ; ParseSize+2A↑p ...
                cmp     al, '/'         ; ibm will assume "/" as an delimeter
                jz      short delim_ret
                cmp     al, 0           ; special case for sysinit!
                jz      short delim_ret

org_delim:                              ; CODE XREF: organize+107↑p
                                        ; organize+1A0↑p
                cmp     al, 20h ; ' '   ; space
                jz      short delim_ret
                cmp     al, 9           ; tab
                jz      short delim_ret
                cmp     al, '='
                jz      short delim_ret
                cmp     al, ','
                jz      short delim_ret
                cmp     al, ';'
                clc

delim_ret:                              ; CODE XREF: any_delim+2↑j
                                        ; any_delim+6↑j ...
                retn
delim           endp


; =============== S U B R O U T I N E =======================================


newline         proc near               ; CODE XREF: doconf+124↑p
                                        ; newline+7↓j
                call    getchr          ; skip non-control characters
                jb      short nl_ret    ; no char
                cmp     al, 0Ah         ; lf
                jnz     short newline
                call    getchr

nl_ret:                                 ; CODE XREF: newline+3↑j
                retn                    ; al = first character of next line (if cf=0)
newline         endp


; =============== S U B R O U T I N E =======================================


mapcase         proc near               ; CODE XREF: organize+B1↑p
                push    cx
                push    si
                push    ds
                push    es
                pop     ds
                mov     bl, al

convloop:                               ; CODE XREF: mapcase+26↓j
                lodsb
                cmp     al, 'a'
                jb      short noconv
                cmp     al, 'z'
                ja      short noconv
                sub     al, 20h         ; convert to upper-case (and al,0DFh)
                mov     [si-1], al

noconv:                                 ; CODE XREF: mapcase+A↑j
                                        ; mapcase+E↑j
                cmp     bl, 'V'         ; CONFIG_SET ; preserve case for part of the line?
                jnz     short check_eol ; no, just check for end-of-line
                cmp     al, '='         ; separator between SET var and value?
                jz      short convdone  ; yes
                                        ; (we don't want to upper-case
                                        ; anything after the "=" in a SET)

check_eol:                              ; CODE XREF: mapcase+18↑j
                cmp     al, 0Dh         ; cr
                jz      short convdone
                cmp     al, 0Ah         ; lf
                jz      short convdone
                loop    convloop

convdone:                               ; CODE XREF: mapcase+1C↑j
                                        ; mapcase+20↑j ...
                pop     ds
                pop     si
                pop     cx
                retn
mapcase         endp


; =============== S U B R O U T I N E =======================================


round           proc near               ; CODE XREF: endfile:dosfts↑p
                                        ; endfile+82↑p ...

; FUNCTION CHUNK AT 1468 SIZE 00000001 BYTES

                push    ax              ; round the values in memlo and memhi
                                        ; to paragraph boundary.
                                        ; perform bounds check.
                mov     ax, cs:memlo
                call    ParaRound       ; para round up
                add     cs:memhi, ax
                mov     cs:memlo, 0
                mov     ax, cs:memhi    ; ax = new memhi
                cmp     ax, cs:ALLOCLIM
                jnb     short mem_err
                test    cs:setdevmarkflag, 2 ; for_devmark
                jz      short skip_set_devmarksize
                push    es
                push    si
                mov     si, cs:devmark_addr
                mov     es, si
                sub     ax, si
                dec     ax
                mov     es:3, ax        ; mov [es:devmark.size],ax ; paragraph
                and     cs:setdevmarkflag, 0FDh ; ~2 ; not 2
                                        ; not_for_devmark
                pop     si
                pop     es

skip_set_devmarksize:                   ; CODE XREF: round+25↑j
                pop     ax
                clc
                retn
; ---------------------------------------------------------------------------

mem_err:                                ; CODE XREF: doconf:NoMem↑j
                                        ; RoundBreakAddr+1E↑j ...
                mov     dx, offset badmem ; "\r\nConfiguration too large for memory"...
                push    cs
                pop     ds
                assume ds:SYSINIT
                call    print
                jmp     stall
round           endp


; =============== S U B R O U T I N E =======================================


calldev         proc near               ; CODE XREF: doconf+48B↑p
                                        ; doconf+491↑p
                mov     ds, word ptr cs:DevEntry+2
                assume ds:nothing
                add     bx, word ptr cs:DevEntry ; do a little relocation
                mov     ax, [bx]
                push    word ptr cs:DevEntry
                mov     word ptr cs:DevEntry, ax
                mov     bx, offset packet
                call    cs:DevEntry
                pop     word ptr cs:DevEntry
                retn
calldev         endp


; =============== S U B R O U T I N E =======================================


todigit         proc near               ; CODE XREF: getnum:b2↓p
                sub     al, '0'
                jb      short notdig
                cmp     al, 9
                ja      short notdig
                clc
                retn
; ---------------------------------------------------------------------------

notdig:                                 ; CODE XREF: todigit+2↑j
                                        ; todigit+6↑j
                stc
                retn
todigit         endp


; =============== S U B R O U T I N E =======================================


getnum          proc near               ; CODE XREF: check_switch+45↑p
                push    bx              ; getnum parses a decimal number.
                                        ; returns it in ax, sets zero flag if ax = 0
                                        ; (may be considered an error),
                                        ; if number is bad carry is set, zero is set, ax=0.
                                        ; ;;
                xor     bx, bx          ; running count is zero

b2:                                     ; CODE XREF: getnum+40↓j
                call    todigit         ; do we have a digit ?
                jb      short badnum    ; no, bomb
                xchg    ax, bx          ; put total in ax
                push    bx              ; save digit (0 to 9)
                mov     bx, 10          ; base of arithmetic
                mul     bx              ; shift by one decimal digit
                pop     bx              ; get back digit (0 to 9)
                add     al, bl          ; get total
                adc     ah, 0           ; make that 16 bits
                jb      short badnum    ; too big a number
                xchg    ax, bx          ; stash total
                call    getchr          ; get next digit
                jb      short b1        ; no more characters
                cmp     al, ' '         ; space?
                jz      short b15       ; then end of digits
                cmp     al, ','         ; ',' is a seperator!!!
                jz      short b15       ; then end of digits.
                cmp     al, 9           ; tab
                jz      short b15
                cmp     al, cs:sepchr   ; allow 0 or special separators
                jz      short b15
                cmp     al, '/'         ; see if another switch follows
                nop                     ; cas - remnant of old bad code
                nop                     ; (04/08/2023 - Erdogan Tan - 'nop,nop' is not neded)
                jz      short b15
                cmp     al, 0Ah         ; lf ; line-feed?
                jz      short b15
                cmp     al, 0Dh         ; cr ; carriage return?
                jz      short b15
                or      al, al          ; end of line separator?
                jnz     short b2        ; no, try as a valid char...

b15:                                    ; CODE XREF: getnum+1F↑j
                                        ; getnum+23↑j ...
                inc     cs:count        ; one more character to s...
                dec     cs:chrptr       ; clears carry, sets zero accordingly

b1:                                     ; CODE XREF: getnum+1B↑j
                mov     ax, bx
                or      ax, ax
                pop     bx
                retn
; ---------------------------------------------------------------------------

badnum:                                 ; CODE XREF: getnum+6↑j
                                        ; getnum+15↑j
                mov     cs:sepchr, 0
                xor     ax, ax          ; set zero flag, and ax = 0
                pop     bx
                stc                     ; and carry set
                retn
getnum          endp


; =============== S U B R O U T I N E =======================================


setdoscountryinfo proc near             ; CODE XREF: doconf+787↑p
                push    di              ; input:
                                        ;   es:di -> pointer to dos_country_cdpg_info
                                        ;   ds:0  -> buffer.
                                        ;      si = 0
                                        ;      ax = country id
                                        ;      dx = code page id. (if 0, then use ccsyscodepage as a default.)
                                        ;      bx = file handle
                                        ;   this routine can handle maximum 438 country_data entries.
                                        ; output:
                                        ;   dos_country_cdpg_info set.
                                        ;   carry set if any file read failure or wrong information in the file.
                                        ;   carry set and cx = -1 if cannot find the matching country_id,
                                        ;         codepage_id in the file.
                push    ax
                push    dx
                xor     cx, cx
                xor     dx, dx
                mov     ax, 512         ; read 512 bytes
                call    readincontrolbuffer ; read the file header
                jb      short setdosdata_fail
                push    es
                push    si
                push    cs
                pop     es
                assume es:SYSINIT
                mov     di, offset country_file_signature ; db 0FFh,'COUNTRY'
                mov     cx, 8           ; length of the signature
                repe cmpsb
                pop     si
                pop     es
                assume es:nothing
                jnz     short setdosdata_fail ; signature mismatch
                add     si, 18
                cmp     byte ptr [si], 1 ; si -> county info type
                                        ; only accept type 1 (currently only 1 header type)
                jnz     short setdosdata_fail ; cannot proceed. error return
                inc     si              ; si -> file offset
                mov     dx, [si]        ; get the info file offset.
                mov     cx, [si+2]
                mov     ax, 6144        ; read 6144 bytes.
                call    readincontrolbuffer ; read info
                jb      short setdosdata_fail
                mov     cx, [si]        ; get the # of country, codepage combination entries
                cmp     cx, 438         ; cannot handle more than 438 entries.
                ja      short setdosdata_fail
                inc     si
                inc     si              ; si -> entry information packet
                pop     dx              ; restore code page id
                pop     ax              ; restore country id
                pop     di              ; search for desired country_id,codepage_id.

setdoscntry_find:                       ; CODE XREF: setdoscountryinfo+55↓j
                cmp     ax, [si+2]      ; compare country_id
                jnz     short setdoscntry_next
                cmp     dx, 0           ; no user specified code page ?
                jz      short setdoscntry_any_codepage ; then no need to match code page id.
                cmp     dx, [si+4]      ; compare code page id
                jz      short setdoscntry_got_it

setdoscntry_next:                       ; CODE XREF: setdoscountryinfo+45↑j
                add     si, [si]        ; next entry
                inc     si
                inc     si              ; take a word for size of entry itself
                loop    setdoscntry_find
                mov     cx, 0FFFFh      ; -1 ; signals that bad country id entered.

setdoscntry_fail:                       ; CODE XREF: setdoscountryinfo+5F↓j
                                        ; setdoscountryinfo+75↓j
                stc
                retn
; ---------------------------------------------------------------------------

setdosdata_fail:                        ; CODE XREF: setdoscountryinfo+D↑j
                                        ; setdoscountryinfo+1D↑j ...
                pop     si
                pop     cx
                pop     di
                jmp     short setdoscntry_fail
; ---------------------------------------------------------------------------

setdoscntry_any_codepage:               ; CODE XREF: setdoscountryinfo+4A↑j
                mov     dx, [si+4]      ; use the code_page_id of the country_id found.

setdoscntry_got_it:                     ; CODE XREF: setdoscountryinfo+4F↑j
                mov     cs:cntrycodepage_id, dx ; save code page id for this country.
                mov     dx, [si+10]     ; get the file offset of country data
                mov     cx, [si+12]
                mov     ax, 512         ; read 512 bytes
                call    readincontrolbuffer
                jb      short setdoscntry_fail
                mov     cx, [si]        ; get the number of entries to handle.
                inc     si
                inc     si              ; si -> first entry

setdoscntry_data:                       ; CODE XREF: setdoscountryinfo+110↓j
                push    di              ; es:di -> dos_country_cdpg_info
                push    cx              ; save # of entry left
                push    si              ; si -> current entry in control buffer
                mov     al, [si+2]      ; get data entry id
                call    getcountrydestination ; get the address of destination in es:di
                jb      short setdoscntry_data_next ; no matching data entry id in dos
                mov     dx, [si+4]      ; get offset of data
                mov     cx, [si+6]
                mov     ax, 4200h
                stc
                int     21h             ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
                                        ; AL = method: offset from beginning of file
                jb      short setdosdata_fail ;
                                        ; read the country.sys data
                mov     dx, 512         ; start of data buffer
                mov     cx, 20          ; read 20 bytes only. we only need to
                mov     ah, 3Fh         ; look at the length of the data in the file.
                stc
                int     21h             ; DOS - 2+ - READ FROM FILE WITH HANDLE
                                        ; BX = file handle, CX = number of bytes to read
                                        ; DS:DX -> buffer
                jb      short setdosdata_fail ; read failure
                cmp     ax, cx
                jnz     short setdosdata_fail
                mov     dx, [si+4]      ; get offset of data again.
                mov     cx, [si+6]
                mov     ax, 4200h       ; move pointer back again
                stc
                int     21h             ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
                                        ; AL = method: offset from beginning of file
                jb      short setdosdata_fail
                push    si
                mov     si, 520         ; (512+8) ; get length of the data from the file
                mov     cx, [si]
                pop     si
                mov     dx, 512         ; start of data buffer
                add     cx, 10          ; signature + a word for the length itself
                mov     ah, 3Fh         ; read the data from the file.
                stc
                int     21h             ; DOS - 2+ - READ FROM FILE WITH HANDLE
                                        ; BX = file handle, CX = number of bytes to read
                                        ; DS:DX -> buffer
                jb      short setdosdata_fail
                cmp     ax, cx
                jnz     short setdosdata_fail
                mov     al, [si+2]      ; save data id for future use.
                mov     si, 520         ; (512+8) ; si-> data buffer + id tag field
                mov     cx, [si]        ; get the length of the file
                inc     cx              ; take care of a word for lenght of tab itself.
                inc     cx
                cmp     cx, 1528        ; (2048-512-8) ; fit into the buffer?
                ja      short setdosdata_fail
                call    setdbcs_before_copy
                cmp     al, 1           ; SetCountryInfo ; is the data for setcountryinfo table?
                jnz     short setdoscntry_mov ; no, don't worry
                push    word ptr es:[di+24] ;
                                        ; [es:di+country_cdpg_info.ccMono_Ptr
                                        ;  -country_cdpg_info.ccCountryInfoLen]
                push    word ptr es:[di+26] ;
                                        ; [es:di+country_cdpg_info.ccMono_Ptr
                                        ;  -country_cdpg_info.ccCountryInfoLen+2]
                                        ;
                                        ; at this time di -> cccountryinfolen
                push    di
                push    ax
                mov     ax, cs:cntrycodepage_id ; do not use the code page info in country_info
                mov     [si+4], ax      ; use the saved one for this !!!
                pop     ax

setdoscntry_mov:                        ; CODE XREF: setdoscountryinfo+E0↑j
                rep movsb               ; copy the table into dos
                cmp     al, 1           ; SetCountryInfo ; was the ccmono_ptr saved?
                jnz     short setdoscntry_data_next
                pop     di
                pop     word ptr es:[di+26] ;
                                        ; [es:di+country_cdpg_info.ccMono_Ptr
                                        ;  -country_cdpg_info.ccCountryInfoLen+2]
                pop     word ptr es:[di+24] ;
                                        ; [es:di+country_cdpg_info.ccMono_Ptr
                                        ;  -country_cdpg_info.ccCountryInfoLen]

setdoscntry_data_next:                  ; CODE XREF: setdoscountryinfo+84↑j
                                        ; setdoscountryinfo+F8↑j
                pop     si              ; restore control buffer pointer
                pop     cx              ; restore # of entries left
                pop     di              ; restore pointer to dso_country_cdpg
                add     si, [si]        ; try to get the next entry
                inc     si
                inc     si              ; take a word of entry length itself
                dec     cx
                cmp     cx, 0
                jz      short setdoscntry_ok
                jmp     setdoscntry_data
; ---------------------------------------------------------------------------

setdoscntry_ok:                         ; CODE XREF: setdoscountryinfo+10E↑j
                retn
setdoscountryinfo endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================


setdbcs_before_copy proc near           ; CODE XREF: setdoscountryinfo+DB↑p
                cmp     al, 7           ; SetDBCS ; dbcs vector set?
                jnz     short sdbcsbc   ; jump if not
                cmp     word ptr es:[di], 0 ; zero byte data block?
                jz      short sdbcsbc   ; jump if so
                push    di
                push    ax
                push    cx
                mov     cx, es:[di]     ; load block length
                add     di, 2           ; points actual data
                xor     al, al          ; fill bytes
                rep stosb               ; clear data block
                pop     cx
                pop     ax
                pop     di

sdbcsbc:                                ; CODE XREF: setdbcs_before_copy+2↑j
                                        ; setdbcs_before_copy+8↑j
                retn
setdbcs_before_copy endp


; =============== S U B R O U T I N E =======================================


getcountrydestination proc near         ; CODE XREF: setdoscountryinfo+81↑p
                push    cx              ; get the destination address
                                        ;  in the dos country info table.
                add     di, 74          ; country_cdpg_info.ccNumber_of_entries
                                        ; skip the reserved area, syscodepage etc.
                mov     cx, es:[di]     ; get the number of entries
                inc     di
                inc     di              ; si -> the first start entry id

getcntrydest:                           ; CODE XREF: getcountrydestination:getcntrydest_loop↓j
                cmp     es:[di], al
                jz      short getcntrydest_ok
                cmp     byte ptr es:[di], 1 ; SetCountryInfo ; was it setcountryinfo entry?
                jz      short getcntrydest_1
                add     di, 5           ; next data id
                jmp     short getcntrydest_loop
; ---------------------------------------------------------------------------

getcntrydest_1:                         ; CODE XREF: getcountrydestination+12↑j
                add     di, 41          ; NEW_COUNTRY_SIZE+3 ; next data id

getcntrydest_loop:                      ; CODE XREF: getcountrydestination+17↑j
                loop    getcntrydest
                stc
                jmp     short getcntrydest_exit
; ---------------------------------------------------------------------------

getcntrydest_ok:                        ; CODE XREF: getcountrydestination+C↑j
                cmp     al, 1           ; SetCountryInfo ; select country info?
                jnz     short getcntrydest_ok1
                inc     di              ; now di -> cccountryinfolen
                jmp     short getcntrydest_exit
; ---------------------------------------------------------------------------

getcntrydest_ok1:                       ; CODE XREF: getcountrydestination+23↑j
                les     di, es:[di+1]   ; get the destination in es:di

getcntrydest_exit:                      ; CODE XREF: getcountrydestination+1F↑j
                                        ; getcountrydestination+26↑j
                pop     cx
                retn
getcountrydestination endp


; =============== S U B R O U T I N E =======================================


readincontrolbuffer proc near           ; CODE XREF: setdoscountryinfo+A↑p
                                        ; setdoscountryinfo+30↑p ...
                push    ax              ; # of bytes to read
                mov     ax, 4200h
                stc
                int     21h             ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
                                        ; AL = method: offset from beginning of file
                pop     cx              ; # of bytes to read
                jb      short ricb_exit
                xor     dx, dx          ; ds:dx -> control buffer
                xor     si, si
                mov     ah, 3Fh         ; read into the buffer
                                        ; should be less than 1024 bytes.
                stc
                int     21h             ; DOS - 2+ - READ FROM FILE WITH HANDLE
                                        ; BX = file handle, CX = number of bytes to read
                                        ; DS:DX -> buffer

ricb_exit:                              ; CODE XREF: readincontrolbuffer+8↑j
                retn
readincontrolbuffer endp

; ---------------------------------------------------------------------------

set_country_path:                       ; ! this procedure is not called from anywhere !
                push    si              ; Erdogan Tan - 04/08/2023
                push    ds
                push    es
                pop     ds
                pop     es
                call    chk_drive_letter
                jb      short scp_default_drv
                mov     al, [si]
                inc     si
                inc     si
                jmp     short scp_setdrv
; ---------------------------------------------------------------------------

scp_default_drv:                        ; CODE XREF: SYSINIT:5143↑j
                mov     ah, 19h
                int     21h             ; DOS - GET DEFAULT DISK NUMBER
                add     al, 'A'

scp_setdrv:                             ; CODE XREF: SYSINIT:5149↑j
                mov     byte ptr cs:cntry_drv, al ; "A:"
                mov     di, offset cntry_path ; "COUNTRY.SYS"
                mov     al, [si]
                cmp     al, '\'
                jz      short scp_root_dir
                cmp     al, '/'
                jz      short scp_root_dir
                jmp     short scp_path
; ---------------------------------------------------------------------------

scp_root_dir:                           ; CODE XREF: SYSINIT:515C↑j
                                        ; SYSINIT:5160↑j
                dec     di

scp_path:                               ; CODE XREF: SYSINIT:5162↑j
                call    move_asciiz
                mov     di, offset cntry_drv ; "A:"
                push    ds
                push    es
                pop     ds
                pop     es
                pop     si
                retn

; =============== S U B R O U T I N E =======================================


chk_drive_letter proc near              ; CODE XREF: SYSINIT:5140↑p
                push    ax
                cmp     byte ptr [si], 'A'
                jb      short cdletter_no
                cmp     byte ptr [si], 'Z'
                ja      short cdletter_no
                cmp     byte ptr [si+1], ':'
                jnz     short cdletter_no
                jmp     short cdletter_exit
; ---------------------------------------------------------------------------

cdletter_no:                            ; CODE XREF: chk_drive_letter+4↑j
                                        ; chk_drive_letter+9↑j ...
                stc

cdletter_exit:                          ; CODE XREF: chk_drive_letter+11↑j
                pop     ax
                retn
chk_drive_letter endp


; =============== S U B R O U T I N E =======================================


move_asciiz     proc near               ; CODE XREF: doconf+715↑p
                                        ; doconf+77A↑p ...
                movsb
                cmp     byte ptr [si-1], 0 ; was it 0?
                jnz     short move_asciiz
                retn
move_asciiz     endp


; =============== S U B R O U T I N E =======================================


badfil          proc near               ; CODE XREF: SYSINIT:0A09↑p
                                        ; endfile+388↑p ...
                push    cs
                pop     es
                assume es:SYSINIT
                mov     si, dx

badload:                                ; CODE XREF: SYSINIT:142A↑p
                                        ; doconf:tryd_2↑p ...
                mov     dx, offset badld_pre ; "\r\nBad or missing $"
                mov     bx, offset crlfm ; "\r\n$"

prnerr:                                 ; CODE XREF: doconf+6AD↑p
                push    cs
                pop     ds
                assume ds:SYSINIT
                call    print

prn1:                                   ; CODE XREF: badfil+1B↓j
                mov     dl, es:[si]
                or      dl, dl
                jz      short prn2
                mov     ah, 2
                int     21h             ; DOS - DISPLAY OUTPUT
                                        ; DL = character to send to standard output
                inc     si
                jmp     short prn1
; ---------------------------------------------------------------------------

prn2:                                   ; CODE XREF: badfil+14↑j
                mov     dx, bx
                call    print
                cmp     cs:donotshownum, 1 ; suppress line number when handling command.com
                jz      short prnexit
                call    error_line

prnexit:                                ; CODE XREF: badfil+28↑j
                retn
badfil          endp


; =============== S U B R O U T I N E =======================================


print           proc near               ; CODE XREF: SYSINIT:0720↑p
                                        ; SYSINIT:09CB↑p ...
                mov     ah, 9
                int     21h             ; DOS - PRINT STRING
                                        ; DS:DX -> string terminated by "$"
                retn
print           endp


; =============== S U B R O U T I N E =======================================


open_dev        proc near               ; CODE XREF: endfile+3A5↑p
                                        ; endfile+3AD↑p
                call    open_file
                jnb     short open_dev3

open_dev1:                              ; CODE XREF: open_dev+1D↓j
                mov     dx, offset nuldev ; "NUL"
                call    open_file

of_retn:                                ; CODE XREF: open_dev+17↓j
                retn
; ---------------------------------------------------------------------------

open_dev3:                              ; CODE XREF: open_dev+3↑j
                mov     bx, ax          ; handle from open to bx
                xor     ax, ax
                mov     ah, 44h
                int     21h             ; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
                                        ; BX = file or device handle
                test    dl, 80h
                jnz     short of_retn
                mov     ah, 3Eh
                int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
                                        ; BX = file handle
                jmp     short open_dev1
open_dev        endp


; =============== S U B R O U T I N E =======================================


open_file       proc near               ; CODE XREF: open_dev↑p
                                        ; open_dev+8↑p
                mov     ah, 3Dh         ; OPEN
                stc
                int     21h             ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
                                        ; DS:DX -> ASCIZ filename
                                        ; AL = access mode
                                        ; 0 - read, 1 - write, 2 - read & write
                retn
open_file       endp

; ---------------------------------------------------------------------------

int24:                                  ; DATA XREF: SYSINIT:070E↑o
                mov     al, 3           ; fail the system call
                iret                    ; return back to dos.
; ---------------------------------------------------------------------------
IBMDOSV71COPYR  db 'IBM DOS Version 7.1 (C)Copyright 1981-2002 IBM Corporation Licens'
                db 'ed Material - Property of IBM All rights reserved '
nuldev          db 'NUL',0              ; DATA XREF: open_dev:open_dev1↑o
condev          db 'CON',0              ; DATA XREF: endfile+37C↑o
auxdev          db 'AUX',0              ; DATA XREF: endfile:goaux2↑o
prndev          db 'PRN',0              ; DATA XREF: endfile+3A8↑o
config          db '\CONFIG.SYS',0      ; DATA XREF: doconf+F↑o
                                        ; doconf:conferr↑o
cntry_drv       db 'A:'                 ; DATA XREF: doconf+6C0↑w
                                        ; doconf+712↑o ...
cntry_root      db '\'                  ; DATA XREF: doconf:tryq_def↑o
                                        ; doconf:tryqdefbad↑o
cntry_path      db 'COUNTRY.SYS',0      ; DATA XREF: SYSINIT:5155↑o
                db 52 dup(0)
country_file_signature db 0FFh,'COUNTRY'
                                        ; DATA XREF: setdoscountryinfo+13↑o
cntrycodepage_id dw 0                   ; DATA XREF: setdoscountryinfo:setdoscntry_got_it↑w
                                        ; setdoscountryinfo+EC↑r
newcmd          db 0                    ; DATA XREF: SYSINIT:0987↑r
                                        ; SYSINIT:09FF↑r ...
                                        ; non-zero if non-std shell specified
tmplate         db 64, 12               ; DATA XREF: SYSINIT:0A55↑o
                                        ; SYSINIT:0A4A↑r ...
                                        ; must precede commnd
                                        ; size of commnd line (excl. null)
                                        ; 5309h-52C9h = 40h = 64
commnd          db '\COMMAND.COM',0     ; DATA XREF: SYSINIT:retry↑o
                                        ; SYSINIT:0A50↑w ...
                db 50 dup(0)
commnd_63       db 0                    ; DATA XREF: doconf+944↑o
commnd2         db '\COMMAND.COM',0     ; DATA XREF: SYSINIT:0A15↑o
                                        ; alternate commands to exec
                db 2,'/P',0             ; followed by their respective alternate command lines
commnd3         db '\MSDOS\COMMAND.COM',0
                                        ; DATA XREF: SYSINIT:do_def3↑o
                db 11
                db 'A:\MSDOS /P',0
commnd4         db '\DOS\COMMAND.COM',0 ; DATA XREF: SYSINIT:comerr↑r
                                        ; SYSINIT:0A31↑o
                db 9
                db 'A:\DOS /P',0
def_swchr       db 0                    ; DATA XREF: doconf+B↑w
                                        ; disable_autoexec:dae_1↑r
command_line    db 2,'/P'               ; DATA XREF: SYSINIT:EXEC0_COM_LINE↑o
                                        ; SYSINIT:093D↑r ...
                db 123 dup(0)
command_line_126 db 0                   ; DATA XREF: doconf+95C↑o
                db 0
pathstring      db 64 dup(0)
dae_flag        db 0                    ; DATA XREF: SYSINIT:0AA7↑w
                                        ; disable_autoexec+7↑r ...
bMenuColor      db 7                    ; DATA XREF: menu_check:set_color↑w
                                        ; menu_check+1CF↑r ...
                                        ; default fgnd/bgnd color
bMenuPage       db 0                    ; DATA XREF: menu_check+1C7↑r
                                        ; menu_check+1FD↑r ...
                                        ; menu video page (KEEP AFTER bMenuColor)
                db 5                    ; video page function # (KEEP AFTER bMenuPage)
bLastCol        db 0                    ; DATA XREF: menu_check+218↑w
                                        ; show_status+C↑r
                                        ; ending column on status line
bLastRow        db 24                   ; DATA XREF: menu_check+1E5↑r
                                        ; menu_check+1EC↑w ...
                                        ; row # of status line (KEEP AFTER bLastCol)
bDisableUI      db 0                    ; DATA XREF: SYSINIT:091E↑r
                                        ; kbd_read↑r ...
                                        ; 1=disable clean/interactive
                                        ; 2=disable default 2-second delay
bCRTPage        db 0                    ; DATA XREF: menu_check+1C4↑w
                                        ; menu_check+34B↑r
                                        ; value saved from BIOS data area
wCRTStart       dw 0                    ; DATA XREF: menu_check+1BD↑w
                                        ; menu_check+344↑r
                                        ; value saved from BIOS data area
bQueryOpt       db 0                    ; DATA XREF: SYSINIT:bypass_autoexec↑w
                                        ; kbd_read+34↑w ...
                                        ; 0=off, 1=prompt all, 2=prompt none, 4=skip all
bDefBlock       db 1                    ; DATA XREF: menu_check:menu_found↑w
                                        ; menu_check:menu_setdefault↑w ...
                                        ; default block #
bMaxBlock       db 0                    ; DATA XREF: menu_check+16C↑w
                                        ; menu_check+18E↑r ...
                                        ; maximum block #
offDefBlock     dw 0                    ; DATA XREF: menu_check+B5↑w
                                        ; menu_check:menu_default↑w ...
                                        ; offset of name of default block (if any)
secTimeOut      db 0FFh                 ; DATA XREF: menu_check+BB↑w
                                        ; menu_check:timeout_ok↑w ...
                                        ; # of seconds for timeout (-1 == indefinite)
secElapsed      db 0                    ; DATA XREF: kbd_read+74↑w
                                        ; menu_check+103↑r ...
                                        ; # of seconds elapsed so far (KEEP AFTER secTimeOut)
abBlockType     db 10 dup(0)            ; DATA XREF: menu_check+13B↑w
                                        ; menu_check:not_topmenu↑r
                                        ; times MAX_MULTI_CONFIG+1 db 0
                                        ; array of block types
aoffBlockName   dw 10 dup(0)            ; DATA XREF: menu_check+141↑w
                                        ; menu_check+17C↑r ...
                                        ; times MAX_MULTI_CONFIG+1 dw 0
                                        ; array of offsets of block names
aoffBlockDesc   dw 10 dup(0)            ; DATA XREF: menu_check+145↑w
                                        ; menu_check+157↑w ...
                                        ; times MAX_MULTI_CONFIG+1 dw 0
                                        ; array of offsets of block descriptions
szBoot          db 'CONFIG=',0          ; DATA XREF: menu_check+70↑w
                                        ; menu_check+2E9↑o
szMenu          db 'MENU',0             ; DATA XREF: menu_check+68↑o
                                        ; copy_block+17↑o
szCommon        db 'COMMON',0           ; DATA XREF: menu_check+2AB↑o
                                        ; menu_check+303↑o ...
comtab          db 1,'[['               ; DATA XREF: organize+36↑o
                                        ; query_user+2F↑o
                                        ; CONFIG.SYS Command Table
                                        ; CONFIG_BEGIN
aBreak          db 5,'BREAKC'           ; CONFIG_BREAK
aBuffers        db 7,'BUFFERSB'         ; CONFIG_BUFFERS
aComment        db 7,'COMMENTY'         ; CONFIG_COMMENT
aCountry        db 7,'COUNTRYQ'         ; CONFIG_COUNTRY
aDevice         db 6,'DEVICED'          ; CONFIG_DEVICE
aDevicehigh     db 0Ah                  ; CONFIG_DEVICEHIGH
                db 'DEVICEHIGHU'
aDos            db 3,'DOSH'             ; CONFIG_DOS
aDrivparm       db 8,'DRIVPARMP'        ; CONFIG_DRIVPARM
aFcbs           db 4,'FCBSX'            ; CONFIG_FCBS
aFiles          db 5,'FILESF'           ; CONFIG_FILES
aInclude        db 7,'INCLUDEJ'         ; CONFIG_INCLUDE
aInstall        db 7,'INSTALLI'         ; CONFIG_INSTALL
aInstallhigh    db 0Bh,'INSTALLHIGHW'   ; CONFIG_INSTALLHIGH
aLastdrive      db 9,'LASTDRIVEL'       ; CONFIG_LASTDRIVE
aSubmenu        db 7,'SUBMENUO'         ; CONFIG_SUBMENU
aMenucolor      db 9,'MENUCOLORR'       ; CONFIG_MENUCOLOR
aMenudefault    db 0Bh,'MENUDEFAULTA'   ; CONFIG_MENUDEFAULT
aMenuitem       db 8,'MENUITEME'        ; CONFIG_MENUITEM
aMultitrack     db 0Ah                  ; CONFIG_MULTITRACK
                db 'MULTITRACKM'
aNumlock        db 7,'NUMLOCKN'         ; CONFIG_NUMLOCK
aRem            db 3,'REM0'             ; CONFIG_REM
aSet            db 3,'SETV'             ; CONFIG_SET
aShell          db 5,'SHELLS'           ; CONFIG_SHELL
aStacks         db 6,'STACKSK'          ; CONFIG_STACKS
aSwitches       db 8,'SWITCHES1'        ; CONFIG_SWITCHES
aDosdata        db 7,'DOSDATAT'         ; CONFIG_DOSDATA
                db 0                    ; end of command table
devp_specialfunc db 0                   ; DATA XREF: endfile+13C↑o
                                        ; setparms+F↑o
                                        ; deviceparameters
devp_devtype    db 2                    ; DATA XREF: diddleback+9↑w
                                        ; process_num+17↑w ...
devp_devattr    dw 0                    ; DATA XREF: diddleback+E↑w
                                        ; parseline+39↑w
devp_cylinders  dw 80                   ; DATA XREF: diddleback+3↑w
                                        ; process_num+26↑w ...
                db 0
devp_bps        dw 0                    ; DATA XREF: endfile+14D↑r
                                        ; setdeviceparameters+1A↑o
                                        ; A_DEVICEPARAMETERS.DP_BPB
                                        ; bytes per sectors
devp_secperclus db 0                    ; DATA XREF: setdeviceparameters:heads_not_altered↑w
                                        ; setdeviceparameters:got_one_secperclus_drive↑w
                dw 0
                db 0
                dw 0
devp_totalsecs  dw 0                    ; DATA XREF: endfile+149↑r
                                        ; setdeviceparameters+9E↑w
                                        ; total sectors
devp_mediaid    db 0                    ; DATA XREF: setdeviceparameters+47↑r
                                        ; setdeviceparameters:got_correct_mediaid↑w
                dw 0
devp_spt        dw 0                    ; DATA XREF: setparms:not_ec35↑r
                                        ; setdeviceparameters+2F↑w ...
devp_heads      dw 0                    ; DATA XREF: setdeviceparameters+3D↑w
                                        ; setdeviceparameters+4B↑r ...
                db 68 dup(0)
devp_trktblents dw 0                    ; DATA XREF: parseline+3C↑w
                db 252 dup(0)
hlim            dw 2                    ; DATA XREF: process_num:try_h↑w
                                        ; setdeviceparameters+3A↑r
slim            dw 9                    ; DATA XREF: process_num+31↑w
                                        ; setdeviceparameters+2C↑r
drive           db 0                    ; DATA XREF: setparms+9↑r
                                        ; setparms+2A↑r ...
switches        dw 0                    ; DATA XREF: setparms+21↑r
                                        ; diddleback+14↑w ...
_bpb48t         dw 512                  ; DATA XREF: SYSINIT:_bpbtable↓o
                                        ; 48 tpi diskettes
                db 2
                dw 1
                db 2
                dw 112
                dw 720                  ; 2*9*40
                db 0FDh
                dw 2
                dw 9
                dw 2
                dd 0
                dd 0
_bpb96t         dw 512                  ; DATA XREF: SYSINIT:573A↓o
                                        ; 96tpi diskettes
                db 1
                dw 1
                db 2
                dw 224
                dw 2400                 ; 2*15*80
                db 0F9h
                dw 7
                dw 15
                dw 2
                dd 0
                dd 0
_bpb35          dw 200h                 ; DATA XREF: SYSINIT:573C↓o
                                        ; SYSINIT:573E↓o ...
                                        ; 3 1/2 inch diskette bpb
                db 2
                dw 1
                db 2
                dw 112
                dw 1440                 ; 2*9*80
                db 0F9h
                dw 3
                dw 9
                dw 2
                dd 0
                dd 0
_bpb35h         dw 512                  ; DATA XREF: SYSINIT:5746↓o
                db 1
                dw 1
                db 2
                dw 224
                dw 2880                 ; 2*18*80
                db 0F0h
                dw 9
                dw 18
                dw 2
                dd 0
                dd 0
_bpb288         dw 512                  ; DATA XREF: SYSINIT:574A↓o
                db 2
                dw 1
                db 2
                dw 240
                dw 5760                 ; 2*36*80
                db 0F0h
                dw 9
                dw 36
                dw 2
                dd 0
                dd 0
_bpbtable       dw offset _bpb48t       ; DATA XREF: setdeviceparameters+16↑r
                                        ; 48tpi drives
                dw offset _bpb96t       ; 96tpi drives
                dw offset _bpb35        ; 3.5" drives
                dw offset _bpb35        ; not used - 8" drives - default to 3.5"
                dw offset _bpb35        ; not used - 8" drives - default to 3.5"
                dw offset _bpb35        ; not used - hard files - default to 3.5"
                dw offset _bpb35        ; not used - tape drives - default to 3.5"
                dw offset _bpb35h       ; 3-1/2" 1.44mb drive
                dw offset _bpb35        ; ERIMO
                dw offset _bpb288       ; 2.88 MB diskette drives
switchlist      db 8,'FHSTDICN'         ; DATA XREF: check_switch+12↑r
                                        ; check_switch+18↑o
                                        ; preserve the positions of n and c
                db 0
badopm          db 0Dh,0Ah              ; DATA XREF: SYSINIT:331C↑o
                                        ; doconf:badop↑o
                db 'Unrecognized command in CONFIG.SYS'
crlfm           db 0Dh,0Ah,'$'          ; DATA XREF: SYSINIT:0A5C↑o
                                        ; doconf+6AA↑o ...
badparm         db 0Dh,0Ah              ; DATA XREF: badparm_p+5↑o
                db 'Bad command or parameters - $'
badsiz_pre      db 0Dh,0Ah              ; DATA XREF: doconf+6A7↑o
                db 'Sector size too large in file $'
badld_pre       db 0Dh,0Ah              ; DATA XREF: badfil:badload↑o
                db 'Bad or missing $'
badcom          db 'Command Interpreter',0
                                        ; DATA XREF: SYSINIT:comerr2↑o
badcountry      db 0Dh,0Ah              ; DATA XREF: doconf+72A↑o
                                        ; cntry_error+5↑o
                db 'Invalid country code or code page',0Dh,0Ah,'$'
badcountrycom   db 0Dh,0Ah              ; DATA XREF: cntry_error:if64↑o
                db 'Error in COUNTRY command',0Dh,0Ah,'$'
insufmemory     db 0Dh,0Ah              ; DATA XREF: doconf:tryqmemory↑o
                db 'Insufficient memory for COUNTRY.SYS file',0Dh,0Ah,'$'
badmem          db 0Dh,0Ah              ; DATA XREF: SYSINIT:memerrjx↑o
                                        ; round:mem_err↑o
                db 'Configuration too large for memory',0Dh,0Ah,'$'
badblock        db 0Dh,0Ah              ; DATA XREF: doconf+4D6↑o
                db 'Too many block devices',0Dh,0Ah,'$'
badstack        db 0Dh,0Ah              ; DATA XREF: doconf+881↑o
                                        ; doconf+8F4↑o
                db 'Invalid STACK parameters',0Dh,0Ah,'$'
badorder        db 0Dh,0Ah              ; DATA XREF: SYSINIT:incorrect_order↑o
                db 'Incorrect order in CONFIG.SYS line $'
errorcmd        db 'Error in CONFIG.SYS line $'
                                        ; DATA XREF: error_line+2↑o
OnOff           db 'ON'                 ; DATA XREF: set_numlock:not_off↑r
OnOff2          db 'OFF'                ; DATA XREF: set_numlock+F↑r
StartMsg        db 'Starting PC DOS...',0Dh,0Ah
                                        ; DATA XREF: BIOSDATA:1D7F↑o
                db 0Ah,0
_$PauseMsg      db 'Press any key to continue...',0Dh,0Ah,'$'
                                        ; DATA XREF: print_error+15↑o
_$CleanMsg      db 'PC DOS is bypassing your CONFIG.SYS and AUTOEXEC.BAT files.',0Dh,0Ah
                                        ; DATA XREF: kbd_read:kbd_cfg_bypass↑o
                db '$'
_$InterMsg      db 'PC DOS will prompt you to confirm each CONFIG.SYS command.',0Dh,0Ah
                                        ; DATA XREF: kbd_read:kbd_cfg_confirm↑o
                db '$'
_$MenuHeader    db 0Dh,0Ah              ; DATA XREF: menu_check+1F0↑o
                db '  PC DOS 7.1 Startup Menu',0Dh,0Ah
                db '  '
                db 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh ; '═' ; ASCII code 205
                db 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh
                db 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh
                db 0Dh,0Ah
                db  24h ; $
_$MenuPrmpt     db '  Enter a choice: $'
                                        ; DATA XREF: menu_check+238↑o
_$StatusLine    db 'F5=Bypass startup files F8=Confirm each line of CONFIG.SYS and AU'
                                        ; DATA XREF: menu_check+20B↑o
                db 'TOEXEC.BAT [ ]$'
_$InterPrmpt    db ' [Y,N,ESC]?$'       ; DATA XREF: query_user:prompt_user↑o
_$YES           db 'YES$'               ; DATA XREF: show_status+31↑r
                                        ; query_user+9E↑r ...
_$NO            db 'NO $'               ; DATA XREF: show_status+27↑r
                                        ; query_user+8C↑r ...
_$TimeOut       db 'Time remaining: $'  ; DATA XREF: select_item+42↑o
badcomprmpt     db 'Enter correct name of Command Interpreter (for example, C:\COMMAN'
                                        ; DATA XREF: SYSINIT:0A3A↑o
                db 'D.COM)',0Dh,0Ah,'$'
_$AutoPrmpt     db 'Process AUTOEXEC.BAT [Y,N]?$'
                                        ; DATA XREF: query_user+24↑o
TooManyDrivesMsg db 'WARNING! Logical drives past Z: exist and will be ignored',0Dh,0Ah
                                        ; DATA XREF: SYSINIT:071D↑o
                db '$'
baddblspace     db 'Required system component is not installed',0Dh,0Ah
                                        ; DATA XREF: MagicPreload+7D↑o
                db '$',0
                db 7 dup(0)
SYSINIT         ends


                end
