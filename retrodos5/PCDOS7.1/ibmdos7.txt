     1                                  ;*****************************************************************************
     2                                  ; IBMDOS7.S (PCDOS 7.1 Kernel) - RETRO DOS v5.0 by ERDOGAN TAN - 01/01/2024
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 04/02/2024 - Retro DOS v5.0 (Modified PCDOS 7.1)
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 22/04/2019 (Retro DOS 4.0), 03/11/2022 (Retro DOS 4.2)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.15
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	   ((nasm ibmdos7.s -l ibmdos7.txt -o IBMDOS.COM -Z error.txt))
    11                                  ;					   -o IBMDOS7.BIN
    12                                  ;*****************************************************************************
    13                                  ; main file: 'retrodos5.s'
    14                                  ; incbin 'IBMDOS7.BIN'
    15                                  ;=============================================================================
    16                                  ; Modified from 'msdos6.s' (modified MSDOS 6.21 kernel src as Retro DOS v4.2)
    17                                  ; 29/09/2023 /// Retro DOS v4.2 (2023) -> Modified MSDOS 6.22 IO.SYS+MSDOS.SYS
    18                                  ;=============================================================================
    19                                  
    20                                  ; 30/12/2022 - Retro DOS v4.2 Kernel ('msdos6.s')
    21                                  ; Modified from 'msdos5.s' (29/12/2022, Retro DOS v4.1 Kernel) file
    22                                  ; as below:
    23                                  ;	1) MS-DOS version has been changed to 6.22 (It was 5.0) 
    24                                  ;	2) Retro DOS version has been changed to 4.2 (It was 4.1)
    25                                  ; (The content has not been changed except kernel version because the kernel
    26                                  ;  code is already compatible with MSDOS 6.x and it is optimized before.)
    27                                  ;	(But IO.SYS part of the kernel is not same with Retro DOS v4.1 code.)
    28                                  
    29                                  ; ----------------------------------------------------------------------------
    30                                  
    31                                  ; 03/11/2022 - Erdogan Tan (Istanbul)
    32                                  
    33                                  ; Note:	This code is a part of Retro DOS 4.0 kernel source code
    34                                  ;	(as included binary, 'MSDOS5.BIN') 
    35                                  ;	Equivalent of MSDOS 5.0 MSDOS.SYS kernel file 
    36                                  ;	
    37                                  ;	((MSDOS 6.0 kernel source code has been modified by using disassembled
    38                                  ;	MSDOS 5.0 MSDOS.SYS)) -- Disassembler: HEX-RAYS IDA Pro --
    39                                  ;	((Disassembly -Reverse engineering- reference: MSDOS 6.0 kernel src))
    40                                        
    41                                  ;------ Retro DOS v2 (v3) boot sector loads RETRODOS.SYS (MSDOS.SYS)
    42                                  ;	at 1000h:0000h and loader (initialization) part of RETRODOS kernel
    43                                  ;	moves IO.SYS (DOSBIOSCODE & DOSBIOSDATA, 'IOSYS5.BIN') to 70h:0000h.
    44                                  ;	Then SYSINIT code to the next segment (4D6h for current version)..
    45                                  ;	SYSINIT code relocates itself and DOSBIOSCODE and MSDOS.SYS
    46                                  ;	(MSDOS5.BIN) according to request/setting in 'config.sys' file.
    47                                  
    48                                  ; ----------------------------------------------------------------------------
    49                                  
    50                                  ; 01/01/2024 - Retro DOS v5.0 Kernel ('ibmdos7.s')
    51                                  ; Modified from 'msdos6.s' (29/09/2023, Retro DOS v4.2 kernel: MSDOS.SYS) file
    52                                  ; as below:
    53                                  ;
    54                                  ;    1) Retro DOS v5.0 IBMDOS.COM is based on disassembled source code
    55                                  ;	of PCDOS 7.1 IBMDOS.COM (2003) and it is derived using Retro DOS v4.2
    56                                  ;	MSDOS.SYS source code. Retro DOS v5.0 (IBMDOS.COM) kernel source code
    57                                  ;	is modified (and optimized) and so, it is not same with the original
    58                                  ;	PCDOS 7.1 IBMDOS.COM.
    59                                  ;
    60                                  ;    2) Retro DOS v4.2 MSDOS.SYS is based on disassembled source code
    61                                  ;	of MSDOS 6.21 MSDOS.SYS, derived using MSDOS 6.0 source code.
    62                                  ;	(And then it has been verified and updated by comparing it with
    63                                  ;	the disassembled source code of MSDOS 6.22 kernel file MSDOS.SYS.)
    64                                  ;
    65                                  ;    3) Labels, names, comments, explanations and structure definitions
    66                                  ;	about procedures and code details are almost entirely taken from
    67                                  ;	the original MSDOS 6.0 source code, except for the details that
    68                                  ;	Erdogan Tan personally experienced. Some of them are incompatible
    69                                  ;	with PCDOS 7.1 code. But they have not been deleted to preserve
    70                                  ;	the originality of the descriptions.)
    71                                  ;
    72                                  ; ('msdos6.s' has been converted to 'ibmdos7.s' and 'retrodos42.s' has been
    73                                  ; converted to 'retrodos5.s'. 'ibmdos7.s' is IBMDOS.COM source code file
    74                                  ; while 'retrodos5.s' is source code of Retro DOS v5 kernel file 'PCDOS.SYS'.
    75                                  ; 'retrodos5.s' includes 'ibmdos7.bin' or IBMDOS.COM as binary file.)
    76                                  		
    77                                  ; ----------------------------------------------------------------------------
    78                                  
    79                                  ;=============================================================================
    80                                  ; Most of comments in this file are from the original MSDOS 6.0 source code
    81                                  ;-----------------------------------------------------------------------------
    82                                  
    83                                  ; MSDOS 6.0 Kernel source files:
    84                                  ;	MSDATA.ASM, 
    85                                  ; 		(MSHEAD.ASM, MSCONST.ASM,CONST2.ASM, MS_DATA.ASM,
    86                                  ;		DOSTAB.ASM, LMSTUB.ASM, WPATCH.INC, MPATCH.ASM)
    87                                  ;	MSTABLE.ASM, MSCODE.ASM, MSDOSME.ASM (DOSMES.INC), TIME.ASM,
    88                                  ;	GETSET.ASM, PARSE.ASM, MISC.ASM, MISC2.ASM, CRIT.ASM, CPMIO.ASM,
    89                                  ;	CPMIO2.ASM, FCBIO.ASM, FCBIO2.ASM, SEARCH.ASM, PATH.ASM, IOCTL.ASM,
    90                                  ;	DELETE.ASM, RENAME.ASM, FINFO.ASM, DUP.ASM, CREATE.ASM, OPEN.ASM,
    91                                  ;	DINFO.ASM, ISEARCH.ASM, BUF.ASM, ABORT.ASM,CLOSE.ASM, DIRCALL.ASM,
    92                                  ;	DISK.ASM, DISK2.ASM, DISK3.ASM, DIR.ASM, DIR2.ASM, DEV.ASM,
    93                                  ;	MKNODE.ASM, ROM.ASM, FCB.ASM, MSCTRLC.ASM, FAT.ASM, MSPROC.ASM
    94                                  ;	ALLOC.ASM, SRVCALL.ASM, UTIL.ASM, MACRO.ASM, MACRO2.ASM, HANDLE.ASM
    95                                  ;	FILE.ASM, LOCK.ASM, ROMFIND.ASM, SHARE.ASM, MSINIT.ASM, ORIGIN.ASM
    96                                  ;
    97                                  ; MSDOS 2.0 Kernel source files:
    98                                  ; 	MSDOS.ASM (STDSW.ASM + MSHEAD.ASM + MSDATA.ASM)
    99                                  ;	MSCODE.ASM
   100                                  ;	DOSMES.ASM ... STDIO.ASM, TIME.ASM, XENIX.ASM, XENIX2.ASM
   101                                  
   102                                  ;============================================================================
   103                                  ; DOSLINK
   104                                  ;============================================================================
   105                                  ;msdos mscode dosmes misc getset dircall alloc dev dir +
   106                                  ;disk fat rom stdbuf stdcall stdctrlc stdfcb stdproc +
   107                                  ;stdio time xenix xenix2
   108                                  
   109                                  ;============================================================================
   110                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
   111                                  ; output in TASM syntax (July 2018 -> NASM syntax) [ IBMDOS.COM, 17/03/1987 ]
   112                                  ;============================================================================
   113                                  ;
   114                                  ; ###########################################################################
   115                                  ; #	This file is generated by The Interactive Disassembler (IDA)	    #
   116                                  ; #	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    #
   117                                  ; #			 Licensed to: Freeware version			    #
   118                                  ; ###########################################################################
   119                                  ;
   120                                  ; Input	MD5   :	75959BC417C19135B982F7959EE9C92A
   121                                  
   122                                  ; ---------------------------------------------------------------------------
   123                                  ; File Name   :	C:\Documents and Settings\Erdoðan Tan\Desktop\MSDOS621.BIN
   124                                  ; Format      :	Binary file
   125                                  ;============================================================================
   126                                  ; MSDOS621.BIN = MSDOS.SYS, 13/02/1994, 38138 bytes (MSDOS 6.21 kernel) 2019
   127                                  ;----------------------------------------------------------------------------
   128                                  ; MSDOS5.BIN = MSDOS.SYS, 11/11/1991, 37394 bytes (MSDOS 5.0 kernel) 2022
   129                                  
   130                                  ;============================================================================
   131                                  ; MSDOS.ASM
   132                                  ;============================================================================
   133                                  
   134                                  ;TITLE   Standard MSDOS
   135                                  ;NAME    MSDOS_2
   136                                  
   137                                  ; Number of disk I/O buffers
   138                                  
   139                                  ;	INCLUDE STDSW.ASM
   140                                  ;       INCLUDE MSHEAD.ASM
   141                                  ;       INCLUDE MSDATA.ASM
   142                                  
   143                                  ;	END
   144                                  
   145                                  ;============================================================================
   146                                  ; STDSW.ASM
   147                                  ;============================================================================
   148                                  
   149                                  TRUE    EQU     0FFFFH
   150                                  FALSE   EQU     ~TRUE ; NOT TRUE
   151                                  
   152                                  ; Use the switches below to produce the standard Microsoft version or the IBM
   153                                  ; version of the operating system
   154                                  ;MSVER   EQU	false
   155                                  ;IBM     EQU	true
   156                                  ;WANG    EQU	FALSE
   157                                  ;ALTVECT EQU	FALSE
   158                                  
   159                                  ; Set this switch to cause DOS to move itself to the end of memory
   160                                  ;HIGHMEM EQU     FALSE
   161                                  
   162                                  ;	IF      IBM
   163                                  ESCCH    EQU	 0			;character to begin escape seq.
   164                                  CANCEL   EQU	 27			;Cancel with escape
   165                                  TOGLINS  EQU	TRUE			;One key toggles insert mode
   166                                  TOGLPRN  EQU	TRUE			;One key toggles printer echo
   167                                  ZEROEXT  EQU	TRUE
   168                                  ;       ELSE
   169                                  ;       IF      WANG			;Are we assembling for WANG?
   170                                  ;ESCCH	 EQU	1FH			;Yes. Use 1FH for escape character
   171                                  ;       ELSE
   172                                  ;ESCCH	 EQU	1BH
   173                                  ;       ENDIF
   174                                  ;CANCEL  EQU	"X"-"@"			;Cancel with Ctrl-X
   175                                  ;TOGLINS EQU	WANG			;Separate keys for insert mode on
   176                                  					;and off if not WANG
   177                                  ;TOGLPRN EQU	FALSE			;Separate keys for printer echo on
   178                                  					;and off
   179                                  ;ZEROEXT EQU	TRUE
   180                                  ;        ENDIF
   181                                  
   182                                  ;============================================================================
   183                                  ; MSHEAD.ASM
   184                                  ;============================================================================
   185                                  
   186                                  ;--------------------------------------------------------------
   187                                  ; TITLE   MSHEAD.ASM -- MS-DOS DEFINITIONS
   188                                  ;--------------------------------------------------------------
   189                                  
   190                                  ; MS-DOS High-performance operating system for the 8086  version 1.28
   191                                  ;        by Microsoft MSDOS development group:
   192                                  ;           Tim Paterson (Ret.)
   193                                  ;           Aaron Reynolds
   194                                  ;           Nancy Panners (Parenting)
   195                                  ;           Mark Zbikowski
   196                                  ;           Chris Peters (BIOS) (ret.)
   197                                  
   198                                  ; ****************** Revision History *************************
   199                                  ;          >> EVERY change must noted below!! <<
   200                                  ;
   201                                  ; 0.34 12/29/80 General release, updating all past customers
   202                                  ; 0.42 02/25/81 32-byte directory entries added
   203                                  ; 0.56 03/23/81 Variable record and sector sizes
   204                                  ; 0.60 03/27/81 Ctrl-C exit changes, including register save on user stack
   205                                  ; 0.74 04/15/81 Recognize I/O devices with file names
   206                                  ; 0.75 04/17/81 Improve and correct buffer handling
   207                                  ; 0.76 04/23/81 Correct directory size when not 2^N entries
   208                                  ; 0.80 04/27/81 Add console input without echo, Functions 7 & 8
   209                                  ; 1.00 04/28/81 Renumber for general release
   210                                  ; 1.01 05/12/81 Fix bug in `STORE'
   211                                  ; 1.10 07/21/81 Fatal error trapping, NUL device, hidden files, date & time,
   212                                  ;               RENAME fix, general cleanup
   213                                  ; 1.11 09/03/81 Don't set CURRENT BLOCK to 0 on open; fix SET FILE SIZE
   214                                  ; 1.12 10/09/81 Zero high half of CURRENT BLOCK after all (CP/M programs don't)
   215                                  ; 1.13 10/29/81 Fix classic "no write-through" error in buffer handling
   216                                  ; 1.20 12/31/81 Add time to FCB; separate FAT from DPT; Kill SMALLDIR; Add
   217                                  ;               FLUSH and MAPDEV calls; allow disk mapping in DSKCHG; Lots
   218                                  ;               of smaller improvements
   219                                  ; 1.21 01/06/82 HIGHMEM switch to run DOS in high memory
   220                                  ; 1.22 01/12/82 Add VERIFY system call to enable/disable verify after write
   221                                  ; 1.23 02/11/82 Add defaulting to parser; use variable escape character Don't
   222                                  ;               zero extent field in IBM version (back to 1.01!)
   223                                  ; 1.24 03/01/82 Restore fcn. 27 to 1.0 level; add fcn. 28
   224                                  ; 1.25 03/03/82 Put marker (00) at end of directory to speed searches
   225                                  ; 1.26 03/03/82 Directory buffers searched as a circular queue, current buffer
   226                                  ;               is searched first when possible to minimize I/O
   227                                  ;      03/03/82 STORE routine optimized to tack on partial sector tail as
   228                                  ;               full sector write when file is growing
   229                                  ;      03/09/82 Multiple I/O buffers
   230                                  ;      03/29/82 Two bugs:  Delete all case resets search to start at beginning
   231                                  ;               of directory (infinite loop possible otherwise), DSKRESET
   232                                  ;               must invalidate all buffers (disk and directory).
   233                                  ; 1.27 03/31/82 Installable device drivers
   234                                  ;                 Function call 47 - Get pointer to device table list
   235                                  ;                 Function call 48 - Assign CON AUX LIST
   236                                  ;      04/01/82 Spooler interrupt (INT 28) added.
   237                                  ; 1.28 04/15/82 DOS retructured to use ASSUMEs and PROC labels around system
   238                                  ;               call entries.  Most CS relative references changed to SS
   239                                  ;               relative with an eye toward putting a portion of the DOS in
   240                                  ;               ROM.  DOS source also broken into header, data and code pieces
   241                                  ;      04/15/82 GETDMA and GETVECT calls added as 24 and 32.  These calls
   242                                  ;               return the current values.
   243                                  ;      04/15/82 INDOS flag implemented for interrupt processing along with
   244                                  ;               call to return flag location (call 29)
   245                                  ;      04/15/82 Volume ID attribute added
   246                                  ;      04/17/82 Changed ABORT return to user to a long ret from a long jump to
   247                                  ;               avoid a CS relative reference.
   248                                  ;      04/17/82 Put call to STATCHK in dispatcher to catch ^C more often
   249                                  ;      04/20/82 Added INT int_upooler into loop ^S wait
   250                                  ;      04/22/82 Dynamic disk I/O buffer allocation and call to manage them
   251                                  ;               call 49.
   252                                  ;      04/23/82 Added GETDSKPTDL as call 50, similar to GETFATPT(DL), returns
   253                                  ;               address of DPB
   254                                  ;      04/29/82 Mod to WRTDEV to look for ^C or ^S at console input when
   255                                  ;               writting to console device via file I/O.  Added a console
   256                                  ;               output attribute to devices.
   257                                  ;      04/30/82 Call to en/dis able ^C check in dispatcher Call 51
   258                                  ;      04/30/82 Code to allow assignment of func 1-12 to disk files as well
   259                                  ;               as devices....  pipes, redirection now possible
   260                                  ;      04/30/82 Expanded GETLIST call to 2.0 standard
   261                                  ;      05/04/82 Change to INT int_fatal_abort callout int HARDERR.  DOS SS
   262                                  ;               (data segment) stashed in ES, INT int_fatal_abort routines must
   263                                  ;               preserve ES.  This mod so HARDERR can be ROMed.
   264                                  ; 1.29 06/01/82 Installable block and character devices as per 2.0 spec
   265                                  ;      06/04/82 Fixed Bug in CLOSE regarding call to CHKFATWRT.  It got left
   266                                  ;               out back about 1.27 or so (oops).  ARR
   267                                  ; 1.30 06/07/82 Directory sector buffering added to main DOS buffer queue
   268                                  ; 1.40 06/15/82 Tree structured directories.  XENIX Path Parser MKDIR CHDIR
   269                                  ;               RMDIR Xenix calls
   270                                  ; 1.41 06/13/82 Made GETBUFFR call PLACEBUF
   271                                  ; 1.50 06/17/82 FATs cached in buffer pool, get FAT pointer calls disappear
   272                                  ;               Frees up lots of memory.
   273                                  ; 1.51 06/24/82 BREAKDOWN modified to do EXACT one sector read/write through
   274                                  ;               system buffers
   275                                  ; 1.52 06/30/82 OPEN, CLOSE, READ, WRITE, DUP, DUP2, LSEEK implemented
   276                                  ; 1.53 07/01/82 OPEN CLOSE mod for Xenix calls, saves and gets remote dir
   277                                  ; 1.54 07/11/82 Function calls 1-12 make use of new 2.0 PDB. Init code
   278                                  ;               changed to set file handle environment.
   279                                  ; 2.00 08/01/82 Number for IBM release
   280                                  ;      01/19/83 No environ bug in EXEC
   281                                  ;      01/19/83 MS-DOS OEM INT 21 extensions (SET_OEM_HANDLER)
   282                                  ;      01/19/83 Performance bug fix in cooked write to NUL
   283                                  ;      01/27/83 Growcnt fixed for 32-bits
   284                                  ;      01/27/83 Find-first problem after create
   285                                  ; 2.01 02/17/83 International DOS
   286                                  ; 2.11 08/12/83 Dos split into several more modules for assembly on
   287                                  ;               an IBM PC
   288                                  ; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
   289                                  ; (MSHEAD.ASM, MSDOS 6.0, 1991) - mshead.asm 1.1 85/04/10 -
   290                                  ; 2.10 03/09/83 Start of NETWORK support
   291                                  ;		New Buffer structure
   292                                  ;		New Sytem file table structure
   293                                  ;		FCB moved to internal representation
   294                                  ;		DOS re-organized
   295                                  ; 2.11 04/21/83 Continuation of 2.10, preliminary Network
   296                                  ;		device interface.
   297                                  ; 2.11 08/12/83 Dos split into several more modules for assembly on
   298                                  ;               an IBM PC
   299                                  ; 2.50 09/12/83 More network stuff
   300                                  ;
   301                                  ; *************************************************************
   302                                  
   303                                  ; ----------------------------------------------------------------------------
   304                                  ; EQUATES
   305                                  
   306                                  ; Interrupt Entry Points:
   307                                  
   308                                  ; INTBASE:      ABORT
   309                                  ; INTBASE+4:    COMMAND
   310                                  ; INTBASE+8:    BASE EXIT ADDRESS
   311                                  ; INTBASE+C:    CONTROL-C ABORT
   312                                  ; INTBASE+10H:  FATAL ERROR ABORT
   313                                  ; INTBASE+14H:  BIOS DISK READ
   314                                  ; INTBASE+18H:  BIOS DISK WRITE
   315                                  ; INTBASE+1CH:  END BUT STAY RESIDENT (NOT SET BY DOS)
   316                                  ; INTBASE+20H:  SPOOLER INTERRUPT
   317                                  ; INTBASE+40H:  Long jump to CALL entry point
   318                                  
   319                                  ENTRYPOINTSEG   EQU     0Ch
   320                                  MAXDIF          EQU     0FFFh
   321                                  SAVEXIT         EQU     10
   322                                  ; 06/05/2019
   323                                  WRAPOFFSET	EQU	0FEF0h  ; (MISC.ASM, MSDOS 6.0, 1991)
   324                                  
   325                                         ; INCLUDE DOSSYM.ASM
   326                                         ; INCLUDE DEVSYM.ASM
   327                                  
   328                                  ; SUBTTL ^C, terminate/abort/exit and Hard error actions
   329                                  ; PAGE
   330                                  ; There are three kinds of context resets that can occur during normal DOS
   331                                  ; functioning:  ^C trap, terminate/abort/exit, and Hard-disk error.  These must
   332                                  ; be handles in a clean fashion that allows nested executions along with the
   333                                  ; ability to trap one's own errors.
   334                                  ;
   335                                  ; ^C trap - A process may elect to catch his own ^Cs.  This is achieved by
   336                                  ;           using the $GET_INTERRUPT_VECTOR and $SET_INTERRUPT_VECTOR as
   337                                  ;           follows:
   338                                  ;
   339                                  ;           $GET_INTERRUPT_VECTOR for INT int_ctrl_c
   340                                  ;           Save it in static memory.
   341                                  ;           $SET_INTERRUPT_VECTOR for INT int_ctrl_c
   342                                  ;
   343                                  ;           The interrupt service routine must preserve all registers and
   344                                  ;           return carry set iff the operation is to be aborted (via abort
   345                                  ;           system call), otherwise, carry is reset and the operation is
   346                                  ;           restarted.  ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE
   347                                  ;           RESULTS.
   348                                  ;
   349                                  ;           To restore original ^C processing (done on terminate/abort/exit),
   350                                  ;           restore INT int_ctrl_c from the saved vector.
   351                                  ;
   352                                  ; Hard-disk error -- The interrupt service routine for INT int_fatal_abort must
   353                                  ;           also preserve registers and return one of three values in AL: 0 and
   354                                  ;           1 imply retry and ignore (???)  and 2 indicates an abort.  The user
   355                                  ;           himself is not to issue the abort, rather, the dos will do it for
   356                                  ;           him by simulating a normal abort/exit system call.  ANY DEVIATION
   357                                  ;           FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
   358                                  ;
   359                                  ; terminate/abort/exit -- The user may not, under any circumstances trap an
   360                                  ;           abort call.  This is reserved for knowledgeable system programs.
   361                                  ;           ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
   362                                  
   363                                  ;SUBTTL SEGMENT DECLARATIONS
   364                                  
   365                                  ; The following are all of the segments used.  They are declared in the order
   366                                  ; that they should be placed in the executable
   367                                  
   368                                  ;
   369                                  ; segment ordering for MSDOS
   370                                  ;
   371                                  
   372                                  ;START           SEGMENT BYTE PUBLIC 'START'
   373                                  ;START           ENDS
   374                                  
   375                                  ;CONSTANTS       SEGMENT BYTE PUBLIC 'CONST'
   376                                  ;CONSTANTS       ENDS
   377                                  
   378                                  ;DATA            SEGMENT WORD PUBLIC 'DATA'
   379                                  ;DATA            ENDS
   380                                  
   381                                  ;CODE            SEGMENT BYTE PUBLIC 'CODE'
   382                                  ;CODE            ENDS
   383                                  
   384                                  ;LAST            SEGMENT BYTE PUBLIC 'LAST'
   385                                  ;LAST            ENDS
   386                                  
   387                                  ;DOSGROUP    GROUP   CODE,CONSTANTS,DATA,LAST
   388                                  
   389                                  ; The following segment is defined such that the data/const classes appear
   390                                  ; before the code class for ROMification
   391                                  
   392                                  ;START		SEGMENT BYTE PUBLIC 'START'
   393                                  ;           	ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
   394                                  ;		JMP     DOSINIT
   395                                  ;START		ENDS
   396                                  
   397                                  ;============================================================================
   398                                  ; BPB.INC, MSDOS 6.0, 1991
   399                                  ;============================================================================
   400                                  ; 09/07/2018 - Retro DOS v3.0
   401                                  
   402                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   403                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   404                                  ;									   ;
   405                                  
   406                                  ;**	BIOS PARAMETER BLOCK DEFINITION
   407                                  ;
   408                                  ;	The BPB contains information about the disk structure. It dates
   409                                  ;	back to the earliest FAT systems and so FAT information is
   410                                  ;	intermingled with physical driver information.
   411                                  ;
   412                                  ;	A boot sector contains a BPB for its device; for other disks
   413                                  ;	the driver creates a BPB. DOS keeps copies of some of this
   414                                  ;	information in the DPB.
   415                                  ;
   416                                  ;	The BDS structure contains a BPB within it. 
   417                                  
   418                                  ; 01/01/2024
   419                                  %if 0
   420                                  
   421                                  struc A_BPB
   422                                  .BPB_BYTESPERSECTOR:	resw	1
   423                                  .BPB_SECTORSPERCLUSTER:	resb	1
   424                                  .BPB_RESERVEDSECTORS:	resw	1
   425                                  .BPB_NUMBEROFFATS:	resb	1
   426                                  .BPB_ROOTENTRIES: 	resw	1
   427                                  .BPB_TOTALSECTORS:	resw	1
   428                                  .BPB_MEDIADESCRIPTOR:	resb	1
   429                                  .BPB_SECTORSPERFAT:	resw	1
   430                                  .BPB_SECTORSPERTRACK:	resw	1
   431                                  .BPB_HEADS:		resw	1
   432                                  .BPB_HIDDENSECTORS:	resw	1
   433                                  			resw	1
   434                                  .BPB_BIGTOTALSECTORS:	resw	1
   435                                  			resw	1
   436                                  			resb	6	; NOTE:  many times these
   437                                  ;					; 	 6 bytes are omitted
   438                                  ;					;	 when BPB manipulations
   439                                  ;					;	 are performed!
   440                                  .size:
   441                                  endstruc
   442                                  
   443                                  %else
   444                                  
   445                                  ; 01/01/2024 - Retro DOS v5.0	
   446                                  
   447                                  struc A_BPB
   448 00000000 ????                    .BYTESPERSECTOR:    resw 1
   449 00000002 ??                      .SECTORSPERCLUSTER: resb 1
   450 00000003 ????                    .RESERVEDSECTORS:   resw 1
   451 00000005 ??                      .NUMBEROFFATS:	    resb 1
   452 00000006 ????                    .ROOTENTRIES:	    resw 1
   453 00000008 ????                    .TOTALSECTORS:	    resw 1
   454 0000000A ??                      .MEDIADESCRIPTOR:   resb 1
   455 0000000B ????                    .SECTORSPERFAT:	    resw 1
   456 0000000D ????                    .SECTORSPERTRACK:   resw 1
   457 0000000F ????                    .HEADS:		    resw 1
   458 00000011 ????????                .HIDDENSECTORS:	    resd 1
   459 00000015 ????????                .BIGTOTALSECTORS:   resd 1
   460                                  ;............ FAT32 ......  + 28
   461 00000019 ????????                .FATSIZE32:	    resd 1
   462 0000001D ????                    .EXTFLAGS:	    resw 1
   463 0000001F ????                    .FSVER:		    resw 1
   464 00000021 ????????                .ROOTDIRCLUSTER:    resd 1
   465 00000025 ????                    .FSINFOSECTOR:	    resw 1  ; (offset from FAT32 bs)
   466 00000027 ????                    .BACKUPBOOTSECTOR:  resw 1  ; (offset from FAT32 bs)
   467 00000029 <res Ch>                .RESERVEDBYTES:	    resb 12 ; (zero bytes)
   468                                  .size:
   469                                  endstruc
   470                                  
   471                                  %endif
   472                                  
   473                                  ;                                                                          ;
   474                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   475                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   476                                  
   477                                  ;============================================================================
   478                                  ; BUFFER.INC, MSDOS 6.0, 1991
   479                                  ;============================================================================
   480                                  ; 04/05/2019 - Retro DOS v4.0
   481                                  ; 03/01/2024 - Retro DOS v5.0
   482                                  
   483                                  ; <Disk I/O Buffer Header>
   484                                  
   485                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   486                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   487                                  ;									   ;
   488                                  
   489                                  ; Field definition for I/O buffer information
   490                                  
   491                                  	; 03/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
   492                                  
   493                                  struc BUFFINFO
   494 00000000 ????                    .buf_next:	resw 1		; Pointer to next buffer in list
   495 00000002 ????                    .buf_prev:	resw 1		; Pointer to prev buffer in list
   496 00000004 ??                      .buf_ID:	resb 1		; Drive of buffer (bit 7 = 0)
   497                                  				; SFT table index (bit 7 = 1)
   498                                  				; = FFH if buffer free
   499 00000005 ??                      .buf_flags:	resb 1		; Bit 7 = 1 if Remote file buffer
   500                                  				;	= 0 if Local device buffer
   501                                  				; Bit 6 = 1 if buffer dirty
   502                                  				; Bit 5 = Reserved
   503                                  				; Bit 4 = Search bit (bit 7 = 1)
   504                                  				; Bit 3 = 1 if buffer is DATA
   505                                  				; Bit 2 = 1 if buffer is DIR
   506                                  				; Bit 1 = 1 if buffer is FAT
   507                                  				; Bit 0 = Reserved
   508 00000006 ????????                .buf_sector:	resd 1		; Sector number of buffer (flags bit 7 = 0)
   509                                  ; The next two items are often refed as a word (flags bit 7 = 0)
   510 0000000A ??                      .buf_wrtcnt:	resb 1		; For FAT sectors, # times sector written out
   511 0000000B ????                    .buf_wrtcntinc:	resw 1		; "   "     "   , # sectors between each write
   512 0000000D ????                    		resw 1 ; * ; 03/01/2024 ; PCDOS 7.1
   513                                  			   ; hw of sectors per FAT
   514 0000000F ????????                .buf_DPB:	resd 1		; Pointer to drive parameters
   515 00000013 ????                    .buf_fill:	resw 1		; How full buffer is (flags bit 7 = 1)
   516 00000015 ??                      .buf_reserved:	resb 1		; make DWORD boundary for 386
   517 00000016 ????                    		resw 1 ; * ; 03/01/2024 ; PCDOS 7.1
   518                                  			   ; reserved word for dword boundary
   519                                  .size:	; 20 bytes ; MSDOS 5.0 to 6.22
   520                                  	; 24 bytes ; PCDOS 7.1 ; 03/01/2024
   521                                  endstruc
   522                                  
   523                                  %define buf_offset	BUFFINFO.buf_sector ; 22/07/2019
   524                                  				;For buf_flags bit 7 = 1, this is the byte
   525                                  				;offset of the start of the buffer in
   526                                  				;the file pointed to by buf_ID. Thus
   527                                  				;the buffer starts at location
   528                                  				;buf_offset in the file and contains
   529                                  				;buf_fill bytes.
   530                                  
   531                                  BUFINSIZ        EQU     BUFFINFO.size
   532                                  
   533                                  buf_Free	EQU	0FFh	; buf_id of free buffer
   534                                  
   535                                  ;Flag byte masks
   536                                  buf_isnet	EQU	10000000B
   537                                  buf_dirty	EQU	01000000B
   538                                  ;***
   539                                  buf_visit	EQU	00100000B
   540                                  ;***
   541                                  buf_snbuf	EQU	00010000B
   542                                  
   543                                  buf_isDATA	EQU	00001000B
   544                                  buf_isDIR	EQU	00000100B
   545                                  buf_isFAT	EQU	00000010B
   546                                  buf_type_0	EQU	11110001B	; AND sets type to "none"
   547                                  
   548                                  buf_NetID	EQU	BUFINSIZ
   549                                  
   550                                  ;                                                                          ;
   551                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   552                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   553                                  
   554                                  ;============================================================================
   555                                  ; DOSSSYM.INC, MSDOS 6.0, 1991
   556                                  ;============================================================================
   557                                  ; 04/05/2019 - Retro DOS v4.0
   558                                  
   559                                  ; <Control character definitions>
   560                                  
   561                                  c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
   562                                  c_BS	    EQU     08h 	; ^H ASCII backspace
   563                                  c_CR	    EQU     0Dh 	; ^M ASCII carriage return
   564                                  c_LF	    EQU     0Ah 	; ^J ASCII linefeed
   565                                  c_ETB	    EQU     17h 	; ^W ASCII end of transmission
   566                                  c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
   567                                  c_ETX	    EQU     03h 	; ^C ASCII end of text
   568                                  c_HT	    EQU     09h 	; ^I ASCII tab
   569                                  
   570                                  ; <User stack inside of system call>
   571                                  ; Location of user registers relative user stack pointer
   572                                  
   573                                  struc	user_env   ; user_environ
   574 00000000 ????                    .user_AX: resw 1
   575 00000002 ????                    .user_BX: resw 1
   576 00000004 ????                    .user_CX: resw 1
   577 00000006 ????                    .user_DX: resw 1
   578 00000008 ????                    .user_SI: resw 1
   579 0000000A ????                    .user_DI: resw 1
   580 0000000C ????                    .user_BP: resw 1
   581 0000000E ????                    .user_DS: resw 1
   582 00000010 ????                    .user_ES: resw 1
   583 00000012 ????                    .user_IP: resw 1
   584 00000014 ????                    .user_CS: resw 1
   585 00000016 ????                    .user_F:  resw 1
   586                                  .size:
   587                                  endstruc
   588                                  
   589                                  ; ---- <Disk map> ----
   590                                  
   591                                  ;	MSDOS partitions the disk into 4 sections:
   592                                  ;
   593                                  ;  phys sector 0:   +-------------------+
   594                                  ;	|	    | boot/reserved	|
   595                                  ;	|	    +-------------------+
   596                                  ;	|	    |  File allocation	|
   597                                  ;	v	    |	   table(s)	|
   598                                  ;		    |  (multiple copies |
   599                                  ;		    |	  are kept)	|
   600                                  ;		    +-------------------+
   601                                  ;		    |	  Directory	|
   602                                  ;		    +-------------------+
   603                                  ;		    |	  File space	|
   604                                  ;		    +-------------------+
   605                                  ;		    |	Unaddressable	|
   606                                  ;		    |  (to end of disk) |
   607                                  ;		    +-------------------+
   608                                  ;
   609                                  ; All partition boundaries are sector boundaries. The size of the FAT is
   610                                  ; adjusted to maximize the file space addressable.
   611                                  
   612                                  ; <File allocation Table information>
   613                                  
   614                                  ; The File Allocation Table uses a 12-bit entry for each allocation unit on
   615                                  ; the disk. These entries are packed, two for every three bytes. The contents
   616                                  ; of entry number N is found by 1) multiplying N by 1.5; 2) adding the result
   617                                  ; to the base address of the Allocation Table; 3) fetching the 16-bit word
   618                                  ; at this address; 4) If N was odd (so that N*1.5 was not an integer), shift
   619                                  ; the word right four bits; 5) mask to 12 bits (AND with 0FFF hex). Entry
   620                                  ; number zero is used as an end-of-file trap in the OS and is passed to the
   621                                  ; BIOS to help determine disk format. Entry 1 is reserved for future use.
   622                                  ; The first available allocation unit is assigned entry number two, and even
   623                                  ; though it is the first, is called cluster 2. Entries greater than 0FF8H
   624                                  ; (12-bit fats) or 0FFF8H (16-bit fats) are end of file marks; entries of zero
   625                                  ; are unallocated. Otherwise, the contents of a FAT entry is the number of
   626                                  ; the next cluster in the file.
   627                                  ;
   628                                  ; Clusters with bad sectors are tagged with FF7H. Any non-zero number would
   629                                  ; do because these clusters show as allocated, but are not part of any
   630                                  ; allocation chain and thus will never be allocated to a file. A particular
   631                                  ; number is selected so that disk checking programs know what to do (ie. a
   632                                  ; cluster with entry FF7H which is not in a chain is not an error).
   633                                  
   634                                  ;**	Character Type Flags
   635                                  ;
   636                                  ;	These flags are used in a lookup table indexed by the character code.
   637                                  ;	They're used to quickly classify characters when parsing paths.
   638                                  ;	I think that these are only used to parse FCBs - jgl
   639                                  
   640                                  FCHK	equ 1	; I think this means "normal name char, no chks needed" -jgl
   641                                  FDELIM	equ 2	; is a delimiter
   642                                  FSPCHK	equ 4	; set if character is not a space or equivalent
   643                                  FFCB	equ 8	; is valid in an FCB
   644                                  
   645                                  ;** Bit definitions for DOS_FLAG
   646                                  ;
   647                                  ; Bit 0 - this is set when a $open call is made from $exec. This is used in
   648                                  ;	  $open to indicate to the redirector that this open is being made
   649                                  ;	  by an exec call.
   650                                  ;
   651                                  ; Bit 2
   652                                  ;
   653                                  ; M003, M027:
   654                                  ;
   655                                  ; The start up code of MS PASCAL 3.2 programs depend on the 1M address wrap 
   656                                  ; if they load below 64K. This is a likely possiblity in DOS 5.x with DOS in
   657                                  ; the HMA. By default DOS will turn A20 OFF before Xferring control to the
   658                                  ; user program in the case of an Exec call. The next call to DOS will turn
   659                                  ; A20 line ON. It has been observed that MS PASCAL 3.2 start up does an int
   660                                  ; 21 ah=25h call before executing the faulty code. This will turn A20 On. 
   661                                  ; In order to support this we will set Bit 2 of this flag in the DOS exec
   662                                  ; call (msproc.asm) if DOS is running in the HMA. In $set_interrupt_vector in
   663                                  ; getset.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
   664                                  ; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
   665                                  ; is non zero then A20 will be turned OFF before returning to the user. 
   666                                  ; Bit 2 will be unconditionally cleared here.
   667                                  ;
   668                                  ; M009, M027:
   669                                  ;
   670                                  ; Mace utilities MKEYRATE.COM version 1.0 copyright 1987 is an execpacked 
   671                                  ; program converted to a com file. Therefore if DOS is loaded high and if 
   672                                  ; this program is loaded below 64K it will blurt out "packed file is corrupt".
   673                                  ; This program does an int 21 ah=49h before executing the buggy execpacked
   674                                  ; code. This int21 call turns a20 on and hence the problem. In $dealloc
   675                                  ; alloc.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
   676                                  ; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
   677                                  ; is non zero then A20 will be turned OFF before returning to the user. 
   678                                  ; Bit 2 will be unconditionally cleared here.
   679                                  
   680                                  EXECOPEN	EQU	00000001b	; bit 0 of DOS_FLAG
   681                                  SUPPRESS_WINA20	EQU	00000010b	; M025
   682                                  EXECA20OFF	EQU	00000100b	; bit 2 of DOS_FLAG
   683                                  
   684                                  ;============================================================================
   685                                  ; VECTOR.INC, MSDOS 6.0, 1991
   686                                  ;============================================================================
   687                                  ; 04/05/2019 - Retro DOS v4.0
   688                                  
   689                                  ; 09/07/2018 - Retro DOS v3.0 (VECTOR.INC, MSDOS 3.3, 1987)
   690                                  
   691                                  ; <interrupt definitions>
   692                                  
   693                                  INTTAB          EQU     20H
   694                                  INTBASE         EQU     4 * INTTAB
   695                                  ENTRYPOINT      EQU     INTBASE+40H
   696                                  
   697                                  ;	IF      ALTVECT
   698                                  ;ALTTAB  EQU     0F0H
   699                                  ;ALTBASE EQU     4 * ALTTAB
   700                                  ;	ENDIF
   701                                  
   702                                  ;
   703                                  ; interrupt assignments
   704                                  ;
   705                                  ;	IF	NOT ALTVECT
   706                                  int_abort	    EQU     INTTAB	; abort process
   707                                  int_command	    EQU     int_abort+1 ; call MSDOS
   708                                  int_terminate	    EQU     int_abort+2 ; int to terminate address
   709                                  int_ctrl_c	    EQU     int_abort+3 ; ^c trapper
   710                                  int_fatal_abort     EQU     int_abort+4 ; hard disk error
   711                                  int_disk_read	    EQU     int_abort+5 ; logical sector disk read
   712                                  int_disk_write	    EQU     int_abort+6 ; logical sector disk write
   713                                  int_keep_process    EQU     int_abort+7 ; terminate program and stay
   714                                  					; resident
   715                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   716                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   717                                  ;									   ;
   718                                  int_spooler	    EQU     int_abort+8 ; spooler call
   719                                  int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
   720                                  int_IBM 	    EQU     int_abort+10; critical section maintenance
   721                                  ;									   ;
   722                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   723                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   724                                  ;	ELSE
   725                                  ;int_abort	    EQU     INTTAB	; abort process
   726                                  ;int_command	    EQU     int_abort+1 ; call MSDOS
   727                                  ;int_terminate	    EQU     ALTTAB	; int to terminate address
   728                                  ;int_ctrl_c	    EQU     int_terminate+1 ; ^c trapper
   729                                  ;int_fatal_abort    EQU     int_terminate+2 ; hard disk error
   730                                  ;int_disk_read	    EQU     int_abort+5 ; logical sector disk read
   731                                  ;int_disk_write	    EQU     int_abort+6 ; logical sector disk write
   732                                  ;int_keep_process   EQU     int_abort+7 ; terminate program and stay resident
   733                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   734                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   735                                  ;									   ;
   736                                  ;int_spooler	    EQU     int_terminate+3 ; spooler call
   737                                  ;int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
   738                                  ;									   ;
   739                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   740                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   741                                  ;	ENDIF
   742                                  
   743                                  addr_int_abort		EQU    4 * int_abort
   744                                  addr_int_command	EQU    4 * int_command
   745                                  addr_int_terminate	EQU    4 * int_terminate
   746                                  addr_int_ctrl_c 	EQU    4 * int_ctrl_c
   747                                  addr_int_fatal_abort	EQU    4 * int_fatal_abort
   748                                  addr_int_disk_read	EQU    4 * int_disk_read
   749                                  addr_int_disk_write	EQU    4 * int_disk_write
   750                                  addr_int_keep_process	EQU    4 * int_keep_process
   751                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   752                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   753                                  ;									   ;
   754                                  addr_int_spooler	EQU    4 * int_spooler
   755                                  addr_int_fastcon	EQU    4 * int_fastcon
   756                                  addr_int_ibm		EQU    4 * int_IBM
   757                                  ;									   ;
   758                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   759                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   760                                  
   761                                  ;============================================================================
   762                                  ; DIRENT.INC, MSDOS 6.0, 1991
   763                                  ;============================================================================
   764                                  ; 04/05/2019 - Retro DOS v4.0
   765                                  
   766                                  ; BREAK <Directory entry>
   767                                  
   768                                  ;
   769                                  ;       +---------------------------+
   770                                  ;       |  (12 BYTE) filename/ext   |       0       0
   771                                  ;       +---------------------------+
   772                                  ;       |     (BYTE) attributes     |       11      B
   773                                  ;       +---------------------------+
   774                                  ;       |    (10 BYTE) reserved     |       12      C
   775                                  ;       +---------------------------+
   776                                  ;       | (WORD) time of last write |       22      16
   777                                  ;       +---------------------------+
   778                                  ;       | (WORD) date of last write |       24      18
   779                                  ;       +---------------------------+
   780                                  ;       |   (WORD) First cluster    |       26      1A
   781                                  ;       +---------------------------+
   782                                  ;       |     (DWORD) file size     |       28      1C
   783                                  ;       +---------------------------+
   784                                  ;
   785                                  ;   First byte of filename  = E5 -> free directory entry
   786                                  ;                           = 00 -> end of allocated directory
   787                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   788                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   789                                  
   790                                  ; 01/01/2024
   791                                  %if 0
   792                                  
   793                                  struc dir_entry
   794                                  .dir_name:	resb 11			; file name
   795                                  .dir_attr:	resb 1			; attribute bits
   796                                  .dir_codepg:	resw 1			; code page DOS 4.00
   797                                  .dir_extcluster: resw 1			; extended attribute starting cluster
   798                                  .dir_attr2:	resb 1			; reserved
   799                                  .dir_pad:	resb 5			; reserved for expansion
   800                                  .dir_time:	resw 1			; time of last write
   801                                  .dir_date:	resw 1			; date of last write
   802                                  .dir_first:	resw 1			; first allocation unit of file
   803                                  .dir_size_l:	resw 1			; low 16 bits of file size
   804                                  .dir_size_h:	resw 1			; high 16 bits of file size
   805                                  .size:
   806                                  endstruc
   807                                  
   808                                  %else
   809                                  
   810                                  ; 01/01/2024 - Retro DOS v5.0 (*)
   811                                  
   812                                  struc dir_entry
   813 00000000 <res Bh>                .dir_name:	resb 11			; file name (short file name)
   814 0000000B ??                      .dir_attr:	resb 1			; file attributes (*)
   815 0000000C ??                      .dir_nt_res:	resb 1			; reserved for use by Windows NT. 0
   816                                  .dir_pad:	;resb 7			; (creation time, last access date
   817                                  					;  for use by Windows) 
   818                                  .dir_crttime_tenth:
   819 0000000D ??                      		resb 1
   820 0000000E ????                    .dir_crttime:	resw 1
   821 00000010 ????                    .dir_crtdate:	resw 1
   822                                  .dir_lstaccdate:
   823 00000012 ????                    		resw 1
   824 00000014 ????                    .dir_fclus_hi:	resw 1	; FAT32	fs	; high word of first cluster number
   825 00000016 ????                    .dir_time:	resw 1			; time of last write
   826 00000018 ????                    .dir_date:	resw 1			; date of last write
   827                                  .dir_fclus:				
   828 0000001A ????                    .dir_first:	resw 1			; first cluster (alloc. unit) of file
   829                                  .dir_file_size:
   830 0000001C ????                    .dir_size_l:	resw 1			; low 16 bits of file size
   831 0000001E ????                    .dir_size_h:	resw 1			; high 16 bits of file size
   832                                  .size:
   833                                  endstruc
   834                                  
   835                                  %endif
   836                                  
   837                                  attr_read_only      EQU      1h
   838                                  attr_hidden         EQU      2h
   839                                  attr_system         EQU      4h
   840                                  attr_volume_id      EQU      8h
   841                                  attr_directory      EQU     10h
   842                                  attr_archive        EQU     20h
   843                                  attr_device	    EQU     40h	; This is a VERY special bit.
   844                                  				;   NO directory entry on a disk EVER
   845                                  				;   has this bit set. It is set non-zero
   846                                  				;   when a device is found by GETPATH
   847                                  
   848                                  attr_all            EQU     attr_hidden+attr_system+attr_directory
   849                                                                          ; OR of hard attributes for FINDENTRY
   850                                  
   851                                  attr_ignore         EQU     attr_read_only+attr_archive
   852                                                                          ; ignore this(ese) attribute(s)
   853                                                                          ; during search first/next
   854                                  
   855                                  attr_changeable     EQU     attr_read_only+attr_hidden+attr_system+attr_archive
   856                                                                          ; changeable via CHMOD
   857                                  
   858                                  DIRFREE		equ	0E5h	; stored in dir_name[0] to indicate free slot
   859                                  
   860                                  ; ----------------------------------------------------------------------------
   861                                  ; 01/01/2024 - Retro DOS v5.0
   862                                  ; ref: FAT32 File System Specification v1.03 (Microsoft, December 6, 2000) (*)
   863                                  
   864                                  attr_long_name	equ attr_read_only|attr_hidden|attr_system|attr_volume_id
   865                                  attr_longname_mask equ attr_long_name|attr_directory|attr_archive
   866                                  
   867                                  ;============================================================================
   868                                  ; DPB.INC, MSDOS 6.0, 1991
   869                                  ;============================================================================
   870                                  ; 24/04/2019 - Retro DOS v4.0
   871                                  
   872                                  ; 19/07/2018 - Retro DOS v3.0 (DPB.INC, MSDOS 3.3, 1987)
   873                                  ; 07/07/2018 - Retro DOS v3.0 (DPB.INC, MSDOS 6.0, 1991)
   874                                  
   875                                  ; ---------------------------------------------------------------------------
   876                                  ;**	DPB - Drive Parameter Block
   877                                  ;
   878                                  ;	BUGBUG - this isn't authorative - it's my probably incomplete and
   879                                  ;	possibly inaccurate deductions from code study... - jgl
   880                                  ;
   881                                  ;	The DPB is DOS's main structure for describing block devices.
   882                                  ;	It contains info about the "Drive" intermingled with info about
   883                                  ;	the FAT file system which is presumably on the drive. I don't know
   884                                  ;	how those fields are used if it's not the FAT file system - BUGBUG
   885                                  ;
   886                                  ;	The DPBs are statically allocated and chained off of DPBHead.
   887                                  ;	Users scan this chain looking for a match on DPB_DRIVE.
   888                                  ;	The DPBs are built at init time from info in the SYSDEV structure.
   889                                  ; ---------------------------------------------------------------------------
   890                                  
   891                                  ; 01/01/2024
   892                                  %if 0
   893                                  
   894                                  struc	DPB
   895                                  .DRIVE:		resb 1		; Logical drive # assoc with DPB (A=0,B=1,...)
   896                                  .UNIT:		resb 1		; Driver unit number of DPB
   897                                  .SECTOR_SIZE:	resw 1		; Size of physical sector in bytes
   898                                  .CLUSTER_MASK:	resb 1		; Sectors/cluster - 1
   899                                  .CLUSTER_SHIFT:	resb 1		; Log2 of sectors/cluster
   900                                  .FIRST_FAT:	resw 1		; Starting record of FATs
   901                                  .FAT_COUNT:	resb 1		; Number of FATs for this drive
   902                                  .ROOT_ENTRIES:	resw 1		; Number of directory entries
   903                                  .FIRST_SECTOR:	resw 1		; First sector of first cluster
   904                                  .MAX_CLUSTER:	resw 1		; Number of clusters on drive + 1
   905                                  ; MSDOS 3.3
   906                                  ;.FAT_SIZE:	resb 1		; Number of records occupied by FAT
   907                                  ; MSDOS 6.0
   908                                  .FAT_SIZE:	resw 1		; Number of records occupied by FAT
   909                                  .DIR_SECTOR:	resw 1		; Starting record of directory
   910                                  .DRIVER_ADDR:	resd 1		; Pointer to driver
   911                                  .MEDIA:		resb 1		; Media byte
   912                                  .FIRST_ACCESS:	resb 1		; This is initialized to -1 to force a media
   913                                  				; check the first time this DPB is used
   914                                  .NEXT_DPB:	resd 1		; Pointer to next Drive parameter block
   915                                  .NEXT_FREE:	resw 1		; Cluster # of last allocated cluster
   916                                  .FREE_CNT:	resw 1		; Count of free clusters, -1 if unknown
   917                                  .size:
   918                                  endstruc
   919                                  
   920                                  %else
   921                                  
   922                                  ; 01/01/2024 - Retro DOS v5.0 (PCDOS 7.1)
   923                                  
   924                                  struc	DPB
   925 00000000 ??                      .DRIVE:		resb 1	; 0	; Logical drive # assoc with DPB (A=0,B=1,...)
   926 00000001 ??                      .UNIT:		resb 1	; 1	; Driver unit number of DPB
   927 00000002 ????                    .SECTOR_SIZE:	resw 1	; 2	; Size of physical sector in bytes
   928 00000004 ??                      .CLUSTER_MASK:	resb 1	; 4	; Sectors/cluster - 1
   929 00000005 ??                      .CLUSTER_SHIFT:	resb 1	; 5	; Log2 of sectors/cluster
   930 00000006 ????                    .FIRST_FAT:	resw 1	; 6	; Starting record of FATs
   931 00000008 ??                      .FAT_COUNT:	resb 1	; 8	; Number of FATs for this drive
   932 00000009 ????                    .ROOT_ENTRIES:	resw 1	; 9	; Number of directory entries
   933 0000000B ????                    .FIRST_SECTOR:	resw 1	; 11	; First sector of first cluster
   934 0000000D ????                    .MAX_CLUSTER:	resw 1	; 13	; Number of clusters on drive + 1
   935 0000000F ????                    .FAT_SIZE:	resw 1	; 15	; Number of records occupied by FAT
   936 00000011 ????                    .DIR_SECTOR:	resw 1	; 17	; Starting record of directory
   937 00000013 ????????                .DRIVER_ADDR:	resd 1  ; 19	; Pointer to driver
   938 00000017 ??                      .MEDIA:		resb 1	; 23	; Media byte
   939 00000018 ??                      .FIRST_ACCESS:	resb 1	; 24	; This is initialized to -1 to force a media
   940                                  				; check the first time this DPB is used
   941 00000019 ????????                .NEXT_DPB:	resd 1	; 25	; Pointer to next Drive parameter block
   942 0000001D ????                    .NEXT_FREE:	resw 1	; 29	; Cluster # of last allocated cluster
   943 0000001F ????                    .FREE_CNT:	resw 1	; 31	; Count of free clusters, -1 if unknown
   944                                  ; FAT32 fs ; 01/01/2024
   945                                  ; ref: https://en.wikibooks.org/wiki/
   946                                  ;      First_steps_towards_system_programming_under_MS-DOS_7/Appendix
   947                                  ;   -- A.03-1. Structure of Drive Parameters Blocks (DPB) ---
   948 00000021 ????                    .FREE_CNT_HW:	resw 1	; 33	; High word of free cluster count
   949 00000023 ????                    .EXT_FLAGS:	resw 1	; 35	; FAT32 extended flags (active FAT number)
   950 00000025 ????                    .FSINFO_SECTOR:	resw 1	; 37	; (FAT32 fs) FSINFO structure sector address
   951 00000027 ????                    .BKBOOT_SECTOR:	resw 1	; 39	; (FAT32 fs) Backup Boot Sector address
   952 00000029 ????????                .FCLUS_FSECTOR: resd 1	; 41	; The first cluster's first sector address
   953 0000002D ????????                .LAST_CLUSTER:	resd 1	; 45	; The last cluster number
   954 00000031 ????????                .FAT32_SIZE:	resd 1	; 49	; Number of FAT sectors (for FAT32 fs)	 
   955 00000035 ????????                .ROOT_CLUSTER:	resd 1	; 53	; Root directory's cluster number (FAT32 fs)
   956                                  ; 01/01/2024 - Retro DOS v5.0
   957 00000039 ????????                .FAT32_NXTFREE:	resd 1  ; 57	; The next free cluster (for FAT32 fs)
   958                                  .size:		; 61 bytes ; 01/01/2024 (PCDOS 7.1)
   959                                  endstruc
   960                                  
   961                                  
   962                                  %endif
   963                                  
   964                                  DPBSIZ  EQU     DPB.size	; Size of the structure in bytes
   965                                  
   966                                  DSKSIZ  EQU	DPB.MAX_CLUSTER	; Size of disk (temp used during init only)
   967                                  
   968                                  ;                                                                          ;
   969                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   970                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   971                                  
   972                                  ;============================================================================
   973                                  ; SF.INC, MSDOS 6.0, 1991
   974                                  ;============================================================================
   975                                  ; 25/04/2019 - Retro DOS v4.0
   976                                  ; 07/07/2018 - Retro DOS v3.0
   977                                  
   978                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   979                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   980                                  ;                                                                          ;
   981                                  
   982                                  ; ---------------------------------------------------------------------------
   983                                  ;**	SF.INC - System File Table
   984                                  ;
   985                                  ;   AN000   version 4.00   Jan. 1988
   986                                  ;   AN003   PTM 3680 --  make NAME offset the same as before (<=3.30)
   987                                  ;   AN009   PTM 3839	 reorder SFT for MS WINDOWS
   988                                  ; ---------------------------------------------------------------------------
   989                                  ;**	System File Table SuperStructure
   990                                  ;
   991                                  ;	The system file table entries are allocated in contiguous groups.
   992                                  ;	There may be more than one such groups; the SF "superstructure"
   993                                  ;	tracks the groups.
   994                                  ; ---------------------------------------------------------------------------
   995                                  
   996                                  struc	SFT
   997 00000000 ????????                .SFLink:	resd 1
   998 00000004 ????                    .SFCount:	resw 1		; number of entries
   999 00000006 ????                    .SFTable:	resw 1		; beginning of array of the following
  1000                                  .size:
  1001                                  endstruc
  1002                                  
  1003                                  ; ---------------------------------------------------------------------------
  1004                                  ;**	System file table entry
  1005                                  ;
  1006                                  ;	These are the structures which are at SFTABLE in the SF structure.
  1007                                  ; ---------------------------------------------------------------------------
  1008                                  
  1009                                  ; 01/01/2024 - Retro DOS v5.0
  1010                                  ; 25/04/2019 - Retro DOS v4.0
  1011                                  
  1012                                  struc SF_ENTRY
  1013 00000000 ????                    .sf_ref_count:	resw 1	; 0	; number of processes sharing entry
  1014                                  				;   if FCB then ref count
  1015 00000002 ????                    .sf_mode:	resw 1	; 2	; mode of access or high bit on if FCB
  1016 00000004 ??                      .sf_attr:	resb 1	; 4	; attribute of file
  1017 00000005 ????                    .sf_flags:	resw 1	; 5	;Bits 8-15
  1018                                  				; Bit 15 = 1 if remote file
  1019                                  				;	 = 0 if local file or device
  1020                                  				; Bit 14 = 1 if date/time is not to be
  1021                                  				;   set from clock at CLOSE. Set by
  1022                                  				;   FILETIMES and FCB_CLOSE. Reset by
  1023                                  				;   other reseters of the dirty bit
  1024                                  				;   (WRITE)
  1025                                  				; Bit 13 = Pipe bit (reserved)
  1026                                  				;
  1027                                  				; Bits 0-7 (old FCB_devid bits)
  1028                                  				; If remote file or local file, bit
  1029                                  				; 6=0 if dirty Device ID number, bits
  1030                                  				; 0-5 if local file.
  1031                                  				; bit 7=0 for local file, bit 7
  1032                                  				;      =1 for local I/O device
  1033                                  				; If local I/O device, bit 6=0 if EOF (input)
  1034                                  				;		Bit 5=1 if Raw mode
  1035                                  				;		Bit 0=1 if console input device
  1036                                  				;		Bit 1=1 if console output device
  1037                                  				;		Bit 2=1 if null device
  1038                                  				;		Bit 3=1 if clock device
  1039 00000007 ????????                .sf_devptr:	resd	1 ; 7	; Points to DPB if local file, points
  1040                                  				; to device header if local device,
  1041                                  				; points to net device header if
  1042                                  				; remote
  1043 0000000B ????                    .sf_firclus:	resw	1 ; 11	; First cluster of file (bit 15 = 0)
  1044 0000000D ????                    .sf_time:	resw	1 ; 13	; Time associated with file
  1045 0000000F ????                    .sf_date:	resw	1 ; 15	; Date associated with file
  1046 00000011 ????????                .sf_size:	resd 	1 ; 17	; Size associated with file
  1047 00000015 ????????                .sf_position:	resd	1 ; 21	; Read/Write pointer or LRU count for FCBs
  1048                                  
  1049                                  ; Starting here, the next 7 bytes may be used by the file system to store
  1050                                  ; an ID
  1051                                  
  1052                                  ; 09/07/2018 - Retro DOS v3.0
  1053                                  
  1054                                  ; MSDOS 3.3 SF.INC, 1987
  1055                                  ;.sf_cluspos:	resw	1	; Position of last cluster accessed
  1056                                  ;.sf_lstclus	resw	1	; Last cluster accessed
  1057                                  ;.sf_dirsec:	resw	1	; Sector number of directory sector
  1058                                  ;				; for this file
  1059                                  ;.sf_dirpos:	resb	1	; Offset of this entry in the above
  1060                                  
  1061                                  ; MSDOS 6.0, SF.INC, 1991
  1062 00000019 ????                    .sf_cluspos:	resw	1 ; 25	; Position of last cluster accessed
  1063 0000001B ????????                .sf_dirsec:	resd	1 ; 27	; Sector number of directory sector
  1064                                  				; for this file
  1065 0000001F ??                      .sf_dirpos:	resb	1 ; 31	; Offset of this entry in the above
  1066                                  
  1067                                  ; End of 7 bytes of file-system specific info.
  1068                                  
  1069 00000020 <res Bh>                .sf_name:	resb	11 ; 32	; 11 character name that is in the
  1070                                  				; directory entry. This is used by
  1071                                  				; close to detect file deleted and
  1072                                  				; disk changed errors.
  1073                                  ; SHARING INFO
  1074 0000002B ????????                .sf_chain:	resd	1 ; 43	; link to next SF
  1075 0000002F ????                    .sf_UID:	resw	1 ; 47
  1076 00000031 ????                    .sf_PID:	resw	1 ; 49	; owner process identifier (PSP segment) 
  1077 00000033 ????                    .sf_MFT:	resw	1 ; 51
  1078                                  
  1079                                  ; MSDOS 6.0, SF.INC, 1991
  1080 00000035 ????                    .sf_lstclus:	resw	1 ; 53	;AN009; Last cluster accessed
  1081 00000037 ????????                .sf_IFS_HDR:	resd	1 ; 55	; pointer to IFS drive or 0:0 for files
  1082                                  
  1083                                  .size:
  1084                                  endstruc
  1085                                  
  1086                                  ; 20/07/2018
  1087                                  ; MSDOS 3.3, SF.INC, 1987
  1088                                  %define sf_netid   SF_ENTRY.sf_cluspos    ; byte
  1089                                  %define sf_OpenAge SF_ENTRY.sf_position+2 ; word
  1090                                  %define sf_LRU	   SF_ENTRY.sf_position	  ; word
  1091                                  ; MSDOS 6.0, SF.INC, 1991
  1092                                  %define sf_fsda	     SF_ENTRY.sf_cluspos  ; byte ;DOS 4.00
  1093                                  %define sf_serial_ID SF_ENTRY.sf_firclus  ; word ;DOS 4.00
  1094                                  
  1095                                  ; 19/07/2018
  1096                                  ; MSDOS 3.3, SF.INC, 1987
  1097                                  
  1098                                  sf_default_number  EQU	5
  1099                                  
  1100                                  ; Note that we need to mark an SFT as being busy for OPEN/CREATE. This is
  1101                                  ; because an INT 24 may prevent us from 'freeing' it. We mark this as such
  1102                                  ; by placing a -1 in the ref_count field.
  1103                                  
  1104                                  sf_busy EQU -1
  1105                                  
  1106                                  ; mode mask for FCB detection
  1107                                  sf_isFCB		EQU	1000000000000000B
  1108                                  
  1109                                  ; Flag word masks
  1110                                  sf_isnet		EQU	1000000000000000B
  1111                                  sf_close_nodate 	EQU	0100000000000000B
  1112                                  sf_pipe 		EQU	0010000000000000B
  1113                                  sf_no_inherit		EQU	0001000000000000B
  1114                                  sf_net_spool		EQU	0000100000000000B
  1115                                  
  1116                                  ; 25/04/2019
  1117                                  sf_entry_size equ SF_ENTRY.size ; 59 (MSDOS 6.0)
  1118                                  
  1119                                  ; ---------------------------------------------------------------------------
  1120                                  ; Local file/device flag masks
  1121                                  ; ---------------------------------------------------------------------------
  1122                                  
  1123                                  devid_file_clean        EQU     40h     ; true if file and not written
  1124                                  devid_file_mask_drive   EQU     3Fh     ; mask for drive number
  1125                                  
  1126                                  devid_device            EQU     80h     ; true if a device
  1127                                  devid_device_EOF        EQU     40h     ; true if end of file reached
  1128                                  devid_device_raw        EQU     20h     ; true if in raw mode
  1129                                  devid_device_special    EQU     10h     ; true if special device
  1130                                  devid_device_clock      EQU     08h     ; true if clock device
  1131                                  devid_device_null       EQU     04h     ; true if null device
  1132                                  devid_device_con_out    EQU     02h     ; true if console output
  1133                                  devid_device_con_in     EQU     01h     ; true if console input
  1134                                  
  1135                                  ; ---------------------------------------------------------------------------
  1136                                  ; structure of devid field as returned by IOCTL is:
  1137                                  ;
  1138                                  ;       BIT     7   6   5   4   3   2   1   0
  1139                                  ;             |---|---|---|---|---|---|---|---|
  1140                                  ;             | I | E | R | S | I | I | I | I |
  1141                                  ;             | S | O | A | P | S | S | S | S |
  1142                                  ;             | D | F | W | E | C | N | C | C |
  1143                                  ;             | E |   |   | C | L | U | O | I |
  1144                                  ;             | V |   |   | L | K | L | T | N |
  1145                                  ;             |---|---|---|---|---|---|---|---|
  1146                                  ;       ISDEV = 1 if this channel is a device
  1147                                  ;             = 0 if this channel is a disk file
  1148                                  ;
  1149                                  ;       If ISDEV = 1
  1150                                  ;
  1151                                  ;             EOF = 0 if End Of File on input
  1152                                  ;             RAW = 1 if this device is in Raw mode
  1153                                  ;                 = 0 if this device is cooked
  1154                                  ;             ISCLK = 1 if this device is the clock device
  1155                                  ;             ISNUL = 1 if this device is the null device
  1156                                  ;             ISCOT = 1 if this device is the console output
  1157                                  ;             ISCIN = 1 if this device is the console input
  1158                                  ;
  1159                                  ;       If ISDEV = 0
  1160                                  ;             EOF = 0 if channel has been written
  1161                                  ;             Bits 0-5 are the block device number for
  1162                                  ;                 the channel (0 = A, 1 = B, ...)
  1163                                  ; ---------------------------------------------------------------------------
  1164                                  
  1165                                  devid_ISDEV     EQU     80h
  1166                                  devid_EOF       EQU     40h
  1167                                  devid_RAW       EQU     20h
  1168                                  devid_SPECIAL   EQU     10H
  1169                                  devid_ISCLK     EQU     08h
  1170                                  devid_ISNUL     EQU     04h
  1171                                  devid_ISCOT     EQU     02h
  1172                                  devid_ISCIN     EQU     01h
  1173                                  
  1174                                  devid_block_dev EQU     1Fh             ; mask for block device number
  1175                                  
  1176                                  ;============================================================================
  1177                                  ; PDB.INC, MSDOS 6.0, 1991
  1178                                  ;============================================================================
  1179                                  ; 04/05/2019 - Retro DOS v4.0
  1180                                  ; 08/07/2018 - Retro DOS v3.0
  1181                                  
  1182                                  ; ---------------------------------------------------------------------------
  1183                                  ; BREAK <Process data block>
  1184                                  ; ---------------------------------------------------------------------------
  1185                                  ;**	Process data block (otherwise known as program header)
  1186                                  ;
  1187                                  
  1188                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
  1189                                  ;	can be rearranged here, ever. Reserved areas are probably safe
  1190                                  ;	for use.
  1191                                  ; ---------------------------------------------------------------------------
  1192                                  
  1193                                  FILPERPROC	EQU     20
  1194                                  
  1195                                  struc PDB	; Process_data_block
  1196 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
  1197 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
  1198 00000004 ??                                      resb 1
  1199 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
  1200 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
  1201 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
  1202 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
  1203 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
  1204 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
  1205 0000002C ????                    .ENVIRON:	resw 1		; segment address of environment
  1206 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
  1207 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
  1208 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
  1209 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
  1210 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
  1211 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
  1212 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
  1213 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
  1214 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
  1215 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
  1216 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
  1217                                  				;  an extended FCB
  1218                                  ;endstruc 	; MSDOS 3.3
  1219                                  	  	; MSDOS 6.0
  1220 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
  1221 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
  1222 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
  1223 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
  1224                                  endstruc
  1225                                  
  1226                                  ;============================================================================
  1227                                  ; EXE.INC, MSDOS 6.0, 1991
  1228                                  ;============================================================================
  1229                                  ; 04/05/2019 - Retro DOS v4.0
  1230                                  
  1231                                  ;**	EXE.INC - Definitions for the EXEC command and EXE files
  1232                                  ; ---------------------------------------------------------------------------
  1233                                  ; The following get used as arguments to the EXEC system call.  They indicate
  1234                                  ; whether or not the program is executed or whether or not a program header
  1235                                  ; gets created.
  1236                                  
  1237                                  exec_func_no_execute EQU 1	; no execute bit
  1238                                  exec_func_overlay    EQU 2	; overlay bit
  1239                                  
  1240                                  struc EXEC0
  1241 00000000 ????                    .ENVIRON:	resw 1		; seg addr of environment
  1242 00000002 ????????                .COM_LINE:	resd 1		; pointer to asciz command line
  1243 00000006 ????????                .5C_FCB:	resd 1		; default fcb at 5C
  1244 0000000A ????????                .6C_FCB:	resd 1		; default fcb at 6C
  1245                                  .size:
  1246                                  endstruc
  1247                                  
  1248                                  struc EXEC1
  1249 00000000 ????                    .ENVIRON:	resw 1		; seg addr of environment
  1250 00000002 ????????                .COM_LINE:	resd 1		; pointer to asciz command line
  1251 00000006 ????????                .5C_FCB:	resd 1		; default fcb at 5C
  1252 0000000A ????????                .6C_FCB:	resd 1		; default fcb at 6C
  1253 0000000E ????                    .SP:		resw 1		; stack pointer of program
  1254 00000010 ????                    .SS:		resw 1		; stack seg register of program
  1255 00000012 ????                    .IP:		resw 1		; entry point IP
  1256 00000014 ????                    .CS:		resw 1		; entry point CS
  1257                                  .size:
  1258                                  endstruc
  1259                                  
  1260                                  struc EXEC3
  1261 00000000 ????                    .load_addr:	resw 1		; seg address of load point
  1262 00000002 ????                    .reloc_fac:	resw 1		; relocation factor
  1263                                  endstruc
  1264                                  
  1265                                  ;**	Exit codes (in upper byte) for terminating programs
  1266                                  
  1267                                  EXIT_TERMINATE		EQU	0
  1268                                  EXIT_ABORT		EQU	0
  1269                                  EXIT_CTRL_C		EQU	1
  1270                                  EXIT_HARD_ERROR 	EQU	2
  1271                                  EXIT_KEEP_PROCESS	EQU	3
  1272                                  
  1273                                  ;**	EXE File Header Description
  1274                                  
  1275                                  struc EXE
  1276 00000000 ????                    .signature:   resw 1		; must contain 4D5A (yay zibo!)
  1277 00000002 ????                    .len_mod_512: resw 1		; low 9 bits of length
  1278 00000004 ????                    .pages:       resw 1		; number of 512b pages in file
  1279 00000006 ????                    .rle_count:   resw 1		; count of reloc entries
  1280 00000008 ????                    .par_dir:     resw 1		; number of paragraphs before image
  1281 0000000A ????                    .min_BSS:     resw 1		; minimum number of para of BSS
  1282 0000000C ????                    .max_BSS:     resw 1		; max number of para of BSS
  1283 0000000E ????                    .SS:          resw 1		; stack of image
  1284 00000010 ????                    .SP:          resw 1		; SP of image
  1285 00000012 ????                    .chksum:      resw 1		; checksum of file (ignored)
  1286 00000014 ????                    .IP:          resw 1		; IP of entry
  1287 00000016 ????                    .CS:          resw 1		; CS of entry
  1288 00000018 ????                    .rle_table:   resw 1		; byte offset of reloc table
  1289 0000001A ????                    .iov:         resw 1		; overlay number (0 for root)
  1290 0000001C ????????                .sym_tab:     resd 1		; offset of symbol table in file
  1291                                  .size:
  1292                                  endstruc
  1293                                  
  1294                                  exe_valid_signature     EQU 5A4Dh
  1295                                  exe_valid_old_signature EQU 4D5Ah
  1296                                  
  1297                                  ;**	EXE file symbol info definitions
  1298                                  
  1299                                  struc symbol_entry
  1300 00000000 ????????                .value:	resd 1
  1301 00000004 ????                    .type:	resw 1
  1302 00000006 ??                      .len:	resb 1
  1303 00000007 <res FFh>               .name:	resb 255
  1304                                  endstruc
  1305                                  
  1306                                  ;**	Data structure passed for ExecReady call
  1307                                  
  1308                                  struc ERStruc
  1309 00000000 ????                     .ER_Reserved:	resw	1	; reserved, should be zero
  1310 00000002 ????                     .ER_Flags:	resw	1
  1311 00000004 ????????                 .ER_ProgName:	resd	1	; ptr to ASCIIZ str of prog name
  1312 00000008 ????                     .ER_PSP:	resw	1	; PSP of the program
  1313 0000000A ????????                 .ER_StartAddr:	resd	1	; Start CS:IP of the program
  1314 0000000E ????????                 .ER_ProgSize:	resd	1	; Program size including PSP
  1315                                   .size:
  1316                                  endstruc
  1317                                  
  1318                                  ;** bit fields in ER_Flags
  1319                                  
  1320                                  ER_EXE		equ	0001h
  1321                                  ER_OVERLAY	equ	0002h
  1322                                  
  1323                                  
  1324                                  ;============================================================================
  1325                                  ; ARENA.INC, MSDOS 6.0, 1991
  1326                                  ;============================================================================
  1327                                  ; 24/04/2019 - Retro DOS v4.0
  1328                                  ; 04/08/2018 - Retro DOS v3.0
  1329                                  
  1330                                  ;BREAK <Memory arena structure>
  1331                                  
  1332                                  ;**	Arena Header
  1333                                  
  1334                                  struc ARENA
  1335 00000000 ??                      .SIGNATURE:	resb 1		; 4D for valid item, 5A for last item
  1336 00000001 ????                    .OWNER:		resw 1		; owner of arena item
  1337 00000003 ????                    .SIZE:		resw 1		; size in paragraphs of item
  1338 00000005 ??????                  .RESERVED:	resb 3		; reserved
  1339 00000008 ????????????????        .NAME:		resb 8		; owner file name
  1340                                  .headersize:			
  1341                                  endstruc
  1342                                  
  1343                                  ; 20/05/2019 - Retro DOS v4.0
  1344                                  ARENAHEADERSIZE equ ARENA.headersize 
  1345                                  
  1346                                  ; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
  1347                                  ; and arena_owner_system are all equal to zero and are contained in DI.
  1348                                  ; Change them and change ALLOC.ASM.
  1349                                  
  1350                                  arena_owner_system  EQU 0               ; free block indication
  1351                                  
  1352                                  arena_signature_normal	EQU 4Dh		; valid signature, not end of arena
  1353                                  arena_signature_end     EQU 5Ah         ; valid signature, last block in arena
  1354                                  
  1355                                  FIRST_FIT	EQU	00000000B
  1356                                  BEST_FIT	EQU	00000001B
  1357                                  LAST_FIT	EQU	00000010B
  1358                                  
  1359                                  ; MSDOS 6.0
  1360                                  LOW_FIRST	EQU	00000000B	; M001
  1361                                  HIGH_FIRST	EQU	10000000B	; M001
  1362                                  HIGH_ONLY	EQU	01000000B	; M001
  1363                                  
  1364                                  LINKSTATE	EQU	00000001B	; M002
  1365                                  
  1366                                  HF_MASK		EQU	~HIGH_FIRST	; M001
  1367                                  HO_MASK		EQU	~HIGH_ONLY	; M001
  1368                                  
  1369                                  STRAT_MASK	EQU	HF_MASK & HO_MASK	; M001;
  1370                                  						; M026: used to mask of bits
  1371                                  						; M026: 6 & 7 of AllocMethod
  1372                                  
  1373                                  ;============================================================================
  1374                                  ; MI.INC, MSDOS 6.0, 1991
  1375                                  ;============================================================================
  1376                                  ; 07/07/2018 - Retro DOS v3.0
  1377                                  
  1378                                  ;BREAK <Machine instruction, flag definitions and character types>
  1379                                  
  1380                                  mi_INT		EQU	0CDh
  1381                                  mi_long_jmp	EQU	0EAh
  1382                                  mi_Long_CALL	EQU	09Ah
  1383                                  mi_Long_RET	EQU	0CBh
  1384                                  mi_Near_RET	EQU	0C3h
  1385                                  
  1386                                  ;			xxxxoditszxaxpxc
  1387                                  f_Overflow	EQU	0000100000000000B
  1388                                  f_Direction	EQU	0000010000000000B
  1389                                  f_Interrupt	EQU	0000001000000000B
  1390                                  f_Trace 	EQU	0000000100000000B
  1391                                  f_Sign		EQU	0000000010000000B
  1392                                  f_Zero		EQU	0000000001000000B
  1393                                  f_Aux		EQU	0000000000010000B
  1394                                  f_Parity	EQU	0000000000000100B
  1395                                  f_Carry 	EQU	0000000000000001B
  1396                                  
  1397                                  ;============================================================================
  1398                                  ; FILEMODE.INC, MSDOS 6.0, 1991
  1399                                  ;============================================================================
  1400                                  ; 13/07/2018 - Retro DOS v3.0
  1401                                  ; 29/04/2019 - Retro DOS v4.0
  1402                                  
  1403                                  ;**	Standard I/O file handles
  1404                                  
  1405                                  stdin       EQU     0
  1406                                  stdout      EQU     1
  1407                                  stderr      EQU     2
  1408                                  stdaux      EQU     3
  1409                                  stdprn      EQU     4
  1410                                  
  1411                                  ;**	File Modes
  1412                                  ; <Xenix subfunction assignments>  ; MSDOS 3.3 FILEMODE.INC
  1413                                  
  1414                                  open_for_read   EQU 0
  1415                                  open_for_write  EQU 1
  1416                                  open_for_both   EQU 2
  1417                                  
  1418                                  ; MSDOS 6.0
  1419                                  OPEN_FOR_BOTH	equ 2
  1420                                  EXEC_OPEN	equ 3	; access code of 3 indicates that open was 
  1421                                  				; made from exec
  1422                                  
  1423                                  access_mask	EQU 0Fh ; 09/08/2018
  1424                                  
  1425                                  SHARING_MASK	    equ 0F0h
  1426                                  SHARING_COMPAT	    equ 000h
  1427                                  SHARING_DENY_BOTH   equ 010h
  1428                                  SHARING_DENY_WRITE  equ 020h
  1429                                  SHARING_DENY_READ   equ 030h
  1430                                  SHARING_DENY_NONE   equ 040h
  1431                                  SHARING_NET_FCB     equ 070h
  1432                                  SHARING_NO_INHERIT  equ 080h
  1433                                  
  1434                                  ; 29/04/2019
  1435                                  
  1436                                  ;**	Extended Open Definitions
  1437                                  
  1438                                  RESERVED_BITS_MASK equ 0FE00h	; reserved bits for extended open flags
  1439                                  EXISTS_MASK	   equ 0Fh 	; "file exists" action field
  1440                                  NOT_EXISTS_MASK    equ 0F0h
  1441                                  
  1442                                  ;*	SF_MODE values
  1443                                  
  1444                                  AUTO_COMMIT_WRITE	equ 4000h
  1445                                  INT_24_ERROR		equ 2000h
  1446                                  
  1447                                  ;*	Flags in EXTOPEN_ON
  1448                                  
  1449                                  EXT_OPEN_ON		equ 01h
  1450                                  EXT_FILE_NOT_EXISTS	equ 04h
  1451                                  EXT_OPEN_I24_OFF	equ 02h
  1452                                  
  1453                                  ;*	Flags in EXTOPEN_FLAG
  1454                                  
  1455                                  ACTION_OPENED		equ 01h
  1456                                  ACTION_CREATED_OPENED	equ 02h
  1457                                  ACTION_REPLACED_OPENED	equ 03h
  1458                                  EXT_EXISTS_OPEN 	equ 01h
  1459                                  EXT_EXISTS_FAIL 	equ 00h
  1460                                  EXT_NEXISTS_CREATE	equ 10h
  1461                                  
  1462                                  ;**	Extended Open Structure
  1463                                  
  1464                                  struc EXT_OPEN_PARM
  1465 00000000 ????????                .SET_LIST:	resd 1
  1466 00000004 ????                    .NUM_OF_PARM:	resw 1
  1467                                  endstruc
  1468                                  
  1469                                  ;============================================================================
  1470                                  ; SYSCALL.INC, MSDOS 6.0, 1991
  1471                                  ;============================================================================
  1472                                  ; 29/04/2019 - Retro DOS v4.0
  1473                                  ; 09/07/2018 - Retro DOS v3.0 (SYSCALL.INC, MSDOS 3.3, 1987)
  1474                                  
  1475                                  ; <system call definitions>
  1476                                  
  1477                                  ABORT                           EQU 0   ;  0      0
  1478                                  STD_CON_INPUT                   EQU 1   ;  1      1
  1479                                  STD_CON_OUTPUT                  EQU 2   ;  2      2
  1480                                  STD_AUX_INPUT                   EQU 3   ;  3      3
  1481                                  STD_AUX_OUTPUT                  EQU 4   ;  4      4
  1482                                  STD_PRINTER_OUTPUT              EQU 5   ;  5      5
  1483                                  RAW_CON_IO                      EQU 6   ;  6      6
  1484                                  RAW_CON_INPUT                   EQU 7   ;  7      7
  1485                                  STD_CON_INPUT_NO_ECHO           EQU 8   ;  8      8
  1486                                  STD_CON_STRING_OUTPUT           EQU 9   ;  9      9
  1487                                  STD_CON_STRING_INPUT            EQU 10  ; 10      A
  1488                                  STD_CON_INPUT_STATUS            EQU 11  ; 11      B
  1489                                  STD_CON_INPUT_FLUSH             EQU 12  ; 12      C
  1490                                  DISK_RESET                      EQU 13  ; 13      D
  1491                                  SET_DEFAULT_DRIVE               EQU 14  ; 14      E
  1492                                  FCB_OPEN                        EQU 15  ; 15      F
  1493                                  FCB_CLOSE                       EQU 16  ; 16     10
  1494                                  DIR_SEARCH_FIRST                EQU 17  ; 17     11
  1495                                  DIR_SEARCH_NEXT                 EQU 18  ; 18     12
  1496                                  FCB_DELETE                      EQU 19  ; 19     13
  1497                                  FCB_SEQ_READ                    EQU 20  ; 20     14
  1498                                  FCB_SEQ_WRITE                   EQU 21  ; 21     15
  1499                                  FCB_CREATE                      EQU 22  ; 22     16
  1500                                  FCB_RENAME                      EQU 23  ; 23     17
  1501                                  GET_DEFAULT_DRIVE               EQU 25  ; 25     19
  1502                                  SET_DMA                         EQU 26  ; 26     1A
  1503                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1504                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1505                                  ;                                                                          ;
  1506                                  GET_DEFAULT_DPB                 EQU 31  ; 31     1F
  1507                                  ;                                                                          ;
  1508                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1509                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1510                                  FCB_RANDOM_READ                 EQU 33  ; 33     21
  1511                                  FCB_RANDOM_WRITE                EQU 34  ; 34     22
  1512                                  GET_FCB_FILE_LENGTH             EQU 35  ; 35     23
  1513                                  GET_FCB_POSITION                EQU 36  ; 36     24
  1514                                  SET_INTERRUPT_VECTOR            EQU 37  ; 37     25
  1515                                  CREATE_PROCESS_DATA_BLOCK       EQU 38  ; 38     26
  1516                                  FCB_RANDOM_READ_BLOCK           EQU 39  ; 39     27
  1517                                  FCB_RANDOM_WRITE_BLOCK          EQU 40  ; 40     28
  1518                                  PARSE_FILE_DESCRIPTOR           EQU 41  ; 41     29
  1519                                  GET_DATE                        EQU 42  ; 42     2A
  1520                                  SET_DATE                        EQU 43  ; 43     2B
  1521                                  GET_TIME                        EQU 44  ; 44     2C
  1522                                  SET_TIME                        EQU 45  ; 45     2D
  1523                                  SET_VERIFY_ON_WRITE             EQU 46  ; 46     2E
  1524                                  ; Extended functionality group
  1525                                  GET_DMA                         EQU 47  ; 47     2F
  1526                                  GET_VERSION                     EQU 48  ; 48     30
  1527                                  KEEP_PROCESS                    EQU 49  ; 49     31
  1528                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1529                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1530                                  ;                                                                          ;
  1531                                  GET_DPB                         EQU 50  ; 50     32
  1532                                  ;                                                                          ;
  1533                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1534                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1535                                  SET_CTRL_C_TRAPPING             EQU 51  ; 51     33
  1536                                  GET_INDOS_FLAG                  EQU 52  ; 52     34
  1537                                  GET_INTERRUPT_VECTOR            EQU 53  ; 53     35
  1538                                  GET_DRIVE_FREESPACE             EQU 54  ; 54     36
  1539                                  CHAR_OPER                       EQU 55  ; 55     37
  1540                                  INTERNATIONAL                   EQU 56  ; 56     38
  1541                                  ; XENIX CALLS
  1542                                  ;   Directory Group
  1543                                  MKDIR                           EQU 57  ; 57     39
  1544                                  RMDIR                           EQU 58  ; 58     3A
  1545                                  CHDIR                           EQU 59  ; 59     3B
  1546                                  ;   File Group
  1547                                  CREAT                           EQU 60  ; 60     3C
  1548                                  OPEN                            EQU 61  ; 61     3D
  1549                                  CLOSE                           EQU 62  ; 62     3E
  1550                                  READ                            EQU 63  ; 63     3F
  1551                                  WRITE                           EQU 64  ; 64     40
  1552                                  UNLINK                          EQU 65  ; 65     41
  1553                                  LSEEK                           EQU 66  ; 66     42
  1554                                  CHMOD                           EQU 67  ; 67     43
  1555                                  IOCTL                           EQU 68  ; 68     44
  1556                                  XDUP                            EQU 69  ; 69     45
  1557                                  XDUP2                           EQU 70  ; 70     46
  1558                                  CURRENT_DIR                     EQU 71  ; 71     47
  1559                                  ;    Memory Group
  1560                                  ALLOC                           EQU 72  ; 72     48
  1561                                  DEALLOC                         EQU 73  ; 73     49
  1562                                  SETBLOCK                        EQU 74  ; 74     4A
  1563                                  ;    Process Group
  1564                                  EXEC                            EQU 75  ; 75     4B
  1565                                  EXIT                            EQU 76  ; 76     4C
  1566                                  _WAIT				EQU 77  ; 77     4D
  1567                                  FIND_FIRST                      EQU 78  ; 78     4E
  1568                                  ;   Special Group
  1569                                  FIND_NEXT                       EQU 79  ; 79     4F
  1570                                  ; SPECIAL SYSTEM GROUP
  1571                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1572                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1573                                  ;                                                                          ;
  1574                                  SET_CURRENT_PDB                 EQU 80  ; 80     50
  1575                                  GET_CURRENT_PDB                 EQU 81  ; 81     51
  1576                                  GET_IN_VARS                     EQU 82  ; 82     52
  1577                                  SETDPB                          EQU 83  ; 83     53
  1578                                  ;                                                                          ;
  1579                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1580                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1581                                  GET_VERIFY_ON_WRITE             EQU 84  ; 84     54
  1582                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1583                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1584                                  ;                                                                          ;
  1585                                  DUP_PDB                         EQU 85  ; 85     55
  1586                                  ;                                                                          ;
  1587                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1588                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1589                                  RENAME                          EQU 86  ; 86     56
  1590                                  FILE_TIMES                      EQU 87  ; 87     57
  1591                                  ALLOCOPER			EQU 88	; 88	 58
  1592                                  ; Network extention system calls
  1593                                  GETEXTENDEDERROR		EQU 89	; 89	 59
  1594                                  CREATETEMPFILE			EQU 90	; 90	 5A
  1595                                  CREATENEWFILE			EQU 91	; 91	 5B
  1596                                  LOCKOPER			EQU 92	; 92	 5C Lock and Unlock
  1597                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1598                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1599                                  ;									   ;
  1600                                  SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
  1601                                  					;	    CloseByName, CloseUser,
  1602                                  					;	    CloseUserProcess,
  1603                                  					;	    GetOpenFileList
  1604                                  ;									   ;
  1605                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1606                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1607                                  USEROPER			EQU 94	; 94	 5E Get and Set
  1608                                  ASSINGOPER			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
  1609                                  XNAMETRANS			EQU 96	; 96	 60
  1610                                  PATHPARSE			EQU 97	; 97	 61
  1611                                  GETCURRENTPSP			EQU 98	; 98	 62
  1612                                  HONGEUL 			EQU 99	; 99	 63
  1613                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1614                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1615                                  ;									   ;
  1616                                  SET_PRINTER_FLAG		EQU 100 ; 100	 64
  1617                                  ;									   ;
  1618                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1619                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1620                                  GETEXTCNTRY			EQU 101 ; 101	 65 
  1621                                  GETSETCDPG			EQU 102 ; 102	 66
  1622                                  EXTHANDLE			EQU 103 ; 103	 67
  1623                                  COMMIT				EQU 104 ; 104	 68
  1624                                  
  1625                                  ; 29/04/2019 - Retro DOS v4.0
  1626                                  ; (MSDOS 6.0, SYSCALL.INC, 1987)
  1627                                  
  1628                                  GetSetMediaID			EQU 105 ; 105	 69
  1629                                  IFS_IOCTL			EQU 107 ; 107	 6B
  1630                                  ExtOpen 			EQU 108 ; 108	 6C
  1631                                  
  1632                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1633                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1634                                  ;                                                                          ;
  1635                                  ;ifdef ROMEXEC
  1636                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
  1637                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
  1638                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
  1639                                  ;endif
  1640                                  ;                                                                          ;
  1641                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1642                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1643                                  
  1644                                  SET_OEM_HANDLER			EQU 248 ; 248    F8
  1645                                  ;OEM_C1				EQU 249 ; 249    F9
  1646                                  ;OEM_C2				EQU 250 ; 250    FA
  1647                                  ;OEM_C3				EQU 251 ; 251    FB
  1648                                  ;OEM_C4				EQU 252 ; 252    FC
  1649                                  ;OEM_C5				EQU 253 ; 253    FD
  1650                                  ;OEM_C6				EQU 254 ; 254    FE
  1651                                  ;OEM_C7				EQU 255 ; 255    FF
  1652                                  
  1653                                  ; 01/01/2024 - Retro DOS v5.0 - PCDOS 7.1 IBMDOS.COM
  1654                                  ; (PCDOS 7.1 extension to MSDOS 6.22 system calls)
  1655                                   
  1656                                  ExtCountryInfo 			equ 112	; 70h
  1657                                  LONGNAME			equ 113	; 71h
  1658                                  LFNFINDCLOSE			equ 114 ; 72h
  1659                                  FAT32EXT			equ 115	; 73h
  1660                                  
  1661                                  ;============================================================================
  1662                                  ; VERSIONA.INC (MSDOS 6.0, 1991)
  1663                                  ;============================================================================
  1664                                  ; 24/04/2019 - Retro DOS 4.0
  1665                                  
  1666                                  ;MAJOR_VERSION	EQU     6
  1667                                  ;;MINOR_VERSION	EQU	00
  1668                                  ;MINOR_VERSION	EQU     21  ; MSDOS 6.21
  1669                                  
  1670                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  1671                                  ;MAJOR_VERSION	EQU     5
  1672                                  ;MINOR_VERSION	EQU     0
  1673                                  
  1674                                  ; 30/12/2022 - Retro DOS v4.2
  1675                                  ;MAJOR_VERSION	EQU     6
  1676                                  ;MINOR_VERSION	EQU     22
  1677                                  
  1678                                  ; 01/01/2024 - Retro DOS v5.0
  1679                                  MAJOR_VERSION	EQU     7
  1680                                  MINOR_VERSION	EQU     10  ; PCDOS 7.1	(7.10)
  1681                                  
  1682                                  ;============================================================================
  1683                                  ; INTNAT.INC, MSDOS 3.3, 1987
  1684                                  ;============================================================================
  1685                                  ; 09/07/2018 - Retro DOS 3.0
  1686                                  
  1687                                  ; Current structure of the data returned by the international call
  1688                                  
  1689                                  struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  1690                                  .Date_tim_format:
  1691 00000000 ????                    		RESW 1		; 0-USA, 1-EUR, 2-JAP
  1692                                  .Currency_sym:
  1693 00000002 ??????????              		RESB 5		; Currency Symbol 5 bytes
  1694                                  .Thous_sep:
  1695 00000007 ????                    		RESB 2		; Thousands separator 2 bytes
  1696                                  .Decimal_sep:
  1697 00000009 ????                    		RESB 2		; Decimal separator 2 bytes
  1698                                  .Date_sep:
  1699 0000000B ????                    		RESB 2		; Date separator 2 bytes
  1700                                  .Time_sep:
  1701 0000000D ????                    		RESB 2		; Time separator 2 bytes
  1702                                  .Bit_field:	
  1703 0000000F ??                      		RESB 1		; Bit values
  1704                                                                     ;   Bit 0 = 0 if currency symbol first
  1705                                                                     ;         = 1 if currency symbol last
  1706                                                                     ;   Bit 1 = 0 if No space after currency symbol
  1707                                                                     ;         = 1 if space after currency symbol
  1708                                  .Currency_cents:
  1709 00000010 ??                      		RESB 	1	; Number of places after currency dec point
  1710                                  .Time_24:
  1711 00000011 ??                      		RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
  1712                                  .Map_call:
  1713 00000012 ????                    		RESW	1	; Address of case mapping call (DWORD)
  1714 00000014 ????                                    RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
  1715                                  				;  in pieces.
  1716                                  .Data_sep:
  1717 00000016 ????                    		RESB	2	; Data list separator character
  1718                                  .size:		
  1719                                  endstruc
  1720                                  
  1721                                  ; Max size of the block returned by the INTERNATIONAL call
  1722                                  
  1723                                  internat_block_max	EQU	32
  1724                                  
  1725                                  ;============================================================================
  1726                                  ; SYSVAR.INC (MSDOS 6.0, 1991)
  1727                                  ;============================================================================
  1728                                  ; 08/07/2018 - Retro DOS v3.0
  1729                                  
  1730                                  ; 01/01/2024 - Retro DOS v5.0
  1731                                  
  1732                                  ;SysInitVars STRUC
  1733                                  struc SYSI
  1734 00000000 ????????                .DPB:	    resd 1	; 0	; DPB chain
  1735 00000004 ????????                .SFT:	    resd 1	; 4	; SFT chain
  1736 00000008 ????????                .CLOCK:	    resd 1	; 8	; CLOCK device
  1737 0000000C ????????                .CON:	    resd 1	; 12	; CON device
  1738 00000010 ????                    .MAXSEC:    resw 1	; 16	; maximum sector size
  1739 00000012 ????????                .BUF:	    resd 1	; 18	; points to Hashinitvar
  1740 00000016 ????????                .CDS:	    resd 1	; 22	; CDS list
  1741 0000001A ????????                .FCB:	    resd 1	; 26	; FCB chain
  1742 0000001E ????                    .Keep:	    resw 1	; 30	; keep count
  1743 00000020 ??                      .NUMIO:	    resb 1	; 32	; Number of block devices
  1744 00000021 ??                      .NCDS:	    resb 1	; 33	; number of CDS's
  1745 00000022 ????????                .DEV:	    resd 1	; 34	; device list
  1746                                  ; 09/07/2018
  1747                                  ; Above parameters are described in MSDOS 3.3 SYSVAR.INC (85/04/10)
  1748                                  ; Following parameters are used with MSDOS 6.0 (Retro DOS v4.0)
  1749 00000026 ????                    .ATTR:	    resw 1	; 38	; null device attribute word
  1750 00000028 ????                    .STRAT:	    resw 1	; 40	; null device strategy entry point
  1751 0000002A ????                    .INTER:	    resw 1	; 42	; null device interrupt entry point
  1752 0000002C ????????????????        .NAME:	    resb 8	; 44	; null device name
  1753 00000034 ??                      .SPLICE:    resb 1	; 52	; TRUE -> splicees being done
  1754 00000035 ????                    .IBMDOS_SIZE: resw 1	; 53 	; DOS size in paragraphs
  1755 00000037 ????????                .IFS_DOSCALL@: resd 1	; 55	; IFS DOS service routine entry
  1756 0000003B ????????                .IFS:	    resd 1	; 59	; IFS header chain
  1757 0000003F ????????                .BUFFERS:   resw 2	; 63	; BUFFERS= values (m,n)
  1758 00000043 ??                      .BOOT_DRIVE: resb 1	; 67	; boot drive A=1 B=2,..
  1759 00000044 ??                      .DWMOVE:    resb 1	; 68	; 1 if 386 machine
  1760 00000045 ????                    .EXT_MEM:   resw 1	; 69	; Extended memory size in KB.
  1761                                  endstruc
  1762                                  ;SysInitVars ENDS
  1763                                  
  1764                                  ;This is added for more information exchange between DOS, BIOS.
  1765                                  ;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86
  1766                                  
  1767                                  ;SysInitVars_Ext struc
  1768                                  struc SYSI_EXT
  1769 00000000 ????????                .SysInitVars:	resd 1		; Points to the above structure.
  1770 00000004 ????????                .Country_Tab:	resd 1		; DOS_Country_cdpg_info
  1771                                  endstruc
  1772                                  ;SysInitVars_Ext ends
  1773                                  
  1774                                  ;============================================================================
  1775                                  ; IOCTL.INC - MSDOS 6.0 - 1991
  1776                                  ;============================================================================
  1777                                  ; 09/07/2018 - Retro DOS v3.0
  1778                                  
  1779                                  ;*** J.K.
  1780                                  ;General Guide -
  1781                                  ;Category Code:
  1782                                  ; 0... .... DOS Defined
  1783                                  ; 1... .... User defined
  1784                                  ; .xxx xxxx Code
  1785                                  
  1786                                  ;Function Code:
  1787                                  ; 0... .... Return error if unsupported
  1788                                  ; 1... .... Ignore if unsupported
  1789                                  ; .0.. .... Intercepted by DOS
  1790                                  ; .1.. .... Passed to driver
  1791                                  ; ..0. .... Sends data/commands to device
  1792                                  ; ..1. .... Quries data/info from device
  1793                                  ; ...x .... Subfunction
  1794                                  ;
  1795                                  ; Note that "Sends/queries" data bit is intended only to regularize the
  1796                                  ; function set.  It plays no critical role; some functions may contain both
  1797                                  ; command and query elements. The convention is that such commands are
  1798                                  ; defined as "sends data".
  1799                                  
  1800                                  ;*****************************;*
  1801                                  ; BLOCK DRIVERS 	      ;*
  1802                                  ;*****************************;*
  1803                                  
  1804                                  ; IOCTL SUB-FUNCTIONS
  1805                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1806                                  IOCTL_GET_DEVICE_INFO	EQU	0
  1807                                  IOCTL_SET_DEVICE_INFO	EQU	1
  1808                                  IOCTL_READ_HANDLE	EQU	2
  1809                                  IOCTL_WRITE_HANDLE	EQU	3
  1810                                  IOCTL_READ_DRIVE	EQU	4
  1811                                  IOCTL_WRITE_DRIVE	EQU	5
  1812                                  IOCTL_GET_INPUT_STATUS	EQU	6
  1813                                  IOCTL_GET_OUTPUT_STATUS EQU	7
  1814                                  IOCTL_CHANGEABLE?	EQU	8
  1815                                  IOCTL_DeviceLocOrRem?	EQU	9
  1816                                  IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
  1817                                  IOCTL_SHARING_RETRY	EQU	0Bh   ;11
  1818                                  GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
  1819                                  GENERIC_IOCTL		EQU	0Dh   ;13
  1820                                  ; (MSDOS 6.0 + MSDOS 3.3)
  1821                                  IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
  1822                                  IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
  1823                                  ; (MSDOS 6.0)
  1824                                  IOCTL_QUERY_HANDLE	EQU	10h   ;16
  1825                                  IOCTL_QUERY_BLOCK	EQU	11h   ;17
  1826                                  
  1827                                  ; GENERIC IOCTL CATEGORY CODES
  1828                                  IOC_OTHER		EQU	0	; Other device control J.K. 4/29/86
  1829                                  IOC_SE			EQU	1	; SERIAL DEVICE CONTROL
  1830                                  IOC_TC			EQU	2	; TERMINAL CONTROL
  1831                                  IOC_SC			EQU	3	; SCREEN CONTROL
  1832                                  IOC_KC			EQU	4	; KEYBOARD CONTROL
  1833                                  IOC_PC			EQU	5	; PRINTER CONTROL
  1834                                  IOC_DC			EQU	8	; DISK CONTROL (SAME AS RAWIO)
  1835                                  
  1836                                  ; GENERIC IOCTL SUB-FUNCTIONS
  1837                                  RAWIO			EQU	8
  1838                                  
  1839                                  ; RAWIO SUB-FUNCTIONS
  1840                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1841                                  GET_DEVICE_PARAMETERS	EQU	60H
  1842                                  SET_DEVICE_PARAMETERS	EQU	40H
  1843                                  READ_TRACK		EQU	61H
  1844                                  WRITE_TRACK		EQU	41H
  1845                                  VERIFY_TRACK		EQU	62H
  1846                                  FORMAT_TRACK		EQU	42H
  1847                                  ; (MSDOS 6.0)
  1848                                  GET_MEDIA_ID		EQU	66h	;AN000;AN003;changed from 63h
  1849                                  SET_MEDIA_ID		EQU	46h	;AN000;AN003;changed from 43h
  1850                                  GET_ACCESS_FLAG 	EQU	67h	;AN002;AN003;Unpublished function.Changed from 64h
  1851                                  SET_ACCESS_FLAG 	EQU	47h	;AN002;AN003;Unpublished function.Changed from 44h
  1852                                  SENSE_MEDIA_TYPE	EQU	68H	;Added for 5.00
  1853                                  
  1854                                  ; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
  1855                                  BUILD_DEVICE_BPB	EQU	000000001B
  1856                                  
  1857                                  ; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
  1858                                  INSTALL_FAKE_BPB	EQU	000000001B
  1859                                  ONLY_SET_TRACKLAYOUT	EQU	000000010B
  1860                                  TRACKLAYOUT_IS_GOOD	EQU	000000100B
  1861                                  
  1862                                  ; SPECIAL FUNCTION FOR FORMAT TRACK
  1863                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1864                                  STATUS_FOR_FORMAT	EQU	000000001B
  1865                                  ; (MSDOS 6.0)
  1866                                  DO_FAST_FORMAT		EQU	000000010B ;AN001;
  1867                                  
  1868                                  ; CODES RETURNED FROM FORMAT STATUS CALL
  1869                                  FORMAT_NO_ROM_SUPPORT	EQU	000000001B
  1870                                  FORMAT_COMB_NOT_SUPPORTED EQU	000000010B
  1871                                  
  1872                                  ; DEVICETYPE VALUES
  1873                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1874                                  MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
  1875                                  DEV_5INCH		EQU	0
  1876                                  DEV_5INCH96TPI		EQU	1
  1877                                  DEV_3INCH720KB		EQU	2
  1878                                  DEV_8INCHSS		EQU	3
  1879                                  DEV_8INCHDS		EQU	4
  1880                                  DEV_HARDDISK		EQU	5
  1881                                  DEV_OTHER		EQU	7
  1882                                  ; (MSDOS 6.0)
  1883                                  ;DEV_3INCH1440KB	EQU	7
  1884                                  DEV_3INCH2880KB		EQU	9
  1885                                  ; Retro DOS v2.0 - 26/03/2018
  1886                                  ;;DEV_TAPE		EQU	6
  1887                                  ;;DEV_ERIMO		EQU	8
  1888                                  ;DEV_3INCH2880KB	EQU	9
  1889                                  DEV_3INCH1440KB		EQU	10
  1890                                  
  1891                                  ; (MSDOS 3.3)
  1892                                  ;MAX_DEV_TYPE		EQU	7
  1893                                  
  1894                                  ; (MSDOS 6.0)
  1895                                  MAX_DEV_TYPE		EQU	10	; MAXIMUM DEVICE TYPE THAT WE
  1896                                  					; CURRENTLY SUPPORT.
  1897                                  struc A_SECTORTABLE
  1898 00000000 ????                    .ST_SECTORNUMBER:	resw	1
  1899 00000002 ????                    .ST_SECTORSIZE:		resw	1
  1900                                  .size:
  1901                                  endstruc
  1902                                  
  1903                                  ;============================================================================
  1904                                  ; DEVSYM.INC
  1905                                  ;============================================================================
  1906                                  ; 07/07/2018 - Retro DOS v3.0
  1907                                  ; 30/04/2019 - Retro DOS v4.0 (DEVSYM.INC, MSDOS 6.0, 1991)
  1908                                  
  1909                                  ;**	DevSym.inc - Device Symbols
  1910                                  
  1911                                  ; The device table list has the form:
  1912                                  struc	SYSDEV
  1913 00000000 ????????                .NEXT:		resd 1		;Pointer to next device header
  1914 00000004 ????                    .ATT:		resw 1		;Attributes of the device
  1915 00000006 ????                    .STRAT:		resw 1		;Strategy entry point
  1916 00000008 ????                    .INT:		resw 1		;Interrupt entry point
  1917 0000000A ????????????????        .NAME:		resb 8		;Name of device (only first byte used for block)
  1918                                  .size:
  1919                                  endstruc
  1920                                  
  1921                                  ;
  1922                                  ; ATTRIBUTE BIT MASKS
  1923                                  ;
  1924                                  ; CHARACTER DEVICES:
  1925                                  ;
  1926                                  ; BIT 15 -> MUST BE 1
  1927                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
  1928                                  ;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
  1929                                  ;     12 -> UNUSED
  1930                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
  1931                                  ;     10 -> MUST BE 0
  1932                                  ;      9 -> MUST BE 0
  1933                                  ;      8 -> UNUSED
  1934                                  ;      7 -> UNUSED
  1935                                  ;      6 -> UNUSED
  1936                                  ;      5 -> UNUSED
  1937                                  ;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
  1938                                  ;      3 -> 1 IF DEVICE IS CLOCK DEVICE
  1939                                  ;      2 -> 1 IF DEVICE IS NULL DEVICE
  1940                                  ;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
  1941                                  ;      0 -> 1 IF DEVICE IS CONSOLE INPUT
  1942                                  ;
  1943                                  ; BLOCK DEVICES:
  1944                                  ;
  1945                                  ; BIT 15 -> MUST BE 0
  1946                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
  1947                                  ;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
  1948                                  ;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
  1949                                  ;	    THE SAME PLACE.
  1950                                  ;     12 -> UNUSED
  1951                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
  1952                                  ;     10 -> MUST BE 0
  1953                                  ;      9 -> MUST BE 0
  1954                                  ;      8 -> UNUSED
  1955                                  ;      7 -> UNUSED
  1956                                  ;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
  1957                                  ;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
  1958                                  ;      5 -> UNUSED
  1959                                  ;      4 -> UNUSED
  1960                                  ;      3 -> UNUSED
  1961                                  ;      2 -> UNUSED
  1962                                  ;      1 -> UNUSED
  1963                                  ;      0 -> UNUSED
  1964                                  ;
  1965                                  
  1966                                  ;Attribute bit masks
  1967                                  DEVTYP	EQU     8000H           ;Bit 15 - 1 if Char, 0 if block
  1968                                  DEVIOCTL EQU    4000H           ;Bit 14 - CONTROL mode bit
  1969                                  ISFATBYDEV EQU  2000H           ;Bit 13 - Device uses FAT ID bytes, comp media.
  1970                                  
  1971                                  ; 09/07/2018 - Retro DOS (DEVSYM.INC, MSDOS 3.3, 1987) 
  1972                                  
  1973                                  OUTTILBUSY EQU	2000H		; OUTPUT UNTIL BUSY IS ENABLED
  1974                                  ISNET	   EQU	1000H		; BIT 12 - 1 IF A NET DEVICE, 0 IF
  1975                                  				;  NOT.  CURRENTLY BLOCK ONLY.
  1976                                  DEVOPCL    EQU	0800H		; BIT 11 - 1 IF THIS DEVICE HAS
  1977                                  				;  OPEN,CLOSE AND REMOVABLE MEDIA
  1978                                  				;  ENTRY POINTS, 0 IF NOT
  1979                                  
  1980                                  EXTENTBIT  EQU	0400H		; BIT 10 - CURRENTLY 0 ON ALL DEVS
  1981                                  				;  THIS BIT IS RESERVED FOR FUTURE USE
  1982                                  				;  TO EXTEND THE DEVICE HEADER BEYOND
  1983                                  				;  ITS CURRENT FORM.
  1984                                  
  1985                                  ; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
  1986                                  ;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
  1987                                  ;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
  1988                                  ;    MACHINES (FORMAT,CHKDSK,RECOVER,..).
  1989                                  
  1990                                  IOQUERY	EQU	0080H		;Bit 7 - Supports generic IOCtl query
  1991                                  
  1992                                  DEV320	EQU	0040H		;BIT 6 - FOR BLOCK DEVICES, THIS
  1993                                  				;DEVICE SUPPORTS SET/GET MAP OF
  1994                                  				;LOGICAL DRIVES, AND SUPPORTS
  1995                                  				;GENERIC IOCTL CALLS.
  1996                                  				;FOR CHARACTER DEVICES, THIS
  1997                                  				;DEVICE SUPPORTS GENERIC IOCTL.
  1998                                  				;THIS IS A DOS 3.2 DEVICE DRIVER.
  1999                                  
  2000                                  ISSPEC	EQU     0010H		;Bit 4 - This device is special ; 15/03/2018
  2001                                  ;ISIBM	EQU     0010H		;Bit 4 - This device is special
  2002                                  ISCLOCK EQU     0008H           ;Bit 3 - This device is the clock device.
  2003                                  ISNULL  EQU     0004H           ;Bit 2 - This device is the null device.
  2004                                  ISCOUT  EQU     0002H           ;Bit 1 - This device is the console output.
  2005                                  ISCIN   EQU     0001H           ;Bit 0 - This device is the console input.
  2006                                  
  2007                                  EXTDRVR	EQU	0002h		;BIT 1 - BLOCK DEVICE EXTENDED DRIVER
  2008                                  				; (MSDOS 6.0, DEVSYM.INC, 1991) ; 30/04/2019
  2009                                  
  2010                                  ;Static Reguest Header
  2011                                  struc	SRHEAD
  2012 00000000 ??                      .REQLEN:	resb 1		;Length in bytes of request block
  2013 00000001 ??                      .REQUNIT:	resb 1		;Device unit number
  2014 00000002 ??                      .REQFUNC:	resb 1		;Type of request
  2015 00000003 ????                    .REQSTAT:	resw 1		;Status Word
  2016 00000005 ????????????????                	resb 8		;Reserved for queue links
  2017                                  .size:
  2018                                  endstruc
  2019                                  
  2020                                  ;Status word masks
  2021                                  STERR   EQU     8000H           ;Bit 15 - Error
  2022                                  STBUI   EQU     0200H           ;Bit 9 - Buisy
  2023                                  STDON   EQU     0100H           ;Bit 8 - Done
  2024                                  STECODE EQU     00FFH           ;Error code
  2025                                  WRECODE EQU     0
  2026                                  
  2027                                  ;Function codes
  2028                                  DINITHL EQU     26              ;Size of init header
  2029                                  DMEDHL  EQU     15              ;Size of media check header
  2030                                  DBPBHL  EQU     22              ;Size of Get BPB header
  2031                                  DRDWRHL EQU     22              ;Size of RD/WR header
  2032                                  DRDNDHL EQU     14              ;Size of non destructive read header
  2033                                  DSTATHL EQU     13              ;Size of status header
  2034                                  DFLSHL  EQU     15              ;Size of flush header
  2035                                  
  2036                                  DEVINIT EQU     0               ;Initialization
  2037                                  DEVMDCH EQU     1               ;Media check
  2038                                  DEVBPB  EQU     2               ;Get BPB
  2039                                  DEVRDIOCTL EQU  3               ;IOCTL read
  2040                                  DEVRD   EQU     4               ;Read
  2041                                  DEVRDND EQU     5               ;Non destructive read no wait (character devs)
  2042                                  DEVIST  EQU     6               ;Input status
  2043                                  DEVIFL  EQU     7               ;Input flush
  2044                                  DEVWRT  EQU     8               ;Write
  2045                                  DEVWRTV EQU     9               ;Write with verify
  2046                                  DEVOST  EQU     10              ;Output status
  2047                                  DEVOFL  EQU     11              ;Output flush
  2048                                  DEVWRIOCTL EQU  12              ;IOCTL write
  2049                                  
  2050                                  ; 09/07/2018 - Retro DOS v3.0 (DEVSYM.INC, MSDOS 3.3, 1987) 
  2051                                  DEVOPN	EQU	13		;DEVICE OPEN
  2052                                  DEVCLS	EQU	14		;DEVICE CLOSE
  2053                                  DOPCLHL EQU	13		;SIZE OF OPEN/CLOSE HEADER
  2054                                  DEVRMD	EQU	15		;REMOVABLE MEDIA
  2055                                  ; 07/08/2018 - Retro DOS v3.0
  2056                                  REMHL	EQU	13		;SIZE OF REMOVABLE MEDIA HEADER
  2057                                  GENIOCTL EQU	19
  2058                                  
  2059                                  ; THE NEXT THREE ARE USED IN DOS 4.0
  2060                                  ;		     20
  2061                                  ;		     21
  2062                                  ;		     22
  2063                                  
  2064                                  DEVGETOWN      EQU   23		;GET DEVICE OWNER
  2065                                  DEVSETOWN      EQU   24		;SET DEVICE OWNER
  2066                                  ; 18/05/2019 - Retro DOS v4.0
  2067                                  IOCTL_QUERY    EQU   25		;Query generic ioctl support
  2068                                  
  2069                                  OWNHL	       EQU   13		;SIZE OF DEVICE OWNER HEADER
  2070                                  
  2071                                  DEVOUT	       EQU   16		; OUTPUT UNTIL BUSY.
  2072                                  DEVOUTL        EQU   DEVWRT	; LENGTH OF OUTPUT UNTIL BUSY
  2073                                  
  2074                                  ; ADDED FOR DOS 5.00
  2075                                  
  2076                                  ; GENERIC IOCTL REQUEST STRUCTURE
  2077                                  ;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
  2078                                  
  2079                                  struc IOCTL_REQ
  2080 00000000 <res Dh>                .SRHEAD:	resb SRHEAD.size
  2081                                  				; GENERIC IOCTL ADDITION.
  2082 0000000D ??                      .MAJORFUNCTION: resb 1		;FUNCTION CODE
  2083 0000000E ??                      .MINORFUNCTION: resb 1		;FUNCTION CATEGORY
  2084 0000000F ????                    .REG_SI:	resw 1
  2085 00000011 ????                    .REG_DI:	resw 1
  2086 00000013 ????????                .GENERICIOCTL_PACKET: resd 1	; POINTER TO DATA BUFFER
  2087                                  .size: ; 07/08/2018
  2088                                  endstruc
  2089                                  
  2090                                  ; DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
  2091                                  GEN_IOCTL_WRT_TRK EQU	40H
  2092                                  GEN_IOCTL_RD_TRK  EQU	60H
  2093                                  GEN_IOCTL_FN_TST  EQU	20H	; USED TO DIFF. BET READS AND WRTS
  2094                                  
  2095                                  ;; 32-bit absolute read/write input list structure
  2096                                  
  2097                                  struc ABS_32RW
  2098 00000000 ????????                .SECTOR_RBA:	resd 1		; relative block address
  2099 00000004 ????                    .ABS_RW_COUNT:	resw 1		; number of sectors to be transferred
  2100 00000006 ????????                .BUFFER_ADDR:	resd 1		; data addrress
  2101                                  .size:
  2102                                  endstruc
  2103                                  
  2104                                  ;; media ID info
  2105                                  
  2106                                  struc MEDIA_ID_INFO
  2107 00000000 ????                    .MEDIA_level:	resw	1	; info level
  2108 00000002 ????????                .MEDIA_Serial:	resd	1	; serial #
  2109 00000006 <res Bh>                .MEDIA_Label:	resb	11	; volume label
  2110 00000011 ????????????????        .MEDIA_System:	resb	8	; system type
  2111                                  .size:
  2112                                  endstruc
  2113                                  
  2114                                  ; equates for DOS34_FLAG
  2115                                  ; (BUGBUG: why are bits 0,1,3 and 4 not defined.)
  2116                                  
  2117                                  FROM_DISK_RESET       EQU   000000000100b   ;from disk reset
  2118                                  Force_I24_Fail	      EQU   000000100000b   ;form IFS CALL BACK
  2119                                  Disable_EOF_I24       EQU   000001000000b   ;disable EOF int24 for input status
  2120                                  DBCS_VOLID	      EQU   000010000000b   ;indicate from volume id
  2121                                  DBCS_VOLID2	      EQU   000100000000b   ;indicate 8th char is DBCS
  2122                                  CTRL_BREAK_FLAG       EQU   001000000000b   ;indicate control break is input
  2123                                  SEARCH_FASTOPEN       EQU   010000000000b   ;set fastopen flag for search
  2124                                  EXEC_AWARE_REDIR      EQU   100000000000b   ;M018: this bit is set by a redir 
  2125                                  					    ;M018: that knows how to handle 
  2126                                  					    ;M018: open for exec
  2127                                  
  2128                                  NO_FROM_DISK_RESET    EQU   ~FROM_DISK_RESET	;not from disk reset
  2129                                  NO_Force_I24_Fail     EQU   ~Force_I24_Fail	;not form IFS CALL BACK
  2130                                  NO_Disable_EOF_I24    EQU   ~Disable_EOF_I24
  2131                                  
  2132                                  ;============================================================================
  2133                                  ; ERROR.INC (MSDOS 6.0, 1991)
  2134                                  ;============================================================================
  2135                                  ; 16/07/2018 - Retro DOS v3.0 
  2136                                  
  2137                                  ;**	ERROR.INC - DOS Error Codes
  2138                                  ;
  2139                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
  2140                                  ;    return error codes through AX. If an error occurred then
  2141                                  ;    the carry bit will be set and the error code is in AX. If no error
  2142                                  ;    occurred then the carry bit is reset and AX contains returned info.
  2143                                  ;
  2144                                  ;    Since the set of error codes is being extended as we extend the operating
  2145                                  ;    system, we have provided a means for applications to ask the system for a
  2146                                  ;    recommended course of action when they receive an error.
  2147                                  ;
  2148                                  ;    The GetExtendedError system call returns a universal error, an error
  2149                                  ;    location and a recommended course of action. The universal error code is
  2150                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
  2151                                  ;    is issued.
  2152                                  
  2153                                  ;	2.0 error codes
  2154                                  
  2155                                  error_invalid_function		EQU	1
  2156                                  error_file_not_found		EQU	2
  2157                                  error_path_not_found		EQU	3
  2158                                  error_too_many_open_files	EQU	4
  2159                                  error_access_denied		EQU	5
  2160                                  error_invalid_handle		EQU	6
  2161                                  error_arena_trashed		EQU	7
  2162                                  error_not_enough_memory 	EQU	8
  2163                                  error_invalid_block		EQU	9
  2164                                  error_bad_environment		EQU	10
  2165                                  error_bad_format		EQU	11
  2166                                  error_invalid_access		EQU	12
  2167                                  error_invalid_data		EQU	13
  2168                                  ;**** reserved			EQU	14	; *****
  2169                                  error_invalid_drive		EQU	15
  2170                                  error_current_directory 	EQU	16
  2171                                  error_not_same_device		EQU	17
  2172                                  error_no_more_files		EQU	18
  2173                                  
  2174                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
  2175                                  
  2176                                  error_write_protect		EQU	19
  2177                                  error_bad_unit			EQU	20
  2178                                  error_not_ready 		EQU	21
  2179                                  error_bad_command		EQU	22
  2180                                  error_CRC			EQU	23
  2181                                  error_bad_length		EQU	24
  2182                                  error_seek			EQU	25
  2183                                  error_not_DOS_disk		EQU	26
  2184                                  error_sector_not_found		EQU	27
  2185                                  error_out_of_paper		EQU	28
  2186                                  error_write_fault		EQU	29
  2187                                  error_read_fault		EQU	30
  2188                                  error_gen_failure		EQU	31
  2189                                  
  2190                                  ;	the new 3.0 error codes reported through INT 24
  2191                                  
  2192                                  error_sharing_violation 	EQU	32
  2193                                  error_lock_violation		EQU	33
  2194                                  error_wrong_disk		EQU	34
  2195                                  error_FCB_unavailable		EQU	35
  2196                                  error_sharing_buffer_exceeded	EQU	36
  2197                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00  ;AN000;
  2198                                  error_handle_EOF		EQU	38    ; DOS 4.00  ;AN000;
  2199                                  error_handle_Disk_Full		EQU	39    ; DOS 4.00  ;AN000;
  2200                                  
  2201                                  ;	New OEM network-related errors are 50-79
  2202                                  
  2203                                  error_not_supported		EQU	50
  2204                                  
  2205                                  error_net_access_denied		EQU	65	;M028
  2206                                  
  2207                                  ;	End of INT 24 reportable errors
  2208                                  
  2209                                  error_file_exists		EQU	80
  2210                                  error_DUP_FCB			EQU	81	; *****
  2211                                  error_cannot_make		EQU	82
  2212                                  error_FAIL_I24			EQU	83
  2213                                  
  2214                                  ;	New 3.0 network related error codes
  2215                                  
  2216                                  error_out_of_structures 	EQU	84
  2217                                  error_already_assigned		EQU	85
  2218                                  error_invalid_password		EQU	86
  2219                                  error_invalid_parameter 	EQU	87
  2220                                  error_NET_write_fault		EQU	88
  2221                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00  ;AN000;
  2222                                  
  2223                                  ;	BREAK <Interrupt 24 error codes>
  2224                                  
  2225                                  ;**	Int24 Error Codes
  2226                                  
  2227                                  error_I24_write_protect 	EQU	0
  2228                                  error_I24_bad_unit		EQU	1
  2229                                  error_I24_not_ready		EQU	2
  2230                                  error_I24_bad_command		EQU	3
  2231                                  error_I24_CRC			EQU	4
  2232                                  error_I24_bad_length		EQU	5
  2233                                  error_I24_Seek			EQU	6
  2234                                  error_I24_not_DOS_disk		EQU	7
  2235                                  error_I24_sector_not_found	EQU	8
  2236                                  error_I24_out_of_paper		EQU	9
  2237                                  error_I24_write_fault		EQU	0Ah
  2238                                  error_I24_read_fault		EQU	0Bh
  2239                                  error_I24_gen_failure		EQU	0Ch
  2240                                  ; NOTE: Code 0DH is used by MT-DOS.
  2241                                  error_I24_wrong_disk		EQU	0Fh
  2242                                  
  2243                                  ;	THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24
  2244                                  ;
  2245                                  ;	NOTE: ABORT is ALWAYS allowed
  2246                                  
  2247                                  Allowed_FAIL			EQU	00001000B
  2248                                  Allowed_RETRY			EQU	00010000B
  2249                                  Allowed_IGNORE			EQU	00100000B
  2250                                  
  2251                                  I24_operation			EQU	00000001B  ;Z if READ,NZ if Write
  2252                                  I24_area			EQU	00000110B  ; 00 if DOS
  2253                                  						   ; 01 if FAT
  2254                                  						   ; 10 if root DIR
  2255                                  						   ; 11 if DATA
  2256                                  I24_class			EQU	10000000B  ;Z if DISK, NZ if FAT or char
  2257                                  
  2258                                  ;	BREAK <GetExtendedError CLASSes ACTIONs LOCUSs>
  2259                                  
  2260                                  ;**	The GetExtendedError call takes an error code and returns CLASS,
  2261                                  ;	ACTION and LOCUS codes to help programs determine the proper action
  2262                                  ;	to take for error codes that they don't explicitly understand.
  2263                                  
  2264                                  ;	Values for error CLASS
  2265                                  
  2266                                  errCLASS_OutRes 	EQU	1	; Out of Resource
  2267                                  errCLASS_TempSit	EQU	2	; Temporary Situation
  2268                                  errCLASS_Auth		EQU	3	; Permission problem
  2269                                  errCLASS_Intrn		EQU	4	; Internal System Error
  2270                                  errCLASS_HrdFail	EQU	5	; Hardware Failure
  2271                                  errCLASS_SysFail	EQU	6	; System Failure
  2272                                  errCLASS_Apperr 	EQU	7	; Application Error
  2273                                  errCLASS_NotFnd 	EQU	8	; Not Found
  2274                                  errCLASS_BadFmt 	EQU	9	; Bad Format
  2275                                  errCLASS_Locked 	EQU	10	; Locked
  2276                                  errCLASS_Media		EQU	11	; Media Failure
  2277                                  errCLASS_Already	EQU	12	; Collision with Existing Item
  2278                                  errCLASS_Unk		EQU	13	; Unknown/other
  2279                                  
  2280                                  ;	Values for error ACTION
  2281                                  
  2282                                  errACT_Retry		EQU	1	; Retry
  2283                                  errACT_DlyRet		EQU	2	; Delay Retry, retry after pause
  2284                                  errACT_User		EQU	3	; Ask user to regive info
  2285                                  errACT_Abort		EQU	4	; abort with clean up
  2286                                  errACT_Panic		EQU	5	; abort immediately
  2287                                  errACT_Ignore		EQU	6	; ignore
  2288                                  errACT_IntRet		EQU	7	; Retry after User Intervention
  2289                                  
  2290                                  ;	Values for error LOCUS
  2291                                  
  2292                                  errLOC_Unk		EQU	1	; No appropriate value
  2293                                  errLOC_Disk		EQU	2	; Random Access Mass Storage
  2294                                  errLOC_Net		EQU	3	; Network
  2295                                  errLOC_SerDev		EQU	4	; Serial Device
  2296                                  errLOC_Mem		EQU	5	; Memory
  2297                                  
  2298                                  ;============================================================================
  2299                                  ; INT2A.INC (MSDOS 6.0, 1991)
  2300                                  ;============================================================================
  2301                                  ; 04/05/2019 - Retro DOS v4.0
  2302                                  
  2303                                  ;**	Int 2A functions
  2304                                  ; ---------------------------------------------------------------------------
  2305                                  ;	Int 2A is an interface to the network code; it's also overloaded
  2306                                  ;		as a critical section handler since critical sections
  2307                                  ;		were originally created to support the net.
  2308                                  ; ---------------------------------------------------------------------------
  2309                                  
  2310                                  ; ---------------------------------------------------------------------------
  2311                                  ;**	This table was created by examining the source and may not be
  2312                                  ;	complete or completely accurate - JGL
  2313                                  ;
  2314                                  ;	M010	MD	8/31/90 - Added definition for AH = 5
  2315                                  
  2316                                  ;	(ah) = 0	installation check
  2317                                  ;			   (returns ah !=0 if installed)
  2318                                  ;	(ah) = 1	cooked net bios call
  2319                                  ;	(ah) = 3	query drive shared
  2320                                  ;			   (ds:si) = "n:" asciz string
  2321                                  ;	(ah) = 4	net bios
  2322                                  ;	       (al) = 0	   cooked net bios call
  2323                                  ;	       (al) = 1	   raw net bios call
  2324                                  ;	       (al) = 2	   ???
  2325                                  ;
  2326                                  ;	(ah) = 5	Get Net Adaptor Resources. CX returns the number of
  2327                                  ;			NCBs available/outstanding. DX returns the number of
  2328                                  ;			sessions. Supposedly, this is documented in an old
  2329                                  ;			IBM PC-LAN reference. Lotus Notes uses it. DOS LAN
  2330                                  ;			Manager 2.0 Enhanced responds to it. But it should
  2331                                  ;			not be used, as it is a hack, only to get Lotus
  2332                                  ;			Notes running.
  2333                                  ;
  2334                                  ;	(ah) = 80h	enter critical section
  2335                                  ;	(ah) = 81h	leave critical section
  2336                                  ;	(ah) = 82h	free all critical sections (Leave-all)
  2337                                  ;	(ah) = 84h	entering idle loop (don't understand how this works)
  2338                                  ; ---------------------------------------------------------------------------
  2339                                  
  2340                                  ;**	Critical section definitions
  2341                                  ; ---------------------------------------------------------------------------
  2342                                  ;	Although DOS is not designed to be reentrant there are some hacks
  2343                                  ;	which various programs use to make it so, in a limited fashion.
  2344                                  ;	Both WIN386 and some servers block copy a section of the DOS data
  2345                                  ;	area so that DOS can be reentered on behalf of another thread/program.
  2346                                  ;	DOS's global data structures, such as the memory arena, are not
  2347                                  ;	in this area, so critical section indicators are used to protect
  2348                                  ;	those areas.  DOS flags a critical section by issuing an INT_IBM
  2349                                  ;	(int 2Ah) at each critical section entry and exit.  Some clients
  2350                                  ;	(such as WIN386) just don't "context switch" the DOS when one
  2351                                  ;	of these is in effect, others, such as the IBM server, go ahead
  2352                                  ;	and reenter the DOS and if they get an int 2A to reenter the same
  2353                                  ;	critical section they then switch away from that second thread and
  2354                                  ;	let the first one finish and exit the section.
  2355                                  ; ---------------------------------------------------------------------------
  2356                                  
  2357                                  ; These below are subject to leave-all sections
  2358                                  critDisk    EQU     1			; Disk I/O critical section
  2359                                  critShare   EQU     1			; Sharer I/O critical section
  2360                                  critMem     EQU     1			; memory maintenance critical section
  2361                                  critSFT     EQU     1			; sft table allocation
  2362                                  critDevice  EQU     2			; Device I/O critical section
  2363                                  critNet     EQU     5			; network critical section
  2364                                  critIFS     EQU     6			; ifsfunc critical section
  2365                                  ; These below are not subject to leave-all sections
  2366                                  critASSIGN  EQU     8			; Assign has munged a system call
  2367                                  
  2368                                  ;============================================================================
  2369                                  ; MULT.INC (MSDOS 6.0, 1991)
  2370                                  ;============================================================================
  2371                                  ; 04/05/2019 - Retro DOS v4.0
  2372                                  
  2373                                  ;Break <Multiplex channels>
  2374                                  
  2375                                  ; ---------------------------------------------------------------------------
  2376                                  ; The current set of defined multiplex channels is (* means documented):
  2377                                  ;
  2378                                  ;   Channel(h)  Issuer          Receiver    Function
  2379                                  ;      00       server          PSPRINT     print job control
  2380                                  ;     *01       print/apps      PRINT       Queueing of files
  2381                                  ;      02       BIOS            REDIR       signal open/close of printers
  2382                                  ;
  2383                                  ;      05       command         REDIR       obtain text of net int 24 message
  2384                                  ;     *06       server/assign   ASSIGN      Install check
  2385                                  ;
  2386                                  ;      08       external driver IBMBIO      interface to internal routines
  2387                                  ;
  2388                                  ;      10       sharer/server   Sharer      install check
  2389                                  ;      11       DOS/server      Redir       install check/redirection funcs
  2390                                  ;      12       sharer/redir    DOS         dos functions and structure maint
  2391                                  ;      13       MSNET           MSNET       movement of NCBs
  2392                                  ;      13       external driver IBMBIO      Reset_Int_13, allows installation
  2393                                  ;                                           of alternative INT_13 drivers after
  2394                                  ;                                           boot_up
  2395                                  ;      14 (IBM) DOS             NLSFUNC     down load NLS country info,DOS 3.3
  2396                                  ;      14 (MS)  APPS            POPUP       MSDOS 4 popup screen functions
  2397                                  ;      15       APPS            MSCDEX      CD-ROM extensions interface
  2398                                  ;      16       WIN386          WIN386      Windows communications
  2399                                  ;      17       Clipboard       WINDOWS     Clipboard interface
  2400                                  ;     *18       Applications    MS-Manger   Toggle interface to manager
  2401                                  ;      19       Shell
  2402                                  ;      1A       Ansi.sys
  2403                                  ;      1B       Fastopen,Vdisk   IBMBIO     EMS INT 67H stub handler
  2404                                  ;
  2405                                  ;      40h      OS/2
  2406                                  ;      41h      Lanman
  2407                                  ;      42h      Lanman
  2408                                  ;      43h      Himem
  2409                                  ;                               AL = 20h    reserved for Mach 20 Himem support
  2410                                  ;                               AL = 30h    reserved for Himem external A20 code
  2411                                  ;      44h      Dosextender
  2412                                  ;      45H      Windows profiler
  2413                                  ;      46h      Windows/286 DOS extender
  2414                                  ;      47h      Basic Compiler Vn. 7.0
  2415                                  ;      48h      Doskey
  2416                                  ;      49h      DOS 5.x install 
  2417                                  ;      4Ah      Multi Purpose
  2418                                  ;                multMULTSWPDSK         0 - Swap Disk in drive A (BIOS)
  2419                                  ;                multMULTGETHMAPTR      1 - Get available HMA & ptr
  2420                                  ;                multMULTALLOCHMA       2 - Allocate HMA (bx == no of bytes)
  2421                                  ;                multMULTTASKSHELL      5 - Shell/switcher API
  2422                                  ;                multMULTRPLTOM         6 - Top Of Memory for RPL support
  2423                                  ;
  2424                                  ;                multSmartdrv           10h
  2425                                  ;                multMagicdrv           11h
  2426                                  ;      4Bh      Task Switcher API
  2427                                  ;
  2428                                  ;      4Ch      APPS            APM         Advanced power management
  2429                                  ;      4Dh      Kana Kanji Converter, MSKK
  2430                                  ;
  2431                                  ;      51h      ODI real mode support driver (for Chicago)
  2432                                  ;
  2433                                  ;      53h      POWER.EXE - used for broadcasting APM events    ; M036
  2434                                  ;      54h      POWER.EXE - used for POWER API                  ; M036
  2435                                  ;
  2436                                  ;      55h      COMMAND.COM
  2437                                  ;                multCOMFIRST           0 - API to determine whether 1st
  2438                                  ;                                           instance of command.com
  2439                                  ;                multCOMFIRSTROM        1 - API to determine whether 1st
  2440                                  ;                                           instance of ROM COMMAND
  2441                                  ;      56h      Sewell Development
  2442                                  ;               INTERLNK
  2443                                  ;
  2444                                  ;      57h      Iomega Corp.
  2445                                  ;
  2446                                  ;      ABh      Unspecified IBM use
  2447                                  ;      ACh      Graphics
  2448                                  ;      ADh      NLS (toronto)
  2449                                  ;      AEh
  2450                                  ;      AFh      Mode
  2451                                  ;      B0h      GRAFTABL        GRAFTABL
  2452                                  ;
  2453                                  ;      D7h      Banyan VINES
  2454                                  ; ---------------------------------------------------------------------------
  2455                                  
  2456                                  ;MUX 00-3F reserverd for IBM
  2457                                  ;MUX 80-BF reserverd for IBM
  2458                                  
  2459                                  ;MUX 40-7F reserved for Microsoft
  2460                                  
  2461                                  ;MUX C0-FF users
  2462                                  
  2463                                  MultSHARE   EQU     10h 		; sharer
  2464                                      ;	1   MFT_enter
  2465                                      ;	2   MFTClose
  2466                                      ;	3   MFTclU
  2467                                      ;	4   MFTCloseP
  2468                                      ;	5   MFTCloN
  2469                                      ;	6   set_block
  2470                                      ;	7   clr_block
  2471                                      ;	8   chk_block
  2472                                      ;	9   MFT_get
  2473                                      ;	10  ShSave
  2474                                      ;	11  ShChk
  2475                                      ;	12  ShCol
  2476                                      ;	13  ShCloseFile
  2477                                  
  2478                                  MultNET     EQU     11h 		; Network support
  2479                                  MultIFS     EQU     11h                 ; Network support
  2480                                      ;   1   IFS_RMDIR
  2481                                      ;   2   IFS_SEQ_RMDIR
  2482                                      ;   3   IFS_MKDIR
  2483                                      ;   4   IFS_SEQ_MKDIR
  2484                                      ;   5   IFS_CHDIR
  2485                                      ;   6   IFS_CLOSE
  2486                                      ;   7   IFS_COMMIT
  2487                                      ;   8   IFS_READ
  2488                                      ;   9   IFS_WRITE
  2489                                      ;   10  IFS_LOCK
  2490                                      ;   11  IFS_UNLOCK
  2491                                      ;   12  IFS_DISK_INFO
  2492                                      ;   13  IFS_SET_FILE_ATTRIBUTE
  2493                                      ;   14  IFS_SEQ_SET_FILE_ATTRIBUTE
  2494                                      ;   15  IFS_GET_FILE_INFO
  2495                                      ;   16  IFS_SEQ_GET_FILE_INFO
  2496                                      ;   17  IFS_RENAME
  2497                                      ;   18  IFS_SEQ_RENAME
  2498                                      ;   19  IFS_DELETE
  2499                                      ;   20  IFS_SEQ_DELETE
  2500                                      ;   21  IFS_OPEN
  2501                                      ;   22  IFS_SEQ_OPEN
  2502                                      ;   23  IFS_CREATE
  2503                                      ;   24  IFS_SEQ_CREATE
  2504                                      ;   25  IFS_SEQ_SEARCH_FIRST
  2505                                      ;   26  IFS_SEQ_SEARCH_NEXT
  2506                                      ;   27  IFS_SEARCH_FIRST
  2507                                      ;   28  IFS_SEARCH_NEXT
  2508                                      ;   29  IFS_ABORT
  2509                                      ;   30  IFS_ASSOPER
  2510                                      ;   31  Printer_SET_STRING
  2511                                      ;   32  IFSFlushBuf
  2512                                      ;   33  IFSBufWrite
  2513                                      ;   34  IFSResetEnvironment
  2514                                      ;   35  IFSSpoolCheck
  2515                                      ;   36  IFSSpoolClose
  2516                                      ;   37  IFSDeviceOper
  2517                                      ;   38  IFSSpoolEchoCheck
  2518                                      ;   39      - - -   Unused   - - -
  2519                                      ;   40      - - -   Unused   - - -
  2520                                      ;   41      - - -   Unused   - - -
  2521                                      ;   42  SERVER_DOSCALL_CLOSEFILES_FOR_UID
  2522                                      ;   43  DEVICE_IOCTL
  2523                                      ;   44  IFS_UPDATE_CB
  2524                                      ;   45  IFS_FILE_XATTRIBUTES
  2525                                      ;   46  IFS_XOPEN
  2526                                      ;   47  IFS_DEPENDENT_IOCTL
  2527                                  
  2528                                  MultDOS     EQU     12h 		; DOS call back
  2529                                      ;	1   DOS_CLOSE
  2530                                      ;	2   RECSET
  2531                                      ;	3   Get DOSGROUP
  2532                                      ;	4   PATHCHRCMP
  2533                                      ;	5   OUT
  2534                                      ;	6   NET_I24_ENTRY
  2535                                      ;	7   PLACEBUF
  2536                                      ;	8   FREE_SFT
  2537                                      ;	9   BUFWRITE
  2538                                      ;	10  SHARE_VIOLATION
  2539                                      ;	11  SHARE_ERROR
  2540                                      ;	12  SET_SFT_MODE
  2541                                      ;	13  DATE16
  2542                                      ;	14  SETVISIT
  2543                                      ;	15  SCANPLACE
  2544                                      ;	16  SKIPVISIT
  2545                                      ;	17  StrCpy
  2546                                      ;	18  StrLen
  2547                                      ;	19  UCase
  2548                                      ;	20  POINTCOMP
  2549                                      ;	21  CHECKFLUSH
  2550                                      ;	22  SFFromSFN
  2551                                      ;	23  GetCDSFromDrv
  2552                                      ;	24  Get_User_Stack
  2553                                      ;	25  GetThisDrv
  2554                                      ;	26  DriveFromText
  2555                                      ;	27  SETYEAR
  2556                                      ;	28  DSUM
  2557                                      ;	29  DSLIDE
  2558                                      ;	30  StrCmp
  2559                                      ;	31  initcds
  2560                                      ;	32  pjfnfromhandle
  2561                                      ;	33  $NameTrans
  2562                                      ;	34  CAL_LK
  2563                                      ;	35  DEVNAME
  2564                                      ;	36  Idle
  2565                                      ;   37  DStrLen
  2566                                      ;   38  NLS_OPEN      DOS 3.3
  2567                                      ;   39  $CLOSE        DOS 3.3
  2568                                      ;   40  NLS_LSEEK     DOS 3.3
  2569                                      ;   41  $READ         DOS 3.3
  2570                                      ;   42  FastInit      DOS 4.0
  2571                                      ;   43  NLS_IOCTL     DOS 3.3
  2572                                      ;   44  GetDevList    DOS 3.3
  2573                                      ;   45  NLS_GETEXT    DOS 3.3
  2574                                      ;   46  MSG_RETRIEVAL DOS 4.0
  2575                                      ;   47  FAKE_VERSION  DOS 4.0
  2576                                  
  2577                                  NLSFUNC     EQU     14h 		; NLSFUNC CALL , DOS 3.3
  2578                                      ;	0   NLSInstall
  2579                                      ;	1   ChgCodePage
  2580                                      ;	2   GetExtInfo
  2581                                      ;	3   SetCodePage
  2582                                      ;	4   GetCntry
  2583                                  
  2584                                  multANSI    EQU     1Ah                 ; ANSI multiplex number
  2585                                      ;   0   INSTALL_CHECK               ; install check for ANSI
  2586                                      ;   1   IOCTL_2F                    ; 2F interface to IOCTL
  2587                                      ;   2   DA_INFO_2F                  ; J.K. Information passing to ANSI.
  2588                                  
  2589                                  multMULT        EQU     4Ah
  2590                                  multMAGIC       EQU     256*multMULT + 11h
  2591                                  multMULTRPLTOM  EQU     06h
  2592                                  
  2593                                      ;   0   swap disk function for single floppy drive m/cs
  2594                                      ;       BIOS broadcasts with cx==0, and apps who handle
  2595                                      ;       swap disk messaging set cx == -1. BIOS sets dl == requested
  2596                                      ;       drive
  2597                                      ;
  2598                                      ;   1   Get available HMA & pointer to it. Returns in BX & ES:DI
  2599                                      ;   2   Allocate HMA. BX == number of bytes in HMA to be allocated
  2600                                      ;       returns pointer in ES:DI
  2601                                      ;
  2602                                      ;   3-4 currently used by nobody
  2603                                      ;   5   Switcher API
  2604                                      ;   6   Top of Memory for RPL.
  2605                                      ;           BIOS issues INT 2f AX=4a06 & DX = Top of Mem and any RPL
  2606                                      ;           code present in TOM should respond with a new TOM in DX
  2607                                      ;           to protect itself from MSLOAD & SYSINIT tromping over it.
  2608                                      ;           SYSINIT builds an arena with owner type 8 & name 'RPL' to
  2609                                      ;           protect the RPL code from COMMAND.COM transient protion.
  2610                                      ;           It is the responsibility of RPL program to release the mem.
  2611                                      ;   7   Reserved for PROTMAN support.
  2612                                      ;  10   smartdrv 4.0
  2613                                      ;  11   dblspace api
  2614                                      ;  12   MRCI     api
  2615                                      ;  13   dblspace/mrci stealth packet api
  2616                                  
  2617                                  MultAPM     EQU     4ch             ; Obselete ???
  2618                                      ;       00h     APM_VER_CHK
  2619                                      ;       01h     APM_SUS_SYS_REQ
  2620                                      ;       FFh     APM_SUS_RES_BATT_NOTIFY
  2621                                  
  2622                                  MultPWR_BRDCST  EQU     53h     ; Used by POWER.EXE to broadcast      ; M036
  2623                                  				;  APM events                         ; M036
  2624                                  MultPWR_API     EQU     54h     ; Used for accessing POWER.EXE's API  ; M036
  2625                                  
  2626                                  ;FASTOPEN is not chained through INT 2F   ; DOS 3.3 F.C.
  2627                                  ;	  it calls Multdos 42 to set up an entry routine address
  2628                                      ;	0   Install status  (reserved)
  2629                                      ;	1   Lookup
  2630                                      ;	2   Insert
  2631                                      ;	3   Delete
  2632                                      ;	4   Purge	    (reserved)
  2633                                  
  2634                                  ;============================================================================
  2635                                  ; FIND.INC (MSDOS 6.0, 1991)
  2636                                  ;============================================================================
  2637                                  ; 17/05/2019 - Retro DOS v4.0
  2638                                  ; 09/07/2018 - Retro DOS v3.0 (MSDOS 3.3, 1987)
  2639                                  
  2640                                  ;Break	<find first/next buffer>
  2641                                  
  2642                                  struc find_buf
  2643 00000000 ??                      .drive:	    resb 1		; drive of search
  2644 00000001 <res Bh>                .name:	    resb 11		; formatted name
  2645 0000000C ??                      .sattr:	    resb 1		; attribute of search
  2646 0000000D ????                    .LastEnt:   resw 1		; LastEnt
  2647 0000000F ????                    .DirStart:  resw 1		; DirStart
  2648 00000011 ????????                .NETID:	    resb 4 ; MSDOS 6.0 	; Reserved for NET
  2649 00000015 ??                      .attr:	    resb 1		; attribute found
  2650 00000016 ????                    .time:	    resw 1		; time
  2651 00000018 ????                    .date:	    resw 1		; date
  2652 0000001A ????                    .size_l:    resw 1		; low(size)
  2653 0000001C ????                    .size_h:    resw 1		; high(size)
  2654 0000001E <res Dh>                .pname:	    resb 13		; packed name
  2655                                  .size:
  2656                                  endstruc
  2657                                  
  2658                                  ;============================================================================
  2659                                  ; DOSCNTRY.INC (MSDOS 6.0, 1991)
  2660                                  ;============================================================================
  2661                                  ; 29/04/2019 - Retro DOS v4.0
  2662                                  ; 09/07/2018 - Retro DOS v3.0 (MSDOS 3.3, 1987)
  2663                                  
  2664                                  ;Equates for COUNTRY INFORMATION.
  2665                                  SetCountryInfo	EQU	1	;country info
  2666                                  SetUcase	EQU	2	;uppercase table
  2667                                  SetLcase	EQU	3	;lowercase table (Reserved)
  2668                                  SetUcaseFile	EQU	4	;uppercase file spec table
  2669                                  SetFileList	EQU	5	;valid file character list
  2670                                  SetCollate	EQU	6	;collating sequence
  2671                                  SetDBCS 	EQU	7	;double byte character set
  2672                                  SetALL		EQU	-1	;all the entries
  2673                                  
  2674                                  ;DOS country and code page information table structure.
  2675                                  ;Internally, IBMDOS gives a pointer to this table.
  2676                                  ;IBMBIO, MODE and NLSFUNC modules communicate with IBMDOS through
  2677                                  ;this structure.
  2678                                  
  2679                                  struc  DOS_CCDPG	; DOS_country_cdpg_info
  2680 00000000 ????????????????        .ccInfo_reserved: 	resb 8	;reserved for internal use
  2681 00000008 <res 40h>               .ccPath_CountrySys:	resb 64 ;path and filename for country info
  2682 00000048 ????                    .ccSysCodePage:		resw 1	;system code page id
  2683 0000004A ????                    .ccNumber_of_entries:	resw 1  ; (default value = 6)
  2684 0000004C ??                      .ccSetUcase:		resb 1  ; (default value = SetUcase)
  2685 0000004D ????????                .ccUcase_ptr:		resd 1	;pointer to Ucase table
  2686                                  
  2687 00000051 ??                      .ccSetUcaseFile:	resb 1	; (default value = SetUcaseFile)
  2688 00000052 ????????                .ccFileUcase_ptr: 	resd 1	;pointer to File Ucase table
  2689                                  
  2690 00000056 ??                      .ccSetFileList:		resb 1 	; (default value = SetFileList)
  2691 00000057 ????????                .ccFileChar_ptr:	resd 1	;pointer to File char list table
  2692                                  
  2693 0000005B ??                      .ccSetCollate:		resb 1	; (default value = SetCollate)
  2694 0000005C ????????                .ccCollate_ptr:		resd 1	;pointer to collate table
  2695                                  
  2696                                  ; MSDOS 6.0
  2697 00000060 ??                      .ccSetDBCS:		resb 1	; (default value = SetDBCS)
  2698 00000061 ????????                .ccDBCS_ptr:		resd 1	; pointer to DBCS table
  2699                                  
  2700 00000065 ??                      .ccSetCountryInfo:	resb 1  ; (default value = SetCountryInfo)
  2701 00000066 ????                    .ccCountryInfoLen:	resw 1	;length of country info
  2702 00000068 ????                    .ccDosCountry:		resw 1	;system country code id
  2703 0000006A ????                    .ccDosCodePage:		resw 1	;system code page id
  2704 0000006C ????                    .ccDFormat:		resw 1	;date format
  2705 0000006E ??????????              .ccCurSymbol:		resb 5	;5 byte of (currency symbol+0)
  2706 00000073 ????                    .cc1000Sep:		resb 2	;2 byte of (1000 sep. + 0)
  2707 00000075 ????                    .ccDecSep:		resb 2	;2 byte of (Decimal sep. + 0)
  2708 00000077 ????                    .ccDateSep:		resb 2	;2 byte of (date sep. + 0)
  2709 00000079 ????                    .ccTimeSep:		resb 2	;2 byte of (time sep. + 0)
  2710 0000007B ??                      .ccCFormat:		resb 1	;currency format flags
  2711 0000007C ??                      .ccCSigDigits:		resb 1	;# of digits in currency
  2712 0000007D ??                      .ccTFormat:		resb 1	;time format
  2713 0000007E ????????                .ccMono_ptr:		resd 1	;monocase routine entry point
  2714 00000082 ????                    .ccListSep:		resb 2	;data list separator
  2715 00000084 <res Ah>                .ccReserved_area: 	resw 5	;reserved
  2716                                  .size:
  2717                                  endstruc
  2718                                  
  2719                                  ;Ucase table
  2720                                  struc CC_UCASE_TAB
  2721 00000000 ????                    .ccUcase_leng:		resw 1	; (default value = 128)
  2722 00000002 <res 80h>               .ccUcase_data:		resb 128
  2723                                  endstruc
  2724                                  
  2725                                  ;File Ucase table
  2726                                  struc CC_FILE_UCASE_TAB
  2727 00000000 ????                    .ccFileucase_leng:	resw 1	; (default value = 128)
  2728 00000002 <res 80h>               .ccFileucase_data:	resb 128
  2729                                  endstruc
  2730                                  
  2731                                  ;File char list
  2732                                  struc CC_FILE_CHAR_TAB
  2733 00000000 ????                    .ccFilechar_leng:	resw 1
  2734 00000002 <res 2Eh>               .ccFilechar_data:	resb 46
  2735                                  endstruc
  2736                                  
  2737                                  ;collate table
  2738                                  struc CC_COLLATE_TAB
  2739 00000000 ????                    .ccCollate_leng:	resw 1	; (default value = 128)
  2740 00000002 <res 100h>              .ccCollate_data:	resb 256
  2741                                  endstruc
  2742                                  
  2743                                  OLD_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDFormat - 10)
  2744                                  NEW_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDosCountry) ; 38
  2745                                  
  2746                                  ; 06/08/2018
  2747                                  ; DOSCNTRY.INC (MSDOS 6.0, 1991)
  2748                                  
  2749                                  ;CAPITALIZATION equates
  2750                                  CAP_ONE_CHAR	equ	20H
  2751                                  CAP_STRING	equ	21H
  2752                                  CAP_ASCIIZ	equ	22H
  2753                                  CHECK_YES_NO	equ	23H
  2754                                  UPPER_TABLE	equ	80H
  2755                                  
  2756                                  ;NLS_YES	equ	59H  ; 'Y'
  2757                                  ;NLS_yes2	equ	79H  ; 'y' 	
  2758                                  ;NLS_NO		equ	4EH  ; 'N'	
  2759                                  ;NLS_no2	equ	6EH  ; 'n'	
  2760                                  
  2761                                  ;============================================================================
  2762                                  ; CURDIR.INC (MSDOS 6.0, 1991)
  2763                                  ;============================================================================
  2764                                  ; 25/04/2019 - Retro DOS v4.0
  2765                                  ; 09/07/2018 - Retro DOS v3.0 (CURDIR.INC, MSDOS 3.3, 1987)
  2766                                  
  2767                                  ;BREAK <Current directory list structure>
  2768                                  
  2769                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2770                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2771                                  ;									   ;
  2772                                  ; CDS items are used bu the internal routines to store cluster numbers and ;
  2773                                  ; network identifiers for each logical name.  The ID field is used dually, ;
  2774                                  ; both as net ID and for a cluster number for local devices.  In the case  ;
  2775                                  ; of local devices, the cluster number will be -1 if there is a potential  ;
  2776                                  ; of the disk being changed or if the path must be recracked.		   ;
  2777                                  ;
  2778                                  ;	Some pathnames have special preambles, such as
  2779                                  ;
  2780                                  ;		\\machine\sharename\...
  2781                                  ;	For these pathnames we can't allow ".." processing to back us
  2782                                  ;	up into the special front part of the name.  The CURDIR_END field
  2783                                  ;	holds the address of the seperator character which marks
  2784                                  ;	the split between the special preamble and the regular
  2785                                  ;	path list; ".." processing isn't allowed to back us up past
  2786                                  ;	(i.e., before) CURDIR_END
  2787                                  ;	For the root, it points at the leading /.  For net
  2788                                  ;	assignments it points at the end (nul) of the initial assignment:
  2789                                  ;	A:/	\\foo\bar	    \\foo\bar\blech\bozo
  2790                                  ;	  ^		 ^		     ^
  2791                                  
  2792                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
  2793                                  
  2794                                  TEMPLEN 	EQU	DIRSTRLEN*2
  2795                                  
  2796                                  struc curdir	; curdir_list
  2797 00000000 <res 43h>               .text:		resb DIRSTRLEN		; text of assignment and curdir
  2798 00000043 ????                    .flags:		resw 1			; various flags
  2799 00000045 ????????                .devptr:	resd 1			; local pointer to DPB or net device
  2800 00000049 ????????                .ID:		resw 2			; cluster of current dir (net ID)
  2801 0000004D ????                    .user_word:	resw 1
  2802 0000004F ????                    .end:		resw 1			; index to ".." backup limit - see above
  2803                                  ; MSDOS 6.0
  2804 00000051 ??                      .type:		resb 1			; IFS drive (2=ifs, 4=netuse)
  2805 00000052 ????????                .ifs_hdr:	resd 1			; Ptr to File System Header
  2806 00000056 ????                    .fsda:		resb 2			; File System Dependent Data Area
  2807                                  .size:
  2808                                  endstruc
  2809                                  
  2810                                  curdirLen	EQU curdir.size	; 88	; Needed for screwed up
  2811                                  
  2812                                  %define curdir_netID curdir_ID  ; dword
  2813                                  
  2814                                  ;**	Flag values for CURDIR_FLAGS
  2815                                  
  2816                                  curdir_isnet	EQU	1000000000000000B
  2817                                  CURDIR_isifs	EQU	1000000000000000B ; MSDOS 6.0	
  2818                                  curdir_inuse	EQU	0100000000000000B
  2819                                  curdir_splice	EQU	0010000000000000B
  2820                                  curdir_local	EQU	0001000000000000B
  2821                                  
  2822                                  ;									   ;
  2823                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2824                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2825                                  
  2826                                  ;============================================================================
  2827                                  ; CPMFCB.INC (MSDOS 3.3, 1987)
  2828                                  ;============================================================================
  2829                                  ; 09/07/2018 - Retro DOS v3.0
  2830                                  
  2831                                  ;BREAK <File Control Block definition>
  2832                                  
  2833                                  ;
  2834                                  ; Field definition for FCBs
  2835                                  ; The FCB has the following structure:
  2836                                  ;
  2837                                  ;	+---------------------------+
  2838                                  ;	|   Drive indicator(byte)   |
  2839                                  ;	+---------------------------+
  2840                                  ;	|    Filename (8 chars)     |
  2841                                  ;	+---------------------------+
  2842                                  ;	|    Extension (3 chars)    |
  2843                                  ;	+---------------------------+
  2844                                  ;	|   Current Extent(word)    |
  2845                                  ;	+---------------------------+
  2846                                  ;	|    Record size (word)     |
  2847                                  ;	+---------------------------+
  2848                                  ;	|    File Size (2 words)    |
  2849                                  ;	+---------------------------+
  2850                                  ;	|	Date of write	    |
  2851                                  ;	+---------------------------+
  2852                                  ;	|	Time of write	    |
  2853                                  ;	+---------------------------+
  2854                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2855                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2856                                  ;									   ;
  2857                                  ;	+---------------------------+
  2858                                  ;	|   8 bytes reserved	    |
  2859                                  ;	+---------------------------+
  2860                                  ;									   ;
  2861                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2862                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2863                                  ;	|    next record number     |
  2864                                  ;	+---------------------------+
  2865                                  ;	|   random record number    |
  2866                                  ;	+---------------------------+
  2867                                  ;
  2868                                  
  2869                                  struc	SYS_FCB
  2870 00000000 ??                      .drive:	resb 1
  2871 00000001 ????????????????        .name:	resb 8
  2872 00000009 ??????                  .ext:	resb 3
  2873 0000000C ????                    .EXTENT: resw 1
  2874 0000000E ????                    .RECSIZ: resw 1			; Size of record (user settable)
  2875 00000010 ????                    .FILSIZ: resw 1			; Size of file in bytes; used with the
  2876                                  				; following word
  2877 00000012 ????                    .DRVBP:	resw 1			; BP for SEARCH FIRST and SEARCH NEXT
  2878 00000014 ????                    .FDATE:	resw 1			; Date of last writing
  2879 00000016 ????                    .FTIME:	resw 1			; Time of last writing
  2880                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2881                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2882                                  ;									   ;
  2883 00000018 ????????????????        .reserved: resb 8		; RESERVED
  2884                                  ;									   ;
  2885                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2886                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2887 00000020 ??                      .NR:	resb 1			; Next record
  2888 00000021 ????????                .RR:	resb 4			; Random record
  2889                                  .size:
  2890                                  endstruc
  2891                                  
  2892                                  FILDIRENT EQU SYS_FCB.FILSIZ	; Used only by SEARCH FIRST and SEARCH
  2893                                  				; NEXT
  2894                                  ; 20/07/2018
  2895                                  %define fcb_sfn	SYS_FCB.reserved ; byte
  2896                                  
  2897                                  ; Note that fcb_net_handle, fcb_nsl_drive, fcb_nsld_drive and fcb_l_drive
  2898                                  ; all must point to the same byte.  Otherwise, the FCBRegen will fail.
  2899                                  ; NOTE about this byte (fcb_nsl_drive)
  2900                                  ;   The high two bits of this byte are used as follows to indicate the FCB type
  2901                                  ;	00 means a local file or device with sharing loaded
  2902                                  ;	10 means a remote (network) file
  2903                                  ;	01 means a local file with no sharing loaded
  2904                                  ;	11 means a local device with no sharing loaded
  2905                                  
  2906                                  ; 20/07/2018
  2907                                  
  2908                                  ;
  2909                                  ; Network FCB
  2910                                  ;
  2911                                  
  2912                                  %define fcb_net_drive	SYS_FCB.reserved+1  ; byte
  2913                                  %define fcb_net_handle	SYS_FCB.reserved+2  ; word
  2914                                  %define fcb_netID	SYS_FCB.reserved+4  ; dword		
  2915                                  
  2916                                  ;
  2917                                  ; No sharing local file FCB
  2918                                  ;
  2919                                  
  2920                                  %define fcb_nsl_drive	SYS_FCB.reserved+1  ; byte
  2921                                  %define fcb_nsl_bits	SYS_FCB.reserved+2  ; byte	
  2922                                  %define fcb_nsl_firclus SYS_FCB.reserved+3  ; word	
  2923                                  %define fcb_nsl_dirsec	SYS_FCB.reserved+5  ; word
  2924                                  %define fcb_nsl_dirpos  SYS_FCB.reserved+7  ; byte
  2925                                  
  2926                                  ;
  2927                                  ; No sharing local device FCB
  2928                                  ;
  2929                                  
  2930                                  %define fcb_nsld_drive	SYS_FCB.reserved+1  ; byte	
  2931                                  %define fcb_nsld_drvptr SYS_FCB.reserved+2  ; dword
  2932                                  
  2933                                  ;
  2934                                  ; Sharing local FCB
  2935                                  ;
  2936                                  
  2937                                  %define fcb_l_drive	SYS_FCB.reserved+1  ; byte
  2938                                  %define fcb_l_firclus	SYS_FCB.reserved+2  ; word
  2939                                  %define fcb_l_mfs	SYS_FCB.reserved+4  ; word
  2940                                  %define fcb_l_attr	SYS_FCB.reserved+6  ; byte
  2941                                  
  2942                                  ;
  2943                                  ; Bogusness:  the four cases are:
  2944                                  ;
  2945                                  ;   local file	    00
  2946                                  ;   local device    40
  2947                                  ;   local sharing   C0
  2948                                  ;   network	    80
  2949                                  ;
  2950                                  ; Since sharing and network collide, we cannot use a test instruction for
  2951                                  ; deciding whether a network or a share check in involved
  2952                                  ;
  2953                                  FCBDEVICE   EQU 040h
  2954                                  FCBNETWORK  EQU 080h
  2955                                  FCBSHARE    EQU 0C0h
  2956                                  
  2957                                  ; FCBSPECIAL must be able to mask off both net and share
  2958                                  FCBSPECIAL  EQU 080h
  2959                                  FCBMASK     EQU 0C0h
  2960                                  
  2961                                  ;============================================================================
  2962                                  ; FASTOPEN.INC, MSDOS 6.0, 1991
  2963                                  ;============================================================================
  2964                                  ; 11/07/2018 - Retro DOS v3.0
  2965                                  ; 25/04/2019 - Retro DOS v4.0
  2966                                  
  2967                                  struc FEI	; FASTOPEN_EXTENDED_INFO
  2968 00000000 ??                      .dirpos:	resb 1
  2969 00000001 ????????                .dirsec:	resd 1 ; MSDOS 6.0
  2970                                  ;.dirsec:	resw 1 ; MSDOS 3.3
  2971 00000005 ????                    .clusnum:	resw 1
  2972 00000007 ????                    .lastent:	resw 1	; for search first ; MSDOS 6.0
  2973 00000009 ????                    .dirstart:	resw 1	; for search first ; MSDOS 6.0
  2974                                  .size:
  2975                                  endstruc
  2976                                  
  2977                                  ; 23/07/2018
  2978                                  ;FASTOPEN NAME CACHING Subfunctions
  2979                                  FONC_Look_up	equ	1
  2980                                  FONC_insert	equ	2
  2981                                  FONC_delete	equ	3
  2982                                  FONC_update	equ	4
  2983                                  FONC_purge	equ	5	;reserved for the future use.
  2984                                  FONC_Rename	equ	6	;AN001
  2985                                  
  2986                                  ; 27/07/2018
  2987                                  ;FastOpen Data Structure
  2988                                  struc fastopen_entry	;Fastopen Entry pointer in DOS
  2989 00000000 ????                    .entry_size:	resw 1	; = 4	; size of the following
  2990 00000002 ????????                .name_caching:	resd 1
  2991                                  ; MSDOS 6.0
  2992                                  ;.fatchain_caching: resd 1	;reserved for future use
  2993                                  .size:
  2994                                  endstruc
  2995                                  
  2996                                  ; 27/07/2018
  2997                                  ;Equates used in DOS.
  2998                                  FastOpen_Set	       equ     00000001b
  2999                                  FastOpen_Reset	       equ     11111110b
  3000                                  Lookup_Success	       equ     00000010b
  3001                                  Lookup_Reset	       equ     11111101b
  3002                                  Special_Fill_Set       equ     00000100b
  3003                                  Special_Fill_Reset     equ     11111011b
  3004                                  No_Lookup	       equ     00001000b
  3005                                  Set_For_Search	       equ     00010000b	;DCR 167
  3006                                  
  3007                                  ; 09/08/2018 
  3008                                  ; (FASTXXXX.INC, MSDOS 6.0, 1991)
  3009                                  ; Fastxxx equates
  3010                                  FastOpen_ID	   equ	   1
  3011                                  FastSeek_ID	   equ	   2
  3012                                  Fast_yes	   equ	   10000000B ; 80h ; fastxxx flag
  3013                                  
  3014                                  ;Structure definitions
  3015                                  ;
  3016                                  struc Fasttable_Entry	 ; Fastxxx  Entry pointer in DOS
  3017 00000000 ????                    .Fast_Entry_Num: resw 1	 ; number of entries
  3018 00000002 ????????                .FastOpen_Seek:	 resd 1	 ; fastopen & fastseek entry address
  3019                                  endstruc
  3020                                  
  3021                                  ;============================================================================
  3022                                  ; LOCK.INC, MSDOS 6.0, 1991
  3023                                  ;============================================================================
  3024                                  ; 14/07/2018 - Retro DOS v3.0
  3025                                  
  3026                                  ;**	LOCK.INC - Definitions for Record Locking
  3027                                  
  3028                                  ;**	LOCK functions
  3029                                  
  3030                                  LOCK_ALL	    equ    0
  3031                                  UNLOCK_ALL	    equ    1
  3032                                  LOCK_MUL_RANGE	    equ    2
  3033                                  UNLOCK_MUL_RANGE    equ    3
  3034                                  LOCK_READ	    equ    4
  3035                                  WRITE_UNLOCK	    equ    5
  3036                                  LOCK_ADD	    equ    6
  3037                                  
  3038                                  ;**	Structure for Lock buffer
  3039                                  
  3040                                  struc LockBuf
  3041 00000000 ????????                .Lock_position:	resd 1		; file position for LOCK
  3042 00000004 ????????                .Lock_length:	resd 1		; number of bytes to LOCK
  3043                                  endstruc
  3044                                  
  3045                                  ;============================================================================
  3046                                  ; DPL.ASM, MSDOS 6.0, 1991
  3047                                  ;============================================================================
  3048                                  ; 04/08/2018 - Retro DOS v3.0
  3049                                  
  3050                                  ; (SRVCALL.ASM)
  3051                                  
  3052                                  struc DPL
  3053 00000000 ????                    .AX:	resw	1	; AX register
  3054 00000002 ????                    .BX:	resw	1	; BX register
  3055 00000004 ????                    .CX:	resw	1	; CX register
  3056 00000006 ????                    .DX:	resw	1	; DX register
  3057 00000008 ????                    .SI:	resw	1	; SI register
  3058 0000000A ????                    .DI:	resw	1	; DI register
  3059 0000000C ????                    .DS:	resw	1	; DS register
  3060 0000000E ????                    .ES:	resw	1	; ES register
  3061 00000010 ????                    .rsrvd: resw	1	; Reserved
  3062 00000012 ????                    .UID:	resw	1	; User (Machine) ID (0 = local macine)
  3063 00000014 ????                    .PID:	resw	1	; Process ID (0 = local user PID)
  3064                                  .size:
  3065                                  endstruc
  3066                                   
  3067                                  ;----------------------------------------------------------------------------
  3068                                  ; DOSDATA
  3069                                  ;----------------------------------------------------------------------------
  3070                                  ;============================================================================
  3071                                  ; 24/04/2019 - Retro DOS v4.0
  3072                                  
  3073                                  DosDataSg equ 3 ; DOS Data Segment address (dw in 'retrodos4.s')
  3074                                  		; ((just after resident IO.SYS code&data))
  3075                                  
  3076                                  ;============================================================================
  3077                                  ; WIN386.INC, MSDOS 6.0, 1991
  3078                                  ;============================================================================
  3079                                  ; 24/04/2019 - Retro DOS 4.0
  3080                                  
  3081                                  ;
  3082                                  ;  Symbols and structures relating to WIN386 support.
  3083                                  ;
  3084                                  ;  Used by files in both the DOS and the BIOS.
  3085                                  ;
  3086                                  ;  Created: 7-13-89 by MRW
  3087                                  ;
  3088                                  
  3089                                  ; WIN386 broadcast int 2fh multiplex number and subfunction numbers
  3090                                  
  3091                                  MultWin386		equ     16h	; Int 2f multiplex number
  3092                                  
  3093                                  Win386_Init		equ	05h	; Win386 initialization
  3094                                  Win386_Exit		equ	06h	; Win386 exit
  3095                                  Win386_Devcall		equ	07h	; Win386 device call out
  3096                                  Win386_InitDone		equ	08h	; Win386 initialization is complete
  3097                                  
  3098                                  ; When Win386_Devcall is broadcast, BX is the Device ID. DOS must 
  3099                                  ; answer call outs from the DOSMGR
  3100                                  
  3101                                  Win386_DOSMGR		equ	15H
  3102                                  
  3103                                  ; The following structures are used to communicate instance data to 
  3104                                  ; Win386 from the DOS and the BIOS. See Win386 API documentation
  3105                                  ; (chapter 3, "Call Out Interfaces") for further description.
  3106                                  
  3107                                  struc Win386_SIS	; Startup Info Structure
  3108 00000000 ????                     .Version:		resb	2	; db 3, 0
  3109 00000002 ????????                 .Next_Dev_Ptr:		resd	1	; pointer to next SIS in list
  3110 00000006 ????????                 .Virt_Dev_File_Ptr:	resd	1
  3111 0000000A ????????                 .Reference_Data:	resd	1
  3112 0000000E ????????                 .Instance_Data_Ptr:	resd	1	; pointer to instance data array
  3113                                  endstruc
  3114                                  
  3115                                  size_of_Win386_SIS equ 18 ; 24/04/2019 - Retro DOS v4.0
  3116                                  
  3117                                  struc Win386_IIS	; Instance Item Structure
  3118 00000000 ????????                .Ptr:			resd	1	; pointer to an instance item
  3119 00000004 ????                    .Size:			resw	1	; size of an instance item
  3120                                  endstruc
  3121                                  
  3122                                  size_of_Win386_IIS equ 6 ; 24/04/2019 - Retro DOS v4.0
  3123                                  
  3124                                  ;Win386 DOSMGR function return values to indicate operation done
  3125                                  
  3126                                  WIN_OP_DONE		equ	0B97Ch	; 
  3127                                  DOSMGR_OP_DONE		equ	0A2ABh	;
  3128                                  
  3129                                  ;M021
  3130                                  ; WInoldap callout multiplex number
  3131                                  
  3132                                  WINOLDAP		equ	46h	;
  3133                                  
  3134                                  ;============================================================================
  3135                                  ;----------------------------------------------------------------------------
  3136                                  ; DOSCODE
  3137                                  ;----------------------------------------------------------------------------
  3138                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3139                                  
  3140                                  ;============================================================================
  3141                                  ; MSHEAD.ASM (MSDOS 6.0, 1991)
  3142                                  ;============================================================================
  3143                                  ; 16/07/2018 - Retro DOS 3.0
  3144                                  ;----------------------------------------------------------------------------
  3145                                  ; 24/04/2019 - Retro DOS 4.0
  3146                                  
  3147                                  ; MSDOS 6.0
  3148                                  ;----------------------------------------------------------------------------
  3149                                  ; FILE : ORIGIN.INC
  3150                                  ;----------------------------------------------------------------------------
  3151                                  ; This is included in origin.asm and mshead.asm. Contains the equate that
  3152                                  ; is used for ORGing the DOS code.
  3153                                  ;
  3154                                  ; Brief Description of the necessacity of this ORG:
  3155                                  ; -------------------------------------------------
  3156                                  ;
  3157                                  ; A special problem exits when running out of the HMA. The HMA starts at 
  3158                                  ; address FFFF:10. There is no place in the HMA with an offset of zero.
  3159                                  ; This means programs running out off the HMA must use non-zero offset base
  3160                                  ; addresses. It also means that if we're running multiple programs from the
  3161                                  ; HMA, the base offset of each segment must atleast be as big as all of the
  3162                                  ; HMA segments that precede it.
  3163                                  ; 
  3164                                  ; One solution to this problem to ORG each module at 64K minus its size.
  3165                                  ; For instance a code segment 1234h bytes in length would org'd at edcbh.
  3166                                  ; This gives max. flexibility regarding it's location in the HMA. By 
  3167                                  ; selecting segment values between f124h and ffffh it could be located 
  3168                                  ; anywhere in the HMA. The problem with this is that programs with such 
  3169                                  ; high ORGs would not be able to run in low RAM.
  3170                                  ;
  3171                                  ; A compromise solution is to set the ORG address somewhere between 0010h
  3172                                  ; and ffffh - their size. In the particular case of the BIOS and the DOS 
  3173                                  ; the following solution has been implemented:
  3174                                  ;
  3175                                  ; The Bios Code segment will have a very small offset and run at the very
  3176                                  ; front of the HMA, after the VDISK header. THE Dos Code segment will have 
  3177                                  ; a base offset of (700+<min. size off RAM based BIOS>+<min. size of the DOS
  3178                                  ; DATA segment when DOS is running low>). This will reflect the lowest 
  3179                                  ; possible physical address at which DOS code will run, while still providing
  3180                                  ; max. possible flexibility in HMA positioning. This offset MUST NOT be 
  3181                                  ; smaller then that 20+size of Bios Code segment when running high. This is 
  3182                                  ; mostly true.
  3183                                  ;
  3184                                  ; Also this ORG'd value must be communicated to the BIOS. This is done by
  3185                                  ; putting this value after the first jmp instruction in the DOS code in
  3186                                  ; mshead.asm. 
  3187                                  ;
  3188                                  ; In order for the stripz utility to know how many zeroes to be stripped 
  3189                                  ; out, this value is placed at the beginning of the binary in origin.asm.
  3190                                  ;
  3191                                  ; Revision History:
  3192                                  ;
  3193                                  ; Currently this is being done manually. Therefore any change in the DOS DATA
  3194                                  ; Size or the BIOS size should be reflected here. --- Feb 90
  3195                                  ;
  3196                                  ; BDSIZE.INC contains the equates for BIODATASIZE, BIOCODESIZ and DOSDATASIZ.
  3197                                  ; A utility called getsize will obtain the corresponding values from msdos
  3198                                  ; and msbio.map and update the values in BDSIZ.INC if they are different. 
  3199                                  ; DOS should now be built using the batch file makedos.bat which invokes this
  3200                                  ; utility. The FORMAT of BDSIZE.INC should not be changed as getsize is 
  3201                                  ; dependant on that.				  --- Apr 3 '90
  3202                                  ;
  3203                                  ; For ROMDOS, however, there is no need to org the doscode to any location
  3204                                  ; other than zero.  Therefore the stripz utility will not need to be used,
  3205                                  ; so the offset will not need to be included at the beginning of the code
  3206                                  ; segment.  Also, the BIOS can just assume that the resident code begins
  3207                                  ; at offset zero within the segment.
  3208                                  ; 
  3209                                  ;
  3210                                  ;--------------------------------------------------------------------------
  3211                                  
  3212                                  BIODATASTART	EQU	00700h
  3213                                  ;include	bdsize.inc	; this sets the values:
  3214                                  				;	BIODATASIZ
  3215                                  				;	BIOCODESIZ
  3216                                  				;	DOSDATASIZ
  3217                                  
  3218                                  ; 05/12/2022
  3219                                  ;BIODATASIZ EQU 00910H	; 0900h for MSDOS 6.21 IO.SYS
  3220                                  			; 0900h for MSDOS 5.0 IO.SYS
  3221                                  ;BIOCODESIZ EQU 01A70H	; 1A70h for MSDOS 6.21 IO.SYS
  3222                                  			; 1A60h for MSDOS 5.0 IO.SYS
  3223                                  ;DOSDATASIZ EQU 01370H	; 1370h for MSDOS 6.21 IO.SYS
  3224                                  			; 1370h for MSDOS 5.0 IO.SYS
  3225                                  ;ifndef ROMDOS
  3226                                  ;
  3227                                  ;BYTSTART	EQU    	BIODATASTART+BIODATASIZ+BIOCODESIZ+DOSDATASIZ
  3228                                  ;PARASTART	EQU	(BYTSTART + 0FH) AND (NOT 0FH)	
  3229                                  ;
  3230                                  ;else
  3231                                  ;
  3232                                  ;BYTSTART	EQU	0
  3233                                  ;PARASTART	EQU	0
  3234                                  ;
  3235                                  ;endif ; ROMDOS
  3236                                  
  3237                                  ; 24/04/2019 - Retro DOS v4.0 - Modification
  3238                                  ; -----------------------------------------------------------------
  3239                                  ;MSDAT001E equ 136Ah ; 4970 ; for MSDOS 6.21	
  3240                                  ;MSDAT001E equ 1370h ; 4976 ; for Retro DOS v4.0 modif. 25/05/2019	
  3241                                  ;DOSDATASIZE equ MSDAT001E
  3242                                  ; 05/12/2022
  3243                                  ;DOSDATASIZE equ $ ; 29/04/2019 ; -only- for RETRO DOS v4.0 :
  3244                                  ;_PARASTART_ equ DOSDATASIZE ; segment value will point to start of
  3245                                  			    ; of DOSDATA (in low memory) while
  3246                                  			    ; dos/kernel code starts just after 
  3247                                  			    ; this data block ((org = DOSDATASIZE))
  3248                                  			    ; (in low memory or in HMA)	
  3249                                  ; -----------------------------------------------------------------
  3250                                  
  3251                                  ; 04/11/2022	
  3252                                  ; -----------------------------------------------------------------	
  3253                                  ; NOTE:
  3254                                  ; Microsoft dos programmers were calling 'IO.SYS' as dos 'BIOS'
  3255                                  ; (Also, they were calling 'ROMBIOS' as 'ROM' only!)
  3256                                  ; -----------------------------------------------------------------
  3257                                  
  3258                                  ; ----------------------------------------------------------------------------
  3259                                  ; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3260                                  ; ----------------------------------------------------------------------------
  3261                                  ; ----------------------------------------------------------------------------
  3262                                  ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  3263                                  ; ----------------------------------------------------------------------------
  3264                                  
  3265                                  ;-----------------------------------------------------------------------------
  3266                                  ; Start of (PCDOS 7.1) IBMDOS.COM
  3267                                  ;-----------------------------------------------------------------------------
  3268                                  
  3269                                  ;segment .code vstart=3DD0h ; 06/12/2022
  3270                                  ; 29/09/2023
  3271                                  ;segment .code vstart=3DE0h ; 19/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.22)
  3272                                  ; ----------------------------------------------------------------------------
  3273                                  ; 01/01/2024
  3274                                  segment .code vstart=3F10h ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1)
  3275                                  								
  3276                                  ; ============================================================================
  3277                                  
  3278                                  ;[ORG 3DE0h]
  3279                                  
  3280                                  ;[ORG _PARASTART_]     ; [org 136Ah]
  3281                                  
  3282                                  ;[ORG 1370h] ; 25/05/2019 - Retro DOS v4.0
  3283                                  
  3284                                  ; 01/01/2024 - Retro DOS v5.0 
  3285                                  ;[ORG 3F10h] 
  3286                                  
  3287                                  	; 05/12/2022 - RetroDOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3288                                  	;PARASTART equ 3DD0h ; BIOSDATASTART+BIOSDATASIZE
  3289                                  			     ; +BIOSCODESIZE+DOSDATASIZE (rounded up)
  3290                                  	
  3291                                  	; 29/09/2023 
  3292                                  	; 19/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
  3293                                  	;PARASTART equ 3DE0h	; (MSDOS 6.22 MSDOS.SYS)
  3294                                  
  3295                                  	; 01/01/2024 - Retro DOS v4.2 (Modified PCDOS 7.1 IBMDOS.COM)
  3296                                  	PARASTART equ 3F10h	; (PCDOS 7.1 IBMDOS.COM)
  3297                                  
  3298                                  	[ORG PARASTART]	
  3299                                  
  3300                                  _$STARTCODE:
  3301                                  
  3302                                  ;PARASTART:
  3303 00000000 E9D680                          JMP     DOSINIT
  3304                                  
  3305                                  	;dw	PARASTART	; PARASTART = 3DE0h for MSDOS 6.0, 6.22
  3306                                  	; 04/11/2022		; PARASTART = 3DD0h for MSDOS 5.0
  3307 00000003 [0000]                  	dw	_$STARTCODE	; PARASTART = 3F10h for PCDOS 7.1 ; 01/01/2024
  3308                                  
  3309                                  BioDataSeg:
  3310 00000005 7000                    	dw	0070h		; Bios data segment fixed at 70h
  3311                                  
  3312                                  ; DosDSeg is a data word in the DOSCODE segment that is loaded with
  3313                                  ; the segment address of DOSDATA. This is purely an optimization, that
  3314                                  ; allows getting the DOS data segment without going through the 
  3315                                  ; BIOS data segment. It is used by the "getdseg" macro.
  3316                                  
  3317                                  DosDSeg:
  3318 00000007 0000                    	dw	0
  3319                                  	
  3320                                  ;============================================================================
  3321                                  ; MSTABLE.ASM (MSDOS 6.0, 1991)
  3322                                  ;============================================================================
  3323                                  ; 16/07/2018 - Retro DOS 3.0
  3324                                  ; 29/04/2019 - Retro DOS 4.0
  3325                                  
  3326                                  	; (MSDOS version)
  3327                                  	; DOSCODE:3DE9h (MSDOS 6.21, MSDOS.SYS)
  3328                                  	;db	6
  3329                                  	;db	20
  3330                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS) 
  3331                                  	; DOSCODE:3DD9h (MSDOS 5.0, MSDOS.SYS)
  3332                                  	;db	5
  3333                                  	;db	0	
  3334                                  
  3335                                  	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
  3336                                  MSVERS:				; MS-DOS version in hex for $GET_VERSION
  3337 00000009 07                      MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
  3338 0000000A 0A                      MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
  3339                                  
  3340                                  ;;hkn YRTAB & MONTAB moved to DOSDATA in ms_data.asm
  3341                                  ;	I_am	YRTAB,8,<200,166,200,165,200,165,200,165>   ; [SYSTEM]
  3342                                  ;	I_am	MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> ; [SYSTEM]
  3343                                  
  3344                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
  3345                                  ; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
  3346                                  ;
  3347                                  ;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   
  3348                                  ;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 
  3349                                  
  3350                                  ; This is the error code mapping table for INT 21 errors. This table defines
  3351                                  ; those error codes which are "allowed" for each system call. If the error
  3352                                  ; code ABOUT to be returned is not "allowed" for the call, the correct action
  3353                                  ; is to return the "real" error via Extended error, and one of the allowed
  3354                                  ; errors on the actual call.
  3355                                  ;
  3356                                  ; The table is organized as follows:
  3357                                  ;
  3358                                  ;    Each entry in the table is of variable size, but the first
  3359                                  ;       two bytes are always:
  3360                                  ;
  3361                                  ;       Call#,Cnt of bytes following this byte
  3362                                  ;
  3363                                  ; EXAMPLE:
  3364                                  ;       Call 61 (OPEN)
  3365                                  ;
  3366                                  ;       DB      61,5,12,3,2,4,5
  3367                                  ;
  3368                                  ;       61 is the AH INT 21 call value for OPEN.
  3369                                  ;        5 indicates that there are 5 bytes after this byte (12,3,2,4,5).
  3370                                  ;       Next five bytes are those error codes which are "allowed" on OPEN.
  3371                                  ;       The order of these values is not important EXCEPT FOR THE LAST ONE (in
  3372                                  ;       this case 5).  The last value will be the one returned on the call if
  3373                                  ;       the "real" error is not one of the allowed ones.
  3374                                  ;
  3375                                  ; There are a number of calls (for instance all of the FCB calls) for which
  3376                                  ;   there is NO entry.  This means that NO error codes are returned on this
  3377                                  ;   call, so set up an Extended error and leave the current error code alone.
  3378                                  ;
  3379                                  ; The table is terminated by a call value of 0FFh
  3380                                  
  3381                                  ;PUBLIC I21_MAP_E_TAB
  3382                                  	; 10/08/2018
  3383                                  
  3384                                  ; 29/04/2019
  3385                                  ; DOSCODE:3DE9h (MSDOS 6.21, MSDOS.SYS)
  3386                                  ; 04/11/2022
  3387                                  ; DOSCODE:3DDBh	(MSDOS 5.0 MSDOS.SYS)
  3388                                  ; 01/01/2024
  3389                                  ; DOSCODE:3F1Bh	(PCDOS 7.1 IBMDOS.COM)
  3390                                  
  3391                                  I21_MAP_E_TAB:	; LABEL	BYTE
  3392 0000000B 38020102                    DB  INTERNATIONAL,2,error_invalid_function,error_file_not_found
  3393 0000000F 3903030205                  DB  MKDIR,3,error_path_not_found,error_file_not_found,error_access_denied
  3394 00000014 3A041003                    DB  RMDIR,4,error_current_directory,error_path_not_found
  3395 00000018 0205                        DB          error_file_not_found,error_access_denied
  3396 0000001A 3B020203                    DB  CHDIR,2,error_file_not_found,error_path_not_found
  3397 0000001E 3C040302                    DB  CREAT,4,error_path_not_found,error_file_not_found
  3398 00000022 04                          DB          error_too_many_open_files
  3399 00000023 05                          DB          error_access_denied
  3400                                      ; MSDOS 6.0
  3401 00000024 3D0603020C                  DB	OPEN,6,error_path_not_found,error_file_not_found,error_invalid_access
  3402 00000029 04                          DB          error_too_many_open_files
  3403 0000002A 1A05                        DB          error_not_DOS_disk,error_access_denied
  3404                                      ; MSDOS 3.3
  3405                                      ;DB	OPEN,5,error_path_not_found,error_file_not_found,error_invalid_access
  3406                                      ;DB		error_too_many_open_files,error_access_denied
  3407 0000002C 3E0106                      DB  CLOSE,1,error_invalid_handle
  3408 0000002F 3F020605                    DB  READ,2,error_invalid_handle,error_access_denied
  3409 00000033 40020605                    DB  WRITE,2,error_invalid_handle,error_access_denied
  3410 00000037 4103030205                  DB  UNLINK,3,error_path_not_found,error_file_not_found,error_access_denied
  3411 0000003C 42020601                    DB  LSEEK,2,error_invalid_handle,error_invalid_function
  3412 00000040 4304030201                  DB  CHMOD,4,error_path_not_found,error_file_not_found,error_invalid_function
  3413 00000045 05                          DB          error_access_denied
  3414 00000046 44050F0D01                  DB  IOCTL,5,error_invalid_drive,error_invalid_data,error_invalid_function
  3415 0000004B 0605                        DB          error_invalid_handle,error_access_denied
  3416 0000004D 45020604                    DB  XDUP,2,error_invalid_handle,error_too_many_open_files
  3417 00000051 46020604                    DB  XDUP2,2,error_invalid_handle,error_too_many_open_files
  3418                                      ; MSDOS 6.0	
  3419 00000055 47021A0F                    DB  CURRENT_DIR,2,error_not_DOS_disk,error_invalid_drive
  3420                                      ; MSDOS 3.3	
  3421                                      ;DB  CURRENT_DIR,1,error_invalid_drive
  3422 00000059 48020708                    DB  ALLOC,2,error_arena_trashed,error_not_enough_memory
  3423 0000005D 49020709                    DB  DEALLOC,2,error_arena_trashed,error_invalid_block
  3424 00000061 4A03070908                  DB  SETBLOCK,3,error_arena_trashed,error_invalid_block,error_not_enough_memory
  3425 00000066 4B08030102                  DB  EXEC,8,error_path_not_found,error_invalid_function,error_file_not_found
  3426 0000006B 040B0A                      DB          error_too_many_open_files,error_bad_format,error_bad_environment
  3427 0000006E 0805                        DB          error_not_enough_memory,error_access_denied
  3428 00000070 4E03030212                  DB  FIND_FIRST,3,error_path_not_found,error_file_not_found,error_no_more_files
  3429 00000075 4F0112                      DB  FIND_NEXT,1,error_no_more_files
  3430                                      ; MSDOS 6.0
  3431 00000078 5605110302                  DB  RENAME,5,error_not_same_device,error_path_not_found,error_file_not_found
  3432 0000007D 1005                        DB		error_current_directory,error_access_denied
  3433                                      ; MSDOS 3.3
  3434                                      ;DB  RENAME,4,error_not_same_device,error_path_not_found,error_file_not_found
  3435                                      ;DB		error_access_denied
  3436                                      ; MSDOS 6.0	
  3437 0000007F 57040608                    DB  FILE_TIMES,4,error_invalid_handle,error_not_enough_memory
  3438 00000083 0D01                        DB		error_invalid_data,error_invalid_function
  3439                                      ; MSDOS 3.3	
  3440                                      ;DB  FILE_TIMES,2,error_invalid_handle,error_invalid_function
  3441 00000085 580101                      DB  ALLOCOPER,1,error_invalid_function
  3442 00000088 5A040302                    DB  CREATETEMPFILE,4,error_path_not_found,error_file_not_found
  3443 0000008C 0405                        DB          error_too_many_open_files,error_access_denied
  3444 0000008E 5B055003                    DB  CREATENEWFILE,5,error_file_exists,error_path_not_found
  3445 00000092 020405                      DB          error_file_not_found,error_too_many_open_files,error_access_denied
  3446 00000095 5C040601                    DB  LOCKOPER,4,error_invalid_handle,error_invalid_function
  3447 00000099 2421                        DB          error_sharing_buffer_exceeded,error_lock_violation
  3448 0000009B 65020102                    DB  GETEXTCNTRY,2,error_invalid_function,error_file_not_found	;DOS 3.3
  3449 0000009F 66020102                    DB  GETSETCDPG,2,error_invalid_function,error_file_not_found        ;DOS 3.3
  3450 000000A3 680106                      DB  COMMIT,1,error_invalid_handle                                   ;DOS 3.3
  3451 000000A6 67030408                    DB  EXTHANDLE,3,error_too_many_open_files,error_not_enough_memory
  3452 000000AA 01                          DB              error_invalid_function
  3453                                      ; MSDOS 6.0		
  3454 000000AB 6C0A                        DB	ExtOpen,10
  3455 000000AD 03020C                      DB	  error_path_not_found,error_file_not_found,error_invalid_access
  3456 000000B0 045008                      DB		error_too_many_open_files,error_file_exists,error_not_enough_memory
  3457 000000B3 1A0D                        DB		error_not_DOS_disk,error_invalid_data
  3458 000000B5 0105                        DB		error_invalid_function,error_access_denied
  3459 000000B7 69040F0D                    DB	GetSetMediaID,4,error_invalid_drive,error_invalid_data
  3460 000000BB 0105                        DB		error_invalid_function,error_access_denied
  3461                                      ; 01/01/2024
  3462                                      ; PCDOS 7.1				
  3463 000000BD 700101                      db	ExtCountryInfo,1,error_invalid_function 
  3464 000000C0 FF                          DB  0FFh
  3465                                  
  3466                                  ;19/09/2023
  3467                                  ;22/12/2022
  3468                                  ;04/11/2022	
  3469                                  ;29/04/2019 - Retro DOS v4.0
  3470                                  ;============================================================================
  3471                                  ; 	Retro DOS v4.0
  3472                                  ;============================================================================
  3473 000000C1 00                      	db 	0
  3474                                  RETRODOSMSG:
  3475 000000C2 0D0A                    	db	13,10
  3476                                  	;;;;;db	"Retro DOS v4.0 by Erdogan Tan [2019]"
  3477                                  	;;;;db	"Retro DOS v4.0 by Erdogan Tan [2022]"
  3478                                  	;;;db	"Retro DOS v4.1 by Erdogan Tan [2022]" ; 28/12/2022
  3479                                  	;;db	"Retro DOS v4.2 by Erdogan Tan [2022]" ; 30/12/2022
  3480                                  	;db	"Retro DOS v4.2 by Erdogan Tan [2023]"
  3481 000000C4 526574726F20444F53-     	db	"Retro DOS v5.0 by Erdogan Tan [2024]" ; 01/01/2024	 
  3481 000000CD 2076352E3020627920-
  3481 000000D6 4572646F67616E2054-
  3481 000000DF 616E205B323032345D 
  3482 000000E8 0D0A2400                	db	13,10,"$", 0 
  3483                                  
  3484                                  ;============================================================================
  3485                                  ; MSTABLE.ASM, MSDOS 6.0, 1991
  3486                                  ;============================================================================
  3487                                  ; 11/07/2018 - Retro DOS v3.0
  3488                                  
  3489                                  	%define short_addr dw  ; 03/03/2018 - Retro DOS v2.0
  3490                                  align 2
  3491                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 0E00h
  3492                                  
  3493                                  ; Standard Functions
  3494                                  ;DISPATCH  LABEL WORD
  3495                                  DISPATCH:
  3496                                  	; 16/07/2018 - Retro DOS v3.0
  3497                                  	; (MSDOS 3.3)
  3498                                  
  3499                                  ; 29/04/2019
  3500                                  ; DOSCODE:3E9Eh (MSDOS 6.21, MSDOS.SYS)
  3501                                  
  3502                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3503                                  ; DOSCODE:3E8Eh (MSDOS 5.0, MSDOS.SYS)
  3504                                  
  3505                                  ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  3506                                  ; DOSCODE:3FD2h (PCDOS 7.1, IBMDOS.COM)
  3507                                  
  3508 000000EC [0B6C]                          short_addr  _$ABORT			    ;  0      0
  3509 000000EE [421C]                          short_addr  _$STD_CON_INPUT		    ;  1      1
  3510 000000F0 [4B1C]                          short_addr  _$STD_CON_OUTPUT		    ;  2      2
  3511 000000F2 [FD1C]                          short_addr  _$STD_AUX_INPUT		    ;  3      3
  3512 000000F4 [181D]                          short_addr  _$STD_AUX_OUTPUT		    ;  4      4
  3513 000000F6 [1E1D]                          short_addr  _$STD_PRINTER_OUTPUT	    ;  5      5
  3514 000000F8 [891B]                          short_addr  _$RAW_CON_IO		    ;  6      6
  3515 000000FA [B51B]                          short_addr  _$RAW_CON_INPUT		    ;  7      7
  3516 000000FC [6319]                          short_addr  _$STD_CON_INPUT_NO_ECHO	    ;  8      8
  3517 000000FE [BC19]                          short_addr  _$STD_CON_STRING_OUTPUT	    ;  9      9
  3518 00000100 [C819]                          short_addr  _$STD_CON_STRING_INPUT	    ; 10      A
  3519 00000102 [321D]                          short_addr  _$STD_CON_INPUT_STATUS	    ; 11      B
  3520 00000104 [3B1D]                          short_addr  _$STD_CON_INPUT_FLUSH	    ; 12      C
  3521 00000106 [3414]                          short_addr  _$DISK_RESET		    ; 13      D
  3522 00000108 [6F0F]                          short_addr  _$SET_DEFAULT_DRIVE		    ; 14      E
  3523 0000010A [3C24]                          short_addr  _$FCB_OPEN			    ; 15      F
  3524 0000010C [DA1D]                          short_addr  _$FCB_CLOSE			    ; 16     10
  3525 0000010E [5325]                          short_addr  _$DIR_SEARCH_FIRST		    ; 17     11
  3526 00000110 [9925]                          short_addr  _$DIR_SEARCH_NEXT		    ; 18     12
  3527 00000112 [801D]                          short_addr  _$FCB_DELETE		    ; 19     13
  3528 00000114 [9722]                          short_addr  _$FCB_SEQ_READ		    ; 20     14
  3529 00000116 [9B22]                          short_addr  _$FCB_SEQ_WRITE	            ; 21     15
  3530 00000118 [4325]                          short_addr  _$FCB_CREATE		    ; 22     16
  3531 0000011A [461E]                          short_addr  _$FCB_RENAME		    ; 23     17
  3532                                  	; 16/07/2018
  3533                                          ;short_addr _CPMFUNC			    ; 24     18	
  3534 0000011C [8C06]                          short_addr  NO_OP			    ; 24     18
  3535 0000011E [6A0F]                          short_addr  _$GET_DEFAULT_DRIVE		    ; 25     19
  3536 00000120 [5F0F]                          short_addr  _$SET_DMA			    ; 26     1A
  3537                                  
  3538                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3539                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3540                                  ;                                                                          ;
  3541 00000122 [0D13]                          short_addr  _$SLEAZEFUNC		    ; 27     1B
  3542 00000124 [0F13]                          short_addr  _$SLEAZEFUNCDL		    ; 28     1C
  3543                                  ;                                                                          ;
  3544                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3545                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3546                                  
  3547                                          ;short_addr  _CPMFUNC			    ; 29     1D
  3548                                          ;short_addr  _CPMFUNC			    ; 30     1E
  3549                                  
  3550                                  ; 08/07/2018 - Retro DOS v3.0
  3551                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3552                                  
  3553 00000126 [8C06]                  	short_addr  NO_OP			    ; 29     1D
  3554 00000128 [8C06]                  	short_addr  NO_OP			    ; 30     1E
  3555                                  
  3556                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3557                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3558                                  ;                                                                          ;
  3559 0000012A [5A13]                          short_addr  _$GET_DEFAULT_DPB               ; 31     1F
  3560                                  ;                                                                          ;
  3561                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3562                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3563                                          ;short_addr _CPMFUNC			    ; 32     20
  3564                                  
  3565                                  ; 08/07/2018 - Retro DOS v3.0
  3566                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3567                                  
  3568 0000012C [8C06]                  	short_addr  NO_OP			    ; 32     20
  3569                                  
  3570 0000012E [9F22]                          short_addr  _$FCB_RANDOM_READ               ; 33     21
  3571 00000130 [A322]                          short_addr  _$FCB_RANDOM_WRITE              ; 34     22
  3572 00000132 [921D]                          short_addr  _$GET_FCB_FILE_LENGTH	    ; 35     23
  3573 00000134 [681D]                          short_addr  _$GET_FCB_POSITION		    ; 36     24
  3574                                  
  3575                                  ;MAXCALL = ($-DISPATCH)/2 - 1
  3576                                  MAXCALL EQU ($-DISPATCH)/2 - 1
  3577                                  
  3578                                  ; Extended Functions
  3579 00000136 [900F]                          short_addr  _$SET_INTERRUPT_VECTOR	    ; 37     25
  3580                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3581                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3582                                  ;                                                                          ;
  3583 00000138 [6716]                          short_addr  _$CREATE_PROCESS_DATA_BLOCK	    ; 38     26
  3584                                  ;                                                                          ;
  3585                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3586                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3587 0000013A [9322]                          short_addr  _$FCB_RANDOM_READ_BLOCK	    ; 39     27
  3588 0000013C [8F22]                          short_addr  _$FCB_RANDOM_WRITE_BLOCK        ; 40     28
  3589 0000013E [EA12]                          short_addr  _$PARSE_FILE_DESCRIPTOR	    ; 41     29
  3590 00000140 [DA0A]                          short_addr  _$GET_DATE                      ; 42     2A
  3591 00000142 [F70A]                          short_addr  _$SET_DATE                      ; 43     2B
  3592 00000144 [160B]                          short_addr  _$GET_TIME                      ; 44     2C
  3593 00000146 [270B]                          short_addr  _$SET_TIME                      ; 45     2D
  3594 00000148 [DF0C]                          short_addr  _$SET_VERIFY_ON_WRITE           ; 46     2E
  3595                                  
  3596                                  ; Extended functionality group
  3597 0000014A [4C0F]                          short_addr  _$GET_DMA                       ; 47     2F
  3598 0000014C [B60C]                          short_addr  _$GET_VERSION                   ; 48     30
  3599 0000014E [AF6B]                          short_addr  _$KEEP_PROCESS		    ; 49     31
  3600                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3601                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3602                                  ;                                                                          ;
  3603 00000150 [5C13]                          short_addr  _$GET_DPB			    ; 50     32
  3604                                  ;                                                                          ;
  3605                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3606                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3607 00000152 [3D02]                          short_addr  _$SET_CTRL_C_TRAPPING           ; 51     33
  3608 00000154 [4413]                          short_addr  _$GET_INDOS_FLAG                ; 52     34
  3609 00000156 [810F]                          short_addr  _$GET_INTERRUPT_VECTOR          ; 53     35
  3610 00000158 [1F0F]                          short_addr  _$GET_DRIVE_FREESPACE           ; 54     36
  3611 0000015A [BD0F]                          short_addr  _$CHAR_OPER                     ; 55     37
  3612 0000015C [E60C]                          short_addr  _$INTERNATIONAL                 ; 56     38
  3613                                  ; XENIX CALLS
  3614                                  ;   Directory Group
  3615 0000015E [4628]                          short_addr  _$MKDIR			    ; 57     39
  3616 00000160 [6927]                          short_addr  _$RMDIR			    ; 58     3A
  3617 00000162 [B627]                          short_addr  _$CHDIR			    ; 59     3B
  3618                                  ;   File Group
  3619 00000164 [CD79]                          short_addr  _$CREAT			    ; 60     3C
  3620 00000166 [F678]                          short_addr  _$OPEN			    ; 61     3D
  3621 00000168 [2771]                          short_addr  _$CLOSE		 	    ; 62     3E
  3622 0000016A [3872]                          short_addr  _$READ			    ; 63     3F
  3623 0000016C [9E72]                          short_addr  _$WRITE			    ; 64     40
  3624 0000016E [1D7A]                          short_addr  _$UNLINK			    ; 65     41
  3625 00000170 [A372]                          short_addr  _$LSEEK			    ; 66     42
  3626 00000172 [DA79]                          short_addr  _$CHMOD			    ; 67     43
  3627 00000174 [AE28]                          short_addr  _$IOCTL			    ; 68     44
  3628 00000176 [5873]                          short_addr  _$DUP			    ; 69     45
  3629 00000178 [7673]                          short_addr  _$DUP2			    ; 70     46
  3630 0000017A [0527]                          short_addr  _$CURRENT_DIR		    ; 71     47
  3631                                  ;   Memory Group
  3632 0000017C [A26C]                          short_addr  _$ALLOC			    ; 72     48
  3633 0000017E [1C6E]                          short_addr  _$DEALLOC                       ; 73     49
  3634 00000180 [F86D]                          short_addr  _$SETBLOCK                      ; 74     4A
  3635                                  ;   Process Group
  3636 00000182 [8965]                          short_addr  _$EXEC			    ; 75     4B
  3637 00000184 [E76B]                          short_addr  _$EXIT			    ; 76     4C
  3638 00000186 [7F65]                          short_addr  _$WAIT			    ; 77     4D
  3639 00000188 [4F26]                          short_addr  _$FIND_FIRST		    ; 78     4E
  3640                                  ;   Special Group
  3641 0000018A [A326]                          short_addr  _$FIND_NEXT			    ; 79     4F
  3642                                  ; SPECIAL SYSTEM GROUP
  3643                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3644                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3645                                  ;                                                                          ;
  3646 0000018C [A202]                          short_addr  _$SET_CURRENT_PDB		    ; 80     50
  3647 0000018E [AE02]                          short_addr  _$GET_CURRENT_PDB               ; 81     51
  3648 00000190 [5013]                          short_addr  _$GET_IN_VARS                   ; 82     52
  3649 00000192 [7B14]                          short_addr  _$SETDPB			    ; 83     53
  3650                                  ;                                                                          ;
  3651                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3652                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3653 00000194 [DA0C]                          short_addr  _$GET_VERIFY_ON_WRITE	    ; 84     54
  3654                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3655                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3656                                  ;                                                                          ;
  3657 00000196 [5616]                          short_addr  _$DUP_PDB                       ; 85     55
  3658                                  ;                                                                          ;
  3659                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3660                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3661 00000198 [437A]                          short_addr  _$RENAME			    ; 86     56
  3662 0000019A [0A73]                          short_addr  _$FILE_TIMES                    ; 87     57
  3663 0000019C [516E]                          short_addr  _$ALLOCOPER                     ; 88     58
  3664                                  
  3665                                  ; 08/07/2018 - Retro DOS v3.0
  3666                                  ; -------------------------------------------------------------------------;
  3667                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3668                                  
  3669                                  ; Network extention system calls
  3670 0000019E [D10F]                          short_addr  _$GetExtendedError              ; 89     59
  3671 000001A0 [CE7A]                          short_addr  _$CreateTempFile                ; 90     5A
  3672 000001A2 [B67A]                          short_addr  _$CreateNewFile                 ; 91     5B
  3673 000001A4 [AF7C]                          short_addr  _$LockOper                      ; 92     5C
  3674 000001A6 [376F]                          short_addr  _$ServerCall                    ; 93     5D
  3675 000001A8 [4074]                          short_addr  _$UserOper                      ; 94     5E
  3676 000001AA [A573]                          short_addr  _$AssignOper                    ; 95     5F
  3677 000001AC [9178]                          short_addr  _$NameTrans                     ; 96     60
  3678 000001AE [8C06]                  	short_addr  NO_OP			    ; 97     61
  3679 000001B0 [AE02]                          short_addr  _$GET_CURRENT_PDB		    ; 98     62
  3680                                  ; the next call is reserved for hangool sys call
  3681                                  	; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0)
  3682 000001B2 [F10F]                  	short_addr  _$ECS_Call			    ; 99     63
  3683                                  	;short_addr  NO_OP  ;  MSDOS 3.3	    ; 99     63
  3684                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3685                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3686                                  ;                                                                          ;
  3687 000001B4 [BA02]                          short_addr  _$SET_PRINTER_FLAG              ; 100    64
  3688                                  ;                                                                          ;
  3689                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3690                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3691 000001B6 [A30D]                          short_addr  _$GetExtCntry                   ; 101    65
  3692 000001B8 [CD0E]                          short_addr  _$GetSetCdPg                    ; 102    66
  3693 000001BA [7471]                          short_addr  _$ExtHandle                     ; 103    67
  3694 000001BC [5A71]                          short_addr  _$COMMIT                        ; 104    68
  3695                                  
  3696                                  ; 08/07/2018
  3697                                  ; Above system calls are valid for Retro DOS v3.0 (MSDOS 3.3) 
  3698                                  ; Following system calls are valid for Retro DOS v4.0 (MSDOS 6.0)
  3699                                  
  3700                                  ; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0)
  3701 000001BE [5917]                  	short_addr  _$GSetMediaID                   ; 105    69   ;AN000;
  3702 000001C0 [5A71]                  	short_addr  _$COMMIT                        ; 106    6A   ;AN000;
  3703 000001C2 [8C06]                  	short_addr  NO_OP                           ; 107    6B   
  3704                                  						    ; IFS_IOCTL no longer 
  3705                                  						    ; supported
  3706 000001C4 [647B]                  	short_addr  _$Extended_Open                 ; 108    6C   ;AN000;
  3707                                  
  3708                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3709                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3710                                  ;                                                                          ;
  3711                                  ;ifdef ROMEXEC
  3712                                  ;       short_addr  $ROM_FIND_FIRST	   	    ; 109    6D
  3713                                  ;       short_addr  $ROM_FIND_NEXT	   	    ; 110    6E
  3714                                  ;	short_addr  $ROM_EXCLUDE		    ; 111    6F	  ; M078
  3715                                  ;endif
  3716                                  ;                                                                          ;
  3717                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3718                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3719                                  
  3720                                  ; --------------------------------------------------------------------------
  3721                                  
  3722                                  ; 01/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
  3723                                  
  3724 000001C6 [8C06]                  	short_addr NO_OP	; 6Dh, OS/2 "DosMkDir2" - ROM DOS: Find first ROM program
  3725 000001C8 [8C06]                  	short_addr NO_OP	; 6Eh, OS/2 "DosEnumAttrib" - ROM DOS: Find next ROM program
  3726 000001CA [8C06]                  	short_addr NO_OP	; 6Fh, OS/2 "DosQMaxEASize" - ROM DOS: Get/set searched ROM area
  3727 000001CC [690D]                  	short_addr _$ExtCountryInfo ; 70h, MSDOS 7 (WIN 95) - Get/set extended country information
  3728                                  				; GET/SET INTERNATIONALIZATION INFORMATION
  3729 000001CE [0C10]                  	short_addr _$LONGNAME	; 71h, MSDOS 7 (WIN 95) LONG FILENAME FUNCTIONS
  3730 000001D0 [0C10]                  	short_addr _$LONGNAME	; 72h, MSDOS 7 (WIN 95) LFN-FindClose
  3731 000001D2 [1910]                  	short_addr _$FAT32EXT	; 73h, MSDOS 7 - FAT32 extended drive functions
  3732                                  
  3733                                  ;MAXCOM  = ($-DISPATCH)/2 - 1
  3734                                  
  3735                                  MAXCOM  EQU ($-DISPATCH)/2 - 1
  3736                                  
  3737                                  ; 08/07/2018 - Retro DOS v3.0
  3738                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3739                                  
  3740                                  ;	If Installed
  3741                                  
  3742                                  align 2
  3743                                  
  3744                                  ;PUBLIC FOO
  3745                                  
  3746                                  FOO:	; LABEL WORD
  3747 000001D4 [4907]                          short_addr Leave2F
  3748                                  
  3749 000001D6 [D801]                  DTab:	DW DOSTable
  3750                                  
  3751                                  	;PUBLIC FOO,DTAB
  3752                                  
  3753                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 0ED6h
  3754                                  
  3755                                  ; 29/04/2019
  3756                                  ; DOSCODE:3F7Ch (MSDOS 6.21, MSDOS.SYS)
  3757                                  
  3758                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3759                                  ; DOSCODE:3F6Ch (MSDOS 5.0, MSDOS.SYS)
  3760                                  
  3761                                  ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  3762                                  ; DOSCODE:40BEh (PCDOS 7.1, IBMDOS.COM)
  3763                                         
  3764                                  DOSTable:  ; LABEL  WORD
  3765 000001D8 32                              DB	(DOSTableEnd-DOSTable-1)/2 ; db 50 ; 01/01/2024 
  3766 000001D9 [BB09]                          short_addr  DOSInstall          ;   0 install check
  3767 000001DB [4537]                          short_addr  DOS_CLOSE           ;   1   DOS_CLOSE
  3768 000001DD [B20F]                          short_addr  RECSET              ;   2   RECSET
  3769 000001DF [B509]                          short_addr  DosGetGroup         ;   3   Get DOSGROUP
  3770 000001E1 [7A5A]                          short_addr  PATHCHRCMP          ;   4   PATHCHRCMP
  3771 000001E3 [4D1C]                          short_addr  OUTT                ;   5   OUT
  3772 000001E5 [505D]                          short_addr  NET_I24_ENTRY       ;   6   NET_I24_ENTRY
  3773 000001E7 [FD62]                          short_addr  PLACEBUF            ;   7   PLACEBUF
  3774 000001E9 [AD38]                          short_addr  FREE_SFT            ;   8   FREE_SFT
  3775 000001EB [C264]                          short_addr  BUFWRITE            ;   9   BUFWRITE
  3776 000001ED [637D]                          short_addr  SHARE_VIOLATION     ;   10  SHARE_VIOLATION
  3777 000001EF [2233]                          short_addr  SHARE_ERROR         ;   11  SHARE_ERROR
  3778 000001F1 [0C33]                          short_addr  SET_SFT_MODE        ;   12  SET_SFT_MODE
  3779 000001F3 [6C0B]                          short_addr  DATE16              ;   13  DATE16
  3780 000001F5 [FC17]                          short_addr  Idle		;   14      empty slot
  3781 000001F7 [F662]                          short_addr  SCANPLACE           ;   15  SCANPLACE
  3782 000001F9 [FC17]                          short_addr  Idle		;   16      empty slot
  3783 000001FB [C917]                          short_addr  StrCpy              ;   17  StrCpy
  3784 000001FD [E117]                          short_addr  StrLen              ;   18  StrLen
  3785 000001FF [255A]                          short_addr  UCase		;   19  UCase
  3786 00000201 [3A63]                          short_addr  POINTCOMP           ;   20  POINTCOMP
  3787 00000203 [9964]                          short_addr  CHECKFLUSH          ;   21  CHECKFLUSH
  3788 00000205 [A270]                          short_addr  SFFromSFN           ;   22  SFFromSFN
  3789 00000207 [0575]                          short_addr  GetCDSFromDrv       ;   23  GetCDSFromDrv
  3790 00000209 [7704]                          short_addr  Get_User_Stack      ;   24  Get_User_Stack
  3791 0000020B [B074]                          short_addr  GETTHISDRV          ;   25  GetThisDrv
  3792 0000020D [B678]                          short_addr  DriveFromText       ;   26  DriveFromText
  3793 0000020F [130C]                          short_addr  SETYEAR             ;   27  SETYEAR
  3794 00000211 [AC0C]                          short_addr  DSUM                ;   28  DSUM
  3795 00000213 [090C]                          short_addr  DSLIDE              ;   29  DSLIDE
  3796 00000215 [A717]                          short_addr  StrCmp              ;   30  StrCmp
  3797 00000217 [F373]                          short_addr  InitCDS             ;   31  initcds
  3798 00000219 [6F70]                          short_addr  pJFNFromHandle      ;   32  pJfnFromHandle
  3799 0000021B [9178]                          short_addr  _$NameTrans		;   33  $NameTrans
  3800 0000021D [B306]                          short_addr  CAL_LK              ;   34  CAL_LK
  3801 0000021F [B34B]                          short_addr  DEVNAME             ;   35  DEVNAME
  3802 00000221 [FC17]                          short_addr  Idle                ;   36  Idle
  3803 00000223 [EF17]                          short_addr  DStrLen             ;   37  DStrLen
  3804 00000225 [9E18]                          short_addr  NLS_OPEN            ;   38  NLS_OPEN      DOS 3.3
  3805 00000227 [2771]                          short_addr  _$CLOSE		;   39  $CLOSE        DOS 3.3
  3806 00000229 [A418]                          short_addr  NLS_LSEEK           ;   40  NLS_LSEEK     DOS 3.3
  3807 0000022B [3872]                          short_addr  _$READ		;   41  $READ         DOS 3.3
  3808 0000022D [6018]                          short_addr  FastInit            ;   42  FastInit      DOS 3.4  ;AN000;
  3809 0000022F [E118]                          short_addr  NLS_IOCTL           ;   43  NLS_IOCTL     DOS 3.3
  3810 00000231 [D018]                          short_addr  GetDevList          ;   44  GetDevList    DOS 3.3
  3811 00000233 [FE18]                          short_addr  NLS_GETEXT          ;   45  NLS_GETEXT    DOS 3.3
  3812                                          
  3813                                  	; 29/04/2019 - Retro DOS v4.0
  3814 00000235 [0219]                  	short_addr  MSG_RETRIEVAL	;   46  MSG_RETRIEVAL DOS 4.0  ;AN000;
  3815                                  
  3816 00000237 [8C06]                  	short_addr  NO_OP		;   M006: 47  no longer supported
  3817                                  ;*** 	short_addr  Fake_Version	;   47  Fake_Version  DOS 4.0  ;AN006;
  3818                                  
  3819                                  	; -------------------------------
  3820                                  
  3821                                  	; 01/01/2024 - Retro DOS v5.0 (PCDOS 7.1)
  3822 00000239 [FD48]                  	short_addr  int_2Fh_1230h	;   48
  3823                                  				; FIND SFT ENTRY IN INTERNAL FILE TABLES
  3824 0000023B [6E09]                  	short_addr  int_2Fh_1231h	;   49
  3825                                  				; SET/CLEAR REPORT WINDOWS TO DOS PROGRAMS FLAG	
  3826                                  
  3827                                  DOSTableEnd:  ; LABEL BYTE
  3828                                  
  3829                                  	;ENDIF
  3830                                  
  3831                                  ; ----------------------------------------------------------------------------
  3832                                  ; BREAK   <Copyright notice and version>
  3833                                  ; ----------------------------------------------------------------------------
  3834                                  
  3835                                  ;CODSTRT EQU	$
  3836                                  
  3837                                  ; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
  3838                                  ; (MSTABLE.ASM, MSDOS 6.0, 1991)
  3839                                  
  3840                                  ; NOTE WARNING: This declaration of HEADER must be THE LAST thing in this
  3841                                  ;       module. The reason is so that the data alignments are the same in
  3842                                  ;       IBM-DOS and MS-DOS up through header.
  3843                                  
  3844                                  	;PUBLIC	HEADER
  3845                                  
  3846                                  HEADER:	; LABEL	BYTE
  3847                                          ;IF	DEBUG
  3848                                          ;DB	13,10,"Debugging DOS version "
  3849                                          ;DB	MAJOR_VERSION + "0"
  3850                                          ;DB	"."
  3851                                          ;DB	(MINOR_VERSION / 10) + "0"
  3852                                          ;DB	(MINOR_VERSION MOD 10) + "0"
  3853                                          ;ENDIF
  3854                                  
  3855                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3856                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
  3857                                  %if 0
  3858                                          ;IF	NOT IBM
  3859                                          DB	13,10,"MS-DOS version "
  3860                                          DB	MAJOR_VERSION + "0"
  3861                                          DB	"."
  3862                                          DB	(MINOR_VERSION / 10) + "0"
  3863                                          ;DB	(MINOR_VERSION MOD 10) + "0"
  3864                                          DB	(MINOR_VERSION % 10) + "0"
  3865                                  
  3866                                          ;IF	HIGHMEM
  3867                                          ;DB	"H"
  3868                                          ;ENDIF
  3869                                  
  3870                                  	;DB	13,10,"Copyright 1981,82,83,84,88 Microsoft Corp.",13,10,"$"
  3871                                  	; 30/04/2019 - Retro DOS v4.0
  3872                                  	DB	13,10,"Copyright 1981-1993 Microsoft Corp.",13,10,"$"	
  3873                                  
  3874                                  	;ENDIF
  3875                                  
  3876                                  %endif
  3877                                  
  3878                                  ;IF DEBUG
  3879                                  ;	DB	13,10,"$"
  3880                                  ;ENDIF
  3881                                  
  3882                                  ;include copyrigh.inc
  3883                                  
  3884                                  ; DOSCODE:3FDDh (MSDOS 6.21, MSDOS.SYS)
  3885                                  
  3886                                  	;DB	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
  3887                                  	;DB	"Licensed Material - Property of Microsoft "
  3888                                  	;DB	"All rights reserved "
  3889                                  
  3890                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3891                                  ; DOSCODE:3FCDh (MSDOS 5.0, MSDOS.SYS)
  3892                                  
  3893                                  ; 28/12/2022 - Retro DOS v4.1
  3894                                  %if 0
  3895                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  3896                                  ms_copyright:
  3897                                  	db	'MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp '
  3898                                  	db	'Licensed Material - Property of Microsoft '
  3899                                  	db	'All rights reserved '
  3900                                  
  3901                                  %endif
  3902                                  	;; 28/12/2022 - Retro DOS v4.1
  3903                                  ;ms_copyright:	
  3904                                    	;db	13,10,"MS DOS Version 5.0"
  3905                                  	;db	13,10,"Copyright 1981-1991 Microsoft Corp.",13,10,"$",0	
  3906                                  
  3907                                  ;	; 21/09/2023 - Retro DOS v4.2 MSDOS.SYS
  3908                                  ;	; (MSDOS 6.22 MSDOS.SYS - DOSCODE:3FDDh (File offset: 509))
  3909                                  ;ms_copyright:
  3910                                  ;	db 'MS DOS Version 6 (C)Copyright 1981-1994 Microsoft Corp '
  3911                                  ;	db 'Licensed Material - Property of Microsoft All rights reserved '
  3912                                  
  3913                                  	; 01/01/2024 - Retro DOS v5.0
  3914                                  	
  3915                                  	; 20/09/2023 - Retro DOS v4.2
  3916                                  ;ms_copyright:	
  3917                                  	;db	13,10,"MS DOS Version 6.22"
  3918                                  	;db	13,10,"Copyright 1981-1994 Microsoft Corp.",13,10,"$",0	
  3919                                  
  3920                                  ;============================================================================
  3921                                  ; MSCODE.ASM
  3922                                  ;============================================================================
  3923                                  
  3924                                  ; Retro DOS v2.0 (NASM 2.11) source code modifications by Erdogan Tan
  3925                                  ; 03/03/2018
  3926                                  
  3927                                  ;
  3928                                  ; MSCODE.ASM -- MSDOS code
  3929                                  ;
  3930                                  
  3931                                  ;INCLUDE DOSSEG.ASM
  3932                                  ;INCLUDE STDSW.ASM
  3933                                  
  3934                                  ;CODE    SEGMENT BYTE PUBLIC  'CODE'
  3935                                  ;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  3936                                  
  3937                                  ;.xcref
  3938                                  ;INCLUDE DOSSYM.ASM
  3939                                  ;INCLUDE DEVSYM.ASM
  3940                                  ;.cref
  3941                                  ;.list
  3942                                  
  3943                                  ;IFNDEF  KANJI
  3944                                  ;KANJI   EQU     0       ; FALSE
  3945                                  ;ENDIF
  3946                                  
  3947                                  ;IFNDEF  IBM
  3948                                  ;IBM     EQU     0
  3949                                  ;ENDIF
  3950                                  
  3951                                  ;IFNDEF  HIGHMEM
  3952                                  ;HIGHMEM  EQU     0
  3953                                  ;ENDIF
  3954                                  
  3955                                          ;i_need  USER_SP,WORD
  3956                                          ;i_need  USER_SS,WORD
  3957                                          ;i_need  SAVEDS,WORD
  3958                                          ;i_need  SAVEBX,WORD
  3959                                          ;i_need  INDOS,BYTE
  3960                                          ;i_need  NSP,WORD
  3961                                          ;i_need  NSS,WORD
  3962                                          ;i_need  CURRENTPDB,WORD
  3963                                          ;i_need  AUXSTACK,BYTE
  3964                                          ;i_need  CONSWAP,BYTE
  3965                                          ;i_need  IDLEINT,BYTE
  3966                                          ;i_need  NOSETDIR,BYTE
  3967                                          ;i_need  ERRORMODE,BYTE
  3968                                          ;i_need  IOSTACK,BYTE
  3969                                          ;i_need  WPERR,BYTE
  3970                                          ;i_need  DSKSTACK,BYTE
  3971                                          ;i_need  CNTCFLAG,BYTE
  3972                                          ;i_need  LEAVEADDR,WORD
  3973                                          ;i_need  NULLDEVPT,DWORD
  3974                                  
  3975                                          ;IF NOT IBM
  3976                                          ;i_need  OEM_HANDLER,DWORD
  3977                                          ;ENDIF
  3978                                  
  3979                                          ;EXTRN   DSKSTATCHK:NEAR,GETBP:NEAR,DSKREAD:NEAR,DSKWRITE:NEAR
  3980                                  
  3981                                  ;============================================================================
  3982                                  ; MSDISP.ASM, MSDOS 6.0, 1991
  3983                                  ;============================================================================
  3984                                  ; 11/07/2018 - Retro DOS v3.0
  3985                                  ; 01/05/2019 - Retro DOS v4.0
  3986                                  
  3987                                  ; DosCode SEGMENT
  3988                                  
  3989                                  ; ==========================================================================
  3990                                  ;
  3991                                  ; $Set_CTRL_C_Trapping
  3992                                  ;
  3993                                  ; Function:
  3994                                  ;	Enable disable ^C checking in dispatcher
  3995                                  ;
  3996                                  ; Inputs:
  3997                                  ;		AL = 0 read ^C status
  3998                                  ;		AL = 1 Set ^C status, DL = 0/1 for ^C off/on
  3999                                  ;		AL = 2 Set ^C status to contents of DL.	Output is old state.
  4000                                  ;		AL = 5 get DOS boot drive
  4001                                  ;		AL = 6 Get version number
  4002                                  ;			RETURNS:
  4003                                  ;				BH = Minor version number
  4004                                  ;				BL = Major version number
  4005                                  ;				DL = DOS internal revision
  4006                                  ;				DH = DOS type flags
  4007                                  ;					Bit 3 	- DOS in ROM
  4008                                  ;					Bit 4 	- DOS in HMA
  4009                                  ;					Bit 0-2, 5-7 - Reserved
  4010                                  ; Outputs:
  4011                                  ;		If AL = 0 then DL = 0/1 for ^C off/on
  4012                                  ;
  4013                                  ; History:
  4014                                  ;      removed	AL = 3 Get CPSW state to DL	    DOS 3.4
  4015                                  ;      removed	AL = 4 Set CPSW state from DL	    DOS 3.4
  4016                                  ; ==========================================================================
  4017                                  
  4018                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4019                                  ; DOSCODE:4045h (MSDOS 5.0, MSDOS.SYS)
  4020                                  
  4021                                  ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  4022                                  ; DOSCODE:4123h (PCDOS 7.1, IBMDOS.COM)
  4023                                  
  4024                                  _$SET_CTRL_C_TRAPPING:
  4025                                  	; 01/05/2019 - Retro DOS v4.0
  4026                                  
  4027 0000023D 3C07                    	cmp	al,7	; 01/01/2024 - Retro DOS v5.0
  4028                                  	;cmp	AL,6			; Is this a valid subfunction?
  4029 0000023F 7603                    	jbe	short scct_1		; If yes continue processing
  4030                                  
  4031 00000241 B0FF                    	mov	AL,0FFh			; Else set AL to -1 and
  4032 00000243 CF                      	iret
  4033                                  scct_1:
  4034 00000244 1E                      	push	DS
  4035                                  
  4036                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4037 00000245 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4038                                  	
  4039 0000024A 50                      	push	AX			; DL only register that can change
  4040 0000024B 56                      	push	SI
  4041                                  
  4042 0000024C BE[3703]                	mov	SI,CNTCFLAG		; DS:SI --> Ctrl C Status byte
  4043 0000024F 30E4                    	xor	AH,AH			; Clear high byte of AX
  4044 00000251 09C0                    	or	AX,AX			; Check for subfunction 0
  4045 00000253 7504                    	jnz	short scct_2		; If not 0 jmp to next check
  4046                                  
  4047 00000255 8A14                    	mov	DL,[SI]			; Else move current ctrl C status
  4048 00000257 EB32                    	jmp	SHORT scct_9s		; into DL and jmp to exit
  4049                                  scct_2:
  4050 00000259 48                      	dec	AX			; Now dec AX and see if it was 1
  4051 0000025A 7507                    	jnz	short scct_3		; If not 0 it wasn't 1 so do next chk
  4052                                  
  4053 0000025C 80E201                  	and	DL,1			; Else mask off bit 0 of DL and
  4054 0000025F 8814                    	mov	[SI],DL			; save it as new Ctrl C status
  4055 00000261 EB28                    	jmp	SHORT scct_9s		; Jmp to exit
  4056                                  scct_3:
  4057 00000263 48                      	dec	AX			; Dec AX again to see if it was 2
  4058 00000264 7507                    	jnz	short scct_4		; If not 0 wasn't 2 so go to next chk
  4059                                  
  4060 00000266 80E201                  	and	DL,1			; Else mask off bit 0 of DL and
  4061 00000269 8614                    	xchg	[SI],DL			; Exchange DL with old status byte
  4062 0000026B EB1E                    	jmp	SHORT scct_9s		; Jump to exit (returning old status)
  4063                                  scct_4:
  4064 0000026D 3C03                    	cmp	al,3 ; 01/01/2024
  4065                                  	;cmp	AX,3 			; Test for 5 after it was dec twice
  4066 0000026F 7506                    	jne	short scct_5		; If not equal then not get boot drv
  4067 00000271 8A16[6900]              	mov	DL,[BOOTDRIVE]		; Else return boot drive in DL
  4068 00000275 EB14                    	jmp	SHORT scct_9s		; Jump to exit (returning boot drive)
  4069                                  scct_5:
  4070                                  	; 01/01/2024 - Retro DOS v5.0
  4071 00000277 7212                    	jb	short scct_9s ; PCDOS 7.1
  4072                                  	;
  4073 00000279 3C04                    	cmp	al,4 ; 01/01/2024
  4074                                  	;cmp	AX,4 			; Test for 6 after it was dec twice
  4075                                  	;jne	short scct_9s		; If not equal then not get version
  4076 0000027B 7512                    	jne	short scct_6 ; 01/01/2024 ; PCDOS 7.1	
  4077                                  
  4078                                  	;mov	BX,(Minor_Version SHL 8) + Major_Version
  4079                                  
  4080                                  	;;mov	bx,1406h ; 6.20	; DOSCODE:4092h (MSDOS 6.21, MSDOS.SYS)
  4081                                  	;;mov	bx,1606h ; 6.22	; DOSCODE:4092h (MSDOS 6.22, MSDOS.SYS)
  4082                                  
  4083                                  	;mov	bx,0A07h ; 7.10	; DOSCODE:4163h (PCDOS 7.1, IMBDOS.COM)
  4084 0000027D BB070A                  	mov	bx,(MINOR_VERSION<<8)+MAJOR_VERSION  ; true dos version
  4085                                  	
  4086                                  	;mov	dl,0			; revision 0
  4087                                  	;mov	DL,DOSREVNM ; 0
  4088                                  
  4089                                  	;xor	dh,dh			; assume vanilla DOS
  4090                                  	; 01/01/2024
  4091 00000280 BA0000                  	mov	dx,0	
  4092 00000283 3836[870D]              	cmp	byte [DosHasHMA],dh ; 0
  4093                                  	;cmp	byte [DosHasHMA],0	; is DOS in HMA?  (M021)
  4094                                  	;;je	short @F
  4095                                  	;je	short scct_6
  4096 00000287 7402                    	je	short scct_9s ; 01/01/2024	
  4097                                  	; 01/01/2024
  4098 00000289 B610                    	mov	dh,10h			; version flags bit 4
  4099                                  	;or	DH,DOSINHMA ; 10h	; 'DOS in HMA' status
  4100                                  ;@@:
  4101                                  ;scct_6:
  4102                                  ;ifdef ROMDOS
  4103                                  ;	or	DH,DOSINROM ; 08h
  4104                                  ;endif ; ROMDOS
  4105                                  
  4106                                  	; 01/01/2024 (PCDOS 7.1)
  4107                                  	;jmp	short short scct_9s
  4108                                  
  4109                                  	; 01/01/2024
  4110                                  ;scct_6:
  4111                                  	; ....
  4112                                  
  4113                                  scct_9s:
  4114 0000028B 5E                      	pop	SI
  4115 0000028C 58                      	pop	AX
  4116 0000028D 1F                      	pop	DS
  4117                                  scct_9f:
  4118 0000028E CF                      	iret
  4119                                  
  4120                                  	; 01/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
  4121                                  scct_6:
  4122 0000028F 8026[8600]DF            	and	byte [DOS_FLAG],0DFh	; clear bit 5 of DOS flag
  4123 00000294 80FA01                  	cmp	dl, 1
  4124 00000297 75F2                    	jne	short scct_9s
  4125 00000299 800E[8600]20            	or	byte [DOS_FLAG],20h	; set bit 5 of DOS flag
  4126 0000029E EBEB                    	jmp	short scct_9s
  4127                                  
  4128                                  SetCtrlShortEntry:			; This allows a conditional entry
  4129                                  					; from main dispatch code
  4130 000002A0 EB9B                    	jmp	SHORT _$SET_CTRL_C_TRAPPING
  4131                                  
  4132                                  ; ==========================================================================
  4133                                  ;
  4134                                  ; The following two routines are dispatched to directly with ints disabled
  4135                                  ; immediately after the int 21h entry.	no DIS state is set.
  4136                                  ;
  4137                                  ; $Set_current_PDB takes BX and sets it to be the current process
  4138                                  ;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
  4139                                  ;
  4140                                  ; ==========================================================================
  4141                                  
  4142                                  _$SET_CURRENT_PDB:
  4143 000002A2 1E                      	push	DS
  4144                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4145 000002A3 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4146 000002A8 891E[3003]              	mov	[CurrentPDB],BX		; Set new PSP segment from caller's BX
  4147 000002AC 1F                      	pop	DS
  4148 000002AD CF                      	iret
  4149                                  
  4150                                  ; ==========================================================================
  4151                                  ;
  4152                                  ; $get_current_PDB returns in BX the current process
  4153                                  ;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
  4154                                  ;
  4155                                  ; ==========================================================================
  4156                                  
  4157                                  _$GET_CURRENT_PDB:
  4158 000002AE 1E                      	push	DS
  4159                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4160 000002AF 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4161 000002B4 8B1E[3003]              	mov	BX,[CurrentPDB]		; Return current PSP segment in BX
  4162 000002B8 1F                      	pop	DS
  4163 000002B9 CF                      	iret
  4164                                  
  4165                                  ; ==========================================================================
  4166                                  ;
  4167                                  ; Sets the Printer Flag to whatever is in AL.
  4168                                  ; NOTE: THIS PROCEDURE IS SUBJECT TO CHANGE!!!
  4169                                  ;
  4170                                  ; ==========================================================================
  4171                                  
  4172                                  _$SET_PRINTER_FLAG:
  4173 000002BA 1E                      	push	ds
  4174                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4175 000002BB 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4176 000002C0 A2[A00A]                	mov	[PRINTER_FLAG],AL 	; Set printer flag from caller's AL
  4177 000002C3 1F                      	pop	ds
  4178 000002C4 CF                      	iret
  4179                                  
  4180                                  ; 01/05/2019 - Retro DOS v4.0
  4181                                  ; 08/07/2018 - Retro DOS v3.0
  4182                                  ; (MSDISP.ASM, MSDOS 6.0, 1991)
  4183                                  
  4184                                  ; ----------------------------------------------------------------------------
  4185                                  ; BREAK   <System call entry points and dispatcher>
  4186                                  ; ----------------------------------------------------------------------------
  4187                                  
  4188                                  ; DOSCODE:40CCh (MSDOS 6.21, MSDOS.SYS)
  4189                                  
  4190                                  ; ==========================================================================
  4191                                  ;
  4192                                  ; The Quit entry point is where all INT 20h's come from. These are old- style
  4193                                  ; exit system calls. The CS of the caller indicates which Process is dying.
  4194                                  ; The error code is presumed to be 0. We simulate an ABORT system call.
  4195                                  ;
  4196                                  ; ==========================================================================
  4197                                  
  4198                                  SYSTEM_CALL:    ; PROC NEAR
  4199                                  
  4200                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4201                                  ; DOSCODE:40BFh (MSDOS 5.0, MSDOS.SYS)
  4202                                  
  4203                                  ;entry	QUIT				
  4204                                  QUIT:				; INT 20H entry point	
  4205                                  	;MOV	AH,0
  4206 000002C5 30E4                    	xor	ah,ah ; 08/07/2018
  4207 000002C7 EB36                    	JMP     SHORT SAVREGS
  4208                                  
  4209                                  ; ---------------------------------------------------------------------------
  4210                                  
  4211                                  	; The system call in AH is out of the range that we know how
  4212                                  	; to handle. We arbitrarily set the contents of AL to 0 and
  4213                                  	; IRET. Note that we CANNOT set the carry flag to indicate an
  4214                                  	; error as this may break some programs compatability.
  4215                                  
  4216                                  BADCALL:
  4217                                          ;MOV	AL,0
  4218 000002C9 30C0                    	xor	al,al ; 08/07/2018
  4219                                  IRETT:	; 06/05/2019
  4220                                  _IRET:
  4221 000002CB CF                              IRET
  4222                                  
  4223                                  ; ---------------------------------------------------------------------------
  4224                                  
  4225                                  ; 01/05/2019 - Retro DOS v4.0
  4226                                  ; DOSCODE:40D3h (MSDOS 6.21 MSDOS.SYS)
  4227                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4228                                  ; DOSCODE:40C6h (MSDOS 5.0 MSDOS.SYS)
  4229                                  
  4230                                  	; An alternative method of entering the system is to perform a
  4231                                  	; CALL 5 in the program segment prefix with the contents of CL
  4232                                  	; indicating what system call the user would like. A subset of
  4233                                  	; the possible system calls is allowed here only the
  4234                                  	; CPM-compatible calls may get dispatched.
  4235                                  
  4236                                  		; System call entry point and dispatcher
  4237                                  CALL_ENTRY:
  4238 000002CC 1E                      	push	DS
  4239                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4240 000002CD 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4241 000002D2 8F06[EC05]              	pop	word [SAVEDS]		; Save original DS
  4242                                  
  4243 000002D6 58                              POP     AX                      ; IP from the long call at 5
  4244 000002D7 58                              POP     AX                      ; Segment from the long call at 5
  4245 000002D8 8F06[8405]              	POP	WORD [USER_SP]		; IP from the CALL 5
  4246                                  
  4247                                  		; Re-order the stack to simulate an interrupt 21.
  4248                                  
  4249 000002DC 9C                      	PUSHF				; Start re-ordering the stack
  4250 000002DD FA                      	CLI
  4251 000002DE 50                              PUSH    AX                      ; Save segment
  4252 000002DF FF36[8405]                      PUSH	WORD [USER_SP]		; Stack now ordered as if INT had been used
  4253                                  	; 04/11/2022
  4254                                  	; DOSCODE:40EAh (MSDOS 6.21 MSDOS.SYS)
  4255                                  	; DOSCODE:40DDh (MSDOS 5.0 MSDOS.SYS)
  4256 000002E3 FF36[EC05]              	push	word [SAVEDS]
  4257 000002E7 1F                      	pop	ds
  4258                                  	;
  4259                                  	;cmp	cl,36
  4260 000002E8 80F924                          CMP     CL,MAXCALL              ; This entry point doesn't get as many calls
  4261 000002EB 77DC                            JA      SHORT BADCALL
  4262 000002ED 88CC                            MOV     AH,CL
  4263                                  	; 08/07/2018
  4264 000002EF EB0E                    	jmp	short SAVREGS
  4265                                  
  4266                                  ; ---------------------------------------------------------------------------
  4267                                  
  4268                                  ; 01/05/2019 - Retro DOS v4.0
  4269                                  ; 01/01/2024 - Retro DOS v5.0
  4270                                  
  4271                                  	; This is the normal INT 21 entry point. We first perform a
  4272                                  	; quick test to see if we need to perform expensive DOS-entry
  4273                                  	; functions. Certain system calls are done without interrupts
  4274                                  	; being enabled.
  4275                                  
  4276                                  	;entry	COMMAND 		; Interrupt call entry point (int 21h)
  4277                                  
  4278                                  ; DOSCODE:40F8h (MSDOS 6.21, MSDOS.SYS)
  4279                                  ; 04/11/2022
  4280                                  ; DOSCODE:40EBh (MSDOS 5.0, MSDOS.SYS)
  4281                                  ; 01/01/2024
  4282                                  ; DOSCODE:41D7h (PCDOS 7.1, IBMDOS.COM)
  4283                                  
  4284                                  COMMAND:
  4285                                  	; 22/12/2022
  4286 000002F1 FA                      	cli
  4287                                  
  4288                                  	; 01/05/2019 - Retro DOS v4.0
  4289                                  	; 08/07/2018 - Retro DOS v3.0
  4290                                  
  4291                                  ; 22/12/2022
  4292                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4293                                  ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  4294                                  
  4295                                  	;IF	NOT IBM
  4296 000002F2 80FCF8                  	CMP	AH,SET_OEM_HANDLER
  4297 000002F5 7203                    	JB	SHORT NOTOEM
  4298 000002F7 E98701                  	JMP	_$SET_OEM_HANDLER
  4299                                  
  4300                                  NOTOEM:
  4301                                  	;ENDIF
  4302                                  
  4303                                  ; DOSCODE:40F8h (MSDOS 6.21, MSDOS.SYS)
  4304                                  ; DOSCODE:40EBh (MSDOS 5.0, MSDOS.SYS)
  4305                                  ; 01/01/2024 - Retro DOS v5.0
  4306                                  ; DOSCODE:41D7h (PCDOS 7.1, IBMDOS.COM)
  4307                                  
  4308                                  	; 22/12/2022
  4309                                  	;cli	; 08/07/2018
  4310                                  	
  4311                                  	; 01/01/2024
  4312                                  _COMMAND: ; MSDOS 3.3 (IBMDOS)
  4313                                  	;;cmp	ah,6Ch  ; MSDOS 6.21
  4314                                  	;cmp	ah,73h	; PCDOS 7.1 ; Max int 21h function call number 
  4315                                  	; 04/11/2022
  4316 000002FA 80FC73                  	CMP     AH,MAXCOM ; 6Ch for MSDOS 6.0 (6.21,6.22) & MSDOS 5.0
  4317                                  			; 73h for PCDOS 7.1	
  4318                                  	;JBE	SHORT SAVREGS
  4319 000002FD 77CA                            JA	SHORT BADCALL ; 08/07/2018
  4320                                  
  4321                                  	; 31/05/2019
  4322                                  
  4323                                  	; The following set of calls are issued by the server at
  4324                                  	; *arbitrary* times and, therefore, must be executed on
  4325                                  	; the user's entry stack and executed with interrupts off.
  4326                                  
  4327                                  SAVREGS:
  4328                                  	; 01/05/2019 - Retro DOS v4.0
  4329                                  	; 10/08/2018
  4330                                  	; 08/07/2018 - Retro DOS v3.0
  4331 000002FF 80FC33                  	cmp	ah,33h			; Check Minimum special case #
  4332                                  	;;je	_$SET_CTRL_C_TRAPPING
  4333                                  	;je	short SetCtrlShortEntry ; If equal jmp directly to function
  4334 00000302 7218                    	jb	short SaveAllRegs	; Not special case so continue	
  4335                                  	; 04/11/2022
  4336 00000304 749A                    	je	short SetCtrlShortEntry ; If equal jmp directly to function
  4337 00000306 80FC64                  	cmp	ah,64h			; Check Max case number
  4338 00000309 7711                    	ja	short SaveAllRegs	; Not special case so continue
  4339 0000030B 74AD                    	je	short _$SET_PRINTER_FLAG ; If equal jmp directly to function
  4340 0000030D 80FC51                  	cmp	ah,51h			; Is this a Get PSP call (51h)?
  4341 00000310 749C                    	je	short _$GET_CURRENT_PDB	; Yes, jmp directly to function
  4342 00000312 80FC62                  	cmp	ah,62h			; Is this a Get PSP call (62h)?
  4343 00000315 7497                    	je	short _$GET_CURRENT_PDB	; Yes, jmp directly to function
  4344 00000317 80FC50                  	cmp     ah,50h			; Is this a Set PSP call (50h) ?
  4345 0000031A 7486                    	je	short _$SET_CURRENT_PDB	; Yes, jmp directly to function
  4346                                  
  4347                                  SaveAllRegs:
  4348                                  	; 01/05/2019 - Retro DOS v4.0
  4349                                  	; 01/01/2024 - Retro DOS v5.0
  4350                                  
  4351 0000031C 06                              push	ES
  4352 0000031D 1E                      	push	DS
  4353 0000031E 55                      	push	BP
  4354 0000031F 57                      	push	DI
  4355 00000320 56                      	push	SI
  4356 00000321 52                      	push	DX
  4357 00000322 51                      	push	CX
  4358 00000323 53                      	push	BX
  4359 00000324 50                      	push	AX
  4360                                  
  4361 00000325 8CD8                    	mov	AX,DS
  4362                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4363 00000327 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4364 0000032C A3[EC05]                	mov	[SAVEDS],AX		; save caller's DS
  4365 0000032F 891E[EA05]              	mov	[SAVEBX],BX
  4366                                  
  4367                                          ;INC     BYTE [INDOS]		; Flag that we're in the DOS
  4368                                  	
  4369                                  	; 08/07/2018 - Retro DOS v3.0
  4370                                  	;xor     ax,ax
  4371                                  	;mov     [USER_ID],ax
  4372                                  	;mov     ax,[CurrentPDB]
  4373                                  	;mov     [PROC_ID],ax
  4374                                  
  4375                                  	; 01/05/2019
  4376                                  
  4377                                  	; Note: Nsp and Nss have to be unconditionally initialized here 
  4378                                  	; even if InDOS is zero. Programs like CROSSTALK 3.7 depend on
  4379                                  	; this!!!
  4380                                  
  4381 00000333 A1[8405]                	MOV     AX,[USER_SP]
  4382 00000336 A3[F205]                        MOV     [NSP],AX
  4383 00000339 A1[8605]                        MOV     AX,[USER_SS]
  4384 0000033C A3[F005]                        MOV     [NSS],AX
  4385                                  
  4386 0000033F 31C0                    	xor	AX,AX ; 0
  4387 00000341 A2[7205]                	mov	[FSHARING],AL		; allow redirection
  4388                                  
  4389 00000344 F606[A110]01            	test	byte [IsWin386],1	; WIN386 patch. Do not update USER_ID
  4390 00000349 7503                    	jnz	short set_indos_flag	; if win386 present
  4391 0000034B A3[3E03]                	mov	[USER_ID],AX
  4392                                  set_indos_flag:
  4393 0000034E FE06[2103]              	INC     BYTE [INDOS]		; Flag that we're in the DOS
  4394                                  
  4395                                  	; 01/01/2024 (PCDOS 7.1 IBMDOS.COM)
  4396 00000352 FE06[DF13]              	inc	byte [INDOS_FLAG]	; duplicated INDOS flag (what for ?)
  4397                                  
  4398 00000356 8926[8405]                      MOV     [USER_SP],SP
  4399 0000035A 8C16[8605]                      MOV     [USER_SS],SS
  4400                                  
  4401 0000035E A1[3003]                	mov	AX,[CurrentPDB]
  4402 00000361 A3[3C03]                	mov	[PROC_ID],AX
  4403 00000364 8ED8                    	mov	DS,AX
  4404 00000366 58                      	pop	AX
  4405 00000367 50                      	push	AX
  4406                                  
  4407                                  	; save user stack in his area for later returns (possibly from EXEC)
  4408                                  
  4409 00000368 89262E00                        MOV     [PDB.USER_STACK],SP	; mov [2Eh], sp
  4410 0000036C 8C163000                        MOV     [PDB.USER_STACK+2],SS	; mov [30h], ss
  4411                                  
  4412                                  	; 18/07/2018
  4413                                  	;mov	byte [CS:FSHARING], 0
  4414                                  
  4415                                  	;MOV     BX,CS			; no holes here.
  4416                                  	;MOV     SS,BX
  4417                                  
  4418                                  	;getdseg <ss>			; ss -> dosdat, already flag is CLI
  4419 00000370 2E8E16[0700]            	mov	ss,[cs:DosDSeg]
  4420                                  					;entry	REDISP
  4421                                  REDISP:
  4422 00000375 BC[A007]                        MOV     SP,AUXSTACK		; Enough stack for interrupts
  4423 00000378 FB                              STI                             ; stack is in our space now...
  4424                                  
  4425 00000379 8CD3                    	mov	bx,ss
  4426 0000037B 8EDB                    	mov	ds,bx
  4427                                  
  4428 0000037D 93                      	xchg	ax,bx
  4429                                  
  4430 0000037E 31C0                    	xor	ax,ax ; 0
  4431                                  
  4432                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4433                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:416Eh  (from org 3DD0h)
  4434                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:417Bh (from org 3DE0h)
  4435                                  
  4436                                  	; (Note: ss: segment prefix was not needed here! ds=ss ! -04/11/2022-)
  4437                                  
  4438                                  	;mov	[ss:EXTOPEN_ON],al ; 0	; Clear extended open flag
  4439                                  	;;and	word [ss:DOS34_FLAG],EXEC_AWARE_REDIR
  4440                                  	;and	word [ss:DOS34_FLAG],800h ; clear all bits except bit 11
  4441                                  	;mov	[ss:CONSWAP],al  ; 0	; random clean up of possibly mis-set flags
  4442                                  	;mov	[ss:NoSetDir],al ; 0	; set directories on search
  4443                                  	;mov	[ss:FAILERR],al ; 0	; FAIL not in progress
  4444                                  	;inc	ax
  4445                                  	;;inc	AL			; AL = 1
  4446                                  	;mov	[ss:IDLEINT],al		; presume that we can issue INT 28h
  4447                                  
  4448                                  	; 15/12/2022
  4449 00000380 A2[F605]                	mov	[EXTOPEN_ON],al ; 0	; Clear extended open flag
  4450                                  	;and	word [DOS34_FLAG],EXEC_AWARE_REDIR
  4451 00000383 8126[1106]0008          	and	word [DOS34_FLAG],800h	; clear all bits except bit 11
  4452 00000389 A2[5703]                	mov	[CONSWAP],al  ; 0	; random clean up of possibly mis-set flags
  4453                                  	;mov	byte [IDLEINT],1
  4454 0000038C A2[4C03]                	mov	[NoSetDir],al ; 0	; set directories on search
  4455 0000038F A2[4A03]                	mov	[FAILERR],al ; 0	; FAIL not in progress
  4456 00000392 40                      	inc	ax
  4457                                  	;inc	al			; AL = 1
  4458 00000393 A2[5803]                	mov	[IDLEINT],al		; presume that we can issue INT 28h
  4459                                  
  4460 00000396 93                      	XCHG	AX,BX			; Restore AX and BX = 1
  4461                                  
  4462 00000397 88E3                    	MOV     BL,AH			
  4463 00000399 D1E3                            SHL     BX,1			; 2 bytes per call in table
  4464                                         
  4465 0000039B FC                      	CLD
  4466                                  		; Since the DOS maintains mucho state information across system
  4467                                  		; calls, we must be very careful about which stack we use.
  4468                                  		; First, all abort operations must be on the disk stack. This
  4469                                  		; is due to the fact that we may be hitting the disk (close
  4470                                  		; operations, flushing) and may need to report an INT 24.
  4471                                          
  4472 0000039C 08E4                    	OR      AH,AH
  4473 0000039E 7416                            JZ      SHORT DSKROUT		; ABORT
  4474                                  
  4475                                          ;CMP	AH,12
  4476                                          ;JBE	SHORT IOROUT		; Character I/O
  4477                                          ;CMP	AH,GET_CURRENT_PDB      ; INT 24h needs GET,SET PDB
  4478                                          ;JZ	SHORT IOROUT
  4479                                          ;CMP	AH,SET_CURRENT_PDB
  4480                                          ;JNZ	SHORT DSKROUT
  4481                                  
  4482                                  		; Second, PRINT and PSPRINT and the server issue
  4483                                  		; GetExtendedError calls at INT 28 and INT 24 time.
  4484                                  		; This call MUST, therefore, use the AUXSTACK.
  4485                                  
  4486                                  	; 10/08/2018
  4487 000003A0 80FC59                  	cmp     ah,GETEXTENDEDERROR ; 59h
  4488 000003A3 7439                    	je      short DISPCALL
  4489                                  	
  4490                                  	; 01/05/2019
  4491                                  	
  4492                                  		; Old 1-12 system calls may be either on the IOSTACK (normal
  4493                                  		; operation) or on the AUXSTACK (at INT 24 time).
  4494                                  
  4495 000003A5 80FC0C                  	cmp     ah,12 ; STD_CON_INPUT_FLUSH ; 0Ch
  4496 000003A8 770C                    	ja      short DSKROUT
  4497                                  
  4498                                  IOROUT:
  4499                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4500                                  	; (ss: prefix was not needed here! ds=ss)
  4501                                  	;cmp	byte [ss:ERRORMODE],0	; Are we in an INT 24h? 
  4502                                  	; 15/12/2022
  4503 000003AA 803E[2003]00            	cmp     BYTE [ERRORMODE],0	; Are we in an INT 24h?
  4504 000003AF 752D                            JNZ     SHORT DISPCALL		; Stay on AUXSTACK if INT 24h
  4505 000003B1 BC[A00A]                        MOV     SP,IOSTACK
  4506 000003B4 EB28                            JMP     SHORT DISPCALL
  4507                                  
  4508                                  		; We are on a system call that is classified as "the rest".
  4509                                  		; We place ourselves onto the DSKSTACK and away we go.
  4510                                  		; We know at this point:
  4511                                  		; *  An INT 24 cannot be in progress. Therefore we reset
  4512                                  		;    ErrorMode and WpErr
  4513                                  		; *  That there can be no critical sections in effect.
  4514                                  		;    We signal the server to remove all the resources.
  4515                                  
  4516                                  DSKROUT:
  4517                                  	; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  4518                                  	; 15/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4519                                  	; 08/07/2018 - Retro DOS v3.0
  4520 000003B6 A3[3A03]                	mov     [USER_IN_AX],ax		; Remember what user is doing
  4521                                  	; 01/01/2024
  4522                                  	;mov	byte [EXTERR_LOCUS],1	; errLOC_Unk (Default)
  4523                                  	;MOV	BYTE [WPERR],-1		; error mode, so good place to
  4524                                  	                   		; make sure flags are reset
  4525 000003B9 C706[2203]FF01          	mov	word [WPERR],1FFh
  4526                                  
  4527 000003BF C606[2003]00            	MOV     BYTE [ERRORMODE],0	; Cannot make non 1-12 calls in
  4528                                  
  4529                                  
  4530                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4531                                  	; (ss: prefix was not needed here! ds=ss)
  4532                                  
  4533                                  	;mov	[ss:USER_IN_AX],ax	; Remember what user is doing
  4534                                  	;mov	byte [ss:EXTERR_LOCUS],1 ; errLOC_Unk (Default)
  4535                                  	;mov	byte [ss:ERRORMODE],0	; Cannot make non 1-12 calls in
  4536                                  	;mov	byte [ss:WPERR],-1	; error mode, so good place to
  4537                                                                          ; make sure flags are reset
  4538 000003C4 50                      	push    ax
  4539 000003C5 B482                    	mov     ah,82h			; Release all resource information
  4540 000003C7 CD2A                    	int     2Ah 		; Microsoft Networks 
  4541                                  				; END DOS CRITICAL SECTIONS 0 THROUGH 7
  4542 000003C9 58                      	pop     ax
  4543                                  
  4544                                  		; Since we are going to be running on the DSKStack and since
  4545                                  		; INT 28 people will use the DSKStack, we must turn OFF the
  4546                                  		; generation of INT 28's.
  4547                                  
  4548                                  	; 15/12/2022
  4549                                  	;mov     byte [ss:IDLEINT],0
  4550                                  	;
  4551                                          ;mov	sp,DSKSTACK
  4552                                  	;test	byte [ss:CNTCFLAG],-1  ; 0FFh
  4553                                          ;jz	short DISPCALL
  4554                                  
  4555 000003CA C606[5803]00            	mov     byte [IDLEINT],0
  4556                                  
  4557 000003CF BC[2009]                	MOV     SP,DSKSTACK
  4558 000003D2 F606[3703]FF            	TEST    BYTE [CNTCFLAG],-1
  4559 000003D7 7405                    	JZ      SHORT DISPCALL
  4560                                  
  4561 000003D9 50                              PUSH    AX
  4562                                          ;invoke	DSKSTATCHK
  4563 000003DA E8B656                          CALL	DSKSTATCHK
  4564 000003DD 58                      	POP     AX
  4565                                  DISPCALL:
  4566                                  	; 01/05/2019 - Retro DOS v4.0
  4567 000003DE 2E8B9F[EC00]            	mov	bx,[CS:BX+DISPATCH]
  4568                                  
  4569                                  	; 15/12/2022
  4570 000003E3 871E[EA05]              	xchg	bx,[SAVEBX]
  4571 000003E7 8E1E[EC05]              	MOV	DS,[SAVEDS]
  4572                                  
  4573                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4574                                  	; (ss: prefix was not needed here! ds=ss)        
  4575                                  	;xchg	bx,[ss:SAVEBX]
  4576                                  	;mov	ds,[ss:SAVEDS]
  4577                                  
  4578 000003EB 36FF16[EA05]            	call	word [SS:SAVEBX] ; near call
  4579                                  
  4580                                  	; The EXEXA20OFF bit of DOS_FLAG will now be unconditionally cleared
  4581                                  	; here. Please see under M003, M009 and M068 tags in dossym.inc
  4582                                  	; for explanation. Also NOTE that a call to ExecReady (ax=4b05) will
  4583                                  	; return to LeaveDos and hence will not clear this bit. This is 
  4584                                  	; because this bit is used to indicate to the next int 21 call that
  4585                                  	; the previous int 21 was an exec.
  4586                                  	;
  4587                                  	; So do not add any code between the call above and the label 
  4588                                  	; LeaveDOS if it needs to be executed even for ax=4b05
  4589                                  
  4590                                  	;;and	byte [ss:DOS_FLAG],~EXECA20OFF
  4591                                  	;and	byte [ss:DOS_FLAG],0FBh ; clear bit 2
  4592                                  
  4593                                  	; 01/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
  4594 000003F0 368026[8600]DB          	and	byte [ss:DOS_FLAG],0DBh ; clear bit 2 and bit 5
  4595                                  
  4596                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4597                                  ; DOSCODE:41F7h
  4598                                  
  4599                                  ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  4600                                  ; DOSCODE:42D4h
  4601                                  
  4602                                  ;entry LEAVE
  4603                                  ;;;_LEAVE:				; Exit from a system call
  4604                                  LeaveDOS: ; 18/07/2018 
  4605                                  ;ASSUME	SS:NOTHING			; User routines may misbehave
  4606 000003F6 FA                      	CLI
  4607                                  
  4608                                  	; 01/05/2019
  4609                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4610 000003F7 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4611 000003FC 803E[8500]00            	cmp	byte [A20OFF_COUNT],0	; M068: Q: is count 0
  4612 00000401 752A                    	jne	short disa20		; M068: N: dec count and turn a20 off
  4613                                  
  4614                                  LeaveA20On:
  4615 00000403 FE0E[2103]                      DEC     BYTE [INDOS]
  4616                                  	
  4617                                  	; 01/01/2024 (PCDOS 7.1 IBMDOS.COM)
  4618 00000407 FE0E[DF13]              	dec	byte [INDOS_FLAG]	; duplicated INDOS flag (what for ?)
  4619                                  
  4620                                          ; 04/11/2022
  4621 0000040B 8E16[8605]              	mov	ss,[USER_SS]
  4622 0000040F 8B26[8405]              	MOV     SP,[USER_SP]
  4623                                  	;MOV	SS,[USER_SS]
  4624 00000413 89E5                    	MOV     BP,SP
  4625                                  	;MOV	[BP.user_AX],AL	
  4626                                          ; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4627                                  	;;mov	[bp+0],al ; MSDOS 5.0 MSDOS.SYS - DOSCODE:4212h	
  4628                                  	;MOV	[BP+user_env.user_AX],AL  ; user_env.user_AX = 0
  4629                                  	
  4630                                  	; 15/12/2022
  4631 00000415 884600                  	MOV	[BP],AL	; mov [bp+0],al
  4632                                  	
  4633                                  	;MOV	AX,[NSP]
  4634                                          ;MOV	[USER_SP],AX
  4635                                          ;MOV	AX,[NSS]
  4636                                          ;MOV	[USER_SS],AX
  4637                                  	; 01/01/2024
  4638 00000418 C406[F005]              	les	ax,[NSS]
  4639 0000041C A3[8605]                	mov	[USER_SS],ax
  4640 0000041F 8C06[8405]              	mov	[USER_SP],es
  4641                                  
  4642 00000423 58                      	pop	AX
  4643 00000424 5B                      	pop	BX
  4644 00000425 59                      	pop	CX
  4645 00000426 5A                      	pop	DX
  4646 00000427 5E                      	pop	SI
  4647 00000428 5F                      	pop	DI
  4648 00000429 5D                      	pop	BP
  4649 0000042A 1F                      	pop	DS
  4650 0000042B 07                      	pop	ES
  4651                                  
  4652 0000042C CF                              IRET
  4653                                  
  4654                                  disa20:	   				; M068 - Start
  4655 0000042D 8B1E[6300]              	mov	bx,[A20OFF_PSP]		; bx = PSP for which a20 to be off'd
  4656 00000431 3B1E[3003]              	cmp	bx,[CurrentPDB]		; Q: do the PSP's match
  4657 00000435 75CC                    	jne	short LeaveA20On	; N: don't clear bit and don't turn 
  4658                                  					;    a20 off
  4659                                  					; Y: turn a20 off and dec a20off_count
  4660 00000437 FE0E[8500]              	dec	byte [A20OFF_COUNT]	; M068 - End
  4661                                   					; Start - M004
  4662 0000043B 1E                      	push	ds			; segment of stub
  4663 0000043C BB[7711]                	mov	bx,disa20_iret		; offset in stub
  4664 0000043F 53                      	push	bx
  4665 00000440 CB                      	retf	  			; go to stub
  4666                                  					; End - M004
  4667                                  ;SYSTEM_CALL ENDP
  4668                                  
  4669                                  ; DOSCODE:424Ch (MSDOS 6.21, MSDOS.SYS)
  4670                                  ; 04/11/2022
  4671                                  ; DOSCODE:423Fh (MSDOS 5.0, MSDOS.SYS)
  4672                                  
  4673                                  ; ==========================================================================
  4674                                  ;
  4675                                  ; Restore_World restores all registers ('cept SS:SP, CS:IP, flags) from
  4676                                  ; the stack prior to giving the user control
  4677                                  ;
  4678                                  ; ==========================================================================
  4679                                  
  4680                                  ; 01/05/2019 - Retro DOS v4.0
  4681                                  
  4682                                          ;procedure restore_world,NEAR
  4683                                  restore_world:
  4684                                  	;getdseg <es>		; es -> dosdata
  4685 00000441 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4686                                  
  4687 00000446 268F06[EE05]                    POP	WORD [ES:RESTORE_TMP]
  4688                                  
  4689 0000044B 58                              POP     AX
  4690 0000044C 5B                              POP     BX
  4691 0000044D 59                              POP     CX
  4692 0000044E 5A                              POP     DX
  4693 0000044F 5E                              POP     SI
  4694 00000450 5F                              POP     DI
  4695 00000451 5D                              POP     BP
  4696 00000452 1F                              POP     DS
  4697                                  
  4698 00000453 26FF26[EE05]                   	jmp	word [ES:RESTORE_TMP]
  4699                                  
  4700                                  ;restore_world	ENDP
  4701                                  
  4702                                  ; 01/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDISP.ASM, 1991)
  4703                                  
  4704                                  ; DOSCODE:4263h (MSDOS 6.21, MSDOS.SYS)
  4705                                  ; 04/11/2022
  4706                                  ; DOSCODE:4256h (MSDOS 5.0, MSDOS.SYS)
  4707                                  
  4708                                  ; ==========================================================================
  4709                                  ;
  4710                                  ; Save_World saves complete registers on the stack
  4711                                  ;
  4712                                  ; ==========================================================================
  4713                                  
  4714                                          ;procedure save_world,NEAR
  4715                                  save_world:
  4716                                  	;getdseg <es>		; es -> dosdata
  4717 00000458 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4718                                  
  4719 0000045D 268F06[EE05]                    POP	WORD [ES:RESTORE_TMP]
  4720                                  
  4721                                  	; 12/05/2019
  4722                                          
  4723 00000462 1E                      	PUSH    DS
  4724 00000463 55                              PUSH    BP
  4725 00000464 57                              PUSH    DI
  4726 00000465 56                              PUSH    SI
  4727 00000466 52                              PUSH    DX
  4728 00000467 51                              PUSH    CX
  4729 00000468 53                              PUSH    BX
  4730 00000469 50                              PUSH    AX
  4731                                  
  4732 0000046A 26FF36[EE05]            	push	word [ES:RESTORE_TMP]
  4733                                  
  4734 0000046F 55                      	push	BP
  4735 00000470 89E5                    	mov	BP,SP
  4736 00000472 8E4614                  	mov	ES,[BP+20]	; es was pushed before call
  4737 00000475 5D                      	pop	BP
  4738                                  	
  4739 00000476 C3                      	retn
  4740                                  
  4741                                  ;save_world	ENDP
  4742                                  
  4743                                  ; 01/05/2019
  4744                                  
  4745                                  ; DOSCODE:4282h (MSDOS 6.21, MSDOS.SYS)
  4746                                  ; 04/11/2022
  4747                                  ; DOSCODE:4275h (MSDOS 5.0, MSDOS.SYS)
  4748                                  
  4749                                  ; ==========================================================================
  4750                                  ;
  4751                                  ; Get_User_Stack returns the user's stack (and hence registers) in DS:SI
  4752                                  ;
  4753                                  ; ==========================================================================
  4754                                  
  4755                                          ;procedure get_user_stack,NEAR
  4756                                  Get_User_Stack:
  4757                                          ;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4758 00000477 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4759 0000047C C536[8405]                      lds	si,[USER_SP]
  4760 00000480 C3                      	retn
  4761                                  
  4762                                  ;get_user_stack  ENDP
  4763                                  
  4764                                  ; 22/12/2022
  4765                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
  4766                                  ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1, IBMDOS.COM)
  4767                                  ;%if 0
  4768                                  
  4769                                  ; ---------------------------------------------------------------------------
  4770                                  ;
  4771                                  ; Set_OEM_Handler -- Set OEM sys call address and handle OEM Calls
  4772                                  ; Inputs:
  4773                                  ;	User registers, User Stack, INTS disabled
  4774                                  ;	If CALL F8, DS:DX is new handler address
  4775                                  ; Function:
  4776                                  ;	Process OEM INT 21 extensions
  4777                                  ; Outputs:
  4778                                  ;	Jumps to OEM_HANDLER if appropriate
  4779                                  ;
  4780                                  ; ---------------------------------------------------------------------------
  4781                                  
  4782                                  ;IF	NOT IBM
  4783                                  
  4784                                  _$SET_OEM_HANDLER:
  4785                                  	; 01/05/2019 - Retro DOS v4.0
  4786                                  	
  4787                                  	;(cmp	ah,SET OEM HANDLER  ; 0F8h)
  4788                                  	;(jb	short NOTOOEM)
  4789                                  
  4790 00000481 06                      	push	es ; *
  4791                                  	;getdseg <es>			; es -> dosdata
  4792 00000482 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4793                                  
  4794 00000487 750C                    	jne	short check_trueversion_request ; check Retro DOS true version
  4795                                  						; (message) request
  4796                                  	; AH = 0F8h = SET OEM HANDLER
  4797                                  
  4798 00000489 268916[1400]            	MOV     [es:OEM_HANDLER],DX	; Set Handler
  4799 0000048E 268C1E[1600]            	MOV     [es:OEM_HANDLER+2],DS
  4800                                  
  4801 00000493 07                      	pop	es ; *
  4802                                  
  4803 00000494 CF                      	IRET                            ; Quick return, Have altered no registers
  4804                                  
  4805                                  check_trueversion_request:
  4806                                  	; 18/07/2019 - Retro DOS v3.0
  4807                                  
  4808                                  	; Retro DOS v2.0 - 20/04/2018
  4809 00000495 83F8FF                  	CMP	AX,0FFFFh
  4810                                  	; 18/07/2018
  4811 00000498 7520                    	jne	short DO_OEM_FUNC ; 01/05/2019
  4812                                  
  4813                                  	; 01/05/2019
  4814 0000049A 07                      	pop	es ; *
  4815                                  
  4816 0000049B B40E                    	mov	ah,0Eh
  4817                                  
  4818                                  	; Retro DOS v4.0 feature only!
  4819 0000049D 81FBA101                	cmp	bx,417  ; Signature to bypass
  4820                                  			; Retro DOS true version message
  4821 000004A1 7414                    	je	short true_version_iret
  4822                                  
  4823 000004A3 56                      	push	si
  4824 000004A4 53                      	push	bx
  4825                                  
  4826 000004A5 BE[C200]                	mov	si,RETRODOSMSG
  4827                                  wrdosmsg:
  4828                                  	;movb	ah,0Eh
  4829 000004A8 BB0700                  	mov	bx,7
  4830                                  wrdosmsg_nxt:
  4831 000004AB 2EAC                    	cs	lodsb
  4832 000004AD 3C24                    	cmp	al,'$'
  4833 000004AF 7404                    	je	short wrdosmsg_ok		
  4834 000004B1 CD10                    	int	10h
  4835 000004B3 EBF6                    	jmp	short wrdosmsg_nxt
  4836                                  
  4837                                  wrdosmsg_ok:
  4838 000004B5 5B                      	pop	bx
  4839 000004B6 5E                      	pop	si
  4840                                  
  4841                                  true_version_iret:
  4842                                  	; ah = 0Eh
  4843                                  	;mov	al,40h ; Retro DOS v4.0
  4844                                  	; 
  4845                                  	;mov	al,41h ; Retro DOS v4.1 
  4846                                  	; 30/12/2022
  4847                                  	;mov	al,42h ; Retro DOS v4.2
  4848                                  	; 01/01/2024
  4849 000004B7 B050                    	mov	al,50h ; Retro DOS v5.0	
  4850 000004B9 CF                      	iret
  4851                                  
  4852                                  	; If above F8 try to jump to handler
  4853                                  
  4854                                  DO_OEM_FUNC:
  4855                                  	; 01/05/2019
  4856 000004BA 26833E[1400]FF          	cmp     word [es:OEM_HANDLER],-1
  4857 000004C0 7504                    	JNE     short OEM_JMP
  4858 000004C2 07                      	pop	es ; *
  4859 000004C3 E903FE                  	JMP     BADCALL                 ; Handler not initialized
  4860                                  OEM_JMP:
  4861 000004C6 06                      	push	es
  4862 000004C7 1F                      	pop	ds ; DOSDATA segment !
  4863 000004C8 07                      	pop	es ; *
  4864                                  
  4865                                  	; 22/12/2022
  4866 000004C9 FB                      	sti	; (enable interrupts before jumping to private handler)  
  4867                                  
  4868 000004CA FF2E[1400]              	JMP     FAR [OEM_HANDLER]
  4869                                  
  4870                                  ;       ENDIF
  4871                                  
  4872                                  ; ---------------------------------------------------------------------------
  4873                                  
  4874                                  ;%endif
  4875                                  
  4876                                  ;============================================================================
  4877                                  ; MCODE.ASM, MSDOS 6.0, 1991
  4878                                  ;============================================================================
  4879                                  ; 17/07/2018 - Retro DOS v3.0
  4880                                  
  4881                                  ;	TITLE	MISC DOS ROUTINES - Int 25 and 26 handlers and other
  4882                                  ;	NAME	IBMCODE
  4883                                  
  4884                                  ;BREAK <NullDev -- Driver for null device>
  4885                                  
  4886                                  ; ROMDOS note:
  4887                                  ;	NUL device driver used to be here, but it was removed and placed in
  4888                                  ;	DOSDATA, because the entry points have to be in the segment as the
  4889                                  ;	header, which is also in DOSDATA.
  4890                                  
  4891                                  ;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>
  4892                                  
  4893                                  ;----------------------------------------------------------------------------
  4894                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
  4895                                  ;----------------------------------------------------------------------------
  4896                                  ; DOSCODE:428Ch (MSDOS 6.21 MSDOS.SYS)
  4897                                  ; DOSCODE:427Fh (MSDOS 5.0 MSDOS.SYS)
  4898                                  
  4899                                  ; 01/01/2024 - Retro DOS v5.0
  4900                                  ; DOSCODE:435Fh (PCDOS 7.1 IBMDOS.COM)
  4901                                  
  4902                                  ;Public MSC001S,MSC001E
  4903                                  ;MSC001S label byte
  4904                                  	;IF	IBM
  4905                                  ; Codes returned by BIOS
  4906                                  ERRIN:
  4907 000004CE 02                      	DB	2			; NO RESPONSE
  4908 000004CF 06                      	DB	6			; SEEK FAILURE
  4909 000004D0 0C                      	DB	12			; GENERAL ERROR
  4910 000004D1 04                      	DB	4			; BAD CRC
  4911 000004D2 08                      	DB	8			; SECTOR NOT FOUND
  4912 000004D3 00                      	DB	0			; WRITE ATTEMPT ON WRITE-PROTECT DISK
  4913                                  ERROUT:
  4914                                  ; DISK ERRORS RETURNED FROM INT 25 and 26
  4915 000004D4 80                      	DB	80H			; NO RESPONSE
  4916 000004D5 40                      	DB	40H			; Seek failure
  4917 000004D6 02                      	DB	2			; Address Mark not found
  4918 000004D7 10                      	DB	10H			; BAD CRC
  4919 000004D8 04                      	DB	4			; SECTOR NOT FOUND
  4920 000004D9 03                      	DB	3			; WRITE ATTEMPT TO WRITE-PROTECT DISK
  4921                                  
  4922                                  NUMERR	EQU	$-ERROUT
  4923                                  	;ENDIF
  4924                                  ;MSC001E label byte
  4925                                  ;----------------------------------------------------------------------------
  4926                                  
  4927                                  ;============================================================================
  4928                                  ; MSCODE.ASM - MSDOS 6.0 - 1991
  4929                                  ;============================================================================
  4930                                  ; 18/07/2018 - Retro DOS v3.0
  4931                                  ; 15/05/2019 - Retro DOS v4.0
  4932                                  
  4933                                  ; 02/01/2024 - Retro DOS v5.0
  4934                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:436Bh
  4935                                  
  4936                                  ;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>>
  4937                                  
  4938                                  ;   AbsSetup - setup for abs disk functions
  4939                                  ;----------------------------------------------------------------------------
  4940                                  
  4941                                  AbsSetup:
  4942                                  	; 02/01/2024 (PCDOS 7.1, Retro DOS 5.0)
  4943                                  	;;;
  4944                                  	;
  4945 000004DA 1E                      	push	ds ; *
  4946 000004DB 16                      	push	ss
  4947 000004DC 1F                      	pop	ds
  4948                                  	;
  4949 000004DD 8826[E20A]              	mov	[absdrw_extd],ah
  4950                                  	;mov	[ss:absdrw_extd],ah	; Extended ABS Disk Read/Write flag
  4951                                  					; (AH=1 for INT 21h ax=7305h function)
  4952 000004E1 08E4                    	or	ah,ah
  4953 000004E3 7508                    	jnz	short AbsSetup1		; INT 21h AX=7305h
  4954                                  
  4955                                  	; INT 25h
  4956 000004E5 FE06[DF13]              	inc	byte [INDOS_FLAG]
  4957                                  	;inc	byte [ss:INDOS_FLAG]	; Windows DOSBOX's INDOS flag ?
  4958                                  	;;;
  4959 000004E9 FE06[2103]              	inc	byte [INDOS]
  4960                                  	;INC	byte [SS:INDOS]		; SS override
  4961                                  AbsSetup1:
  4962 000004ED FB                      	STI
  4963 000004EE FC                      	CLD
  4964                                  	; 02/01/2024
  4965                                  	;PUSH	DS
  4966                                  	;push	ss
  4967                                  	;pop	ds
  4968 000004EF E83A01                  	CALL	GETBP
  4969                                  	; 02/01/2024
  4970 000004F2 1F                      	pop	ds ; *
  4971 000004F3 7229                    	JC	short errdriv 		; PM. error drive ;AN000;
  4972                                  	
  4973                                  	; 02/01/2024
  4974                                  	;;mov	word [es:bp+1Fh]
  4975                                  	;MOV	WORD [ES:BP+DPB.FREE_CNT],-1 ; do not trust user at all.
  4976                                  ;errdriv:
  4977                                  	;POP	DS
  4978                                  	;jnc	short AbsSetup2
  4979                                  ;AbsSetup_retn:
  4980                                  	;retn
  4981                                  
  4982                                  AbsSetup2:
  4983                                  	; 15/05/2019 - Retro DOS v4.0
  4984                                  	; MSDOS 6.0
  4985                                  					; SS override
  4986 000004F5 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0 ;>32mb	from API		;AN000;
  4987 000004FC E8BF04                  	CALL	RW32_CONVERT		;>32mb convert 32bit format to 16bit ;AN000;
  4988                                  	;jc	short AbsSetup_retn
  4989                                  	;call	SET_RQ_SC_PARMS 	;LB. set up SC parms		;AN000;
  4990                                  	; 02/01/2024 - Retro DOS v5.0
  4991 000004FF 721D                    	jc	short errdriv
  4992                                  	;call	null_sub ; retn	; PCDOS 7.1 IBMDOS.COM
  4993                                  
  4994                                  	; MSDOS 3.3 (& MSDOS 6.0)
  4995 00000501 1E                      	PUSH	DS
  4996 00000502 56                      	PUSH	SI
  4997 00000503 50                      	PUSH	AX
  4998                                  
  4999 00000504 16                      	push	ss
  5000 00000505 1F                      	pop	ds
  5001                                  	
  5002 00000506 BE[BE03]                	MOV	SI,OPENBUF
  5003 00000509 8804                    	MOV	[SI],AL
  5004 0000050B 800441                  	ADD	BYTE [SI],"A"
  5005 0000050E C744013A00              	MOV	WORD [SI+1],003AH ; ":",0
  5006 00000513 B80003                  	MOV	AX,0300H
  5007 00000516 F8                      	CLC
  5008 00000517 CD2A                    	INT	int_IBM ; int 2Ah	; Will set carry if shared
  5009                                  		
  5010                                  		; 04/11/2022
  5011                                  		; (INT 2Ah - AX = 0300h)
  5012                                  		; Microsoft Networks - CHECK DIRECT I/O
  5013                                  		; DS:SI -> ASCIIZ disk device name (may be full path or
  5014                                  		;    only drive specifier--must include the colon)
  5015                                  		; Return: CF clear if absolute disk access allowed
  5016                                  
  5017 00000519 58                      	POP	AX
  5018 0000051A 5E                      	POP	SI
  5019 0000051B 1F                      	POP	DS
  5020 0000051C 730E                    	jnc	short AbsSetup_retn
  5021                                  
  5022                                  	; 02/01/2024
  5023                                  errdriv:
  5024                                  	;mov	word [ss:EXTERR],32h
  5025 0000051E 36C706[2403]3200        	MOV	word [ss:EXTERR],error_not_supported
  5026                                  	; 02/01/2024 - Retro DOS v5.0
  5027 00000525 36C706[080E]0702        	mov	word [ss:AbsDskErr],207h ; PCDOS 7.1 IBMDOS.COM
  5028                                  
  5029                                  	; 02/01/2024
  5030                                  AbsSetup_retn:
  5031 0000052C C3                      	retn
  5032                                  
  5033                                  ;---------------------------------------------------------------------------
  5034                                  ;
  5035                                  ; Procedure Name : ABSDRD
  5036                                  ;
  5037                                  ; Interrupt 25 handler. Performs absolute disk read.
  5038                                  ; Inputs:	AL - 0-based drive number
  5039                                  ;		DS:BX point to destination buffer
  5040                                  ;		CX number of logical sectors to read
  5041                                  ;		DX starting logical sector number (0-based)
  5042                                  ; Outputs:	Original flags still on stack
  5043                                  ;		Carry set
  5044                                  ;		    AH error from BIOS
  5045                                  ;		    AL same as low byte of DI from INT 24
  5046                                  ;
  5047                                  ;---------------------------------------------------------------------------
  5048                                          ;procedure   ABSDRD,FAR
  5049                                  ABSDRD:
  5050                                  	; 15/05/2019 - Retro DOS v4.0
  5051                                  	; MSDOS 6.21 (DOSCODE:42E5h)
  5052                                  	; 04/11/2022
  5053                                  	; MSDOS 5.0 (DOSCODE:42D8h)
  5054                                  
  5055                                  	; 02/01/2024 - Retro DOS v5.0
  5056                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:43C4h
  5057                                  	
  5058                                  	;;;
  5059 0000052D 30E4                    	xor     ah,ah	; ah=0		; Interrupt 25h handler (ah=0)
  5060 0000052F 31F6                    	xor     si,si	; si=0		; clear read/write mode flags
  5061                                  					; (used with INT 21h ax=7305h)
  5062                                  FAT32_ABSDRD:	; ah=1 si=0 cf=0 (jump from '_$FAT32EXT')
  5063 00000531 FA                      	cli
  5064                                  	;clc ; not necessary
  5065                                  				; INT 21h
  5066                                  				;	AX = 7305h
  5067                                  				; FAT32 - EXTENDED ABSOLUTE DISK READ/WRITE
  5068                                  				;	CX = FFFFh
  5069                                  				;	DL = drive number (01h=A:, etc.)
  5070                                  				;	SI = read/write mode flags
  5071                                  				;	DS:BX -> disk I/O packet
  5072                                  				;
  5073                                  				; Extended Absolute Disk Read/Write mode flags:
  5074                                  				;
  5075                                  				;	Bit(s)  Description
  5076                                  				;	0	direction (0=read, 1=write)
  5077                                  				;	12-1	reserved (0)
  5078                                  				;	14-13	write type (should be 00 on reads).
  5079                                  				;		00 unknown data.
  5080                                  				;		01 FAT data.
  5081                                  				;		10 directory data.
  5082                                  				;		11 file data
  5083                                  				;	15     reserved (0)
  5084                                  				;
  5085                                  				; Format of disk read/write packet:
  5086                                  				;
  5087                                  				;	Offset Size    Description
  5088                                  				;	00h    DWORD   sector number
  5089                                  				;	04h    WORD    number of sectors to r/w
  5090                                  				;	06h    DWORD   transfer address
  5091                                  				;
  5092                                  				; ref: Ralf Brown's Interrupt List
  5093                                  	;;;
  5094                                  absdrd_1:
  5095                                  	; MSDOS 6.0
  5096                                  	;CLI
  5097                                  	
  5098                                  ;	set up ds to point to DOSDATA
  5099                                  
  5100 00000532 50                      	push	ax			; preserve AX value
  5101 00000533 8CD8                    	mov	ax,ds			; store DS value in AX
  5102                                  	;getdseg <ds>
  5103 00000535 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5104 0000053A A3[840D]                	mov	[TEMPSEG],ax		; store DS value in TEMPSEG
  5105 0000053D 58                      	pop	ax			; restore AX value
  5106                                  
  5107                                  	; M072:
  5108                                  	; We shall save es on the user stack here. We need to use ES in
  5109                                  	; order to access the DOSDATA variables AbsRdWr_SS/SP at exit 
  5110                                  	; time in order to restore the user stack.
  5111                                  
  5112 0000053E 06                      	push	es  ; ****		; M072
  5113                                  
  5114                                  	; 02/01/2024 - Retrodos v5.0 (PCDOS 7.1 IBMDOS.COM)
  5115                                  	;;;
  5116                                  	; 02/01/2024
  5117 0000053F 9C                      	pushf	; !*!
  5118 00000540 7300                    	jnc	short absdrd_2		; (not jumped from ABSDWRT) absolute disk read
  5119                                  	
  5120                                  	;(jumped from ABSDRWT)
  5121                                  	; 02/01/2023 ; (!*!)
  5122                                  	;or	ah,ah
  5123                                  	;stc				; absolute disk write
  5124                                  	;jmp	short absdrd_3
  5125                                  absdrd_2:
  5126 00000542 08E4                    	or	ah,ah
  5127                                  absdrd_3:
  5128 00000544 7510                    	jnz	short absdrd_4		; EXTENDED ABSOLUTE DISK READ/WRITE
  5129                                  	;;;
  5130                                  
  5131 00000546 8C16[1B06]              	MOV	[AbsRdWr_SS],SS		; M013
  5132 0000054A 8926[1D06]              	MOV	[AbsRdWr_SP],SP		; M013
  5133                                  
  5134                                  ; 	set up ss to point to DOSDATA
  5135                                  ;
  5136                                  ; NOTE! Due to an obscure bug in the 80286, you cannot use the ROMDOS
  5137                                  ; version of the getdseg macro with the SS register! An interrupt will
  5138                                  ; sneak through.
  5139                                  
  5140                                  ;ifndef ROMDOS
  5141                                  	;getdseg <ss>			; cli in entry of routine
  5142                                  
  5143 0000054E 2E8E16[0700]            	mov     ss,[cs:DosDSeg]
  5144                                  
  5145                                  ;else
  5146                                  ;	mov	ds, cs:[BioDataSeg]
  5147                                  ;	assume	ds:bdata
  5148                                  ;
  5149                                  ;	mov	ss, ds:[DosDataSg]
  5150                                  ;	assume	ss:DOSDATA
  5151                                  ;
  5152                                  ;endif ; ROMDOS
  5153                                  					; 02/01/2024
  5154 00000553 BC[2009]                	MOV	SP,DSKSTACK	 	;"@#IBM:12.01.2003.build_1.32#@ IBMDOS.COM(USA)"
  5155                                  					; (PCDOS 7.1 IBMDOS.COM)
  5156                                  absdrd_4:
  5157                                  	; 02/01/2024
  5158 00000556 9D                      	popf	; !*!
  5159                                  	;
  5160 00000557 8E1E[840D]              	mov	ds,[TEMPSEG]		; restore DS value
  5161                                  
  5162 0000055B 06                      	push	es ; *** (MSDOS 6.21)
  5163 0000055C E8F9FE                  	call	save_world		; save all regs
  5164                                  
  5165 0000055F 06                      	PUSH	ES ; **
  5166                                  
  5167                                  	; 02/01/2024 - Retrodos v5.0
  5168                                  	;;;
  5169 00000560 7303                    	jnc	short absdrd_5  ; (!*!)	; absolute disk read
  5170 00000562 E9A500                  	jmp     absdrwt_3       ; (!*!)	; (jumping back to) absolute disk write
  5171                                  absdrd_5:
  5172                                  	;;;
  5173                                  
  5174 00000565 E872FF                  	CALL	AbsSetup
  5175 00000568 723D                    	JC	short ILEAVE
  5176                                  
  5177                                  	; Here is a gross temporary fix to get around a serious design flaw in
  5178                                  	;  the secondary cache. The secondary cache does not check for media
  5179                                  	;  changed (it should). Hence, you can change disks, do an absolute
  5180                                  	;  read, and get data from the previous disk. To get around this,
  5181                                  	;  we just won't use the secondary cache for absolute disk reads.
  5182                                  	;                                                      -mw 8/5/88
  5183                                  
  5184                                  	;EnterCrit critDisk
  5185 0000056A E89613                  	call	ECritDisk
  5186 0000056D 36C606[9C12]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ; invalidate SC  ;AN000;
  5187                                  	;LeaveCrit critDisk
  5188 00000573 E8BA13                  	call	LCritDisk
  5189                                  
  5190                                          ;invoke	DSKREAD
  5191 00000576 E8833A                  	CALL	DSKREAD
  5192 00000579 7513                            jnz	short ERR_LEAVE		;Jump if read unsuccessful.
  5193                                  
  5194 0000057B 89F9                            mov     cx,di
  5195 0000057D 368C1E[0E06]                    mov     [ss:TEMP_VAR2],ds
  5196 00000582 36891E[0C06]                    mov     [ss:TEMP_VAR],bx
  5197                                  
  5198                                  ;       CX = # of contiguous sectors read. (These constitute a block of
  5199                                  ;            sectors, also termed an "Extent".)
  5200                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
  5201                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
  5202                                  ;       ES:BP -> Drive Parameter Block (DPB).
  5203                                  ;
  5204                                  ;	The Buffer Queue must now be scanned: the contents of any dirty
  5205                                  ;	buffers must be "read" into the transfer memory block, so that the
  5206                                  ;       transfer memory reflects the most recent data.
  5207                                  
  5208                                  	;invoke	DskRdBufScan		;This trashes DS, but don't care.
  5209 00000587 E8C23C                          call	DskRdBufScan
  5210 0000058A EB1B                    	jmp     short ILEAVE
  5211                                  
  5212                                  TLEAVE:
  5213 0000058C 7419                    	JZ	short ILEAVE
  5214                                  
  5215                                  ERR_LEAVE:				; M039
  5216                                  	; 15/07/2018 - Retro DOS v3.0
  5217                                          ;IF	IBM
  5218                                  ; Translate the error code to ancient 1.1 codes
  5219 0000058E 06                              PUSH    ES ; *
  5220 0000058F 0E                              PUSH    CS
  5221 00000590 07                              POP     ES
  5222 00000591 30E4                            XOR     AH,AH			; Nul error code
  5223                                  	;mov	cx,6
  5224 00000593 B90600                          MOV     CX,NUMERR		; Number of possible error conditions
  5225 00000596 BF[CE04]                        MOV     DI,ERRIN		; Point to error conditions
  5226 00000599 F2AE                            REPNE   SCASB
  5227 0000059B 7504                            JNZ     SHORT LEAVECODE		; Not found
  5228                                  	;mov	ah,[ES:DI+5]
  5229 0000059D 268A6505                        MOV     AH,[ES:DI+NUMERR-1]	; Get translation
  5230                                  LEAVECODE:
  5231 000005A1 07                              POP     ES ; *
  5232                                  	; 15/05/2019 - Retro DOS v4.0
  5233 000005A2 36A3[080E]              	mov	[ss:AbsDskErr],ax
  5234                                          ;ENDIF
  5235                                  
  5236 000005A6 F9                              STC
  5237                                  ILEAVE:
  5238                                  	; 15/05/2019
  5239 000005A7 07                              POP     ES ; **
  5240 000005A8 E896FE                  	call	restore_world
  5241 000005AB 07                              pop	es ; *** (MSDOS 6.21)
  5242                                  
  5243                                  	; 02/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
  5244                                  	;;;
  5245 000005AC 9C                      	pushf
  5246 000005AD 36803E[E20A]00          	cmp	byte [ss:absdrw_extd],0
  5247                                  			; FAT32- EXTENDED ABSOLUTE DISK READ/WRITE flag
  5248 000005B3 751F                    	jnz     short ILEAVE_EXTD	; INT 21h AX=7305h
  5249                                  	; INT 25h
  5250 000005B5 9D                      	popf
  5251                                  	;;;
  5252                                  
  5253 000005B6 FA                      	CLI
  5254 000005B7 36A1[080E]              	mov     ax,[ss:AbsDskErr]	; restore error
  5255 000005BB 36FE0E[2103]            	DEC	BYTE [SS:INDOS]
  5256                                  	;
  5257                                  	; 02/01/2024 (PCDOS 7.1 IBMDOS.COM)
  5258 000005C0 36FE0E[DF13]            	dec	byte [ss:INDOS_FLAG]	; Windows DOSBOX's INDOS flag ?
  5259                                  	;
  5260 000005C5 16                              push	ss			; M072 - Start
  5261 000005C6 07                      	pop	es			; es - dosdata
  5262 000005C7 268E16[1B06]                    mov	ss,[es:AbsRdWr_SS]	; M013
  5263 000005CC 268B26[1D06]            	mov	sp,[es:AbsRdWr_SP]	; M013
  5264 000005D1 07                      	pop	es  ; ****		; Note es was saved on user
  5265                                  					; stack at entry 
  5266                                  					; M072 - End
  5267 000005D2 FB                              STI
  5268 000005D3 CB                      	RETF   ; ! FAR return !
  5269                                  
  5270                                  	; 02/01/2024 - Retro DOS v5.0
  5271                                  	; (PCDOS 7.1 IBMDOS.COM)
  5272                                  	;;;
  5273                                  ILEAVE_EXTD:	; return from INT 21h AX=7305h
  5274 000005D4 9D                      	popf
  5275 000005D5 36A1[080E]              	mov	ax,[ss:AbsDskErr]	; restore error
  5276 000005D9 07                      	pop	es ; ****
  5277 000005DA FB                      	sti
  5278 000005DB C3                      	retn
  5279                                  	;;;
  5280                                  
  5281                                  ;ABSDRD	ENDP
  5282                                  
  5283                                  ;---------------------------------------------------------------------------
  5284                                  ;
  5285                                  ; Procedure Name : ABSDWRT
  5286                                  ;
  5287                                  ; Interrupt 26 handler. Performs absolute disk write.
  5288                                  ; Inputs:	AL - 0-based drive number
  5289                                  ;		DS:BX point to source buffer
  5290                                  ;		CX number of logical sectors to write
  5291                                  ;		DX starting logical sector number (0-based)
  5292                                  ; Outputs:	Original flags still on stack
  5293                                  ;		Carry set
  5294                                  ;		    AH error from BIOS
  5295                                  ;		    AL same as low byte of DI from INT 24
  5296                                  ;
  5297                                  ;---------------------------------------------------------------------------
  5298                                          ;procedure   ABSDWRT,FAR
  5299                                  ABSDWRT:
  5300                                  	; 15/05/2019 - Retro DOS v4.0
  5301                                  	; MSDOS 6.21 (DOSCODE:436Ch)
  5302                                  	; 04/11/2022
  5303                                  	; MSDOS 5.0 (DOSCODE:435Fh)
  5304                                  
  5305                                  	; 03/01/2024 - Retro DOS v5.0
  5306                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:4477h
  5307                                  
  5308                                  	;;;
  5309 000005DC 30E4                    	xor     ah,ah	; ah=0		; Interrupt 26h handler (ah=0)
  5310 000005DE BE0100                  	mov	si,1			; set direction flag/bit to write
  5311                                  					; (used with INT 21h ax=7305h)
  5312                                  FAT32_ABSDWRT:	; ah=1 si=1 cf=0 (jump from '_$FAT32EXT')
  5313                                  
  5314                                  				; INT 21h
  5315                                  				;	AX = 7305h
  5316                                  				; FAT32 - EXTENDED ABSOLUTE DISK READ/WRITE
  5317                                  				;	CX = FFFFh
  5318                                  				;	DL = drive number (01h=A:, etc.)
  5319                                  				;	SI = read/write mode flags
  5320                                  				;	DS:BX -> disk I/O packet
  5321                                  				;
  5322                                  				; Extended Absolute Disk Read/Write mode flags:
  5323                                  				;
  5324                                  				;	Bit(s)  Description
  5325                                  				;	0	direction (0=read, 1=write)
  5326                                  				;	12-1	reserved (0)
  5327                                  				;	14-13	write type (should be 00 on reads).
  5328                                  				;		00 unknown data.
  5329                                  				;		01 FAT data.
  5330                                  				;		10 directory data.
  5331                                  				;		11 file data
  5332                                  				;	15     reserved (0)
  5333                                  				;
  5334                                  				; Format of disk read/write packet:
  5335                                  				;
  5336                                  				;	Offset Size    Description
  5337                                  				;	00h    DWORD   sector number
  5338                                  				;	04h    WORD    number of sectors to r/w
  5339                                  				;	06h    DWORD   transfer address
  5340                                  				;
  5341                                  				; ref: Ralf Brown's Interrupt List
  5342 000005E1 3C02                    	cmp	al,2
  5343 000005E3 7220                    	jb	short absdrwt_2	; floppy disk
  5344                                  	; hard disk
  5345 000005E5 53                      	push	bx
  5346 000005E6 1E                      	push	ds
  5347 000005E7 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5348 000005EC 30FF                    	xor	bh,bh
  5349 000005EE 88C3                    	mov	bl,al			;
  5350                                  					; NOTE: PCDOS 7.1 kernel does not set
  5351                                  					; DOS_FLAG bit 6 or drive_flags bit 7
  5352                                  					; (It appears that these bits are set
  5353                                  					; by Windows or a system utility or
  5354                                  					; driver that knows the addresses of
  5355                                  					; these FLAGs in the DOSDATA segment.)
  5356                                  					; Erdogan Tan - 03/01/2024
  5357                                  					;
  5358 000005F0 F687[2F14]80            	test	byte [drive_flags+bx],80h 
  5359                                  					; test bit 7 (locked bit) ; 29/01/2024
  5360 000005F5 7505                    	jnz	short absdwrt_1		; locked (logical drive) -allowed to abs write-
  5361                                  					; NOTE: lock/unlock are MSDOS/PCDOS 7 extd functions
  5362 000005F7 F606[8600]40            	test	byte [DOS_FLAG],40h	; test bit 6 (large disk support -windows- bit?)
  5363                                  					; NOTE: Retro DOS v5 kernel must set this bit.
  5364                                  absdwrt_1:
  5365 000005FC 1F                      	pop     ds
  5366 000005FD 5B                      	pop     bx
  5367 000005FE 7505                    	jnz     short absdrwt_2	; allowed
  5368 00000600 F9                      	stc
  5369 00000601 E81AFF                  	call    errdriv		; error
  5370 00000604 CB                      	retf
  5371                                  
  5372                                  ;absdrwt_2:
  5373                                  	;;;
  5374                                  
  5375                                  ; 03/01/2024
  5376                                  %if 0
  5377                                  	CLI
  5378                                  
  5379                                  ;	set up ds to point to DOSDATA
  5380                                  
  5381                                  	push	ax
  5382                                  	mov	ax,ds
  5383                                  	;getdseg <ds>
  5384                                  	mov	ds,[cs:DosDSeg]
  5385                                  	mov	[TEMPSEG],ax
  5386                                  	pop	ax
  5387                                  
  5388                                  	; M072:
  5389                                  	; We shall save es on the user stack here. We need to use ES in
  5390                                  	; order to access the DOSDATA variables AbsRdWr_SS/SP at exit 
  5391                                  	; time in order to restore the user stack.
  5392                                  
  5393                                  	push	es ; ****		; M072
  5394                                  
  5395                                  	MOV	[AbsRdWr_SS],SS		; M013
  5396                                  	MOV	[AbsRdWr_SP],SP		; M013
  5397                                  
  5398                                  	; set up ss to point to DOSDATA
  5399                                  	;
  5400                                  	; NOTE! Due to an obscure bug in the 80286, you cannot use the 
  5401                                  	; ROMDOS version of the getdseg macro with the SS register!
  5402                                  	; An interrupt will sneak through.
  5403                                  
  5404                                  ;ifndef ROMDOS
  5405                                  	;getdseg <ss>			; cli in entry of routine
  5406                                  	mov     ss,[cs:DosDSeg]
  5407                                  ;else
  5408                                  ;	mov	ds, cs:[BioDataSeg]
  5409                                  ;	assume	ds:bdata
  5410                                  ;
  5411                                  ;	mov	ss, ds:[DosDataSg]
  5412                                  ;	assume	ss:DOSDATA
  5413                                  ;
  5414                                  ;endif ; ROMDOS
  5415                                  
  5416                                  	MOV	SP,DSKSTACK
  5417                                  		; we are now switched to DOS's disk stack
  5418                                  
  5419                                  	mov	ds,[TEMPSEG]		; restore user's ds
  5420                                  
  5421                                  	push	es ; *** (MSDOS 6.21)
  5422                                  
  5423                                  	call	save_world	      	; save all regs
  5424                                  
  5425                                  	PUSH	ES ; **
  5426                                  %endif
  5427                                  	; 03/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
  5428                                  	;;;
  5429                                  absdrwt_2:
  5430 00000605 FA                      	cli
  5431 00000606 F9                      	stc			; writable disk
  5432                                  				; ('jumped from ABSDWRT' sign for common r/w code)
  5433 00000607 E928FF                  	jmp	absdrd_1        ; jump to ABSDRD (common r/w) code
  5434                                  	;;;
  5435                                  
  5436                                  absdrwt_3:
  5437 0000060A E8CDFE                  	CALL	AbsSetup
  5438 0000060D 7298                    	JC	short ILEAVE
  5439                                  
  5440                                  	; 03/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
  5441 0000060F E8F95A                  	call	chk_set_first_access
  5442                                  
  5443                                  	;EnterCrit critDisk
  5444 00000612 E8EE12                  	call	ECritDisk
  5445 00000615 36C606[9C12]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ; invalidate SC ;AN000;
  5446 0000061B E8DF03                  	CALL	Fastxxx_Purge		 ; purge fatopen ;AN000;
  5447                                  	;LeaveCrit critDisk
  5448 0000061E E80F13                  	call	LCritDisk
  5449                                  
  5450                                  ;M039
  5451                                  ;       DS:BX = transfer address (source data address).
  5452                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
  5453                                  ;	     sectors, also termed an "Extent".)
  5454                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
  5455                                  ;       ES:BP -> Drive Parameter Block (DPB).
  5456                                  ;       [CURSC_DRIVE] = -1 (invalid drive).
  5457                                  ;
  5458                                  ;       Free any buffered sectors which are in Extent; they are being over-
  5459                                  ;       written. Note that all the above registers are preserved for
  5460                                  ;       DSKWRITE.
  5461                                  
  5462 00000621 1E                              push    ds
  5463                                  	;invoke	DskWrtBufPurge          ; This trashes DS.
  5464 00000622 E83E3F                  	call	DskWrtBufPurge
  5465 00000625 1F                              pop     ds
  5466                                  ;M039
  5467                                  	;invoke	DSKWRITE
  5468 00000626 E8FC39                  	call	DSKWRITE
  5469 00000629 E960FF                  	JMP	TLEAVE
  5470                                  
  5471                                  ;ABSDWRT ENDP
  5472                                  
  5473                                  ;----------------------------------------------------------------------------
  5474                                  ;
  5475                                  ; Procedure Name : GETBP
  5476                                  ;
  5477                                  ; Inputs:
  5478                                  ;	AL = Logical unit number (A = 0)
  5479                                  ; Function:
  5480                                  ;	Find Drive Parameter Block
  5481                                  ; Outputs:
  5482                                  ;	ES:BP points to DPB
  5483                                  ;	[THISDPB] = ES:BP
  5484                                  ;	Carry set if unit number bad or unit is a NET device.
  5485                                  ;		Later case sets extended error error_I24_not_supported
  5486                                  ; No other registers alteredjjj
  5487                                  ;
  5488                                  ;----------------------------------------------------------------------------
  5489                                  
  5490                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5491                                  	; 04/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  5492                                  	; PCDOS 76.1 IBMDOS.COM - DOSCODE:44C7h
  5493                                  GETBP:
  5494                                  	; 15/05/2019 - Retro DOS v4.0
  5495                                  	; 11/07/2018 - Retro DOS v3.0
  5496 0000062C 50                      	PUSH	AX
  5497 0000062D 0401                    	ADD	AL, 1		; No increment; need carry flag
  5498 0000062F 7216                    	JC	SHORT SKIPGET
  5499 00000631 E87C6E                  	CALL	GETTHISDRV
  5500                                  	; MSDOS 6.0
  5501 00000634 7311                    	JNC	SHORT SKIPGET		;PM. good drive		;AN000;
  5502 00000636 30E4                    	XOR	AH,AH			;DCR. ax= error code 	;AN000;
  5503 00000638 83F81A                  	CMP	AX,error_not_DOS_disk	;DCR. is unknown media ? ;AN000;
  5504 0000063B 740A                    	JZ	SHORT SKIPGET 		;DCR. yes, let it go 	;AN000;
  5505 0000063D F9                      	STC				;DCR.			;AN000;
  5506 0000063E A3[2403]                	MOV	[EXTERR],AX	;PM. invalid drive or Non DOS drive ;AN000;
  5507 00000641 C706[080E]0102          	MOV	WORD [AbsDskErr],201h
  5508                                  SKIPGET:
  5509 00000647 58                      	POP	AX
  5510 00000648 7212                    	JC	SHORT GETBP_RETN ; 15/12/2022
  5511                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  5512                                  	;jnc	short getbp_t
  5513                                  	;retn
  5514                                  getbp_t:
  5515 0000064A C42E[A205]              	LES	BP,[THISCDS]
  5516                                  	; 15/12/2022
  5517 0000064E 26F6464480              	test	byte [es:bp+curdir.flags+1],curdir_isnet>>8
  5518                                  	; 07/12/2022
  5519                                  	;TEST	WORD [ES:BP+43H],8000H
  5520                                  	;TEST	WORD [ES:BP+curdir.flags],curdir_isnet ; Clears carry
  5521 00000653 7408                    	JZ	SHORT GETBP_CDS
  5522                                  GETBP_err:	; 04/01/2024
  5523 00000655 C706[2403]3200          	MOV	WORD [EXTERR],error_not_supported  ; 32h
  5524 0000065B F9                      	STC
  5525                                  GETBP_RETN:
  5526 0000065C C3                      	RETN
  5527                                  
  5528                                  GETBP_CDS:
  5529                                  	;LES	BP,[ES:BP+45H]
  5530 0000065D 26C46E45                	LES	BP,[ES:BP+curdir.devptr]
  5531                                  	; 04/01/2024 (PCDOS 7.1 IBMDOS.COM)
  5532                                  	;;;
  5533 00000661 50                      	push	ax
  5534 00000662 09E8                    	or	ax,bp
  5535 00000664 58                      	pop	ax
  5536 00000665 74EE                    	jz	short GETBP_err ; zero address, error
  5537                                  	;;;
  5538                                  ;----------------------------------------------------------------------------
  5539                                  GOTDPB:
  5540                                  	; Load THISDPB from ES:BP
  5541 00000667 892E[8A05]              	MOV	[THISDPB],BP
  5542 0000066B 8C06[8C05]              	MOV	[THISDPB+2],ES
  5543 0000066F C3                      	RETN
  5544                                  
  5545                                  ;BREAK <SYS_RET_OK SYS_RET_ERR CAL_LK ETAB_LK set system call returns>
  5546                                  
  5547                                  ;----------------------------------------------------------------------------
  5548                                  ;
  5549                                  ; Procedure Name : SYS_RETURN
  5550                                  ;
  5551                                  ; These are the general system call exit mechanisms. All internal system
  5552                                  ; calls will transfer (jump) to one of these at the end. Their sole purpose
  5553                                  ; is to set the user's flags and set his AX register for return.
  5554                                  ;
  5555                                  ;----------------------------------------------------------------------------
  5556                                  
  5557                                          ;procedure   SYS_RETURN,NEAR
  5558                                  SYS_RETURN:        
  5559                                          ;entry	SYS_RET_OK
  5560                                  SYS_RET_OK:   
  5561 00000670 E804FE                  	call    Get_User_Stack
  5562                                  		; turn off user's carry flag
  5563                                  SYS_RET_OK_clc: ; 25/06/2019 
  5564                                          ;;and	word [SI+16h],0FFFEh 
  5565                                  	;and	word [SI+user_env.user_F],~f_Carry 
  5566                                          ; 25/06/2019
  5567 00000673 806416FE                	and	byte [SI+user_env.user_F],~f_Carry ; 0FEh
  5568                                  	; 04/01/2024
  5569                                  	;JMP	SHORT DO_RET
  5570                                  DO_RET:
  5571                                          ;MOV	[SI+user_env.user_AX],AX ; Really only sets AH
  5572 00000677 8904                    	MOV	[SI],AX
  5573 00000679 C3                      	RETN
  5574                                  
  5575                                          ;entry   SYS_RET_ERR
  5576                                  SYS_RET_ERR:        
  5577 0000067A 30E4                    	XOR     AH,AH 		; hack to allow for smaller error rets
  5578 0000067C E86B00                  	call	ETAB_LK 	; Make sure code is OK, EXTERR gets set
  5579 0000067F E81900                  	CALL	ErrorMap
  5580                                  
  5581                                  	;entry	From_GetSet
  5582                                  From_GetSet:
  5583 00000682 E8F2FD                          call    Get_User_Stack
  5584                                  		 ; signal carry to user
  5585                                  	;;or	word [SI+16h],1
  5586                                  	;OR	word [SI+user_env.user_F],f_Carry
  5587                                  	; 25/06/2019
  5588 00000685 804C1601                	or	byte [SI+user_env.user_F],f_Carry
  5589 00000689 F9                      	STC			; also, signal internal error
  5590                                  	; 04/01/2024
  5591 0000068A EBEB                    	jmp	short DO_RET
  5592                                  ;DO_RET:
  5593                                  	;;MOV	[SI+user_env.user_AX],AX ; Really only sets AH
  5594                                  	;MOV	[SI],AX
  5595                                  	;RETN
  5596                                  
  5597                                  	;entry	FCB_RET_OK
  5598                                  FCB_RET_OK:
  5599                                  	;entry	NO_OP		; obsolete system calls dispatch to here
  5600                                  NO_OP:
  5601 0000068C 30C0                    	XOR	AL,AL
  5602 0000068E C3                      	retn
  5603                                  
  5604                                  	;entry	FCB_RET_ERR
  5605                                  FCB_RET_ERR:
  5606 0000068F 30E4                    	XOR	AH,AH
  5607 00000691 36A3[2403]              	mov	[ss:EXTERR],AX
  5608 00000695 E80300                  	CALL	ErrorMap
  5609 00000698 B0FF                    	MOV	AL,-1
  5610 0000069A C3                      	retn
  5611                                  
  5612                                  	;entry	ErrorMap
  5613                                  ErrorMap:
  5614 0000069B 56                      	PUSH	SI
  5615                                  				; ERR_TABLE_21 is now in DOSDATA
  5616 0000069C BE[220E]                	MOV	SI,ERR_TABLE_21
  5617                                  				; SS override for FAILERR and EXTERR
  5618 0000069F 36803E[4A03]00          	CMP	byte [SS:FAILERR],0 ; Check for SPECIAL case.
  5619 000006A5 7407                    	JZ	short EXTENDED_NORMAL ; All is OK.
  5620                                  		 ; Ooops, this is the REAL reason
  5621                                  	;mov	word [SS:EXTERR],53h
  5622 000006A7 36C706[2403]5300        	MOV	word [SS:EXTERR],error_FAIL_I24
  5623                                  EXTENDED_NORMAL:
  5624 000006AE E80200                  	call	CAL_LK		; Set CLASS,ACTION,LOCUS for EXTERR
  5625 000006B1 5E                      	POP	SI
  5626 000006B2 C3                      	retn
  5627                                  
  5628                                  	;EndProc SYS_RETURN
  5629                                  
  5630                                  ;---------------------------------------------------------------------------
  5631                                  ;
  5632                                  ; Procedure Name : CAL_LK
  5633                                  ;
  5634                                  ; Inputs:
  5635                                  ;	SI is OFFSET in DOSDATA of CLASS,ACTION,LOCUS Table to use
  5636                                  ;		(DS NEED not be DOSDATA)
  5637                                  ;	[EXTERR] is set with error
  5638                                  ; Function:
  5639                                  ;	Look up and set CLASS ACTION and LOCUS values for GetExtendedError
  5640                                  ; Outputs:
  5641                                  ;	[EXTERR_CLASS] set
  5642                                  ;	[EXTERR_ACTION] set
  5643                                  ;	[EXTERR_LOCUS] set  (EXCEPT on certain errors as determined by table)
  5644                                  ; Destroys SI, FLAGS
  5645                                  ;
  5646                                  ;---------------------------------------------------------------------------
  5647                                  
  5648                                  	;procedure CAL_LK,NEAR
  5649                                  CAL_LK:
  5650 000006B3 1E                      	PUSH	DS
  5651 000006B4 50                      	PUSH	AX
  5652 000006B5 53                      	PUSH	BX
  5653                                  
  5654                                  ;M048	Context DS		; DS:SI -> Table
  5655                                  ;
  5656                                  ; Since this function can be called thru int 2f we shall not assume that SS
  5657                                  ; is DOSDATA
  5658                                  
  5659                                  	;getdseg  <ds>	; M048: DS:SI -> Table
  5660                                  	; 15/05/2019 - Retro DOS v4.0
  5661 000006B6 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5662                                  
  5663                                  	; 18/07/2018
  5664                                  	;push	ss
  5665                                  	;pop	ds
  5666                                  
  5667 000006BB 8B1E[2403]              	MOV	BX,[EXTERR]	; Get error in BL
  5668                                  TABLK1:
  5669 000006BF AC                      	LODSB
  5670                                  
  5671 000006C0 3CFF                    	CMP	AL,0FFH
  5672 000006C2 7409                    	JZ	short GOT_VALS	; End of table
  5673 000006C4 38D8                    	CMP	AL,BL
  5674 000006C6 7405                    	JZ	short GOT_VALS	; Got entry
  5675 000006C8 83C603                  	ADD	SI,3		; Next table entry
  5676                                  	; 15/08/2018
  5677 000006CB EBF2                    	JMP	short TABLK1
  5678                                  
  5679                                  GOT_VALS:
  5680 000006CD AD                      	LODSW			; AL is CLASS, AH is ACTION
  5681                                  
  5682 000006CE 80FCFF                  	CMP	AH,0FFH
  5683 000006D1 7404                    	JZ	short NO_SET_ACT
  5684 000006D3 8826[2603]              	MOV	[EXTERR_ACTION],AH ; Set ACTION
  5685                                  NO_SET_ACT:
  5686 000006D7 3CFF                    	CMP	AL,0FFH
  5687 000006D9 7403                    	JZ	short NO_SET_CLS
  5688 000006DB A2[2703]                	MOV	[EXTERR_CLASS],AL ; Set CLASS
  5689                                  NO_SET_CLS:
  5690 000006DE AC                      	LODSB			; Get LOCUS
  5691                                  
  5692 000006DF 3CFF                    	CMP	AL,0FFH
  5693 000006E1 7403                    	JZ	short NO_SET_LOC
  5694 000006E3 A2[2303]                	MOV	[EXTERR_LOCUS],AL
  5695                                  NO_SET_LOC:
  5696 000006E6 5B                      	POP	BX
  5697 000006E7 58                      	POP	AX
  5698 000006E8 1F                      	POP	DS
  5699 000006E9 C3                      	retn
  5700                                  
  5701                                  	;EndProc CAL_LK
  5702                                  
  5703                                  ;---------------------------------------------------------------------------
  5704                                  ;
  5705                                  ; Procedure Name : ETAB_LK
  5706                                  ;
  5707                                  ; Inputs:
  5708                                  ;	AX is error code
  5709                                  ;	[USER_IN_AX] has AH value of system call involved
  5710                                  ; Function:
  5711                                  ;	Make sure error code is appropriate to this call.
  5712                                  ; Outputs:
  5713                                  ;	AX MAY be mapped error code
  5714                                  ;	[EXTERR] = Input AX
  5715                                  ; Destroys ONLY AX and FLAGS
  5716                                  ;
  5717                                  ;---------------------------------------------------------------------------
  5718                                  
  5719                                  	;procedure ETAB_LK,NEAR
  5720                                  
  5721                                  ETAB_LK: ; 10/08/2018 - Retro DOS v3.0
  5722 000006EA 1E                      	PUSH	DS
  5723 000006EB 56                      	PUSH	SI
  5724 000006EC 51                      	PUSH	CX
  5725 000006ED 53                      	PUSH	BX
  5726                                  
  5727                                  	;Context DS			; SS is DOSDATA
  5728                                  
  5729 000006EE 16                      	push	ss
  5730 000006EF 1F                      	pop	ds
  5731                                  
  5732 000006F0 A3[2403]                	MOV	[EXTERR],AX		; Set EXTERR with "real" error
  5733                                  
  5734                                  					; I21_MAP_E_TAB is now in DOSCODE
  5735 000006F3 BE[0B00]                	MOV	SI,I21_MAP_E_TAB
  5736 000006F6 88C7                    	MOV	BH,AL			; Real code to BH
  5737 000006F8 8A1E[3B03]              	MOV	BL,[USER_IN_AX+1]	; Sys call to BL
  5738                                  TABLK2:
  5739                                  	; 15/05/2019 - Retro DOS v4.0
  5740 000006FC 2E                      	cs
  5741 000006FD AD                      	lodsw	; MSDOS 6.0 (MSDOS 6.21 - MSDOS.SYS, DOSCODE:447Dh)
  5742                                  	
  5743                                  	; 18/07/2018 - Retro DOS v3.0
  5744                                  	;lodsw		; IBMDOS.COM (MSDOS 3.3) - Offset 16F7h
  5745                                  
  5746 000006FE 3CFF                    	CMP	AL,0FFH 		; End of table?
  5747 00000700 740C                    	JZ	short NOT_IN_TABLE	; Yes
  5748 00000702 38D8                    	CMP	AL,BL			; Found call?
  5749 00000704 740C                    	JZ	short GOT_CALL		; Yes
  5750 00000706 86E0                    	XCHG	AH,AL			; Count to AL
  5751 00000708 30E4                    	XOR	AH,AH			; Make word for add
  5752 0000070A 01C6                    	ADD	SI,AX			; Next table entry
  5753 0000070C EBEE                    	JMP	short TABLK2
  5754                                  
  5755                                  NOT_IN_TABLE:
  5756 0000070E 88F8                    	MOV	AL,BH			; Restore original code
  5757 00000710 EB0C                    	JMP	SHORT NO_MAP
  5758                                  
  5759                                  GOT_CALL:
  5760 00000712 88E1                    	MOV	CL,AH
  5761 00000714 30ED                    	XOR	CH,CH			; Count of valid err codes to CX
  5762                                  CHECK_CODE:
  5763                                  	; 15/05/2019 - Retro DOS v4.0
  5764 00000716 2E                      	cs
  5765 00000717 AC                      	lodsb	; MSDOS 6.0 (MSDOS 6.21 - MSDOS.SYS, DOSCODE:4497h)
  5766                                  
  5767                                  	; 18/07/2018
  5768                                  	;lodsb		; IBMDOS.COM (MSDOS 3.3) - Offset 1710h
  5769                                  
  5770 00000718 38F8                    	CMP	AL,BH			; Code OK?
  5771 0000071A 7402                    	JZ	short NO_MAP		; Yes
  5772 0000071C E2F8                    	LOOP	CHECK_CODE
  5773                                  NO_MAP:
  5774 0000071E 30E4                    	XOR	AH,AH			; AX is now valid code
  5775 00000720 5B                      	POP	BX
  5776 00000721 59                      	POP	CX
  5777 00000722 5E                      	POP	SI
  5778 00000723 1F                      	POP	DS
  5779 00000724 C3                      	retn
  5780                                  
  5781                                  	;EndProc ETAB_LK
  5782                                  
  5783                                  ; 18/07/2018 - Retro DOS v3.0
  5784                                  ;---------------------------------------------------------------------------
  5785                                  ; BREAK <DOS 2F Handler and default NET 2F handler>
  5786                                  
  5787                                  ;IF installed ; (*)
  5788                                  
  5789                                  ;---------------------------------------------------------------------------
  5790                                  ;
  5791                                  ; Procedure Name : SetBad
  5792                                  ;
  5793                                  ; SetBad sets up info for bad functions
  5794                                  ;
  5795                                  ;---------------------------------------------------------------------------
  5796                                  
  5797                                  SetBad:
  5798                                  	;mov	ax,1
  5799 00000725 B80100                  	MOV	AX,error_invalid_function ; ALL NET REQUESTS get inv func
  5800                                  
  5801                                  	; MSDOS 3.3
  5802                                  	;;mov	byte [cs:EXTERR_LOCUS],1
  5803                                  	;MOV	byte [CS:EXTERR_LOCUS],errLOC_Unk
  5804                                  
  5805                                  ;	set up ds to point to DOSDATA
  5806                                  
  5807                                  	; 15/05/2019 - Retro DOS v4.0
  5808                                  	; MSDOS 6.0
  5809 00000728 1E                      	push	ds
  5810                                  
  5811                                  	;getdseg <ds>
  5812 00000729 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5813                                  
  5814 0000072E C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1	
  5815                                  
  5816 00000733 1F                      	pop	ds	  	;hkn; restore ds
  5817                                  
  5818 00000734 F9                      	STC
  5819 00000735 C3                      	retn
  5820                                  
  5821                                  ;--------------------------------------------------------------------------
  5822                                  ;
  5823                                  ; Procedure Name : BadCall
  5824                                  ;
  5825                                  ; BadCall is the initial routine for bad function calls
  5826                                  ;
  5827                                  ;--------------------------------------------------------------------------
  5828                                  
  5829                                  BadCall:
  5830 00000736 E8ECFF                  	call	SetBad
  5831 00000739 CB                      	retf
  5832                                  
  5833                                  ;--------------------------------------------------------------------------
  5834                                  ;
  5835                                  ; OKCall always sets carry to off.
  5836                                  ;
  5837                                  ;-----------------------------------------------------------------------
  5838                                  
  5839                                  OKCall:
  5840 0000073A F8                      	CLC
  5841 0000073B CB                      	retf
  5842                                  
  5843                                  ;---------------------------------------------------------------------------
  5844                                  ;
  5845                                  ; Procedure Name : INT2F
  5846                                  ;
  5847                                  ; INT 2F handler works as follows:
  5848                                  ;   PUSH    AX
  5849                                  ;   MOV     AX,multiplex:function
  5850                                  ;   INT     2F
  5851                                  ;   POP     ...
  5852                                  ; The handler itself needs to make the AX available for the various routines.
  5853                                  ;
  5854                                  ;----------------------------------------------------------------------------
  5855                                  
  5856                                  ; 15/05/2019 - Retro DOS v4.0
  5857                                  
  5858                                  ;KERNEL_SEGMENT equ 70h
  5859                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5860                                  DOSBIODATASEG equ 70h
  5861                                  
  5862                                  ; retrodos4.s - offset in BIOSDATA
  5863                                  bios_i2f equ 5
  5864                                  
  5865                                  ;PUBLIC	Int2F
  5866                                  ;INT2F	PROC	FAR
  5867                                  
  5868                                  ; 15/05/2019
  5869                                  ; DOSCODE:44BDh (MSDOS 6.21, MSDOS.SYS)
  5870                                  
  5871                                  ; 04/11/2022
  5872                                  ; DOSCODE:44B0h (MSDOS 5.0, MSDOS.SYS)
  5873                                  
  5874                                  	; 15/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5875                                  	; 18/07/2018 - Retro DOS v3.0
  5876                                  	; 05/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  5877                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:45DAh
  5878                                  INT2F:
  5879                                  	; Offset 172Fh in IBMDOS.COM (MSDOS 3.3), 1987
  5880                                  INT2FNT:
  5881                                  	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
  5882 0000073C FB                      	STI
  5883                                  	;cmp	ah,11h
  5884 0000073D 80FC11                  	CMP	AH,MultNET
  5885 00000740 750A                    	JNZ	short INT2FSHR
  5886                                  TestInstall:
  5887 00000742 08C0                    	OR	AL,AL
  5888 00000744 7403                    	JZ	short Leave2F
  5889                                  BadFunc:
  5890 00000746 E8DCFF                  	CALL	SetBad
  5891                                  
  5892                                  	;entry	Leave2F
  5893                                  Leave2F:
  5894 00000749 CA0200                  	RETF	2			; long return + clear flags off stack
  5895                                  
  5896                                  INT2FSHR:
  5897                                  	;cmp	ah,10h
  5898 0000074C 80FC10                  	CMP	AH,MultSHARE		; is this a share request
  5899 0000074F 74F1                    	JZ	short TestInstall	; yes, check for installation
  5900                                  INT2FNLS:
  5901                                  	;cmp	ah,14h
  5902 00000751 80FC14                  	CMP	AH,NLSFUNC		; is this a DOS 3.3 NLSFUNC request
  5903 00000754 74EC                    	JZ	short TestInstall	; yes check for installation
  5904                                  INT2FDOS:
  5905                                  	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
  5906                                  
  5907                                  	; 18/07/2018
  5908                                  	; MSDOS 3.3
  5909                                  	;;cmp	ah,12h	
  5910                                  	;CMP	AH,MultDOS
  5911                                  	;jz	short DispatchDOS
  5912                                  	;iret
  5913                                  
  5914                                  	; 15/05/2019
  5915                                  	; MSDOS 6.0
  5916                                  	;cmp	ah,12h	; 07/12/2022
  5917 00000756 80FC12                  	CMP	AH,MultDOS
  5918 00000759 7503                    	JNZ	short check_win		;check if win386 broadcast
  5919 0000075B E93F02                  	jmp	DispatchDOS
  5920                                  
  5921                                  	; .... win386 .... 
  5922                                  
  5923                                  check_win:
  5924                                  	;cmp	ah,16h
  5925 0000075E 80FC16                  	cmp	ah,MultWin386		; Is this a broadcast from Win386?
  5926 00000761 7408                    	je	short Win386_Msg
  5927                                  
  5928                                  	; M044
  5929                                  	; Check if the callout is from Winoldap indicating swapping out or in 
  5930                                  	; of Windows. If so, do special action of going and saving last para
  5931                                  	; of the Windows memory arena which Winoldap does not save due to a 
  5932                                  	; bug
  5933                                  
  5934 00000763 80FC46                  	cmp	ah,WINOLDAP ; 46h	; from Winoldap?
  5935                                  	;jne	short next_i2f		; no, chain on
  5936                                  	; 15/12/2022
  5937                                  	;jmp	winold_swap		; yes, do desired action
  5938 00000766 7460                    	je	short winold_swap
  5939 00000768 E92301                  	jmp	next_i2f
  5940                                  
  5941                                  	; 15/12/2022
  5942                                  ;next_i2f:
  5943                                  ;	;;;jmp	bios_i2f
  5944                                  ;	;;jmp	far ptr 70h:5 ; MSDOS 6.21 (MSDOS.SYS, DOSCODE:44F1h)
  5945                                  ;	;jmp	KERNEL_SEGMENT:bios_i2f
  5946                                  ;	; 04/11/2022
  5947                                  ;	jmp	DOSBIODATASEG:bios_i2f
  5948                                  
  5949                                  ;	IRET				; This assume that we are at the head
  5950                                  					; of the list
  5951                                  ;INT2F	ENDP
  5952                                  
  5953                                  ; 15/05/2019 - Retro DOS v4.0
  5954                                  
  5955                                  ; We have received a message from Win386. There are three possible
  5956                                  ; messages we could get from Win386:
  5957                                  ;
  5958                                  ; Init 		- for this, we set the IsWin386 flag and return a pointer
  5959                                  ;		  to the Win386 startup info structure.
  5960                                  ; Exit		- for this, we clear the IsWin386 flag.
  5961                                  ; DOSMGR query 	- for this, we need to indicate that instance data
  5962                                  ;		  has already been handled. this is indicated by setting
  5963                                  ;		  CX to a non-zero value.
  5964                                  
  5965                                  Win386_Msg:
  5966 0000076B 1E                      	push	ds
  5967                                  
  5968                                  	;getdseg <DS>			; ds is DOSDATA
  5969 0000076C 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5970                                  
  5971                                  	; For WIN386 2.xx instance data
  5972                                  
  5973 00000771 3C03                    	cmp	al,3			; win386 2.xx instance data call?
  5974 00000773 7503                    	jne	short Win386_Msg_exit
  5975 00000775 E94801                  	jmp	OldWin386Init		; yes, return instance data
  5976                                  Win386_Msg_exit:
  5977 00000778 3C06                    	cmp	al,Win386_Exit	 ; 6	; is it an exit call?
  5978 0000077A 7503                    	jne	short Win386_Msg_devcall
  5979 0000077C E94A01                  	jmp	Win386_Leaving
  5980                                  Win386_Msg_devcall:
  5981 0000077F 3C07                    	cmp	al,Win386_Devcall ; 7	; is it call from DOSMGR?
  5982 00000781 7503                    	jne	short Win386_Msg_init
  5983 00000783 E97E01                  	jmp	Win386_Query
  5984                                  Win386_Msg_init:
  5985 00000786 3C05                    	cmp	al,Win386_Init	; 5	; is it an init call?
  5986 00000788 7403                    	je	short Win386_Starting
  5987 0000078A E90001                  	jmp	win_nexti2f		; no, return
  5988                                  
  5989                                  Win386_Starting:
  5990                                  	; 05/01/2024 - Retro DOS v5.0
  5991                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:4630h
  5992                                  	;;;
  5993 0000078D 50                      	push	ax
  5994 0000078E 51                      	push	cx
  5995 0000078F 57                      	push	di
  5996 00000790 06                      	push	es
  5997 00000791 1E                      	push	ds
  5998 00000792 07                      	pop	es
  5999 00000793 BF[FB01]                	mov	di,INBUF
  6000 00000796 B90500                  	mov	cx,5
  6001 00000799 FC                      	cld
  6002                                  Win386_s_floop:
  6003 0000079A B8434F                  	mov	ax,'CO'	; 4F43h
  6004 0000079D AB                      	stosw
  6005 0000079E B84E20                  	mov	ax,'N '	; 204Eh
  6006 000007A1 AB                      	stosw
  6007 000007A2 83C737                  	add	di,55	; (write 5 times 'CON ' and skip 55 bytes between them)
  6008                                  			; what for ?
  6009 000007A5 E2F3                    	loop	Win386_s_floop
  6010 000007A7 07                      	pop	es
  6011 000007A8 5F                      	pop	di
  6012 000007A9 59                      	pop	cx
  6013 000007AA 58                      	pop	ax
  6014                                  	;;;
  6015                                  
  6016                                  	; 17/12/2022
  6017 000007AB F6C201                  	test	dl,1
  6018                                  	;test	dx,1			; is this really win386?
  6019 000007AE 7403                    	jz	short Win386_vchk	; YES! go and handle it
  6020 000007B0 E9DA00                  	jmp	win_nexti2f		; NO! It's win 286 dos extender! M002
  6021                                  Win386_vchk:
  6022                                  	; M018 -- start of block changes
  6023                                  	; The VxD needs to be loaded only for Win 3.0. If version is greater 
  6024                                  	; than 030Ah, we skip the VxD presence check
  6025                                  
  6026                                  ;M067 -- Begin changes
  6027                                  ; If Win 3.0 is run, the VxD ptr has been initialized. If Win 3.1 is now
  6028                                  ;run, it tries to unnecesarily load the VxD even though it is not needed.
  6029                                  ;So, we null out the VxD ptr before the check.
  6030                                  
  6031                                  	;mov	word [Win386_Info+6],0
  6032 000007B3 C706[2D10]0000          	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr],0
  6033                                  	;mov	word [Win386_Info+8],0
  6034 000007B9 C706[2F10]0000          	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2],0
  6035                                  
  6036                                  ;M067 -- End changes
  6037                                  
  6038                                  ;ifdef JAPAN
  6039                                  ;	cmp	di,0300h		; version >= 300 i.e 3.10 ;M037
  6040                                  ;else
  6041                                  	;cmp	di,030Ah		; version >= 30a i.e 3.10 ;M037
  6042                                  	; 05/01/2024 - PCDOS 7.1 - Retro DOS v5.0
  6043 000007BF 81FF0004                	cmp	di,0400h		; version >= 400 ; 05/01/2024
  6044                                  ;endif
  6045                                  	;ljae	noVxD31			; yes, VxD not needed 	 ;M037
  6046 000007C3 724E                    	jb	short Win386_vxd
  6047 000007C5 E9DD00                  	jmp	noVxD31
  6048                                  
  6049                                  	; 15/12/2022
  6050                                  winold_swap:
  6051 000007C8 1E                      	push	ds
  6052 000007C9 06                      	push	es
  6053 000007CA 56                      	push	si
  6054 000007CB 57                      	push	di
  6055 000007CC 51                      	push	cx
  6056                                  
  6057                                  	;getdseg <ds>			;ds = DOSDATA
  6058 000007CD 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6059                                  
  6060 000007D2 3C01                    	cmp	al,1			;swap Windows out call
  6061 000007D4 751B                    	jne	short swapin		;no, check if Swap in call
  6062 000007D6 E88801                  	call	getwinlast
  6063 000007D9 1E                      	push	ds
  6064 000007DA 07                      	pop	es
  6065 000007DB 8EDE                    	mov	ds,si			;ds = memory arena of Windows
  6066 000007DD 31F6                    	xor	si,si
  6067                                  	;mov	di,6 ; 05/01/2024
  6068 000007DF BF[0600]                	mov	di,WinoldPatch1 ; 6
  6069 000007E2 B90800                  	mov	cx,8
  6070 000007E5 FC                      	cld
  6071 000007E6 51                      	push	cx
  6072 000007E7 F3A4                    	rep	movsb			;save first 8 bytes
  6073 000007E9 59                      	pop	cx
  6074                                  	;mov	di,1176h ; 05/01/2024
  6075 000007EA BF[9D12]                	mov	di,WinoldPatch2 ; 1176h
  6076 000007ED F3A4                    	rep	movsb			;save next 8 bytes
  6077 000007EF EB1B                    	jmp	short winold_done
  6078                                  swapin:
  6079 000007F1 3C02                    	cmp	al,2			;swap Windows in call?
  6080 000007F3 7517                    	jne	short winold_done	;no, something else, pass it on
  6081 000007F5 E86901                  	call	getwinlast
  6082 000007F8 8EC6                    	mov	es,si
  6083 000007FA 31FF                    	xor	di,di
  6084 000007FC BE[0600]                	mov	si,WinoldPatch1
  6085 000007FF B90800                  	mov	cx,8
  6086 00000802 FC                      	cld
  6087 00000803 51                      	push	cx
  6088 00000804 F3A4                    	rep	movsb			;restore first 8 bytes
  6089 00000806 59                      	pop	cx
  6090 00000807 BE[9D12]                	mov	si,WinoldPatch2
  6091 0000080A F3A4                    	rep	movsb			;restore next 8 bytes
  6092                                  winold_done:
  6093 0000080C 59                      	pop	cx
  6094 0000080D 5F                      	pop	di
  6095 0000080E 5E                      	pop	si
  6096 0000080F 07                      	pop	es
  6097 00000810 1F                      	pop	ds
  6098 00000811 EB7B                    	jmp	short next_i2f		;chain on
  6099                                  	; 15/12/2022
  6100                                  	;jmp	next_i2f	
  6101                                  
  6102                                  Win386_vxd:
  6103 00000813 50                      	push	ax
  6104 00000814 53                      	push	bx
  6105 00000815 51                      	push	cx
  6106 00000816 52                      	push	dx
  6107 00000817 56                      	push	si
  6108 00000818 57                      	push	di			; save regs !!dont change order!!
  6109                                  
  6110 00000819 8B1E[8C00]              	mov	bx,[UMB_HEAD]		; M062 - Start
  6111 0000081D 83FBFF                  	cmp	bx,0FFFFh    		; Q: have umbs been initialized
  6112 00000820 741F                    	je	short Vxd31		; N: continue
  6113                                  					; Y: save arena associated with 
  6114                                  					;    umb_head
  6115                                  
  6116 00000822 C606[210E]01            	mov	byte [UmbSaveFlag],1	; indicate that we're saving 
  6117                                  					; umb_arena
  6118 00000827 1E                      	push	ds
  6119 00000828 06                      	push	es
  6120                                  
  6121                                  	;mov	ax,ds
  6122                                  	;mov	es,ax			; es - > dosdata
  6123                                  	; 05/01/2024
  6124 00000829 1E                      	push	ds
  6125 0000082A 07                      	pop	es
  6126                                  
  6127 0000082B 8EDB                    	mov	ds,bx
  6128 0000082D 31F6                    	xor	si,si			; ds:si -> umb_head
  6129                                  
  6130                                  	; 05/01/2024 PCDOS 7.1
  6131                                  	;;;			
  6132                                  	;clc	; not necessary (XOR already clears CF)
  6133                                  
  6134                                  restore_ubmhead:		; !! PCDOS 7.1 bug !!
  6135                                  				; jump from 'Win386_Leaving' here was/is wrong
  6136                                  				; (DI and SI would be reversed for 'Win386_Leaving')
  6137                                  				; Erdogan Tan - 05/01/2024
  6138                                  	;;;
  6139                                  
  6140 0000082F FC                      	cld
  6141                                  
  6142 00000830 BF[5612]                	mov	di,UmbSave1
  6143 00000833 B90B00                  	mov	cx,11
  6144 00000836 F3A4                    	rep	movsb
  6145                                  
  6146 00000838 BF[1C0E]                	mov	di,UmbSave2
  6147                                  	;mov	cx,5
  6148                                  	; 18/12/2022
  6149 0000083B B105                    	mov	cl,5
  6150 0000083D F3A4                    	rep	movsb
  6151                                  	
  6152                                  	; 05/01/2024 PCDOS 7.1
  6153                                  	;;;	
  6154                                  	;jnb	short restore_ubmhead_c ; (not jumped from 'Win386_Leaving')
  6155                                  	;jmp	restore_ubmhead_ok ; (jumped from 'Win386_Leaving' just after 'stc')
  6156                                  ;restore_ubmhead_c:
  6157                                  	;;;
  6158                                  
  6159 0000083F 07                      	pop	es
  6160 00000840 1F                      	pop	ds			; M062 - End
  6161                                  
  6162                                  Vxd31:
  6163                                  	;test	byte [DOS_FLAG],2
  6164 00000841 F606[8600]02            	test	byte [DOS_FLAG],SUPPRESS_WINA20	; M066
  6165 00000846 7408                    	jz	short Dont_Supress		; M066
  6166 00000848 5F                      	pop	di				; M066
  6167 00000849 5E                      	pop	si				; M066
  6168 0000084A 5A                      	pop	dx				; M066
  6169 0000084B 59                      	pop	cx				; M066
  6170 0000084C 5B                      	pop	bx				; M066
  6171 0000084D 58                      	pop	ax				; M066
  6172 0000084E EB55                    	jmp	short noVxD31			; M066
  6173                                  
  6174                                  	; We check here if the VxD is available in the root of the boot drive. 
  6175                                  	; We do an extended open to suppress any error messages
  6176                                  	
  6177                                  Dont_Supress:
  6178 00000850 A0[6900]                	mov	al,[BOOTDRIVE]
  6179 00000853 0440                    	add	al,'A' - 1		; get drive letter
  6180 00000855 A2[1F14]                	mov	[VxDpath],al		; path is root of bootdrive
  6181                                  	;mov	ah,ExtOpen  ;6Ch	; extended open
  6182                                  	;mov	al,0			; no extended attributes
  6183                                  	; 18/12/2022
  6184 00000858 B8006C                  	mov	ax,ExtOpen<<8 ; 6C00h
  6185 0000085B BB8020                  	mov	bx,2080h		; read access, compatibility mode
  6186                                  					; no inherit, suppress crit err
  6187 0000085E B90700                  	mov	cx,7			; hidden,system,read-only attr
  6188                                  	;05/01/2024
  6189                                  	;inc	dx			; dx bit 0 = 1 ; fail if file does not exist
  6190 00000861 BA0100                  	mov	dx,1			; fail if file does not exist
  6191                                  	
  6192 00000864 BE[1F14]                	mov	si,VxDpath ; "c:\\wina20.386"	
  6193                                  					; path of VxD file
  6194 00000867 BFFFFF                  	mov	di,0FFFFh		; no extended attributes
  6195                                  
  6196 0000086A CD21                    	int	21h			; do extended open
  6197                                  
  6198 0000086C 5F                      	pop	di
  6199 0000086D 5E                      	pop	si
  6200 0000086E 5A                      	pop	dx
  6201 0000086F 59                      	pop	cx
  6202                                  
  6203 00000870 7321                    	jnc	short VxDthere		; we found the VxD, go ahead
  6204                                  
  6205                                  	; We could not find the VxD. Cannot let windows load. Return cx != 0 
  6206                                  	; to indicate error to Windows after displaying message to user that 
  6207                                  	; VxD needs to be present to run Windows in enhanced mode.
  6208                                  
  6209 00000872 52                      	push	dx
  6210 00000873 1E                      	push	ds
  6211 00000874 56                      	push	si
  6212 00000875 BE[320A]                	mov	si,NoVxDErrMsg
  6213 00000878 0E                      	push	cs
  6214 00000879 1F                      	pop	ds
  6215 0000087A B96300                  	mov	cx,VxDMesLen ; 99	;
  6216 0000087D B402                    	mov	ah,2			; write char to console
  6217 0000087F FC                      	cld
  6218                                  vxdlp:
  6219 00000880 AC                      	lodsb
  6220 00000881 86D0                    	xchg	dl,al			; get char in dl
  6221 00000883 CD21                    	int	21h
  6222 00000885 E2F9                    	loop	vxdlp
  6223                                  
  6224 00000887 5E                      	pop	si
  6225 00000888 1F                      	pop	ds
  6226 00000889 5A                      	pop	dx
  6227 0000088A 5B                      	pop	bx
  6228 0000088B 58                      	pop	ax			;all registers restored
  6229 0000088C 41                      	inc	cx			;cx != 0 to indicate error
  6230                                  	; 15/12/22022
  6231                                  	;jmp	win_nexti2f		;chain on
  6232                                  	;jmp	short win_nexti2f
  6233                                  
  6234                                  	; 15/12/2022
  6235                                  win_nexti2f:
  6236 0000088D 1F                      	pop	ds
  6237                                  	;jmp	short next_i2f		; go to BIOS i2f handler
  6238                                  	; 15/12/2022
  6239                                  next_i2f:
  6240                                  	;;;jmp	bios_i2f
  6241                                  	;;jmp	far ptr 70h:5 ; MSDOS 6.21 (MSDOS.SYS, DOSCODE:44F1h)
  6242                                  	;jmp	KERNEL_SEGMENT:bios_i2f
  6243                                  	; 04/11/2022
  6244 0000088E EA05007000              	jmp	DOSBIODATASEG:bios_i2f
  6245                                  
  6246                                  VxDthere:
  6247 00000893 89C3                    	mov	bx,ax
  6248 00000895 B43E                    	mov	ah,CLOSE ; 3Eh
  6249 00000897 CD21                    	int	21h			;close the file
  6250                                  
  6251                                  	; Update the VxD ptr in the instance data structure with path to VxD
  6252                                  
  6253                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  6254                                  	;mov	bx,Win386_Info
  6255                                  	;mov	word [bx+Win386_SIS.Virt_Dev_File_Ptr],VxDpath
  6256                                  	;mov	word [bx+Win386_SIS.Virt_Dev_File_Ptr+2],ds
  6257                                  	; 15/12/2022
  6258 00000899 C706[2D10][1F14]        	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr],VxDpath
  6259 0000089F 8C1E[2F10]              	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2],ds
  6260                                  
  6261 000008A3 5B                      	pop	bx
  6262 000008A4 58                      	pop	ax
  6263                                  noVxD31:
  6264                                  	; M018; End of block changes
  6265                                  
  6266 000008A5 800E[A110]01            	or	byte [IsWin386],1 	; Indicate WIN386 present
  6267 000008AA 800E[860D]01            	or	byte [redir_patch],1	; Enable critical sections; M002
  6268                                  
  6269                                  	; M002;
  6270                                  	; Save the previous es:bx (instance data ptr) into our instance table
  6271                                  
  6272 000008AF 52                      	push	dx			; M002
  6273 000008B0 89DA                    	mov	dx,bx			; M002
  6274                                  					; point ES:BX to Win386_Info ; M002
  6275 000008B2 BB[2710]                	mov	bx,Win386_Info 
  6276 000008B5 895702                  	mov	[bx+2],dx		; M002
  6277 000008B8 8C4704                  	mov	[bx+4],es		; M002
  6278 000008BB 5A                      	pop	dx			; M002
  6279 000008BC 1E                      	push	ds			; M002
  6280 000008BD 07                      	pop	es			; M002
  6281                                  	;jmp	win_nexti2f		; M002
  6282                                  	; 15/12/2022
  6283 000008BE EBCD                    	jmp	short win_nexti2f
  6284                                  
  6285                                  	; 15/12/2022
  6286                                  	; Code to return Win386 2.xx instance table
  6287                                  OldWin386Init:
  6288 000008C0 58                      	pop	ax			; discard ds pushed on stack
  6289 000008C1 BE[2C12]                	mov	si,OldInstanceJunk 
  6290                                  					; ds:si = instance table
  6291 000008C4 B84852                  	mov	ax,5248h ; 'HR'		; indicate instance data present
  6292                                  	;jmp	next_i2f
  6293                                  	; 15/12/2022
  6294 000008C7 EBC5                    	jmp	short next_i2f
  6295                                  
  6296                                  Win386_Leaving:
  6297                                  	; 15/12/2022
  6298 000008C9 F6C201                  	test 	dl,1
  6299                                  	;test	dx,1			; is this really win386?
  6300                                  	;jz	short Win386_Leaving_c
  6301                                  	;jmp	win_nexti2f		; NO! It's win 286 dos extender! M002
  6302                                  	; 15/12/2022
  6303 000008CC 75BF                    	jnz	short win_nexti2f	
  6304                                  
  6305                                  Win386_Leaving_c:
  6306                                  					; M062 - Start
  6307 000008CE 803E[210E]01            	cmp	byte [UmbSaveFlag],1	; Q: was umb_arena saved at win start
  6308                                  					;    up.
  6309 000008D3 7523                    	jne	short noumb		; N: not saved 
  6310 000008D5 C606[210E]00            	mov	byte [UmbSaveFlag],0	; Y: clear UmbSaveFlag and restore 
  6311                                  					;    previously saved umb_head
  6312                                  
  6313                                  	; 05/01/2024 - PCDOS 7.1 (has BUG here!)
  6314                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:472Bh
  6315                                  	;;;
  6316                                  	;push	ax ; (not necessary)
  6317                                  	;push	es
  6318                                  	;push	cx
  6319                                  	;push	si
  6320                                  	;push	di
  6321                                  	;mov	es,[UMB_HEAD]
  6322                                  	;xor	di,di
  6323                                  	;stc
  6324                                  	;jmp	restore_ubmhead	; !! PCDOS 7.1 bug !! IBMDOS.COM - DOSCODE:4737h
  6325                                  	;			; (jumped code does not restore umbhead,
  6326                                  	;			; MSDOS 6.22 "Win386_Leaving" code was/is correct,
  6327                                  	;			; modified code -in PCDOS 7.1 IBMDOS.COM- is wrong)
  6328                                  	;			; Erdogan Tan - 05/01/2024
  6329                                  	;
  6330                                  	;;;
  6331                                  
  6332                                  	; 05/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1)
  6333                                  	;push	ax ; (not necessary)
  6334 000008DA 06                      	push	es
  6335 000008DB 51                      	push	cx
  6336 000008DC 56                      	push	si
  6337 000008DD 57                      	push	di
  6338                                  
  6339                                  	;mov	ax,[UMB_HEAD]
  6340                                  	;mov	es,ax
  6341                                  	; 05/01/2024
  6342 000008DE 8E06[8C00]              	mov	es,[UMB_HEAD]
  6343 000008E2 31FF                    	xor	di,di			; es:di -> umb_head
  6344                                  
  6345 000008E4 FC                      	cld
  6346                                  
  6347 000008E5 BE[5612]                	mov	si,UmbSave1
  6348 000008E8 B90B00                  	mov	cx,11
  6349 000008EB F3A4                    	rep	movsb
  6350 000008ED BE[1C0E]                	mov	si,UmbSave2
  6351                                  	;mov	cx,5
  6352                                  	; 18/12/2022
  6353 000008F0 B105                    	mov	cl,5
  6354 000008F2 F3A4                    	rep	movsb
  6355                                  
  6356                                  restore_ubmhead_ok:	; 05/01/2024 - PCDOS 7.1 IBMDOS.COM - DOSCODE:473Ah
  6357 000008F4 5F                      	pop	di
  6358 000008F5 5E                      	pop	si
  6359 000008F6 59                      	pop	cx
  6360 000008F7 07                      	pop	es
  6361                                  	; 05/01/2024
  6362                                  	;pop	ax
  6363                                  noumb:					; M062 - End
  6364 000008F8 8026[A110]00            	and	byte [IsWin386],0	; Win386 is gone
  6365 000008FD 8026[860D]00            	and	byte [redir_patch],0	; Disable critical sections ; M002
  6366 00000902 EB89                    	jmp	short win_nexti2f
  6367                                  
  6368                                  ;	; 15/12/2022
  6369                                  ;	; Code to return Win386 2.xx instance table
  6370                                  ;OldWin386Init:
  6371                                  ;	pop	ax			; discard ds pushed on stack
  6372                                  ;	mov	si,OldInstanceJunk 
  6373                                  ;					; ds:si = instance table
  6374                                  ;	mov	ax,5248h ; 'RH'		; indicate instance data present
  6375                                  ;	;jmp	next_i2f
  6376                                  ;	; 15/12/2022
  6377                                  ;	jmp	short _next_i2f
  6378                                  
  6379                                  Win386_Query:
  6380 00000904 83FB15                  	cmp	bx,Win386_DOSMGR ; 15h	; is this from DOSMGR?
  6381 00000907 7584                    	jne	short win_nexti2f     	; no, ignore it & chain to next
  6382 00000909 09C9                    	or	cx,cx			; is it an instance query?
  6383 0000090B 7508                    	jnz	short dosmgr_func	; no, some DOSMGR query
  6384 0000090D 41                      	inc	cx			; indicate that data is instanced
  6385                                  ;
  6386                                  ; M001; We were previously returning a null ptr in es:bx. This will not work.
  6387                                  ; M001; WIN386 needs a ptr to a table in es:bx with the following offsets:
  6388                                  ; M001;  
  6389                                  ; M001; OFFSETS STRUC
  6390                                  ; M001; 	Major_version	db	?
  6391                                  ; M001; 	Minor_version	db	?
  6392                                  ; M001; 	SaveDS		dw	?
  6393                                  ; M001; 	SaveBX		dw	?
  6394                                  ; M001; 	Indos		dw	?
  6395                                  ; M001; 	User_id		dw	?
  6396                                  ; M001; 	CritPatch	dw	?
  6397                                  ; M001; OFFSETS	ENDS
  6398                                  ; M001; 
  6399                                  ; M001; User_Id is the only variable really important for proper functioning  
  6400                                  ; M001; of Win386. The other variables are used at init time to patch stuff
  6401                                  ; M001; out. In DOS 5.0, we do the patching ourselves. But we still need to 
  6402                                  ; M001; pass this table because Win386 depends on this table to get the 
  6403                                  ; M001; User_Id offset.
  6404                                  ; M001; 
  6405 0000090E BB[9310]                	mov	bx,Win386_DOSVars	; M001 
  6406 00000911 1E                      	push	ds			; M001
  6407 00000912 07                      	pop	es			; es:bx points at offset table ; M001
  6408 00000913 EB40                    	jmp	short PopIret		; M001
  6409                                  
  6410                                  ; 15/12/2022
  6411                                  ;	; Code to return Win386 2.xx instance table
  6412                                  ;OldWin386Init:
  6413                                  ;	pop	ax			; discard ds pushed on stack
  6414                                  ;	mov	si,OldInstanceJunk 
  6415                                  ;					; ds:si = instance table
  6416                                  ;	mov	ax,5248h ; 'RH'		; indicate instance data present
  6417                                  ;	;jmp	next_i2f
  6418                                  ;	; 15/12/2022
  6419                                  ;	jmp	short _next_i2f
  6420                                  
  6421                                  dosmgr_func:
  6422 00000915 49                      	dec	cx
  6423 00000916 7435                    	jz	short win386_patch	; call to patch DOS
  6424 00000918 49                      	dec	cx
  6425 00000919 743A                    	jz	short PopIret		; remove DOS patches, ignore
  6426 0000091B 49                      	dec	cx
  6427 0000091C 7439                    	jz	short win386_size	; get size of DOS data structures
  6428 0000091E 49                      	dec	cx
  6429 0000091F 7428                    	jz	short win386_inst	; instance more data
  6430                                  	;dec	cx
  6431                                  	;jnz	short PopIret		; no functions above this
  6432                                  	; 05/01/2024 (PCDOS 7.1 IBMDOS.COM DOSCODE:4771h)
  6433 00000921 E232                    	loop	PopIret
  6434                                  
  6435                                  	; Get DOS device driver size -- es:di points at device driver header
  6436                                  	; In DOS 4.x, the para before the device header contains an arena 
  6437                                  	; header for the driver.
  6438                                  
  6439 00000923 8CC0                    	mov	ax,es			; ax = device header segment
  6440                                  
  6441                                  	; We check to see if we have a memory arena for this device driver. 
  6442                                  	; The way to do this would be to look at the previous para to see if
  6443                                  	; it has a 'D' marking it as an arena and also see if the owner-field 
  6444                                  	; in the arena is the same as the device header segment. These two 
  6445                                  	; checks together should take care of all cases
  6446                                  
  6447 00000925 48                      	dec	ax			; get arena header
  6448 00000926 06                      	push	es
  6449 00000927 8EC0                    	mov	es,ax			; arena header for device driver
  6450                                  
  6451 00000929 26803D44                	cmp	byte [es:di],'D'	; is it a device arena?
  6452 0000092D 7517                    	jnz	short cantsize		; no, cant size this driver
  6453 0000092F 40                      	inc	ax			; get back device header segment
  6454 00000930 26394501                	cmp	[es:di+1],ax		; owner field pointing at driver?
  6455 00000934 7510                    	jnz	short cantsize		; no, not a proper arena
  6456                                  
  6457 00000936 268B4503                	mov	ax,[es:di+3]		; get arena size in paras
  6458 0000093A 07                      	pop	es
  6459                                  
  6460                                  	; We have to multiply by 16 to get the number of bytes in (bx:cx)
  6461                                  	; Speed is not critical and so we choose the shortest method 
  6462                                  	; -- use "mul"
  6463                                  
  6464 0000093B BB1000                  	mov	bx,16
  6465 0000093E F7E3                    	mul	bx
  6466 00000940 89C1                    	mov	cx,ax
  6467 00000942 89D3                    	mov	bx,dx
  6468 00000944 EB09                    	jmp	short win386_done	; return with device driver size
  6469                                  cantsize:
  6470 00000946 07                      	pop	es
  6471 00000947 31C0                    	xor	ax,ax
  6472                                  win386_inst:	; 05/01/2024
  6473 00000949 31D2                    	xor	dx,dx			; ask DOSMGR to use its methods
  6474 0000094B EB08                    	jmp	short PopIret		; return
  6475                                  
  6476                                  win386_patch:
  6477                                  	; dx contains bits marking the patches to be applied. We return 
  6478                                  	; the field with all bits set to indicate that all patches have been
  6479                                  	; done
  6480                                  
  6481 0000094D 89D3                    	mov	bx,dx			; move patch bitfield to bx
  6482                                   	;jmp	short win386_done	; done, return
  6483                                  	; 15/12/2022
  6484                                  	; 15/12/2022
  6485                                  win386_done:
  6486 0000094F B87CB9                  	mov	ax,WIN_OP_DONE		; 0B97Ch
  6487 00000952 BAABA2                  	mov	dx,DOSMGR_OP_DONE	; 0A2ABh
  6488                                  PopIret:
  6489 00000955 1F                      	pop	ds
  6490 00000956 CF                      	iret	
  6491                                  
  6492                                  win386_size:
  6493                                  	; Return the size of DOS data structures -- currently only CDS size
  6494                                  
  6495                                  	; 17/12/2022
  6496 00000957 F6C201                  	test	dl,1
  6497                                  	;test	dx,1			; check for CDS size bit
  6498 0000095A 74F9                    	jz	short PopIret		; no, unknown structure -- return
  6499                                  
  6500 0000095C B95800                  	mov	cx,curdirLen	; 88 	; cx = CDS size
  6501 0000095F EBEE                    	jmp	short win386_done	; return with the size
  6502                                  
  6503                                  ; 05/01/2024
  6504                                  %if 0
  6505                                  win386_inst:
  6506                                  	; WIN386 check to see if DOS has identified the CDS,SFT and device
  6507                                  	; chain as instance data. Currently, we let the WIN386 DOSMGR handle
  6508                                  	; this by returning a status of not previously instanced. The basic
  6509                                  	; structure of these things have not changed and so the current 
  6510                                  	; DOSMGR code should be able to work it out
  6511                                  
  6512                                  	xor	dx,dx			; make sure dx has a not done value
  6513                                  	jmp	short PopIret		; skip done indication
  6514                                  %endif
  6515                                  
  6516                                  	; 15/12/2022
  6517                                  ;win386_done:
  6518                                  ;	mov	ax,WIN_OP_DONE		; 0B97Ch
  6519                                  ;	mov	dx,DOSMGR_OP_DONE	; 0A2ABh
  6520                                  ;PopIret:
  6521                                  ;	pop	ds
  6522                                  ;	iret				; return back up the chain
  6523                                  
  6524                                  	; 15/12/2022
  6525                                  ;win_nexti2f:
  6526                                  	;pop	ds
  6527                                  	;jmp	next_i2f		; go to BIOS i2f handler
  6528                                  
  6529                                  ;End WIN386 support
  6530                                  
  6531                                  ; 15/05/2019
  6532                                  
  6533                                  ;M044; Start of changes
  6534                                  ; Winoldap has a bug in that its calculations for the Windows memory image
  6535                                  ; to save is off by 1 para. This para can happen to be a Windows arena if the
  6536                                  ; DOS top of memory happens to be at an odd boundary (as is the case when
  6537                                  ; UMBs are present). This is because Windows builds its arenas only at even
  6538                                  ; para boundaries. This arena now gets trashed when Windows is swapped back
  6539                                  ; in leading to a crash. Winoldap issues callouts when it swaps Windows out
  6540                                  ; and back in. We sit on these callouts. On the Windows swapout, we save the
  6541                                  ; last para of the Windows memory block and then restore this para on the
  6542                                  ; Windows swapin callout. 
  6543                                  
  6544                                  getwinlast:
  6545                                  	; 07/12/2022
  6546 00000961 8B36[3003]              	mov	si,[CurrentPDB]
  6547 00000965 4E                      	dec	si
  6548 00000966 8EC6                    	mov	es,si
  6549 00000968 2603360300              	add	si,[es:3]
  6550 0000096D C3                      	retn
  6551                                  
  6552                                  ; 15/12/2022
  6553                                  %if 0
  6554                                  winold_swap:
  6555                                  	push	ds
  6556                                  	push	es
  6557                                  	push	si
  6558                                  	push	di
  6559                                  	push	cx
  6560                                  
  6561                                  	;getdseg <ds>			;ds = DOSDATA
  6562                                  	mov	ds,[cs:DosDSeg]
  6563                                  
  6564                                  	cmp	al,1			;swap Windows out call
  6565                                  	jne	short swapin		;no, check if Swap in call
  6566                                  	call	getwinlast
  6567                                  	push	ds
  6568                                  	pop	es
  6569                                  	mov	ds,si			;ds = memory arena of Windows
  6570                                  	xor	si,si
  6571                                  	mov	di,WinoldPatch1
  6572                                  	mov	cx,8
  6573                                  	cld
  6574                                  	push	cx
  6575                                  	rep	movsb			;save first 8 bytes
  6576                                  	pop	cx
  6577                                  	mov	di,WinoldPatch2
  6578                                  	rep	movsb			;save next 8 bytes
  6579                                  	jmp	short winold_done
  6580                                  swapin:
  6581                                  	cmp	al,2			;swap Windows in call?
  6582                                  	jne	short winold_done	;no, something else, pass it on
  6583                                  	call	getwinlast
  6584                                  	mov	es,si
  6585                                  	xor	di,di
  6586                                  	mov	si,WinoldPatch1
  6587                                  	mov	cx,8
  6588                                  	cld
  6589                                  	push	cx
  6590                                  	rep	movsb			;restore first 8 bytes
  6591                                  	pop	cx
  6592                                  	mov	si,WinoldPatch2
  6593                                  	rep	movsb			;restore next 8 bytes
  6594                                  winold_done:
  6595                                  	pop	cx
  6596                                  	pop	di
  6597                                  	pop	si
  6598                                  	pop	es
  6599                                  	pop	ds
  6600                                  	jmp	next_i2f		;chain on
  6601                                  
  6602                                  %endif
  6603                                  
  6604                                  ;M044; End of changes
  6605                                  
  6606                                  ; ---------------------------------------------------------------------
  6607                                  ; 06/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM/MSDOS.SYS)
  6608                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:4811h
  6609                                  
  6610                                  	; INT 2Fh AX=1231h
  6611                                  	; Windows95 - SET/CLEAR "REPORT WINDOWS TO DOS PROGRAMS" FLAG
  6612                                  	; 			(Ref: Ralf Brown's Interrupt List)
  6613                                  int_2Fh_1231h:
  6614 0000096E 1E                      	push	ds
  6615 0000096F 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6616 00000974 31C0                    	xor	ax,ax ; 0
  6617 00000976 08D2                    	or	dl,dl
  6618 00000978 7507                    	jnz	short not_1231_dl_0
  6619 0000097A C606[A210]01            	mov	byte [IsWin386+1],1	; set byte after "IsWIN386" to 01h
  6620 0000097F EB1A                    	jmp	short int_2f_1231h_retn
  6621                                  
  6622                                  	;nop
  6623                                  
  6624                                  not_1231_dl_0:
  6625 00000981 80FA01                  	cmp	dl,1
  6626 00000984 7507                    	jne	short not_1231_dl_1	; clear "IsWIN386" bit 1
  6627 00000986 800E[A110]02            	or	byte [IsWin386],2	; set "IsWIN386" bit 1
  6628 0000098B EB0E                    	jmp	short int_2f_1231h_retn
  6629                                  
  6630                                  	;nop
  6631                                  
  6632                                  not_1231_dl_1:
  6633 0000098D 80FA02                  	cmp	dl,2
  6634 00000990 7507                    	jne	short not_1231_dl_2
  6635 00000992 8026[A110]FD            	and	byte [IsWin386],0FDh	; clear bit 1
  6636 00000997 EB02                    	jmp	short int_2f_1231h_retn
  6637                                  not_1231_dl_2:
  6638 00000999 40                      	inc	ax              	; return error, ax = 1
  6639 0000099A F9                      	stc
  6640                                  int_2f_1231h_retn:
  6641 0000099B 1F                      	pop	ds
  6642 0000099C C3                      	retn
  6643                                  
  6644                                  ; ---------------------------------------------------------------------
  6645                                  
  6646                                  ; 15/05/2019
  6647                                  
  6648                                  ; 06/01/2024 - Retro DOS v5.0
  6649                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:4842h
  6650                                  
  6651                                  DispatchDOS:
  6652 0000099D 2EFF36[D401]            	PUSH	word [CS:FOO]		; push return address
  6653 000009A2 2EFF36[D601]            	PUSH	word [CS:DTab]		; push table address
  6654 000009A7 50                      	PUSH	AX			; push index
  6655 000009A8 55                      	PUSH	BP
  6656 000009A9 89E5                    	MOV	BP,SP
  6657                                  		; stack looks like:
  6658                                  		;   0	BP
  6659                                  		;   2	DISPATCH
  6660                                  		;   4	TABLE
  6661                                  		;   6	RETURN
  6662                                  		;   8	LONG-RETURN
  6663                                  		;   C	FLAGS
  6664                                  		;   E	AX
  6665                                  	
  6666 000009AB 8B460E                  	MOV	AX,[BP+0Eh]		; get AX value
  6667 000009AE 5D                      	POP	BP
  6668 000009AF E8640E                  	call	TableDispatch
  6669 000009B2 E991FD                  	JMP	BadFunc 		; return indicates invalid function
  6670                                  
  6671                                  INT2F_etcetera:
  6672                                  	;entry	DosGetGroup
  6673                                  DosGetGroup:
  6674                                  	; MSDOS 3.3
  6675                                  	;push	cs
  6676                                  	;pop	ds
  6677                                  	;retn
  6678                                  
  6679                                  	; MSDOS 6.0
  6680                                  ;SR; Cannot use CS now
  6681                                  ;
  6682                                  ;	PUSH	CS
  6683                                  ;	POP	DS
  6684                                  
  6685                                  	; 04/11/2022
  6686                                  	; (MSDOS 5.0 MSDOS.SYS - DOSCODE:46FBh)
  6687                                  
  6688                                  	;getdseg <ds>
  6689 000009B5 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6690 000009BA C3                      	retn
  6691                                  
  6692                                  	;entry	DOSInstall
  6693                                  DOSInstall:
  6694 000009BB B0FF                    	MOV	AL,0FFh
  6695 000009BD C3                      	retn
  6696                                  
  6697                                  ;ENDIF ; (*)
  6698                                  
  6699                                  
  6700                                  ; 15/05/2019 - Retro DOS v4.0
  6701                                  ; 06/01/2024 - Retro DOS v5.0
  6702                                  
  6703                                  ;------------------------------------------------------------------------
  6704                                  ;
  6705                                  ; Procedure Name : RW32_CONVERT
  6706                                  ;
  6707                                  ;Input: same as ABSDRD and ABSDWRT
  6708                                  ;	 ES:BP -> DPB
  6709                                  ;Functions: convert 32bit absolute RW input parms to 16bit input parms
  6710                                  ;Output: carry set when CX=-1 and drive is less then 32mb
  6711                                  ;	 carry clear, parms ok
  6712                                  ;
  6713                                  ;------------------------------------------------------------------------
  6714                                  
  6715                                  	; 06/01/2024
  6716                                  RW32_CONVERT:
  6717 000009BE 83F9FF                  	CMP	CX,-1			   ;>32mb  new format ?	;AN000;
  6718                                  	;inc	cx ; *	; 01 -> 0
  6719 000009C1 7423                    	JZ	short new32format	   ;>32mb  yes		;AN000;
  6720                                  	;dec	dx
  6721                                  	
  6722                                  	;cmp	word [es:bp+0Fh],0
  6723 000009C3 26837E0F00              	cmp	word [es:bp+DPB.FAT_SIZE],0 ; PCDOS 7.1
  6724 000009C8 741A                    	jz	short rw32_conv_err ; FAT32 fs
  6725                                  
  6726 000009CA 50                      	PUSH	AX			   ;>32mb  save ax	;AN000;
  6727 000009CB 52                      	PUSH	DX			   ;>32mb  save dx	;AN000;
  6728                                  	;mov	ax,[es:bp+0Dh]
  6729 000009CC 268B460D                	MOV	AX,[ES:BP+DPB.MAX_CLUSTER] ;>32mb  get max cluster # ;AN000;
  6730                                  	;mov	dl,[es:bp+4]
  6731 000009D0 268A5604                	MOV	DL,[ES:BP+DPB.CLUSTER_MASK] ;>32mb		;AN000;
  6732 000009D4 80FAFE                  	CMP	DL,0FEh ; 254		;>32mb  removable ?	;AN000;
  6733 000009D7 7407                    	JZ	short letold		;>32mb  yes		;AN000;
  6734                                  	;INC	DL			;>32mb			;AN000;
  6735                                  	; 17/12/2022
  6736 000009D9 42                      	inc	dx
  6737 000009DA 30F6                    	XOR	DH,DH			;>32mb  dx = sector/cluster ;AN000;
  6738 000009DC F7E2                    	MUL	DX			;>32mb  dx:ax= max sector # ;AN000;
  6739 000009DE 09D2                    	OR	DX,DX	; (clears CF)	;>32mb  > 32mb ?	;AN000;
  6740                                  letold:
  6741 000009E0 5A                      	POP	DX			;>32mb  restore dx	;AN000;
  6742 000009E1 58                      	POP	AX			;>32mb  restore ax 	;AN000;
  6743 000009E2 7418                    	JZ	short old_style	; cf=0	;>32mb  no 		;AN000;
  6744                                  
  6745                                  	; 06/01/2024
  6746                                  	;push	ds
  6747                                  	;;getdseg <ds>
  6748                                  	;mov	ds,[cs:DosDSeg]
  6749                                  	;mov	word [AbsDskErr],207h	;>32mb  bad address mark
  6750                                  	;pop	ds
  6751                                  rw32_conv_err:
  6752 000009E4 F9                      	STC				;>32mb			;AN000;
  6753 000009E5 C3                      	retn				;>32mb			;AN000;
  6754                                  
  6755                                  new32format:
  6756                                  	;mov	dx,[bx+2]
  6757 000009E6 8B5702                  	MOV	DX,[BX+ABS_32RW.SECTOR_RBA+2] ;>32mb		;AN000;
  6758                                  
  6759 000009E9 1E                      	push	ds			; set up ds to DOSDATA
  6760                                  	;getdseg <ds>
  6761 000009EA 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6762 000009EF 8916[0706]              	MOV	[HIGH_SECTOR],DX	;>32mb			;AN000;
  6763 000009F3 1F                      	pop	ds
  6764                                  
  6765 000009F4 8B17                    	mov	dx,[bx]
  6766                                  	;MOV	DX,[BX+ABS_32RW.SECTOR_RBA]  ;>32mb		;AN000;
  6767                                  	;mov	cx,[bx+4]
  6768 000009F6 8B4F04                  	MOV	CX,[BX+ABS_32RW.ABS_RW_COUNT] ;>32mb		;AN000;
  6769                                  	;lds	bx,[bx+6]
  6770 000009F9 C55F06                  	LDS	BX,[BX+ABS_32RW.BUFFER_ADDR] ;>32mb		;AN000;
  6771                                  old_style:				;>32mb			;AN000;
  6772                                  	; 06/01/2024
  6773                                  	; cf=0
  6774                                  	;CLC				;>32mb			;AN000;
  6775 000009FC C3                      	retn				;>32mb			;AN000;
  6776                                  
  6777                                  ;------------------------------------------------------------------------
  6778                                  ;
  6779                                  ; Procedure Name : Fastxxx_Purge
  6780                                  ;
  6781                                  ; Input: None
  6782                                  ; Functions: Purge Fastopen/ Cache Buffers
  6783                                  ; Output: None
  6784                                  ;
  6785                                  ;------------------------------------------------------------------------
  6786                                  
  6787                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6788                                  
  6789                                  Fastxxx_Purge:
  6790 000009FD 50                      	PUSH	AX			; save regs.	;AN000;
  6791 000009FE 56                      	PUSH	SI						;AN000;
  6792 000009FF 52                      	PUSH	DX						;AN000;
  6793                                  topen:
  6794 00000A00 1E                      	push	ds			; set up ds to DOSDATA
  6795                                  	;getdseg <ds>
  6796 00000A01 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6797                                  
  6798 00000A06 F606[6D12]80            	TEST	byte [FastOpenFlg],Fast_yes ; 80h 
  6799                                  					; fastopen installed ?	;AN000;
  6800 00000A0B 1F                      	pop	ds
  6801 00000A0C 740B                    	JZ	short nofast		; no			;AN000;
  6802 00000A0E B401                    	MOV	AH,FastOpen_ID	; 1				;AN000;
  6803                                  dofast:
  6804 00000A10 B005                    	MOV	AL,FONC_purge  ;5	; purge			;AN000;
  6805                                  	;;mov	dl,[es:bp+0]
  6806                                  	; 05/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  6807                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; set up drive number	;AN000;
  6808                                  	; 15/12/2022
  6809 00000A12 268A5600                	mov	dl,[es:bp]
  6810                                  	;invoke	Fast_Dispatch		; call fastopen/seek	;AN000;
  6811 00000A16 E87C23                  	call	Fast_Dispatch
  6812                                  nofast:
  6813 00000A19 5A                      	POP	DX						;AN000;
  6814 00000A1A 5E                      	POP	SI			; restore regs		;AN000;
  6815 00000A1B 58                      	POP	AX			 			;AN000;
  6816 00000A1C C3                      	retn				; exit
  6817                                  
  6818                                  ;============================================================================
  6819                                  ; DOSMES.INC (MSDOS 6.0, 1991)
  6820                                  ;============================================================================
  6821                                  ; 29/04/2019 - Retro DOS v4.0
  6822                                  
  6823                                  ;include dossym.inc
  6824                                  ;include dosmac.inc
  6825                                  ;include doscntry.inc
  6826                                  
  6827                                  ; DOSCODE Segment
  6828                                  
  6829                                  ; 17/07/2018 - Retro DOS v3.0  [ DOSMES.INC (MSDOS 3.3, 1987) ]
  6830                                  ; ---------------------------------------------------------------------------
  6831                                  ;include divmes.inc
  6832                                  
  6833                                  ; DOSCODE:48C3h (PCDOS 7.1, IBMDOS.COM) - 06/04/2024 -
  6834                                  ; -------------------------------------
  6835                                  ; DOSCODE:4778h (MSDOS 6.21, MSDOS.SYS)
  6836                                  ; -------------------------------------
  6837                                  ; DOSCODE:476Bh (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6838                                  
  6839                                  ; THIS IS THE ONLY DOS "MESSAGE". IT DOES NOT NEED A TERMINATOR.
  6840                                  	;PUBLIC	DIVMES
  6841                                  
  6842 00000A1D 0D0A44697669646520-     DIVMES:	DB	13,10,"Divide overflow",13,10
  6842 00000A26 6F766572666C6F770D-
  6842 00000A2F 0A                 
  6843                                  
  6844                                  	;PUBLIC	DivMesLen
  6845                                  DivMesLen:
  6846 00000A30 1300                    	DW	$-DIVMES  ; 19	; Length of the above message in bytes
  6847                                  
  6848                                  ; DOSCODE:478Dh (MSDOS 6.21, MSDOS.SYS)
  6849                                  ; -------------------------------------
  6850                                  ; DOSCODE:4780h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6851                                  
  6852                                  ; (MSDOS 6.0)
  6853                                  ; VxD not found error message
  6854                                  
  6855                                  NoVxDErrMsg:
  6856 00000A32 596F75206D75737420-     	db  'You must have the file WINA20.386 in the root of your boot drive'
  6856 00000A3B 686176652074686520-
  6856 00000A44 66696C652057494E41-
  6856 00000A4D 32302E33383620696E-
  6856 00000A56 2074686520726F6F74-
  6856 00000A5F 206F6620796F757220-
  6856 00000A68 626F6F742064726976-
  6856 00000A71 65                 
  6857 00000A72 0D0A746F2072756E20-     	db  0Dh,0Ah,'to run Windows in Enhanced Mode',0Dh,0Ah
  6857 00000A7B 57696E646F77732069-
  6857 00000A84 6E20456E68616E6365-
  6857 00000A8D 64204D6F64650D0A   
  6858                                  
  6859                                  VxDMesLen equ $ - NoVxDErrMsg  ; 99
  6860                                  
  6861                                  ; 13/05/2019 - Retro DOS v4.0
  6862                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6863                                  
  6864                                  ;include yesno.asm  (MNSDOS 6.0)
  6865                                  ; -------------------------------------
  6866                                  ; DOSCODE:47F0h (MSDOS 6.21, MSDOS.SYS)
  6867                                  ; DOSCODE:47E3h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6868                                  
  6869                                  ; This is for country Yes and No
  6870                                  
  6871                                  ; 06/01/2024 (Retro DOS 5.0 - PCDOS 7.1 IBMDOS.COM)
  6872                                  ;NLS_YES:	db 'Y'
  6873                                  ;NLS_NO:	db 'N'
  6874                                  ;NLS_yes2:	db 'y'
  6875                                  ;NLS_no2:	db 'n'
  6876                                  
  6877                                  ; ---------------------------------------------------------------------------
  6878                                  
  6879                                  ; DOSCODE:493Bh (PCDOS 7.1, IBMDOS.COM) - 06/04/2024 -
  6880                                  ; -------------------------------------
  6881                                  ; DOSCODE:47F4h (MSDOS 6.21, MSDOS.SYS)
  6882                                  ; DOSCODE:47E7h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6883                                  
  6884                                  ;SUBTTL EDIT FUNCTION ASSIGNMENTS AND HEADERS
  6885                                  
  6886                                  ; The following two tables implement the current buffered input editing
  6887                                  ; routines. The tables are pairwise associated in reverse order for ease
  6888                                  ; in indexing. That is; The first entry in ESCTAB corresponds to the last
  6889                                  ; entry in ESCFUNC, and the last entry in ESCTAB to the first entry in ESCFUNC.
  6890                                  
  6891                                  	;PUBLIC	CANCHAR
  6892                                  CANCHAR:
  6893 00000A95 1B                      	DB	CANCEL	; 1Bh	;Cancel line character
  6894                                  	
  6895                                  	;PUBLIC	ESCCHAR
  6896                                  ESCCHAR:
  6897 00000A96 00                      	DB	ESCCH	; 0	;Lead-in character for escape sequences
  6898                                  	
  6899                                  	;IF	NOT Rainbow
  6900                                  
  6901                                  ESCTAB:	; LABEL BYTE
  6902                                  
  6903                                  	;IF	IBM
  6904 00000A97 40                      	DB	64		; Ctrl-Z - F6
  6905 00000A98 4D                      	DB	77		; Copy one char - -->
  6906 00000A99 3B                      	DB	59		; Copy one char - F1
  6907 00000A9A 53                      	DB	83		; Skip one char - DEL
  6908 00000A9B 3C                      	DB	60		; Copy to char - F2
  6909 00000A9C 3E                      	DB	62		; Skip to char - F4
  6910 00000A9D 3D                      	DB	61		; Copy line - F3
  6911 00000A9E 3D                      	DB	61		; Kill line (no change to template ) - Not used
  6912 00000A9F 3F                      	DB	63		; Reedit line (new template) - F5
  6913 00000AA0 4B                      	DB	75		; Backspace - <--
  6914 00000AA1 52                      	DB	82		; Enter insert mode - INS (toggle)
  6915 00000AA2 52                      	DB	82		; Exit insert mode - INS (toggle)
  6916 00000AA3 41                      	DB	65		; Escape character - F7
  6917 00000AA4 41                      	DB	65		; End of table
  6918                                  	;ENDIF
  6919                                  
  6920                                  ESCEND: ; LABEL BYTE
  6921                                  
  6922                                  ESCTABLEN EQU ESCEND-ESCTAB
  6923                                  
  6924                                  ESCFUNC: ; LABEL WORD
  6925                                  	
  6926 00000AA5 [011A]                  	short_addr  GETCH	; Ignore the escape sequence
  6927 00000AA7 [7E1A]                  	short_addr  TWOESC
  6928 00000AA9 [731B]                  	short_addr  EXITINS
  6929 00000AAB [731B]                  	short_addr  ENTERINS
  6930 00000AAD [791A]                  	short_addr  BACKSP
  6931 00000AAF [5F1B]                  	short_addr  REEDIT
  6932 00000AB1 [661A]                  	short_addr  KILNEW
  6933 00000AB3 [F51A]                  	short_addr  COPYLIN
  6934 00000AB5 [271B]                  	short_addr  SKIPSTR
  6935 00000AB7 [FB1A]                  	short_addr  COPYSTR
  6936 00000AB9 [1E1B]                  	short_addr  SKIPONE
  6937 00000ABB [001B]                  	short_addr  COPYONE
  6938 00000ABD [001B]                  	short_addr  COPYONE
  6939 00000ABF [7A1B]                  	short_addr  CTRLZ
  6940                                  
  6941                                  	;ENDIF
  6942                                  
  6943                                  ; DOSMES.INC (MSDOS 6.0, 1991)
  6944                                  ; ---------------------------------------------------------------------------
  6945                                  ; DOSMES.ASM (MSDOS 2.11, 1983)
  6946                                  
  6947                                  ; OEMFunction key is expected to process a single function
  6948                                  ;   key input from a device and dispatch to the proper
  6949                                  ;   routines leaving all registers UNTOUCHED.
  6950                                  ;
  6951                                  ; Inputs:   CS, SS are DOSGROUP
  6952                                  ; Outputs:  None. This function is expected to JMP to onw of
  6953                                  ;           the following labels:
  6954                                  ;
  6955                                  ;           GetCh       - ignore the sequence
  6956                                  ;           TwoEsc      - insert an ESCChar in the buffer
  6957                                  ;           ExitIns     - toggle insert mode
  6958                                  ;           EnterIns    - toggle insert mode
  6959                                  ;           BackSp      - move backwards one space
  6960                                  ;           ReEdit      - reedit the line with a new template
  6961                                  ;           KilNew      - discard the current line and start from scratch
  6962                                  ;           CopyLin     - copy the rest of the template into the line
  6963                                  ;           SkipStr     - read the next character and skip to it in the template
  6964                                  ;           CopyStr     - read next char and copy from template to line until char
  6965                                  ;           SkipOne     - advance position in template one character
  6966                                  ;           CopyOne     - copy next character in template into line
  6967                                  ;           CtrlZ       - place a ^Z into the template
  6968                                  ; Registers that are allowed to be modified by this function are:
  6969                                  ;           AX, CX, BP
  6970                                  
  6971                                  ; 13/05/2019 - Retro DOS v4.0
  6972                                  ; -------------------------------------
  6973                                  ; DOSCODE:4820h (MSDOS 6.21, MSDOS.SYS)
  6974                                  
  6975                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6976                                  ; -------------------------------------
  6977                                  ; DOSCODE:4813h (MSDOS 5.0, MSDOS.SYS)
  6978                                  
  6979                                  ; 06/01/2024 - Retro DOS v5.0
  6980                                  ; -------------------------------------
  6981                                  ; DOSCODE:4967h (PCDOS 7.1, IBMDOS.COM)
  6982                                  
  6983                                  OEMFunctionKey:
  6984 00000AC1 E89F0E                  	CALL	_$STD_CON_INPUT_NO_ECHO	; Get the second byte of the sequence
  6985 00000AC4 B10E                    	MOV     CL,ESCTABLEN ; 14	; length of table for scan
  6986 00000AC6 57                      	PUSH    DI                      ; save DI (cannot change it!)
  6987 00000AC7 BF[970A]                	MOV     DI,ESCTAB		; offset of second byte table
  6988 00000ACA 06                      	push	es
  6989 00000ACB 0E                      	push	cs
  6990 00000ACC 07                      	pop	es
  6991 00000ACD F2AE                    	REPNE   SCASB                   ; Look it up in the table
  6992 00000ACF 07                      	pop	es
  6993 00000AD0 5F                      	POP     DI                      ; restore DI
  6994 00000AD1 D1E1                    	SHL     CX,1                    ; convert byte offset to word
  6995 00000AD3 89CD                    	MOV     BP,CX                   ; move to indexable register
  6996                                  	;JMP	word [BP+ESCFUNC]	; Go to the right routine
  6997 00000AD5 2EFFA6[A50A]            	JMP	word [CS:BP+ESCFUNC]
  6998                                  
  6999                                  ;DOSCODE ENDS
  7000                                  	
  7001                                  ;============================================================================
  7002                                  ; TIME.ASM (MSDOS 6.0, 1991)
  7003                                  ;============================================================================
  7004                                  ; Retro DOS v3.0 - 18/07/2018
  7005                                  
  7006                                  ; SYSCALL.ASM (MSDOS 2.11, 1983)
  7007                                  ;----------------------------------------------------------------------------
  7008                                  ; Retro DOS v2.0 - 13/03/2018
  7009                                  
  7010                                  ;**	TIME.ASM - System Calls and low level routines for DATE and TIME
  7011                                  
  7012                                  	;BREAK <DATE AND TIME - SYSTEM CALLS 42,43,44,45>
  7013                                  
  7014                                  ;**	$GET_DATE - Get Current Date
  7015                                  ;----------------------------------------
  7016                                  ;	ENTRY	none
  7017                                  ;	EXIT	(cx:dx) = current date
  7018                                  ;	USES	all
  7019                                  
  7020                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7021                                  ; 06/01/2024 - Retro DOS v5.0 (Modified MSDOS 7.1 IBMDOS.COM)	
  7022                                  
  7023                                  _$GET_DATE:	;System call 42
  7024                                  
  7025 00000ADA 16                      	PUSH	SS
  7026 00000ADB 1F                      	POP	DS
  7027 00000ADC E8B700                  	CALL	READTIME	;Check for rollover to next day
  7028 00000ADF A1[5203]                	MOV	AX,[YEAR]
  7029                                  
  7030                                  ;	WARNING!!!! DAY and MONTH must be adjacently allocated!
  7031                                  
  7032 00000AE2 8B1E[5003]              	MOV	BX,[DAY]	; fetch both day and month
  7033 00000AE6 E88EF9                  	CALL	Get_User_Stack	;Get pointer to user registers
  7034                                  	;MOV	[SI+6],BX	;DH=month, DL=day
  7035 00000AE9 895C06                  	MOV	[SI+user_env.user_DX],BX
  7036 00000AEC 05BC07                  	ADD	AX,1980		;Put bias back
  7037                                  	;MOV	[SI+4],AX	;CX=year
  7038 00000AEF 894404                  	MOV	[SI+user_env.user_CX],AX
  7039 00000AF2 36A0[5603]              	MOV	AL,[SS:WEEKDAY]	;hkn; SS override
  7040                                  RET20:	; 05/11/2022
  7041                                  RET24:	; 18/12/2022
  7042 00000AF6 C3                      	RETN
  7043                                  
  7044                                  ;**	$SET_DATE - Set Current Date
  7045                                  ;----------------------------------------
  7046                                  ;	ENTRY	(cx:dx) = current date
  7047                                  ;	EXIT	(al) = -1 iff bad date
  7048                                  ;		(al) = 0 if ok
  7049                                  ;	USES	all
  7050                                  
  7051                                  _$SET_DATE:	;System call 43
  7052                                  
  7053 00000AF7 B0FF                    	MOV	AL,-1		;Be ready to flag error
  7054 00000AF9 81E9BC07                	SUB	CX,1980		;Fix bias in year
  7055                                  	;JC	SHORT RET24	;Error if not big enough
  7056                                  	; 05/11/2022
  7057 00000AFD 72F7                    	jc	short RET20
  7058 00000AFF 83F977                  	CMP	CX,119		;Year must be less than 2100
  7059 00000B02 77F2                    	JA	SHORT RET24
  7060 00000B04 08F6                    	OR	DH,DH
  7061                                  	;JZ	SHORT RET24
  7062                                   	; 05/11/2022
  7063 00000B06 74EE                    	jz	short RET20
  7064 00000B08 08D2                    	OR	DL,DL
  7065                                  	;JZ	SHORT RET24	;Error if either month or day is 0
  7066                                  	; 05/11/2022
  7067 00000B0A 74EA                    	jz	short RET20
  7068 00000B0C 80FE0C                  	CMP	DH,12		;Check against max. month
  7069 00000B0F 77E5                    	JA	SHORT RET24
  7070 00000B11 16                      	PUSH	SS
  7071 00000B12 1F                      	POP	DS
  7072                                  	;CALL	DODATE
  7073                                  	; 18/12/2022
  7074 00000B13 E91301                  	jmp	DODATE
  7075                                  ;RET24:  
  7076                                  	;RETN
  7077                                  
  7078                                  ;**	$GET_TIME - Get Current Time
  7079                                  ;----------------------------------------
  7080                                  ;	ENTRY	none
  7081                                  ;	EXIT	(cx:dx) = current time
  7082                                  ;	USES	all
  7083                                  
  7084                                  _$GET_TIME:			;System call 44
  7085                                  
  7086 00000B16 16                      	PUSH	SS
  7087 00000B17 1F                      	POP	DS
  7088 00000B18 E87B00                  	CALL	READTIME
  7089 00000B1B E859F9                  	CALL	Get_User_Stack	;Get pointer to user registers
  7090                                  	;MOV	[SI+6],DX
  7091 00000B1E 895406                  	MOV	[SI+user_env.user_DX],DX
  7092                                  	;MOV	[SI+4],CX
  7093 00000B21 894C04                  	MOV	[SI+user_env.user_CX],CX
  7094                                  set_time_ok:	; 06/01/2024
  7095 00000B24 30C0                    	XOR	AL,AL
  7096                                  RET26:  
  7097 00000B26 C3                      	RETN
  7098                                  
  7099                                  ;**	$SET_TIME - Set Current Time
  7100                                  ;----------------------------------------
  7101                                  ;	ENTRY	(cx:dx) = time
  7102                                  ;	EXIT	(al) = 0 if 0k
  7103                                  ;		(al) = -1 if invalid
  7104                                  ;	USES	ALL
  7105                                  
  7106                                  _$SET_TIME:			;System call 45
  7107                                  
  7108 00000B27 B0FF                    	MOV	AL,-1		;Flag in case of error
  7109 00000B29 80FD18                  	CMP	CH,24		;Check hours
  7110 00000B2C 73F8                    	JAE	SHORT RET26
  7111 00000B2E 80F93C                  	CMP	CL,60		;Check minutes
  7112 00000B31 73F3                    	JAE	SHORT RET26
  7113 00000B33 80FE3C                  	CMP	DH,60		;Check seconds
  7114 00000B36 73EE                    	JAE	SHORT RET26
  7115 00000B38 80FA64                  	CMP	DL,100		;Check 1/100's
  7116 00000B3B 73E9                    	JAE	SHORT RET26
  7117 00000B3D 51                      	PUSH	CX
  7118 00000B3E 52                      	PUSH	DX
  7119 00000B3F 16                      	PUSH	SS
  7120 00000B40 1F                      	POP	DS
  7121 00000B41 BB[B603]                	MOV	BX,TIMEBUF
  7122 00000B44 B90600                  	MOV	CX,6
  7123                                  	;XOR	DX,DX
  7124                                  	;MOV	AX,DX
  7125 00000B47 31C0                    	xor	ax,ax
  7126 00000B49 99                      	cwd	; 06/01/2024
  7127 00000B4A 53                      	PUSH	BX
  7128 00000B4B E87845                  	CALL	SETREAD
  7129 00000B4E 1E                      	PUSH	DS
  7130 00000B4F C536[2E00]              	LDS	SI,[BCLOCK]
  7131 00000B53 E8FA44                  	CALL	DEVIOCALL2	;Get correct day count
  7132 00000B56 1F                      	POP	DS
  7133 00000B57 5B                      	POP	BX
  7134 00000B58 E89E45                  	CALL	SETWRITE
  7135 00000B5B 8F06[BA03]              	POP	WORD [TIMEBUF+4]
  7136 00000B5F 8F06[B803]              	POP	WORD [TIMEBUF+2]
  7137 00000B63 C536[2E00]              	LDS	SI,[BCLOCK]
  7138 00000B67 E8E644                  	CALL	DEVIOCALL2	;Set the time
  7139                                  	; 06/01/2024
  7140                                  	;XOR	AL,AL
  7141                                  	;RETN
  7142 00000B6A EBB8                    	jmp	short set_time_ok
  7143                                  
  7144                                  ; 11/07/2018 - Retro DOS v3.0
  7145                                  ; Retro DOS v2.0 - 14/03/2018
  7146                                  
  7147                                  FOURYEARS EQU 3*365 + 366  ; = 1461 
  7148                                  
  7149                                  ;SUBTTL DATE16, READTIME, DODATE -- GUTS OF TIME AND DATE
  7150                                  ;----------------------------------------------------------
  7151                                  ; Date16 returns the current date in AX, current time in DX
  7152                                  ;   AX - YYYYYYYMMMMDDDDD  years months days
  7153                                  ;   DX - HHHHHMMMMMMSSSSS  hours minutes seconds/2
  7154                                  
  7155                                  DATE16:
  7156                                  	
  7157                                  ;M048	Context DS
  7158                                  ;
  7159                                  ; Since this function can be called thru int 2f we shall not assume that SS
  7160                                  ; is DOSDATA
  7161                                  
  7162                                  	;push	ss
  7163                                  	;pop	ds
  7164                                  
  7165                                  	;getdseg <ds>		; M048
  7166                                  
  7167                                  	; 13/05/2019 - Retro DOS v4.0
  7168 00000B6C 2E8E1E[0700]            	mov	ds, [cs:DosDSeg]	
  7169                                  
  7170 00000B71 51                      	PUSH	CX
  7171 00000B72 06                      	PUSH	ES
  7172 00000B73 E82000                  	CALL	READTIME
  7173 00000B76 07                      	POP	ES
  7174 00000B77 D0E1                    	SHL	CL,1		;Minutes to left part of byte
  7175 00000B79 D0E1                    	SHL	CL,1
  7176 00000B7B D1E1                    	SHL	CX,1		;Push hours and minutes to left end
  7177 00000B7D D1E1                    	SHL	CX,1
  7178 00000B7F D1E1                    	SHL	CX,1
  7179 00000B81 D0EE                    	SHR	DH,1		;Count every two seconds
  7180 00000B83 08F1                    	OR	CL,DH		;Combine seconds with hours and minutes
  7181 00000B85 89CA                    	MOV	DX,CX
  7182                                  
  7183                                  ;	WARNING! MONTH and YEAR must be adjacently allocated
  7184                                  
  7185 00000B87 A1[5103]                	MOV	AX,[MONTH]	;Fetch month and year
  7186 00000B8A B104                    	MOV	CL,4
  7187 00000B8C D2E0                    	SHL	AL,CL		;Push month to left to make room for day
  7188 00000B8E D1E0                    	SHL	AX,1
  7189 00000B90 59                      	POP	CX
  7190 00000B91 0A06[5003]              	OR	AL,[DAY]
  7191                                  RET21:
  7192 00000B95 C3                      	RETN
  7193                                  
  7194                                  ;----------------------------------------------------------
  7195                                  
  7196                                  READTIME:
  7197                                  
  7198                                  ;Gets time in CX:DX. Figures new date if it has changed.
  7199                                  ;Uses AX, CX, DX.
  7200                                  
  7201 00000B96 C706[E20D]0000          	MOV	word [DATE_FLAG],0 ; reset date flag for CPMIO
  7202 00000B9C 56                      	PUSH	SI
  7203 00000B9D 53                      	PUSH	BX
  7204                                  
  7205 00000B9E BB[B603]                	MOV	BX,TIMEBUF
  7206                                  
  7207 00000BA1 B90600                  	MOV	CX,6
  7208                                  	;XOR	DX,DX
  7209                                  	;MOV	AX,DX
  7210                                  	; 06/01/2024
  7211 00000BA4 31C0                    	xor	ax,ax
  7212 00000BA6 99                      	cwd
  7213 00000BA7 E81C45                  	CALL	SETREAD
  7214 00000BAA 1E                      	PUSH	DS
  7215 00000BAB C536[2E00]              	LDS	SI,[BCLOCK]
  7216 00000BAF E89E44                  	CALL	DEVIOCALL2	;Get correct date and time
  7217 00000BB2 1F                      	POP	DS
  7218 00000BB3 5B                      	POP	BX
  7219 00000BB4 5E                      	POP	SI
  7220 00000BB5 A1[B603]                	MOV	AX,[TIMEBUF]
  7221 00000BB8 8B0E[B803]              	MOV	CX,[TIMEBUF+2]
  7222 00000BBC 8B16[BA03]              	MOV	DX,[TIMEBUF+4]
  7223 00000BC0 3B06[5403]              	CMP	AX,[DAYCNT]	;See if day count is the same
  7224                                  	;JZ	SHORT RET22
  7225 00000BC4 74CF                    	JZ	SHORT RET21 ; 18/07/2018
  7226                                  	;cmp	ax,43830
  7227 00000BC6 3D36AB                  	CMP	AX,FOURYEARS*30 ;Number of days in 120 years
  7228 00000BC9 733D                    	JAE	SHORT RET22	;Ignore if too large
  7229 00000BCB A3[5403]                	MOV	[DAYCNT],AX
  7230 00000BCE 56                      	PUSH	SI
  7231 00000BCF 51                      	PUSH	CX
  7232 00000BD0 52                      	PUSH	DX		;Save time
  7233 00000BD1 31D2                    	XOR	DX,DX
  7234                                  	;mov	cx,1461
  7235 00000BD3 B9B505                  	MOV	CX,FOURYEARS	;Number of days in 4 years
  7236 00000BD6 F7F1                    	DIV	CX		;Compute number of 4-year units
  7237 00000BD8 D1E0                    	SHL	AX,1
  7238 00000BDA D1E0                    	SHL	AX,1
  7239 00000BDC D1E0                    	SHL	AX,1		;Multiply by 8 (no. of half-years)
  7240 00000BDE 89C1                    	MOV	CX,AX		;<240 implies AH=0
  7241                                  
  7242 00000BE0 BE[650D]                	MOV	SI,YRTAB	;Table of days in each year
  7243                                  
  7244 00000BE3 E82300                  	CALL	DSLIDE		;Find out which of four years we're in
  7245 00000BE6 D1E9                    	SHR	CX,1		;Convert half-years to whole years
  7246 00000BE8 7304                    	JNC	SHORT SK	;Extra half-year?
  7247 00000BEA 81C2C800                	ADD	DX,200
  7248                                  SK:
  7249 00000BEE E82200                  	CALL	SETYEAR
  7250 00000BF1 B101                    	MOV	CL,1		;At least at first month in year
  7251                                  
  7252 00000BF3 BE[6D0D]                	MOV	SI,MONTAB	;Table of days in each month
  7253                                  	
  7254 00000BF6 E81000                  	CALL	DSLIDE		;Find out which month we're in
  7255 00000BF9 880E[5103]              	MOV	[MONTH],CL
  7256 00000BFD 42                      	INC	DX		;Remainder is day of month (start with one)
  7257 00000BFE 8816[5003]              	MOV	[DAY],DL
  7258 00000C02 E89400                  	CALL	WKDAY		;Set day of week
  7259 00000C05 5A                      	POP	DX
  7260 00000C06 59                      	POP	CX
  7261 00000C07 5E                      	POP	SI
  7262                                  RET22:  
  7263 00000C08 C3                      	RETN
  7264                                  
  7265                                  ;----------------------------------------------------------
  7266                                  
  7267                                  DSLIDE:
  7268                                  	;MOV	AH,0
  7269                                  	; 06/01/2024
  7270                                  	; (AH=0)
  7271                                  DSLIDE1:
  7272 00000C09 AC                      	LODSB			;Get count of days
  7273 00000C0A 39C2                    	CMP	DX,AX		;See if it will fit
  7274                                  	;JB	SHORT RET23	;If not, done
  7275 00000C0C 72FA                    	jb	short RET22 ; 13/05/2019 - Retro DOS v4.0
  7276 00000C0E 29C2                    	SUB	DX,AX
  7277 00000C10 41                      	INC	CX		;Count one more month/year
  7278 00000C11 EBF6                    	JMP	SHORT DSLIDE1
  7279                                  
  7280                                  ;----------------------------------------------------------
  7281                                  
  7282                                  SETYEAR:
  7283                                  
  7284                                  ;Set year with value in CX. Adjust length of February for this year.
  7285                                  
  7286                                  ; NOTE: This can also be called thru int 2f. If this is called then it will
  7287                                  ;	  set DS to DOSDATA. Since the only guy calling this should be the DOS
  7288                                  ;	redir, DS will be DOSDATA anyway. It is going to be in-efficient to
  7289                                  ;	preserve DS as CHKYR is also called as a routine.
  7290                                  
  7291                                  	; MSDOS 6.0 (18/07/2018) ; *
  7292                                  
  7293                                  	;GETDSEG DS
  7294                                  
  7295                                  	;PUSH	CS  ; *
  7296                                  	;POP	DS  ; *
  7297                                  
  7298                                  	; 13/05/2019 - Retro DOS v4.0
  7299 00000C13 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  7300                                  
  7301                                  	; Offset 18CEh in IBMDOS.COM (MSDOS 3.3), 1987
  7302                                  	; 05/11/2022 
  7303                                  	; DOSCODE:4970h in MSDOS.SYS (MSDOS 5.0), 1991 
  7304                                  
  7305 00000C18 880E[5203]              	MOV	[YEAR],CL
  7306                                  CHKYR:
  7307 00000C1C F6C103                  	TEST	CL,3		;Check for leap year
  7308 00000C1F B01C                    	MOV	AL,28
  7309 00000C21 7502                    	JNZ	SHORT SAVFEB	;28 days if no leap year
  7310 00000C23 FEC0                    	INC	AL		;Add leap day
  7311                                  SAVFEB:
  7312 00000C25 A2[6E0D]                	mov	[february],al
  7313                                  	;MOV	[MONTAB+1],AL	;Store for February
  7314                                  RET23:  
  7315 00000C28 C3                      	RETN
  7316                                  
  7317                                  ;----------------------------------------------------------
  7318                                  
  7319                                  DODATE:
  7320 00000C29 E8F0FF                  	CALL	CHKYR		;Set Feb. up for new year
  7321 00000C2C 88F0                    	MOV	AL,DH
  7322                                  
  7323 00000C2E BB[6C0D]                	MOV	BX,MONTAB-1	;DOSDATA:0D1Bh for MSDOS 6.21
  7324                                  				; 06/01/2024
  7325                                  				;DOSDATA:0D1Bh for PCDOS 7.1 
  7326                                  
  7327 00000C31 D7                      	XLAT			;Look up days in month
  7328 00000C32 38D0                    	CMP	AL,DL
  7329 00000C34 B0FF                    	MOV	AL,-1		;Restore error flag, just in case
  7330                                  	;JB	SHORT RET25	;Error if too many days
  7331 00000C36 72F0                    	jb	short RET23 ; 18/07/2018
  7332 00000C38 E8D8FF                  	CALL	SETYEAR
  7333                                  ;
  7334                                  ; WARNING! DAY and MONTH must be adjacently allocated
  7335                                  ;
  7336 00000C3B 8916[5003]              	MOV	[DAY],DX	;Set both day and month
  7337 00000C3F D1E9                    	SHR	CX,1
  7338 00000C41 D1E9                    	SHR	CX,1
  7339                                  	;mov	ax,1461
  7340 00000C43 B8B505                  	MOV	AX,FOURYEARS
  7341 00000C46 89D3                    	MOV	BX,DX
  7342 00000C48 F7E1                    	MUL	CX
  7343 00000C4A 8A0E[5203]              	MOV	CL,[YEAR]
  7344 00000C4E 80E103                  	AND	CL,3
  7345                                  
  7346 00000C51 BE[650D]                	MOV	SI,YRTAB
  7347                                  
  7348 00000C54 89C2                    	MOV	DX,AX
  7349 00000C56 D1E1                    	SHL	CX,1		;Two entries per year, so double count
  7350 00000C58 E85100                  	CALL	DSUM		;Add up the days in each year
  7351 00000C5B 88F9                    	MOV	CL,BH		;Month of year
  7352                                  
  7353 00000C5D BE[6D0D]                	MOV	SI,MONTAB
  7354                                  
  7355 00000C60 49                      	DEC	CX		;Account for months starting with one
  7356 00000C61 E84800                  	CALL	DSUM		;Add up days in each month
  7357 00000C64 88D9                    	MOV	CL,BL		;Day of month
  7358 00000C66 49                      	DEC	CX		;Account for days starting with one
  7359 00000C67 01CA                    	ADD	DX,CX		;Add in to day total
  7360 00000C69 92                      	XCHG	AX,DX		;Get day count in AX
  7361 00000C6A A3[5403]                	MOV	[DAYCNT],AX
  7362 00000C6D 56                      	PUSH	SI
  7363 00000C6E 53                      	PUSH	BX
  7364 00000C6F 50                      	PUSH	AX
  7365                                  
  7366 00000C70 BB[B603]                	MOV	BX,TIMEBUF
  7367                                  
  7368 00000C73 B90600                  	MOV	CX,6
  7369                                  	;XOR	DX,DX
  7370                                  	;MOV	AX,DX
  7371                                  	; 06/01/2024
  7372 00000C76 31C0                    	xor	ax,ax
  7373 00000C78 99                      	cwd
  7374 00000C79 53                      	PUSH	BX
  7375 00000C7A E84944                  	CALL	SETREAD
  7376                                  
  7377 00000C7D 1E                      	PUSH	DS
  7378 00000C7E C536[2E00]              	LDS	SI,[BCLOCK]
  7379 00000C82 E8CB43                  	CALL	DEVIOCALL2	;Get correct date and time
  7380 00000C85 1F                      	POP	DS
  7381 00000C86 5B                      	POP	BX
  7382 00000C87 E86F44                  	CALL	SETWRITE
  7383 00000C8A 8F06[B603]              	POP	WORD [TIMEBUF]
  7384 00000C8E 1E                      	PUSH	DS
  7385 00000C8F C536[2E00]              	LDS	SI,[BCLOCK]
  7386 00000C93 E8BA43                  	CALL	DEVIOCALL2	;Set the date
  7387 00000C96 1F                      	POP	DS
  7388 00000C97 5B                      	POP	BX
  7389 00000C98 5E                      	POP	SI
  7390                                  WKDAY:
  7391 00000C99 A1[5403]                	MOV	AX,[DAYCNT]
  7392 00000C9C 31D2                    	XOR	DX,DX
  7393 00000C9E B90700                  	MOV	CX,7
  7394 00000CA1 40                      	INC	AX
  7395 00000CA2 40                      	INC	AX		;First day was Tuesday
  7396 00000CA3 F7F1                    	DIV	CX		;Compute day of week
  7397 00000CA5 8816[5603]              	MOV	[WEEKDAY],DL
  7398 00000CA9 30C0                    	XOR	AL,AL		;Flag OK
  7399                                  RET25:
  7400 00000CAB C3                      	RETN
  7401                                  
  7402                                  ;----------------------------------------------------------
  7403                                  
  7404                                  ;**	DSUM - Compute the sum of a string of bytes
  7405                                  ;
  7406                                  ;	ENTRY	(cx) = byte count
  7407                                  ;		(ds:si) = byte address
  7408                                  ;		(dx) = sum register, initialized by caller
  7409                                  ;	EXIT	(dx) updated
  7410                                  ;	USES	ax, cx, dx, si, flags
  7411                                  
  7412                                  DSUM:
  7413 00000CAC B400                    	MOV	AH,0
  7414 00000CAE E305                    	JCXZ	DSUM9 ; 13/05/2019 - Retro DOS v4.0
  7415                                  	;JCXZ	RET25 ; 18/07/2018
  7416                                  DSUM1:
  7417 00000CB0 AC                      	LODSB
  7418 00000CB1 01C2                    	ADD	DX,AX
  7419 00000CB3 E2FB                    	LOOP	DSUM1
  7420                                  DSUM9:
  7421 00000CB5 C3                      	RETN
  7422                                  
  7423                                  ;============================================================================
  7424                                  ; GETSET.ASM (MSDOS 6.0, 1991)
  7425                                  ;============================================================================
  7426                                  ; 29/04/2019 - Retro DOS v4.0
  7427                                  ; 18/07/2018 - Retro DOS v3.0 (GETSET.ASM, MSDOS 6.0, 1991)
  7428                                  
  7429                                  ; 12/03/2018 - Retro DOS v2.0 
  7430                                  
  7431                                  ;TITLE	GETSET - GETting and SETting MS-DOS system calls
  7432                                  ;NAME	GETSET
  7433                                  
  7434                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
  7435                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
  7436                                  
  7437                                  ;USERNUM:
  7438                                  ;	DW	0			; 24 bit user number
  7439                                  ;       DB      0
  7440                                  ;;	IF      IBM
  7441                                  ;;OEMNUM: DB    0			; 8 bit OEM number
  7442                                  ;;	ELSE
  7443                                  ;OEMNUM: DB     0FFH			; 8 bit OEM number
  7444                                  ;;	ENDIF
  7445                                  
  7446                                  ;MSVERS:		; MS-DOS version in hex for $GET_VERSION
  7447                                  ;; 08/07/2018 - Retro DOS v3.0
  7448                                  ;MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
  7449                                  ;MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
  7450                                  
  7451                                  ;BREAK <$Get_Version -- Return MSDOS version number>
  7452                                  ;----------------------------------------------------------------------------
  7453                                  
  7454                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7455                                  ; DOSCODE:4A0Fh (MSDOS 5.0 MSDOS.SYS)
  7456                                  
  7457                                  ; 06/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  7458                                  ; DOSCODE:4B5Fh (PCDOS 7.1 IBMDOS.COM)
  7459                                  
  7460                                  _$GET_VERSION:
  7461                                  
  7462                                  ; Inputs:
  7463                                  ;       None
  7464                                  ; Function:
  7465                                  ;       Return MS-DOS version number
  7466                                  ; Outputs:
  7467                                  ;       OEM number in BH
  7468                                  ;       User number in BL:CX (24 bits)
  7469                                  ;       Version number as AL.AH in binary
  7470                                  ;       NOTE: On pre 1.28 DOSs AL will be zero
  7471                                  
  7472                                  ; MSDOS 6.0
  7473                                  ;
  7474                                  ;	Fake_Count is used to lie about the version numbers to support
  7475                                  ;	old binarys. See ms_table.asm for more info.
  7476                                  ;
  7477                                  ;		if input al = 00
  7478                                  ;		  (bh) = OEM number			
  7479                                  ;		else if input al = 01
  7480                                  ;		  (bh) = version flags
  7481                                  ;		 
  7482                                  ;		       	 bits 0-2 = DOS internal revision
  7483                                  ;		       	 bits 3-7 = DOS type flags
  7484                                  ;		              bit 3    = DOS is in ROM
  7485                                  ;		              bit 4    = DOS in in HMA
  7486                                  ;		              bits 5-7 = reserved
  7487                                  ;               M007 change - only bit 3 is now valid. Other bits
  7488                                  ;               are 0 when AL = 1
  7489                                  
  7490                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
  7491 00000CB6 36C50E[B203]            	lds	cx, [ss:USERNUM]
  7492 00000CBB 8CDB                    	mov	bx, ds
  7493                                  
  7494                                  	; MSDOS 3.3 (IBMDOS.COM, offset 196Dh)
  7495                                  	;--------------------------------------
  7496                                  	; MSDOS 6.21 (MSDOS.SYS, DOSCODE:4A1Ch)
  7497                                  
  7498 00000CBD 16                              PUSH    SS
  7499 00000CBE 1F                              POP     DS
  7500                                          
  7501                                  	; 06/01/2024
  7502                                  	;MOV	BX,[USERNUM+2]
  7503                                          ;MOV	CX,[USERNUM]
  7504                                  
  7505                                  	; 13/05/2019 - Retro DOS v4.0
  7506                                  
  7507                                  	;If AL == 1, ROMDOS will return BH = dos internal version # &
  7508                                  	;DOS flags
  7509                                  
  7510 00000CBF 3C01                    	cmp	AL,1
  7511 00000CC1 7502                    	jne	short Norm_Vers
  7512                                  
  7513                                  ;ifdef ROMDOS
  7514                                  ;	mov	BH,DOSINROM 	; Just set the bit for ROM version
  7515                                  ;				(DOSINROM = 8)
  7516                                  ;else
  7517 00000CC3 30FF                            xor     bh,bh		; Otherwise return 0
  7518                                  ;endif				;M007 end
  7519                                  
  7520                                  Norm_Vers:
  7521                                  	;MOV	AX,[MSVERS]  ; MSDOS 3.3
  7522                                  
  7523                                          	; MSDOS 6.0	; MSVERS is a label in TABLE segment	
  7524                                  	; 13/05/2019 - Retro DOS v4.0
  7525 00000CC5 1E                      	push	ds		; Get the version number from the
  7526 00000CC6 8E1E[3003]              	mov	ds,[CurrentPDB]	; current app's PSP segment
  7527                                  	;mov	ax,[40h]
  7528 00000CCA A14000                  	mov	ax,[PDB.Version] ; AX = DOS version number	
  7529                                  	; 07/12/2022
  7530 00000CCD 1F                      	pop	ds
  7531 00000CCE E8A6F7                  	call	Get_User_Stack
  7532                                  				; Put values for return registers
  7533                                  				; in the proper place on the user's	 
  7534                                  				; stack addressed by DS:SI
  7535                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
  7536                                  gdrvfspc_ret:
  7537                                          ;MOV	[SI+user_env.user_AX],AX
  7538 00000CD1 8904                            MOV	[SI],AX
  7539                                          ;MOV	[SI+4],CX
  7540 00000CD3 894C04                  	mov	[SI+user_env.user_CX],CX
  7541                                  set_user_bx:
  7542                                  	;MOV	[SI+2],BX
  7543 00000CD6 895C02                  	mov	[SI+user_env.user_BX],BX
  7544                                  
  7545 00000CD9 C3                      	RETN
  7546                                  
  7547                                  ; 18/07/2018 - Retro DOS v3.0
  7548                                  
  7549                                  ;BREAK <$Get/Set_Verify_on_Write - return/set verify-after-write flag>
  7550                                  ;----------------------------------------------------------------------------
  7551                                  
  7552                                  ;**	$Get_Verify_On_Write - Get Status of Verify on write flag
  7553                                  ;
  7554                                  ;	ENTRY	none
  7555                                  ;	EXIT	(al) = value of VERIFY flag
  7556                                  ;	USES	all
  7557                                  
  7558                                  
  7559                                  _$GET_VERIFY_ON_WRITE:
  7560                                  
  7561                                  ;hkn; SS override
  7562 00000CDA 36A0[FF02]              	MOV	AL,[SS:VERFLG]	; Retro DOS v2.0 - 12/03/2018
  7563 00000CDE C3                      	retn
  7564                                  
  7565                                  ;**	$Set_Verify_On_Write - Set Status of Verify on write flag
  7566                                  ;
  7567                                  ;	ENTRY	(al) = value of VERIFY flag
  7568                                  ;	EXIT	none
  7569                                  ;	USES	all
  7570                                  
  7571                                  _$SET_VERIFY_ON_WRITE:
  7572                                  
  7573 00000CDF 2401                    	AND	AL,1
  7574                                  ;hkn; SS override
  7575 00000CE1 36A2[FF02]              	MOV	[SS:VERFLG],AL	; Retro DOS v2.0 - 12/03/2018
  7576                                  RET27:	; 18/07/2018
  7577 00000CE5 C3                      	retn
  7578                                  
  7579                                  ; 19/07/2018 - Retro DOS v3.0
  7580                                  
  7581                                  ;BREAK <$International - return country-dependent information>
  7582                                  ;----------------------------------------------------------------------------
  7583                                  ;
  7584                                  ; Procedure Name : $INTERNATIONAL
  7585                                  ;
  7586                                  ; Inputs:
  7587                                  ;	MOV	AH,International
  7588                                  ;	MOV	AL,country	(al = 0 => current country)
  7589                                  ;      [MOV	BX,country]
  7590                                  ;	LDS	DX,block
  7591                                  ;	INT	21
  7592                                  ; Function:
  7593                                  ;	give users an idea of what country the application is running
  7594                                  ; Outputs:
  7595                                  ;	IF DX != -1 on input (get country)
  7596                                  ;	  AL = 0 means return current country table.
  7597                                  ;	  0<AL<0FFH means return country table for country AL
  7598                                  ;	  AL = 0FF means return country table for country BX
  7599                                  ;	  No Carry:
  7600                                  ;	     Register BX will contain the 16-bit country code.
  7601                                  ;	     Register AL will contain the low 8 bits of the country code.
  7602                                  ;	     The block pointed to by DS:DX is filled in with the information
  7603                                  ;	     for the particular country.
  7604                                  ;		BYTE  Size of this table excluding this byte and the next
  7605                                  ;		BYTE  Country code represented by this table
  7606                                  ;			A sequence of n bytes, where n is the number specified
  7607                                  ;			by the first byte above and is not > internat_block_max,
  7608                                  ;			in the correct order for being returned by the
  7609                                  ;			INTERNATIONAL call as follows:
  7610                                  ;		WORD	Date format 0=mdy, 1=dmy, 2=ymd
  7611                                  ;		5 BYTE	Currency symbol null terminated
  7612                                  ;		2 BYTE	thousands separator null terminated
  7613                                  ;		2 BYTE	Decimal point null terminated
  7614                                  ;		2 BYTE	Date separator null terminated
  7615                                  ;		2 BYTE	Time separator null terminated
  7616                                  ;		1 BYTE	Bit field.  Currency format.
  7617                                  ;			Bit 0.	=0 $ before #  =1 $ after #
  7618                                  ;			Bit 1.	no. of spaces between # and $ (0 or 1)
  7619                                  ;		1 BYTE	No. of significant decimal digits in currency
  7620                                  ;		1 BYTE	Bit field.  Time format.
  7621                                  ;			Bit 0.	=0 12 hour clock  =1 24 hour
  7622                                  ;		DWORD	Call address of case conversion routine
  7623                                  ;		2 BYTE	Data list separator null terminated.
  7624                                  ;	  Carry:
  7625                                  ;	     Register AX has the error code.
  7626                                  ;	IF DX = -1 on input (set current country)
  7627                                  ;	  AL = 0 is an error
  7628                                  ;	  0<AL<0FFH means set current country to country AL
  7629                                  ;	  AL = 0FF means set current country to country BX
  7630                                  ;	  No Carry:
  7631                                  ;	    Current country SET
  7632                                  ;	    Register AL will contain the low 8 bits of the country code.
  7633                                  ;	  Carry:
  7634                                  ;	     Register AX has the error code.
  7635                                  ;-----------------------------------------------------------------------------
  7636                                  
  7637                                  ;procedure   $INTERNATIONAL,NEAR   ; DOS 3.3
  7638                                  
  7639                                  ; 13/05/2019 - Retro DOS v4.0
  7640                                  ; DOSCODE:4A4Dh (MSDOS 6.21, MSDOS.SYS)
  7641                                  
  7642                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7643                                  ; DOSCODE:4A40h (MSDOS 5.0, MSDOS.SYS)
  7644                                  
  7645                                  ; 06/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 PCDOS.COM)
  7646                                  ; DOSCODE:4B8Dh (PCDOS 7.1, IBMDOS.COM)
  7647                                  
  7648                                  _$INTERNATIONAL:  ; IBMDOS.COM (MSDOS 3.3), offset 1992h
  7649                                  	 
  7650 00000CE6 3CFF                    	CMP	AL,0FFH
  7651 00000CE8 7404                    	JZ	short BX_HAS_CODE	; -1 means country code is in BX
  7652 00000CEA 88C3                    	MOV	BL,AL			; Put AL country code in BX
  7653 00000CEC 30FF                    	XOR	BH,BH
  7654                                  BX_HAS_CODE:
  7655 00000CEE 1E                      	PUSH	DS
  7656 00000CEF 07                      	POP	ES
  7657 00000CF0 52                      	PUSH	DX
  7658 00000CF1 5F                      	POP	DI			; User buffer to ES:DI
  7659                                  
  7660                                  ;hkn; SS is DOSDATA
  7661                                  ;	context DS
  7662                                  
  7663 00000CF2 16                      	push	ss
  7664 00000CF3 1F                      	pop	ds
  7665                                  
  7666 00000CF4 83FFFF                  	CMP	DI,-1
  7667 00000CF7 745D                    	JZ	short international_set
  7668 00000CF9 09DB                    	OR	BX,BX
  7669 00000CFB 7505                    	JNZ	short international_find
  7670                                  
  7671                                  ;hkn; country_cdpg is in DOSDATA segment.
  7672 00000CFD BE[5113]                	MOV	SI,COUNTRY_CDPG
  7673                                  
  7674 00000D00 EB39                    	JMP	SHORT international_copy
  7675                                  
  7676                                  international_find:
  7677                                  	;MOV	BP,0			 ; flag it for GetCntry only
  7678                                  	; 06/01/2024
  7679 00000D02 31ED                    	xor	bp,bp ; 0
  7680 00000D04 E80A00                  	CALL	international_get
  7681 00000D07 7255                    	JC	short errtn
  7682                                  	;CMP	BX,0			 ; nlsfunc finished it ?
  7683                                  	; 06/01/2024
  7684 00000D09 09DB                    	or	bx,bx
  7685 00000D0B 752E                    	JNZ	SHORT international_copy ; no, copy by myself
  7686 00000D0D 89D3                    	MOV	BX,DX			 ; put country back
  7687 00000D0F EB3A                    	JMP	SHORT international_ok3
  7688                                  
  7689                                  international_get:
  7690 00000D11 BE[5113]                	MOV	SI,COUNTRY_CDPG
  7691                                  
  7692                                  ;hkn; country_cdpg is in DOSDATA segment.
  7693                                  ;hkn; use ss override to access COUNTRY_CDPG fields
  7694                                  
  7695                                  	; MSDOS 3.3
  7696                                  	;;cmp	bx,[SI+63h]
  7697                                  	;CMP	BX,[SI+DOS_CCDPG.ccDosCountry]
  7698                                  	;jz	short RET27
  7699                                  
  7700                                  	; 13/05/2019 - Retro DOS v4.0
  7701                                  
  7702                                  	; MSDOS 6.0
  7703                                  	;cmp	bx,[ss:si+68h]
  7704 00000D14 363B5C68                	CMP	BX,[ss:SI+DOS_CCDPG.ccDosCountry] ; = current country id
  7705 00000D18 74CB                    	jz	short RET27			; return if equal
  7706                                  
  7707 00000D1A 89DA                    	MOV	DX,BX
  7708 00000D1C 31DB                    	XOR	BX,BX			; bx = 0, default code page
  7709                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7710 00000D1E B80014                  	mov	ax,1400h
  7711 00000D21 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7712                                  			; Return: AL = 00h not installed, OK to install
  7713                                  			; 01h not installed, not OK
  7714                                  			; FFh installed
  7715 00000D23 3CFF                    	CMP	AL,0FFH
  7716 00000D25 7510                    	JNZ	short interr		; not in memory
  7717                                  	
  7718                                  	; 06/01/2024
  7719 00000D27 B80314                  	mov	ax,1403h		; set country info
  7720                                  
  7721                                  	;cmp	bp,0
  7722 00000D2A 09ED                    	or	bp,bp			; GetCntry ?
  7723 00000D2C 7501                    	JNZ	short stcdpg
  7724                                  	
  7725                                  	;CallInstall GetCntry,NLSFUNC,4	; get country info
  7726                                  	;mov	ax,1404h
  7727 00000D2E 40                      	inc	ax	; AX = 1404h ; get country info
  7728                                  
  7729                                  	; 06/01/2024
  7730                                  	;int	2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
  7731                                  	;		; BX = code page, DX = country code,
  7732                                  	;		; DS:SI -> internal code page structure
  7733                                  	;		; ES:DI -> user buffer
  7734                                  	;		; Return: AL = status
  7735                                  	;
  7736                                  	;JMP	short chkok
  7737                                  	
  7738                                  	;nop
  7739                                  
  7740                                  stcdpg:
  7741                                  	;CallInstall SetCodePage,NLSFUNC,3  ; set country info
  7742                                  	; 06/01/2024
  7743                                  	;mov     ax,1403h
  7744                                  gscdpg:
  7745 00000D2F CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - SET COUNTRY INFO
  7746                                  			; DS:SI -> internal code page structure
  7747                                  			; BX = code page, DX = country code
  7748                                  			; Return: AL = status
  7749                                  chkok:
  7750 00000D31 08C0                    	or	al,al			; success ?
  7751                                  	;retz				; yes
  7752 00000D33 74B0                    	jz	short RET27
  7753                                  
  7754                                  setcarry:
  7755 00000D35 F9                      	STC				; set carry
  7756 00000D36 C3                      	retn
  7757                                  interr:
  7758 00000D37 B0FF                    	MOV	AL,0FFH			; flag nlsfunc error
  7759 00000D39 EBFA                    	JMP	short setcarry
  7760                                  
  7761                                  international_copy:
  7762                                  
  7763                                  ;hkn; country_cdpg is in DOSDATA segment.
  7764                                  ;hkn; use ss override to access COUNTRY_CDPG fields
  7765                                  
  7766                                  	; MSDOS 3.3
  7767                                  	;;mov	bx,[SI+63h]
  7768                                  	;mov	BX,[SI+DOS_CCDPG.ccDosCountry]
  7769                                  	;mov	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; 08/09/2018
  7770                                  
  7771                                  	; 13/05/2019 - Retro DOS v4.0
  7772                                  
  7773                                  	; MSDOS 6.0
  7774                                  	;mov	bx,[ss:si+68h]
  7775 00000D3B 368B5C68                	MOV	BX,[ss:SI+DOS_CCDPG.ccDosCountry] ; = current country id
  7776 00000D3F BE[BD13]                	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; COUNTRY_CDPG + 108
  7777                                  
  7778                                  	;mov	cx,24
  7779 00000D42 B91800                  	MOV	CX,OLD_COUNTRY_SIZE
  7780                                  
  7781                                  	; MSDOS 6.0
  7782                                  
  7783                                  ;hkn;	must set up DS to SS so that international info can be copied
  7784                                  	
  7785 00000D45 1E                      	push	ds
  7786                                  
  7787 00000D46 16                      	push	ss			; cs -> ss
  7788 00000D47 1F                      	pop	ds
  7789                                  
  7790 00000D48 F3A4                    	REP	MOVSB			; copy country info
  7791                                  
  7792                                  	; MSDOS 6.0
  7793                                  
  7794 00000D4A 1F                      	pop	ds	;hkn;	restore ds
  7795                                  
  7796                                  international_ok3:
  7797 00000D4B E829F7                  	call	Get_User_Stack
  7798                                  ;ASSUME	DS:NOTHING
  7799                                  	;MOV	[SI+2],BX
  7800 00000D4E 895C02                  	MOV	[SI+user_env.user_BX],BX
  7801                                  international_ok:
  7802 00000D51 89D8                    	MOV	AX,BX			; Return country code in AX too.
  7803                                  ;SYS_RET_OK_jmp:
  7804                                  	; 05/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7805                                  	; 09/01/2024
  7806                                  ;nono:	; 15/12/2022
  7807                                  SYS_RET_OK_jmp:
  7808 00000D53 E91AF9                  	jmp	SYS_RET_OK
  7809                                  
  7810                                  international_set:
  7811                                  
  7812                                  ;hkn; ASSUME	DS:DOSGROUP
  7813                                  ;ASSUME	DS:DOSDATA
  7814                                  
  7815 00000D56 BD0100                  	MOV	BP,1			; flag it for SetCodePage only
  7816 00000D59 E8B5FF                  	CALL	international_get
  7817 00000D5C 73F3                    	JNC	short international_ok
  7818                                  errtn:
  7819 00000D5E 3CFF                    	CMP	AL,0FFH
  7820 00000D60 7403                    	JZ	short errtn2
  7821                                  errtn1:
  7822 00000D62 E915F9                  	jmp	SYS_RET_ERR		; return what we got from NLSFUNC
  7823                                  errtn2:
  7824                                  	;error	error_invalid_function	; NLSFUNC not existent
  7825                                  
  7826                                  	;mov	al,1
  7827 00000D65 B001                    	mov	al,error_invalid_function
  7828 00000D67 EBF9                    	jmp	short errtn1 ; 13/05/2019 - Retro DOS v4.0
  7829                                  ;errtn3:
  7830                                  ;	jmp	SYS_RET_ERR
  7831                                  
  7832                                  ;EndProc $INTERNATIONAL
  7833                                  
  7834                                  
  7835                                  ; ---------------------------------------------------------------------------
  7836                                  
  7837                                  	; 06/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 PCDOS.COM)
  7838                                  	; DOSCODE:4C10h (PCDOS 7.1, IBMDOS.COM)
  7839                                  
  7840                                  _$ExtCountryInfo:
  7841                                  			; INT 21h, AH = 70h
  7842                                  			; GET/SET INTERNATIONALIZATION INFORMATION
  7843                                  			; ****
  7844                                  			; AL = subfunction
  7845                                  			; 00h SET general internationalization info
  7846                                  			;    CX = buffer size (up to 38 bytes)
  7847                                  			;    DS:SI -> buffer containing internationalization info
  7848                                  			;  first three bytes are skipped, the rest is copied to
  7849                                  			;  somewhere in the DOS data segment
  7850                                  			; 01h SET extended internationalization info
  7851                                  			;    CX = number of bytes to set (up to 58 bytes)
  7852                                  			;    DS:SI -> buffer containing internationalization info
  7853                                  			; 02h GET extended internationalization info
  7854                                  			;    CX = buffer size in bytes (up to 58 bytes used)
  7855                                  			;    ES:DI -> buffer
  7856                                  			; ****
  7857                                  			; (Ref: Ralf Brown's Interrupt List) - had some mistakes -
  7858 00000D69 3C02                    	cmp	al,2 
  7859 00000D6B 77F8                    	ja	short errtn2
  7860 00000D6D 06                      	push    es
  7861 00000D6E 16                      	push    ss
  7862 00000D6F 750F                    	jnz	short ext_cntry_inf_1
  7863 00000D71 07                      	pop	es		; AX = GET 35 bytes info (from offset 3 to 37)
  7864                                  				; (38 bytes buffer is used)
  7865 00000D72 BF[B913]                	mov	di,_COUNTRY_ID
  7866 00000D75 268B45FE                	mov	ax,[es:di-2]	; NEW_COUNTRY_SIZE = 38
  7867 00000D79 BB0300                  	mov	bx,3		; skip the 1st 3 bytes of the buffer
  7868 00000D7C 01DE                    	add	si,bx
  7869 00000D7E EB13                    	jmp	short ext_cntry_inf_4
  7870                                  
  7871                                  ext_cntry_inf_1:
  7872 00000D80 FEC8                    	dec	al
  7873 00000D82 7506                    	jnz	short ext_cntry_inf_2 ; AX = 2
  7874                                  				; AX = 1 (set)
  7875 00000D84 07                      	pop	es
  7876 00000D85 BF[E113]                	mov	di,_ENU		; "ENU"
  7877 00000D88 EB04                    	jmp	short ext_cntry_inf_3
  7878                                  
  7879                                  ext_cntry_inf_2:
  7880 00000D8A 1F                      	pop	ds		; AX = 2 (get)
  7881 00000D8B BE[E113]                	mov	si,_ENU		; "ENU"
  7882                                  
  7883                                  ext_cntry_inf_3:		; CODE XREF: DOSCODE:4C2F^j
  7884 00000D8E 31DB                    	xor	bx,bx		; 0
  7885 00000D90 B83A00                  	mov	ax,58		; 3Ah
  7886                                  
  7887                                  ext_cntry_inf_4:
  7888 00000D93 39C1                    	cmp	cx,ax		; > 38 ? (58)
  7889                                  	;jb	short ext_cntry_inf_5 ; no
  7890 00000D95 7602                    	jna	short ext_cntry_inf_5 ; 06/01/2024
  7891 00000D97 89C1                    	mov	cx,ax		; yes, decrease size to 38 (58)
  7892                                  
  7893                                  ext_cntry_inf_5:
  7894 00000D99 89C8                    	mov	ax,cx		; buffer (filled) size
  7895 00000D9B 29D9                    	sub	cx,bx		; copy byte count
  7896 00000D9D F3A4                    	rep movsb
  7897 00000D9F 07                      	pop	es
  7898 00000DA0 E91903                  	jmp	ret_ax_to_user_cx ; ax -> user's cx
  7899                                  
  7900                                  ; ---------------------------------------------------------------------------
  7901                                  
  7902                                  ; 19/07/2018
  7903                                  
  7904                                  ;BREAK <$GetExtCntry - return extended country-dependent information>
  7905                                  
  7906                                  ;----------------------------------------------------------------------------
  7907                                  ;
  7908                                  ; Procedure Name : $GetExtCntry
  7909                                  ;
  7910                                  ; Inputs:
  7911                                  ;	if AL >= 20H
  7912                                  ;	  AL= 20H    capitalize single char, DL= char
  7913                                  ;	      21H    capitalize string, CX= string length
  7914                                  ;	      22H    capitalize ASCIIZ string
  7915                                  ;	      23H    YES/NO check, DL=1st char DH= 2nd char (DBCS)
  7916                                  ;	      80H bit 0 = use normal upper case table
  7917                                  ;		      1 = use file upper case table
  7918                                  ;	   DS:DX points to string
  7919                                  ;
  7920                                  ;	else
  7921                                  ;
  7922                                  ;	MOV	AH,GetExtCntry	 ; DOS 3.3
  7923                                  ;	MOV	AL,INFO_ID	( info type,-1 selects all )
  7924                                  ;	MOV	BX,CODE_PAGE	( -1 = active code page )
  7925                                  ;	MOV	DX,COUNTRY_ID	( -1 = active country )
  7926                                  ;	MOV	CX,SIZE 	( amount of data to return )
  7927                                  ;	LES	DI,COUNTRY_INFO ( buffer for returned data )
  7928                                  ;	INT	21
  7929                                  ; Function:
  7930                                  ;	give users extended country dependent information
  7931                                  ;	or capitalize chars
  7932                                  ; Outputs:
  7933                                  ;	  No Carry:
  7934                                  ;	     extended country info is succesfully returned
  7935                                  ;	  Carry:
  7936                                  ;	     Register AX has the error code.
  7937                                  ;	     AX=0, NO	 for YES/NO CHECK
  7938                                  ;		1, YES
  7939                                  ;----------------------------------------------------------------------------
  7940                                  
  7941                                  ;procedure   $GetExtCntry,NEAR	; DOS 3.3
  7942                                  
  7943                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7944                                  	; 06/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  7945                                  
  7946                                  	; MSDOS 6.0
  7947                                  _$GetExtCntry:
  7948 00000DA3 3C20                    	CMP	AL,CAP_ONE_CHAR 	; < 20H ?
  7949 00000DA5 726A                    	JB	short notcap
  7950                                  capcap: 				;
  7951 00000DA7 A880                    	TEST	AL,UPPER_TABLE	; 80h	; which upper case table
  7952 00000DA9 7505                    	JNZ	short fileupper		; file upper case
  7953                                  
  7954                                  ;hkn; UCASE_TAB in DOSDATA
  7955 00000DAB BB[030B]                	MOV	BX,UCASE_TAB+2		; get normal upper case
  7956 00000DAE EB05                    	JMP	SHORT capit
  7957                                  
  7958                                  fileupper:
  7959                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM - DOSCODE:4C57h)
  7960                                  	; ((Note: This must be a bugfix, because bit 7 of AX is 1 here!))
  7961                                  	; AL >= 80h
  7962 00000DB0 247F                    	and	al,7Fh 
  7963                                  
  7964                                  ;hkn; FILE_UCASE_TAB in DOSDATA
  7965 00000DB2 BB[850B]                	MOV	BX,FILE_UCASE_TAB+2 ; get file upper case
  7966                                  capit:					;
  7967 00000DB5 3C20                    	CMP	AL,CAP_ONE_CHAR ; 20h	; cap one char ?
  7968 00000DB7 750D                    	JNZ	short chkyes		; no
  7969 00000DB9 88D0                    	MOV	AL,DL			; set up AL
  7970 00000DBB E88C4C                  	call	GETLET3 		; upper case it
  7971 00000DBE E8B6F6                  	call	Get_User_Stack		; get user stack
  7972                                  	;mov	[si+6],al
  7973 00000DC1 884406                  	MOV	[SI+user_env.user_DX],AL ; user's DL=AL
  7974 00000DC4 EB24                    	JMP	SHORT nono		; done
  7975                                  chkyes: 				;
  7976 00000DC6 3C23                    	CMP	AL,CHECK_YES_NO	; 23h	; check YES or NO ?
  7977 00000DC8 7523                    	JNZ	short capstring		; no
  7978                                  
  7979 00000DCA 31C0                    	XOR	AX,AX			; presume NO
  7980                                  		      
  7981                                  ;hkn; NLS_YES, NLS_NO, NLS_yes2, NLS_no2 is defined in msdos.cl3 which is
  7982                                  ;hkn; included in yesno.asm in the DOSCODE segment.
  7983                                  
  7984                                  	; 06/08/2018 - Retro DOS v3.0
  7985                                  	; 13/05/2019 - Retro DOS v4.0
  7986                                  	;cmp	dl,'Y'
  7987 00000DCC 2E3A16[5D14]            	CMP	DL,[cs:NLS_YES]		; is 'Y' ?
  7988 00000DD1 7416                    	JZ	short yesyes		; yes
  7989                                  	;cmp	dl,'y'
  7990 00000DD3 2E3A16[5F14]            	CMP	DL,[cs:NLS_yes2]	; is 'y' ?
  7991 00000DD8 740F                    	JZ	short yesyes		; yes
  7992                                  	;cmp	dl,'N'
  7993 00000DDA 2E3A16[5E14]            	CMP	DL,[cs:NLS_NO]		; is  'N'?
  7994 00000DDF 7409                    	JZ	short nono		; no
  7995                                  	;cmp	dl,'n'
  7996 00000DE1 2E3A16[6014]            	CMP	DL,[cs:NLS_no2]		; is 'n' ?
  7997 00000DE6 7402                    	JZ	short nono		; no
  7998                                  ;dbcs_char:				;
  7999 00000DE8 40                      	INC	AX			; not YES or NO
  8000                                  yesyes: 				;
  8001 00000DE9 40                      	INC	AX			; return 1
  8002                                  	; 15/12/2022
  8003                                  	; 09/01/2024 - Retro DOS v5.0
  8004                                  nono:	
  8005                                  	;jmp	short SYS_RET_OK_jmp	;
  8006                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8007                                  	; 09/01/2024
  8008 00000DEA E983F8                  	jmp	SYS_RET_OK		; done
  8009                                  
  8010                                  capstring:				;
  8011 00000DED 89D6                    	MOV	SI,DX			; si=dx
  8012 00000DEF 3C21                    	CMP	AL,CAP_STRING	; 21h	; cap string ?
  8013 00000DF1 750D                    	JNZ	short capascii		; no
  8014                                  	;OR	CX,CX			; check count 0
  8015                                  	;JZ	short nono		; yes finished
  8016                                  	; 06/01/2024
  8017 00000DF3 E3F5                    	jcxz	nono
  8018                                  concap: 				;
  8019 00000DF5 AC                      	LODSB				; get char
  8020 00000DF6 E8514C                  	call	GETLET3 		; upper case it
  8021 00000DF9 8844FF                  	MOV	byte [SI-1],AL		; store back
  8022                                  ;next99: 				;
  8023 00000DFC E2F7                    	LOOP	concap			; continue
  8024 00000DFE EBEA                    	JMP	short nono		; done
  8025                                  capascii:				;
  8026 00000E00 3C22                    	CMP	AL,CAP_ASCIIZ	; 22h	; cap ASCIIZ string ?
  8027 00000E02 7573                    	JNZ	short capinval		; no
  8028                                  concap2:				;
  8029 00000E04 AC                      	LODSB				; get char
  8030 00000E05 08C0                    	or	al,al			; end of string ?
  8031 00000E07 74E1                    	JZ	short nono		; yes
  8032 00000E09 E83E4C                  	call	GETLET3 		; upper case it
  8033 00000E0C 8844FF                  	MOV	[SI-1],AL		; store back
  8034 00000E0F EBF3                    	JMP	short concap2 		; continue
  8035                                  
  8036                                  	; MSDOS 3.3 (& MSDOS 6.0)
  8037                                  
  8038                                  ; Offset 1A19h in IBMDOS.COM (MSDOS 3.3), 1987 	
  8039                                  ; _$GetExtCntry:
  8040                                  
  8041                                  notcap:
  8042 00000E11 83F905                  	CMP	CX,5			; minimum size is 5
  8043                                  	;jb	short sizeerror
  8044                                  	; 09/01/2024
  8045 00000E14 7261                    	jb	short capinval		; (size error)
  8046                                  
  8047                                  GEC_CONT:
  8048                                  ;hkn; SS is DOSDATA
  8049                                  	;context DS
  8050                                  
  8051 00000E16 16                      	push	ss
  8052                                  	;pop	es  ; ! (Retro DOS v3.0 BUG) !
  8053 00000E17 1F                      	pop	ds  ; 13/05/2019 - Retro DOS v4.0	
  8054                                  	
  8055                                  ;hkn; COUNTRY_CDPG is in DOSDATA
  8056 00000E18 BE[5113]                	MOV	SI,COUNTRY_CDPG
  8057                                  
  8058                                  ; ------------------------------------------------------------
  8059                                  	; 06/01/2024 - Retro DOS v5.0
  8060                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:4CC6h
  8061                                  	;;;
  8062 00000E1B 08C0                    	or	al,al
  8063 00000E1D 752A                    	jnz	short GETCNTRY
  8064                                  			; AL = 0 (INT 21h, AX=6500h)
  8065                                  			; Set extended country-dependent information
  8066                                  			; (SET GENERAL INTERNATIONALIZATION INFO)
  8067                                  
  8068 00000E1F 83E907                  	sub	cx,7		; minimum 8 bytes
  8069 00000E22 7653                    	jbe	short capinval	; error_invalid_function
  8070 00000E24 8B5C48                  	mov	bx,[si+48h]	; [SI+DOS_CCDPG.ccSysCodePage]
  8071 00000E27 8D7466                  	lea	si,[si+66h]	; SI+DOS_CCDPG.ccCountryInfoLen
  8072 00000E2A 8B04                    	mov	ax,[si]
  8073 00000E2C 83E804                  	sub	ax,4
  8074 00000E2F 39C1                    	cmp	cx,ax
  8075 00000E31 7602                    	jbe	short set_intern_inf
  8076 00000E33 89C1                    	mov	cx,ax
  8077                                  set_intern_inf:
  8078 00000E35 89C8                    	mov	ax,cx
  8079 00000E37 83C004                  	add	ax,4
  8080 00000E3A 26894501                	mov	[es:di+1], ax	; info length/size (will be written)
  8081 00000E3E 83C606                  	add	si,6		; DOS_CCDPG.ccDFormat
  8082 00000E41 83C707                  	add	di,7		; points to date format
  8083 00000E44 E8AE09                  	call	XCHGP		; ds:si = user's buffer + 6
  8084                                  				; es:di = country info buffer + 7
  8085 00000E47 EB3F                    	jmp	short OK_RETN
  8086                                  	;;;
  8087                                  ; ------------------------------------------------------------
  8088                                  	
  8089                                  	; 06/01/2024
  8090                                  GETCNTRY:
  8091 00000E49 83FAFF                  	CMP	DX,-1 ; COUNTRY_ID	; active country ?
  8092 00000E4C 7503                    	JNZ	short GETCDPG 		; no
  8093                                  
  8094                                  ;hkn; use DS override to accesss country_cdpg fields
  8095                                  	;;mov	dx,[si+63h] ; MSDOS 3.3
  8096                                  	;mov	dx,[si+68h] ; MSDOS 6.0
  8097 00000E4E 8B5468                  	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]
  8098                                  					; get active country id;smr;use DS
  8099                                  GETCDPG:
  8100 00000E51 83FBFF                  	CMP	BX,-1 ; CODE_PAGE	; active code page?
  8101 00000E54 7503                    	JNZ	short CHKAGAIN		; no, check again
  8102                                  
  8103                                  ;hkn; use DS override to accesss country_cdpg fields
  8104                                  	;;mov	bx,[si+65h] ; MSDOS 3.3	
  8105                                  	;mov	bx,[si+6Ah] ; MSDOS 6.0
  8106 00000E56 8B5C6A                  	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
  8107                                  					; get active code page id;smr;Use DS
  8108                                  CHKAGAIN:
  8109                                  	;cmp	dx,[si+68h] ; MSDOS 6.0
  8110 00000E59 3B5468                  	CMP	DX,[SI+DOS_CCDPG.ccDosCountry]
  8111                                  					; same as active country id?;smr;use DS
  8112 00000E5C 7550                    	JNZ	short CHKNLS		; no
  8113                                  	;cmp	bx,[si+6Ah] ; MSDOS 6.0	
  8114 00000E5E 3B5C6A                  	CMP	BX,[SI+DOS_CCDPG.ccDosCodePage]	
  8115                                  					; same as active code pg id?;smr;use DS
  8116 00000E61 754B                    	JNZ	short CHKNLS		; no
  8117                                  CHKTYPE:
  8118                                  	;mov	bx,[si+48h]
  8119 00000E63 8B5C48                  	MOV	BX,[SI+DOS_CCDPG.ccSysCodePage]	
  8120                                  					; bx = sys code page id;smr;use DS
  8121 00000E66 51                      	PUSH	CX			; save cx
  8122                                  	;mov	cx,[si+4Ah]
  8123 00000E67 8B4C4A                  	MOV	CX,[SI+DOS_CCDPG.ccNumber_of_entries]  ;smr;use DS
  8124                                  	;mov	si,COUNTRY_CDPG+76
  8125 00000E6A BE[9D13]                	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccSetUcase   ;smr;CDPG in DOSDATA
  8126                                  NXTENTRY:
  8127 00000E6D 3A04                    	CMP	AL,[SI] 		; compare info type;smr;use DS
  8128 00000E6F 740B                    	JZ	short FOUNDIT
  8129 00000E71 83C605                  	ADD	SI,5			; next entry
  8130 00000E74 E2F7                    	LOOP	NXTENTRY
  8131 00000E76 59                      	POP	CX
  8132                                  capinval:
  8133                                  	;error	error_invalid_function	; info type not found
  8134                                  	;mov	al,1
  8135 00000E77 B001                    	mov	al,error_invalid_function
  8136                                  ;SYS_RET_ERR_jmp:
  8137                                  	;jmp	SYS_RET_ERR
  8138                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8139                                  SYS_RET_ERR_jmp:
  8140 00000E79 E9FEF7                  	jmp	SYS_RET_ERR	
  8141                                  
  8142                                  FOUNDIT:
  8143 00000E7C A4                      	MOVSB				; move info id byte
  8144 00000E7D 59                      	POP	CX			; restore char count
  8145                                  	;cmp	al,1
  8146 00000E7E 3C01                    	CMP	AL,SetCountryInfo	; select country info type ?
  8147 00000E80 7415                    	JZ	short setsize
  8148 00000E82 B90400                  	MOV	CX,4			; 4 bytes will be moved
  8149 00000E85 B80500                  	MOV	AX,5			; 5 bytes will be returned in CX
  8150                                  OK_RETN:
  8151 00000E88 F3A4                    	REP	MOVSB			; copy info
  8152 00000E8A 89C1                    	MOV	CX,AX			; CX = actual length returned
  8153 00000E8C 89D8                    	MOV	AX,BX			; return sys code page in ax
  8154                                  GETDONE:
  8155 00000E8E E8E6F5                  	call	Get_User_Stack		; return actual length to user's CX
  8156                                  	;mov	[si+4],cx 
  8157 00000E91 894C04                  	MOV	[SI+user_env.user_CX],CX
  8158                                  	;jmp	SYS_RET_OK
  8159                                  	; 15/12/2022
  8160                                  	; 25/06/2019
  8161 00000E94 E9DCF7                  	jmp	SYS_RET_OK_clc
  8162                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8163                                  	; 15/12/2022
  8164                                  ;nono_jmp:
  8165                                  	;jmp	short nono
  8166                                  setsize:
  8167 00000E97 83E903                  	SUB	CX,3			; size after length field
  8168 00000E9A 390C                    	CMP	[SI],CX			; less than table size ;smr;use ds
  8169 00000E9C 7302                    	JAE	short setsize2		; no
  8170 00000E9E 8B0C                    	MOV	CX,[SI]			; truncate to table size ;smr;use ds
  8171                                  setsize2:
  8172 00000EA0 26890D                  	MOV	[ES:DI],CX		; copy actual length to user's buffer
  8173                                  	;ADD	DI,2			; update index
  8174                                  	;ADD	SI,2
  8175                                  	; 06/01/2024
  8176 00000EA3 47                      	inc	di
  8177 00000EA4 47                      	inc	di
  8178 00000EA5 46                      	inc	si
  8179 00000EA6 46                      	inc	si
  8180 00000EA7 89C8                    	MOV	AX,CX
  8181 00000EA9 83C003                  	ADD	AX,3			; AX has the actual length
  8182 00000EAC EBDA                    	JMP	short OK_RETN 		; go move it
  8183                                  CHKNLS:
  8184 00000EAE 30E4                    	XOR	AH,AH
  8185                                  	;PUSH	AX			; save info type
  8186                                  	;POP	BP			; bp = info type
  8187                                  	; 06/01/2024
  8188 00000EB0 89C5                    	mov	bp,ax
  8189                                  
  8190                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  8191 00000EB2 B80014                  	mov     ax,1400h
  8192 00000EB5 CD2F                    	int     2Fh     ; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  8193                                  			; Return: AL = 00h not installed, OK to install
  8194                                  			; 01h not installed, not OK
  8195                                  			; FFh installed
  8196 00000EB7 3CFF                    	CMP	AL,0FFH
  8197 00000EB9 7402                    	JZ	short NLSNXT		; in memory
  8198                                  
  8199                                  sizeerror:
  8200                                  	; 09/01/2024 - Retro DOS v5.0
  8201                                  	;
  8202                                  ;	;error	error_invalid_function
  8203                                  ;	;mov	al,1
  8204                                  ;	mov	al,error_invalid_function
  8205                                  ;	;jmp	SYS_RET_ERR
  8206                                  ;	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8207                                  ;sys_ret_err_jmp2:
  8208                                  ;	jmp	short SYS_RET_ERR_jmp
  8209                                  	; 09/01/2024
  8210 00000EBB EBBA                    	jmp	short capinval
  8211                                  
  8212                                  NLSNXT: 
  8213                                  	;CallInstall GetExtInfo,NLSFUNC,2 ;get extended info
  8214 00000EBD B80214                  	mov     ax,1402h
  8215 00000EC0 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
  8216                                  			; BP = subfunction, BX = code page
  8217                                  			; DX = country code, DS:SI -> internal code page structure
  8218                                  			; ES:DI -> user buffer, CX = size of user buffer
  8219                                  			; Return: AL = status
  8220                                  			; 00h successful
  8221                                  			; else DOS error code
  8222                                  
  8223 00000EC2 3C00                    	CMP	AL,0			; success ?
  8224 00000EC4 7505                    	JNZ	short NLSERROR
  8225                                  	;mov	ax,[si+48h] ; 13/05/2019 
  8226 00000EC6 8B4448                  	MOV	AX,[SI+DOS_CCDPG.ccSysCodePage]
  8227                                  			; ax = sys code page id;smr;use ds;
  8228                                  			;BUGBUG;check whether DS is OK after the above calls
  8229 00000EC9 EBC3                    	JMP	short GETDONE
  8230                                  seterr:
  8231                                  	; 15/12/2022
  8232                                  NLSERROR:
  8233                                  	;jmp	SYS_RET_ERR		; return what is got from NLSFUNC
  8234                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8235                                  	;jmp	short sys_ret_err_jmp2
  8236                                  	; 15/12/2022
  8237 00000ECB EBAC                    	jmp	short SYS_RET_ERR_jmp
  8238                                  
  8239                                  ;EndProc $GetExtCntry
  8240                                  
  8241                                  ; 13/05/2019 - Retro DOS v4.0
  8242                                  ; DOSCODE:4BD6h (MSDOS 6.21, MSDOS.SYS)
  8243                                  
  8244                                  ;BREAK <$GetSetCdPg - get or set global code page>
  8245                                  ;----------------------------------------------------------------------------
  8246                                  ;**	$GetSetCdPg - Get or Set Global Code Page
  8247                                  ;
  8248                                  ;   System call format:
  8249                                  ;
  8250                                  ;	MOV	AH,GetSetCdPg	; DOS 3.3
  8251                                  ;	MOV	AL,n		; n = 1 : get code page, n = 2 : set code page
  8252                                  ;	MOV	BX,CODE_PAGE	(set code page only)
  8253                                  ;	INT	21
  8254                                  ;
  8255                                  ;	ENTRY	(al) = n
  8256                                  ;		(bx) = code page
  8257                                  ;	EXIT	'C' clear
  8258                                  ;		  global code page is set	(set global code page)
  8259                                  ;		  (BX) = active code page id	(get global code page)
  8260                                  ;		  (DX) = system code page id	(get global code page)
  8261                                  ;		'C' set
  8262                                  ;		  (AX) = error code
  8263                                  
  8264                                  ;procedure  $GetSetCdPg,NEAR   ; DOS 3.3
  8265                                  
  8266                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8267                                  	; DOSCODE:4BC9h
  8268                                  
  8269                                  	; 06/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  8270                                  	; DOSCODE:4D73h
  8271                                  
  8272                                  _$GetSetCdPg:
  8273                                  
  8274                                  ;hkn; SS is DOSDATA
  8275                                  	;context DS
  8276                                  
  8277 00000ECD 16                      	push	ss
  8278 00000ECE 1F                      	pop	ds
  8279                                  
  8280                                  ;hkn; COUNTRY_CDPG is in DOSDATA
  8281 00000ECF BE[5113]                	MOV	SI,COUNTRY_CDPG	  ; (DOSDATA:122Ah for MSDOS 6.21)
  8282                                  
  8283 00000ED2 3C01                    	CMP	AL,1		       ; get global code page
  8284 00000ED4 7512                    	JNZ	short setglpg 	       ; set global code page
  8285                                  	
  8286                                  	;;mov	bx,[si+65h] ; MSDOS 3.3
  8287                                  	;mov	bx,[si+6Ah] ; MSDOS 6.0
  8288 00000ED6 8B5C6A                  	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
  8289                                  					; get active code page id;smr;use ds
  8290                                  	;mov	dx,[si+48h]
  8291 00000ED9 8B5448                  	MOV	DX,[SI+DOS_CCDPG.ccSysCodePage]
  8292                                  				  	; get sys code page id;smr;use ds
  8293 00000EDC E898F5                  	call	Get_User_Stack
  8294                                  ;ASSUME DS:NOTHING
  8295                                  	;;mov	[si+2],bx
  8296                                  	;MOV	[SI+user_env.user_BX],BX ; update returned bx
  8297                                  	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
  8298 00000EDF E8F4FD                  	call    set_user_bx	; MOV [SI+user_env.user_BX],BX 
  8299                                  	;mov	[si+6],dx
  8300 00000EE2 895406                  	MOV	[SI+user_env.user_DX],DX ; update returned dx
  8301                                  OK_RETURN:
  8302                                  	; 15/12/2022
  8303                                  	;transfer SYS_RET_OK
  8304 00000EE5 E988F7                  	jmp	SYS_RET_OK
  8305                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8306                                  	;jmp	short nono_jmp
  8307                                  
  8308                                  ;hkn; ASSUME DS:DOSGROUP
  8309                                  ;ASSUME	DS:DOSDATA
  8310                                  
  8311                                  setglpg:
  8312 00000EE8 3C02                    	CMP	AL,2
  8313 00000EEA 752F                    	JNZ	short nomem
  8314                                  	
  8315                                  	;;mov	dx,[si+63h] ; MSDOS 3.3
  8316                                  	;mov	dx,[si+68h] ; MSDOS 6.0
  8317 00000EEC 8B5468                  	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]	;smr;use ds
  8318                                  	
  8319                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  8320 00000EEF B80014                  	mov     ax,1400h
  8321 00000EF2 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  8322                                  			; Return: AL = 00h not installed, OK to install
  8323                                  			; 01h not installed, not OK
  8324                                  			; FFh installed
  8325 00000EF4 3CFF                    	CMP	AL,0FFH
  8326 00000EF6 7523                    	JNZ	short nomem		; not in memory
  8327                                  
  8328                                  	;CallInstall SetCodePage,NLSFUNC,1 ;set the code page
  8329 00000EF8 B80114                  	mov     ax,1401h
  8330 00000EFB CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - CHANGE CODE PAGE
  8331                                  			; DS:SI -> internal code page structure
  8332                                  			; BX = new code page, DX = country code???
  8333                                  			; Return: AL = status
  8334                                  			; 00h successful
  8335                                  			; else DOS error code
  8336                                  	;cmp	al,0
  8337 00000EFD 08C0                    	or	al,al			; success ?
  8338 00000EFF 74E4                    	JZ	short OK_RETURN		; yes
  8339                                  
  8340 00000F01 3C41                    	CMP	AL,65			; set device code page failed
  8341 00000F03 75C6                    	JNZ	short seterr
  8342                                  	;MOV	AX,65
  8343                                  	; 06/01/2024
  8344 00000F05 98                      	cbw
  8345 00000F06 A3[2403]                	MOV	[EXTERR],AX
  8346                                  	;mov	byte [EXTERR_ACTION],6
  8347                                  	;mov	byte [EXTERR_CLASS],5
  8348                                  	;mov	byte [EXTERR_LOCUS],4
  8349 00000F09 C606[2603]06            	MOV	byte [EXTERR_ACTION],errACT_Ignore
  8350 00000F0E C606[2703]05            	MOV	byte [EXTERR_CLASS],errCLASS_HrdFail
  8351 00000F13 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
  8352                                  	;transfer From_GetSet
  8353 00000F18 E967F7                  	jmp	From_GetSet
  8354                                  
  8355                                  	; 15/12/2022
  8356                                  ;seterr:
  8357                                  	;;;transfer SYS_RET_ERR
  8358                                  	;;jmp	SYS_RET_ERR
  8359                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8360                                  	;jmp	short NLSERROR
  8361                                  
  8362                                  nomem:
  8363                                  	;error	error_invalid_function	; function not defined
  8364                                  	;mov	al,1
  8365 00000F1B B001                    	mov	al,error_invalid_function
  8366 00000F1D EBAC                    	jmp	short seterr
  8367                                  
  8368                                  ;EndProc $GetSetCdPg
  8369                                  
  8370                                  ; 13/05/2019 - Retro DOS v4.0
  8371                                  ; DOSCODE:4C2Bh (MSDOS 6.21, MSDOS.SYS)
  8372                                  
  8373                                  ;BREAK <$Get_Drive_Freespace -- Return bytes of free disk space on a drive>
  8374                                  ;----------------------------------------------------------------------------
  8375                                  ;**	$Get_Drive_Freespace - Return amount of drive free space
  8376                                  ;
  8377                                  ;	$Get_Drive_Freespace returns the # of free allocation units on a
  8378                                  ;		drive.
  8379                                  ;
  8380                                  ;	This call returns the same info in the same registers (except for the
  8381                                  ;	FAT pointer) as the old FAT pointer calls
  8382                                  ;
  8383                                  ;	ENTRY	DL = Drive number
  8384                                  ;	EXIT	AX = Sectors per allocation unit
  8385                                  ;		   = -1 if bad drive specified
  8386                                  ;		On User Stack
  8387                                  ;		    BX = Number of free allocation units
  8388                                  ;		    DX = Total Number of allocation units on disk
  8389                                  ;		    CX = Sector size
  8390                                  
  8391                                  ;procedure   $GET_DRIVE_FREESPACE,NEAR
  8392                                  
  8393                                  	; 09/01/2024
  8394                                  	; 06/01/2024 - Retro DOS v5.0
  8395                                  	; (PCDOS 7.1 IBMDOS.COM - DOSCODE:4DC4h)
  8396                                  
  8397                                  _$GET_DRIVE_FREESPACE:
  8398                                  
  8399                                  ;hkn; SS is DOSDATA
  8400                                  	;context DS
  8401 00000F1F 16                      	push	ss
  8402 00000F20 1F                      	pop	ds
  8403                                  
  8404 00000F21 88D0                    	MOV	AL,DL
  8405                                  	;invoke	GetThisDrv		; Get drive
  8406 00000F23 E88A65                  	call	GETTHISDRV
  8407                                  SET_AX_RET:
  8408 00000F26 721C                    	JC	short BADFDRV
  8409                                  	;invoke	DISK_INFO
  8410 00000F28 E85D24                  	call	DISK_INFO
  8411                                  	; 09/01/2024
  8412                                  	;XCHG	DX,BX
  8413                                  	;;JC	short SET_AX_RET	; User FAILed to I 24
  8414                                  	; 06/01/2024
  8415 00000F2B 7217                    	jc	short BADFDRV
  8416                                  	; 09/01/2024 - Retro DOS v5.0 (PCDOS 7.1)
  8417                                  gdrvfspc_1:
  8418 00000F2D 30E4                    	XOR	AH,AH			; Chuck Fat ID byte
  8419                                  	;;;
  8420 00000F2F 57                      	push	di
  8421 00000F30 E80E09                  	call	TestNet
  8422 00000F33 5F                      	pop	di
  8423 00000F34 7203                    	jc	short gdrvfspc_2
  8424 00000F36 E85325                  	call    modify_cluster_count
  8425                                  			; if hw of total clusters (di) > 0
  8426                                  			; sectors per cluster and cluster counts
  8427                                  			; will be modified (shifted)
  8428                                  			; (but sectors per clust * clust count will be same)
  8429                                  			; /// disk size -calculation- limit = 2 GB ///
  8430                                  gdrvfspc_2:
  8431 00000F39 87D3                    	xchg	dx,bx		; bx = free clusters (after xchg)
  8432                                  	;;;
  8433                                  DoSt:
  8434 00000F3B E839F5                  	call	Get_User_Stack
  8435                                  ;ASSUME	DS:NOTHING
  8436                                  	;mov	[si+6],dx
  8437                                  	;;mov	[si+4],cx
  8438                                  	;;mov	[si+2],bx
  8439                                  	; 09/01/2024
  8440 00000F3E 895406                  	MOV	[SI+user_env.user_DX],DX ; total clusters
  8441                                  	;MOV	[SI+user_env.user_CX],CX
  8442                                  	;MOV	[SI+user_env.user_BX],BX
  8443                                  	;;MOV	[SI+user_env.user_AX],AX
  8444                                  	;mov	[si],ax
  8445                                  	;;return
  8446                                  	;retn
  8447                                  	; 09/01/2024
  8448 00000F41 E98DFD                  	jmp     gdrvfspc_ret	; ax = sectors per cluster (modified)
  8449                                  
  8450                                  BADFDRV:
  8451                                  	; MSDOS 3.3
  8452                                  	;;mov	al,0Fh
  8453                                  	;mov	al,error_invalid_drive	; Assume error
  8454                                  
  8455                                  	; 13/05/2019 - Retro DOS v4.0
  8456                                  
  8457                                  	; MSDOS 6.0 & MSDOS 3.3
  8458                                  	;invoke	FCB_RET_ERR
  8459 00000F44 E848F7                  	call	FCB_RET_ERR
  8460                                  	
  8461 00000F47 B8FFFF                  	MOV	AX,-1
  8462 00000F4A EBEF                    	JMP	short DoSt
  8463                                  
  8464                                  ;EndProc $GET_DRIVE_FREESPACE
  8465                                  
  8466                                  ;	BREAK <$Get_DMA, $Set_DMA -- Get/Set current DMA address>
  8467                                  ;----------------------------------------------------------------------------
  8468                                  ;**	$Get_DMA - Get Disk Transfer Address
  8469                                  ;
  8470                                  ;	ENTRY	none
  8471                                  ;	EXIT	ES:BX is current transfer address
  8472                                  ;	USES	all
  8473                                  
  8474                                  	; 09/01/2024
  8475                                  _$GET_DMA:
  8476 00000F4C 368B1E[2C03]            	MOV	BX,[SS:DMAADD]
  8477 00000F51 368B0E[2E03]            	MOV	CX,[SS:DMAADD+2]
  8478 00000F56 E81EF5                  	call	Get_User_Stack
  8479                                  	;mov	[si+2],bx
  8480                                  	;mov	[si+10h],cx
  8481                                  	; 09/01/2024
  8482                                  	;MOV	[SI+user_env.user_BX],BX
  8483 00000F59 894C10                  	MOV	[SI+user_env.user_ES],CX
  8484                                  	;retn
  8485                                  	; 09/01/2024
  8486 00000F5C E977FD                  	jmp	set_user_bx
  8487                                  
  8488                                  ;**	$Set_DMA - Set Disk Transfer Address
  8489                                  ;----------------------------------------------------------------------------
  8490                                  ;	ENTRY	DS:DX is current transfer address
  8491                                  ;	EXIT	none
  8492                                  ;	USES	all
  8493                                  
  8494                                  _$SET_DMA:
  8495 00000F5F 368916[2C03]            	MOV	[SS:DMAADD],DX
  8496 00000F64 368C1E[2E03]            	MOV	[SS:DMAADD+2],DS
  8497 00000F69 C3                      	retn
  8498                                  
  8499                                  ;	BREAK <$Get_Default_Drive, $Set_Default_Drive -- Set/Get default drive>
  8500                                  ;------------------------------------------------------------------------------
  8501                                  
  8502                                  ;**	$Get_Default_Drive - Get Current Default Drive
  8503                                  ;-----------------------------------------------------
  8504                                  ;	ENTRY	none
  8505                                  ;	EXIT	(AL) = drive number
  8506                                  ;	USES	all
  8507                                  
  8508                                  _$GET_DEFAULT_DRIVE:
  8509 00000F6A 36A0[3603]              	MOV	AL,[SS:CURDRV]
  8510 00000F6E C3                      	retn
  8511                                  
  8512                                  ;**	$Set_Default_Drive - Specify new Default Drive
  8513                                  ;-----------------------------------------------------
  8514                                  ;	ENTRY	(DL) = Drive number for new default drive
  8515                                  ;	EXIT	(AL) = Number of drives, NO ERROR RETURN IF DRIVE NUMBER BAD
  8516                                  
  8517                                  _$SET_DEFAULT_DRIVE:
  8518 00000F6F 88D0                    	MOV	AL,DL
  8519 00000F71 FEC0                    	INC	AL			; A=1, B=2...
  8520 00000F73 E81E65                  	call	GetVisDrv		; see if visible drive
  8521 00000F76 7204                    	JC	short SETRET		; errors do not set
  8522 00000F78 36A2[3603]              	MOV	[SS:CURDRV],AL		; no, set
  8523                                  
  8524                                  SETRET:
  8525 00000F7C 36A0[4700]              	MOV	AL,[SS:CDSCOUNT]	; let user see what the count really is
  8526 00000F80 C3                      	retn
  8527                                  
  8528                                  ;BREAK <$Get/Set_Interrupt_Vector - Get/Set interrupt vectors>
  8529                                  ;----------------------------------------------------------------------------
  8530                                  
  8531                                  ;**	$Get_Interrupt_Vector - Get Interrupt Vector
  8532                                  ;---------------------------------------------------
  8533                                  ;	$Get_Interrupt_Vector is the official way for user pgms to get the
  8534                                  ;	contents of an interrupt vector.
  8535                                  ;
  8536                                  ;	ENTRY	(AL) = interrupt number
  8537                                  ;	EXIT	(ES:BX) = current interrupt vector
  8538                                  
  8539                                  _$GET_INTERRUPT_VECTOR:
  8540 00000F81 E82E00                  	CALL	RECSET
  8541 00000F84 26C41F                  	LES	BX,[ES:BX]
  8542 00000F87 E8EDF4                  	call	Get_User_Stack
  8543                                  set_user_es_bx:
  8544                                  	; 09/01/2024 (PCDOS 7.1 IBMDOS.COM)
  8545                                  	;;mov	[si+2],bx
  8546                                  	;mov	[si+10h],es
  8547                                  	;MOV	[SI+user_env.user_BX],BX
  8548 00000F8A 8C4410                  	MOV	[SI+user_env.user_ES],ES
  8549                                  	;retn
  8550 00000F8D E946FD                  	jmp	set_user_bx
  8551                                  
  8552                                  ;**	$Set_Interrupt_Vector - Set Interrupt Vector
  8553                                  ;---------------------------------------------------
  8554                                  ;	$Set_Interrupt_Vector is the official way for user pgms to set the
  8555                                  ;	contents of an interrupt vector.
  8556                                  ;
  8557                                  ;	M004, M068: Also set A20OFF_COUNT to 1 if EXECA20OFF bit has been set 
  8558                                  ;	and if A20OFF_COUNT is non-zero. See under tag M003 in inc\dossym.inc 
  8559                                  ;	for explanation.
  8560                                  ;
  8561                                  ;	ENTRY	(AL) = interrupt number
  8562                                  ;		(ds:dx) = desired new vector value
  8563                                  ;	EXIT	none
  8564                                  ;	USES	all
  8565                                  
  8566                                  ; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8567                                  ; 13/05/2019 - Retro DOS v4.0
  8568                                  
  8569                                  _$SET_INTERRUPT_VECTOR:
  8570 00000F90 E81F00                  	CALL	RECSET
  8571 00000F93 FA                      	CLI				; Watch out!!!!! Folks sometimes use
  8572 00000F94 268917                  	MOV	[ES:BX],DX		;   this for hardware ints (like timer).
  8573 00000F97 268C5F02                	MOV	[ES:BX+2],DS
  8574 00000F9B FB                      	STI
  8575                                  					; M004, M068 - Start
  8576                                  	; MSDOS 6.0
  8577 00000F9C 36F606[8600]04          	test	byte [ss:DOS_FLAG],EXECA20OFF ; 4
  8578                                  					; Q: was the previous call an int 21h
  8579                                  					;    exec call
  8580                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8581                                  	;jnz	short siv_1		; Y: go set count
  8582                                  	;retn				; N: return
  8583                                  	; 15/12/2022
  8584 00000FA2 740D                    	jz	short siv_2
  8585                                  siv_1:	
  8586 00000FA4 36803E[8500]00          	cmp	byte [ss:A20OFF_COUNT],0 ; Q: is count 0
  8587 00000FAA 7505                    	jnz	short siv_2		 ; N: done 
  8588                                  	; 20/09/2023
  8589 00000FAC 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]
  8590                                  	;mov	byte [ss:A20OFF_COUNT],1 ; Y: set it to 1 to indicate to dos
  8591                                  					 ; dispatcher to turn A20 Off before
  8592                                  					 ; returning to user.
  8593                                  siv_2:
  8594                                  	; 07/12/2022
  8595 00000FB1 C3                      	retn				; M004, M068 - End
  8596                                  	
  8597                                  RECSET:
  8598 00000FB2 31DB                    	XOR	BX,BX
  8599 00000FB4 8EC3                    	MOV	ES,BX
  8600 00000FB6 88C3                    	MOV	BL,AL
  8601 00000FB8 D1E3                    	SHL	BX,1
  8602 00000FBA D1E3                    	SHL	BX,1
  8603 00000FBC C3                      	retn
  8604                                  
  8605                                  ;	BREAK <$Char_Oper - hack on paths, switches so that xenix can look like PCDOS>
  8606                                  ;-------------------------------------------------------------------------------------
  8607                                  
  8608                                  ;**	$Char_Oper - Manipulate Switch Character
  8609                                  ;
  8610                                  ;	This function was put in to facilitate XENIX path/switch compatibility
  8611                                  ;
  8612                                  ;	ENTRY	AL = function:
  8613                                  ;		    0 - read switch char
  8614                                  ;		    1 - set switch char (char in DL)
  8615                                  ;		    2 - read device availability
  8616                                  ;			Always returns available
  8617                                  ;		    3 - set device availability
  8618                                  ;			No longer supported (NOP)
  8619                                  ;	EXIT	(al) = 0xff iff error
  8620                                  ;		(al) != 0xff if ok
  8621                                  ;		  (dl) = character/flag, if "read switch char" subfunction
  8622                                  ;	USES	AL, DL
  8623                                  ;
  8624                                  ;	NOTE	This already obsolete function has been deactivated in DOS 5.0
  8625                                  ;		The character / is always returned for subfunction 0,
  8626                                  ;		subfunction 2 always returns -1, all other subfunctions are ignored.
  8627                                  
  8628                                  ; 13/05/2019 - Retro DOS v4.0
  8629                                  ; DOSCODE:4CC9h (MSDOS 6.21, MSDOS.SYS)
  8630                                  
  8631                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8632                                  ; DOSCODE:4CBCh (MSDOS 5.0, MSDOS.SYS)
  8633                                  
  8634                                  _$CHAR_OPER:
  8635                                  	; MSDOS 6.0
  8636 00000FBD 08C0                    	or	al,al				; get switch?
  8637 00000FBF B22F                    	mov	dl,'/'				; assume yes
  8638 00000FC1 7407                    	jz	short chop_1			; jump if yes
  8639 00000FC3 3C02                    	cmp	al,2				; check device availability?
  8640 00000FC5 B2FF                    	mov	dl,-1				; assume yes
  8641 00000FC7 7401                    	jz	short chop_1			; jump if yes
  8642 00000FC9 C3                      	retn					; otherwise just quit
  8643                                  
  8644                                  ; subfunctions requiring return of value to user come here. DL holds
  8645                                  ; value to return
  8646                                  
  8647                                  chop_1:
  8648 00000FCA E8AAF4                  	call	Get_User_Stack
  8649 00000FCD 895406                  	mov	[SI+user_env.user_DX],dx	; store value for user
  8650 00000FD0 C3                      	retn
  8651                                  
  8652                                  	; MSDOS 3.3
  8653                                  	; Offset 1B87h in IBMDOS.COM (MSDOS 3.3), 1987
  8654                                  	;push	ss
  8655                                  	;pop	ds
  8656                                  	;cmp	al,1
  8657                                  	;jb	short chop_1
  8658                                  	;jz	short chop_2
  8659                                  	;cmp	al,3
  8660                                  	;jb	short chop_3
  8661                                  	;jz	short chop_5
  8662                                  	;mov	al,0FFh
  8663                                  	;retn
  8664                                  ;chop_1:
  8665                                  	;mov	dl,[chSwitch]
  8666                                  	;jmp	short chop_4
  8667                                  ;chop_2:
  8668                                  	;mov	[chSwitch],dl
  8669                                  	;retn
  8670                                  ;chop_3:
  8671                                  	;mov	dl, FFh
  8672                                  ;chop_4:
  8673                                  	;call	Get_User_Stack
  8674                                  	;mov	[si+6],dx
  8675                                  ;chop_5:
  8676                                  	;retn
  8677                                  
  8678                                  ;**	$GetExtendedError - Return Extended error code
  8679                                  ;----------------------------------------------------------------------------
  8680                                  ;	This function reads up the extended error info from the static
  8681                                  ;	variables where it was stored.
  8682                                  ;
  8683                                  ;	ENTRY	none
  8684                                  ;	EXIT	AX = Extended error code (0 means no extended error)
  8685                                  ;		BL = recommended action
  8686                                  ;		BH = class of error
  8687                                  ;		CH = locus of error
  8688                                  ;		ES:DI = may be pointer
  8689                                  ;	USES	ALL
  8690                                  
  8691                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8692                                  
  8693                                  _$GetExtendedError:
  8694 00000FD1 16                      	push	ss
  8695 00000FD2 1F                      	pop	ds
  8696 00000FD3 A1[2403]                	MOV	AX,[EXTERR]
  8697 00000FD6 C43E[2803]              	LES	DI,[EXTERRPT]
  8698 00000FDA 8B1E[2603]              	MOV	BX,[EXTERR_ACTION]	; BL = Action, BH = Class
  8699 00000FDE 8A2E[2303]              	MOV	CH,[EXTERR_LOCUS]
  8700 00000FE2 E892F4                  	call	Get_User_Stack
  8701                                  	;mov	[si+0Ah],di
  8702 00000FE5 897C0A                  	MOV	[SI+user_env.user_DI],DI
  8703                                  
  8704                                  	; 09/01/2024 (PCDOS 7.1 IBMDOS.COM)
  8705                                  	;;mov	[si+10h],es
  8706                                  	;MOV	[SI+user_env.user_ES],ES
  8707                                  	;;mov	[si+2],bx
  8708                                  	;MOV	[SI+user_env.user_BX],BX
  8709 00000FE8 E89FFF                  	call	set_user_es_bx
  8710                                  
  8711                                  	;mov	[si+4],cx
  8712 00000FEB 894C04                  	MOV	[SI+user_env.user_CX],CX
  8713                                  jmp_SYS_RET_OK:
  8714                                  	; 15/12/2022
  8715                                  	;jmp	SYS_RET_OK
  8716                                  	; 25/06/2019
  8717 00000FEE E982F6                  	jmp	SYS_RET_OK_clc ; 15/12/2022
  8718                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8719                                  ;jmp_SYS_RET_OK:
  8720                                  	;jmp	SYS_RET_OK
  8721                                  
  8722                                  ; --------------------------------------------------------------------------
  8723                                  ; 09/01/2024
  8724                                  %if 0
  8725                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8726                                  	; DOSCODE:4CF3h
  8727                                  ;patch_or_unknown:
  8728                                  ;get_code_page:
  8729                                  	push    si
  8730                                  	mov     si, COUNTRY_CDPG
  8731                                  	;mov	ax, [si+DOS_CCDPG.ccDosCodePage]
  8732                                  	mov     ax, [ss:si+6Ah]
  8733                                  	pop     si
  8734                                  	retn
  8735                                  %endif
  8736                                  ; --------------------------------------------------------------------------
  8737                                  
  8738                                  ; 29/04/2019 - Retro DOS v4.0
  8739                                  
  8740                                  ;BREAK	<ECS_call - Extended Code System support function>
  8741                                  ;---------------------------------------------------------------------------
  8742                                  ; Inputs:
  8743                                  ;	AL = 0	get lead byte table
  8744                                  ;		on return DS:SI has the table location
  8745                                  ;
  8746                                  ;	AL = 1	set / reset interim console flag
  8747                                  ;		DL = flag (00H or 01H)
  8748                                  ;		no return
  8749                                  ;
  8750                                  ;	AL = 2	get interim console flag
  8751                                  ;		on return DL = current flag value
  8752                                  ;
  8753                                  ;	AL = OTHER then error, and returns with:
  8754                                  ;		AX = error_invalid_function
  8755                                  ;
  8756                                  ;  NOTE: THIS CALL DOES GUARANTEE THAT REGISTER OTHER THAN
  8757                                  ;	 SS:SP WILL BE PRESERVED!
  8758                                  ;---------------------------------------------------------------------------
  8759                                  
  8760                                  _$ECS_Call:
  8761 00000FF1 08C0                    	or	al,al			; AL = 0 (get table)?
  8762                                  	;jnz	short _okok
  8763                                  	; 15/12/2022
  8764 00000FF3 7403                    	jz	short get_lbt
  8765                                  ;_okok:
  8766 00000FF5 E978F6                  	jmp	SYS_RET_OK
  8767                                  get_lbt:
  8768 00000FF8 E87CF4                  	call	Get_User_Stack		; *
  8769                                  
  8770                                  ;hkn; dbcs_table moved low to dosdata
  8771                                  	;mov	word [si+8],DBCS_TAB+2
  8772 00000FFB C74408[390D]            	mov	word [SI+user_env.user_SI],DBCS_TAB+2
  8773                                  
  8774 00001000 06                      	push	es
  8775                                  	;getdseg <es>			; es = DOSDATA
  8776 00001001 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  8777                                  	;mov	[si+14],es
  8778 00001006 8C440E                  	mov	[SI+user_env.user_DS],es
  8779 00001009 07                      	pop	es
  8780                                  
  8781                                  	; 15/12/2022
  8782 0000100A EBE2                    	jmp	short jmp_SYS_RET_OK ; jmp SYS_RET_OK_clc ; *
  8783                                  ;_okok:
  8784                                  	; 15/12/2022	
  8785                                  	;;transfer SYS_RET_OK
  8786                                  	;jmp	short jmp_SYS_RET_OK
  8787                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8788                                  	;;jmp	SYS_RET_OK
  8789                                  	;jmp	short jmp_SYS_RET_OK
  8790                                  
  8791                                  ; --------------------------------------------------------------------------
  8792                                  ; 10/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM - DOSCODE:4EB4h)
  8793                                  ; --------------------------------------------------------------------------
  8794                                  
  8795                                  	; INT 21h, AH=71h - LONG FILENAME FUNCTIONS
  8796                                  	; INT 21h, AH=72h - LFN FindClose
  8797                                  _$LONGNAME:
  8798 0000100C 30C0                    	xor	al,al			; longname functions are not supported
  8799                                  lfn_error:
  8800 0000100E E866F4                  	call	Get_User_Stack
  8801 00001011 834C1601                	or	word [si+16h],1		; [SI+user_env.user_F],f_Carry
  8802 00001015 F9                      	stc
  8803 00001016 8904                    	mov	[si],ax			; [SI+user_env.user_ax]
  8804 00001018 C3                      	retn
  8805                                  ; ---------------------------------------------------------------------------
  8806                                  
  8807                                  	; FAT32 - EXTENDED FUNCTIONS 
  8808                                  	; INT 21h, AH=73h
  8809                                  _$FAT32EXT:
  8810 00001019 3C05                    	cmp	al,5			; INT 21h AX = 7305h
  8811 0000101B 7609                    	jbe	short valid_fat32_ext_function
  8812 0000101D B001                    	mov	al,1			; error_invalid_function
  8813                                  fat32_ext_func_err:
  8814 0000101F E958F6                  	jmp	SYS_RET_ERR
  8815                                  
  8816                                  function_5_invalid_cx:
  8817 00001022 B057                    	mov	al,57h			; error_invalid_parameter
  8818                                  fat32_ext_func_err_j:
  8819 00001024 EBF9                    	jmp	short fat32_ext_func_err
  8820                                  
  8821                                  valid_fat32_ext_function:
  8822 00001026 7524                    	jnz	short not_function_5
  8823 00001028 83F9FF                  	cmp	cx,0FFFFh 	; Function 5 - FAT32 - EXTENDED ABSOLUTE DISK READ/WRITE
  8824 0000102B 75F5                    	jne	short function_5_invalid_cx
  8825 0000102D F7C6FE9F                	test	si,9FFEh		; read/write mode flags
  8826 00001031 75EF                    	jnz	short function_5_invalid_cx
  8827 00001033 88D0                    	mov	al,dl			; drive number, 1 = A
  8828 00001035 FEC8                    	dec	al
  8829 00001037 B401                    	mov	ah,1
  8830 00001039 F7C60100                	test	si,1
  8831 0000103D 7405                    	jz	short function_5_read
  8832 0000103F E89FF5                  	call	FAT32_ABSDWRT		; INT 21h AX = 7305h (SI bit 0 = 1)
  8833 00001042 EB03                    	jmp	short fat32_absdrw_ret
  8834                                  
  8835                                  function_5_read:
  8836 00001044 E8EAF4                  	call	FAT32_ABSDRD		; INT 21h AX = 7305h (SI bit 0 = 0)
  8837                                  fat32_absdrw_ret:
  8838 00001047 72C5                    	jc	short lfn_error
  8839 00001049 E924F6                  	jmp	SYS_RET_OK
  8840                                  
  8841                                  not_function_5:
  8842 0000104C 3C03                    	cmp	al,3		; Function 3 - FAT32 - GET EXTENDED FREE SPACE ON DRIVE
  8843 0000104E 7475                    	je	short function_73_3
  8844 00001050 3C02                    	cmp	al,2
  8845 00001052 7203                    	jb	short chk_drive_lock_flush
  8846 00001054 E90503                  	jmp	_$GET_DPB	; Function 2 - FAT32 - "Get_ExtDPB" - GET EXTENDED DPB
  8847                                  			  	; Function 4 - FAT32 - Set DPB TO USE FOR FORMATTING
  8848                                  
  8849                                  chk_drive_lock_flush:
  8850 00001057 80FA1A                  	cmp	dl,26			; MSDOS 7 - DRIVE LOCKING AND FLUSHING
  8851 0000105A 7604                    	jbe	short drv_lock_flush_1
  8852 0000105C B00F                    	mov	al,0Fh			; invalid drive number
  8853                                  drv_lock_flush_err:
  8854                                  	;jmp	short fat32_ext_func_err_j ; ax = error code
  8855                                  	; 10/01/2024
  8856 0000105E EBBF                    	jmp	short fat32_ext_func_err
  8857                                  
  8858                                  drv_lock_flush_1:
  8859 00001060 FECA                    	dec	dl
  8860 00001062 7905                    	jns	short drv_lock_flush_2
  8861 00001064 368A16[3603]            	mov	dl,[ss:CURDRV]		; 0 = default/current drive)
  8862                                  drv_lock_flush_2:
  8863 00001069 B600                    	mov	dh,0
  8864 0000106B 89D3                    	mov	bx,dx
  8865 0000106D 80F901                  	cmp	cl,1			; which flag to get or set
  8866 00001070 7604                    	jbe	short drv_lock_flush_3
  8867 00001072 B001                    	mov	al,1			; error_invalid_function
  8868                                  	;jmp	short drv_lock_flush_err
  8869                                  	; 10/01/2024
  8870 00001074 EBA9                    	jmp	short fat32_ext_func_err
  8871                                  
  8872                                  drv_lock_flush_3:
  8873 00001076 368AA7[2F14]            	mov	ah,[ss:drive_flags+bx]
  8874 0000107B 08C9                    	or	cl,cl
  8875 0000107D 7422                    	jz	short get_set_indctd_flag ; use bit 1 and bit 2
  8876 0000107F 08C0                    	or	al,al			; get drive's dirty-buffers flag
  8877 00001081 7419                    	jz	short get_dirty_buf_flag ; use bit 3
  8878 00001083 80E4F7                  	and	ah,0F7h			; clear bit 3
  8879 00001086 80E508                  	and	ch,8			; izolate bit 3 of the new flag value
  8880 00001089 08EC                    	or	ah,ch			; set AH bit 3 according to CH bit 3
  8881 0000108B 3688A7[2F14]            	mov	[ss:drive_flags+bx],ah	; set or reset dirty buffer flag
  8882 00001090 F6C408                  	test	ah,8
  8883 00001093 7505                    	jnz	short set_dirty_flag_ok	; bit 3 is set/1
  8884 00001095 B0FF                    	mov	al,0FFh
  8885 00001097 E8C053                  	call	FLUSHBUF
  8886                                  set_dirty_flag_ok:
  8887 0000109A EB26                    	jmp	short jmp_to_SYS_RET_OK
  8888                                  
  8889                                  get_dirty_buf_flag:
  8890 0000109C 80E408                  	and	ah,8			; izolate dirty buffers flag
  8891 0000109F EB19                    	jmp	short mov_flag_cl_to_al	; AH = new flag and 08h (bit 3 used)
  8892                                  
  8893                                  get_set_indctd_flag:
  8894 000010A1 08C0                    	or	al,al
  8895 000010A3 7412                    	jz	short get_indicated_flag
  8896 000010A5 80E4F9                  	and	ah,0F9h			; clear bit 1 and bit 2
  8897 000010A8 F6C502                  	test	ch,2			; new value for indicated flag
  8898 000010AB 7403                    	jz	short reset_indctd_flags ; bit 1 is zero
  8899 000010AD 80CC06                  	or	ah,6			; set bit 1 and bit 2
  8900                                  reset_indctd_flags:
  8901 000010B0 3688A7[2F14]            	mov	[ss:drive_flags+bx],ah
  8902 000010B5 EB0B                    	jmp	short jmp_to_SYS_RET_OK
  8903                                  
  8904                                  get_indicated_flag:
  8905 000010B7 80E406                  	and	ah,6			; AH = new flag and 06h (bits 1 and 2 used)
  8906                                  mov_flag_cl_to_al:			; CODE XREF: DOSCODE:4F47^j
  8907 000010BA 88C8                    	mov	al,cl			; value of CL on entry
  8908                                  ret_ax_to_user_cx:  ; ax -> user's cx
  8909 000010BC E8B8F3                  	call	Get_User_Stack
  8910 000010BF 894404                  	mov	[si+4],ax		; [SI+user_env.user_cx] ; requested flag
  8911                                  jmp_to_SYS_RET_OK:
  8912 000010C2 E9ABF5                  	jmp	SYS_RET_OK
  8913                                  
  8914                                  function_73_3:
  8915 000010C5 89D6                    	mov	si,dx		; FAT32 - GET EXTENDED FREE SPACE ON DRIVE
  8916                                  				; AX = 7303h
  8917                                  				; DS:DX -> ASCIZ string for drive ("C:\" or "\\SERVER\Share")
  8918                                  				; ES:DI -> buffer for extended free space structure
  8919                                  				; CX = length of buffer for extended free space
  8920 000010C7 E8EC67                  	call	DriveFromText
  8921 000010CA 92                      	xchg	ax,dx
  8922 000010CB AD                      	lodsw
  8923 000010CC FECA                    	dec	dl
  8924 000010CE 80FA1A                  	cmp	dl,26
  8925 000010D1 7323                    	jnb	short func_73_3_err2
  8926 000010D3 08E4                    	or	ah,ah
  8927 000010D5 751F                    	jnz	short func_73_3_err2
  8928 000010D7 E8A049                  	call	PATHCHRCMP
  8929 000010DA 751A                    	jnz	short func_73_3_err2
  8930 000010DC FEC2                    	inc	dl
  8931 000010DE 83F92C                  	cmp	cx,44			; buffer (Structure) size must be 44
  8932 000010E1 721C                    	jb	short func_73_3_err4
  8933 000010E3 26837D0200              	cmp	word [es:di+2],0	; buffer structure version (must be 0)
  8934 000010E8 7511                    	jnz	short func_73_3_err3
  8935 000010EA 16                      	push	ss
  8936 000010EB 1F                      	pop	ds
  8937 000010EC 88D0                    	mov	al,dl
  8938 000010EE E8BF63                  	call	GETTHISDRV
  8939 000010F1 7310                    	jnc	short fill_efs_struc_b
  8940                                  func_73_3_err1:
  8941 000010F3 E899F5                  	call	FCB_RET_ERR
  8942                                  func_73_3_err2:
  8943 000010F6 B00F                    	mov	al,0Fh			; error_invalid_drive
  8944                                  jmp_to_SYS_RET_ERR:
  8945 000010F8 E97FF5                  	jmp	SYS_RET_ERR
  8946                                  
  8947                                  func_73_3_err3:
  8948 000010FB B057                    	mov	al,57h			; error_invalid_parameter
  8949                                  jmp_to_jmp_SYS_RET_ERR:
  8950 000010FD EBF9                    	jmp	short jmp_to_SYS_RET_ERR
  8951                                  
  8952                                  func_73_3_err4:
  8953 000010FF B018                    	mov	al,18h	   		; error_bad_length
  8954 00001101 EBFA                    	jmp	short jmp_to_jmp_SYS_RET_ERR
  8955                                  
  8956                                  fill_efs_struc_b:
  8957 00001103 E88222                  	call	DISK_INFO
  8958 00001106 72EB                    	jc	short func_73_3_err1
  8959 00001108 30E4                    	xor	ah,ah
  8960 0000110A 56                      	push	si			; si:dx = free cluster count
  8961 0000110B 57                      	push	di			; di:bx = number of clusters
  8962 0000110C E868F3                  	call	Get_User_Stack
  8963 0000110F 8E4410                  	mov	es,[si+10h]		; user's buffer segment (in ES)
  8964 00001112 8B7C0A                  	mov	di,[si+0Ah]		; user's buffer offset/address (in DI)
  8965                                  	; 10/01/2024
  8966 00001115 06                      	push	es
  8967 00001116 1F                      	pop	ds ; (*)
  8968                                  	;
  8969                                  	;mov	[es:di+10h],bx		; total number of clusters on the drive
  8970                                  	;mov	[es:di+20h],bx		; total allocation units, without adjustment for compression
  8971 00001117 895D10                  	mov	[di+10h],bx
  8972 0000111A 895D20                  	mov	[di+20h],bx
  8973 0000111D 5B                      	pop	bx
  8974                                  	;mov	[es:di+12h],bx		; total number of clusters on the drive, hw
  8975                                  	;mov	[es:di+22h],bx		; total allocation units, hw
  8976                                  	;mov	[es:di+0Ch],dx		; number of available clusters
  8977                                  	;mov	[es:di+1Ch],dx		; number of available allocation units, without adjustment
  8978 0000111E 895D12                  	mov	[di+12h],bx
  8979 00001121 895D22                  	mov	[di+22h],bx
  8980 00001124 89550C                  	mov	[di+0Ch],dx
  8981 00001127 89551C                  	mov	[di+1Ch],dx
  8982 0000112A 5A                      	pop	dx
  8983                                  	;mov	[es:di+0Eh],dx		; number of available clusters, hw
  8984                                  	;mov	[es:di+1Eh],dx		; number of available allocation units, hw
  8985                                  	;mov	[es:di+8],cx		; bytes per sector
  8986                                  	;mov	[es:di+4],ax		; sectors per cluster (with adjustment for compression)
  8987 0000112B 89550E                  	mov	[di+0Eh],dx
  8988 0000112E 89551E                  	mov	[di+1Eh],dx
  8989 00001131 894D08                  	mov	[di+8],cx
  8990 00001134 894504                  	mov	[di+4],ax	
  8991 00001137 89C1                    	mov	cx,ax
  8992 00001139 F7E3                    	mul	bx			; 32 bit multiplication
  8993 0000113B 720B                    	jc	short dsk_cap_calc_overf ; disk capacity calculation overflow error
  8994 0000113D 89C3                    	mov	bx,ax
  8995                                  	;mov	ax,[es:di+20h]		; total allocation units, lw
  8996 0000113F 8B4520                  	mov	ax,[di+20h]
  8997 00001142 F7E1                    	mul	cx
  8998 00001144 01DA                    	add	dx,bx
  8999 00001146 7305                    	jnb	short dsk_cap_calc_ok
  9000                                  dsk_cap_calc_overf:
  9001 00001148 B8FFFF                  	mov	ax,0FFFFh		; set to 0FFFFFFFFh
  9002 0000114B 89C2                    	mov	dx,ax
  9003                                  dsk_cap_calc_ok:
  9004                                  	; 10/01/2024
  9005                                  	; ds = es (*)
  9006                                  	;mov	[es:di+1Ah],dx
  9007                                  	;mov	[es:di+18h],ax		; total number of physical sectors on the drive,
  9008                                  					; without adjustment for compression
  9009 0000114D 89551A                  	mov	[di+1Ah],dx
  9010 00001150 894518                  	mov	[di+18h],ax
  9011 00001153 89C8                    	mov	ax,cx			; 32 bit multiplication
  9012                                  	;mul	word [es:di+0Eh]	; number of available clusters, hw
  9013 00001155 F7650E                  	mul	word [di+0Eh]
  9014 00001158 720B                    	jc	short dsk_free_calc_overf
  9015 0000115A 89C3                    	mov	bx,ax
  9016                                  	;mov	ax,[es:di+0Ch]		; number of available clusters, lw
  9017 0000115C 8B450C                  	mov	ax,[di+0Ch]
  9018 0000115F F7E1                    	mul	cx
  9019 00001161 01DA                    	add	dx,bx
  9020 00001163 7305                    	jnc	short dsk_free_calc_ok
  9021                                  dsk_free_calc_overf:
  9022 00001165 B8FFFF                  	mov	ax,0FFFFh
  9023 00001168 89C2                    	mov	dx,ax
  9024                                  dsk_free_calc_ok:
  9025                                  	; 10/01/2024
  9026                                  	;mov	[es:di+16h],dx		; hw
  9027                                  	;mov	[es:di+14h],ax		; number of physical sectors available on the drive,
  9028                                  					; without adjustment for compression
  9029 0000116A 895516                  	mov	[di+16h],dx
  9030 0000116D 894514                  	mov	[di+14h],ax
  9031 00001170 31C0                    	xor	ax,ax	; 0
  9032                                  	;mov	[es:di+0Ah],ax		; number of bytes per sector, high word = 0
  9033                                  	;mov	[es:di+6],ax		; number of sectors per cluster, high word = 0
  9034 00001172 89450A                  	mov	[di+0Ah],ax
  9035 00001175 894506                  	mov	[di+6],ax
  9036                                  	
  9037                                  	;mov	[es:di+24h],ax		; reserved, 8 bytes zero
  9038                                  	;mov	[es:di+26h],ax
  9039                                  	;mov	[es:di+28h],ax
  9040                                  	;mov	[es:di+2Ah],ax
  9041 00001178 83C724                  	add	di,24h ; 36 ; 10/01/2024
  9042 0000117B AB                      	stosw
  9043 0000117C AB                      	stosw
  9044 0000117D AB                      	stosw
  9045 0000117E AB                      	stosw
  9046 0000117F B82C00                  	mov	ax,44
  9047 00001182 29C7                    	sub	di,ax ; 10/01/2024 
  9048                                  	;mov	[es:di],ax		; size of returned structure = 44
  9049                                  	; 10/01/2024
  9050                                  	;mov	[di],ax
  9051 00001184 AB                      	stosw
  9052 00001185 E9E8F4                  	jmp	SYS_RET_OK
  9053                                  
  9054                                  ; ---------------------------------------------------------------------------
  9055                                  
  9056                                  ; 12/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM/MSDOS.SYS)
  9057                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:504Ah
  9058                                  
  9059                                  Set_DPBforFormat:	; INT 21h, AX = 7304h (continues from _$GET_DPB)
  9060                                  	; 12/01/2024			; (Ref: Ralf Brown's Interrupt List)
  9061 00001188 B81800                  	mov	ax,18h
  9062 0000118B 394404                  	cmp	[si+4],ax	
  9063                                  	;cmp	word ptr [si+4],24	; [SI+user_env.user_CX]
  9064                                  					; size of buffer (must be at least 18h)
  9065                                  	;jnb	short setdpbf_2
  9066                                  	;mov	al,18h			; error_bad_length
  9067                                  ;setdpbf_1:
  9068                                  	;jmp	SYS_RET_ERR
  9069 0000118E 7223                    	jb	short setdpbf_1 ; al = 18h
  9070                                  setdpbf_2:
  9071 00001190 06                      	push	es			; ES:BP = Drive parameter block
  9072 00001191 55                      	push	bp
  9073 00001192 8E4410                  	mov	es,[si+10h]		; [SI+user_env.user_ES]
  9074 00001195 8B7C0A                  	mov	di,[si+0Ah]		; [SI+user_env.user_DI]
  9075 00001198 5E                      	pop	si
  9076 00001199 1F                      	pop	ds
  9077                                  
  9078 0000119A 268B4504                	mov	ax,[es:di+4]		; (call) function number
  9079 0000119E 26837D0200              	cmp	word [es:di+2],0	; structure version (must be 0)
  9080 000011A3 750C                    	jnz	short setdpbf_3
  9081 000011A5 26837D0600              	cmp	word [es:di+6],0	; (must be 0)
  9082 000011AA 7505                    	jnz	short setdpbf_3
  9083 000011AC 83F804                  	cmp	ax,4			; (max) 5 functions (0 to 4)
  9084 000011AF 7605                    	jbe	short setdpbf_4
  9085                                  setdpbf_3:
  9086 000011B1 B057                    	mov	al,57h			; error_invalid_parameter
  9087                                  	;jmp	short setdpbf_1
  9088                                  setdpbf_1:
  9089 000011B3 E9C4F4                  	jmp	SYS_RET_ERR
  9090                                  
  9091                                  setdpbf_4:
  9092 000011B6 26C7051800              	mov	word [es:di],18h	; (call) size
  9093 000011BB 08C0                    	or	al,al
  9094 000011BD 7403                    	jz	short setdpbf_5		; invalidate DPB counts
  9095 000011BF E98200                  	jmp	setdpbf_18
  9096                                  
  9097                                  setdpbf_5:
  9098 000011C2 31D2                    	xor	dx,dx	; 0
  9099 000011C4 8B5C0D                  	mov	bx,[si+0Dh]		; DPB.MAX_CLUSTER
  9100 000011C7 39540F                  	cmp	[si+0Fh],dx ; 0
  9101                                  	;cmp	word [si+0Fh],0		; DPB.FAT_SIZE
  9102 000011CA 7506                    	jnz	short setdpbf_6		; not FAT32
  9103 000011CC 8B542F                  	mov	dx,[si+2Fh]
  9104 000011CF 8B5C2D                  	mov	bx,[si+2Dh]		; DPB.LAST_CLUSTER
  9105                                  setdpbf_6:
  9106 000011D2 268B450A                	mov	ax,[es:di+0Ah]
  9107 000011D6 268B4D08                	mov	cx,[es:di+8]		; new DPB free count
  9108                                  		  		; (00000000h=no change, FFFFFFFFh=unknown)
  9109 000011DA 09C0                    	or	ax,ax
  9110 000011DC 7502                    	jnz	short setdpbf_7
  9111 000011DE E322                    	jcxz	setdpbf_11
  9112                                  setdpbf_7:
  9113 000011E0 83F8FF                  	cmp	ax,0FFFFh
  9114 000011E3 7505                    	jne	short setdpbf_8
  9115 000011E5 83F9FF                  	cmp	cx,0FFFFh
  9116 000011E8 7408                    	je	short setdpbf_10	; (set as UNKNOWN/INITIAL)
  9117                                  setdpbf_8:
  9118 000011EA 39D0                    	cmp	ax,dx			; must be < DPB.LAST_CLUSTER
  9119 000011EC 7502                    	jne	short setdpbf_9
  9120 000011EE 39D9                    	cmp	cx,bx
  9121                                  setdpbf_9:
  9122 000011F0 73BF                    	jnb	short setdpbf_3
  9123                                  setdpbf_10:
  9124 000011F2 804C1801                	or	byte [si+18h],1		; DPB.FIRST_ACCESS (bit 0 = 1)
  9125 000011F6 894C1F                  	mov	[si+1Fh],cx		; DPB.FREE_CNT
  9126 000011F9 837C0F00                	cmp	word [si+0Fh],0		; DP.FAT_SIZE
  9127 000011FD 7503                    	jnz	short setdpbf_11	; FAT12 or FAT16
  9128 000011FF 894421                  	mov	[si+21h],ax		; DPB.FREE_CNT_HW
  9129                                  setdpbf_11:
  9130 00001202 268B450E                	mov	ax,[es:di+0Eh]
  9131 00001206 268B4D0C                	mov	cx,[es:di+0Ch]		; new DPB next-free
  9132                                  		  		; (00000000h=no change, FFFFFFFFh=unknown)
  9133 0000120A 09C0                    	or	ax,ax
  9134 0000120C 7502                    	jnz	short setdpbf_12
  9135 0000120E E32E                    	jcxz	setdpbf_17
  9136                                  setdpbf_12:
  9137 00001210 83F8FF                  	cmp	ax,0FFFFh
  9138 00001213 7505                    	jne	short setdpbf_13
  9139 00001215 83F9FF                  	cmp	cx,0FFFFh
  9140 00001218 7411                    	je	short setdpbf_16	; (set as UNKNOWN/INITIAL)
  9141                                  setdpbf_13:
  9142 0000121A 21C0                    	and	ax,ax
  9143                                  	;cmp	ax,0			; must be >= 2
  9144 0000121C 7505                    	jnz	short setdpbf_14
  9145 0000121E 83F902                  	cmp	cx,2
  9146                                  ;setdpbf_14:
  9147 00001221 728E                    	jb	short setdpbf_3
  9148                                  setdpbf_14:
  9149 00001223 39D0                    	cmp	ax,dx			; must be < DPB.LAST_CLUSTER
  9150 00001225 7502                    	jne	short setdpbf_15
  9151 00001227 39D9                    	cmp	cx,bx
  9152                                  setdpbf_15:
  9153 00001229 7786                    	ja	short setdpbf_3
  9154                                  setdpbf_16:
  9155 0000122B 804C1801                	or	byte [si+18h],1		; DPB.FIRST_ACCESS (bit 0 = 1)
  9156 0000122F 894C1D                  	mov	[si+1Dh],cx		; DPB.NEXT_FREE
  9157 00001232 837C0F00                	cmp	word [si+0Fh],0		; DPB.FAT_SIZE
  9158 00001236 7506                    	jnz	short setdpbf_17	; FAT16 or FAT12
  9159 00001238 89443B                  	mov	[si+3Bh],ax
  9160 0000123B 894C39                  	mov	[si+39h],cx		; DPB.FAT32_NXTFREE
  9161                                  setdpbf_17:
  9162 0000123E B80473                  	mov	ax,7304h		; done (successful)
  9163 00001241 E92CF4                  	jmp	SYS_RET_OK
  9164                                  
  9165                                  setdpbf_18:
  9166                                  	;dec	al
  9167 00001244 48                      	dec	ax
  9168 00001245 7514                    	jnz	short setdpbf_19
  9169 00001247 1E                      	push	ds			; rebuild DPB from BPB
  9170 00001248 56                      	push	si
  9171 00001249 26C57508                	lds	si,[es:di+8]		; BIOS Parameter Block
  9172 0000124D 5D                      	pop	bp
  9173 0000124E 07                      	pop	es
  9174 0000124F B95845                  	mov	cx,4558h		; 'XE' (NASM syntax)
  9175 00001252 BA5241                  	mov	dx,4152h		; 'RA' (NASM syntax)
  9176 00001255 E82302                  	call	_$SETDPB
  9177 00001258 E915F4                  	jmp	SYS_RET_OK
  9178                                  
  9179                                  setdpbf_19:
  9180                                  	;dec	al
  9181 0000125B 48                      	dec	ax
  9182 0000125C 7507                    	jnz	short setdpbf_20
  9183                                  		  ; force media change
  9184                                  		  ; (next access to drive rebuild DPB)
  9185 0000125E 804C1880                	or	byte [si+18h],80h	; DPB.FIRST_ACCESS (bit 7 = 1)
  9186                                  setdpbf_29:	; 12/01/2024
  9187 00001262 E90BF4                  	jmp	SYS_RET_OK
  9188                                  
  9189                                  setdpbf_20:
  9190 00001265 837C0F00                	cmp	word [si+0Fh],0		; DPB.FAT_SIZE
  9191 00001269 7405                    	jz	short setdpbf_22 ; FAT32
  9192 0000126B B00F                    	mov	al,0Fh			; error_invalid_drive
  9193                                  		 ; (function 3 or 4 are only for drives with FAT32 fs)
  9194                                  setdpbf_21:
  9195 0000126D E90AF4                  	jmp	SYS_RET_ERR
  9196                                  
  9197                                  setdpbf_22:
  9198                                  	;dec	al
  9199 00001270 48                      	dec	ax
  9200 00001271 7454                    	jz	short setdpbf_30	; get/set active FAT number and mirroring
  9201 00001273 8B4435                  	mov	ax,[si+35h]		; DPB.ROOT_CLUSTER		
  9202                                  			; get/set root directory cluster number
  9203 00001276 2689450C                	mov	[es:di+0Ch],ax		; (ret) previous root directory cluster number
  9204 0000127A 8B4437                  	mov	ax,[si+37h]
  9205 0000127D 2689450E                	mov	[es:di+0Eh],ax
  9206 00001281 268B4D0A                	mov	cx,[es:di+0Ah]
  9207 00001285 268B4508                	mov	ax,[es:di+8]		; (call) new root directory cluster number
  9208 00001289 83F8FF                  	cmp	ax,0FFFFh		; -1 --> return only previous root dir cluster number
  9209 0000128C 7505                    	jne	short setdpbf_23
  9210 0000128E 83F9FF                  	cmp	cx,0FFFFh
  9211 00001291 74CF                    	je	short setdpbf_29
  9212                                  setdpbf_23:
  9213 00001293 21C9                    	and	cx,cx
  9214                                  	;cmp	cx,0			; cluster number must be >= 2
  9215                                  	;jnz	short setdpbf_24
  9216 00001295 7509                    	jnz	short setdpbf_26
  9217 00001297 83F802                  	cmp	ax,2
  9218                                  setdpbf_24:
  9219 0000129A 7304                    	jnb	short setdpbf_26
  9220                                  setdpbf_25:
  9221                                  	;jmp	setdpbf_3		; error (invalid parameter)
  9222                                  	; 12/01/2024
  9223 0000129C B057                    	mov	al,57h			; error_invalid_parameter
  9224 0000129E EBCD                    	jmp	short setdpbf_21
  9225                                  
  9226                                  setdpbf_26:
  9227 000012A0 3B4C2F                  	cmp	cx,[si+2Fh]		; must be <= DPB.LAST_CLUSTER
  9228 000012A3 7503                    	jne	short setdpbf_27
  9229 000012A5 3B442D                  	cmp	ax,[si+2Dh]
  9230                                  setdpbf_27:
  9231 000012A8 77F2                    	ja	short setdpbf_25	; error
  9232 000012AA 894C37                  	mov	[si+37h],cx		; DPB.ROOT_CLUSTER
  9233 000012AD 894435                  	mov	[si+35h],ax
  9234 000012B0 804C1802                	or	byte [si+18h],2		; DPB.FIRST_ACCESS (bit 1 = 1)
  9235 000012B4 1E                      	push    ds
  9236 000012B5 56                      	push    si
  9237 000012B6 5D                      	pop	bp
  9238 000012B7 07                      	pop	es
  9239 000012B8 E84806                  	call    ECritDisk
  9240 000012BB E8D321                  	call    update_fat32_fsinfo
  9241 000012BE E86F06                  	call    LCritDisk
  9242 000012C1 739F                    	jnc	short setdpbf_29
  9243 000012C3 B01F                    	mov	al,1Fh			; error_gen_failure
  9244                                  setdpbf_28:
  9245 000012C5 EBA6                    	jmp	short setdpbf_21
  9246                                  
  9247                                  	; 12/01/2024
  9248                                  ;setdpbf_29:
  9249                                  	;jmp	SYS_RET_OK
  9250                                  
  9251                                  setdpbf_30:
  9252                                  	; 12/01/2024
  9253                                  	; ax = 0
  9254 000012C7 8164238F00              	and	word [si+23h],8Fh	; DPB.EXT_FLAGS (clear bit 4-6)
  9255 000012CC 8B4C23                  	mov	cx,[si+23h]
  9256 000012CF 26894D0C                	mov	[es:di+0Ch],cx		; (ret) previous active FAT/mirroring state
  9257 000012D3 2689450E                	mov	[es:di+0Eh],ax ; 0
  9258                                  	;mov	word [es:di+0Eh],0	; put zero to Set_DPBforFormat struc offset 14
  9259 000012D7 268B5508                	mov	dx,[es:di+8]		; (call) new active FAT/mirroring state,
  9260                                  		  			;  or FFFFFFFFh to get
  9261 000012DB 83FAFF                  	cmp	dx,0FFFFh
  9262                                  	;jnz	short setdpbf_31
  9263                                  	;jmp	SYS_RET_OK
  9264                                  	; 12/01/2024
  9265 000012DE 7482                    	je	short setdpbf_29
  9266                                  
  9267                                  setdpbf_31:
  9268 000012E0 F7C270FF                	test    dx,0FF70h
  9269                                  	;jz	short setdpbf_33	; bit 4-6 of DBP.EXT_FLAGS must be 0
  9270                                  	;mov	al,57h			; error_invalid_parameter
  9271                                  	; 12/01/2024
  9272 000012E4 75B6                    	jnz	short setdpbf_25
  9273                                  setdpbf_32:
  9274                                  	;;jmp	short setdpbf_28
  9275                                  	; 12/01/2024
  9276                                  	;jmp	short setdpbf_21
  9277                                  	
  9278                                  setdpbf_33:
  9279 000012E6 B001                    	mov	al,1			; error_invalid_function
  9280                                  					; (modification is not allowed)
  9281                                  	;jmp	short setdpbf_32
  9282                                  	; 12/01/2024
  9283 000012E8 EB83                    	jmp	short setdpbf_21
  9284                                  
  9285                                  ; ---------------------------------------------------------------------------
  9286                                  
  9287                                  ;============================================================================
  9288                                  ; PARSE.ASM, MSDOS 6.0, 1991
  9289                                  ;============================================================================
  9290                                  ; 19/07/2018 - Retro DOS v3.0
  9291                                  ; 15/05/2019 - Retro DOS v4.0
  9292                                  
  9293                                  ; System calls for parsing command lines
  9294                                  ;
  9295                                  ;   $PARSE_FILE_DESCRIPTOR
  9296                                  ;
  9297                                  ;   Modification history:
  9298                                  ;
  9299                                  ;       Created: ARR 30 March 1983
  9300                                  ;               EE PathParse 10 Sept 1983
  9301                                  ;
  9302                                  
  9303                                  ;BREAK <$Parse_File_Descriptor -- Parse an arbitrary string into an FCB>
  9304                                  ;---------------------------------------------------------------------------
  9305                                  ; Inputs:
  9306                                  ;       DS:SI Points to a command line
  9307                                  ;       ES:DI Points to an empty FCB
  9308                                  ;       Bit 0 of AL = 1 At most one leading separator scanned off
  9309                                  ;                   = 0 Parse stops if separator encountered
  9310                                  ;       Bit 1 of AL = 1 If drive field blank in command line - leave FCB
  9311                                  ;                   = 0  "    "    "     "         "      "  - put 0 in FCB
  9312                                  ;       Bit 2 of AL = 1 If filename field blank - leave FCB
  9313                                  ;                   = 0  "       "      "       - put blanks in FCB
  9314                                  ;       Bit 3 of AL = 1 If extension field blank - leave FCB
  9315                                  ;                   = 0  "       "      "        - put blanks in FCB
  9316                                  ; Function:
  9317                                  ;       Parse command line into FCB
  9318                                  ; Returns:
  9319                                  ;       AL = 1 if '*' or '?' in filename or extension, 0 otherwise
  9320                                  ;       DS:SI points to first character after filename
  9321                                  ;---------------------------------------------------------------------------
  9322                                  
  9323                                  	; 13/01/2024
  9324                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:51BFh
  9325                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:4D22h
  9326                                  
  9327                                  _$PARSE_FILE_DESCRIPTOR:
  9328 000012EA E8FF45                  	call	MAKEFCB
  9329 000012ED 56                      	PUSH    SI
  9330 000012EE E886F1                  	call	Get_User_Stack
  9331                                  	;pop	word [si+8]
  9332 000012F1 8F4408                  	POP     word [SI+user_env.user_SI]
  9333 000012F4 C3                      	retn
  9334                                  
  9335                                  ; --------------------------------------------------------------------------
  9336                                  ; 13/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM - DOSCODE:51CAh)
  9337                                  ; --------------------------------------------------------------------------
  9338                                  
  9339                                  set_exerr_locus_unk:
  9340 000012F5 50                      	push    ax
  9341 000012F6 B001                    	mov     al,1		; errLOC_Unk
  9342                                  set_exerr_locus:
  9343 000012F8 36A2[2303]                      mov	[ss:EXTERR_LOCUS],al
  9344 000012FC 58                              pop	ax
  9345 000012FD C3                              retn
  9346                                  
  9347                                  set_exerr_locus_disk:
  9348 000012FE 50                      	push	ax
  9349 000012FF B002                    	mov	al,2		; errLOC_Disk
  9350 00001301 EBF5                    	jmp	short set_exerr_locus
  9351                                  
  9352                                  set_exerr_locus_ser:
  9353 00001303 50                      	push	ax
  9354 00001304 B004                    	mov	al,4		; errLOC_SerDev
  9355 00001306 EBF0                    	jmp	short set_exerr_locus
  9356                                  
  9357                                  set_exerr_locus_mem:
  9358 00001308 50                      	push	ax
  9359 00001309 B005                    	mov	al,5		; errLOC_Mem
  9360 0000130B EBEB                    	jmp	short set_exerr_locus
  9361                                  
  9362                                  ; ---------------------------------------------------------------------------
  9363                                  
  9364                                  ;============================================================================
  9365                                  ; MISC.ASM, MSDOS 6.0, 1991
  9366                                  ;============================================================================
  9367                                  ; 19/07/2018 - Retro DOS v3.0
  9368                                  
  9369                                  ; 29/04/2019 - Retro DOS v4.0
  9370                                  
  9371                                  ;ENTRYPOINTSEG	EQU	0CH
  9372                                  ;MAXDIF		EQU	0FFFH
  9373                                  ;SAVEXIT 	EQU	10
  9374                                  ;WRAPOFFSET	EQU	0FEF0h
  9375                                  
  9376                                  ;
  9377                                  ;----------------------------------------------------------------------------
  9378                                  ;
  9379                                  ;**	$SLEAZEFUNC - Get a Pointer to the Media Byte
  9380                                  ;
  9381                                  ;	Return Stuff sort of like old get fat call
  9382                                  ;
  9383                                  ;	ENTRY	none
  9384                                  ;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
  9385                                  ;			GOD help anyone who tries to do ANYTHING except
  9386                                  ;			READ this ONE byte.
  9387                                  ;		DX = Total Number of allocation units on disk
  9388                                  ;		CX = Sector size
  9389                                  ;		AL = Sectors per allocation unit
  9390                                  ;		   = -1 if bad drive specified
  9391                                  ;	USES	all
  9392                                  ;
  9393                                  ;**	$SLEAZEFUNCDL - Get a Pointer to the Media Byte
  9394                                  ;
  9395                                  ;	Identical to $SLEAZEFUNC except (dl) = drive
  9396                                  ;
  9397                                  ;	ENTRY	(dl) = drive (0=default, 1=A, 2=B, etc.)
  9398                                  ;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
  9399                                  ;			GOD help anyone who tries to do ANYTHING except
  9400                                  ;			READ this ONE byte.
  9401                                  ;		DX = Total Number of allocation units on disk
  9402                                  ;		CX = Sector size
  9403                                  ;		AL = Sectors per allocation unit
  9404                                  ;		   = -1 if bad drive specified
  9405                                  ;	USES	all
  9406                                  ;
  9407                                  ;----------------------------------------------------------------------------
  9408                                  ;
  9409                                  	; 10/01/2024 - Retro DOS v5.0
  9410                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:51E2h
  9411                                  
  9412                                  _$SLEAZEFUNC:
  9413                                  	; 15/05/2019 - Retro DOS v4.0
  9414 0000130D B200                    	MOV	DL,0
  9415                                  _$SLEAZEFUNCDL:
  9416 0000130F 16                      	push	ss
  9417 00001310 1F                      	pop	ds
  9418                                  	
  9419 00001311 88D0                    	MOV	AL,DL
  9420 00001313 E89A61                  	call	GETTHISDRV		; Get CDS structure
  9421                                  SET_AL_RET:
  9422                                  	; MSDOS 3.3
  9423                                  	;;mov	al, 0Fh
  9424                                  	;MOV	AL,error_invalid_drive	; Assume error	;AC000;
  9425                                  	
  9426                                  	; MSDOS 6.0 & MSDOS 3.3
  9427 00001316 7229                    	JC	short BADSLDRIVE
  9428                                  
  9429 00001318 E86D20                  	call	DISK_INFO
  9430                                  	;JC	short SET_AL_RET	; User FAILed to I 24
  9431 0000131B 7224                    	jc	short BADSLDRIVE
  9432 0000131D 8826[9805]              	MOV	[FATBYTE],AH	; FAT (MEDIA) ID byte
  9433                                  
  9434                                  	; 10/01/2024 - Retro DOS v5.0 (PCDOS 7.1)
  9435                                  	;;;
  9436 00001321 30E4                    	xor     ah, ah		; AH = 0
  9437                                  				; AL = sectors per cluster
  9438 00001323 57                      	push    di		; di:bx = number of clusters
  9439 00001324 E81A05                  	call    TestNet
  9440 00001327 5F                      	pop     di
  9441 00001328 7205                    	jc      short sleazefunc1
  9442 0000132A 51                      	push    cx		; bytes per sector
  9443 0000132B E85E21                  	call    modify_cluster_count
  9444 0000132E 59                      	pop     cx		; ax = sectors per cluster (modified)
  9445                                  				; dx = number of clusters (modified)
  9446                                  				; if bytes per cluster > 16384
  9447                                  				;    and hw of cluster count > 0
  9448                                  				;    bx = 0FFFEh (invalidated parm sign)
  9449                                  sleazefunc1:
  9450                                  	;;;
  9451                                  
  9452                                  ; NOTE THAT A FIXED MEMORY CELL IS USED --> THIS CALL IS NOT
  9453                                  ; RE-ENTRANT. USERS BETTER GET THE ID BYTE BEFORE THEY MAKE THE
  9454                                  ; CALL AGAIN
  9455                                  
  9456                                  	;MOV	DI,FATBYTE
  9457                                  	; 10/01/2024 
  9458                                  	;XOR	AH,AH			; AL has sectors/cluster
  9459 0000132F E845F1                  	call	Get_User_Stack
  9460                                  	;mov	[si+4],cx
  9461                                  	;mov	[si+6],bx
  9462                                  	;mov	[si+2],di
  9463 00001332 894C04                  	MOV	[SI+user_env.user_CX],CX
  9464 00001335 895C06                  	MOV	[SI+user_env.user_DX],BX
  9465                                  	;MOV	[SI+user_env.user_BX],DI
  9466                                  	; 10/01/2024
  9467 00001338 C74402[9805]            	MOV	word [SI+user_env.user_BX],FATBYTE
  9468                                  	
  9469                                  	;mov	[si+0Eh],ss
  9470 0000133D 8C540E                  	MOV     [SI+user_env.user_DS],SS ; stash correct pointer
  9471                                  
  9472 00001340 C3                      	retn
  9473                                  
  9474                                  BADSLDRIVE:
  9475 00001341 E94BF3                  	jmp	FCB_RET_ERR
  9476                                  
  9477                                  ;
  9478                                  ;----------------------------------------------------------------------------
  9479                                  ;
  9480                                  ;**	$Get_INDOS_Flag - Return location of DOS Critical Section Flag
  9481                                  ;
  9482                                  ;	Returns location of DOS status for interrupt routines
  9483                                  ;
  9484                                  ;	ENTRY	none
  9485                                  ;	EXIT	(es:bx) = flag location
  9486                                  ;	USES	all
  9487                                  ;
  9488                                  ;----------------------------------------------------------------------------
  9489                                  ;
  9490                                  
  9491                                  _$GET_INDOS_FLAG:
  9492 00001344 E830F1                  	CALL	Get_User_Stack
  9493                                  	;MOV	WORD [SI+2],INDOS
  9494 00001347 C74402[2103]            	MOV	word [SI+user_env.user_BX],INDOS
  9495                                  getin_segm:	; 13/01/2024
  9496                                  	;MOV	[SI+10H],SS
  9497 0000134C 8C5410                  	MOV	[SI+user_env.user_ES],SS
  9498 0000134F C3                      	RETN 
  9499                                  
  9500                                  ;
  9501                                  ;----------------------------------------------------------------------------
  9502                                  ;
  9503                                  ;**	$Get_IN_Vars - Return Pointer to DOS Variables
  9504                                  ;
  9505                                  ;	Return a pointer to interesting DOS variables This call is version
  9506                                  ;	dependent and is subject to change without notice in future versions.
  9507                                  ;	Use at risk.
  9508                                  ;
  9509                                  ;	ENTRY	none
  9510                                  ;	EXIT	(es:bx) = address of SYSINITVAR
  9511                                  ;	uses	ALL
  9512                                  ;
  9513                                  ;----------------------------------------------------------------------------
  9514                                  ;
  9515                                  
  9516                                  	; 13/01/2024 - Retro DOS v5.0
  9517                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:5226h
  9518                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:4D65h
  9519                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:4D58h
  9520                                  
  9521                                  _$GET_IN_VARS:
  9522 00001350 E824F1                  	CALL	Get_User_Stack
  9523                                  	;MOV	WORD [SI+2],SYSINITVAR
  9524                                  	;MOV	word [SI+user_env.user_BX],SYSINITVAR
  9525 00001353 C74402[2600]            	MOV	word [SI+user_env.user_BX],SYSINITVARS
  9526                                  	; 13/01/2024
  9527                                  	;;MOV	[SI+10H],SS
  9528                                  	;MOV	[SI+user_env.user_ES],SS
  9529                                  	;RETN
  9530 00001358 EBF2                    	jmp	short getin_segm
  9531                                  ;
  9532                                  ;----------------------------------------------------------------------------
  9533                                  ;
  9534                                  ;**	$Get_Default_DPB - Return a pointer to the Default DPB
  9535                                  ;
  9536                                  ;	Return pointer to drive parameter table for default drive
  9537                                  ;
  9538                                  ;	ENTRY	none
  9539                                  ;	EXIT	(ds:bx) = DPB address
  9540                                  ;	USES	all
  9541                                  ;
  9542                                  ;**	$Get_DPB - Return a pointer to a specified DPB
  9543                                  ;
  9544                                  ;	Return pointer to a specified drive parameter table
  9545                                  ;
  9546                                  ;	ENTRY	(dl) = drive # (0 = default, 1=A, 2=B, etc.)
  9547                                  ;	EXIT	(al) = 0 iff ok
  9548                                  ;		  (ds:bx) = DPB address
  9549                                  ;		(al) = -1 if bad drive
  9550                                  ;	USES	all
  9551                                  ;
  9552                                  ;----------------------------------------------------------------------------
  9553                                  ;
  9554                                  
  9555                                  ; 10/01/2024
  9556                                  %if 0
  9557                                  
  9558                                  ; 15/05/2019 - Retro DOS v4.0
  9559                                  
  9560                                  _$GET_DEFAULT_DPB:
  9561                                  	MOV	DL,0
  9562                                  _$GET_DPB:
  9563                                  	push	ss
  9564                                  	pop	ds
  9565                                  
  9566                                  	MOV	AL,DL
  9567                                  	call	GETTHISDRV		; Get CDS structure
  9568                                  	JC	short ISNODRV 		; no valid drive
  9569                                  	LES	DI,[THISCDS]		; check for net CDS
  9570                                  	;;test	word [es:di+43h],8000h
  9571                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
  9572                                  	;test	byte [es:di+44h],80h
  9573                                  	test	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
  9574                                  	JNZ	short ISNODRV 		; No DPB to point at on NET stuff
  9575                                  	call	ECritDisk
  9576                                  	call	FATREAD_CDS		; Force Media Check and return DPB
  9577                                  	call	LCritDisk
  9578                                  	JC	short ISNODRV 		; User FAILed to I 24, only error we
  9579                                  					;   have.
  9580                                  	call	Get_User_Stack
  9581                                  	;mov	[si+2],bp
  9582                                  	MOV	[SI+user_env.user_BX],BP
  9583                                  	;mov	[si+0Eh],es
  9584                                  	MOV	[SI+user_env.user_DS],ES
  9585                                  	XOR	AL,AL
  9586                                  	retn
  9587                                  ISNODRV:
  9588                                  	MOV	AL,-1
  9589                                  	retn
  9590                                  
  9591                                  %else
  9592                                  
  9593                                  ; 13/01/2024
  9594                                  ; 10/01/2024 - Retro DOS v5.0
  9595                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:5230h
  9596                                  
  9597                                  _$GET_DEFAULT_DPB:
  9598 0000135A B200                    	MOV	DL,0
  9599                                  _$GET_DPB:
  9600 0000135C 16                      	push	ss
  9601 0000135D 1F                      	pop	ds
  9602                                  
  9603 0000135E 88D0                    	MOV	AL,DL
  9604 00001360 E84D61                  	call	GETTHISDRV		; Get CDS structure
  9605 00001363 B00F                    	mov	al,0Fh			; error_invalid_drive
  9606 00001365 7315                    	jnc	short getdpb_3		
  9607                                  
  9608                                  	; no valid drive
  9609                                  getdpb_1:
  9610                                  	; 13/01/2024
  9611 00001367 E80DF1                  	call	Get_User_Stack
  9612 0000136A 813C0273                	cmp	word [si],7302h		; INT 21h, AX = 7302h ? Get_ExtDPB
  9613                                  					; GET EXTENDED DPB
  9614 0000136E 7406                    	je      short getdpb_2
  9615 00001370 813C0473                	cmp	word [si],7304h		; INT 21h, AX = 7304h ? Set_DPBforFormat
  9616                                  					; Set DPB TO USE FOR FORMATTING
  9617 00001374 7503                    	jne	short ISNODRV
  9618                                  getdpb_2:
  9619 00001376 E901F3                  	jmp     SYS_RET_ERR
  9620                                  
  9621                                  ISNODRV:
  9622 00001379 B0FF                    	mov	al,0FFh	; -1		; invalid (or network) drive
  9623 0000137B C3                      	retn
  9624                                  
  9625                                  getdpb_3:
  9626 0000137C C43E[A205]              	LES	DI,[THISCDS]		; check for net CDS
  9627                                  	;;test	word [es:di+43h],8000h
  9628                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
  9629                                  	;test	byte [es:di+44h],80h
  9630 00001380 26F6454480              	test	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
  9631                                  	;JNZ	short ISNODRV 		; No DPB to point at on NET stuff
  9632                                  	; 10/01/2024
  9633 00001385 75E0                    	jnz	short getdpb_1
  9634 00001387 E87905                  	call	ECritDisk
  9635 0000138A E8274D                  	call	FATREAD_CDS		; Force Media Check and return DPB
  9636 0000138D E8A005                  	call	LCritDisk
  9637                                  	;JC	short ISNODRV 		; User FAILed to I 24,
  9638 00001390 B053                    	mov	al,53h ; error_FAIL_I24 ;  only error we have.
  9639 00001392 72D3                    	jc	short getdpb_1
  9640 00001394 E8E0F0                  	call	Get_User_Stack
  9641                                  	; 13/01/2024
  9642 00001397 813C0473                	cmp	word [si],7304h		; INT 21h, AX = 7304h ?
  9643 0000139B 7503                    	jnz	short getdpb_4
  9644 0000139D E9E8FD                  	jmp	Set_DPBforFormat
  9645                                  
  9646                                  	; 13/01/2024
  9647                                  getdpb_4:
  9648 000013A0 813C0273                	cmp	word [si],7302h		; INT 21h, AX = 7302h ?
  9649 000013A4 7410                    	je	short getdpb_5
  9650 000013A6 26837E0F00              	cmp	word [es:bp+0Fh],0
  9651 000013AB 74BA                    	jz	short getdpb_1
  9652 000013AD 896C02                  	mov	[si+2],bp
  9653 000013B0 8C440E                  	mov	[si+0Eh],es
  9654 000013B3 30C0                    	xor	al,al			; status = 0 = successful
  9655 000013B5 C3                      	retn
  9656                                  
  9657                                  getdpb_5:
  9658 000013B6 B018                    	mov	al,18h			; error_bad_length
  9659 000013B8 837C043F                	cmp	word [si+4],63		; [SI+user_env.user_CX]
  9660                                  					; length of buffer (must be 63 bytes)
  9661 000013BC 72B8                    	jb	short getdpb_2		; error
  9662                                  
  9663 000013BE 06                      	push	es			; ES:BP = Drive parameter block
  9664 000013BF 55                      	push	bp
  9665 000013C0 8E4410                  	mov	es,[si+16]		; [SI+user_env.user_ES]
  9666 000013C3 8B7C0A                  	mov	di,[si+10]		; [SI+user_env.user_DI]
  9667 000013C6 8B5C08                  	mov	bx,[si+8]		; [SI+user_env.user_SI] (!)
  9668 000013C9 5E                      	pop	si
  9669 000013CA 1F                      	pop	ds
  9670                                  
  9671 000013CB B83D00                  	mov	ax,61			; length of following data (003Dh)
  9672 000013CE AB                      	stosw
  9673 000013CF 89C1                    	mov	cx,ax
  9674 000013D1 57                      	push	di
  9675 000013D2 F3A4                    	rep movsb
  9676 000013D4 5F                      	pop	di
  9677                                  	
  9678                                  	; 13/01/2024
  9679 000013D5 06                      	push	es
  9680 000013D6 1F                      	pop	ds
  9681 000013D7 31C0                    	xor	ax,ax ; 0
  9682                                  
  9683 000013D9 81FBA6F1                	cmp	bx,0F1A6h		; (!) signature (undocumented),
  9684                                  					;  must be 0F1A6h to get device driver
  9685                                  					;  address and next-DBP pointer
  9686                                  					; (Ref: Ralf Brown's Interrupt List)
  9687 000013DD 740E                    	je	short getdpb_6
  9688                                  	
  9689                                  	;xor	ax,ax	; 0
  9690 000013DF 48                      	dec	ax 	; -1
  9691                                  	;mov	[es:di+19h],ax		; pointer to next DPB (invalidated)
  9692                                  	;mov	[es:di+1Bh],ax
  9693                                  	;mov	[es:di+13h],ax		; pointer to driver address (invalidated)
  9694                                  	;mov	[es:di+15h],ax
  9695                                  	; 13/01/2024
  9696 000013E0 894519                  	mov	[di+19h],ax ; -1	; pointer to next DPB (invalidated)
  9697 000013E3 89451B                  	mov	[di+1Bh],ax
  9698 000013E6 894513                  	mov	[di+13h],ax		; pointer to driver address (invalidated)
  9699 000013E9 894515                  	mov	[di+15h],ax	
  9700                                  
  9701                                  	; 13/01/2024
  9702 000013EC 40                      	inc	ax ; 0
  9703                                  getdpb_6:
  9704                                  	; 13/01/2024
  9705                                  	; ax = 0
  9706 000013ED 39450F                  	cmp	[di+0Fh],ax ; 0
  9707                                  	;cmp	[es:di+0Fh],ax ; 0	; FAT (16 bit) size ?
  9708                                  	;;cmp	word [es:di+0Fh],0
  9709 000013F0 743F                    	jz	short getdpb_8		; FAT32
  9710                                  			  ; FAT16 or FAT12
  9711                                  	;mov	ax,[es:di+0Dh]		; DPB.MAX_CLUSTER
  9712                                  	;mov	[es:di+2Dh],ax		; DPB.LAST_CLUSTER
  9713                                  	;mov	ax,[es:di+0Fh]		; DPB.FAT_SIZE
  9714                                  	;mov	[es:di+31h],ax		; DPB.FAT32_SIZE
  9715                                  	;mov	ax,[es:di+1Dh]		; DPB.NEXT_FREE
  9716                                  	;mov	[es:di+39h],ax		; DPB.FAT32_NXTFREE
  9717                                  	;mov	ax,[es:di+0Bh]		; DPB.FIRST_SECTOR
  9718                                  	;mov	[es:di+29h],ax		; DPB.FCLUS_FSECTOR
  9719                                  	; 13/01/2024
  9720 000013F2 8B450D                  	mov	ax,[di+0Dh]		; DPB.MAX_CLUSTER
  9721 000013F5 89452D                  	mov	[di+2Dh],ax		; DPB.LAST_CLUSTER
  9722 000013F8 8B450F                  	mov	ax,[di+0Fh]		; DPB.FAT_SIZE
  9723 000013FB 894531                  	mov	[di+31h],ax		; DPB.FAT32_SIZE
  9724 000013FE 8B451D                  	mov	ax,[di+1Dh]		; DPB.NEXT_FREE
  9725 00001401 894539                  	mov	[di+39h],ax		; DPB.FAT32_NXTFREE
  9726 00001404 8B450B                  	mov	ax,[di+0Bh]		; DPB.FIRST_SECTOR
  9727 00001407 894529                  	mov	[di+29h],ax		; DPB.FCLUS_FSECTOR	
  9728                                  
  9729 0000140A 31C0                    	xor	ax,ax	; 0
  9730                                  	;mov	[es:di+2Fh],ax		; DPB.LAST_CLUSTER high word
  9731                                  	;mov	[es:di+33h],ax		; DPB.FAT32_SIZE high word
  9732                                  	;mov	[es:di+3Bh],ax		; DPB.FAT32_NXTFREE high word
  9733                                  	;mov	[es:di+2Bh],ax		; DPB.FCLUS_FSECTOR high word
  9734                                  	;mov	[es:di+35h],ax		; DPB.ROOT_CLUSTER
  9735                                  	;mov	[es:di+37h],ax		; DPB.ROOT_CLUSTER high word
  9736                                  	;mov	[es:di+23h],ax		; DPB.EXT_FLAGS
  9737                                  	; 13/01/2024
  9738 0000140C 89452F                  	mov	[di+2Fh],ax ; 0		; DPB.LAST_CLUSTER high word
  9739 0000140F 894533                  	mov	[di+33h],ax		; DPB.FAT32_SIZE high word
  9740 00001412 89453B                  	mov	[di+3Bh],ax		; DPB.FAT32_NXTFREE high word
  9741 00001415 89452B                  	mov	[di+2Bh],ax		; DPB.FCLUS_FSECTOR high word
  9742 00001418 894535                  	mov	[di+35h],ax		; DPB.ROOT_CLUSTER
  9743 0000141B 894537                  	mov	[di+37h],ax		; DPB.ROOT_CLUSTER high word
  9744 0000141E 894523                  	mov	[di+23h],ax		; DPB.EXT_FLAGS
  9745 00001421 48                      	dec	ax	; -1
  9746                                  	;mov	[es:di+25h],ax		; DPB.FSINFO_SECTOR (invalidated)
  9747                                  	;mov	[es:di+27h],ax		; DPB.BKBOOT_SECTOR (invalidated)
  9748                                  	; 13/01/2024
  9749 00001422 894525                  	mov	[di+25h],ax		; DPB.FSINFO_SECTOR (invalidated)
  9750 00001425 894527                  	mov	[di+27h],ax		; DPB.BKBOOT_SECTOR (invalidated)
  9751 00001428 3B451F                  	cmp	ax,[di+1Fh]
  9752                                  	;cmp	ax,[es:di+1Fh]		; DPB.FREE_COUNT (= -1 ?)
  9753 0000142B 7401                    	je	short getdpb_7
  9754 0000142D 40                      	inc	ax	; -1 -> 0
  9755                                  getdpb_7:
  9756 0000142E 894521                  	mov	[di+21h],ax
  9757                                  	;mov	[es:di+21h],ax		; DPB.PB.FREE_COUNT high word
  9758                                  getdpb_8:
  9759                                  	;xor	ax,ax			; status = 0 = successful
  9760 00001431 E93CF2                  	jmp	SYS_RET_OK
  9761                                  
  9762                                  %endif
  9763                                  
  9764                                  ;
  9765                                  ;----------------------------------------------------------------------------
  9766                                  ;
  9767                                  ;**	$Disk_Reset - Flush out Dirty Buffers
  9768                                  ;
  9769                                  ;	$DiskReset flushes and invalidates all buffers. BUGBUG - do
  9770                                  ;		we really invalidate? SHould we? THis screws non-removable
  9771                                  ;		caching. Maybe CHKDSK relies upon it, though....
  9772                                  ;
  9773                                  ;	ENTRY	none
  9774                                  ;	EXIT	none
  9775                                  ;	USES	all
  9776                                  ;
  9777                                  ;----------------------------------------------------------------------------
  9778                                  ;
  9779                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  9780                                  	; DOSCODE:4D94h
  9781                                  	; 13/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
  9782                                  	; DOSCODE:5322h
  9783                                  _$DISK_RESET:
  9784                                  	; 15/05/2019 - Retro DOS v4.0
  9785 00001434 B0FF                    	mov	al,0FFh	; -1
  9786 00001436 16                      	push	ss
  9787 00001437 1F                      	pop	ds
  9788                                  	; 06/11/2022
  9789                                  	;MOV	AL,-1
  9790 00001438 E8C804                  	call	ECritDisk
  9791                                  	; MSDOS 6.0
  9792                                  	;;or	word [DOS34_FLAG],4
  9793                                  	;or	word [DOS34_FLAG],FROM_DISK_RESET    ;AN000;
  9794 0000143B 800E[1106]04            	or	byte [DOS34_FLAG],FROM_DISK_RESET ; 4 ; 15/05/2019
  9795 00001440 E81750                  	call	FLUSHBUF
  9796                                  	; MSDOS 6.0
  9797                                  	;and	word [DOS34_FLAG],0FFFBh
  9798                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9799                                  	;and	word [DOS34_FLAG],NO_FROM_DISK_RESET ;AN000;
  9800                                  	; 15/12/2022
  9801 00001443 8026[1106]FB            	and	byte [DOS34_FLAG],NO_FROM_DISK_RESET ; 0FBh ; 15/05/2019
  9802                                  
  9803                                  	; 13/01/2024 - Retro DOS v5.0
  9804                                  	; (PCDOS 7.1 IBMDOS.COM)
  9805                                  	;;;
  9806 00001448 C42E[2600]              	les     bp,[DPBHEAD]
  9807                                  drst_1:
  9808 0000144C 83FDFF                  	cmp	bp,0FFFFh	; -1 ?
  9809 0000144F 7409                    	je	short drst_2	; yes, it is the last DPB
  9810 00001451 E83D20                  	call	update_fat32_fsinfo ; update FSINFO (sector) parameters 
  9811 00001454 26C46E19                	les	bp,[es:bp+19h]	; DPB.NEXT_DPB
  9812 00001458 EBF2                    	jmp	short drst_1
  9813                                  drst_2:
  9814                                  	;;;
  9815                                  
  9816 0000145A C706[050E]0000          	mov	word [SC_STATUS],0	; Throw out secondary cache ; M041
  9817                                  ;
  9818                                  ; We will "ignore" any errors on the flush, and go ahead and invalidate. This
  9819                                  ; call doesn't return any errors and it is supposed to FORCE a known state, so
  9820                                  ; let's do it.
  9821                                  ;
  9822                                  ; Invalidate 'last-buffer' used
  9823                                  ;
  9824 00001460 BBFFFF                  	MOV	BX,-1 ; 0FFFFh	
  9825 00001463 891E[2000]              	MOV	[LastBuffer+2],BX
  9826 00001467 891E[1E00]              	MOV	[LastBuffer],BX
  9827                                  
  9828                                  	; MSDOS 3.3 
  9829                                  	; IBMDOS.COM, Offset 1C66h
  9830                                  	;;;;
  9831                                  	;lds	si,[BUFFHEAD]
  9832                                  	;mov	ax,20FFh	; .buf_ID,    AL = FFh (Free buffer)
  9833                                  				; .buf_flags, AH = 0, reset/clear
  9834                                  ;DRST_1:
  9835                                  	;;mov	[si+4],ax
  9836                                  	;mov	[si+BUFFINFO.buf_ID],ax
  9837                                  	;lds	si,[SI]
  9838                                  	;cmp	si,bx ; -1
  9839                                  	;je	short DRST_2
  9840                                  	;;mov	[si+4],ax
  9841                                  	;mov	[si+BUFFINFO.buf_ID],ax
  9842                                  	;lds	si,[SI]
  9843                                  	;cmp	si,bx
  9844                                  	;jne	short DRST_1
  9845                                  	;;;;
  9846                                  ;DRST_2:
  9847 0000146B E8C204                  	call	LCritDisk
  9848 0000146E B8FFFF                  	MOV	AX,-1
  9849                                  	; 07/12/2022
  9850                                  	;mov	ax,0FFFFh
  9851                                  	;CallInstall NetFlushBuf,MultNET,32,AX,AX
  9852 00001471 50                      	push	ax ; * MSDOS 6.0 ; 15/05/2019
  9853 00001472 B82011                  	mov     ax,1120h
  9854 00001475 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
  9855                                  			; DS = DOS CS
  9856                                  			; Return: CF clear (successful)
  9857 00001477 58                      	pop	ax ; * MSDOS 6.0 ; 15/05/2019
  9858                                  	
  9859 00001478 C3                      	retn
  9860                                  
  9861                                  	; 19/07/2018 - Retro DOS v3.0
  9862                                  
  9863                                  ;
  9864                                  ;	BREAK <$SetDPB - Create a valid DPB from a user-specified BPB>
  9865                                  ;
  9866                                  ;----------------------------------------------------------------------------
  9867                                  ;
  9868                                  ;**	$SetDPB - Create a DPB
  9869                                  ;
  9870                                  ;	SetDPB Creates a valid DPB from a user-specified BPB
  9871                                  ;
  9872                                  ;	ENTRY	ES:BP Points to DPB
  9873                                  ;		DS:SI Points to BPB
  9874                                  ;	EXIT	DPB setup
  9875                                  ;	USES	ALL but BP, DS, ES
  9876                                  ;
  9877                                  ;----------------------------------------------------------------------------
  9878                                  ;
  9879                                  
  9880                                  ; 10/05/2019 - Retro DOS v4.0
  9881                                  
  9882                                  ; DOSCODE:4DD6h (MSDOS 6.21, MSDOS.SYS)
  9883                                  
  9884                                  ; MSDOS 6.0
  9885 00001479 0300                    word3:	dw	3			; M008 -- word value for divides
  9886                                  
  9887                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0)
  9888                                  ; DOSCODE:4DC9h (MSDOS 5.0, MSDOS.SYS)
  9889                                  
  9890                                  ; 13/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1)
  9891                                  ; DOSCODE:5369h (PCDOS 7.1, IBMDOS.COM)
  9892                                  
  9893                                  ; 13/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1)
  9894                                  ; Windows ME IO.SYS (Extracted) - BIOSCODE:4EF8h 
  9895                                  
  9896                                  ;procedure   $SETDPB,NEAR
  9897                                  
  9898                                  _$SETDPB:
  9899 0000147B 89EF                    	MOV	DI,BP
  9900                                  	;ADD	DI,2			; Skip over dpb_drive and dpb_UNIT
  9901                                  	; 13/01/2024
  9902 0000147D 47                      	inc	di
  9903 0000147E 47                      	inc	di
  9904 0000147F AD                      	LODSW
  9905 00001480 AB                      	STOSW				; dpb_sector_size
  9906                                  
  9907                                  	; 13/01/2024
  9908                                  	; Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
  9909                                  	;;;
  9910 00001481 81F95845                	cmp	cx,4558h	; 'XE' (NASM syntax)
  9911                                  				; CX = signature 4558h ('EX') for FAT32 extended BPB/DPB
  9912 00001485 7506                    	jne	short not_fat32_extension
  9913 00001487 81FA5241                	cmp	dx,4152h	; 'RA' (NASM syntax)
  9914                                  				; DX = signature 4152h ('AR') for FAT32 extended BPB/DPB
  9915 0000148B 7402                    	je	short chk_fat32_conditions
  9916                                  not_fat32_extension:                    ; ...
  9917 0000148D 31C9                    	xor	cx,cx	; 0	; (Do not use FAT32 extensions -32 bit parameters-)
  9918                                  chk_fat32_conditions:  
  9919 0000148F 51                      	push	cx	; (*)
  9920                                  	;;;
  9921                                  	
  9922                                  	; 13/01/2024
  9923                                  	; MSDOS 6.0
  9924                                  	;cmp	byte [si+3],0
  9925                                  	;CMP	BYTE [SI+A_BPB.BPB_NUMBEROFFATS-2],0
  9926 00001490 807C0300                	cmp	byte [SI+A_BPB.NUMBEROFFATS-2],0 ; FAT file system drive ;AN000;
  9927                                  	;JNZ	short yesfat			 ; yes			 ;AN000;
  9928 00001494 740C                    	jz	short nofat ; 13/01/2024 (PCDOS 7.1)
  9929                                  
  9930                                  	; 13/01/2024 - Retro DOS v5.0
  9931                                  	;;;
  9932                                  	;cmp	word [si+9],0	; .BPB_SECTORSPERFAT ; BPB_FATSz16
  9933 00001496 837C0900                	cmp	word [si+A_BPB.SECTORSPERFAT-2],0
  9934 0000149A 7516                    	jnz	short yesfat
  9935                                  	;cmp	word [si+29],0	; .BPB_FAT32VERSION ; BPB_FSVer
  9936 0000149C 837C1D00                	cmp	word [si+A_BPB.FSVER-2],0
  9937 000014A0 7410                    	jz	short yesfat
  9938                                  nofat:             
  9939                                  	;;;
  9940                                  
  9941                                  	; 13/01/2024
  9942                                  	;;mov	byte [es:di+4],0
  9943                                  	;MOV	BYTE [ES:DI+DPB.FAT_COUNT-4],0
  9944                                  	;JMP	short setend			; NO		;AN000;
  9945                                  
  9946                                  	; 13/01/2024 (WINME IO.SYS)
  9947                                  	;mov	byte [es:di+4],0 ; DPB.FAT_COUNT
  9948                                  	;xor	eax,eax
  9949                                  	;jmp	setend
  9950                                  
  9951                                  	; 13/01/2024 (PCDOS7.1 IBMDOS.COM)
  9952 000014A2 31C0                    	xor	ax,ax ; 0
  9953 000014A4 26884504                	mov	[es:di+DPB.FAT_COUNT-4],al ; DPB.FAT_COUNT = 0
  9954                                  
  9955                                  	; 13/01/2024 (not necessary) 
  9956                                  	;add	di,15	; DPB.DRIVER_ADDR
  9957                                  
  9958 000014A8 83C60B                  	add	si,11	; .BPB_SECTORSPERTRACK
  9959                                  
  9960                                  	;mov	[es:bp+15],ax	; DPB.FAT_SIZE = 0
  9961 000014AB 2689460F                	mov	[es:bp+DPB.FAT_SIZE],ax
  9962                                  
  9963 000014AF E9B500                  	jmp	setend
  9964                                  
  9965                                  yesfat: ; 10/08/2018
  9966 000014B2 89C2                    	MOV	DX,AX
  9967 000014B4 AC                      	LODSB
  9968                                  	;;;
  9969                                  	; 13/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
  9970 000014B5 08C0                    	or	al,al
  9971 000014B7 74E9                    	jz	short nofat
  9972                                  	;;;
  9973                                  	;DEC	AL
  9974                                  	; 17/12/2022
  9975 000014B9 48                      	dec	ax
  9976 000014BA AA                      	STOSB				; dpb_cluster_mask
  9977                                  	;INC	AL
  9978 000014BB 40                      	inc	ax
  9979 000014BC 30E4                    	XOR	AH,AH
  9980                                  LOG2LOOP:
  9981 000014BE A801                    	test	AL,1
  9982 000014C0 7506                    	JNZ	short SAVLOG
  9983 000014C2 FEC4                    	INC	AH
  9984 000014C4 D0E8                    	SHR	AL,1
  9985 000014C6 EBF6                    	JMP	SHORT LOG2LOOP
  9986                                  SAVLOG:
  9987 000014C8 88E0                    	MOV	AL,AH
  9988 000014CA AA                      	STOSB				; dpb_cluster_shift
  9989 000014CB 88C3                    	MOV	BL,AL
  9990 000014CD A5                      	MOVSW				; dpb_first_FAT Start of FAT (# of reserved sectors)
  9991 000014CE AC                      	LODSB
  9992 000014CF AA                      	STOSB				; dpb_FAT_count Number of FATs
  9993                                  ;	OR	AL,AL			; NONFAT ?				;AN000;
  9994                                  ;	JZ	short setend		; yes, don't do anything                ;AN000;
  9995 000014D0 88C7                    	MOV	BH,AL
  9996 000014D2 AD                      	LODSW
  9997 000014D3 AB                      	STOSW				; dpb_root_entries Number of directory entries
  9998 000014D4 B105                    	MOV	CL,5
  9999 000014D6 D3EA                    	SHR	DX,CL			; Directory entries per sector
 10000 000014D8 48                      	DEC	AX
 10001 000014D9 01D0                    	ADD	AX,DX			; Cause Round Up
 10002 000014DB 89D1                    	MOV	CX,DX
 10003 000014DD 31D2                    	XOR	DX,DX
 10004 000014DF F7F1                    	DIV	CX
 10005 000014E1 89C1                    	MOV	CX,AX			; Number of (root) directory sectors
 10006 000014E3 47                      	INC	DI
 10007 000014E4 47                      	INC	DI			; Skip dpb_first_sector
 10008 000014E5 A5                      	MOVSW			; Total number of sectors in DSKSIZ (temp as dpb_max_cluster)
 10009 000014E6 AC                      	LODSB
 10010                                  	;mov	[es:bp+17h],al
 10011 000014E7 26884617                	MOV	[ES:BP+DPB.MEDIA],AL	; Media byte
 10012 000014EB AD                      	LODSW				; Number of sectors in a FAT
 10013                                  	
 10014                                  	;;;
 10015                                  	;MSDOS 3.3
 10016                                  	;
 10017                                  	;STOSB		; DPB.FAT_SIZE
 10018                                  	;MUL	BH
 10019                                  	
 10020                                  	;MSDOS 6.0
 10021                                  	;
 10022 000014EC AB                      	STOSW		; DPB.FAT_SIZE	;AC000;;>32mb dpb_FAT_size
 10023                                  
 10024                                  ; 13/01/2024
 10025                                  %if 0
 10026                                  	MOV	DL,BH			;AN000;;>32mb
 10027                                  	XOR	DH,DH			;AN000;;>32mb
 10028                                  	MUL	DX			;AC000;;>32mb Space occupied by all FATs
 10029                                  	;;;
 10030                                  	
 10031                                  	;add	ax,[es:bp+6]
 10032                                  	ADD	AX,[ES:BP+DPB.FIRST_FAT]
 10033                                  	STOSW				; dpb_dir_sector
 10034                                  	ADD	AX,CX			; Add number of (root) directory sectors
 10035                                  	;mov	[es:bp+0Bh],ax
 10036                                  	MOV	[ES:BP+DPB.FIRST_SECTOR],AX
 10037                                  	
 10038                                  	; MSDOS 6.0
 10039                                  	MOV	CL,BL			;F.C. >32mb				;AN000;
 10040                                  	;;cmp	word [es:bp+0Dh],0
 10041                                  	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
 10042                                  	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
 10043                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10044                                  	; 15/12/2022
 10045                                  	; 28/07/2019
 10046                                  	mov	bx,[ES:BP+DSKSIZ]
 10047                                  	or	bx,bx
 10048                                  	JNZ	short normal_dpb	;F.C. >32mb				;AN000;
 10049                                  	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
 10050                                  	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
 10051                                  	
 10052                                  
 10053                                  	XOR	CH,CH			;F.C. >32mb				;AN000;
 10054                                  	;mov	bx,[si+8]
 10055                                  	mov	bx,[si+A_BPB.BIGTOTALSECTORS-A_BPB.SECTORSPERTRACK] ; 01/01/2024 (temporary)
 10056                                  	;MOV	BX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK]	;AN000;
 10057                                  	;mov	dx,[si+10]
 10058                                  	mov	dx,[si+A_BPB.BIGTOTALSECTORS-A_BPB.SECTORSPERTRACK+2] ; 01/01/2024 (temporary)
 10059                                  	;MOV	DX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK+2]	;AN000;
 10060                                  	SUB	BX,AX			;AN000;;F.C. >32mb
 10061                                  	SBB	DX,0			;AN000;;F.C. >32mb
 10062                                  	OR	CX,CX			;AN000;;F.C. >32mb
 10063                                  	JZ	short norot		;AN000;;F.C. >32mb
 10064                                  rott:					;AN000;;F.C. >32mb
 10065                                  	CLC				;AN000;;F.C. >32mb
 10066                                  	RCR	DX,1			;AN000;;F.C. >32mb
 10067                                  	RCR	BX,1			;AN000;;F.C. >32mb
 10068                                  	LOOP	rott			;AN000;;F.C. >32mb
 10069                                  norot:					;AN000;
 10070                                  	; 15/12/2022
 10071                                  	;MOV	AX,BX			;AN000;;F.C. >32mb
 10072                                  	JMP	short setend		;AN000;;F.C. >32mb
 10073                                  normal_dpb:
 10074                                  	;;sub	ax,[es:bp+0Dh]
 10075                                  	;SUB	AX,[ES:BP+DSKSIZ]
 10076                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10077                                  	; 15/12/2022
 10078                                  	; bx = [es:bp+DSKSIZ]
 10079                                  	;sub	ax,bx ; 28/07/2019
 10080                                  	;;SUB	AX,[ES:BP+DSKSIZ]
 10081                                  	; 15/12/2022
 10082                                  	sub	bx,ax
 10083                                  	;NEG	AX			; Sectors in data area
 10084                                  ;;	MOV	CL,BL			; dpb_cluster_shift
 10085                                  	; 15/12/2022
 10086                                  	; CL = cluster shift
 10087                                  	; BX = number of data sectors 
 10088                                  	;SHR	AX,CL			; Div by sectors/cluster
 10089                                  	shr	bx,cl 
 10090                                  setend:
 10091                                  ;	M008 - CAS
 10092                                  ;
 10093                                  	; 15/12/2022
 10094                                  	inc	bx
 10095                                  	;INC	AX			; +2 (reserved), -1 (count -> max)
 10096                                  ;
 10097                                  ;	There has been a bug in our fatsize calculation for so long
 10098                                  ;	  that we can't correct it now without causing some user to
 10099                                  ;	  experience data loss. There are even cases where allowing
 10100                                  ;	  the number of clusters to exceed the fats is the optimal
 10101                                  ;	  case -- where adding 2 more fat sectors would make the
 10102                                  ;	  data field smaller so that there's nothing to use the extra
 10103                                  ;	  fat sectors for.
 10104                                  ;
 10105                                  ;	Note that this bug had very minor known symptoms. CHKDSK would
 10106                                  ;	  still report that there was a cluster left when the disk was
 10107                                  ;	  actually full. Very graceful failure for a corrupt system
 10108                                  ;	  configuration. There may be worse cases that were never
 10109                                  ;	  properly traced back to this bug. The problem cases only
 10110                                  ;	  occurred when partition sizes were very near FAT sector
 10111                                  ;	  rounding boundaries, which were rare cases.
 10112                                  ;
 10113                                  ;	Also, it's possible that some third-party partition program might
 10114                                  ;	  create a partition that had a less-than-perfect FAT calculation
 10115                                  ;	  scheme. In this hypothetical case, the number of allocation
 10116                                  ;	  clusters which don't actually have FAT entries to represent
 10117                                  ;	  them might be larger and might create a more catastrophic
 10118                                  ;	  failure. So we'll provide the safeguard of limiting the
 10119                                  ;	  max_cluster to the amount that will fit in the FATs.
 10120                                  ;
 10121                                  ;	ax = maximum legal cluster, ES:BP -> dpb
 10122                                  
 10123                                  ;	make sure the number of fat sectors is actually enough to
 10124                                  ;	  hold that many clusters. otherwise, back the number of
 10125                                  ;	  clusters down
 10126                                  
 10127                                  	; 15/12/2022
 10128                                  	; bx = number of clusters
 10129                                  
 10130                                  	; 19/07/2018 - Retro DOS v3.0
 10131                                  	; MSDOS 6.0
 10132                                  	; 15/12/2022
 10133                                  	;mov	bx,ax			; remember calculated # clusters
 10134                                  
 10135                                  	; 01/08/2018 (MSDOS 3.3)
 10136                                  	;mov	al,[ES:BP+DPB.FAT_SIZE]
 10137                                  	;xor	ah,ah 
 10138                                  
 10139                                  	; 10/05/2019 - Retro DOS v4.0
 10140                                  	;mov	ax,[ES:BP+0Fh]
 10141                                  	mov	ax,[ES:BP+DPB.FAT_SIZE]
 10142                                  
 10143                                  	;mul	word [es:bp+2]	
 10144                                  	mul	word [ES:BP+DPB.SECTOR_SIZE] ; how big is the FAT?
 10145                                  	cmp	bx,4096-10  ; 0FF6h	; test for 12 vs. 16 bit fat
 10146                                  	jb	short setend_fat12
 10147                                  	shr	dx,1
 10148                                  
 10149                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10150                                  	; 15/12/2022
 10151                                  ;cs3 7/2/92
 10152                                  	jnz	short setend_faterr	; some bonehead gave us more fatspace
 10153                                  					; than enough for the maximum FAT,
 10154                                  					; so go ahead and use the calculated
 10155                                  					; number of clusters.
 10156                                  ;cs3 7/2/92
 10157                                  
 10158                                  	rcr	ax,1			; find number of entries
 10159                                  	cmp	ax,4096-10+1		; would this truncation move us
 10160                                  ;					;  into 12-bit fatland?
 10161                                  	jb	short setend_faterr	; then go ahead and let the
 10162                                  ;					;  inconsistency pass through
 10163                                  ;					;  rather than lose data by
 10164                                  ;					;  correcting the fat type
 10165                                  	jmp	short setend_fat16
 10166                                  
 10167                                  setend_fat12:
 10168                                  	add	ax,ax			; (fatsiz*2)/3 = # of fat entries
 10169                                  	adc	dx,dx
 10170                                  
 10171                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10172                                  ;cs3 7/2/92
 10173                                  	; 15/12/2022
 10174                                  	cmp	dx,3			; if our fatspace is WAY more than
 10175                                  	jnb	short setend_faterr	; we need, we may get an overflow
 10176                                  					; here. Check for it and use
 10177                                  					; the calculated size in this case.
 10178                                  ;cs3 7/2/92
 10179                                  
 10180                                  	div	word [cs:word3]
 10181                                  
 10182                                  setend_fat16:
 10183                                  	dec	ax			; limit at 1
 10184                                  	cmp	ax,bx			; is fat big enough?
 10185                                  	jbe	short setend_fat	; use max value that'll fit
 10186                                  
 10187                                  setend_faterr:
 10188                                  	mov	ax,bx			; use calculated value
 10189                                  
 10190                                  setend_fat:
 10191                                  
 10192                                  ;	now ax = maximum legal cluster
 10193                                  
 10194                                  ;	end M008
 10195                                  
 10196                                  
 10197                                  	;mov	[es:bp+0Dh], ax
 10198                                  	MOV	[ES:BP+DPB.MAX_CLUSTER],AX
 10199                                  
 10200                                  	;;mov	word [es:bp+1Ch],0  ; MSDOS 3.3
 10201                                  	;mov	word [es:bp+1Dh],0  ; MSDOS 6.0
 10202                                  	MOV	word [ES:BP+DPB.NEXT_FREE],0 
 10203                                  					; Init so first ALLOC starts at
 10204                                  					; begining of FAT
 10205                                  	;;mov	word [es:bp+1Eh],-1 ; MSDOS 3.3
 10206                                  	;mov	word [es:bp+1Fh],-1 ; MSDOS 6.0
 10207                                  	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; current count is invalid.
 10208                                  
 10209                                  	retn
 10210                                  
 10211                                  %else
 10212                                  	; 13/01/2024 - Retro DOS v5.0
 10213                                  	;;;
 10214 000014ED 31D2                    	xor	dx,dx ; 0
 10215 000014EF 09C0                    	or	ax,ax
 10216 000014F1 750C                    	jnz	short savlog1	; 16 bit FAT size
 10217 000014F3 5A                      	pop	dx		; (*) FAT32 extensions
 10218                                  				; (use 32 bit FAT and Root Dir size if >0)
 10219 000014F4 52                      	push    dx		; (*)
 10220 000014F5 09D2                    	or	dx,dx
 10221 000014F7 7406                    	jz	short savlog1	; Do not use FAT32 extensions
 10222                                  				; (do not use 32 bit FAT size field)
 10223 000014F9 8B440C                  	mov	ax,[si+12]	; .BPB_SECTORSPERFAT32 ; BPB_FATSz32
 10224 000014FC 8B540E                  	mov	dx,[si+14]	; .BPB_SECTORSPERFAT32+2
 10225                                  savlog1:
 10226 000014FF 51                      	push    cx		; (**) Root directory sectors
 10227 00001500 89C1                    	mov	cx,ax		; 32 bit multiply
 10228 00001502 88F8                    	mov	al,bh		; FAT count
 10229 00001504 30E4                    	xor	ah,ah
 10230 00001506 F7E2                    	mul	dx
 10231 00001508 91                      	xchg    ax,cx
 10232 00001509 88FA                    	mov	dl,bh		; FAT count
 10233 0000150B 30F6                    	xor	dh,dh
 10234 0000150D F7E2                    	mul	dx
 10235 0000150F 01CA                    	add	dx,cx
 10236 00001511 59                      	pop	cx		; (**)
 10237 00001512 39D0                    	cmp	ax,dx
 10238 00001514 7504                    	jne	short savlog2
 10239                                  
 10240                                  	; 13/01/2024
 10241                                  	;or	ax,ax
 10242                                  	;jnz	short savlog2
 10243                                  
 10244                                  	; 13/01/2024 (not necessary)
 10245                                  	;inc	di
 10246                                  	;inc	di
 10247                                  	; di = 	DPB.DRIVER_ADDR	
 10248                                  
 10249                                  	;jmp	short setend
 10250                                  
 10251                                  	; 13/01/2024
 10252 00001516 09C0                    	or	ax,ax
 10253 00001518 744D                    	jz	short setend
 10254                                  
 10255                                  savlog2:
 10256 0000151A 26034606                	add	ax,[es:bp+DPB.FIRST_FAT]
 10257                                  	;add	ax,[es:bp+6]	; dx:ax = (total) FAT sectors
 10258 0000151E 83D200                  	adc	dx,0
 10259 00001521 AB                      	stosw			; DPB.DIR_SECTOR
 10260 00001522 01C8                    	add	ax,cx		; + root directory size
 10261 00001524 2689460B                	mov	[es:bp+DPB.FIRST_SECTOR],ax
 10262                                  	;mov	[es:bp+11],ax	; DPB.FIRST_SECTOR ; First data sector
 10263 00001528 83D200                  	adc	dx,0
 10264 0000152B 59                      	pop	cx		; (*)
 10265 0000152C 51                      	push    cx
 10266 0000152D E308                    	jcxz    savlog3
 10267 0000152F 26894629                	mov	[es:bp+DPB.FCLUS_FSECTOR],ax
 10268                                  	;mov	[es:bp+41],ax	; DPB.BIG_FIRST_SECTOR ; FAT32 first sector field
 10269 00001533 2689562B                	mov	[es:bp+DPB.FCLUS_FSECTOR+2],dx
 10270                                  	;mov	[es:bp+43],dx
 10271                                  savlog3: 
 10272 00001537 88D9                    	mov	cl,bl		; cluster shift
 10273 00001539 26837E0D00              	cmp	word [es:bp+DPB.MAX_CLUSTER],0
 10274                                  	;cmp	word [es:bp+13],0 ; DPB.MAX_CLUSTER
 10275                                  				; (contains 16 bit .BPB_TOTALSECTORS as temporary)
 10276 0000153E 751D                    	jnz	short normal_dpb
 10277 00001540 30ED                    	xor	ch,ch
 10278 00001542 52                      	push    dx	; (**)
 10279 00001543 8B5C08                  	mov	bx,[si+8]	; SI points to .BPB_SECTORSPERTRACK and SI+8 is
 10280                                  				; .BPB_BIGTOTALSECTORS (32 bit total sectors)
 10281 00001546 8B540A                  	mov	dx,[si+10]
 10282 00001549 29C3                    	sub	bx,ax
 10283 0000154B 58                      	pop	ax	; (**)
 10284 0000154C 19C2                    	sbb	dx,ax		; dx:bx = data sectors (for cluster count calc)
 10285 0000154E 09C9                    	or	cx,cx
 10286 00001550 7407                    	jz	short norot
 10287                                  rott:
 10288 00001552 F8                      	clc
 10289 00001553 D1DA                    	rcr	dx,1
 10290 00001555 D1DB                    	rcr	bx,1
 10291 00001557 E2F9                    	loop    rott
 10292                                  norot:
 10293 00001559 89D8                    	mov	ax,bx		; dx:ax = cluster count
 10294 0000155B EB0A                    	jmp	short setend
 10295                                  
 10296                                  normal_dpb:
 10297 0000155D 262B460D                	sub	ax,[es:bp+DPB.MAX_CLUSTER]
 10298                                  	;sub	ax,[es:bp+13]	; first sector - total sectors
 10299 00001561 31D2                    	xor	dx,dx
 10300 00001563 F7D8                    	neg	ax		; data sectors = total sectors - first sector
 10301 00001565 D3E8                    	shr	ax,cl		; cluster count
 10302                                  
 10303                                  setend:
 10304                                  	; 13/01/2024 (PCDOS 7.1 IBMDOS.COM)
 10305 00001567 59                      	pop	cx		; (*) 0 = not 32 bit fat sectors
 10306 00001568 51                      	push	cx		; (*)
 10307                                  	
 10308                                  	; 13/01/2024
 10309                                  	; (PCDOS 7.1 IBMDOS.COM BUGfix)
 10310 00001569 31D2                    	xor	dx,dx ; 0
 10311                                  	; si = BIOS Parameter Block + 13
 10312                                  	
 10313                                  	; 13/01/2024 (PCDOS 7.1 IBMDOS.COM)
 10314 0000156B 83C001                  	add	ax,1
 10315 0000156E 83D200                  	adc	dx,0			; calculated # clusters HW
 10316 00001571 89C3                    	mov	bx,ax			; calculated # clusters LW
 10317 00001573 268B460F                	mov	ax,[es:bp+DPB.FAT_SIZE]
 10318                                  	;mov	ax,[es:bp+15]		; FAT size (16 bit)
 10319 00001577 E30C                    	jcxz	setend1			; Do not use 32 bit FAT sectors field
 10320 00001579 31C9                    	xor	cx,cx
 10321 0000157B 09C0                    	or	ax,ax
 10322 0000157D 7506                    	jnz	short setend1
 10323 0000157F 8B440C                  	mov	ax,[si+12]		; .BPB_SECTORSPERFAT32  ; 32 bit FAT size field.
 10324 00001582 8B4C0E                  	mov	cx,[si+14]		; .BPB_SECTORSPERFAT32+2
 10325                                  setend1:
 10326 00001585 52                      	push    dx	; (**)		; cx:ax = FAT size (in sectors)
 10327                                  					; dx:bx = calculated number of clusters
 10328 00001586 91                      	xchg    ax,cx
 10329 00001587 26F76602                	mul	word [es:bp+DPB.SECTOR_SIZE]
 10330                                  	;mul	word [es:bp+2]		; DPB.SECTOR_SIZE
 10331 0000158B 91                      	xchg    ax,cx
 10332 0000158C 26F76602                	mul	word [es:bp+DPB.SECTOR_SIZE]
 10333                                  	;mul	word [es:bp+2]
 10334 00001590 01CA                    	add	dx,cx			; dx:ax = FAT size in bytes
 10335 00001592 59                      	pop	cx	; (**)		; calculated # clusters HW
 10336 00001593 09C9                    	or	cx,cx
 10337 00001595 7506                    	jnz	short setend2		; FAT32
 10338 00001597 81FBF60F                	cmp	bx,0FF6h
 10339 0000159B 721E                    	jb	short setend_fat12	; FAT12
 10340                                  setend2:
 10341                                  	; (PCDOS 7.1 IBMDOS.COM BUGfix)
 10342                                  	;or	cx,cx			; HW of calculated cluster count
 10343                                  	;jnz	short setend3
 10344 0000159D 83FBF6                  	cmp	bx,0FFF6h
 10345 000015A0 720C                    	jb	short setend4		; FAT16
 10346                                  setend3:
 10347 000015A2 D1EA                    	shr	dx,1			; FAT32 ; 4 byte (32 bit) cluster number
 10348                                  					; fatsiz/4 = # of fat entries
 10349 000015A4 D1D8                    	rcr	ax,1
 10350 000015A6 D1EA                    	shr	dx,1
 10351 000015A8 7408                    	jz	short setend5		; dx = 0
 10352 000015AA D1D8                    	rcr	ax,1
 10353 000015AC EB1B                    	jmp	short setend_fat16
 10354                                  
 10355                                  setend4:
 10356 000015AE D1EA                    	shr	dx,1			; FAT16 ; 2 byte (16 bit) cluster number
 10357                                  					; fatsiz/2 = # of fat entries
 10358 000015B0 7525                    	jnz	short setend_faterr ; dx > 0
 10359                                  setend5:
 10360 000015B2 D1D8                    	rcr	ax,1			; FAT16 ; 2 byte (16 bit) cluster number
 10361                                  					; fatsiz/2 = # of fat entries
 10362 000015B4 3DF70F                  	cmp	ax,0FF7h		; 4096-10+1
 10363 000015B7 721E                    	jb	short setend_faterr
 10364 000015B9 EB0E                    	jmp	short setend_fat16
 10365                                  
 10366                                  setend_fat12:
 10367 000015BB 01C0                    	add	ax,ax			; FAT12 ; 1.5 byte (12 bit) cluster number
 10368                                  					; (fatsiz*2)/3 = # of fat entries
 10369 000015BD 11D2                    	adc	dx,dx
 10370 000015BF 83FA03                  	cmp	dx,3			; if our fatspace is more than we need
 10371                                  					; use calculated size
 10372 000015C2 7313                    	jnb	short setend_faterr
 10373 000015C4 2EF736[7914]            	div	word [cs:word3]
 10374                                  setend_fat16:
 10375 000015C9 83E801                  	sub	ax,1
 10376 000015CC 83DA00                  	sbb	dx,0
 10377 000015CF 39CA                    	cmp	dx,cx			; is fat big enough?
 10378 000015D1 7704                    	ja	short setend_faterr
 10379 000015D3 39D8                    	cmp	ax,bx
 10380 000015D5 7604                    	jbe	short setend_fat32	; use max value that'll fit
 10381                                  setend_faterr:
 10382 000015D7 89D8                    	mov	ax,bx			; use calculated value
 10383 000015D9 89CA                    	mov	dx,cx
 10384                                  setend_fat32:
 10385 000015DB 26837E0F00              	cmp	word [es:bp+DPB.FAT_SIZE],0
 10386                                  	;cmp	word [es:bp+15],0	; DPB.FAT_SIZE ; 16 bit FAT size
 10387 000015E0 750E                    	jnz	short setend6
 10388 000015E2 26C74611FFFF            	mov	word [es:bp+DPB.DIR_SECTOR],-1 
 10389                                  	;mov	word [es:bp+17],0FFFFh	; DPB.DIR_SECTOR
 10390                                  					; (16 bit directory sector field)
 10391 000015E8 26C7460D0000            	mov	word [es:bp+DPB.MAX_CLUSTER],0 
 10392                                  	;mov	word [es:bp+13],0	; DPB.MAX_CLUSTER (16 bit)
 10393 000015EE EB04                    	jmp	short setend7
 10394                                  
 10395                                  setend6:
 10396 000015F0 2689460D                	mov	[es:bp+DPB.MAX_CLUSTER],ax
 10397                                  	;mov	[es:bp+13],ax	; DPB.MAX_CLUSTER = calculated last cluster number
 10398                                  setend7:
 10399 000015F4 59                      	pop	cx	; (*)		; 1 = use FAT32 extensions
 10400                                  					; 0 = don't use FAT32 extensions (32 bit fields)
 10401 000015F5 E353                    	jcxz	setend_fat		; do not use FAT32 extensions
 10402                                  	;mov	[es:bp+45],ax		; DPB.MAX_CLUSTER32 ; dx:ax = last cluster number
 10403                                  	;mov	[es:bp+47],dx
 10404 000015F7 2689462D                	mov	[es:bp+DPB.LAST_CLUSTER],ax
 10405 000015FB 2689562F                	mov	[es:bp+DPB.LAST_CLUSTER+2],dx
 10406 000015FF B8FFFF                  	mov	ax,0FFFFh ; -1
 10407 00001602 8D7E21                  	lea	di,[bp+DPB.FREE_CNT_HW]
 10408                                  	;lea	di,[bp+33]		; DPB.FAT32_EXT ; FAT32 extensions
 10409                                  					; -1 = ready
 10410 00001605 AB                      	stosw
 10411 00001606 8D7410                  	lea	si,[si+16]		; FAT32 flags
 10412 00001609 A5                      	movsw	   			; DPB FAT32 flags ; [bp+23h]
 10413 0000160A 83C606                  	add	si,6
 10414 0000160D AD                      	lodsw				; FSINFO structure sector number
 10415 0000160E 8B54DC                  	mov	dx,[si-24h]		; .BPB_RESERVEDSECTORS ; Number of reserved sectors.
 10416 00001611 09C0                    	or	ax,ax
 10417 00001613 7404                    	jz	short setend8
 10418 00001615 39D0                    	cmp	ax,dx
 10419 00001617 7203                    	jb	short setend9
 10420                                  setend8:
 10421 00001619 B8FFFF                  	mov	ax,0FFFFh ; -1		; invalid
 10422                                  setend9:
 10423 0000161C AB                      	stosw				; DPB FSINFO structure sector number
 10424                                  					; [bp+25h]
 10425 0000161D AD                      	lodsw				; Sector number of the backup boot sector
 10426 0000161E 09C0                    	or	ax,ax
 10427 00001620 7404                    	jz	short setend10
 10428 00001622 39D0                    	cmp	ax,dx
 10429 00001624 7203                    	jb	short setend11
 10430                                  setend10:
 10431 00001626 B8FFFF                  	mov	ax,0FFFFh ; -1		; invalid
 10432                                  setend11:
 10433 00001629 AB                      	stosw	   			; DPB backup boot sector address
 10434                                  					; [bp+27h]
 10435 0000162A 83C708                  	add	di,8			; [bp+31h]
 10436 0000162D 31D2                    	xor	dx,dx
 10437 0000162F 268B45DE                	mov	ax,[es:di-34]		; [bp+0Fh] ; DPB.MAX_CLUSTER
 10438 00001633 39D0                    	cmp	ax,dx
 10439 00001635 7506                    	jnz	short setend12		; > 0 (not FAT32)
 10440 00001637 8B44F0                  	mov	ax,[si-16]		; FAT32 Sectors per FAT ; .BPB_SECTORSPERFAT32
 10441 0000163A 8B54F2                  	mov	dx,[si-14]
 10442                                  setend12:
 10443 0000163D AB                      	stosw				; DPB FAT32 FAT size in sectors ; [bp+31h]
 10444 0000163E 89D0                    	mov	ax,dx
 10445 00001640 AB                      	stosw
 10446 00001641 83EE08                  	sub	si,8			; Root directory cluster number
 10447 00001644 A5                      	movsw				; DPB Root Dir Cluster ; [bp+35h]
 10448 00001645 A5                      	movsw
 10449 00001646 31C0                    	xor	ax,ax			; DPB reserved ; [bp+39h]
 10450 00001648 AB                      	stosw
 10451 00001649 AB                      	stosw	
 10452                                  %endif
 10453                                  	;;;
 10454                                  
 10455                                  setend_fat:
 10456                                  
 10457                                  	; 13/01/2024 - Retro DOS v5.0
 10458 0000164A 31C0                    	xor	ax,ax ; 0
 10459                                  
 10460                                  	;mov	word [es:bp+1Dh],ax ; 0
 10461 0000164C 2689461D                	mov	word [es:bp+DPB.NEXT_FREE],ax ; 0 
 10462                                  					; Init so first ALLOC starts at
 10463                                  					; begining of FAT
 10464 00001650 48                      	dec	ax  ; -1
 10465                                  	;mov	word [es:bp+1Fh],ax ; -1
 10466 00001651 2689461F                	mov	word [es:bp+DPB.FREE_CNT],ax ; -1 ; current count is invalid.
 10467                                  
 10468 00001655 C3                      	retn
 10469                                  
 10470                                  ;EndProc $SETDPB
 10471                                  
 10472                                  ;BREAK <$Create_Process_Data_Block,SetMem -- Set up process data block>
 10473                                  
 10474                                  ;
 10475                                  ;----------------------------------------------------------------------------
 10476                                  ;
 10477                                  ;**	$Dup_PDB
 10478                                  ;
 10479                                  ; Inputs:   DX is new segment address of process
 10480                                  ;	    SI is end of new allocation block
 10481                                  ;
 10482                                  ;----------------------------------------------------------------------------
 10483                                  ;
 10484                                  	; 14/01/2024 - Retro DOS 5.0
 10485                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:554Fh
 10486                                  
 10487                                  _$DUP_PDB:
 10488                                  
 10489                                  ;hkn;	CreatePDB would have a CS override. This is not valid.
 10490                                  ;hkn;	Must set up ds in order to acess CreatePDB. Also SS is 
 10491                                  ;hkn;	has been assumed to be NOTHING. It may not have DOSDATA.
 10492                                  
 10493                                  	; MSDOS 3.3
 10494                                  	;MOV	byte [CS:CreatePDB],0FFh  ; indicate a new process
 10495                                  	;MOV	DS,[CS:CurrentPDB]
 10496                                  
 10497                                  	; 15/05/2019 - Retro DOS v4.0
 10498                                  	; MSDOS 6.0
 10499 00001656 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 10500 0000165B C606[A803]FF            	MOV	byte [CreatePDB],0FFh
 10501 00001660 8E1E[3003]              	MOV	DS,[CurrentPDB]
 10502                                  
 10503 00001664 56                      	PUSH	SI
 10504 00001665 EB0A                    	JMP	SHORT CreateCopy
 10505                                  
 10506                                  ;
 10507                                  ;----------------------------------------------------------------------------
 10508                                  ;
 10509                                  ; Inputs:
 10510                                  ;	DX = Segment number of new base
 10511                                  ; Function:
 10512                                  ;	Set up program base and copy term and ^C from int area
 10513                                  ; Returns:
 10514                                  ;	None
 10515                                  ; Called at DOS init
 10516                                  ;
 10517                                  ;----------------------------------------------------------------------------
 10518                                  ;
 10519                                  
 10520                                  ; 15/05/2019 - Retro DOS v4.0
 10521                                  ; DOSCODE:4EB6h (MSDOS 6.21, MSDOS.SYS)
 10522                                  
 10523                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10524                                  ; DOSCODE:4EA2h (MSDOS 5.0, MSDOS.SYS)
 10525                                  
 10526                                  _$CREATE_PROCESS_DATA_BLOCK:
 10527                                  			; Offset 1D02h in IBMDOS.COM (MSDOS 3.3), 1987
 10528 00001667 E80DEE                  	CALL	Get_User_Stack
 10529                                  	;mov	ds,[si+14h]
 10530 0000166A 8E5C14                  	MOV	DS,[SI+user_env.user_CS]
 10531                                  	;push	word [2]
 10532 0000166D FF360200                	PUSH	word [PDB.BLOCK_LEN] ;*
 10533                                  CreateCopy:
 10534 00001671 8EC2                    	MOV	ES,DX
 10535                                  
 10536 00001673 31F6                    	XOR	SI,SI			; copy entire PDB
 10537 00001675 89F7                    	MOV	DI,SI
 10538 00001677 B98000                  	MOV	CX,128
 10539 0000167A F3A5                    	REP	MOVSW
 10540                                  
 10541                                  ; DOS 3.3 7/9/86
 10542                                  	;mov	cx,20
 10543                                  	;MOV	CX,FILPERPROC		; copy handles in case of
 10544                                  	; 15/12/2022
 10545 0000167C B114                    	mov	cl,FILPERPROC ; 06/07/2019
 10546                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10547                                  	;mov	cx,FILPERPROC
 10548                                  
 10549                                  	;mov	di,18h
 10550 0000167E BF1800                  	MOV	DI,PDB.JFN_TABLE	; Set Handle Count has been issued
 10551                                  	;;PUSH	DS ; * 15/05/2019
 10552                                  	;;lds	si,[34h]
 10553                                  	;LDS	SI,[PDB.JFN_Pointer]
 10554                                  	;REP	MOVSB
 10555                                  	;;POP	DS ; * 15/05/2019
 10556                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10557                                  	; 05/12/2022
 10558                                  	; (push ds then pop ds is not needed here!)
 10559                                  	;push	ds
 10560                                  	;lds	si,[34h]
 10561 00001681 C5363400                	lds	si,[PDB.JFN_Pointer]
 10562 00001685 F3A4                    	rep	movsb
 10563                                  	;pop	ds
 10564                                  
 10565                                  ; DOS 3.3 7/9/86
 10566                                  	;hkn ;CreatePDB would have a CS override. This is not valid.
 10567                                  	;hkn ;Must set up ds in order to access CreatePDB. Also SS is 
 10568                                  	;hkn ;has been assumed to be NOTHING. It may not have DOSDATA.
 10569                                  
 10570 00001687 2E8E1E[0700]            	mov	ds,[cs:DosDSeg] ; 15/05/2019
 10571                                  
 10572                                  	;;test	byte [cs:CreatePDB],0FFh
 10573                                  	;cmp	byte [CS:CreatePDB],0	; Shall we create a process?
 10574                                  	; 17/12/2022
 10575 0000168C 380E[A803]              	cmp	[CreatePDB],cl ; 0
 10576                                  	;cmp	byte [CreatePDB],0 ; 15/05/2019
 10577 00001690 744A                    	JZ	short Create_PDB_cont 	; nope, old style call
 10578                                  
 10579                                  ; Here we set up for a new process...
 10580                                  
 10581                                  	;PUSH	CS			; Called at DOSINIT time, NO SS
 10582                                  	;POP	DS
 10583                                  
 10584                                  	; MSDOS 6.0
 10585                                  	;;getdseg <ds>			; ds -> dosdata
 10586                                  	;mov	ds,[cs:DosDSeg] ; 15/05/2019
 10587                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10588                                  	; (nonsense! but i put this for addr compatibility as temporary)
 10589                                  	; 15/12/2022
 10590                                  	;mov	ds,[cs:DosDSeg] ; 15/05/2019
 10591                                  
 10592 00001692 31DB                    	XOR	BX,BX			; dup all jfns
 10593                                  	;mov	cx,20
 10594                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10595                                  	;MOV	CX,FILPERPROC		; only 20 of them
 10596                                  	; 15/12/2022
 10597 00001694 B114                    	mov	cl,FILPERPROC ; 06/07/2019
 10598                                  
 10599                                  Create_dup_jfn:
 10600 00001696 06                      	PUSH	ES ;**			; save new PDB
 10601 00001697 E8F259                  	call	SFFromHandle		; get sf pointer
 10602 0000169A B0FF                    	MOV	AL,-1			; unassigned JFN
 10603 0000169C 7224                    	JC	short CreateStash	; file was not really open
 10604                                  	;;test	word [es:di+5],1000h
 10605                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_no_inherit
 10606                                  	; 15/05/2019
 10607                                  	;test	byte [es:di+6],10h
 10608 0000169E 26F6450610              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_no_inherit>>8)
 10609 000016A3 751D                    	JNZ	short CreateStash	; if no-inherit bit is set, skip dup.
 10610                                  
 10611                                  ; We do not inherit network file handles.
 10612                                  
 10613                                  	;mov	ah,[es:di+2]
 10614 000016A5 268A6502                	MOV	AH,[ES:DI+SF_ENTRY.sf_mode]
 10615                                  	;and	ah,0F0h
 10616 000016A9 80E4F0                  	AND	AH,SHARING_MASK
 10617                                  	;cmp	ah,70h
 10618 000016AC 80FC70                  	CMP	AH,SHARING_NET_FCB
 10619 000016AF 7411                    	jz	short CreateStash
 10620                                  
 10621                                  ; The handle we have found is duplicatable (and inheritable). Perform
 10622                                  ; duplication operation.
 10623                                  
 10624 000016B1 893E[9E05]              	MOV	[THISSFT],DI
 10625 000016B5 8C06[A005]              	MOV	[THISSFT+2],ES
 10626 000016B9 E81D1A                  	call	DOS_DUP 		; signal duplication
 10627                                  
 10628                                  ; get the old sfn for copy
 10629                                  
 10630 000016BC E8B059                  	call	pJFNFromHandle		; ES:DI is jfn
 10631 000016BF 268A05                  	MOV	AL,[ES:DI]		; get sfn
 10632                                  
 10633                                  ; Take AL (old sfn or -1) and stash it into the new position
 10634                                  
 10635                                  CreateStash:
 10636 000016C2 07                      	POP	ES ;**
 10637                                  	;mov	[es:bx+18h],al
 10638 000016C3 26884718                	MOV	[ES:BX+PDB.JFN_TABLE],AL ; copy into new place!
 10639 000016C7 43                      	INC	BX			; next jfn...
 10640 000016C8 E2CC                    	LOOP	Create_dup_jfn
 10641                                  
 10642 000016CA 8B1E[3003]              	MOV	BX,[CurrentPDB]		; get current process
 10643                                  	; 06/11/2022
 10644                                  	;mov	[es:16h],bx
 10645 000016CE 26891E1600              	MOV	[ES:PDB.PARENT_PID],BX	; stash in child
 10646 000016D3 8C06[3003]              	MOV	[CurrentPDB],ES
 10647                                  	;MOV	DS,BX ; 28/07/2019
 10648                                  	; 07/12/2022
 10649                                  	;mov	ds,[cs:DosDSeg]
 10650                                  	; 15/12/2022
 10651                                  	; ds = [cs:DosDSeg]
 10652 000016D7 C606[A803]00            	mov	byte [CreatePDB],0	; reset flag
 10653                                  	;mov	ds,bx
 10654                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10655                                  	; 15/12/2022
 10656                                  	;mov	ds,bx
 10657                                  
 10658                                  ; end of new process create
 10659                                  
 10660                                  Create_PDB_cont:
 10661                                  	;MOV	BYTE [CS:CreatePDB],0	; reset flag
 10662                                  
 10663                                  ;hkn; It comes to this point from 2 places. So, change to DOSDATA temporarily	
 10664                                  
 10665                                  	;; 28/07/2019
 10666                                  	;;push	ds
 10667                                  	;;mov	ds,[cs:DosDSeg]
 10668                                  	;mov	byte [CreatePDB],0
 10669                                  	;;pop	ds
 10670                                  
 10671                                  ; 05/12/2022
 10672                                  ;	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10673                                  ;	; (push-pop ds is nonsense here! 
 10674                                  ;	;  but i am using same code with original MSDOS.SYS
 10675                                  ;	;  for address compatibility.)
 10676                                  ;	push	ds
 10677                                  ;	; ds = [cs:DosDSeg] !
 10678                                  ;	mov	ds,[cs:DosDSeg]  ; again !
 10679                                  ;	mov	byte [CreatePDB],0
 10680                                  ;	pop	ds
 10681                                  
 10682 000016DC 58                      	POP	AX ;*
 10683                                  
 10684                                  	;entry	SETMEM
 10685                                  
 10686                                  	; 17/12/2022
 10687                                  	; cx = 0
 10688                                  
 10689                                  ;---------------------------------------------------------------------------
 10690                                  ; Inputs:
 10691                                  ;	AX = Size of memory in paragraphs
 10692                                  ;	DX = Segment
 10693                                  ; Function:
 10694                                  ;	Completely prepares a program base at the
 10695                                  ;	specified segment.
 10696                                  ; Called at DOS init
 10697                                  ; Outputs:
 10698                                  ;	DS = DX
 10699                                  ;	ES = DX
 10700                                  ;	[0] has INT int_abort
 10701                                  ;	[2] = First unavailable segment
 10702                                  ;	[5] to [9] form a long call to the entry point
 10703                                  ;	[10] to [13] have exit address (from int_terminate)
 10704                                  ;	[14] to [17] have ctrl-C exit address (from int_ctrl_c)
 10705                                  ;	[18] to [21] have fatal error address (from int_fatal_abort)
 10706                                  ; DX,BP unchanged. All other registers destroyed.
 10707                                  ;---------------------------------------------------------------------------
 10708                                  
 10709                                  SETMEM:
 10710                                  	;XOR	CX,CX
 10711                                  	; 17/12/2022
 10712                                  	; cx = 0
 10713 000016DD 8ED9                    	MOV	DS,CX
 10714 000016DF 8EC2                    	MOV	ES,DX
 10715                                  	;mov	si,88h
 10716 000016E1 BE8800                  	MOV	SI,addr_int_terminate
 10717                                  	;mov	di,10 ; 0Ah
 10718 000016E4 BF0A00                  	MOV	DI,SAVEXIT
 10719                                  	;MOV	CX,6
 10720                                  	; 15/12/2022
 10721 000016E7 B106                    	mov	cl,6
 10722 000016E9 F3A5                    	REP	MOVSW
 10723 000016EB 26A30200                	MOV	[ES:2],AX
 10724 000016EF 29D0                    	SUB	AX,DX
 10725 000016F1 3DFF0F                  	CMP	AX,MAXDIF ; 0FFFh
 10726 000016F4 7603                    	JBE	short HAVDIF
 10727 000016F6 B8FF0F                  	MOV	AX,MAXDIF
 10728                                  HAVDIF:
 10729 000016F9 83E810                  	SUB	AX,10h			; Allow for 100h byte "stack"
 10730 000016FC BB0C00                  	MOV	BX,ENTRYPOINTSEG ; 0Ch	;	in .COM files
 10731 000016FF 29C3                    	SUB	BX,AX
 10732 00001701 B104                    	MOV	CL,4
 10733 00001703 D3E0                    	SHL	AX,CL
 10734 00001705 8EDA                    	MOV	DS,DX
 10735                                  
 10736                                  	; (MSDOS 6.0 note)
 10737                                  	;
 10738                                  	; The address in BX:AX will be F01D:FEF0 if there is 64K or more 
 10739                                  	; memory in the system. This is equivalent to 0:c0 if A20 is OFF.
 10740                                  	; If DOS is in HMA this equivalence is no longer valid as A20 is ON.
 10741                                  	; But the BIOS which now resides in FFFF:30 has 5 bytes in FFFF:D0
 10742                                  	; (F01D:FEF0) which is the same as the ones in 0:C0, thereby 
 10743                                  	; making this equvalence valid for this particular case. If however
 10744                                  	; there is less than 64K remaining the address in BX:AX will not 
 10745                                  	; be the same as above. We will then stuff 0:c0, the call 5 address
 10746                                  	; into the PSP.
 10747                                  	;
 10748                                  	; Therefore for the case where there is less than 64K remaining in 
 10749                                  	; the system old CPM Apps that look at PSP:6 to determine memory
 10750                                  	; requirements will not work. Call 5, however will continue to work
 10751                                  	; for all cases.
 10752                                  	;
 10753                                  
 10754                                  	;mov	[6],ax
 10755                                  	;mov	[8],bx
 10756                                  
 10757 00001707 A30600                  	MOV	[PDB.CPM_CALL+1],AX
 10758 0000170A 891E0800                	MOV	[PDB.CPM_CALL+3],BX
 10759                                  
 10760                                  	; 06/05/2019 - Retro DOS v4.0
 10761 0000170E 3DF0FE                  	cmp	ax,WRAPOFFSET ; 0FEF0h	; Q: does the system have >= 64k of
 10762                                  					;    memory left
 10763 00001711 740C                    	je	short addr_ok		; Y: the above calculated address is
 10764                                  					;    OK
 10765                                  					; N: 
 10766                                  
 10767 00001713 C7060600C000            	MOV	WORD [PDB.CPM_CALL+1],0C0h
 10768 00001719 C70608000000            	MOV	WORD [PDB.CPM_CALL+3],0
 10769                                  addr_ok:
 10770                                  	;mov	word [0],20CDh
 10771 0000171F C7060000CD20            	MOV	word [PDB.EXIT_CALL],(int_abort*256) + mi_INT
 10772                                  	;mov	byte [5],9Ah
 10773 00001725 C60605009A              	MOV	BYTE [PDB.CPM_CALL],mi_Long_CALL
 10774                                  	;mov	word [50h],21CDh
 10775 0000172A C7065000CD21            	MOV	WORD [PDB.CALL_SYSTEM],(int_command*256) + mi_INT
 10776                                  	;mov	byte [52h],0CBh
 10777 00001730 C6065200CB              	MOV	BYTE [PDB.CALL_SYSTEM+2],mi_Long_RET
 10778                                  	;mov	word [34h],18h
 10779 00001735 C70634001800            	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE
 10780                                  	;mov	word [36h],ds
 10781 0000173B 8C1E3600                	MOV	WORD [PDB.JFN_Pointer+2],DS
 10782                                  	;mov	word [32h],20
 10783 0000173F C70632001400            	MOV	WORD [PDB.JFN_Length],FILPERPROC
 10784                                  ;
 10785                                  ; The server runs several PDB's without creating them VIA EXEC.  We need to
 10786                                  ; enumerate all PDB's at CPS time in order to find all references to a
 10787                                  ; particular SFT.  We perform this by requiring that the server link together
 10788                                  ; for us all sub-PDB's that he creates. The requirement for us, now, is to
 10789                                  ; initialize this pointer.
 10790                                  ;
 10791                                   	;mov	word [38h],-1
 10792 00001745 C7063800FFFF            	MOV	word [PDB.Next_PDB],-1
 10793                                  	;mov	word [3Ah],-1
 10794 0000174B C7063A00FFFF            	MOV	word [PDB.Next_PDB+2],-1
 10795                                  
 10796                                  	; 06/05/2019
 10797                                  	; Set the real version number in the PSP - 5.00
 10798                                  
 10799                                  	;mov	word [es:PDB.Version],1406h ; MSDOS 6.21 (DOSCODE:4FB6h)
 10800                                  	; 07/12/2022
 10801 00001751 26C7064000070A          	mov	word [ES:PDB.Version],(MINOR_VERSION*256)+MAJOR_VERSION
 10802                                  
 10803 00001758 C3                      	retn
 10804                                  
 10805                                  ; 29/04/2019 - Retro DOS v4.0
 10806                                  
 10807                                  ;BREAK <$GSetMediaID -- get set media ID>
 10808                                  
 10809                                  ;---------------------------------------------------------------------------
 10810                                  ; Inputs:
 10811                                  ;	BL= drive number as defined in IOCTL
 10812                                  ;	AL= 0 get media ID
 10813                                  ;	    1 set media ID
 10814                                  ;	DS:DX= buffer containing information
 10815                                  ;		DW  0  info level (set on input)
 10816                                  ;		DD  ?  serial #
 10817                                  ;		DB  11 dup(?)  volume id
 10818                                  ;		DB   8 dup(?)  file system type
 10819                                  ; Function:
 10820                                  ;	Get or set media ID
 10821                                  ; Returns:
 10822                                  ;	carry clear, DS:DX is filled
 10823                                  ;	carry set, error
 10824                                  ;---------------------------------------------------------------------------
 10825                                  
 10826                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10827                                  
 10828                                  ; 14/01/2024
 10829                                  %if 0
 10830                                  
 10831                                  _$GSetMediaID:
 10832                                  	; RAWIO - GET_MEDIA_ID
 10833                                  	mov	cx,0866h	      ;AN000;MS.; assume get for IOCTL
 10834                                  	cmp	al,0		      ;AN001;MS.; get ?
 10835                                  	je	short doioctl 	      ;AN000;MS.; yes
 10836                                  	;cmp	al,1		      ;AN000;MS.; set ?
 10837                                  	;jne	short errorfunc	      ;AN000;MS.; no
 10838                                  	; 15/12/2022
 10839                                  	dec	al
 10840                                  	jnz	short errorfunc ; al > 1
 10841                                  	; RAWIO - SET_MEDIA_ID
 10842                                  	;mov	cx,0846h	      ;AN001;MS.;
 10843                                  	; 15/12/2022
 10844                                  	mov	cl,46h	; cx = 0846h
 10845                                  doioctl:			      ;AN000;
 10846                                  	mov	al,0Dh		      ;AN000;MS.; generic IOCTL
 10847                                  	;invoke	$IOCTL		      ;AN000;MS.; let IOCTL take care of it
 10848                                  	;call	_$IOCTL
 10849                                  	;retn			      ;AN000;MS.;
 10850                                  	; 15/12/2022
 10851                                  	jmp	_$IOCTL
 10852                                  errorfunc:			      ;AN000;
 10853                                  	;error	error_invalid_function;AN000;MS. ; invalid function
 10854                                  	;mov	al,1
 10855                                  	mov	al,error_invalid_function
 10856                                  	jmp	SYS_RET_ERR
 10857                                  
 10858                                  %else
 10859                                  	; 14/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 10860                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:5667h
 10861                                  
 10862                                  _$GSetMediaID:
 10863 00001759 1E                      	push	ds
 10864 0000175A 56                      	push	si
 10865 0000175B 36C536[A205]            	lds	si,[ss:THISCDS]
 10866 00001760 C57445                  	lds	si,[si+45h]		; [si+curdir.devptr]
 10867                                  					; local pointer to DPB or net device
 10868 00001763 8B740F                  	mov	si,[si+0Fh]		; [si+DPB.FAT_SIZE]
 10869 00001766 B96608                  	mov	cx,0866h		; assume get for IOCTL
 10870 00001769 3C01                    	cmp	al,1			; set ?
 10871 0000176B 7208                    	jb	short doioctl1		; get
 10872 0000176D 7733                    	ja	short errorfunc		; invalid
 10873 0000176F B146                    	mov	cl,46h	; cx = 0846h
 10874                                  	;or	si,si
 10875 00001771 21F6                    	and	si,si ; 14/01/2024
 10876 00001773 7424                    	jz	short doioctl2
 10877                                  doioctl1:
 10878 00001775 09F6                    	or	si,si
 10879 00001777 7522                    	jnz	short doioctl
 10880 00001779 1F                      	pop	ds
 10881 0000177A 1E                      	push	ds
 10882 0000177B 89D6                    	mov	si,dx	; disk info
 10883                                  			; .................................
 10884                                  			;
 10885                                  			; 00h    WORD    0000h (info level)
 10886                                  			; 02h    DWORD   disk serial number (binary)
 10887                                  			; 06h 11 BYTEs   volume label or "NO NAME    " if none present
 10888                                  			; 11h  8 BYTEs   (AL=00h only) filesystem type
 10889                                  			;		"FAT12   "
 10890                                  			;		"FAT16   "
 10891                                  			;		"FAT32   " ; PCDOS 7.1
 10892                                  			;		"CDROM   "
 10893                                  			;		"CD001   " 
 10894                                  			;		"CDAUDIO "
 10895                                  			; .................................
 10896                                  			; (ref: Ralf Brown's Interrupt List) 		
 10897                                  
 10898 0000177D 817C114641              	cmp	word [si+11h],4146h ; 'FA'
 10899 00001782 7517                    	jne	short doioctl
 10900 00001784 817C135433              	cmp	word [si+13h],3354h ; 'T3'
 10901 00001789 7510                    	jne	short doioctl
 10902 0000178B 817C153220              	cmp     word [si+15h],2032h ; '2 '
 10903 00001790 7509                    	jne	short doioctl
 10904 00001792 817C172020              	cmp	word [si+17h],2020h ; '  '
 10905 00001797 7502                    	jne	short doioctl
 10906                                  doioctl2:
 10907 00001799 B548                    	mov	ch,48h	; cx = 4846h
 10908                                  doioctl:
 10909 0000179B 5E                      	pop	si
 10910 0000179C 1F                      	pop	ds
 10911 0000179D B00D                    	mov	al,0Dh			; generic IOCTL
 10912                                  	;call	_$IOCTL
 10913                                          ;retn
 10914 0000179F E90C11                  	jmp	_$IOCTL			; let IOCTL take care of it
 10915                                  
 10916                                  errorfunc:
 10917 000017A2 B001                    	mov	al,1			; error_invalid_function
 10918 000017A4 E9D3EE                  	jmp	SYS_RET_ERR
 10919                                  
 10920                                  %endif
 10921                                  
 10922                                  ; 16/05/2019 - Retro DOS v4.0
 10923                                  
 10924                                  ;============================================================================
 10925                                  ; MISC2.ASM, MSDOS 6.0, 1991
 10926                                  ;============================================================================
 10927                                  ; 20/07/2018 - Retro DOS v3.0
 10928                                  ; 29/04/2019 - Retro DOS v4.0
 10929                                  
 10930                                  ; Break <STRCMP - compare two ASCIZ strings DS:SI to ES:DI>
 10931                                  ;----------------------------------------------------------------------------
 10932                                  ;
 10933                                  ;   Strcmp - compare ASCIZ DS:SI to ES:DI. Case INSENSITIVE. '/' = '\'
 10934                                  ;	     Strings of different lengths don't match.
 10935                                  ;   Inputs:  DS:SI - pointer to source string  ES:DI - pointer to dest string
 10936                                  ;   Outputs: Z if strings same, NZ if different
 10937                                  ;   Registers modified: NONE
 10938                                  ;----------------------------------------------------------------------------
 10939                                  
 10940                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10941                                  
 10942                                  	; 14/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 10943                                  	; (PCDOS 7.1 IBMDOS.COM DOSCODE:56B6h)
 10944                                  	; (MSDOS 6.22 MSDOS.SYS DOSCODE:4FD7h)
 10945                                  StrCmp:
 10946 000017A7 56                      	push	si
 10947 000017A8 57                      	push	di
 10948 000017A9 50                      	push	ax
 10949                                  Cmplp:
 10950 000017AA AC                      	LODSB
 10951 000017AB E87742                  	call	UCase			; convert to upper case
 10952 000017AE E8C942                  	call	PATHCHRCMP		; convert '/' to '\' ; 07/12/2022 ('\')
 10953 000017B1 88C4                    	MOV	AH,AL
 10954 000017B3 268A05                  	MOV	AL,[ES:DI]
 10955 000017B6 47                      	INC	DI
 10956 000017B7 E86B42                  	call	UCase			; convert to upper case
 10957 000017BA E8BD42                  	call	PATHCHRCMP		; convert '/' to '\' ; 07/12/2022 ('\')
 10958 000017BD 38C4                    	CMP	AH,AL
 10959 000017BF 7504                    	JNZ	short PopRet		; Strings dif
 10960                                  
 10961 000017C1 08C0                    	OR	AL,AL
 10962 000017C3 75E5                    	JNZ	short Cmplp		; More string
 10963                                  PopRet:
 10964 000017C5 58                      	pop	ax
 10965 000017C6 5F                      	pop	di
 10966 000017C7 5E                      	pop	si
 10967 000017C8 C3                      	retn
 10968                                  
 10969                                  ;Break <STRCPY - copy ASCIZ string from DS:SI to ES:DI>
 10970                                  ;----------------------------------------------------------------------------
 10971                                  ;
 10972                                  ;   Strcpy - copy an ASCIZ string from DS:SI to ES:DI and make uppercase
 10973                                  ;   FStrcpy - copy an ASCIZ string from DS:SI to ES:DI. no modification of
 10974                                  ;	characters.
 10975                                  ;
 10976                                  ;   Inputs:	DS:SI - pointer to source string
 10977                                  ;		ES:DI - pointer to destination string
 10978                                  ;   Outputs:	ES:DI point byte after nul byte at end of dest string
 10979                                  ;		DS:SI point byte after nul byte at end of source string
 10980                                  ;   Registers modified: SI,DI
 10981                                  ;----------------------------------------------------------------------------
 10982                                  
 10983                                  StrCpy:
 10984 000017C9 50                      	push	ax
 10985                                  CPYLoop:
 10986 000017CA AC                      	LODSB
 10987 000017CB E85742                  	call	UCase			; convert to upper case
 10988 000017CE E8A942                  	call	PATHCHRCMP		; convert / to \ ;
 10989 000017D1 AA                      	STOSB
 10990                                  
 10991 000017D2 08C0                    	OR	AL,AL
 10992 000017D4 75F4                    	JNZ	short CPYLoop
 10993 000017D6 58                      	pop	ax
 10994 000017D7 C3                      	retn
 10995                                  
 10996                                  ;----------------------------------------------------------------------------
 10997                                  ; Procedure Name : FStrCpy
 10998                                  ;----------------------------------------------------------------------------
 10999                                  
 11000                                  FStrCpy:
 11001 000017D8 50                      	push	ax
 11002                                  FCPYLoop:
 11003 000017D9 AC                      	LODSB
 11004 000017DA AA                      	STOSB
 11005 000017DB 08C0                    	OR	AL,AL
 11006 000017DD 75FA                    	JNZ	short FCPYLoop
 11007 000017DF 58                      	pop	ax
 11008 000017E0 C3                      	retn
 11009                                  
 11010                                  ; 20/07/2018 - Retro DOS v3.0
 11011                                  ;----------------------------------------------------------------------------
 11012                                  ; UCase, IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1E2Fh
 11013                                  ;----------------------------------------------------------------------------
 11014                                  ;
 11015                                  ;UCase:	
 11016                                  ;	call	_UCase	 ; Offset 5518h (GetLet, Offset 5517h)
 11017                                  ;	retn
 11018                                  
 11019                                  ;Break <StrLen - compute length of string ES:DI>
 11020                                  ;----------------------------------------------------------------------------
 11021                                  ;**	StrLen - Compute Length of String
 11022                                  ;
 11023                                  ;	StrLen computes the length of a string, including the trailing 00
 11024                                  ;
 11025                                  ;	ENTRY	(es:di) = address of string
 11026                                  ;	EXIT	(cx) = size of string
 11027                                  ;	USES	cx, flags
 11028                                  ;----------------------------------------------------------------------------
 11029                                  
 11030                                  StrLen:
 11031 000017E1 57                      	push	di
 11032 000017E2 50                      	push	ax
 11033                                  	;MOV	CX,-1
 11034 000017E3 B9FFFF                  	mov	cx,65535
 11035 000017E6 30C0                    	XOR	AL,AL
 11036 000017E8 F2AE                    	REPNE	SCASB
 11037 000017EA F7D1                    	NOT	CX
 11038 000017EC 58                      	pop	ax
 11039 000017ED 5F                      	pop	di
 11040 000017EE C3                      	retn
 11041                                  
 11042                                  ;----------------------------------------------------------------------------
 11043                                  ;**	DStrLen - Compute Length of String
 11044                                  ;
 11045                                  ;	ENTRY	(ds:si) = address of string
 11046                                  ;	EXIT	(cx) = size of string, including trailing NUL
 11047                                  ;	USES	cx, flags
 11048                                  ;----------------------------------------------------------------------------
 11049                                  
 11050                                  DStrLen:	; BUGBUG - this guy is a pig, who uses him?
 11051 000017EF E80300                  	CALL	XCHGP
 11052 000017F2 E8ECFF                  	CALL	StrLen
 11053                                  	;CALL	XCHGP
 11054                                  	;retn
 11055                                  	; 18/12/2022
 11056                                  	;jmp	short XCHGP
 11057                                  
 11058                                  ;----------------------------------------------------------------------------
 11059                                  ;**	XCHGP - Exchange Source and Destination Pointers
 11060                                  ;
 11061                                  ;	XCHGP exchanges (DS:SI) and (ES:DI)
 11062                                  ;
 11063                                  ;	ENTRY	none
 11064                                  ;	EXIT	pairs exchanged
 11065                                  ;	USES	SI, DI, DS, ES
 11066                                  ;----------------------------------------------------------------------------
 11067                                  
 11068                                  XCHGP:
 11069 000017F5 1E                      	push	ds
 11070 000017F6 06                      	push	es
 11071 000017F7 1F                      	pop	ds
 11072 000017F8 07                      	pop	es
 11073 000017F9 87F7                    	XCHG	SI,DI
 11074                                  xchgp_retn:
 11075 000017FB C3                      	retn
 11076                                  
 11077                                  ;Break	<Idle - wait for a specified amount of time>
 11078                                  ;----------------------------------------------------------------------------
 11079                                  ;
 11080                                  ;   Idle - when retrying an operation due to a lock/sharing violation,
 11081                                  ;   	   we spin until RetryLoop is exhausted.
 11082                                  ;
 11083                                  ;   Inputs:	RetryLoop is the number of times we spin
 11084                                  ;   Outputs:	Wait
 11085                                  ;   Registers modified: none
 11086                                  ;----------------------------------------------------------------------------
 11087                                  
 11088                                  Idle:
 11089                                  	;test	byte [SS:FSHARING],0FFh
 11090 000017FC 36803E[7205]00          	cmp	byte [SS:FSHARING],0	;hkn; SS override
 11091                                  	;retnz
 11092 00001802 75F7                    	jnz	short xchgp_retn
 11093                                  	;SAVE	<CX>
 11094 00001804 51                      	push	cx
 11095 00001805 368B0E[1C00]            	MOV	CX,[ss:RetryLoop]	;hkn; SS override
 11096 0000180A E308                    	JCXZ	Idle3
 11097                                  Idle1:	
 11098 0000180C 51                      	PUSH	CX
 11099 0000180D 31C9                    	XOR	CX,CX
 11100                                  Idle2:	
 11101 0000180F E2FE                    	LOOP	Idle2
 11102 00001811 59                      	POP	CX
 11103 00001812 E2F8                    	LOOP	Idle1
 11104                                  Idle3:	
 11105                                  	;RESTORE <CX>
 11106 00001814 59                      	pop	cx
 11107 00001815 C3                      	retn
 11108                                  
 11109                                  ;Break	<TableDispatch - dispatch to a table>
 11110                                  ;----------------------------------------------------------------------------
 11111                                  ;
 11112                                  ;   TableDispatch - given a table and an index, jmp to the approptiate
 11113                                  ;   routine. Preserve all input registers to the routine.
 11114                                  ;
 11115                                  ;   Inputs:	Push	return address
 11116                                  ;		Push	Table address
 11117                                  ;		Push	index (byte)
 11118                                  ;   Outputs:	appropriate routine gets jumped to.
 11119                                  ;		return indicates invalid index
 11120                                  ;   Registers modified: none.
 11121                                  ;----------------------------------------------------------------------------
 11122                                  
 11123                                  struc TFrame	 ; TableFrame
 11124 00000000 ????                    .OldBP:	 resw 1  ; 0
 11125 00000002 ????                    .OldRet: resw 1  ; 2
 11126 00000004 ??                      .Index:	 resb 1  ; 4
 11127 00000005 ??                      .Pad:	 resb 1  ; 5  
 11128 00000006 ????                    .Tab:	 resw 1  ; 6
 11129 00000008 ????                    .NewRet: resw 1  ; 8
 11130                                  endstruc
 11131                                  
 11132                                  TableDispatch:
 11133 00001816 55                      	PUSH	BP
 11134 00001817 89E5                    	MOV	BP,SP
 11135 00001819 53                      	PUSH	BX			; save BX
 11136                                  	;mov	bx,[bp+6]
 11137 0000181A 8B5E06                  	MOV	BX,[BP+TFrame.Tab]	; get pointer to table
 11138 0000181D 2E8A1F                  	MOV	BL,[CS:BX]		; maximum index
 11139                                  	;cmp	[bp+4],bl
 11140 00001820 385E04                  	CMP	[BP+TFrame.Index],BL	; table error?
 11141 00001823 7317                    	JAE	short TableError	; yes
 11142                                  	;mov	bl,[bp+4]
 11143 00001825 8A5E04                  	MOV	BL,[BP+TFrame.Index]	; get desired table index
 11144 00001828 30FF                    	XOR	BH,BH			; convert to word
 11145 0000182A D1E3                    	SHL	BX,1			; convert to word pointer
 11146 0000182C 43                      	INC	BX			; point past first length byte
 11147                                  	; 17/08/2018
 11148                                  	;add	bx,[bp+6]
 11149 0000182D 035E06                  	ADD	BX,[BP+TFrame.Tab]	; get real offset
 11150 00001830 2E8B1F                  	MOV	BX,[CS:BX]		; get contents of table entry
 11151                                  	;mov	[bp+6],bx
 11152 00001833 895E06                  	MOV	[BP+TFrame.Tab],BX	; put table entry into return address
 11153 00001836 5B                      	POP	BX			; restore BX
 11154 00001837 5D                      	POP	BP			; restore BP
 11155 00001838 83C404                  	ADD	SP,4			; clean off Index and our return addr
 11156 0000183B C3                      	retn				; do operation
 11157                                  TableError:
 11158 0000183C 5B                      	POP	BX			; restore BX
 11159 0000183D 5D                      	POP	BP			; restore BP
 11160 0000183E C20600                  	RETN	6			; clean off Index, Table and RetAddr
 11161                                  
 11162                                  ;Break	<TestNet - determine if a CDS is for the network>
 11163                                  ;----------------------------------------------------------------------------
 11164                                  ;
 11165                                  ;   TestNet - examine CDS pointed to by ThisCDS and see if it indicates a
 11166                                  ;	network CDS. This will handle NULL cds also.
 11167                                  ;
 11168                                  ;   Inputs:	ThisCDS points to CDS or NULL
 11169                                  ;   Outputs:	ES:DI = ThisCDS
 11170                                  ;		carry Set => network
 11171                                  ;		carry Clear => local
 11172                                  ;   Registers modified: none.
 11173                                  ;----------------------------------------------------------------------------
 11174                                  
 11175                                  TestNet:
 11176                                  	;LES	DI,[CS:THISCDS]
 11177                                  
 11178                                  	; 16/05/2019 - Retro DOS v4.0
 11179 00001841 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 11180 00001846 26C43E[A205]            	LES	DI,[ES:THISCDS]
 11181 0000184B 83FFFF                  	CMP	DI,-1
 11182 0000184E 7408                    	JZ	short CMCRet		; UNC? carry is clear
 11183                                  	;;test	word [es:di+43h],8000h
 11184                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 11185                                  	;test	byte [es:di+44h],80h
 11186 00001850 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 11187 00001855 7501                    	JNZ	short CMCRet		; jump has carry clear
 11188 00001857 C3                      	retn				; carry is clear
 11189                                  CMCRet: 
 11190 00001858 F5                      	CMC
 11191 00001859 C3                      	retn
 11192                                  
 11193                                  ;Break	<IsSFTNet - see if an sft is for the network>
 11194                                  ;----------------------------------------------------------------------------
 11195                                  ;
 11196                                  ;   IsSFTNet - examine SF pointed to by ES:DI and see if it indicates a
 11197                                  ;	network file.
 11198                                  ;
 11199                                  ;   Inputs:	ES:DI point to SFT
 11200                                  ;   Outputs:	Zero set if not network sft
 11201                                  ;		zero reset otherwise
 11202                                  ;		Carry CLEAR!!!
 11203                                  ;   Registers modified: none.
 11204                                  ;----------------------------------------------------------------------------
 11205                                  
 11206                                  IsSFTNet:
 11207                                  	;;test	word [es:di+5],8000h
 11208                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 11209                                  	; 16/05/2019 
 11210                                  	;test	byte [es:di+6],80h
 11211 0000185A 26F6450680              	TEST	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 11212 0000185F C3                      	retn
 11213                                  
 11214                                  ;Break	<FastInit - Initialize FastTable entries >
 11215                                  ;----------------------------------------------------------------------------
 11216                                  ;   DOS 4.00   2/9/87
 11217                                  ;   FastInit  - initialize the FASTXXX routine entry
 11218                                  ;		  in the FastTable
 11219                                  ;
 11220                                  ;   Inputs:	BX = FASTXXX ID ( 1=fastopen )
 11221                                  ;		DS:SI = address of FASTXXX routine entry
 11222                                  ;		   SI = -1 for query only
 11223                                  ;   Outputs:	Carry flag clear, if success
 11224                                  ;		Carry flag set,   if failure
 11225                                  ;
 11226                                  ;
 11227                                  ;----------------------------------------------------------------------------
 11228                                  
 11229                                  ;Procedure FastInit,NEAR
 11230                                  ;	ASSUME	CS:DOSCODE,SS:NOTHING
 11231                                  
 11232                                  ;	; MSDOS 3.3
 11233                                  ;	; IBMDOS.COM (1987) - Offset 1EB3h
 11234                                  ;FastInit:
 11235                                  ;	mov	di,FastTable ; FastOpenTable
 11236                                  ;	mov	ax,[cs:di+4]		; Entry segment
 11237                                  ;	mov	bx,cs			; get DOS segment
 11238                                  ;	cmp	ax,bx			; first time installed ?	
 11239                                  ;	je	short ok_install	; yes
 11240                                  ;	stc				; set carry
 11241                                  ;	retn				; (cf=1 means) already installed !
 11242                                  ;
 11243                                  ;ok_install:
 11244                                  ;	mov	bx,FastTable ; FastOpenTable
 11245                                  ;	mov	cx,ds
 11246                                  ;	; set address of FASTXXX (FASTOPEN) routine entry
 11247                                  ;	mov	[cs:bx+4],cx
 11248                                  ;	mov	[cs:bx+2],si
 11249                                  ;	retn
 11250                                  
 11251                                  ; 16/05/2019 - Retro DOS v4.0
 11252                                  
 11253                                  ; 14/01/2024 - Retro DOS v5.0
 11254                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:5773h
 11255                                  
 11256                                  FastInit:
 11257                                  	; MSDOS 6.0
 11258                                  	;hkn; set up es to dosdataseg.
 11259 00001860 06                      	push	es
 11260                                  	;getdseg <es>			; es -> dosdata
 11261 00001861 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 11262                                  
 11263                                  	;hkn; FastTable is in DOSDATA
 11264 00001866 BF[6512]                	MOV	DI,FastTable+2		;AN000;FO. points to fastxxx entry
 11265 00001869 4B                      	DEC	BX			;AN000;FO.;; decrement index
 11266 0000186A 89DA                    	MOV	DX,BX			;AN000;FO.;; save bx
 11267 0000186C D1E3                    	SHL	BX,1			;AN000;FO.;; times 4, each entry is DWORD
 11268 0000186E D1E3                    	SHL	BX,1			;AN000;FO.
 11269 00001870 01DF                    	ADD	DI,BX			;AN000;FO. index to the entry
 11270 00001872 268B4502                	MOV	AX,[ES:DI+2]		;AN000;FO. get entry segment
 11271                                  fcheck: 				;AN000;
 11272 00001876 8CC9                    	MOV	CX,CS			;AN000;FO.;; get DOS segment
 11273 00001878 39C8                    	CMP	AX,CX			;AN000;FO.;; first time installed ?
 11274 0000187A 7405                    	JZ	short ok_install	;AN000;FO.;; yes
 11275 0000187C 09C0                    	OR	AX,AX			;AN000;FO.;
 11276                                  	;JZ	short ok_install	;AN000;FO.;
 11277                                  	;STC				;AN000;FO.;; already installed !
 11278                                  	;JMP	SHORT FSret		;AN000;FO. set carry
 11279                                  	; 14/01/2024
 11280 0000187E F9                      	stc
 11281 0000187F 7517                    	jnz	short FSret
 11282                                  ok_install:				;AN000;
 11283 00001881 83FEFF                  	CMP	SI,-1			;AN000;FO.; Query only ?
 11284 00001884 7412                    	JZ	short FSret		;AN000;FO.; yes
 11285 00001886 8CD9                    	MOV	CX,DS			;AN000;FO.; get FASTXXX entry segment
 11286 00001888 26894D02                	MOV	[ES:DI+2],CX		;AN000;FO.; initialize routine entry
 11287 0000188C 268935                  	MOV	[ES:DI],SI		;AN000;FO.; initialize routine offset
 11288                                  
 11289                                  ;hkn; FastFlg moved to DOSDATA
 11290 0000188F BF[6D12]                	MOV	DI,FastFlg		;AN000;FO.; get addr of FASTXXX flags
 11291 00001892 01D7                    	ADD	DI,DX			;AN000;FO.; index to a FASTXXX flag
 11292                                  	;or	byte [es:di],80h
 11293 00001894 26800D80                	OR	byte [ES:DI],Fast_yes	;AN000;FO.; indicate installed
 11294                                  FSret:					;AN000;
 11295 00001898 07                      	pop	es
 11296 00001899 C3                      	retn				;AN000;FO.
 11297                                  
 11298                                  ;EndProc FastInit
 11299                                  
 11300                                  ;Break	<FastRet - initial routine in FastOpenTable >
 11301                                  ;----------------------------------------------------------------------------
 11302                                  ;   DOS 3.3   6/10/86
 11303                                  ;   FastRet	- indicate FASTXXXX  not in memory
 11304                                  ;
 11305                                  ;   Inputs:	None
 11306                                  ;   Outputs:	AX = -1 and carry flag set
 11307                                  ;
 11308                                  ;   Registers modified: none.
 11309                                  ;----------------------------------------------------------------------------
 11310                                  
 11311                                  FastRet:
 11312                                  	;mov	ax,-1
 11313                                  	;stc
 11314                                  	;retf
 11315 0000189A F9                      	STC
 11316 0000189B 19C0                    	sbb	ax,ax		; (ax) = -1, 'C' set
 11317 0000189D CB                      	RETF
 11318                                  
 11319                                  ;Break	<NLS_OPEN - do $open for NLSFUNC>
 11320                                  ;----------------------------------------------------------------------------
 11321                                  ;   DOS 3.3   6/10/86
 11322                                  ;   NLS_OPEN	- call $OPEN for NLSFUNC
 11323                                  ;
 11324                                  ;   Inputs:	Same input as $OPEN except CL = mode
 11325                                  ;   Outputs:	same output as $OPEN
 11326                                  ;
 11327                                  ;----------------------------------------------------------------------------
 11328                                  
 11329                                  ;hkn; NOTE! SS MUST HAVE BEEN SET UP TO DOSDATA BY THE TIME THESE
 11330                                  ;hkn; NLS FUNCTIONS ARE CALLED!!! THERE FORE WE WILL USE SS OVERRIDES
 11331                                  ;hkn; IN ORDER TO ACCESS DOS DATA VARIABLES!
 11332                                  
 11333                                  NLS_OPEN:
 11334                                  ;	MOV	BL,[CPSWFLAG]	 ; disable code page matching logic
 11335                                  ;	MOV	BYTE [CPSWFLAG],0
 11336                                  ;	PUSH	BX		 ; save current state
 11337                                  
 11338 0000189E 88C8                    	MOV	AL,CL		 ; set up correct interface for $OPEN
 11339 000018A0 E85360                  	call	_$OPEN
 11340                                  
 11341                                  ;	POP	BX		 ; restore current state
 11342                                  ;	MOV	[CPSWFLAG],BL
 11343                                  
 11344 000018A3 C3                      	RETN
 11345                                  
 11346                                  ;Break	<NLS_LSEEK - do $LSEEK for NLSFUNC>
 11347                                  ;----------------------------------------------------------------------------
 11348                                  ;   DOS 3.3   6/10/86
 11349                                  ;   NLS_LSEEK	- call $LSEEK for NLSFUNC
 11350                                  ;
 11351                                  ;   Inputs:	BP = open mode
 11352                                  ;   Outputs:	same output as $LSEEK
 11353                                  ;
 11354                                  ;----------------------------------------------------------------------------
 11355                                  
 11356                                  ; 16/05/2019 - Retro DOS v4.0
 11357                                  
 11358                                  NLS_LSEEK:
 11359 000018A4 36FF36[8405]            	PUSH	word [SS:USER_SP] ; save user stack
 11360 000018A9 36FF36[8605]            	PUSH	word [SS:USER_SS]
 11361 000018AE E81000                  	CALL	Fake_User_Stack
 11362 000018B1 89E8                    	MOV	AX,BP		; set up correct interface for $LSEEK
 11363 000018B3 E8ED59                  	call	_$LSEEK
 11364 000018B6 368F06[8605]            	POP	word [SS:USER_SS] ; restore user stack
 11365 000018BB 368F06[8405]            	POP	word [SS:USER_SP]
 11366 000018C0 C3                      	RETN
 11367                                  
 11368                                  ;Break	<Fake_User_Stack - save user stack>
 11369                                  ;----------------------------------------------------------------------------
 11370                                  ;   DOS 3.3   6/10/86
 11371                                  ;   Fake_User_Stack - save user stack pointer
 11372                                  ;
 11373                                  ;----------------------------------------------------------------------------
 11374                                  
 11375                                  Fake_User_Stack:
 11376 000018C1 36A1[BB0D]              	MOV	AX,[SS:USER_SP_2F] ; replace with INT 2Fh stack
 11377 000018C5 36A3[8405]              	MOV	[SS:USER_SP],AX
 11378 000018C9 8CD0                    	MOV	AX,SS
 11379 000018CB 36A3[8605]              	MOV	[SS:USER_SS],AX
 11380 000018CF C3                      	RETN
 11381                                  
 11382                                  ;Break	<GetDevList - get device header list pointer>
 11383                                  ;----------------------------------------------------------------------------
 11384                                  ;   DOS 3.3   7/25/86
 11385                                  ;   GetDevList - get device header list pointer
 11386                                  ;
 11387                                  ;   Output: AX:BX points to the device header list
 11388                                  ;----------------------------------------------------------------------------
 11389                                  
 11390                                  GetDevList:
 11391                                  	; 16/05/2019 - Retro DOS v4.0
 11392 000018D0 BE[790D]                	MOV	SI,SysInitTable
 11393 000018D3 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 11394 000018D8 C534                    	LDS	SI,[SI]
 11395                                  	;mov	ax,[si+34]  ; SSYSINITVARS offset 34 = [SI+SYSI.DEV]
 11396 000018DA 8B4422                  	MOV	AX,[SI+SYSI.DEV]
 11397                                  	;mov	bx,[si+36]  ; SSYSINITVARS offset 36 = [SI+SYSI.DEV+2]
 11398 000018DD 8B5C24                  	MOV	BX,[SI+SYSI.DEV+2]
 11399 000018E0 C3                      	RETN
 11400                                  
 11401                                  ;Break	<NLS_IOCTL - do $IOCTL for NLSFUNC>
 11402                                  ;----------------------------------------------------------------------------
 11403                                  ;   DOS 3.3   7/25/86
 11404                                  ;   NLS_IOCTL	- call $IOCTL for NLSFUNC
 11405                                  ;
 11406                                  ;   Inputs:	BP = function code 0CH
 11407                                  ;   Outputs:	same output as generic $IOCTL
 11408                                  ;
 11409                                  ;----------------------------------------------------------------------------
 11410                                  
 11411                                  NLS_IOCTL:
 11412                                  	; 16/05/2019 - Retro DOS v4.0
 11413 000018E1 36FF36[8405]            	PUSH	word [SS:USER_SP] ; save user stack
 11414 000018E6 36FF36[8605]            	PUSH	word [SS:USER_SS]
 11415 000018EB E8D3FF                  	CALL	Fake_User_Stack
 11416 000018EE 89E8                    	MOV	AX,BP		; set up correct interface for $IOCTL
 11417 000018F0 E8BB0F                  	call	_$IOCTL
 11418 000018F3 368F06[8605]            	POP	word [SS:USER_SS] ; restore user stack
 11419 000018F8 368F06[8405]            	POP	word [SS:USER_SP]
 11420 000018FD C3                      	RETN
 11421                                  
 11422                                  ;Break	<NLS_GETEXT- get extended error for NLSFUNC>
 11423                                  ;----------------------------------------------------------------------------
 11424                                  ;   DOS 3.3   7/25/86
 11425                                  ;   NLS_GETEXT	-
 11426                                  ;
 11427                                  ;   Inputs:	none
 11428                                  ;   Outputs:	AX = extended error
 11429                                  ;
 11430                                  ;----------------------------------------------------------------------------
 11431                                  
 11432                                  NLS_GETEXT:
 11433                                  	; 16/05/2019 - Retro DOS v4.0
 11434 000018FE 36A1[2403]              	MOV	AX,[SS:EXTERR]	 ; return extended error
 11435                                  	; 23/09/2023
 11436                                  MSG_RETRIEVAL:
 11437 00001902 C3                      	RETN
 11438                                  
 11439                                  ; 29/04/2019 - Retro DOS v4.0
 11440                                  
 11441                                  ;Break	<MSG_RETRIEVAL- get beginning addr of system and parser messages>
 11442                                  
 11443                                  ;----------------------------------------------------------------------------
 11444                                  ;   DOS 4.00
 11445                                  ;
 11446                                  ;   Inputs:	DL=0 get extended error message addr
 11447                                  ;		  =1 set extended error message addr
 11448                                  ;		  =2 get parser error message addr
 11449                                  ;		  =3 set parser error message addr
 11450                                  ;		  =4 get critical error message addr
 11451                                  ;		  =5 set critical error message addr
 11452                                  ;		  =6 get file system error message addr
 11453                                  ;		  =7 set file system error message addr
 11454                                  ;		  =8 get address for code reduction
 11455                                  ;		  =9 set address for code reduction
 11456                                  ;   Function:	get/set message address
 11457                                  ;   Outputs:	ES:DI points to addr when get
 11458                                  ;----------------------------------------------------------------------------
 11459                                  
 11460                                  ;Procedure MSG_RETRIEVAL,NEAR
 11461                                  ;	ASSUME	CS:DOSCODE,SS:NOTHING
 11462                                  
 11463                                  ; 23/09/2023
 11464                                  ;MSG_RETRIEVAL:
 11465                                  
 11466                                  ;;	NOTE:  This function lives in command.com resident code now.
 11467                                  ;;	If the int 2F ever gets this far, we'll return registers
 11468                                  ;;	unchanged, which produces the same result as before, if
 11469                                  ;;	command.com wasn't present (and therefore no messages available).
 11470                                  ;;
 11471                                  ;;	I didn't point the entry in the 2F table to No_Op because
 11472                                  ;;	No_Op zeroes AL.
 11473                                  ;;
 11474                                  ;;;hkn; set up ds to point to DOSDATA
 11475                                  ;;	push	ds
 11476                                  ;;	getdseg	<ds>			; ds -> dosdata
 11477                                  ;;
 11478                                  ;;	PUSH	AX		    ;AN000;;MS. save regs
 11479                                  ;;	PUSH	SI		    ;AN000;;MS. save regs
 11480                                  ;;	MOV	AX,DX		    ;AN000;;MS.
 11481                                  ;;	MOV	SI,OFFSET DOSDATA:MSG_EXTERROR ;AN000;;MS.
 11482                                  ;;	test	AL,1		    ;AN000;;MS. get ?
 11483                                  ;;	JZ	toget		    ;AN000;;MS. yes
 11484                                  ;;	DEC	AL		    ;AN000;;MS.
 11485                                  ;;toget:				    ;AN000;
 11486                                  ;;	SHL	AL,1		    ;AN000;;MS. times 2
 11487                                  ;;	XOR	AH,AH		    ;AN000;;MS.
 11488                                  ;;	ADD	SI,AX		    ;AN000;;MS. position to the entry
 11489                                  ;;	test	DL,1		    ;AN000;;MS. get ?
 11490                                  ;;	JZ	getget			     ;AN000;;MS. yes
 11491                                  ;;	MOV	WORD PTR DS:[SI],DI    ;AN000;;MS. set MSG
 11492                                  ;;	MOV	WORD PTR DS:[SI+2],ES  ;AN000;;MS. address to ES:DI
 11493                                  ;;	JMP	SHORT MSGret		     ;AN000;;MS. exit
 11494                                  ;;getget: 				     ;AN000;
 11495                                  ;;	LES	DI,DWORD PTR DS:[SI]	     ;AN000;;MS. get msg addr
 11496                                  ;;MSGret: 				     ;AN000;
 11497                                  ;;	POP	SI			     ;AN000;;MS.
 11498                                  ;;	POP	AX			     ;AN000;;MS.
 11499                                  ;;
 11500                                  ;;	pop	ds
 11501                                  
 11502                                  ;	return				     ;AN000;;MS. exit
 11503                                  
 11504                                  ; 23/09/2023
 11505                                  ;	retn	; 29/04/2019
 11506                                  
 11507                                  ;============================================================================
 11508                                  ; ECritDisk, LCritDisk, ECritDevice, LCritDevice
 11509                                  ; IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1F36h
 11510                                  ;============================================================================
 11511                                  ; 20/07/2018 - Retro DOS v3.0
 11512                                  
 11513                                  ;	; MSDOS 3.3
 11514                                  ;	; 08/08/2018 - Retro DOS v3.0
 11515                                  ;ECritMEM:
 11516                                  ;ECritSFT:
 11517                                  ;	;
 11518                                  ;ECritDisk:
 11519                                  ;	retn
 11520                                  ;	;push	ax
 11521                                  ;	
 11522                                  ;	mov	ax,8001h
 11523                                  ;	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
 11524                                  ;			; AL = critical section number (00h-0Fh)
 11525                                  ;	pop	ax
 11526                                  ;	retn
 11527                                  ;
 11528                                  ;	; MSDOS 3.3
 11529                                  ;	; 08/08/2018 - Retro DOS v3.0
 11530                                  ;LCritMEM:
 11531                                  ;LCritSFT:
 11532                                  ;	;
 11533                                  ;LCritDisk:
 11534                                  ;	retn
 11535                                  ;	;push	ax
 11536                                  ;	
 11537                                  ;	mov	ax,8101h
 11538                                  ;	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
 11539                                  ;			; AL = critical section number (00h-0Fh)
 11540                                  ;	pop	ax
 11541                                  ;	retn
 11542                                  ;
 11543                                  ;ECritDevice:
 11544                                  ;	retn
 11545                                  ;	;push	ax
 11546                                  ;	
 11547                                  ;	mov	ax,8002h
 11548                                  ;	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
 11549                                  ;			; AL = critical section number (00h-0Fh)
 11550                                  ;	pop	ax
 11551                                  ;	retn
 11552                                  ;
 11553                                  ;LCritDevice:
 11554                                  ;	retn
 11555                                  ;	;push	ax
 11556                                  ;	
 11557                                  ;	mov	ax,8102h
 11558                                  ;	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
 11559                                  ;			; AL = critical section number (00h-0Fh)
 11560                                  ;	pop	ax
 11561                                  ;	retn
 11562                                  
 11563                                  ;============================================================================
 11564                                  ; CRIT.ASM, MSDOS 6.0, 1991
 11565                                  ;============================================================================
 11566                                  ; 12/05/2019 - Retro DOS v4.0
 11567                                  
 11568                                  ; Critical Section Routines
 11569                                  
 11570                                  ; MSDOS 6.21 - MSDOS.SYS - DOSCODE:513Ah
 11571                                  
 11572                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11573                                  ; DOSCODE:5126h (MSDOS 5.0 MSDOS.SYS)
 11574                                  
 11575                                  ; ---------------------------------------------------------------------------
 11576                                  ; Each handler must leave everything untouched; including flags!
 11577                                  ;
 11578                                  ; Sleaze for time savings: first instruction is a return. This is patched
 11579                                  ; by the sharer to be a PUSH AX to complete the correct routines.
 11580                                  ; ---------------------------------------------------------------------------
 11581                                  
 11582                                  ; (DOSMAC.INC, MSDOS 6.0, 1991)
 11583                                  ; ---------------------------------------------------------------------------
 11584                                  ; Some old versions of the 80286 have a bug in the chip. The popf instruction
 11585                                  ; will enable interrupts. Therefore in a section of code with interrupts
 11586                                  ; disabled and you need a popf instruction use the 'popff' macro instead.
 11587                                  ; ---------------------------------------------------------------------------
 11588                                  
 11589                                  ;%macro POPFF 0
 11590                                  ;	jmp	$+3
 11591                                  ;	iret
 11592                                  ;	push	cs
 11593                                  ;	call	$-2
 11594                                  ;%endmacro
 11595                                  
 11596                                  ; ---------------------------
 11597                                  
 11598                                  ; 14/01/2024 - Retro DOS v5.0
 11599                                  %if 0
 11600                                  
 11601                                  ;Procedure  ECritDisk,NEAR
 11602                                  	;public  ECritMEM
 11603                                  	;public  ECritSFT
 11604                                  ECritMEM:
 11605                                  ECritSFT:
 11606                                  ;
 11607                                  ECritDisk:
 11608                                  
 11609                                  ;SR; Check if critical section is to be entered
 11610                                  
 11611                                  	pushf
 11612                                  	cmp	byte [ss:redir_patch],0
 11613                                  	jz	short ECritDisk_2
 11614                                  
 11615                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11616                                  ;	;popff  ; * (macro)
 11617                                  ;	jmp	short ECritDisk_1 ; *
 11618                                  ;
 11619                                  ;ECritDisk_iret: ; *
 11620                                  ;	iret ; *
 11621                                  
 11622                                  	; 16/12/2022
 11623                                  	; 13/11/2022
 11624                                  	;jmp	short ECritDisk_1
 11625                                  	; 06/11/2022
 11626                                  ;ECritDisk_iret:
 11627                                  ;	iret	
 11628                                  
 11629                                  	; 06/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11630                                  ECritDisk_1:
 11631                                  	push	cs ; *
 11632                                  	call	ECritDisk_iret ; *		
 11633                                  	
 11634                                  ECritDisk_0:
 11635                                  	PUSH    AX
 11636                                  	;MOV	AX,8000h+critDisk
 11637                                  	;INT	int_IBM
 11638                                  	mov	ax,8001h
 11639                                  	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
 11640                                  			; AL = critical section number (00h-0Fh)
 11641                                  	POP     AX
 11642                                  	retn
 11643                                  
 11644                                  	; 16/12/2022
 11645                                  	; 13/11/2022
 11646                                  ECritDisk_iret:  ; 12/05/2019 - Retro DOS v4.0
 11647                                  LCritDisk_iret: 
 11648                                  	iret
 11649                                  
 11650                                  ECritDisk_2:
 11651                                  	;;popff ; *
 11652                                  	;;retn
 11653                                  ;	jmp	short ECritDisk_3 ; *
 11654                                  ;ECritDisk_iret2: ; *
 11655                                  ;	iret
 11656                                  	
 11657                                  	; 16/12/2022
 11658                                  	; 13/11/2022
 11659                                  	;jmp	short ECritDisk_3
 11660                                  ;ECritDisk_iret2:
 11661                                  	;iret
 11662                                  
 11663                                  ECritDisk_3:
 11664                                  	push    cs ; *
 11665                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11666                                  	;call	ECritDisk_iret2 ; *
 11667                                  	;retn
 11668                                  	; 16/12/2022
 11669                                  	call	ECritDisk_iret
 11670                                  	retn
 11671                                  
 11672                                  ;EndProc ECritDisk
 11673                                  
 11674                                  ; ---------------------------
 11675                                  
 11676                                  ;Procedure   LCritDisk,NEAR
 11677                                  	;public  LCritMEM
 11678                                  	;public  LCritSFT
 11679                                  LCritMEM:
 11680                                  LCritSFT:
 11681                                  ;
 11682                                  LCritDisk:
 11683                                  
 11684                                  ;SR; Check if critical section is to be entered
 11685                                  
 11686                                  	pushf
 11687                                  	cmp	byte [ss:redir_patch],0
 11688                                  	jz	short LCritDisk_2
 11689                                  	;popff  ; * (macro)
 11690                                  ;	jmp	short LCritDisk_1 ; *
 11691                                  ;
 11692                                  ;LCritDisk_iret: ; *
 11693                                  ;	iret ; *
 11694                                  
 11695                                  	; 16/12/2022
 11696                                  	; 13/11/2022
 11697                                  	;jmp	short LCritDisk_1
 11698                                  ;LCritDisk_iret:
 11699                                  	;iret
 11700                                  
 11701                                  LCritDisk_1:
 11702                                  	push	cs ; *
 11703                                  	call	LCritDisk_iret ; *		
 11704                                  	
 11705                                  LCritDisk_0:
 11706                                  	PUSH	AX
 11707                                  	;MOV	AX,8100h+critDisk
 11708                                  	;INT	int_IBM
 11709                                  	mov	ax,8101h
 11710                                  	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
 11711                                  			; AL = critical section number (00h-0Fh)
 11712                                  	POP	AX
 11713                                  	retn
 11714                                  
 11715                                  ;LCritDisk_iret:  ; 12/05/2019 - Retro DOS v4.0 
 11716                                  ;	iret
 11717                                  
 11718                                  LCritDisk_2:
 11719                                  	;;popff ; *
 11720                                  	;;retn
 11721                                  ;	jmp	short LCritDisk_3 ; *
 11722                                  ;LCritDisk_iret2: ; *
 11723                                  ;	iret
 11724                                  
 11725                                  	; 16/12/2022
 11726                                  	; 13/11/2022
 11727                                  	;jmp	short LCritDisk_3
 11728                                  ;LCritDisk_iret2:
 11729                                  	;iret
 11730                                  
 11731                                  LCritDisk_3:
 11732                                  	push    cs ; *
 11733                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11734                                  	;call	LCritDisk_iret2 ; *
 11735                                  	;retn
 11736                                  	; 16/12/2022
 11737                                  	call	LCritDisk_iret
 11738                                  	retn
 11739                                  
 11740                                  ;EndProc LCritDisk
 11741                                  
 11742                                  ; ---------------------------
 11743                                  
 11744                                  ;Procedure   ECritDevice,NEAR
 11745                                  
 11746                                  ECritDevice:
 11747                                  
 11748                                  ;SR; Check if critical section is to be entered
 11749                                  
 11750                                  	pushf
 11751                                  	cmp	byte [ss:redir_patch],0
 11752                                  	jz	short ECritDevice_2
 11753                                  	;popff  ; * (macro)
 11754                                  ;	jmp	short ECritDevice_1 ; *
 11755                                  ;
 11756                                  ;ECritDevice_iret: ; *
 11757                                  ;	iret ; *
 11758                                  
 11759                                  	; 16/12/2022	
 11760                                  	; 13/11/2022
 11761                                  	;jmp	short ECritDevice_1
 11762                                  ;ECritDevice_iret:
 11763                                  	;iret
 11764                                  
 11765                                  ECritDevice_1:
 11766                                  	push	cs ; *
 11767                                  	call	ECritDevice_iret ; *		
 11768                                  	
 11769                                  ECritDevice_0:
 11770                                  	PUSH	AX
 11771                                  	;MOV	AX,8000h+critDevice
 11772                                  	;INT	int_IBM
 11773                                  	mov	ax,8002h
 11774                                  	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
 11775                                  			; AL = critical section number (00h-0Fh)
 11776                                  	POP     AX
 11777                                  	retn
 11778                                  
 11779                                  	; 16/12/2022
 11780                                  	; 06/12/2022
 11781                                  ECritDevice_iret:  ; 12/05/2019 - Retro DOS v4.0
 11782                                  LCritDevice_iret: 
 11783                                  	iret
 11784                                  
 11785                                  ECritDevice_2:
 11786                                  	;;popff ; *
 11787                                  	;;retn
 11788                                  ;	jmp	short ECritDevice_3 ; *
 11789                                  ;ECritDevice_iret2: ; *
 11790                                  ;	iret
 11791                                  
 11792                                  	; 16/12/2022
 11793                                  	; 13/11/2022
 11794                                  	;jmp	short ECritDevice_3
 11795                                  ;ECritDevice_iret2:
 11796                                  	;iret
 11797                                  
 11798                                  ECritDevice_3:
 11799                                  	push    cs ; *
 11800                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11801                                  	;call	ECritDevice_iret2 ; *
 11802                                  	;retn
 11803                                  	; 16/12/2022
 11804                                  	call	ECritDevice_iret
 11805                                  	retn
 11806                                  
 11807                                  ;EndProc ECritDevice
 11808                                  
 11809                                  ; ---------------------------
 11810                                  
 11811                                  ;Procedure   LCritDevice,NEAR
 11812                                  
 11813                                  LCritDevice:
 11814                                  
 11815                                  ;SR; Check if critical section is to be entered
 11816                                  
 11817                                  	pushf
 11818                                  	cmp	byte [ss:redir_patch],0
 11819                                  	jz	short LCritDevice_2
 11820                                  	;popff  ; * (macro)
 11821                                  ;	jmp	short LCritDevice_1 ; *
 11822                                  ;
 11823                                  ;LCritDevice_iret: ; *
 11824                                  ;	iret ; *
 11825                                  
 11826                                  	; 16/12/2022
 11827                                  	; 13/11/2022
 11828                                  	;jmp	short LCritDevice_1
 11829                                  ;LCritDevice_iret:
 11830                                  	;iret
 11831                                  
 11832                                  LCritDevice_1:
 11833                                  	push	cs ; *
 11834                                  	call	LCritDevice_iret ; *		
 11835                                  	
 11836                                  LCritDevice_0:
 11837                                  	PUSH	AX
 11838                                  	;MOV	AX,8100h+critDevice
 11839                                  	;INT	int_IBM
 11840                                  	mov	ax,8102h
 11841                                  	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
 11842                                  			; AL = critical section number (00h-0Fh)
 11843                                  	POP     AX
 11844                                  	retn
 11845                                  
 11846                                  ;LCritDevice_iret:  ; 12/05/2019 - Retro DOS v4.0 
 11847                                  ;	iret
 11848                                  
 11849                                  LCritDevice_2:
 11850                                  	;;popff ; *
 11851                                  	;;retn
 11852                                  ;	jmp	short LCritDevice_3 ; *
 11853                                  ;LCritDevice_iret2: ; *
 11854                                  ;	iret
 11855                                  
 11856                                  	; 16/12/2022
 11857                                  	; 13/11/2022
 11858                                  	;jmp	short LCritDevice_3
 11859                                  ;LCritDevice_iret2:
 11860                                  	;iret
 11861                                  
 11862                                  LCritDevice_3:
 11863                                  	push    cs ; *
 11864                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11865                                  	;call	LCritDevice_iret2 ; *
 11866                                  	;retn
 11867                                  	; 16/12/2022
 11868                                  	call	LCritDevice_iret
 11869                                  	retn
 11870                                  
 11871                                  ;EndProc LCritDevice
 11872                                  
 11873                                  %endif
 11874                                  
 11875                                  	; 15/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1)
 11876                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:580Dh
 11877                                  
 11878                                  ; 15/01/2024 - Retro DOS v5.0
 11879                                  %if 1
 11880                                  	;;;
 11881                                  ; ---------------------------------------------------------------------------
 11882                                  ECritMEM:
 11883                                  ECritSFT:
 11884                                  ; ---------------------------------------------------------------------------
 11885                                  	; PCDOS 7.1 IBMDOS.COM
 11886                                  ECritDisk:
 11887 00001903 51                      	push	cx
 11888 00001904 B500                    	mov	ch,0
 11889 00001906 368A0E[860D]            	mov	cl,[ss:redir_patch]
 11890 0000190B E321                    	jcxz	ECritDisk_3
 11891 0000190D 59                      	pop	cx
 11892 0000190E 50                      	push	ax
 11893 0000190F B80180                  	mov	ax,8001h	; BEGIN DOS CRITICAL SECTION
 11894                                  				; AL = critical section number (01h)
 11895                                  ECritDisk_1:
 11896                                  ; ----------------------------------------
 11897                                  LCritDisk_1:
 11898                                  ECritDevice_1:
 11899                                  LCritDevice_1:
 11900 00001912 51                      	push	cx
 11901 00001913 B500                    	mov	ch,0
 11902 00001915 368A0E[A110]            	mov	cl,[ss:IsWin386]
 11903 0000191A E305                    	jcxz	ECritDisk2
 11904 0000191C 59                      	pop	cx
 11905 0000191D CD2A                    	int	2Ah		; Microsoft Networks - BEGIN DOS CRITICAL SECTION
 11906                                  				; AL = critical section number (00h-0Fh)
 11907 0000191F 58                      	pop	ax
 11908 00001920 C3                      	retn
 11909                                  
 11910                                  ECritDisk2:
 11911 00001921 06                      	push	es
 11912                                  	;mov	cx,0
 11913                                  	; 15/01/2024
 11914                                  	; cx = 0
 11915 00001922 8EC1                    	mov	es,cx
 11916 00001924 9C                      	pushf			; simulate INT 2Ah
 11917 00001925 26FF1EA800              	call	far [es:00A8h]	; call far (INT 2Ah vector)
 11918 0000192A 07                      	pop	es
 11919 0000192B 59                      	pop	cx
 11920 0000192C 58                      	pop	ax
 11921 0000192D C3                      	retn
 11922                                  
 11923                                  ECritDisk_3:
 11924                                  ; ----------------------------------------
 11925                                  LCritDisk_3:
 11926                                  ECritDevice_3:
 11927                                  LCritDevice_3:
 11928 0000192E 59                      	pop	cx
 11929 0000192F C3                      	retn
 11930                                  
 11931                                  ; ---------------------------------------------------------------------------
 11932                                  LCritMEM:
 11933                                  LCritSFT:
 11934                                  ; ---------------------------------------------------------------------------
 11935                                  	; PCDOS 7.1 IBMDOS.COM
 11936                                  LCritDisk:
 11937 00001930 51                      	push	cx
 11938 00001931 B500                    	mov	ch,0
 11939 00001933 368A0E[860D]            	mov	cl,[ss:redir_patch]
 11940 00001938 E3F4                    	jcxz	LCritDisk_3
 11941 0000193A 59                      	pop	cx
 11942 0000193B 50                      	push	ax
 11943 0000193C B80181                  	mov	ax,8101h	; END DOS CRITICAL SECTION
 11944                                  				; AL = critical section number (01h)
 11945 0000193F EBD1                    	jmp	short LCritDisk_1
 11946                                  
 11947                                  ; ---------------------------------------------------------------------------
 11948                                  
 11949                                  ECritDevice:
 11950 00001941 51                      	push	cx
 11951 00001942 B500                    	mov	ch,0
 11952 00001944 368A0E[860D]            	mov	cl,[ss:redir_patch]
 11953 00001949 E3E3                    	jcxz	ECritDevice_3
 11954 0000194B 59                      	pop	cx
 11955 0000194C 50                      	push	ax
 11956 0000194D B80280                  	mov	ax,8002h	; BEGIN DOS CRITICAL SECTION
 11957                                  				; AL = critical section number (02h)
 11958 00001950 EBC0                    	jmp	short ECritDevice_1
 11959                                  
 11960                                  ; ---------------------------------------------------------------------------
 11961                                  
 11962                                  LCritDevice:
 11963 00001952 51                      	push	cx
 11964 00001953 B500                    	mov	ch,0
 11965 00001955 368A0E[860D]            	mov	cl,[ss:redir_patch]
 11966 0000195A E3D2                    	jcxz	LCritDevice_3
 11967 0000195C 59                      	pop	cx
 11968 0000195D 50                      	push	ax
 11969 0000195E B80281                  	mov	ax,8102h	; END DOS CRITICAL SECTION
 11970                                  				; AL = critical section number (02h)
 11971 00001961 EBAF                    	jmp	short LCritDevice_1
 11972                                  
 11973                                  ; ---------------------------------------------------------------------------
 11974                                  	;;;
 11975                                  %endif
 11976                                  
 11977                                  ;============================================================================
 11978                                  ; CPMIO.ASM, MSDOS 6.0, 1991
 11979                                  ;============================================================================
 11980                                  ; 20/07/2018 - Retro DOS v3.0
 11981                                  
 11982                                  ;============================================================================
 11983                                  ; STDIO.ASM - (MSDOS 2.0)
 11984                                  ;============================================================================
 11985                                  
 11986                                  ;
 11987                                  ; Standard device IO for MSDOS (first 12 function calls)
 11988                                  ;
 11989                                  
 11990                                  ;.xlist
 11991                                  ;.xcref
 11992                                  ;INCLUDE STDSW.ASM
 11993                                  ;INCLUDE DOSSEG.ASM
 11994                                  ;.cref
 11995                                  ;.list
 11996                                  
 11997                                  ;TITLE   STDIO - device IO for MSDOS
 11998                                  ;NAME    STDIO
 11999                                  
 12000                                  ;INCLUDE IO.ASM
 12001                                  
 12002                                  ; ---------------------------------------------------------------------------
 12003                                  ;
 12004                                  ; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
 12005                                  ;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
 12006                                  ;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
 12007                                  ;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
 12008                                  ;			    to restore MSDOS 2.0 device IO source code 
 12009                                  ;
 12010                                  ;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)	
 12011                                  	
 12012                                  ;============================================================================
 12013                                  ; STDIO.ASM - (MSDOS 2.0)
 12014                                  ;============================================================================
 12015                                  
 12016                                  ;
 12017                                  ; Standard device IO for MSDOS (first 12 function calls)
 12018                                  ;
 12019                                  
 12020                                  ;.xlist
 12021                                  ;.xcref
 12022                                  ;INCLUDE STDSW.ASM
 12023                                  ;INCLUDE DOSSEG.ASM
 12024                                  ;.cref
 12025                                  ;.list
 12026                                  
 12027                                  ;TITLE   STDIO - device IO for MSDOS
 12028                                  ;NAME    STDIO
 12029                                  
 12030                                  ;INCLUDE IO.ASM
 12031                                  
 12032                                  ; ---------------------------------------------------------------------------
 12033                                  ;
 12034                                  ; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
 12035                                  ;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
 12036                                  ;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
 12037                                  ;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
 12038                                  ;			    to restore MSDOS 2.0 device IO source code 
 12039                                  ;
 12040                                  ;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)		
 12041                                  ;
 12042                                  ;============================================================================
 12043                                  ; IO.ASM (MSDOS 2.0) (IBMDOS.COM 2.0) - STRIN.ASM (MSDOS 2.0, 19/08/1983)
 12044                                  ;============================================================================
 12045                                  ; Retro DOS v2.0 by Erdogan Tan, 13/03/2018 - 14/03/2018
 12046                                  
 12047                                  ; (Disassembled code of IBMDOS.COM, 08/03/1983) - Dissassembler: IDA Pro Free
 12048                                  ; (Comments are from CPMIO.ASM - 1991, MSDOS 6.0) 
 12049                                  
 12050                                  ;============================================================================
 12051                                  ; CPMIO.ASM (MSDOS 6.0, 1991)
 12052                                  ;============================================================================
 12053                                  ; Retro DOS v4.0 by Erdogan Tan, 04/05/2019
 12054                                  
 12055                                  	; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12056                                  
 12057                                  ;**	Standard device IO for MSDOS (first 12 function calls)
 12058                                  ;
 12059                                  ;	TITLE	IBMCPMIO - device IO for MSDOS
 12060                                  ;	NAME	IBMCPMIO
 12061                                  
 12062                                  ;	Old style CP/M 1-12 system calls to talk to reserved devices
 12063                                  ;
 12064                                  ;	$Std_Con_Input_No_Echo
 12065                                  ;	$Std_Con_String_Output
 12066                                  ;	$Std_Con_String_Input
 12067                                  ;	$RawConIO
 12068                                  ;	$RawConInput
 12069                                  ;	RAWOUT
 12070                                  ;	RAWOUT2
 12071                                  ;
 12072                                  
 12073                                  ; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
 12074                                  ; They assume ES and DS NOTHING, while not strictly correct, this forces data
 12075                                  ; references to be SS or CS relative which is desired.
 12076                                  
 12077                                  ; ---------------------------------------------------------------------------
 12078                                  
 12079                                  ;	TITLE	CPMIO2 - device IO for MSDOS
 12080                                  ;	NAME	CPMIO2
 12081                                  
 12082                                  ;
 12083                                  ;	Microsoft Confidential
 12084                                  ;	Copyright (C) Microsoft Corporation 1991
 12085                                  ;	All Rights Reserved.
 12086                                  ;
 12087                                  
 12088                                  ;**	Old style CP/M 1-12 system calls to talk to reserved devices
 12089                                  ;
 12090                                  ;	$Std_Con_Input
 12091                                  ;	$Std_Con_Output
 12092                                  ;	OUTT
 12093                                  ;	TAB
 12094                                  ;	BUFOUT
 12095                                  ;	$Std_Aux_Input
 12096                                  ;	$Std_Aux_Output
 12097                                  ;	$Std_Printer_Output
 12098                                  ;	$Std_Con_Input_Status
 12099                                  ;	$Std_Con_Input_Flush
 12100                                  ;
 12101                                  ;	Revision History:
 12102                                  ;
 12103                                  ;	  AN000	 version 4.00 - Jan. 1988
 12104                                  
 12105                                  ; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
 12106                                  ; They assume ES and DS NOTHING, while not strictly correct, this forces data
 12107                                  ; references to be SS or CS relative which is desired.
 12108                                  
 12109                                  ;DOSCODE SEGMENT
 12110                                  ;	ASSUME	SS:DOSDATA,CS:DOSCODE
 12111                                  
 12112                                  
 12113                                  ;hkn; 	All the variables use SS override or DS. Therefore there is
 12114                                  ;hkn;	no need to specifically set up any seg regs unless SS assumption is
 12115                                  ;hkn;	not valid. 
 12116                                  
 12117                                  ; DOSCODE:51BAh (MSDOS 6.21, MSDOS.SYS)
 12118                                  ; 08/11/2022
 12119                                  ; DOSCODE:51A6h (MSDOS 5.0, MSDOS.SYS)
 12120                                  
 12121                                  ;
 12122                                  ;----------------------------------------------------------------------------
 12123                                  ;
 12124                                  ; Procedure : $Std_Con_Input_No_Echo
 12125                                  ;
 12126                                  ;----------------------------------------------------------------------------
 12127                                  ;
 12128                                  
 12129                                  _$STD_CON_INPUT_NO_ECHO:   ;System call 8
 12130                                  
 12131                                  ; Inputs:
 12132                                  ;	None
 12133                                  ; Function:
 12134                                  ;	Input character from console, no echo
 12135                                  ; Returns:
 12136                                  ;	AL = character
 12137                                  
 12138 00001963 1E                      	push	ds
 12139 00001964 56                      	push	si
 12140                                  INTEST:
 12141 00001965 E8DC41                  	call	STATCHK
 12142 00001968 753B                    	jnz	short GET ; 08/09/2018
 12143                                  ;*************************************************************************
 12144                                  ;hkn; SS override
 12145 0000196A 36803E[A00A]00          	cmp	byte [SS:PRINTER_FLAG],0  ; is printer idle?
 12146 00001970 7505                    	jnz	short no_sys_wait
 12147 00001972 B405                    	mov	ah,5			; get input status with system wait
 12148 00001974 E80435                  	call	IOFUNC
 12149                                  no_sys_wait:
 12150                                  ;**************************************************************************
 12151 00001977 B484                    	MOV	AH,84h		; (Microsoft Networks - KEYBOARD BUSY LOOP)
 12152 00001979 CD2A                    	INT	int_IBM	 ; int 2Ah
 12153                                  
 12154                                  ;;; 7/15/86  update the date in the idle loop
 12155                                  ;;; Dec 19, 1986 D.C.L. changed following CMP to Byte Ptr from Word Ptr
 12156                                  ;;;;		 to shorten loop in consideration of the PC Convertible
 12157                                  
 12158                                  ;hkn; SS override
 12159 0000197B 36803E[E20D]FF          	CMP	byte [SS:DATE_FLAG],-1	; date is updated may be every
 12160 00001981 751B                    	JNZ	short NoUpdate		; 65535 x ? ms if no one calls
 12161                                  
 12162 00001983 50                      	PUSH	AX
 12163 00001984 53                      	PUSH	BX			; following is tricky,
 12164 00001985 51                      	PUSH	CX			; it may be called by critical handler
 12165 00001986 52                      	PUSH	DX			; at that time, DEVCALL is used by
 12166                                  					; other's READ or WRITE
 12167 00001987 1E                      	PUSH	DS			; save DS = SFT's segment
 12168                                  
 12169                                  ;hkn; READTIME must use ds = DOSDATA
 12170                                  ;hkn;	PUSH	CS			; READTIME must use DS=CS
 12171                                  
 12172 00001988 16                      	PUSH	SS ; 04/05/2019
 12173 00001989 1F                      	POP	DS
 12174                                  
 12175 0000198A B80000                  	MOV	AX,0			; therefore, we save DEVCALL
 12176 0000198D E89402                  	CALL	Save_Restore_Packet	; save DEVCALL packet
 12177                                  	;invoke	READTIME		; readtime
 12178 00001990 E803F2                  	call	READTIME
 12179 00001993 B80100                  	MOV	AX,1
 12180 00001996 E88B02                  	CALL	Save_Restore_Packet	; restore DEVCALL packet
 12181                                  
 12182                                  ;	; MSDOS 3.3 (IBMDOS.COM, Offset 1F8Ch)
 12183                                  ;	; (MSDOS 6.0 code does not contain IBM DOS FETCHI_TAG check)
 12184                                  ;	push	bx
 12185                                  ;	mov	bx,DATE_FLAG
 12186                                  ;	add	bx,2  ; mov bx,FETCHI_FLAG
 12187                                  ;	cmp	word [cs:bx],5872h
 12188                                  ;	jz	short FETCHI_TAG_chk_ok
 12189                                  ;	call	DOSINIT
 12190                                  ;FETCHI_TAG_chk_ok:
 12191                                  ;	pop	bx
 12192                                  
 12193 00001999 1F                      	POP	DS			; restore DS
 12194 0000199A 5A                      	POP	DX
 12195 0000199B 59                      	POP	CX
 12196 0000199C 5B                      	POP	BX
 12197 0000199D 58                      	POP	AX
 12198                                  NoUpdate:
 12199                                  
 12200                                  ;hkn; SS override
 12201 0000199E 36FF06[E20D]            	INC	word [SS:DATE_FLAG]
 12202                                  
 12203                                  ;;; 7/15/86 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 12204 000019A3 EBC0                    	JMP	short INTEST
 12205                                  GET:
 12206 000019A5 30E4                    	XOR	AH,AH
 12207 000019A7 E8D134                  	call	IOFUNC
 12208 000019AA 5E                      	POP	SI
 12209 000019AB 1F                      	POP	DS
 12210                                  ;;; 7/15/86
 12211                                  
 12212                                  ;hkn; SS override
 12213                                  	; MSDOS 6.0
 12214 000019AC 36C606[E10D]00          	MOV	BYTE [SS:SCAN_FLAG],0
 12215                                  	;
 12216 000019B2 3C00                    	CMP	AL,0	    ; extended code ( AL )
 12217 000019B4 7505                    	JNZ	short noscan
 12218                                  
 12219                                  ;hkn; SS override
 12220                                  	;MOV	BYTE [SS:SCAN_FLAG],1 ; set this flag for ALT_Q key
 12221                                  	; 20/06/2023
 12222 000019B6 36FE06[E10D]            	inc	byte [SS:SCAN_FLAG]
 12223                                  noscan:
 12224 000019BB C3                      	retn
 12225                                  ;
 12226                                  ;----------------------------------------------------------------------------
 12227                                  ;
 12228                                  ;**	$STD_CON_STRING_OUTPUT - Console String Output
 12229                                  ;
 12230                                  ;
 12231                                  ;	ENTRY	(DS:DX) Point to output string '$' terminated
 12232                                  ;	EXIT	none
 12233                                  ;	USES	ALL
 12234                                  ;
 12235                                  ;----------------------------------------------------------------------------
 12236                                  ;
 12237                                  
 12238                                  _$STD_CON_STRING_OUTPUT:	;System call 9
 12239                                  
 12240 000019BC 89D6                    	mov	si,dx
 12241                                  STRING_OUT1:	
 12242 000019BE AC                      	lodsb
 12243 000019BF 3C24                    	cmp	al,'$'
 12244 000019C1 74F8                    	je	short noscan
 12245                                  NEXT_STR1:
 12246 000019C3 E88702                  	call	OUTT
 12247 000019C6 EBF6                    	jmp	short STRING_OUT1
 12248                                  
 12249                                  ;----------------------------------------------------------------------------
 12250                                  ;
 12251                                  ;**	$STD_CON_STRING_INPUT - Input Line from Console
 12252                                  ;
 12253                                  ;	$STD_CON_STRING_INPUT Fills a buffer from console input until CR
 12254                                  ;
 12255                                  ;	ENTRY	(ds:dx) = input buffer
 12256                                  ;	EXIT	none
 12257                                  ;	USES	ALL
 12258                                  ;
 12259                                  ;----------------------------------------------------------------------------
 12260                                  
 12261                                  	; 15/01/2024 - Retro DOS v5.0
 12262                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:58D4h
 12263                                  
 12264                                  _$STD_CON_STRING_INPUT:		;System call 10
 12265                                  
 12266                                  	; 15/01/2024
 12267                                  	;mov	ax,ss
 12268                                  	;mov	es,ax
 12269 000019C8 16                      	push	ss
 12270 000019C9 07                      	pop	es
 12271                                  
 12272 000019CA 89D6                    	mov	si,dx
 12273 000019CC 30ED                    	xor	ch,ch
 12274 000019CE AD                      	lodsw
 12275                                  
 12276                                  ;	(AL) = the buffer length
 12277                                  ;	(AH) = the template length
 12278                                  
 12279 000019CF 08C0                            or	al,al
 12280 000019D1 74E8                            jz	short noscan	;Buffer is 0 length!!?
 12281 000019D3 88E3                    	mov	bl,ah		;Init template counter
 12282 000019D5 88EF                            mov	bh,ch		;Init template counter
 12283                                  
 12284                                  ;	(BL) = the number of bytes in the template
 12285                                  
 12286 000019D7 38D8                            cmp	al,bl
 12287 000019D9 7605                            jbe	short NOEDIT	;If length of buffer inconsistent with contents
 12288 000019DB 80380D                          cmp	byte [bx+si],c_CR ; 0Dh
 12289 000019DE 7402                            jz	short EDITON	;If CR correctly placed EDIT is OK
 12290                                  
 12291                                  ; The number of chars in the template is >= the number of chars in buffer or
 12292                                  ; there is no CR at the end of the template. This is an inconsistant state
 12293                                  ; of affairs. Pretend that the template was empty:
 12294                                  ;
 12295                                  
 12296                                  NOEDIT:	
 12297 000019E0 88EB                    	mov	bl,ch		;Reset buffer
 12298                                  EDITON: 
 12299 000019E2 88C2                    	mov	dl,al
 12300 000019E4 4A                      	dec	dx		;DL is # of bytes we can put in the buffer
 12301                                  
 12302                                  ;	Top level. We begin to read a line in.
 12303                                  
 12304                                  NEWLIN: 
 12305 000019E5 36A0[F901]              	mov	al,[SS:CARPOS]
 12306 000019E9 36A2[FA01]              	mov	[SS:STARTPOS],al ;Remember position in raw buffer
 12307                                  
 12308 000019ED 56                      	push	si
 12309 000019EE BF[FB01]                	mov	di,INBUF ;Build the new line here
 12310 000019F1 36882E[7905]            	mov	byte [SS:INSMODE],ch ;Insert mode off
 12311 000019F6 88EF                    	mov	bh,ch		;No chars from template yet
 12312 000019F8 88EE                    	mov	dh,ch		;No chars to new line yet
 12313 000019FA E866FF                  	call	_$STD_CON_INPUT_NO_ECHO ;Get first char
 12314 000019FD 3C0A                    	cmp	al,c_LF		; 0Ah	;Linefeed 
 12315 000019FF 7503                    	jnz	short GOTCH
 12316                                  
 12317                                  ;	This is the main loop of reading in a character and processing it.
 12318                                  ;
 12319                                  ;	(BH) = the index of the next byte in the template
 12320                                  ;	(BL) = the length of the template
 12321                                  ;	(DH) = the number of bytes in the buffer
 12322                                  ;	(DL) = the length of the buffer
 12323                                  
 12324                                  GETCH:
 12325 00001A01 E85FFF                  	call	_$STD_CON_INPUT_NO_ECHO
 12326                                  GOTCH:
 12327                                  ;
 12328                                  ; Brain-damaged Tim Patterson ignored ^F in case his BIOS did not flush the
 12329                                  ; input queue.
 12330                                  ;
 12331 00001A04 3C06                            cmp	al,"F"-"@"  ; CMP AL, 6  ; Ignore ^F
 12332 00001A06 74F9                    	jz	short GETCH
 12333                                  
 12334                                  ;	If the leading char is the function-key lead byte
 12335                                  
 12336                                  	;cmp	al,[SS:ESCCHAR]
 12337                                  
 12338                                  	; 04/05/2019 - Retro DOS v4.0
 12339                                  
 12340                                  ;hkn; 	ESCCHAR is in TABLE seg (DOSCODE)
 12341                                  
 12342 00001A08 2E3A06[960A]            	CMP	AL,[cs:ESCCHAR]
 12343 00001A0D 7439                            jz	short ESCAPE	;change reserved keyword DBM 5-7-87
 12344                                  
 12345                                  ;	Rubout and ^H are both destructive backspaces.
 12346                                  
 12347 00001A0F 3C7F                            cmp	al,c_DEL ; 7FH
 12348                                          ;jz	short BACKSPJ
 12349                                          ; 15/01/2024
 12350 00001A11 7466                    	je	short BACKSP
 12351 00001A13 3C08                    	cmp	al,c_BS  ; 8
 12352                                          ;jz	short BACKSPJ
 12353                                          ; 15/01/2024
 12354 00001A15 7462                    	je	short BACKSP
 12355                                  
 12356                                  	; 04/05/2019 -	MSDOS 6.0, also MSDOS 6.21 has bug (bullshit) here.
 12357                                  	;		Two NOPs -instead of a JMP short, as two bytes-
 12358                                  	;	   	after CMP and a CMP again!
 12359                                  	;		
 12360                                  	;		-It would be better if they use a 'JMP short' to 
 12361                                  	;	      	DOSCODE:5279h from DOSCODE:5271h and leave NOPs
 12362                                  	;		between them. Then, they would be able use a patch
 12363                                  	;		between 5271h and 5279h when if it will be required.
 12364                                  	;		I think Tim Patterson would not do this CMP mistake!-
 12365                                  	;	
 12366                                  	; (MSDOS.SYS, from DOSCODE:5271h to DOSCODE:5279h)
 12367                                  
 12368                                  	; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12369                                  	;
 12370                                  	; (Note: nops below might be used for patching code for Windows 3.1)
 12371                                  
 12372                                  ;DOSCODE:526D	cmp     al, 8
 12373                                  ;DOSCODE:526F	jz      short BACKSPJ
 12374                                  ;DOSCODE:5271	cmp     al, 17h
 12375                                  ;DOSCODE:5273	nop
 12376                                  ;DOSCODE:5274	nop
 12377                                  ;DOSCODE:5275	cmp     al, 15h
 12378                                  ;DOSCODE:5277	nop
 12379                                  ;DOSCODE:5278	nop
 12380                                  ;DOSCODE:5279	cmp     al, 0Dh
 12381                                  ;DOSCODE:527B	jz      short ENDLIN
 12382                                  ;DOSCODE:527D	cmp     al, 0Ah
 12383                                  ;DOSCODE:527F	jz      short PHYCRLF
 12384                                  	
 12385                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12386                                  	; DOSCODE:525Dh
 12387                                  
 12388                                  ; 16/12/2022
 12389                                  %if 0
 12390                                  	; MSDOS 6.0
 12391                                  ;	^W deletes backward once and then backs up until a letter is before the
 12392                                  ;	cursor
 12393                                  
 12394                                  	CMP     AL,"W"-"@" ; 17h
 12395                                  
 12396                                  ;	The removal of the comment characters before the jump statement will
 12397                                  ;	cause ^W to backup a word.
 12398                                  
 12399                                  ;***	JZ	short WordDel
 12400                                  	NOP
 12401                                  	NOP
 12402                                  
 12403                                  	CMP     AL,"U"-"@" ; 15h
 12404                                  
 12405                                  ;	The removal of the comment characters before the jump statement will
 12406                                  ;	cause ^U to clear a line.
 12407                                  
 12408                                  ;***	JZ	short LineDel
 12409                                  	NOP
 12410                                  	NOP
 12411                                  
 12412                                  %endif
 12413                                  
 12414                                  ;	CR terminates the line.
 12415                                  
 12416 00001A17 3C0D                            cmp	al,c_CR ; 0Dh
 12417 00001A19 7430                            jz	short ENDLIN
 12418                                  
 12419                                  ;	LF goes to a new line and keeps on reading.
 12420                                  
 12421 00001A1B 3C0A                            cmp	al,c_LF ; 0Ah
 12422 00001A1D 7442                    	jz	short PHYCRLF
 12423                                  
 12424                                  ;	^X (or ESC) deletes the line and starts over
 12425                                  
 12426                                  	; MSDOS 3.3
 12427                                  	;cmp	al,[ss:CANCHAR] ; 1Bh
 12428                                  	;jz	short KILNEW
 12429                                  
 12430                                  	; MSDOS 6.0 (& MSDOS 6.21)
 12431                                  
 12432                                  ;hkn; 	CANCHAR is in TABLE seg (DOSCODE), so CS override
 12433                                  
 12434 00001A1F 2E3A06[950A]            	cmp	al,[cs:CANCHAR] ; 1Bh
 12435 00001A24 7440                    	jz	short KILNEW
 12436                                  	
 12437                                  	;cmp	al,CANCEL ; 1Bh	; Retro DOS v3.0
 12438                                  	;jz	short KILNEW
 12439                                  
 12440                                  ; Otherwise, we save the input character.
 12441                                  
 12442                                  SAVCH:	
 12443 00001A26 38D6                    	cmp	dh,dl
 12444 00001A28 7317                    	jnb	short BUFFUL		; buffer is full.
 12445 00001A2A AA                              stosb
 12446 00001A2B FEC6                    	inc	dh                      ; increment count in buffer.
 12447 00001A2D E8B102                  	call	BUFOUT			; Print control chars nicely
 12448                                  
 12449 00001A30 36803E[7905]00                  cmp	byte [SS:INSMODE], 0
 12450 00001A36 75C9                    	jnz	short GETCH		; insertmode => don't advance template
 12451 00001A38 38DF                            cmp	bh,bl
 12452 00001A3A 73C5                            jnb	short GETCH		; no more characters in template
 12453 00001A3C 46                              inc	si                      ; Skip to next char in template
 12454 00001A3D FEC7                            inc	bh                      ; remember position in template
 12455 00001A3F EBC0                            jmp	short GETCH
 12456                                  
 12457                                  	; 15/01/2024
 12458                                  ;BACKSPJ: 
 12459                                  	;jmp	short BACKSP
 12460                                  
 12461                                  BUFFUL: 
 12462 00001A41 B007                    	mov	al, 7			; Bell to signal full buffer
 12463 00001A43 E80702                  	call	OUTT
 12464 00001A46 EBB9                    	jmp	short GETCH
 12465                                  
 12466                                  ESCAPE: 
 12467                                  	;transfer OEMFunctionKey
 12468 00001A48 E976F0                  	JMP	OEMFunctionKey		; let the OEM's handle the key dispatch
 12469                                  
 12470                                  ENDLIN:
 12471 00001A4B AA                              stosb				; Put the CR in the buffer
 12472 00001A4C E8FE01                  	call	OUTT                    ; Echo it
 12473 00001A4F 5F                              pop	di                      ; Get start of user buffer
 12474 00001A50 8875FF                          mov	[di-1], dh		; Tell user how many bytes
 12475 00001A53 FEC6                            inc	dh			; DH is length including CR
 12476                                  
 12477                                  COPYNEW:
 12478                                  	; (IBMDOS.COM, MSDOS 2.0, STRIN.ASM)
 12479                                  	;mov	bp, es
 12480                                  	;mov	bx, ds
 12481                                  	;mov	es, bx
 12482                                  	;mov	ds, bp
 12483                                  	;mov	si, INBUF
 12484                                  	;mov	cl, dh
 12485                                  	;rep	movsb
 12486                                  	;retn
 12487                                  
 12488                                  	; CPMIO.ASM (MSDOS 6.0)
 12489                                  	; (IBMDOS.COM, MSDOS 3.3, Offset 2061h) 
 12490                                  	;SAVE	<DS,ES>
 12491 00001A55 1E                      	PUSH	DS
 12492 00001A56 06                      	PUSH	ES
 12493                                  	;RESTORE <DS,ES>		; XCHG ES,DS
 12494 00001A57 1F                      	POP	DS
 12495 00001A58 07                      	POP	ES
 12496                                  
 12497                                  ;;hkn; INBUF is in DOSDATA
 12498 00001A59 BE[FB01]                        MOV     SI,INBUF
 12499 00001A5C 88F1                            MOV     CL,DH                   ; set up count
 12500 00001A5E F3A4                            REP     MOVSB                   ; Copy final line to user buffer
 12501                                  OLDBAK_RETN:
 12502 00001A60 C3                              RETN
 12503                                  
 12504                                  ;	Output a CRLF to the user screen and do NOT store it into the buffer
 12505                                  
 12506                                  PHYCRLF:
 12507 00001A61 E81B01                  	CALL	CRLF
 12508 00001A64 EB9B                            JMP	short GETCH
 12509                                  
 12510                                  	; MSDOS 6.0 (& MSDOS 3.3, IBMDOS.COM, 1987)
 12511                                  
 12512                                  ; DOSCODE:52CAh (MSDOS 621, MSDOS.SYS)
 12513                                  
 12514                                  	; Note: Following routines were not used in IBMDOS.COM
 12515                                  	;	-CRTL+W, CRTL+U is not activated-
 12516                                  	;	but they were in the kernel code!?)
 12517                                  
 12518                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12519                                  	; DOSCODE:52B6h
 12520                                  
 12521                                  ;;;;;;;;
 12522                                  
 12523                                  ; 16/12/2022
 12524                                  %if 0
 12525                                  ;
 12526                                  ; Delete the previous line
 12527                                  ;
 12528                                  LineDel:
 12529                                  	OR      DH,DH
 12530                                  	JZ	short GETCH	 ; 06/12/2022
 12531                                  	Call    BackSpace
 12532                                  	JMP	short LineDel
 12533                                  
 12534                                  %endif
 12535                                  
 12536                                  ;
 12537                                  ; delete the previous word.
 12538                                  ;
 12539                                  WordDel:
 12540                                  WordLoop:
 12541                                  ;	Call    BackSpace               ; backspace the one spot
 12542                                  ;	OR      DH,DH
 12543                                  ;	JZ	short GetChj
 12544                                  ;	MOV     AL,[ES:DI-1]
 12545                                  ;	cmp     al,'0'
 12546                                  ;	jb	short GetChj
 12547                                  ;	cmp     al,'9'
 12548                                  ;	jbe	short WordLoop
 12549                                  ;	OR      AL,20h
 12550                                  ;	CMP     AL,'a'
 12551                                  ;	JB	short GetChj
 12552                                  ;	CMP     AL,'z'
 12553                                  ;	JBE	short WordLoop
 12554                                  ;GetChj: 
 12555                                  ;	JMP	GETCH
 12556                                  
 12557                                  ; 16/12/2022
 12558                                  %if 0
 12559                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12560                                  	; (Worddel is not called or jumped from anywhere!)
 12561                                  WordDel:
 12562                                  WordLoop:
 12563                                  	Call    BackSpace               ; backspace the one spot
 12564                                  	OR      DH,DH
 12565                                  	JZ	short GetChj
 12566                                  	MOV     AL,[ES:DI-1]
 12567                                  	cmp     al,'0'
 12568                                  	jb	short GetChj
 12569                                  	cmp     al,'9'
 12570                                  	jbe	short WordLoop
 12571                                  	OR      AL,20h
 12572                                  	CMP     AL,'a'
 12573                                  	JB	short GetChj
 12574                                  	CMP     AL,'z'
 12575                                  	JBE	short WordLoop
 12576                                  GetChj: 
 12577                                  	JMP	GETCH
 12578                                  
 12579                                  %endif
 12580                                  
 12581                                  ;;;;;;;;
 12582                                  
 12583                                  ; DOSCODE:52F3h (MSDOS 621, MSDOS.SYS)
 12584                                  
 12585                                  ; The user wants to throw away what he's typed in and wants to start over.
 12586                                  ; We print the backslash and then go to the next line and tab to the correct
 12587                                  ; spot to begin the buffered input.
 12588                                  
 12589                                  KILNEW:
 12590 00001A66 B05C                            mov	al,'\'
 12591 00001A68 E8E201                          call	OUTT            ;Print the CANCEL indicator
 12592 00001A6B 5E                              pop	si		;Remember start of edit buffer
 12593                                  PUTNEW:
 12594 00001A6C E81001                  	call	CRLF            ;Go to next line on screen
 12595 00001A6F 36A0[FA01]              	mov	al,[SS:STARTPOS]
 12596 00001A73 E84B02                  	call	TAB             ;Tab over
 12597 00001A76 E96CFF                          JMP     NEWLIN		;Start over again
 12598                                  
 12599                                  ;	Destructively back up one character position
 12600                                  
 12601                                  BACKSP:
 12602                                  	; 09/09/2018
 12603 00001A79 E80800                  	Call    BackSpace
 12604 00001A7C EB83                    	JMP     short GETCH	; 15/01/2024
 12605                                  
 12606                                  	; 15/01/2024
 12607                                  ;User really wants an ESC character in his line
 12608                                  TWOESC:	
 12609 00001A7E 2EA0[960A]              	mov	al,[cs:ESCCHAR] ; 10/06/2019
 12610 00001A82 EBA2                    	jmp	short SAVCH
 12611                                  
 12612                                  BackSpace:
 12613 00001A84 08F6                    	or	dh,dh
 12614 00001A86 7419                    	jz	short OLDBAK	;No chars in line, do nothing to line
 12615 00001A88 E85800                  	call	BACKUP          ;Do the backup
 12616 00001A8B 268A05                  	mov	al,[es:di]	;Get the deleted char
 12617 00001A8E 3C20                            cmp	al,20h	; ' '
 12618 00001A90 730F                    	jnb	short OLDBAK	;Was a normal char
 12619 00001A92 3C09                            cmp	al,c_HT ; 9
 12620 00001A94 741B                    	jz	short BAKTAB	;Was a tab, fix up users display
 12621                                  ;; 9/27/86 fix for ctrl-U backspace
 12622 00001A96 3C15                    	CMP     AL,"U"-"@" ; 15h ; ctrl-U is a section symbol not ^U
 12623 00001A98 7407                    	JZ	short OLDBAK
 12624 00001A9A 3C14                           	CMP     AL,"T"-"@" ; 14h ; ctrl-T is a paragraphs symbol not ^T
 12625 00001A9C 7403                    	JZ	short OLDBAK
 12626                                  ;; 9/27/86 fix for ctrl-U backspace
 12627 00001A9E E84500                          call	BACKMES         ;Was a control char, zap the '^'
 12628                                  OLDBAK:
 12629 00001AA1 36803E[7905]00                  cmp	byte [SS:INSMODE], 0
 12630 00001AA7 75B7                    	jnz	short OLDBAK_RETN ;In insert mode, done
 12631 00001AA9 08FF                    	or	bh,bh
 12632 00001AAB 74B3                            jz	short OLDBAK_RETN 
 12633                                  				;Not advanced in template, stay where we are
 12634 00001AAD FECF                    	dec	bh		;Go back in template
 12635 00001AAF 4E                              dec	si
 12636 00001AB0 C3                      	retn
 12637                                  BAKTAB:
 12638 00001AB1 57                              push	di
 12639 00001AB2 4F                              dec	di		;Back up one char
 12640 00001AB3 FD                              std			;Go backward
 12641 00001AB4 88F1                            mov	cl,dh		;Number of chars currently in line
 12642 00001AB6 B020                            mov	al,20h	; ' '
 12643 00001AB8 53                              push	bx
 12644 00001AB9 B307                            mov	bl,7		;Max
 12645 00001ABB E30E                            jcxz	FIGTAB		;At start, do nothing
 12646                                  FNDPOS:
 12647 00001ABD AE                              scasb			;Look back
 12648 00001ABE 7609                    	jbe	short CHKCNT
 12649 00001AC0 26807D0109              	cmp	byte [es:di+1],9
 12650 00001AC5 7409                    	jz	short HAVTAB	;Found a tab
 12651 00001AC7 FECB                    	dec	bl		;Back one char if non tab control char
 12652                                  CHKCNT:
 12653 00001AC9 E2F2                            loop	FNDPOS
 12654                                  FIGTAB:		
 12655 00001ACB 362A1E[FA01]            	sub	bl,[SS:STARTPOS]
 12656                                  HAVTAB:
 12657 00001AD0 28F3                    	sub	bl,dh
 12658 00001AD2 00D9                    	add	cl,bl
 12659 00001AD4 80E107                  	and	cl,7		;CX has correct number to erase
 12660 00001AD7 FC                      	cld			;Back to normal
 12661 00001AD8 5B                      	pop	bx
 12662 00001AD9 5F                      	pop	di
 12663 00001ADA 74C5                    	jz	short OLDBAK	;Nothing to erase
 12664                                  TABBAK:
 12665 00001ADC E80700                  	call	BACKMES
 12666 00001ADF E2FB                    	loop	TABBAK		;Erase correct number of chars
 12667 00001AE1 EBBE                    	jmp	short OLDBAK
 12668                                  
 12669                                  BACKUP:
 12670 00001AE3 FECE                            dec	dh		;Back up in line
 12671 00001AE5 4F                              dec	di
 12672                                  BACKMES:
 12673 00001AE6 B008                            mov	al,c_BS ; 8	;Backspace
 12674 00001AE8 E86201                          call	OUTT
 12675 00001AEB B020                            mov	al,20h ; ' '	;Erase
 12676 00001AED E85D01                          call	OUTT
 12677 00001AF0 B008                            mov	al,c_BS ; 8	;Backspace
 12678 00001AF2 E95801                  	jmp	OUTT		;Done
 12679                                  
 12680                                  	; 15/01/2024
 12681                                  ;User really wants an ESC character in his line
 12682                                  ;TWOESC:	
 12683                                  ;	mov	al,[cs:ESCCHAR] ; 10/06/2019
 12684                                  ;	jmp	SAVCH
 12685                                  
 12686                                  ;Copy the rest of the template
 12687                                  COPYLIN:
 12688 00001AF5 88D9                            mov	cl,bl		;Total size of template
 12689 00001AF7 28F9                    	sub	cl,bh		;Minus position in template, is number to move
 12690 00001AF9 EB07                            jmp	short COPYEACH
 12691                                  
 12692                                  COPYSTR:
 12693 00001AFB E83200                  	call	FINDOLD         ;Find the char
 12694 00001AFE EB02                    	jmp	short COPYEACH  ;Copy up to it
 12695                                  
 12696                                  ;Copy one char from template to line
 12697                                  COPYONE:
 12698 00001B00 B101                            mov	cl,1
 12699                                  ;Copy CX chars from template to line
 12700                                  COPYEACH:
 12701 00001B02 36C606[7905]00                  mov	byte [SS:INSMODE],0	;All copies turn off insert mode
 12702 00001B08 38D6                    	cmp	dh,dl
 12703 00001B0A 740F                            jz	short GETCH2		;At end of line, can't do anything
 12704 00001B0C 38DF                            cmp	bh,bl
 12705 00001B0E 740B                            jz	short GETCH2		;At end of template, can't do anything
 12706 00001B10 AC                              lodsb
 12707 00001B11 AA                              stosb
 12708 00001B12 E8CC01                  	call	BUFOUT
 12709 00001B15 FEC7                            inc	bh			;Ahead in template
 12710 00001B17 FEC6                            inc	dh			;Ahead in line
 12711 00001B19 E2E7                            loop	COPYEACH
 12712                                  GETCH2:
 12713 00001B1B E9E3FE                          jmp	GETCH
 12714                                  
 12715                                  ;Skip one char in template
 12716                                  SKIPONE:
 12717 00001B1E 38DF                    	cmp	bh,bl
 12718 00001B20 74F9                    	jz	short GETCH2		;At end of template
 12719 00001B22 FEC7                    	inc	bh			;Ahead in template
 12720 00001B24 46                      	inc	si
 12721                                          ;jmp	GETCH
 12722                                  	; 15/01/2024
 12723 00001B25 EBF4                    	jmp	short GETCH2
 12724                                  
 12725                                  SKIPSTR:
 12726 00001B27 E80600                  	call	FINDOLD                 ;Find out how far to go
 12727 00001B2A 01CE                            add	si,cx			;Go there
 12728 00001B2C 00CF                            add	bh,cl
 12729                                          ;jmp	GETCH
 12730                                  	; 15/01/2024
 12731 00001B2E EBEB                    	jmp	short GETCH2
 12732                                  
 12733                                  ;Get the next user char, and look ahead in template for a match
 12734                                  ;CX indicates how many chars to skip to get there on output
 12735                                  ;NOTE: WARNING: If the operation cannot be done, the return
 12736                                  ;       address is popped off and a jump to GETCH is taken.
 12737                                  ;       Make sure nothing extra on stack when this routine
 12738                                  ;       is called!!! (no PUSHes before calling it).
 12739                                  
 12740                                  FINDOLD:
 12741 00001B30 E830FE                          call	_$STD_CON_INPUT_NO_ECHO
 12742                                  
 12743                                  	; STRIN.ASM (MSDOS 2.11, 19/07/2018) 
 12744                                  
 12745                                  	;CMP     AL,[SS:ESCCHAR]	
 12746                                  	;JNZ     SHORT FINDSETUP
 12747                                  
 12748                                  	; CPMIO.ASM (MSDOS 6.0, 04/05/2019 - Retro DOS v4.0)
 12749                                  
 12750                                  ;hkn; ESCCHAR is in TABLE seg (DOSCODE), so CS override
 12751                                  
 12752 00001B33 2E3A06[960A]            	CMP	AL,[CS:ESCCHAR]		; did he type a function key?
 12753 00001B38 7505                    	JNZ	SHORT FINDSETUP		; no, set up for scan
 12754                                  
 12755 00001B3A E826FE                  	CALL	_$STD_CON_INPUT_NO_ECHO	; eat next char
 12756 00001B3D EB1D                            JMP	SHORT NOTFND		; go try again
 12757                                  FINDSETUP:
 12758 00001B3F 88D9                    	mov	cl,bl
 12759 00001B41 28F9                            sub	cl,bh		;CX is number of chars to end of template
 12760 00001B43 7417                    	jz	short NOTFND	;At end of template
 12761 00001B45 49                              dec	cx		;Cannot point past end, limit search
 12762 00001B46 7414                            jz	short NOTFND	;If only one char in template, forget it
 12763 00001B48 06                      	push	es
 12764 00001B49 1E                      	push	ds
 12765 00001B4A 07                      	pop	es
 12766 00001B4B 57                      	push	di
 12767 00001B4C 89F7                    	mov	di,si		;Template to ES:DI
 12768 00001B4E 47                      	inc	di
 12769 00001B4F F2AE                    	repne	scasb		;Look
 12770 00001B51 5F                      	pop	di
 12771 00001B52 07                      	pop	es
 12772 00001B53 7507                    	jnz	short NOTFND	;Didn't find the char
 12773 00001B55 F6D1                            not	cl		;Turn how far to go into how far we went
 12774 00001B57 00D9                            add	cl,bl		;Add size of template
 12775 00001B59 28F9                            sub	cl,bh		;Subtract current pos, result distance to skip
 12776                                  FINDOLD_RETN:
 12777 00001B5B C3                      	retn
 12778                                  
 12779                                  NOTFND:
 12780 00001B5C 5D                      	pop	bp              ;Chuck return address
 12781                                  	;jmp	GETCH
 12782                                  	; 15/01/2024
 12783                                  GETCH2_j:
 12784 00001B5D EBBC                    	jmp	short GETCH2
 12785                                  
 12786                                  REEDIT:
 12787 00001B5F B040                    	mov	al,'@'		;Output re-edit character
 12788 00001B61 E8E900                  	call	OUTT
 12789 00001B64 5F                      	pop	di
 12790 00001B65 57                      	push	di
 12791 00001B66 06                      	push	es
 12792 00001B67 1E                      	push	ds
 12793 00001B68 E8EAFE                  	call	COPYNEW		;Copy current line into template
 12794 00001B6B 1F                      	pop	ds
 12795 00001B6C 07                      	pop	es
 12796 00001B6D 5E                      	pop	si
 12797 00001B6E 88F3                    	mov	bl,dh		;Size of line is new size template
 12798 00001B70 E9F9FE                  	jmp	PUTNEW		;Start over again
 12799                                  
 12800                                  EXITINS:
 12801                                  ENTERINS:
 12802 00001B73 36F616[7905]            	not	byte [SS:INSMODE]
 12803                                  	;jmp	GETCH
 12804                                  	; 15/01/2024
 12805 00001B78 EBE3                    	jmp	short GETCH2_j
 12806                                  
 12807                                  ;Put a real live ^Z in the buffer (embedded)
 12808                                  CTRLZ:
 12809 00001B7A B01A                    	mov	al,"Z"-"@" ; 1Ah
 12810 00001B7C E9A7FE                          jmp	SAVCH
 12811                                  
 12812                                  ;Output a CRLF
 12813                                  CRLF:
 12814 00001B7F B00D                    	mov	al,c_CR ; 0Dh 
 12815 00001B81 E8C900                  	call	OUTT
 12816 00001B84 B00A                    	mov	al,c_LF ; 0Ah
 12817 00001B86 E9C400                  	jmp	OUTT
 12818                                  
 12819                                  ;
 12820                                  ;----------------------------------------------------------------------------
 12821                                  ;
 12822                                  ;**	$RAW_CON_IO - Do Raw Console I/O
 12823                                  ;
 12824                                  ;	Input or output raw character from console, no echo
 12825                                  ;
 12826                                  ;	ENTRY	DL = -1 if input
 12827                                  ;		   =  output character if output
 12828                                  ;	EXIT	(AL) = input character if input
 12829                                  ;	USES	all
 12830                                  ;
 12831                                  ;----------------------------------------------------------------------------
 12832                                  ; 20/07/2018 - Retro DOS v3.0
 12833                                  
 12834                                  ; 04/05/2019 - Retro DOS v4.0
 12835                                  ; DOSCODE:541Ch (MSDOS 6.21, MSDOS.SYS)
 12836                                  
 12837                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12838                                  ; DOSCODE:5408h (MSDOS 5.0, MSDOS.SYS)
 12839                                  
 12840                                  _$RAW_CON_IO:			; System call 6
 12841                                  
 12842 00001B89 88D0                            MOV	AL,DL
 12843 00001B8B 3CFF                            CMP	AL,-1
 12844 00001B8D 7541                    	JNZ	SHORT RAWOUT ; 16/12/2022
 12845                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12846                                  	;jz	short rci1
 12847                                  	;jmp	short RAWOUT
 12848                                  	; 16/12/202
 12849                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12850                                  	;nop
 12851                                  rci1:
 12852                                  			; Get pointer to register save area
 12853 00001B8F 36C43E[8405]            	LES	DI,[SS:USER_SP] ; 12/03/2018
 12854 00001B94 31DB                    	XOR	BX,BX
 12855                                      	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 12856 00001B96 E85B23                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 12857                                          ;JC	SHORT RET17
 12858 00001B99 72C0                            jc	short FINDOLD_RETN
 12859 00001B9B B401                    	MOV	AH,1
 12860 00001B9D E8DB32                  	CALL	IOFUNC
 12861 00001BA0 750B                    	JNZ	SHORT RESFLG
 12862 00001BA2 E8713F                  	CALL	SPOOLINT
 12863                                  	;OR	BYTE [ES:DI+16H],40H
 12864 00001BA5 26804D1640              	OR	BYTE [ES:DI+user_env.user_F],40H ; Set user's zero flag
 12865 00001BAA 30C0                    	XOR	AL,AL
 12866                                  RET17:
 12867 00001BAC C3                      	RETN
 12868                                  
 12869                                  RESFLG:
 12870                                  	;AND	BYTE [ES:DI+16H],0FFH-40H  ; 0BFh
 12871 00001BAD 26806516BF              	AND	BYTE [ES:DI+user_env.user_F],0FFH-40H
 12872                                  				; Reset user's zero flag
 12873                                  ;RILP:
 12874                                  rci0:
 12875 00001BB2 E8613F                       	CALL	SPOOLINT
 12876                                  ;
 12877                                  ;----------------------------------------------------------------------------
 12878                                  ;
 12879                                  ;**	$Raw_CON_INPUT - Raw Console Input
 12880                                  ;
 12881                                  ;	Input raw character from console, no echo
 12882                                  ;
 12883                                  ;	ENTRY	none
 12884                                  ;	EXIT	(al) = character
 12885                                  ;	USES	all
 12886                                  ;
 12887                                  ;----------------------------------------------------------------------------
 12888                                  ;
 12889                                  
 12890                                  ;rci0:	invoke	SPOOLINT
 12891                                  
 12892                                  	;entry	$RAW_CON_INPUT
 12893                                  
 12894                                  	; 04/05/2019 - Retro DOS v4.0
 12895                                  
 12896                                  ; DOSCODE:544Bh (MSDOS 6.21, MSDOS.SYS)
 12897                                  
 12898                                  	; 15/01/2024 - Retro DOS v5.0
 12899                                  
 12900                                  ; DOSCODE:5ACBh (PCDOS 7.1, IBMDOS.COM)
 12901                                  
 12902                                  _$RAW_CON_INPUT:		; System call 7
 12903 00001BB5 53                      	push	bx
 12904 00001BB6 31DB                    	XOR	BX,BX
 12905                                  	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 12906 00001BB8 E83923                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 12907 00001BBB 5B                      	pop	bx
 12908 00001BBC 72EE                    	JC	SHORT RET17
 12909 00001BBE B401                    	MOV	AH,1
 12910 00001BC0 E8B832                  	CALL	IOFUNC
 12911                                  	;JZ	SHORT RILP	; MSDOS 2.11
 12912                                  	;XOR	AH,AH
 12913                                          ;CALL	IOFUNC
 12914                                          ;RETN
 12915 00001BC3 7506                    	jnz	short rci5	; MSDOS 3.3 & MSDOS 6.0
 12916 00001BC5 B484                    	MOV	AH,84h
 12917 00001BC7 CD2A                    	INT	int_IBM  ; int 2Ah
 12918 00001BC9 EBE7                    	JMP	short rci0
 12919                                  rci5:	
 12920 00001BCB 30E4                    	XOR	AH,AH
 12921                                  	;CALL	IOFUNC
 12922                                  	;RETN
 12923                                  	; 18/12/2022
 12924 00001BCD E9AB32                  	jmp	IOFUNC
 12925                                  
 12926                                  ;       Output the character in AL to stdout
 12927                                  ;
 12928                                  	;entry	RAWOUT
 12929                                  RAWOUT:
 12930 00001BD0 53                      	PUSH    BX
 12931 00001BD1 BB0100                  	MOV     BX,1
 12932                                  
 12933                                  	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 12934 00001BD4 E81D23                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 12935 00001BD7 721E                    	JC	SHORT RAWRET1
 12936                                  
 12937                                  	;
 12938                                  	; MSDOS 2.11
 12939                                          ;TEST	BYTE [SI+18H],080H	; output to file?
 12940                                          ;JZ	SHORT RAWNORM		; if so, do normally
 12941                                          ;PUSH	DS
 12942                                          ;PUSH	SI
 12943                                          ;LDS	SI,[SI+19H]		; output to special?
 12944                                  	;TEST	BYTE [SI+4],ISSPEC
 12945                                  	;POP	SI
 12946                                  	;
 12947                                          
 12948                                  	; MSDOS 3.3 & MSDOS 6.0
 12949                                  	;mov	bx,[si+5]
 12950 00001BD9 8B5C05                  	MOV	BX,[SI+SF_ENTRY.sf_flags] ;hkn; DS set up by get_io_sft
 12951                                   ;
 12952                                   ; If we are a network handle OR if we are not a local device then go do the
 12953                                   ; output the hard way.
 12954                                   ;	
 12955                                  	;and	bx,8080h
 12956 00001BDC 81E38080                	AND	BX,sf_isnet+devid_device
 12957                                  	;cmp	bx,80h
 12958 00001BE0 81FB8000                	CMP	BX,devid_device
 12959 00001BE4 7513                    	jnz     short RAWNORM
 12960 00001BE6 1E                      	push    ds
 12961                                  	;lds	bx,[si+7]
 12962 00001BE7 C55C07                  	LDS	BX,[SI+SF_ENTRY.sf_devptr] ; output to special?
 12963                                  	;test	byte [bx+4],10h
 12964 00001BEA F6470410                	TEST	BYTE [BX+SYSDEV.ATT],ISSPEC
 12965                                  	;
 12966                                  
 12967 00001BEE 1F                      	POP	DS
 12968 00001BEF 7408                    	JZ	SHORT RAWNORM		; if not, do normally
 12969                                  
 12970                                  	;INT	int_fastcon  ; int 29h	; quickly output the char
 12971                                  	; 15/01/2024
 12972 00001BF1 9C                      	pushf			; simulate INT 29h
 12973 00001BF2 FF1EA400                	call    far [29h*4]	; call far [00A4h]
 12974                                  
 12975                                  	;JMP	SHORT RAWRET
 12976                                  ;RAWNORM:
 12977                                  ;	CALL    RAWOUT3
 12978                                  RAWRET: 
 12979 00001BF6 F8                      	CLC
 12980                                  RAWRET1:
 12981 00001BF7 5B                      	POP     BX
 12982                                  RAWRET2:
 12983 00001BF8 C3                      	RETN
 12984                                  RAWNORM:
 12985 00001BF9 E80700                  	CALL    RAWOUT3
 12986 00001BFC EBF8                    	jmp	short RAWRET
 12987                                  
 12988                                  ;	Output the character in AL to handle in BX
 12989                                  ;
 12990                                  ;	entry	RAWOUT2
 12991                                  
 12992                                  RAWOUT2:
 12993                                  	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 12994                                  	;JC	SHORT RET18
 12995 00001BFE E8F322                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 12996 00001C01 72F5                    	JC	SHORT RAWRET2
 12997                                  RAWOUT3:
 12998 00001C03 50                      	PUSH	AX
 12999 00001C04 EB0C                    	JMP	SHORT RAWOSTRT
 13000                                  ROLP:
 13001 00001C06 E80D3F                  	CALL	SPOOLINT
 13002                                  
 13003                                  	; 01/05/2019 - Retro DOS v4.0
 13004                                  
 13005                                  	; MSDOS 6.0
 13006                                  	;OR	word [ss:DOS34_FLAG],CTRL_BREAK_FLAG ; 001000000000b
 13007                                  	; 17/12/2022
 13008 00001C09 36800E[1206]02          	or	byte [ss:DOS34_FLAG+1],(CTRL_BREAK_FLAG>>8) ; 02h
 13009                                  	;or	word [ss:DOS34_FLAG],200h
 13010                                  				;AN002; set control break
 13011                                  	;invoke DSKSTATCHK
 13012 00001C0F E8813E                  	call	DSKSTATCHK	;AN002; check control break
 13013                                  RAWOSTRT:
 13014 00001C12 B403                    	MOV	AH,3
 13015 00001C14 E86432                  	CALL	IOFUNC
 13016 00001C17 74ED                    	JZ	SHORT ROLP
 13017                                  
 13018                                  	; MSDOS 6.0
 13019                                  ;SR;
 13020                                  ; IOFUNC now returns ax = 0ffffh if there was an I24 on a status call and
 13021                                  ;the user failed. We do not send a char if this happens. We however return
 13022                                  ;to the caller with carry clear because this DOS call does not return any
 13023                                  ;status. 
 13024                                  ;
 13025 00001C19 40                      	inc	ax		;fail on I24 if ax = -1
 13026 00001C1A 58                      	POP	AX
 13027 00001C1B 7405                    	jz	short nosend	;yes, do not send char
 13028 00001C1D B402                    	MOV	AH,2
 13029 00001C1F E85932                  	call	IOFUNC
 13030                                  nosend:
 13031 00001C22 F8                      	CLC			; Clear carry indicating successful
 13032 00001C23 C3                      	retn
 13033                                  
 13034                                  	; MSDOS 3.3 & MSDOS 2.11
 13035                                  	;POP	AX
 13036                                  	;MOV	AH,2
 13037                                          ;CALL	IOFUNC
 13038                                  	;CLC			; Clear carry indicating successful
 13039                                  ;RET18:    
 13040                                  	;RETN
 13041                                  
 13042                                  ;;10/08/2018
 13043                                  ; 20/07/2018 - Retro DOS v3.0
 13044                                  ; ---------------------------------------------------------------------------
 13045                                  ; Retro DOS v2.0 (MSDOS 2.11) - OUTMES
 13046                                  ; ---------------------------------------------------------------------------
 13047                                  
 13048                                  ; This routine is called at DOS init
 13049                                  
 13050                                  ;;	;procedure OUTMES,NEAR ; String output for internal messages
 13051                                  ;;OUTMES:
 13052                                  ;;	;LODS	CS:BYTE PTR [SI]
 13053                                  ;;	CS	LODSB
 13054                                  ;;	CMP     AL,"$" ; 24h
 13055                                  ;;	JZ	SHORT RET18
 13056                                  ;;	CALL	OUTT
 13057                                  ;;	JMP     SHORT OUTMES
 13058                                  
 13059                                  ; ---------------------------------------------------------------------------
 13060                                  
 13061                                  ; 20/07/2018 - Retro DOS v3.0
 13062                                  
 13063                                  ; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 2252h
 13064                                  
 13065                                  ;
 13066                                  ;----------------------------------------------------------------------------
 13067                                  ;
 13068                                  ; Inputs:
 13069                                  ;	AX=0 save the DEVCALL request packet
 13070                                  ;	  =1 restore the DEVCALL request packet
 13071                                  ; Function:
 13072                                  ;	save or restore the DEVCALL packet
 13073                                  ; Returns:
 13074                                  ;	none
 13075                                  ;
 13076                                  ;----------------------------------------------------------------------------
 13077                                  ;
 13078                                  
 13079                                  ; 04/05/2019 - Retro DOS v4.0
 13080                                  ; DOSCODE:54B9h (MSDOS 6.21, MSDOS.SYS)
 13081                                  
 13082                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13083                                  ; DOSCODE:54A5h (MSDOS 5.0, MSDOS.SYS)
 13084                                  
 13085                                  ; 12/05/2019
 13086                                  
 13087                                  	; 15/01/2024 - Retro DOS v5.0
 13088                                  	; DOSCODE:5B42h (PCDOS 7.1, IBMDOS.COM)
 13089                                  
 13090                                  Save_Restore_Packet:
 13091 00001C24 1E                      	PUSH	DS
 13092 00001C25 06                      	PUSH	ES
 13093 00001C26 56                      	PUSH	SI
 13094 00001C27 57                      	PUSH	DI
 13095                                  
 13096                                  	; 16/12/2022
 13097                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13098                                  	; 09/09/2018
 13099 00001C28 BF[BD0D]                	mov	di,FAKE_STACK_2F 
 13100 00001C2B BE[5A03]                	mov	si,DEVCALL
 13101                                  	;
 13102                                  	; 21/09/2023
 13103 00001C2E 09C0                    	or	ax,ax 
 13104                                  	;CMP	AX,0		; save packet
 13105 00001C30 7402                    	JZ	short save_packet ; 16/12/2022
 13106                                  	;je	short set_seg
 13107                                  
 13108                                  	; MSDOS 6.0
 13109                                  restore_packet:
 13110                                  ;	MOV	SI,OFFSET DOSDATA:Packet_Temp	;source
 13111                                  ;	MOV	DI,OFFSET DOSDATA:DEVCALL	;destination
 13112                                  	; MSDOS 3.3
 13113                                  	;mov	si,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 13114                                  	;mov	di,DEVCALL  ; 09/09/2018
 13115                                  	;
 13116                                  	;JMP	short set_seg
 13117                                  
 13118                                  	; 16/12/2022	
 13119                                  	; 09/09/2018
 13120 00001C32 87F7                    	xchg	si,di  ; DI = offset DEVCALL, SI = offset FAKE_STACK_2F
 13121                                  
 13122                                  ; 16/12/2022
 13123                                  %if 0
 13124                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13125                                  	cmp	ax,0		; save packet
 13126                                  	jz	short save_packet
 13127                                  	mov	si,FAKE_STACK_2F ; 07/12/2022
 13128                                  	mov	di,DEVCALL 
 13129                                  	jmp	short set_seg
 13130                                  
 13131                                  	; MSDOS 6.0
 13132                                  save_packet:
 13133                                  ;	MOV	DI,OFFSET DOSDATA:Packet_Temp	;destination
 13134                                  ;	MOV	SI,OFFSET DOSDATA:DEVCALL	;source
 13135                                  	; 09/09/2018
 13136                                  	; MSDOS 3.3
 13137                                  	;mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 13138                                  	;mov	si,DEVCALL ; 09/09/2018
 13139                                  
 13140                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13141                                  	mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 13142                                  	mov	si,DEVCALL
 13143                                  %endif
 13144                                  
 13145                                  ; 16/12/2022
 13146                                  save_packet:
 13147                                  ;set_seg:
 13148                                  	; MSDOS 3.3
 13149                                  	;mov	ax,cs
 13150                                  
 13151                                  	; MSDOS 6.0
 13152                                  	;MOV	AX,SS		; set DS,ES to DOSDATA
 13153                                  	;MOV	DS,AX
 13154                                  	;MOV	ES,AX
 13155                                  	; 15/01/2024
 13156 00001C34 16                      	push	ss
 13157 00001C35 1F                      	pop	ds
 13158 00001C36 1E                      	push	ds
 13159 00001C37 07                      	pop	es
 13160                                  
 13161 00001C38 B90B00                  	MOV	CX,11		; 11 words to move
 13162 00001C3B F3A5                    	REP	MOVSW
 13163                                  
 13164 00001C3D 5F                      	POP	DI
 13165 00001C3E 5E                      	POP	SI
 13166 00001C3F 07                      	POP	ES
 13167 00001C40 1F                      	POP	DS
 13168 00001C41 C3                      	retn
 13169                                  
 13170                                  ;============================================================================
 13171                                  ; CPMIO2.ASM, MSDOS 6.0, 1991
 13172                                  ;============================================================================
 13173                                  ; 20/07/2018 - Retro DOS v3.0
 13174                                  ; 01/05/2019 - Retro DOS v4.0
 13175                                  
 13176                                  ;hkn; 	All the variables use SS override or DS. Therefore there is
 13177                                  ;hkn;	no need to specifically set up any seg regs unless SS assumption is
 13178                                  ;hkn;	not valid. 
 13179                                  
 13180                                  ;
 13181                                  ;----------------------------------------------------------------------------
 13182                                  ;
 13183                                  ;**	$STD_CON_INPUT - System Call 1
 13184                                  ;
 13185                                  ;	Input character from console, echo
 13186                                  ;
 13187                                  ;	ENTRY	none
 13188                                  ;	EXIT	(al) = character
 13189                                  ;	USES	ALL
 13190                                  ;
 13191                                  ;----------------------------------------------------------------------------
 13192                                  ;
 13193                                  
 13194                                  _$STD_CON_INPUT:	;System call 1
 13195                                  	
 13196 00001C42 E81EFD                  	CALL	_$STD_CON_INPUT_NO_ECHO
 13197 00001C45 50                      	PUSH	AX
 13198 00001C46 E80400                  	CALL	OUTT
 13199 00001C49 58                      	POP	AX
 13200                                  CON_INPUT_RETN:	
 13201 00001C4A C3                      	RETN
 13202                                  
 13203                                  ;
 13204                                  ;----------------------------------------------------------------------------
 13205                                  ;
 13206                                  ;**	$STD_CON_OUTPUT - System Call 2
 13207                                  ;
 13208                                  ;	Output character to console
 13209                                  ;
 13210                                  ;	ENTRY	(dl) = character
 13211                                  ;	EXIT	none
 13212                                  ;	USES	all
 13213                                  ;
 13214                                  ;----------------------------------------------------------------------------
 13215                                  ;
 13216                                  
 13217                                  ; DOSCODE:54E9h (MSDOS 6.21, MSDOS.SYS)
 13218                                  
 13219                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13220                                  ; DOSCODE:54D5h (MSDOS 5.0, MSDOS.SYS)
 13221                                  
 13222                                  ; 15/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 13223                                  ; DOSCODE:5B70h (PCDOS 7.1, IBMDOS.COM)
 13224                                  
 13225                                  _$STD_CON_OUTPUT:	;System call 2
 13226                                  
 13227 00001C4B 88D0                    	MOV	AL,DL
 13228                                  OUTT:
 13229 00001C4D 3C20                    	CMP	AL,20H ; " "
 13230 00001C4F 725C                    	JB	SHORT CTRLOUT
 13231 00001C51 3C7F                    	CMP	AL,c_DEL ; 7Fh
 13232 00001C53 7405                    	JZ	SHORT OUTCH
 13233                                  OUTCHA:	
 13234                                  	;INC	BYTE PTR [CARPOS]
 13235 00001C55 36FE06[F901]            	INC	BYTE [SS:CARPOS]
 13236                                  OUTCH:
 13237 00001C5A 1E                      	PUSH	DS
 13238 00001C5B 56                      	PUSH	SI
 13239                                  	;INC	BYTE PTR [CHARCO]		;invoke statchk...
 13240                                  	;AND	BYTE PTR [CHARCO],00111111B	;AN000; every 64th char
 13241 00001C5C 36FE06[0003]            	INC	BYTE [SS:CHARCO]	
 13242                                  	;AND	BYTE [SS:CHARCO],00111111B
 13243                                  	; 01/05/2019 - Retro DOS v4.0
 13244 00001C61 368026[0003]3F          	and	byte [SS:CHARCO],3Fh
 13245 00001C67 7505                    	JNZ	SHORT OUTSKIP
 13246                                  
 13247 00001C69 50                      	PUSH	AX
 13248 00001C6A E8D73E                  	CALL	STATCHK
 13249 00001C6D 58                      	POP	AX
 13250                                  OUTSKIP:
 13251 00001C6E E85FFF                  	CALL	RAWOUT				;output the character
 13252                                  
 13253 00001C71 5E                      	POP	SI
 13254 00001C72 1F                      	POP	DS
 13255                                  
 13256                                  	;TEST	BYTE PTR [PFLAG],-1
 13257                                  	;retz
 13258 00001C73 36F606[FE02]FF          	TEST	BYTE [SS:PFLAG],0FFh
 13259 00001C79 74CF                    	JZ	SHORT CON_INPUT_RETN
 13260                                  
 13261 00001C7B 53                      	PUSH	BX
 13262 00001C7C 1E                      	PUSH	DS
 13263 00001C7D 56                      	PUSH	SI
 13264 00001C7E BB0100                  	MOV	BX,1
 13265                                  	; 20/07/2018 - Retro DOS v3.0
 13266                                  	; MSDOS 3.3
 13267                                  	; MSDOS 6.0 (CPMIO2.ASM)
 13268 00001C81 E87022                  	CALL	GET_IO_SFT		;hkn; GET_IO_SFT will set up DS:SI
 13269                                  					;hkn; to sft entry
 13270 00001C84 7224                    	JC	SHORT TRIPOPJ
 13271                                  
 13272                                  	; 01/05/2019 - Retro DOS v4.0
 13273                                  
 13274                                  	;mov	bx,[si+5]
 13275 00001C86 8B5C05                  	MOV	BX,[SI+SF_ENTRY.sf_flags]
 13276                                  	;test	bx,8000h
 13277                                  	;TEST	BX,sf_isnet	; 8000h		; output to NET?
 13278 00001C89 F6C780                  	test	bh,(sf_isnet>>8) ; 80h
 13279 00001C8C 751C                    	JNZ	short TRIPOPJ 			; if so, no echo
 13280                                  	;;test	bx,80h
 13281                                  	;TEST	BX,devid_device 		; output to file?
 13282 00001C8E F6C380                  	test	bl,devid_device ; 80h
 13283 00001C91 7417                    	JZ	SHORT TRIPOPJ 			; if so, no echo
 13284                                  	; 14/03/2018
 13285                                  	;call	GET_IO_FCB	 	; IBMDOS.COM, MSDOS 2.11
 13286                                  	;jc	short TRIPOPJ
 13287                                  	; MSDOS 2.11
 13288                                  	;test	byte [SI+18H], 80h
 13289                                  	;jz	short TRIPOPJ
 13290 00001C93 BB0400                  	MOV	BX,4
 13291 00001C96 E85B22                  	CALL	GET_IO_SFT
 13292 00001C99 720F                    	JC	SHORT TRIPOPJ
 13293                                  	;;test	word [si+5], 800h
 13294                                  	;TEST	word [SI+SF_ENTRY.sf_flags],sf_net_spool ; 800H
 13295                                  	;test	byte [si+6],8 ; 08/11/2022
 13296 00001C9B F6440608                	test	byte [SI+SF_ENTRY.sf_flags+1],(sf_net_spool>>8) ; 8 
 13297                                  						; StdPrn redirected?
 13298                                  	;;JZ	SHORT LISSTRT2J			; No, OK to echo
 13299                                  	;jz	LISSTRT2 ; 10/08/2018 
 13300                                  	; 16/12/2022
 13301 00001C9F 7503                    	jnz	short outch1
 13302 00001CA1 E98700                  	jmp	LISSTRT2
 13303                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13304                                  	;jz	short LISSTRT2J
 13305                                  outch1:
 13306                                  	;MOV	BYTE [PFLAG],0
 13307 00001CA4 36C606[FE02]00          	MOV	BYTE [SS:PFLAG],0		; If a spool, NEVER echo
 13308                                  	; MSDOS 2.11
 13309                                  	;mov	bx,4
 13310                                  	;jmp	short LISSTRT2
 13311                                  	
 13312                                  TRIPOPJ:
 13313                                  	; 20/07/2018
 13314 00001CAA E98100                  	JMP	TRIPOP
 13315                                  
 13316                                  	; 16/12/2022
 13317                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13318                                  ;LISSTRT2J:
 13319                                  ;	JMP	LISSTRT2
 13320                                  
 13321                                  CTRLOUT:
 13322 00001CAD 3C0D                    	CMP	AL,c_CR ; 0Dh
 13323 00001CAF 7420                    	JZ	SHORT ZERPOS
 13324 00001CB1 3C08                    	CMP	AL,c_BS ; 8
 13325 00001CB3 7424                    	JZ	SHORT BACKPOS
 13326 00001CB5 3C09                    	CMP	AL,c_HT ; 9
 13327 00001CB7 75A1                    	JNZ	SHORT OUTCH
 13328                                  	;MOV	AL,[CARPOS]
 13329 00001CB9 36A0[F901]              	MOV	AL,[SS:CARPOS]
 13330 00001CBD 0CF8                    	OR	AL,0F8H
 13331 00001CBF F6D8                    	NEG	AL
 13332                                  TAB:
 13333 00001CC1 51                      	PUSH	CX
 13334 00001CC2 88C1                    	MOV	CL,AL
 13335 00001CC4 B500                    	MOV	CH,0
 13336 00001CC6 E307                    	JCXZ	POPTAB
 13337                                  TABLP:
 13338 00001CC8 B020                    	MOV	AL," "
 13339 00001CCA E880FF                  	CALL	OUTT
 13340 00001CCD E2F9                    	LOOP	TABLP
 13341                                  POPTAB:
 13342 00001CCF 59                      	POP	CX
 13343                                  
 13344 00001CD0 C3                      	RETN
 13345                                  
 13346                                  ZERPOS:
 13347                                  	;MOV	BYTE PTR [CARPOS],0
 13348 00001CD1 36C606[F901]00          	MOV	BYTE [SS:CARPOS],0
 13349                                  	; 10/08/2018
 13350 00001CD7 EB81                    	JMP	short OUTCH ; 04/05/2019
 13351                                  	
 13352                                  	; 18/12/2022
 13353                                  ;OUTJ:	
 13354                                  	;JMP	OUTT
 13355                                  
 13356                                  BACKPOS:
 13357                                  	;DEC	BYTE PTR [CARPOS]
 13358 00001CD9 36FE0E[F901]            	DEC	BYTE [SS:CARPOS]
 13359 00001CDE E979FF                  	JMP	OUTCH
 13360                                  
 13361                                  BUFOUT:
 13362 00001CE1 3C20                    	CMP	AL," "
 13363 00001CE3 7315                    	JAE	SHORT OUTJ		;Normal char
 13364 00001CE5 3C09                    	CMP	AL,9
 13365 00001CE7 7411                    	JZ	SHORT OUTJ		;OUT knows how to expand tabs
 13366                                  	;DOS 3.3  7/14/86
 13367 00001CE9 3C15                    	CMP	AL,"U"-"@" ; 15h	; turn ^U to section symbol
 13368 00001CEB 740D                    	JZ	short CTRLU
 13369 00001CED 3C14                    	CMP	AL,"T"-"@" ; 14h	; turn ^T to paragraph symbol
 13370 00001CEF 7409                    	JZ	short CTRLU
 13371                                  NOT_CTRLU:
 13372                                  	;DOS 3.3  7/14/86
 13373 00001CF1 50                      	PUSH	AX
 13374 00001CF2 B05E                    	MOV	AL,"^"
 13375 00001CF4 E856FF                  	CALL	OUTT		;Print '^' before control chars
 13376 00001CF7 58                      	POP	AX
 13377 00001CF8 0C40                    	OR	AL,40H		;Turn it into Upper case mate
 13378                                  CTRLU:
 13379                                  	;CALL	OUTT
 13380                                  	; 18/12/2022
 13381                                  OUTJ:
 13382 00001CFA E950FF                  	jmp	OUTT
 13383                                  ;BUFOUT_RETN:
 13384                                  	;RETN
 13385                                  
 13386                                  ;
 13387                                  ;----------------------------------------------------------------------------
 13388                                  ;
 13389                                  ;**	$STD_AUX_INPUT - System Call 3
 13390                                  ;
 13391                                  ;	$STD_AUX_INPUT returns a character from Aux Input
 13392                                  ;
 13393                                  ;	ENTRY	none
 13394                                  ;	EXIT	(al) = character
 13395                                  ;	USES	all
 13396                                  ;
 13397                                  ;----------------------------------------------------------------------------
 13398                                  ;
 13399                                  
 13400                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13401                                  
 13402                                  _$STD_AUX_INPUT:	;System call 3
 13403                                  
 13404 00001CFD E8443E                  	CALL	STATCHK
 13405 00001D00 BB0300                  	MOV	BX,3
 13406 00001D03 E8EE21                  	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
 13407                                  	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
 13408                                  	;retc
 13409                                  	; 16/12/2022
 13410                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13411                                  	;JC	SHORT BUFOUT_RETN
 13412                                  	;JMP	SHORT TAISTRT
 13413                                  	; 07/12/2022
 13414 00001D06 7304                    	jnc	SHORT TAISTRT
 13415 00001D08 C3                      	retn	
 13416                                  
 13417                                  AUXILP:
 13418 00001D09 E80A3E                  	CALL	SPOOLINT
 13419                                  TAISTRT:
 13420 00001D0C B401                    	MOV	AH,1
 13421 00001D0E E86A31                  	CALL	IOFUNC
 13422 00001D11 74F6                    	JZ	SHORT AUXILP
 13423 00001D13 30E4                    	XOR	AH,AH
 13424                                  	; 16/12/2022
 13425                                  	;CALL	IOFUNC
 13426                                  	;RETN
 13427                                  	; 07/12/2022
 13428 00001D15 E96331                  	jmp	IOFUNC
 13429                                  
 13430                                  ;
 13431                                  ;----------------------------------------------------------------------------
 13432                                  ;
 13433                                  ;**	$STD_AUX_OUTPUT - Output character to AUX
 13434                                  ;
 13435                                  ;	ENTRY	(dl) = character
 13436                                  ;	EXIT	none
 13437                                  ;	USES	all
 13438                                  ;
 13439                                  ;----------------------------------------------------------------------------
 13440                                  ;
 13441                                  
 13442                                  _$STD_AUX_OUTPUT:	;System call 4
 13443                                  
 13444 00001D18 53                      	PUSH	BX
 13445 00001D19 BB0300                  	MOV	BX,3
 13446 00001D1C EB04                    	JMP	SHORT SENDOUT
 13447                                  
 13448                                  ;
 13449                                  ;----------------------------------------------------------------------------
 13450                                  ;
 13451                                  ;**	$STD_PRINTER_OUTPUT - Output character to printer
 13452                                  ;
 13453                                  ;	ENTRY	(dl) = character
 13454                                  ;	EXIT	none
 13455                                  ;	USES	all
 13456                                  ;
 13457                                  ;----------------------------------------------------------------------------
 13458                                  ;
 13459                                  
 13460                                  _$STD_PRINTER_OUTPUT:	;System call 5
 13461                                  
 13462 00001D1E 53                      	PUSH	BX
 13463 00001D1F BB0400                  	MOV	BX,4
 13464                                  
 13465                                  SENDOUT:
 13466 00001D22 88D0                    	MOV	AL,DL
 13467 00001D24 50                      	PUSH	AX
 13468 00001D25 E81C3E                  	CALL	STATCHK
 13469 00001D28 58                      	POP	AX
 13470 00001D29 1E                      	PUSH	DS
 13471 00001D2A 56                      	PUSH	SI
 13472                                  LISSTRT2:
 13473 00001D2B E8D0FE                  	CALL	RAWOUT2
 13474                                  TRIPOP:
 13475 00001D2E 5E                      	POP	SI
 13476 00001D2F 1F                      	POP	DS
 13477 00001D30 5B                      	POP	BX
 13478                                  SCIS_RETN:	; 20/07/2018
 13479 00001D31 C3                      	RETN
 13480                                  ;
 13481                                  ;----------------------------------------------------------------------------
 13482                                  ;
 13483                                  ;**	$STD_CON_INPUT_STATUS - System Call 11
 13484                                  ;
 13485                                  ;	Check console input status
 13486                                  ;
 13487                                  ;	ENTRY	none
 13488                                  ;	EXIT	AL = -1 character available, = 0 no character
 13489                                  ;	USES	all
 13490                                  ;
 13491                                  ;----------------------------------------------------------------------------
 13492                                  ;
 13493                                  
 13494                                  _$STD_CON_INPUT_STATUS:		;System call 11
 13495                                  
 13496 00001D32 E80F3E                  	CALL	STATCHK
 13497 00001D35 B000                    	MOV	AL,0		; no xor!!
 13498                                  	;retz
 13499 00001D37 74F8                    	JZ	SHORT SCIS_RETN ; 15/04/2018
 13500                                  	;OR	AL,-1
 13501                                  	; 15/01/2024 (PCDOS 7.1 IBMDOS.COM)
 13502 00001D39 48                      	dec	ax ; al = -1 
 13503                                  ;SCIS_RETN:
 13504 00001D3A C3                      	RETN
 13505                                  
 13506                                  ;
 13507                                  ;----------------------------------------------------------------------------
 13508                                  ;
 13509                                  ;**	$STD_CON_INPUT_FLUSH - System Call 12
 13510                                  ;
 13511                                  ;	Flush console input buffer and perform call in AL
 13512                                  ;
 13513                                  ;	ENTRY	(AL) = DOS function to be called after flush (1,6,7,8,10)
 13514                                  ;	EXIT	(al) = 0 iff (al) was not one of the supported fcns
 13515                                  ;		return arguments for the fcn supplied in (AL)
 13516                                  ;	USES	all
 13517                                  ;
 13518                                  ;----------------------------------------------------------------------------
 13519                                  ;
 13520                                  
 13521                                  _$STD_CON_INPUT_FLUSH:		;System call 12
 13522                                  
 13523 00001D3B 50                      	PUSH	AX
 13524 00001D3C 52                      	PUSH	DX
 13525 00001D3D 31DB                    	XOR	BX,BX
 13526 00001D3F E8B221                  	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
 13527                                  	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
 13528 00001D42 7205                    	JC	SHORT BADJFNCON
 13529 00001D44 B404                    	MOV	AH,4
 13530 00001D46 E83231                  	CALL	IOFUNC
 13531                                  
 13532                                  BADJFNCON:
 13533 00001D49 5A                      	POP	DX
 13534 00001D4A 58                      	POP	AX
 13535 00001D4B 88C4                    	MOV	AH,AL
 13536 00001D4D 3C01                    	CMP	AL,1
 13537 00001D4F 7413                    	JZ	SHORT REDISPJ
 13538 00001D51 3C06                    	CMP	AL,6
 13539 00001D53 740F                    	JZ	SHORT REDISPJ
 13540 00001D55 3C07                    	CMP	AL,7
 13541 00001D57 740B                    	JZ	SHORT REDISPJ
 13542 00001D59 3C08                    	CMP	AL,8
 13543 00001D5B 7407                    	JZ	SHORT REDISPJ
 13544 00001D5D 3C0A                    	CMP	AL,10
 13545 00001D5F 7403                    	JZ	SHORT REDISPJ
 13546 00001D61 B000                    	MOV	AL,0
 13547 00001D63 C3                      	RETN
 13548                                  
 13549                                  REDISPJ:
 13550 00001D64 FA                      	CLI
 13551                                  	;transfer REDISP
 13552 00001D65 E90DE6                  	JMP	REDISP
 13553                                  
 13554                                  ;============================================================================
 13555                                  ; FCBIO.ASM, MSDOS 6.0, 1991
 13556                                  ;============================================================================
 13557                                  ; 20/07/2018 - Retro DOS v3.0
 13558                                  ; 17/05/2019 - Retro DOS v4.0
 13559                                  
 13560                                  ;**	FCBIO.ASM - Ancient 1.0 1.1 FCB system calls
 13561                                  ;
 13562                                  ;	$GET_FCB_POSITION
 13563                                  ;	$FCB_DELETE
 13564                                  ;	$GET_FCB_FILE_LENGTH
 13565                                  ;	$FCB_CLOSE
 13566                                  ;	$FCB_RENAME
 13567                                  ;	SaveFCBInfo
 13568                                  ;	ResetLRU
 13569                                  ;	SetOpenAge
 13570                                  ;	LRUFCB
 13571                                  ;	FCBRegen
 13572                                  ;	BlastSFT
 13573                                  ;	CheckFCB
 13574                                  ;	SFTFromFCB
 13575                                  ;	FCBHardErr
 13576                                  ;
 13577                                  ;	Revision history:
 13578                                  ;
 13579                                  ;		Created: ARR 4 April 1983"
 13580                                  ;			 MZ  6 June  1983 completion of functions
 13581                                  ;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
 13582                                  ;					  times.  Change so successive closes work by
 13583                                  ;					  always returning OK.	Also, detect I/O to
 13584                                  ;					  already closed FCB and return EOF.
 13585                                  ;			 MZ 16 Jan   1984 More braindamage.  Need to separate info
 13586                                  ;					  out of sft into FCB for reconnection
 13587                                  ;
 13588                                  ;		A000	 version 4.00  Jan. 1988
 13589                                  
 13590                                  ;Break <$Get_FCB_Position - set random record fields to current pos>
 13591                                  ;----------------------------------------------------------------------------
 13592                                  ;
 13593                                  ;   $Get_FCB_Position - look at an FCB, retrieve the current position from the
 13594                                  ;	extent and next record field and set the random record field to point
 13595                                  ;	to that record
 13596                                  ;
 13597                                  ;   Inputs:	DS:DX point to a possible extended FCB
 13598                                  ;   Outputs:	The random record field of the FCB is set to the current record
 13599                                  ;   Registers modified: all
 13600                                  ;
 13601                                  ;----------------------------------------------------------------------------
 13602                                  ;
 13603                                  
 13604                                  _$GET_FCB_POSITION:
 13605 00001D68 E80A05                  	call	GetExtended		; point to FCB
 13606 00001D6B E8DB04                  	call	GetExtent		; DX:AX is current record
 13607                                  	;mov	[si+21h],ax
 13608 00001D6E 894421                  	MOV	[SI+SYS_FCB.RR],AX 	; drop in low order piece
 13609                                  	;mov	[si+23h],dl
 13610 00001D71 885423                  	MOV	[SI+SYS_FCB.RR+2],DL	; drop in high order piece
 13611                                  	;cmp	word [si+0Eh],64
 13612 00001D74 837C0E40                	CMP	word [SI+SYS_FCB.RECSIZ],64
 13613 00001D78 7303                    	JAE	short GetFCBBye
 13614                                  	;mov	[si+24h],dh
 13615 00001D7A 887424                  	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
 13616                                  GoodPath:	; 16/12/2022
 13617                                  GetFCBBye:
 13618 00001D7D E90CE9                  	jmp	FCB_RET_OK
 13619                                  
 13620                                  ;Break <$FCB_Delete - remove several files that match the input FCB>
 13621                                  ;----------------------------------------------------------------------------
 13622                                  ;
 13623                                  ;**	$FCB_Delete - Delete from FCB Template
 13624                                  ;
 13625                                  ;	given an FCB, remove all directory entries in the current
 13626                                  ;	directory that have names that match the FCB's ?  marks.
 13627                                  ;
 13628                                  ;	ENTRY	(DS:DX) = address of FCB
 13629                                  ;	EXIT	entries matching the FCB are deleted
 13630                                  ;		(al) = ff iff no entries were deleted
 13631                                  ;	USES	all
 13632                                  ;
 13633                                  ;----------------------------------------------------------------------------
 13634                                  ;
 13635                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13636                                  
 13637                                  _$FCB_DELETE:		; System call 19
 13638                                  					; OpenBuf is in DOSDATA
 13639 00001D80 BF[BE03]                	MOV	DI,OPENBUF 		; appropriate place 
 13640                                  
 13641 00001D83 E89F57                  	call	TransFCB		; convert FCB to path
 13642 00001D86 7207                    	JC	short BadPath 		; signal no deletions
 13643                                  
 13644 00001D88 16                      	push	SS
 13645 00001D89 1F                      	pop	DS			; SS is DOSDATA
 13646                                  
 13647 00001D8A E8FC0D                  	call	DOS_DELETE		; wham
 13648                                  	;JC	short BadPath
 13649                                  	; 16/12/2022
 13650 00001D8D 73EE                    	jnc 	short GoodPath
 13651                                  ;GoodPath:
 13652                                  ;	;jmp	FCB_RET_OK		; do a good return
 13653                                  ;	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13654                                  ;	jmp	short GetFCBBye
 13655                                  
 13656                                  BadPath:
 13657                                  	; Error code is in AX
 13658                                  
 13659 00001D8F E9FDE8                  	jmp	FCB_RET_ERR		; let someone else signal the error
 13660                                  
 13661                                  ;Break <$Get_FCB_File_Length - return the length of a file>
 13662                                  ;----------------------------------------------------------------------------
 13663                                  ;
 13664                                  ;   $Get_FCB_File_Length - set the random record field to the length of the
 13665                                  ;	file in records (rounded up if partial).
 13666                                  ;
 13667                                  ;   Inputs:	DS:DX - point to a possible extended FCB
 13668                                  ;   Outputs:	Random record field updated to reflect the number of records
 13669                                  ;   Registers modified: all
 13670                                  ;
 13671                                  ;----------------------------------------------------------------------------
 13672                                  ;
 13673                                  	; 15/01/2024 - Retrodos v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 13674                                  
 13675                                  _$GET_FCB_FILE_LENGTH:
 13676                                  
 13677 00001D92 E8E004                  	call	GetExtended		; get real FCB pointer
 13678                                  					; DX points to Input FCB
 13679                                  
 13680                                  					; OpenBuf is in DOSDATA
 13681 00001D95 BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 13682                                  
 13683 00001D98 1E                      	push	ds			; save pointer to true FCB
 13684 00001D99 56                      	push	si
 13685 00001D9A E88857                  	call	TransFCB		; Trans name DS:DX, sets SATTRIB
 13686 00001D9D 5E                      	pop	si
 13687 00001D9E 1F                      	pop	ds
 13688 00001D9F 72EE                    	JC	short BadPath
 13689 00001DA1 1E                      	push	ds			; save pointer
 13690 00001DA2 56                      	push	si
 13691 00001DA3 16                      	push	ss		
 13692 00001DA4 1F                      	pop	ds
 13693 00001DA5 E84012                  	call	GET_FILE_INFO		; grab the info
 13694 00001DA8 5E                      	pop	si			; get pointer back
 13695 00001DA9 1F                      	pop	ds
 13696 00001DAA 72E3                    	JC	short BadPath 		; invalid something
 13697                                  	; 15/01/2024
 13698                                  	;MOV	DX,BX (*)		; get high order size
 13699                                  	;MOV	AX,DI (**)		; get low order size
 13700 00001DAC 89D8                    	mov	ax,bx ; hw of file size
 13701                                  	;
 13702                                  	;mov	bx,[si+0Eh]
 13703 00001DAE 8B5C0E                  	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
 13704 00001DB1 09DB                    	OR	BX,BX			; empty record => 0 size for file
 13705 00001DB3 7502                    	JNZ	short GetSize 		; not empty
 13706                                  	;MOV	BX,128
 13707 00001DB5 B380                    	mov	bl,128	; 15/01/2024
 13708                                  GetSize:
 13709                                  	; 15/01/2024
 13710                                  	;MOV	DI,AX			; save low order word
 13711                                  	;MOV	AX,DX			; move high order for divide
 13712                                  	;xchg	ax,dx ; (*)
 13713                                  	; ax = hw of file size
 13714                                  
 13715 00001DB7 31D2                    	XOR	DX,DX			; clear out high
 13716 00001DB9 F7F3                    	DIV	BX			; wham
 13717 00001DBB 50                      	PUSH	AX			; save dividend
 13718 00001DBC 89F8                    	MOV	AX,DI ; (**)		; get low order piece
 13719 00001DBE F7F3                    	DIV	BX			; wham
 13720 00001DC0 89D1                    	MOV	CX,DX			; save remainder
 13721 00001DC2 5A                      	POP	DX			; get high order dividend
 13722 00001DC3 E306                    	JCXZ	LengthStore		; no roundup
 13723 00001DC5 83C001                  	ADD	AX,1
 13724 00001DC8 83D200                  	ADC	DX,0			; 32-bit increment
 13725                                  LengthStore:
 13726                                  	;mov	[si+21h],ax
 13727 00001DCB 894421                  	MOV	[SI+SYS_FCB.RR],AX	; store low order
 13728                                  	;mov	[si+23h],dl
 13729 00001DCE 885423                  	MOV	[SI+SYS_FCB.RR+2],DL	; store high order
 13730 00001DD1 08F6                    	OR	DH,DH
 13731 00001DD3 74A8                    	JZ	short GoodPath		; not storing insignificant zero
 13732                                  	;mov	[si+24h],dh
 13733 00001DD5 887424                  	MOV	[SI+SYS_FCB.RR+3],DH	; save that high piece
 13734                                  	; 16/12/2022
 13735                                  GoodRet:
 13736                                  	;jmp	FCB_RET_OK
 13737 00001DD8 EBA3                    	jmp	short GoodPath
 13738                                  
 13739                                  ;Break <$FCB_Close - close a file>
 13740                                  ;----------------------------------------------------------------------------
 13741                                  ;
 13742                                  ;   $FCB_Close - given an FCB, look up the SFN and close it. Do not free it
 13743                                  ;	as the FCB may be used for further I/O
 13744                                  ;
 13745                                  ;   Inputs:	DS:DX point to FCB
 13746                                  ;   Outputs:	AL = FF if file was not found on disk
 13747                                  ;   Registers modified: all
 13748                                  ;
 13749                                  ;----------------------------------------------------------------------------
 13750                                  ;
 13751                                  	; 16/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 13752                                  
 13753                                  _$FCB_CLOSE:		; System call 16
 13754                                  
 13755 00001DDA 30C0                    	XOR	AL,AL			; default search attributes
 13756 00001DDC E89604                  	call	GetExtended		; DS:SI point to real FCB
 13757 00001DDF 7403                    	JZ	short NoAttr		; not extended
 13758 00001DE1 8A44FF                  	MOV	AL,[SI-1]		; get attributes
 13759                                  NoAttr:
 13760                                  					; SS override
 13761 00001DE4 36A2[6B05]              	MOV	[SS:ATTRIB],AL		; stash away found attributes
 13762 00001DE8 E8DD03                  	call	SFTFromFCB
 13763 00001DEB 72EB                    	JC	short GoodRet 		; MZ 16 Jan Assume death
 13764                                  
 13765                                  	; If the sharer is present, then the SFT is not regenable. Thus, 
 13766                                  	; there is no need to set the SFT's attribute.
 13767                                  
 13768                                  	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
 13769                                  	;;; done
 13770                                  
 13771                                  	;mov	al,[es:di+4]
 13772 00001DED 268A4504                	MOV	AL,[ES:DI+SF_ENTRY.sf_attr]
 13773 00001DF1 30E4                    	XOR	AH,AH
 13774 00001DF3 50                      	PUSH	AX
 13775                                  
 13776                                  	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
 13777                                  	;;; done
 13778                                  
 13779 00001DF4 E85A5F                  	call	CheckShare
 13780 00001DF7 7508                    	JNZ	short NoStash
 13781 00001DF9 36A0[6B05]              	MOV	AL,[SS:ATTRIB]
 13782                                  	;mov	[es:di+4],al
 13783 00001DFD 26884504                	MOV	[ES:DI+SF_ENTRY.sf_attr],AL ; attempted attribute for close
 13784                                  NoStash:
 13785                                  
 13786                                  ; 16/01/2024
 13787                                  %if 0
 13788                                  	;mov	ax,[si+14h]
 13789                                  	MOV	AX,[SI+SYS_FCB.FDATE] ; move in the time and date
 13790                                  	;mov	[es:di+0Fh],ax
 13791                                  	MOV	[ES:DI+SF_ENTRY.sf_date],AX
 13792                                  	;mov	ax,[si+16h]
 13793                                  	MOV	AX,[SI+SYS_FCB.FTIME]
 13794                                  	;mov	[es:di+0Dh],ax
 13795                                  	MOV	[ES:DI+SF_ENTRY.sf_time],AX
 13796                                  	;mov	ax,[si+10h]
 13797                                  	MOV	AX,[SI+SYS_FCB.FILSIZ]
 13798                                  	;mov	[es:di+11h],ax
 13799                                  	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 13800                                  	;mov	ax,[si+12h]
 13801                                  	MOV	AX,[SI+SYS_FCB.FILSIZ+2]
 13802                                  	;mov	[es:di+13h],ax
 13803                                  	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 13804                                  	;or	word [es:di+5],4000h
 13805                                  	; 17/12/2022
 13806                                  	or	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8) ; 40h
 13807                                  	;OR	word [ES:DI+SF_ENTRY.sf_flags],sf_close_nodate
 13808                                  %else
 13809                                  	; 16/01/2024 (PCDOS 7.1 IBMDOS.COM)
 13810 00001E01 1E                      	push	ds
 13811                                  	;lds	ax,[si+14h]
 13812 00001E02 C54414                  	lds	ax,[si+SYS_FCB.FDATE]	; move in the time and date
 13813                                  	;mov	[es:di+0Fh],ax
 13814 00001E05 2689450F                	mov	[es:di+SF_ENTRY.sf_date],ax
 13815                                  	;mov	[es:di+0Dh],ds		
 13816 00001E09 268C5D0D                	mov	[es:di+SF_ENTRY.sf_time],ds
 13817 00001E0D 1F                      	pop	ds
 13818                                  	;lds	ax,[si+10h]
 13819 00001E0E C54410                  	lds	ax,[si+SYS_FCB.FILSIZ]
 13820                                  	;mov	[es:di+11h],ax
 13821 00001E11 26894511                	mov	[es:di+SF_ENTRY.sf_size],ax
 13822                                  	;mov	[es:di+13h],ds
 13823 00001E15 268C5D13                	mov	[es:di+SF_ENTRY.sf_size+2],ds
 13824                                  	; 16/01/2024
 13825                                  	;;or	word [es:di+5], 4000h
 13826                                  	;or	word [es:di+SF_ENTRY.sf_flags], sf_close_nodate
 13827 00001E19 26804D0640              	or	byte [es:di+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8) ; 40h
 13828                                  %endif
 13829                                  
 13830 00001E1E 16                      	push	ss
 13831 00001E1F 1F                      	pop	ds
 13832 00001E20 E82219                  	call	DOS_CLOSE	; wham
 13833 00001E23 C43E[9E05]              	LES	DI,[THISSFT]
 13834                                  
 13835                                  	;;; 9/8/86 F.C. restore SFT attribute
 13836 00001E27 59                      	POP	CX
 13837                                  	;mov	[es:di+4],cl
 13838 00001E28 26884D04                	MOV	[ES:DI+SF_ENTRY.sf_attr],CL
 13839                                  	;;; 9/8/86 F.C. restore SFT attribute
 13840                                  
 13841 00001E2C 9C                      	PUSHF
 13842                                  	;test	word [es:di],0FFFFh
 13843                                  	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],0
 13844                                  				; zero ref count gets blasted
 13845 00001E2D 26833D00                	cmp	word [ES:DI],0
 13846 00001E31 7507                    	jnz     short CloseOK
 13847 00001E33 50                      	PUSH	AX
 13848 00001E34 B04D                    	MOV	AL,'M' ; 4Dh
 13849 00001E36 E80903                  	call	BlastSFT
 13850 00001E39 58                      	POP	AX
 13851                                  CloseOK:
 13852 00001E3A 9D                      	POPF
 13853 00001E3B 739B                    	JNC	short GoodRet
 13854                                  	;cmp	al,6
 13855 00001E3D 3C06                    	CMP	AL,error_invalid_handle
 13856 00001E3F 7497                    	JZ	short GoodRet
 13857                                  	;mov	al,2
 13858 00001E41 B002                    	MOV	AL,error_file_not_found
 13859                                  fren90:
 13860                                  	; 16/12/2022
 13861                                  fcb_close_err:
 13862 00001E43 E949E8                  	jmp	FCB_RET_ERR
 13863                                  
 13864                                  ;
 13865                                  ;----------------------------------------------------------------------------
 13866                                  ;
 13867                                  ;**	$FCB_Rename - Rename a File
 13868                                  ;
 13869                                  ;	$FCB_Rename - rename a file in place within a directory. Renames
 13870                                  ;	multiple files copying from the meta characters.
 13871                                  ;
 13872                                  ;	ENTRY	DS:DX point to an FCB. The normal name field is the source
 13873                                  ;		    name of the files to be renamed. Starting at offset 11h
 13874                                  ;		    in the FCB is the destination name.
 13875                                  ;	EXIT	AL = 0 -> no error occurred and all files were renamed
 13876                                  ;		AL = FF -> some files may have been renamed but:
 13877                                  ;			rename to existing file or source file not found
 13878                                  ;	USES	ALL
 13879                                  ;
 13880                                  ;----------------------------------------------------------------------------
 13881                                  ;
 13882                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13883                                  	; 16/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 13884                                  
 13885                                  _$FCB_RENAME:		; System call 23
 13886                                  
 13887 00001E46 E82C04                  	call	GetExtended		; get pointer to real FCB
 13888 00001E49 52                      	push	dx
 13889 00001E4A 8A04                    	MOV	AL,[SI] 		; get drive byte
 13890 00001E4C 83C610                  	ADD	SI,10h			; point to destination
 13891                                  
 13892                                  					; RenBuf is in DOSDATA
 13893 00001E4F BF[3E04]                	MOV	DI,RENBUF		; point to destination buffer
 13894 00001E52 FF34                    	push	word [SI]
 13895 00001E54 1E                      	push	ds
 13896                                  	;push	di			; save source pointer for TransFCB
 13897                                  	; 16/01/2024 (Retro DOS v4 BugFix!)
 13898 00001E55 56                      	push	si
 13899 00001E56 8804                    	MOV	[SI],AL			; drop in real drive
 13900 00001E58 89F2                    	MOV	DX,SI			; let TransFCB know where the FCB is
 13901 00001E5A E8C856                  	call	TransFCB		; munch this pathname
 13902 00001E5D 5E                      	pop	si
 13903 00001E5E 1F                      	pop	ds	
 13904 00001E5F 8F04                    	pop	WORD [SI]		; get path back
 13905 00001E61 5A                      	pop	dx			; Original FCB pointer
 13906 00001E62 72DF                    	JC	short fren90		; bad path -> error
 13907                                  
 13908                                  					; SS override for WFP_Start & Ren_WFP
 13909 00001E64 368B36[B205]            	MOV	SI,[ss:WFP_START]	; get pointer
 13910 00001E69 368936[B405]            	MOV	[ss:REN_WFP],SI		; stash it
 13911                                  
 13912                                  					; OpenBuf is in DOSDATA
 13913 00001E6E BF[BE03]                	MOV	DI,OPENBUF		; appropriate spot
 13914 00001E71 E8B156                  	call	TransFCB		; wham
 13915                                  					; NOTE that this call is pointing
 13916                                  					;  back to the ORIGINAL FCB so
 13917                                  					;  SATTRIB gets set correctly
 13918 00001E74 72CD                    	JC	short fren90		; error
 13919                                  	;;;
 13920                                  	; 16/01/2024 - Retro DOS 5.0
 13921                                  	; (PCDOS 7.1 IBMDOS.COM)
 13922 00001E76 36C606[7B12]43          	mov	byte [ss:PATHNAMELEN], 67 ; DIRSTRLEN = 67
 13923                                  	;mov	word [ss:PATHNAMELEN], 67 ; set pathname length to 67
 13924                                  	;;;
 13925 00001E7C E81D0F                  	call	DOS_RENAME
 13926 00001E7F 72C2                    	JC	short fren90
 13927                                  	; 16/12/2022
 13928 00001E81 E908E8                  	jmp	FCB_RET_OK
 13929                                  	
 13930                                  ;	Error -
 13931                                  ;
 13932                                  ;	(al) = error code
 13933                                  
 13934                                  	; 16/12/2022
 13935                                  ;fren90:	
 13936                                  ;	;jmp	FCB_RET_ERR
 13937                                  ;	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13938                                  ;	jmp	short fcb_close_err
 13939                                  
 13940                                  ;Break <Misbehavior fixers>
 13941                                  ;
 13942                                  ;   FCBs suffer from several problems. First, they are maintained in the
 13943                                  ;   user's space so he may move them at will. Second, they have a small
 13944                                  ;   reserved area that may be used for system information. Third, there was
 13945                                  ;   never any "rules for behavior" for FCBs; there was no protocol for their
 13946                                  ;   usage.
 13947                                  ;
 13948                                  ;   This results in the following misbehavior:
 13949                                  ;
 13950                                  ;	infinite opens of the same file:
 13951                                  ;
 13952                                  ;	While (TRUE) {			While (TRUE) {
 13953                                  ;	    FCBOpen (FCB);		    FCBOpen (FCB);
 13954                                  ;	    Read (FCB); 		    Write (FCB);
 13955                                  ;	    }				    }
 13956                                  ;
 13957                                  ;	infinite opens of different files:
 13958                                  ;
 13959                                  ;	While (TRUE) {			While (TRUE) {
 13960                                  ;	    FCBOpen (FCB[i++]); 	    FCBOpen (FCB[i++]);
 13961                                  ;	    Read (FCB); 		    Write (FCB);
 13962                                  ;	    }				    }
 13963                                  ;
 13964                                  ;	multiple closes of the same file:
 13965                                  ;
 13966                                  ;	FCBOpen (FCB);
 13967                                  ;	while (TRUE)
 13968                                  ;	    FCBClose (FCB);
 13969                                  ;
 13970                                  ;	I/O after closing file:
 13971                                  ;
 13972                                  ;	FCBOpen (FCB);
 13973                                  ;	while (TRUE) {
 13974                                  ;	    FCBWrite (FCB);
 13975                                  ;	    FCBClose (FCB);
 13976                                  ;	    }
 13977                                  ;
 13978                                  ;   The following is am implementation of a methodology for emulating the
 13979                                  ;   above with the exception of I/O after close. We are NOT attempting to
 13980                                  ;   resolve that particular misbehavior. We will enforce correct behaviour in
 13981                                  ;   FCBs when they refer to a network file or when there is file sharing on
 13982                                  ;   the local machine.
 13983                                  ;
 13984                                  ;   The reserved fields of the FCB (10 bytes worth) is divided up into various
 13985                                  ;   structures depending on the file itself and the state of operations of the
 13986                                  ;   OS. The information contained in this reserved field is enough to
 13987                                  ;   regenerate the SFT for the local non-shared file. It is assumed that this
 13988                                  ;   regeneration procedure may be expensive. The SFT for the FCB is
 13989                                  ;   maintained in a LRU cache as the ONLY performance inprovement.
 13990                                  ;
 13991                                  ;   No regeneration of SFTs is attempted for network FCBs.
 13992                                  ;
 13993                                  ;   To regenerate the SFT for a local FCB, it is necessary to determine if the
 13994                                  ;   file sharer is working. If the file sharer is present then the SFT is not
 13995                                  ;   regenerated.
 13996                                  ;
 13997                                  ;   Finally, if there is no local sharing, the full name of the file is no
 13998                                  ;   longer available. We can make up for this by using the following
 13999                                  ;   information:
 14000                                  ;
 14001                                  ;	The Drive number (from the DPB).
 14002                                  ;	The physical sector of the directory that contains the entry.
 14003                                  ;	The relative position of the entry in the sector.
 14004                                  ;	The first cluster field.
 14005                                  ;	The last used SFT.
 14006                                  ;      OR In the case of a device FCB
 14007                                  ;	The low 6 bits of sf_flags (indicating device type)
 14008                                  ;	The pointer to the device header
 14009                                  ;
 14010                                  ;   We read in the particular directory sector and examine the indicated
 14011                                  ;   directory entry. If it matches, then we are kosher; otherwise, we fail.
 14012                                  ;
 14013                                  ;   Some key items need to be remembered:
 14014                                  ;
 14015                                  ;	Even though we are caching SFTs, they may contain useful sharing
 14016                                  ;	information. We enforce good behavior on the FCBs.
 14017                                  ;
 14018                                  ;	Network support must not treat FCBs as impacting the ref counts on
 14019                                  ;	open VCs. The VCs may be closed only at process termination.
 14020                                  ;
 14021                                  ;	If this is not an installed version of the DOS, file sharing will
 14022                                  ;	always be present.
 14023                                  ;
 14024                                  ;	We MUST always initialize lstclus to = firclus when regenerating a
 14025                                  ;	file. Otherwise we start allocating clusters up the wazoo.
 14026                                  ;
 14027                                  ;	Always initialize, during regeneration, the mode field to both isFCB
 14028                                  ;	and open_for_both. This is so the FCB code in the sharer can find the
 14029                                  ;	proper OI record.
 14030                                  ;
 14031                                  ;   The test bits are:
 14032                                  ;
 14033                                  ;	00 -> local file
 14034                                  ;	40 -> sharing local
 14035                                  ;	80 -> network
 14036                                  ;	C0 -> local device
 14037                                  
 14038                                  ;Break	<SaveFCBInfo - store pertinent information from an SFT into the FCB>
 14039                                  ;----------------------------------------------------------------------------
 14040                                  ;
 14041                                  ;   SaveFCBInfo - given an FCB and its associated SFT, copy the relevant
 14042                                  ;	pieces of information into the FCB to allow for subsequent
 14043                                  ;	regeneration. Poke LRU also.
 14044                                  ;
 14045                                  ;   Inputs:	ThisSFT points to a complete SFT.
 14046                                  ;		DS:SI point to the FCB (not an extended one)
 14047                                  ;   Outputs:	The relevant reserved fields in the FCB are filled in.
 14048                                  ;		DS:SI preserved
 14049                                  ;		ES:DI point to sft
 14050                                  ;   Registers modified: All
 14051                                  ;
 14052                                  ;
 14053                                  ;----------------------------------------------------------------------------
 14054                                  ;
 14055                                  
 14056                                  	; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14057                                  	; 20/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 14058                                  	
 14059                                  SaveFCBInfo:
 14060                                  
 14061 00001E84 36C43E[9E05]            	LES	DI,[SS:THISSFT]		; SS override
 14062 00001E89 E8CEF9                  	call	IsSFTNet
 14063 00001E8C 740B                    	JZ	short SaveLocal		; if not network then save local info
 14064                                  ;
 14065                                  ;----- In net support -----
 14066                                  ;
 14067                                  	; 17/05/2019 - Retro DOS v4.0
 14068                                  
 14069                                  	; MSDOS 3.3
 14070                                  	;;mov	ax,[es:di+1Dh]
 14071                                  	;mov	ax,[es:di+SF_ENTRY.sf_dirsec]
 14072                                  	;;mov	[si+1Ah],ax
 14073                                  	;mov	[si+fcb_net_handle],ax
 14074                                  	;push	es
 14075                                  	;push	di
 14076                                  	;;les	di,[es:di+19h]
 14077                                  	;LES	DI,[ES:DI+sf_netid]
 14078                                  	;;mov	[si+1Ch],di
 14079                                  	;MOV	[SI+fcb_netID],DI	; save net ID
 14080                                  	;;mov 	[si+1Eh],es
 14081                                  	;MOV	[SI+fcb_netID+2],ES
 14082                                  	;pop	di
 14083                                  	;pop	es
 14084                                  
 14085                                  	; MSDOS 6.0
 14086                                  	;mov	ax,[es:di+0Bh]
 14087 00001E8E 268B450B                	MOV	AX,[ES:DI+sf_serial_ID] ;AN000;;IFS. save IFS ID
 14088                                  	;mov	[si+1Ch],ax
 14089 00001E92 89441C                  	MOV	[SI+fcb_netID],ax	;AN000;;IFS.
 14090                                  	
 14091                                  	;mov	bl,80h
 14092 00001E95 B380                    	MOV	BL,FCBNETWORK
 14093                                  ;
 14094                                  ;----- END In net support -----
 14095                                  ;
 14096 00001E97 EB63                    	jmp	SHORT SaveSFN
 14097                                  
 14098                                  SaveLocal:
 14099                                  	;IF	Installed
 14100 00001E99 E8B55E                  	call	CheckShare
 14101                                  	;JZ	short SaveNoShare	; no sharer
 14102                                  	;JMP	short SaveShare		; sharer present
 14103                                  	; 16/12/2022
 14104                                  	; 28/07/2019
 14105 00001E9C 7559                    	jnz	short SaveShare
 14106                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14107                                  	;JZ	short SaveNoShare	; no sharer
 14108                                  	;JMP	short SaveShare		; sharer present
 14109                                  
 14110                                  SaveNoShare:
 14111                                  	;;test 	word [es:di+5],80h
 14112                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 14113 00001E9E 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; 80h	
 14114 00001EA3 7542                    	JNZ	short SaveNoShareDev	; Device
 14115                                  
 14116                                  	; Save no sharing local file information
 14117                                  
 14118                                  	;;mov	ax,[es:di+1Dh]  ; MSDOS 3.3
 14119                                  	;mov	ax,[es:di+1Bh]  ; MSDOS 6.0
 14120 00001EA5 268B451B                	MOV	AX,[ES:DI+SF_ENTRY.sf_dirsec] ; get directory sector F.C.
 14121                                  	;mov	[si+1Dh],ax
 14122 00001EA9 89441D                  	MOV	[SI+fcb_nsl_dirsec],AX
 14123                                  
 14124                                  	; MSDOS 6.0
 14125                                  
 14126                                  	;SR; Store high byte of directory sector
 14127                                  	;mov	ax,[es:di+1Dh]
 14128 00001EAC 268B451D                	mov	ax,[es:di+SF_ENTRY.sf_dirsec+2] ; get high word
 14129                                  	
 14130                                  	; SR;
 14131                                  	; We have to store the read-only and archive attributes of the file.
 14132                                  	; We extract it from the SFT and store it in the top two bits of the 
 14133                                  	; sector number ( sector number == 22 bits only )
 14134                                  
 14135                                  	;mov	bl,[es:di+4]
 14136 00001EB0 268A5D04                	mov	bl,[es:di+SF_ENTRY.sf_attr]
 14137 00001EB4 88DF                    	mov	bh,bl
 14138 00001EB6 D0CB                    	ror	bl,1
 14139 00001EB8 D0E7                    	shl	bh,1
 14140 00001EBA 08FB                    	or	bl,bh
 14141 00001EBC 80E3C0                  	and	bl,0C0h
 14142 00001EBF 08D8                    	or	al,bl
 14143                                  	;mov	[si+18h],al ; 08/11/2022
 14144 00001EC1 884418                  	mov	[si+fcb_sfn],al	; sector number = 22 bits
 14145                                  
 14146                                  	; MSDOS 6.0 (& MSDOS 3.3)
 14147                                  	;mov	al,[es:di+1Fh]
 14148 00001EC4 268A451F                	MOV	AL,[ES:DI+SF_ENTRY.sf_dirpos] ; location in sector
 14149                                  	;mov	[si+1Fh],al
 14150 00001EC8 88441F                  	MOV	[SI+fcb_nsl_dirpos],AL
 14151                                  
 14152                                  	; 20/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
 14153                                  	;;;
 14154                                  	;;mov	ax,[es:di+0Bh]	; .sf_firclus:
 14155                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_firclus] ; first cluster
 14156                                  	; 20/01/2024
 14157                                  	; (PCDOS 7.1 IBMDOS.COM - DOSCODE:5DF5h)
 14158                                  	; (Windows ME IO.SYS - BIOSCODE:5D60h)
 14159 00001ECB 268B452B                	mov	ax,[es:di+2Bh]  ; .sf_chain !!! (MSDOS 6.22)
 14160                                  	;mov	ax,[es:di+SF_ENTRY.sf_chain] ; first cluster (32 bit) !?
 14161                                  	;;;
 14162                                  	;mov	[si+1Bh],ax
 14163 00001ECF 89441B                  	MOV	[SI+fcb_nsl_firclus],AX
 14164 00001ED2 B300                    	MOV	BL,0
 14165                                  
 14166                                  	; Create the bits field from the dirty/device bits of the flags word 
 14167                                  	; and the mode byte
 14168                                  
 14169                                  SetFCBBits:
 14170                                  	;mov	ax,[es:di+5]
 14171 00001ED4 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 14172 00001ED8 24C0                    	AND	AL,0C0h 		; mask off drive bits
 14173                                  	;or	al,[es:di+2]
 14174 00001EDA 260A4502                	OR	AL,[ES:DI+SF_ENTRY.sf_mode] ; stick in open mode
 14175                                  	;mov	[si+1Ah], al
 14176 00001EDE 88441A                  	MOV	[SI+fcb_nsl_bits],AL	; save dirty info
 14177                                  
 14178                                  	; MSDOS 6.0
 14179                                  	
 14180                                  	; SR;
 14181                                  	; Check if we came here for local file or device. If for local file, 
 14182                                  	; skip setting of SFT index
 14183                                  	
 14184 00001EE1 08DB                    	or	bl,bl
 14185 00001EE3 7428                    	jz	short SaveNoSFN		; do not save SFN if local file
 14186                                  
 14187 00001EE5 EB15                    	JMP	short SaveSFN 		; go and save SFN
 14188                                  
 14189                                  	; Save no sharing local device information
 14190                                  
 14191                                  SaveNoShareDev:
 14192                                  	; 20/01/2024
 14193                                  	;;mov	ax,[es:di+7]
 14194                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_devptr]
 14195                                  	;;mov	[si+1Ah],ax
 14196                                  	;MOV	[SI+fcb_nsld_drvptr],AX
 14197                                  	;;mov	ax,[es:di+9]
 14198                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_devptr+2]
 14199                                  	;MOV	[SI+fcb_nsld_drvptr+2],AX
 14200                                  	; 20/01/2024 (PCDOS 7.1 IBMDOS.COM)
 14201 00001EE7 06                      	push	es
 14202 00001EE8 26C44507                	les	ax,[es:di+SF_ENTRY.sf_devptr]
 14203 00001EEC 89441A                  	mov	[si+fcb_nsld_drvptr],ax
 14204 00001EEF 8C441C                  	mov	[si+fcb_nsld_drvptr+2],es
 14205 00001EF2 07                      	pop	es
 14206                                  	
 14207                                  	;mov	bl,40h
 14208 00001EF3 B340                    	MOV	BL,FCBDEVICE
 14209                                  	; 28/12/2022
 14210 00001EF5 EBDD                    	JMP	short SetFCBBits	; go and save SFN
 14211                                  
 14212                                  SaveShare:
 14213                                  	;ENDIF
 14214                                  
 14215                                  ;----- In share support -----
 14216                                  
 14217                                  	;call	far [ss:ShSave]
 14218 00001EF7 36FF1E[B800]            	Call	far [ss:JShare+(10*4)] ; 10 = ShSave ; SS Override
 14219                                  
 14220                                  ;----- end in share support -----
 14221                                  
 14222                                  	; 17/05/2019
 14223                                  
 14224                                  SaveSFN:
 14225                                  	;lea	ax,[di-6]
 14226 00001EFC 8D45FA                  	LEA	AX,[DI-SFT.SFTable]
 14227                                  	
 14228                                  	; Adjust for offset to table.
 14229                                  	
 14230 00001EFF 362B06[4000]            	SUB	AX,[SS:SFTFCB]		; SS override for SftFCB
 14231                                  
 14232 00001F04 53                      	push	bx			;bx = FCB type (net/Share or local)
 14233                                  	;;mov	bl,53 ; MSDOS 3.3
 14234                                  	;mov	bl,59 ; MSDOS 6.0
 14235 00001F05 B33B                    	MOV	BL,SF_ENTRY.size
 14236 00001F07 F6F3                    	DIV	BL
 14237                                  	;mov	[si+18h],al
 14238 00001F09 884418                  	MOV	[SI+fcb_sfn],AL		; last used SFN
 14239 00001F0C 5B                      	pop	bx			;restore bx
 14240                                  
 14241                                  SaveNoSFN:
 14242                                  	;mov	ax,[es:di+5]
 14243 00001F0D 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 14244 00001F11 243F                    	AND	AL,3Fh			; get real drive
 14245 00001F13 08D8                    	OR	AL,BL
 14246                                  	;mov	[si+19h],al
 14247 00001F15 884419                  	MOV	[SI+fcb_l_drive],AL
 14248                                  
 14249 00001F18 36A1[1000]              	MOV	AX,[SS:FCBLRU]		; get lru count
 14250 00001F1C 40                      	INC	AX
 14251                                  	;mov	[es:di+15h],ax
 14252 00001F1D 26894515                	MOV	[ES:DI+sf_LRU],AX
 14253 00001F21 7506                    	JNZ	short SimpleStuff
 14254                                  	
 14255                                  	; lru flag overflowed. Run through all FCB sfts and adjust:  
 14256                                  	; LRU < 8000H get set to 0. Others -= 8000h. This LRU = 8000h
 14257                                  	
 14258                                  	;mov	bx,15h
 14259 00001F23 BB1500                  	MOV	BX,SF_ENTRY.sf_position
 14260 00001F26 E80500                  	call	ResetLRU
 14261                                  
 14262                                  	; Set new LRU to AX
 14263                                  SimpleStuff:
 14264 00001F29 36A3[1000]              	MOV	[SS:FCBLRU],AX
 14265 00001F2D C3                      	retn
 14266                                  
 14267                                  ;Break	<ResetLRU - reset overflowed lru counts>
 14268                                  ;----------------------------------------------------------------------------
 14269                                  ;
 14270                                  ;   ResetLRU - during lru updates, we may wrap at 64K. We must walk the
 14271                                  ;   entire set of SFTs and subtract 8000h from their lru counts and truncate
 14272                                  ;   at 0.
 14273                                  ;
 14274                                  ;   Inputs:	BX is offset into SFT field where lru firld is kept
 14275                                  ;		ES:DI point to SFT currently being updated
 14276                                  ;   Outputs:	All FCB SFTs have their lru fields truncated
 14277                                  ;		AX has 8000h
 14278                                  ;   Registers modified: none
 14279                                  ;
 14280                                  ;----------------------------------------------------------------------------
 14281                                  ;
 14282                                  
 14283                                  	; 17/05/2019 - Retro DOS v4.0
 14284                                  ResetLRU:
 14285                                  	; ResetLRU is only called from fcbio.asm. So SS can be assumed to be 
 14286                                  	; DOSDATA
 14287                                  
 14288 00001F2E B80080                  	MOV	AX,8000h
 14289 00001F31 06                      	push	es
 14290 00001F32 57                      	push	di
 14291                                  	;LES	DI,[CS:SFTFCB]		; get pointer to head
 14292 00001F33 36C43E[4000]            	LES	DI,[SS:SFTFCB] ; MSDOS 6.0
 14293                                  	;mov	cx,[es:di+4]
 14294 00001F38 268B4D04                	MOV	CX,[ES:DI+SFT.SFCount]
 14295                                  	;lea	di,[di+6]
 14296 00001F3C 8D7D06                  	LEA	DI,[DI+SFT.SFTable] 	; point at table
 14297                                  ovScan:
 14298 00001F3F 262901                  	SUB	[ES:DI+BX],AX		; decrement lru count
 14299 00001F42 7703                    	JA	short ovLoop
 14300 00001F44 268901                  	MOV	[ES:DI+BX],AX		; truncate at 0
 14301                                  ovLoop:
 14302                                  	;;add	di,53	; MSDOS 3.3
 14303                                  	;add	di,59	; MSDOS 6.0	
 14304 00001F47 83C73B                  	ADD	DI,SF_ENTRY.size	; advance to next
 14305 00001F4A E2F3                    	LOOP	ovScan
 14306 00001F4C 5F                      	pop	di
 14307 00001F4D 07                      	pop	es
 14308 00001F4E 268901                  	MOV	[ES:DI+BX],AX
 14309 00001F51 C3                      	retn
 14310                                  
 14311                                  ;IF  0  ; We dont need this routine any more.
 14312                                  ;
 14313                                  ;Break	<SetOpenAge - update the open age of a SFT>
 14314                                  ;----------------------------------------------------------------------------
 14315                                  ;
 14316                                  ;   SetOpenAge - In order to maintain the first N open files in the FCB cache,
 14317                                  ;   we keep the 'open age' or an LRU count based on opens. We update the
 14318                                  ;   count here and fill in the appropriate field.
 14319                                  ;
 14320                                  ;   Inputs:	ES:DI point to SFT
 14321                                  ;   Outputs:	ES:DI has the open age field filled in.
 14322                                  ;		If open age has wraparound, we will have subtracted 8000h
 14323                                  ;		    from all open ages.
 14324                                  ;   Registers modified: AX
 14325                                  ;
 14326                                  ;----------------------------------------------------------------------------
 14327                                  ;
 14328                                  ;SetOpenAge:
 14329                                  ;	; 20/07/2018 - Retro DOS v3.0
 14330                                  ;	; MSDOS 3.3 - IBMDOS.COM, Offset 2597h 
 14331                                  ;	; (& MSDOS 6.0, FCBIO.ASM)
 14332                                  ;
 14333                                  ;	; SetOpenAge is called from fcbio2.asm. SS can be assumed to be valid.
 14334                                  ;
 14335                                  ;	MOV	AX,[CS:OpenLRU]	; SS override
 14336                                  ;	INC	AX
 14337                                  ;	;mov	[es:di+17h],ax
 14338                                  ;	MOV	[ES:DI+sf_OpenAge],AX
 14339                                  ;	JNZ	short SetDone
 14340                                  ;	;mov	bx,17h
 14341                                  ;	MOV	BX,SF_ENTRY.sf_position+2 ; mov bx,sf_OpenAge
 14342                                  ;	call	ResetLRU
 14343                                  ;SetDone:
 14344                                  ;	MOV	[CS:OpenLRU],AX
 14345                                  ;	retn
 14346                                  ;
 14347                                  ;ENDIF	; SetOpenAge no longer needed
 14348                                  
 14349                                  ; 21/07/2018 - Retro DOS v3.0
 14350                                  ; LRUFCB for MSDOS 6.0 !
 14351                                  
 14352                                  ;Break	<LRUFCB - perform LRU on FCB sfts>
 14353                                  ;----------------------------------------------------------------------------
 14354                                  ;
 14355                                  ;   LRUFCB - find LRU fcb in cache. Set ThisSFT and return it. We preserve
 14356                                  ;	the first keepcount sfts if they are network sfts or if sharing is
 14357                                  ;	loaded.  If carry is set then NO BLASTING is NECESSARY.
 14358                                  ;
 14359                                  ;   Inputs:	none
 14360                                  ;   Outputs:	ES:DI point to SFT
 14361                                  ;		ThisSFT points to SFT
 14362                                  ;		SFT is zeroed
 14363                                  ;		Carry set of closes failed
 14364                                  ;   Registers modified: none
 14365                                  ;
 14366                                  ;----------------------------------------------------------------------------
 14367                                  ;
 14368                                  ; MSDOS 6.0
 14369                                  ;IF 0	; rewritten this routine
 14370                                  ;
 14371                                  ;LRUFCB: ; MSDOS 3.3 - IBMDOS.COM (1987) - Offset 25ADh
 14372                                  ;	call	save_world
 14373                                  ;	
 14374                                  ; Find nth oldest NET/SHARE FCB. We want to find its age for the second scan
 14375                                  ; to find the lease recently used one that is younger than the open age.  We
 14376                                  ; operate be scanning the list n times finding the least age that is greater
 14377                                  ; or equal to the previous minimum age.
 14378                                  ;
 14379                                  ;   BP is the count of times we need to go through this loop.
 14380                                  ;   AX is the current acceptable minimum age to consider
 14381                                  ;
 14382                                  ;	mov	bp,[CS:KEEPCOUNT]	; k = keepcount;
 14383                                  ;	XOR	AX,AX			; low = 0;
 14384                                  ;
 14385                                  ; If we've scanned the table n times, then we are done.
 14386                                  ;
 14387                                  ;lru1:
 14388                                  ;	CMP	bp,0			; while (k--) {
 14389                                  ;	JZ	short lru75
 14390                                  ;	DEC	bp
 14391                                  ;
 14392                                  ; Set up for scan.
 14393                                  ;
 14394                                  ;   AX is the minimum age for consideration
 14395                                  ;   BX is the minimum age found during the scan
 14396                                  ;   SI is the position of the entry that corresponds to BX
 14397                                  ;
 14398                                  ;	MOV	BX,-1			;     min = 0xffff;
 14399                                  ;	MOV	si,BX			;     pos = 0xffff;
 14400                                  ;	LES	DI,[CS:SFTFCB]		;     for (CX=FCBCount; CX>0; CX--)
 14401                                  ;	;mov	cx,[es:di+4]
 14402                                  ;	MOV	CX,[ES:DI+SFT.SFCount]
 14403                                  ;	;lea	di,[di+6]
 14404                                  ;	LEA	DI,[DI+SFT.SFTable]
 14405                                  ;
 14406                                  ; Innermost loop.  If the current entry is free, then we are done.  Or, if the
 14407                                  ; current entry is busy (indicating a previous aborted allocation), then we
 14408                                  ; are done.  In both cases, we use the found entry.
 14409                                  ;
 14410                                  ;lru2:
 14411                                  ;	cmp	word [es:di],0
 14412                                  ;	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0
 14413                                  ;	jz	short lru25
 14414                                  ;	;cmp	word [es:di],-1
 14415                                  ;	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy
 14416                                  ;	cmp	word [es:di],sf_busy
 14417                                  ;	jnz	short lru3
 14418                                  ;
 14419                                  ; The entry is usable without further scan.  Go and use it.
 14420                                  ;
 14421                                  ;lru25:
 14422                                  ;	MOV	si,DI			;	      pos = i;
 14423                                  ;	JMP	short lru11		;	      goto got;
 14424                                  ;
 14425                                  ; See if the entry is for the network or for the sharer.
 14426                                  ;
 14427                                  ;  If for the sharer or network then
 14428                                  ;	if the age < current minimum AND >= allowed minimum then
 14429                                  ;	    this entry becomes current minimum
 14430                                  ;
 14431                                  ;lru3:
 14432                                  ;	;test	word [es:di+5],8000h
 14433                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet 
 14434                                  ;					;	  if (!net[i]
 14435                                  ;	JNZ	short lru35
 14436                                  ;if installed
 14437                                  ;	call	CheckShare		;		&& !sharing)
 14438                                  ;	JZ	short lru5		;	  else
 14439                                  ;ENDIF
 14440                                  ;
 14441                                  ; This SFT is for the net or is for the sharer. See if it less than the
 14442                                  ; current minimum.
 14443                                  ;
 14444                                  ;lru35:
 14445                                  ;	;mov	dx,[es:di+17h]
 14446                                  ;	MOV	DX,[ES:DI+sf_OpenAge]
 14447                                  ;	CMP	DX,AX			;	  if (age[i] >= low &&
 14448                                  ;	JB	short lru5
 14449                                  ;	CMP	DX,BX
 14450                                  ;	JAE	short lru5		;	      age[i] < min) {
 14451                                  ;
 14452                                  ; entry is new minimum.  Remember his age.
 14453                                  ;
 14454                                  ;	mov	bx,DX			;	      min = age[i];
 14455                                  ;	mov	si,di			;	      pos = i;
 14456                                  ;
 14457                                  ; End of loop.	gp back for more
 14458                                  ;
 14459                                  ;lru5:
 14460                                  ;	;add	di,53
 14461                                  ;	add	di,SF_ENTRY.size
 14462                                  ;	loop	lru2			;	      }
 14463                                  ;
 14464                                  ; The scan is complete. If we have successfully found a new minimum (pos != -1)
 14465                                  ; set then threshold value to this new minimum + 1. Otherwise, the scan is
 14466                                  ; complete.  Go find LRU.
 14467                                  ;
 14468                                  ;lru6:	
 14469                                  ;	cmp	si,-1			; position not -1?
 14470                                  ;	jz	short lru75		; no, done with everything
 14471                                  ;	lea	ax,[bx+1]		; set new threshold age
 14472                                  ;	jmp	short lru1		; go and loop for more
 14473                                  ;lru65:	
 14474                                  ;	stc
 14475                                  ;	jmp	short LRUDead		;	  return -1;
 14476                                  ;
 14477                                  ; Main loop is done. We have AX being the age+1 of the nth oldest sharer or
 14478                                  ; network entry. We now make a second pass through to find the LRU entry
 14479                                  ; that is local-no-share or has age >= AX
 14480                                  ;
 14481                                  ;lru75:
 14482                                  ;	mov	bx,-1			; min = 0xffff;
 14483                                  ;	mov	si,bx			; pos = 0xffff;
 14484                                  ;	LES	DI,[CS:SFTFCB]		; for (CX=FCBCount; CX>0; CX--)
 14485                                  ;	;mov	cx,[es:di+4]
 14486                                  ;	MOV	CX,[ES:DI+SFT.SFCount]
 14487                                  ;	;lea	di,[di+6]
 14488                                  ;	LEA	DI,[DI+SFT.SFTable]
 14489                                  ;
 14490                                  ; If this is is local-no-share then go check for LRU else if age >= threshold
 14491                                  ; then check for lru.
 14492                                  ;
 14493                                  ;lru8:
 14494                                  ;	;test	word [es:di+5],8000h
 14495                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 14496                                  ;	jnz	short lru85		; is for network, go check age
 14497                                  ;	call	CheckShare		; sharer here?
 14498                                  ;	jz	short lru86		; no, go check lru
 14499                                  ;
 14500                                  ; Network or sharer.  Check age
 14501                                  ;
 14502                                  ;lru85:
 14503                                  ;	;cmp	[es:di+17h],ax
 14504                                  ;	cmp	[es:di+sf_OpenAge],ax
 14505                                  ;	jb	short lru9		; age is before threshold, skip it
 14506                                  ;
 14507                                  ; Check LRU
 14508                                  ;
 14509                                  ;lru86:
 14510                                  ;	;cmp	[es:di+15h],bx
 14511                                  ;	cmp	[es:di+sf_LRU],bx	; is LRU less than current LRU?
 14512                                  ;	jae	short lru9		; no, skip this
 14513                                  ;	mov	si,di			; remember position
 14514                                  ;	;mov	bx,[es:di+15h]
 14515                                  ;	mov	bx,[es:di+sf_LRU]	; remember new minimum LRU
 14516                                  ;
 14517                                  ; Done with this entry, go back for more.
 14518                                  ;
 14519                                  ;lru9:
 14520                                  ;	;add	di, 53
 14521                                  ;	add	di,SF_ENTRY.size
 14522                                  ;	loop	lru8
 14523                                  ;
 14524                                  ; Scan is complete. If we found NOTHING that satisfied us then we bomb
 14525                                  ; out. The conditions here are:
 14526                                  ;
 14527                                  ;  No local-no-shares AND all net/share entries are older than threshold
 14528                                  ;
 14529                                  ;lru10:
 14530                                  ;	cmp	si,-1			; if no one f
 14531                                  ;	jz	short lru65		;     return -1;
 14532                                  ;lru11:
 14533                                  ;	mov	di,si
 14534                                  ;	MOV	[CS:THISSFT],DI		; set thissft
 14535                                  ;	MOV	[CS:THISSFT+2],ES
 14536                                  ;
 14537                                  ; If we have sharing or thisSFT is a net sft, then close it until ref count
 14538                                  ; is 0.
 14539                                  ;
 14540                                  ;	;test	word [es:di+5],8000h
 14541                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 14542                                  ;	JNZ	short LRUClose
 14543                                  ;IF INSTALLED
 14544                                  ;	call	CheckShare
 14545                                  ;	JZ	short LRUDone
 14546                                  ;ENDIF
 14547                                  ;
 14548                                  ; Repeat close until ref count is 0
 14549                                  ;
 14550                                  ;LRUClose:
 14551                                  ;	push	ss
 14552                                  ;	pop	ds
 14553                                  ;	LES	DI,[THISSFT]
 14554                                  ;	cmp     word [es:di],0
 14555                                  ;	;CMP	word [ES:DI+SFT.sf_ref_count],0 ; is ref count still <> 0?
 14556                                  ;	JZ	short LRUDone 		; nope, all done
 14557                                  ;	call	DOS_CLOSE
 14558                                  ;	jnc	short LRUClose		; no error => clean up
 14559                                  ;	;cmp	al,6
 14560                                  ;	cmp	al,error_invalid_handle
 14561                                  ;	jz	short LRUClose
 14562                                  ;	stc
 14563                                  ;	JMP	short LRUDead
 14564                                  ;LRUDone:
 14565                                  ;	XOR	AL,AL
 14566                                  ;	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared
 14567                                  ;
 14568                                  ;LRUDead:
 14569                                  ;	call	restore_world
 14570                                  ;	LES     DI,[CS:THISSFT]
 14571                                  ;	jnc	short LRUFCB_retn
 14572                                  ;LRUFCB_err:
 14573                                  ;	; mov	al, 23h	
 14574                                  ;	MOV	AL,error_FCB_unavailable
 14575                                  ;LRUFCB_retn:	
 14576                                  ;	retn:
 14577                                  ;
 14578                                  ;ENDIF	; LRUFCB has been rewritten below.
 14579                                  
 14580                                  ; 17/05/2019 - Retro DOS v4.0
 14581                                  ; LRUFCB for MSDOS 6.0 !
 14582                                  ;----------------------------------------------------------------------------
 14583                                  ;
 14584                                  ; LruFCB -- allocate the LRU SFT from the SFT Table. The LRU scheme
 14585                                  ; maintains separate counts for net/Share and local SFTs. We allocate a 
 14586                                  ; net/Share SFT only if we do not find a local SFT. This helps keep
 14587                                  ; net/Share SFTs which cannot be regenerated for as long as possible. We
 14588                                  ; optimize regeneration operations by keeping track of the current local
 14589                                  ; SFT. This avoids scanning of the SFTs as long as we have at least one 
 14590                                  ; local SFT in the SFT Block.
 14591                                  ;
 14592                                  ; Inputs: al = 0 => Regenerate SFT operation
 14593                                  ;	    = 1 => Allocate new SFT for Open/Create
 14594                                  ;
 14595                                  ; Outputs: Carry clear
 14596                                  ;	 	es:di = Address of allocated SFT
 14597                                  ;	  	ThisSFT = Address of allocated SFT
 14598                                  ;
 14599                                  ;	  carry set if closes of net/Share files failed 
 14600                                  ;		al = error_FCB_unavailable
 14601                                  ;
 14602                                  ; Registers affected: None
 14603                                  ;
 14604                                  ;----------------------------------------------------------------------------
 14605                                  
 14606                                  ;LruFCB	PROC	NEAR
 14607                                  LRUFCB:
 14608                                  	; 17/05/2019 - Retro DOS v4.0
 14609                                  	; DOSCODE:5805h (MSDOS 6.21, MSDOS.SYS)
 14610                                  
 14611                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14612                                  	; DOSCODE:57F1h (MSDOS 5.0, MSDOS.SYS)
 14613                                  
 14614                                  	; 20/01/2024 Retro DOS v5.0 (Modified PCDOS 7.1 IBMMDOS.COM)
 14615                                  	; DOSCODE:5E7Ch (PCDOS 7.1, IBMDOS.COM)
 14616                                  
 14617 00001F52 06                      	push	es	; * (MSDOS 6.21)
 14618                                  	
 14619 00001F53 E802E5                  	call	save_world
 14620                                  	
 14621                                  	;getdseg <ds>		;ds = DOSDATA
 14622 00001F56 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 14623                                  
 14624 00001F5B 08C0                    	or	al,al		;Check if regenerate allocation
 14625 00001F5D 7516                    	jnz	short lru1	;Try to find SFT to use
 14626                                  
 14627                                  	; This is a regen call. If LocalSFT contains the address of a valid 
 14628                                  	; local SFT, just return that SFT to reuse
 14629                                  
 14630                                  	; 20/01/2024
 14631                                  	;mov	di,[LocalSFT]
 14632                                  	;or	di,[LocalSFT+2]	;is address == 0?
 14633                                  	;jz	short lru1	;invalid local SFT, find one
 14634                                  
 14635                                  	; We have found a valid local SFT. Recycle this SFT
 14636                                  
 14637 00001F5F C43E[A710]              	les	di,[LocalSFT]
 14638                                  
 14639                                  	; 20/01/2024 (PCDOS 7.1 IBMDOS.COM)
 14640 00001F63 8CC1                    	mov	cx,es
 14641 00001F65 09F9                    	or	cx,di		; is address == 0?
 14642 00001F67 740C                    	jz	short lru1	; invalid local SFT, find one
 14643                                  
 14644                                  gotlocalSFT:
 14645 00001F69 893E[9E05]              	mov	[THISSFT],di
 14646 00001F6D 8C06[A005]              	mov	[THISSFT+2],es
 14647 00001F71 F8                      	clc
 14648 00001F72 E9A900                  	jmp	LRUDone		;clear up SFT and return
 14649                                  
 14650                                  lru1:
 14651 00001F75 C43E[4000]              	les	di,[SFTFCB]	;es:di = SF Table for FCBs
 14652                                  	;mov	cx,[es:di+4]
 14653 00001F79 268B4D04                	mov	cx,[es:di+SFT.SFCount]	;cx = number of SFTs
 14654                                  	;lea	di,[di+6]
 14655 00001F7D 8D7D06                  	lea	di,[di+SFT.SFTable]	;es:di = first SFT
 14656                                  
 14657                                  	; We scan through all the SFTs scanning for a free one. It also 
 14658                                  	; remembers the LRU SFT for net/Share SFTs and local SFTs separately. 
 14659                                  	; bx = min. LRU for local SFTs
 14660                                  	; si = pos. of local SFT with min. LRU
 14661                                  	; dx = min. LRU for net/Share SFTs
 14662                                  	; bp = pos. of net/Share SFT with min. LRU
 14663                                  
 14664 00001F80 BBFFFF                  	mov	bx,-1		; init. to 0xffff ( max. LRU value )
 14665 00001F83 89DE                    	mov	si,bx
 14666 00001F85 89DA                    	mov	dx,bx
 14667 00001F87 89DD                    	mov	bp,bx
 14668                                  
 14669                                  findSFT:
 14670                                  	;See if this SFT is a free one. If so, return it
 14671 00001F89 26830D00                	or	word [es:di],0
 14672                                  	;or	word [es:di+SF_ENTRY.sf_ref_count],0 ;reference count = 0 ?
 14673 00001F8D 744C                    	jz	short gotSFT	;yes, SFT is free
 14674                                  	;;cmp	word [es:di],-1
 14675                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy ;Is it busy?
 14676 00001F8F 26833DFF                	cmp	word [es:di],sf_busy ; -1 
 14677 00001F93 7446                    	jz	short gotSFT	;no, can use it
 14678                                  
 14679                                  	; Check if this SFT is local and store its address in LocalSFT. Can be 
 14680                                  	; used for a later regen.
 14681                                  
 14682                                  	; 16/12/2022
 14683                                  	; 08/11/2022
 14684                                  	;test	byte [es:di+6],80h
 14685 00001F95 26F6450680              	test	byte [es:di+SF_ENTRY.sf_flags+1],(sf_isnet>>8) ; 80h
 14686                                  	; 08/11/2022 Retro DOS v4.0 (MSDOS 5.0 MSDOS.SYS compatibility)
 14687                                  	;;test	word [es:di+5],8000h
 14688                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet ; network SFT?
 14689 00001F9A 7531                    	jnz	short lru5	;yes, get net/Share LRU
 14690                                  
 14691                                  ;IF installed
 14692 00001F9C E8B25D                  	call	CheckShare	;Share present?
 14693                                  ;ENDIF
 14694 00001F9F 752C                    	jnz	short lru5	;yes, get net/Share LRU
 14695                                  
 14696                                  	;Local SFT, register its address
 14697                                  
 14698                                  	; !!HACK!!!
 14699                                  	; There is a slightly dirty hack out here in a desperate bid to save  
 14700                                  	; code space. There is similar code duplicated at label 'gotSFT'. We 
 14701                                  	; enter from there if al = 0, update the LocalSFT variable, and since 
 14702                                  	; al = 0, we jump out of the loop to the exit point. I have commented 
 14703                                  	; out the code that previously existed at label 'gotSFT'
 14704                                  
 14705                                  hackpoint:
 14706 00001FA1 893E[A710]              	mov	[LocalSFT],di
 14707 00001FA5 8C06[A910]              	mov	[LocalSFT+2],es	;store local SFT address
 14708                                  
 14709 00001FA9 08C0                    	or	al,al		;Is operation = REGEN?
 14710 00001FAB 74BC                    	jz	short gotlocalSFT ;yes, return this SFT for reuse
 14711                                  
 14712                                  	;Get LRU for local files
 14713                                  	
 14714                                  	;cmp	[es:di+15h],bx
 14715 00001FAD 26395D15                	cmp	[es:di+sf_LRU],bx ;SFT.LRU < min?
 14716 00001FB1 7306                    	jae	short lru4	;no, skip 
 14717                                  
 14718                                  	;mov	bx,[es:di+15h]
 14719 00001FB3 268B5D15                	mov	bx,[es:di+sf_LRU] ;yes, store new minimum
 14720 00001FB7 89FE                    	mov	si,di		;store SFT position
 14721                                  lru4:
 14722                                  	;add	di,59
 14723 00001FB9 83C73B                  	add	di,SF_ENTRY.size ;go to next SFT
 14724 00001FBC E2CB                    	loop	findSFT
 14725                                  	
 14726                                  	; 20/01/2024
 14727 00001FBE 49                      	dec	cx ; -1
 14728                                  
 14729                                  	; Check whether we got a net/Share or local SFT. If local SFT
 14730                                  	; available, we will reuse it instead of net/Share LRU
 14731                                  
 14732 00001FBF 89F7                    	mov	di,si
 14733                                  	;cmp	si,-1		;local SFT available?
 14734 00001FC1 39CE                    	cmp	si,cx ; 20/01/2024
 14735 00001FC3 7516                    	jnz	short gotSFT	;yes, return it
 14736                                  
 14737                                  	;No local SFT, see if we got a net/Share SFT
 14738                                  
 14739 00001FC5 89EF                    	mov	di,bp
 14740                                  
 14741 00001FC7 39CD                    	cmp	bp,cx ; -1 ; 20/01/2024
 14742                                  	;cmp	bp,-1		;net/Share SFT available?
 14743 00001FC9 752D                    	jnz	short gotnetSFT	;yes, return it
 14744                                  noSFT:
 14745                                  	; NB: This error should never occur. We always must have an LRU SFT.
 14746                                  	; This error can occur only if the SFT has been corrupted or the LRU
 14747                                  	; count is not maintained properly.
 14748                                  
 14749 00001FCB EB4E                    	jmp	short errorbadSFT ;error, no FCB available.
 14750                                  
 14751                                  	; Handle the LRU for net/Share SFTs
 14752                                  lru5:
 14753                                  	;cmp	[es:di+15h],dx
 14754 00001FCD 26395515                	cmp	[es:di+sf_LRU],dx ;SFT.LRU < min?
 14755 00001FD1 73E6                    	jae	short lru4	;no, skip
 14756                                  
 14757                                  	;mov	dx,[es:di+15h]
 14758 00001FD3 268B5515                	mov	dx,[es:di+sf_LRU] ;yes, store new minimum
 14759                                  
 14760 00001FD7 89FD                    	mov	bp,di		;store SFT position
 14761 00001FD9 EBDE                    	jmp	short lru4	;continue with next SFT
 14762                                  
 14763                                  gotSFT:
 14764 00001FDB 08C0                    	or	al,al
 14765 00001FDD 74C2                    	jz	short hackpoint	;save es:di in LocalSFT
 14766                                  
 14767                                  	; HACK!!!
 14768                                  	; The code here differs from the code at 'hackpoint' only in the 
 14769                                  	; order of the check for al. If al = 0, we can jump to 'hackpoint'
 14770                                  	; and then from there jump out to 'gotlocalSFT'. The original code
 14771                                  	; has been commented out below and replaced by the code just above.
 14772                                  
 14773                                  ;If regen, then this SFT can be registered as a local one ( even if free ).
 14774                                  ;
 14775                                  ;	or	al,al		  ;Regen?
 14776                                  ;	jnz	short notlocaluse ;yes, register it and return
 14777                                  ;
 14778                                  ;Register this SFT as a local one
 14779                                  ;
 14780                                  ;	mov	[LocalSFT],di
 14781                                  ;	mov	[LocalSFT+2],es
 14782                                  ;	jmp	gotlocalSFT	;return to caller
 14783                                  ;
 14784                                  ;notlocaluse:
 14785                                  
 14786                                  	; The caller is probably going to use this SFT for a net/Share file.
 14787                                  	; We will come here only on a Open/Create when the caller($FCB_OPEN)
 14788                                  	; does not really know whether it is a local file or not. We
 14789                                  	; invalidate LocalSFT if the SFT we are going to use was previously
 14790                                  	; registered as a local SFT that can be recycled.
 14791                                  
 14792 00001FDF 8CC0                    	mov	ax,es
 14793 00001FE1 393E[A710]              	cmp	[LocalSFT],di		;Offset same?
 14794 00001FE5 750E                    	jne	short notinvalid
 14795 00001FE7 3906[A910]              	cmp	[LocalSFT+2],ax		;Segments same?
 14796                                  	;je	short zerolocalSFT	;no, no need to invalidate
 14797                                  	; 20/01/2024 (PCDOS 7.1 IBMDOS.COM)
 14798 00001FEB 7508                    	jne	short notinvalid
 14799                                  zerolocalSFT:	
 14800 00001FED 31C0                    	xor	ax,ax ; 0
 14801 00001FEF A3[A710]                	mov	[LocalSFT],ax
 14802 00001FF2 A3[A910]                	mov	[LocalSFT+2],ax
 14803                                  	
 14804                                  notinvalid:
 14805 00001FF5 E971FF                  	jmp	gotlocalSFT
 14806                                  
 14807                                  	; The SFT we are going to use was registered in the LocalSFT variable.
 14808                                  	; Invalidate this variable i.e LocalSFT = NULL
 14809                                  
 14810                                  ;zerolocalSFT:
 14811                                  	;xor	ax,ax ; 0
 14812                                  	;mov	[LocalSFT],ax
 14813                                  	;mov	[LocalSFT+2],ax
 14814                                  	;
 14815                                  	;jmp	gotlocalSFT
 14816                                  
 14817                                  gotnetSFT:
 14818                                  	; We have an SFT that is currently net/Share. If it is going to be
 14819                                  	; used for a regen, we know it has to be a local SFT. Update the
 14820                                  	; LocalSFT variable
 14821                                  
 14822 00001FF8 08C0                    	or	al,al
 14823 00001FFA 7508                    	jnz	short closenet
 14824                                  
 14825 00001FFC 893E[A710]              	mov	[LocalSFT],di
 14826 00002000 8C06[A910]              	mov	[LocalSFT+2],es	;store local SFT address
 14827                                  closenet:
 14828 00002004 893E[9E05]              	mov	[THISSFT],di	; set thissft
 14829 00002008 8C06[A005]              	mov	[THISSFT+2],es	
 14830                                  
 14831                                  	; If we have sharing or thisSFT is a net sft, then close it until ref
 14832                                  	; count is 0.
 14833                                  	; NB: We come here only if it is a net/Share SFT that is going to be
 14834                                  	; recycled -- no need to check for this.
 14835                                  
 14836                                  LRUClose:
 14837 0000200C 26833D00                	cmp	word [es:di],0
 14838                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0 ; is ref count still <> 0?
 14839 00002010 740C                    	jz	short LRUDone	; nope, all done
 14840                                  
 14841 00002012 E83017                  	call	DOS_CLOSE
 14842 00002015 73F5                    	jnc	short LRUClose	; no error => clean up
 14843                                  
 14844                                  	; Bugbug: I dont know why we are trying to close after we get an
 14845                                  	; error closing. Seems like we could have a potential infinite loop
 14846                                  	; here. This has to be verified.
 14847                                  
 14848 00002017 3C06                    	cmp	al,error_invalid_handle ; 6
 14849 00002019 74F1                    	je	short LRUClose
 14850                                  errorbadSFT:
 14851 0000201B F9                      	stc
 14852 0000201C EB05                    	JMP	short LRUDead
 14853                                  LRUDone:
 14854 0000201E 30C0                    	XOR	AL,AL
 14855 00002020 E81F01                  	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared
 14856                                  
 14857                                  LRUDead:
 14858 00002023 E81BE4                  	call	restore_world		; use macro
 14859                                  	
 14860 00002026 07                      	pop	es ; * (MSDOS 6.21)
 14861                                  
 14862                                  	;getdseg <es>
 14863 00002027 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 14864 0000202C 26C43E[9E05]            	les	di,[es:THISSFT]		;es:di points at allocated SFT
 14865                                  
 14866                                  	;;retnc
 14867                                  	;jc	short LruFCB_err
 14868                                  	;retn
 14869                                  
 14870                                  	; 16/12/2022
 14871                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14872 00002031 7302                    	jnc	short LruFCB_retn
 14873                                  	;jc	short LruFCB_err
 14874                                  	;retn
 14875                                  		
 14876                                  LruFCB_err:
 14877 00002033 B023                    	MOV	AL,error_FCB_unavailable ; 23h
 14878                                  LruFCB_retn:
 14879 00002035 C3                      	retn
 14880                                  	
 14881                                  ;LruFCB	ENDP
 14882                                  
 14883                                  ; 17/05/2019 - Retro DOS v4.0
 14884                                  
 14885                                  ; DOSCODE:58F3h (MSDOS 6.21, MSDOS.SYS)
 14886                                  
 14887                                  ; --------------------------------------------------------------------------
 14888                                  ;**** RegenCopyName -- This function copies the filename from the FCB to
 14889                                  ; SFT and also to DOS local buffers. There was duplicate code in FCBRegen
 14890                                  ; to copy the name to different destinations
 14891                                  ;
 14892                                  ; Inputs: ds:si = source string
 14893                                  ;	 es:di = destination string
 14894                                  ;	 cx = length of string
 14895                                  ;
 14896                                  ; Outputs: String copied to destination
 14897                                  ;
 14898                                  ; Registers affected: cx,di,si
 14899                                  ; --------------------------------------------------------------------------
 14900                                  
 14901                                  RegenCopyName:
 14902                                  CopyName:
 14903 00002036 AC                      	lodsb			;load character
 14904 00002037 E8EB39                  	call	UCase		; convert char to upper case
 14905                                  StuffChar2:
 14906 0000203A AA                      	STOSB			;store converted character
 14907 0000203B E2F9                    	LOOP	CopyName	;
 14908                                  DoneName:
 14909 0000203D C3                      	retn
 14910                                  
 14911                                  ; --------------------------------------------------------------------------
 14912                                  
 14913                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14914                                  	; 21/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 14915                                  
 14916                                  FCBRegen:
 14917                                  	; called from SFTFromFCB. SS already DOSDATA
 14918                                  
 14919                                  	; General data filling. Mode is sf_isFCB + open_for_both, date/time 
 14920                                  	; we do not fill, size we do no fill, position we do not fill,
 14921                                  	; bit 14 of flags = TRUE, other bits = FALSE
 14922                                  
 14923                                  	;mov	al,[si+19h]
 14924 0000203E 8A4419                  	MOV	AL,[SI+fcb_l_drive]
 14925                                  
 14926                                  	; We discriminate based on the first two bits in the reserved field.
 14927                                  	
 14928                                  	;test	al,80h
 14929 00002041 A880                    	test	AL,FCBSPECIAL		; check for no sharing test
 14930 00002043 741C                    	JZ	short RegenNoSharing	; yes, go regen from no sharing
 14931                                  
 14932                                  	; The FCB is for a network or a sharing based system. At this point 
 14933                                  	; we have already closed the SFT for this guy and reconnection is 
 14934                                  	; impossible.
 14935                                  	;
 14936                                  	; Remember that he may have given us a FCB with bogus information in
 14937                                  	; it. Check to see if sharing is present or if the redir is present.
 14938                                  	; If either is around, presume that we have cycled out the FCB and 
 14939                                  	; give the hard error. Otherwise, just return with carry set.
 14940                                  
 14941 00002045 E8095D                  	call	CheckShare		; test for sharer
 14942 00002048 7509                    	JNZ	short RegenFail		; yep, fail this.
 14943                                  	
 14944                                  	;mov	ax,1100h
 14945 0000204A B80011                  	MOV	AX,MultNET<<8		; install check on multnet
 14946 0000204D CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - INSTALLATION CHECK
 14947                                  			; Return: AL = 00h  not installed, OK to install
 14948                                  			; 01h  not installed, not OK to install
 14949                                  			; FFh  installed
 14950 0000204F 08C0                    	OR	AL,AL			; is it there?
 14951 00002051 740C                    	JZ	short RegenDead		; no, just fail the operation
 14952                                  RegenFail:
 14953                                  	; 17/05/2019 - Retro DOS v4.0
 14954                                  	;MOV	AX,[CS:USER_IN_AX]	; SS override
 14955 00002053 36A1[3A03]              	mov	ax,[SS:USER_IN_AX] ; MSDOS 6.0
 14956                                  
 14957                                  	;cmp	ah,10h
 14958 00002057 80FC10                  	cmp	AH,FCB_CLOSE
 14959 0000205A 7403                    	jz	short RegenDead
 14960 0000205C E89F01                  	call	FCBHardErr		; massive hard error.
 14961                                  RegenDead:
 14962 0000205F F9                      	STC				; carry set
 14963                                  FCBRegen_retn:
 14964 00002060 C3                      	retn
 14965                                  
 14966                                  	; Local FCB without sharing. Check to see if sharing is loaded. If 
 14967                                  	; so fail the operation.
 14968                                  
 14969                                  RegenNoSharing:
 14970 00002061 E8ED5C                  	call	CheckShare		; Sharing around?
 14971 00002064 75ED                    	JNZ	short RegenFail
 14972                                  	
 14973                                  	; Find an SFT for this guy.
 14974                                  	
 14975                                  	; 17/05/2019 - Retro DOS v4.0
 14976                                  
 14977                                  	; MSDOS 3.3
 14978                                  	;call	LRUFCB
 14979                                  	;jc	short FCBRegen_retn
 14980                                  	
 14981                                  	; MSDOS 6.0
 14982 00002066 50                      	push	ax
 14983 00002067 B000                    	mov	al,0			;indicate it is a regen operation
 14984 00002069 E8E6FE                  	call	LRUFCB
 14985 0000206C 58                      	pop	ax
 14986 0000206D 72F1                    	jc	short FCBRegen_retn
 14987                                  
 14988                                  	;mov	word [es:di+2],8002h
 14989 0000206F 26C745020280            	MOV	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB+open_for_both+SHARING_COMPAT
 14990 00002075 243F                    	AND	AL,3Fh			; get drive number for flags
 14991 00002077 98                      	CBW
 14992                                  	;or	ax,4000h
 14993 00002078 0D0040                  	OR	AX,sf_close_nodate	; normal FCB operation
 14994                                  
 14995                                  	; The bits field consists of the upper two bits (dirty and device) 
 14996                                  	; from the SFT and the low 4 bits from the open mode.
 14997                                  
 14998                                  	;mov	cl,[si+1Ah]
 14999 0000207B 8A4C1A                  	MOV	CL,[SI+fcb_nsl_bits]	; stick in dirty bits.
 15000 0000207E 88CD                    	MOV	CH,CL
 15001 00002080 80E5C0                  	AND	CH,0C0h 		; mask off the dirty/device bits
 15002 00002083 08E8                    	OR	AL,CH
 15003                                  	;and	cl,0Fh
 15004 00002085 80E10F                  	AND	CL,access_mask		; get the mode bits
 15005                                  	;mov	[es:di+2],cl
 15006 00002088 26884D02                	MOV	[ES:DI+SF_ENTRY.sf_mode],CL
 15007                                  	;mov	[es:di+5],ax
 15008 0000208C 26894505                	MOV	[ES:DI+SF_ENTRY.sf_flags],AX ; initial flags
 15009                                  	;MOV	AX,[CS:PROC_ID]		; SS override
 15010 00002090 36A1[3C03]              	mov	ax,[ss:PROC_ID] ; MSDOS 6.0
 15011                                  	;mov	[es:di+31h],ax
 15012 00002094 26894531                	MOV	[ES:DI+SF_ENTRY.sf_PID],AX
 15013 00002098 1E                      	push	ds
 15014 00002099 56                      	push	si
 15015 0000209A 06                      	push	es
 15016 0000209B 57                      	push	di
 15017 0000209C 16                      	push	ss
 15018 0000209D 07                      	pop	es
 15019 0000209E BF[4B05]                	MOV	DI,NAME1		; NAME1 is in DOSDATA
 15020                                  
 15021 000020A1 B90800                  	MOV	CX,8
 15022 000020A4 46                      	INC	SI			; Skip past drive byte to name in FCB
 15023                                  
 15024                                  	; MSDOS 3.3
 15025                                  ;RegenCopyName:
 15026                                  	;lodsb
 15027                                  	;call	UCase
 15028                                  	;stosb
 15029                                  	;loop	RegenCopyName
 15030                                  
 15031                                  	; MSDOS 6.0
 15032 000020A5 E88EFF                  	call	RegenCopyName		;copy the name to NAME1
 15033                                  
 15034 000020A8 16                      	push	ss	; SS is DOSDATA
 15035 000020A9 1F                      	pop	ds
 15036                                  
 15037                                  	;mov	byte [ATTRIB],16h
 15038 000020AA C606[6B05]16            	MOV	byte [ATTRIB],attr_hidden+attr_system+attr_directory
 15039                                  					; Must set this to something interesting
 15040                                  					; to call DEVNAME.
 15041 000020AF E8012B                  	call	DEVNAME 		; check for device
 15042 000020B2 5E                      	pop	si
 15043 000020B3 07                      	pop	es
 15044 000020B4 5E                      	pop	si
 15045 000020B5 1F                      	pop	ds
 15046 000020B6 7219                    	JC	short RegenFileNoSharing ; not found on device list => file
 15047                                  
 15048                                  	; Device found. We can ignore disk-specific info
 15049                                  
 15050                                  	;mov	[es:di+5],bh
 15051 000020B8 26887D05                	MOV	[ES:DI+SF_ENTRY.sf_flags],BH ; device parms
 15052                                  	;mov	byte [es:di+4],0
 15053 000020BC 26C6450400              	MOV	byte [ES:DI+SF_ENTRY.sf_attr],0 ; attribute
 15054                                  					; SS override
 15055                                  	;LDS	SI,[CS:DEVPT]		; get device driver
 15056 000020C1 36C536[9A05]            	lds	si,[ss:DEVPT] ; MSDOS 6.0
 15057                                  	;mov	[es:di+7],si
 15058 000020C6 26897507                	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
 15059                                  	;mov	[es:di+9],ds
 15060 000020CA 268C5D09                	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
 15061 000020CE C3                      	retn				; carry is clear
 15062                                  
 15063                                  RegenDeadJ:
 15064 000020CF EB8E                    	JMP	short RegenDead
 15065                                  
 15066                                  	; File found. Just copy in the remaining pieces.
 15067                                  
 15068                                  RegenFileNoSharing:
 15069                                  	;mov	ax,[es:di+5]
 15070 000020D1 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 15071 000020D5 83E03F                  	AND	AX,03Fh
 15072 000020D8 1E                      	push	ds
 15073 000020D9 56                      	push	si
 15074 000020DA E80153                  	call	FIND_DPB
 15075                                  	;mov	[es:di+7],si
 15076 000020DD 26897507                	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
 15077                                  	;mov	[es:di+9],ds
 15078 000020E1 268C5D09                	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
 15079 000020E5 5E                      	pop	si
 15080 000020E6 1F                      	pop	ds
 15081 000020E7 72E6                    	jc	short RegenDeadJ	; if find DPB fails, then drive
 15082                                  					; indicator was bogus
 15083                                  	;mov	ax,[si+1Dh]
 15084 000020E9 8B441D                  	MOV	AX,[SI+fcb_nsl_dirsec]
 15085                                  	;;mov	[es:di+1Dh],ax ; MSDOS 3.3
 15086                                  	;mov	[es:di+1Bh],ax ; MSDOS 6.0
 15087 000020EC 2689451B                	MOV	[ES:DI+SF_ENTRY.sf_dirsec],AX
 15088                                  
 15089                                  	; MSDOS 6.0
 15090                                  
 15091                                  	; SR;
 15092                                  	; Extract the read-only and archive bits from the top 2 bits of the sector
 15093                                  	; number
 15094                                  
 15095                                  	;mov	al,[si+18h]
 15096 000020F0 8A4418                  	mov	al,[si+fcb_sfn]
 15097 000020F3 24C0                    	and	al,0C0h		;get the 2 attribute bits
 15098 000020F5 88C4                    	mov	ah,al
 15099 000020F7 D0C4                    	rol	ah,1
 15100 000020F9 D0E8                    	shr	al,1
 15101 000020FB 08E0                    	or	al,ah
 15102 000020FD 243F                    	and	al,03Fh		;mask off unused bits
 15103                                  	;mov	[es:di+4],al
 15104 000020FF 26884504                	mov	[es:di+SF_ENTRY.sf_attr],al
 15105                                  
 15106                                  	; SR;
 15107                                  	; Update the higher word of the directory sector from the FCB
 15108                                  
 15109                                  	;;mov	al,[si+18h]
 15110 00002103 8A4418                  	mov	al,[si+fcb_sfn]
 15111 00002106 243F                    	and	al,03Fh		;mask off top 2 bits -- attr bits
 15112 00002108 28E4                    	sub	ah,ah
 15113                                  	;mov	[es:di+1Dh],ax
 15114 0000210A 2689451D                	mov	[es:di+SF_ENTRY.sf_dirsec+2],ax ;update high word
 15115                                  
 15116                                  	; 21/01/2024
 15117                                  	; MSDOS 6.0 (& MSDOS 3.3)
 15118                                  	;mov	ax,[si+1Bh]
 15119 0000210E 8B441B                  	MOV	AX,[SI+fcb_nsl_firclus]
 15120                                  	;;mov	[es:di+0Bh],ax
 15121                                  	;MOV	[ES:DI+SF_ENTRY.sf_firclus],AX
 15122                                  	;;;
 15123                                  	; 21/01/2024 (PCDOS 7.1 IBMDOS.COM)
 15124 00002111 2689452B                	mov	[es:di+2Bh],ax	; .sf_chain !!! (MSDOS 6.22)
 15125                                  	;mov	[es:di+SF_ENTRY.sf_chain],ax ; first cluster (32 bit) !?
 15126                                  	;;;	
 15127                                  
 15128                                  	;;mov	[es:di+1Bh],ax ; MSDOS 3.3
 15129                                  	;mov	[es:di+35h],ax ; MSDOS 6.0
 15130 00002115 26894535                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
 15131                                  
 15132                                  	;;;
 15133                                  	; 21/01/2024 (PCDOS 7.1 IBMDOS.COM)
 15134 00002119 31C0                    	xor     ax, ax	; 0
 15135 0000211B 2689452D                	mov     es:[di+2Dh], ax ; 0
 15136 0000211F 2689452D                	mov	[es:di+SF_ENTRY.sf_chain+2],ax
 15137                                  				; .sf_chain ! (MSDOS 6.22)
 15138                                  				; high word of first cluster (32 bit) !?
 15139 00002123 26894537                	mov	[es:di+37h],ax ; 0
 15140                                  	;mov	[es:di+SF_ENTRY.sf_lstclus+2],ax ; hw of last cluster
 15141                                  	;;;
 15142                                  
 15143                                  	;mov	al,[si+1Fh]
 15144 00002127 8A441F                  	MOV	AL,[SI+fcb_nsl_dirpos]
 15145                                  	;mov  	[es:di+1Fh],al
 15146 0000212A 2688451F                	MOV	[ES:DI+SF_ENTRY.sf_dirpos],AL
 15147                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 15148 0000212E 26FF05                  	inc	word [ES:DI]		; Increment reference count.
 15149                                  					; Existing FCB entries would be
 15150                                  					; flushed unnecessarily because of
 15151                                  					; check in CheckFCB of the ref_count.
 15152                                  					; July 22/85 - BAS
 15153                                  	;;;
 15154                                  	; 21/01/2024 (PCDOS 7.1 IBMDOS.COM)
 15155 00002131 E87627                  	call	set_sftfcb_entry ; put SFT entry number in the SFTFCB table
 15156                                  				 ; as FCB index number
 15157                                  	;;;
 15158                                  
 15159                                  	;lea	si,[si+1]
 15160 00002134 8D7401                  	LEA	SI,[SI+SYS_FCB.name]
 15161                                  	;lea	di,[di+20h]
 15162 00002137 8D7D20                  	LEA	DI,[DI+SF_ENTRY.sf_name]
 15163                                  	;mov	cx,11
 15164 0000213A B90B00                  	MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
 15165                                  	
 15166                                  	; MSDOS 6.0
 15167 0000213D E8F6FE                  	call	RegenCopyName	;copy name to SFT 
 15168                                  	
 15169                                  	; MSDOS 3.3
 15170                                  ;RegenCopyName2:
 15171                                  	;lodsb
 15172                                  	;call    UCase
 15173                                  	;stosb
 15174                                  	;loop    RegenCopyName2
 15175                                  
 15176 00002140 F8                      	clc
 15177 00002141 C3                      	retn
 15178                                  
 15179                                  ; 17/05/2019 - Retro DOS v4.0
 15180                                  ; 21/01/2024 - Retro DOS v5.0
 15181                                  
 15182                                  ;**	BlastSFT - FIll SFT with Garbage
 15183                                  ; --------------------------------------------------------------------------
 15184                                  ;	BlastSFT is used when an SFT is no longer needed; it's called with
 15185                                  ;	various garbage values to put into the SFT.  I don't know why,
 15186                                  ;	presumably to help with debugging (jgl).  We clear the few fields
 15187                                  ;	necessary to show that the SFT is free after filling it.
 15188                                  ;
 15189                                  ;	ENTRY	(es:di) = address of SFT
 15190                                  ;		(al) = fill character
 15191                                  ;	EXIT	(ax) = -1
 15192                                  ;		'C' clear
 15193                                  ;	USES	AX, CX, Flags
 15194                                  
 15195                                  BlastSFT:
 15196                                  	; 21/01/2024 (PCDOS 7.1 IBMDOS.COM)
 15197                                  	;;;
 15198 00002142 E8B927                  	call	SFT_FREE
 15199                                  	;;;
 15200 00002145 57                      	push	di
 15201                                  	;mov	cx,53 ; MSDOS 3.3
 15202                                  	;mov	cx,59 ; MSDOS 6.0
 15203 00002146 B93B00                  	mov	cx,SF_ENTRY.size
 15204 00002149 F3AA                    	rep	stosb
 15205 0000214B 5F                      	pop	di
 15206 0000214C 29C0                    	sub	ax,ax	; 0		; clear 'C'-----------------;
 15207 0000214E 268905                  	mov	[es:di],ax
 15208                                  	;mov	[es:di+SF_ENTRY.sf_ref_count],ax ; set ref count    ;
 15209                                  	;mov	[es:di+15h],ax
 15210 00002151 26894515                	mov	[es:di+sf_LRU],ax	; set lru		    ;
 15211 00002155 48                      	dec	ax	; -1					    ;
 15212                                  	;mov	[es:di+17h],ax ; 0FFFFh ; -1
 15213 00002156 26894517                	mov	[es:di+sf_OpenAge],ax	; set open age to -1	    ;
 15214                                  BlastSFT_retn:
 15215 0000215A C3                      	retn				; return with 'C' clear     ;
 15216                                  
 15217                                  ;Break	<CheckFCB - see if the SFT pointed to by the FCB is still OK>
 15218                                  ; --------------------------------------------------------------------------
 15219                                  ;
 15220                                  ;   CheckFCB - examine an FCB and its contents to see if it needs to be
 15221                                  ;   regenerated.
 15222                                  ;
 15223                                  ;   Inputs:	DS:SI point to FCB (not extended)
 15224                                  ;		AL is SFT index
 15225                                  ;   Outputs:	Carry Set - FCB needs to be regened
 15226                                  ;		Carry clear - FCB is OK. ES:DI point to SFT
 15227                                  ;   Registers modified: AX and BX
 15228                                  ;
 15229                                  ; --------------------------------------------------------------------------
 15230                                  
 15231                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15232                                  	; DOSCODE:59F0h (MSDOS 5.0, MSDOS.SYS)
 15233                                  
 15234                                  	; 21/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 15235                                  	; DOSCODE:607Eh (PCDOS 7.1 IBMDOS.COM)
 15236                                  CheckFCB:
 15237                                  		
 15238                                  	; called from $fcb_open and sftfromfcb. SS already set up to DOSDATA
 15239                                  
 15240                                  	; MSDOS 3.3
 15241                                  
 15242                                  	; LES	DI,[CS:SFTFCB]
 15243                                  
 15244                                  	; MSDOS 6.0
 15245                                  	
 15246                                  	; SR;
 15247                                  	; We check if the given FCB is for a local file. If so, we return a 
 15248                                  	; bad SFT status forcing the caller to regenerate the SFT.
 15249                                  
 15250                                  	;test	byte [si+19h],0C0h
 15251 0000215B F64419C0                	test	byte [si+fcb_l_drive],FCBNETWORK|FCBSHARE|FCBDEVICE
 15252 0000215F 7447                    	jz	short BadSFT		;Local file, return bad SFT
 15253 00002161 36C43E[4000]            	LES     DI,[SS:SFTFCB]		; SS override
 15254                                  
 15255                                  	; MSDOS 6.0 (& MSDOS 3.3)
 15256                                  	;cmp	[es:di+4],al
 15257 00002166 26384504                	CMP	[ES:DI+SFT.SFCount],AL
 15258 0000216A 723C                    	JC	short BadSFT
 15259                                  	;;mov	bl,53 ; MSDOS 3.3
 15260                                  	;mov	bl,59 ; MSDOS 6.0
 15261 0000216C B33B                    	MOV	BL,SF_ENTRY.size
 15262 0000216E F6E3                    	MUL	BL
 15263                                  	;lea	di,[di+6]
 15264 00002170 8D7D06                  	LEA	DI,[DI+SFT.SFTable]
 15265 00002173 01C7                    	ADD	DI,AX
 15266                                  	;MOV	AX,[CS:PROC_ID]	; MSDOS 3.3
 15267 00002175 36A1[3C03]              	mov	ax,[SS:PROC_ID] ; MSDOS 6.0  ; SS override
 15268                                  	;cmp	[es:di+31h],ax
 15269 00002179 26394531                	CMP	[ES:DI+SF_ENTRY.sf_PID],AX
 15270 0000217D 7529                    	JNZ	short BadSFT		; must match process
 15271 0000217F 26833D00                	cmp	word [es:di],0
 15272                                  	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],0
 15273 00002183 7423                    	JZ	short BadSFT		; must also be in use
 15274                                  	;mov	al,[si+19h]
 15275 00002185 8A4419                  	MOV	AL,[SI+fcb_l_drive]
 15276                                  	;test	al,80h
 15277 00002188 A880                    	test	AL,FCBSPECIAL		; a special FCB?
 15278 0000218A 7428                    	JZ	short CheckNoShare	; No. try local or device
 15279                                  
 15280                                  	; Since we are a special FCB, try NOT to use a bogus test instruction.
 15281                                  	; FCBSHARE is a superset of FCBNETWORK.
 15282                                  
 15283 0000218C 50                      	PUSH	AX
 15284                                  	;and	al,0C0h
 15285 0000218D 24C0                    	AND	AL,FCBMASK
 15286                                  	;cmp	al,0C0h
 15287 0000218F 3CC0                    	CMP	AL,FCBSHARE		; net FCB?
 15288 00002191 58                      	POP	AX
 15289 00002192 7516                    	JNZ	short CheckNet		; no
 15290                                  					; yes
 15291                                  ;
 15292                                  ;----- In share support -----
 15293                                  ;
 15294                                  	;call	far [cs:JShare+(11*4)]
 15295 00002194 36FF1E[BC00]            	Call    far [ss:JShare+(11*4)] ; 11 = ShChk ; SS Override
 15296 00002199 720D                    	JC	short BadSFT
 15297                                  
 15298                                  ; 21/01/2024
 15299                                  %if 0
 15300                                  	JMP	SHORT CheckD
 15301                                  ;
 15302                                  ;----- End in share support -----
 15303                                  ;
 15304                                  	; 09/11/2022
 15305                                  	; (There is not any procedure/sub
 15306                                  	;  which calls or jumps to CheckFirClus here)
 15307                                  	;;;
 15308                                  CheckFirClus:
 15309                                  	;cmp     bx,[es:di+0Bh]
 15310                                  	; 07/12/2022
 15311                                  	CMP	BX,[ES:DI+SF_ENTRY.sf_firclus]
 15312                                  	JNZ	short BadSFT
 15313                                  	;;;
 15314                                  %endif
 15315                                  
 15316                                  CheckD: 
 15317 0000219B 243F                    	AND	AL,3Fh
 15318                                  	;mov	ah,[es:di+5]
 15319 0000219D 268A6505                	MOV	AH,[ES:DI+SF_ENTRY.sf_flags]
 15320 000021A1 80E43F                  	AND	AH,3Fh
 15321 000021A4 38C4                    	CMP	AH,AL
 15322                                  	; 16/12/2022
 15323 000021A6 74B2                    	jz	short BlastSFT_retn	; carry is clear
 15324                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15325                                  	;jnz	short BadSFT
 15326                                  ;CheckD_retn:
 15327                                  	;retn
 15328                                  BadSFT: 
 15329 000021A8 F9                      	STC
 15330 000021A9 C3                      	retn
 15331                                  				
 15332                                  CheckNet:
 15333                                  	; 17/05/2019 - Retro DOS v4.0
 15334                                  	
 15335                                  ;----- In net support -----
 15336                                  
 15337                                  	; MSDOS 3.3
 15338                                  	;;mov	ax,[si+1Ah]
 15339                                  	;mov	ax,[si+fcb_net_handle]
 15340                                  	;;cmp	ax,[es:di+1Dh]
 15341                                  	;cmp	ax,[ES:DI+SF_ENTRY.sf_dirsec]
 15342                                  	;jnz	short BadSFT
 15343                                  	;;cmp	ax,[es:di+19h]
 15344                                  	;cmp	ax,[ES:DI+sf_netid]
 15345                                  	;jnz     short BadSFT
 15346                                  	;;mov	ax,[si+1Eh]
 15347                                  	;mov	ax,[si+fcb_l_attr]
 15348                                  	;;cmp	ax,[es:di+1Bh]
 15349                                  	;cmp	ax,[es:di+SF_ENTRY.sf_lstclus]
 15350                                  	;jnz     short BadSFT
 15351                                  
 15352                                  	; MSDOS 6.0
 15353                                  	;mov	ax,[si+1Ch]
 15354 000021AA 8B441C                  	MOV	AX,[SI+fcb_netID]	;AN000;IFS.DOS 4.00
 15355                                  	; 09/11/2022
 15356                                  	;cmp	ax,[es:di+0Bh] 
 15357 000021AD 263B450B                	CMP	AX,[ES:DI+sf_serial_ID]	;AN000;IFS.DOS 4.00
 15358 000021B1 75F5                    	JNZ	short BadSFT
 15359                                  
 15360                                  ;----- END In net support -----
 15361                                  
 15362                                  CheckNet_retn:
 15363 000021B3 C3                      	retn
 15364                                  
 15365                                  CheckNoShare:
 15366                                  
 15367                                  ; 16/12/2022
 15368                                  ;	; 09/11/2022 (following test instruction is nonsense!)
 15369                                  ;	; (I am leaving it here for MSDOS 5.0 MSDOS.SYS compatibility)
 15370                                  ;	;test	al,40h
 15371                                  ;	test	AL,FCBDEVICE		; Device?
 15372                                  ;	;jnz	short $+2 ; 09/11/2022
 15373                                  ;	JNZ	short CheckNoShareDev 	; Yes
 15374                                  
 15375                                  	; MSDOS 3.3 - IBMDOS.COM - Offset 27EFh
 15376                                  	;;mov	bx,[si+1Dh]
 15377                                  	;MOV	BX,[SI+fcb_nsl_dirsec]
 15378                                  	;;cmp	bx,[es:di+1Dh]
 15379                                  	;cmp	bx,[ES:DI+SF_ENTRY.sf_dirsec]
 15380                                  	;jnz	short BadSFT
 15381                                  	;;mov	bl,[si+1Fh]
 15382                                  	;MOV	bl,[SI+fcb_nsl_dirpos]
 15383                                  	;;cmp	bl,[es:di+1Fh]
 15384                                  	;cmp	bl,[ES:DI+SF_ENTRY.sf_dirpos]
 15385                                  	;jnz	short BadSFT
 15386                                  	;;mov	bl,[si+1Ah]
 15387                                  	;MOV	bl,[SI+fcb_nsl_bits]
 15388                                  	;;mov	bh,[es:di+5]
 15389                                  	;MOV	bh,[ES:DI+SF_ENTRY.sf_flags]
 15390                                  	;xor	bh,bl
 15391                                  	;and	bh,0C0h
 15392                                  	;jnz	short BadSFT
 15393                                  	;;xor	bl,[es:di+2]
 15394                                  	;xor	bl,[ES:DI+SF_ENTRY.sf_mode]
 15395                                  	;and	bl,0Fh
 15396                                  	;jnz	short BadSFT
 15397                                  	;push	di
 15398                                  	;push	si
 15399                                  	;;lea	di,[di+20h]  ; MSDOS 3.3
 15400                                  	;LEA	DI,[DI+SF_ENTRY.sf_name]
 15401                                  	;;lea	si,[si+1]
 15402                                  	;LEA	SI,[SI+SYS_FCB.name]
 15403                                  	;;mov	cx,11
 15404                                  	;MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
 15405                                  	;repe	cmpsb
 15406                                  	;pop	si
 15407                                  	;pop	di
 15408                                  	;jnz	short BadSFT
 15409                                  	;;mov	bx,[si+1Bh]
 15410                                  	;MOV	bX,[SI+fcb_nsl_firclus]
 15411                                  	;jmp	short CheckFirClus
 15412                                  
 15413                                  	; MSDOS 6.0
 15414                                  
 15415                                  	; SR;
 15416                                  	; The code below to match a local FCB with its SFT can no longer be
 15417                                  	; used. We just return a no-match status. This check is done right
 15418                                  	; at the top.
 15419                                  
 15420                                  CheckNoShareDev:
 15421                                  	;mov	bx,[si+1Ah]
 15422 000021B4 8B5C1A                  	MOV	BX,[SI+fcb_nsld_drvptr]
 15423                                  	;cmp	bx,[es:di+7]
 15424 000021B7 263B5D07                	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr]
 15425 000021BB 75EB                    	JNZ	short BadSFT
 15426                                  	;mov	bx,[si+1Ch]
 15427 000021BD 8B5C1C                  	MOV	BX,[SI+fcb_nsld_drvptr+2]
 15428                                  	;cmp	bx,[es:di+9]
 15429 000021C0 263B5D09                	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr+2]
 15430 000021C4 75E2                    	JNZ	short BadSFT
 15431 000021C6 EBD3                    	JMP	short CheckD
 15432                                  
 15433                                  ;Break	<SFTFromFCB - take a FCB and obtain a SFT from it>
 15434                                  ;----------------------------------------------------------------------------
 15435                                  ;
 15436                                  ;   SFTFromFCB - the workhorse of this compatability crap. Check to see if
 15437                                  ;	the SFT for the FCB is Good. If so, make ThisSFT point to it. If not
 15438                                  ;	good, get one from the cache and regenerate it. Overlay the LRU field
 15439                                  ;	with PID
 15440                                  ;
 15441                                  ;   Inputs:	DS:SI point to FCB
 15442                                  ;   Outputs:	ThisSFT point to appropriate SFT
 15443                                  ;		Carry clear -> OK ES:DI -> SFT
 15444                                  ;		Carry set -> error in ax
 15445                                  ;   Registers modified: ES,DI, AX
 15446                                  ;
 15447                                  ;----------------------------------------------------------------------------
 15448                                  
 15449                                  SFTFromFCB:
 15450                                  	; called from fcbio and $fcb_close. SS already set up to DOSDATA
 15451                                  
 15452                                  	; 17/05/2019 - Retro DOS v4.0
 15453                                  
 15454 000021C8 50                      	push	ax
 15455 000021C9 53                      	push	bx
 15456                                  	;mov	al,[si+18h]
 15457 000021CA 8A4418                  	MOV	AL,[SI+fcb_sfn] 	; set SFN for check
 15458 000021CD E88BFF                  	call	CheckFCB
 15459 000021D0 5B                      	pop	bx
 15460 000021D1 58                      	pop	ax
 15461                                  	;MOV	[CS:THISSFT],DI		; SS override
 15462                                  	;MOV	[CS:THISSFT+2],ES
 15463 000021D2 36893E[9E05]            	MOV	[SS:THISSFT],DI		; SS override
 15464 000021D7 368C06[A005]            	MOV	[SS:THISSFT+2],ES
 15465 000021DC 7311                    	JNC	short Set_SFT		; no problems, just set thissft
 15466                                  	
 15467                                  	; 09/11/2022 (MSDOS 5.0)
 15468                                  	; 31/05/2019
 15469 000021DE 06                      	push	es ; * (MSDOS 6.21) & (MSDOS 5.0)
 15470 000021DF E876E2                  	call	save_world
 15471 000021E2 E859FE                  	call	FCBRegen
 15472 000021E5 E859E2                  	call	restore_world		; use macro restore world
 15473 000021E8 07                      	pop	es ; * (MSDOS 6.21) ; 31/05/2019 ; 09/11/2022 (MSDOS 5.0)	
 15474                                  
 15475                                  	;MOV	AX,[CS:EXTERR]		; SS override
 15476 000021E9 36A1[2403]              	MOV	AX,[SS:EXTERR]		; SS override
 15477 000021ED 72C4                    	jc	short CheckNet_retn
 15478                                  
 15479                                  Set_SFT: 
 15480                                  	;LES	DI,[CS:THISSFT]		; SS override for THISSFT & PROC_ID
 15481 000021EF 36C43E[9E05]            	les	di,[ss:THISSFT]
 15482                                  	;PUSH	word [CS:PROC_ID]	; set process id
 15483 000021F4 36FF36[3C03]            	push	word [ss:PROC_ID]
 15484                                  	;pop	word [es:di+31h]
 15485 000021F9 268F4531                	POP     word [ES:DI+SF_ENTRY.sf_PID]
 15486 000021FD C3                      	retn				; carry is clear
 15487                                  
 15488                                  ;Break	<FCBHardErr - generate INT 24 for hard errors on FCBS>
 15489                                  ;----------------------------------------------------------------------------
 15490                                  ;
 15491                                  ;   FCBHardErr - signal to a user app that he is trying to use an
 15492                                  ;	unavailable FCB.
 15493                                  ;
 15494                                  ;   Inputs:	none.
 15495                                  ;   Outputs:	none.
 15496                                  ;   Registers modified: all
 15497                                  ;
 15498                                  ;----------------------------------------------------------------------------
 15499                                  
 15500                                  	; 21/01/2024 - Retro DOS v5.0
 15501                                  FCBHardErr:
 15502                                  	; 17/05/2019 - Retro DOS v4.0
 15503 000021FE 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 15504                                  	;
 15505                                  	;mov	ax,23h
 15506 00002203 B82300                  	MOV	AX,error_FCB_unavailable
 15507                                  	;;mov	byte [cs:ALLOWED],8
 15508                                  	;MOV	byte [CS:ALLOWED],Allowed_FAIL
 15509 00002206 26C606[4B03]08          	mov	byte [es:ALLOWED],Allowed_FAIL	
 15510                                  	
 15511                                  	;LES	BP,[CS:THISDPB]
 15512 0000220C 26C42E[8A05]            	les	bp,[es:THISDPB]
 15513                                  	
 15514 00002211 BF0100                  	MOV	DI,1			; Fake some registers
 15515 00002214 89F9                    	MOV	CX,DI
 15516                                  	;;;
 15517                                  	; 21/01/2024 (PCDOS 7.1 IBMDOS.COM) 
 15518 00002216 31D2                    	xor	dx,dx ; 0
 15519                                  	;cmp	[es:bp+0Fh],dx
 15520 00002218 2639560F                	cmp	[es:bp+DPB.FAT_SIZE],dx ; 0
 15521 0000221C 740B                    	jz	short fcbharderr_fat32 ; FAT32
 15522 0000221E 268916[0706]            	mov	[es:HIGH_SECTOR],dx ; 0
 15523                                  	;mov	dx,[es:bp+0Bh]
 15524 00002223 268B560B                	mov	dx,[es:bp+DPB.FIRST_SECTOR]
 15525 00002227 EB0D                    	jmp	short fcbharderr_fat
 15526                                  fcbharderr_fat32:
 15527                                  	;mov	dx,[es:bp+2Bh]
 15528 00002229 268B562B                	mov	dx,[es:bp+DPB.FCLUS_FSECTOR+2]
 15529 0000222D 268916[0706]            	mov	[es:HIGH_SECTOR],dx
 15530                                  	;mov	dx,[es:bp+29h]
 15531 00002232 268B5629                	mov	dx,[es:bp+DPB.FCLUS_FSECTOR]
 15532                                  fcbharderr_fat: 
 15533                                  	;;;
 15534                                  	; 21/01/2024
 15535                                  	;;mov	dx,[es:bp+0Bh]
 15536                                  	;MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
 15537                                  	
 15538 00002236 E8AA3A                  	call	HARDERR
 15539 00002239 F9                      	STC
 15540 0000223A C3                      	retn
 15541                                  
 15542                                  ;============================================================================
 15543                                  ; FCBIO2.ASM, MSDOS 6.0, 1991
 15544                                  ;============================================================================
 15545                                  ; 21/07/2018 - Retro DOS v3.0
 15546                                  ; 17/05/2019 - Retro DOS v4.0
 15547                                  
 15548                                  ;**	FCBIO2.ASM - Ancient 1.0 1.1 FCB system calls
 15549                                  ;
 15550                                  ;	GetRR
 15551                                  ;	GetExtent
 15552                                  ;	SetExtent
 15553                                  ;	GetExtended
 15554                                  ;	GetRecSize
 15555                                  ;	FCBIO
 15556                                  ;	$FCB_OPEN
 15557                                  ;	$FCB_CREATE
 15558                                  ;	$FCB_RANDOM_WRITE_BLOCK
 15559                                  ;	$FCB_RANDOM_READ_BLOCK
 15560                                  ;	$FCB_SEQ_READ
 15561                                  ;	$FCB_SEQ_WRITE
 15562                                  ;	$FCB_RANDOM_READ
 15563                                  ;	$FCB_RANDOM_WRITE
 15564                                  ;
 15565                                  ;	Revision history:
 15566                                  ;
 15567                                  ;		Created: ARR 4 April 1983
 15568                                  ;			 MZ  6 June  1983 completion of functions
 15569                                  ;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
 15570                                  ;				  times.  Change so successive closes work by
 15571                                  ;				  always returning OK.	Also, detect I/O to
 15572                                  ;				  already closed FCB and return EOF.
 15573                                  ;		 MZ 16 Jan   1984 More braindamage.  Need to separate info
 15574                                  ;				  out of sft into FCB for reconnection
 15575                                  ;
 15576                                  ;	    A000   version 4.00	Jan. 1988
 15577                                  
 15578                                  ; Defintions for FCBOp flags
 15579                                  
 15580                                  RANDOM	equ 2				; random operation
 15581                                  FCBREAD equ 4				; doing a read
 15582                                  BLOCK	equ 8				; doing a block I/O
 15583                                  
 15584                                  ;Break <GetRR - return the random record field in DX:AX>
 15585                                  ;---------------------------------------------------------------------------
 15586                                  ;
 15587                                  ;   GetRR - correctly load DX:AX with the random record field (3 or 4 bytes)
 15588                                  ;	from the FCB pointed to by DS:SI
 15589                                  ;
 15590                                  ;   Inputs:	DS:SI point to an FCB
 15591                                  ;		BX has record size
 15592                                  ;   Outputs:	DX:AX contain the contents of the random record field
 15593                                  ;   Registers modified: none
 15594                                  ;---------------------------------------------------------------------------
 15595                                  
 15596                                  GetRR:
 15597                                  	;mov	ax,[si+21h]
 15598 0000223B 8B4421                  	MOV	AX,[SI+SYS_FCB.RR]	; get low order part
 15599                                  	;mov	dx,[si+23h]
 15600 0000223E 8B5423                  	MOV	DX,[SI+SYS_FCB.RR+2]	; get high order part
 15601 00002241 83FB40                  	CMP	BX,64			; ignore MSB of RR if recsiz > 64
 15602 00002244 7202                    	JB	short GetRRBye
 15603                                  GetExtent_bye:	; 21/01/2024
 15604 00002246 30F6                    	XOR	DH,DH
 15605                                  GetRRBye:
 15606 00002248 C3                      	retn
 15607                                  
 15608                                  ;Break <GetExtent - retrieve next location for sequential IO>
 15609                                  ;---------------------------------------------------------------------------
 15610                                  ;
 15611                                  ;   GetExtent - Construct the next record to perform I/O from the EXTENT and
 15612                                  ;	NR fields in the FCB.
 15613                                  ;
 15614                                  ;   Inputs:	DS:SI - point to FCB
 15615                                  ;   Outputs:	DX:AX contain the contents of the random record field
 15616                                  ;   Registers modified: none
 15617                                  ;---------------------------------------------------------------------------
 15618                                  
 15619                                  GetExtent:
 15620                                  	;mov	al,[si+20h]
 15621 00002249 8A4420                  	MOV	AL,[SI+SYS_FCB.NR]	; get low order piece
 15622                                  	;mov	dx,[si+0Ch]
 15623 0000224C 8B540C                  	MOV	DX,[SI+SYS_FCB.EXTENT]	; get high order piece
 15624 0000224F D0E0                    	SHL	AL,1
 15625 00002251 D1EA                    	SHR	DX,1
 15626 00002253 D0D8                    	RCR	AL,1	; move low order bit of DL to high order of AH
 15627 00002255 88D4                    	MOV	AH,DL
 15628 00002257 88F2                    	MOV	DL,DH
 15629                                  	; 21/01/2024 (PCDOS 7.1 IBMDOS.COM)
 15630                                  	;XOR	DH,DH
 15631                                  	;retn
 15632 00002259 EBEB                    	jmp	short GetExtent_bye
 15633                                  
 15634                                  ;Break <SetExtent - update the extent/NR field>
 15635                                  ;---------------------------------------------------------------------------
 15636                                  ;
 15637                                  ;   SetExtent - change the position of an FCB by filling in the extent/NR
 15638                                  ;	fields
 15639                                  ;
 15640                                  ;   Inputs:	DS:SI point to FCB
 15641                                  ;		DX:AX is a record location in file
 15642                                  ;   Outputs:	Extent/NR fields are filled in
 15643                                  ;   Registers modified: CX
 15644                                  ;---------------------------------------------------------------------------
 15645                                  
 15646                                  SetExtent:
 15647 0000225B 50                      	push	ax
 15648 0000225C 52                      	push	dx
 15649 0000225D 89C1                    	MOV	CX,AX
 15650 0000225F 247F                    	AND	AL,7FH			; next rec field
 15651                                  	;mov	[si+20h],al
 15652 00002261 884420                  	MOV	[SI+SYS_FCB.NR],AL
 15653 00002264 80E180                  	AND	CL,80H			; save upper bit
 15654 00002267 D1E1                    	SHL	CX,1
 15655 00002269 D1D2                    	RCL	DX,1			; move high bit of CX to low bit of DX
 15656 0000226B 88E8                    	MOV	AL,CH
 15657 0000226D 88D4                    	MOV	AH,DL
 15658                                  	;mov	[si+0Ch], ax
 15659 0000226F 89440C                  	MOV	[SI+SYS_FCB.EXTENT],AX	; all done
 15660 00002272 5A                      	pop	dx
 15661 00002273 58                      	pop	ax
 15662 00002274 C3                      	retn
 15663                                  
 15664                                  ;Break <GetExtended - find FCB in potential extended fcb>
 15665                                  ;---------------------------------------------------------------------------
 15666                                  ;
 15667                                  ;   GetExtended - Make DS:SI point to FCB from DS:DX
 15668                                  ;
 15669                                  ;   Inputs:	DS:DX point to a possible extended FCB
 15670                                  ;   Outputs:	DS:SI point to the FCB part
 15671                                  ;		zeroflag set if not extended fcb
 15672                                  ;   Registers modified: SI
 15673                                  ;---------------------------------------------------------------------------
 15674                                  
 15675                                  GetExtended:
 15676 00002275 89D6                    	MOV	SI,DX			; point to Something
 15677 00002277 803CFF                  	CMP	BYTE [SI],-1		; look for extention
 15678 0000227A 7503                    	JNZ	short GetBye		; not there
 15679 0000227C 83C607                  	ADD	SI,7			; point to FCB
 15680                                  GetBye:
 15681 0000227F 39D6                    	CMP	SI,DX			; set condition codes
 15682                                  getextd_retn:
 15683 00002281 C3                      	retn
 15684                                  
 15685                                  ;Break <GetRecSize - return in BX the FCB record size>
 15686                                  ;---------------------------------------------------------------------------
 15687                                  ;
 15688                                  ;   GetRecSize - return in BX the record size from the FCB at DS:SI
 15689                                  ;
 15690                                  ;   Inputs:	DS:SI point to a non-extended FCB
 15691                                  ;   Outputs:	BX contains the record size
 15692                                  ;   Registers modified: None
 15693                                  ;---------------------------------------------------------------------------
 15694                                  
 15695                                  	; 22/01/2024
 15696                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15697                                  GetRecSize:
 15698                                  	;mov	bx,[si+0Eh]
 15699 00002282 8B5C0E                  	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
 15700 00002285 09DB                    	OR	BX,BX			; is it nul?
 15701                                  	;jz	short getextd_retn
 15702                                  	; 22/01/2024 (BugFix)
 15703 00002287 75F8                    	jnz	short getextd_retn
 15704                                  	;MOV	BX,128			; use default size
 15705 00002289 B380                    	mov	bl,128	; (PCDOS 7.1 IBMDOS.COM)
 15706                                  	;mov	[si+0Eh],bx
 15707 0000228B 895C0E                  	MOV	[SI+SYS_FCB.RECSIZ],BX	; stuff it back
 15708 0000228E C3                      	retn
 15709                                  
 15710                                  ; 23/01/2024 - Retro DOS v5.0
 15711                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:61B3h
 15712                                  
 15713                                  ; 22/07/2018 - Retro DOS v3.0
 15714                                  
 15715                                  ;BREAK <$FCB_Random_write_Block - write a block of records to a file >
 15716                                  ;----------------------------------------------------------------------------
 15717                                  ;
 15718                                  ;   $FCB_Random_Write_Block - retrieve a location from the FCB, seek to it
 15719                                  ;	and write a number of blocks from it.
 15720                                  ;
 15721                                  ;   Inputs:	DS:DX point to an FCB
 15722                                  ;   Outputs:	AL = 0 write was successful and the FCB position is updated
 15723                                  ;		AL <> 0 Not enough room on disk for the output
 15724                                  ;
 15725                                  ;----------------------------------------------------------------------------
 15726                                  
 15727                                  _$FCB_RANDOM_WRITE_BLOCK:
 15728                                  	;mov	AL,0Ah	
 15729 0000228F B00A                    	MOV	AL,RANDOM+BLOCK
 15730 00002291 EB12                    	JMP	short FCBIO	; 23/01/2024
 15731                                  
 15732                                  ;BREAK <$FCB_Random_Read_Block - read a block of records to a file >
 15733                                  ;----------------------------------------------------------------------------
 15734                                  ;
 15735                                  ;   $FCB_Random_Read_Block - retrieve a location from the FCB, seek to it
 15736                                  ;	and read a number of blocks from it.
 15737                                  ;
 15738                                  ;   Inputs:	DS:DX point to an FCB
 15739                                  ;   Outputs:	AL = error codes defined above
 15740                                  ;
 15741                                  ;----------------------------------------------------------------------------
 15742                                  
 15743                                  _$FCB_RANDOM_READ_BLOCK:
 15744                                  	;mov	AL,0Eh	
 15745 00002293 B00E                    	MOV	AL,RANDOM+FCBREAD+BLOCK
 15746 00002295 EB0E                    	JMP	short FCBIO	; 23/01/2024
 15747                                  
 15748                                  ;BREAK <$FCB_Seq_Read - read the next record from a file >
 15749                                  ;----------------------------------------------------------------------------
 15750                                  ;
 15751                                  ;   $FCB_Seq_Read - retrieve the next record from an FCB and read it into
 15752                                  ;	memory
 15753                                  ;
 15754                                  ;   Inputs:	DS:DX point to an FCB
 15755                                  ;   Outputs:	AL = error codes defined above
 15756                                  ;
 15757                                  ;----------------------------------------------------------------------------
 15758                                  
 15759                                  _$FCB_SEQ_READ:
 15760                                  	;mov	AL,4	
 15761 00002297 B004                    	MOV	AL,FCBREAD
 15762 00002299 EB0A                    	JMP	short FCBIO	; 23/01/2024
 15763                                  
 15764                                  ;BREAK <$FCB_Seq_Write - write the next record to a file >
 15765                                  ;----------------------------------------------------------------------------
 15766                                  ;
 15767                                  ;   $FCB_Seq_Write - retrieve the next record from an FCB and write it to the
 15768                                  ;	file
 15769                                  ;
 15770                                  ;   Inputs:	DS:DX point to an FCB
 15771                                  ;   Outputs:	AL = error codes defined above
 15772                                  ;
 15773                                  ;----------------------------------------------------------------------------
 15774                                  
 15775                                  _$FCB_SEQ_WRITE:
 15776 0000229B B000                    	MOV	AL,0
 15777 0000229D EB06                    	JMP	short FCBIO	; 23/01/2024
 15778                                  
 15779                                  ;BREAK <$FCB_Random_Read - Read a single record from a file >
 15780                                  ;----------------------------------------------------------------------------
 15781                                  ;
 15782                                  ;   $FCB_Random_Read - retrieve a location from the FCB, seek to it and read a
 15783                                  ;	record from it.
 15784                                  ;
 15785                                  ;   Inputs:	DS:DX point to an FCB
 15786                                  ;   Outputs:	AL = error codes defined above
 15787                                  ;
 15788                                  ;----------------------------------------------------------------------------
 15789                                  
 15790                                  _$FCB_RANDOM_READ:
 15791                                  	;mov	AL,6	
 15792 0000229F B006                    	MOV	AL,RANDOM+FCBREAD
 15793                                  	; 23/01/2024
 15794                                  	;jmp	FCBIO 		; single block
 15795 000022A1 EB02                    	jmp	short FCBIO
 15796                                  
 15797                                  ;BREAK <$FCB_Random_Write - write a single record to a file >
 15798                                  ;----------------------------------------------------------------------------
 15799                                  ;
 15800                                  ;   $FCB_Random_Write - retrieve a location from the FCB, seek to it and write
 15801                                  ;	a record to it.
 15802                                  ;
 15803                                  ;   Inputs:	DS:DX point to an FCB
 15804                                  ;   Outputs:	AL = error codes defined above
 15805                                  ;
 15806                                  ;----------------------------------------------------------------------------
 15807                                  
 15808                                  _$FCB_RANDOM_WRITE:
 15809                                  	;mov	AL,2	
 15810 000022A3 B002                    	MOV	AL,RANDOM
 15811                                  	; 23/01/2024
 15812                                  	;;jmp	FCBIO
 15813                                  	;jmp	short FCBIO
 15814                                  
 15815                                  ;BREAK <FCBIO - do internal FCB I/O>
 15816                                  ;---------------------------------------------------------------------------
 15817                                  ;
 15818                                  ;   FCBIO - look at FCBOP and merge all FCB operations into a single routine.
 15819                                  ;
 15820                                  ;   Inputs:	FCBOP flags which operations need to be performed
 15821                                  ;		DS:DX point to FCB
 15822                                  ;		CX may have count of number of records to xfer
 15823                                  ;   Outputs:	AL has error code
 15824                                  ;   Registers modified: all
 15825                                  ;---------------------------------------------------------------------------
 15826                                  
 15827                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15828                                  	; DOSCODE:5B17h (MSDOS 5.0 MSDOS.SYS)
 15829                                  
 15830                                  	; 23/01/2024
 15831                                  	; DOSCODE:5B2Bh (MSDOS 6.22 MSDOS.SYS)
 15832                                  
 15833                                  	; 23/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 15834                                  	; DOSCODE:61C9h (PCDOS 7.1 IBMDOS.COM)
 15835                                  
 15836                                  FCBIO:
 15837                                  
 15838                                  FEOF	EQU	1
 15839                                  FTRIM	EQU	2
 15840                                  
 15841                                  %define	FCBErr	byte [bp-1]  ; byte	
 15842                                  %define	cRec	word [bp-3]  ; word	
 15843                                  ;%define RecPos	word [bp-7]  ; dword
 15844                                  %define RecPosL	word [bp-7]  ; word
 15845                                  %define RecPosH	word [bp-5]  ; word
 15846                                  %define	RecSize	word [bp-9]  ; word
 15847                                  ;%define bPos	word [bp-13] ; dword
 15848                                  %define bPosL	word [bp-13] ; word
 15849                                  %define bPosH	word [bp-11] ; word
 15850                                  %define cByte	word [bp-15] ; word	
 15851                                  %define cResult word [bp-17] ; word	
 15852                                  %define	cRecRes	word [bp-19] ; word
 15853                                  %define	FCBOp	byte [bp-20] ; byte
 15854                                  ; 23/01/2024
 15855                                  %define bPos bp-13
 15856                                  
 15857                                  	;Enter
 15858                                  
 15859 000022A5 55                      	push	bp
 15860 000022A6 89E5                    	mov	bp,sp
 15861 000022A8 83EC14                  	sub	sp,20
 15862                                  	;mov	[bp-20],al
 15863 000022AB 8846EC                  	MOV	FCBOp,AL
 15864                                  	;mov	byte [bp-1],0
 15865 000022AE C646FF00                	MOV	FCBErr,0		;   FCBErr = 0;
 15866 000022B2 E8C0FF                  	call	GetExtended		;   FCB = GetExtended ();
 15867                                  	;test	byte [bp-20],8
 15868 000022B5 F646EC08                	TEST	FCBOp,BLOCK		;   if ((OP&BLOCK) == 0)
 15869 000022B9 7503                    	JNZ	short GetPos
 15870 000022BB B90100                  	MOV	CX,1			;	cRec = 1;
 15871                                  GetPos:
 15872                                  	;mov	[bp-3],cx
 15873 000022BE 894EFD                  	MOV	cRec,CX 		;*Tail coalesce
 15874 000022C1 E885FF                  	call	GetExtent		;   RecPos = GetExtent ();
 15875 000022C4 E8BBFF                  	call	GetRecSize		;   RecSize = GetRecSize ();
 15876                                  	;mov	[bp-9],bx
 15877 000022C7 895EF7                  	MOV	RecSize,BX
 15878                                  	;test	byte [bp-20],2
 15879 000022CA F646EC02                	TEST	FCBOp,RANDOM		;   if ((OP&RANDOM) <> 0)
 15880 000022CE 7403                    	JZ	short GetRec
 15881 000022D0 E868FF                  	call	GetRR			;	RecPos = GetRR ();
 15882                                  GetRec:
 15883                                  	;mov	[bp-7],ax
 15884 000022D3 8946F9                  	MOV	RecPosL,AX		;*Tail coalesce
 15885                                  	;mov	[bp-5],dx
 15886 000022D6 8956FB                  	MOV	RecPosH,DX
 15887 000022D9 E87FFF                  	call	SetExtent		;   SetExtent (RecPos);
 15888                                  	;mov	ax,[bp-5]
 15889 000022DC 8B46FB                  	MOV	AX,RecPosH		;   bPos = RecPos * RecSize;
 15890 000022DF F7E3                    	MUL	BX
 15891 000022E1 89C7                    	MOV	DI,AX
 15892                                  	;mov	ax,[bp-7]
 15893 000022E3 8B46F9                  	MOV	AX,RecPosL
 15894 000022E6 F7E3                    	MUL	BX
 15895 000022E8 01FA                    	ADD	DX,DI
 15896                                  	;mov	[bp-13],ax
 15897 000022EA 8946F3                  	MOV	bPosL,AX
 15898                                  	;mov	[bp-11],dx
 15899 000022ED 8956F5                  	MOV	bPosH,DX
 15900                                  	;mov	ax,[bp-3]
 15901 000022F0 8B46FD                  	MOV	AX,cRec 		;   cByte = cRec * RecSize;
 15902 000022F3 F7E3                    	MUL	BX
 15903                                  	;mov	[bp-15],ax
 15904 000022F5 8946F1                  	MOV	cByte,AX
 15905                                  
 15906                                  ;hkn; 	SS override
 15907 000022F8 360306[2C03]            	ADD	AX,[SS:DMAADD]		;   if (cByte+DMA > 64K) {
 15908 000022FD 83D200                  	ADC	DX,0
 15909 00002300 7419                    	JZ	short DoOper
 15910                                  	;mov	byte [bp-1],2
 15911 00002302 C646FF02                	MOV	FCBErr,FTRIM		;	FCBErr = FTRIM;
 15912                                  
 15913                                  ;hkn; 	SS override
 15914 00002306 36A1[2C03]              	MOV	AX,[SS:DMAADD]		;	cRec = (64K-DMA)/RecSize;
 15915 0000230A F7D8                    	NEG	AX
 15916 0000230C 7501                    	JNZ	short DoDiv
 15917 0000230E 48                      	DEC	AX
 15918                                  DoDiv:
 15919 0000230F 31D2                    	XOR	DX,DX
 15920 00002311 F7F3                    	DIV	BX
 15921                                  	;mov	[bp-3],ax
 15922 00002313 8946FD                  	MOV	cRec,AX
 15923 00002316 F7E3                    	MUL	BX			;	cByte = cRec * RecSize;
 15924                                  	;mov	[bp-15],ax
 15925 00002318 8946F1                  	MOV	cByte,AX		;	}
 15926                                  DoOper:
 15927 0000231B 31DB                    	XOR	BX,BX
 15928                                  	;mov	[bp-17],bx
 15929 0000231D 895EEF                  	MOV	cResult,BX		;   cResult = 0;
 15930                                  	;cmp	[bp-15],bx
 15931 00002320 395EF1                  	CMP	cByte,BX		;   if (cByte <> 0 ||
 15932 00002323 7506                    	JNZ	short DoGetExt
 15933                                  	;test	byte [bp-1],2
 15934 00002325 F646FF02                	TEST	FCBErr,FTRIM		;	(FCBErr&FTRIM) == 0) {
 15935                                  	;JZ	short DoGetExt
 15936                                  	;JMP	short SkipOp
 15937                                  	; 16/12/2022
 15938 00002329 756E                    	jnz	short SkipOp
 15939                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15940                                  	;JZ	short DoGetExt
 15941                                  	;JMP	short SkipOp
 15942                                  DoGetExt:
 15943 0000232B E89AFE                  	call	SFTFromFCB		;	if (!SFTFromFCB (SFT,FCB))
 15944 0000232E 730F                    	JNC	short ContinueOp
 15945                                  FCBDeath:
 15946 00002330 E85CE3                  	call	FCB_RET_ERR		; signal error, map for extended
 15947                                  	;mov	word [bp-19],0
 15948 00002333 C746ED0000              	MOV	cRecRes,0		; no bytes transferred
 15949                                  	;mov	byte [bp-1],1
 15950 00002338 C646FF01                	MOV	FCBErr,FEOF		;	    return FTRIM;
 15951 0000233C E9E700                  	JMP	FCBSave 		; bam!
 15952                                  ContinueOp:
 15953                                  	; 23/01/2024
 15954                                  	; (PCDOS 7.1 IBMDOS.COM)
 15955                                  	;
 15956                                  	;;mov	ax,[si+10h]
 15957                                  	;MOV	AX,[SI+SYS_FCB.FILSIZ]
 15958                                  	;;mov	[es:di+11h],ax
 15959                                  	;MOV	[ES:DI+SF_ENTRY.sf_size],AX
 15960                                  	;;mov	ax,[si+12h]
 15961                                  	;MOV	AX,[SI+SYS_FCB.FILSIZ+2]
 15962                                  	;;mov	[es:di+13h],ax
 15963                                  	;MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 15964                                  	;;;
 15965 0000233F 1E                      	push	ds
 15966 00002340 C54410                  	lds	ax,[si+SYS_FCB.FILSIZ]
 15967 00002343 26894511                	mov	[es:di+SF_ENTRY.sf_size],ax
 15968 00002347 268C5D13                	mov	[es:di+SF_ENTRY.sf_size+2],ds
 15969 0000234B C546F3                  	lds	ax,[bPos] ; lds ax,[bp-13]
 15970 0000234E 8CDA                    	mov	dx,ds
 15971 00002350 1F                      	pop	ds
 15972                                  	;;;
 15973                                  	;;mov	ax,[bp-13]
 15974                                  	;MOV	AX,bPosL
 15975                                  	;;mov	dx,[bp-11]
 15976                                  	;MOV	DX,bPosH
 15977                                  	
 15978                                  	;mov	[es:di+15h],ax
 15979 00002351 26894515                	MOV	[ES:DI+SF_ENTRY.sf_position],AX
 15980                                  	;xchg	dx,[es:di+17h]
 15981 00002355 26875517                	XCHG	[ES:DI+SF_ENTRY.sf_position+2],DX
 15982 00002359 52                      	PUSH	DX			; save away Open age.
 15983                                  	;mov	cx,[bp-15]
 15984 0000235A 8B4EF1                  	MOV	CX,cByte		;	cResult =
 15985                                  
 15986                                  ;hkn; DOS_Read is in DOSCODE
 15987 0000235D BF[783B]                	MOV	DI,DOS_READ		;	    *(OP&FCBRead ? DOS_Read
 15988                                  	;test	byte [bp-20],4
 15989 00002360 F646EC04                	TEST	FCBOp,FCBREAD		;		 : DOS_Write)(cRec);
 15990 00002364 7503                    	JNZ	short DoContext
 15991                                  
 15992                                  ;hkn; DOS_Write is in DOSCODE
 15993 00002366 BF[A13D]                	MOV	DI,DOS_WRITE
 15994                                  DoContext:
 15995 00002369 55                      	push	bp
 15996 0000236A 1E                      	push	ds
 15997 0000236B 56                      	push	si
 15998                                  
 15999                                  ;hkn; SS is DOSDATA
 16000 0000236C 16                      	push	ss
 16001 0000236D 1F                      	pop	ds
 16002                                  
 16003                                  ;; Fix for disk full
 16004 0000236E FFD7                    	CALL	DI	; DOS_READ or DOS_WRITE	
 16005                                  	
 16006 00002370 5E                      	pop	si
 16007 00002371 1F                      	pop	ds
 16008 00002372 5D                      	pop	bp
 16009 00002373 72BB                    	JC	short FCBDeath
 16010                                  	
 16011 00002375 36803E[0B06]00          	CMP	BYTE [SS:DISK_FULL],0	; treat disk full as error
 16012 0000237B 7406                    	JZ	short NODSKFULL
 16013 0000237D 36C606[0B06]00          	MOV	BYTE [SS:DISK_FULL],0	; clear the flag
 16014                                  
 16015                                  	; 23/01/2024
 16016                                  	; (PCDOS 7.1 IBMDOS.COM)
 16017                                  	;;mov	byte [bp-1],1 
 16018                                  	;MOV	FCBErr,FEOF		; set disk full flag
 16019                                  
 16020                                  NODSKFULL:
 16021                                  ;; Fix for disk full
 16022                                  	;mov	[bp-17],cx
 16023 00002383 894EEF                  	MOV	cResult,CX
 16024 00002386 E8FBFA                  	call	SaveFCBInfo		;	SaveFCBInfo (FCB);
 16025                                  	;pop	word [es:di+17h]	
 16026 00002389 268F4517                	POP	WORD [ES:DI+SF_ENTRY.sf_position+2] ; restore open age
 16027                                  			       ; (sf_OpenAge = SF_ENTRY.sf_position+2)
 16028                                  
 16029                                  	; 23/01/2024
 16030                                  	; (PCDOS 7.1 IBMDOS.COM)
 16031                                  	;
 16032                                  	;;mov	ax,[es:di+11h]
 16033                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_size]
 16034                                  	;;mov	[si+10h],ax
 16035                                  	;MOV	[SI+SYS_FCB.FILSIZ],AX
 16036                                  	;;mov	ax,[es:di+13h]
 16037                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
 16038                                  	;;mov	[si+12h],ax
 16039                                  	;MOV	[SI+SYS_FCB.FILSIZ+2],AX
 16040                                  	;;;
 16041 0000238D 06                      	push	es
 16042 0000238E 26C44511                	les	ax,[es:di+SF_ENTRY.sf_size]
 16043 00002392 894410                  	mov	[si+SYS_FCB.FILSIZ],ax
 16044 00002395 8C4412                  	mov	[si+SYS_FCB.FILSIZ+2],es
 16045 00002398 07                      	pop	es
 16046                                  	;;;
 16047                                  					;	}
 16048                                  SkipOp:
 16049                                  	;mov	ax,[bp-17]
 16050 00002399 8B46EF                  	MOV	AX,cResult		;   cRecRes = cResult / RecSize;
 16051 0000239C 31D2                    	XOR	DX,DX
 16052                                  	;div	word [bp-9]
 16053 0000239E F776F7                  	DIV	RecSize
 16054                                  	;mov	[bp-19],ax
 16055 000023A1 8946ED                  	MOV	cRecRes,AX
 16056                                  	;add	[bp-7],ax
 16057 000023A4 0146F9                  	ADD	RecPosL,AX		;   RecPos += cRecResult;
 16058                                  	;adc	word [bp-5],0
 16059 000023A7 8356FB00                	ADC	RecPosH,0
 16060                                  
 16061                                  ; If we have not gotten the expected number of records, we signal an EOF
 16062                                  ; condition. On input, this is EOF. On output this is usually disk full.
 16063                                  ; BUT... Under 2.0 and before, all device output IGNORED this condition. So
 16064                                  ; do we.
 16065                                  
 16066                                  	;cmp	ax,[bp-3]
 16067 000023AB 3B46FD                  	CMP	AX,cRec 		;   if (cRecRes <> cRec)
 16068 000023AE 7411                    	JZ	short TryBlank
 16069                                  	;test	byte [bp-20],4
 16070 000023B0 F646EC04                	TEST	FCBOp,FCBREAD		;	if (OP&FCBRead || !DEVICE)
 16071 000023B4 7507                    	JNZ	short SetEOF
 16072                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16073                                  	; MSDOS 3.3
 16074                                  	;;test	word [es:di+5],80h
 16075                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 16076                                  	;JNZ	short TryBlank
 16077                                  	; MSDOS 5.0 & MSDOS 6.0
 16078                                  	;test	byte [es:di+5],80h
 16079 000023B6 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 16080 000023BB 7504                    	jnz	short TryBlank
 16081                                  
 16082                                  SetEOF:
 16083                                  	;mov	byte [bp-1],1
 16084 000023BD C646FF01                	MOV	FCBErr,FEOF		;	FCBErr = FEOF;
 16085                                  TryBlank:				;
 16086 000023C1 09D2                    	OR	DX,DX			;   if (cResult%RecSize <> 0) {
 16087 000023C3 7426                    	JZ	short SetExt
 16088                                  	;add	word [bp-7],1
 16089 000023C5 8346F901                	ADD	RecPosL,1		;	RecPos++;
 16090                                  	;adc	word [bp-5],0
 16091 000023C9 8356FB00                	ADC	RecPosH,0
 16092                                  	;test	byte [bp-20],4
 16093 000023CD F646EC04                	TEST	FCBOp,FCBREAD		;	if(OP&FCBRead) <> 0) {
 16094 000023D1 7418                    	JZ	short SetExt
 16095                                  	;inc	word [bp-19]
 16096 000023D3 FF46ED                  	INC	cRecRes 		;	cRecRes++;
 16097                                  	;mov	byte [bp-1],3
 16098 000023D6 C646FF03                	MOV	FCBErr,FTRIM+FEOF	;	FCBErr = FTRIM | FEOF;
 16099                                  	;mov	cx,[bp-9]
 16100 000023DA 8B4EF7                  	MOV	CX,RecSize		;	Blank (RecSize-cResult%RecSize,
 16101 000023DD 29D1                    	SUB	CX,DX			;	       DMA+cResult);
 16102 000023DF 30C0                    	XOR	AL,AL
 16103                                  ;hkn; 	SS override
 16104 000023E1 36C43E[2C03]            	les     di,[ss:DMAADD]
 16105                                  	;add	di,[bp-17]
 16106 000023E6 037EEF                  	ADD	DI,cResult
 16107 000023E9 F3AA                    	REP	STOSB			;   }	}
 16108                                  SetExt:
 16109                                  	;mov	dx,[bp-5]
 16110 000023EB 8B56FB                  	MOV	DX,RecPosH
 16111                                  	;mov	ax,[bp-7]
 16112 000023EE 8B46F9                  	MOV	AX,RecPosL
 16113                                  	;test	byte [bp-20],2
 16114 000023F1 F646EC02                	TEST	FCBOp,RANDOM		;   if ((OP&Random) == 0 ||
 16115 000023F5 7406                    	JZ	short DoSetExt
 16116                                  	;test	byte [bp-20],8
 16117 000023F7 F646EC08                	TEST	FCBOp,BLOCK		;	(OP&BLOCK) <> 0)
 16118 000023FB 7403                    	JZ	short TrySetRR
 16119                                  DoSetExt:
 16120 000023FD E85BFE                  	call	SetExtent		;	SetExtent (RecPos, FCB);
 16121                                  TrySetRR:
 16122                                  	;test	byte [bp-20],8
 16123 00002400 F646EC08                	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
 16124 00002404 740F                    	JZ	short TryReturn
 16125                                  	;mov	[si+21h],ax
 16126 00002406 894421                  	MOV	[SI+SYS_FCB.RR],AX	;	FCB->RR = RecPos;
 16127                                  	;mov	[si+23h],dl
 16128 00002409 885423                  	MOV	[SI+SYS_FCB.RR+2],DL
 16129                                  	;cmp	word [si+0Eh],64
 16130 0000240C 837C0E40                	CMP	word [SI+SYS_FCB.RECSIZ],64
 16131 00002410 7303                    	JAE	short TryReturn
 16132                                  	;mov	[si+24h],dh
 16133 00002412 887424                  	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
 16134                                  TryReturn: 
 16135                                  	;test	byte [bp-20],4
 16136 00002415 F646EC04                	TEST	FCBOp,FCBREAD		;   if (!(FCBOP & FCBREAD)) {
 16137 00002419 750B                    	JNZ	short FCBSave
 16138 0000241B 1E                      	push	ds			;	FCB->FDate = date;
 16139 0000241C E84DE7                  	call	DATE16			;	FCB->FTime = time;
 16140 0000241F 1F                      	pop	ds
 16141                                  	;mov	[si+14h],ax
 16142 00002420 894414                  	MOV	[SI+SYS_FCB.FDATE],AX
 16143                                  	;mov	[si+16h],dx
 16144 00002423 895416                  	MOV	[SI+SYS_FCB.FTIME],DX	;	}
 16145                                  FCBSave: 
 16146                                  	;test	byte [bp-20],8
 16147 00002426 F646EC08                	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
 16148 0000242A 7409                    	jz	short DoReturn
 16149                                  	;mov	cx,[bp-19]
 16150 0000242C 8B4EED                  	MOV	CX,cRecRes		;	user_CX = cRecRes;
 16151 0000242F E845E0                  	call    Get_User_Stack
 16152                                  	;mov	[si+4],cx
 16153 00002432 894C04                  	MOV	[SI+user_env.user_CX],CX
 16154                                  DoReturn:
 16155                                  	;mov	al,[bp-1]
 16156 00002435 8A46FF                  	MOV	AL,FCBErr		;   return (FCBERR);
 16157                                  	;Leave	
 16158 00002438 89EC                    	mov     sp,bp
 16159 0000243A 5D                      	pop     bp
 16160 0000243B C3                      	retn
 16161                                  
 16162                                  ; 22/07/2018 - Retro DOS v3.0
 16163                                  
 16164                                  ;Break <$FCB_Open - open an old-style FCB>
 16165                                  ;---------------------------------------------------------------------------
 16166                                  ;
 16167                                  ;   $FCB_Open - CPM compatability file open. The user has formatted an FCB
 16168                                  ;	for us and asked to have the rest filled in.
 16169                                  ;
 16170                                  ;   Inputs:	DS:DX point to an unopenned FCB
 16171                                  ;   Outputs:	AL indicates status 0 is ok FF is error
 16172                                  ;		FCB has the following fields filled in:
 16173                                  ;		    Time/Date Extent/NR Size
 16174                                  ;---------------------------------------------------------------------------
 16175                                  
 16176                                  	; 23/01/2024 - Retro DOS v5.0
 16177                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:6362h
 16178                                  
 16179                                  _$FCB_OPEN:			; System call 15
 16180                                  	
 16181                                  	;mov	ax,2 
 16182 0000243C B80200                  	MOV	AX,SHARING_COMPAT+open_for_both
 16183                                  
 16184                                  ;hkn; DOS_Open is in DOSCODE
 16185 0000243F B9[2032]                	MOV	CX,DOS_OPEN
 16186                                  
 16187                                  ; The following is common code for Creation and openning of FCBs. AX is
 16188                                  ; either attributes (for create) or open mode (for open)... DS:DX points to
 16189                                  ; the FCB
 16190                                  
 16191                                  DoAccess:
 16192 00002442 1E                      	push	ds
 16193 00002443 52                      	push	dx
 16194 00002444 51                      	push	cx
 16195 00002445 50                      	push	ax			; save FCB pointer away
 16196                                  
 16197                                  ;hkn; 	OpenBuf is in DOSDATA
 16198 00002446 BF[BE03]                	MOV	DI,OPENBUF
 16199 00002449 E8D950                  	call	TransFCB		; crunch the fcb
 16200 0000244C 58                      	pop	ax
 16201 0000244D 59                      	pop	cx
 16202 0000244E 5A                      	pop	dx
 16203 0000244F 1F                      	pop	ds			; get fcb
 16204 00002450 7303                    	JNC	short FindFCB		; everything seems ok
 16205                                  FCBOpenErr:
 16206                                  	; AL has error code
 16207 00002452 E93AE2                  	jmp	FCB_RET_ERR
 16208                                  FindFCB:
 16209 00002455 E81DFE                  	call	GetExtended		; DS:SI will point to FCB
 16210                                  
 16211                                  	; 17/05/2019 - Retro DOS v4.0
 16212                                  
 16213                                  	; MSDOS 3.3
 16214                                  	;call	LRUFCB
 16215                                  	;jc	short HardMessage
 16216                                  
 16217                                  	; MSDOS 6.0
 16218 00002458 50                      	push	ax
 16219 00002459 B001                    	mov	al,1			;indicate Open/Create operation
 16220 0000245B E8F4FA                  	call	LRUFCB			; get a sft entry (no error)
 16221 0000245E 58                      	pop	ax
 16222 0000245F 722A                    	jc	short HardMessage
 16223                                  	
 16224                                  	;mov	word [es:di+2],8000h
 16225 00002461 26C745020080            	mov	word [es:di+SF_ENTRY.sf_mode],sf_isFCB
 16226 00002467 1E                      	push	ds
 16227 00002468 56                      	push	si	
 16228 00002469 53                      	push	bx			; save fcb pointer
 16229 0000246A 89CE                    	MOV	SI,CX
 16230                                  
 16231                                  ;hkn; SS is DOSDATA
 16232 0000246C 16                      	push	ss
 16233 0000246D 1F                      	pop	ds			    ; let DOS_Open see variables
 16234 0000246E FFD6                    	CALL	SI ; DOS_OPEN or DOS_CREATE ; go open the file
 16235 00002470 5B                      	pop	bx
 16236 00002471 5E                      	pop	si
 16237 00002472 1F                      	pop	ds			; get fcb
 16238                                  
 16239                                  ;hkn; SS override
 16240 00002473 36C43E[9E05]            	LES	DI,[SS:THISSFT]		; get sf pointer
 16241 00002478 7318                    	JNC	short FCBOK		; operation succeeded
 16242                                  failopen:
 16243 0000247A 50                      	PUSH	AX
 16244 0000247B B052                    	MOV	AL,"R"	; 52h		; clear out field (free sft)
 16245 0000247D E8C2FC                  	call	BlastSFT
 16246 00002480 58                      	POP	AX
 16247                                  	;cmp	ax,4
 16248 00002481 83F804                  	CMP	AX,error_too_many_open_files
 16249 00002484 7405                    	JZ	short HardMessage
 16250                                  	;cmp	ax,24h
 16251 00002486 83F824                  	CMP	AX,error_sharing_buffer_exceeded
 16252 00002489 7505                    	jnz	short DeadFCB
 16253                                  HardMessage:
 16254 0000248B 50                      	PUSH	AX
 16255 0000248C E86FFD                  	call	FCBHardErr
 16256 0000248F 58                      	POP	AX
 16257                                  DeadFCB:
 16258                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16259                                  	;jmp	FCB_RET_ERR
 16260 00002490 EBC0                    	jmp	short FCBOpenErr
 16261                                  FCBOK:
 16262                                  	; MSDOS 6.0
 16263 00002492 E8C5F3                  	call	IsSFTNet		;AN007;F.C. >32mb  Non Fat file?
 16264 00002495 7531                    	JNZ	short FCBOK2		;AN007;F.C. >32mb  yes
 16265 00002497 E8B758                  	call	CheckShare		;AN000;F.C. >32mb  share around?
 16266                                  	;JNZ	short FCBOK2		;AN000;F.C. >32mb  yes
 16267                                  	; 23/01/2024 - Retro DOS v5.0
 16268                                  	; (PCDOS 7.1 IBMDOS.COM)
 16269 0000249A 750A                    	jnz	short FCBOK1
 16270                                  
 16271                                  ;SR;
 16272                                  ; If we reach here, we know we have got a local SFT. Let's update the 
 16273                                  ; LocalSFT variable to reflect this.
 16274                                  
 16275 0000249C 36893E[A710]            	mov	[ss:LocalSFT],di
 16276 000024A1 368C06[A910]            	mov	[ss:LocalSFT+2],es; Store the SFT address
 16277                                  ;;SR;
 16278                                  ;; The check below is not valid anymore since we regenerate for media > 32M.
 16279                                  ;;
 16280                                  ;;	CMP	WORD [ES:DI+SF_ENTRY.sf_dirsec+2],0 
 16281                                  ;;					       ;AN000;F.C. >32mb  if dirsec >32mb
 16282                                  ;;	JZ	short FCBOK2		       ;AN000;F.C. >32mb    then error
 16283                                  ;;	MOV	AX,error_sys_comp_not_loaded   ;AN000;F.C. >32mb
 16284                                  ;;	JMP	short failopen		       ;AN000;F.C. >32mb
 16285                                  
 16286                                  	; 23/01/2024 - Retro DOS v5.0
 16287                                  	; (PCDOS 7.1 IBMDOS.COM)
 16288                                  	;;;
 16289                                  FCBOK1:
 16290                                  	;test	byte [es:di+5],80h
 16291 000024A6 26F6450580              	test	byte [es:di+SF_ENTRY.sf_flags],devid_device
 16292 000024AB 751B                    	jnz	short FCBOK2	; local device
 16293                                  	;test	byte [es:di+4],8
 16294 000024AD 26F6450408              	test	byte [es:di+SF_ENTRY.sf_attr],attr_volume_id
 16295 000024B2 7514                    	jnz	short FCBOK2
 16296                                  		; local file
 16297 000024B4 06                      	push	es
 16298 000024B5 57                      	push	di
 16299                                  	;les	di,[es:di+0Fh]
 16300 000024B6 26C47D07                	les	di,[es:di+SF_ENTRY.sf_devptr] ; local file's DPB
 16301                                  	;cmp	word [es:di+0Fh],0
 16302 000024BA 26837D0F00              	cmp	word [es:di+DPB.FAT_SIZE],0 ; (16 bit FAT size)	
 16303 000024BF 5F                      	pop	di
 16304 000024C0 07                      	pop	es
 16305 000024C1 7505                    	jnz	short FCBOK2	; not FAT32 (ok)
 16306                                  	;mov	ax,0Fh		; error_invalid_drive (for FAT32)
 16307 000024C3 B80F00                  	mov	ax,error_invalid_drive
 16308 000024C6 EBB2                    	jmp	short failopen
 16309                                  	;;; 
 16310                                  
 16311                                  FCBOK2:
 16312                                  	; MSDOS 6.0 (& MSDOS 3.3)
 16313 000024C8 26FF05                  	inc	word [es:di]
 16314                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count] ; increment reference count
 16315                                  
 16316                                  	; 23/01/2024 - Retro DOS v5.0
 16317                                  	; (PCDOS 7.1 IBMDOS.COM)
 16318                                  	;;;
 16319 000024CB E8DC23                  	call	set_sftfcb_entry
 16320                                  	;;;
 16321                                  
 16322 000024CE E8B3F9                  	call	SaveFCBInfo
 16323                                  
 16324                                  	; MSDOS 3.3
 16325                                  	;call	SetOpenAge
 16326                                  	; MSDOS 6.0 (& MSDOS 3.3)
 16327                                  	;test	word [es:di+5],80h
 16328                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 16329 000024D1 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device  ; 28/07/2019
 16330 000024D6 7508                    	JNZ	short FCBNoDrive	; do not munge drive on devices
 16331                                  
 16332 000024D8 8A04                    	MOV	AL,[SI]			; get drive byte
 16333 000024DA E8D34F                  	call	GETTHISDRV		; convert
 16334                                  	;INC	AL
 16335                                  	; 17/12/2022
 16336 000024DD 40                      	inc	ax
 16337 000024DE 8804                    	MOV	[SI],AL			; stash in good drive letter
 16338                                  
 16339                                  FCBNoDrive:
 16340                                  	;mov	word [si+0Eh],128
 16341 000024E0 C7440E8000              	MOV	word [SI+SYS_FCB.RECSIZ],80h ; stuff in default record size
 16342                                  
 16343                                  	; 23/01/2024 - Retro DOS v5.0
 16344                                  	; (PCDOS 7.1 IBMDOS.COM)
 16345                                  	;;;
 16346                                  	;;mov	ax,[es:di+0Dh]
 16347                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_time] ; set time
 16348                                  	;;mov	[si+16h],ax
 16349                                  	;MOV	[SI+SYS_FCB.FTIME],AX
 16350                                  	;;mov	ax,[es:di+0Fh]
 16351                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_date] ; set date
 16352                                  	;;mov	[si+14h],ax
 16353                                  	;MOV	[SI+SYS_FCB.FDATE],AX
 16354                                  	;;mov	ax,[es:di+11h]
 16355                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_size] ; set sizes
 16356                                  	;;mov	[si+10h],ax
 16357                                  	;MOV	[SI+SYS_FCB.FILSIZ],AX
 16358                                  	;;mov	ax,[es:di+13h]
 16359                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
 16360                                  	;;mov	[si+12h],ax
 16361                                  	;MOV	[SI+SYS_FCB.FILSIZ+2],AX
 16362                                  	;
 16363 000024E5 06                      	push	es
 16364                                  	;les	ax,[es:di+0Dh]
 16365 000024E6 26C4450D                	les	ax,[es:di+SF_ENTRY.sf_time]
 16366                                  	;mov	[si+16h],ax
 16367 000024EA 894416                  	mov	[si+SYS_FCB.FTIME],ax	; set time
 16368                                  	;mov	[si+14h],es
 16369 000024ED 8C4414                  	mov	[si+SYS_FCB.FDATE],es	; set date
 16370 000024F0 07                      	pop	es
 16371 000024F1 06                      	push	es
 16372                                  	;les	ax,[es:di+11h]
 16373 000024F2 26C44511                	les	ax,[es:di+SF_ENTRY.sf_size] ; set size
 16374                                  	;mov	[si+10h],ax
 16375 000024F6 894410                  	mov	[si+SYS_FCB.FILSIZ],ax
 16376                                  	;mov	[si+12h],ax
 16377 000024F9 8C4412                  	mov	[si+SYS_FCB.FILSIZ+2],es
 16378 000024FC 07                      	pop	es
 16379                                  	;;;
 16380                                  	
 16381 000024FD 31C0                    	XOR	AX,AX			; convenient zero
 16382                                  	;mov	[si+0Ch],ax
 16383 000024FF 89440C                  	MOV	[SI+SYS_FCB.EXTENT],AX	; point to beginning of file
 16384                                  
 16385                                  ; We must scan the set of FCB SFTs for one that appears to match the current
 16386                                  ; one.	We cheat and use CheckFCB to match the FCBs.
 16387                                  
 16388                                  ;hkn; 	SS override
 16389 00002502 36C43E[4000]            	LES	DI,[SS:SFTFCB]		; get the pointer to head of the list
 16390                                  	;mov	ah,[es:di+4]
 16391 00002507 268A6504                	MOV	AH,[ES:DI+SFT.SFCount]	; get number of SFTs to scan
 16392                                  OpenScan:
 16393                                  	;cmp	al,[si+18h]
 16394 0000250B 3A4418                  	CMP	AL,[SI+fcb_sfn]		; don't compare ourselves
 16395 0000250E 7407                    	JZ	short SkipCheck
 16396 00002510 50                      	push	ax			; preserve count
 16397 00002511 E847FC                  	call	CheckFCB		; do they match
 16398 00002514 58                      	pop	ax			; get count back
 16399 00002515 7309                    	JNC	short OpenFound		; found a match!
 16400                                  SkipCheck:
 16401 00002517 FEC0                    	INC	AL			; advance to next FCB
 16402 00002519 38E0                    	CMP	AL,AH			; table full?
 16403 0000251B 75EE                    	JNZ	short OpenScan		; no, go for more
 16404                                  OpenDone:
 16405 0000251D 30C0                    	xor	al,al			; return success
 16406 0000251F C3                      	retn
 16407                                  
 16408                                  ; The SFT at ES:DI is the one that is already in use for this FCB. We set the
 16409                                  ; FCB to use this one. We increment its ref count. We do NOT close it at all.
 16410                                  ; Consider:
 16411                                  ;
 16412                                  ;   open (foo)	delete (foo) open (bar)
 16413                                  ;
 16414                                  ; This causes us to recycle (potentially) bar through the same local SFT as
 16415                                  ; foo even though foo is no longer needed; this is due to the server closing
 16416                                  ; foo for us when we delete it. Unfortunately, we cannot see this closure.
 16417                                  ; If we were to CLOSE bar, the server would then close the only reference to
 16418                                  ; bar and subsequent I/O would be lost to the redirector.
 16419                                  ;
 16420                                  ; This gets solved by NOT closing the sft, but zeroing the ref count
 16421                                  ; (effectively freeing the SFT) and informing the sharer (if relevant) that
 16422                                  ; the SFT is no longer in use. Note that the SHARER MUST keep its ref counts
 16423                                  ; around. This will allow us to access the same file through multiple network
 16424                                  ; connections and NOT prematurely terminate when the ref count on one
 16425                                  ; connection goes to zero.
 16426                                  
 16427                                  OpenFound:
 16428                                  	;mov	[si+18h],al
 16429 00002520 884418                  	MOV	[SI+fcb_sfn],AL 	; assign with this
 16430 00002523 26FF05                  	inc	word [es:di]
 16431                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 16432                                  					; remember this new invocation
 16433                                  	; 23/01/2024 - Retro DOS v5.0
 16434                                  	; (PCDOS 7.1 IBMDOS.COM)
 16435                                  	;;;
 16436 00002526 E88123                  	call	set_sftfcb_entry
 16437                                  	;;;
 16438                                  
 16439                                  	; 24/01/2024
 16440 00002529 16                      	push	ss
 16441 0000252A 1F                      	pop	ds
 16442                                  	
 16443                                  	;MOV	AX,[SS:FCBLRU]		; update LRU counts
 16444 0000252B A1[1000]                	mov	ax,[FCBLRU] ; 24/01/2024
 16445                                  	;mov	[es:di+15h],ax
 16446 0000252E 26894515                	MOV	[ES:DI+sf_LRU],AX
 16447                                  ;
 16448                                  ; We have an FCB sft that is now of no use. We release sharing info and then
 16449                                  ; blast it to prevent other reuse.
 16450                                  ;
 16451                                  	;push	ss
 16452                                  	;pop	ds
 16453                                  	
 16454 00002532 C43E[9E05]              	LES	DI,[THISSFT]
 16455 00002536 26FF0D                  	dec	word [es:di]
 16456                                  	;DEC	word [ES:DI+SF_ENTRY.sf_ref_count]
 16457                                  					; free the newly allocated SFT
 16458 00002539 E84D58                  	call	ShareEnd
 16459 0000253C B043                    	MOV	AL,'C'	 ; 43h
 16460 0000253E E801FC                  	call	BlastSFT
 16461 00002541 EBDA                    	JMP	short OpenDone
 16462                                  
 16463                                  ;BREAK	<$FCB_Create - create a new directory entry>
 16464                                  ;----------------------------------------------------------------------------
 16465                                  ;
 16466                                  ;   $FCB_Create - CPM compatability file create. The user has formatted an
 16467                                  ;	FCB for us and asked to have the rest filled in.
 16468                                  ;
 16469                                  ;   Inputs:	DS:DX point to an unopenned FCB
 16470                                  ;   Outputs:	AL indicates status 0 is ok FF is error
 16471                                  ;		FCB has the following fields filled in:
 16472                                  ;		    Time/Date Extent/NR Size
 16473                                  ;----------------------------------------------------------------------------
 16474                                  
 16475                                  _$FCB_CREATE:		; System call 22
 16476                                  
 16477                                  ;hkn; DOS_Create is in DOSCODE
 16478 00002543 B9[EF30]                	MOV	CX,DOS_CREATE		; routine to call
 16479 00002546 31C0                    	XOR	AX,AX			; attributes to create
 16480 00002548 E82AFD                  	call	GetExtended		; get extended FCB
 16481 0000254B 7403                    	JZ	short DoAccessJ		; not an extended FCB
 16482 0000254D 8A44FF                  	MOV	AL,[SI-1]		; get attributes
 16483                                  DoAccessJ:
 16484 00002550 E9EFFE                  	JMP	DoAccess		; do dirty work
 16485                                  
 16486                                  ;============================================================================
 16487                                  ; SEARCH.ASM, MSDOS 6.0, 1991
 16488                                  ;============================================================================
 16489                                  ; 22/07/2018 - Retro DOS v3.0
 16490                                  ; 17/05/2019 - Retro DOS v4.0
 16491                                  
 16492                                  ; DOSCODE:5DDFh (MSDOS 6.21, MSDOS.SYS)
 16493                                  
 16494                                  ; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16495                                  ; DOSCODE:5DCBh (MSDOS 5.0, MSDOS.SYS)
 16496                                  
 16497                                  ;**	Search.asm
 16498                                  ;----------------------------------------------------------------------------
 16499                                  ;	Directory search system calls.
 16500                                  ;	These will be passed direct text of the pathname from the user. 
 16501                                  ;	They will need to be passed through the macro expander prior to
 16502                                  ;	being sent through the low-level stuff. 
 16503                                  ;	I/O specs are defined in DISPATCH. The system calls are:
 16504                                  ;
 16505                                  ;	$Dir_Search_First	  written
 16506                                  ;	$Dir_Search_Next	  written
 16507                                  ;	$Find_First	  written
 16508                                  ;	$Find_Next		  written
 16509                                  ;	PackName		  written
 16510                                  ;
 16511                                  ;	Modification history:
 16512                                  ;
 16513                                  ;	  Created: ARR 4 April 1983
 16514                                  
 16515                                  ;----------------------------------------------------------------------------
 16516                                  ; Procedure Name : $DIR_SEARCH_FIRST
 16517                                  ;
 16518                                  ; Inputs:
 16519                                  ;	DS:DX Points to unopenned FCB
 16520                                  ; Function:
 16521                                  ;	Directory is searched for first matching entry and the directory
 16522                                  ;	entry is loaded at the disk transfer address
 16523                                  ; Returns:
 16524                                  ;	AL = -1 if no entries matched, otherwise 0
 16525                                  ;----------------------------------------------------------------------------
 16526                                  
 16527                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 2B88h
 16528                                  	
 16529                                  	; 24/01/2024
 16530                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:5DCBh
 16531                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:5DDFh
 16532                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:647Bh
 16533                                  	; Windows ME IO.SYS - BIOSCODE:61E5h
 16534                                  
 16535                                  _$DIR_SEARCH_FIRST:
 16536 00002553 368916[A605]            	MOV	[SS:THISFCB],DX
 16537 00002558 368C1E[A805]            	MOV	[SS:THISFCB+2],DS
 16538 0000255D 89D6                    	MOV	SI,DX
 16539 0000255F 803CFF                  	CMP	BYTE [SI],0FFH
 16540 00002562 7503                    	JNZ	short NORMFCB4
 16541 00002564 83C607                  	ADD	SI,7			; Point to drive select byte
 16542                                  NORMFCB4:
 16543 00002567 FF34                    	push	word [SI]		; Save original drive byte for later
 16544                                  
 16545 00002569 16                      	push	ss
 16546 0000256A 07                      	pop	es			; get es to address DOSGroup
 16547                                  
 16548 0000256B BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 16549 0000256E E8B44F                  	call	TransFCB		; convert the FCB, set SATTRIB EXTFCB
 16550 00002571 7304                    	JNC	short SearchIt		; no error, go and look
 16551 00002573 5B                      	pop	bx			; Clean stack
 16552                                  
 16553                                  ; Error code is in AX
 16554                                  
 16555                                  	; 09/11/2022
 16556                                  dcf_errj:
 16557 00002574 E918E1                  	jmp	FCB_RET_ERR		; error
 16558                                  
 16559                                  SearchIt:
 16560 00002577 16                      	push	ss
 16561 00002578 1F                      	pop	ds			; get ready for search
 16562                                  	;push	word [DMAADD]
 16563                                  	;push	word [DMAADD+2]
 16564                                  	; 24/01/2024
 16565 00002579 C43E[2C03]              	les	di,[DMAADD]
 16566 0000257D 57                      	push	di
 16567 0000257E 06                      	push	es
 16568 0000257F C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 16569 00002585 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 16570                                  	; MSDOS 3.3
 16571                                  	;call	DOS_SEARCH_FIRST
 16572                                  	; MSDOS 6.0
 16573 00002589 E8B70F                  	call	GET_FAST_SEARCH		; search
 16574 0000258C 8F06[2E03]              	pop	word [DMAADD+2]
 16575 00002590 8F06[2C03]              	pop	word [DMAADD]
 16576 00002594 735A                    	JNC	short SearchSet		; no error, transfer info
 16577 00002596 5B                      	pop	bx			; Clean stack
 16578                                  
 16579                                  ; Error code is in AX
 16580                                  
 16581                                  	; 09/11/2022
 16582                                  	;jmp	FCB_RET_ERR
 16583 00002597 EBDB                    	jmp	short dcf_errj
 16584                                  
 16585                                  ;----------------------------------------------------------------------------
 16586                                  ;
 16587                                  ; Procedure Name : $DIR_SEARCH_NEXT
 16588                                  ;
 16589                                  ; Inputs:
 16590                                  ;	DS:DX points to unopenned FCB returned by $DIR_SEARCH_FIRST
 16591                                  ; Function:
 16592                                  ;	Directory is searched for the next matching entry and the directory
 16593                                  ;	entry is loaded at the disk transfer address
 16594                                  ; Returns:
 16595                                  ;	AL = -1 if no entries matched, otherwise 0
 16596                                  ;----------------------------------------------------------------------------
 16597                                  
 16598                                  	; 24/01/2024
 16599                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:5E5Fh
 16600                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:5E73h
 16601                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:6517h
 16602                                  	; Windows ME IO.SYS - BIOSCODE:6273h
 16603                                  
 16604                                  _$DIR_SEARCH_NEXT:
 16605 00002599 368916[A605]            	MOV	[SS:THISFCB],DX
 16606 0000259E 368C1E[A805]            	MOV	[SS:THISFCB+2],DS
 16607                                  	; 24/01/2024 (PCDOS 7.1)
 16608                                  	;MOV	byte [SS:SATTRIB],0
 16609                                  	;MOV	byte [SS:EXTFCB],0
 16610 000025A3 B000                    	mov	al,0
 16611 000025A5 36A2[6D05]              	mov	[SS:SATTRIB],al ; 0
 16612 000025A9 36A2[6D05]              	mov	[SS:SATTRIB],al ; 0
 16613                                  
 16614 000025AD 16                      	push	ss
 16615 000025AE 07                      	pop	es
 16616                                  
 16617 000025AF BF[BE04]                	MOV	DI,SEARCHBUF
 16618                                  
 16619 000025B2 89D6                    	MOV	SI,DX
 16620 000025B4 803CFF                  	CMP	BYTE [SI],0FFh
 16621 000025B7 750D                    	JNZ	short NORMFCB6
 16622 000025B9 83C606                  	ADD	SI,6
 16623 000025BC AC                      	LODSB
 16624                                  
 16625 000025BD 36A2[6D05]              	MOV	[SS:SATTRIB],AL
 16626 000025C1 36FE0E[6C05]            	DEC	byte [SS:EXTFCB]
 16627                                  NORMFCB6:
 16628 000025C6 AC                      	LODSB				; Get original user drive byte
 16629 000025C7 50                      	push	ax			; Put it on stack
 16630 000025C8 8A4414                  	MOV	AL,[SI+20]		; Get correct search contin drive byte
 16631 000025CB AA                      	STOSB				; Put in correct place
 16632 000025CC B90A00                  	MOV	CX,20/2
 16633 000025CF F3A5                    	REP	MOVSW			; Transfer in rest of search contin info
 16634                                  
 16635 000025D1 16                      	push	ss
 16636 000025D2 1F                      	pop	ds
 16637                                  
 16638                                  	;push	word [DMAADD]
 16639                                  	;push	word [DMAADD+2]
 16640                                  	; 24/01/2024
 16641 000025D3 C43E[2C03]              	les	di,[DMAADD]
 16642 000025D7 57                      	push	di
 16643 000025D8 06                      	push	es
 16644 000025D9 C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 16645 000025DF 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 16646 000025E3 E85D10                  	call	DOS_SEARCH_NEXT 	; Find it
 16647 000025E6 8F06[2E03]              	pop	word [DMAADD+2]
 16648 000025EA 8F06[2C03]              	pop	word [DMAADD]
 16649 000025EE 724A                    	JC	short SearchNoMore
 16650                                  	; 24/01/2024
 16651                                  	;JMP	SearchSet		; Ok set return
 16652                                  
 16653                                  ;;;	; 24/01/2024 - Retro DOS v5.0
 16654                                  
 16655                                  ; The search was successful (or the search-next). We store the information
 16656                                  ; into the user's FCB for continuation.
 16657                                  
 16658                                  SearchSet:
 16659 000025F0 BE[BE04]                	MOV	SI,SEARCHBUF
 16660 000025F3 C43E[A605]              	LES	DI,[THISFCB]		; point to the FCB
 16661 000025F7 F606[6C05]FF            	TEST	byte [EXTFCB],0FFh
 16662 000025FC 7403                    	JZ	short NORMFCB1
 16663 000025FE 83C707                  	ADD	DI,7			; Point past the extension
 16664                                  NORMFCB1:
 16665 00002601 5B                      	pop	bx			; Get original drive byte
 16666 00002602 08DB                    	OR	BL,BL
 16667 00002604 7506                    	JNZ	short SearchDrv
 16668 00002606 8A1E[3603]              	MOV	BL,[CURDRV]
 16669 0000260A FEC3                    	INC	BL
 16670                                  SearchDrv:
 16671 0000260C AC                      	LODSB				; Get correct search contin drive byte
 16672 0000260D 86C3                    	XCHG	AL,BL			; Search byte to BL, user byte to AL
 16673 0000260F 47                      	INC	DI
 16674                                  	;STOSB				; Store the correct "user" drive byte
 16675                                  					;  at the start of the search info
 16676 00002610 B90A00                  	MOV	CX,20/2
 16677 00002613 F3A5                    	REP	MOVSW			; Rest of search cont info, SI -> entry
 16678 00002615 86C3                    	XCHG	AL,BL			; User drive byte back to BL, search
 16679                                  					;   byte to AL
 16680 00002617 AA                      	STOSB				; Search contin drive byte at end of
 16681                                  					;   contin info
 16682 00002618 C43E[2C03]              	LES	DI,[DMAADD]
 16683 0000261C F606[6C05]FF            	TEST	byte [EXTFCB],0FFh
 16684 00002621 740D                    	JZ	short NORMFCB2
 16685 00002623 B0FF                    	MOV	AL,0FFh
 16686 00002625 AA                      	STOSB
 16687 00002626 FEC0                    	INC	AL
 16688                                  	;MOV	CX,5
 16689                                  	; 17/12/2022
 16690 00002628 B105                    	mov	cl,5
 16691 0000262A F3AA                    	REP	STOSB
 16692 0000262C A0[6D05]                	MOV	AL,[SATTRIB]
 16693 0000262F AA                      	STOSB
 16694                                  NORMFCB2:
 16695 00002630 88D8                    	MOV	AL,BL			; User Drive byte
 16696 00002632 AA                      	STOSB
 16697                                  	;MOV	CX,16			; 32 / 2 words of dir entry
 16698                                  	; 17/12/2022
 16699 00002633 B110                    	mov	cl,16
 16700 00002635 F3A5                    	REP	MOVSW
 16701 00002637 E952E0                  	jmp	FCB_RET_OK
 16702                                  ;;;
 16703                                  
 16704                                  SearchNoMore:
 16705 0000263A C43E[A605]              	LES	DI,[THISFCB]
 16706 0000263E F606[6C05]FF            	TEST	byte [EXTFCB],0FFh
 16707 00002643 7403                    	JZ	short NORMFCB8
 16708 00002645 83C707                  	ADD	DI,7			; Point past the extension
 16709                                  NORMFCB8:
 16710 00002648 5B                      	pop	bx			; Get original drive byte
 16711 00002649 26881D                  	MOV	[ES:DI],BL		; Store the correct "user" drive byte
 16712                                  					;  at the right spot
 16713                                  ; error code is in AX
 16714                                  
 16715 0000264C E940E0                  	jmp	FCB_RET_ERR
 16716                                  
 16717                                  ; 17/05/2019 - Retro DOS v4.0
 16718                                  
 16719                                  ; DOSCODE:5EE6h (MSDOS 6.21, MSDOS.SYS)
 16720                                  
 16721                                  ;---------------------------------------------------------------------------
 16722                                  ;
 16723                                  ;   Procedure Name : $FIND_FIRST
 16724                                  ; 
 16725                                  ;   Assembler usage:
 16726                                  ;	    MOV AH, FindFirst
 16727                                  ;	    LDS DX, name
 16728                                  ;	    MOV CX, attr
 16729                                  ;	    INT 21h
 16730                                  ;	; DMA address has datablock
 16731                                  ;
 16732                                  ;   Error Returns:
 16733                                  ;	    AX = error_path_not_found
 16734                                  ;	       = error_no_more_files
 16735                                  ;---------------------------------------------------------------------------
 16736                                  
 16737                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16738                                  	; DOSCODE:5ED2h (MSDOS 5.0, MSDOS.SYS)
 16739                                  
 16740                                  	; 24/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 16741                                  	; DOSCODE:6594h (PCDOS 7.1, IBMDOS.COM)
 16742                                  
 16743                                  _$FIND_FIRST:
 16744 0000264F 89D6                    	MOV	SI,DX			; get name in appropriate place
 16745 00002651 36880E[6D05]            	MOV	[SS:SATTRIB],CL		; Search attribute to correct loc
 16746                                  
 16747 00002656 BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 16748                                  
 16749 00002659 E82F4F                  	call	TransPathSet		; convert the path
 16750 0000265C 7305                    	JNC	short Find_it 		; no error, go and look
 16751                                  FindError:
 16752                                  	;mov	al,3
 16753 0000265E B003                    	mov	al, error_path_not_found ; error and map into one.
 16754                                  	; 09/11/2022
 16755                                  FF_errj:
 16756 00002660 E917E0                  	jmp	SYS_RET_ERR
 16757                                  Find_it:
 16758 00002663 16                      	push	ss
 16759 00002664 1F                      	pop	ds
 16760                                  
 16761                                  	;push	word [DMAADD]
 16762                                  	;push	word [DMAADD+2]
 16763                                  	; 24/01/2024 (PCDOS 7.1 IBMDOS.COM)
 16764 00002665 C43E[2C03]              	les	di,[DMAADD]
 16765 00002669 57                      	push	di
 16766 0000266A 06                      	push	es
 16767                                  	
 16768 0000266B C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 16769 00002671 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 16770                                  	; MSDOS 3.3
 16771                                  	;call	DOS_SEARCH_FIRST
 16772                                  	; MSDOS 6.0
 16773 00002675 E8CB0E                  	call	GET_FAST_SEARCH 	; search
 16774 00002678 8F06[2E03]              	pop	word [DMAADD+2]
 16775 0000267C 8F06[2C03]              	pop	word [DMAADD]
 16776                                  	
 16777                                  	; 16/12/2022
 16778                                  	;JNC	short FindSet 		; no error, transfer info
 16779 00002680 72DE                    	jc	short FF_errj	; jmp SYS_RET_ERR
 16780                                  	;
 16781                                  	;jmp	SYS_RET_ERR
 16782                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16783                                  ;FFF_errj:
 16784                                  	;jmp	short FF_errj	; jmp SYS_RET_ERR
 16785                                  
 16786                                  FindSet:
 16787 00002682 BE[BE04]                	MOV	SI,SEARCHBUF
 16788 00002685 C43E[2C03]              	LES	DI,[DMAADD]
 16789 00002689 B91500                  	MOV	CX,21
 16790 0000268C F3A4                    	REP	MOVSB
 16791 0000268E 56                      	PUSH	SI			; Save pointer to start of entry
 16792                                  	;mov	al,[si+0Bh]
 16793 0000268F 8A440B                  	MOV	AL,[SI+dir_entry.dir_attr]
 16794 00002692 AA                      	STOSB
 16795                                  	;add	si,16h ; 22
 16796 00002693 83C616                  	ADD	SI,dir_entry.dir_time
 16797 00002696 A5                      	MOVSW				; dir_time
 16798 00002697 A5                      	MOVSW				; dir_date
 16799 00002698 46                      	INC	SI
 16800 00002699 46                      	INC	SI			; Skip dir_first
 16801 0000269A A5                      	MOVSW				; dir_size (2 words)
 16802 0000269B A5                      	MOVSW
 16803 0000269C 5E                      	POP	SI			; Point back to dir_name
 16804 0000269D E83300                   	CALL	PackName
 16805 000026A0 E9CDDF                  	jmp	SYS_RET_OK		; bye with no errors
 16806                                  
 16807                                  ;---------------------------------------------------------------------------
 16808                                  ;
 16809                                  ;   Procedure Name : $FIND_NEXT
 16810                                  ;
 16811                                  ;   Assembler usage:
 16812                                  ;	; dma points at area returned by find_first
 16813                                  ;	    MOV AH, findnext
 16814                                  ;	    INT 21h
 16815                                  ;	; next entry is at dma
 16816                                  ;
 16817                                  ;   Error Returns:
 16818                                  ;	    AX = error_no_more_files
 16819                                  ;---------------------------------------------------------------------------
 16820                                  
 16821                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16822                                  
 16823                                  	; 24/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 16824                                  	; DOSCODE:65ECh (PCDOS 7.1, IBMDOS.COM)
 16825                                  
 16826                                  _$FIND_NEXT:
 16827 000026A3 16                      	push	ss
 16828 000026A4 07                      	pop	es
 16829                                  
 16830 000026A5 BF[BE04]                	MOV	DI,SEARCHBUF
 16831                                  
 16832 000026A8 36C536[2C03]            	LDS	SI,[SS:DMAADD]
 16833                                  
 16834 000026AD B91500                  	MOV	CX,21
 16835 000026B0 F3A4                    	REP	MOVSB			; Put the search continuation info
 16836                                  					;  in the right place
 16837 000026B2 16                      	push	ss
 16838 000026B3 1F                      	pop	ds			; get ready for search
 16839                                  	
 16840                                  	; 24/01/2024 (Retro DOS v5-v4)
 16841                                  	;push	word [DMAADD]
 16842                                  	;push	word [DMAADD+2]
 16843 000026B4 C43E[2C03]              	les	di,[DMAADD]
 16844 000026B8 57                      	push	di
 16845 000026B9 06                      	push	es
 16846 000026BA C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 16847 000026C0 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 16848 000026C4 E87C0F                  	call	DOS_SEARCH_NEXT 	; Find it
 16849 000026C7 8F06[2E03]              	pop	word [DMAADD+2]
 16850 000026CB 8F06[2C03]              	pop	word [DMAADD]
 16851 000026CF 73B1                    	JNC	short FindSet 		; No error, set info
 16852                                  	;jmp	SYS_RET_ERR
 16853                                  	; 16/12/2022
 16854 000026D1 EB8D                    	jmp	short FF_errj	; jmp SYS_RET_ERR
 16855                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16856                                  	;jmp	short FFF_errj	; jmp SYS_RET_ERR
 16857                                  
 16858                                  ;---------------------------------------------------------------------------
 16859                                  ;**	PackName - Convert file names from FCB to ASCIZ format.
 16860                                  ;
 16861                                  ;	PackName transfers a file name from DS:SI to ES:DI and converts it to
 16862                                  ;	the ASCIZ format.
 16863                                  ;
 16864                                  ;	ENTRY	(DS:SI) = 11 character FCB or dir entry name
 16865                                  ;		(ES:DI) = destination area (13 bytes)
 16866                                  ;	EXIT	(ds:SI) and (es:DI) advanced
 16867                                  ;	USES	al, CX, SI, DI, Flags  (BUGBUG - not verified - jgl)
 16868                                  ;---------------------------------------------------------------------------
 16869                                  
 16870                                  	; 25/01/2024 - Retro DOS v5.0
 16871                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:6627h
 16872                                  
 16873                                  PackName:
 16874                                  ;	Move over 8 characters to cover the name component, then trim it's
 16875                                  ;	trailing blanks.
 16876                                  
 16877                                  	;MOV	CX,8			; Pack the name
 16878                                  	;REP	MOVSB			; Move all of it
 16879                                  	; 25/01/2024
 16880 000026D3 B90400                  	mov	cx,4
 16881 000026D6 F3A5                    	rep	movsw
 16882                                  main_kill_tail:
 16883 000026D8 26807DFF20              	CMP	BYTE [ES:DI-1]," "
 16884 000026DD 7507                    	JNZ	short find_check_dot
 16885 000026DF 4F                      	DEC	DI			; Back up over trailing space
 16886 000026E0 41                      	INC	CX
 16887 000026E1 83F908                  	CMP	CX,8
 16888 000026E4 72F2                    	JB	short main_kill_tail
 16889                                  find_check_dot:
 16890                                  	;CMP	WORD [SI],(" " << 8) | " "
 16891 000026E6 813C2020                	cmp     word [si],2020h 
 16892 000026EA 7506                    	JNZ	short got_ext 		; Some chars in extension
 16893 000026EC 807C0220                	CMP	BYTE [SI+2]," "
 16894 000026F0 740F                    	JZ	short find_done		; No extension
 16895                                  got_ext:
 16896 000026F2 B02E                    	MOV	AL,"."	; 2Eh
 16897 000026F4 AA                      	STOSB
 16898                                  	;MOV	CX,3
 16899                                  	;; 18/12/2022
 16900                                  	;;mov	cl,3
 16901                                  	;;REP	MOVSB
 16902                                  	;movsb
 16903                                  	;movsb
 16904                                  	;movsb
 16905                                  	; 25/01/2024
 16906 000026F5 A5                      	movsw
 16907 000026F6 A4                      	movsb
 16908                                  ext_kill_tail:
 16909 000026F7 26807DFF20              	CMP	BYTE [ES:DI-1]," "
 16910 000026FC 7503                    	JNZ	short find_done
 16911 000026FE 4F                      	DEC	DI			; Back up over trailing space
 16912 000026FF EBF6                    	JMP	short ext_kill_tail
 16913                                  find_done:
 16914 00002701 31C0                    	XOR	AX,AX
 16915 00002703 AA                      	STOSB				; NUL terminate
 16916 00002704 C3                      	retn
 16917                                  
 16918                                  ;---------------------------------------------------------------------------
 16919                                  
 16920                                  ; 24/01/2024
 16921                                  %if 0
 16922                                  	; 17/05/2019 - Retro DOS v4.0
 16923                                  GET_FAST_SEARCH:
 16924                                  	; 22/07/2018
 16925                                  	; MSDOS 6.0
 16926                                  	; 17/12/2022
 16927                                  	OR	byte [ss:DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)  ; 04h
 16928                                  	;OR	word [ss:DOS34_FLAG],SEARCH_FASTOPEN  ; 400h
 16929                                  					;FO.trigger fastopen ;AN000;
 16930                                  	;call	DOS_SEARCH_FIRST
 16931                                  	;retn
 16932                                  	; 17/12/2022
 16933                                  	jmp	DOS_SEARCH_FIRST
 16934                                  %endif
 16935                                  
 16936                                  ;============================================================================
 16937                                  ; PATH.ASM, MSDOS 6.0, 1991
 16938                                  ;============================================================================
 16939                                  ; 06/08/2018 - Retro DOS v3.0
 16940                                  ; 17/05/2019 - Retro DOS v4.0
 16941                                  
 16942                                  ; DOSCODE:5FB0h (MSDOS 6.21, MSDOS.SYS)
 16943                                  
 16944                                  ;**	Directory related system calls. These will be passed direct text of the
 16945                                  ;	pathname from the user. They will need to be passed through the macro
 16946                                  ;	expander prior to being sent through the low-level stuff. I/O specs are
 16947                                  ;	defined in DISPATCH. The system calls are:
 16948                                  ;
 16949                                  ;	$CURRENT_DIR  Written
 16950                                  ;	$RMDIR	  Written
 16951                                  ;	$CHDIR	  Written
 16952                                  ;	$MKDIR	  Written
 16953                                  ;
 16954                                  ;
 16955                                  ;	Modification history:
 16956                                  ;
 16957                                  ;	    Created: ARR 4 April 1983
 16958                                  ;		 MZ 10 May 1983     CurrentDir implemented
 16959                                  ;		 MZ 11 May 1983     RmDir, ChDir, MkDir implemented
 16960                                  ;		 EE 19 Oct 1983     RmDir no longer allows you to delete a
 16961                                  ;				    current directory.
 16962                                  ;		 MZ 19 Jan 1983     Brain damaged applications rely on success
 16963                                  
 16964                                  ;	I_Need	ThisCDS,DWORD		; pointer to Current CDS
 16965                                  ;	I_Need	WFP_Start,WORD		; pointer to beginning of directory text
 16966                                  ;	I_Need	Curr_Dir_End,WORD	; offset to end of directory part
 16967                                  ;	I_Need	OpenBuf,128		; temp spot for translated name
 16968                                  ;	I_need	fSplice,BYTE		; TRUE => do splice
 16969                                  ;	I_Need	NoSetDir,BYTE		; TRUE => no exact match on splice
 16970                                  ;	I_Need	cMeta,BYTE
 16971                                  ;	I_Need	DrvErr,BYTE					;AN000;
 16972                                  
 16973                                  ;BREAK <$CURRENT_DIR - dump the current directory into user space>
 16974                                  ;----------------------------------------------------------------------------
 16975                                  ;
 16976                                  ;   Procedure Name : $CURRENT_DIR
 16977                                  ;
 16978                                  ;   Assembler usage:
 16979                                  ;		LDS	SI,area
 16980                                  ;		MOV	DL,drive
 16981                                  ;		INT	21h
 16982                                  ;	    ; DS:SI is a pointer to 64 byte area that contains drive
 16983                                  ;	    ; current directory.
 16984                                  ;   Error returns:
 16985                                  ;	    AX = error_invalid_drive
 16986                                  ;
 16987                                  ;----------------------------------------------------------------------------
 16988                                  
 16989                                  	; 06/08/2018 - Retro DOS v3.0
 16990                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 2D4Eh
 16991                                  
 16992                                  	; 25/01/2024 - Retro DOS v5.0
 16993                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:5F9Ch  ; Retro DOS v4.1 (& v4.0)
 16994                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:5FB0h ; Retro DOS v4.2
 16995                                  	; Windows ME IO.SYS - BIOSCODE:6393h
 16996                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:6664h ; Retro DOS v5.0
 16997                                  
 16998                                  _$CURRENT_DIR:
 16999 00002705 E8FBF1                  	call	ECritDisk
 17000 00002708 88D0                    	MOV	AL,DL			; get drive number (0=def, 1=A)
 17001 0000270A E8874D                  	call	GetVisDrv		; grab it
 17002 0000270D 7310                    	JNC	short CurrentValidate 	; no error -> go and validate dir
 17003                                  CurdirErr:
 17004 0000270F E81EF2                  	call	LCritDisk
 17005                                  
 17006                                  	; MSDOS 3.3
 17007                                  	;mov	al,0Fh
 17008                                  	
 17009                                  	; MSDOS 6.0
 17010 00002712 1E                      	push	ds
 17011 00002713 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 17012 00002718 A0[1006]                	mov	al,[DrvErr]		;IFS.			;AN000;
 17013 0000271B 1F                      	pop	ds
 17014                                  
 17015                                  curdir_errj:
 17016 0000271C E95BDF                  	jmp	SYS_RET_ERR		;IFS. make noise	;AN000;
 17017                                  
 17018                                  CurrentValidate:
 17019 0000271F 1E                      	push	ds			; save destination
 17020 00002720 56                      	push	si
 17021                                  	
 17022                                  	;LDS	SI,[CS:THISCDS] ; MSDOS 3.3
 17023                                  	
 17024                                  	; MSDOS 6.0
 17025 00002721 2E8E1E[0700]            	mov     ds,[cs:DosDSeg]
 17026                                  	; 25/01/2024 (PCDOS 7.1 IBMDOS.COM)
 17027 00002726 C606[4C03]00            	mov	byte [NoSetDir],0 ; *
 17028                                  	
 17029                                  	; 25/01/2024
 17030                                  	;lds     si,[THISCDS]
 17031                                  
 17032                                  ; 16/12/2022
 17033                                  %if 0
 17034                                  	; 09/11/2022 (following test instruction is nonsense!)
 17035                                  	; (I am leaving it here for MSDOS 5.0 MSDOS.SYS compatibility)
 17036                                  
 17037                                  	;test	word [si+43h],8000h
 17038                                  	TEST	word [SI+curdir.flags],curdir_isnet
 17039                                  	;jnz	short $+2  ; 09/11/2022	
 17040                                  	jnz	short DoCheck
 17041                                  %endif
 17042                                  
 17043                                  ; Random optimization nuked due to some utilities using GetCurrentDir to do
 17044                                  ; media check.
 17045                                  ;	CMP	word [SI+curdir.ID],0
 17046                                  ;	JZ	short GetDst
 17047                                  DoCheck:
 17048                                  	;MOV	byte [cs:NoSetDir],0	; interested only in contents
 17049                                  
 17050                                  	; 25/01/2024
 17051                                  	; MSDOS 6.0
 17052                                  	;push	ds
 17053                                  	;mov	ds,[cs:DosDSeg]
 17054                                  	;mov	byte [NoSetDir],0 ; *
 17055                                  	;pop	ds
 17056                                  
 17057 0000272B BF[BE03]                	MOV	DI,OPENBUF
 17058 0000272E E80F25                  	call	ValidateCDS		; output is ES:DI -> CDS
 17059                                  
 17060 00002731 06                      	push	es	 		; swap source and destination
 17061 00002732 57                      	push	di
 17062 00002733 5E                      	pop	si
 17063 00002734 1F                      	pop	ds
 17064                                  GetDst:
 17065 00002735 5F                      	pop	di
 17066 00002736 07                      	pop	es			; get real destination
 17067 00002737 72D6                    	JC	short CurdirErr
 17068                                  	;ADD	SI,curdir.text ; add si,0 ; 09/08/2018
 17069                                  	;
 17070                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17071                                  	; DOSCODE:5FE2h (MSDOS 5.0, MSDOS.SYS)
 17072                                  	; 16/12/2022
 17073                                  	;add	si,0  ; add si,curdir.text
 17074                                  	;
 17075                                  	;add	si,[si+4Fh] ; 17/05/2019
 17076 00002739 03744F                  	ADD	SI,[SI+curdir.end]
 17077 0000273C 803C5C                  	CMP	BYTE [SI],'\'	; 5Ch	; root or subdirs present?
 17078 0000273F 7501                    	JNZ	short CurrentCopy
 17079 00002741 46                      	INC	SI
 17080                                  CurrentCopy:
 17081                                  ;	call	FStrCpy
 17082                                  ;; 10/29/86 E5 char
 17083 00002742 50                      	PUSH	AX
 17084 00002743 AC                      	LODSB				; get char
 17085 00002744 08C0                    	OR	AL,AL
 17086 00002746 7413                    	JZ	short FOK
 17087 00002748 3C05                    	CMP	AL,05H
 17088 0000274A 740D                    	JZ	short FCHANGE
 17089 0000274C EB01                    	JMP	short FFF
 17090                                  FCPYNEXT:
 17091 0000274E AC                      	LODSB				; get char
 17092                                  FFF:
 17093 0000274F 3C5C                    	CMP	AL,'\'			; beginning of directory
 17094 00002751 7508                    	JNZ	short FOK		; no
 17095 00002753 AA                      	STOSB				; put into user's buffer
 17096 00002754 AC                      	LODSB				; 1st char of dir is 05?
 17097 00002755 3C05                    	CMP	AL,05H
 17098 00002757 7502                    	JNZ	short FOK		; no
 17099                                  FCHANGE:
 17100 00002759 B0E5                    	MOV	AL,0E5H			; make it E5
 17101                                  FOK:
 17102 0000275B AA                      	STOSB				; put into user's buffer
 17103 0000275C 08C0                    	OR	AL,AL			; final char
 17104 0000275E 75EE                    	JNZ	short FCPYNEXT		; no
 17105 00002760 58                      	POP	AX
 17106                                  
 17107                                  ;; 10/29/86 E5 char
 17108 00002761 30C0                    	xor	AL,AL			; MZ 19 Jan 84
 17109 00002763 E8CAF1                  	call	LCritDisk
 17110 00002766 E907DF                  	jmp	SYS_RET_OK		; no more, bye!
 17111                                  
 17112                                  ; 17/05/2019 - Retro DOS v4.0
 17113                                  
 17114                                  ; DOSCODE:6029h (MSDOS 6.21, MSDOS.SYS)
 17115                                  
 17116                                  ;BREAK <$RmDir -- Remove a directory>
 17117                                  ;----------------------------------------------------------------------------
 17118                                  ;
 17119                                  ; Procedure Name : $RmDir
 17120                                  ;
 17121                                  ; Inputs:
 17122                                  ;	DS:DX Points to asciz name
 17123                                  ; Function:
 17124                                  ;	Delete directory if empty
 17125                                  ; Returns:
 17126                                  ;	STD XENIX Return
 17127                                  ;	AX = error_path_not_found If path bad
 17128                                  ;	AX = error_access_denied If
 17129                                  ;		Directory not empty
 17130                                  ;		Path not directory
 17131                                  ;		Root directory specified
 17132                                  ;		Directory malformed (. and .. not first two entries)
 17133                                  ;		User tries to delete a current directory
 17134                                  ;	AX = error_current_directory
 17135                                  ;
 17136                                  ;----------------------------------------------------------------------------
 17137                                  
 17138                                  	; 10/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17139                                  	; DOSCODE:6015h (MSDOS 5.0, MSDOS.SYS)
 17140                                  
 17141                                  	; 25/01/2025 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 17142                                  	; DOSCODE:66C8h (PCDOS 7.1, IBMDOS.COM)
 17143                                  
 17144                                  _$RMDIR:
 17145 00002769 52                      	push	dx			; Save ptr to name
 17146 0000276A 1E                      	push	ds
 17147 0000276B 89D6                    	mov	si,dx			; Load ptr into si
 17148 0000276D BF[BE03]                	mov	di,OPENBUF		; di = ptr to buf for trans name
 17149 00002770 57                      	push	di
 17150 00002771 E81F4E                  	call	TransPathNoSet		; Translate the name
 17151 00002774 5F                      	pop	di			; di = ptr to buf for trans name
 17152 00002775 7306                    	jnc	short rmlset		; If transpath succeeded, continue
 17153 00002777 1F                      	pop	ds
 17154 00002778 5A                      	pop	dx			; Restore the name
 17155                                  	;mov	al,3
 17156 00002779 B003                    	mov	al,error_path_not_found ; Otherwise, return an error
 17157                                  	; 16/12/2022
 17158                                  rmdir_errj: ; 10/08/2018
 17159                                  chdir_errj:
 17160 0000277B EB9F                    	jmp	short curdir_errj
 17161                                  	;jmp	SYS_RET_ERR
 17162                                  rmlset:
 17163 0000277D 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1	;   if (cMeta >= 0)
 17164 00002783 7518                    	Jnz	short rmerr		;	return (-1);
 17165 00002785 16                      	push	ss
 17166 00002786 07                      	pop	es
 17167 00002787 30C0                    	xor	al,al			; al = 0 , ie drive a:
 17168                                  rmloop: 
 17169 00002789 E8794D                  	call	GetCDSFromDrv		; Get curdir for drive in al
 17170 0000278C 7215                    	jc	short rmcont		; If error, exit loop & cont normally
 17171                                  
 17172                                  	; 25/01/2024 - Retro DOS v5.0
 17173                                  	; (PCDOS 7.1 IBMDOS.COM)
 17174                                  	;;;
 17175                                  	;;test	word [si+43h],4000h
 17176                                  	;test	word [si+curdir.flags],curdir_inuse
 17177 0000278E F6444440                	test	byte [si+curdir.flags+1],(curdir_inuse>>8)
 17178 00002792 7405                    	jz	short rmdir_nxt
 17179                                  	;;;
 17180                                  
 17181 00002794 E810F0                  	call	StrCmp			; Are the 2 paths the same?
 17182 00002797 7404                    	jz	short rmerr		; Yes, report error.
 17183                                  rmdir_nxt:	; 25/01/2024
 17184 00002799 FEC0                    	inc	al			; No, inc al to next drive number
 17185 0000279B EBEC                    	jmp	short rmloop		; Go check next drive.
 17186                                  rmerr:
 17187 0000279D 1F                      	pop	ds
 17188 0000279E 5A                      	pop	dx			; Restore ptr the name
 17189                                  	;mov	al,10h
 17190 0000279F B010                    	mov	al,error_current_directory ; error
 17191                                  	; 16/12/2022
 17192                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17193                                  ;chdir_errj:
 17194 000027A1 EBD8                    	jmp	short rmdir_errj
 17195                                  rmcont:
 17196 000027A3 1F                      	pop	ds
 17197 000027A4 5A                      	pop	dx			; Restore ptr the name
 17198 000027A5 BE[A13A]                	MOV	SI,DOS_RMDIR
 17199                                  
 17200                                  	; 25/01/2024 - Retro DOS v5.0
 17201                                  	; (PCDOS 7.1 IBMDOS.COM)
 17202                                  	;;;
 17203 000027A8 E896F0                  	call	TestNet
 17204 000027AB BF4300                  	mov	di,67		; DIRSTRLEN
 17205 000027AE 7303                    	jnc	short rmcont2   ; local directory
 17206 000027B0 BF8000                  	mov	di,128
 17207                                  rmcont2:
 17208                                  	;;;
 17209 000027B3 E99900                  	JMP	DoDirCall
 17210                                  
 17211                                  ; 17/05/2019 - Retro DOS v4.0
 17212                                  
 17213                                  ; DOSCODE:6065h (MSDOS 6.21, MSDOS.SYS)
 17214                                  
 17215                                  ;BREAK <$ChDir -- Change current directory on a drive>
 17216                                  ;----------------------------------------------------------------------------
 17217                                  ;
 17218                                  ; $ChDir - Top-level change directory system call.  This call is responsible
 17219                                  ; for setting up the CDS for the specified drive appropriately.  There are
 17220                                  ; several cases to consider:
 17221                                  ;
 17222                                  ;   o	Local, simple CDS.  In this case, we take the input path and convert
 17223                                  ;	it into a WFP.	We verify the existance of this directory and then
 17224                                  ;	copy the WFP into the CDS and set up the ID field to point to the
 17225                                  ;	directory cluster.
 17226                                  ;   o	Net CDS.  We form the path from the root (including network prefix)
 17227                                  ;	and verify its existance (via DOS_Chdir).  If successful, we copy the
 17228                                  ;	WFP back into the CDS.
 17229                                  ;   o	SUBST'ed CDS.  This is no different than the local, simple CDS.
 17230                                  ;   o	JOIN'ed CDS.  This is trouble as there are two CDS's at work.  If we
 17231                                  ;	call TransPath, we will get the PHYSICAL CDS that the path refers to
 17232                                  ;	and the PHYSICAL WFP that the input path refers to.  This is perfectly
 17233                                  ;	good for the validation but not for currency.  We call TransPathNoSet
 17234                                  ;	to process the path but to return the logical CDS and the logical
 17235                                  ;	path.  We then copy the logical path into the logical CDS.
 17236                                  ;
 17237                                  ; Inputs:
 17238                                  ;	DS:DX Points to asciz name
 17239                                  ; Returns:
 17240                                  ;	STD XENIX Return
 17241                                  ;	AX = chdir_path_not_found if error
 17242                                  ;
 17243                                  ;----------------------------------------------------------------------------
 17244                                  	
 17245                                  	; 25/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
 17246                                  	
 17247                                  _$CHDIR:
 17248                                  	; 25/01/2024
 17249                                  	;;;
 17250 000027B6 36C606[7B12]43          	mov	byte [ss:PATHNAMELEN],67 ; Retro DOS v5.0
 17251                                  	;mov	word [ss:PATHNAMELEN],67 ; DIRSTRLEN = 67
 17252                                  	;;;
 17253 000027BC BF[BE03]                	MOV	DI,OPENBUF		; spot for translated name
 17254 000027BF 89D6                    	MOV	SI,DX			; get source
 17255 000027C1 E8C34D                  	call	TransPath		; go munge the path and get real CDS
 17256 000027C4 7304                    	JNC	short ChDirCrack	; no errors, try path
 17257                                  ChDirErrP:
 17258                                  	;mov	al,3
 17259 000027C6 B003                    	MOV	AL,error_path_not_found
 17260                                  ChDirErr:
 17261                                  	;jmp	SYS_RET_ERR 	; oops!
 17262                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17263 000027C8 EBB1                    	jmp	short chdir_errj
 17264                                  
 17265                                  ChDirCrack:
 17266 000027CA 803E[7A05]FF            	CMP	byte [CMETA],-1		; No meta chars allowed.
 17267 000027CF 75F5                    	JNZ	short ChDirErrP
 17268                                  
 17269                                  ; We cannot do a ChDir (yet) on a raw CDS. This is treated as a path not
 17270                                  ; found.
 17271                                  
 17272 000027D1 C43E[A205]              	LES	DI,[THISCDS]
 17273 000027D5 83FFFF                  	CMP	DI,-1			;   if (ThisCDS == NULL)
 17274 000027D8 74EC                    	JZ	short ChDirErrP		;	error ();
 17275                                  
 17276                                  ; Find out if the directory exists.
 17277                                  
 17278 000027DA E87B12                  	call	DOS_CHDIR
 17279                                  	;Jc	short ChDirErr
 17280                                  	; 16/12/2022
 17281 000027DD 729C                    	jc	short chdir_errj
 17282                                  ;
 17283                                  ; Get back CDS to see if a join as seen. Set the currency pointer (only if
 17284                                  ; not network). If one was seen, all we need to do is copy in the text
 17285                                  ;
 17286                                  	; 25/01/2024 - Retro DOS V5.0
 17287 000027DF FF36[E30A]              	push	word [DIRSTART_HW] ; *
 17288                                  
 17289 000027E3 C43E[A205]              	LES	DI,[THISCDS]
 17290                                  	;test	word [es:di+43h],2000h
 17291                                  	; 17/12/2022
 17292 000027E7 26F6454420              	test	byte [ES:DI+curdir.flags+1],curdir_splice>>8
 17293                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice
 17294                                  
 17295                                  	; 25/01/2024 (PCDOS 7.1)
 17296                                  	;mov	dx,[DIRSTART_HW]
 17297                                  
 17298 000027EC 742B                    	JZ	short GotCDS
 17299                                  
 17300                                  ; The CDS was joined. Let's go back and grab the logical CDS.
 17301                                  
 17302 000027EE 06                      	push	es	
 17303 000027EF 57                      	push	di
 17304                                  	;push	dx ; 25/01/2024 (PCDOS 7.1)
 17305 000027F0 51                      	push	cx ; word [DIRSTART]	; save CDS and cluster...
 17306 000027F1 E883DC                  	call	Get_User_Stack		; get original text
 17307                                  	
 17308                                  	;mov	di,[si+6]
 17309 000027F4 8B7C06                  	MOV	DI,[SI+user_env.user_DX]
 17310                                  	;mov	ds,[si+0Eh]
 17311 000027F7 8E5C0E                  	MOV	DS,[SI+user_env.user_DS]
 17312                                  	
 17313 000027FA BE[BE03]                	MOV	SI,OPENBUF		; spot for translated name
 17314 000027FD 87F7                    	XCHG	SI,DI
 17315 000027FF 30C0                    	XOR	AL,AL			; do no splicing
 17316 00002801 57                      	push	di
 17317 00002802 E88E4D                  	call	TransPathNoSet		; Munge path
 17318 00002805 5E                      	pop	si
 17319                                  
 17320                                  ; There should NEVER be an error here.
 17321                                  
 17322                                  ;IF FALSE
 17323                                  ;	JNC SKipErr
 17324                                  ;	fmt <>,<>,<"$p: Internal CHDIR error\n">
 17325                                  ;SkipErr:
 17326                                  ;ENDIF
 17327 00002806 C43E[A205]              	LES	DI,[THISCDS]		; get new CDS
 17328                                  	;mov	word [es:di+49h],-1
 17329 0000280A 26C74549FFFF            	MOV	word [ES:DI+curdir.ID],-1
 17330                                  					; no valid cluster here...
 17331                                  	;;; 25/01/2024 (PCDOS 7.1)
 17332                                  	;mov	word [es:di+4Bh],-1
 17333 00002810 26C7454BFFFF            	mov	word [es:di+curdir.ID+2],-1
 17334                                  	;;;
 17335 00002816 59                      	pop	cx ; word [DIRSTART]
 17336                                  	;pop	dx ; 25/01/2024 (PCDOS 7.1)
 17337 00002817 5F                      	pop	di
 17338 00002818 07                      	pop	es
 17339                                  
 17340                                  ; ES:DI point to the physical CDS, CX is the ID (local only)
 17341                                  
 17342                                  GotCDS:
 17343                                  	; 25/01/2024 - Retro DOS v5.0
 17344 00002819 5A                      	pop	dx ; word [DIRSTART_HW] ; *
 17345                                  
 17346                                  ; wfp_start points to the text. See if it is long enough
 17347                                  
 17348                                  	; MSDOS 3.3
 17349                                  	;push	ss
 17350                                  	;pop	ds
 17351                                  	;mov	si,[WFP_START]
 17352                                  	;push	cx
 17353                                  	;call	DStrLen
 17354                                  	;cmp	cx,67 ; cmp cx,DIRSTRLEN
 17355                                  	;pop	cx
 17356                                  	;ja	short ChDirErrP
 17357                                  
 17358                                  	; MSDOS 6.0
 17359 0000281A E85C00                  	CALL	Check_PathLen		;PTM.		;AN000;
 17360 0000281D 77A7                    	JA	short ChDirErrP
 17361                                  	; MSDOS 3.3 & MSDOS 6.0
 17362                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet ; 8000h
 17363                                  	; 17/12/2022
 17364 0000281F 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8
 17365 00002824 7518                    	JNZ	short SkipRecency
 17366                                  	; MSDOS 6.0
 17367                                  	;test	word [es:di+43h],2000h
 17368                                  	; 17/12/2022
 17369 00002826 26F6454420              	test	byte [ES:DI+curdir.flags+1],curdir_splice>>8
 17370                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice 
 17371                                  					;PTM. for Join and Subst ;AN000;
 17372 0000282B 7405                    	JZ	short setdirclus	;PTM.		;AN000;
 17373 0000282D B9FFFF                  	MOV	CX,-1			;PTM.		;AN000;
 17374                                  	;;; 25/01/2024 (PCDOS 7.1 IBMDOS.COM)
 17375 00002830 89CA                    	mov	dx,cx
 17376                                  setdirclus:
 17377                                  	;mov	[es:di+49h],cx
 17378 00002832 26894D49                	MOV	[ES:DI+curdir.ID],CX
 17379                                  	;;; 25/01/2024 (PCDOS 7.1 IBMDOS.COM)
 17380 00002836 2689554B                	mov	[es:di+curdir.ID+2],dx
 17381                                  	;;;
 17382 0000283A C43E[A205]              	LES	DI,[THISCDS]		; get logical CDS
 17383                                  SkipRecency:
 17384 0000283E E897EF                  	call	FStrCpy
 17385 00002841 30C0                    	XOR	AL,AL
 17386                                  mkdir_ok:
 17387 00002843 E92ADE                  	jmp	SYS_RET_OK
 17388                                  
 17389                                  ; 17/05/2019 - Retro DOS v4.0
 17390                                  
 17391                                  ; DOSCODE:60E1h (MSDOS 6.21, MSDOS.SYS)
 17392                                  
 17393                                  ;BREAK <$MkDir - Make a directory entry>
 17394                                  ;---------------------------------------------------------------------------
 17395                                  ;
 17396                                  ; Procedure Name : $MkDir
 17397                                  ; Inputs:
 17398                                  ;	DS:DX Points to asciz name
 17399                                  ; Function:
 17400                                  ;	Make a new directory
 17401                                  ; Returns:
 17402                                  ;	STD XENIX Return
 17403                                  ;	AX = mkdir_path_not_found if path bad
 17404                                  ;	AX = mkdir_access_denied  If
 17405                                  ;		Directory cannot be created
 17406                                  ;		Node already exists
 17407                                  ;		Device name given
 17408                                  ;		Disk or directory(root) full
 17409                                  ;---------------------------------------------------------------------------
 17410                                  
 17411                                  	; 10/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17412                                  
 17413                                  	; 25/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 17414                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:67B0h
 17415                                  
 17416                                  _$MKDIR:
 17417                                  	;MOV	SI,DOS_MKDIR
 17418                                  	;;;
 17419                                  	; 25/01/2024 (PCDOS 7.1 IBMDOS.COM)
 17420 00002846 36C606[7B12]43          	mov	byte [ss:PATHNAMELEN],67 ; Retro DOS v5.0
 17421                                  	;mov	word [ss:PATHNAMELEN],67 ; DIRSTRLEN (standard length = 67)
 17422                                  mkdir_x:	; (windows) extended length (128)
 17423 0000284C BE[4339]                	mov	si,DOS_MKDIR
 17424                                  	;;;
 17425                                  DoDirCall:
 17426 0000284F BF[BE03]                	MOV	DI,OPENBUF		; spot for translated name
 17427                                  
 17428 00002852 56                      	push	si
 17429 00002853 89D6                    	MOV	SI,DX			; get source
 17430 00002855 E82F4D                  	call	TransPath		; go munge the path
 17431 00002858 5E                      	pop	si
 17432 00002859 7305                    	JNC	short MkDirCrack	; no errors, try path
 17433                                  MkErrP:
 17434 0000285B B003                    	MOV	AL,error_path_not_found	; oops!
 17435                                  MkErr:
 17436 0000285D E91ADE                  	jmp	SYS_RET_ERR
 17437                                  MkDirCrack:
 17438 00002860 36803E[7A05]FF          	CMP	byte [SS:CMETA],-1
 17439 00002866 75F3                    	JNZ	short MkErrP
 17440                                  
 17441                                  	; MSDOS 3.3
 17442                                  	;push	ss
 17443                                  	;pop	ds
 17444                                  	;call	si
 17445                                  	;jb	short MkErr
 17446                                  	;;jmp	short mkdir_ok
 17447                                  	;jmp	SYS_RET_OK
 17448                                  
 17449                                  	; MSDOS 6.0
 17450 00002868 56                      	PUSH	SI			;PTM.			;AN000;
 17451                                  		; 25/01/2024 (PCDOS 7.1 IBMDOS.COM)
 17452                                  		; check path len > [PATNAMELEN] ; 67 or 128
 17453 00002869 E80D00                  	CALL	Check_PathLen		;PTM. check path len > 67 ? ;AN000;
 17454 0000286C 5E                      	POP	SI			;PTM.			;AN000;
 17455 0000286D 7604                    	JBE	short pathok		;PTM.			;AN000;
 17456                                  	;mov	al,5
 17457 0000286F B005                    	MOV	AL,error_access_denied	;PTM. ops!
 17458                                  	;jmp	SYS_RET_ERR		;PTM.
 17459 00002871 EBEA                    	jmp	short MkErr
 17460                                  pathok:
 17461 00002873 FFD6                    	CALL	SI			; go get file
 17462 00002875 72E6                    	JC	short MkErr		; error
 17463                                  	; 16/12/2022
 17464                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17465 00002877 EBCA                    	jmp	short mkdir_ok		; ok
 17466                                  	;jmp	SYS_RET_OK
 17467                                  
 17468                                  ;----------------------------------------------------------------------------
 17469                                  ;
 17470                                  ; Procedure Name : Check_PathLen
 17471                                  ;
 17472                                  ; Inputs:
 17473                                  ;	nothing
 17474                                  ; Function:
 17475                                  ;	check if final path length greater than 67
 17476                                  ; Returns:
 17477                                  ;	Above flag set if > 67
 17478                                  ;
 17479                                  ;---------------------------------------------------------------------------
 17480                                  
 17481                                  	; 25/01/2024 - Retro DOS v5.0
 17482                                  	; (PCDOS 7.1 IBMDOS.COM)
 17483                                  
 17484                                  Check_PathLen:
 17485                                  	; 09/09/2018
 17486                                  	;mov	SI,[WFP_START]
 17487 00002879 368B36[B205]            	MOV	SI,[SS:WFP_START] ; MSDOS 6.0
 17488                                  Check_PathLen2:
 17489                                  	; 25/01/2024 - Retro DOS v5.0
 17490                                  	; Note: dx is not changed in 'Check_PathLen';
 17491                                  	;	no need to push/pop (*)
 17492                                  	;
 17493 0000287E 16                      	push	ss
 17494 0000287F 1F                      	pop	ds
 17495                                  	;mov	SI,[WFP_START]	  ; MSDOS 3.3
 17496 00002880 51                      	push	CX
 17497                                  	; (PCDOS 7.1 IBMDOS.COM)
 17498                                  	;push	dx ; 25/01/2024	(*)
 17499 00002881 E86BEF                  	CALL	DStrLen
 17500                                  	; (PCDOS 7.1 IBMDOS.COM)
 17501 00002884 3B0E[7B12]              	cmp	cx,[PATHNAMELEN] ; 67 or 128
 17502                                  	;CMP	CX,DIRSTRLEN ; 67
 17503                                  	;pop	dx
 17504 00002888 59                      	POP	CX
 17505 00002889 C3                      	retn
 17506                                  
 17507                                  ;============================================================================
 17508                                  ; IOCTL.ASM, MSDOS 6.0, 1991
 17509                                  ;============================================================================
 17510                                  ; 07/08/2018 - Retro DOS v3.0
 17511                                  ; 17/05/2019 - Retro DOS v4.0
 17512                                  
 17513                                  ;**	IOCTL system call.
 17514                                  ;----------------------------------------------------------------------------
 17515                                  ;	$IOCTL
 17516                                  ;
 17517                                  ;	  Revision history:
 17518                                  ;
 17519                                  ;		Created: ARR 4 April 1983
 17520                                  ;
 17521                                  ;		GenericIOCTL added:		KGS	22 April 1985
 17522                                  ;
 17523                                  ;		A000	version 4.00	Jan. 1988
 17524                                  ;
 17525                                  ;		Used jump table to dispatch IOCTL functions. HKN 3/12/90
 17526                                  ;
 17527                                  
 17528                                  ;BREAK <IOCTL - munge on a handle to do device specific stuff>
 17529                                  ;---------------------------------------------------------------------------
 17530                                  ;
 17531                                  ;   Assembler usage:
 17532                                  ;	    MOV     BX, Handle
 17533                                  ;	    MOV     DX, Data
 17534                                  ;
 17535                                  ;	(or LDS     DX,BUF
 17536                                  ;	    MOV     CX,COUNT)
 17537                                  ;
 17538                                  ;	    MOV     AH, Ioctl
 17539                                  ;	    MOV     AL, Request
 17540                                  ;	    INT     21h
 17541                                  ;
 17542                                  ;   AH = 0  Return a combination of low byte of sf_flags and device driver
 17543                                  ;	    attribute word in DX, handle in BX:
 17544                                  ;	    DH = high word of device driver attributes
 17545                                  ;	    DL = low byte of sf_flags
 17546                                  ;	 1  Set the bits contained in DX to sf_flags.  DH MUST be 0.  Handle
 17547                                  ;	    in BX.
 17548                                  ;	 2  Read CX bytes from the device control channel for handle in BX
 17549                                  ;	    into DS:DX.  Return number read in AX.
 17550                                  ;	 3  Write CX bytes to the device control channel for handle in BX from
 17551                                  ;	    DS:DX.  Return bytes written in AX.
 17552                                  ;	 4  Read CX bytes from the device control channel for drive in BX
 17553                                  ;	    into DS:DX.  Return number read in AX.
 17554                                  ;	 5  Write CX bytes to the device control channel for drive in BX from
 17555                                  ;	    DS:DX.  Return bytes written in AX.
 17556                                  ;	 6  Return input status of handle in BX. If a read will go to the
 17557                                  ;	    device, AL = 0FFh, otherwise 0.
 17558                                  ;	 7  Return output status of handle in BX. If a write will go to the
 17559                                  ;	    device, AL = 0FFh, otherwise 0.
 17560                                  ;	 8  Given a drive in BX, return 1 if the device contains non-
 17561                                  ;	    removable media, 0 otherwise.
 17562                                  ;	 9  Return the contents of the device attribute word in DX for the
 17563                                  ;	    drive in BX.  0200h is the bit for shared.	1000h is the bit for
 17564                                  ;	    network. 8000h is the bit for local use.
 17565                                  ;	 A  Return 8000h if the handle in BX is for the network or not.
 17566                                  ;	 B  Change the retry delay and the retry count for the system. BX is
 17567                                  ;	    the count and CX is the delay.
 17568                                  ;
 17569                                  ;   Error returns:
 17570                                  ;	    AX = error_invalid_handle
 17571                                  ;	       = error_invalid_function
 17572                                  ;	       = error_invalid_data
 17573                                  ;
 17574                                  ;-------------------------------------------------------------------------------
 17575                                  ;
 17576                                  ;   This is the documentation copied from DOS 4.0 it is much better
 17577                                  ;   than the above
 17578                                  ;
 17579                                  ;	There are several basic forms of IOCTL calls:
 17580                                  ;
 17581                                  ;
 17582                                  ;	** Get/Set device information:	**
 17583                                  ;
 17584                                  ;	ENTRY	(AL) = function code
 17585                                  ;		  0 - Get device information
 17586                                  ;		  1 - Set device information
 17587                                  ;		(BX) = file handle
 17588                                  ;		(DX) = info for "Set Device Information"
 17589                                  ;	EXIT	'C' set if error
 17590                                  ;		  (AX) = error code
 17591                                  ;		'C' clear if OK
 17592                                  ;		  (DX) = info for "Get Device Information"
 17593                                  ;	USES	ALL
 17594                                  ;
 17595                                  ;
 17596                                  ;	**  Read/Write Control Data From/To Handle  **
 17597                                  ;
 17598                                  ;	ENTRY	(AL) = function code
 17599                                  ;		  2 - Read device control info
 17600                                  ;		  3 - Write device control info
 17601                                  ;		(BX) = file handle
 17602                                  ;		(CX) = transfer count
 17603                                  ;		(DS:DX) = address for data
 17604                                  ;	EXIT	'C' set if error
 17605                                  ;		  (AX) = error code
 17606                                  ;		'C' clear if OK
 17607                                  ;		  (AX) = count of bytes transfered
 17608                                  ;	USES	ALL
 17609                                  ;
 17610                                  ;
 17611                                  ;	**  Read/Write Control Data From/To Block Device  **
 17612                                  ;
 17613                                  ;	ENTRY	(AL) = function code
 17614                                  ;		  4 - Read device control info
 17615                                  ;		  5 - Write device control info
 17616                                  ;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
 17617                                  ;		(CX) = transfer count
 17618                                  ;		(DS:DX) = address for data
 17619                                  ;	EXIT	'C' set if error
 17620                                  ;		  (AX) = error code
 17621                                  ;		'C' clear if OK
 17622                                  ;		  (AX) = count of bytes transfered
 17623                                  ;	USES	ALL
 17624                                  ;
 17625                                  ;
 17626                                  ;	**  Get Input/Output Status  **
 17627                                  ;
 17628                                  ;	ENTRY	(AL) = function code
 17629                                  ;		  6 - Get Input status
 17630                                  ;		  7 - Get Output Status
 17631                                  ;		(BX) = file handle
 17632                                  ;	EXIT	'C' set if error
 17633                                  ;		  (AX) = error code
 17634                                  ;		'C' clear if OK
 17635                                  ;		  (AL) = 00 if not ready
 17636                                  ;		  (AL) = FF if ready
 17637                                  ;	USES	ALL
 17638                                  ;
 17639                                  ;
 17640                                  ;	**  Get Drive Information  **
 17641                                  ;
 17642                                  ;	ENTRY	(AL) = function code
 17643                                  ;		  8 - Check for removable media
 17644                                  ;		  9 - Get device attributes
 17645                                  ;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
 17646                                  ;	EXIT	'C' set if error
 17647                                  ;		  (AX) = error code
 17648                                  ;		'C' clear if OK
 17649                                  ;		  (AX) = 0/1 media is removable/fixed (func. 8)
 17650                                  ;		  (DX) = device attribute word (func. 9)
 17651                                  ;	USES	ALL
 17652                                  ;
 17653                                  ;
 17654                                  ;	**  Get Redirected bit	**
 17655                                  ;
 17656                                  ;	ENTRY	(AL) = function code
 17657                                  ;		  0Ah - Network stuff
 17658                                  ;		(BX) = file handle
 17659                                  ;	EXIT	'C' set if error
 17660                                  ;		  (AX) = error code
 17661                                  ;		'C' clear if OK
 17662                                  ;		  (DX) = SFT flags word, 8000h set if network file
 17663                                  ;	USES	ALL
 17664                                  ;
 17665                                  ;
 17666                                  ;	**  Change sharer retry parameters  **
 17667                                  ;
 17668                                  ;	ENTRY	(AL) = function code
 17669                                  ;		  0Bh - Set retry parameters
 17670                                  ;		(CX) = retry loop count
 17671                                  ;		(DX) = number of retries
 17672                                  ;	EXIT	'C' set if error
 17673                                  ;		  (AX) = error code
 17674                                  ;		'C' clear if OK
 17675                                  ;	USES	ALL
 17676                                  ;
 17677                                  ;
 17678                                  ;   =================================================================
 17679                                  ;
 17680                                  ;	**  New Standard Control  **
 17681                                  ;
 17682                                  ;	ALL NEW IOCTL FACILITIES SHOULD USE THIS FORM.	THE OTHER
 17683                                  ;	FORMS ARE OBSOLETE.
 17684                                  ;
 17685                                  ;   =================================================================
 17686                                  ;
 17687                                  ;	ENTRY	(AL) = function code
 17688                                  ;		  0Ch - Control Function subcode
 17689                                  ;		(BX) = File Handle
 17690                                  ;		(CH) = Category Indicator
 17691                                  ;		(CL) = Function within category
 17692                                  ;		(DS:DX) = address for data, if any
 17693                                  ;		(SI) = Passed to device as argument, use depends upon function
 17694                                  ;		(DI) = Passed to device as argument, use depends upon function
 17695                                  ;	EXIT	'C' set if error
 17696                                  ;		  (AX) = error code
 17697                                  ;		'C' clear if OK
 17698                                  ;		  (SI) = Return value, meaning is function dependent
 17699                                  ;		  (DI) = Return value, meaning is function dependent
 17700                                  ;		  (DS:DX) = Return address, use is function dependent
 17701                                  ;	USES	ALL
 17702                                  ;
 17703                                  ;    ============== Generic IOCTL Definitions for DOS 3.2 ============
 17704                                  ;     (See inc\ioctl.inc for more info)
 17705                                  ;
 17706                                  ;	ENTRY	(AL) = function code
 17707                                  ;		  0Dh - Control Function subcode
 17708                                  ;		(BL) = Drive Number (0 = Default, 1= 'A')
 17709                                  ;		(CH) = Category Indicator
 17710                                  ;		(CL) = Function within category
 17711                                  ;		(DS:DX) = address for data, if any
 17712                                  ;		(SI) = Passed to device as argument, use depends upon function
 17713                                  ;		(DI) = Passed to device as argument, use depends upon function
 17714                                  ;
 17715                                  ;	EXIT	'C' set if error
 17716                                  ;		  (AX) = error code
 17717                                  ;		'C' clear if OK
 17718                                  ;		  (DS:DX) = Return address, use is function dependent
 17719                                  ;	USES	ALL
 17720                                  ;
 17721                                  ;---------------------------------------------------------------------------
 17722                                  	
 17723                                  	; 17/05/2019 - Retro DOS v4.0
 17724                                  	; DOSCODE:611Eh (MSDOS 6.21, MSDOS.SYS)
 17725                                  
 17726                                  	; 11/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17727                                  	; DOSCODE:610Ah (MSDOS 5.0, MSDOS.SYS)
 17728                                  
 17729                                  	; 14/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 17730                                  	; DOSCODE:67F7h (PCDOS 7.1, IBMDOS.COM)
 17731                                  
 17732                                  IOCTLJMPTABLE:	;label	word
 17733                                  	; MSDOS 3.3 (& MSDOS 6.0)
 17734 0000288A [C628]                  	dw	ioctl_getset_data	; 0
 17735 0000288C [C628]                  	dw	ioctl_getset_data   	; 1
 17736 0000288E [1029]                  	dw	ioctl_control_string	; 2
 17737 00002890 [1029]                  	dw	ioctl_control_string	; 3
 17738 00002892 [A32A]                  	dw	ioctl_get_dev		; 4
 17739 00002894 [A32A]                  	dw	ioctl_get_dev		; 5
 17740 00002896 [2829]                  	dw	ioctl_status		; 6
 17741 00002898 [2829]                  	dw	ioctl_status		; 7
 17742 0000289A [022A]                  	dw	ioctl_rem_media		; 8
 17743 0000289C [4B2A]                  	dw	ioctl_drive_attr	; 9
 17744 0000289E [952A]                  	dw	ioctl_handle_redir	; A
 17745 000028A0 [3D2A]                  	dw	Set_Retry_Parameters	; B
 17746 000028A2 [4429]                  	dw	GENERICIOCTLHANDLE	; C
 17747 000028A4 [5E29]                  	dw	GENERICIOCTL		; D
 17748                                  	; MSDOS 6.0 (& MSDOS 3.3)
 17749 000028A6 [442B]                  	dw	ioctl_drive_owner	; E
 17750 000028A8 [442B]                  	dw	ioctl_drive_owner	; F
 17751                                  	; MSDOS 6.0
 17752 000028AA [4429]                  	dw	query_handle_support	; 10h
 17753 000028AC [5E29]                  	dw	query_device_support	; 11h
 17754                                  
 17755                                  	; 11/11/2022
 17756                                  _$IOCTL:
 17757 000028AE 8CDE                    	MOV	SI,DS			; Stash DS for calls 2,3,4 and 5
 17758 000028B0 16                      	push	ss
 17759 000028B1 1F                      	pop	ds			;hkn; SS is DOSDATA
 17760                                  
 17761                                  	; MSDOS 3.3
 17762                                  	;cmp	al,0Fh 
 17763                                  	; MSDOS 6.0
 17764 000028B2 3C11                    	cmp	al,11h			; al must be between 0 & 11h
 17765 000028B4 770D                    	ja	short ioctl_bad_funj2	; if not bad function #
 17766                                  
 17767                                  	; 14/01/2024
 17768                                  	; 28/05/2019
 17769                                  	;push	AX	; 14/01/2024	; Need to save AL for generic IOCTL
 17770 000028B6 89C7                    	mov	di,ax			; di NOT a PARM
 17771 000028B8 81E7FF00                	and	di,0FFh			; di = al
 17772 000028BC D1E7                    	shl	di,1			; di = index into jmp table
 17773                                  	;pop	AX			; Restore AL for generic IOCTL
 17774                                  
 17775                                  
 17776 000028BE 2EFFA5[8A28]            	jmp	word [CS:DI+IOCTLJMPTABLE]
 17777                                  
 17778                                  ioctl_bad_funj2:
 17779 000028C3 E90401                  	JMP	ioctl_bad_fun  ; 10/08/2018
 17780                                  
 17781                                  ;--------------------------------------------------------------------------
 17782                                  ;
 17783                                  ; IOCTL: AL = 0,1
 17784                                  ;
 17785                                  ; ENTRY: DS = DOSDATA
 17786                                  ;
 17787                                  ;--------------------------------------------------------------------------
 17788                                  
 17789                                  	; 29/01/2024 - Retro DOS v5.0
 17790                                  ioctl_getset_data:
 17791                                  	; MSDOS 6.0
 17792 000028C6 E8C347                  	call	SFFromHandle		; ES:DI -> SFT
 17793 000028C9 7305                    	JNC	short ioctl_check_permissions ; have valid handle
 17794                                  ioctl_bad_handle:
 17795                                  	;mov	al,6
 17796 000028CB B006                    	mov	al,error_invalid_handle
 17797                                  ioctl_error:
 17798 000028CD E9AADD                  	jmp	SYS_RET_ERR
 17799                                  
 17800                                  ioctl_check_permissions:
 17801 000028D0 3C00                    	CMP	AL,0
 17802                                  	;mov	al,[es:di+5]
 17803 000028D2 268A4505                	MOV	AL,[ES:DI+SF_ENTRY.sf_flags]; Get low byte of flags
 17804 000028D6 7419                    	JZ	short ioctl_read	; read the byte
 17805                                  
 17806 000028D8 08F6                    	or	dh,dh
 17807 000028DA 7404                    	JZ	short ioctl_check_device ; can I set with this data?
 17808                                  	;mov	al,0Dh
 17809 000028DC B00D                    	mov	al,error_invalid_data	; no DH <> 0
 17810                                  	;jmp	SYS_RET_ERR
 17811 000028DE EBED                    	jmp	short ioctl_error
 17812                                  
 17813                                  ioctl_check_device:
 17814 000028E0 A880                    	test	AL,devid_device  ; 80h	; can I set this handle?
 17815 000028E2 74DF                    	jz	short ioctl_bad_funj2
 17816 000028E4 80CA80                  	OR	DL,devid_device 	; Make sure user doesn't turn off the
 17817                                  					;   device bit!! He can muck with the
 17818                                  					;   others at will.
 17819                                  	;MOV	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 17820                                  	; 29/01/2024
 17821                                  	;;;
 17822 000028E7 E819EA                  	call	set_exerr_locus_ser ; (PCDOS 7.1 IBMDOS.COM)
 17823                                  	;;;
 17824 000028EA 26885505                	MOV	BYTE [ES:DI+SF_ENTRY.sf_flags],DL  ;AC000;MS.; Set flags
 17825                                  ioctl_ok:
 17826 000028EE E97FDD                  	jmp	SYS_RET_OK
 17827                                  
 17828                                  ioctl_read:
 17829                                  	;MOV	byte [EXTERR_LOCUS],errLOC_Disk  ; 2
 17830                                  	; 29/01/2024
 17831                                  	;;;
 17832 000028F1 E80AEA                  	call	set_exerr_locus_disk ; (PCDOS 7.1 IBMDOS.COM)
 17833                                  	;;;
 17834 000028F4 30E4                    	XOR	AH,AH
 17835 000028F6 A880                    	test	AL,devid_device 	; Should I set high byte
 17836 000028F8 740B                    	JZ	short ioctl_no_high	; no
 17837                                  	;MOV	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 17838                                  	; 29/01/2024
 17839                                  	;;;
 17840 000028FA E806EA                  	call	set_exerr_locus_ser ; (PCDOS 7.1 IBMDOS.COM)
 17841                                  	;;;
 17842                                  	;les	di,[es:di+7]
 17843 000028FD 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
 17844                                  	;mov	ah,[es:di+5]
 17845 00002901 268A6505                	MOV	AH,[ES:DI+SYSDEV.ATT+1] ; Get high byte
 17846                                  ioctl_no_high:
 17847 00002905 89C2                    	MOV	DX,AX
 17848                                  ioctl_set_dx:	; 16/12/2022
 17849 00002907 E86DDB                  	call	Get_User_Stack
 17850                                  	;mov	[si+6],dx
 17851 0000290A 895406                  	MOV	[SI+user_env.user_DX],DX
 17852                                  	;;jmp	SYS_RET_OK
 17853                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17854                                  ioctl_ok_j:
 17855                                  	; 16/12/2022
 17856 0000290D E963DD                  	jmp	SYS_RET_OK_clc	 ; (after 'Get_User_Stack') 
 17857                                  	;jmp	short ioctl_ok
 17858                                  	; 26/07/2019
 17859                                  	;jmp	SYS_RET_OK_clc
 17860                                  
 17861                                  ;--------------------------------------------------------------------------
 17862                                  ;
 17863                                  ; IOCTL: AL = 2,3
 17864                                  ;
 17865                                  ; ENTRY: DS = DOSDATA
 17866                                  ;	 SI = user's DS
 17867                                  ;
 17868                                  ;--------------------------------------------------------------------------
 17869                                  
 17870                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17871                                  ioctl_control_string:
 17872 00002910 E87947                  	call	SFFromHandle		; ES:DI -> SFT
 17873 00002913 72B6                    	JC	short ioctl_bad_handle	; invalid handle
 17874                                  	; 07/12/2022
 17875                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
 17876                                  	;jz	short ioctl_bad_funj2			; No it is a file
 17877                                  	; MSDOS 5.0 & MSDOS 6.0
 17878 00002915 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
 17879 0000291A 74A7                    	jz	short ioctl_bad_funj2			; No it is a file
 17880                                  	;MOV	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 17881                                  	; 29/01/2024
 17882                                  	;;;
 17883 0000291C E8E4E9                  	call	set_exerr_locus_ser ; (PCDOS 7.1 IBMDOS.COM)
 17884                                  	;;;
 17885 0000291F 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
 17886 00002923 30DB                    	XOR	BL,BL			; Unit number of char dev = 0
 17887 00002925 E98301                  	JMP	ioctl_do_string
 17888                                  
 17889                                  ;--------------------------------------------------------------------------
 17890                                  ;
 17891                                  ; IOCTL: AL = 6,7
 17892                                  ;
 17893                                  ; ENTRY: DS = DOSDATA
 17894                                  ;
 17895                                  ;--------------------------------------------------------------------------
 17896                                  
 17897                                  ioctl_status:
 17898 00002928 B401                    	MOV	AH,1
 17899 0000292A 2C06                    	SUB	AL,6			; 6=0,7=1
 17900 0000292C 7402                    	JZ	short ioctl_get_status
 17901 0000292E B403                    	MOV	AH,3
 17902                                  ioctl_get_status:
 17903 00002930 50                      	PUSH	AX
 17904 00002931 E8C015                  	call	GET_IO_SFT
 17905 00002934 58                      	POP	AX
 17906                                  	;JNC	short DO_IOFUNC
 17907                                  	;JMP	short ioctl_bad_handle	; invalid SFT
 17908                                  	; 16/12/2022
 17909 00002935 7294                    	jc	short ioctl_bad_handle
 17910                                  DO_IOFUNC:
 17911 00002937 E84125                  	call	IOFUNC
 17912 0000293A 88C4                    	MOV	AH,AL
 17913 0000293C B0FF                    	MOV	AL,0FFH
 17914                                  	;JNZ	short ioctl_status_ret
 17915                                  	; 29/01/2024
 17916 0000293E 75AE                    	jnz	short ioctl_ok
 17917 00002940 FEC0                    	INC	AL
 17918                                  ioctl_status_ret:
 17919                                  	;jmp	SYS_RET_OK
 17920                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17921                                  	;jmp	short ioctl_ok_j
 17922                                  	; 16/12/2022
 17923 00002942 EBAA                    	jmp	short ioctl_ok
 17924                                  
 17925                                  ;--------------------------------------------------------------------------
 17926                                  ;
 17927                                  ; Generic IOCTL entry point. AL = C, D, 10h, 11h
 17928                                  ;
 17929                                  ;	here we invoke the Generic IOCTL using the IOCTL_Req structure.
 17930                                  ;	SI:DX -> Users Device Parameter Table
 17931                                  ;	IOCALL -> IOCTL_Req structure
 17932                                  ;
 17933                                  ; 	If on entry AL >= IOCTL_QUERY_HANDLE the function is a
 17934                                  ;	QueryIOCtlSupport call ELSE it's a standard generic IOCtl
 17935                                  ;	call.
 17936                                  ;
 17937                                  ; BUGBUG: Don't push anything on the stack between GENERIOCTL: and 
 17938                                  ;         the call to Check_If_Net because Check_If_Net gets our
 17939                                  ;         return address off the stack if the drive is invalid.
 17940                                  ;
 17941                                  ;--------------------------------------------------------------------------
 17942                                  
 17943                                  	; 29/01/2024 - Retro DOS v5.0
 17944                                  
 17945                                  query_handle_support:	; Entry point for handles
 17946                                  GENERICIOCTLHANDLE:
 17947 00002944 E84547                  	call	SFFromHandle		; Get SFT for device.
 17948 00002947 727E                    	jc	short ioctl_bad_handlej
 17949                                  
 17950                                  	;test	word [es:di+5],8000h
 17951                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet	; M031;
 17952                                  	;test	byte [es:di+6],80h
 17953 00002949 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 17954 0000294E 757A                    	jnz	short ioctl_bad_fun	; Cannot do this over net.
 17955                                  
 17956                                  	;mov	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 17957                                  	; 29/01/2024
 17958                                  	;;;
 17959 00002950 E8B0E9                  	call	set_exerr_locus_ser ; (PCDOS 7.1 IBMDOS.COM)
 17960                                  	;;;
 17961                                  
 17962                                  	;les	di,[es:di+7]
 17963 00002953 26C47D07                	les	di,[es:di+SF_ENTRY.sf_devptr]	; Get pointer to device.
 17964                                  	;;;
 17965                                  	; 29/01/2024 - PCDOS 7.1 IBMDOS.COM
 17966 00002957 C606[B103]FF            	mov	byte [IOCTL_drvnum],0FFh	; invalidate drive number
 17967                                  					; (for extended -lock/unlock- functions)
 17968                                  	;;;
 17969 0000295C EB16                    	jmp	short Do_GenIOCTL
 17970                                  
 17971                                  	; 29/01/2024 - Retro DOS v5.0
 17972                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:68DAh
 17973                                  	; (WINME IO.SYS - BIOSCODE:6612h)
 17974                                  
 17975                                  query_device_support:	; Entry point for devices:
 17976                                  GENERICIOCTL:
 17977                                  	;mov	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 17978                                  	; 29/01/2024
 17979                                  	;;;
 17980 0000295E E89DE9                  	call	set_exerr_locus_disk
 17981 00002961 80FD48                  	cmp	ch,48h			; category (extended, disk lock/unlock)
 17982 00002964 7405                    	je      short GenIOCTL_chk_net	; extended (MSDOS/PCDOS 7)
 17983                                  	;;;
 17984                                  
 17985 00002966 80FD08                  	cmp	ch,IOC_DC ; 8		; Only disk devices are allowed to use
 17986 00002969 755F                    	jne	short ioctl_bad_fun	; no handles with Generic IOCTL.
 17987                                  
 17988                                  	; 29/01/2024 
 17989                                  	;;;
 17990                                  GenIOCTL_chk_net:
 17991 0000296B 881E[B103]              	mov	[IOCTL_drvnum],bl	; drive number
 17992                                  	;;;
 17993                                  
 17994 0000296F E8C301                  	CALL	Check_If_Net		; ES:DI := Get_hdr_block of device in BL
 17995 00002972 7556                    	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
 17996                                  
 17997                                  Do_GenIOCTL:
 17998                                  	; 29/01/2024 - Retro DOS v5.0 
 17999                                  	;;;
 18000 00002974 80FD48                  	cmp	ch,48h			; category code 48h for FAT32
 18001 00002977 7456                    	je	short GenIOCTL_extended ; MSDOS/PCDOS 7 functions (lock/unlock)
 18002                                  	;cmp	ch,8
 18003 00002979 80FD08                  	cmp	ch,IOC_DC ; 8          	; disk control
 18004 0000297C 7451                    	je	short GenIOCTL_extended
 18005                                  GenIOCTL_normal:			; MSDOS 5-6.22 functions
 18006                                  	;;;
 18007                                  
 18008                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEV320 
 18009                                  					; Can device handle Generic IOCTL funcs
 18010                                  	; 09/09/2018
 18011                                  	;test	byte [es:di+4],40h
 18012 0000297E 26F6450440              	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
 18013 00002983 7445                    	jz	short ioctl_bad_fun
 18014                                  
 18015                                  	; 17/05/2019 - Retro DOS v4.0
 18016                                  
 18017                                  	; MSDOS 6.0
 18018                                  	;mov	byte [IOCALL_REQFUNC],19 ; 13h
 18019 00002985 C606[7E03]13            	mov	byte [IOCALL_REQFUNC],GENIOCTL ; Assume real Request
 18020                                  	;cmp	al,10h
 18021 0000298A 3C10                    	cmp	AL,IOCTL_QUERY_HANDLE	; See if this is just a query
 18022 0000298C 7C0C                    	jl	short SetIOCtlBlock
 18023                                  	
 18024                                  	;TEST	word [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
 18025                                  	;test	byte [es:di+4],80h 
 18026 0000298E 26F6450480              	TEST	byte [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
 18027 00002993 7435                    	jz	short ioctl_bad_fun	; No support for query 
 18028                                  	;
 18029                                  	;mov	byte [IOCALL_REQFUNC],19h	
 18030 00002995 C606[7E03]19            	mov	byte [IOCALL_REQFUNC],IOCTL_QUERY ; Just a query (5.00)
 18031                                  
 18032                                  SetIOCtlBlock:
 18033 0000299A 06                      	PUSH	ES			; DEVIOCALL2 expects Device header block
 18034 0000299B 57                      	PUSH	DI			; in DS:SI
 18035                                  					; Setup Generic IOCTL Request Block
 18036                                  	;mov	byte [IOCALL_REQLEN],23
 18037 0000299C C606[7C03]17            	mov	byte [IOCALL_REQLEN],IOCTL_REQ.size
 18038                                  	; 07/09/2018 (MSDOS 3.3)
 18039                                  	;;mov	byte [IOCALL_REQFUNC],19
 18040                                  	;mov	byte [IOCALL_REQFUNC],GENIOCTL ; 07/09/2018
 18041                                  	;
 18042 000029A1 881E[7D03]              	MOV	[IOCALL_REQUNIT],BL
 18043 000029A5 882E[8903]              	MOV	[IOCALL+IOCTL_REQ.MAJORFUNCTION],CH
 18044 000029A9 880E[8A03]              	MOV	[IOCALL+IOCTL_REQ.MINORFUNCTION],CL
 18045 000029AD 8936[8B03]              	MOV	[IOCALL+IOCTL_REQ.REG_SI],SI
 18046 000029B1 893E[8D03]              	MOV	[IOCALL+IOCTL_REQ.REG_DI],DI
 18047 000029B5 8916[8F03]              	MOV	[IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET],DX
 18048 000029B9 8936[9103]              	MOV	[IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET+2],SI
 18049                                  
 18050                                  ;hkn; IOCALL is in DOSDATA
 18051 000029BD BB[7C03]                	MOV	BX,IOCALL
 18052                                  
 18053 000029C0 16                      	PUSH	SS
 18054 000029C1 07                      	POP	ES
 18055                                  					; DS:SI -> Device header.
 18056 000029C2 5E                      	POP	SI
 18057 000029C3 1F                      	POP	DS
 18058                                  	; 10/08/2018
 18059 000029C4 E91D01                  	jmp	ioctl_do_IO		; Perform Call to device driver
 18060                                  	
 18061                                  ioctl_bad_handlej:
 18062 000029C7 E901FF                  	jmp	ioctl_bad_handle
 18063                                  
 18064                                  	; 29/01/2024
 18065                                  ioctl_bad_fun:
 18066 000029CA B001                    	mov	al, error_invalid_function  ; 1
 18067 000029CC E9ABDC                  	jmp	SYS_RET_ERR	
 18068                                  
 18069                                  	; 29/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 18070                                  GenIOCTL_extended:
 18071 000029CF 80F96A                  	cmp	cl,6Ah			; UNLOCK LOGICAL VOLUME
 18072                                  	;je	short GenIOCTL_chk_lock
 18073 000029D2 740E                    	je	short GenIOCTL_lock_unlock
 18074 000029D4 80F94A                  	cmp	cl,4Ah			; LOCK LOGICAL VOLUME
 18075 000029D7 75A5                    	jne	short GenIOCTL_normal
 18076                                  ;GenIOCTL_chk_lock:
 18077                                  	;cmp	cl,4Ah			; LOCK LOGICAL VOLUME
 18078                                  	;jne	short GenIOCTL_lock_unlock
 18079 000029D9 80FF04                  	cmp	bh,4			; lock level (0-4)
 18080 000029DC 7404                    	je	short GenIOCTL_lock_unlock
 18081 000029DE 08FF                    	or	bh,bh
 18082 000029E0 75E8                    	jnz	short ioctl_bad_fun
 18083                                  GenIOCTL_lock_unlock:
 18084 000029E2 8A1E[B103]              	mov	bl,[IOCTL_drvnum]	; drive number (1=A:, 2=B: ..)
 18085 000029E6 30FF                    	xor	bh,bh
 18086 000029E8 4B                      	dec	bx
 18087 000029E9 80FB1A                  	cmp	bl,26			; logical disk number limit
 18088 000029EC 73DC                    	jnb	short ioctl_bad_fun
 18089 000029EE 80F96A                  	cmp	cl,6Ah			; UNLOCK LOGICAL VOLUME
 18090 000029F1 7507                    	jne	short GenIOCTL_lock
 18091 000029F3 80A7[2F14]7F            	and	byte [bx+drive_flags],7Fh ; UNLOCK
 18092 000029F8 EB05                    	jmp	short GenIOCTL_OK
 18093                                  GenIOCTL_lock:
 18094 000029FA 808F[2F14]80            	or	byte [bx+drive_flags],80h ; LOCK
 18095                                  GenIOCTL_OK:
 18096 000029FF E96EDC                  	jmp	SYS_RET_OK
 18097                                  
 18098                                  ;---------------------------------------------------------------------------
 18099                                  ;
 18100                                  ; IOCTL: AL = 8
 18101                                  ;
 18102                                  ; ENTRY: DS = DOSDATA
 18103                                  ;
 18104                                  ; BUGBUG: Don't push anything on the stack between ioctl_rem_media: and 
 18105                                  ;         the call to Check_If_Net because Check_If_Net gets our
 18106                                  ;         return address off the stack if the drive is invalid.
 18107                                  ;
 18108                                  ;-------------------------------------------------------------------------
 18109                                  
 18110                                  	; 30/01/2024
 18111                                  ioctl_rem_media:
 18112                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18113 00002A02 E83001                  	CALL	Check_If_Net
 18114 00002A05 75C3                    	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
 18115                                  					;   certainly don't know how to do this
 18116                                  					;   call.
 18117                                  	;test	word [es:di+4],800h
 18118                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL ; See if device can
 18119                                  	;test	byte [es:di+5],8
 18120 00002A07 26F6450508              	TEST	byte [es:di+SYSDEV.ATT+1],(DEVOPCL>>8)
 18121 00002A0C 74BC                    	JZ	short ioctl_bad_fun		; NO
 18122                                  
 18123                                  ;hkn; SS override for IOCALL
 18124                                  	; 30/01/2024
 18125                                  	; ds = ss = DOSDATA segment ('Get_Driver_BL' in 'Check_If_Net')
 18126                                  	;MOV	byte [SS:IOCALL_REQFUNC],DEVRMD ; 15
 18127 00002A0E C606[7E03]0F            	mov	byte [IOCALL_REQFUNC],DEVRMD ; 15
 18128 00002A13 B00D                    	MOV	AL,REMHL  ; 13
 18129 00002A15 88DC                    	MOV	AH,BL			; Unit number
 18130                                  	;MOV	[SS:IOCALL_REQLEN],AX
 18131 00002A17 A3[7C03]                	mov	[IOCALL_REQLEN],ax	
 18132 00002A1A 31C0                    	XOR	AX,AX
 18133                                  	;MOV	[SS:IOCALL_REQSTAT],AX
 18134 00002A1C A3[7F03]                	mov	[IOCALL_REQSTAT],ax ; 0
 18135                                  	
 18136 00002A1F 06                      	PUSH	ES
 18137 00002A20 1F                      	POP	DS
 18138 00002A21 89FE                    	MOV	SI,DI			; DS:SI -> driver
 18139 00002A23 16                      	PUSH	SS
 18140 00002A24 07                      	POP	ES
 18141                                  
 18142                                  ;hkn; IOCALL is in DOSDATA (msconst.asm)
 18143                                  	; 30/01/2024
 18144                                  	; (ds <> ss, ss = DOSDATA segment)
 18145 00002A25 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 18146 00002A28 1E                      	push	ds
 18147 00002A29 56                      	push	si
 18148 00002A2A E82326                  	call	DEVIOCALL2
 18149 00002A2D 5E                      	pop	si
 18150 00002A2E 1F                      	pop	ds
 18151                                  
 18152                                  ;hkn; SS override
 18153 00002A2F 36A1[7F03]              	MOV	AX,[SS:IOCALL_REQSTAT]	; Get Status word
 18154                                  	;AND	AX,STBUI ; 200h		; Mask to busy bit
 18155                                  	; 29/01/2024
 18156 00002A33 80E402                  	and	ah,STBUI>>8 ; 2
 18157 00002A36 B109                    	MOV	CL,9
 18158 00002A38 D3E8                    	SHR	AX,CL			; Busy bit to bit 0
 18159                                  ioctl_da_ok_j:	; 11/11/2022
 18160 00002A3A E933DC                  	jmp	SYS_RET_OK
 18161                                  
 18162                                  	; 29/01/2024
 18163                                  ;--------------------------------------------------------------------------
 18164                                  ;
 18165                                  ; IOCTL: AL = B
 18166                                  ;
 18167                                  ; ENTRY: DS = DOSDATA
 18168                                  ;
 18169                                  ;--------------------------------------------------------------------------
 18170                                  
 18171                                  Set_Retry_Parameters:
 18172                                  	; 09/09/2018
 18173 00002A3D 890E[1C00]              	MOV	[RetryLoop],CX		; 0 retry loop count allowed
 18174 00002A41 09D2                    	OR	DX,DX			; zero retries not allowed
 18175 00002A43 7485                    	JZ	short ioctl_bad_fun
 18176                                  	; 29/01/2024
 18177                                  	;jnz	short set_new_retry_cnt
 18178                                  	;jmp	ioctl_bad_fun
 18179                                  ;set_new_retry_cnt:
 18180 00002A45 8916[1A00]              	MOV	[RetryCount],DX		; Set new retry count
 18181                                  doneok:
 18182                                  	;jmp	SYS_RET_OK		; Done
 18183                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18184                                  	;jmp	short ioctl_status_ret
 18185                                  	; 16/12/2022
 18186                                  	;jmp	short ioctl_ok	 ; jmp SYS_RET_OK
 18187                                  	; 29/01/2024
 18188 00002A49 EBEF                    	jmp	short ioctl_da_ok_j
 18189                                  
 18190                                  ;-------------------------------------------------------------------------
 18191                                  ;
 18192                                  ; IOCTL: AL = 9
 18193                                  ;
 18194                                  ; ENTRY: DS = DOSDATA
 18195                                  ;
 18196                                  ;-------------------------------------------------------------------------
 18197                                  
 18198                                  	; 30/01/2024 - Retro DOS v5.0
 18199                                  
 18200                                  ioctl_drive_attr:
 18201                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18202 00002A4B 88D8                    	mov	al,bl
 18203 00002A4D E8604A                  	call	GETTHISDRV
 18204 00002A50 723E                    	jc	short ioctl_drv_err
 18205 00002A52 E8B500                  	call	Get_Driver_BL
 18206                                  	; MSDOS 6.0
 18207 00002A55 7239                    	JC	short ioctl_drv_err	; drive not valid
 18208                                  
 18209                                  	; 30/01/2024 - Retro DOS v5.0
 18210                                  	; 30/01/2024 - PCDOS 7.1 IBMDOS.COM
 18211                                  	;;;
 18212                                  	;mov	dx,942h		; 0942h -> Attribute word
 18213                                  	;			; bit 11 - open/close/remmedia calls supported
 18214                                  	;			; bit 8 - (new type driver)
 18215                                  	;			; bit 6 - Generic IOCTL call supported
 18216                                  	;			; bit 1 - driver supports 32-bit sector addressing
 18217                                  	;jnz     short ioctl_drive_attr2 ; NET device
 18218                                  			; 30/01/2024
 18219                                  			; NOTE: 'jnz' condition is correct for Windows ME
 18220                                  			; 'Get_Driver_BL ' because it tests bit 0 of [drive_flags] 	
 18221                                  			; but in PCDOS 7.1 'Get_Driver_BL', this flag
 18222                                  			;	 (remote or removable? disk flag) is not tested
 18223                                  			; the last test is net device test)
 18224                                  	;;;;
 18225                                  
 18226                                  	;mov	dx,[es:di+4]
 18227 00002A57 268B5504                	mov	dx,[es:di+SYSDEV.ATT]	
 18228                                  				; get device attribute word
 18229                                  ;ioctl_drive_attr2: ; 30/01/2024
 18230 00002A5B 88C3                    	MOV	BL,AL		; Phys letter to BL (A=0)
 18231                                  
 18232                                  ;hkn; SS override
 18233                                  	; 30/01/2024
 18234                                  	; (MSDOS 6.22 IO.SYS - DOSCODE:62B8h)
 18235                                  	; (PCDOS 7.1 IBMDOS.COM - DOSCODE:69DBh)
 18236                                  	;LES	DI,[SS:THISCDS]	; NOTE: PCDOS 7.1 has bug here,
 18237                                  				; ds must be same with ss here...
 18238                                  				; because there is 'les di, [ds:THISCDS]' in
 18239                                  				; Get_Driver_BL
 18240                                  				; and a second 'test byte ptr es:[ di+44h],80h'
 18241                                  				; is not necessary; also its result (jnz)
 18242                                  				; overwrites DS. /// Erdogan Tan - 30/01/2024
 18243                                  	; 30/01/2024
 18244                                  	; Retro DOS v5.0
 18245                                  	; (Windows ME IO.SYS - BIOSCODE:67ABh)
 18246 00002A5D C43E[A205]              	les	di,[THISCDS] 
 18247                                  
 18248                                  	;test	word [es:di+43h],8000h
 18249                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 18250                                  	;test	byte [es:di+44h],80h
 18251 00002A61 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 18252 00002A66 7403                    	JZ	short IOCTLShare
 18253                                  
 18254                                  	;or	dx,1000h ; (MSDOS 3.3)
 18255                                  
 18256                                  ;	Net devices don't return a device attribute word.
 18257                                  ;	Bit 12 = 1, meaning net device, all others = 0.
 18258                                  
 18259 00002A68 BA0010                  	MOV	DX,1000h ; MSDOS 6.0
 18260                                  
 18261                                  IOCTLShare:
 18262                                  	; 30/01/2024
 18263                                  	; ds = ss = DOSDATA segment
 18264                                  	;push	ss
 18265                                  	;pop	ds
 18266                                  	
 18267 00002A6B BE[BE03]                	MOV	SI,OPENBUF
 18268 00002A6E 80C341                  	ADD	BL,"A"	; 41h
 18269 00002A71 881C                    	MOV	[SI],BL
 18270 00002A73 C744013A00              	MOV	WORD [SI+1],003AH ; ":",0
 18271 00002A78 B80003                  	MOV	AX,0300h
 18272 00002A7B F8                      	CLC
 18273                                  	;INT	int_IBM
 18274 00002A7C CD2A                    	int     2Ah	; Microsoft Networks - CHECK DIRECT I/O
 18275                                  			; DS:SI -> ASCIZ disk device name 
 18276                                  			; (may be full path or only drive
 18277                                  			; specifier--must include the colon)
 18278                                  			; Return: CF clear if absolute disk access allowed
 18279 00002A7E 7303                    	JNC	short IOCTLLocal	; Not shared
 18280                                  	;OR	DX,0200H		; Shared, bit 9
 18281                                  	; 17/12/2022
 18282 00002A80 80CE02                  	or	dh,02h
 18283                                  IOCTLLocal:
 18284                                  	;test	word [es:di+43h],1000h
 18285                                  	;TEST	word [ES:DI+curdir.flags],curdir_local
 18286                                  	;test	byte [es:di+44h],10h
 18287 00002A83 26F6454410              	TEST	byte [ES:DI+curdir.flags+1],(curdir_local>>8)
 18288                                  	;JZ	short ioctl_set_DX
 18289                                  	; 16/12/2022
 18290 00002A88 7403                    	jz	short _ioctl_set_DX
 18291                                  	;OR	DX,8000h
 18292                                  	; 17/12/2022
 18293 00002A8A 80CE80                  	or	dh,80h
 18294                                  ;ioctl_set_DX:
 18295                                  _ioctl_set_DX:
 18296                                  	; 16/12/2022
 18297 00002A8D E977FE                  	jmp	ioctl_set_dx
 18298                                  ; 16/12/2022
 18299                                  %if 0	
 18300                                  	call	Get_User_Stack
 18301                                  	MOV	[SI+user_env.user_DX],DX
 18302                                  	;;jmp	SYS_RET_OK
 18303                                  	;; 25/06/2019
 18304                                  	;jmp	SYS_RET_OK_clc
 18305                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18306                                  ioctl_gd_ok_j:
 18307                                  	jmp	short ioctl_da_ok_j
 18308                                  %endif
 18309                                  
 18310                                  ioctl_drv_err:
 18311 00002A90 B00F                    	mov	al,error_invalid_drive ; 0Fh
 18312                                  ioctl_gd_err_j:	; 11/11/2022
 18313 00002A92 E9E5DB                  	jmp	SYS_RET_ERR
 18314                                  
 18315                                  ;--------------------------------------------------------------------------
 18316                                  ;
 18317                                  ; IOCTL: AL = A
 18318                                  ;
 18319                                  ; ENTRY: DS = DOSDATA
 18320                                  ;
 18321                                  ;--------------------------------------------------------------------------
 18322                                  
 18323                                  ioctl_handle_redir:
 18324 00002A95 E8F445                  	call	SFFromHandle		; ES:DI -> SFT
 18325 00002A98 7303                    	JNC	short ioctl_got_sft	; have valid handle
 18326 00002A9A E92EFE                  	jmp	ioctl_bad_handle ; 10/08/2018
 18327                                  
 18328                                  ioctl_got_sft:
 18329                                  	;mov	dx,[es:di+5]
 18330 00002A9D 268B5505                	MOV	DX,[ES:DI+SF_ENTRY.sf_flags] ; Get flags
 18331                                  	;JMP	short ioctl_set_DX	; pass dx to user and return
 18332                                  	; 16/12/2022
 18333 00002AA1 EBEA                    	jmp	short _ioctl_set_DX
 18334                                  
 18335                                  	; 16/12/2022
 18336                                  ;ioctl_bad_funj:
 18337                                  	;JMP	ioctl_bad_fun
 18338                                  
 18339                                  ;--------------------------------------------------------------------------
 18340                                  ;
 18341                                  ; IOCTL: AL= 4,5
 18342                                  ;
 18343                                  ; ENTRY: DS = DOSDATA
 18344                                  ;	 SI = user's DS
 18345                                  ;
 18346                                  ;
 18347                                  ; BUGBUG: Don't push anything on the stack between ioctl_get_dev: and 
 18348                                  ;         the call to Check_If_Net because Check_If_Net gets our
 18349                                  ;         return address off the stack if the drive is invalid.
 18350                                  ;
 18351                                  ;-------------------------------------------------------------------------
 18352                                  
 18353                                  	; 30/01/2024 - Retro DOS v5.0
 18354                                  
 18355                                  ioctl_get_dev:
 18356 00002AA3 E88F00                  	CALL	Check_If_Net
 18357                                  	;JNZ	short ioctl_bad_funj	; There are no "net devices", and they
 18358                                  					; certainly don't know how to do this
 18359                                  					; call.
 18360                                  	; 16/12/2022
 18361 00002AA6 7403                    	jz	short ioctl_do_string
 18362                                  ioctl_bad_funj:
 18363 00002AA8 E91FFF                  	JMP	ioctl_bad_fun
 18364                                  
 18365                                  ioctl_do_string:
 18366                                  	;test	word [es:di+4],4000h
 18367                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVIOCTL; See if device accepts control
 18368                                  	;test	byte [es:di+5],40h
 18369 00002AAB 26F6450540              	TEST	byte [ES:DI+SYSDEV.ATT+1],(DEVIOCTL>>8)
 18370 00002AB0 74F6                    	JZ	short ioctl_bad_funj		; NO
 18371                                  					; assume IOCTL read
 18372 00002AB2 C606[7E03]03            	MOV	byte [IOCALL_REQFUNC],DEVRDIOCTL  ; 3
 18373                                  
 18374 00002AB7 A801                    	TEST	AL,1			; is it func. 4/5 or 2/3
 18375 00002AB9 7405                    	JZ	short ioctl_control_call ; it is read. goto ioctl_control_call
 18376                                  
 18377                                  					; it is an IOCTL write
 18378 00002ABB C606[7E03]0C            	MOV	byte [IOCALL_REQFUNC],DEVWRIOCTL ; 12
 18379                                  
 18380                                  ioctl_control_call:
 18381                                  	; 30/01/2024
 18382 00002AC0 B016                    	MOV	AL,DRDWRHL ; 22	; MSDOS 6.22 MSDOS.SYS, Windows ME IO.SYS
 18383                                  	;mov	al,20 ; PCDOS 7.1 IBMDOS.COM
 18384                                  ioctl_setup_pkt:
 18385 00002AC2 88DC                    	MOV	AH,BL			; Unit number
 18386 00002AC4 A3[7C03]                	MOV	[IOCALL_REQLEN],AX
 18387 00002AC7 31C0                    	XOR	AX,AX
 18388 00002AC9 A3[7F03]                	MOV	[IOCALL_REQSTAT],AX ; 0
 18389 00002ACC A2[8903]                	MOV	[IOMED],AL
 18390 00002ACF 890E[8E03]              	MOV	[IOSCNT],CX
 18391 00002AD3 8916[8A03]              	MOV	[IOXAD],DX
 18392 00002AD7 8936[8C03]              	MOV	[IOXAD+2],SI
 18393 00002ADB 06                      	PUSH	ES
 18394 00002ADC 1F                      	POP	DS
 18395 00002ADD 89FE                    	MOV	SI,DI			; DS:SI -> driver
 18396 00002ADF 16                      	PUSH	SS
 18397 00002AE0 07                      	POP	ES
 18398                                  
 18399 00002AE1 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 18400                                  ioctl_do_IO:
 18401 00002AE4 E86925                  	call	DEVIOCALL2
 18402                                  
 18403                                  ;hkn; SS override for IOCALL
 18404                                  	;test	word [SS:IOCALL_REQSTAT],8000h
 18405                                  	;TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
 18406                                  	;test	byte [SS:IOCALL_REQSTAT+1],80h
 18407 00002AE7 36F606[8003]80          	TEST	byte [SS:IOCALL_REQSTAT+1],(STERR>>8)
 18408 00002AED 7507                    	JNZ	short ioctl_string_err
 18409                                  
 18410                                  ;hkn; SS override
 18411 00002AEF 36A1[8E03]              	MOV	AX,[SS:IOSCNT]		; Get actual bytes transferred
 18412                                  	; 16/12/2022
 18413 00002AF3 E97ADB                  	jmp	SYS_RET_OK
 18414                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18415                                  	;jmp	short ioctl_gd_ok_j
 18416                                  
 18417                                  ioctl_string_err:
 18418 00002AF6 368B3E[7F03]            	MOV	DI,[SS:IOCALL_REQSTAT]	;Get Error
 18419                                  device_err:
 18420 00002AFB 81E7FF00                	AND	DI,STECODE ; 00FFh	; mask out irrelevant bits
 18421 00002AFF 89F8                    	MOV	AX,DI
 18422 00002B01 E8DB33                  	call	SET_I24_EXTENDED_ERROR
 18423                                  
 18424                                  ;hkn; use SS override
 18425                                  ;hkn;	mov	ax,[CS:EXTERR]
 18426 00002B04 36A1[2403]              	mov	ax,[SS:EXTERR]
 18427                                  	;jmp	SYS_RET_ERR
 18428                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18429 00002B08 EB88                    	jmp	short ioctl_gd_err_j
 18430                                  
 18431                                  ; 17/05/2019 - Retro DOS v4.0
 18432                                  
 18433                                  ;--------------------------------------------------------------------------
 18434                                  ; Proc name : Get_Driver_BL
 18435                                  ;
 18436                                  ;	DS is DOSDATA
 18437                                  ;	BL is drive number (0=default)
 18438                                  ;	Returns pointer to device in ES:DI, unit number in BL if carry clear
 18439                                  ;	No regs modified
 18440                                  ;
 18441                                  ;---------------------------------------------------------------------------
 18442                                  
 18443                                  	; 30/01/2024 - Retro DOS v5.0
 18444                                  
 18445                                  Get_Driver_BL:
 18446 00002B0A 50                      	PUSH	AX
 18447 00002B0B 88D8                    	MOV	AL,BL			; Drive
 18448 00002B0D E8A049                  	call	GETTHISDRV
 18449 00002B10 7221                    	jc	short ioctl_bad_drv
 18450 00002B12 30DB                    	XOR	BL,BL			; Unit zero on Net device
 18451 00002B14 C606[2303]03            	MOV	byte [EXTERR_LOCUS],errLOC_Net ; 3
 18452 00002B19 C43E[A205]              	LES	DI,[THISCDS]
 18453                                  	;test	word [es:di+43h],8000h
 18454                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 18455                                  	;test	byte [es:di+44h],80h
 18456 00002B1D 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 18457                                  	;les	di,[es:di+45h]
 18458 00002B22 26C47D45                	LES	DI,[ES:DI+curdir.devptr] ; ES:DI -> Dpb or net dev
 18459 00002B26 750B                    	JNZ	short got_dev_ptr	 ; Is net
 18460                                  	;;;
 18461                                  	; 30/01/2024 - PCDOS 7.1 IBMDOS.COM
 18462                                  	;MOV	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 18463 00002B28 E8D3E7                  	call	set_exerr_locus_disk
 18464                                  	;;;
 18465                                  	;mov	bl,[es:di+1]
 18466 00002B2B 268A5D01                	MOV	BL,[ES:DI+DPB.UNIT]	; Unit number
 18467                                  	;les	di,[es:di+13h]
 18468 00002B2F 26C47D13                	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Driver addr
 18469                                  got_dev_ptr:
 18470                                  	; 30/01/2024
 18471                                  	; cf=0
 18472                                  	;CLC
 18473                                  ioctl_bad_drv:
 18474 00002B33 58                      	POP	AX
 18475 00002B34 C3                      	retn
 18476                                  
 18477                                  ;-------------------------------------------------------------------------
 18478                                  ; Proc Name : Check_If_Net:
 18479                                  ;
 18480                                  ;
 18481                                  ; Checks if the device is over the net or not. Returns result in ZERO flag.
 18482                                  ; If no device is found, the return address is popped off the stack, and a
 18483                                  ; jump is made to ioctl_drv_err.
 18484                                  ;
 18485                                  ; On Entry:
 18486                                  ; Registers same as those for Get_Driver_BL
 18487                                  ;
 18488                                  ; On Exit:
 18489                                  ; ZERO flag	- set if not a net device
 18490                                  ;		- reset if net device
 18491                                  ; ES:DI -> the device
 18492                                  ;
 18493                                  ;
 18494                                  ; BUGBUG: This function assumes the following stack setup on entry
 18495                                  ;
 18496                                  ;	  SP+2 -> Error return address
 18497                                  ;	  SP   -> Normal return address
 18498                                  ;
 18499                                  ;-------------------------------------------------------------------------
 18500                                  
 18501                                  	; 30/01/2024 - Retro DOS v5.0
 18502                                  	; MSDOS 6.22 MSDOS.SYS - DOSCODE:639Ch
 18503                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:6A91h
 18504                                  	; Windows ME IO.SYS - BIOSCODE:68E1h
 18505                                  
 18506                                  Check_If_Net:
 18507                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18508 00002B35 E8D2FF                  	CALL	Get_Driver_BL
 18509 00002B38 7201                    	JC	short ioctl_drv_err_pop	; invalid drive letter
 18510                                  
 18511                                  ; 30/01/2024 ('Get_Driver_BL' returns with
 18512                                  ;	      'curdir_isnet' condition/ZF, no need to a second test)
 18513                                  %if 0
 18514                                  	;;;
 18515                                  	; (PCDOS 7.1 IBMDOS.COM, Windows ME IO.SYS)
 18516                                  	PUSH	ES
 18517                                  	PUSH	DI
 18518                                  	LES	DI,[THISCDS]
 18519                                  	;test	word [es:di+43h],8000h
 18520                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 18521                                  	;test	byte [es:di+44h],80h
 18522                                  	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 18523                                  	POP	DI
 18524                                  	POP	ES
 18525                                  	;;;
 18526                                  %endif
 18527 00002B3A C3                      	retn
 18528                                  
 18529                                  ioctl_drv_err_pop:
 18530 00002B3B 58                      	pop	ax			; pop off return address
 18531 00002B3C E951FF                  	jmp	ioctl_drv_err
 18532                                  
 18533                                  ioctl_bad_funj3:
 18534 00002B3F E988FE                  	jmp	ioctl_bad_fun
 18535                                  
 18536                                  ioctl_string_errj:
 18537 00002B42 EBB2                    	jmp	short ioctl_string_err  ; 25/05/2019
 18538                                  
 18539                                  ;--------------------------------------------------------------------------
 18540                                  ;
 18541                                  ; IOCTL: AL = E, F
 18542                                  ;
 18543                                  ; ENTRY: DS = DOSDATA
 18544                                  ;
 18545                                  ;
 18546                                  ; BUGBUG: Don't push anything on the stack between ioctl_drive_owner: and 
 18547                                  ;         the call to Check_If_Net because Check_If_Net gets our
 18548                                  ;         return address off the stack if the drive is invalid.
 18549                                  ;
 18550                                  ;--------------------------------------------------------------------------
 18551                                  
 18552                                  ioctl_drive_owner:
 18553                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18554 00002B44 E8EEFF                  	Call	Check_If_Net
 18555 00002B47 75F6                    	JNZ	short ioctl_bad_funj3 	; There are no "net devices", and they
 18556                                  					;   certainly don't know how to do this
 18557                                  					;   call.
 18558                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEV320	; See if device can handle this
 18559                                  	; 09/09/2018
 18560                                  	;test	byte [es:di+4],40h
 18561 00002B49 26F6450440              	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
 18562 00002B4E 74EF                    	JZ	short ioctl_bad_funj3 	; NO
 18563                                  	;mov	byte [IOCALL_REQFUNC],23
 18564 00002B50 C606[7E03]17            	mov	byte [IOCALL_REQFUNC],DEVGETOWN	; default to get owner
 18565 00002B55 3C0E                    	cmp	al,0Eh			; Get Owner ?
 18566 00002B57 7405                    	jz	short GetOwner
 18567                                  SetOwner:
 18568 00002B59 C606[7E03]18            	MOV	byte [IOCALL_REQFUNC],DEVSETOWN ; 24
 18569                                  GetOwner:
 18570 00002B5E B00D                    	MOV	AL,OWNHL ; 13
 18571 00002B60 88DC                    	MOV	AH,BL			; Unit number
 18572 00002B62 A3[7C03]                	MOV	[IOCALL_REQLEN],AX
 18573 00002B65 31C0                    	XOR	AX,AX
 18574 00002B67 A3[7F03]                	MOV	[IOCALL_REQSTAT],AX
 18575 00002B6A 06                      	PUSH	ES
 18576 00002B6B 1F                      	POP	DS
 18577 00002B6C 89FE                    	MOV	SI,DI			; DS:SI -> driver
 18578 00002B6E 16                      	PUSH	SS
 18579 00002B6F 07                      	POP	ES
 18580 00002B70 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 18581 00002B73 1E                      	push	ds
 18582 00002B74 56                      	push	si
 18583 00002B75 E8D824                  	call	DEVIOCALL2
 18584 00002B78 5E                      	pop	si
 18585 00002B79 1F                      	pop	ds
 18586                                  ;hkn; SS override
 18587                                  	;TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
 18588                                  	;test	byte [SS:IOCALL_REQSTAT+1],80h
 18589 00002B7A 36F606[8003]80          	TEST	byte [SS:IOCALL_REQSTAT+1],(STERR>>8)
 18590 00002B80 75C0                    	jnz	short ioctl_string_errj
 18591 00002B82 36A0[7D03]              	MOV	AL,[SS:IOCALL_REQUNIT]	; Get owner returned by device
 18592                                  					; owner returned is 1-based.
 18593 00002B86 E9E7DA                  	jmp	SYS_RET_OK
 18594                                  
 18595                                  ;============================================================================
 18596                                  ; DELETE.ASM, MSDOS 6.0, 1991
 18597                                  ;============================================================================
 18598                                  ; 07/08/2018 - Retro DOS v3.0
 18599                                  ; 17/05/2019 - Retro DOS v4.0
 18600                                  
 18601                                  ;	TITLE	DOS_DELETE - Internal DELETE call for MS-DOS
 18602                                  ;	NAME	DOS_DELETE
 18603                                  
 18604                                  ;
 18605                                  ;	Microsoft Confidential
 18606                                  ;	Copyright (C) Microsoft Corporation 1991
 18607                                  ;	All Rights Reserved.
 18608                                  ;
 18609                                  
 18610                                  ;**	DELETE.ASM - Low level routine for deleting files
 18611                                  ;----------------------------------------------------------------------------
 18612                                  ;		DOS_DELETE
 18613                                  ;		REN_DEL_Check
 18614                                  ;		FastOpen_Delete	       ; DOS 3.3
 18615                                  ;		FastOpen_Update	       ; DOS 3.3
 18616                                  
 18617                                  ;   Revision history:
 18618                                  ;
 18619                                  ;   A000  version 4.00	Jan. 1988
 18620                                  ;   A001  Fastopen Rename fix	April 1989
 18621                                  
 18622                                  ;Installed = TRUE
 18623                                  
 18624                                  ;	i_need	NoSetDir,BYTE
 18625                                  ;	i_need	Creating,BYTE
 18626                                  ;	i_need	DELALL,BYTE
 18627                                  ;	i_need	THISDPB,DWORD
 18628                                  ;	i_need	THISSFT,DWORD
 18629                                  ;	i_need	THISCDS,DWORD
 18630                                  ;	i_need	CURBUF,DWORD
 18631                                  ;	i_need	ATTRIB,BYTE
 18632                                  ;	i_need	SATTRIB,BYTE
 18633                                  ;	i_need	WFP_START,WORD
 18634                                  ;	i_need	REN_WFP,WORD			 ;BN001
 18635                                  ;	i_need	NAME1,BYTE			 ;BN001
 18636                                  ;	i_need	FoundDel,BYTE
 18637                                  ;	i_need	AUXSTACK,BYTE
 18638                                  ;	i_need	VOLCHNG_FLAG,BYTE
 18639                                  ;	i_need	JShare,DWORD
 18640                                  ;	i_need	FastOpenTable,BYTE		  ; DOS 3.3
 18641                                  ;	i_need	FastTable,BYTE			  ; DOS 4.00
 18642                                  ;
 18643                                  ;	i_need	Del_ExtCluster,WORD		  ; DOS 4.00
 18644                                  ;
 18645                                  ;	i_need	SAVE_BX,WORD			  ; DOS 4.00
 18646                                  ;	i_need	DMAADD,DWORD
 18647                                  ;	i_need	RENAMEDMA,BYTE
 18648                                  
 18649                                  ;----------------------------------------------------------------------------
 18650                                  ;
 18651                                  ; Procedure Name : DOS_DELETE
 18652                                  ;
 18653                                  ; Inputs:
 18654                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 18655                                  ;		terminated)
 18656                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 18657                                  ;		( = -1 if current dir not involved, else
 18658                                  ;		 Points to first char after last "/" of current dir part)
 18659                                  ;	[THISCDS] Points to CDS being used
 18660                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 18661                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 18662                                  ; Function:
 18663                                  ;	Delete the specified file(s)
 18664                                  ; Outputs:
 18665                                  ;	CARRY CLEAR
 18666                                  ;		OK
 18667                                  ;	CARRY SET
 18668                                  ;	    AX is error code
 18669                                  ;		error_file_not_found
 18670                                  ;			Last element of path not found
 18671                                  ;		error_path_not_found
 18672                                  ;			Bad path (not in curr dir part if present)
 18673                                  ;		error_bad_curr_dir
 18674                                  ;			Bad path in current directory part of path
 18675                                  ;		error_access_denied
 18676                                  ;			Attempt to delete device or directory
 18677                                  ;		***error_sharing_violation***
 18678                                  ;			Deny both access required, generates an INT 24.
 18679                                  ;			This error is NOT returned. The INT 24H is generated,
 18680                                  ;			  and the file is ignored (not deleted). Delete will
 18681                                  ;			  simply continue on looking for more files.
 18682                                  ;			  Carry will NOT be set in this case.
 18683                                  ; DS preserved, others destroyed
 18684                                  ;
 18685                                  ;----------------------------------------------------------------------------
 18686                                  
 18687                                  FILEFOUND   equ 01h
 18688                                  FILEDELETED equ 10h
 18689                                  
 18690                                  	; 12/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 18691                                  	; DOSCODE:63E9h (MSDOS 5.0, MSDOS.SYS)
 18692                                  
 18693                                  	; 30/01/2024 - Retro DOS v5.0 (Modified MSDOS 5.0 IBMDOS.COM)
 18694                                  	; DOSCODE:6B11h (PCDOS 7.1, IBMDOS.COM)
 18695                                  
 18696                                  DOS_DELETE:
 18697                                  
 18698                                  ;hkn; DOS_Delete is called from file.asm and fcbio.asm. DS has been set up 
 18699                                  ;hkn; appropriately at this point.
 18700                                  
 18701 00002B89 E8B5EC                  	call	TestNet
 18702 00002B8C 7306                    	JNC	short LOCAL_DELETE
 18703                                  
 18704                                  ;IF NOT Installed
 18705                                  ;	transfer NET_DELETE
 18706                                  ;ELSE
 18707                                  	;MOV	AX,(MultNET SHL 8) | 19
 18708                                  	;INT	2FH
 18709                                  	;return
 18710                                  
 18711 00002B8E B81311                  	mov	ax,1113h
 18712 00002B91 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
 18713                                  			; SS = DS = DOS CS, SDA first filename pointer -> 
 18714                                  			;		fully-qualified filename in DOS CS
 18715                                  			; SDA CDS pointer -> current directory structure for drive with file
 18716                                  			; Return: CF set on error
 18717 00002B93 C3                      	retn
 18718                                  ;ENDIF
 18719                                  
 18720                                  LOCAL_DELETE:
 18721 00002B94 C606[6F05]00            	MOV	byte [FOUNDDEL],0	; No files found and no files deleted
 18722 00002B99 E867ED                  	call	ECritDisk
 18723                                  	;mov	word [CREATING],0E500h
 18724 00002B9C C706[7E05]00E5          	MOV	WORD [CREATING],DIRFREE*256+0 ; Assume not del *.*
 18725 00002BA2 8B36[B205]              	MOV	SI,[WFP_START]
 18726                                  SKPNUL:
 18727 00002BA6 AC                      	LODSB
 18728 00002BA7 08C0                    	OR	AL,AL
 18729 00002BA9 75FB                    	JNZ	short SKPNUL		; go to end
 18730 00002BAB 83EE04                  	SUB	SI,4			; Back over possible "*.*"
 18731 00002BAE 813C2A2E                	CMP	WORD [SI],2E2Ah ; "*."
 18732 00002BB2 7506                    	JNZ	short TEST_QUEST
 18733 00002BB4 807C022A                	CMP	BYTE [SI+2],"*"
 18734 00002BB8 741F                    	JZ	short CHECK_ATTS
 18735                                  TEST_QUEST:
 18736 00002BBA 83EE09                  	SUB	SI,9		; Back over possible "????????.???"
 18737 00002BBD 87FE                    	XCHG	DI,SI
 18738                                  
 18739 00002BBF 16                      	push	ss
 18740                                  	;pop	ds ; ! Retro DOS v3.0 BUG !
 18741 00002BC0 07                      	pop	es ; 17/05/2019
 18742                                  
 18743 00002BC1 B83F3F                  	MOV	AX,"??" ; 3F3Fh
 18744 00002BC4 B90400                  	MOV	CX,4		; four sets of "??"
 18745 00002BC7 F3AF                    	REPE	SCASW
 18746 00002BC9 751C                    	JNZ	short NOT_ALL
 18747 00002BCB 87FE                    	XCHG	DI,SI
 18748 00002BCD AD                      	LODSW
 18749 00002BCE 3D2E3F                  	CMP	AX,3F2Eh ; ".?"
 18750 00002BD1 7514                    	JNZ	short NOT_ALL
 18751 00002BD3 AD                      	LODSW
 18752 00002BD4 3D3F3F                  	CMP	AX,"??"
 18753 00002BD7 750E                    	JNZ	short NOT_ALL
 18754                                  CHECK_ATTS:
 18755 00002BD9 A0[6D05]                	MOV	AL,[SATTRIB]
 18756                                  	;and	al,1Fh
 18757 00002BDC 241F                    	AND	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
 18758                                  					; Look only at hidden bits
 18759                                  	;cmp	al,1Fh
 18760 00002BDE 3C1F                    	CMP	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
 18761                                  					; All must be set
 18762 00002BE0 7505                    	JNZ	short NOT_ALL
 18763                                  
 18764                                  ; NOTE WARNING DANGER-----
 18765                                  ;    This DELALL stuff is not safe. It allows directories to be deleted.
 18766                                  ;	It should ONLY be used by FORMAT in the ROOT directory.
 18767                                  
 18768 00002BE2 C606[7F05]00            	MOV	byte [DELALL],0		; DEL *.* - flag deleting all
 18769                                  NOT_ALL:
 18770 00002BE7 C606[4C03]01            	MOV	byte [NoSetDir],1
 18771 00002BEC E8161D                  	call	GetPathNoSet
 18772 00002BEF 7312                    	JNC	short Del_found
 18773 00002BF1 750B                    	JNZ	short _bad_path
 18774 00002BF3 08C9                    	OR	CL,CL
 18775 00002BF5 7407                    	JZ	short _bad_path
 18776                                  No_file:
 18777 00002BF7 B80200                  	MOV	AX,error_file_not_found
 18778                                  ErrorReturn:
 18779 00002BFA F9                      	STC
 18780                                  	;call	LCritDisk
 18781                                  	;retn
 18782                                  	; 18/12/2022
 18783 00002BFB E932ED                  	jmp	LCritDisk
 18784                                  
 18785                                  _bad_path:
 18786 00002BFE B80300                  	MOV	AX,error_path_not_found
 18787 00002C01 EBF7                    	JMP	short ErrorReturn
 18788                                  
 18789                                  Del_found:
 18790 00002C03 750C                    	JNZ	short NOT_DIR		; Check for dir specified
 18791 00002C05 803E[7F05]00            	CMP	byte [DELALL],0		; DelAll = 0 allows delete of dir.
 18792 00002C0A 7405                    	JZ	short NOT_DIR
 18793                                  Del_access_err:
 18794 00002C0C B80500                  	MOV	AX,error_access_denied
 18795 00002C0F EBE9                    	JMP	short ErrorReturn
 18796                                  
 18797                                  NOT_DIR:
 18798 00002C11 08E4                    	OR	AH,AH			; Check if device name
 18799 00002C13 78F7                    	JS	short Del_access_err	; Can't delete I/O devices
 18800                                  
 18801                                  ; Main delete loop. CURBUF+2:BX points to a matching directory entry.
 18802                                  
 18803                                  DELFILE:
 18804 00002C15 800E[6F05]01            	OR	byte [FOUNDDEL],FILEFOUND ; file found, not deleted yet
 18805                                  
 18806                                  ; If we are deleting the Volume ID, then we set VOLUME_CHNG flag to make
 18807                                  ; DOS issue a build BPB call the next time this drive is accessed.
 18808                                  
 18809 00002C1A 1E                      	PUSH	DS
 18810 00002C1B 8A26[7F05]              	MOV	AH,[DELALL]
 18811 00002C1F C53E[E205]              	LDS	DI,[CURBUF]
 18812                                  	
 18813                                  ;hkn; SS override
 18814 00002C23 36F606[6B05]01          	TEST	byte [SS:ATTRIB],attr_read_only ; are we deleting RO files too?
 18815 00002C29 7509                    	JNZ	short DoDelete		; yes
 18816                                  
 18817 00002C2B F6470B01                	TEST	byte [BX+dir_entry.dir_attr],attr_read_only
 18818 00002C2F 7403                    	JZ	short DoDelete		; not read only
 18819                                  
 18820                                  	; 30/01/2024 (PCDOS 7.1 IBMDOS.COM)
 18821                                  Skip_it:
 18822 00002C31 1F                      	POP	DS
 18823 00002C32 EB57                    	JMP	SHORT DELNXT		; Skip it (Note ES:BP not set)
 18824                                  
 18825                                  DoDelete:
 18826 00002C34 E8AF00                  	call	REN_DEL_Check		; Sets ES:BP = [THISDPB]
 18827                                  	;JNC	short DEL_SHARE_OK
 18828                                  	;POP	DS
 18829                                  	;JMP	SHORT DELNXT		; Skip it
 18830                                  	; 30/01/2024
 18831 00002C37 72F8                    	jc	short Skip_it
 18832                                  
 18833                                  DEL_SHARE_OK:
 18834                                  	; 17/05/2019 - Retro DOS v4.0
 18835                                  	; MSDOS 6.0
 18836                                  	;test	byte [di+5],40h
 18837 00002C39 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 18838                                  					;LB. if already dirty		  ;AN000;
 18839 00002C3D 7507                    	JNZ	short yesdirty		;LB.  don't increment dirty count ;AN000;
 18840 00002C3F E82939                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 18841                                  	;or	byte [di+5],40h
 18842 00002C42 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty
 18843                                  yesdirty:
 18844 00002C46 8827                    	mov	[bx],ah 
 18845                                  	;MOV	[BX+dir_entry.dir_name],AH ; Put in E5H or 0
 18846                                  	;;;
 18847                                  	; 30/01/2024 - Retro DOS v5.0
 18848                                  	; (PCDOS 7.1 IBMDOS.COM)
 18849 00002C48 31DB                    	xor	bx,bx ; 0
 18850                                  	;cmp	[es:bp+0Fh],bx
 18851 00002C4A 26395E0F                	cmp	[es:bp+DPB.FAT_SIZE],bx ; 0
 18852 00002C4E 7503                    	jnz     short yesdirty_fc_1	;  not FAT32
 18853 00002C50 8B5CFA                  	mov     bx,[si-6]		;  high word of the first cluster (FAT32)
 18854                                  yesdirty_fc_1:
 18855                                  	;mov	[ss:CLUSTNUM_HW],bx 
 18856 00002C53 89DA                    	mov	dx,bx ; * ; 30/01/2024 - Retro DOS v5.0
 18857                                  	;;;
 18858                                  
 18859 00002C55 8B1C                    	MOV	BX,[SI] 		; Get firclus pointer
 18860 00002C57 1F                      	POP	DS
 18861                                  	;;;
 18862 00002C58 8916[EF0A]              	mov	[CLUSTNUM_HW],dx ; * ; 30/01/2024 - Retro DOS v5.0
 18863                                  	;;;
 18864 00002C5C 800E[6F05]10            	OR	byte [FOUNDDEL],FILEDELETED ; 10h ; Deleted file
 18865                                  
 18866                                  	; 30/01/2024
 18867                                  	;CMP	BX,2
 18868                                  	;JB	short DELNXT		; File has invalid FIRCLUS (too small)
 18869                                  	;;;
 18870                                  	; 30/01/2024 - Retro DOS v5.0
 18871                                  	; (PCDOS 7.1 IBMDOS.COM)
 18872                                  	;cmp	word [CLUSTNUM_HW],0
 18873 00002C61 21D2                    	and	dx,dx ; 30/01/2024 - Retro DOS v5.0
 18874 00002C63 7505                    	jnz	short yesdirty_fc_2
 18875 00002C65 83FB02                  	cmp	bx,2
 18876 00002C68 7221                    	jb	short DELNXT		; File has invalid FIRCLUS (too small)
 18877                                  yesdirty_fc_2:
 18878                                  	;cmp	word [es:bp+0Fh],0
 18879 00002C6A 26837E0F00              	cmp	word [es:bp+DPB.FAT_SIZE],0
 18880 00002C6F 750C                    	jnz     short yesdirty_fc_3	; not FAT32
 18881                                  	;push	bx
 18882                                  	;mov	bx,[CLUSTNUM_HW]
 18883                                  	;;cmp	bx,[es:bp+2Fh]
 18884                                  	;cmp	bx,[es:bp+DPB.LAST_CLUSTER+2]
 18885                                  	;30/01/2024 - Retro DOS v5.0
 18886                                  	;mov	dx,[CLUSTNUM_HW]
 18887                                  	; dx = [CLUSTNUM_HW] ; *
 18888 00002C71 263B562F                	cmp	dx,[es:bp+DPB.LAST_CLUSTER+2]
 18889                                  	;pop	bx
 18890 00002C75 750A                    	jne	short yesdirty_fc_4
 18891                                  	;cmp	bx,[es:bp+2Dh]
 18892 00002C77 263B5E2D                	cmp	bx,[es:bp+DPB.LAST_CLUSTER]
 18893 00002C7B EB04                    	jmp     short yesdirty_fc_4
 18894                                  yesdirty_fc_3:
 18895                                  	;;;
 18896                                  	;cmp	bx,[es:bp+0Dh]
 18897 00002C7D 263B5E0D                	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 18898                                  yesdirty_fc_4:	; 30/01/2024
 18899 00002C81 7708                    	JA	short DELNXT		; File has invalid FIRCLUS (too big)
 18900                                  
 18901 00002C83 E8192C                  	call	RELEASE 		; Free file data
 18902 00002C86 7258                    	JC	short No_fileJ
 18903                                  
 18904                                  ; DOS 3.3  FastOpen
 18905                                  
 18906 00002C88 E8D900                  	CALL	FastOpen_Delete 	; delete the dir info in fastopen
 18907                                  
 18908                                  ; DOS 3.3  FastOpen
 18909                                  
 18910                                  DELNXT:
 18911 00002C8B C42E[8A05]              	LES	BP,[THISDPB]		; Possible to get here without this set
 18912 00002C8F E8991A                  	call	GETENTRY		; Registers need to be reset
 18913 00002C92 724C                    	JC	short No_fileJ
 18914 00002C94 E8D219                  	call	NEXTENT
 18915                                  	;JNC	short DELFILE
 18916                                  	; 30/01/2024
 18917 00002C97 7203                    	jc	short DELNXT2
 18918 00002C99 E979FF                  	jmp	DELFILE
 18919                                  DELNXT2:
 18920 00002C9C C42E[8A05]              	LES	BP,[THISDPB]		; NEXTENT sets ES=DOSGROUP
 18921                                  	
 18922                                  	;;;
 18923                                  	; 30/01/2024 - Retro DOS v5.0
 18924                                  	; (PCDOS 7.1 IBMDOS.COM)
 18925                                  	;
 18926 00002CA0 E8EE07                  	call	update_fat32_fsinfo
 18927                                  	;;;
 18928                                  
 18929                                  	; 12/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18930                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 18931                                  	;;mov	al,[es:bp+0]
 18932                                  	; 15/12/2022
 18933 00002CA3 268A4600                	MOV	AL,[ES:BP]
 18934 00002CA7 E8B037                  	call	FLUSHBUF
 18935 00002CAA 7234                    	JC	short No_fileJ
 18936                                  ;
 18937                                  ; Now we need to test FoundDel for our flags. The cases to consider are:
 18938                                  ;
 18939                                  ;   not found not deleted		file not found
 18940                                  ;   not found	  deleted		*** impossible ***
 18941                                  ;	found not deleted		access denied (read-only)
 18942                                  ;	found	  deleted		no error
 18943                                  ;
 18944 00002CAC F606[6F05]10            	TEST	byte [FOUNDDEL],FILEDELETED ; did we delete a file?
 18945 00002CB1 7426                    	JZ	short DelError		; no, figure out what's wrong.
 18946                                  
 18947                                  ; We set VOLCHNG_FLAG to indicate that we have changed the volume label
 18948                                  ; and to force the DOS to issue a media check.
 18949                                  
 18950 00002CB3 F606[6B05]08            	TEST	byte [ATTRIB],attr_volume_id ; 8
 18951 00002CB8 741C                    	jz	short No_Set_Flag
 18952 00002CBA 50                      	PUSH	AX
 18953 00002CBB 06                      	PUSH	ES
 18954 00002CBC 57                      	PUSH	DI
 18955 00002CBD C43E[A205]              	LES	DI,[THISCDS]
 18956 00002CC1 268A25                  	MOV	AH,[ES:DI]		; Get drive
 18957 00002CC4 80EC41                  	SUB	AH,'A'                  ; Convert to 0-based
 18958 00002CC7 8826[A10A]              	mov	[VOLCHNG_FLAG],AH
 18959                                  	
 18960                                  	; MSDOS 6.0
 18961 00002CCB 30FF                    	XOR	BH,BH			;>32mb delete volume id from boot record ;AN000;
 18962 00002CCD E8EB04                  	call	Set_Media_ID		;>32mb set volume id to boot record	 ;AN000;
 18963                                  	 
 18964 00002CD0 E8E133                  	call	FATREAD_CDS		; force media check
 18965 00002CD3 5F                      	POP	DI
 18966 00002CD4 07                      	POP	ES
 18967 00002CD5 58                      	POP	AX
 18968                                  No_Set_Flag:
 18969                                  	;call	LCritDisk		; carry is clear
 18970                                  	;retn
 18971                                  	; 18/12/2022
 18972 00002CD6 E957EC                  	jmp	LCritDisk
 18973                                  DelError:
 18974 00002CD9 F606[6F05]01            	TEST	byte [FOUNDDEL],FILEFOUND ; not deleted. Did we find file?
 18975 00002CDE 7503                    	JNZ	short Del_access_errJ 	; yes. Access denied
 18976                                  No_fileJ:
 18977 00002CE0 E914FF                  	JMP	No_file ; 10/08/2018 		; Nope
 18978                                  Del_access_errJ:
 18979 00002CE3 E926FF                  	JMP	Del_access_err ; 10/08/2018
 18980                                  
 18981                                  ; 08/08/2018 - Retro DOS v3.0
 18982                                  
 18983                                  ;Break	<REN_DEL_Check - check for access for rename and delete>
 18984                                  ;---------------------------------------------------------------------------
 18985                                  ; Procedure Name : REN_DEL_Check
 18986                                  ;
 18987                                  ; Inputs:
 18988                                  ;	[THISDPB] set
 18989                                  ;	[CURBUF+2]:BX points to entry
 18990                                  ;	[CURBUF+2]:SI points to firclus field of entry
 18991                                  ;	[WFP_Start] points to name
 18992                                  ; Function:
 18993                                  ;	Check for Exclusive access on given file.
 18994                                  ;	  Used by RENAME, SET_FILE_INFO, and DELETE.
 18995                                  ; Outputs:
 18996                                  ;	ES:BP = [THISDPB]
 18997                                  ;	NOTE: The WFP string pointed to by [WFP_Start] Will be Modified. The
 18998                                  ;		last element will be loaded from the directory entry. This is
 18999                                  ;		so the name given to the sharer doesn't have any meta chars in
 19000                                  ;		it.
 19001                                  ;	Carry set if sharing violation, INT 24H generated
 19002                                  ;	    NOTE THAT AX IS NOT error_sharing_violation.
 19003                                  ;		This is because input AX is preserved.
 19004                                  ;		Caller must set the error if needed.
 19005                                  ;	Carry clear
 19006                                  ;		OK
 19007                                  ; AX,DS,BX,SI,DI preserved
 19008                                  ;---------------------------------------------------------------------------
 19009                                  
 19010                                  	; 31/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 19011                                  	
 19012                                  REN_DEL_Check:
 19013                                  
 19014 00002CE6 1E                      	PUSH	DS
 19015 00002CE7 57                      	PUSH	DI
 19016 00002CE8 50                      	PUSH	AX
 19017 00002CE9 53                      	PUSH	BX
 19018 00002CEA 56                      	PUSH	SI		; Save CURBUF pointers
 19019                                  	
 19020 00002CEB 16                      	push	ss
 19021 00002CEC 07                      	pop	es
 19022                                  
 19023                                  ;hkn; context ES will assume ES to DOSDATA
 19024                                  ;hkn; ASSUME	ES:DOSGROUP
 19025                                  
 19026                                  ;hkn; SS override
 19027 00002CED 368B3E[B205]            	MOV	DI,[SS:WFP_START] ; ES:DI -> WFP
 19028 00002CF2 89DE                    	MOV	SI,BX
 19029                                  
 19030                                  ;hkn; SS override
 19031 00002CF4 368E1E[E405]            	MOV	DS,[SS:CURBUF+2] ; DS:SI -> entry (FCB style name)
 19032 00002CF9 89FB                    	MOV	BX,DI		; Set backup limit for skipback
 19033                                  	;ADD	BX,2		; Skip over d: to point to leading '\'
 19034                                  	; 31/01/2024
 19035 00002CFB 43                      	inc	bx
 19036 00002CFC 43                      	inc	bx
 19037 00002CFD E8E1EA                  	call	StrLen		; CX is length of ES:DI including NUL
 19038 00002D00 49                      	DEC	CX		; Don't include nul in count
 19039 00002D01 01CF                    	ADD	DI,CX		; Point to NUL at end of string
 19040 00002D03 E8644A                  	call	SkipBack	; Back up one element
 19041 00002D06 47                      	INC	DI		; Point to start of last element
 19042                                  
 19043                                  	; 17/05/2019 - Retro DOS v4.0
 19044                                  ;hkn; SS override
 19045                                  	; MSDOS 6.0
 19046 00002D07 36893E[0106]            	MOV	[SS:SAVE_BX],DI	;IFS. save for DOS_RENAME   ;AN000;
 19047                                  	;
 19048 00002D0C E8C4F9                  	call	PackName	; Transfer name from entry to ASCIZ tail.
 19049 00002D0F 5E                      	POP	SI		; Get back entry pointers
 19050 00002D10 5B                      	POP	BX
 19051 00002D11 53                      	PUSH	BX
 19052 00002D12 56                      	PUSH	SI		; Back on stack
 19053                                  	
 19054 00002D13 16                      	push	ss
 19055 00002D14 1F                      	pop	ds
 19056                                  
 19057                                  ;hkn; context DS will assume ES to DOSDATA
 19058                                  ;hkn; ASSUME	DS:DOSGROUP
 19059                                  
 19060                                  ; Close the file if possible by us.
 19061                                  ;
 19062                                  ;if installed
 19063 00002D15 FF1E[C400]              	Call	far [JShare+(13*4)] ; 13 = ShCloseFile
 19064                                  ;else
 19065                                  ;	Call	ShCloseFile
 19066                                  ;endif
 19067                                  	;;;
 19068                                  	; 31/01/2024 - Retro DOS v5.0
 19069                                  	; PCDOS 7.1 IBMDOS.COM
 19070 00002D19 803E[0303]FF            	cmp	byte [fShare],0FFh
 19071 00002D1E 750A                    	jne	short rdc_1
 19072 00002D20 8C06[A005]              	mov	[THISSFT+2],es
 19073 00002D24 893E[9E05]              	mov	[THISSFT],di
 19074 00002D28 EB0A                    	jmp	short rdc_2
 19075                                  rdc_1:
 19076                                  	;;;
 19077 00002D2A 8C1E[A005]              	MOV	[THISSFT+2],DS
 19078                                  
 19079                                  ;hkn; AUXSTACK is in DOSDATA
 19080 00002D2E C706[9E05][6507]        	MOV	word [THISSFT],AUXSTACK-SF_ENTRY.size  ; RENAMEDMA+(384-59)
 19081                                  				; Scratch space
 19082                                  rdc_2:		; 30/01/2024
 19083 00002D34 30E4                    	XOR	AH,AH		; Indicate file to DOOPEN (high bit off)
 19084 00002D36 E8F027                  	call	DOOPEN		; Fill in SFT for share check
 19085 00002D39 C43E[9E05]              	LES	DI,[THISSFT]
 19086                                  	;mov	word [es:di+2],10h
 19087 00002D3D 26C745021000            	MOV	word [ES:DI+SF_ENTRY.sf_mode],SHARING_DENY_BOTH ; 10h
 19088                                  				; requires exclusive access
 19089                                  	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],1 ; Pretend open
 19090 00002D43 26C7050100              	mov	word [ES:DI],1
 19091 00002D48 E84350                  	call	ShareEnter
 19092 00002D4B 720D                    	jc	short CheckDone
 19093 00002D4D C43E[9E05]              	LES	DI,[THISSFT]
 19094                                  	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],0
 19095 00002D51 26C7050000              	mov	word [ES:DI],0	; Pretend closed and free
 19096                                  	
 19097 00002D56 E83050                  	call	ShareEnd	; Tell sharer we're done with THISSFT
 19098 00002D59 F8                      	CLC
 19099                                  CheckDone:
 19100 00002D5A C42E[8A05]              	LES	BP,[THISDPB]
 19101 00002D5E 5E                      	POP	SI
 19102 00002D5F 5B                      	POP	BX
 19103 00002D60 58                      	POP	AX
 19104 00002D61 5F                      	POP	DI
 19105 00002D62 1F                      	POP	DS
 19106 00002D63 C3                      	retn
 19107                                  
 19108                                  ;Break	<FastOpen_Delete - delete dir info in fastopen>
 19109                                  ;---------------------------------------------------------------------------
 19110                                  ; Procedure Name : FastOpen_Delete
 19111                                  ; Inputs:
 19112                                  ;	None
 19113                                  ; Function:
 19114                                  ;	Call FastOpen to delete the dir info.
 19115                                  ; Outputs:
 19116                                  ;	None
 19117                                  ;---------------------------------------------------------------------------
 19118                                  
 19119                                  	; 31/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 19120                                  
 19121                                  FastOpen_Delete:
 19122 00002D64 9C                      	PUSHF			; save flag
 19123 00002D65 56                      	PUSH	SI		; save registers
 19124 00002D66 57                      	push	di ; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 19125 00002D67 53                      	PUSH	BX
 19126 00002D68 50                      	PUSH	AX
 19127                                  	;mov	si,[WFP_START] ; MSDOS 3.3
 19128                                  ;hkn; SS override
 19129                                  	; 17/05/2019 - Retro DOS v4.0
 19130                                  	; MSDOS 6.0
 19131 00002D69 368B36[B205]            	MOV	SI,[ss:WFP_START] ; ds:si points to path name
 19132                                  	
 19133 00002D6E B003                    	MOV	AL,FONC_delete	; al = 3
 19134                                  
 19135                                  ; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 19136                                  %if 0 
 19137                                  fastinvoke:
 19138                                  ;hkn; FastTable is in DOSDATA
 19139                                  	MOV	BX,FastTable+2
 19140                                  	CALL	far [BX]	; call fastopen
 19141                                  	POP	AX		; restore registers
 19142                                  	POP	BX
 19143                                  	;pop	di ; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 19144                                  	POP	SI
 19145                                  	POPF			; restore flag
 19146                                  	retn
 19147                                  %else
 19148 00002D70 EB0F                    	jmp	short fastinvoke ; 31/01/2024
 19149                                  %endif
 19150                                  
 19151                                  	; 13/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19152                                  	; DOSCODE:65A0h (MSDOS 5.0 MSDOS.SYS)
 19153                                  
 19154                                  	; 31/01/2024 Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 19155                                  	; DOSCODE:65B4h (MSDOS 6.22 MSDOS.SYS)
 19156                                  	; DOSCODE:6D07h (PCDOS 7.1 IBMDOS.COM)
 19157                                  
 19158                                  ;Break	<FastOpen_Rename - Rename directory>	   ; PTR 5622
 19159                                  ;---------------------------------------------------------------------------
 19160                                  ; PROCEDURE Name : FastOpen_Rename
 19161                                  ;
 19162                                  ; Inputs:
 19163                                  ;	 REN_WFP   = Path Name
 19164                                  ;	 NAME1	   = New Name
 19165                                  ; Function:
 19166                                  ;	Call FastOpen to rename the dir entry in the cache
 19167                                  ; Outputs:
 19168                                  ;	None
 19169                                  ;---------------------------------------------------------------------------
 19170                                  
 19171                                  FastOpen_Rename:
 19172                                  	; 17/05/2019 - Retro DOS v4.0
 19173                                  	; 08/08/2018 - Retro DOS v3.0
 19174                                  	; MSDOS 6.0
 19175 00002D72 9C                      	PUSHF			;AN001 save flag
 19176 00002D73 56                      	PUSH	SI		;AN001 save registers
 19177 00002D74 57                      	PUSH	DI		;AN001
 19178 00002D75 53                      	PUSH	BX		;AN001
 19179 00002D76 50                      	PUSH	AX		;AN001
 19180                                  	;
 19181                                  ;hkn; SS override
 19182 00002D77 368B36[B405]            	MOV	SI,[SS:REN_WFP]	;AN001	;;AN001  ds:si-->Path name addrs
 19183                                  
 19184                                  ;hkn; NAME1 is in DOSDATA
 19185 00002D7C BF[4B05]                	MOV	DI,NAME1	;;AN001  ds:di-->New name addrs
 19186                                  	;mov	al,6
 19187 00002D7F B006                    	MOV	AL,FONC_Rename	;;AN001  al = 6
 19188                                  
 19189                                  fastinvoke:	; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 19190                                  	
 19191                                  ;hkn; FastTable is in DOSDATA
 19192 00002D81 BB[6512]                	MOV	BX,FastTable+2
 19193 00002D84 FF1F                    	CALL	far [BX]	;;AN001  call fastopen
 19194                                  	
 19195 00002D86 58                      	POP	AX		; restore registers  ;AN001
 19196 00002D87 5B                      	POP	BX				     ;AN001
 19197 00002D88 5F                      	POP	DI				     ;AN001
 19198 00002D89 5E                      	POP	SI				     ;AN001
 19199 00002D8A 9D                      	POPF			; restore flag	     ;AN001
 19200 00002D8B C3                      	retn					     ;AN001
 19201                                  
 19202                                  ;Break	<FastOpen_Update - update dir info in fastopen>
 19203                                  ;---------------------------------------------------------------------------
 19204                                  ; Procedure Name : FastOpen_Update
 19205                                  ;
 19206                                  ; Inputs:
 19207                                  ;	DL     drive number (A=0,B=1,,,)
 19208                                  ;	CX     first cluster #
 19209                                  ;	AH     0 updates dir entry
 19210                                  ;	       1 updates CLUSNUM , BP = new CLUSNUM
 19211                                  ;	ES:DI  directory entry
 19212                                  ; Function:
 19213                                  ;	Call FastOpen to update the dir info.
 19214                                  ; Outputs:
 19215                                  ;	None
 19216                                  ;---------------------------------------------------------------------------
 19217                                  
 19218                                  FastOpen_Update:
 19219 00002D8C 9C                      	PUSHF			; save flag
 19220 00002D8D 56                      	PUSH	SI
 19221 00002D8E 57                      	push	di ; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 19222 00002D8F 53                      	PUSH	BX		; save regs
 19223 00002D90 50                      	PUSH	AX
 19224 00002D91 B004                    	MOV	AL,FONC_update	; al = 4
 19225 00002D93 EBEC                    	JMP	short fastinvoke
 19226                                  
 19227                                  	; 17/05/2019
 19228                                  
 19229                                  	; MSDOS 6.0
 19230                                  ;entry Fast_Dispatch		; future fastxxxx entry	;AN000;
 19231                                  ;---------------------------------------------------------------------------
 19232                                  Fast_Dispatch:
 19233                                  ;hkn; FastTable is in DOSDATA
 19234 00002D95 BE[6512]                	MOV	SI,FastTable+2	; index to the	     ;AN000;
 19235                                  ;hkn; use SS override
 19236 00002D98 36FF1C                  	CALL	far [SS:SI]	; RMFD call fastopen
 19237 00002D9B C3                      	retn
 19238                                  
 19239                                  ;============================================================================
 19240                                  ; RENAME.ASM, MSDOS 6.0, 1991
 19241                                  ;============================================================================
 19242                                  ; 08/08/2018 - Retro DOS v3.0
 19243                                  ; 17/05/2019 - Retro DOS v4.0
 19244                                  
 19245                                  ;	TITLE	DOS_RENAME - Internal RENAME call for MS-DOS
 19246                                  ;	NAME	DOS_RENAME
 19247                                  
 19248                                  ;**	Low level routine for renaming files
 19249                                  ;----------------------------------------------------------------------------
 19250                                  ;	DOS_RENAME
 19251                                  ;
 19252                                  ;	Modification history:
 19253                                  ;
 19254                                  ;	    Created: ARR 30 March 1983
 19255                                  
 19256                                  ;----------------------------------------------------------------------------
 19257                                  ;
 19258                                  ; Procedure Name : DOS_RENAME
 19259                                  ;
 19260                                  ; Inputs:
 19261                                  ;	[WFP_START] Points to SOURCE WFP string ("d:/" must be first 3
 19262                                  ;		chars, NUL terminated)
 19263                                  ;	[CURR_DIR_END] Points to end of Current dir part of string [SOURCE]
 19264                                  ;		( = -1 if current dir not involved, else
 19265                                  ;		 Points to first char after last "/" of current dir part)
 19266                                  ;	[REN_WFP] Points to DEST WFP string ("d:/" must be first 3
 19267                                  ;		chars, NUL terminated)
 19268                                  ;	[THISCDS] Points to CDS being used
 19269                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 19270                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 19271                                  ; Function:
 19272                                  ;	Rename the specified file(s)
 19273                                  ;	NOTE: This routine uses most of AUXSTACK as a temp buffer.
 19274                                  ; Outputs:
 19275                                  ;	CARRY CLEAR
 19276                                  ;	    OK
 19277                                  ;	CARRY SET
 19278                                  ;	    AX is error code
 19279                                  ;		error_file_not_found
 19280                                  ;			No match for source, or dest path invalid
 19281                                  ;		error_not_same_device
 19282                                  ;			Source and dest are on different devices
 19283                                  ;		error_access_denied
 19284                                  ;			Directory specified (not simple rename),
 19285                                  ;			Device name given, Destination exists.
 19286                                  ;			NOTE: In third case some renames may have
 19287                                  ;			 been done if metas.
 19288                                  ;		error_path_not_found
 19289                                  ;			Bad path (not in curr dir part if present)
 19290                                  ;			SOURCE ONLY
 19291                                  ;		error_bad_curr_dir
 19292                                  ;			Bad path in current directory part of path
 19293                                  ;			SOURCE ONLY
 19294                                  ;		error_sharing_violation
 19295                                  ;			Deny both access required, generates an INT 24.
 19296                                  ; DS preserved, others destroyed
 19297                                  ;
 19298                                  ;----------------------------------------------------------------------------
 19299                                  
 19300                                  	; 14/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19301                                  	; 31/01/2024 Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 19302                                  
 19303                                  DOS_RENAME:
 19304                                  
 19305                                  ;hkn; DOS_RENAME is called from file.asm and fcbio.asm. DS has been set up
 19306                                  ;hkn; at this point to DOSDATA.
 19307                                  
 19308 00002D9C E8A2EA                  	call	TestNet
 19309 00002D9F 7306                    	JNC	short LOCAL_RENAME
 19310                                  
 19311                                  ;IF NOT Installed
 19312                                  ;	transfer NET_RENAME
 19313                                  ;ELSE
 19314                                  	;MOV	AX,(MultNET SHL 8) OR 17
 19315                                  	;INT	2FH
 19316                                  	;return
 19317                                  
 19318 00002DA1 B81111                  	mov     ax, 1111h
 19319 00002DA4 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
 19320                                  			; SS = DS = DOS CS, 
 19321                                  			; SDA first filename pointer = offset of fully-qualified old name
 19322                                  			; SDA CDS pointer -> current directory
 19323                                  			; Return: CF set on error
 19324 00002DA6 C3                      	retn
 19325                                  ;ENDIF
 19326                                  
 19327                                  LOCAL_RENAME:
 19328 00002DA7 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 19329 00002DAC 8B36[B205]              	MOV	SI,[WFP_START]
 19330 00002DB0 8B3E[B405]              	MOV	DI,[REN_WFP]
 19331 00002DB4 8A04                    	MOV	AL,[SI]
 19332 00002DB6 8A25                    	MOV	AH,[DI]
 19333 00002DB8 0D2020                  	OR	AX,2020H		; Lower case
 19334 00002DBB 38E0                    	CMP	AL,AH
 19335 00002DBD 7405                    	JZ	short SAMEDRV
 19336 00002DBF B81100                  	MOV	AX,error_not_same_device ; 11h
 19337 00002DC2 F9                      	STC
 19338 00002DC3 C3                      	retn
 19339                                  
 19340                                  SAMEDRV:
 19341 00002DC4 FF36[2E03]              	PUSH	WORD [DMAADD+2]
 19342 00002DC8 FF36[2C03]              	PUSH	WORD [DMAADD]
 19343 00002DCC 8C1E[2E03]              	MOV	[DMAADD+2],DS
 19344                                  
 19345                                  ;hkn; RENAMEDMA is in DOSDATA
 19346 00002DD0 C706[2C03][2006]        	MOV	WORD [DMAADD],RENAMEDMA
 19347 00002DD6 C606[7005]00            	MOV	byte [FOUND_DEV],0	; Rename fails on DEVS, assume not a dev
 19348 00002DDB E825EB                  	call	ECritDisk
 19349 00002DDE E86807                  	call	DOS_SEARCH_FIRST	; Sets [NoSetDir] to 1, [CURBUF+2]:BX
 19350                                  					;    points to entry
 19351 00002DE1 7314                    	JNC	short Check_Dev
 19352 00002DE3 83F812                  	CMP	AX,error_no_more_files ; 12h
 19353 00002DE6 7503                    	JNZ	short GOTERR
 19354 00002DE8 B80200                  	MOV	AX,error_file_not_found ; 2
 19355                                  GOTERR:
 19356 00002DEB F9                      	STC
 19357                                  RENAME_POP:
 19358 00002DEC 8F06[2C03]              	POP	WORD [DMAADD]
 19359 00002DF0 8F06[2E03]              	POP	WORD [DMAADD+2]
 19360                                  	;call	LCritDisk
 19361                                  	;retn
 19362                                  	; 16/12/2022
 19363 00002DF4 E939EB                  	jmp	LCritDisk
 19364                                  
 19365                                  Check_Dev:
 19366                                  	; 17/05/2019 - Retro DOS v4.0
 19367                                  	;mov	ax,5
 19368 00002DF7 B80500                  	MOV	AX,error_access_denied	; Assume error
 19369                                  	
 19370                                  	; MSDOS 6.0
 19371 00002DFA 1E                      	PUSH	DS			      ;PTM.			    ;AN000;
 19372 00002DFB C536[2C03]              	LDS	SI,[DMAADD]		      ;PTM.  check if source a dir  ;AN000;
 19373                                  	;add	si,21
 19374 00002DFF 83C615                  	ADD	SI,find_buf.attr	      ;PTM.			    ;AN000;
 19375                                  	;test	byte [si+11],10h
 19376 00002E02 F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;PTM.	    ;AN000;
 19377 00002E06 7407                    	JZ	short notdir		      ;PTM.			    ;AN000;
 19378 00002E08 8B36[B405]              	MOV	SI,[REN_WFP]		      ;PTM.  if yes, make sure path ;AN000;
 19379 00002E0C E86FFA                  	call	Check_PathLen2		      ;PTM.   length < 67	    ;AN000;
 19380                                  notdir:
 19381 00002E0F 1F                      	POP	DS			      ;PTM.			    ;AN000;
 19382 00002E10 77D9                    	JA	short GOTERR		      ;PTM.			    ;AN000;
 19383                                  
 19384                                  	; MSDOS 3.3 & MSDOS 6.0
 19385 00002E12 803E[7005]00            	CMP	byte [FOUND_DEV],0
 19386 00002E17 75D2                    	JNZ	short GOTERR
 19387                                  
 19388                                  ; At this point a source has been found. There is search continuation info (a
 19389                                  ; la DOS_SEARCH_NEXT) for the source at RENAMEDMA, together with the first
 19390                                  ; directory entry found.
 19391                                  ; [THISCDS], [THISDPB], and [THISDRV] are set and will remain correct
 19392                                  ; throughout the RENAME since it is known at this point that the source and
 19393                                  ; destination are both on the same device.
 19394                                  ; [SATTRIB] is also set.
 19395                                  
 19396 00002E19 89DE                    	MOV	SI,BX
 19397                                  	;add	si,26
 19398 00002E1B 83C61A                  	ADD	SI,dir_entry.dir_first
 19399 00002E1E E8C5FE                  	call	REN_DEL_Check
 19400 00002E21 7305                    	JNC	short REN_OK1
 19401 00002E23 B82000                  	MOV	AX,error_sharing_violation  ; 20h
 19402 00002E26 EBC4                    	JMP	short RENAME_POP
 19403                                  
 19404                                  ;------------------------------------------------------------------------------
 19405                                  ; Check if the source is a file or directory. If file, delete the entry
 19406                                  ; from the Fastopen cache. If directory, rename it later
 19407                                  ;------------------------------------------------------------------------------
 19408                                  
 19409                                  REN_OK1:				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 19410                                  	; MSDOS 6.0
 19411                                  	; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 19412                                  	;PUSH	SI
 19413 00002E28 C536[2C03]              	LDS	SI,[DMAADD]		;BN00X; PTM. check if source a dir ;AN000;
 19414                                  	;add	si,21
 19415 00002E2C 83C615                  	ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
 19416                                  	;test	byte [si+11],10h
 19417 00002E2F F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM. ;AN000;
 19418                                  	;JZ	short NOT_DIR1		;;BN00XPTM.			;AN000;
 19419 00002E33 7503                    	jnz	short SWAP_SOURCE ; 31/01/2024
 19420                                  	;POP	SI			;BN00X
 19421                                  	;JMP	SHORT SWAP_SOURCE	;BN00X
 19422                                  ;NOT_DIR1:				;;BN00X it is a file, delete the entry
 19423                                  	;POP	SI
 19424                                  
 19425                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19426 00002E35 E82CFF                  	call	FastOpen_Delete 	; delete dir info in fastopen DOS 3.3
 19427                                  SWAP_SOURCE:
 19428                                  	; MSDOS 3.3
 19429                                  	;MOV	SI,[REN_WFP]
 19430                                  	;MOV	[WFP_START],SI
 19431                                  	; MSDOS 6.0
 19432 00002E38 A1[B205]                	MOV	AX,[WFP_START]		; Swap source and destination
 19433 00002E3B 8B36[B405]              	MOV	SI,[REN_WFP]		; Swap source and destination
 19434 00002E3F 8936[B205]              	MOV	[WFP_START],SI		; WFP_START = Destination path
 19435 00002E43 A3[B405]                	MOV	[REN_WFP],AX		; REN_WFP   = Source path
 19436                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19437 00002E46 C706[B605]FFFF          	MOV	word [CURR_DIR_END],-1	; No current dir on dest
 19438                                  	;mov	word [CREATING],0E5FFh
 19439 00002E4C C706[7E05]FFE5          	MOV	WORD [CREATING],DIRFREE*256+0FFh  ; Creating, not DEL *.*
 19440                                  					; A rename is like a CREATE_NEW as far
 19441                                  					; as the destination is concerned.
 19442 00002E52 E8B01A                  	call	GetPathNoSet
 19443                                  
 19444                                  ;   If this GETPATH fails due to file not found, we know all renames will work
 19445                                  ;   since no files match the destination name. If it fails for any other
 19446                                  ;   reason, the rename fails on a path not found, or whatever (also fails if
 19447                                  ;   we find a device or directory). If the GETPATH succeeds, we aren't sure
 19448                                  ;   if the rename should fail because we haven't built an explicit name by
 19449                                  ;   substituting for the meta chars in it. In this case the destination file
 19450                                  ;   spec with metas is in [NAME1] and the explicit source name is at RENAMEDMA
 19451                                  ;   in the directory entry part.
 19452                                  	
 19453 00002E55 722A                    	JC	short NODEST
 19454                                  	
 19455                                  	; MSDOS 6.0
 19456                                  	;JZ	short BAD_ACC 		; Dest string is a directory	;AC000;
 19457                                  	; !! MSDOS 3.3 !!
 19458                                  	;JZ	short BAD_ACC ; !!	; Dest string is a directory
 19459                                  
 19460 00002E57 08E4                    	OR	AH,AH			; Device?
 19461 00002E59 7933                    	JNS	short SAVEDEST		; No, continue
 19462                                  BAD_ACC:
 19463 00002E5B B80500                  	MOV	AX,error_access_denied
 19464 00002E5E F9                      	STC
 19465                                  RENAME_CLEAN:
 19466 00002E5F 9C                      	PUSHF				; Save carry state
 19467 00002E60 50                      	PUSH	AX			; and error code (if carry set)
 19468                                  	;;;
 19469                                  	; 31/01/2024 - Retro DOS v5.0
 19470                                  	; (PCDOS 7.1 IBMDOS.COM)
 19471 00002E61 C42E[8A05]              	les	bp,[THISDPB]
 19472 00002E65 E82906                  	call	update_fat32_fsinfo
 19473                                  	;;;
 19474 00002E68 A0[7605]                	MOV	AL,[THISDRV]
 19475 00002E6B E8EC35                  	call	FLUSHBUF
 19476 00002E6E 58                      	POP	AX
 19477 00002E6F 803E[4A03]00            	CMP	byte [FAILERR],0
 19478 00002E74 7504                    	JNZ	short BAD_ERR		; User FAILed to I 24
 19479 00002E76 9D                      	POPF
 19480 00002E77 E972FF                  	JMP	RENAME_POP
 19481                                  
 19482                                  BAD_ERR:
 19483 00002E7A 58                      	POP	AX			; Saved flags
 19484                                  	; 16/12/202
 19485                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 19486                                  BAD_PATH: ; *
 19487 00002E7B B80300                  	MOV	AX,error_path_not_found
 19488 00002E7E E96AFF                  	JMP	GOTERR
 19489                                  
 19490                                  NODEST:
 19491 00002E81 75F8                    	JNZ	short BAD_PATH
 19492 00002E83 803E[4A03]00            	CMP	byte [FAILERR],0
 19493 00002E88 75F1                    	JNZ	short BAD_PATH		; Search for dest failed 
 19494                                  					; because user FAILed on I 24
 19495                                  	; 14/11/2022
 19496 00002E8A 08C9                    	OR	CL,CL
 19497                                  	;JNZ	short SAVEDEST
 19498                                  	; 17/05/2019
 19499 00002E8C 74ED                    	jz	short BAD_PATH ; *
 19500                                  ;BAD_PATH: ; *
 19501                                  ;	MOV	AX,error_path_not_found
 19502                                  ;	;STC
 19503                                  ;	;JMP	RENAME_POP
 19504                                  ;	; 17/05/2019
 19505                                  ;	jmp	GOTERR 
 19506                                  
 19507                                  ; 16/12/2022
 19508                                  %if 0
 19509                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 19510                                  	or	cl,cl
 19511                                  	jnz	short SAVEDEST
 19512                                  	;jz	short BAD_PATH ; *
 19513                                  BAD_PATH: ; *
 19514                                  	;mov	ax,3
 19515                                  	mov	ax,error_path_not_found
 19516                                  	stc
 19517                                  	jmp	RENAME_POP
 19518                                  %endif
 19519                                  
 19520                                  SAVEDEST:
 19521 00002E8E 16                      	push	ss
 19522 00002E8F 07                      	pop	es
 19523                                  
 19524                                  ;hkn; NAME1 & NAME2 is in DOSDATA
 19525 00002E90 BF[5705]                	MOV	DI,NAME2
 19526 00002E93 BE[4B05]                	MOV	SI,NAME1
 19527                                  
 19528 00002E96 B90B00                  	MOV	CX,11
 19529 00002E99 F3A4                    	REP	MOVSB			; Save dest with metas at NAME2
 19530                                  	;;;
 19531                                  	; 31/01/2024
 19532                                  	; (PCDOS 7.1 IBMDOS.COM)
 19533 00002E9B A1[E30A]                	mov	ax,[DIRSTART_HW]
 19534 00002E9E A3[ED0A]                	mov	[DESTSTART_HW],ax
 19535                                  	;;;
 19536 00002EA1 A1[C205]                	MOV	AX,[DIRSTART]
 19537 00002EA4 A3[6405]                	MOV	[DESTSTART],AX
 19538                                  BUILDDEST:
 19539                                  	; 31/01/2024
 19540                                  	;push	ss
 19541                                  	;pop	es			; needed due to JMP BUILDDEST below
 19542                                  
 19543                                  ;hkn; RENAMEDMA, NAME1, NAME2 in DOSDATA
 19544 00002EA7 BB[3506]                	MOV	BX,RENAMEDMA+21		; Source of replace chars
 19545 00002EAA BF[4B05]                	MOV	DI,NAME1		; Real dest name goes here
 19546 00002EAD BE[5705]                	MOV	SI,NAME2		; Raw dest
 19547                                  
 19548 00002EB0 B90B00                  	MOV	CX,11
 19549                                  
 19550                                  	; 17/05/2019 - Retro DOS v4.0
 19551                                  
 19552                                  	; MSDOS 6.0
 19553 00002EB3 E82601                  	CALL	NEW_RENAME		;IFS. replace ? chars	;AN000;
 19554                                  
 19555                                  	; MSDOS 3.3
 19556                                  
 19557                                  ; 08/08/2018 - Retro DOS v3.0
 19558                                  ; MSDOS 6.0 
 19559                                  ;---------------------------------------------------------------------------
 19560                                  ;Procedure: NEW_RENAME
 19561                                  ;
 19562                                  ;Input: DS:SI -> raw string with ?
 19563                                  ;	ES:DI -> destination string
 19564                                  ;	DS:BX -> source string
 19565                                  ;Function: replace ? chars of raw string with chars in source string and
 19566                                  ;	   put in destination string
 19567                                  ;Output: ES:DI-> new string
 19568                                  ;---------------------------------------------------------------------------
 19569                                  ;
 19570                                  ;NEW_RENAME:
 19571                                  ;NEWNAM:
 19572                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 341Ah
 19573                                  ;	LODSB
 19574                                  ;	CMP	AL,"?"
 19575                                  ;	JNZ	short NOCHG
 19576                                  ;	MOV	AL,[BX] 		; Get replace char
 19577                                  ;NOCHG:
 19578                                  ;	STOSB
 19579                                  ;	INC	BX			; Next replace char
 19580                                  ;	LOOP	NEWNAM
 19581                                  ;	; MSDOS 6.0
 19582                                  ;	;retn
 19583                                  
 19584                                  	; MSDOS 3.3 & MSDOS 6.0
 19585                                  	;mov	byte [ATTRIB],16h
 19586 00002EB6 C606[6B05]16            	MOV	byte [ATTRIB],attr_all	; Stop duplicates with any attributes
 19587 00002EBB C606[7E05]FF            	MOV	byte [CREATING],0FFH
 19588 00002EC0 E8F01C                  	call	DEVNAME 		; Check if we built a device name
 19589 00002EC3 7396                    	JNC	short BAD_ACC
 19590                                  	;;;
 19591                                  	; 31/01/2024
 19592                                  	; (PCDOS 7.1 IBMDOS.COM)
 19593 00002EC5 8B1E[ED0A]              	mov	bx,[DESTSTART_HW]
 19594 00002EC9 891E[F50A]              	mov	[ROOTCLUST_HW],bx
 19595                                  	;;;
 19596 00002ECD 8B1E[6405]              	MOV	BX,[DESTSTART]
 19597 00002ED1 C42E[8A05]              	LES	BP,[THISDPB]
 19598 00002ED5 E81519                  	call	SETDIRSRCH		; Reset search to start of dir
 19599 00002ED8 7281                    	JC	short BAD_ACC 		; Screw up
 19600 00002EDA E84217                  	call	FINDENTRY		; See if new name already exists
 19601                                  	;JNC	short BAD_ACC 		; Error if found
 19602                                  	; 31/01/2024
 19603 00002EDD 7346                    	jnc	short BAD_ACCJ
 19604 00002EDF 803E[4A03]00            	CMP	byte [FAILERR],0
 19605 00002EE4 753F                    	JNZ	short BAD_ACCJ		; Find failed because user FAILed to I 24
 19606 00002EE6 A1[6405]                	MOV	AX,[DESTSTART]		; DIRSTART of dest
 19607                                  	;;;
 19608                                  	; 31/01/2024
 19609 00002EE9 8B16[ED0A]              	mov	dx,[DESTSTART_HW]
 19610 00002EED C42E[8A05]              	les	bp,[THISDPB]
 19611 00002EF1 26837E0F00              	cmp	word [es:bp+DPB.FAT_SIZE],0
 19612                                  	;cmp	word [es:bp+0Fh],0
 19613 00002EF6 7506                    	jnz	short builddst_1	; not FAT32
 19614 00002EF8 3B16[3106]              	cmp	dx,[RENAMEDMA+17]	; DIRSTART_HW of source
 19615 00002EFC 7506                    	jne	short builddst_2
 19616                                  builddst_1:
 19617                                  	;;;
 19618 00002EFE 3B06[2F06]              	CMP	AX,[RENAMEDMA+15]	; DIRSTART of source
 19619 00002F02 7451                    	JZ	short SIMPLE_RENAME	; If =, just give new name
 19620                                  builddst_2:	; 31/01/2024
 19621                                  	;mov	al,[RENAMEDMA+32]
 19622 00002F04 A0[4006]                	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr]
 19623 00002F07 A810                    	TEST	AL,attr_directory ; 10h
 19624 00002F09 751A                    	JNZ	short BAD_ACCJ		; Can only do a simple rename on dirs,
 19625                                  					; otherwise the . and .. entries get
 19626                                  					; wiped.
 19627 00002F0B A2[6B05]                	MOV	[ATTRIB],AL
 19628 00002F0E 8C1E[A005]              	MOV	[THISSFT+2],DS
 19629                                  
 19630                                  ;hkn; AUXSTACK is in DOSDATA
 19631                                  	;mov	si,RENAMEDMA+145h
 19632 00002F12 BE[6507]                	MOV	SI,AUXSTACK-SF_ENTRY.size ; RENAMEDMA+325
 19633 00002F15 8936[9E05]              	MOV	[THISSFT],SI
 19634                                  	;mov	word [SI+2],2
 19635 00002F19 C744020200              	MOV	word [SI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 19636 00002F1E 31C9                    	XOR	CX,CX			; Set "device ID" for call into makenode
 19637 00002F20 E86E24                  	call	RENAME_MAKE		; This is in mknode
 19638 00002F23 7303                    	JNC	short GOT_DEST
 19639                                  BAD_ACCJ:
 19640 00002F25 E933FF                  	JMP	BAD_ACC
 19641                                  
 19642                                  GOT_DEST:
 19643 00002F28 53                      	push	bx
 19644 00002F29 C43E[9E05]              	LES	DI,[THISSFT]		; RENAME_MAKE entered this into sharing
 19645 00002F2D E8594E                  	call	ShareEnd		; we need to remove it.
 19646 00002F30 5B                      	pop	bx
 19647                                  
 19648                                  ; A zero length entry with the correct new name has now been made at
 19649                                  ;   [CURBUF+2]:BX.
 19650                                  
 19651 00002F31 C43E[E205]              	LES	DI,[CURBUF]
 19652                                  
 19653                                  ; 31/01/2024 - Retro DOS v5.0
 19654                                  %if 0
 19655                                  	; MSDOS 6.0
 19656                                  	;test	byte [es:di+5],40h
 19657                                  	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 19658                                  					;LB. if already dirty		  ;AN000;
 19659                                  	JNZ	short yesdirty1		;LB.  don't increment dirty count ;AN000;
 19660                                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 19661                                  	;or	byte [es:di+5],40h
 19662                                  	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 19663                                  yesdirty1:
 19664                                  %else
 19665                                  	; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 19666 00002F35 E82736                  	call	SET_BUF_DIRTY
 19667                                  %endif
 19668 00002F38 89DF                    	MOV	DI,BX
 19669                                  	;add	di,11
 19670 00002F3A 83C70B                  	ADD	DI,dir_entry.dir_attr	; Skip name
 19671                                  
 19672                                  ;hkn; RENAMEDMA is in DOSDATA
 19673                                  	;mov	si,[RENAMEDMA+32]
 19674 00002F3D BE[4006]                	MOV	SI,RENAMEDMA+21+dir_entry.dir_attr
 19675                                  	;mov	cx,21
 19676 00002F40 B91500                  	MOV	CX,dir_entry.size-dir_entry.dir_attr
 19677 00002F43 F3A4                    	REP	MOVSB
 19678 00002F45 E86E00                  	CALL	GET_SOURCE
 19679 00002F48 7269                    	JC	short RENAME_OVER
 19680 00002F4A 89DF                    	MOV	DI,BX
 19681 00002F4C 8E06[E405]              	MOV	ES,[CURBUF+2]
 19682 00002F50 B0E5                    	MOV	AL,DIRFREE ; 0E5h
 19683 00002F52 AA                      	STOSB				; "free" the source
 19684 00002F53 EB13                    	JMP	SHORT DIRTY_IT
 19685                                  
 19686                                  SIMPLE_RENAME:
 19687 00002F55 E85E00                  	CALL	GET_SOURCE		; Get the source back
 19688 00002F58 7259                    	JC	short RENAME_OVER
 19689 00002F5A 89DF                    	MOV	DI,BX
 19690 00002F5C 8E06[E405]              	MOV	ES,[CURBUF+2]
 19691                                  
 19692                                  ;hkn; NAME1 is in DOSDATA
 19693 00002F60 BE[4B05]                	MOV	SI,NAME1		; New Name
 19694 00002F63 B90B00                  	MOV	CX,11
 19695 00002F66 F3A4                    	REP	MOVSB
 19696                                  DIRTY_IT:
 19697 00002F68 8B3E[E205]              	MOV	DI,[CURBUF]
 19698                                  
 19699                                  ; 31/01/2024 - Retro DOS v5.0
 19700                                  %if 0
 19701                                  	; MSDOS 6.0
 19702                                  	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 19703                                  					;LB. if already dirty		  ;AN000;
 19704                                  	JNZ	short yesdirty2		;LB.  don't increment dirty count ;AN000;
 19705                                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 19706                                  	
 19707                                  	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 19708                                  %else
 19709                                  	; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
 19710 00002F6C E8F035                  	call	SET_BUF_DIRTY
 19711                                  %endif
 19712                                  	
 19713                                  ;------------------------------------------------------------------------------
 19714                                  ; Check if the source is a directory of file. If directory rename it to the
 19715                                  ; the new name in the Fastopen cache buffer. If file name it has been
 19716                                  ; previously deleted.
 19717                                  ;------------------------------------------------------------------------------
 19718                                  
 19719                                  ;yesdirty2:	; 31/01/2024
 19720                                  	; MSDOS 6.0
 19721 00002F6F 56                      	PUSH	SI
 19722 00002F70 C536[2C03]              	LDS	SI,[DMAADD]		;;BN00XPTM. chek if source a dir ;AN000;
 19723                                  	;add	si,21
 19724 00002F74 83C615                  	ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
 19725                                  	;test	byte [si+0Bh],10h
 19726 00002F77 F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM.	;AN000;
 19727 00002F7B 7403                    	JZ	short NOT_DIR2		;;BN00XPTM.			;AN000;
 19728 00002F7D E8F2FD                  	call	FastOpen_Rename		;;BN00X rename dir entry in fastopen
 19729                                  	; 31/01/2024
 19730                                  	;POP	SI
 19731                                  	;JMP	SHORT NOT_DIRTY1
 19732                                  NOT_DIR2:				;;BN00X it is a file, delete the entry
 19733 00002F80 5E                      	POP	SI
 19734                                  NOT_DIRTY1:				;;BN00X
 19735                                  NEXT_SOURCE:
 19736                                  ;hkn; RENAMEDMA is in DOSDATA
 19737 00002F81 BE[2106]                	MOV	SI,RENAMEDMA+1		;Name
 19738                                  
 19739                                  ; WARNING! Rename_Next leaves the disk critical section *ALWAYS*. We need
 19740                                  ; to enter it before going to RENAME_Next.
 19741                                  
 19742 00002F84 E87CE9                  	call	ECritDisk
 19743 00002F87 C606[7E05]00            	MOV	byte [CREATING],0 ; Correct setting for search (we changed it
 19744                                  				  ;  to FF when we made the prev new file).
 19745 00002F8C E80007                  	call	RENAME_NEXT
 19746                                  
 19747                                  ; Note, now, that we have exited the previous ENTER and so are back to where
 19748                                  ; we were before.
 19749                                  
 19750 00002F8F 7222                    	JC	short RENAME_OVER
 19751                                  
 19752                                  	;lea	si,[bx+26]
 19753 00002F91 8D771A                  	LEA	SI,[BX+dir_entry.dir_first]
 19754 00002F94 E84FFD                  	call	REN_DEL_Check
 19755 00002F97 7306                    	JNC	short REN_OK2
 19756 00002F99 B82000                  	MOV	AX,error_sharing_violation ; 20h
 19757                                  jmp_to_rename_clean: ; 28/12/2022
 19758 00002F9C E9C0FE                  	JMP	RENAME_CLEAN ; 10/08/2018
 19759                                  
 19760                                  ;------------------------------------------------------------------------------
 19761                                  ; Check if file or directory. If file, delete file from the Fastopen cache,
 19762                                  ; if directory, rename directory name in the Fastopen cache.
 19763                                  ;-----------------------------------------------------------------------------
 19764                                  
 19765                                  REN_OK2:
 19766                                  	; MSDOS 6.0
 19767                                  	;mov	al,[RERNAMEDMA+32]
 19768 00002F9F A0[4006]                	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr] ; PTR P5622
 19769                                  	;test	al,10h
 19770 00002FA2 A810                    	TEST	AL,attr_directory	;;BN00X directory
 19771 00002FA4 7408                    	JZ	short Ren_Directory	;;BN00X no - file, delete it
 19772                                  	
 19773                                  	; MSDOS 3.3 & MSDOS 6.0
 19774 00002FA6 E8BBFD                  	call	FastOpen_Delete 	;;BN00X delete dir info in fastopen DOS 3.3
 19775                                  jmp_to_builddest: ; 28/12/2022
 19776                                  	; 31/01/2024
 19777 00002FA9 16                      	push	ss
 19778 00002FAA 07                      	pop	es
 19779 00002FAB E9F9FE                  	JMP	BUILDDEST		;;BN00X
 19780                                  
 19781                                  	; MSDOS 6.0
 19782                                  Ren_Directory:
 19783 00002FAE E8C1FD                  	call	FastOpen_Rename 	;;BN00X delete dir info in fastopen DOS 3.3
 19784                                  	;JMP	BUILDDEST
 19785                                  	; 28/12/2022
 19786 00002FB1 EBF6                    	jmp	short jmp_to_builddest
 19787                                  
 19788                                  RENAME_OVER:
 19789 00002FB3 F8                      	CLC
 19790                                  	;JMP	RENAME_CLEAN ; 10/08/2018
 19791                                  	; 28/12/2022
 19792 00002FB4 EBE6                    	jmp	short jmp_to_rename_clean
 19793                                  
 19794                                  ;----------------------------------------------------------------------------
 19795                                  ; Procedure: GET_SOURCE
 19796                                  ;
 19797                                  ; Inputs:
 19798                                  ;	RENAMEDMA has source info
 19799                                  ; Function:
 19800                                  ;	Re-find the source
 19801                                  ; Output:
 19802                                  ;	[CURBUF] set
 19803                                  ;	[CURBUF+2]:BX points to entry
 19804                                  ;	Carry set if error (currently user FAILed to I 24)
 19805                                  ; DS preserved, others destroyed
 19806                                  ;----------------------------------------------------------------------------
 19807                                  
 19808                                  GET_SOURCE:
 19809                                  	;;;
 19810                                  	; 01/02/2024 - Retro DOS v5.0
 19811                                  	; (PCDOS 7.1 IBMDOS.COM)
 19812 00002FB6 C42E[8A05]              	les	bp,[THISDPB]
 19813 00002FBA 31DB                    	xor	bx,bx ; 0
 19814                                  	;cmp	[es:bp+0Fh],bx
 19815 00002FBC 26395E0F                	cmp	[es:bp+DPB.FAT_SIZE],bx ; > 0 ?
 19816 00002FC0 7504                    	jnz	short gs_cont		; yes, it is not FAT32
 19817 00002FC2 8B1E[3106]              	mov	bx,[RENAMEDMA+17]	; DirStart+2
 19818                                  gs_cont:
 19819 00002FC6 891E[F50A]              	mov	[ROOTCLUST_HW],bx	; hw of cluster number
 19820                                  	;;;
 19821 00002FCA 8B1E[2F06]              	MOV	BX,[RENAMEDMA+15]	; DirStart
 19822                                  	; 01/02/2024
 19823                                  	;LES	BP,[THISDPB]
 19824 00002FCE E81C18                  	call	SETDIRSRCH
 19825 00002FD1 7214                    	JC	short gs_ret_label	; retc
 19826 00002FD3 E8BC1B                  	call	STARTSRCH
 19827 00002FD6 A1[2D06]                	MOV	AX,[RENAMEDMA+13]	; Lastent
 19828                                  	;call	GETENT
 19829                                  	; 18/12/2022
 19830 00002FD9 E95217                  	jmp	GETENT
 19831                                  ;gs_ret_label:
 19832                                  	;retn
 19833                                  
 19834                                  ; MSDOS 6.0 
 19835                                  ;---------------------------------------------------------------------------
 19836                                  ;Procedure: NEW_RENAME
 19837                                  ;
 19838                                  ;Input: DS:SI -> raw string with ?
 19839                                  ;	ES:DI -> destination string
 19840                                  ;	DS:BX -> source string
 19841                                  ;Function: replace ? chars of raw string with chars in source string and
 19842                                  ;	   put in destination string
 19843                                  ;Output: ES:DI-> new string
 19844                                  ;---------------------------------------------------------------------------
 19845                                  
 19846                                  NEW_RENAME:
 19847                                  	; 17/05/2019 - Retro DOS v4.0
 19848                                  NEWNAM:
 19849                                  	; DOSCODE:680Eh (MSDOS 6.21, MSDOS.SYS)
 19850 00002FDC AC                      	LODSB
 19851 00002FDD 3C3F                    	CMP	AL,"?" ; 3Fh
 19852 00002FDF 7502                    	JNZ	short NOCHG
 19853 00002FE1 8A07                    	MOV	AL,[BX] 		; Get replace char
 19854                                  NOCHG:
 19855 00002FE3 AA                      	STOSB
 19856 00002FE4 43                      	INC	BX			; Next replace char
 19857 00002FE5 E2F5                    	LOOP	NEWNAM
 19858                                  	; MSDOS 6.0
 19859                                  gs_ret_label:	; 18/12/2022
 19860 00002FE7 C3                      	retn
 19861                                  
 19862                                  ;============================================================================
 19863                                  ; FINFO.ASM, MSDOS 6.0, 1991
 19864                                  ;============================================================================
 19865                                  ; 08/08/2018 - Retro DOS v3.0
 19866                                  ; 17/05/2019 - Retro DOS v4.0
 19867                                  
 19868                                  ;**	Low level routines for returning file information and setting file
 19869                                  ;	attributes
 19870                                  ;
 19871                                  ;	GET_FILE_INFO
 19872                                  ;	SET_FILE_ATTRIBUTE
 19873                                  ;
 19874                                  ;	Modification history:
 19875                                  ;
 19876                                  ;	    Created: ARR 30 March 1983
 19877                                  ;
 19878                                  ;	M025: Return access_denied if attempting to set
 19879                                  ;	      attribute of root directory.
 19880                                  ;
 19881                                  
 19882                                  ;SUBTTL GET_FILE_INFO -- Get File Information
 19883                                  
 19884                                  ;---------------------------------------------------------------------------
 19885                                  ; Procedure Name : GET_FILE_INFO
 19886                                  ;
 19887                                  ; Inputs:
 19888                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 19889                                  ;		terminated)
 19890                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 19891                                  ;		( = -1 if current dir not involved, else
 19892                                  ;		 Points to first char after last "/" of current dir part)
 19893                                  ;	[THISCDS] Points to CDS being used
 19894                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 19895                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 19896                                  ; Function:
 19897                                  ;	Get Information about a file
 19898                                  ; Returns:
 19899                                  ;	CARRY CLEAR
 19900                                  ;	    AX = Attribute of file
 19901                                  ;	    CX = Time stamp of file
 19902                                  ;	    DX = Date stamp of file
 19903                                  ;	    BX:DI = Size of file (32 bit)
 19904                                  ;	CARRY SET
 19905                                  ;	    AX is error code
 19906                                  ;		error_file_not_found
 19907                                  ;			Last element of path not found
 19908                                  ;		error_path_not_found
 19909                                  ;			Bad path (not in curr dir part if present)
 19910                                  ;		error_bad_curr_dir
 19911                                  ;			Bad path in current directory part of path
 19912                                  ; DS preserved, others destroyed
 19913                                  ;---------------------------------------------------------------------------
 19914                                  
 19915                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19916                                  
 19917                                  GET_FILE_INFO:
 19918                                  
 19919                                  ;hkn; get_file_info is called from file.asm and fcbio.asm. DS has been set 
 19920                                  ;hkn; to DOSDATA at this point. So DOSassume is OK.
 19921                                  
 19922 00002FE8 E856E8                  	call	TestNet
 19923 00002FEB 7306                    	JNC	short LOCAL_INFO
 19924                                  
 19925                                  ;IF NOT Installed
 19926                                  ;	transfer NET_GET_FILE_INFO
 19927                                  ;ELSE
 19928                                  ;	MOV	AX,(MultNET SHL 8) OR 15
 19929                                  ;	INT	2FH
 19930                                  ;	return
 19931                                  
 19932 00002FED B80F11                  	mov     ax, 110Fh
 19933 00002FF0 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
 19934                                  			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
 19935                                  			; SDA CDS pointer -> current directory
 19936                                  			; Return: CF set on error, AX = file attributes
 19937 00002FF2 C3                      	retn
 19938                                  ;ENDIF
 19939                                  
 19940                                  LOCAL_INFO:
 19941 00002FF3 E80DE9                  	call	ECritDisk
 19942 00002FF6 C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 19943                                  	; MSDOS 3.3
 19944                                  	;call	GETPATH
 19945                                  	; MSDOS 6.0
 19946 00002FFB E8C900                  	call	GET_FAST_PATH
 19947                                  	; MSDOS 3.3 & MSDOS 6.0
 19948 00002FFE 7312                    	JNC	short info_check_dev
 19949                                  NO_PATH:
 19950 00003000 750B                    	JNZ	short bad_path1
 19951 00003002 08C9                    	OR	CL,CL
 19952 00003004 7407                    	JZ	short bad_path1
 19953                                  info_no_file:
 19954 00003006 B80200                  	MOV	AX,error_file_not_found
 19955                                  BadRet:
 19956 00003009 F9                      	STC
 19957                                  JustRet:
 19958                                  	;call	LCritDisk
 19959                                  	;retn
 19960                                  	; 18/12/2022
 19961 0000300A E923E9                  	jmp	LCritDisk
 19962                                  
 19963                                  bad_path1:
 19964 0000300D B80300                  	MOV	AX,error_path_not_found
 19965 00003010 EBF7                    	jmp	short BadRet
 19966                                  
 19967                                  info_check_dev:
 19968 00003012 08E4                    	OR	AH,AH
 19969 00003014 78F0                    	JS	short info_no_file	; device
 19970                                  
 19971                                  	; MSDOS 6.0
 19972                                  ;SR;
 19973                                  ; If root dir then CurBuf == -1. Check for this case and return subdir attr
 19974                                  ;for a root dir
 19975                                  
 19976 00003016 833E[E205]FF            	cmp	word [CURBUF],-1	;is it a root dir?
 19977 0000301B 7506                    	jne	short not_root		;no, CurBuf ptr is valid
 19978                                  
 19979 0000301D 30E4                    	xor	ah,ah
 19980 0000301F B010                    	mov	al,attr_directory ; 10h
 19981                                  	;clc
 19982                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 19983                                  	; (DOSCODE:683Eh)
 19984                                  	; 16/12/2022
 19985                                  	;clc
 19986 00003021 EBE7                    	jmp	short JustRet
 19987                                  
 19988                                  not_root:
 19989                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19990 00003023 1E                      	PUSH	DS
 19991 00003024 8E1E[E405]              	MOV	DS,[CURBUF+2]
 19992 00003028 89DE                    	MOV	SI,BX
 19993 0000302A 31DB                    	XOR	BX,BX			; Assume size=0 (dir)
 19994 0000302C 89DF                    	MOV	DI,BX
 19995                                  	;mov	cx,[si+16h]
 19996 0000302E 8B4C16                  	MOV	CX,[SI+dir_entry.dir_time]
 19997                                  	;mov	dx,[si+18h]
 19998 00003031 8B5418                  	MOV	DX,[SI+dir_entry.dir_date]
 19999 00003034 30E4                    	XOR	AH,AH
 20000                                  	;mov	al,[si+0Bh]
 20001 00003036 8A440B                  	MOV	AL,[SI+dir_entry.dir_attr]
 20002                                  	;test	al,10h
 20003 00003039 A810                    	TEST	AL,attr_directory
 20004 0000303B 7506                    	JNZ	short NO_SIZE
 20005                                  	;mov	di,[si+1Ch]
 20006 0000303D 8B7C1C                  	MOV	DI,[SI+dir_entry.dir_size_l]
 20007                                  	;mov	bx,[si+1Eh]
 20008 00003040 8B5C1E                  	MOV	BX,[SI+dir_entry.dir_size_h]
 20009                                  NO_SIZE:
 20010 00003043 1F                      	POP	DS
 20011                                  	;CLC
 20012                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20013                                  	; (DOSCODE:6864h)
 20014                                  	; 16/12/2022
 20015                                  	;clc
 20016 00003044 EBC4                    	jmp	short JustRet
 20017                                  
 20018                                  ;Break	<SET_FILE_ATTRIBUTE -- Set File Attribute>
 20019                                  ;-------------------------------------------------------------------------------
 20020                                  ; Procedure Name : SET_FILE_ATTRIBUTE
 20021                                  ; Inputs:
 20022                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 20023                                  ;		terminated)
 20024                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 20025                                  ;		( = -1 if current dir not involved, else
 20026                                  ;		 Points to first char after last "/" of current dir part)
 20027                                  ;	[THISCDS] Points to CDS being used
 20028                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 20029                                  ;	[SATTRIB] is attribute of search (determines what files may be found)
 20030                                  ;	AX is new attributes to give to file
 20031                                  ; Function:
 20032                                  ;	Set File Attributes
 20033                                  ; Returns:
 20034                                  ;	CARRY CLEAR
 20035                                  ;	    No error
 20036                                  ;	CARRY SET
 20037                                  ;	    AX is error code
 20038                                  ;		error_file_not_found
 20039                                  ;			Last element of path not found
 20040                                  ;		error_path_not_found
 20041                                  ;			Bad path (not in curr dir part if present)
 20042                                  ;		error_bad_curr_dir
 20043                                  ;			Bad path in current directory part of path
 20044                                  ;		error_access_denied
 20045                                  ;			Attempt to set an attribute which cannot be set
 20046                                  ;			(attr_directory, attr_volume_ID)
 20047                                  ;		error_sharing_violation
 20048                                  ;			Sharing mode of file did not allow the change
 20049                                  ;			(this request requires exclusive write/read access)
 20050                                  ;			(INT 24H generated)
 20051                                  ; DS preserved, others destroyed
 20052                                  ;----------------------------------------------------------------------------
 20053                                  
 20054                                  	; 01/02/2024 - Retro DOS v5.0
 20055                                  
 20056                                  SET_FILE_ATTRIBUTE:
 20057                                  
 20058                                  ;hkn; set_file_attr is called from file.asm. DS has been set 
 20059                                  ;hkn; to DOSDATA at this point. So DOSassume is OK.
 20060                                  
 20061 00003046 A9D8FF                  	TEST	AX,~attr_changeable ; 0FFD8h
 20062 00003049 7412                    	JZ	short set_look
 20063                                  _BAD_ACC:
 20064                                  	;MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1
 20065                                  	;;;
 20066                                  	; 01/02/2024 - Retro DOS v5.0
 20067                                  	; (PCDOS 7.1 IBMDOS.COM)
 20068 0000304B E8A7E2                  	call	set_exerr_locus_unk
 20069                                  	;;;
 20070 0000304E C606[2703]07            	MOV	byte [EXTERR_CLASS],errCLASS_Apperr ; 7
 20071 00003053 C606[2603]04            	MOV	byte [EXTERR_ACTION],errACT_Abort ; 4
 20072 00003058 B80500                  	MOV	AX,error_access_denied ; 5
 20073 0000305B F9                      	STC
 20074 0000305C C3                      	retn
 20075                                  	
 20076                                  set_look:
 20077 0000305D E8E1E7                  	call	TestNet
 20078 00003060 7308                    	JNC	short LOCAL_SET
 20079                                  
 20080                                  ;IF NOT Installed
 20081                                  ;	transfer NET_SEQ_SET_FILE_ATTRIBUTE
 20082                                  ;ELSE
 20083 00003062 50                      	PUSH	AX
 20084                                  	
 20085                                  	;MOV	AX,(MultNET SHL 8) OR 14
 20086                                  	;INT	2FH
 20087                                  
 20088 00003063 B80E11                  	mov     ax, 110Eh
 20089 00003066 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
 20090                                  			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
 20091                                  			; SDA CDS pointer -> current directory
 20092                                  			; STACK: WORD new file attributes
 20093                                  			; Return: CF set on error
 20094                                  
 20095 00003068 5B                      	POP	BX			; clean stack
 20096 00003069 C3                      	retn
 20097                                  ;ENDIF
 20098                                  
 20099                                  LOCAL_SET:
 20100 0000306A E896E8                  	call	ECritDisk
 20101 0000306D 50                      	PUSH	AX			; Save new attributes
 20102 0000306E C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 20103 00003073 E88918                  	call	GETPATH 		; get path through fastopen if there	;AC000;
 20104 00003076 7308                    	JNC	short set_check_device
 20105 00003078 5B                      	POP	BX			; Clean stack (don't zap AX)
 20106 00003079 EB85                    	JMP	short NO_PATH
 20107                                  
 20108                                  	; MSDOS 6.0
 20109                                  cannot_set_root:			; M025:
 20110 0000307B B80500                  	mov	ax,error_access_denied	; M025: return error is attempting
 20111                                  	;stc				; M025: to set attr. of root
 20112                                  	;jmp	short OK_BYE		; M025:
 20113                                  	; 01/02/2024
 20114 0000307E EB89                    	jmp	short BadRet
 20115                                  
 20116                                  set_check_device:
 20117 00003080 08E4                    	OR	AH,AH
 20118 00003082 7906                    	JNS	short set_check_share
 20119 00003084 58                      	POP	AX
 20120 00003085 E8A8E8                  	call	LCritDisk
 20121 00003088 EBC1                    	JMP	short _BAD_ACC 		; device
 20122                                  
 20123                                  set_check_share:
 20124 0000308A 58                      	POP	AX			; Get new attributes
 20125                                  
 20126                                  	; MSDOS 6.0
 20127 0000308B 833E[E205]FF            	cmp	word [CURBUF], -1	; M025: Q: is this the root dir
 20128 00003090 74E9                    	je	short cannot_set_root	; M025: Y: return error
 20129                                  
 20130                                  	; MSDOS 3.3 & MSDOS 6.0
 20131 00003092 E851FC                  	call	REN_DEL_Check
 20132 00003095 7305                    	JNC	short set_do
 20133 00003097 B82000                  	MOV	AX,error_sharing_violation ; 32
 20134 0000309A EB28                    	jmp	short OK_BYE
 20135                                  
 20136                                  set_do:
 20137                                  	; MSDOS 3.3 & MSDOS 6.0
 20138 0000309C C43E[E205]              	LES	DI,[CURBUF]
 20139 000030A0 2680670BD8              	AND	BYTE [ES:BX+dir_entry.dir_attr],~attr_changeable ; 0D8h
 20140 000030A5 2608470B                	OR	BYTE [ES:BX+dir_entry.dir_attr],AL
 20141                                  
 20142                                  ; 01/02/2024 - Retro DOS v5.0
 20143                                  %if 0
 20144                                  	; MSDOS 6.0
 20145                                  	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 20146                                  					;LB. if already dirty		  ;AN000;
 20147                                  	JNZ	short yesdirty3		;LB.  don't increment dirty count ;AN000;
 20148                                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 20149                                  	
 20150                                  	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 20151                                  yesdirty3:
 20152                                  %else
 20153                                  	; 01/02/2024
 20154                                  	; (PCDOS 7.1 IBMDOS.COM)
 20155 000030A9 E8B334                  	call	SET_BUF_DIRTY
 20156                                  %endif
 20157 000030AC A0[7605]                	MOV	AL,[THISDRV]
 20158                                  ;;;; 10/1/86 F.C update fastopen cache
 20159 000030AF 52                      	PUSH	DX
 20160 000030B0 57                      	PUSH	DI
 20161 000030B1 B400                    	MOV	AH,0		  ; dir entry update
 20162 000030B3 88C2                    	MOV	DL,AL		  ; drive number A=0,B=1,,
 20163 000030B5 89DF                    	MOV	DI,BX		  ; ES:DI -> dir entry
 20164 000030B7 E8D2FC                  	call	FastOpen_Update
 20165 000030BA 5F                      	POP	DI
 20166 000030BB 5A                      	POP	DX
 20167                                  ;;;; 9/11/86 F.C update fastopen cache
 20168 000030BC E89B33                  	call	FLUSHBUF
 20169 000030BF 7303                    	JNC	short OK_BYE
 20170 000030C1 B80200                  	MOV	AX,error_file_not_found
 20171                                  OK_BYE:
 20172                                  	;call	LCritDisk
 20173                                  	;retn
 20174                                  	; 16/12/2022
 20175 000030C4 E969E8                  	jmp	LCritDisk
 20176                                  
 20177                                  ;----------------------------------------------------------------------------
 20178                                  
 20179                                  	; 17/05/2019 - Retro DOS v4.0
 20180                                  
 20181                                  	; MSDOS 6.0
 20182                                  GET_FAST_PATH:
 20183                                  ;hkn; use SS override for FastOpenFlg
 20184 000030C7 36800E[6D12]01          	OR	byte [ss:FastOpenFlg],FastOpen_Set
 20185                                  					;FO. trigger fastopen	;AN000;
 20186 000030CD E82F18                  	call	GETPATH
 20187 000030D0 9C                      	PUSHF			 	;FO.			;AN000;
 20188 000030D1 368026[6D12]80          	AND	byte [ss:FastOpenFlg],Fast_yes 
 20189                                  					;FO. clear all fastopen flags ;AN000;
 20190 000030D7 9D                      	POPF				;FO.			;AN000;
 20191 000030D8 C3                      	retn
 20192                                  
 20193                                  ;============================================================================
 20194                                  ; DUP.ASM, MSDOS 6.0, 1991
 20195                                  ;============================================================================
 20196                                  ; 08/08/2018 - Retro DOS v3.0
 20197                                  ; 17/05/2019 - Retro DOS v4.0
 20198                                  
 20199                                  ;** 	Low level DUP routine for use by EXEC when creating a new process.
 20200                                  ;   	Exports the DUP to the server machine and increments the SFT ref count
 20201                                  ;
 20202                                  ;	DOS_DUP
 20203                                  ;
 20204                                  ;	Modification history:
 20205                                  ;
 20206                                  ;	  Created: ARR 30 March 1983
 20207                                  
 20208                                  ;BREAK <DOS_DUP -- DUP SFT across network>
 20209                                  ;---------------------------------------------------------------------------
 20210                                  ; Procedure Name : DOS_DUP
 20211                                  ;
 20212                                  ; Inputs:
 20213                                  ;	[THISSFT] set to the SFT for the file being DUPed
 20214                                  ;		(a non net SFT is OK, in this case the ref
 20215                                  ;		 count is simply incremented)
 20216                                  ; Function:
 20217                                  ;	Signal to the devices that a logical open is occurring
 20218                                  ; Returns:
 20219                                  ;	ES:DI point to SFT
 20220                                  ;    Carry clear
 20221                                  ;	SFT ref_count is incremented
 20222                                  ; Registers modified: None.
 20223                                  ; NOTE:
 20224                                  ;	This routine is called from $CREATE_PROCESS_DATA_BLOCK at DOSINIT
 20225                                  ;	time with SS NOT DOSGROUP. There will be no Network handles at
 20226                                  ;	that time.
 20227                                  ;---------------------------------------------------------------------------
 20228                                  
 20229                                  DOS_DUP:
 20230                                  	;LES	DI,[CS:THISSFT]  ; MSDOS 3.3
 20231                                  
 20232                                  	; MSDOS 6.0
 20233 000030D9 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 20234 000030DE 26C43E[9E05]            	les	di,[es:THISSFT]
 20235                                  
 20236                                  	;Entry	Dos_Dup_Direct
 20237                                  DOS_Dup_Direct:
 20238 000030E3 E874E7                  	call	IsSFTNet
 20239 000030E6 7503                    	JNZ	short DO_INC
 20240 000030E8 E8E11E                  	call	DEV_OPEN_SFT
 20241                                  DO_INC:
 20242                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 20243 000030EB 26FF05                  	inc	word [ES:DI]		; Clears carry (if this ever wraps
 20244                                  					;   we're in big trouble anyway)
 20245 000030EE C3                      	retn
 20246                                  
 20247                                  ;============================================================================
 20248                                  ; CREATE.ASM, MSDOS 6.0, 1991
 20249                                  ;============================================================================
 20250                                  ; 08/08/2018 - Retro DOS v3.0
 20251                                  ; 18/05/2019 - Retro DOS v4.0
 20252                                  
 20253                                  ;TITLE	DOS_CREATE/DOS_CREATE_NEW - Internal CREATE calls for MS-DOS
 20254                                  ;NAME	DOS_CREATE
 20255                                  ;----------------------------------------------------------------------------
 20256                                  ;**	Internal Create and Create new to create a local or NET file and SFT.
 20257                                  ;
 20258                                  ;	DOS_CREATE
 20259                                  ;	DOS_CREATE_NEW
 20260                                  ;	SET_MKND_ERR
 20261                                  ;	SET_Media_ID
 20262                                  ;	SET_EXT_Mode
 20263                                  ;
 20264                                  ;	Revision history:
 20265                                  ;
 20266                                  ;	    A000 version 4.00	  Jan. 1988
 20267                                  ;	    A001  D490 -- Change IOCTL subfunctios from 63h,43h to 66h, 46h
 20268                                  
 20269                                  ;Installed = TRUE
 20270                                  
 20271                                  ;	i_need	THISSFT,DWORD
 20272                                  ;	i_need	THISCDS,DWORD
 20273                                  ;	I_need	EXTERR,WORD
 20274                                  ;	I_Need	ExtErr_locus,BYTE
 20275                                  ;	I_need	JShare,DWORD
 20276                                  ;	I_need	VOLCHNG_FLAG,BYTE
 20277                                  ;	I_need	SATTRIB,BYTE
 20278                                  ;	I_need	CALLVIDM,DWORD
 20279                                  ;	I_need	EXTOPEN_ON,BYTE 		  ;AN000; extended open
 20280                                  ;	I_need	NAME1,BYTE			  ;AN000;
 20281                                  ;	I_need	NO_NAME_ID,BYTE 		  ;AN000;
 20282                                  ;	I_need	Packet_Temp,WORD		  ;AN000;
 20283                                  ;	I_need	DOS34_FLAG,WORD 		  ;AN000;
 20284                                  ;	I_need	SAVE_BX,WORD			  ;AN000;
 20285                                  
 20286                                  ;***	DOS_CREATE - Create a File
 20287                                  ;----------------------------------------------------------------------------
 20288                                  ;	DOS_Create is called to create the specified file, truncating
 20289                                  ;	the old one if it exists.
 20290                                  ;
 20291                                  ;	ENTRY	AX is Attribute to create
 20292                                  ;		(ds) = DOSDATA
 20293                                  ;		[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 20294                                  ;			terminated)
 20295                                  ;		[CURR_DIR_END] Points to end of Current dir part of string
 20296                                  ;			( = -1 if current dir not involved, else
 20297                                  ;			 Points to first char after last "/" of current dir part)
 20298                                  ;		[THISCDS] Points to CDS being used
 20299                                  ;			(Low word = -1 if NUL CDS (Net direct request))
 20300                                  ;		[THISSFT] Points to SFT to fill in if file created
 20301                                  ;			(sf_mode field set so that FCB may be detected)
 20302                                  ;		[SATTRIB] Is attribute of search, determines what files can be found
 20303                                  ;
 20304                                  ;	EXIT	sf_ref_count is NOT altered
 20305                                  ;		CARRY CLEAR
 20306                                  ;		    THISSFT filled in.
 20307                                  ;			sf_mode = unchanged for FCB, sharing_compat + open_for_both
 20308                                  ;		CARRY SET
 20309                                  ;		    AX is error code
 20310                                  ;			error_path_not_found
 20311                                  ;				Bad path (not in curr dir part if present)
 20312                                  ;			error_bad_curr_dir
 20313                                  ;				Bad path in current directory part of path
 20314                                  ;			error_access_denied
 20315                                  ;				Attempt to re-create read only file , or
 20316                                  ;				create a second volume id or create a dir
 20317                                  ;			error_sharing_violation
 20318                                  ;				The sharing mode was correct but not allowed
 20319                                  ;				generates an INT 24
 20320                                  ;	USES	all but DS
 20321                                  ;----------------------------------------------------------------------------
 20322                                  
 20323                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20324                                  	; DOSCODE:6920h (MSDOS 5.0, MSDOS.SYS)
 20325                                  
 20326                                  	; 01/02/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 20327                                  	; DOSCODE:708Ah (PCDOS 7.1, IBMDOS.COM)
 20328                                  
 20329                                  DOS_CREATE:
 20330                                  	; 18/05/2019 - Retro DOS v4.0
 20331                                  	; DOSCODE:6934h (MSDOS 6.21, MSDOS.SYS)
 20332                                  
 20333                                  ;hkn; dispatched to from file.asm and fcbio.asm. DS set up to DOSDATA at 
 20334                                  ;hkn; this point.
 20335                                  
 20336 000030EF 30E4                    	XOR	AH,AH		; Truncate is OK
 20337                                  
 20338                                  ;	Enter here from Dos_Create_New
 20339                                  ;
 20340                                  ;	(ah) = 0 iff truncate OK
 20341                                  
 20342                                  Create_inter:
 20343 000030F1 A8C0                    	TEST	AL,~(attr_all+attr_ignore+attr_volume_id) ; 80h
 20344                                  				; Mask out any meaningless bits
 20345 000030F3 7511                    	JNZ	short AttErr
 20346 000030F5 A808                    	TEST	AL,attr_volume_id
 20347 000030F7 7407                    	JZ	short NoReset
 20348                                  	
 20349                                  	; MSDOS 6.0
 20350                                  	; 16/12/2022
 20351 000030F9 800E[1106]80            	OR	byte [DOS34_FLAG],DBCS_VOLID ; 80h ;AN000;FOR dbcs volid
 20352                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20353                                  	;or	word [DOS34_FLAG],DBCS_VOLID ; 80h 
 20354                                  	
 20355 000030FE B008                    	MOV	AL,attr_volume_id ; 8
 20356                                  NoReset:
 20357 00003100 0C20                    	OR	AL,attr_archive ; File changed  ; 20h
 20358 00003102 A850                    	TEST	AL,attr_directory+attr_device ; 50h
 20359 00003104 7408                    	JZ	short ATT_OK
 20360                                  AttErr:
 20361 00003106 B80500                  	MOV	AX,5		; Attribute problem
 20362                                  	;MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1
 20363                                  	; 01/02/2024
 20364 00003109 E8E9E1                  	call	set_exerr_locus_unk
 20365 0000310C EB62                    	JMP	SHORT SET_MKND_ERR ; Gotta use MKDIR to make dirs, NEVER allow
 20366                                  				   ;	attr_device to be set.
 20367                                  ATT_OK:
 20368 0000310E C43E[9E05]              	LES	DI,[THISSFT]
 20369 00003112 06                      	PUSH	ES
 20370 00003113 C436[A205]              	LES	SI,[THISCDS]
 20371 00003117 83FEFF                  	CMP	SI,-1
 20372 0000311A 751B                    	JNE	short TEST_RE_NET
 20373                                  
 20374                                  ;	No CDS, it must be redirected.
 20375                                  
 20376 0000311C 07                      	POP	ES
 20377                                  
 20378                                  	; MSDOS 6.0
 20379                                  ;Extended open hooks
 20380                                  	;test	byte [EXTOPEN_ON],1
 20381 0000311D F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 20382 00003122 740D                    	JZ	short NOEXTOP 		    ;AN000;EO. no, do normal
 20383                                  IFS_extopen:				    ;AN000;EO.
 20384 00003124 50                      	PUSH	AX			    ;AN000;EO. pass create attr
 20385                                  	;MOV	AX,(MultNET SHL 8) OR 46    ;AN000;EO. issue extended open verb
 20386 00003125 B82E11                  	mov	ax,112Eh
 20387                                  NOEXTOP2:	; 01/02/2024 (PCDOS 7.1 IBMDOS.COM)
 20388 00003128 CD2F                    	INT	2FH			    ;AN000;EO.
 20389 0000312A 5B                      	POP	BX			    ;AN000;EO. trash bx
 20390 0000312B C606[F605]00            	MOV	byte [EXTOPEN_ON],0	    ;AN000;EO.
 20391 00003130 C3                      	retn				    ;AN000;EO.
 20392                                  NOEXTOP:				    ;AN000;
 20393                                  ;Extended open hooks
 20394                                  
 20395                                  ;IF NOT Installed
 20396                                  ;	transfer NET_SEQ_CREATE
 20397                                  ;ELSE
 20398 00003131 50                      	PUSH	AX
 20399                                  
 20400                                  	;MOV	AX,(MultNET SHL 8) OR 24
 20401                                  	;INT	2FH
 20402                                  
 20403 00003132 B81811                  	mov     ax,1118h
 20404                                  	; 01/02/2024
 20405                                  	;int     2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE
 20406                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 20407                                  			; SDA first filename pointer -> fully-qualified name of file
 20408                                  			; STACK: WORD file creation mode???
 20409                                  
 20410                                  	;POP	BX			; BX is trashed anyway
 20411                                  	;retn
 20412 00003135 EBF1                    	jmp	short NOEXTOP2 ; 01/02/2024
 20413                                  ;ENDIF
 20414                                  
 20415                                  ;	We have a CDS. See if it's network
 20416                                  
 20417                                  TEST_RE_NET:
 20418                                  	;;test	word [es:si+43h],8000h
 20419                                  	;TEST	word [ES:SI+curdir.flags],curdir_isnet
 20420                                  	; 07/12/2022
 20421                                  	;test	byte [es:si+44h],80h
 20422                                  	; 17/12/2022
 20423 00003137 26F6444480              	test	byte [ES:SI+curdir.flags+1],curdir_isnet>>8
 20424 0000313C 07                      	POP	ES
 20425 0000313D 7417                    	JZ	short LOCAL_CREATE
 20426                                  
 20427                                  	; MSDOS 6.0
 20428 0000313F E8CA00                  	CALL	Set_EXT_mode		    ;AN000;EO.
 20429 00003142 7205                    	JC	SHORT dochk		    ;AN000;EO.
 20430                                  	;;or	word [es:di+2],2
 20431                                  	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.
 20432                                  	; 17/12/2022
 20433 00003144 26804D0202              	or	byte [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.
 20434                                  
 20435                                  ;Extended open hooks
 20436                                  dochk:
 20437 00003149 F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 20438 0000314E 75D4                    	JNZ	short IFS_extopen	    ;AN000;EO. yes, issue extended open
 20439                                  ;Extended open hooks
 20440                                  
 20441                                  ;IF NOT Installed
 20442                                  ;	transfer NET_CREATE
 20443                                  ;ELSE
 20444 00003150 50                      	PUSH	AX
 20445                                  	
 20446                                  	;MOV	AX,(MultNET SHL 8) OR 23
 20447                                  	;INT	2FH
 20448                                  	
 20449 00003151 B81711                  	mov     ax,1117h
 20450                                  	
 20451                                  	; 01/02/2024
 20452                                  	;int     2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
 20453                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 20454                                  			; SDA first filename pointer -> fully-qualified name of file to open
 20455                                  			; SDA CDS pointer -> current directory
 20456                                  			; Return: CF set on error
 20457                                  
 20458                                  	;POP	BX			; BX is trashed anyway
 20459                                  ;nomore:
 20460                                  	;retn
 20461 00003154 EBD2                    	jmp	short NOEXTOP2 ; 01/02/2024
 20462                                  ;ENDIF
 20463                                  
 20464                                  ;**	It's a local create. We have a local CDS for it.
 20465                                  
 20466                                  LOCAL_CREATE:
 20467                                  	; MSDOS 6.0
 20468 00003156 E8B300                  	CALL	Set_EXT_mode	;AN000;EO. set mode if from extended open
 20469 00003159 7205                    	JC	short setdone	;AN000;EO.
 20470                                  	
 20471                                  	; MSDOS 3.3 & MSDOS 6.0
 20472                                  	; 17/12/2022
 20473                                  	;;or	word [es:di+2],2
 20474                                  	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 20475                                  	;or	byte [es:di+2],2
 20476 0000315B 26804D0202              	or	byte [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 20477                                  setdone:
 20478 00003160 E8A0E7                  	call	ECritDisk
 20479 00003163 E80522                  	call	MakeNode
 20480 00003166 7317                    	JNC	short Create_ok
 20481 00003168 C606[A10A]FF            	mov	byte [VOLCHNG_FLAG],-1	; indicate no change in volume label
 20482 0000316D E8C0E7                  	call	LCritDisk
 20483                                  
 20484                                  	;entry	SET_MKND_ERR
 20485                                  SET_MKND_ERR:
 20486                                  
 20487                                  ;	Looks up MakeNode errors and converts them. AL is MakeNode
 20488                                  ;	error, SI is GETPATH bad spot return if path_not_found error.
 20489                                  
 20490                                  ;hkn; CRTERRTAB is in TABLE seg (DOSCODE)
 20491 00003170 BB[7731]                	MOV     BX,CRTERRTAB
 20492                                  	;XLAT  ; MSDOS 3.3
 20493                                  	; 18/05/2019 - Retro DOS v4.0
 20494 00003173 2E                      	CS
 20495 00003174 D7                      	XLAT
 20496                                  CreatBadRet:
 20497 00003175 F9                      	STC
 20498 00003176 C3                      	retn
 20499                                  
 20500                                  ; 13/05/2019 - Retro DOS v4.0
 20501                                  ; DOSCODE:69C4h (MSDOS 6.21, MSDOS.SYS)
 20502                                  ; ---------------------------------------------------------------------------
 20503                                  
 20504                                  ;** Internal Create and Create new to create a local or NET file and SFT.
 20505                                  
 20506                                  ; 17/07/2018 - Retro DOS v3.0
 20507                                  ; Offset 12B1h of IBMDOS.COM (MSDOS 3.3), 1987
 20508                                  
 20509                                  ;CRTERRTAB: ; 19/07/2018 - MSDOS 3.3	
 20510                                  ;	db	0,5,52h,50h,3,5,20h
 20511                                  
 20512                                  ;CRTERRTAB: ; 18/05/2019 - MSDOS 6.0	
 20513                                  ;	db	0,5,52h,50h,3,5,20h,2
 20514                                  
 20515                                  ; 08/08/2018
 20516                                  
 20517                                  CRTERRTAB:	;LABEL BYTE	; Lookup table for MakeNode returns
 20518 00003177 00                      	DB	0			; none
 20519 00003178 05                      	DB	error_access_denied	; MakeNode error 1
 20520 00003179 52                      	DB	error_cannot_make	; MakeNode error 2
 20521 0000317A 50                      	DB	error_file_exists	; MakeNode error 3
 20522 0000317B 03                      	DB	error_path_not_found	; MakeNode error 4
 20523 0000317C 05                      	DB	error_access_denied	; MakeNode error 5
 20524 0000317D 20                      	DB	error_sharing_violation ; MakeNode error 6
 20525                                  	; MSDOS 6.0
 20526 0000317E 02                      	DB	error_file_not_found	; MakeNode error 7
 20527                                  
 20528                                  ; ---------------------------------------------------------------------------
 20529                                  
 20530                                  ; We have just created a new file. This results in the truncation of old
 20531                                  ; files. We must inform the sharer to slash all the open SFT's for this
 20532                                  ; file to the current size.
 20533                                  
 20534                                  ; If we created a volume id on the diskette, set the VOLCHNG_FLAG to logical
 20535                                  ; drive number to force a Build BPB after Media Check.
 20536                                  
 20537                                  ;;; FASTOPEN 8/29/86
 20538                                  Create_ok:
 20539 0000317F E8E2FB                  	call	FastOpen_Delete
 20540                                  ;;; FASTOPEN 8/29/86
 20541 00003182 A0[6D05]                	mov	al,[SATTRIB]
 20542 00003185 A808                    	test	al,attr_volume_id
 20543 00003187 741C                    	jz	short NoVolLabel
 20544 00003189 C43E[A205]              	LES	DI,[THISCDS]
 20545                                  	;mov	ah,[ES:DI+curdir.text]	; get drive letter
 20546 0000318D 268A25                  	mov	ah,[ES:DI] ; 09/08/2018
 20547 00003190 80EC41                  	sub	ah,'A'	; 41h		; convert to drive number
 20548 00003193 8826[A10A]              	mov	[VOLCHNG_FLAG],ah	;Set flag to indicate volid change
 20549                                  	
 20550                                  	; 18/05/2019 - Retro DOS v4.0
 20551                                  
 20552                                  	; MSDOS 6.0
 20553 00003197 B701                    	MOV	BH,1			;AN000;>32mb set volume id to boot record
 20554 00003199 E81F00                  	CALL	Set_Media_ID		;AN000;>32mb
 20555                                  	
 20556 0000319C E864E7                  	call	ECritDisk
 20557 0000319F E8122F                  	call	FATREAD_CDS		; force a media check
 20558 000031A2 E88BE7                  	call	LCritDisk
 20559                                  
 20560                                  NoVolLabel:
 20561 000031A5 B80200                  	MOV	ax,2
 20562 000031A8 C43E[9E05]              	LES	DI,[THISSFT]
 20563                                  ;if installed
 20564                                  	;call	JShare + 14 * 4
 20565 000031AC FF1E[C800]              	call	far [JShare+(14*4)] ; 14 = ShSU
 20566                                  ;else
 20567                                  ;	Call	ShSU
 20568                                  ;endif
 20569 000031B0 E87DE7                  	call	LCritDisk
 20570 000031B3 E95601                  	jmp	SET_SFT_MODE
 20571                                  
 20572                                  ;---------------------------------------------------------------------------
 20573                                  ; Procedure Name : Dos_Create_New
 20574                                  ;
 20575                                  ; Inputs:
 20576                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 20577                                  ;		terminated)
 20578                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 20579                                  ;		( = -1 if current dir not involved, else
 20580                                  ;		 Points to first char after last "/" of current dir part)
 20581                                  ;	[THISCDS] Points to CDS being used
 20582                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 20583                                  ;	[THISSFT] Points to SFT to fill in if file created
 20584                                  ;		(sf_mode field set so that FCB may be detected)
 20585                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 20586                                  ;	AX is Attribute to create
 20587                                  ; Function:
 20588                                  ;	Try to create the specified file truncating an old one that exists
 20589                                  ; Outputs:
 20590                                  ;	sf_ref_count is NOT altered
 20591                                  ;	CARRY CLEAR
 20592                                  ;	    THISSFT filled in.
 20593                                  ;		sf_mode = sharing_compat + open_for_both for Non-FCB SFT
 20594                                  ;	CARRY SET
 20595                                  ;	    AX is error code
 20596                                  ;		error_path_not_found
 20597                                  ;			Bad path (not in curr dir part if present)
 20598                                  ;		error_bad_curr_dir
 20599                                  ;			Bad path in current directory part of path
 20600                                  ;		error_access_denied
 20601                                  ;			Create a second volume id or create a dir
 20602                                  ;		error_file_exists
 20603                                  ;			Already a file by this name
 20604                                  ; DS preserved, others destroyed
 20605                                  ;---------------------------------------------------------------------------
 20606                                  
 20607                                  DOS_Create_New:
 20608 000031B6 B401                    	MOV	AH,1		; Truncate is NOT OK
 20609 000031B8 E936FF                  	JMP	Create_inter
 20610                                  
 20611                                  ; MSDOS 6.0
 20612                                  ;---------------------------------------------------------------------------
 20613                                  ; Procedure Name : Set_Media_ID
 20614                                  ;
 20615                                  ; Inputs:
 20616                                  ;	NAME1= Volume ID
 20617                                  ;	BH= 0, delete volume id
 20618                                  ;	    1, set new volume id
 20619                                  ;	DS= DOSGROUP
 20620                                  ; Function:
 20621                                  ;	Set Volume ID to DOS 4.00 Boot record.
 20622                                  ; Outputs:
 20623                                  ;	CARRY CLEAR
 20624                                  ;	    volume id set
 20625                                  ;	CARRY SET
 20626                                  ;	    AX is error code
 20627                                  ;---------------------------------------------------------------------------
 20628                                  
 20629                                  	; 18/05/2019 - Retro DOS v4.0
 20630                                  	; 01/02/2024 - Retro DOS v5.0
 20631                                  Set_Media_ID:
 20632 000031BB 50                      	PUSH	AX		;AN000;;>32mb
 20633 000031BC 06                      	PUSH	ES		;AN000;;>32mb
 20634 000031BD 57                      	PUSH	DI		;AN000;;>32mb
 20635                                  
 20636 000031BE FEC4                    	INC	AH		;AN000;;>32mb  bl=drive #
 20637 000031C0 88E3                    	MOV	BL,AH		;AN000;;>32mb  bl=drive # (A=1,B=2,,,)
 20638 000031C2 B00D                    	MOV	AL,0DH		;AN000;;>32mb  generic IOCTL
 20639                                  	;MOV	CX,0866H	;AN001;;>32mb  get media id
 20640                                  	; 01/02/2024
 20641                                  	; (PCDOS 7.1 IBMDOS.COM)
 20642 000031C4 B96648                  	mov	cx,4866h	; ch = FAT32 disk drive (CATEGORY CODE)
 20643                                  				; cl = minor code,
 20644                                  				;      get volume serial number (and name)
 20645                                  
 20646                                  ;hkn; PACKET_TEMP is in DOSDATA
 20647 000031C7 BA[BD0D]                	MOV	DX,Packet_Temp	;AN000;>32mb
 20648                                  
 20649                                  Set_Media_ID_1:
 20650                                  	; 01/02/2024
 20651 000031CA 51                      	push	cx
 20652                                  
 20653 000031CB 53                      	PUSH	BX		;AN000;;>32mb
 20654 000031CC 52                      	PUSH	DX		;AN000;;>32mb
 20655 000031CD 30FF                    	XOR	BH,BH		;AN000;;>32mb
 20656                                  
 20657                                  	;invoke	$IOCTL		;AN000;;>32mb
 20658 000031CF E8DCF6                  	call	_$IOCTL	
 20659                                  
 20660 000031D2 5A                      	POP	DX		;AN000;;>32mb
 20661 000031D3 5B                      	POP	BX		;AN000;;>32mb
 20662                                  
 20663                                  	; 01/02/2024
 20664 000031D4 59                      	pop	cx
 20665                                  	;JC	short geterr	;AN000;;>32mb
 20666 000031D5 730A                    	jnc	short Set_Media_ID_2
 20667 000031D7 80FD48                  	cmp	ch,48h		; is it FAT32 disk drive request?
 20668 000031DA F9                      	stc
 20669 000031DB 7529                    	jne	short geterr	; (ch=8 request failed!)
 20670 000031DD B508                    	mov	ch,8		; set category code for (old) FAT disk drive
 20671                                  				; (except FAT32)
 20672 000031DF EBE9                    	jmp     short Set_Media_ID_1 ; and try again
 20673                                  
 20674                                  Set_Media_ID_2:
 20675 000031E1 08FF                    	OR	BH,BH		;AN000;;>32mb delete volume id
 20676 000031E3 7405                    	JZ	short NoName	;AN000;>32mb yes
 20677                                  
 20678                                  ;hkn; NAME1 is in DOSDATA
 20679 000031E5 BE[4B05]                	MOV	SI,NAME1	;AN000;>32mb
 20680                                  
 20681 000031E8 EB03                    	JMP	SHORT doset	;AN000;>32mb yes
 20682                                  NoName: 			;AN000;
 20683                                  
 20684                                  ;hkn; NO_NAME_ID is in DOSDATA
 20685 000031EA BE[0A0E]                	MOV	SI,NO_NAME_ID	;AN000;>32mb
 20686                                  
 20687                                  doset:				;AN000;
 20688 000031ED 89D7                    	MOV	DI,DX		;AN000;;>32mb
 20689                                  	;add	di,6
 20690 000031EF 83C706                  	ADD	DI,MEDIA_ID_INFO.MEDIA_Label ;AN000;;>32mb
 20691                                  
 20692                                  ;hkn; ES & DS must point to SS
 20693                                  ;hkn;	PUSH	CS		;AN000;;>32mb  move new volume id to packet
 20694 000031F2 16                      	PUSH	SS		;AN000;;>32mb  move new volume id to packet
 20695                                  
 20696 000031F3 1F                      	POP	DS		;AN000;;>32mb
 20697                                  
 20698                                  ;hkn;	PUSH	CS		;AN000;;>32mb
 20699 000031F4 16                      	PUSH	SS		;AN000;;>32mb
 20700                                  
 20701 000031F5 07                      	POP	ES		;AN000;;>32mb
 20702                                  
 20703                                  	; 01/02/2024
 20704 000031F6 51                      	push	cx
 20705                                  
 20706 000031F7 B90B00                  	MOV	CX,11		;AN000;;>32mb
 20707 000031FA F3A4                    	REP	MOVSB		;AN000;;>32mb
 20708                                  
 20709                                  	;MOV	CX,0846H	;AN001;;>32mb
 20710                                  	; 01/02/2024
 20711 000031FC 59                      	pop	cx
 20712 000031FD B146                    	mov	cl,46h		; set volume serial number (and name)
 20713                                  	;
 20714 000031FF B00D                    	MOV	AL,0DH		;AN000;;>32mb
 20715 00003201 30FF                    	XOR	BH,BH		;AN000;;>32mb
 20716                                  	;invoke	$IOCTL		;AN000;;>32mb  set volume id
 20717 00003203 E8A8F6                  	call	_$IOCTL	
 20718                                  geterr: 			;AN000;
 20719                                  ;hkn;	PUSH	CS		;AN000;>32mb
 20720 00003206 16                      	PUSH	SS		;AN000;>32mb
 20721                                  
 20722 00003207 1F                      	POP	DS		;AN000;>32mb   ds= dosgroup
 20723                                  
 20724 00003208 5F                      	POP	DI		;AN000;;>32mb
 20725 00003209 07                      	POP	ES		;AN000;;>32mb
 20726 0000320A 58                      	POP	AX		;AN000;;>32mb
 20727 0000320B C3                      	retn			;AN000;>32mb
 20728                                  
 20729                                  ; MSDOS 6.0
 20730                                  ;---------------------------------------------------------------------------
 20731                                  ; Procedure Name : Set_EXT_mode
 20732                                  ;
 20733                                  ; Inputs:
 20734                                  ;	[EXTOPEN_ON]= flag for extended open
 20735                                  ;	SAVE_BX= mode specified in Extended Open
 20736                                  ; Function:
 20737                                  ;	Set mode in ThisSFT
 20738                                  ; Outputs:
 20739                                  ;	carry set,mode is set if from Extended Open
 20740                                  ;	carry clear, mode not set yet
 20741                                  ;---------------------------------------------------------------------------
 20742                                  
 20743                                  ; 13/05/2019 - Retro DOS v4.0
 20744                                  
 20745                                  Set_EXT_mode:
 20746                                  
 20747                                  ;hkn; SS override
 20748 0000320C 36F606[F605]01          	TEST	byte [ss:EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 20749 00003212 740B                    	JZ	short NOTEX		    ;AN000;EO. no, do normal
 20750 00003214 50                      	PUSH	AX			    ;AN000;EO.
 20751                                  
 20752                                  ;hkn; SS override
 20753 00003215 36A1[0106]              	MOV	AX,[ss:SAVE_BX]		    ;AN000;EO.
 20754                                  	;or	[es:di+2],ax
 20755 00003219 26094502                	OR	[ES:DI+SF_ENTRY.sf_mode],AX ;AN000;EO.
 20756 0000321D 58                      	POP	AX			    ;AN000;EO.
 20757 0000321E F9                      	STC				    ;AN000;EO.
 20758                                  NOTEX:					    ;AN000;
 20759 0000321F C3                      	retn				    ;AN000;EO.
 20760                                  
 20761                                  ;============================================================================
 20762                                  ; OPEN.ASM, MSDOS 6.0, 1991
 20763                                  ;============================================================================
 20764                                  ; 08/08/2018 - Retro DOS v3.0
 20765                                  ; 18/05/2019 - Retro DOS v4.0
 20766                                  
 20767                                  ;	TITLE	DOS_OPEN - Internal OPEN call for MS-DOS
 20768                                  ;	NAME	DOS_OPEN
 20769                                  
 20770                                  ;**	OPEN.ASM - File Open
 20771                                  ;----------------------------------------------------------------------------
 20772                                  ;	Low level routines for openning a file from a file spec.
 20773                                  ;	Also misc routines for sharing errors
 20774                                  ;
 20775                                  ;	DOS_Open
 20776                                  ;	Check_Access_AX
 20777                                  ;	SHARE_ERROR
 20778                                  ;	SET_SFT_MODE
 20779                                  ;	Code_Page_Mismatched_Error		   ; DOS 4.00
 20780                                  ;
 20781                                  ;	Revision history:
 20782                                  ;
 20783                                  ;	    Created: ARR 30 March 1983
 20784                                  ;	    A000	version 4.00   Jan. 1988
 20785                                  ;
 20786                                  ;	M034 - The value in save_bx must be pushed on to the stack for
 20787                                  ; 	       remote extended opens and not save_cx.
 20788                                  ;
 20789                                  ;	M035 - if open made from exec then we must set the appropriate bits
 20790                                  ;	       on the stack before calling off to the redir.
 20791                                  ;	M042 - Bit 11 of DOS34_FLAG set indicates that the redir knows how 
 20792                                  ;	       to handle open from exec. In this case set the appropriate bit
 20793                                  ;	       else do not.
 20794                                  ;----------------------------------------------------------------------------	
 20795                                  
 20796                                  ;Installed = TRUE
 20797                                  
 20798                                  ;	i_need	NoSetDir,BYTE
 20799                                  ;	i_need	THISSFT,DWORD
 20800                                  ;	i_need	THISCDS,DWORD
 20801                                  ;	i_need	CURBUF,DWORD
 20802                                  ;	i_need	CurrentPDB,WORD
 20803                                  ;	i_need	CURR_DIR_END,WORD
 20804                                  ;	I_need	RetryCount,WORD
 20805                                  ;	I_need	Open_Access,BYTE
 20806                                  ;	I_need	fSharing,BYTE
 20807                                  ;	i_need	JShare,DWORD
 20808                                  ;	I_need	FastOpenFlg,byte
 20809                                  ;	I_need	EXTOPEN_ON,BYTE 		  ;AN000;; DOS 4.00
 20810                                  ;	I_need	ALLOWED,BYTE			  ;AN000;; DOS 4.00
 20811                                  ;	I_need	EXTERR,WORD			  ;AN000;; DOS 4.00
 20812                                  ;	I_need	EXTERR_LOCUS,BYTE		  ;AN000;; DOS 4.00
 20813                                  ;	I_need	EXTERR_ACTION,BYTE		  ;AN000;; DOS 4.00
 20814                                  ;	I_need	EXTERR_CLASS,BYTE		  ;AN000;; DOS 4.00
 20815                                  ;	I_need	CPSWFLAG,BYTE			  ;AN000;; DOS 4.00
 20816                                  ;	I_need	EXITHOLD,DWORD			  ;AN000;; DOS 4.00
 20817                                  ;	I_need	THISDPB,DWORD			  ;AN000;; DOS 4.00
 20818                                  ;	I_need	SAVE_CX,WORD			  ;AN000;; DOS 4.00
 20819                                  ;	I_need	SAVE_BX,WORD			  ;M034
 20820                                  ;
 20821                                  ;	I_need	DOS_FLAG,BYTE
 20822                                  ;	I_need	DOS34_FLAG,WORD			  ;M042
 20823                                  
 20824                                  ;Break	<DOS_Open - internal file access>
 20825                                  ;---------------------------------------------------------------------------
 20826                                  ; Procedure Name : DOS_Open
 20827                                  ;
 20828                                  ; Inputs:
 20829                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 20830                                  ;		terminated)
 20831                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 20832                                  ;		( = -1 if current dir not involved, else
 20833                                  ;		 Points to first char after last "/" of current dir part)
 20834                                  ;	[THISCDS] Points to CDS being used
 20835                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 20836                                  ;	[THISSFT] Points to SFT to fill in if file found
 20837                                  ;		(sf_mode field set so that FCB may be detected)
 20838                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 20839                                  ;	AX is Access and Sharing mode
 20840                                  ;	  High NIBBLE of AL (Sharing Mode)
 20841                                  ;		sharing_compat	   file is opened in compatibility mode
 20842                                  ;		sharing_deny_none  file is opened Multi reader, Multi writer
 20843                                  ;		sharing_deny_read  file is opened Only reader, Multi writer
 20844                                  ;		sharing_deny_write file is opened Multi reader, Only writer
 20845                                  ;		sharing_deny_both  file is opened Only reader, Only writer
 20846                                  ;	  Low NIBBLE of AL (Access Mode)
 20847                                  ;		open_for_read	file is opened for reading
 20848                                  ;		open_for_write	file is opened for writing
 20849                                  ;		open_for_both	file is opened for both reading and writing.
 20850                                  ;
 20851                                  ;	  For FCB SFTs AL should = sharing_compat + open_for_both
 20852                                  ;		(not checked)
 20853                                  ; Function:
 20854                                  ;	Try to open the specified file
 20855                                  ; Outputs:
 20856                                  ;	sf_ref_count is NOT altered
 20857                                  ;	CARRY CLEAR
 20858                                  ;	    THISSFT filled in.
 20859                                  ;	CARRY SET
 20860                                  ;	    AX is error code
 20861                                  ;		error_file_not_found
 20862                                  ;			Last element of path not found
 20863                                  ;		error_path_not_found
 20864                                  ;			Bad path (not in curr dir part if present)
 20865                                  ;		error_bad_curr_dir
 20866                                  ;			Bad path in current directory part of path
 20867                                  ;		error_invalid_access
 20868                                  ;			Bad sharing mode or bad access mode or bad combination
 20869                                  ;		error_access_denied
 20870                                  ;			Attempt to open read only file for writting, or
 20871                                  ;			open a directory
 20872                                  ;		error_sharing_violation
 20873                                  ;			The sharing mode was correct but not allowed
 20874                                  ;			generates an INT 24 on compatibility mode SFTs
 20875                                  ; DS preserved, others destroyed
 20876                                  ;----------------------------------------------------------------------------
 20877                                  
 20878                                  ; 18/05/2019 - Retro DOS v4.0
 20879                                  ; DOSCODE:6A60h (MSDOS 6.21, MSDOS.SYS)
 20880                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20881                                  ; DOSCODE:6A4Ch (MSDOS 5.0, MSDOS.SYS)
 20882                                  
 20883                                  ; 01/02/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 20884                                  ; DOSCODE:71BBh (PCDOS 7.1, IBMDOS.COM)
 20885                                  
 20886                                  DOS_OPEN:
 20887                                  	; DS has been set up to DOSDATA in file.asm and fcbio2.asm. 
 20888                                  
 20889 00003220 C606[4C03]00            	MOV	byte [NoSetDir],0
 20890 00003225 E83301                  	CALL	Check_Access_AX
 20891 00003228 722B                    	JC	short do_ret_label	    ; retc
 20892                                  
 20893 0000322A C43E[9E05]              	LES	DI,[THISSFT]
 20894 0000322E 30E4                    	XOR	AH,AH
 20895                                  
 20896                                  	; sleaze! move only access/sharing mode in. Leave sf_isFCB unchanged
 20897                                  
 20898 00003230 26884502                	MOV	[ES:DI+SF_ENTRY.sf_mode],AL ; For moment do this on FCBs too
 20899 00003234 06                      	PUSH	ES
 20900 00003235 C436[A205]              	LES	SI,[THISCDS]
 20901                                  	; 18/08/2018
 20902 00003239 83FEFF                  	CMP	SI,-1 ; 0FFFFh
 20903 0000323C 7530                    	JNZ	short TEST_RE_NET1
 20904 0000323E 07                      	POP	ES
 20905                                  
 20906                                  	; MSDOS 6.0
 20907                                  ;Extended open hooks
 20908 0000323F F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;FT. from extended open		;AN000;
 20909 00003244 7410                    	JZ	short _NOEXTOP 		    ;FT. no, do normal			;AN000;
 20910                                  _IFS_extopen:									;AN000;
 20911 00003246 A0[0106]                	MOV	AL,[SAVE_BX]		    ; M034 - save_bx has original bx  
 20912                                  					    ; with which call was made. This
 20913                                  					    ; has the open access bits. 
 20914                                  	;;MOV	AL,[SAVE_CX]		    ; M034 - FT. al= create attribute
 20915                                  	
 20916 00003249 50                      	PUSH	AX			    ;FT. pass create attr to IFS	;AN000;
 20917                                  	;mov	ax,112Eh
 20918                                  	;MOV	AX,(MultNET SHL 8) OR 46    ;FT. issue extended open verb	;AN000;
 20919 0000324A B82E11                  	mov	ax,(MultNET*256)+46 
 20920 0000324D CD2F                    	INT	2FH			    ;FT.				;AN000;
 20921 0000324F 5B                      	POP	BX			    ;FT. trash bx			;AN000;
 20922 00003250 C606[F605]00            	MOV	byte [EXTOPEN_ON],0	    ;FT.				;AN000;
 20923                                  
 20924                                  do_ret_label:
 20925 00003255 C3                      	retn				    ;FT.				;AN000;
 20926                                  _NOEXTOP:
 20927                                  ;Extended open hooks
 20928                                  	;
 20929                                  ;IF NOT Installed
 20930                                  	;transfer NET_SEQ_OPEN
 20931                                  ;ELSE
 20932                                  	
 20933                                  do_net_int2f:
 20934 00003256 F606[8600]01            	test	byte [DOS_FLAG],EXECOPEN ; Q: was this open call made from exec
 20935 0000325B 7409                    	jz	short not_exec_open	; N: just do net open
 20936                                  					; Y: check to see if redir is aware
 20937                                  					;    of this 
 20938                                  	
 20939                                  					; M042 - start
 20940                                  	;test	word [DOS34_FLAG],EXEC_AWARE_REDIR ; 800h
 20941 0000325D F606[1206]08            	test	byte [DOS34_FLAG+1],(EXEC_AWARE_REDIR>>8)
 20942                                  					; Q: does this redir know how to 
 20943                                  					;    this
 20944 00003262 7402                    	jz	short not_exec_open	; N: just do net open
 20945                                  					; Y: set bit 3 of access byte and 
 20946                                  					;    set sharing mode to DENY_WRITE
 20947                                  					; M042 - end
 20948                                  	
 20949                                  	; NOTE: This specific mode has not been set for the code assembled
 20950                                  	; under the "NOT Installed" conditional. Currently Installed is 
 20951                                  	; always one.
 20952                                  					; M035 - set the bits on the stack
 20953                                  	;mov	al,23h
 20954 00003264 B023                    	mov	AL,SHARING_DENY_WRITE+EXEC_OPEN
 20955                                  	
 20956                                  not_exec_open:
 20957                                  	; MSDOS 3.3 & MSDOS 6.0
 20958 00003266 50                      	PUSH	AX
 20959                                  
 20960                                  	;MOV	AX,(MultNET SHL 8) OR 22
 20961                                  	;INT	2FH
 20962                                  
 20963 00003267 B81611                  	mov     ax,1116h
 20964 0000326A CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE
 20965                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 20966                                  			; SDA first filename pointer -> fully-qualified name of file to open
 20967                                  			; STACK: WORD file open mode
 20968                                  			; Return: CF set on error
 20969                                  
 20970 0000326C 5B                      	POP	BX			; clean stack
 20971                                  ;do_ret_label: ; 09/08/2018
 20972 0000326D C3                      	retn
 20973                                  ;ENDIF
 20974                                  
 20975                                  TEST_RE_NET1:
 20976                                  	;TEST	word [ES:SI+curdir.flags],curdir_isnet
 20977                                  	; 17/12/2022
 20978 0000326E 26F6444480              	test	byte [ES:SI+curdir.flags+1],curdir_isnet>>8
 20979 00003273 07                      	POP	ES
 20980                                  	; 18/05/2019
 20981 00003274 7409                    	JZ	short LOCAL_OPEN
 20982                                  
 20983                                  ;Extended open hooks
 20984                                  	; MSDOS 6.0
 20985 00003276 F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;FT. from extended open	;AN000;
 20986 0000327B 75C9                    	JNZ	short _IFS_extopen	      ;FT. issue extended open	;AN000;
 20987                                  ;Extended open hooks
 20988                                  
 20989                                  ;IF NOT Installed
 20990                                  ;	transfer NET_OPEN
 20991                                  ;ELSE
 20992 0000327D EBD7                    	jmp	short do_net_int2f
 20993                                  ;ENDIF
 20994                                  
 20995                                  LOCAL_OPEN:
 20996                                  	; MSDOS 3.3 & MSDOS 6.0
 20997 0000327F E881E6                  	call	ECritDisk
 20998                                  
 20999                                  ; DOS 3.3 FastOPen 6/16/86
 21000                                  
 21001                                  	;or	byte [FastOpenFlg],5
 21002 00003282 800E[6D12]05            	OR	byte [FastOpenFlg],FastOpen_Set+Special_Fill_Set ; only open can
 21003                                  
 21004 00003287 E87516                  	call	GETPATH
 21005                                  
 21006                                  ; DOS 3.3 FastOPen 6/16/86
 21007                                  
 21008 0000328A 731D                    	JNC	short Open_found
 21009 0000328C 7511                    	JNZ	short bad_path2
 21010 0000328E 08C9                    	OR	CL,CL
 21011 00003290 740D                    	JZ	short bad_path2
 21012                                  OpenFNF:
 21013 00003292 B80200                  	MOV	AX,error_file_not_found	; 2
 21014                                  OpenBadRet:
 21015                                  ;hkn; FastOpenFlg is in DOSDATA use SS override
 21016                                  	; 12/08/2018
 21017                                  	;mov	byte [cs:FastOpenFlg],0 ; IBMDOS.COM (MSDOS 3.3) offset 36CAh
 21018                                  	; MSDOS 6.0
 21019 00003295 368026[6D12]80          	AND	BYTE [SS:FastOpenFlg],Fast_yes    ;; DOS 3.3
 21020 0000329B F9                      	STC
 21021                                  	;call	LCritDisk
 21022                                  	; 16/12/2022
 21023 0000329C E991E6                  	jmp	LCritDisk
 21024                                  	;;JMP	Clear_FastOpen ; 10/08/2018
 21025                                  	;retn 	; 08/09/2018
 21026                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21027                                  	;jmp	Clear_FastOpen
 21028                                  
 21029                                  bad_path2:
 21030 0000329F B80300                  	MOV	AX,error_path_not_found	; 3
 21031 000032A2 EBF1                    	JMP	short OpenBadRet
 21032                                  
 21033                                  Open_Bad_Access:
 21034 000032A4 B80500                  	MOV	AX,error_access_denied	; 5
 21035 000032A7 EBEC                    	JMP	short OpenBadRet
 21036                                  
 21037                                  Open_found:
 21038 000032A9 74F9                    	JZ	short Open_Bad_Access 	; test for directories
 21039 000032AB 08E4                    	OR	AH,AH
 21040 000032AD 783E                    	JS	short open_ok		; Devices don't have attributes
 21041 000032AF 8E06[E405]              	MOV	ES,[CURBUF+2]		; get buffer location
 21042                                  	;mov	al,[es:bx+0Bh]
 21043 000032B3 268A470B                	MOV	AL,[ES:BX+dir_entry.dir_attr]
 21044 000032B7 A808                    	TEST	AL,attr_volume_id	; can't open volume ids
 21045 000032B9 75E9                    	JNZ	short Open_Bad_Access
 21046 000032BB A801                    	TEST	AL,attr_read_only	; check write on read only
 21047 000032BD 742E                    	JZ	short open_ok
 21048                                  
 21049                                  ; The file is marked READ-ONLY. We verify that the open mode allows access to
 21050                                  ; the read-only file. Unfortunately, with FCB's and net-FCB's we cannot
 21051                                  ; determine at the OPEN time if such access is allowed. Thus, we defer such
 21052                                  ; processing until the actual write operation:
 21053                                  ;
 21054                                  ; If FCB, then we change the mode to be read_only.
 21055                                  ; If net_FCB, then we change the mode to be read_only.
 21056                                  ; If not open for read then error.
 21057                                  
 21058 000032BF 1E                      	push	ds
 21059 000032C0 56                      	push	si
 21060 000032C1 C536[9E05]              	LDS	SI,[THISSFT]
 21061                                  	;mov	cx,[si+2]
 21062 000032C5 8B4C02                  	MOV	CX,[SI+SF_ENTRY.sf_mode]
 21063                                  	; 17/12/2022
 21064                                  	;test	ch,80h
 21065 000032C8 F6C580                  	test	ch,sf_isFCB>>8
 21066                                  	;TEST	CX,sf_isFCB ; 8000h	; is it FCB?
 21067 000032CB 750A                    	JNZ	short ResetAccess	; yes, reset the access
 21068 000032CD 88CA                    	MOV	DL,CL
 21069 000032CF 80E2F0                  	AND	DL,SHARING_MASK	; 0F0h
 21070 000032D2 80FA70                  	CMP	DL,SHARING_NET_FCB ; 70h ; is it net FCB?
 21071 000032D5 7508                    	JNZ	short NormalOpen	; no
 21072                                  ResetAccess:
 21073                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)	
 21074                                  	;AND	CX,~access_mask	; 0FFF0h ; clear access
 21075                                  	; 16/12/2022
 21076                                  	;and	cl,0F0h ; 18/05/2019
 21077                                  	;;;
 21078                                  	; 01/02/2024 - Retro DOS v5.0
 21079                                  	; (PCDOS 7.1 IBMDOS.COM)
 21080                                  	;and	cx,0FFFCh
 21081 000032D7 80E1FC                  	and	cl,0FCh ; ~3 ; ~open_mode_mask ; clear access
 21082                                  	;;;
 21083                                  ;	OR	CX,open_for_read ; 0	; stick in open_for_read
 21084 000032DA 894C02                  	MOV	[SI+SF_ENTRY.sf_mode],CX
 21085 000032DD EB0C                    	JMP	SHORT FillSFT
 21086                                  
 21087                                  ; The SFT is normal. See if the requested access is open_for_read
 21088                                  
 21089                                  NormalOpen:
 21090                                  	;AND	CL,access_mask	; 0Fh	; remove extras
 21091                                  	;;;
 21092                                  	; 01/02/2024 - Retro DOS v5.0
 21093                                  	; (PCDOS 7.1 IBMDOS.COM)
 21094 000032DF 80E103                  	and     cl,3		; it was 'and cl,0Fh' in MSDOS 6.22
 21095                                  				; (and cl,access_mask)
 21096                                  				; this may be open_mode_mask
 21097                                  	;;;
 21098 000032E2 80F900                  	CMP	CL,open_for_read ; 0	; is it open for read?
 21099 000032E5 7404                    	JZ	short FillSFT	; yes
 21100 000032E7 5E                      	pop	si
 21101 000032E8 1F                      	pop	ds
 21102 000032E9 EBB9                    	JMP	short Open_Bad_Access
 21103                                  ;
 21104                                  ; All done, restore registers and fill the SFT.
 21105                                  ;
 21106                                  FillSFT:
 21107 000032EB 5E                      	pop	si
 21108 000032EC 1F                      	pop	ds
 21109                                  open_ok:
 21110 000032ED E83922                  	call	DOOPEN			; Fill in SFT
 21111                                  
 21112                                  ;hkn; FastOpenFlg is in DOSDATA. use SS override
 21113                                  	; 18/05/2019
 21114                                  	;and	byte [ss:FastOpenFlag],80h
 21115 000032F0 368026[6D12]80          	AND	BYTE [SS:FastOpenFlg],Fast_yes	;; DOS 3.3
 21116                                  	; 12/08/2018
 21117                                  	;and	byte [FastOpenFlg],Fast_yes	
 21118                                  
 21119                                  	; MSDOS 6.0
 21120 000032F6 E84300                  	CALL	DO_SHARE_CHECK
 21121 000032F9 7303                    	JNC	short SHARE_OK
 21122                                  	;call	LCritDisk
 21123                                  	; 16/12/2022
 21124 000032FB E932E6                  	jmp	LCritDisk
 21125                                  	;;JMP	short Clear_FastOpen
 21126                                  	;retn	; 18/05/2019
 21127                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21128                                  	;jmp	short Clear_FastOpen	
 21129                                  
 21130                                  	; MSDOS 3.3
 21131                                  ;DO_SHARE_CHECK:
 21132                                  ;	MOV	CX,[RetryCount]		; Get # tries to do
 21133                                  ;OpenShareRetry:
 21134                                  ;	push	cx			; Save number left to do
 21135                                  ;	call	SHARE_CHECK		; Final Check
 21136                                  ;	pop	cx			; CX = # left
 21137                                  ;	JNC	short SHARE_OK		; No problem with access
 21138                                  ;	call	Idle
 21139                                  ;	LOOP	OpenShareRetry		; One more retry used up
 21140                                  ;OpenShareFail:
 21141                                  ;	LES	DI,[THISSFT]
 21142                                  ;	call	SHARE_ERROR
 21143                                  ;	JNC	short DO_SHARE_CHECK	; User wants more retry
 21144                                  	
 21145                                  	;12/08/2018
 21146                                  	;mov	byte [ss:FastOpenFlg],0
 21147                                  	;08/09/2018
 21148                                  	;mov	byte [FastOpenFlg],0
 21149                                  	;call	LCritDisk
 21150                                  	;JMP	short Clear_FastOpen
 21151                                  	;retn
 21152                                  
 21153                                  SHARE_OK:
 21154                                  	; MSDOS 3.3 & MSDOS 6.0
 21155 000032FE B80300                  	MOV	AX,3
 21156 00003301 C43E[9E05]              	LES	DI,[THISSFT]
 21157                                  ;if installed
 21158                                  	;call	JShare + 14 * 4
 21159 00003305 FF1E[C800]              	call	far [JShare+(14*4)]  ; 14 = ShSU
 21160                                  ;else
 21161                                  ;	Call	ShSU
 21162                                  ;endif
 21163 00003309 E824E6                  	call	LCritDisk
 21164                                  	
 21165                                  	;FallThru Set_SFT_Mode
 21166                                  
 21167                                  ;----------------------------------------------------------------------------
 21168                                  ; Procedure Name : SET_SFT_MODE
 21169                                  ;
 21170                                  ; Finish SFT initialization for new reference. Set the correct mode.
 21171                                  ;
 21172                                  ;   Inputs:
 21173                                  ;	ThisSFT points to SFT
 21174                                  ;
 21175                                  ;   Outputs:
 21176                                  ;	Carry clear
 21177                                  ;   Registers modified: AX.
 21178                                  ;---------------------------------------------------------------------------
 21179                                  
 21180                                  ;hkn; called from create. DS already set up to DOSDATA.
 21181                                  
 21182                                  SET_SFT_MODE:
 21183 0000330C C43E[9E05]              	LES	DI,[THISSFT]
 21184 00003310 E8B91C                  	call	DEV_OPEN_SFT
 21185                                  	;test	word [es:di+2],8000h
 21186                                  	; 17/12/2022
 21187                                  	;test	byte [es:di+3],80h
 21188 00003313 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],sf_isFCB>>8
 21189                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; Clears carry
 21190 00003318 7407                    	JZ	short Clear_FastOpen	; sf_mode correct (retz)
 21191 0000331A A1[3003]                	MOV	AX,[CurrentPDB]
 21192                                  	;mov	[es:di+31h],ax
 21193 0000331D 26894531                	MOV	[ES:DI+SF_ENTRY.sf_PID],AX ; For FCB sf_PID=PDB
 21194                                  
 21195                                  Clear_FastOpen:
 21196 00003321 C3                      	retn			       ;;;;; DOS 3.3
 21197                                  
 21198                                  ;----------------------------------------------------------------------------
 21199                                  ; Procedure Name : SHARE_ERROR
 21200                                  ;
 21201                                  ; Called on sharing violations. ES:DI points to SFT. AX has error code
 21202                                  ; If SFT is FCB or compatibility mode gens INT 24 error.
 21203                                  ; Returns carry set AX=error_sharing_violation if user says ignore (can't
 21204                                  ; really ignore). Carry clear if user wants a retry. ES, DI, DS preserved
 21205                                  ;---------------------------------------------------------------------------
 21206                                  
 21207                                  SHARE_ERROR:
 21208                                  	; 17/12/2022
 21209                                  	;test	byte [es:di+3],80h
 21210 00003322 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],sf_isFCB>>8 ; 80h
 21211                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; 8000h
 21212 00003327 7509                    	JNZ	short _HARD_ERR
 21213 00003329 268A4D02                	MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
 21214 0000332D 80E1F0                  	AND	CL,SHARING_MASK  ; 0F0h
 21215                                  	;CMP	CL,SHARING_COMPAT ; 0
 21216                                  	;JNE	short _NO_HARD_ERR
 21217                                  	; 21/09/2023
 21218 00003330 7505                    	jnz	short _NO_HARD_ERR
 21219                                  _HARD_ERR:
 21220 00003332 E82E4A                  	call	SHARE_VIOLATION
 21221                                  	;retnc				; User wants retry
 21222 00003335 73EA                    	jnc	short Clear_FastOpen
 21223                                  _NO_HARD_ERR:
 21224 00003337 B82000                  	MOV	AX,error_sharing_violation  ; 20h
 21225 0000333A F9                      	STC
 21226 0000333B C3                      	retn
 21227                                  
 21228                                  ; MSDOS 6.0
 21229                                  ;----------------------------------------------------------------------------
 21230                                  ; Procedure Name : DO_SHARE_CHECK
 21231                                  ;
 21232                                  ; Input: THISDPB, WFP_Start, THISSFT set
 21233                                  ; Functions: check file sharing mode is valid
 21234                                  ; Output: carry set, error
 21235                                  ;	  carry clear, share ok
 21236                                  ;----------------------------------------------------------------------------
 21237                                  
 21238                                  	; 18/05/2019 - Retro DOS v4.0
 21239                                  DO_SHARE_CHECK:
 21240 0000333C E8C4E5                  	call	ECritDisk		; enter critical section
 21241                                  OPN_RETRY:
 21242 0000333F 8B0E[1A00]              	MOV	CX,[RetryCount]		; Get # tries to do
 21243                                  OpenShareRetry:
 21244 00003343 51                      	push	cx			; Save number left to do
 21245 00003344 E8174A                  	call	SHARE_CHECK		; Final Check
 21246 00003347 59                      	pop	cx			; CX = # left
 21247 00003348 730E                    	JNC	short Share_Ok2		; No problem with access
 21248 0000334A E8AFE4                  	call	Idle
 21249 0000334D E2F4                    	LOOP	OpenShareRetry		; One more retry used up
 21250                                  OpenShareFail:
 21251 0000334F C43E[9E05]              	LES	DI,[THISSFT]
 21252 00003353 E8CCFF                  	call	SHARE_ERROR
 21253 00003356 73E7                    	JNC	short OPN_RETRY		; User wants more retry
 21254                                  Share_Ok2:
 21255                                  	;call	LCritDisk		; leave critical section
 21256                                  	;retn
 21257                                  	; 18/12/2022
 21258 00003358 E9D5E5                  	jmp	LCritDisk
 21259                                  
 21260                                  ;-----------------------------------------------------------------------------
 21261                                  ; Procedure Name : Check_Access
 21262                                  ;
 21263                                  ; Inputs:
 21264                                  ;	AX is mode
 21265                                  ;	  High NIBBLE of AL (Sharing Mode)
 21266                                  ;		sharing_compat	   file is opened in compatibility mode
 21267                                  ;		sharing_deny_none  file is opened Multi reader, Multi writer
 21268                                  ;		sharing_deny_read  file is opened Only reader, Multi writer
 21269                                  ;		sharing_deny_write file is opened Multi reader, Only writer
 21270                                  ;		sharing_deny_both  file is opened Only reader, Only writer
 21271                                  ;	  Low NIBBLE of AL (Access Mode)
 21272                                  ;		open_for_read	file is opened for reading
 21273                                  ;		open_for_write	file is opened for writing
 21274                                  ;		open_for_both	file is opened for both reading and writing.
 21275                                  ; Function:
 21276                                  ;	Check this access mode for correctness
 21277                                  ; Outputs:
 21278                                  ;	[open_access] = AL input
 21279                                  ;	Carry Clear
 21280                                  ;		Mode is correct
 21281                                  ;		AX unchanged
 21282                                  ;	Carry Set
 21283                                  ;		Mode is bad
 21284                                  ;		AX = error_invalid_access
 21285                                  ; No other registers effected
 21286                                  ;----------------------------------------------------------------------------
 21287                                  
 21288                                  	; 23/01/2024 - Retro DOS v5.0
 21289                                  Check_Access_AX:
 21290 0000335B A2[6E05]                	MOV	[OPEN_ACCESS],AL
 21291 0000335E 53                      	PUSH	BX
 21292                                  
 21293                                  ;	If sharing, then test for special sharing mode for FCBs
 21294                                  
 21295 0000335F 88C3                    	MOV	BL,AL
 21296 00003361 80E3F0                  	AND	BL,SHARING_MASK ; 0F0h
 21297                                  
 21298                                  	;CMP	byte [FSHARING],-1
 21299                                  	;JNZ	short CheckShareMode	; not through server call, must be ok
 21300                                  	; 23/01/2024
 21301                                  	; PCDOS 7.1 IBMDOS.COM
 21302 00003364 803E[7205]00            	cmp	byte [FSHARING],0
 21303 00003369 7405                    	jz	short CheckShareMode	; not through server call, must be ok
 21304                                  
 21305 0000336B 80FB70                  	CMP	BL,SHARING_NET_FCB ; 70h
 21306 0000336E 7405                    	JZ	short CheckAccessMode	; yes, we have an FCB
 21307                                  CheckShareMode:
 21308 00003370 80FB40                  	CMP	BL,40h			; is this a good sharing mode?
 21309 00003373 770D                    	JA	short Make_Bad_Access
 21310                                  CheckAccessMode:
 21311 00003375 88C3                    	MOV	BL,AL
 21312                                  	; 23/01/2024
 21313 00003377 80E303                  	and	bl,3 ; PCDOS 7.1 IBMDOS.COM	
 21314                                  	;AND	BL,access_mask ; 0Fh
 21315 0000337A 80FB02                  	CMP	BL,2
 21316 0000337D 7703                    	JA	short Make_Bad_Access
 21317 0000337F 5B                      	POP	BX
 21318 00003380 F8                      	CLC
 21319 00003381 C3                      	retn
 21320                                  
 21321                                  Make_Bad_Access:
 21322 00003382 B80C00                  	MOV	AX,error_invalid_access ; 0Ch
 21323 00003385 5B                      	POP	BX
 21324 00003386 F9                      	STC
 21325 00003387 C3                      	retn
 21326                                  
 21327                                  ;============================================================================
 21328                                  ; DINFO.ASM, MSDOS 6.0, 1991
 21329                                  ;============================================================================
 21330                                  ; 08/08/2018 - Retro DOS v3.0
 21331                                  ; 18/05/2019 - Retro DOS v4.0
 21332                                  ; 02/02/2024 - Retro DOS v5.0
 21333                                  
 21334                                  ;**	Low level routine for returning disk drive information from a local
 21335                                  ;	  or NET device
 21336                                  ;
 21337                                  ;	DISK_INFO
 21338                                  ;
 21339                                  ;	  Modification history:
 21340                                  ;
 21341                                  ;		Created: ARR 30 March 1983
 21342                                  
 21343                                  ;	Break	<DISK_INFO -- Get Disk Drive Information>
 21344                                  ;---------------------------------------------------------------------------
 21345                                  ; Procedure Name : DISK_INFO
 21346                                  ;
 21347                                  ; Inputs:
 21348                                  ;	[THISCDS] Points to the Macro List Structure of interest
 21349                                  ;		(It MAY NOT be NUL, error not detected)
 21350                                  ; Function:
 21351                                  ;	Get Interesting Drive Information
 21352                                  ; Returns:
 21353                                  ;	DX = Number of free allocation units
 21354                                  ;	BX = Total Number of allocation units on disk
 21355                                  ;	CX = Sector size
 21356                                  ;	AL = Sectors per allocation unit
 21357                                  ;	AH = FAT ID BYTE
 21358                                  ;	Carry set if error (currently user FAILed to I 24)
 21359                                  ; Segs except ES preserved, others destroyed
 21360                                  ;----------------------------------------------------------------------------
 21361                                  
 21362                                  ;hkn; called from getset.asm and misc.asm. DS has already been set up to
 21363                                  ;hkn; DOSDATA. 
 21364                                  
 21365                                  	; 02/02/2024 - Retro DOS v5.0
 21366                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:732Bh
 21367                                  
 21368                                  DISK_INFO:
 21369                                  	; 08/08/2018 - Retro DOS v3.0
 21370                                  	; IBM DOS.COM (MSDOS 3.3, 1987) - Offset 37C5h
 21371                                  
 21372 00003388 E8B6E4                  	call	TestNet
 21373 0000338B 7318                    	JNC	short LOCAL_DSK_INFO
 21374                                  
 21375                                  	;;;
 21376                                  	; 02/02/2024 (PCDOS 7.1 IBMDOS.COM)
 21377 0000338D 31F6                    	xor     si,si	; free cluster count hw = 0
 21378 0000338F 31FF                    	xor     di,di	; number of clusters hw = 0
 21379                                  	;;;
 21380                                  
 21381                                  ;IF NOT Installed
 21382                                  ;	transfer NET_DISK_INFO
 21383                                  ;ELSE
 21384                                  	;MOV	AX,(MultNET SHL 8) OR 12
 21385                                  	;INT	2FH
 21386                                  	;return
 21387                                  
 21388 00003391 B80C11                  	mov     ax,110Ch
 21389 00003394 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
 21390                                  			; ES:DI -> current directory
 21391                                  			; Return: AL = sectors per cluster, BX = total clusters
 21392                                  			; CX = bytes per sector, DX = number of available clusters
 21393                                  	;;;
 21394                                  	; 02/02/2024 (PCDOS 7.1 IBMDOS.COM)
 21395 00003396 83FBFF                  	cmp	bx,0FFFFh
 21396 00003399 7502                    	jne	short dsk_info_1
 21397 0000339B 89DF                    	mov	di,bx
 21398                                  dsk_info_1:
 21399 0000339D 83FAFF                  	cmp	dx,0FFFFh
 21400 000033A0 7502                    	jne	short disk_info_retn
 21401 000033A2 89D6                    	mov	si,dx
 21402                                  disk_info_retn:
 21403                                  	;;;
 21404 000033A4 C3                      	retn
 21405                                  ;ENDIF
 21406                                  
 21407                                  LOCAL_DSK_INFO:
 21408                                  	;MOV	byte [EXTERR_LOCUS],errLOC_Disk
 21409                                  	;;;
 21410                                  	; 02/02/2024 (PCDOS 7.1 IBMDOS.COM)
 21411 000033A5 E856DF                  	call	set_exerr_locus_disk
 21412                                  	;;;
 21413 000033A8 E858E5                  	call	ECritDisk
 21414 000033AB E8062D                  	call	FATREAD_CDS		; perform media check.
 21415                                  	;JC	short CRIT_LEAVE
 21416                                  	;;; 02/02/2024
 21417 000033AE 720D                    	jc	short dsk_info_2
 21418 000033B0 31C0                    	xor	ax,ax
 21419 000033B2 A3[EF0A]                	mov	[CLUSTNUM_HW],ax ; 0	; clear high word of cluster number
 21420                                  	;;;
 21421 000033B5 BB0200                  	MOV	BX,2
 21422 000033B8 E8622B                  	call	UNPACK			; Get first FAT sector into CURBUF
 21423                                  	;JC	short CRIT_LEAVE
 21424                                  	;;;
 21425                                  	; 02/02/2024 - Retro DOS v5.0
 21426 000033BB 7303                    	jnc	short dsk_info_3
 21427                                  dsk_info_2:
 21428                                  	;jmp	CRIT_LEAVE
 21429 000033BD E970E5                  	jmp	LCritDisk
 21430                                  dsk_info_3:
 21431                                  	;;;
 21432 000033C0 C536[E205]              	LDS	SI,[CURBUF]
 21433                                  	; 02/02/2024
 21434                                  	;;mov	ah,[si+20]
 21435                                  	;mov	ah,[si+24] ; PCDOS 71. IBMDOS.COM
 21436 000033C4 8A6418                  	MOV	AH,[SI+BUFINSIZ]	; get FAT ID BYTE
 21437                                  
 21438                                  ;hkn; SS is DOSDATA
 21439 000033C7 16                      	push	ss
 21440 000033C8 1F                      	pop	ds
 21441                                  
 21442                                  ; 02/02/2024 - Retro DOS v5.0
 21443                                  %if 0
 21444                                  	;mov	cx,[es:bp+0Dh]
 21445                                  	MOV	CX,[ES:BP+DPB.MAX_CLUSTER]
 21446                                  
 21447                                  ; Examine the current free count. If it indicates that we have an invalid
 21448                                  ; count, do the expensive calculation.
 21449                                  
 21450                                  	;mov	dx,[es:bp+1Fh]
 21451                                  	MOV	DX,[ES:BP+DPB.FREE_CNT] ; get free count
 21452                                  	CMP	DX,-1			; is it valid?
 21453                                  	JZ	short DoScan
 21454                                  
 21455                                  ; Check to see if it is in a reasonable range. If so, trust it and return.
 21456                                  ; Otherwise, we need to blast out an internal error message and then recompute
 21457                                  ; the count.
 21458                                  
 21459                                  	CMP	DX,CX			; is it in a reasonable range?
 21460                                  	JB	short GotVal		; yes, trust it.
 21461                                  DoScan:
 21462                                  	XOR	DX,DX
 21463                                  	DEC	CX
 21464                                  SCANFREE:
 21465                                  	call	UNPACK
 21466                                  	JC	short CRIT_LEAVE
 21467                                  	JNZ	short NOTFREECLUS
 21468                                  	INC	DX			; A free one
 21469                                  NOTFREECLUS:
 21470                                  	INC	BX			; Next cluster
 21471                                  	LOOP	SCANFREE
 21472                                  	DEC	BX			; BX was next cluster. Convert to
 21473                                  ReturnVals:
 21474                                  	DEC	BX			; count
 21475                                  	;mov	al,[es:bp+4]
 21476                                  	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
 21477                                  	INC	AL			; Sectors/cluster
 21478                                  	;mov	cx,[es:bp+2]
 21479                                  	MOV	CX,[ES:BP+DPB.SECTOR_SIZE] ; Bytes/sector
 21480                                  	;mov	[es:bp+1Fh],dx
 21481                                  	MOV	[ES:BP+DPB.FREE_CNT],DX
 21482                                  	CLC
 21483                                  CRIT_LEAVE:
 21484                                  	;call	LCritDisk
 21485                                  	;retn
 21486                                  	; 17/12/2022
 21487                                  	jmp	LCritDisk
 21488                                  
 21489                                  ; We have correctly computed everything previously. Load up registers for
 21490                                  ; return.
 21491                                  
 21492                                  GotVal: 
 21493                                  	MOV	BX,CX			; get cluster count
 21494                                  	JMP	short ReturnVals
 21495                                  
 21496                                  %else
 21497                                  	; 02/02/2024 (PCDOS 7.1 IBMDOS.COM)
 21498 000033C9 31F6                    	xor	si,si	; 0
 21499 000033CB 89F7                    	mov	di,si	; 0
 21500                                  	;mov	dx,[es:bp+1Fh]
 21501 000033CD 268B561F                	mov	dx,[es:bp+DPB.FREE_CNT]	; get free count
 21502                                  	;cmp	[es:bp+0Fh],si
 21503 000033D1 2639760F                	cmp	[es:bp+DPB.FAT_SIZE],si ; FAT32 (16 bit FAT size = 0) ?
 21504 000033D5 7406                    	jz	short dsk_info_4	; yes
 21505                                  	;mov	cx,[es:bp+0Dh]
 21506 000033D7 268B4E0D                	mov	cx,[es:bp+DPB.MAX_CLUSTER]
 21507 000033DB EB18                    	jmp	short dsk_info_5 ; zf=0, si=di=0
 21508                                  
 21509                                  dsk_info_4:
 21510                                  	;mov	di,[es:bp+2Fh]
 21511 000033DD 268B7E2F                	mov	di,[es:bp+DPB.LAST_CLUSTER+2]
 21512                                  	;mov	cx,[es:bp+2Dh]
 21513 000033E1 268B4E2D                	mov	cx,[es:bp+DPB.LAST_CLUSTER]
 21514                                  	;mov	si,[es:bp+21h]
 21515 000033E5 268B7621                	mov	si,[es:bp+DPB.FREE_CNT_HW] ; hw of free cluster count
 21516 000033E9 39F2                    	cmp	dx,si			; same (zero) ?
 21517                                  ;dsk_info_5:
 21518 000033EB 7504                    	jnz	short dsk_info_6	; not same (not zero)
 21519 000033ED 42                      	inc	dx
 21520 000033EE 740B                    	jz	short dsk_info_8	; 0FFFFh -> 0 (free count is invalid/initial)
 21521                                  					; free count calculation is needed
 21522 000033F0 4A                      	dec	dx
 21523                                  dsk_info_6:
 21524 000033F1 39FE                    	cmp	si,di			; same hw ?
 21525 000033F3 7502                    	jne	short dsk_info_7	; no
 21526                                  dsk_info_5:	; 02/02/2024 - Retro DOS v5.0 
 21527 000033F5 39CA                    	cmp	dx,cx			; same lw ?
 21528                                  dsk_info_7:
 21529 000033F7 7268                    	jb	short GotVal		; free cluster count < last cluster number
 21530 000033F9 31D2                    	xor	dx,dx	; 0
 21531                                  dsk_info_8:
 21532 000033FB 31F6                    	xor	si,si	; 0
 21533 000033FD 83E901                  	sub	cx,1			; last cluster number - 1 = number of clusters
 21534 00003400 19F7                    	sbb	di,si
 21535                                  	;or	byte [es:bp+18h],1
 21536 00003402 26804E1801              	or	byte [es:bp+DPB.FIRST_ACCESS],1 ; set first access bit 0
 21537                                  					; (Update flag for FSINFO sector)
 21538                                  SCANFREE:
 21539 00003407 56                      	push	si
 21540 00003408 FF36[F30A]              	push	word [CCONTENT_HW]
 21541 0000340C 57                      	push	di
 21542 0000340D E80D2B                  	call	UNPACK
 21543 00003410 5F                      	pop	di
 21544 00003411 8F06[F30A]              	pop	word [CCONTENT_HW]
 21545 00003415 5E                      	pop	si
 21546 00003416 7246                    	jc	short CRIT_LEAVE
 21547 00003418 7504                    	jnz	short NOTFREECLUS
 21548 0000341A 42                      	inc	dx			; a free one
 21549 0000341B 7501                    	jnz	short NOTFREECLUS
 21550 0000341D 46                      	inc	si			; increase hw of free cluster count
 21551                                  
 21552                                  NOTFREECLUS:
 21553 0000341E 43                      	inc	bx			; next cluster
 21554 0000341F 7504                    	jnz	short NOTFREECLUS2
 21555 00003421 FF06[EF0A]              	inc	word [CLUSTNUM_HW]	; increase hw of (next) cluster number
 21556                                  
 21557                                  NOTFREECLUS2:
 21558 00003425 83E901                  	sub	cx,1			; decrease remain cluster count for calculation
 21559 00003428 83DF00                  	sbb	di,0
 21560 0000342B 75DA                    	jnz	short SCANFREE
 21561 0000342D E302                    	jcxz	NOTFREECLUS3		; calculation completed
 21562 0000342F EBD6                    	jmp	short SCANFREE
 21563                                  
 21564                                  NOTFREECLUS3:
 21565 00003431 8B3E[EF0A]              	mov	di,[CLUSTNUM_HW]
 21566 00003435 83EB01                  	sub	bx,1
 21567 00003438 83DF00                  	sbb	di,0			; di:bx = last cluster number
 21568                                  
 21569                                  ReturnVals:
 21570 0000343B 31C9                    	xor	cx,cx
 21571 0000343D 83EB01                  	sub	bx,1
 21572 00003440 19CF                    	sbb	di,cx			; di:bx = number of clusters
 21573                                  	;mov	al,[es:bp+4]
 21574 00003442 268A4604                	mov	al,[es:bp+DPB.CLUSTER_MASK] ; spc - 1
 21575 00003446 FEC0                    	inc	al			; sectors per cluster
 21576                                  	;mov	[es:bp+1Fh],dx		
 21577 00003448 2689561F                	mov	[es:bp+DPB.FREE_CNT],dx	; free cluster count,lw
 21578                                  	;cmp	[es:bp+0Fh],cx ; 0
 21579 0000344C 26394E0F                	cmp	[es:bp+DPB.FAT_SIZE],cx ; 0 ; FAT32 (16 bit FAT size = 0) ?
 21580 00003450 7507                    	jnz	short ReturnVals2	; no
 21581                                  	;mov	[es:bp+21h],si
 21582 00003452 26897621                	mov	[es:bp+DPB.FREE_CNT_HW],si ; hw of free cluster count
 21583                                  
 21584 00003456 E83800                  	call	update_fat32_fsinfo
 21585                                  
 21586                                  ReturnVals2:
 21587                                  	;mov	cx,[es:bp+2]
 21588 00003459 268B4E02                	mov	cx,[es:bp+DPB.SECTOR_SIZE] ; bytes per sector
 21589 0000345D F8                      	clc
 21590                                  
 21591                                  CRIT_LEAVE:
 21592                                  	;call	LCritDisk
 21593                                  	;retn
 21594 0000345E E9CFE4                  	jmp	LCritDisk
 21595                                  
 21596                                  GotVal:
 21597 00003461 89CB                    	mov	bx,cx
 21598 00003463 EBD6                    	jmp	short ReturnVals
 21599                                  
 21600                                  %endif
 21601                                  
 21602                                  ; =============== S U B R O U T I N E =======================================
 21603                                  
 21604                                  ; 03/02/2024 - Retro DOS v5.0
 21605                                  
 21606                                  modify_spc:
 21607 00003465 50                      	push	ax			; ax = sectors per cluster
 21608 00003466 52                      	push	dx
 21609 00003467 F7E1                    	mul	cx			; bytes per sector
 21610                                  	;cmp	dx,0
 21611 00003469 21D2                    	and	dx,dx
 21612 0000346B 7503                    	jnz	short mspc_1
 21613 0000346D 3D0040                  	cmp	ax,16384		; 16 kilobytes (per cluster)
 21614                                  					; ***
 21615                                  					; actual disk size limit
 21616                                  					; without invalidating cluster counts is
 21617                                  					; 2 GB (512K clusters * 8 sectors per cluster)
 21618                                  					;      (128K clusters * 32 sectors per cluster)
 21619                                  mspc_1:
 21620 00003470 5A                      	pop	dx
 21621 00003471 58                      	pop	ax
 21622 00003472 760E                    	jbe	short mspc_3		; bytes per cluster <= 16 KB
 21623                                                                          ; ***
 21624                                                                          ; bytes per cluster > 16 KB
 21625 00003474 31FF                    	xor	di,di			; 0
 21626 00003476 BBFEFF                  	mov	bx,0FFFEh		; (invalidated)
 21627 00003479 09F6                    	or	si,si			; hw of free cluster count
 21628 0000347B 7404                    	jz	short mspc_2		; si = 0
 21629 0000347D 89FE                    	mov	si,di			; si = 0
 21630 0000347F 89DA                    	mov	dx,bx			; dx = bx = 0FFFEh (invalidated)
 21631                                  mspc_2:
 21632 00003481 C3                      	retn
 21633                                  
 21634                                  mspc_3:
 21635 00003482 D1E0                    	shl	ax,1			; sectors per clust = sectors per clust * 2
 21636                                  					; (ax <= 32768) -modified spc limit-
 21637 00003484 D1EF                    	shr	di,1			; cluster count = cluster count /2
 21638                                  					; di:bx = modified value of total clusters
 21639                                  mspc_4:
 21640 00003486 D1DB                    	rcr	bx,1
 21641 00003488 D1EE                    	shr	si,1			; free clusters = free clusters / 2
 21642 0000348A D1DA                    	rcr	dx,1			; si:dx = modified value of free clusters
 21643                                  
 21644                                  ; ---------------------------------------------------------------------------
 21645                                  
 21646                                  	; 03/02/2024
 21647                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:7431h
 21648                                  
 21649                                  modify_cluster_count:
 21650 0000348C 09FF                    	or	di,di			; hw of cluster count
 21651 0000348E 75D5                    	jnz	short modify_spc
 21652 00003490 C3                      	retn
 21653                                  
 21654                                  ; =============== S U B R O U T I N E =======================================
 21655                                  
 21656                                  ; write FSINFO sector onto disk
 21657                                  
 21658                                  ; 03/02/2024 - Retro DOS v5.0
 21659                                  ; --------------------------------
 21660                                  ; FAT32 FSInfo Sector Structure
 21661                                  ; --------------------------------
 21662                                  ; ref: Microsoft FAT32 File System Specification (2000)
 21663                                  
 21664                                  struc FSINFO		; Offset ;
 21665 00000000 ????????                .LeadSig:	resb 4	  ; 0		; Value 0x41615252. Lead Signature.
 21666 00000004 <res 1E0h>              .Reserved1:	resb 480  ; 4		; Reserved. Must be 0. Never be used.
 21667 000001E4 ????????                .StrucSig:	resb 4	  ; 484		; Value 0x61417272. Fields Signature.
 21668 000001E8 ????????                .Free_Count:	resb 4	  ; 488		; Last known free cluster count. (*) 
 21669 000001EC ????????                .Nxt_Free:	resb 4	  ; 492		; Start clus for free clus srch. (**)
 21670 000001F0 <res Ch>                .Reserved2:	resb 12	  ; 496		; Reserved. Must be 0. Never be used.
 21671 000001FC ????????                .TrailSig:	resb 4	  ; 508		; Value 0xAA550000. Trail Signature.
 21672                                  .size:
 21673                                  endstruc
 21674                                  
 21675                                  ; (*) If the value is 0xFFFFFFFF, then the free count is unknown
 21676                                  ;     and must be computed.
 21677                                  ; (**) If the value is 0xFFFFFFFF, then free cluster search must be started
 21678                                  ;     from cluster 2.
 21679                                  ; Lead Signature, Fields (Structure) Signature and Trail Signature
 21680                                  ; are used to validate FSInfo sector.
 21681                                  
 21682                                  ; --------------------------------
 21683                                  
 21684                                  	; 03/02/2024 - Retro DOS v5.0
 21685                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:7436h
 21686                                  	; (Windows ME IO.SYS - BIOSCODE:7227h)
 21687                                  
 21688                                  update_fat32_fsinfo:
 21689 00003491 51                      	push	cx
 21690 00003492 52                      	push	dx
 21691 00003493 31C9                    	xor	cx,cx
 21692                                  	;mov	dx,[es:bp+25h]
 21693 00003495 268B5625                	mov	dx,[es:bp+DPB.FSINFO_SECTOR]
 21694                                  	;cmp	[es:bp+0Fh],cx
 21695 00003499 26394E0F                	cmp	[es:bp+DPB.FAT_SIZE],cx ; 0
 21696                                  				; (16bit FAT size field = 0 for FAT32 fs)
 21697 0000349D 7505                    	jne	short u_fat32_inf_1
 21698 0000349F 83FAFF                  	cmp	dx,0FFFFh ; -1
 21699 000034A2 7508                    	jne	short u_fat32_inf_2
 21700                                  
 21701                                  u_fat32_inf_1:
 21702 000034A4 5A                      	pop	dx
 21703 000034A5 59                      	pop	cx
 21704                                  	;and	byte [es:bp+18h],0F4h
 21705 000034A6 26806618F4              	and	byte [es:bp+DPB.FIRST_ACCESS],0F4h ; clear bit 0,1 and 3
 21706                                  					; bit 0 - FSINFO update (dirty) bit
 21707                                  					; bit 1 - BPB_RootClus update bit
 21708                                  					; bit 3 - BPB_ExtFlags update bit
 21709 000034AB C3                      	retn
 21710                                  
 21711                                  u_fat32_inf_2:
 21712 000034AC 50                      	push	ax
 21713 000034AD 53                      	push	bx
 21714 000034AE 57                      	push	di
 21715 000034AF 56                      	push	si
 21716 000034B0 1E                      	push	ds
 21717 000034B1 36803E[7900]00          	cmp	byte [ss:BuffInHMA],0	; is buffers in HMA?
 21718 000034B7 740A                    	jz	short u_fat32_inf_3	; no
 21719 000034B9 36C53E[7A00]            	lds	di,[ss:LoMemBuff]	; read it into scratch buffer
 21720                                  	;sub	di,24
 21721 000034BE 83EF18                  	sub	di,BUFINSIZ		; space for buffer header
 21722                                  					; (buffer header size = 24)
 21723                                  	;clc
 21724 000034C1 EB0E                    	jmp	short u_fat32_inf_4
 21725                                  
 21726                                  u_fat32_inf_3:
 21727 000034C3 06                      	push	es
 21728 000034C4 55                      	push	bp
 21729 000034C5 E81C2E                  	call	GETCURHEAD		; ds:di = first buffer in queue
 21730 000034C8 52                      	push	dx
 21731 000034C9 E8F62F                  	call	BUFWRITE		; BufWrite writes a buffer to the disk,
 21732                                  					;  if it's dirty.
 21733 000034CC 5A                      	pop	dx
 21734 000034CD 5D                      	pop	bp
 21735 000034CE 07                      	pop	es
 21736                                  ;u_fat32_inf_4:
 21737 000034CF 726A                    	jc	short u_fat32_inf_5
 21738                                  u_fat32_inf_4:
 21739 000034D1 31C9                    	xor	cx,cx
 21740                                  	;lea	bx,[di+24]
 21741 000034D3 8D5D18                  	lea	bx,[di+BUFINSIZ]	; buffer data address
 21742                                  	;mov	byte [ss:ALLOWED],18h
 21743 000034D6 36C606[4B03]18          	mov	byte [ss:ALLOWED],Allowed_FAIL+Allowed_RETRY
 21744 000034DC 36890E[0706]            	mov	[ss:HIGH_SECTOR],cx ; 0
 21745 000034E1 41                      	inc	cx			; cx = sector count = 1
 21746                                  					; es:bp = DPB
 21747 000034E2 53                      	push	bx			; ds:bx = buffer (data) address
 21748 000034E3 52                      	push	dx			; HIGH_SECTOR:dx = disk sector address
 21749 000034E4 E8C50A                  	call	DREAD		 	; read fs info sector
 21750 000034E7 5A                      	pop	dx
 21751 000034E8 5B                      	pop	bx
 21752 000034E9 7250                    	jc	short u_fat32_inf_5
 21753                                  
 21754                                  	;cmp	word [bx+FSINFO.LeadSig],5252h	
 21755 000034EB 813F5252                	cmp	word [bx],5252h		; 'RR'
 21756 000034EF 754A                    	jne	short u_fat32_inf_5
 21757                                  	;cmp	word [bx+2],4161h	; 'aA' ; (NASM syntax)
 21758 000034F1 817F026141              	cmp	word [bx+FSINFO.LeadSig+2],4161h
 21759 000034F6 7543                    	jne	short u_fat32_inf_5
 21760                                  	
 21761                                  	;cmp	word [bx+1E4h],7272h	; 'rr' at offset 484
 21762 000034F8 81BFE4017272            	cmp	word [bx+FSINFO.StrucSig],7272h
 21763 000034FE 753B                    	jne	short u_fat32_inf_5
 21764                                  
 21765                                  	;cmp	word [bx+1E6h],6141h	; 'Aa' at offset 486
 21766 00003500 81BFE6014161            	cmp	word [bx+FSINFO.StrucSig+2],6141h
 21767 00003506 7533                    	jne	short u_fat32_inf_5
 21768                                  
 21769                                  	;cmp	word [bx+1FEh],0AA55h	; boot signature at offset 510
 21770 00003508 81BFFE0155AA            	cmp	word [bx+FSINFO.TrailSig+2],0AA55h
 21771 0000350E 752B                    	jne	short u_fat32_inf_5
 21772                                  	
 21773                                  	;mov	ax,[es:bp+1Fh]
 21774 00003510 268B461F                	mov	ax,[es:bp+DPB.FREE_CNT]
 21775                                  	;mov	[bx+1E8h],ax 
 21776 00003514 8987E801                	mov	[bx+FSINFO.Free_Count],ax ; at offset 488
 21777                                  	;mov	ax,[es:bp+21h]
 21778 00003518 268B4621                	mov	ax,[es:bp+DPB.FREE_CNT+2]
 21779                                  	;mov	[bx+1EAh],ax
 21780 0000351C 8987EA01                	mov	[bx+FSINFO.Free_Count+2],ax
 21781                                  
 21782                                  	;mov	ax,[es:bp+39h]
 21783 00003520 268B4639                	mov	ax,[es:bp+DPB.FAT32_NXTFREE]
 21784                                  	;mov	[bx+1ECh],ax
 21785 00003524 8987EC01                	mov	[bx+FSINFO.Nxt_Free],ax	; at offset 492
 21786                                  	;mov	ax,[es:bp+3Bh]
 21787 00003528 268B463B                	mov	ax,[es:bp+DPB.FAT32_NXTFREE+2]
 21788                                  	;mov	[bx+1EEh],ax
 21789 0000352C 8987EE01                	mov	[bx+FSINFO.Nxt_Free+2],ax
 21790                                  
 21791 00003530 31C9                    	xor	cx,cx
 21792 00003532 36890E[0706]            	mov	[ss:HIGH_SECTOR],cx ; 0
 21793 00003537 41                      	inc	cx	; 1
 21794 00003538 E8D10A                  	call	DWRITE
 21795                                  
 21796                                  u_fat32_inf_5:
 21797 0000353B 1F                      	pop	ds
 21798 0000353C 5E                      	pop	si
 21799 0000353D 5F                      	pop	di
 21800 0000353E 5B                      	pop	bx
 21801 0000353F 58                      	pop	ax
 21802 00003540 E961FF                  	jmp	u_fat32_inf_1
 21803                                  
 21804                                  ;============================================================================
 21805                                  ; ISEARCH.ASM, MSDOS 6.0, 1991
 21806                                  ;============================================================================
 21807                                  ; 22/07/2018 - Retro DOS v3.0
 21808                                  
 21809                                  ;	TITLE	DOS_SEARCH - Internal SEARCH calls for MS-DOS
 21810                                  ;	NAME	DOS_SEARCH
 21811                                  
 21812                                  ;**	Low level routines for doing local and NET directory searches
 21813                                  ;
 21814                                  ;	DOS_SEARCH_FIRST
 21815                                  ;	DOS_SEARCH_NEXT
 21816                                  ;	RENAME_NEXT
 21817                                  ;
 21818                                  ;	Revision history:
 21819                                  ;
 21820                                  ;	    Created: ARR 30 March 1983
 21821                                  ;	    A000	version 4.00  Jan. 1988
 21822                                  ;	    A001	PTM 3564 -- search for fastopen
 21823                                  
 21824                                  ;Installed = TRUE
 21825                                  
 21826                                  ;--------------------------------------------------------------------------
 21827                                  ;
 21828                                  ; Procedure Name : DOS_SEARCH_FIRST
 21829                                  ;
 21830                                  ; Inputs:
 21831                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 21832                                  ;		terminated)
 21833                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 21834                                  ;		( = -1 if current dir not involved, else
 21835                                  ;		 Points to first char after last "/" of current dir part)
 21836                                  ;	[THISCDS] Points to CDS being used
 21837                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 21838                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 21839                                  ;	[DMAADD] Points to 53 byte buffer
 21840                                  ; Function:
 21841                                  ;	Initiate a search for the given file spec
 21842                                  ; Outputs:
 21843                                  ;	CARRY CLEAR
 21844                                  ;	    The 53 bytes ot DMAADD are filled in as follows:
 21845                                  ;
 21846                                  ;	LOCAL
 21847                                  ;	    Drive Byte (A=1, B=2, ...) High bit clear
 21848                                  ;		NEVER STORE DRIVE BYTE AFTER  found_it
 21849                                  ;	    11 byte search name with Meta chars in it
 21850                                  ;	    Search Attribute Byte, attribute of search
 21851                                  ;	    WORD LastEnt value
 21852                                  ;	    WORD DirStart
 21853                                  ;	    4 byte pad
 21854                                  ;	    32 bytes of the directory entry found
 21855                                  ;	NET
 21856                                  ;	    21 bytes First byte has high bit set
 21857                                  ;	    32 bytes of the directory entry found
 21858                                  ;
 21859                                  ;	CARRY SET
 21860                                  ;	    AX = error code
 21861                                  ;		error_no_more_files
 21862                                  ;			No match for this file
 21863                                  ;		error_path_not_found
 21864                                  ;			Bad path (not in curr dir part if present)
 21865                                  ;		error_bad_curr_dir
 21866                                  ;			Bad path in current directory part of path
 21867                                  ; DS preserved, others destroyed
 21868                                  ;---------------------------------------------------------------------------
 21869                                  
 21870                                  ; 24/01/2024
 21871                                  %if 1
 21872                                  	; 17/05/2019 - Retro DOS v4.0
 21873                                  GET_FAST_SEARCH:
 21874                                  	; 22/07/2018
 21875                                  	; MSDOS 6.0
 21876                                  	; 17/12/2022
 21877 00003543 36800E[1206]04          	OR	byte [ss:DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)  ; 04h
 21878                                  	;OR	word [ss:DOS34_FLAG],SEARCH_FASTOPEN  ; 400h
 21879                                  					;FO.trigger fastopen ;AN000;
 21880                                  	;call	DOS_SEARCH_FIRST
 21881                                  	;retn
 21882                                  	; 24/01/2024
 21883                                  	; 17/12/2022
 21884                                  	;jmp	DOS_SEARCH_FIRST
 21885                                  %endif
 21886                                  
 21887                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21888                                  	; DOSCODE:6C22h (MSDOS 5.0, MSDOS.SYS)
 21889                                  
 21890                                  	; 03/02/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 21891                                  	; DOSCODE:74E9h (PCDOS 7.1, IBMDOS.COM)
 21892                                  
 21893                                  DOS_SEARCH_FIRST:
 21894                                  	; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 3826h
 21895                                  
 21896 00003549 C43E[A205]              	LES	DI,[THISCDS]
 21897 0000354D 83FFFF                  	CMP	DI,-1
 21898 00003550 7506                    	JNZ	short TEST_RE_NET2
 21899                                  
 21900                                  ;IF NOT Installed
 21901                                  ;	transfer NET_SEQ_SEARCH_FIRST
 21902                                  ;ELSE
 21903                                  	;mov	ax,1119h
 21904 00003552 B81911                  	MOV	AX,(MultNET<<8)|25
 21905 00003555 CD2F                    	INT	2Fh
 21906 00003557 C3                      	retn
 21907                                  ;ENDIF
 21908                                  
 21909                                  TEST_RE_NET2:
 21910                                  	;test	word [es:di+43h],8000h
 21911                                  	; 17/12/2022
 21912                                  	;test	byte [es:di+44h],80h
 21913                                  	; 28/12/2022
 21914 00003558 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8
 21915                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 21916 0000355D 7406                    	JZ	short LOCAL_SEARCH_FIRST
 21917                                  
 21918                                  ;IF NOT Installed
 21919                                  ;	transfer NET_SEARCH_FIRST
 21920                                  ;ELSE
 21921                                  	;mov	ax,111Bh
 21922 0000355F B81B11                  	MOV	AX,(MultNET<<8)|27
 21923 00003562 CD2F                    	INT	2FH
 21924 00003564 C3                      	retn
 21925                                  ;ENDIF
 21926                                  	; 18/05/2019 - Retro DOS v4.0
 21927                                  LOCAL_SEARCH_FIRST:
 21928 00003565 E89BE3                  	call	ECritDisk
 21929                                  	; MSDOS 6.0
 21930                                  	;;test	word [DOS34_FLAG],400h
 21931                                  	; 17/12/2022
 21932                                  	;test	byte [DOS34_FLAG+1],04h
 21933 00003568 F606[1206]04            	test	byte [DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)
 21934                                  	;TEST	word [DOS34_FLAG],SEARCH_FASTOPEN ;AN000;
 21935 0000356D 7405                    	JZ	short NOFN			;AN000;
 21936                                  	;or	byte [FastOpenFlg],1
 21937 0000356F 800E[6D12]01            	OR	byte [FastOpenFlg],FastOpen_Set	;AN000;
 21938                                  NOFN:						;AN000;
 21939 00003574 C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 21940                                  
 21941                                  ; 03/02/2024
 21942                                  %if 0
 21943                                  	; MSDOS 6.0
 21944                                  	CALL	CHECK_QUESTION		;AN000;;FO. is '?' in path
 21945                                  	JNC	short norm_GETPATH	;AN000;;FO. no
 21946                                  %else
 21947                                  	; 03/02/2024
 21948 00003579 16                      	push	ss
 21949 0000357A 1F                      	pop	ds			;AN000;;FO. ds:si -> final path
 21950 0000357B 8B36[B205]              	mov	si,[WFP_START]		;AN000;;FO.
 21951                                  getnext:				;AN000;
 21952 0000357F AC                      	lodsb				;AN000;;FO. get char
 21953 00003580 08C0                    	or	al,al			;AN000;;FO. is it null
 21954 00003582 7409                    	jz	short NO_Question	;AN000;;FO. yes
 21955 00003584 3C3F                    	cmp	al,'?'                  ;AN000;;FO. is '?'
 21956 00003586 75F7                    	jne	short getnext 		;AN000;;FO. no
 21957                                  %endif
 21958                                  	;and	byte [FastOpenFlg],80h
 21959 00003588 8026[6D12]80            	AND	byte [FastOpenFlg],Fast_yes ;AN000;;FO. reset fastopen
 21960                                  NO_Question:	; 03/02/2024
 21961                                  norm_GETPATH:
 21962 0000358D E86F13                  	call	GETPATH
 21963                                  	; BX = offset NAME1
 21964                                  ;_getdone:
 21965 00003590 7318                    	JNC	short find_check_dev
 21966 00003592 7511                    	JNZ	short bad_path3
 21967 00003594 08C9                    	OR	CL,CL
 21968 00003596 740D                    	JZ	short bad_path3
 21969                                  find_no_more:
 21970                                  	;mov	ax,12h
 21971 00003598 B81200                  	MOV	AX,error_no_more_files
 21972                                  BadBye:
 21973                                  	; MSDOS 6.0
 21974 0000359B 368026[6D12]80          	AND	byte [SS:FastOpenFlg],Fast_yes  ;AN000;;FO. reset fastopen
 21975                                  
 21976 000035A1 F9                      	STC
 21977                                  	;call	LCritDisk
 21978                                  	;retn
 21979                                  	; 18/12/2022
 21980 000035A2 E98BE3                  	jmp	LCritDisk
 21981                                  
 21982                                  bad_path3:
 21983                                  	;mov	ax,3
 21984 000035A5 B80300                  	MOV	AX,error_path_not_found
 21985 000035A8 EBF1                    	JMP	short BadBye
 21986                                  
 21987                                  find_check_dev:
 21988 000035AA 08E4                    	OR	AH,AH
 21989 000035AC 790A                    	JNS	short found_entry
 21990 000035AE C706[4803]FFFF          	MOV	word [LASTENT],-1	; Cause DOS_SEARCH_NEXT to fail
 21991 000035B4 FE06[7005]              	INC	byte [FOUND_DEV]	; Tell DOS_RENAME we found a device
 21992                                  found_entry:
 21993                                  
 21994                                  ; We set the physical drive byte here Instead of after found_it; Doing
 21995                                  ; a search-next may not have wfp_start set correctly
 21996                                  
 21997 000035B8 C43E[2C03]              	LES	DI,[DMAADD]
 21998 000035BC 8B36[B205]              	MOV	SI,[WFP_START]		; get pointer to beginning
 21999 000035C0 AC                      	LODSB
 22000 000035C1 2C40                    	SUB	AL,'A'-1                ; logical drive
 22001 000035C3 AA                      	STOSB				; High bit not set (local)
 22002                                  found_it:
 22003 000035C4 C43E[2C03]              	LES	DI,[DMAADD]
 22004 000035C8 47                      	INC	DI
 22005                                  
 22006                                  	; MSDOS 6.0
 22007 000035C9 1E                      	PUSH	DS				  ;FO.;AN001; save ds
 22008                                  	;test	byte [FastOpenFlg],10h
 22009 000035CA F606[6D12]10            	TEST	byte [FastOpenFlg],Set_For_Search ;FO.;AN001; from fastopen
 22010 000035CF 7408                    	JZ	short notfast			  ;FO.;AN001;
 22011 000035D1 89DE                    	MOV	SI,BX				  ;FO.;AN001;
 22012 000035D3 8E1E[E405]              	MOV	DS,[CURBUF+2]			  ;FO.;AN001;
 22013 000035D7 EB03                    	JMP	SHORT movmov			  ;FO.;AN001;
 22014                                  
 22015                                  notfast:
 22016 000035D9 BE[4B05]                	MOV	SI,NAME1		; find_buf 2 = formatted name
 22017                                  movmov:
 22018                                  ; Special E5 code
 22019 000035DC A4                      	MOVSB
 22020 000035DD 26807DFF05              	CMP	BYTE [ES:DI-1],5
 22021 000035E2 7505                    	JNZ	short NOTKANJB
 22022 000035E4 26C645FFE5              	MOV	BYTE [ES:DI-1],0E5H
 22023                                  NOTKANJB:
 22024                                  	;MOV	CX,10
 22025                                  	;REP	MOVSB
 22026                                  	; 03/02/2024
 22027 000035E9 B90500                  	mov	cx,5
 22028 000035EC F3A5                    	rep	movsw
 22029                                  
 22030                                  	; 08/09/2018
 22031 000035EE 1F                      	POP	DS			;FO.;AN001; restore ds
 22032                                  
 22033 000035EF A0[6B05]                	MOV	AL,[ATTRIB]
 22034 000035F2 AA                      	STOSB
 22035 000035F3 50                      	PUSH	AX			; Save AH device info
 22036 000035F4 A1[4803]                	MOV	AX,[LASTENT]
 22037 000035F7 AB                      	STOSW
 22038 000035F8 A1[C205]                	MOV	AX,[DIRSTART]
 22039 000035FB AB                      	STOSW
 22040                                  
 22041                                  	; 03/02/2024 - Retro DOS v5.0
 22042                                  	; PCDOS 7.1 IBMDOS.COM
 22043                                  	;;;
 22044 000035FC A1[E30A]                	MOV	AX,[DIRSTART_HW]
 22045 000035FF AB                      	STOSW
 22046 00003600 83C702                  	add	di,2
 22047                                  ; 4 bytes of 21 byte cont structure left for NET stuff
 22048                                  	;ADD	DI,4
 22049                                  	;;;
 22050                                  	
 22051 00003603 58                      	POP	AX			; Recover AH device info
 22052 00003604 08E4                    	OR	AH,AH
 22053 00003606 781B                    	JS	short DOSREL		; Device entry is DOSGROUP relative
 22054 00003608 833E[E205]FF            	CMP	WORD [CURBUF],-1
 22055 0000360D 7510                    	JNZ	short OKSTORE
 22056                                  
 22057                                  	; MSDOS 6.0
 22058 0000360F F606[6D12]10            	TEST	byte [FastOpenFlg],Set_For_Search
 22059                                  					;AN000;;FO. from fastopen and is good
 22060 00003614 7509                    	JNZ	short OKSTORE		;AN000;;FO.
 22061                                  
 22062                                  	; The user has specified the root directory itself, rather than some
 22063                                  	; contents of it. We can't "find" that.
 22064                                  
 22065 00003616 26C745F8FFFF            	MOV	WORD [ES:DI-8],-1	; Cause DOS_SEARCH_NEXT to fail by
 22066                                  					;   stuffing a -1 at Lastent
 22067 0000361C E979FF                  	JMP	find_no_more
 22068                                  
 22069                                  OKSTORE:
 22070 0000361F 8E1E[E405]              	MOV	DS,[CURBUF+2]
 22071                                  DOSREL:
 22072                                  	; BX = offset NAME1 (from GETPATH)
 22073 00003623 89DE                    	MOV	SI,BX			; SI-> start of entry
 22074                                  
 22075                                  ; NOTE: DOS_RENAME depends on BX not being altered after this point
 22076                                  
 22077                                  	;;mov	cx,32
 22078                                  	;MOV	CX,dir_entry.size
 22079                                  	; 03/02/2024
 22080 00003625 B91000                  	mov	cx,dir_entry.size>>1
 22081                                  ;;;;; 7/29/86
 22082 00003628 89F8                    	MOV	AX,DI			; save the 1st byte addr
 22083                                  	;REP	MOVSB
 22084 0000362A F3A5                    	rep	movsw
 22085                                  	;
 22086 0000362C 89C7                    	MOV	DI,AX			; restore 1st byte addr
 22087 0000362E 26803D05                	CMP	BYTE [ES:DI],05H	; special char check
 22088 00003632 7504                    	JNZ	short NO05
 22089 00003634 26C605E5                	MOV	BYTE [ES:DI],0E5H	; convert it back to E5
 22090                                  NO05:
 22091                                  
 22092                                  ;;;;; 7/29/86
 22093                                  
 22094                                  ;hkn; FastOpenflg is in DOSDATA use SS
 22095                                  	; 16/12/2022
 22096                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22097                                  	; MSDOS 6.0
 22098                                  	;AND	byte [SS:FastOpenFlg],Fast_yes ;AN000;;FO. reset fastopen
 22099                                  	; 18/05/2019 - Retro DOS v4.0
 22100 00003638 16                      	push	ss
 22101 00003639 1F                      	pop	ds
 22102                                  	; 16/12/2022
 22103 0000363A 8026[6D12]80            	AND	byte [FastOpenFlg],Fast_yes ; 80h
 22104                                  
 22105                                  ;hkn; SS is DOSDATA
 22106                                  	;push	ss
 22107                                  	;pop	ds
 22108 0000363F F8                      	CLC
 22109                                  	;call	LCritDisk
 22110                                  	;retn
 22111                                  	; 16/12/2022
 22112 00003640 E9EDE2                  	jmp	LCritDisk
 22113                                  
 22114                                  ;BREAK <DOS_SEARCH_NEXT - scan for subsequent matches>
 22115                                  ;----------------------------------------------------------------------------
 22116                                  ;
 22117                                  ; Procedure Name : DOS_SEARCH_NEXT
 22118                                  ;
 22119                                  ; Inputs:
 22120                                  ;	[DMAADD] Points to 53 byte buffer returned by DOS_SEARCH_FIRST
 22121                                  ;	    (only first 21 bytes must have valid information)
 22122                                  ; Function:
 22123                                  ;	Look for subsequent matches
 22124                                  ; Outputs:
 22125                                  ;	CARRY CLEAR
 22126                                  ;	    The 53 bytes at DMAADD are updated for next call
 22127                                  ;		(see DOS_SEARCH_FIRST)
 22128                                  ;	CARRY SET
 22129                                  ;	    AX = error code
 22130                                  ;		error_no_more_files
 22131                                  ;			No more files to find
 22132                                  ; DS preserved, others destroyed
 22133                                  ;---------------------------------------------------------------------------
 22134                                  
 22135                                  ;hkn; called from search.asm. DS already set up at this point.
 22136                                  
 22137                                  	; 03/02/2024 - Retro DOS v5.0
 22138                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:75ECh
 22139                                  
 22140                                  DOS_SEARCH_NEXT:
 22141 00003643 C43E[2C03]              	LES	DI,[DMAADD]	; 24/01/2024 (Retro DOS v5-v4)
 22142 00003647 268A05                  	MOV	AL,[ES:DI]
 22143 0000364A A880                    	TEST	AL,80H			; Test for NET
 22144 0000364C 7406                    	JZ	short LOCAL_SEARCH_NEXT
 22145                                  ;IF NOT Installed
 22146                                  ;	transfer NET_SEARCH_NEXT
 22147                                  ;ELSE
 22148                                  	;mov	ax,111Ch
 22149 0000364E B81C11                  	MOV	AX,(MultNET<<8)|28
 22150 00003651 CD2F                    	INT	2FH  ; Multiplex - NETWORK REDIRECTOR - FINDNEXT
 22151                                  		     ; SS = DS = DOS CS, [DTA] = 21-byte findfirst search data
 22152                                  		     ; Return: CF set on error, AX = DOS error code
 22153                                  		     ; CF clear if successful
 22154 00003653 C3                      	retn
 22155                                  ;ENDIF
 22156                                  
 22157                                  LOCAL_SEARCH_NEXT:
 22158                                  	;AL is drive A=1
 22159                                  	;mov	byte [EXTERR_LOCUS],2
 22160 00003654 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 22161 00003659 E8A7E2                  	call	ECritDisk
 22162                                  
 22163                                  ;hkn; DummyCDS is in DOSDATA
 22164 0000365C C706[A205][F304]        	MOV     word [THISCDS],DUMMYCDS
 22165                                  ;hkn; Segment address is DOSDATA - use ds
 22166                                  ;hkn;	MOV     WORD [THISCDS+2],CS
 22167 00003662 8C1E[A405]              	mov	[THISCDS+2],DS
 22168                                  
 22169 00003666 0440                    	ADD	AL,'A'-1
 22170 00003668 E8883D                  	call	InitCDS
 22171                                  
 22172                                  ;	call	GETTHISDRV		; Set CDS pointer
 22173                                  
 22174 0000366B 7253                    	JC	short No_files		; Bogus drive letter
 22175 0000366D C43E[A205]              	LES	DI,[THISCDS]		; Get CDS pointer
 22176                                  	;les	bp,[es:di+45h]
 22177 00003671 26C46D45                	LES	BP,[ES:DI+curdir.devptr] ; Get DPB pointer
 22178 00003675 E8EFCF                  	call	GOTDPB			; [THISDPB] = ES:BP
 22179                                  
 22180                                  	; 16/12/2022
 22181 00003678 268A4600                	mov	al,[ES:BP]
 22182                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22183                                  	;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[ES:BP+0]
 22184 0000367C A2[7605]                	mov	[THISDRV],AL
 22185                                  	;mov	word [CREATING],0E500h
 22186 0000367F C706[7E05]00E5          	MOV	WORD [CREATING],(DIRFREE*256)+0
 22187 00003685 C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 22188 0000368A C536[2C03]              	LDS	SI,[DMAADD]
 22189 0000368E AC                      	LODSB				; Drive Byte
 22190                                  
 22191                                  	;entry	RENAME_NEXT		; Entry used by DOS_RENAME
 22192                                  RENAME_NEXT:
 22193                                  	;context ES
 22194 0000368F 16                      	push	ss
 22195 00003690 07                      	pop	es			; THIS BLOWS ES:BP POINTER TO DPB
 22196                                  
 22197                                  ;hkn; NAME1 is in DOSDATA
 22198 00003691 BF[4B05]                	MOV	DI,NAME1
 22199                                  
 22200 00003694 B90B00                  	MOV	CX,11
 22201 00003697 F3A4                    	REP	MOVSB			; Search name
 22202 00003699 AC                      	LODSB				; Attribute
 22203                                  
 22204                                  ;hkn; SS override
 22205 0000369A 36A2[6B05]              	MOV	[SS:ATTRIB],AL
 22206 0000369E AD                      	LODSW				; LastEnt
 22207 0000369F 09C0                    	OR	AX,AX
 22208                                  	; 03/02/2024
 22209                                  	;JNS	short cont_load
 22210 000036A1 781D                    	js	short No_files
 22211                                  ;No_files:
 22212                                  	;JMP	find_no_more
 22213                                  
 22214                                  cont_load:
 22215 000036A3 50                      	PUSH	AX			; Save LastEnt
 22216 000036A4 AD                      	LODSW				; DirStart
 22217 000036A5 89C3                    	MOV	BX,AX
 22218                                  
 22219                                  	;;;
 22220                                  	; 03/02/2024 - Retro DOS v5.0
 22221                                  	; (PCDOS 7.1 IBMDOS.COM)
 22222 000036A7 AD                      	lodsw				; DIRSTART_HW
 22223                                  	;;;
 22224                                  
 22225                                  ;hkn; SS is DOSDATA
 22226                                  	;context DS
 22227 000036A8 16                      	push	ss
 22228 000036A9 1F                      	pop	ds
 22229 000036AA C42E[8A05]              	LES	BP,[THISDPB]		; Recover ES:BP
 22230                                  
 22231                                  	;;;
 22232                                  	; 03/02/2024 - Retro DOS v5.0
 22233                                  	; (PCDOS 7.1 IBMDOS.COM)
 22234                                  	
 22235                                  	;cmp	word [es:bp+0Fh],0
 22236 000036AE 26837E0F00              	cmp	word [es:bp+DPB.FAT_SIZE],0
 22237 000036B3 7402                    	jz	short cont_load2 ; FAT32 fs
 22238 000036B5 31C0                    	xor	ax,ax ; 0
 22239                                  cont_load2:
 22240 000036B7 A3[F50A]                	mov	[ROOTCLUST_HW],ax	; 0 or DIRSTART_HW
 22241                                  	;;;
 22242                                  
 22243                                  	;invoke	SetDirSrch
 22244 000036BA E83011                  	call	SETDIRSRCH
 22245 000036BD 7304                    	JNC	short SEARCH_GOON
 22246 000036BF 58                      	POP	AX			; Clean stack
 22247                                  	;JMP	short No_files
 22248                                  	; 03/02/2024
 22249                                  No_files:
 22250 000036C0 E9D5FE                  	JMP	find_no_more
 22251                                  
 22252                                  SEARCH_GOON:
 22253 000036C3 E8CC14                  	call	STARTSRCH
 22254 000036C6 58                      	POP	AX			; Restore LastEnt
 22255 000036C7 E86410                  	call	GETENT
 22256 000036CA 72F4                    	JC	short No_files
 22257 000036CC E89A0F                  	call	NEXTENT
 22258 000036CF 72EF                    	JC	short No_files
 22259 000036D1 30E4                    	XOR	AH,AH			; If Search_Next, can't be a DEV
 22260 000036D3 E9EEFE                  	JMP	found_it ; 10/08/2018
 22261                                  
 22262                                  ; MSDOS 6.0
 22263                                  ;---------------------------------------------------------------------------
 22264                                  ;
 22265                                  ; Procedure Name : CHECK_QUESTION
 22266                                  ;
 22267                                  ; Input: [WFP_START]= pointer to final path
 22268                                  ; Function: check '?' char
 22269                                  ; Output: carry clear, if no '?'
 22270                                  ;	 carry set, if '?' exists
 22271                                  ;---------------------------------------------------------------------------
 22272                                  
 22273                                  ; 03/02/2024
 22274                                  %if 0
 22275                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22276                                  CHECK_QUESTION:
 22277                                  ;hkn;	wfp_start is in DOSDATA;hkn;	MOV	WORD PTR ThisCDS+2,CS
 22278                                  ;hkn;	PUSH	CS			;AN000;;FO.
 22279                                  	push	ss
 22280                                  	POP	DS			;AN000;;FO. ds:si -> final path
 22281                                  	; 16/12/2022
 22282                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22283                                  	MOV	SI,[WFP_START]		;AN000;;FO.
 22284                                  	;mov	si,[ss:WFP_START]
 22285                                  getnext:				;AN000;
 22286                                  	LODSB				;AN000;;FO. get char
 22287                                  	OR	AL,AL			;AN000;;FO. is it null
 22288                                  	JZ	short NO_Question	;AN000;;FO. yes
 22289                                  	CMP	AL,'?'                  ;AN000;;FO. is '?'
 22290                                  	JNZ	short getnext 		;AN000;;FO. no
 22291                                  	STC				;AN000;;FO.
 22292                                  NO_Question:				;AN000;
 22293                                  	retn				;AN000;;FO.
 22294                                  %endif
 22295                                  
 22296                                  ;============================================================================
 22297                                  ; ABORT.ASM, MSDOS 6.0, 1991
 22298                                  ;============================================================================
 22299                                  ; 23/07/2018 - Retro DOS v3.0
 22300                                  ; 18/05/2019 - Retro DOS v4.0
 22301                                  
 22302                                  ;**
 22303                                  ;
 22304                                  ; Internal Abort call closes all handles and FCBs associated with a process.
 22305                                  ;  If process has NET resources a close all is sent out over the net.
 22306                                  ;
 22307                                  ;   DOS_ABORT
 22308                                  ;
 22309                                  ;   Modification history:
 22310                                  ;
 22311                                  ;       Created: ARR 30 March 1983
 22312                                  ;
 22313                                  ;	M038	SR	10/16/90	Free SFT with the PSP of the process
 22314                                  ;				being terminated only if it is busy.
 22315                                  ;
 22316                                  
 22317                                  ;Break   <DOS_ABORT -- CLOSE all files for process>
 22318                                  ;--------------------------------------------------------------------------
 22319                                  ;
 22320                                  ; Procedure Name : DOS_ABORT
 22321                                  ;
 22322                                  ; Inputs:
 22323                                  ;       [CurrentPDB] set to PID of process aborting
 22324                                  ; Function:
 22325                                  ;       Close all files and free all SFTs for this PID
 22326                                  ; Returns:
 22327                                  ;       None
 22328                                  ; All destroyed except stack
 22329                                  ;---------------------------------------------------------------------------
 22330                                  
 22331                                  	; 03/02/2024 - Retro DOS v5.0
 22332                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:7685h
 22333                                  	; (Win ME IO.SYS - BIOSCODE:74F4h) 
 22334                                  
 22335                                  DOS_ABORT:
 22336 000036D6 368E06[3003]            	MOV     ES,[SS:CurrentPDB]	; SS override
 22337 000036DB 268B0E3200              	MOV     CX,[ES:PDB.JFN_Length]  ; Number of JFNs
 22338                                  reset_free_jfn:
 22339 000036E0 89CB                    	MOV     BX,CX
 22340 000036E2 51                      	PUSH    CX
 22341 000036E3 4B                      	DEC     BX                      ; get jfn (start with last one)
 22342                                  
 22343 000036E4 E8403A                  	CALL	_$CLOSE
 22344 000036E7 59                      	POP     CX
 22345 000036E8 E2F6                    	LOOP    reset_free_jfn          ; and do 'em all
 22346                                  
 22347                                  ; Note: We do need to explicitly close FCBs. Reasons are as follows: If we
 22348                                  ; are running in the no-sharing no-network environment, we are simulating the
 22349                                  ; 2.0 world and thus if the user doesn't close the file, that is his problem
 22350                                  ; BUT... the cache remains in a state with garbage that may be reused by the
 22351                                  ; next process. We scan the set and blast the ref counts of the FCBs we own.
 22352                                  ;
 22353                                  ; If sharing is loaded, then the following call to close process will
 22354                                  ; correctly close all FCBs. We will then need to walk the list AFTER here.
 22355                                  ;
 22356                                  ; Finally, the following call to NET_Abort will cause an EOP to be sent to all
 22357                                  ; known network resources. These resources are then responsible for cleaning
 22358                                  ; up after this process.
 22359                                  ;
 22360                                  ; Sleazy, eh?
 22361                                  
 22362                                  	;context DS			; SS is DOSDATA
 22363 000036EA 16                      	push	ss
 22364 000036EB 1F                      	pop	ds  ; 09/09/2018
 22365                                  
 22366                                  	;CallInstall Net_Abort, MultNET, 29
 22367 000036EC B81D11                  	mov	ax,111Dh
 22368 000036EF CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR 
 22369                                  			;	    - CLOSE ALL REMOTE FILES FOR PROCESS
 22370                                  			; DS???, SS = DOS CS
 22371                                  ;if installed
 22372 000036F1 FF1E[A000]              	call	far [JShare+(4*4)]	; 4 = MFTCloseP
 22373                                  ;else
 22374                                  ;	call 	MFTCloseP
 22375                                  ;endif
 22376                                  
 22377                                  ; Scan the FCB cache for guys that belong to this process and zap their ref
 22378                                  ; counts.
 22379                                  					; SS override
 22380 000036F5 36C43E[4000]            	les     di,[ss:SFTFCB]		; grab the pointer to the table
 22381                                  
 22382                                  	;;;
 22383                                  	; 03/02/2024 - Retro DOS v5.0
 22384                                  	; PCDOS 7.1 IBMDOS.COM
 22385                                  SFTFCB_check:
 22386 000036FA 8CC1                    	mov	cx,es
 22387 000036FC 09F9                    	or	cx,di
 22388 000036FE E31C                    	jcxz	FCBScanDone
 22389 00003700 57                      	push	di
 22390                                  SFTFCB_OK:
 22391                                  	;;;
 22392                                  	;mov	cx,[es:di+4]
 22393 00003701 268B4D04                	mov     cx,[es:di+SFT.SFCount]
 22394 00003705 E315                    	jcxz    FCBScanDone
 22395                                  	;lea	di,[di+6]
 22396 00003707 8D7D06                  	LEA     DI,[DI+SFT.SFTable]	; point at table
 22397 0000370A 36A1[3C03]              	mov     ax,[SS:PROC_ID]		; SS override
 22398                                  FCBTest:
 22399                                  	;cmp	[es:di+31h],ax
 22400 0000370E 26394531                	cmp	[es:di+SF_ENTRY.sf_PID],ax ; is this one of ours
 22401 00003712 7503                    	jnz	short FCBNext		; no, skip it
 22402                                  
 22403                                  ; 03/02/2024 - Retro DOS v5.0
 22404                                  %if 0
 22405                                  	mov	word [es:di],0
 22406                                  	;mov	word [es:di+SF_ENTRY.sf_ref_count],0 ; yes, blast ref count
 22407                                  %else
 22408                                  	; 03/02/2024
 22409                                  	; PCDOS 7.1 IBMDOS.COM
 22410 00003714 E8E711                  	call    SFT_FREE
 22411                                  %endif
 22412                                  
 22413                                  FCBNext:
 22414 00003717 83C73B                  	add     di,SF_ENTRY.size ; 59 (for MSDOS 6.0)
 22415 0000371A E2F2                    	loop    FCBTest
 22416                                  FCBScanDone:
 22417                                  
 22418                                  ; Walk the SFT to eliminate all busy SFT's for this process.
 22419                                  
 22420 0000371C 31DB                    	XOR     BX,BX
 22421                                  Scan:
 22422 0000371E 53                      	push    bx
 22423 0000371F E88039                  	call	SFFromSFN
 22424 00003722 5B                      	pop     bx
 22425                                  	;jnc	short Scan1
 22426                                  	;retn
 22427                                  
 22428                                  	; 18/12/2022
 22429                                  	;jc	short NO_Question ; retn
 22430                                  	; 03/02/2024
 22431 00003723 7232                    	jc	short RET2
 22432                                  
 22433                                  ;M038
 22434                                  ; Do what the comment above says, check for busy state
 22435                                  
 22436                                  Scan1:
 22437                                  	;cmp	word [es:di],0
 22438                                  	;jz	short scan_next  ; MSDOS 3.3
 22439                                  	; MSDOS 6.0
 22440 00003725 26833DFF                	cmp	word [es:di],sf_busy ; -1
 22441                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy
 22442                                  				; Is Sft busy? ;M038
 22443 00003729 7517                    	jnz	short scan_next ; no
 22444                                  ;
 22445                                  ; we have a SFT that is busy. See if it is for the current process
 22446                                  ;
 22447 0000372B 36A1[3C03]              	mov     ax,[SS:PROC_ID]		; SS override
 22448                                  	;cmp	[es:di+31h],ax
 22449 0000372F 26394531                	cmp	[es:di+SF_ENTRY.sf_PID],ax
 22450 00003733 750D                    	jnz	short scan_next
 22451 00003735 36A1[3E03]              	mov     ax,[SS:USER_ID]		; SS override
 22452                                  	;sub	ax,[es:di+2Fh] ; PCDOS 7.1 IBMDOS.COM ; 03/02/2024
 22453                                  	;cmp	[es:di+2Fh],ax
 22454 00003739 2639452F                	cmp	[es:di+SF_ENTRY.sf_UID],ax
 22455 0000373D 7503                    	jnz	short scan_next
 22456                                  
 22457                                  ; This SFT is labelled as ours.
 22458                                  
 22459                                  ; 03/02/2024 - Retro DOS v5.0
 22460                                  %if 0
 22461                                  	mov	word [es:di],0
 22462                                  	;mov	word [es:di+SF_ENTRY.sf_ref_count],0
 22463                                  %else
 22464                                  	; 03/02/2024
 22465                                  	; PCDOS 7.1 IBMDOS.COM
 22466 0000373F E8BC11                  	call    SFT_FREE
 22467                                  %endif
 22468                                  
 22469                                  scan_next:
 22470 00003742 43                      	inc     bx
 22471 00003743 EBD9                    	jmp     short Scan
 22472                                  
 22473                                  ;============================================================================
 22474                                  ; CLOSE.ASM, MSDOS 6.0, 1991
 22475                                  ;============================================================================
 22476                                  ; 23/07/2018 - Retro DOS v3.0
 22477                                  ; 18/05/2019 - Retro DOS v4.0
 22478                                  
 22479                                  ;**	Internal Close and Commit calls to close a local or NET SFT.
 22480                                  ;
 22481                                  ;	DOS_CLOSE
 22482                                  ;	DOS_COMMIT
 22483                                  ;	FREE_SFT
 22484                                  ;	SetSFTTimes
 22485                                  ;
 22486                                  ;	Revision history:
 22487                                  ;
 22488                                  ;	   AN000  version 4.00	Jan. 1988
 22489                                  ;	   A005   PTM 3718 --- lost clusters when fastopen installed
 22490                                  ;	   A011   PTM 4766 --- C2 fastopen problem
 22491                                  
 22492                                  ;Installed = TRUE
 22493                                  
 22494                                  ;Break <DOS_CLOSE -- CLOSE FILE from SFT>
 22495                                  ;---------------------------------------------------------------------------
 22496                                  ;
 22497                                  ; Procedure Name : DOS_CLOSE
 22498                                  ;
 22499                                  ; Inputs:
 22500                                  ;	[THISSFT] set to the SFT for the file being used
 22501                                  ; Function:
 22502                                  ;	Close the indicated file via the SFT
 22503                                  ; Returns:
 22504                                  ;	sf_ref_count decremented otherwise
 22505                                  ;	ES:DI point to SFT
 22506                                  ;	Carry set if error
 22507                                  ;	    AX has error code
 22508                                  ; DS preserved, others destroyed
 22509                                  ;---------------------------------------------------------------------------
 22510                                  
 22511                                  ;hkn; DOS_CLOSE called from fcbio.asm and handle.asm. DS alreday set up.
 22512                                  
 22513                                  ; 18/05/2019 - Retro DOS v4.0
 22514                                  ; DOSCODE:6E2Eh (MSDOS 6.21, MSDOS.SYS)
 22515                                  
 22516                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22517                                  ; DOSCODE:6E1Ah (MSDOS 5.0, MSDOS.SYS)
 22518                                  
 22519                                  ; 23/07/2018 - IBMDOS.COM (MSDOS 3.3), 1987 - Offset 39D0h
 22520                                  
 22521                                  	; 03/02/2024 - Retro DOS v5.0
 22522                                  	; PCDOS 7.1 IBMDOS.COM - DOSCODE:76FEh
 22523                                  	; (Win ME IO.SYS - BIOSCODE:7579h) 
 22524                                  
 22525                                  DOS_CLOSE:
 22526 00003745 C43E[9E05]              	LES	DI,[THISSFT]
 22527                                  	;mov	bx,[ES:DI+5]
 22528 00003749 268B5D05                	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
 22529                                  
 22530                                  ; Network closes are handled entirely by the net code.
 22531                                  
 22532                                  	;;test	bx,8000h
 22533                                  	;TEST	BX,sf_isnet
 22534                                  	; 17/12/2022
 22535                                  	;test	bh,80h
 22536 0000374D F6C780                  	test	bh,(sf_isnet>>8)
 22537 00003750 7406                    	JZ	short LocalClose
 22538                                  
 22539                                  	;CallInstall Net_Close,MultNET,6
 22540 00003752 B80611                  	mov     ax,1106h
 22541 00003755 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE FILE
 22542                                  			; ES:DI -> SFT
 22543                                  			; SFT DPB field -> DPB of drive containing file
 22544                                  			; Return: CF set on error, AX = DOS error code
 22545                                  			; CF clear if successful
 22546                                  RET2:		; 03/02/2024
 22547 00003757 C3                      	retn
 22548                                  
 22549                                  ; All closes release the sharing information.
 22550                                  ; No commit releases sharing information
 22551                                  ;
 22552                                  ; All closes decrement the ref count.
 22553                                  ; No commit decrements the ref count.
 22554                                  
 22555                                  LocalClose:
 22556 00003758 E8A8E1                  	call	ECritDisk
 22557 0000375B E8C901                  	CALL	SetSFTTimes
 22558 0000375E E84C01                  	CALL	FREE_SFT		; dec ref count or mark as busy
 22559                                  
 22560                                  ;hkn; SS is DOSDATA
 22561                                  	;Context DS
 22562 00003761 16                      	push	ss
 22563 00003762 1F                      	pop	ds
 22564                                  
 22565 00003763 50                      	push	ax
 22566 00003764 53                      	push	bx
 22567 00003765 E82146                  	call	ShareEnd
 22568 00003768 5B                      	pop	bx
 22569 00003769 58                      	pop	ax
 22570                                  
 22571                                  ; Commit enters here. AX from commit MUST be <> 1, BX is flags word
 22572                                  
 22573                                  CloseEntry:
 22574 0000376A 50                      	PUSH	AX
 22575                                  
 22576                                  ; File clean or device does not get stamped nor disk looked at.
 22577                                  
 22578                                  	;test	bx,0C0h
 22579                                  	; 17/12/2022
 22580 0000376B F6C3C0                  	test	bl,devid_file_clean+devid_device
 22581                                  	;TEST	BX,devid_file_clean+devid_device
 22582 0000376E 7403                    	JZ	short rdir
 22583                                  	; 14/11/2022
 22584 00003770 E90101                  	JMP	FREE_SFT_OK		; either clean or device
 22585                                  	;jnz	short FREE_SFT_OK ; 24/07/2019	
 22586                                  
 22587                                  ; Retrieve the directory entry for the file
 22588                                  
 22589                                  rdir:
 22590 00003773 E84401                  	CALL	DirFromSFT
 22591                                  	;mov	al,5
 22592 00003776 B005                    	MOV	AL,error_access_denied
 22593                                  	
 22594                                  	; 03/02/2024
 22595                                  	;JNC	short clook
 22596                                  	;; 14/11/2022
 22597                                  	;JMP	CloseFinish		; pretend the close worked.
 22598                                  	;;jc	short CloseFinish ; 24/07/2019
 22599                                  	
 22600                                  	;;;
 22601                                  	; 03/02/2024 - Retro DOS v5.0
 22602                                  	; (PCDOS 7.1 IBMDOS.COM)
 22603 00003778 7240                    	jc	short jmp_to_CloseFinish ; pretend the close worked.
 22604                                  rdir2:
 22605                                  	;test	word [si+2],4
 22606 0000377A F6440204                	test	byte [si+SF_ENTRY.sf_mode],4 ; devid_device_null
 22607                                  					; bit 2 - null device
 22608 0000377E 751F                    	jnz	short clook
 22609                                  
 22610 00003780 1E                      	push	ds
 22611 00003781 53                      	push	bx
 22612 00003782 C55C07                  	lds	bx,[si+7]
 22613 00003785 C55C07                  	lds	bx,[si+SF_ENTRY.sf_devptr] ; pointer to DPB
 22614                                  
 22615 00003788 8A1F                    	mov	bl,[bx]			; DPB.DRIVE
 22616 0000378A 30FF                    	xor	bh,bh  ; 0
 22617 0000378C 36F687[2F14]04          	test	byte [ss:bx+drive_flags],4
 22618                                  					; bit 2 - last access date/time flag?
 22619                                  					; or disk accessed flag !?
 22620 00003792 5B                       	pop	bx
 22621 00003793 7409                    	jz	short skip_upd_laccdt	; no support for last access date&time
 22622 00003795 1F                      	pop	ds
 22623 00003796 1E                      	push	ds
 22624 00003797 E8D2D3                  	call	DATE16
 22625                                  	;mov	[es:di+12h],ax
 22626 0000379A 26894512                	mov	[es:di+dir_entry.dir_lstaccdate],ax
 22627                                  skip_upd_laccdt:
 22628 0000379E 1F                      	pop	ds
 22629                                  	;;;
 22630                                  
 22631                                  clook:
 22632                                  
 22633                                  ; ES:DI points to entry
 22634                                  ; DS:SI points to SFT
 22635                                  ; ES:BX points to buffer header
 22636                                  
 22637 0000379F 57                      	push	di
 22638 000037A0 56                      	push	si
 22639                                  	;lea	si,[si+20h]
 22640 000037A1 8D7420                  	LEA	SI,[SI+SF_ENTRY.sf_name]
 22641                                  
 22642                                  ; ES:DI point to directory entry
 22643                                  ; DS:SI point to unpacked name
 22644                                  
 22645 000037A4 E84EE0                  	call	XCHGP
 22646                                  
 22647                                  ; ES:DI point to unpacked name
 22648                                  ; DS:SI point to directory entry
 22649                                  
 22650 000037A7 E81D0F                  	call	MetaCompare
 22651 000037AA E848E0                  	call	XCHGP
 22652 000037AD 5E                      	pop	si
 22653 000037AE 5F                      	pop	di
 22654 000037AF 740C                    	JZ	short CLOSE_GO		; Name OK
 22655                                  Bye:	
 22656 000037B1 89F7                    	MOV	DI,SI
 22657 000037B3 1E                      	PUSH	DS
 22658 000037B4 07                      	POP	ES			; ES:DI points to SFT
 22659 000037B5 16                      	PUSH	SS
 22660 000037B6 1F                      	POP	DS
 22661 000037B7 F9                      	STC
 22662                                  	;mov	al,2
 22663 000037B8 B002                    	MOV	AL,error_file_not_found
 22664                                  	
 22665                                  jmp_to_CloseFinish: ; 03/02/2024
 22666                                  	;JMP	CloseFinish ; 24/07/2019
 22667                                  	; 03/02/2024
 22668                                  	; (PCDOS 7.1 IBMDOS.COM)
 22669 000037BA E9DF00                  	jmp	CloseFinish2
 22670                                  
 22671                                  	; 18/05/2019 - Retro DOS v4.0
 22672                                  CLOSE_GO:
 22673                                  	; 03/02/2024
 22674                                  	;mov	al,[si+4]
 22675 000037BD 8A4404                  	mov	al,[si+SF_ENTRY.sf_attr]
 22676                                  	
 22677                                  	; MSDOS 6.0
 22678                                  	;test	word [si+2],8000h
 22679                                  	;TEST	word [SI+SF_ENTRY.sf_mode],sf_isFCB ; FCB ?
 22680                                  	; 17/12/2022
 22681                                  	;test	byte [si+3],80h
 22682 000037C0 F6440380                	test	byte [SI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8) ; FCB ?
 22683 000037C4 740A                    	JZ	short nofcb		; no, set dir attr, sf_attr
 22684                                  	; MSDOS 3.3 & MSDOS 6.0
 22685                                  	;mov	ch,[es:di+0Bh]
 22686 000037C6 268A6D0B                	MOV	CH,[ES:DI+dir_entry.dir_attr]
 22687                                  
 22688                                  	; 03/02/2024
 22689                                  	;;mov	al,[si+4]
 22690                                  	;MOV	AL,[SI+SF_ENTRY.sf_attr]
 22691                                  
 22692                                  ;hkn; SS override
 22693 000037CA 36A2[6B05]              	MOV	[SS:ATTRIB],AL
 22694                                  	; MSDOS 3.3
 22695                                  	;;call	MatchAttributes
 22696                                  	;;JNZ	short Bye		; attributes do not match
 22697                                  	; 18/05/2019
 22698 000037CE EB04                    	JMP	SHORT setattr		;FT.
 22699                                  nofcb:
 22700                                  	; 03/02/2024
 22701                                  	; MSDOS 6.0
 22702                                  	;;mov	al,[si+4]
 22703                                  	;MOV	AL,[SI+SF_ENTRY.sf_attr] ;FT.		;AN000;
 22704                                  
 22705 000037D0 2688450B                	MOV	[ES:DI+dir_entry.dir_attr],AL ;FT.	;AN000;
 22706                                  setattr:
 22707                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22708                                  	;or	byte [es:di+0Bh],20h
 22709 000037D4 26804D0B20              	OR	BYTE [ES:DI+dir_entry.dir_attr],attr_archive ;Set archive
 22710                                  	; MSDOS 6.0
 22711                                  	;mov	ax,[es:di+1Ah]
 22712 000037D9 268B451A                	MOV	AX,[ES:DI+dir_entry.dir_first] ;AN011
 22713                                  					;F.O. save old first cluster
 22714                                  ;hkn; SS override
 22715 000037DD 36A3[0310]              	MOV	[SS:OLD_FIRSTCLUS],AX	;AN011;F.O. save old first cluster
 22716                                  
 22717                                  	;;;
 22718                                  	; 03/02/2024
 22719                                  	; PCDOS 7.1 IBMDOS.COM
 22720                                  	;mov	ax,[es:di+14h]
 22721 000037E1 268B4514                	mov	ax,[ES:DI+dir_entry.dir_fclus_hi] ; old first cluster, hw
 22722 000037E5 36A3[0310]              	MOV	[ss:OLD_FIRSTCLUS],ax
 22723                                  	;;;
 22724                                  
 22725                                  	;;mov	ax,[si+0Bh]
 22726                                  	;MOV	AX,[SI+SF_ENTRY.sf_firclus]
 22727                                  	;;;
 22728                                  	; 03/02/2024
 22729                                  	; PCDOS 7.1 IBMDOS.COM
 22730 000037E9 8B442B                  	mov     ax,[si+2Bh]	; mov ax,[si+SF_ENTRY.sf_chain]
 22731                                  				; first cluster (32 bit) low word !
 22732                                  	;;;	
 22733                                  	;mov	[es:di+1Ah],ax
 22734 000037EC 2689451A                	MOV	[ES:DI+dir_entry.dir_first],AX	;Set firclus pointer
 22735                                  	;;; 03/02/2024
 22736 000037F0 8B442D                  	mov     ax,[si+2Dh]	; mov ax,[si+SF_ENTRY.sf_chain+2]
 22737                                  				; first cluster (32 bit) high word
 22738                                  	;mov	[es:di+14h],ax
 22739 000037F3 26894514                	mov	[es:di+dir_entry.dir_fclus_hi],ax
 22740                                  	;;;
 22741                                  
 22742                                  ; 03/02/2024
 22743                                  %if 0
 22744                                  	;mov	ax,[si+11h]
 22745                                  	MOV	AX,[SI+SF_ENTRY.sf_size]
 22746                                  	;mov	[es:di+1Ch],ax
 22747                                  	MOV	[ES:DI+dir_entry.dir_size_l],AX	;Set size
 22748                                  	;mov	ax,[si+13h]
 22749                                  	MOV	AX,[SI+SF_ENTRY.sf_size+2]
 22750                                  	;mov	[es:di+1Eh],ax
 22751                                  	MOV	[ES:DI+dir_entry.dir_size_h],AX
 22752                                  	;mov	ax,[si+0Fh]
 22753                                  	MOV	AX,[SI+SF_ENTRY.sf_date]
 22754                                  	;mov	[es:di+18h],ax
 22755                                  	MOV	[ES:DI+dir_entry.dir_date],AX	;Set date
 22756                                  	;mov	ax,[si+0Dh]
 22757                                  	MOV	AX,[SI+SF_ENTRY.sf_time]
 22758                                  	;mov	[es:di+16h],ax
 22759                                  	MOV	[ES:DI+dir_entry.dir_time],AX	;Set time
 22760                                  %else
 22761                                  	; 03/02/2024 - Retro DOS v5.0
 22762 000037F7 56                      	push	si
 22763 000037F8 83C60D                  	add	si,0Dh
 22764 000037FB AD                      	lodsw	; [si+SF_ENTRY.sf_time]
 22765 000037FC 26894516                	mov	[es:di+dir_entry.dir_time],ax	; Set time
 22766 00003800 AD                      	lodsw	; [si+SF_ENTRY.sf_date]
 22767 00003801 26894518                	mov	[es:di+dir_entry.dir_date],ax	; Set date
 22768 00003805 AD                      	lodsw	; [si+SF_ENTRY.sf_size]
 22769 00003806 2689451C                	mov	[es:di+dir_entry.dir_size_l],ax	; Set size
 22770 0000380A AD                      	lodsw	; [si+SF_ENTRY.sf_size+2]
 22771 0000380B 2689451E                	mov	[es:di+dir_entry.dir_size_h],ax
 22772 0000380F 5E                      	pop	si
 22773                                  %endif
 22774                                  
 22775                                  	; MSDOS 6.0
 22776                                  ;; File Tagging
 22777 00003810 26F6470540              	TEST	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty
 22778                                  				  ;LB. if already dirty		    ;AN000;
 22779 00003815 7508                    	JNZ	short yesdirty4	  ;LB.  don't increment dirty count ;AN000;
 22780                                  	; 02/06/2019
 22781 00003817 E8512D                  	call	INC_DIRTY_COUNT   ;LB.				    ;AN000;
 22782                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22783                                  	;or	byte [es:bx+5],40h
 22784 0000381A 26804F0540              	OR	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty
 22785                                  yesdirty4:
 22786 0000381F 1E                      	push	ds
 22787 00003820 56                      	push	si
 22788                                  
 22789                                  ; 03/02/2024
 22790                                  %if 0
 22791                                  	; MSDOS 6.0
 22792                                  	;mov	cx,[si+0Bh]
 22793                                  	; 07/12/2022
 22794                                  	MOV	CX,[SI+SF_ENTRY.sf_firclus] ; do this for Fastopen
 22795                                  %else
 22796                                  	; 03/02/2024
 22797                                  	; PCDOS 7.1
 22798 00003821 8B4C2B                  	mov	cx,[si+2Bh]		; [es:di+SF_ENTRY.sf_chain]
 22799                                  					; first cluster (32 bit) low word !?
 22800                                  %endif
 22801                                  
 22802                                  ;hkn; SS override
 22803 00003824 36A0[7605]              	MOV	AL,[SS:THISDRV]
 22804                                  	; MSDOS 3.3 
 22805                                  	;push	ss
 22806                                  	;pop	ds
 22807                                  	;MOV	AL,[THISDRV]
 22808                                  ;;; 10/1/86  update fastopen cache
 22809                                  	; MSDOS 3.3 & MSDOS 6.0
 22810 00003828 52                      	PUSH	DX
 22811 00003829 B400                    	MOV	AH,0			; dir entry update
 22812 0000382B 88C2                    	MOV	DL,AL			; drive number A=0, B=1,,,
 22813                                  	;;;
 22814                                  	; 03/02/2024 - Retro DOS v5.0
 22815                                  	; PCDOS 7.1
 22816 0000382D 53                      	push	bx ; *
 22817 0000382E 8B5C2D                  	mov	bx,[si+2Dh]		; [es:di+SF_ENTRY.sf_chain+2]
 22818                                  					; first cluster (32 bit) high word !?
 22819 00003831 09DB                    	or	bx,bx
 22820 00003833 7511                    	jnz	short do_update2
 22821                                  	;;;
 22822                                  	; MSDOS 6.0
 22823 00003835 09C9                    	OR	CX,CX			;AN005; first cluster 0; may be truncated
 22824 00003837 750D                    	JNZ	short do_update2	;AN005; no, do update
 22825 00003839 B403                    	MOV	AH,3			;AN005; do a delete cache entry
 22826                                  	;mov	di,[si+1Bh]
 22827 0000383B 8B7C1B                  	MOV	DI,[SI+SF_ENTRY.sf_dirsec] ;AN005; cx:di = dir sector
 22828                                  	;mov	cx,[si+1Dh]
 22829 0000383E 8B4C1D                  	MOV	CX,[SI+SF_ENTRY.sf_dirsec+2] ;AN005;
 22830                                  	;mov	dh,[si+1Fh]
 22831 00003841 8A741F                  	MOV	DH,[SI+SF_ENTRY.sf_dirpos] ;AN005; dh = dir pos
 22832 00003844 EB1A                    	JMP	SHORT do_update 	;AN011;F.O.
 22833                                  
 22834                                  do_update2:				;AN011;F.O.
 22835                                  	;;;
 22836                                  	; 03/02/2024
 22837                                  	; PCDOS 7.1
 22838 00003846 363B1E[6112]            	cmp	bx,[ss:OLD_FIRSTCLUS_HW] ; same as old first cluster?
 22839 0000384B 7507                    	jnz	short do_update3 ; no
 22840                                  	;;;
 22841                                  
 22842                                  ;hkn; SS override fort OLD_FIRSTCLUS
 22843                                  	; 
 22844 0000384D 363B0E[0310]            	CMP	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O. same as old first cluster?
 22845 00003852 740C                    	JZ	short do_update		;AN011;F.O. yes
 22846                                  do_update3:	; 03/02/2024
 22847 00003854 B402                    	MOV	AH,2			;AN011;F.O. delete the old entry
 22848 00003856 368B0E[0310]            	MOV	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O.
 22849                                  	;;;
 22850                                  	; 03/02/2024
 22851                                  	; PCDOS 7.1
 22852 0000385B 368B1E[6112]            	mov	bx,[ss:OLD_FIRSTCLUS_HW]
 22853                                  	;;; 
 22854                                  do_update:				;AN005;
 22855                                  ;hkn; SS is DOSDATA
 22856                                  	;Context DS
 22857 00003860 16                      	push	ss
 22858 00003861 1F                      	pop	ds
 22859                                  	;;;
 22860                                  	; 03/02/2024 - Retro DOS v5.0
 22861 00003862 87DE                    	xchg	bx,si	; PCDOS 7.1 IBMDOS.COM
 22862                                  	;;;
 22863                                  	; MSDOS 3.3 & MSDOS 6.0
 22864 00003864 E825F5                  	call	FastOpen_Update 	; invoke fastopen
 22865                                  	;;;
 22866                                  	; 03/02/2024
 22867 00003867 87DE                    	xchg	bx,si	; PCDOS 7.1 IBMDOS.COM
 22868 00003869 5B                      	pop	bx ; *
 22869                                  	;;;
 22870 0000386A 5A                      	POP	DX
 22871                                  
 22872                                  ;;; 10/1/86  update fastopen cache
 22873 0000386B E8EC2B                  	call	FLUSHBUF		; flush all relevant buffers
 22874 0000386E 5F                      	pop	di
 22875 0000386F 07                      	pop	es
 22876                                  	;mov	al,5
 22877 00003870 B005                    	MOV	AL,error_access_denied
 22878 00003872 7215                    	JC	short CloseFinish
 22879                                  FREE_SFT_OK:
 22880                                  	; 03/02/2024
 22881                                  	;CLC				; signal no error.
 22882                                  	
 22883                                  	;;;
 22884                                  	; 03/02/2024 - Retro DOS v5.0
 22885                                  	; PCDOS 7.1 IBMDOS.COM
 22886                                  	;test	word [es:di+5],8080h
 22887 00003874 26F745058080            	test	word [es:di+SF_ENTRY.sf_flags],sf_isnet+devid_device
 22888 0000387A 7520                    	jnz	short CloseFinish2
 22889 0000387C 06                      	push	es
 22890 0000387D 55                      	push	bp
 22891                                  	;les	bp,[es:di+7]
 22892 0000387E 26C46D07                	les	bp,[es:di+SF_ENTRY.sf_devptr] ; DPB
 22893 00003882 E80CFC                  	call	update_fat32_fsinfo
 22894 00003885 5D                      	pop	bp
 22895 00003886 07                      	pop	es
 22896 00003887 EB13                    	jmp	short CloseFinish2
 22897                                  	
 22898                                  CloseFinish:	; 03/02/2024 - Retro DOS v5.0
 22899 00003889 1E                      	push    ds
 22900 0000388A 53                      	push    bx
 22901 0000388B 26C55D07                	lds     bx,[es:di+7]		; [es:di+SF_ENTRY.sf_devptr] ; DPB
 22902 0000388F 8A1F                    	mov     bl,[bx]			; DPB.DRIVE
 22903 00003891 30FF                    	xor     bh,bh ; 0
 22904 00003893 3680A7[2F14]FB          	and     byte [ss:bx+drive_flags],0FBh ; clear bit 2
 22905                                  					; bit 2 - last access date/time flag?
 22906                                  					; or disk accessed (successful) flag !?
 22907 00003899 5B                      	pop     bx
 22908 0000389A 1F                      	pop     ds
 22909 0000389B F9                      	stc
 22910                                  	;;;
 22911                                  
 22912                                  CloseFinish2:	 ; 03/02/2024 - Retro DOS v5.0
 22913                                  ;Closefinish:
 22914                                  
 22915                                  ; Indicate to the device that the SFT is being closed.
 22916                                  
 22917                                  ;;;; 7/21/86
 22918 0000389C 9C                      	PUSHF				; save flag from DirFromSFT
 22919 0000389D E83417                  	call	DEV_CLOSE_SFT
 22920 000038A0 9D                      	POPF
 22921                                  ;;;; 7/21/86
 22922                                  ;
 22923                                  ; See if the ref count indicates that we have busied the SFT. If so, mark the
 22924                                  ; SFT as being free. Note that we do NOT need to be in critSFT as we are ONLY
 22925                                  ; going to be moving from busy to free.
 22926                                  ;
 22927 000038A1 59                      	POP	CX			; get old ref count
 22928 000038A2 9C                      	PUSHF
 22929                                  	; 03/02/2024
 22930                                  	;DEC	CX			; if cx != 1
 22931                                  	;JNZ	short NoFree		; then do NOT free SFT
 22932 000038A3 E203                    	loop	NoFree ; PCDOS 7.1 IBMDOS.COM
 22933                                  
 22934                                  ; 03/02/2024 - Retro DOS v5.0
 22935                                  %if 0
 22936                                  	mov	[es:di],cx
 22937                                  	;MOV	[ES:DI+SF_ENTRY.sf_ref_Count],CX ; mov [es:di+0],cx
 22938                                  %else
 22939                                  	; 03/02/2024
 22940                                  	; PCDOS 7.1 IBMDOS.COM
 22941 000038A5 E85610                  	call    SFT_FREE
 22942                                  %endif
 22943                                  
 22944                                  NoFree:
 22945 000038A8 E885E0                  	call	LCritDisk
 22946 000038AB 9D                      	POPF
 22947 000038AC C3                      	retn
 22948                                  
 22949                                  ;---------------------------------------------------------------------------
 22950                                  ;
 22951                                  ; Procedure Name : FREE_SFT
 22952                                  ;
 22953                                  ; ES:DI -> SFT. Decs sft_ref_count. If the count goes to 0, mark it as busy.
 22954                                  ; Flags preserved. Return old ref count in AX
 22955                                  ;
 22956                                  ; Note that busy is indicated by the SFT ref count being -1.
 22957                                  ;
 22958                                  ;---------------------------------------------------------------------------
 22959                                  
 22960                                  FREE_SFT:
 22961 000038AD 9C                      	PUSHF		; Save carry state
 22962 000038AE 268B05                  	mov	ax,[es:di]
 22963                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 22964 000038B1 48                      	DEC	AX
 22965 000038B2 7501                    	JNZ	short SetCount
 22966 000038B4 48                      	DEC	AX
 22967                                  SetCount:
 22968 000038B5 268705                  	xchg	ax,[es:di]
 22969                                  	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 22970 000038B8 9D                      	POPF
 22971 000038B9 C3                      	retn
 22972                                  
 22973                                  	; 18/05/2019 - Retro DOS v4.0
 22974                                  
 22975                                  ;----------------------------------------------------------------------------
 22976                                  ;
 22977                                  ; Procedure Name : DirFromSFT
 22978                                  ;
 22979                                  ;   DirFromSFT - locate a directory entry given an SFT.
 22980                                  ;
 22981                                  ;   Inputs:	ES:DI point to SFT
 22982                                  ;		DS = DOSDATA
 22983                                  ;   Outputs:
 22984                                  ;		EXTERR_LOCUS = errLOC_Disk
 22985                                  ;		CurBuf points to buffer
 22986                                  ;		Carry Clear -> operation OK
 22987                                  ;		    ES:DI point to entry
 22988                                  ;		    ES:BX point to buffer
 22989                                  ;		    DS:SI point to SFT
 22990                                  ;		Carry SET   -> operation failed
 22991                                  ;		    registers trashified
 22992                                  ;   Registers modified: ALL
 22993                                  ;----------------------------------------------------------------------------
 22994                                  
 22995                                  	; 04/02/2024 - Retro DOS v5.0
 22996                                  	; PCDOS 7.1 IBMDOS.COM
 22997                                  
 22998                                  DirFromSFT:
 22999                                  	;;mov	byte [EXTERR_LOCUS],2
 23000                                  	;MOV	byte [EXTERR_LOCUS],errLOC_Disk
 23001                                  	; 04/02/2024
 23002 000038BA E841DA                  	call	set_exerr_locus_disk
 23003                                  	;
 23004 000038BD 06                      	push	es
 23005 000038BE 57                      	push	di
 23006                                  	; MSDOS 3.3
 23007                                  	;;mov	dx,[es:di+1Dh]
 23008                                  	;MOV	dx,[ES:DI+SF_ENTRY.sf_dirsec]
 23009                                  	; MSDOS 6.0
 23010                                  	;mov	dx,[es:[di+1Dh]
 23011 000038BF 268B551D                	MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec+2]  ;F.C. >32mb
 23012 000038C3 8916[0706]              	MOV	[HIGH_SECTOR],DX		 ;F.C. >32mb
 23013                                  	; 04/02/2024
 23014 000038C7 52                      	push	dx
 23015                                  	;mov	dx,[es:di+1Bh]
 23016 000038C8 268B551B                	MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec]
 23017                                  	; 04/02/2024
 23018                                  	; 19/05/2019
 23019                                  	;PUSH	word [HIGH_SECTOR]	;F.C. >32mb
 23020                                  	; MSDOS 3.3 & MSDOS 6.0
 23021 000038CC 52                      	PUSH	DX
 23022 000038CD E8D327                  	call	FATREAD_SFT		; ES:BP points to DPB, [THISDRV] set
 23023                                  					; [THISDPB] set
 23024 000038D0 5A                      	POP	DX
 23025 000038D1 8F06[0706]              	POP	word [HIGH_SECTOR]	;F.C. >32mb
 23026 000038D5 721E                    	JC	short PopDone
 23027                                  	; 22/09/2023
 23028                                  	;XOR	AL,AL	; *		; Pre read
 23029                                  	;;mov	byte [ALLOWED],18h
 23030                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 23031                                  	;call	GETBUFFR
 23032                                  	; 22/09/2023
 23033 000038D7 E87C2A                  	call	GETBUFFER ; * 		; Pre read
 23034 000038DA 7219                    	JC	short PopDone
 23035 000038DC 5E                      	pop	si
 23036 000038DD 1F                      	pop	ds			; Get back SFT pointer
 23037                                  
 23038                                  ;hkn; SS override
 23039 000038DE 36C43E[E205]            	LES	DI,[SS:CURBUF]
 23040                                  	;or	byte [es:di+5],4
 23041 000038E3 26804D0504              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
 23042 000038E8 89FB                    	MOV	BX,DI			; ES:BX point to buffer header
 23043                                  	;;;lea	di,[di+16] ; MSDOS 3.3
 23044                                  	;;lea	di,[di+20] ; MSDOS 6.0
 23045                                  	; 04/02/2024
 23046                                  	;lea	di,[di+24] ; MSDOS 7.1
 23047 000038EA 8D7D18                  	LEA	DI,[DI+BUFINSIZ] 	; Point to buffer
 23048                                  	;mov	al,32
 23049 000038ED B020                    	MOV	AL,dir_entry.size
 23050                                  	;mul	byte [si+1Fh] ; MSDOS 6.0
 23051 000038EF F6641F                  	MUL	byte [SI+SF_ENTRY.sf_dirpos]
 23052 000038F2 01C7                    	ADD	DI,AX			; Point at the entry
 23053 000038F4 C3                      	retn				; carry is clear
 23054                                  PopDone:
 23055 000038F5 5F                      	pop	di
 23056 000038F6 07                      	pop	es
 23057                                  PopDone_retn:
 23058 000038F7 C3                      	retn
 23059                                  
 23060                                  ;----------------------------------------------------------------------------
 23061                                  ;
 23062                                  ;**	DOS_Commit - UPdate Directory Entries
 23063                                  ;
 23064                                  ;	ENTRY	same as DOS_CLOSE (??? BUGBUG - update this jgl)
 23065                                  ;		(DS) = DOSGROUP
 23066                                  ;	EXIT	Same as DOS_CLOSE except ref_count field is not altered
 23067                                  ;	USES	all but DS
 23068                                  ;
 23069                                  ;----------------------------------------------------------------------------
 23070                                  
 23071                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23072                                  ; DOSCODE:6F72h (MSDOS 5.0, MSDOS.SYS)
 23073                                  
 23074                                  ; 04/02/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 23075                                  ; DOSCODE:78B8h (PCDOS 7.1 IBMDOS.COM)
 23076                                  
 23077                                  DOS_COMMIT:
 23078                                  	;hkn; called from srvcall. DS already set up.
 23079 000038F8 C43E[9E05]              	LES	DI,[THISSFT]
 23080                                  	;mov	bx,[es:di+5]
 23081 000038FC 268B5D05                	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
 23082                                  	;test	bx,0C0h
 23083                                  	; 17/12/2022
 23084 00003900 F6C3C0                  	test	bl,devid_file_clean+devid_device ;Clears carry
 23085                                  	;TEST	BX,devid_file_clean+devid_device ;Clears carry
 23086 00003903 75F2                    	jnz	short PopDone_retn
 23087                                  	;test	bx,8000h
 23088                                  	; 17/12/2022
 23089                                  	;test	bh,80h
 23090 00003905 F6C780                  	test	bh,(sf_isnet>>8) ; 80h
 23091                                  	;TEST	BX,sf_isnet ; 8000h
 23092 00003908 7406                    	JZ	short LOCAL_COMMIT
 23093                                  
 23094                                  ;IF NOT Installed
 23095                                  ;	transfer NET_COMMIT
 23096                                  ;ELSE
 23097                                  	;mov	ax,1107h
 23098 0000390A B80711                  	MOV	AX,(MultNET<<8)|7
 23099 0000390D CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
 23100                                  			; ES:DI -> SFT
 23101                                  			; SFT DPB field -> DPB of drive containing file
 23102                                  			; Return: CF set on error, AX = DOS error code
 23103                                  			; CF clear if successful
 23104                                  localcommit_retn: ; 18/12/2022	
 23105 0000390F C3                      	retn
 23106                                  ;ENDIF
 23107                                  
 23108                                  ; Perform local commit operation by doing a close but not releaseing the SFT.
 23109                                  ; There are three ways we can do this. One is to enter a critical section to
 23110                                  ; protect a potential free. The second is to increment the ref count to mask
 23111                                  ; the close decrementing.
 23112                                  ;
 23113                                  ; The proper way is to let the caller's of close decide if a decrement should
 23114                                  ; be done. We do this by providing another entry into close after the
 23115                                  ; decrement and after the share information release.
 23116                                  
 23117                                  ; DOSCODE:6FA0h (MSDOS 6.21, MSDOS.SYS)
 23118                                  ; DOSCODE:6F8Ch (MSDOS 5.0, MSDOS.SYS) 
 23119                                  
 23120                                  LOCAL_COMMIT:
 23121 00003910 E8F0DF                  	call	ECritDisk
 23122                                  	; MSDOS 6.0
 23123 00003913 E8EDDF                  	call	ECritDisk	;PTM.
 23124 00003916 E80E00                  	call	SetSFTTimes
 23125 00003919 B8FFFF                  	MOV	AX,-1 ; 0FFFFh
 23126 0000391C E84BFE                  	call	CloseEntry
 23127                                  	; MSDOS 6.0
 23128 0000391F 9C                      	PUSHF			;PTM.				;AN000;
 23129 00003920 E8A916                  	call	DEV_OPEN_SFT	;PTM.  increment device count	;AN000;
 23130 00003923 9D                      	POPF			;PTM.				;AN000;
 23131                                  	;call	LCritDisk	;PTM.				;AN000;
 23132                                  	; 18/12/2022
 23133 00003924 E909E0                  	jmp	LCritDisk
 23134                                  ;localcommit_retn:
 23135                                  ;	retn
 23136                                  
 23137                                  ;Break	<SetSFTTimes - signal a change in the times for an SFT>
 23138                                  ;----------------------------------------------------------------------------
 23139                                  ;
 23140                                  ; Procedure Name : SetSFTTimes
 23141                                  ;
 23142                                  ;   SetSFTTimes - Examine the flags for a SFT and set the time appropriately.
 23143                                  ;   Reflect these times in other SFT's for the same file.
 23144                                  ;
 23145                                  ;   Inputs:	ES:DI point to SFT
 23146                                  ;		BX = sf_flags set appropriately
 23147                                  ;   Outputs:	Set sft times to current time if File & dirty & !nodate
 23148                                  ;   Registers modified: All except ES:DI, BX, AX
 23149                                  ;
 23150                                  ;----------------------------------------------------------------------------
 23151                                  
 23152                                  	; 04/02/2024 - Retro DOS v5.0
 23153                                  	; PCDOS 7.1 IBMDOS.COM 
 23154                                  
 23155                                  SetSFTTimes:
 23156                                  
 23157                                  ; 04/02/2024
 23158                                  %if 0
 23159                                  ;	File clean or device does not get stamped nor disk looked at.
 23160                                  	
 23161                                  	;test	bx,0C0h
 23162                                  	; 17/12/2022
 23163                                  	test	bl,devid_file_clean+devid_device
 23164                                  	;TEST	BX,devid_file_clean+devid_device
 23165                                  	;retnz				; clean or device => no timestamp
 23166                                  	jnz	short localcommit_retn
 23167                                  
 23168                                  ;	file and dirty. See if date is good
 23169                                  
 23170                                  	;test	bx,4000h
 23171                                  	; 17/12/2022
 23172                                  	;test	bh,40h
 23173                                  	test	bh,(sf_close_nodate>>8)
 23174                                  	;TEST	BX,sf_close_nodate
 23175                                  	;retnz				; nodate => no timestamp
 23176                                  	jnz	short localcommit_retn
 23177                                  %else
 23178                                  	; 04/02/2024
 23179                                  	; (PCDOS 7.1 IBMDOS.COM)
 23180                                  	;test	bx,40C0h
 23181 00003927 F7C3C040                	test	bx,sf_close_nodate+devid_file_clean+devid_device
 23182 0000392B 75E2                    	jnz	short localcommit_retn
 23183                                  %endif
 23184                                  
 23185 0000392D 50                      	push	ax
 23186 0000392E 53                      	push	bx
 23187 0000392F E83AD2                  	call	DATE16			; Date/Time to AX/DX
 23188                                  	;mov	[es:di+0Fh],ax
 23189 00003932 2689450F                	MOV	[ES:DI+SF_ENTRY.sf_date],AX
 23190                                  	;mov	[es:di+0Dh],dx
 23191 00003936 2689550D                	MOV	[ES:DI+SF_ENTRY.sf_time],DX
 23192 0000393A 31C0                    	XOR	AX,AX
 23193                                  ;if installed
 23194                                  	;call	JShare + 14 * 4
 23195 0000393C FF1E[C800]              	call	far [JShare+(14*4)]	; 14 = ShSU
 23196                                  ;else
 23197                                  ;	call	ShSU
 23198                                  ;endif
 23199 00003940 5B                      	pop	bx
 23200 00003941 58                      	pop	ax
 23201 00003942 C3                      	retn
 23202                                  
 23203                                  ;============================================================================
 23204                                  ; DIRCALL.ASM, MSDOS 6.0, 1991
 23205                                  ;============================================================================
 23206                                  ; 23/07/2018 - Retro DOS v3.0
 23207                                  ; 18/05/2019 - Retro DOS v4.0
 23208                                  
 23209                                  ; DOSCODE:6FDAh (MSDOS 6.21, MSDOS.SYS)
 23210                                  
 23211                                  ;TITLE DIRCALL - Directory manipulation internal calls
 23212                                  ;NAME  DIRCALL
 23213                                  
 23214                                  ;**	Low level directory manipulation routines for making removing and
 23215                                  ;	  verifying local or NET directories
 23216                                  ;
 23217                                  ;	DOS_MKDIR
 23218                                  ;	DOS_CHDIR
 23219                                  ;	DOS_RMDIR
 23220                                  ;
 23221                                  ;	Modification history:
 23222                                  ;
 23223                                  ;		Created: ARR 30 March 1983
 23224                                  
 23225                                  ;BREAK <DOS_MkDir - Make a directory entry>
 23226                                  ;---------------------------------------------------------------------------
 23227                                  ;
 23228                                  ; Procedure Name : DOS_MkDir
 23229                                  ;
 23230                                  ; Inputs:
 23231                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 23232                                  ;		terminated)
 23233                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 23234                                  ;		( = -1 if current dir not involved, else
 23235                                  ;		 Points to first char after last "/" of current dir part)
 23236                                  ;	[THISCDS] Points to CDS being used
 23237                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 23238                                  ; Function:
 23239                                  ;	Make a new directory
 23240                                  ; Returns:
 23241                                  ;	Carry Clear
 23242                                  ;		No error
 23243                                  ;	Carry Set
 23244                                  ;	    AX is error code
 23245                                  ;		error_path_not_found
 23246                                  ;			Bad path (not in curr dir part if present)
 23247                                  ;		error_bad_curr_dir
 23248                                  ;			Bad path in current directory part of path
 23249                                  ;		error_access_denied
 23250                                  ;			Already exists, device name
 23251                                  ; DS preserved, Others destroyed
 23252                                  ;---------------------------------------------------------------------------
 23253                                  
 23254                                  ;hkn; called from path.asm. DS already set up.
 23255                                  
 23256                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23257                                  ; DOSCODE:6FC6h (MSDOS 5.0, MSDOS.SYS)
 23258                                  
 23259                                  ; 04/02/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 23260                                  ; DOSCODE:78FFh (PCDOS 7.1, IBMDOS.COM)
 23261                                  
 23262                                  DOS_MKDIR:
 23263 00003943 E8FBDE                  	call	TestNet
 23264 00003946 7313                    	JNC	short LOCAL_MKDIR
 23265                                  
 23266                                  ;IF NOT Installed
 23267                                  ;	transfer NET_MKDIR
 23268                                  ;ELSE
 23269                                  	;mov	ax,1103h
 23270 00003948 B80311                  	MOV	AX,(MultNET<<8)|3
 23271 0000394B CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY
 23272                                  			; SS = DOS CS
 23273                                  			; SDA first filename pointer -> fully-qualified directory name
 23274                                  			; SDA CDS pointer -> current directory
 23275                                  			; Return: CF set on error, AX = DOS error code
 23276                                  			; CF clear if successful
 23277 0000394D C3                      	retn
 23278                                  ;ENDIF
 23279                                  
 23280                                  NODEACCERRJ:
 23281                                  	;mov	ax,5
 23282 0000394E B80500                  	MOV	AX,error_access_denied
 23283                                  _BadRet:
 23284 00003951 F9                      	STC
 23285                                  	;call	LCritDisk
 23286                                  	;retn
 23287                                  	; 18/12/2022
 23288 00003952 E9DBDF                  	jmp	LCritDisk
 23289                                  
 23290                                  PATHNFJ:
 23291 00003955 E8D8DF                  	call	LCritDisk
 23292 00003958 E915F8                  	jmp	SET_MKND_ERR	; Map the MakeNode error and return
 23293                                  
 23294                                  LOCAL_MKDIR:
 23295 0000395B E8A5DF                  	call	ECritDisk
 23296                                  
 23297                                  ; MakeNode requires an SFT to fiddle with. We Use a temp spot (RENBUF)
 23298                                  
 23299 0000395E 8C16[A005]              	MOV	[THISSFT+2],SS
 23300                                  
 23301                                  ;hkn; DOSDATA
 23302 00003962 C706[9E05][3E04]        	MOV	WORD [THISSFT],RENBUF
 23303                                  
 23304                                  ;  NOTE: Need WORD PTR because MASM takes type of
 23305                                  ;   TempSFT (byte) instead of type of sf_mft (word).
 23306                                  
 23307                                  	;mov	word [RENBUF+33h],0 ; MSDOS 6.0
 23308 00003968 C706[7104]0000          	MOV	WORD [RENBUF+SF_ENTRY.sf_MFT],0
 23309                                  				; make sure SHARER won't complain.
 23310                                  	;mov	al,10h
 23311 0000396E B010                    	MOV	AL,attr_directory
 23312 00003970 E8F819                  	call	MakeNode
 23313 00003973 72E0                    	JC	short PATHNFJ
 23314 00003975 83F803                  	CMP	AX,3
 23315 00003978 74D4                    	JZ	short NODEACCERRJ ; Can't make a device into a directory
 23316 0000397A C42E[8A05]              	LES	BP,[THISDPB]	; Makenode zaps this
 23317 0000397E C53E[E205]              	LDS	DI,[CURBUF]
 23318 00003982 29FE                    	SUB	SI,DI
 23319 00003984 56                      	PUSH	SI		; Pointer to dir_first
 23320                                  
 23321                                  ; 04/02/2024
 23322                                  %if 0
 23323                                  	; MSDOS 6.0
 23324                                  	;push	word [DI+8]
 23325                                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;F.C. >32mb
 23326                                  	; MSDOS 3.3 & MSDOS 6.0
 23327                                  	;push	word [di+6]
 23328                                  	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Sector of new node
 23329                                  %else
 23330                                  	; 04/02/2024
 23331                                  	; (PCDOS 7.1 IBMDOS.COM)
 23332 00003985 C54506                  	lds	ax,[di+BUFFINFO.buf_sector] ; Sector of new node
 23333 00003988 1E                      	push	ds
 23334 00003989 50                      	push	ax
 23335                                  %endif
 23336                                  
 23337 0000398A 16                      	push	ss
 23338 0000398B 1F                      	pop	ds
 23339                                  
 23340                                  	; 04/02/2024
 23341                                  	;PUSH	word [DIRSTART]	; Parent for .. entry
 23342 0000398C 31C0                    	XOR	AX,AX
 23343                                  	;MOV	[DIRSTART],AX	; Null directory
 23344                                  	;;;
 23345                                  	; Retro DOS v5.0
 23346                                  	; PCDOS 7.1 IBMDOS.COM
 23347 0000398E 89C2                    	mov	dx,ax ; 0
 23348 00003990 8716[E30A]              	xchg	dx,[DIRSTART_HW] ; Null directory
 23349 00003994 8706[C205]              	xchg	ax,[DIRSTART]
 23350                                  	;
 23351                                  	;cmp	word [es:bp+0Fh],0
 23352 00003998 26837E0F00              	cmp	word [es:bp+DPB.FAT_SIZE],0
 23353 0000399D 7510                    	jnz	short LOCAL_MKDIR_cont ; not FAT32
 23354                                  	;cmp	[es:bp+35h],ax
 23355 0000399F 26394635                	cmp	[es:bp+DPB.ROOT_CLUSTER],ax
 23356 000039A3 750A                    	jne     short LOCAL_MKDIR_cont
 23357                                  	;cmp	[es:bp+37h],dx
 23358 000039A5 26395637                	cmp	[es:bp+DPB.ROOT_CLUSTER+2],dx
 23359 000039A9 7504                    	jne	short LOCAL_MKDIR_cont
 23360                                  	;
 23361 000039AB 31D2                    	xor	dx,dx
 23362 000039AD 31C0                    	xor	ax,ax
 23363                                  		; dx:ax = 0 for root directory
 23364                                  LOCAL_MKDIR_cont:
 23365 000039AF 52                      	push	dx
 23366                                  	;;;
 23367 000039B0 50                      	push	ax
 23368                                  
 23369 000039B1 E8F318                  	call	NEWDIR
 23370 000039B4 7278                    	JC	short NODEEXISTSPOPDEL ; No room
 23371 000039B6 E8750D                  	call	GETENT		; First entry
 23372 000039B9 7273                    	JC	short NODEEXISTSPOPDEL ; Screw up
 23373 000039BB C43E[E205]              	LES	DI,[CURBUF]
 23374                                  
 23375                                  ; 04/02/2024
 23376                                  %if 0
 23377                                  	; MSDOS 6.0
 23378                                  	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 23379                                  				 ;LB. if already dirty		    ;AN000;
 23380                                  	JNZ	short yesdirty5	 ;LB.   don't increment dirty count ;AN000;
 23381                                  	call	INC_DIRTY_COUNT  ;LB.				    ;AN000;
 23382                                  	
 23383                                  	; MSDOS 3.3 & MSDOS 6.0
 23384                                  	;or	byte [es:di+5],40h  ; 07/12/2022
 23385                                  	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 23386                                  %else
 23387                                  	; 04/02/2024
 23388                                  	; (PCDOS 7.1 IBMDOS.COM)
 23389 000039BF E89D2B                  	call    SET_BUF_DIRTY
 23390                                  %endif
 23391                                  
 23392                                  yesdirty5:
 23393                                  	;;;add	di,16 ; MSDOS 3.3
 23394                                  	;;add	di,20 ; MSDOS 6.0
 23395                                  	; 04/02/2024
 23396                                  	;add	di,24 ; PCDOS 7.1	
 23397 000039C2 83C718                  	ADD	DI,BUFINSIZ	; Point at buffer
 23398 000039C5 B82E20                  	MOV	AX,202EH	; ". "
 23399                                  	;;;
 23400                                  	; 04/02/2024 (PCDOS 7.1 IBMDOS.COM)
 23401 000039C8 8B16[E30A]              	mov	dx,[DIRSTART_HW]
 23402 000039CC 8916[F90A]              	mov	[CLUSTERS_HW],dx
 23403                                  	;;;
 23404 000039D0 8B16[C205]              	MOV	DX,[DIRSTART]	; Point at itself
 23405 000039D4 E87019                  	call	SETDOTENT
 23406 000039D7 B82E2E                  	MOV	AX,2E2EH	; ".."
 23407 000039DA 5A                      	POP	DX		; Parent
 23408                                  	;;;
 23409                                  	; 04/02/2024 (PCDOS 7.1 IBMDOS.COM)
 23410 000039DB 8F06[F90A]              	pop	word [CLUSTERS_HW]
 23411                                  	;;;
 23412 000039DF E86519                  	call	SETDOTENT
 23413 000039E2 C42E[8A05]              	LES	BP,[THISDPB]
 23414                                  	; 22/09/2023
 23415                                  	;;mov	byte [ALLOWED],18h
 23416                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 23417 000039E6 5A                      	POP	DX		; Entry sector
 23418                                  	; MSDOS 6.0
 23419 000039E7 8F06[0706]              	POP	word [HIGH_SECTOR] ;F.C. >32mb
 23420                                  
 23421                                  	;XOR	AL,AL ; *	; Pre read
 23422                                  	;call	GETBUFFR
 23423                                  	; 22/09/2023
 23424 000039EB E86829                  	call	GETBUFFER ; *	; Pre read
 23425 000039EE 7265                    	JC	short NODEEXISTSP
 23426                                  	;;;
 23427                                  	; 04/02/2024 (PCDOS 7.1 IBMDOS.COM)
 23428 000039F0 A1[E30A]                	mov	ax,[DIRSTART_HW]
 23429                                  	;;;
 23430 000039F3 8B16[C205]              	MOV	DX,[DIRSTART]
 23431 000039F7 C53E[E205]              	LDS	DI,[CURBUF]
 23432                                  	;or	byte [di+5],4
 23433 000039FB 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 23434 000039FF 5E                      	POP	SI		; dir_first pointer
 23435 00003A00 01FE                    	ADD	SI,DI
 23436 00003A02 8914                    	MOV	[SI],DX		; dir_entry.dir_first
 23437                                  	;;;
 23438                                  	; 04/02/2024 (PCDOS 7.1 IBMDOS.COM)
 23439 00003A04 8944FA                  	mov	[si-6],ax	; dir_entry.dir_fclus_hi
 23440                                  	;;;
 23441                                  
 23442 00003A07 31D2                    	XOR	DX,DX
 23443 00003A09 895402                  	MOV	[SI+2],DX	; Zero size
 23444 00003A0C 895404                  	MOV	[SI+4],DX
 23445                                  DIRUP:
 23446                                  	; MSDOS 6.0
 23447 00003A0F F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
 23448                                  	;			 ;LB. if already dirty 		   ;AN000;
 23449 00003A13 7507                    	JNZ	short yesdirty6	 ;LB.  don't increment dirty count ;AN000;
 23450 00003A15 E8532B                  	call	INC_DIRTY_COUNT  ;LB.				   ;AN000;
 23451                                  	
 23452                                  	; MSDOS 3.3 & MSDOS 6.0
 23453                                  	;or	byte [di+5],40h
 23454 00003A18 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty	; Dirty buffer
 23455                                  yesdirty6:
 23456 00003A1C 16                      	push	ss
 23457 00003A1D 1F                      	pop	ds
 23458                                  	;;;
 23459                                  	; 04/02/2024 (PCDOS 7.1 IBMDOS.COM)
 23460 00003A1E E870FA                  	call	update_fat32_fsinfo
 23461                                  	;;;
 23462 00003A21 268A4600                	mov	al,[es:bp]
 23463                                  	;MOV	AL,[ES:BP+DPB.DRIVE]  ; mov al,[es:bp+0]
 23464 00003A25 E8322A                  	call	FLUSHBUF
 23465                                  	;mov	ax,5
 23466 00003A28 B80500                  	MOV	AX,error_access_denied
 23467                                  	;call	LCritDisk
 23468                                  	;retn
 23469                                  	; 18/12/2022
 23470 00003A2B E902DF                  	jmp	LCritDisk
 23471                                  
 23472                                  NODEEXISTSPOPDEL:
 23473                                  	;;;
 23474                                  	; 04/02/2024 (PCDOS 7.1 IBMDOS.COM)
 23475 00003A2E 5A                      	pop	dx		; Parent
 23476                                  	;;;
 23477 00003A2F 5A                      	POP	DX		; Parent
 23478 00003A30 5A                      	POP	DX		; Entry sector
 23479                                  	; MSDOS 6.0 
 23480 00003A31 8F06[0706]              	POP	word [HIGH_SECTOR] ; F.C. >32mb
 23481 00003A35 C42E[8A05]              	LES	BP,[THISDPB]
 23482                                  	; 22/09/2023
 23483                                  	;;mov	byte [ALLOWED],18h
 23484                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 23485                                  	;XOR	AL,AL ; *	; Pre read
 23486                                  	;call	GETBUFFR
 23487                                  	; 22/09/2023
 23488 00003A39 E81A29                  	call	GETBUFFER ; *	; Pre read
 23489 00003A3C 7217                    	JC	short NODEEXISTSP
 23490 00003A3E C53E[E205]              	LDS	DI,[CURBUF]
 23491                                  	;or	byte [di+5],4
 23492 00003A42 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 23493 00003A46 5E                      	POP	SI		; dir_first pointer
 23494 00003A47 01FE                    	ADD	SI,DI
 23495                                  	;sub	si,1Ah ; 26
 23496 00003A49 83EE1A                  	SUB	SI,dir_entry.dir_first	;Point back to start of dir entry
 23497 00003A4C C604E5                  	MOV	BYTE [SI],0E5H	; Free the entry
 23498 00003A4F E8BDFF                  	CALL	DIRUP		; Error doesn't matter since erroring anyway
 23499                                  NODEEXISTS:
 23500 00003A52 E9F9FE                  	JMP	NODEACCERRJ ; 10/08/2018
 23501                                  
 23502                                  NODEEXISTSP:
 23503 00003A55 5E                      	POP	SI		; Clean stack
 23504 00003A56 EBFA                    	JMP	short NODEEXISTS
 23505                                  
 23506                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23507                                  
 23508                                  ;BREAK <DOS_ChDir -- Verify a directory>
 23509                                  ;----------------------------------------------------------------------------
 23510                                  ;
 23511                                  ; Procedure Name : DOS_ChDir
 23512                                  ;
 23513                                  ; Inputs:
 23514                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 23515                                  ;		terminated)
 23516                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 23517                                  ;		( = -1 if current dir not involved, else
 23518                                  ;		 Points to first char after last "/" of current dir part)
 23519                                  ;	[THISCDS] Points to CDS being used May not be NUL
 23520                                  ; Function:
 23521                                  ;	Validate the path for potential new current directory
 23522                                  ; Returns:
 23523                                  ;	NOTE:
 23524                                  ;	    [SATTRIB] is modified by this call
 23525                                  ;	Carry Clear
 23526                                  ;	    CX is cluster number of the DIR, LOCAL CDS ONLY
 23527                                  ;		Caller must NOT set ID fields on a NET CDS.
 23528                                  ;	Carry Set
 23529                                  ;	    AX is error code
 23530                                  ;		error_path_not_found
 23531                                  ;			Bad path
 23532                                  ;		error_access_denied
 23533                                  ;			device or file name
 23534                                  ; DS preserved, Others destroyed
 23535                                  ;----------------------------------------------------------------------------
 23536                                  
 23537                                  ;hkn; called from path.asm and dir2.asm. DS already set up.
 23538                                  
 23539                                  ; 18/05/2019 - Retro DOS v4.0
 23540                                  ; DOSCODE:70DAh (MSDOS 6.21, MSDOS.SYS)
 23541                                  
 23542                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23543                                  ; DOSCODE:70C6h (MSDOS 5.0, MSDOS.SYS)
 23544                                  
 23545                                  ; 04/02/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 23546                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:7A23h
 23547                                  
 23548                                  ; (Windows ME IO.SYS - BIOSCODE:7839h)
 23549                                  ; (MSDOS 6.22 MSDOS.SYS - DOSCODE:70DAh)
 23550                                  
 23551                                  DOS_CHDIR:
 23552 00003A58 E8E6DD                  	call	TestNet
 23553 00003A5B 7306                    	JNC	short LOCAL_CHDIR
 23554                                  
 23555                                  ;IF NOT Installed
 23556                                  ;	transfer NET_CHDIR
 23557                                  ;ELSE
 23558                                  	;mov	ax,1105h
 23559 00003A5D B80511                  	MOV	AX,(MultNET<<8)|5
 23560 00003A60 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CHDIR
 23561                                  			; SS = DOS CS
 23562                                  			; SDA first filename pointer -> fully-qualified directory name
 23563                                  			; SDA CDS pointer -> current directory
 23564                                  			; Return: CF set on error, AX = DOS error code
 23565                                  			; CF clear if successful
 23566 00003A62 C3                      	retn
 23567                                  ;ENDIF
 23568                                  
 23569                                  LOCAL_CHDIR:
 23570 00003A63 E89DDE                  	call	ECritDisk
 23571                                  	; MSDOS 6.0
 23572                                  	;;test	word [es:di+43h],2000h
 23573                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice ;PTM.
 23574                                  	; 17/12/2022
 23575                                  	;test	byte [es:di+44h],20h
 23576 00003A66 26F6454420              	test	byte [ES:DI+curdir.flags+1],(curdir_splice>>8) ;PTM.
 23577 00003A6B 740C                    	JZ	short nojoin		   ;PTM.
 23578                                  	;mov	word [es:di+49h], 0FFFFh
 23579 00003A6D 26C74549FFFF            	MOV	word [ES:DI+curdir.ID],0FFFFH ;PTM.
 23580                                  	;;;
 23581                                  	; 04/02/2024 (PCDOS 7.1 IBMDOS.COM)
 23582                                  	;mov	word [es:di+4Bh], 0FFFFh
 23583 00003A73 26C7454BFFFF            	mov	word [es:di+curdir.ID+2],0FFFFh
 23584                                  	;;;
 23585                                  nojoin:
 23586                                  	; MSDOS 3.3 & MSDOS 6.0
 23587 00003A79 C606[4C03]00            	MOV	byte [NoSetDir],0 ; FALSE
 23588                                  	;mov	byte [SATTRIB],16h
 23589 00003A7E C606[6D05]16            	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
 23590                                  				; Dir calls can find these
 23591                                  ; DOS 3.3  6/24/86 FastOpen
 23592 00003A83 800E[6D12]01            	OR	byte [FastOpenFlg],FastOpen_Set	; set fastopen flag
 23593 00003A88 E8740E                  	call	GETPATH
 23594                                  
 23595                                  	; 04/02/2024
 23596                                  	;PUSHF						;AN000;
 23597 00003A8B 9F                      	lahf						
 23598 00003A8C 8026[6D12]80            	AND	byte [FastOpenFlg],Fast_yes ; clear it all ;AC000;
 23599                                  	;POPF						;AN000;
 23600 00003A91 9E                      	sahf
 23601                                  
 23602                                  ; DOS 3.3  6/24/86 FastOpen
 23603                                  
 23604                                  	; MSDOS 3.3
 23605                                  	;mov	byte [FastOpenFlg],0
 23606                                  	
 23607                                  	;mov	ax,3
 23608 00003A92 B80300                  	MOV	AX,error_path_not_found
 23609 00003A95 7207                    	JC	short ChDirDone
 23610 00003A97 753A                    	JNZ	short NOTDIRPATH	; Path not a DIR
 23611 00003A99 8B0E[C205]              	MOV	CX,[DIRSTART]		; Get cluster number
 23612 00003A9D F8                      	CLC
 23613                                  ChDirDone:
 23614                                  	;call	LCritDisk
 23615                                  	;retn
 23616                                  	; 18/12/2022
 23617 00003A9E E98FDE                  	jmp	LCritDisk
 23618                                  
 23619                                  ;BREAK <DOS_RmDir -- Remove a directory>
 23620                                  ;----------------------------------------------------------------------------
 23621                                  ;
 23622                                  ; Procedure Name : DOS_RmDir
 23623                                  ;
 23624                                  ; Inputs:
 23625                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 23626                                  ;		terminated)
 23627                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 23628                                  ;		( = -1 if current dir not involved, else
 23629                                  ;		 Points to first char after last "/" of current dir part)
 23630                                  ;	[THISCDS] Points to CDS being used
 23631                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 23632                                  ; Function:
 23633                                  ;	Remove a directory
 23634                                  ;	NOTE: Attempt to remove current directory must be detected by caller
 23635                                  ; Returns:
 23636                                  ;	NOTE:
 23637                                  ;	    [SATTRIB] is modified by this call
 23638                                  ;	Carry Clear
 23639                                  ;		No error
 23640                                  ;	Carry Set
 23641                                  ;	    AX is error code
 23642                                  ;		error_path_not_found
 23643                                  ;			Bad path (not in curr dir part if present)
 23644                                  ;		error_bad_curr_dir
 23645                                  ;			Bad path in current directory part of path
 23646                                  ;		error_access_denied
 23647                                  ;			device or file name, root directory
 23648                                  ;			Bad directory ('.' '..' messed up)
 23649                                  ; DS preserved, Others destroyed
 23650                                  ;----------------------------------------------------------------------------
 23651                                  
 23652                                  ;hkn; called from path.asm. DS already set up.
 23653                                  
 23654                                  ; 18/05/2019 - Retro DOS v4.0
 23655                                  ; DOSCODE:711Fh (MSDOS 6.21, MSDOS.SYS)
 23656                                  
 23657                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23658                                  ; DOSCODE:710Bh (MSDOS 5.0, MSDOS.SYS)
 23659                                  
 23660                                  DOS_RMDIR:
 23661 00003AA1 E89DDD                  	call	TestNet
 23662 00003AA4 7306                    	JNC	short LOCAL_RMDIR
 23663                                  
 23664                                  ;IF NOT Installed
 23665                                  ;	transfer NET_RMDIR
 23666                                  ;ELSE
 23667                                  	;mov	ax,1101h
 23668 00003AA6 B80111                  	MOV	AX,(MultNET<<8)|1
 23669 00003AA9 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
 23670                                  			; SS = DOS CS
 23671                                  			; SDA first filename pointer -> fully-qualified directory name
 23672                                  			; SDA CDS pointer -> current directory
 23673                                  			; Return: CF set on error, AX = DOS error code
 23674                                  			; CF clear if successful
 23675 00003AAB C3                      	retn
 23676                                  ;ENDIF
 23677                                  
 23678                                  LOCAL_RMDIR:
 23679 00003AAC E854DE                  	call	ECritDisk
 23680 00003AAF C606[4C03]00            	MOV	byte [NoSetDir],0
 23681                                  	;mov	byte [SATTRIB],16h
 23682 00003AB4 C606[6D05]16            	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
 23683                                  					; Dir calls can find these
 23684 00003AB9 E8430E                  	call	GETPATH
 23685 00003ABC 720C                    	JC	short NOPATH		; Path not found
 23686 00003ABE 7513                    	JNZ	short NOTDIRPATH	; Path not a DIR
 23687 00003AC0 8B3E[C205]              	MOV	DI,[DIRSTART]
 23688 00003AC4 09FF                    	OR	DI,DI			; Root ?
 23689 00003AC6 750E                    	JNZ	short rmdir_get_buf	; No
 23690 00003AC8 EB09                    	JMP	SHORT NOTDIRPATH
 23691                                  
 23692                                  NOPATH:
 23693                                  	;mov	ax,3
 23694 00003ACA B80300                  	MOV	AX,error_path_not_found
 23695 00003ACD E981FE                  	JMP	_BadRet
 23696                                  
 23697                                  NOTDIRPATHPOP:
 23698 00003AD0 58                      	POP	AX  ; MSDOS 6.0		;F.C. >32mb
 23699 00003AD1 58                      	POP	AX
 23700                                  NOTDIRPATHPOP2:
 23701 00003AD2 58                      	POP	AX
 23702                                  NOTDIRPATH:
 23703 00003AD3 E978FE                  	JMP	NODEACCERRJ
 23704                                  
 23705                                  rmdir_get_buf:
 23706 00003AD6 C53E[E205]              	LDS	DI,[CURBUF]
 23707 00003ADA 29FB                    	SUB	BX,DI		; Compute true offset
 23708 00003ADC 53                      	PUSH	BX		; Save entry pointer
 23709                                  	
 23710                                  	; MSDOS 6.0
 23711                                  	;push	word [di+8]
 23712 00003ADD FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2] ;F.C. >32mb
 23713                                  	
 23714                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23715                                  	;push	word [di+6]
 23716 00003AE0 FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Save sector number
 23717                                  
 23718                                  ;hkn; SS is DOSDATA
 23719                                  	;context DS
 23720 00003AE3 16                      	push	ss
 23721 00003AE4 1F                      	pop	ds
 23722                                  	;context ES
 23723 00003AE5 16                      	push	ss
 23724 00003AE6 07                      	pop	es
 23725                                  
 23726                                  ;hkn; NAME1 is in DOSDATA
 23727 00003AE7 BF[4B05]                	MOV	DI,NAME1
 23728 00003AEA B03F                    	MOV	AL,'?'
 23729 00003AEC B90B00                  	MOV	CX,11
 23730 00003AEF F3AA                    	REP	STOSB
 23731 00003AF1 30C0                    	XOR	AL,AL
 23732 00003AF3 AA                      	STOSB				; Nul terminate it
 23733 00003AF4 E89B10                  	call	STARTSRCH		; Set search
 23734 00003AF7 E8310C                  	call	GETENTRY		; Get start of directory
 23735 00003AFA 72D4                    	JC	short NOTDIRPATHPOP	; Screw up
 23736 00003AFC 8E1E[E405]              	MOV	DS,[CURBUF+2]
 23737 00003B00 89DE                    	MOV	SI,BX
 23738 00003B02 AD                      	LODSW
 23739                                  	;CMP	AX,(' ' SHL 8) OR '.'   ; First entry '.'?
 23740 00003B03 3D2E20                  	cmp	ax,202Eh ; ". "
 23741 00003B06 75C8                    	JNZ	short NOTDIRPATHPOP	; Nope
 23742                                  	;add	si,30
 23743 00003B08 83C61E                  	ADD	SI,dir_entry.size-2 ; Next entry
 23744 00003B0B AD                      	LODSW
 23745                                  	;CMP	AX,('.' SHL 8) OR '.'   ; Second entry '..'?
 23746                                  	;cmp	ax, '..'
 23747 00003B0C 3D2E2E                  	cmp	ax,2E2Eh
 23748 00003B0F 75BF                    	JNZ	short NOTDIRPATHPOP	; Nope
 23749                                  
 23750                                  ;hkn; SS is DOSDATA
 23751                                  	;context DS
 23752 00003B11 16                      	push	ss
 23753 00003B12 1F                      	pop	ds
 23754 00003B13 C706[4803]0200          	MOV	word [LASTENT],2	; Skip . and ..
 23755 00003B19 E80F0C                  	call	GETENTRY		; Get next entry
 23756 00003B1C 72B2                    	JC	short NOTDIRPATHPOP	; Screw up
 23757                                  	;mov	byte [ATTRIB],16h
 23758 00003B1E C606[6B05]16            	MOV	byte [ATTRIB],attr_directory+attr_hidden+attr_system
 23759 00003B23 E80D0B                  	call	SRCH			; Do a search
 23760 00003B26 73A8                    	JNC	short NOTDIRPATHPOP	; Found another entry!
 23761 00003B28 803E[4A03]00            	CMP	byte [FAILERR],0
 23762 00003B2D 75A1                    	JNZ	short NOTDIRPATHPOP	; Failure of search due to I 24 FAIL
 23763 00003B2F C42E[8A05]              	LES	BP,[THISDPB]
 23764 00003B33 8B1E[C205]              	MOV	BX,[DIRSTART]
 23765 00003B37 E8651D                  	call	RELEASE 		; Release data in sub dir
 23766 00003B3A 7294                    	JC	short NOTDIRPATHPOP	; Screw up
 23767 00003B3C 5A                      	POP	DX			; Sector # of entry
 23768 00003B3D 8F06[0706]              	POP	word [HIGH_SECTOR] ; MSDOS 6.0	; F.C. >32mb
 23769                                  	; 22/09/2023
 23770                                  	;;mov	byte [ALLOWED],18h
 23771                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 23772                                  	;XOR	AL,AL ; *		; Pre read
 23773                                  	;call	GETBUFFR		; Get sector back
 23774 00003B41 E81228                  	call	GETBUFFER ; *		; Pre Read
 23775 00003B44 728C                    	JC	short NOTDIRPATHPOP2	; Screw up
 23776 00003B46 C53E[E205]              	LDS	DI,[CURBUF]
 23777                                  	;or	byte [di+5],4
 23778 00003B4A 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 23779 00003B4E 5B                      	POP	BX			; Pointer to start of entry
 23780 00003B4F 01FB                    	ADD	BX,DI			; Corrected
 23781 00003B51 C607E5                  	MOV	BYTE [BX],0E5H		; Free the entry
 23782                                  
 23783                                  ;DOS 3.3 FastOpen  6/16/86  F.C.
 23784 00003B54 1E                      	PUSH	DS
 23785                                  
 23786                                  ;hkn; SS is DOSDATA
 23787                                  	;context DS
 23788 00003B55 16                      	push	ss
 23789 00003B56 1F                      	pop	ds
 23790                                  
 23791                                  	; MSDOS 6.0
 23792 00003B57 E80AF2                  	call	FastOpen_Delete 	; call fastopen to delete an entry
 23793                                  
 23794                                  ;	; MSDOS 3.3
 23795                                  ;_FastOpen_Delete:
 23796                                  ;	push	ax
 23797                                  ;	mov	si,[WFP_START]
 23798                                  ;	mov	bx,FastTable
 23799                                  ;	;mov	al,3  ; FONC_delete
 23800                                  ;	mov	al,FONC_delete
 23801                                  ;	call	far [BX+2]  ; FastTable+2
 23802                                  ;	pop	ax
 23803                                  
 23804 00003B5A 1F                      	POP	DS
 23805                                  ;DOS 3.3 FastOpen  6/16/86  F.C.
 23806                                  
 23807 00003B5B E9B1FE                  	JMP	DIRUP			; In MKDIR, dirty buffer and flush
 23808                                  
 23809                                  ;============================================================================
 23810                                  ; DISK.ASM, MSDOS 6.0, 1991
 23811                                  ;============================================================================
 23812                                  ; 23/07/2018 - Retro DOS v3.0 
 23813                                  ; 04/05/2019 - Retro DOS v4.0
 23814                                  
 23815                                  ;	TITLE	DISK - Disk utility routines
 23816                                  ;	NAME	Disk
 23817                                  
 23818                                  ;**	Low level Read and write routines for local SFT I/O on files and devs
 23819                                  ;
 23820                                  ;	SWAPCON
 23821                                  ;	SWAPBACK
 23822                                  ;	DOS_READ
 23823                                  ;	DOS_WRITE
 23824                                  ;	get_io_sft
 23825                                  ;	DirRead
 23826                                  ;	FIRSTCLUSTER
 23827                                  ;	SET_BUF_AS_DIR
 23828                                  ;	FATSecRd
 23829                                  ;	DREAD
 23830                                  ;	CHECK_WRITE_LOCK
 23831                                  ;	CHECK_READ_LOCK
 23832                                  ;
 23833                                  ;	Revision history:
 23834                                  ;
 23835                                  ;		A000   version 4.00  Jan. 1988
 23836                                  ;
 23837                                  ;----------------------------------------------------------------------------
 23838                                  ;
 23839                                  ; M065 : B#5276. On raw read/write of a block of characters if a critical
 23840                                  ;		error happens, DOS retries the entire block assuming that
 23841                                  ;		zero characters were transferred. Modified the code to take
 23842                                  ;		into account the number of characters transfered before
 23843                                  ;		retrying the operation.
 23844                                  ;
 23845                                  ;----------------------------------------------------------------------------
 23846                                  ;
 23847                                  
 23848                                  ;Installed = TRUE
 23849                                  
 23850                                  ;Break	<SwapCon, Swap Back - Old-style I/O to files>
 23851                                  
 23852                                  ; **** Drivers for file input from devices ****
 23853                                  ;----------------------------------------------------------------------------
 23854                                  ;   Indicate that there is no more I/O occurring through another SFT outside
 23855                                  ;   of handles 0 and 1
 23856                                  ;
 23857                                  ;   Inputs:	DS is DOSDATA
 23858                                  ;   Outputs:	CONSWAP is set to false.
 23859                                  ;   Registers modified: none
 23860                                  ;----------------------------------------------------------------------------
 23861                                  
 23862                                  ; IBMDOS.COM (MSDOS 3.3) - Offset 3CF8h
 23863                                  
 23864                                  ; DOSCODE:71E3h (MSDOS 6.21, MSDOS.SYS)
 23865                                  ; 04/05/2019 - Retro DOS v4.0
 23866                                  
 23867                                  ; DOSCODE:71CFh (MSDOS 5.0, MSDOS.SYS)
 23868                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23869                                  
 23870                                  SWAPBACK:
 23871 00003B5E C606[5703]00            	MOV	BYTE [CONSWAP],0	; signal no conswaps
 23872 00003B63 C3                      	retn
 23873                                  
 23874                                  ;----------------------------------------------------------------------------
 23875                                  ;
 23876                                  ; Procedure Name : SWAPCON
 23877                                  ;
 23878                                  ;   Copy ThisSFT to CONSFT for use by the 1-12 primitives.
 23879                                  ;
 23880                                  ;   Inputs:	ThisSFT as the sft of the desired file
 23881                                  ;		DS is DOSDATA
 23882                                  ;   Outputs:	CONSWAP is set.  CONSFT = ThisSFT.
 23883                                  ;   Registers modified: none
 23884                                  ;--------------------------------------------------------------------------
 23885                                  
 23886                                  SWAPCON:
 23887                                  	; MSDOS 3.3
 23888                                  	;push	es
 23889                                  	;push	di
 23890                                  	;mov	byte [CONSWAP],1
 23891                                  	;les	di,[THISSFT]
 23892                                  	;mov	word [CONSFT],di
 23893                                  	;mov	word [CONSFT+2],es
 23894                                  	;pop	di
 23895                                  	;pop	es
 23896                                  	;retn
 23897                                  
 23898                                  	; MSDOS 6.0
 23899 00003B64 C606[5703]01            	mov	byte [CONSWAP],1	; ConSwap = TRUE
 23900 00003B69 50                      	push	ax
 23901 00003B6A A1[9E05]                	mov	ax,[THISSFT]
 23902 00003B6D A3[E605]                	mov	[CONSFT],ax
 23903 00003B70 A1[A005]                	mov	ax,[THISSFT+2]
 23904 00003B73 A3[E805]                	mov	[CONSFT+2],ax
 23905 00003B76 58                      	pop	ax
 23906 00003B77 C3                      	retn
 23907                                  
 23908                                  ; DOSCODE:71FDh (MSDOS 6.21, MSDOS.SYS)
 23909                                  ; 04/05/2019 - Retro DOS v4.0
 23910                                  
 23911                                  ;Break	<DOS_READ -- MAIN READ ROUTINE AND DEVICE IN ROUTINES>
 23912                                  ;-----------------------------------------------------------------------------
 23913                                  ;
 23914                                  ; Inputs:
 23915                                  ;	ThisSFT set to the SFT for the file being used
 23916                                  ;	[DMAADD] contains transfer address
 23917                                  ;	CX = No. of bytes to read
 23918                                  ;	DS = DOSDATA
 23919                                  ; Function:
 23920                                  ;	Perform read operation
 23921                                  ; Outputs:
 23922                                  ;    Carry clear
 23923                                  ;	SFT Position and cluster pointers updated
 23924                                  ;	CX = No. of bytes read
 23925                                  ;	ES:DI point to SFT
 23926                                  ;    Carry set
 23927                                  ;	AX is error code
 23928                                  ;	CX = 0
 23929                                  ;	ES:DI point to SFT
 23930                                  ; DS preserved, all other registers destroyed
 23931                                  ;
 23932                                  ;-----------------------------------------------------------------------------
 23933                                  
 23934                                  ;hkn; called from fcbio.asm, handle.asm and dev.asm. DS is be set up.
 23935                                  
 23936                                  ; DOSCODE:71E9h (MSDOS 5.0, MSDOS.SYS)
 23937                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23938                                  
 23939                                  DOS_READ:
 23940 00003B78 C43E[9E05]              	LES	DI,[THISSFT]
 23941                                  
 23942                                  ; Verify that the sft has been opened in a mode that allows reading.
 23943                                  
 23944                                  	;mov	al,[es:di+2]
 23945 00003B7C 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 23946                                  	;and	al,0Fh
 23947 00003B80 240F                    	AND	AL,access_mask
 23948                                  	;cmp	al,1
 23949 00003B82 3C01                    	CMP	AL,open_for_write
 23950 00003B84 7503                    	JNE	short READ_NO_MODE	; Is read or both
 23951 00003B86 E90306                  	jmp	SET_ACC_ERR
 23952                                  
 23953                                  READ_NO_MODE:
 23954 00003B89 E8E104                  	call	SETUP
 23955 00003B8C E30B                    	JCXZ	NoIORet 		; no bytes to read - fast return
 23956 00003B8E E8C9DC                  	call	IsSFTNet
 23957 00003B91 7408                    	JZ	short LOCAL_READ
 23958                                  
 23959                                  ;IF NOT Installed
 23960                                  ;	transfer NET_READ
 23961                                  ;ELSE
 23962                                  	;mov	ax,1108h
 23963 00003B93 B80811                  	MOV	AX,(MultNET<<8)|8
 23964 00003B96 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - READ FROM REMOTE FILE
 23965                                  			; ES:DI -> SFT
 23966                                  			; SFT DPB field -> DPB of drive containing file
 23967                                  			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
 23968                                  			; Return: CF set on error, CX = bytes read
 23969 00003B98 C3                      	retn
 23970                                  ;ENDIF
 23971                                  
 23972                                  ; The user ended up requesting 0 bytes of input. We do nothing for this case
 23973                                  ; except return immediately.
 23974                                  
 23975                                  NoIORet:
 23976 00003B99 F8                      	CLC
 23977 00003B9A C3                      	retn
 23978                                  
 23979                                  LOCAL_READ:
 23980                                  	;test	word [es:di+5],80h
 23981                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device  ; Check for named device I/O
 23982 00003B9B 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; 02/06/2019
 23983 00003BA0 750E                    	JNZ	short READDEV
 23984                                  
 23985                                  	;mov	byte [EXTERR_LOCUS],2
 23986 00003BA2 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 23987 00003BA7 E859DD                  	call	ECritDisk
 23988 00003BAA E89B05                  	call	DISKREAD
 23989                                  
 23990                                  critexit:
 23991                                  	;call	LCritDisk
 23992                                  	;retn
 23993                                  	; 16/12/2022
 23994 00003BAD E980DD                  	jmp	LCritDisk
 23995                                  
 23996                                  ; We are reading from a device. Examine the status of the device to see if we
 23997                                  ; can short-circuit the I/O. If the device in the EOF state or if it is the
 23998                                  ; null device, we can safely indicate no transfer.
 23999                                  
 24000                                  READDEV:
 24001                                  	;mov	byte [EXTERR_LOCUS],4
 24002 00003BB0 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 24003                                  	;mov	bl,[es:di+5]
 24004 00003BB5 268A5D05                	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
 24005 00003BB9 C43E[2C03]              	LES	DI,[DMAADD]
 24006                                  	;test	bl,40h
 24007 00003BBD F6C340                  	test	BL,devid_device_EOF	; End of file?
 24008 00003BC0 7407                    	JZ	short ENDRDDEVJ3
 24009                                  	;test	bl,4
 24010 00003BC2 F6C304                  	test	BL,devid_device_null	; NUL device?
 24011 00003BC5 7405                    	JZ	short TESTRAW 		; NO
 24012 00003BC7 30C0                    	XOR	AL,AL			; Indicate EOF by setting zero
 24013                                  ENDRDDEVJ3:
 24014                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 24015                                  	;JMP	short ENDRDDEVJ2
 24016                                  	; 16/12/2022
 24017 00003BC9 E96701                  	jmp	ENDRDDEV ; 04/05/2019
 24018                                  
 24019                                  ; We need to hit the device. Figure out if we do a raw read or we do the
 24020                                  ; bizarre std_con_string_input.
 24021                                  
 24022                                  TESTRAW:
 24023                                  	;test	bl,20h
 24024 00003BCC F6C320                  	test	BL,devid_device_raw	; Raw mode?
 24025 00003BCF 7508                    	JNZ	short DVRDRAW 		; Yes, let the device do all local editing
 24026                                  	;test	bl,1
 24027 00003BD1 F6C301                  	test	BL,devid_device_con_in	; Is it console device?
 24028 00003BD4 7461                    	JZ	short NOTRDCON
 24029 00003BD6 E98F01                  	JMP	READCON
 24030                                  
 24031                                  DVRDRAW:
 24032 00003BD9 06                      	PUSH	ES
 24033 00003BDA 1F                      	POP	DS			; Xaddr to DS:DI
 24034                                  
 24035                                  	; 04/05/2019 - Retro DOS v4.0
 24036                                  
 24037                                  	; MSDOS 6.0
 24038                                  ;SR;
 24039                                  ;Check for win386 presence -- if present, do polled read of characters
 24040                                  
 24041 00003BDB 36F606[A110]01          	test	byte [ss:IsWin386],1 ; 19/05/2019
 24042 00003BE1 7408                    	jz	short ReadRawRetry	;not present
 24043 00003BE3 F6C301                  	test	bl,devid_device_con_in	;is it console device
 24044 00003BE6 7403                    	jz	short ReadRawRetry	;no, do normal read
 24045 00003BE8 E9BA00                  	jmp	do_polling		;yes, do win386 polling loop
 24046                                  
 24047                                  ReadRawRetry:
 24048 00003BEB 89FB                    	MOV	BX,DI			; DS:BX transfer addr
 24049 00003BED 31C0                    	XOR	AX,AX			; Media Byte, unit = 0
 24050 00003BEF 89C2                    	MOV	DX,AX			; Start at 0
 24051 00003BF1 E8D214                  	call	SETREAD
 24052 00003BF4 1E                      	PUSH	DS			; Save Seg part of Xaddr
 24053                                  
 24054                                  ;hkn; SS override
 24055 00003BF5 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 24056 00003BFA E85014                  	call	DEVIOCALL
 24057 00003BFD 89FA                    	MOV	DX,DI			; DS:DX is preserved by INT 24
 24058 00003BFF B486                    	MOV	AH,86H			; Read error
 24059                                  
 24060                                  ;hkn; SS override
 24061 00003C01 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 24062                                  	; MSDOS 3.3
 24063                                  	;test	di,8000h
 24064                                  	;jz	short CRDROK
 24065                                  	; MSDOS 6.0
 24066 00003C06 09FF                    	or	di,di
 24067 00003C08 7923                    	jns	short CRDROK		; no errors
 24068                                  	; MSDOS 3.3 (& MSDOS 6.0)
 24069 00003C0A E8A520                  	call	CHARHARD
 24070 00003C0D 89D7                    	MOV	DI,DX			; DS:DI is Xaddr
 24071                                  
 24072                                  	; 04/05/2019
 24073                                  
 24074                                  	; MSDOS 6.0
 24075 00003C0F 36033E[6C03]            	add	di,[ss:CALLSCNT]	; update ptr and count to reflect the	M065
 24076 00003C14 362B0E[6C03]            	sub	cx,[ss:CALLSCNT]	; number of chars xferred		M065
 24077                                  
 24078                                  	; MSDOS 3.3 (& MSDOS 6.0)
 24079 00003C19 08C0                    	OR	AL,AL
 24080 00003C1B 7410                    	JZ	short CRDROK		; Ignore
 24081 00003C1D 3C03                    	CMP	AL,3
 24082 00003C1F 7403                    	JZ	short CRDFERR 		; fail.
 24083 00003C21 1F                      	POP	DS			; Recover saved seg part of Xaddr
 24084 00003C22 EBC7                    	JMP	short ReadRawRetry	; Retry
 24085                                  
 24086                                  ; We have encountered a device-driver error. We have informed the user of it
 24087                                  ; and he has said for us to fail the system call.
 24088                                  
 24089                                  CRDFERR:
 24090 00003C24 5F                      	POP	DI			; Clean stack
 24091                                  DEVIOFERR:
 24092                                  
 24093                                  ;hkn; SS override
 24094 00003C25 36C43E[9E05]            	LES	DI,[SS:THISSFT]
 24095 00003C2A E95D05                  	jmp	SET_ACC_ERR_DS
 24096                                  
 24097                                  CRDROK:
 24098 00003C2D 5F                      	POP	DI			; Chuck saved seg of Xaddr
 24099 00003C2E 89D7                    	MOV	DI,DX
 24100                                  
 24101                                  ;hkn; SS override
 24102 00003C30 36033E[6C03]            	ADD	DI,[ss:CALLSCNT]	; Amount transferred
 24103                                  	;JMP	SHORT ENDRDDEVJ3
 24104                                  	; 16/12/2022
 24105 00003C35 EB6B                    	jmp	short ENDRDDEVJ2
 24106                                  
 24107                                  ; We are going to do a cooked read on some character device. There is a
 24108                                  ; problem here, what does the data look like? Is it a terminal device, line
 24109                                  ; CR line CR line CR, or is it file data, line CR LF line CR LF? Does it have
 24110                                  ; a ^Z at the end which is data, or is the ^Z not data?  In any event we're
 24111                                  ; going to do this: Read in pieces up to CR (CRs included in data) or ^z (^z
 24112                                  ; included in data). this "simulates" the way con works in cooked mode
 24113                                  ; reading one line at a time. With file data, however, the lines will look
 24114                                  ; like, LF line CR. This is a little weird.
 24115                                  
 24116                                  NOTRDCON:
 24117 00003C37 8CC0                    	MOV	AX,ES
 24118 00003C39 8ED8                    	MOV	DS,AX
 24119 00003C3B 89FB                    	MOV	BX,DI
 24120 00003C3D 31D2                    	XOR	DX,DX
 24121 00003C3F 89D0                    	MOV	AX,DX
 24122 00003C41 51                      	PUSH	CX
 24123 00003C42 B90100                  	MOV	CX,1
 24124 00003C45 E87E14                  	call	SETREAD
 24125 00003C48 59                      	POP	CX
 24126                                  
 24127                                  ;hkn; SS override
 24128 00003C49 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 24129                                  	;lds	si,[si+7]
 24130 00003C4E C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 24131                                  DVRDLP:
 24132 00003C51 E83F1E                  	call	DSKSTATCHK
 24133 00003C54 E8F913                  	call	DEVIOCALL2
 24134 00003C57 57                      	PUSH	DI		; Save "count" done
 24135 00003C58 B486                    	MOV	AH,86H
 24136                                  
 24137                                  ;hkn; SS override
 24138 00003C5A 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 24139                                  	
 24140                                  	; MSDOS 3.3
 24141                                  	;test	di,8000h
 24142                                  	;jz	short CRDOK
 24143                                  	; MSDOS 6.0
 24144 00003C5F 09FF                    	or	di,di
 24145 00003C61 7917                    	jns	short CRDOK
 24146                                  	
 24147 00003C63 E84C20                  	call	CHARHARD
 24148 00003C66 5F                      	POP	DI
 24149                                  
 24150                                  ;hkn; SS override
 24151 00003C67 36C706[6C03]0100        	MOV	word [SS:CALLSCNT],1
 24152 00003C6E 3C01                    	CMP	AL,1
 24153 00003C70 74DF                    	JZ	short DVRDLP		;Retry
 24154 00003C72 3C03                    	CMP	AL,3
 24155 00003C74 74AF                    	JZ	short DEVIOFERR		; FAIL
 24156 00003C76 30C0                    	XOR	AL,AL			; Ignore, Pick some random character
 24157 00003C78 EB12                    	JMP	SHORT DVRDIGN
 24158                                  
 24159                                  CRDOK:
 24160 00003C7A 5F                      	POP	DI
 24161                                  
 24162                                  ;hkn; SS override
 24163 00003C7B 36833E[6C03]01          	CMP	word [SS:CALLSCNT],1
 24164                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 24165 00003C81 751F                    	JNZ	short ENDRDDEVJ2
 24166                                  	; 16/12/2022
 24167                                  	;jnz	short ENDRDDEV ; 24/07/2019
 24168                                  
 24169 00003C83 1E                      	PUSH	DS
 24170                                  
 24171                                  ;hkn; SS override
 24172 00003C84 368E1E[6A03]            	MOV	DS,[SS:CALLXAD+2]
 24173 00003C89 8A05                    	MOV	AL,[DI]			; Get the character we just read
 24174 00003C8B 1F                      	POP	DS
 24175                                  DVRDIGN:
 24176                                  
 24177                                  ;hkn; SS override
 24178 00003C8C 36FF06[6803]            	INC	WORD [SS:CALLXAD]	; Next character
 24179 00003C91 36C706[5D03]0000        	MOV	word [SS:DEVCALL_REQSTAT],0
 24180 00003C98 47                      	INC	DI			; Next character
 24181 00003C99 3C1A                    	CMP	AL,1Ah			; ^Z?
 24182                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 24183 00003C9B 7405                    	JZ	short ENDRDDEVJ2	; Yes, done zero set (EOF)
 24184                                  	; 16/12/2022
 24185                                  	;jz	short ENDRDDEV ; 24/07/2019	
 24186 00003C9D 3C0D                    	CMP	AL,c_CR  ; 0Dh		; CR?
 24187 00003C9F E0B0                    	LOOPNZ	DVRDLP			; Loop if no, else done
 24188 00003CA1 40                      	INC	AX			; Resets zero flag so NOT EOF, unless
 24189                                  					;  AX=FFFF which is not likely
 24190                                  ENDRDDEVJ2:
 24191                                  	; 16/12/2022
 24192                                  	;JMP	short ENDRDDEV		; changed short to long for win386
 24193                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24194 00003CA2 E98E00                  	jmp	ENDRDDEV
 24195                                  
 24196                                  	; 04/05/2019
 24197                                  
 24198                                  	; MSDOS 6.0
 24199                                  ;SR;
 24200                                  ;Polling code for raw read on CON when WIN386 is present
 24201                                  ;
 24202                                  ;At this point -- ds:di is transfer address
 24203                                  ;		  cx is count
 24204                                  
 24205                                  do_polling:
 24206 00003CA5 89FB                    	mov	bx,di			;ds:bx is Xfer address
 24207 00003CA7 31C0                    	xor	ax,ax
 24208 00003CA9 89C2                    	mov	dx,ax
 24209 00003CAB E81814                  	call	SETREAD			;prepare device packet
 24210                                  
 24211                                  do_io:
 24212                                  ;Change read to a NON-DESTRUCTIVE READ, NO WAIT
 24213                                  
 24214 00003CAE 26C6470205              	mov	byte [es:bx+2],DEVRDND ; 5 ;Change command code
 24215 00003CB3 1E                      	push	ds
 24216 00003CB4 36C536[9E05]            	lds	si,[ss:THISSFT]		;get device header
 24217 00003CB9 E89113                  	call	DEVIOCALL		;call device driver
 24218 00003CBC 1F                      	pop	ds
 24219                                  	
 24220                                  	;test	word [es:bx+3],8000h
 24221                                  	; 16/12/2022
 24222                                  	;test	byte [es:bx+4],80h
 24223 00003CBD 26F6470480              	test	byte [es:bx+SRHEAD.REQSTAT+1],STERR>>8 
 24224                                  	;test	word [es:bx+SRHEAD.REQSTAT],STERR ;check if error
 24225 00003CC2 7413                    	jz	short check_busy	;no
 24226                                  
 24227 00003CC4 1E                      	push	ds
 24228 00003CC5 89FA                    	mov	dx,di
 24229                                  	;invoke charhard		;invoke int 24h handler
 24230 00003CC7 E8E81F                  	call	CHARHARD
 24231 00003CCA 89D7                    	mov	di,dx
 24232 00003CCC 08C0                    	or	al,al
 24233 00003CCE 745D                    	jz	short pop_done_read	;ignore by user, assume read done
 24234 00003CD0 3C03                    	cmp	al,3
 24235 00003CD2 7448                    	jz	short devrderr		;user asked to fail
 24236 00003CD4 1F                      	pop	ds
 24237 00003CD5 EBD7                    	jmp	short do_io		;user asked to retry
 24238                                  
 24239                                  check_busy:
 24240                                  	;test	word [es:bx+3],200h
 24241                                  	; 16/12/2022
 24242 00003CD7 26F6470402              	test	byte [es:bx+SRHEAD.REQSTAT+1],02h
 24243                                  	;test	word [es:bx+SRHEAD.REQSTAT],0200h ;see if busy bit set
 24244 00003CDC 7547                    	jnz	short no_char		;yes, no character available
 24245                                  
 24246                                  ;Character is available. Read in 1 character at a time until all characters
 24247                                  ;are read in or no character is available
 24248                                  
 24249 00003CDE 26C6470204              	mov	byte [es:bx+2],DEVRD ; 4 ;command code is READ now
 24250 00003CE3 26C747120100            	mov	word [es:bx+18],1	;change count to 1 character
 24251 00003CE9 1E                      	push	ds
 24252 00003CEA 36C536[9E05]            	lds	si,[ss:THISSFT]
 24253 00003CEF E85B13                  	call	DEVIOCALL
 24254                                  
 24255 00003CF2 89FA                    	mov	dx,di
 24256 00003CF4 B486                    	mov	ah,86h
 24257                                  	;mov	di,[es:bx+3]
 24258 00003CF6 268B7F03                	mov	di,[es:bx+SRHEAD.REQSTAT] ;get returned status
 24259 00003CFA F7C70080                	test	di,STERR ; 8000h	;was there an error during read?
 24260 00003CFE 7410                    	jz	short next_char		;no,read next character
 24261                                  
 24262                                  	;invoke	charhard		;invoke int 24h handler
 24263 00003D00 E8AF1F                  	call	CHARHARD
 24264 00003D03 89D7                    	mov	di,dx			;restore di
 24265 00003D05 08C0                    	or	al,al			;
 24266 00003D07 7424                    	jz	short pop_done_read	;ignore by user,assume read is done
 24267 00003D09 3C03                    	cmp	al,3
 24268 00003D0B 740F                    	jz	short devrderr		;user issued a 'fail',indicate error
 24269 00003D0D 1F                      	pop	ds
 24270 00003D0E EB9E                    	jmp	short do_io		;user issued a retry
 24271                                  
 24272                                  next_char:
 24273 00003D10 1F                      	pop	ds
 24274 00003D11 89D7                    	mov	di,dx
 24275 00003D13 49                      	dec	cx			;decrement count
 24276 00003D14 E318                    	jcxz	done_read		;all characters read in
 24277 00003D16 26FF470E                	inc	word [es:bx+14]		;update transfer address
 24278 00003D1A EB92                    	jmp	short do_io			;read next character in
 24279                                  
 24280                                  devrderr:
 24281 00003D1C 5F                      	pop	di			;discard segment address
 24282 00003D1D 36C43E[9E05]            	les	di,[ss:THISSFT]
 24283                                  	;transfer SET_ACC_ERR_DS	;indicate error
 24284 00003D22 E96504                  	jmp     SET_ACC_ERR_DS
 24285                                  
 24286                                  no_char:
 24287                                  ;Since no character is available, we let win386 switch the VM out
 24288                                  
 24289 00003D25 50                      	push	ax
 24290 00003D26 B484                    	mov	ah,84h	; Microsoft Networks - KEYBOARD BUSY LOOP
 24291 00003D28 CD2A                    	int	2Ah			;indicate idle to WIN386
 24292                                  
 24293                                  ;When control returns from WIN386, we continue the raw read
 24294                                  
 24295 00003D2A 58                      	pop	ax
 24296 00003D2B EB81                    	jmp	do_io
 24297                                  
 24298                                  pop_done_read:
 24299 00003D2D 1F                      	pop	ds
 24300                                  done_read:
 24301 00003D2E 36033E[6C03]            	add	di,[ss:CALLSCNT] ; 19/05/2019
 24302                                  
 24303                                  	; 16/12/2022
 24304                                  
 24305                                  	;jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit
 24306                                  	;jmp	ENDRDDEV ; 04/05/2019
 24307                                  
 24308                                  	; 04/05/2019 - Retro DOS v4.0
 24309                                  ENDRDDEV:
 24310 00003D33 16                      	push	ss
 24311 00003D34 1F                      	pop	ds
 24312 00003D35 EB1F                    	jmp	short endrddev1
 24313                                  
 24314                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24315                                  	;jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit
 24316                                  
 24317                                  TRANBUF:
 24318 00003D37 AC                      	LODSB
 24319 00003D38 AA                      	STOSB
 24320 00003D39 3C0D                    	CMP	AL,c_CR ; 0Dh	; Check for carriage return
 24321 00003D3B 7503                    	JNZ	short NORMCH
 24322 00003D3D C6040A                  	MOV	BYTE [SI],c_LF ; 0Ah
 24323                                  NORMCH:
 24324 00003D40 3C0A                    	CMP	AL,c_LF ; 0Ah
 24325 00003D42 E0F3                    	LOOPNZ	TRANBUF
 24326 00003D44 7507                    	JNZ	short ENDRDCON
 24327 00003D46 31F6                    	XOR	SI,SI		; Cause a new buffer to be read
 24328 00003D48 E802DF                  	call	OUTT		; Transmit linefeed
 24329 00003D4B 0C01                    	OR	AL,1		; Clear zero flag--not end of file
 24330                                  ENDRDCON:
 24331                                  ;hkn; SS is DOSDATA
 24332 00003D4D 16                      	push	ss
 24333 00003D4E 1F                      	pop	ds
 24334 00003D4F E80CFE                  	CALL	SWAPBACK
 24335 00003D52 8936[2200]              	MOV	[CONTPOS],SI
 24336                                  
 24337                                  	; 16/12/2022
 24338                                  ;ENDRDDEV:
 24339                                  ;;hkn; SS is DOSDATA
 24340                                  ;	push	ss
 24341                                  ;	pop	ds
 24342                                  endrddev1:	; 04/05/2019
 24343 00003D56 893E[B805]              	MOV	[NEXTADD],DI
 24344 00003D5A 7509                    	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
 24345 00003D5C C43E[9E05]              	LES	DI,[THISSFT]
 24346                                  	;and	byte [es:di+5],0BFh
 24347 00003D60 26806505BF              	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF 
 24348                                  				; Mark as no more data available
 24349                                  SETSFTC:
 24350                                  	; 31/07/2019
 24351                                  	;call	SETSFT
 24352                                  	;retn
 24353 00003D65 E9B604                  	jmp	SETSFT
 24354                                  
 24355                                  ; 16/12/2022
 24356                                  %if 0
 24357                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24358                                  ENDRDDEV:
 24359                                  ;hkn; SS is DOSDATA
 24360                                  	push	ss
 24361                                  	pop	ds
 24362                                  	MOV	[NEXTADD],DI
 24363                                  	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
 24364                                  	LES	DI,[THISSFT]
 24365                                  	;and	byte [es:di+5],0BFh
 24366                                  	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF 
 24367                                  				; Mark as no more data available
 24368                                  SETSFTC:
 24369                                  	;call	SETSFT
 24370                                  	;retn
 24371                                  	jmp	SETSFT	
 24372                                  %endif
 24373                                  
 24374                                  READCON:
 24375 00003D68 E8F9FD                  	CALL	SWAPCON
 24376 00003D6B 8B36[2200]              	MOV	SI,[CONTPOS]
 24377 00003D6F 09F6                    	OR	SI,SI
 24378 00003D71 75C4                    	JNZ	short TRANBUF
 24379 00003D73 803E[7B02]80            	CMP	BYTE [CONBUF],128 ; 80h
 24380 00003D78 7406                    	JZ	short GETBUF
 24381 00003D7A C706[7B02]80FF          	MOV	WORD [CONBUF],0FF80H ; Set up 128-byte buffer with no template
 24382                                  GETBUF:
 24383 00003D80 51                      	PUSH	CX
 24384 00003D81 06                      	PUSH	ES
 24385 00003D82 57                      	PUSH	DI
 24386                                  
 24387                                  ;hkn; CONBUF is in DOSDATA
 24388 00003D83 BA[7B02]                	MOV	DX,CONBUF
 24389                                  
 24390 00003D86 E83FDC                  	call	_$STD_CON_STRING_INPUT	; Get input buffer
 24391 00003D89 5F                      	POP	DI
 24392 00003D8A 07                      	POP	ES
 24393 00003D8B 59                      	POP	CX
 24394                                  
 24395                                  ;hkn; CONBUF is in DOSDATA
 24396 00003D8C BE[7D02]                	MOV	SI,CONBUF+2
 24397                                  
 24398 00003D8F 803C1A                  	CMP	BYTE [SI],1AH	; Check for Ctrl-Z in first character
 24399 00003D92 75A3                    	JNZ	short TRANBUF
 24400 00003D94 B01A                    	MOV	AL,1AH
 24401 00003D96 AA                      	STOSB
 24402 00003D97 4F                      	DEC	DI
 24403 00003D98 B00A                    	MOV	AL,c_LF
 24404 00003D9A E8B0DE                  	call	OUTT		; Send linefeed
 24405 00003D9D 31F6                    	XOR	SI,SI
 24406 00003D9F EBAC                    	JMP	short ENDRDCON ; 04/05/2019
 24407                                  
 24408                                  ; 24/07/2018 - Retro DOS v3.0
 24409                                  
 24410                                  ;Break	<DOS_WRITE -- MAIN WRITE ROUTINE AND DEVICE OUT ROUTINES>
 24411                                  ;---------------------------------------------------------------------------
 24412                                  ;
 24413                                  ; Procedure Name : DOS_WRITE
 24414                                  ;
 24415                                  ; Inputs:
 24416                                  ;	ThisSFT set to the SFT for the file being used
 24417                                  ;	[DMAADD] contains transfer address
 24418                                  ;	CX = No. of bytes to write
 24419                                  ; Function:
 24420                                  ;	Perform write operation
 24421                                  ;	NOTE: If CX = 0 on input, file is truncated or grown
 24422                                  ;		to current sf_position
 24423                                  ; Outputs:
 24424                                  ;    Carry clear
 24425                                  ;	SFT Position and cluster pointers updated
 24426                                  ;	CX = No. of bytes written
 24427                                  ;	ES:DI point to SFT
 24428                                  ;    Carry set
 24429                                  ;	AX is error code
 24430                                  ;	CX = 0
 24431                                  ;	ES:DI point to SFT
 24432                                  ; DS preserved, all other registers destroyed
 24433                                  ;---------------------------------------------------------------------------
 24434                                  
 24435                                  ;hkn; called from fcbio2.asm, handle.asm and dev.asm. DS is set up at this 
 24436                                  ;hkn; point to DOSDATA.
 24437                                  
 24438                                  ; 04/05/2019 - Retro DOS v4.0
 24439                                  ; DOSCODE:742Ch (MSDOS 6.21, MSDOS.SYS)
 24440                                  
 24441                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24442                                  ; DOSCODE:7418h (MSDOS 5.0, MSDOS.SYS)
 24443                                  
 24444                                  DOS_WRITE:
 24445 00003DA1 C43E[9E05]              	LES	DI,[THISSFT]
 24446                                  	;mov	al,[ES:DI+2]
 24447 00003DA5 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 24448                                  	;and	al,0Fh
 24449 00003DA9 240F                    	AND	AL,access_mask
 24450                                  	;cmp	al,0
 24451 00003DAB 3C00                    	CMP	AL,open_for_read
 24452 00003DAD 7503                    	JNE	short Check_FCB_RO		 ;Is write or both
 24453                                  BadMode:
 24454 00003DAF E9DA03                  	jmp	SET_ACC_ERR
 24455                                  
 24456                                  ; NOTE: The following check for writting to a Read Only File is performed
 24457                                  ;	    ONLY on FCBs!!!!
 24458                                  ;	We ALLOW writes to Read Only files via handles to allow a CREATE
 24459                                  ;	    of a read only file which can then be written to.
 24460                                  ;	This is OK because we are NOT ALLOWED to OPEN a RO file via handles
 24461                                  ;	    for writting, or RE-CREATE an EXISTING RO file via handles. Thus,
 24462                                  ;	    CREATing a NEW RO file, or RE-CREATing an existing file which
 24463                                  ;	    is NOT RO to be RO, via handles are the only times we can write
 24464                                  ;	    to a read-only file.
 24465                                  
 24466                                  Check_FCB_RO:
 24467                                  	;;test	word [es:di+2],8000h
 24468                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 24469                                  	;JZ	short WRITE_NO_MODE	; Not an FCB
 24470                                  	
 24471                                  	;test	byte [es:di+3],80h
 24472 00003DB2 26F6450380              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 24473 00003DB7 7407                    	JZ	short WRITE_NO_MODE	; Not an FCB
 24474                                  
 24475                                  	;test	byte [es:di+4],1
 24476 00003DB9 26F6450401              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_read_only
 24477 00003DBE 75EF                    	JNZ	short BadMode 		; Can't write to Read_Only files via FCB
 24478                                  WRITE_NO_MODE:
 24479 00003DC0 E8AA02                  	call	SETUP
 24480 00003DC3 E894DA                  	call	IsSFTNet
 24481 00003DC6 7406                    	JZ	short LOCAL_WRITE
 24482                                  
 24483                                  ;IF NOT Installed
 24484                                  ;	transfer NET_WRITE
 24485                                  ;ELSE
 24486                                  	;mov	ax,1109h
 24487 00003DC8 B80911                  	MOV	AX,(MultNET<<8)|9
 24488 00003DCB CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
 24489                                  			; ES:DI -> SFT
 24490                                  			; SFT DPB field -> DPB of drive containing file
 24491                                  			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
 24492                                  			; Return: CF set on error, CX = bytes written
 24493 00003DCD C3                      	retn
 24494                                  ;ENDIF
 24495                                  
 24496                                  LOCAL_WRITE:
 24497                                  	;;test	word [es:di+5],80h
 24498                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 24499                                  	;jnz	short WRTDEV
 24500                                  
 24501                                  	;test	byte [es:di+5],80h
 24502 00003DCE 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; Check for named device I/O
 24503 00003DD3 756E                    	jnz	short WRTDEV
 24504                                  
 24505                                  	;mov	byte [EXTERR_LOCUS],2
 24506 00003DD5 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 24507 00003DDA E826DB                  	call	ECritDisk
 24508                                  
 24509 00003DDD E8F404                  	call	DISKWRITE
 24510                                  
 24511                                  	; 04/05/2019 - Retro DOS v4.0
 24512                                  
 24513                                  	; MSDOS 6.0
 24514                                  ; Extended Open
 24515 00003DE0 7210                    	JC	short nocommit
 24516                                  	
 24517 00003DE2 C43E[9E05]              	LES	DI,[THISSFT]
 24518                                  	
 24519                                  	;;test	word [ES:DI+2],4000h
 24520                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],AUTO_COMMIT_WRITE
 24521                                  	;JZ	short nocommit
 24522                                  	
 24523                                  	;test	byte [ES:DI+3],40h
 24524 00003DE6 26F6450340              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(AUTO_COMMIT_WRITE>>8)
 24525 00003DEB 7405                    	JZ	short nocommit
 24526                                  	
 24527 00003DED 51                      	PUSH	CX
 24528 00003DEE E807FB                  	call	DOS_COMMIT
 24529 00003DF1 59                      	POP	CX
 24530                                  nocommit:
 24531                                  ; Extended Open
 24532                                  	;call	LCritDisk
 24533                                  	;retn
 24534                                  	; 18/12/2022
 24535 00003DF2 E93BDB                  	jmp	LCritDisk
 24536                                  
 24537                                  DVWRTRAW:
 24538 00003DF5 31C0                    	XOR	AX,AX			; Media Byte, unit = 0
 24539 00003DF7 E8FF12                  	call	SETWRITE
 24540 00003DFA 1E                      	PUSH	DS			; Save seg of transfer
 24541                                  
 24542                                  ;hkn; SS override
 24543 00003DFB 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 24544 00003E00 E84A12                  	call	DEVIOCALL		; DS:SI -> DEVICE
 24545                                  
 24546 00003E03 89FA                    	MOV	DX,DI			; Offset part of Xaddr saved in DX
 24547 00003E05 B487                    	MOV	AH,87H
 24548                                  
 24549                                  ;hkn; SS override
 24550 00003E07 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 24551                                  
 24552                                  	; MSDOS 3.3
 24553                                  	;test	di,8000h
 24554                                  	;jz	short CWRTROK
 24555                                  
 24556                                  	; MSDOS 6.0
 24557 00003E0C 09FF                    	or	di,di
 24558 00003E0E 7920                    	jns	short CWRTROK
 24559                                  	
 24560                                  	; MSDOS 3.3 (& MSDOS 6.0)
 24561 00003E10 E89F1E                  	call	CHARHARD
 24562                                  
 24563                                  	; 04/05/2019  - Retro DOS v4.0
 24564                                  
 24565                                  	; MSDOS 6.0
 24566 00003E13 362B0E[6C03]            	sub	cx,[ss:CALLSCNT]	; update ptr & count to reflect	M065
 24567 00003E18 89D3                    	mov	bx,dx			; number of chars xferred	M065
 24568 00003E1A 36031E[6C03]            	add	bx,[ss:CALLSCNT]	;				M065
 24569 00003E1F 89DF                    	mov	di,bx			;				M065
 24570                                  	
 24571                                  	; MSDOS 3.3
 24572                                  	;MOV	BX,DX			; Recall transfer addr		M065
 24573                                  
 24574                                  	; MSDOS 3.3 (& MSDOS 6.0)
 24575 00003E21 08C0                    	OR	AL,AL
 24576 00003E23 740B                    	JZ	short CWRTROK 		; Ignore
 24577 00003E25 3C03                    	CMP	AL,3
 24578 00003E27 7403                    	JZ	short CWRFERR
 24579 00003E29 1F                      	POP	DS			; Recover saved seg of transfer
 24580 00003E2A EBC9                    	JMP	short DVWRTRAW		; Try again
 24581                                  CWRFERR:
 24582 00003E2C 58                      	POP	AX			; Chuck saved seg of transfer
 24583 00003E2D E9F4FD                  	JMP	CRDFERR 		; Will pop one more stack element
 24584                                  CWRTROK:
 24585 00003E30 58                      	POP	AX			; Chuck saved seg of transfer
 24586 00003E31 1F                      	POP	DS
 24587 00003E32 A1[6C03]                	MOV	AX,[CALLSCNT]		; Get actual number of bytes transferred
 24588                                  ENDWRDEV:
 24589 00003E35 C43E[9E05]              	LES	DI,[THISSFT]
 24590 00003E39 89C1                    	MOV	CX,AX
 24591                                  	;call	ADDREC
 24592                                  	;retn
 24593                                  	; 16/12/2022
 24594                                  	; 10/06/2019
 24595 00003E3B E90104                  	jmp	ADDREC
 24596                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24597                                  	;call	ADDREC
 24598                                  	;retn
 24599                                  	
 24600                                  WRTNUL:
 24601 00003E3E 89CA                    	MOV	DX,CX			; Entire transfer done
 24602                                  WRTCOOKJ:
 24603 00003E40 E98D00                  	JMP	WRTCOOKDONE
 24604                                  WRTDEV:
 24605                                  	;mov	byte [EXTERR_LOCUS],4
 24606 00003E43 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 24607                                  	;or	byte [es:di+5],40h
 24608 00003E48 26804D0540              	OR	BYTE [ES:DI+SF_ENTRY.sf_flags],devid_device_EOF
 24609                                  					; Reset EOF for input
 24610                                  	;mov	bl,[es:di+5]
 24611 00003E4D 268A5D05                	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
 24612 00003E51 31C0                    	XOR	AX,AX
 24613 00003E53 E3E0                    	JCXZ	ENDWRDEV		; problem of creating on a device.
 24614 00003E55 1E                      	PUSH	DS
 24615 00003E56 88D8                    	MOV	AL,BL
 24616 00003E58 C51E[2C03]              	LDS	BX,[DMAADD]		; Xaddr to DS:BX
 24617 00003E5C 89DF                    	MOV	DI,BX			; Xaddr to DS:DI
 24618 00003E5E 31D2                    	XOR	DX,DX			; Set starting point
 24619                                  	;test	al,20h
 24620 00003E60 A820                    	test	AL,devid_device_raw	; Raw?
 24621                                  	;JZ	short TEST_DEV_CON
 24622                                  	;JMP	DVWRTRAW
 24623                                  	; 16/12/2022
 24624 00003E62 7591                    	jnz	short DVWRTRAW
 24625                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24626                                  	;JZ	short TEST_DEV_CON
 24627                                  	;JMP	short DVWRTRAW
 24628                                  
 24629                                  TEST_DEV_CON:
 24630                                  	;test	al,2
 24631 00003E64 A802                    	test	AL,devid_device_con_out ; Console output device?
 24632 00003E66 756E                    	jnz	short WRITECON
 24633                                  	;test	al,4
 24634 00003E68 A804                    	test	AL,devid_device_null
 24635 00003E6A 75D2                    	JNZ	short WRTNUL
 24636 00003E6C 89D0                    	MOV	AX,DX
 24637 00003E6E 803F1A                  	CMP	BYTE [BX],1Ah		; ^Z?
 24638 00003E71 74CD                    	JZ	short WRTCOOKJ		; Yes, transfer nothing
 24639 00003E73 51                      	PUSH	CX
 24640 00003E74 B90100                  	MOV	CX,1
 24641 00003E77 E87F12                  	call	SETWRITE
 24642 00003E7A 59                      	POP	CX
 24643                                  
 24644                                  ;hkn; SS override
 24645 00003E7B 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 24646                                  ;
 24647                                  ;SR; Removed X25 support from here
 24648                                  ;
 24649                                  	;lds	si,[si+7]
 24650 00003E80 C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 24651                                  DVWRTLP:
 24652 00003E83 E80D1C                  	call	DSKSTATCHK
 24653 00003E86 E8C711                  	call	DEVIOCALL2
 24654 00003E89 57                      	PUSH	DI
 24655 00003E8A B487                    	MOV	AH,87H
 24656                                  
 24657                                  ;hkn; SS override
 24658 00003E8C 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 24659                                  	
 24660                                  	; MSDOS 3.3
 24661                                  	;test	di,8000h
 24662                                  	;jz	short CWROK
 24663                                  
 24664                                  	; MSDOS 6.0
 24665 00003E91 09FF                    	or	di,di
 24666 00003E93 7916                    	jns	short CWROK
 24667                                  	
 24668                                  	; MSDOS 3.3 (& MSDOS 6.0)
 24669 00003E95 E81A1E                  	call	CHARHARD
 24670 00003E98 5F                      	POP	DI
 24671                                  
 24672                                  ;hkn; SS override
 24673 00003E99 36C706[6C03]0100        	MOV	word [SS:CALLSCNT],1
 24674 00003EA0 3C01                    	CMP	AL,1
 24675 00003EA2 74DF                    	JZ	short DVWRTLP 	; Retry
 24676 00003EA4 08C0                    	OR	AL,AL
 24677 00003EA6 740C                    	JZ	short DVWRTIGN	; Ignore
 24678                                  	; 10/08/2018
 24679 00003EA8 E979FD                  	JMP	CRDFERR 	; Fail, pops one stack element
 24680                                  CWROK:
 24681 00003EAB 5F                      	POP	DI
 24682                                  
 24683                                  ;hkn; SS override
 24684 00003EAC 36833E[6C03]00          	CMP	word [SS:CALLSCNT],0
 24685 00003EB2 741C                    	JZ	short WRTCOOKDONE
 24686                                  DVWRTIGN:
 24687 00003EB4 42                      	INC	DX
 24688                                  
 24689                                  ;hkn; SS override for CALLXAD
 24690 00003EB5 36FF06[6803]            	INC	WORD [SS:CALLXAD]
 24691 00003EBA 47                      	INC	DI
 24692 00003EBB 1E                      	PUSH	DS
 24693 00003EBC 368E1E[6A03]            	MOV	DS,[SS:CALLXAD+2]
 24694 00003EC1 803D1A                  	CMP	BYTE [DI],1Ah	; ^Z?
 24695 00003EC4 1F                      	POP	DS
 24696 00003EC5 7409                    	JZ	short WRTCOOKDONE
 24697                                  
 24698                                  ;hkn; SS override
 24699 00003EC7 36C706[5D03]0000        	MOV	word [SS:DEVCALL_REQSTAT],0
 24700 00003ECE E2B3                    	LOOP	DVWRTLP
 24701                                  WRTCOOKDONE:
 24702 00003ED0 89D0                    	MOV	AX,DX
 24703 00003ED2 1F                      	POP	DS
 24704 00003ED3 E95FFF                  	JMP	ENDWRDEV ; 10/08/2018
 24705                                  
 24706                                  WRITECON:
 24707 00003ED6 1E                      	PUSH	DS
 24708                                  
 24709                                  ;hkn; SS is DOSDATA
 24710 00003ED7 16                      	push	ss
 24711 00003ED8 1F                      	pop	ds
 24712 00003ED9 E888FC                  	CALL	SWAPCON
 24713 00003EDC 1F                      	POP	DS
 24714 00003EDD 89DE                    	MOV	SI,BX
 24715 00003EDF 51                      	PUSH	CX
 24716                                  WRCONLP:
 24717 00003EE0 AC                      	LODSB
 24718 00003EE1 3C1A                    	CMP	AL,1Ah		; ^Z?
 24719 00003EE3 7405                    	JZ	short CONEOF
 24720 00003EE5 E865DD                  	call	OUTT
 24721 00003EE8 E2F6                    	LOOP	WRCONLP
 24722                                  CONEOF:
 24723 00003EEA 58                      	POP	AX			; Count
 24724 00003EEB 29C8                    	SUB	AX,CX			; Amount actually written
 24725 00003EED 1F                      	POP	DS
 24726 00003EEE E86DFC                  	CALL	SWAPBACK
 24727 00003EF1 E941FF                  	JMP	ENDWRDEV
 24728                                  
 24729                                  ;---------------------------------------------------------------------------
 24730                                  ;
 24731                                  ; Procedure Name : get_io_sft
 24732                                  ;
 24733                                  ;   Convert JFN number in BX to sf_entry in DS:SI We get the normal SFT if
 24734                                  ;   CONSWAP is FALSE or if the handle desired is 2 or more. Otherwise, we
 24735                                  ;   retrieve the sft from ConSFT which is set by SwapCon.
 24736                                  ;
 24737                                  ;---------------------------------------------------------------------------
 24738                                  
 24739                                  ; 04/05/2019 - Retro DOS v4.0
 24740                                  ; DOSCODE:7583h (MSDOS 6.21, MSDOS.SYS)
 24741                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24742                                  ; DOSCODE:756Fh (MSDOS 5.0, MSDOS.SYS)
 24743                                  
 24744                                  GET_IO_SFT:
 24745                                  	;test	byte [SS:CONSWAP],0FFh
 24746 00003EF4 36803E[5703]00          	cmp	byte [SS:CONSWAP],0			;smr;SS Override
 24747 00003EFA 7512                    	JNZ	short GetRedir
 24748                                  GetNormal:
 24749 00003EFC 16                      	push	ss
 24750 00003EFD 1F                      	pop	ds
 24751 00003EFE 06                      	PUSH	ES
 24752 00003EFF 57                      	PUSH	DI
 24753 00003F00 E88931                  	call	SFFromHandle
 24754 00003F03 7206                    	JC	short RET44P
 24755 00003F05 8CC6                    	MOV	SI,ES
 24756 00003F07 8EDE                    	MOV	DS,SI
 24757 00003F09 89FE                    	MOV	SI,DI
 24758                                  RET44P:
 24759 00003F0B 5F                      	POP	DI
 24760 00003F0C 07                      	POP	ES
 24761 00003F0D C3                      	retn
 24762                                  GetRedir:
 24763 00003F0E 83FB01                  	CMP	BX,1
 24764 00003F11 77E9                    	JA	short GetNormal
 24765 00003F13 36C536[E605]            	LDS	SI,[SS:CONSFT]
 24766 00003F18 F8                      	CLC
 24767                                  get_io_sft_retn:
 24768 00003F19 C3                      	retn
 24769                                  
 24770                                  ;Break	<DIRREAD -- READ A DIRECTORY SECTOR>
 24771                                  ;---------------------------------------------------------------------------
 24772                                  ;
 24773                                  ; Procedure Name : DIRREAD
 24774                                  ;
 24775                                  ; Inputs:
 24776                                  ;	AX = Directory block number (relative to first block of directory)
 24777                                  ;	ES:BP = Base of drive parameters
 24778                                  ;	[DIRSEC] = First sector of first cluster of directory
 24779                                  ;	[CLUSNUM] = Next cluster
 24780                                  ;	[CLUSFAC] = Sectors/Cluster
 24781                                  ; Function:
 24782                                  ;	Read the directory block into [CURBUF].
 24783                                  ; Outputs:
 24784                                  ;	[NXTCLUSNUM] = Next cluster (after the one skipped to)
 24785                                  ;	[SECCLUSPOS] Set
 24786                                  ;	ES:BP unchanged
 24787                                  ;	[CURBUF] Points to Buffer with dir sector
 24788                                  ;	Carry set if error (user said FAIL to I 24)
 24789                                  ; DS preserved, all other registers destroyed.
 24790                                  ;---------------------------------------------------------------------------
 24791                                  
 24792                                  ;hkn; called from dir.asm. DS already set up to DOSDATA.
 24793                                  
 24794                                  DIRREAD:
 24795                                  
 24796                                  ; Note that ClusFac is the sectors per cluster. This is NOT necessarily
 24797                                  ; the same as what is in the DPB! In the case of the root directory, we have
 24798                                  ; ClusFac = # sectors in the root directory. The root directory is detected
 24799                                  ; by DIRStart = 0.
 24800                                  
 24801 00003F1A 31D2                    	XOR	DX,DX
 24802                                  	;CMP	word [DIRSTART],0
 24803                                  	; 21/09/2023
 24804 00003F1C 3916[C205]              	cmp	[DIRSTART],dx ; 0
 24805 00003F20 7503                    	jnz	short SubDir
 24806 00003F22 92                      	XCHG	AX,DX
 24807 00003F23 EB0C                    	JMP	short DoRead
 24808                                  
 24809                                  ; Convert the sector number in AX into cluster and sector-within-cluster pair
 24810                                  
 24811                                  SubDir:
 24812 00003F25 88C2                    	MOV	DL,AL
 24813                                  	;and	dl,[es:bp+4]
 24814 00003F27 26225604                	AND	DL,[ES:BP+DPB.CLUSTER_MASK]
 24815                                  
 24816                                  ;	(DX) = sector-in-cluster
 24817                                  
 24818                                  	;mov	cl,[es:bp+5]
 24819 00003F2B 268A4E05                	MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 24820 00003F2F D3E8                    	SHR	AX,CL
 24821                                  
 24822                                  ;	(DX) = position in cluster
 24823                                  ;	(AX) = number of clusters to skip
 24824                                  
 24825                                  DoRead:
 24826 00003F31 8816[7305]              	MOV	[SECCLUSPOS],DL
 24827 00003F35 89C1                    	MOV	CX,AX
 24828 00003F37 88D4                    	MOV	AH,DL
 24829                                  
 24830                                  ;	(CX) = number of clusters to skip.
 24831                                  ;	(AH) = remainder
 24832                                  
 24833                                  	; 04/05/2019 - Retro DOS v4.0
 24834                                  	 
 24835                                  	; MSDOS 6.0
 24836                                  	;MOV	DX,[DIRSEC+2]	     	  ;>32mb
 24837                                  	;MOV	[HIGH_SECTOR],DX	  ;>32mb
 24838                                  	;MOV	DX,[DIRSEC]
 24839                                  	;ADD	DL,AH
 24840                                  	;ADC	DH,0
 24841                                  	;ADC	word [HIGH_SECTOR],0	  ;>32mb
 24842                                  	; 21/09/2023
 24843 00003F39 31DB                    	xor	bx,bx ; 0
 24844 00003F3B 8B16[BE05]              	mov	dx,[DIRSEC]
 24845 00003F3F 00E2                    	add	dl,ah
 24846 00003F41 10DE                    	adc	dh,bl ; 0
 24847 00003F43 131E[C005]              	adc	bx,[DIRSEC+2]
 24848 00003F47 891E[0706]              	mov	[HIGH_SECTOR],bx
 24849                                  
 24850 00003F4B 8B1E[BC05]              	MOV	BX,[CLUSNUM]
 24851 00003F4F 891E[DC05]              	MOV	[NXTCLUSNUM],BX
 24852 00003F53 E319                    	JCXZ	FIRSTCLUSTER
 24853                                  SKPCLLP:
 24854 00003F55 E8C51F                  	call	UNPACK
 24855 00003F58 72BF                    	jc	short get_io_sft_retn
 24856 00003F5A 87DF                    	XCHG	BX,DI
 24857 00003F5C E8A71F                  	call	IsEOF			; test for eof based on fat size
 24858 00003F5F 7302                    	JAE	short HAVESKIPPED
 24859 00003F61 E2F2                    	LOOP	SKPCLLP
 24860                                  HAVESKIPPED:
 24861 00003F63 891E[DC05]              	MOV	[NXTCLUSNUM],BX
 24862 00003F67 89FA                    	MOV	DX,DI
 24863 00003F69 88E3                    	MOV	BL,AH
 24864 00003F6B E85818                  	call	FIGREC
 24865                                  
 24866                                  	;entry	FIRSTCLUSTER
 24867                                  
 24868                                  FIRSTCLUSTER:
 24869                                  	; 22/09/2023
 24870                                  	;;mov	byte [ALLOWED],18h
 24871                                  	;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 24872                                  	;XOR	AL,AL ; *	; Indicate pre-read
 24873                                  	;call	GETBUFFR
 24874 00003F6E E8E523                  	call	GETBUFFER ; *	; pre-read
 24875 00003F71 72A6                    	jc	short get_io_sft_retn
 24876                                  
 24877                                  	;entry	SET_BUF_AS_DIR
 24878                                  
 24879                                  SET_BUF_AS_DIR:
 24880                                  
 24881                                  ;	Set the type of CURBUF to be a directory sector.
 24882                                  ;	Only flags are modified.
 24883                                  
 24884 00003F73 1E                      	PUSH	DS
 24885 00003F74 56                      	PUSH	SI
 24886 00003F75 C536[E205]              	LDS	SI,[CURBUF]
 24887                                  	;or	byte [si+5],4
 24888 00003F79 804C0504                	OR	byte [SI+BUFFINFO.buf_flags],buf_isDIR	; Clears carry
 24889 00003F7D 5E                      	POP	SI
 24890 00003F7E 1F                      	POP	DS
 24891                                  dirread_retn:
 24892 00003F7F C3                      	retn
 24893                                  
 24894                                  ;Break	<FATSECRD -- READ A FAT SECTOR>
 24895                                  ;----------------------------------------------------------------------------
 24896                                  ;
 24897                                  ; Procedure Name : FATSECRD
 24898                                  ; Inputs:
 24899                                  ;	Same as DREAD
 24900                                  ;	DS:BX = Transfer address
 24901                                  ;	CX = Number of sectors
 24902                                  ;	DX = Absolute record number
 24903                                  ;	ES:BP = Base of drive parameters
 24904                                  ; Function:
 24905                                  ;	Calls BIOS to perform FAT read.
 24906                                  ; Outputs:
 24907                                  ;	Same as DREAD
 24908                                  ;---------------------------------------------------------------------------
 24909                                  
 24910                                  	; 04/05/2019 - Retro DOS v4.0
 24911                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)	
 24912                                  
 24913                                  FATSECRD:
 24914                                  ;hkn; SS override
 24915                                  	;mov	byte [ss:ALLOWED],18h
 24916 00003F80 36C606[4B03]18          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
 24917 00003F86 89CF                    	MOV	DI,CX
 24918                                  	;mov	cl,[es:bp+8]
 24919 00003F88 268A4E08                	MOV	CL,[ES:BP+DPB.FAT_COUNT]
 24920                                  	; MSDOS 3.3
 24921                                  	;;mov	al,[es:bp+0Fh]
 24922                                  	;MOV	AL,[ES:BP+DPB.FAT_SIZE] 				
 24923                                  	;XOR	AH,AH
 24924                                  	; MSDOS 6.0
 24925                                  	;mov	ax,[es:bp+0Fh]
 24926 00003F8C 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE] ;>32mb
 24927 00003F90 30ED                    	XOR	CH,CH	
 24928 00003F92 52                      	PUSH	DX
 24929                                  NXTFAT:
 24930                                  	; MSDOS 6.0
 24931                                  ;hkn; SS override
 24932 00003F93 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0	;>32mb FAT sectors cannot exceed
 24933 00003F9A 51                      	PUSH	CX			;32mb
 24934 00003F9B 50                      	PUSH	AX
 24935 00003F9C 89F9                    	MOV	CX,DI
 24936 00003F9E E85B00                  	call	DSKREAD
 24937 00003FA1 58                      	POP	AX
 24938 00003FA2 59                      	POP	CX
 24939 00003FA3 7420                    	JZ	short RET41P		; Carry clear
 24940 00003FA5 01C2                    	ADD	DX,AX
 24941 00003FA7 E2EA                    	LOOP	NXTFAT
 24942 00003FA9 5A                      	POP	DX
 24943 00003FAA 89F9                    	MOV	CX,DI
 24944                                  
 24945                                  ; NOTE FALL THROUGH
 24946                                  
 24947                                  ;Break	<DREAD -- DO A DISK READ>
 24948                                  ;---------------------------------------------------------------------------
 24949                                  ;
 24950                                  ; Procedure Name : DREAD
 24951                                  ;
 24952                                  ; Inputs:
 24953                                  ;	DS:BX = Transfer address
 24954                                  ;	CX = Number of sectors
 24955                                  ;	DX = Absolute record number	      (LOW)
 24956                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 24957                                  ;	ES:BP = Base of drive parameters
 24958                                  ;	[ALLOWED] must be set in case call to HARDERR needed
 24959                                  ; Function:
 24960                                  ;	Calls BIOS to perform disk read. If BIOS reports
 24961                                  ;	errors, will call HARDERRRW for further action.
 24962                                  ; Outputs:
 24963                                  ;	Carry set if error (currently user FAILED to INT 24)
 24964                                  ; DS,ES:BP preserved. All other registers destroyed.
 24965                                  ;---------------------------------------------------------------------------
 24966                                  
 24967                                  	;entry	DREAD
 24968                                  DREAD:
 24969 00003FAC E84D00                  	call	DSKREAD
 24970 00003FAF 74CE                    	jz	short dirread_retn	; Carry clear
 24971                                  ;hkn; SS override
 24972 00003FB1 36C606[7505]00          	MOV	BYTE [SS:READOP],0
 24973 00003FB7 E89A00                  	call	HARDERRRW
 24974 00003FBA 3C01                    	CMP	AL,1			; Check for retry
 24975 00003FBC 74EE                    	JZ	short DREAD
 24976 00003FBE 3C03                    	CMP	AL,3			; Check for FAIL
 24977 00003FC0 F8                      	CLC
 24978 00003FC1 7501                    	JNZ	short NO_CAR		; Ignore
 24979 00003FC3 F9                      	STC
 24980                                  NO_CAR:
 24981 00003FC4 C3                      	retn
 24982                                  RET41P: 
 24983 00003FC5 5A                      	POP	DX
 24984 00003FC6 C3                      	retn
 24985                                  
 24986                                  ; 24/07/2018 - Retro DOS v3.0
 24987                                  
 24988                                  ;Break	<CHECK_WRITE_LOCK>
 24989                                  ;---------------------------------------------------------------------------
 24990                                  ;
 24991                                  ; Procedure Name : CHECK_WRITE_LOCK
 24992                                  ;
 24993                                  ; Inputs:
 24994                                  ;	output of SETUP
 24995                                  ;	ES:DI -> SFT
 24996                                  ; Function:
 24997                                  ;	check write lock
 24998                                  ; Outputs:
 24999                                  ;	Carry set if error
 25000                                  ;	Carry clear if ok
 25001                                  ;
 25002                                  ;----------------------------------------------------------------------------
 25003                                  
 25004                                  	; 04/05/2019 - Retro DOS v4.0
 25005                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25006                                  
 25007                                  CHECK_WRITE_LOCK:
 25008                                  	; MSDOS 6.0
 25009                                  	;test	byte [es:di+4],8
 25010 00003FC7 26F6450408              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
 25011                                  	;JZ	short write_cont			     ;no
 25012                                  	;;call	SET_ACC_ERR_DS
 25013                                  	;;retn
 25014                                  	;;jnz	SET_ACC_ERR_DS
 25015                                  	; 19/08/2018
 25016                                  	;jz	short write_cont
 25017                                  	;jmp	SET_ACC_ERR_DS
 25018                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25019 00003FCC 7403                    	JZ	short write_cont
 25020                                  	;call	SET_ACC_ERR_DS
 25021                                  	;retn
 25022                                  	; 16/12/2022
 25023 00003FCE E9B901                  	jmp	SET_ACC_ERR_DS
 25024                                  
 25025                                  write_cont:				;
 25026 00003FD1 51                      	PUSH	CX			;save reg
 25027 00003FD2 09C9                    	OR	CX,CX			;
 25028 00003FD4 7501                    	JNZ	short Not_Truncate	;
 25029 00003FD6 49                      	dec	cx			;(cx) = -1; check for lock on whole file
 25030                                  Not_Truncate:				;
 25031 00003FD7 B080                    	MOV	AL,80H			;check write access
 25032 00003FD9 E8393D                  	call	LOCK_CHECK		;check lock
 25033 00003FDC 59                      	POP	CX			;restore reg
 25034 00003FDD 7305                    	JNC	short WRITE_OK		;lock ok
 25035 00003FDF E85F01                  	call	WRITE_LOCK_VIOLATION	;issue I24
 25036 00003FE2 73ED                    	JNC	short write_cont	;retry
 25037                                  WRITE_OK:				;
 25038 00003FE4 C3                      	retn				;
 25039                                  
 25040                                  ;Break	<CHECK_READ_LOCK>
 25041                                  ;---------------------------------------------------------------------------
 25042                                  ;
 25043                                  ; Procedure Name : CHECK_READ_LOC
 25044                                  ;
 25045                                  ; Inputs:
 25046                                  ;	ES:DI -> SFT
 25047                                  ;	output of SETUP
 25048                                  ; Function:
 25049                                  ;	check read lock
 25050                                  ; Outputs:
 25051                                  ;	Carry set if error
 25052                                  ;	Carry clear if ok
 25053                                  ;----------------------------------------------------------------------------
 25054                                  
 25055                                  CHECK_READ_LOCK:
 25056                                  	; MSDOS 6.0
 25057                                  	;test	byte [es:di+4],8
 25058 00003FE5 26F6450408              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
 25059                                  	;JZ	short do_retry			   	     ; no
 25060                                  	;;call	SET_ACC_ERR
 25061                                  	;;retn
 25062                                  	;;jnz	SET_ACC_ERR
 25063                                  	; 16/12/2022
 25064                                  	; 28/07/2019
 25065 00003FEA 7403                    	jz	short do_retry
 25066 00003FEC E99D01                  	jmp	SET_ACC_ERR
 25067                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25068                                  	;JZ	short do_retry
 25069                                  	;call	SET_ACC_ERR
 25070                                  	;retn
 25071                                  do_retry:				;
 25072 00003FEF 30C0                    	xor	al,al			;check read access
 25073 00003FF1 E8213D                  	call	LOCK_CHECK		;check lock
 25074 00003FF4 7305                    	JNC	short READLOCK_OK 	;lock ok
 25075 00003FF6 E82801                  	call	READ_LOCK_VIOLATION	;issue I24
 25076 00003FF9 73F4                    	JNC	short do_retry		;retry
 25077                                  READLOCK_OK:				;
 25078 00003FFB C3                      	retn				;
 25079                                  
 25080                                  ;============================================================================
 25081                                  ; DISK2.ASM, MSDOS 6.0, 1991
 25082                                  ;============================================================================
 25083                                  ; 24/07/2018 - Retro DOS v3.0
 25084                                  ; 04/05/2019 - Retro DOS v4.0
 25085                                  
 25086                                  ;	TITLE	DISK2 - Disk utility routines
 25087                                  ;	NAME	Disk2
 25088                                  
 25089                                  ;**	Low level Read and write routines for local SFT I/O on files and devs
 25090                                  ;
 25091                                  ;	DskRead
 25092                                  ;	DWRITE
 25093                                  ;	DSKWRITE
 25094                                  ;	HarderrRW
 25095                                  ;	SETUP
 25096                                  ;	BREAKDOWN
 25097                                  ;	READ_LOCK_VIOLATION
 25098                                  ;	WRITE_LOCK_VIOLATION
 25099                                  ;	DISKREAD
 25100                                  ;	SET_ACC_ERR_DS
 25101                                  ;	SET_ACC_ERR
 25102                                  ;	SETSFT
 25103                                  ;	SETCLUS
 25104                                  ;	AddRec
 25105                                  ;
 25106                                  ;	Revision history:
 25107                                  ;
 25108                                  ;		AN000 version 4.00 Jan. 1988
 25109                                  ;		M039 DB 10/17/90 - Disk read/write optimization
 25110                                  
 25111                                  ; 04/05/2019 - Retro DOS v4.0
 25112                                  ; DOSCODE:7699h (MSDOS 6.21, MSDOS.SYS)
 25113                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25114                                  ; DOSCODE:7685h (MSDOS 5.0, MSDOS.SYS)
 25115                                  
 25116                                  ;Break	<DSKREAD -- PHYSICAL DISK READ>
 25117                                  ;---------------------------------------------------------------------------
 25118                                  ;
 25119                                  ; Procedure Name : DSKREAD
 25120                                  ;
 25121                                  ; Inputs:
 25122                                  ;	DS:BX = Transfer addr
 25123                                  ;	CX = Number of sectors
 25124                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 25125                                  ;	DX = Absolute record number	       (LOW)
 25126                                  ;	ES:BP = Base of drive parameters
 25127                                  ; Function:
 25128                                  ;	Call BIOS to perform disk read
 25129                                  ; Outputs:
 25130                                  ;	DI = CX on entry
 25131                                  ;	CX = Number of sectors unsuccessfully transfered
 25132                                  ;	AX = Status word as returned by BIOS (error code in AL if error)
 25133                                  ;	Zero set if OK (from BIOS) (carry clear)
 25134                                  ;	Zero clear if error (carry clear)
 25135                                  ; SI Destroyed, others preserved
 25136                                  ;---------------------------------------------------------------------------
 25137                                  
 25138                                  DSKREAD:
 25139 00003FFC 51                      	PUSH	CX
 25140                                  	;mov	ah,[es:bp+17h] ; 04/05/2019
 25141 00003FFD 268A6617                	MOV	AH,[ES:BP+DPB.MEDIA]
 25142                                  	;mov	al,[es:bp+1]
 25143 00004001 268A4601                	MOV	AL,[ES:BP+DPB.UNIT]
 25144 00004005 53                      	PUSH	BX
 25145 00004006 06                      	PUSH	ES
 25146 00004007 E8BC10                  	call	SETREAD
 25147 0000400A EB27                    	JMP	short DODSKOP
 25148                                  
 25149                                  ;Break	<DWRITE -- SEE ABOUT WRITING>
 25150                                  ;--------------------------------------------------------------------------
 25151                                  ;
 25152                                  ; Procedure Name : DWRITE
 25153                                  ;
 25154                                  ; Inputs:
 25155                                  ;	DS:BX = Transfer address
 25156                                  ;	CX = Number of sectors
 25157                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 25158                                  ;	DX = Absolute record number	       (LOW)
 25159                                  ;	ES:BP = Base of drive parameters
 25160                                  ;	[ALLOWED] must be set in case HARDERR called
 25161                                  ; Function:
 25162                                  ;	Calls BIOS to perform disk write. If BIOS reports
 25163                                  ;	errors, will call HARDERRRW for further action.
 25164                                  ; Output:
 25165                                  ;	Carry set if error (currently, user FAILed to I 24)
 25166                                  ; BP preserved. All other registers destroyed.
 25167                                  ;----------------------------------------------------------------------------
 25168                                  
 25169                                  	;entry	DWRITE
 25170                                  DWRITE:
 25171 0000400C E81600                  	CALL	DSKWRITE
 25172 0000400F 7413                    	jz	short dw_ret_label	; Carry clear (retz)
 25173                                  
 25174                                  ;hkn; SS override
 25175 00004011 36C606[7505]01          	MOV	BYTE [SS:READOP],1
 25176 00004017 E83A00                  	call	HARDERRRW
 25177 0000401A 3C01                    	CMP	AL,1		; Check for retry
 25178 0000401C 74EE                    	JZ	short DWRITE
 25179 0000401E 3C03                    	CMP	AL,3		; Check for FAIL
 25180 00004020 F8                      	CLC
 25181 00004021 7501                    	JNZ	short NO_CAR2 	; Ignore
 25182 00004023 F9                      	STC
 25183                                  NO_CAR2:
 25184                                  dw_ret_label:
 25185 00004024 C3                      	retn
 25186                                  
 25187                                  ;Break	<DSKWRITE -- PHYSICAL DISK WRITE>
 25188                                  ;---------------------------------------------------------------------------
 25189                                  ;
 25190                                  ; Procedure Name : DSKWRITE
 25191                                  ;
 25192                                  ; Inputs:
 25193                                  ;	DS:BX = Transfer addr
 25194                                  ;	CX = Number of sectors
 25195                                  ;	DX = Absolute record number	       (LOW)
 25196                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 25197                                  ;	ES:BP = Base of drive parameters
 25198                                  ; Function:
 25199                                  ;	Call BIOS to perform disk read
 25200                                  ; Outputs:
 25201                                  ;	DI = CX on entry
 25202                                  ;	CX = Number of sectors unsuccessfully transfered
 25203                                  ;	AX = Status word as returned by BIOS (error code in AL if error)
 25204                                  ;	Zero set if OK (from BIOS) (carry clear)
 25205                                  ;	Zero clear if error (carry clear)
 25206                                  ; SI Destroyed, others preserved
 25207                                  ;
 25208                                  ;----------------------------------------------------------------------------
 25209                                  
 25210                                  	;entry	DSKWRITE
 25211                                  DSKWRITE:
 25212 00004025 51                      	PUSH	CX
 25213                                  	;mov	ah,[es:bp+17h] ; 04/05/2019
 25214 00004026 268A6617                	MOV	AH,[ES:BP+DPB.MEDIA]
 25215                                  	;mov	al,[es:bp+1]
 25216 0000402A 268A4601                	MOV	AL,[ES:BP+DPB.UNIT]
 25217 0000402E 53                      	PUSH	BX
 25218 0000402F 06                      	PUSH	ES
 25219 00004030 E8C610                  	call	SETWRITE
 25220                                  DODSKOP:
 25221 00004033 8CD9                    	MOV	CX,DS		; Save DS
 25222 00004035 1F                      	POP	DS		; DS:BP points to DPB
 25223 00004036 1E                      	PUSH	DS
 25224                                  
 25225                                  	;lds	si,[ds:bp+13h] ; 04/05/2019
 25226 00004037 3EC57613                	LDS	SI,[ds:BP+DPB.DRIVER_ADDR] ; 07/09/2018
 25227 0000403B E81210                  	call	DEVIOCALL2
 25228                                  
 25229 0000403E 8ED9                    	MOV	DS,CX		; Restore DS
 25230 00004040 07                      	POP	ES		; Restore ES
 25231 00004041 5B                      	POP	BX
 25232                                  
 25233                                  ;hkn; SS override
 25234 00004042 368B0E[6C03]            	MOV	CX,[SS:CALLSCNT] ; Number of sectors transferred
 25235 00004047 5F                      	POP	DI
 25236 00004048 29F9                    	SUB	CX,DI
 25237 0000404A F7D9                    	NEG	CX		; Number of sectors not transferred
 25238                                  
 25239                                  ;hkn; SS override
 25240 0000404C 36A1[5D03]              	MOV	AX,[SS:DEVCALL_REQSTAT]
 25241                                  	;test	ax,8000h
 25242                                  	; 17/12/2022
 25243                                  	;test	ah,80h
 25244 00004050 F6C480                  	test	ah,(STERR>>8)
 25245                                  	;test	AX,STERR
 25246 00004053 C3                      	retn
 25247                                  
 25248                                  ;Break	<HardErrRW - map extended errors and call harderr>
 25249                                  ;---------------------------------------------------------------------------
 25250                                  ;
 25251                                  ; Procedure Name : HardErrRW
 25252                                  ;
 25253                                  ; Inputs:
 25254                                  ;	AX is error code from read or write
 25255                                  ;	Other registers set as per HARDERR
 25256                                  ; Function:
 25257                                  ;	Checks the error code for special extended
 25258                                  ;	errors and maps them if needed. Then invokes
 25259                                  ;	Harderr
 25260                                  ; Outputs:
 25261                                  ;	Of HARDERR
 25262                                  ; AX may be modified prior to call to HARDERR.
 25263                                  ; No other registers altered.
 25264                                  ;
 25265                                  ;---------------------------------------------------------------------------
 25266                                  
 25267                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25268                                  HARDERRRW:
 25269                                  	;cmp	al,0Fh
 25270 00004054 3C0F                    	CMP	AL,error_I24_wrong_disk
 25271 00004056 7512                    	JNZ	short DO_ERR			; Nothing to do
 25272                                  
 25273                                  	; MSDOS 3.3
 25274                                  	;push	ds
 25275                                  	;push	si
 25276                                  	;lds	si,[ss:CALLVIDRW]
 25277                                  	;mov	[ss:EXTERRPT+2], ds
 25278                                  	;mov	[ss:EXTERRPT], si
 25279                                  	;pop	si
 25280                                  	;pop	ds
 25281                                  
 25282                                  	; MSDOS 6.0
 25283 00004058 50                      	push	ax
 25284 00004059 36A1[7003]              	mov	ax,[SS:CALLVIDRW]		; get ptr lo  ;smr;SS Override
 25285 0000405D 36A3[2803]              	mov	[ss:EXTERRPT],ax		; set ext err ptr lo
 25286 00004061 36A1[7203]              	mov	ax,[SS:CALLVIDRW+2]		; get ptr hi from dev
 25287 00004065 36A3[2A03]              	mov	[ss:EXTERRPT+2],ax		; set ext err ptr hi
 25288 00004069 58                      	pop	ax
 25289                                  DO_ERR:
 25290                                  	;;call	HARDERR
 25291                                  	;;retn
 25292                                  	; 16/12/2022
 25293                                  	; 10/06/2019
 25294 0000406A E9761C                  	jmp	HARDERR	
 25295                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25296                                  	;call	HARDERR
 25297                                  	;retn
 25298                                  
 25299                                  ; 24/07/2018 - Retro DOS v3.0
 25300                                  
 25301                                  ;Break	<SETUP -- SETUP A DISK READ OR WRITE FROM USER>
 25302                                  ;----------------------------------------------------------------------------
 25303                                  ;
 25304                                  ; Procedure Name : SETUP
 25305                                  ;
 25306                                  ; Inputs:
 25307                                  ;	ES:DI point to SFT (value also in THISSFT)
 25308                                  ;	DMAAdd contains transfer address
 25309                                  ;	CX = Byte count
 25310                                  ;	DS = DOSDATA
 25311                                  ;   WARNING Stack must be clean, two ret addrs on stack, 1st of caller,
 25312                                  ;		2nd of caller of caller.
 25313                                  ; Outputs:
 25314                                  ;	    CX = byte count
 25315                                  ;	    [THISDPB] = Base of drive parameters if file
 25316                                  ;		      = Pointer to device header if device or NET
 25317                                  ;	    ES:DI Points to SFT
 25318                                  ;	    [NEXTADD] = Displacement of disk transfer within segment
 25319                                  ;	    [TRANS] = 0 (No transfers yet)
 25320                                  ;	    BytPos = Byte position in file
 25321                                  ;
 25322                                  ;	The following fields are relevant to local files (not devices) only:
 25323                                  ;
 25324                                  ;	    SecPos = Position of first sector (local files only)
 25325                                  ;	    [BYTSECPOS] = Byte position in first sector (local files only)
 25326                                  ;	    [CLUSNUM] = First cluster (local files only)
 25327                                  ;	    [SECCLUSPOS] = Sector within first cluster (local files only)
 25328                                  ;	    [THISDRV] = Physical unit number (local files only)
 25329                                  ;
 25330                                  ;      RETURNS ONE LEVEL UP WITH:
 25331                                  ;	   CX = 0
 25332                                  ;	   CARRY = Clear
 25333                                  ;	IF AN ERROR IS DETECTED
 25334                                  ; All other registers destroyed
 25335                                  ;----------------------------------------------------------------------------
 25336                                  
 25337                                  ;hkn; called from disk.asm. DS has been set up to DOSDATA.
 25338                                  
 25339                                  ; DOSCODE:770Bh (MSDOS 6.21, MSDOS.SYS)
 25340                                  
 25341                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25342                                  ; DOSCODE:76F7h (MSDOS 5.0, MSDOS.SYS)
 25343                                  
 25344                                  SETUP:
 25345                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 411Bh
 25346                                  
 25347                                  	;lds 	si,[es:di+7]
 25348 0000406D 26C57507                	LDS	SI,[ES:DI+SF_ENTRY.sf_devptr]
 25349                                  
 25350                                  ;hkn; SS override
 25351 00004071 368C1E[8C05]            	MOV	[SS:THISDPB+2],DS
 25352                                  
 25353                                  ;hkn; SS is DOSDATA
 25354 00004076 16                      	push	ss
 25355 00004077 1F                      	pop	ds
 25356                                  
 25357 00004078 8936[8A05]              	MOV	[THISDPB],SI
 25358                                  
 25359 0000407C 8B1E[2C03]              	MOV	BX,[DMAADD]
 25360 00004080 891E[B805]              	MOV	[NEXTADD],BX		;Set NEXTADD to start of Xaddr
 25361 00004084 C606[7405]00            	MOV	BYTE [TRANS],0		;No transferes
 25362                                  	;mov	ax,[es:di+15h]
 25363 00004089 268B4515                	MOV	AX,[ES:DI+SF_ENTRY.sf_position]
 25364                                  	;mov	dx,[es:di+17h]
 25365 0000408D 268B5517                	MOV	DX,[ES:DI+SF_ENTRY.sf_position+2]
 25366 00004091 8916[D005]              	MOV	[BYTPOS+2],DX		;Set it
 25367 00004095 A3[CE05]                	MOV	[BYTPOS],AX
 25368                                  	;test	word [es:di+5],8080h
 25369 00004098 26F745058080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet+devid_device
 25370 0000409E 753C                    	JNZ	short NOSETSTUFF	;Following not done on devs or NET
 25371 000040A0 06                      	PUSH	ES
 25372 000040A1 C42E[8A05]              	LES	BP,[THISDPB]		;Point at the DPB
 25373                                  
 25374                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25375                                  	;;mov	bl,[es:bp+0]
 25376                                  	;MOV	BL,[ES:BP+DPB.DRIVE]
 25377                                  	; 05/12/2022
 25378 000040A5 268A5E00                	mov	bl,[es:bp]
 25379                                  	
 25380 000040A9 881E[7605]              	MOV	[THISDRV],BL		;Set THISDRV
 25381                                  	;mov	bx,[es:bp+2]
 25382 000040AD 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
 25383                                  
 25384                                  	;; MSDOS 3.3
 25385                                  	;cmp	dx,bx
 25386                                  	;jnb	short EOFERR
 25387                                  	;div	bx
 25388                                  	;mov	[SECPOS],ax
 25389                                  	;mov	[BYTSECPOS],dx
 25390                                  	;mov	dx,ax
 25391                                  	;;and	al,[es:bp+4]
 25392                                  	;AND	AL,[ES:BP+DPB.CLUSTER_MASK]
 25393                                  	;mov	[SECCLUSPOS],al
 25394                                  	;mov	ax,cx
 25395                                  	;;mov	cl,[es:bp+5]
 25396                                  	;MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 25397                                  	;shr	dx,cl
 25398                                  	;mov	[CLUSNUM],dx
 25399                                  	;pop	es
 25400                                  	;mov	cx,ax
 25401                                  
 25402                                  	; 04/05/2019 - Retro DOS v4.0
 25403                                  
 25404                                  	; MSDOS 6.0
 25405                                  ;M039: Optimized this section.
 25406 000040B1 51                              PUSH    CX			;SHR32 and DIV32 use CX.
 25407 000040B2 E83405                  	call	DIV32			;DX:AX/BX = CX:AX + DX (rem)
 25408 000040B5 8916[CC05]              	MOV	[BYTSECPOS],DX
 25409 000040B9 A3[C405]                	MOV	[SECPOS],AX
 25410 000040BC 890E[C605]              	MOV	[SECPOS+2],CX
 25411 000040C0 89CA                    	MOV	DX,CX
 25412                                  
 25413 000040C2 89C3                    	MOV	BX,AX
 25414                                  	;and	bl,[es:bp+4]
 25415 000040C4 26225E04                	AND	BL,[ES:BP+DPB.CLUSTER_MASK]
 25416 000040C8 881E[7305]              	MOV	[SECCLUSPOS],BL
 25417                                  
 25418 000040CC E84105                  	call	SHR32			;(DX:AX SHR dpb_cluster_shift)
 25419 000040CF 59                      	POP	CX			;CX = byte count.
 25420 000040D0 751F                    	JNZ	short EOFERR		;cluster number above 64k
 25421                                  	;cmp	ax,[es:bp+0Dh]
 25422 000040D2 263B460D                	CMP	AX,[ES:BP+DPB.MAX_CLUSTER] ;>32mb  if > disk size ;AN000;
 25423 000040D6 7719                    	JA	short EOFERR		   ;>32mb  then EOF       ;AN000;
 25424                                  
 25425 000040D8 A3[BC05]                	MOV	[CLUSNUM],AX
 25426 000040DB 07                      	POP	ES			; ES:DI point to SFT
 25427                                  ;M039
 25428                                  
 25429                                  NOSETSTUFF:
 25430 000040DC 89C8                    	MOV	AX,CX		; AX = Byte count.
 25431 000040DE 0306[2C03]              	ADD	AX,[DMAADD]	; See if it will fit in one segment
 25432 000040E2 730C                    	JNC	short setup_OK	; Must be less than 64
 25433 000040E4 A1[2C03]                	MOV	AX,[DMAADD]
 25434 000040E7 F7D8                    	NEG	AX		; Amount of room left in segment (know
 25435                                  				;    less than 64K since max value of CX
 25436                                  				;    is FFFF).
 25437 000040E9 7501                    	JNZ	short NoDec
 25438 000040EB 48                      	DEC	AX
 25439                                  NoDec:
 25440 000040EC 89C1                    	MOV	CX,AX		; Can do this much
 25441 000040EE E304                    	JCXZ	NOROOM		; Silly user gave Xaddr of FFFF in segment
 25442                                  setup_OK:
 25443 000040F0 C3                      	retn
 25444                                  
 25445                                  EOFERR:
 25446 000040F1 07                      	POP	ES		; ES:DI point to SFT
 25447 000040F2 31C9                    	XOR	CX,CX		; No bytes read
 25448                                  ;;;;;;;;;;; 7/18/86
 25449                                  	; MSDOS 3.3
 25450                                  	;MOV	BYTE [DISK_FULL],1 ; set disk full flag
 25451                                  ;;;;;;;;;;;
 25452                                  NOROOM:
 25453 000040F4 5B                      	POP	BX		; Kill return address
 25454 000040F5 F8                      	CLC
 25455 000040F6 C3                      	retn			; RETURN TO CALLER OF CALLER
 25456                                  
 25457                                  ;Break	<BREAKDOWN -- CUT A USER READ OR WRITE INTO PIECES>
 25458                                  ;---------------------------------------------------------------------------
 25459                                  ;
 25460                                  ; Procedure Name : BREAKDOWN
 25461                                  ;
 25462                                  ; Inputs:
 25463                                  ;	CX = Length of disk transfer in bytes
 25464                                  ;	ES:BP = Base of drive parameters
 25465                                  ;	[BYTSECPOS] = Byte position within first sector
 25466                                  ;	DS = DOSDATA
 25467                                  ; Outputs:
 25468                                  ;	[BYTCNT1] = Bytes to transfer in first sector
 25469                                  ;	[SECCNT] = No. of whole sectors to transfer
 25470                                  ;	[BYTCNT2] = Bytes to transfer in last sector
 25471                                  ; AX, BX, DX destroyed. No other registers affected.
 25472                                  ;---------------------------------------------------------------------------
 25473                                  
 25474                                  BREAKDOWN:
 25475 000040F7 A1[CC05]                	MOV	AX,[BYTSECPOS]
 25476 000040FA 89CB                    	MOV	BX,CX
 25477 000040FC 09C0                    	OR	AX,AX
 25478 000040FE 740E                    	JZ	short SAVFIR	; Partial first sector?
 25479                                  	;sub	ax,[es:bp+2]
 25480 00004100 262B4602                	SUB	AX,[ES:BP+DPB.SECTOR_SIZE]
 25481 00004104 F7D8                    	NEG	AX		; Max number of bytes left in first sector
 25482 00004106 29C3                    	SUB	BX,AX		; Subtract from total length
 25483 00004108 7304                    	JAE	short SAVFIR
 25484 0000410A 01D8                    	ADD	AX,BX		; Don't use all of the rest of the sector
 25485 0000410C 31DB                    	XOR	BX,BX		; And no bytes are left
 25486                                  SAVFIR:
 25487 0000410E A3[D205]                	MOV	[BYTCNT1],AX
 25488 00004111 89D8                    	MOV	AX,BX
 25489 00004113 31D2                    	XOR	DX,DX
 25490                                  	;div	word [ES:BP+2]
 25491 00004115 26F77602                	DIV	word [ES:BP+DPB.SECTOR_SIZE]  ; How many whole sectors?
 25492 00004119 A3[D605]                	MOV	[SECCNT],AX
 25493 0000411C 8916[D405]              	MOV	[BYTCNT2],DX	; Bytes remaining for last sector
 25494                                  	; MSDOS 3.3
 25495                                  	;OR	DX,[BYTCNT1]	; SMR ONESECTORFIX BUGBUG
 25496                                  	;retnz			; NOT (BYTCNT1 = BYTCNT2 = 0)
 25497                                  	;CMP	AX,1
 25498                                  	;retnz
 25499                                  	;MOV	AX,[ES:BP+DPB.SECTOR_SIZE] ; Buffer EXACT one sector I/O
 25500                                  	;MOV	[BYTCNT2],AX
 25501                                  	;MOV	[SECCNT],DX	; DX = 0
 25502                                  _RET45:
 25503 00004120 C3                      	retn
 25504                                  
 25505                                  ; DOSCODE:77BFh (MSDOS 6.21, MSDOS.SYS)
 25506                                  
 25507                                  ;----------------------------------------------------------------------------
 25508                                  ;
 25509                                  ; Procedure Name : READ_LOCK_VIOLATION
 25510                                  ;
 25511                                  ; ES:DI points to SFT. This entry used by NET_READ
 25512                                  ; Carry set if to return error (CX=0,AX=error_sharing_violation).
 25513                                  ; Else do retrys.
 25514                                  ; ES:DI,DS,CX preserved
 25515                                  ;
 25516                                  ;----------------------------------------------------------------------------
 25517                                  
 25518                                  READ_LOCK_VIOLATION:
 25519 00004121 C606[7505]00            	MOV	byte [READOP],0
 25520                                  ERR_ON_CHECK:
 25521                                  	;;test	word [es:di+2],8000h
 25522                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 25523                                  	;JNZ	short HARD_ERR
 25524                                  
 25525                                  	; 04/05/2019
 25526                                  	;test	byte [es:di+3],80h
 25527 00004126 26F6450380              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 25528 0000412B 7508                    	JNZ	short HARD_ERR
 25529                                  
 25530                                  	;PUSH	CX
 25531                                  	;;mov	cl,[es:di+2]
 25532                                  	;MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
 25533                                  	;;and	cl,0F0h
 25534                                  	;AND	CL,SHARING_MASK
 25535                                  	;;cmp	cl,0
 25536                                  	;CMP	CL,SHARING_COMPAT
 25537                                  	;POP	CX
 25538                                  	;JNE	short NO_HARD_ERR
 25539                                  	; 21/09/2023
 25540 0000412D 268A4502                	mov	al,[ES:DI+SF_ENTRY.sf_mode]
 25541 00004131 24F0                    	and	al,SHARING_MASK
 25542                                  	;cmp	al,SHARING_COMPAT
 25543                                  	;jne	short NO_HARD_ERR
 25544 00004133 7505                    	jnz	short NO_HARD_ERR
 25545                                  HARD_ERR:
 25546 00004135 E8F33B                  	call	LOCK_VIOLATION
 25547 00004138 73E6                    	jnc	short _RET45		; User wants Retrys
 25548                                  NO_HARD_ERR:
 25549 0000413A 31C9                    	XOR	CX,CX			;No bytes transferred
 25550                                  	;mov	ax,21h
 25551 0000413C B82100                  	MOV	AX,error_lock_violation
 25552 0000413F F9                      	STC
 25553 00004140 C3                      	retn
 25554                                  
 25555                                  ;----------------------------------------------------------------------------
 25556                                  ;
 25557                                  ; Procedure Name : WRITE_LOCK_VIOLATION
 25558                                  ;
 25559                                  ; Same as READ_LOCK_VIOLATION except for READOP.
 25560                                  ; This entry used by NET_WRITE
 25561                                  ;
 25562                                  ;----------------------------------------------------------------------------
 25563                                  
 25564                                  WRITE_LOCK_VIOLATION:
 25565 00004141 C606[7505]01            	MOV	byte [READOP],1
 25566 00004146 EBDE                    	JMP	short ERR_ON_CHECK
 25567                                  
 25568                                  ; 04/05/2019 - Retro DOS v4.0
 25569                                  
 25570                                  ; DOSCODE:77ECh (MSDOS 6.21, MSDOS.SYS)
 25571                                  
 25572                                  ;Break	<DISKREAD -- PERFORM USER DISK READ>
 25573                                  ;----------------------------------------------------------------------------
 25574                                  ;
 25575                                  ; Procedure Name : DISKREAD
 25576                                  ;
 25577                                  ; Inputs:
 25578                                  ;	Outputs of SETUP
 25579                                  ; Function:
 25580                                  ;	Perform disk read
 25581                                  ; Outputs:
 25582                                  ;    Carry clear
 25583                                  ;	CX = No. of bytes read
 25584                                  ;	ES:DI point to SFT
 25585                                  ;	SFT offset and cluster pointers updated
 25586                                  ;    Carry set
 25587                                  ;	CX = 0
 25588                                  ;	ES:DI point to SFT
 25589                                  ;	AX has error code
 25590                                  ;----------------------------------------------------------------------------
 25591                                  
 25592                                  ;hkn; called from disk.asm. DS already set up.
 25593                                  
 25594                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25595                                  ; DOSCODE:77D8h (MSDOS 5.0, MSDOS.SYS)
 25596                                  
 25597                                  DISKREAD:
 25598                                  	;mov	ax,[es:di+11h]
 25599 00004148 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]
 25600                                  	;mov	bx,[es:di+13h]
 25601 0000414C 268B5D13                	MOV	BX,[ES:DI+SF_ENTRY.sf_size+2]
 25602 00004150 2B06[CE05]              	SUB	AX,[BYTPOS]
 25603 00004154 1B1E[D005]              	SBB	BX,[BYTPOS+2]
 25604 00004158 7226                    	JB	short RDERR		;Read starts past EOF
 25605 0000415A 750A                    	JNZ	short ENUF		;More than 64k to EOF
 25606 0000415C 09C0                    	OR	AX,AX
 25607 0000415E 7420                    	JZ	short RDERR		;Read starts at EOF
 25608 00004160 39C8                    	CMP	AX,CX
 25609 00004162 7302                    	JAE	short ENUF		;I/O fits
 25610 00004164 89C1                    	MOV	CX,AX			;Limit read to up til EOF
 25611                                  ENUF:
 25612                                  	; MSDOS 3.3
 25613                                  	;test	byte [es:di+4],8
 25614                                  	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
 25615                                  	;jnz	short SET_ACC_ERR
 25616                                  	;call	LOCK_CHECK
 25617                                  	;jnb	short _READ_OK
 25618                                  	;call	READ_LOCK_VIOLATION
 25619                                  	;jnb	short ENUF
 25620                                  	;retn
 25621                                  
 25622                                  	; MSDOS 6.0
 25623 00004166 E87CFE                  	call	CHECK_READ_LOCK		;IFS. check read lock	;AN000;
 25624 00004169 7301                    	JNC	short _READ_OK 		; There are no locks
 25625 0000416B C3                      	retn
 25626                                  
 25627                                  _READ_OK:
 25628 0000416C C42E[8A05]              	LES	BP,[THISDPB]
 25629 00004170 E884FF                  	CALL	BREAKDOWN
 25630 00004173 8B0E[BC05]              	MOV	CX,[CLUSNUM]
 25631                                  
 25632 00004177 E8B214                  	call	FNDCLUS
 25633                                       	; MSDOS 6.0			;M022 conditional removed here
 25634 0000417A 720E                    	JC	short SET_ACC_ERR_DS	; fix to take care of I24 fail
 25635                                  					; migrated from 330a - HKN
 25636 0000417C 09C9                    	OR	CX,CX
 25637 0000417E 7413                    	JZ	short SKIPERR
 25638                                  RDERR:
 25639 00004180 B40E                    	MOV	AH,0EH			;MS. read/data/fail ;AN000;
 25640 00004182 E92102                  	jmp	WRTERR22
 25641                                  
 25642                                  ;RDLASTJ: 
 25643                                  	;JMP	RDLAST                  ;M039
 25644                                  
 25645                                  SETSFTJ2: 
 25646 00004185 E99600                  	JMP	SETSFT
 25647                                  
 25648                                  CANOT_READ:
 25649                                  	; MSDOS 3.3
 25650                                  	;POP	CX		;M039.
 25651                                  	; MSDOS 3.3 & MSDOS 6.0
 25652 00004188 59                      	POP	CX              ;Clean stack.
 25653 00004189 5B                      	POP	BX
 25654                                  
 25655                                  	;entry	SET_ACC_ERR_DS
 25656                                  SET_ACC_ERR_DS:
 25657                                  
 25658                                  ;hkn; SS is DOSDATA
 25659                                  	;Context DS
 25660 0000418A 16                      	push	ss
 25661 0000418B 1F                      	pop	ds
 25662                                  
 25663                                  	;entry	SET_ACC_ERR
 25664                                  SET_ACC_ERR:
 25665 0000418C 31C9                    	XOR	CX,CX
 25666                                  	;mov	ax,5
 25667 0000418E B80500                  	MOV	AX,error_access_denied
 25668 00004191 F9                      	STC
 25669 00004192 C3                      	retn
 25670                                  
 25671                                  SKIPERR:
 25672 00004193 8916[BA05]              	MOV	[LASTPOS],DX
 25673 00004197 891E[BC05]              	MOV	[CLUSNUM],BX
 25674 0000419B 833E[D205]00            	CMP	word [BYTCNT1],0
 25675 000041A0 7405                    	JZ	short RDMID
 25676                                  
 25677 000041A2 E8FD14                  	call	BUFRD
 25678 000041A5 72E3                    	JC	short SET_ACC_ERR_DS
 25679                                  
 25680                                  RDMID:
 25681 000041A7 833E[D605]00            	CMP	word [SECCNT],0
 25682                                  	;JZ	RDLAST ; 10/08/2018
 25683 000041AC 7453                    	jz	short RDLAST
 25684                                  
 25685 000041AE E88615                  	call	NEXTSEC
 25686 000041B1 72D2                    	JC	short SETSFTJ2
 25687                                  
 25688 000041B3 C606[7405]01            	MOV	BYTE [TRANS],1		; A transfer is taking place
 25689                                  ONSEC:
 25690 000041B8 8A16[7305]              	MOV	DL,[SECCLUSPOS]	; (dx/DL = Extent start) ((dh = ?))
 25691 000041BC 8B0E[D605]              	MOV	CX,[SECCNT]
 25692 000041C0 8B1E[BC05]              	MOV	BX,[CLUSNUM]
 25693                                  RDLP:
 25694 000041C4 E8A115                  	call	OPTIMIZE
 25695 000041C7 72C1                    	JC	short SET_ACC_ERR_DS
 25696                                  
 25697 000041C9 57                      	PUSH	DI                      ;DI = Next physical cluster.
 25698 000041CA 50                      	PUSH	AX                      ;AX = # of sectors remaining.
 25699 000041CB 53                      	PUSH	BX			;[DMAADD+2]:BX = Transfer address.
 25700                                  	;mov	byte [ALLOWED],38h
 25701 000041CC C606[4B03]38            	MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
 25702 000041D1 8E1E[2E03]              	MOV	DS,[DMAADD+2]
 25703                                  
 25704 000041D5 52                      	PUSH	DX                      ;[HIGH_SECTOR]:DX = phys. sector #.
 25705 000041D6 51                      	PUSH	CX                      ;CX = # of contiguous sectors to read.
 25706                                  
 25707                                  	; 04/05/2019 - Retro DOS v4.0
 25708                                  
 25709                                  	; MSDOS 6.0
 25710 000041D7 E87223                  	call	SET_RQ_SC_PARMS		;LB. do this for SC ;AN000;
 25711                                  
 25712                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25713 000041DA E8CFFD                  	call	DREAD
 25714                                  
 25715                                  	; MSDOS 3.3 
 25716                                  	;pop	bx
 25717                                  	;pop	dx
 25718                                  	;jc	short CANOT_READ
 25719                                  	;add	bx,dx	; (bx = Extent end)
 25720                                  	;mov	al,[es:bp] ; mov al,[es:bp+0]
 25721                                  	;;mov	al,[ES:BP+DPB.DRIVE] 
 25722                                  	;call	SETVISIT
 25723                                  	; ->***
 25724                                  ;M039
 25725                                  	; MSDOS 6.0 
 25726 000041DD 59                      	pop	cx
 25727 000041DE 5A                      	pop	dx
 25728 000041DF 368F06[0C06]            	pop	WORD [ss:TEMP_VAR]
 25729 000041E4 72A2                    	jc	short CANOT_READ
 25730                                  
 25731 000041E6 368C1E[0E06]            	mov	[ss:TEMP_VAR2],ds
 25732                                  
 25733                                  ;       CX = # of contiguous sectors read. (These constitute a block of
 25734                                  ;            sectors, also termed an "Extent".)
 25735                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 25736                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
 25737                                  ;       ES:BP -> Drive Parameter Block (DPB).
 25738                                  ;
 25739                                  ;	The Buffer Queue must now be scanned: the contents of any dirty
 25740                                  ;	buffers must be "read" into the transfer memory block, so that the
 25741                                  ;       transfer memory reflects the most recent data.
 25742                                  
 25743 000041EB E85E00                  	call	DskRdBufScan
 25744                                  
 25745                                  	;Context DS
 25746 000041EE 16                      	push	ss
 25747 000041EF 1F                      	pop	ds
 25748                                          
 25749 000041F0 59                      	pop	cx
 25750 000041F1 5B                              pop	bx
 25751                                  
 25752                                  ;       CX = # of sector remaining.
 25753                                  ;       BX = Next physical cluster.
 25754                                  
 25755                                  ;M039
 25756                                  
 25757                                  ;;;;;;;;
 25758                                  ;	; 25/07/2018 - Retro DOS v3.0
 25759                                  ;	; ***->
 25760                                  ;	; MSDOS 3.3
 25761                                  ;	; IBMDOS.COM (1987) - Offset 42BDh
 25762                                  ;bufq:
 25763                                  ;;	DX = Extent start.
 25764                                  ;;	BX = Extent end.
 25765                                  ;;	 AL = Drive #.
 25766                                  ;;     DS:DI-> 1st buffer in queue.
 25767                                  ;
 25768                                  ;	;or	byte [di+5],20h
 25769                                  ;	or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
 25770                                  ;	;cmp	al,[di+4]	
 25771                                  ;	cmp	al,[DI+BUFFINFO.buf_ID]
 25772                                  ;	jnz	short bufq3
 25773                                  ;	;cmp	[di+6],dx
 25774                                  ;	cmp	[DI+BUFFINFO.buf_sector],dx
 25775                                  ;	jb	short bufq3	; Jump if Extent start > buffer sector.
 25776                                  ;	;cmp	[di+6],bx
 25777                                  ;	cmp	[DI+BUFFINFO.buf_sector],bx
 25778                                  ;	jnb	short bufq3	; Jump if Extent end >= buffer sector.
 25779                                  ;	
 25780                                  ;	; Buffer sector is in the Extent (contiguous sectors to read)
 25781                                  ;
 25782                                  ;;      Buffer's sector is in Extent: if it is dirty, copy its contents to
 25783                                  ;;      transfer memory; otherwise, just re-position it in the buffer queue
 25784                                  ;;      as MRU (Most Recently Used).
 25785                                  ;
 25786                                  ;	;test	byte [di+5],40h
 25787                                  ;	test	byte [DI+BUFFINFO.buf_flags],buf_dirty ; Bit 6 = dirty flag
 25788                                  ;	jz	short bufq2	; clear buffer, check the next buff sec
 25789                                  ;	pop	ax ; transfer address
 25790                                  ;	push	ax
 25791                                  ;	push	di
 25792                                  ;	push	dx
 25793                                  ;	;sub	dx,[di+6]
 25794                                  ;	sub	dx,[DI+BUFFINFO.buf_sector]
 25795                                  ;	neg	dx
 25796                                  ;
 25797                                  ;;      DX = offset (in sectors) of buffer sector within Transfer memory
 25798                                  ;;           block.
 25799                                  ;
 25800                                  ;	mov	si,di
 25801                                  ;	mov	di,ax
 25802                                  ;	mov	ax,dx
 25803                                  ;	;mov	cx,[es:bp+6]	
 25804                                  ;	mov     cx,[ES:BP+DPB.SECTOR_SIZE] ; CX = sector size (in bytes).
 25805                                  ;	mul	cx
 25806                                  ;	add	di,ax
 25807                                  ;
 25808                                  ;	lea	si,[si+16]
 25809                                  ;	lea	si,[SI+BUFINSIZ] ;DS:SI -> buffer data.
 25810                                  ;	shr	cx,1
 25811                                  ;	push	es
 25812                                  ;	mov	es,[SS:DMAADD+2]
 25813                                  ;
 25814                                  ;;      CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
 25815                                  ;;      DS:SI-> Buffer sector data.
 25816                                  ;;      ES:DI-> Destination within Transfer memory block.
 25817                                  ;
 25818                                  ;	rep	movsw			;Copy buffer sector to Transfer memory
 25819                                  ;	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 25820                                  ;	;rep	movsb                   ;Copy last byte.
 25821                                  ;	jnc	short bufq1
 25822                                  ;	movsb
 25823                                  ;bufq1:
 25824                                  ;	pop	es
 25825                                  ;	pop	dx
 25826                                  ;	pop	di
 25827                                  ;	mov	al,[es:bp]  ; mov al,[es:bp+0]
 25828                                  ;	;mov	al,[ES:BP+DPB.DRIVE]
 25829                                  ;bufq2:
 25830                                  ;	call	SCANPLACE
 25831                                  ;bufq3:
 25832                                  ;	call	SKIPVISIT
 25833                                  ;	jnz	short bufq
 25834                                  ;	
 25835                                  ;	push	ss
 25836                                  ;	pop	ds
 25837                                  ;	pop	cx
 25838                                  ;	pop	cx
 25839                                  ;	pop	bx	
 25840                                  ;bufq4:
 25841                                  ;;;;;;;
 25842 000041F2 E30D                    	JCXZ	RDLAST
 25843                                  
 25844 000041F4 E80F1D                  	call	IsEOF			; test for eof on fat size
 25845 000041F7 7325                    	JAE	short SETSFT
 25846                                  
 25847 000041F9 B200                    	MOV	DL,0
 25848 000041FB FF06[BA05]              	INC	word [LASTPOS]		; We'll be using next cluster
 25849 000041FF EBC3                    	JMP	short RDLP ; 19/05/2019
 25850                                  
 25851                                  RDLAST:
 25852 00004201 A1[D405]                	MOV	AX,[BYTCNT2]
 25853 00004204 09C0                    	OR	AX,AX
 25854 00004206 7416                    	JZ	short SETSFT
 25855 00004208 A3[D205]                	MOV	[BYTCNT1],AX
 25856                                  
 25857 0000420B E82915                  	call	NEXTSEC
 25858 0000420E 720E                    	JC	short SETSFT
 25859                                  
 25860 00004210 C706[CC05]0000          	MOV	word [BYTSECPOS],0
 25861 00004216 E88914                  	call	BUFRD
 25862                                  	; 10/08/2018
 25863                                  
 25864 00004219 7303                    	JNC	short SETSFT
 25865 0000421B E96CFF                  	JMP	SET_ACC_ERR_DS
 25866                                  
 25867                                  ;------------------------------------------------------------------------------
 25868                                  ;
 25869                                  ; Procedure Name : SETSFT
 25870                                  ; Inputs:
 25871                                  ;	[NEXTADD],[CLUSNUM],[LASTPOS] set to determine transfer size
 25872                                  ;		and set cluster fields
 25873                                  ; Function:
 25874                                  ;	Update [THISSFT] based on the transfer
 25875                                  ; Outputs:
 25876                                  ;	sf_position, sf_lstclus, and sf_cluspos updated
 25877                                  ;	ES:DI points to [THISSFT]
 25878                                  ;	CX No. of bytes transferred
 25879                                  ;	Carry clear
 25880                                  ;
 25881                                  ;----------------------------------------------------------------------------
 25882                                  
 25883                                  	;entry	SETSFT
 25884                                  
 25885                                  ; 26/07/2018 - Retro DOS v3.0
 25886                                  SETSFT:
 25887 0000421E C43E[9E05]              	LES	DI,[THISSFT]
 25888                                  
 25889                                  ; Same as SETSFT except ES:DI already points to SFT
 25890                                  	;entry	SETCLUS
 25891                                  SETCLUS:	
 25892 00004222 8B0E[B805]              	MOV	CX,[NEXTADD]
 25893 00004226 2B0E[2C03]              	SUB	CX,[DMAADD]		; Number of bytes transfered
 25894                                  	;;test	word [es:di+5],80h
 25895                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 25896                                  	;JNZ	short ADDREC		; don't set clusters if device
 25897                                  
 25898                                  	; 04/05/2019 - Retro DOS v4.0
 25899                                  	;test	byte [es:di+5],80h
 25900 0000422A 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 25901 0000422F 750E                    	JNZ	short ADDREC		; don't set clusters if device
 25902                                  
 25903 00004231 A1[BC05]                	MOV	AX,[CLUSNUM]
 25904                                  	;;mov	[es:di+1Bh],ax ; MSDOS 3.3
 25905                                  	;mov	[es:di+35h],ax ; MSDOS 6.0 (& MSDOS 6.21)
 25906 00004234 26894535                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
 25907 00004238 A1[BA05]                	MOV	AX,[LASTPOS]
 25908                                  	;mov	[es:di+19h],ax
 25909 0000423B 26894519                	MOV	[ES:DI+SF_ENTRY.sf_cluspos],AX
 25910                                  
 25911                                  ;----------------------------------------------------------------------------
 25912                                  ;
 25913                                  ; Procedure : AddRec
 25914                                  ; Inputs:
 25915                                  ;	ES:DI points to SFT
 25916                                  ;	CX is No. Bytes transferred
 25917                                  ; Function:
 25918                                  ;	Update the SFT offset based on the transfer
 25919                                  ; Outputs:
 25920                                  ;	sf_position updated to point to first byte after transfer
 25921                                  ;	ES:DI points to SFT
 25922                                  ;	CX No. of bytes transferred
 25923                                  ;	Carry clear
 25924                                  ;----------------------------------------------------------------------------
 25925                                  
 25926                                  	;entry	AddRec
 25927                                  ADDREC:
 25928 0000423F E309                    	JCXZ	RET28		; If no records read,  don't change position
 25929                                  	;add	[es:di+15h],cx
 25930 00004241 26014D15                	ADD	[ES:DI+SF_ENTRY.sf_position],CX  ; Update current position
 25931                                  	;adc	word [es:di+17h], 0
 25932 00004245 2683551700              	ADC	WORD [ES:DI+SF_ENTRY.sf_position+2],0
 25933                                  RET28:	
 25934 0000424A F8                      	CLC
 25935 0000424B C3                      	retn
 25936                                  
 25937                                  ; 25/07/2018
 25938                                  ; MSDOS 6.0
 25939                                  ;Break   <DskRdBufScan -- Disk Read Buffer Scan>
 25940                                  ;----------------------------------------------------------------------------
 25941                                  ;
 25942                                  ; Procedure Name : DskRdBufScan
 25943                                  ;
 25944                                  ; Inputs:
 25945                                  ;       CX = # of contiguous sectors read. (These constitute a block of
 25946                                  ;            sectors, also termed an "Extent".)
 25947                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 25948                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
 25949                                  ;       ES:BP -> Drive Parameter Block (DPB).
 25950                                  ;
 25951                                  ; Function:
 25952                                  ;	The Buffer Queue is scanned: the contents of any dirty buffers are
 25953                                  ;	"read" into the transfer memory block, so that the transfer memory
 25954                                  ;	reflects the most recent data.
 25955                                  ;
 25956                                  ; Outputs:
 25957                                  ;       Transfer memory updated as required.
 25958                                  ;
 25959                                  ; Uses:
 25960                                  ;       DS,AX,BX,CX,SI,DI destroyed.
 25961                                  ;       SS override for all global variables.
 25962                                  ;
 25963                                  ; Notes:
 25964                                  ;       FIRST_BUFF_ADDR is set-up to contain the LAST buffer to check, rather
 25965                                  ;	than the FIRST.
 25966                                  ;----------------------------------------------------------------------------
 25967                                  ;M039: Created
 25968                                  
 25969                                  ; 04/05/2019 - Retro DOS v4.0
 25970                                  ; DOSCODE:78F0h (MSDOS 6.21, MSDOS.SYS)
 25971                                  
 25972                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25973                                  ; DOSCODE:78DCh (MSDOS 5.0, MSDOS.SYS) 
 25974                                  
 25975                                  ;procedure DskRdBufScan,NEAR
 25976                                  ;
 25977                                  ;ASSUME  DS:NOTHING
 25978                                  
 25979                                  DskRdBufScan:
 25980 0000424C 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0 ; Any dirty buffers?
 25981 00004252 743C                    	je	short bufx		     ; -no, skip all work.
 25982                                  
 25983 00004254 368B1E[0706]            	mov     bx,[ss:HIGH_SECTOR]
 25984 00004259 89DE                    	mov     si,bx
 25985 0000425B 01D1                    	add     cx,dx
 25986 0000425D 83D600                  	adc     si,0
 25987                                  
 25988 00004260 E88120                  	call	GETCURHEAD		;DS:DI -> 1st buf in queue.
 25989                                  	;mov	ax,[di+2]
 25990 00004263 8B4502                  	mov     ax,[di+BUFFINFO.buf_prev]
 25991 00004266 36A3[A512]              	mov     [ss:FIRST_BUFF_ADDR],ax
 25992                                  		
 25993                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25994                                  	;;mov	al,[es:bp+0]
 25995                                  	;mov	al,[es:bp+DPB.DRIVE]
 25996                                  	; 15/12/2022
 25997 0000426A 268A4600                	mov	al,[es:bp]
 25998                                  
 25999                                  ;       BX:DX = Extent start.
 26000                                  ;       SI:CX = Extent end + 1.
 26001                                  ;          AL = Drive #.
 26002                                  ;       DS:DI-> 1st buffer in queue.
 26003                                  ;[FIRST_BUFF_ADDR] = Address offset of last buffer in queue.
 26004                                  
 26005                                  bufq:	
 26006                                  	;cmp	al,[di+4]
 26007 0000426E 3A4504                  	cmp     al,[di+BUFFINFO.buf_ID] ;Same drive?
 26008 00004271 7514                    	jne	short bufq1        	;  -no, jump.
 26009                                  
 26010                                  ;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 26011                                  ;       ja	short bufq1		;Jump if Extent start > buffer sector.
 26012                                  
 26013                                  	;cmp	bx,[di+8]
 26014 00004273 3B5D08                  	cmp	bx,[di+BUFFINFO.buf_sector+2]
 26015 00004276 7503                    	jne	short bufq01
 26016                                  	;cmp	dx,[di+6]
 26017 00004278 3B5506                  	cmp	dx,[di+BUFFINFO.buf_sector]
 26018                                  bufq01:
 26019 0000427B 770A                    	ja	short bufq1
 26020                                  
 26021                                  ;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 26022                                  ;       ja	short bufq2		;Jump if Extent end >= buffer sector.
 26023                                  
 26024                                  	;cmp	si,[di+8]
 26025 0000427D 3B7508                  	cmp	si,[di+BUFFINFO.buf_sector+2]
 26026 00004280 7503                    	jne	short bufq02
 26027                                  	;cmp	cx,[di+6]
 26028 00004282 3B4D06                  	cmp	cx,[di+BUFFINFO.buf_sector]
 26029                                  bufq02:
 26030 00004285 770A                    	ja	short bufq2
 26031                                  bufq1:	
 26032 00004287 363B3E[A512]            	cmp     di,[ss:FIRST_BUFF_ADDR]	;Scanned entire buffer queue?
 26033 0000428C 8B3D                    	mov	di,[di]
 26034                                  	;mov	di,[di+BUFFINFO.buf_next] ; Set-up for next buffer.
 26035 0000428E 75DE                    	jne	short bufq		; -no, do next buffer
 26036                                  bufx:
 26037 00004290 C3                      	retn				;Exit.
 26038                                  
 26039                                  ;       Buffer's sector is in Extent: if it is dirty, copy its contents to
 26040                                  ;	transfer memory; otherwise, just re-position it in the buffer queue
 26041                                  ;       as MRU (Most Recently Used).
 26042                                  
 26043                                  bufq2:	
 26044 00004291 50                      	push	ax
 26045                                  	;test	byte [di+5],40h
 26046 00004292 F6450540                	test	byte [di+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty?
 26047 00004296 742D                    	jz	short bufq3                    ; -no, jump.
 26048                                  
 26049                                  ;       SaveReg <cx,dx,si,di,es>
 26050 00004298 51                      	push	cx
 26051 00004299 52                      	push	dx
 26052 0000429A 56                      	push	si
 26053 0000429B 57                      	push	di
 26054 0000429C 06                      	push	es
 26055                                  
 26056 0000429D 89D0                    	mov     ax,dx
 26057                                  	;sub	ax,[di+6]
 26058 0000429F 2B4506                  	sub	ax,[di+BUFFINFO.buf_sector]
 26059 000042A2 F7D8                    	neg	ax
 26060                                  
 26061                                  ;       AX = offset (in sectors) of buffer sector within Transfer memory
 26062                                  ;            block. (Note: the upper word of the sector # may be ignored
 26063                                  ;	     since no more than 64k bytes will ever be read. This 64k limit
 26064                                  ;            is imposed by the input parameters of the disk read operation.)
 26065                                  
 26066                                  	;lea	si,[di+20]
 26067 000042A4 8D7518                  	lea	si,[di+BUFINSIZ]	;DS:SI -> buffer data.
 26068                                  	;mov	cx,[es:bp+2]
 26069 000042A7 268B4E02                	mov     cx,[es:bp+DPB.SECTOR_SIZE] ;CX = sector size (in bytes).
 26070 000042AB F7E1                    	mul     cx			;AX = offset (in bytes) of buf. sector
 26071 000042AD 368B3E[0C06]            	mov     di,[ss:TEMP_VAR]
 26072 000042B2 01C7                    	add	di,ax
 26073 000042B4 368E06[0E06]            	mov	es,[ss:TEMP_VAR2]
 26074 000042B9 D1E9                    	shr	cx,1
 26075                                  
 26076                                  ;	   CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
 26077                                  ;       DS:SI-> Buffer sector data.
 26078                                  ;       ES:DI-> Destination within Transfer memory block.
 26079                                  
 26080 000042BB F3A5                    	rep	movsw			;Copy buffer sector to Transfer memory
 26081                                  	;; 04/05/2019
 26082                                  	;;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 26083                                  	;;rep	movsb                   ;Copy last byte.
 26084                                  	;jnc	short bufq03	
 26085                                  	;movsb
 26086                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26087                                  	;adc	cx,0
 26088                                  	;rep	movsb
 26089                                  	; 22/09/2023
 26090 000042BD 7301                    	jnc	short bufq03
 26091 000042BF A4                      	movsb
 26092                                  bufq03:
 26093                                  	;RestoreReg <es,di,si,dx,cx>
 26094 000042C0 07                      	pop	es
 26095 000042C1 5F                      	pop	di
 26096 000042C2 5E                      	pop	si
 26097 000042C3 5A                      	pop	dx
 26098 000042C4 59                      	pop	cx
 26099                                  
 26100                                  ;       DS:DI -> current buffer.
 26101                                  bufq3:	
 26102 000042C5 89F8                    	mov     ax,di			;DS:AX -> Current buffer.
 26103                                          ;invoke SCANPLACE
 26104 000042C7 E82C20                  	call	SCANPLACE
 26105 000042CA 363B06[A512]            	cmp	ax,[ss:FIRST_BUFF_ADDR] ;Last buffer?
 26106 000042CF 58                      	pop	ax
 26107                                  	;jne	short bufq		; -no, jump.
 26108                                  	;;jmp	short bufx		; -yes, exit.
 26109                                  	;; 12/06/2019
 26110                                  	;retn
 26111                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compability)
 26112 000042D0 759C                    	jne	short bufq
 26113 000042D2 EBBC                    	jmp	short bufx
 26114                                  
 26115                                  ;EndProc DskRdBufScan
 26116                                  
 26117                                  ;============================================================================
 26118                                  ; DISK3.ASM, MSDOS 6.0, 1991
 26119                                  ;============================================================================
 26120                                  ; 04/05/2019 - Retro DOS v4.0
 26121                                  ; 24/07/2018 - Retro DOS v3.0
 26122                                  
 26123                                  ;Break   <DISKWRITE -- PERFORM USER DISK WRITE>
 26124                                  ;----------------------------------------------------------------------------
 26125                                  ;
 26126                                  ; Procedure Name : DISKWRITE
 26127                                  ;
 26128                                  ; Inputs:
 26129                                  ;       Outputs of SETUP
 26130                                  ; Function:
 26131                                  ;       Perform disk write
 26132                                  ; Outputs:
 26133                                  ;    Carry clear
 26134                                  ;       CX = No. of bytes written
 26135                                  ;       ES:DI point to SFT
 26136                                  ;       SFT offset and cluster pointers updated
 26137                                  ;    Carry set
 26138                                  ;       CX = 0
 26139                                  ;       ES:DI point to SFT
 26140                                  ;       AX has error code
 26141                                  ;----------------------------------------------------------------------------
 26142                                  
 26143                                  ;hkn; called by DOS_WRITE. DS already set up at this point.
 26144                                  
 26145                                  ; DOSCODE:797Ah (MSDOS 6.21, MSDOS.SYS)
 26146                                  
 26147                                  ; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26148                                  ; DOSCODE:7966h (MSDOS 5.0, MSDOS.SYS) 
 26149                                  
 26150                                  DISKWRITE:
 26151                                  	; MSDOS 3.3
 26152                                  	; IBMDOS.COM - Offset 436Dh
 26153                                  	;;test	byte [es:di+4],8
 26154                                  	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
 26155                                  	;jz	short write_cont
 26156                                  	;jmp	SET_ACC_ERR_DS
 26157                                  ;write_cont:
 26158                                  	;push	cx
 26159                                  	;or	cx,cx
 26160                                  	;jnz	short Not_Truncate
 26161                                  	;;mov	cx,-1
 26162                                  	;dec	cx
 26163                                  ;Not_Truncate:
 26164                                  	;call	LOCK_CHECK
 26165                                  	;pop	cx
 26166                                  	;jnb	short _WRITE_OK
 26167                                  	;call	WRITE_LOCK_VIOLATION
 26168                                  	;jnb	short DISKWRITE
 26169                                  	;retn
 26170                                  
 26171                                  	; MSDOS 6.0
 26172 000042D4 E8F0FC                  	call	CHECK_WRITE_LOCK	;IFS. check write lock	;AN000;
 26173                                  	; 19/08/2018
 26174 000042D7 7304                    	JNC	short _WRITE_OK		;IFS. lock check ok	;AN000;
 26175 000042D9 C3                      	retn
 26176                                  
 26177                                  WRTEOFJ:
 26178 000042DA E9DC01                  	JMP     WRTEOF
 26179                                  
 26180                                  _WRITE_OK:
 26181                                   	; 27/07/2018
 26182                                  	; IBMDOS.COM - Offset 438Eh
 26183                                  	
 26184                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26185                                  	;and	word [es:di+5],0BFBFh
 26186 000042DD 26816505BFBF            	AND     word [ES:DI+SF_ENTRY.sf_flags],~(sf_close_nodate|devid_file_clean)
 26187                                  				; Mark file as dirty, clear no date on close
 26188                                  
 26189                                  	; 04/05/2019 - Retro DOS v4.0	
 26190                                  
 26191                                  	; MSDOS 6.0
 26192                                  	; mov 	ax,[es:di+11h]
 26193 000042E3 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]		;M039
 26194 000042E7 A3[0C06]                        MOV	[TEMP_VAR],AX                           ;M039
 26195                                  	;mov	ax,[es:di+13h]
 26196 000042EA 268B4513                	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]		;M039
 26197 000042EE A3[0E06]                        MOV	[TEMP_VAR2],AX                          ;M039
 26198                                  
 26199                                  ;	TEMP_VAR2:TEMP_VAR = Current file size (sf_size);M039
 26200                                  
 26201                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26202 000042F1 C42E[8A05]              	LES     BP,[THISDPB]
 26203                                  
 26204 000042F5 E8FFFD                  	call	BREAKDOWN
 26205                                  
 26206 000042F8 A1[CE05]                	MOV     AX,[BYTPOS]
 26207 000042FB 8B16[D005]              	MOV     DX,[BYTPOS+2]
 26208 000042FF E3D9                    	JCXZ    WRTEOFJ                 ;Make the file length = sf_position
 26209 00004301 01C8                    	ADD     AX,CX
 26210 00004303 83D200                  	ADC     DX,0                    ;DX:AX = last byte to write + 1.
 26211                                  
 26212                                  	;mov	bx,[es:bp+2]
 26213 00004306 268B5E02                	MOV     BX,[ES:BP+DPB.SECTOR_SIZE]
 26214                                  
 26215                                  	; MSDOS 3.3
 26216                                  	;cmp	dx,bx
 26217                                  	;jnb	short WRTERR33
 26218                                  	;div	bx
 26219                                  	;mov	bx,ax
 26220                                  	;OR	DX,DX
 26221                                  	;JNZ	short CALCLUS
 26222                                  	;dec	ax
 26223                                  ;CALCLUS:
 26224                                  	; MSDOS 3.3
 26225                                  	;mov	cl,[es:bp+5]
 26226                                  	;MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 26227                                  	;shr	ax,cl
 26228                                  	;push	ax
 26229                                  	;push	dx
 26230                                  	;push	es
 26231                                  	;les	di,[THISSFT]
 26232                                  	;;mov	ax,[es:di+11h]
 26233                                  	;;mov	dx,[es:di+13h]
 26234                                  	;mov	ax,[ES:DI+SF_ENTRY.sf_size]
 26235                                  	;mov	dx,[ES:DI+SF_ENTRY.sf_size+2]
 26236                                  	;pop	es
 26237                                  	;;DX:AX = current file size (in bytes).
 26238                                  	;;div	word [es:bp+2]
 26239                                  	;div	word [ES:BP+DPB.SECTOR_SIZE]
 26240                                  	;mov	cx,ax
 26241                                  	;or	dx,dx
 26242                                  	;jz	short NORND
 26243                                  	;inc	ax
 26244                                  ;NORND:
 26245                                  	; MSDOS 6.0
 26246 0000430A E8DC02                  	CALL	DIV32                   ;DX:AX/BX = CX:AX + DX (rem.).
 26247 0000430D 89C6                    	MOV	SI,AX
 26248 0000430F 890E[0706]                      MOV	[HIGH_SECTOR],CX
 26249                                  
 26250                                  ;       [HIGH_SECTOR]:SI = Last full sector to write.
 26251                                  
 26252 00004313 09D2                    	OR	DX,DX
 26253 00004315 52                      	PUSH	DX			;M039: Free DX for use by SHR32
 26254 00004316 89CA                    	MOV	DX,CX			;M039
 26255 00004318 7506                    	JNZ	short CALCLUS
 26256 0000431A 83E801                  	SUB	AX,1                    ;AX must be zero base indexed	;AC000;
 26257 0000431D 83DA00                  	SBB	DX,0			;M039 ;F.C. >32mb		;AN000;
 26258                                  
 26259                                  CALCLUS:
 26260                                  	; MSDOS 6.0
 26261 00004320 E8ED02                  	CALL	SHR32                   ;F.C. >32mb			;AN000;
 26262 00004323 5A                      	POP	DX
 26263                                  
 26264                                  ;       AX = Last cluster to write.
 26265                                  ;       DX = # of bytes in last sector to write (the "tail").
 26266                                  ;       BX = [ES:BP+DPB.SECTOR_SIZE]
 26267                                  
 26268 00004324 50                      	PUSH	AX
 26269 00004325 52                      	PUSH	DX
 26270                                  ;M039
 26271 00004326 8B16[0E06]              	mov	dx,[TEMP_VAR2]
 26272 0000432A A1[0C06]                	mov	ax,[TEMP_VAR]           ;DX:AX = current file size (in bytes).
 26273 0000432D E8B902                  	call	DIV32           	;DX:AX/BX = CX:AX + DX (rem.)
 26274 00004330 890E[0E06]              	mov	[TEMP_VAR2],cx
 26275 00004334 890E[CA05]              	mov	[VALSEC+2],cx
 26276 00004338 89C1                    	mov	cx,ax
 26277 0000433A 89F3                    	mov	bx,si
 26278                                  
 26279                                  ;       [HIGH_SECTOR]:BX = Last full sector to write.
 26280                                  ;          [VALSEC+2]:CX = Last full sector of current file.
 26281                                  ;         [TEMP_VAR2]:CX = Last full sector of current file.
 26282                                  ;                     DX = # of bytes in last sector of current file.
 26283                                  ;M039
 26284 0000433C 09D2                    	OR	DX,DX
 26285 0000433E 7407                    	JZ	short NORND
 26286                                  	;ADD	AX,1            	;Round up if any remainder	;AC000;
 26287                                  	;ADC	word [VALSEC+2],0
 26288                                  	; 22/09/2023
 26289 00004340 40                      	inc	ax  ; 0FFFFh -> 0
 26290 00004341 7504                    	jnz	short NORND
 26291 00004343 FF06[CA05]              	inc	word [VALSEC+2]
 26292                                  NORND:	
 26293                                  	; MSDOS 3.3 & MSDOS 6.0
 26294 00004347 A3[C805]                	MOV     [VALSEC],AX
 26295                                  
 26296                                  ;       [VALSEC] = Last sector of current file.
 26297                                  
 26298 0000434A 31C0                    	XOR     AX,AX
 26299 0000434C A3[DE05]                	MOV     [GROWCNT],AX
 26300 0000434F A3[E005]                	MOV     [GROWCNT+2],AX
 26301 00004352 58                      	POP     AX
 26302                                  
 26303                                  	; MSDOS 6.0
 26304 00004353 8B3E[0706]              	MOV	DI,[HIGH_SECTOR]        ;F.C. >32mb			;AN000;
 26305 00004357 3B3E[0E06]              	CMP	DI,[TEMP_VAR2]		;M039; F.C. >32mb		;AN000;
 26306 0000435B 7263                    	JB	short NOGROW		;F.C. >32mb                     ;AN000;
 26307 0000435D 7408                    	JZ	short lowsec		;F.C. >32mb                     ;AN000;
 26308 0000435F 29CB                    	SUB	BX,CX                   ;F.C. >32mb                     ;AN000;
 26309 00004361 1B3E[0E06]              	SBB	DI,[TEMP_VAR2]   	;M039; F.C. >32mb di:bx no. of sectors ;AN000;
 26310 00004365 EB08                    	JMP	short yesgrow           ;F.C. >32mb                     ;AN000;
 26311                                  lowsec:
 26312                                  	;MOV	DI,0			;F.C. >32mb
 26313                                  	; 22/09/2023
 26314 00004367 31FF                    	xor	di,di
 26315                                  	; MSDOS 3.3 & MSDOS 6.0
 26316 00004369 29CB                    	SUB	BX,CX			; Number of full sectors
 26317 0000436B 7253                    	JB	short NOGROW
 26318 0000436D 7444                    	JZ	short TESTTAIL
 26319                                  yesgrow:
 26320                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26321 0000436F 89D1                    	MOV     CX,DX
 26322 00004371 93                      	XCHG    AX,BX
 26323                                  	;mul	word [es:bp+2]
 26324 00004372 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE]  ; Bytes of full sector growth
 26325                                  	
 26326                                  	; MSDOS 6.0
 26327 00004376 8916[0706]              	MOV	[HIGH_SECTOR],DX         ;F.C. >32mb save dx                    ;AN000;
 26328 0000437A A3[0E06]                	MOV	[TEMP_VAR2],AX    	 ;M039; F.C. >32mb save ax		;AN000;
 26329 0000437D 89F8                    	MOV	AX,DI                    ;F.C. >32mb                            ;AN000;
 26330                                  	;mul	word [es:bp+2]
 26331 0000437F 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE] ;F.C. >32mb do higher word multiply ;AN000;
 26332                                  	
 26333 00004383 0306[0706]              	ADD	AX,[HIGH_SECTOR]         ;F.C. >32mb add lower value            ;AN000;
 26334 00004387 89C2                    	MOV	DX,AX                    ;F.C. >32mb DX:AX is the result of     ;AN000;
 26335 00004389 A1[0E06]                	MOV	AX,[TEMP_VAR2]    	 ;M039; F.C. >32mb a 32 bit multiply	;AN000;
 26336                                  
 26337                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26338 0000438C 29C8                    	SUB     AX,CX			; Take off current "tail"
 26339 0000438E 83DA00                  	SBB     DX,0			; 32-bit extension
 26340 00004391 01D8                    	ADD     AX,BX			; Add on new "tail"
 26341 00004393 83D200                  	ADC     DX,0			; ripple tim's head off
 26342 00004396 EB21                    	JMP     SHORT SETGRW
 26343                                  
 26344                                  HAVSTART:
 26345                                  	;int 3
 26346 00004398 89C1                    	MOV     CX,AX
 26347 0000439A E8AF12                  	call	SKPCLP
 26348                                  	;JCXZ	DOWRTJ
 26349                                  	; 16/12/2022
 26350 0000439D E357                    	jcxz	DOWRT
 26351                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26352                                  	;jcxz	DOWRTJ
 26353                                  
 26354 0000439F E85114                  	call	ALLOCATE
 26355                                  	;JNC	short DOWRTJ
 26356                                  	; 16/12/2022
 26357 000043A2 7352                    	jnc	short DOWRT
 26358                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26359                                  	;jnc	short DOWRTJ
 26360                                  
 26361                                  	;entry   WRTERR
 26362                                  WRTERR:
 26363 000043A4 B40F                    	MOV     AH,0FH			;MS. write/data/fail/abort      ;AN000;
 26364                                  
 26365                                  	;entry WRTERR22
 26366                                  WRTERR22:
 26367 000043A6 A0[7605]                	MOV     AL,[THISDRV]		;MS.                            ;AN000;
 26368                                  
 26369                                  	; 27/07/2018
 26370                                  WRTERR33:
 26371                                  	;MOV	CX,0			;No bytes transferred
 26372 000043A9 31C9                    	XOR     CX,CX
 26373                                  					
 26374 000043AB C43E[9E05]              	LES     DI,[THISSFT]
 26375                                  	;CLC ; 19/05/2019
 26376                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26377                                  	; 16/12/2022
 26378                                  	;clc
 26379 000043AF C3                      	retn
 26380                                  
 26381                                  	; 16/12/2022
 26382                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26383                                  ;DOWRTJ:
 26384                                  	;JMP	short DOWRT
 26385                                  
 26386                                  ACC_ERRWJ:
 26387                                  	; 10/08/2018
 26388                                  	;JMP	SET_ACC_ERRW
 26389                                  	; 16/12/2022
 26390 000043B0 E9D7FD                  	jmp	SET_ACC_ERR_DS
 26391                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26392                                  	;jmp	SET_ACC_ERRW	
 26393                                  
 26394                                  TESTTAIL:
 26395 000043B3 29D0                    	SUB     AX,DX
 26396 000043B5 7609                    	JBE	short NOGROW
 26397 000043B7 31D2                    	XOR     DX,DX
 26398                                  SETGRW:
 26399 000043B9 A3[DE05]                	MOV	[GROWCNT],AX
 26400 000043BC 8916[E005]              	MOV	[GROWCNT+2],DX
 26401                                  NOGROW:
 26402 000043C0 58                      	POP     AX
 26403 000043C1 8B0E[BC05]              	MOV     CX,[CLUSNUM]    ; First cluster accessed
 26404 000043C5 E86412                  	call	FNDCLUS
 26405 000043C8 72E6                    	JC	short ACC_ERRWJ
 26406 000043CA 891E[BC05]              	MOV     [CLUSNUM],BX
 26407 000043CE 8916[BA05]              	MOV     [LASTPOS],DX
 26408                                  
 26409 000043D2 29D0                    	SUB     AX,DX           ; Last cluster minus current cluster
 26410 000043D4 7420                    	JZ	short DOWRT	; If we have last clus, we must have first
 26411 000043D6 E3C0                    	JCXZ    HAVSTART        ; See if no more data
 26412 000043D8 51                      	PUSH    CX              ; No. of clusters short of first
 26413 000043D9 89C1                    	MOV     CX,AX
 26414 000043DB E81514                  	call	ALLOCATE
 26415 000043DE 59                      	POP     CX
 26416 000043DF 72C3                    	JC	short WRTERR
 26417 000043E1 8B16[BA05]              	MOV     DX,[LASTPOS]
 26418 000043E5 42                      	INC     DX
 26419 000043E6 49                      	DEC     CX
 26420 000043E7 7405                    	JZ	short NOSKIP
 26421 000043E9 E86012                  	call	SKPCLP
 26422 000043EC 72C2                    	JC	short ACC_ERRWJ
 26423                                  NOSKIP:
 26424 000043EE 891E[BC05]              	MOV     [CLUSNUM],BX
 26425 000043F2 8916[BA05]              	MOV     [LASTPOS],DX
 26426                                  DOWRT:
 26427 000043F6 833E[D205]00            	CMP     word [BYTCNT1],0
 26428 000043FB 7409                    	JZ	short WRTMID
 26429 000043FD 8B1E[BC05]              	MOV     BX,[CLUSNUM]
 26430 00004401 E8D712                  	call	BUFWRT
 26431 00004404 72AA                    	JC	short ACC_ERRWJ
 26432                                  WRTMID:
 26433 00004406 A1[D605]                	MOV     AX,[SECCNT]
 26434 00004409 09C0                    	OR      AX,AX
 26435                                  	; 20/11/2022
 26436 0000440B 746F                    	JZ	short WRTLAST	; 24/07/2019	;M039
 26437 0000440D 0106[C405]              	ADD     [SECPOS],AX
 26438                                  	; 19/05/2019
 26439                                  	; MSDOS 6.0
 26440 00004411 8316[C605]00            	ADC	WORD [SECPOS+2],0	;F.C. >32mb 	;AN000;
 26441 00004416 E81E13                  	call	NEXTSEC
 26442                                  	; 16/12/2022
 26443 00004419 7295                    	JC	short ACC_ERRWJ
 26444                                  	;JC	short SET_ACC_ERRW	;M039
 26445 0000441B C606[7405]01            	MOV     BYTE [TRANS],1		; A transfer is taking place
 26446 00004420 8A16[7305]              	MOV     DL,[SECCLUSPOS] 	; (dx/DL = Extent start) ((dh = ?))
 26447 00004424 8B1E[BC05]              	MOV     BX,[CLUSNUM]
 26448 00004428 8B0E[D605]              	MOV     CX,[SECCNT]
 26449                                  WRTLP:
 26450 0000442C E83913                  	call	OPTIMIZE
 26451 0000442F 7248                    	JC	short SET_ACC_ERRW
 26452                                  	; 16/12/2022
 26453                                  	;JC	short ACC_ERRWJ
 26454                                  
 26455                                  ;M039
 26456                                  ;       DI = Next physical cluster.
 26457                                  ;       AX = # sectors remaining.
 26458                                  ;       [DMAADD+2]:BX = transfer address (source data address).
 26459                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
 26460                                  ;	     sectors, also termed an "Extent".)
 26461                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 26462                                  ;       ES:BP -> Drive Parameter Block (DPB).
 26463                                  ;
 26464                                  ;       Purge the Buffer Queue and the Secondary Cache of any buffers which
 26465                                  ;	are in Extent; they are being over-written.
 26466                                  
 26467 00004431 57                      	push    di
 26468 00004432 50                      	push    ax
 26469                                  
 26470                                  	; MSDOS 3.3
 26471                                  	; IBMDOS.COM (1987) - Offset 4497h
 26472                                  	;push	dx
 26473                                  	;push	bx
 26474                                  	;mov	al,[es:bp]
 26475                                  	;;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
 26476                                  	;mov	bx,cx
 26477                                  	;add	bx,dx	; (bx = Extent end)
 26478                                  
 26479                                  ;	DX = Extent start.
 26480                                  ;	BX = Extent end.
 26481                                  ;	AL = Drive #.
 26482                                  
 26483                                  	;call	SETVISIT
 26484                                  
 26485                                  ;wbufq1:
 26486                                  	;;or	byte [di+5],20h
 26487                                  	;or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
 26488                                  	;;cmp	al,[di+4]	
 26489                                  	;cmp	al,[DI+BUFFINFO.buf_ID]
 26490                                  	;jnz	short wbufq2	; Jump if Extent start > buffer sector.
 26491                                  	;;cmp	[di+6],dx
 26492                                  	;cmp	[DI+BUFFINFO.buf_sector],dx
 26493                                  	;jb	short wbufq2
 26494                                  	;;cmp	[di+6],bx
 26495                                  	;cmp	[DI+BUFFINFO.buf_sector],bx
 26496                                  	;jnb	short wbufq2	; Jump if Extent end >= buffer sector.
 26497                                  
 26498                                  	;; Buffer sector is in the Extent
 26499                                  
 26500                                  	;;mov	word [di+4],20FFh
 26501                                  	;mov	word [DI+BUFFINFO.buf_ID],20FFh
 26502                                  	;				; .buf_ID,    AL = FFh (Free buffer)
 26503                                  	;				; .buf_flags, AH = 0, reset/clear
 26504                                  	;call	SCANPLACE
 26505                                  ;wbufq2:
 26506                                  	;call	SKIPVISIT
 26507                                  	;jnz	short wbufq1
 26508                                  	;pop	bx
 26509                                  	;pop	dx
 26510                                  
 26511                                          ; MSDOS 6.0
 26512 00004433 E82D01                  	call	DskWrtBufPurge		;DS trashed.
 26513                                  
 26514                                  ;ASSUME DS:NOTHING
 26515                                  ;M039
 26516                                  	; MSDOS 3.3 & MSDOS 6.0
 26517                                  ;hkn; SS override for DMAADD and ALLOWED
 26518 00004436 368E1E[2E03]            	MOV     DS,[SS:DMAADD+2]
 26519                                  	;mov	byte [ss:ALLOWED],38h
 26520 0000443B 36C606[4B03]38          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
 26521                                  
 26522                                  ;	put logic from DWRITE in-line here so we can modify it
 26523                                  ;	for DISK FULL conditions.
 26524                                  
 26525                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26526                                  	; DOSCODE:7AD8h (MSDOS 5.0 MSDOS.SYS)
 26527                                  
 26528                                  	; 16/12/2022
 26529                                  	; MSDOS 3.3 (& MSDOS 5.0)
 26530                                  	;call	DWRITE
 26531                                  
 26532                                  ;DWRITE_OKAY:
 26533                                  
 26534                                  	; 16/12/2022
 26535                                  	; MSDOS 5.0 (& MSDOS 3.3)
 26536                                  	;pop     cx
 26537                                  	;pop     bx
 26538                                  	;push    ss
 26539                                  	;pop     ds
 26540                                  	;jc      short SET_ACC_ERRW
 26541                                  	;jcxz    WRTLAST
 26542                                  	;mov     dl, 0
 26543                                  	;inc     word [LASTPOS]
 26544                                  	;jmp     short WRTLP
 26545                                  
 26546                                  	; 16/12/2022
 26547                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26548                                  DWRITE_LUP:
 26549                                  	; 23/07/2019 - Retro DOS v3.2
 26550                                  
 26551                                  	; MSDOS 6.0
 26552 00004441 E8E1FB                  	call	DSKWRITE
 26553 00004444 7417                    	jz	short DWRITE_OKAY
 26554                                  
 26555                                  ;;	int	3
 26556                                  
 26557 00004446 3C27                    	cmp	al,error_handle_Disk_Full	; compressed volume full?
 26558 00004448 7423                    	jz	short DWRITE_DISK_FULL
 26559                                  
 26560                                  	; 16/12/2022
 26561                                  
 26562                                  ;;hkn; SS override
 26563 0000444A 36C606[7505]01          	MOV	BYTE [SS:READOP],1
 26564 00004450 E801FC                  	call	HARDERRRW
 26565 00004453 3C01                    	CMP	AL,1		; Check for retry
 26566 00004455 74EA                    	JZ	short DWRITE_LUP
 26567                                  
 26568                                  	; 16/12/2022
 26569                                  	; 23/07/2019
 26570                                  	;POP	CX ; *4*
 26571                                  	;POP	BX ; *5*
 26572                                  	;
 26573                                  	;push	ss
 26574                                  	;pop	ds
 26575                                  	;
 26576                                  
 26577                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26578                                  
 26579                                  	; 16/12/2022
 26580 00004457 3C03                    	CMP	AL,3		; Check for FAIL
 26581 00004459 F8                      	CLC
 26582 0000445A 7501                    	JNZ	short DWRITE_OKAY ; Ignore
 26583 0000445C F9                      	STC
 26584                                  
 26585                                  DWRITE_OKAY:
 26586                                  	; 16/12/2022
 26587                                  	; 23/07/2019
 26588                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26589 0000445D 59                      	POP	CX ; *4*
 26590 0000445E 5B                      	POP	BX ; *5*
 26591                                  
 26592                                  ;       CX = # sectors remaining.
 26593                                  ;       BX = Next physical cluster.
 26594                                  
 26595                                  ;hkn; SS override
 26596                                          ;Context DS
 26597                                  	; 16/12/2022
 26598                                  	;push	ss
 26599                                  	;pop	ds
 26600                                  
 26601                                  	; 16/12/2022
 26602 0000445F 7218                    	jc	short SET_ACC_ERRW
 26603                                  
 26604                                  	; 16/12/2022
 26605 00004461 16                      	push	ss
 26606 00004462 1F                      	pop	ds
 26607                                  
 26608 00004463 E317                    	JCXZ    WRTLAST
 26609                                  
 26610                                  	;MOV	DL,0
 26611 00004465 30D2                    	xor	dl,dl ; 23/07/2019
 26612 00004467 FF06[BA05]              	INC     word [LASTPOS]	; We'll be using next cluster
 26613 0000446B EBBF                    	JMP     short WRTLP
 26614                                  
 26615                                  	; 23/07/2019 - Retro DOS v3.2
 26616                                  	; 09/08/2018
 26617                                  	; MSDOS 6.0
 26618                                  DWRITE_DISK_FULL:
 26619                                  	;Context DS		;SQ 3-5-93 DS must be setup on return!
 26620                                  	; 16/12/2022
 26621 0000446D 16                      	push	ss
 26622 0000446E 1F                      	pop	ds
 26623 0000446F 59                      	pop	cx		; unjunk stack
 26624 00004470 5B                      	pop	bx
 26625 00004471 C606[0B06]01            	mov	byte [DISK_FULL],1
 26626                                  	;stc
 26627 00004476 E92BFF                  	jmp	WRTERR ; 24/07/2019 ; go to disk full exit
 26628                                  
 26629                                  	; 16/12/2022
 26630                                  SET_ACC_ERRW:
 26631 00004479 E90EFD                  	jmp	SET_ACC_ERR_DS
 26632                                  
 26633                                  WRTLAST:
 26634 0000447C A1[D405]                	MOV     AX,[BYTCNT2]
 26635 0000447F 09C0                    	OR      AX,AX
 26636 00004481 7413                    	JZ	short FINWRT
 26637 00004483 A3[D205]                	MOV     [BYTCNT1],AX
 26638 00004486 E8AE12                  	call	NEXTSEC
 26639 00004489 72EE                    	JC	short SET_ACC_ERRW
 26640 0000448B C706[CC05]0000          	MOV     word [BYTSECPOS],0
 26641 00004491 E84712                  	call	BUFWRT
 26642 00004494 72E3                    	JC	short SET_ACC_ERRW
 26643                                  FINWRT:
 26644 00004496 C43E[9E05]              	LES     DI,[THISSFT]
 26645 0000449A A1[DE05]                	MOV     AX,[GROWCNT]
 26646 0000449D 8B0E[E005]              	MOV     CX,[GROWCNT+2]
 26647 000044A1 09C0                    	OR      AX,AX
 26648 000044A3 7502                    	JNZ	short UPDATE_size
 26649 000044A5 E30F                    	JCXZ    SAMSIZ
 26650                                  UPDATE_size:
 26651                                  	;add	[es:di+11h],ax
 26652 000044A7 26014511                	ADD     [ES:DI+SF_ENTRY.sf_size],AX
 26653                                  	;adc	[es:di+13h],cx
 26654 000044AB 26114D13                	ADC     [ES:DI+SF_ENTRY.sf_size+2],CX
 26655                                  
 26656                                  ; Make sure that all other SFT's see this growth also.
 26657                                  
 26658 000044AF B80100                  	MOV     AX,1
 26659                                  ;if installed
 26660                                  	;Call	JShare + 14 * 4
 26661 000044B2 FF1E[C800]              	call    far [JShare+(14*4)]	; 14 = ShSU
 26662                                  ;else
 26663                                  ;	Call    ShSU
 26664                                  ;endif
 26665                                  
 26666                                  SAMSIZ:
 26667 000044B6 E969FD                  	jmp	SETCLUS	; ES:DI already points to SFT
 26668                                  
 26669                                  	; 16/12/2022
 26670                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26671                                  ;SET_ACC_ERRW:
 26672                                  	;jmp	SET_ACC_ERR_DS
 26673                                  
 26674                                  WRTEOF:
 26675 000044B9 89C1                    	MOV     CX,AX
 26676 000044BB 09D1                    	OR      CX,DX
 26677 000044BD 746C                    	JZ	short KILLFIL
 26678 000044BF 83E801                  	SUB     AX,1
 26679 000044C2 83DA00                  	SBB     DX,0
 26680                                  
 26681                                  	; MSDOS 3.3
 26682                                  	;;div	word [es:bp+2]
 26683                                  	;div	word [ES:BP+DPB.SECTOR_SIZE]
 26684                                  	;;mov	cl,[es:bp+5]
 26685                                  	;mov	cl,[ES:BP+DPB.CLUSTER_SHIFT] 
 26686                                  	;shr	ax,cl
 26687                                  
 26688                                  	; MSDOS 6.0
 26689 000044C5 53                      	PUSH	BX
 26690                                  	;mov	bx,[es:bp+2]
 26691 000044C6 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]    ;F.C. >32mb                       ;AN000;
 26692 000044CA E81C01                  	CALL	DIV32                         ;F.C. >32mb                       ;AN000;
 26693 000044CD 5B                      	POP	BX			      ;F.C. >32mb			;AN000;
 26694 000044CE 89CA                    	MOV	DX,CX			      ;M039
 26695 000044D0 890E[0706]                      MOV	[HIGH_SECTOR],CX              ;M039: Probably extraneous, but not sure.
 26696 000044D4 E83901                  	CALL	SHR32                         ;F.C. >32mb                       ;AN000;
 26697                                  
 26698 000044D7 89C1                    	MOV     CX,AX
 26699 000044D9 E85011                  	call	FNDCLUS
 26700                                  SET_ACC_ERRWJ2:
 26701 000044DC 729B                    	JC	short SET_ACC_ERRW
 26702                                  
 26703 000044DE E326                    	JCXZ    RELFILE
 26704 000044E0 E81013                  	call	ALLOCATE
 26705                                  	;JC	short WRTERRJ              ;;;;;;;;; disk full
 26706                                  	; 16/12/2022
 26707 000044E3 7303                    	jnc	short UPDATE
 26708 000044E5 E9BCFE                  	JMP	WRTERR
 26709                                  UPDATE:
 26710 000044E8 C43E[9E05]              	LES	DI,[THISSFT]
 26711 000044EC A1[CE05]                	MOV	AX,[BYTPOS]
 26712                                  	;mov	[es:di+11h],ax
 26713 000044EF 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 26714 000044F3 A1[D005]                	MOV	AX,[BYTPOS+2]
 26715                                  	;mov	[es:di+13h],ax
 26716 000044F6 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 26717                                  ;
 26718                                  ; Make sure that all other SFT's see this growth also.
 26719                                  ;
 26720 000044FA B80200                  	MOV     AX,2
 26721                                  ;if installed
 26722                                  	;Call	JShare + 14 * 4
 26723 000044FD FF1E[C800]              	call    far [JShare+(14*4)]	; 14 = ShSU
 26724                                  ;else
 26725                                  ;	Call    ShSU
 26726                                  ;endif
 26727 00004501 31C9                    	XOR     CX,CX
 26728 00004503 E939FD                  	jmp	ADDREC
 26729                                  
 26730                                  	; 16/12/2022
 26731                                  ;WRTERRJ: 
 26732                                  	;JMP	WRTERR
 26733                                  
 26734                                  ;;;;;;;;;;;;;;;; 7/18/86
 26735                                  ;;;;;;;;;;;;;;;;
 26736                                  
 26737                                  RELFILE:
 26738                                  	; MSDOS 6.0
 26739 00004506 06                      	PUSH    ES                    ;AN002; BL Reset Lstclus and cluspos to
 26740 00004507 C43E[9E05]              	LES     DI,[THISSFT]          ;AN002; BL beginning of file if current
 26741                                  	;cmp	dx,[es:di+19h]
 26742 0000450B 263B5519                	CMP     DX,[ES:DI+SF_ENTRY.sf_cluspos]	;AN002; BL cluspos is past EOF.
 26743 0000450F 730E                    	JAE	short SKIPRESET	      		;AN002; BL
 26744                                  	;mov	[es:di+19h],0
 26745 00004511 26C745190000            	MOV     word [ES:DI+SF_ENTRY.sf_cluspos],0 ;AN002; BL
 26746                                  	;mov	dx,[es:di+0Bh]
 26747 00004517 268B550B                	MOV     DX,[ES:DI+SF_ENTRY.sf_firclus]	;AN002; BL
 26748                                  	;mov	[es:di+35h],dx
 26749 0000451B 26895535                	MOV     [ES:DI+SF_ENTRY.sf_lstclus],DX	;AN002; BL
 26750                                  SKIPRESET:                            		;AN002; BL
 26751 0000451F 07                      	POP     ES                    		;AN002; BL
 26752                                  ;
 26753 00004520 BAFFFF                  	MOV     DX,0FFFFH
 26754 00004523 E87B13                  	call	RELBLKS
 26755                                  	; 16/12/2022
 26756                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26757 00004526 73C0                    	jnc	short UPDATE
 26758                                  SET_ACC_ERRWJ:
 26759                                  	;JC	short SET_ACC_ERRWJ2
 26760                                  	;JMP	SHORT UPDATE
 26761                                  	; 16/12/2022
 26762 00004528 E95FFC                  	jmp	SET_ACC_ERR_DS
 26763                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26764                                  	;JC	short SET_ACC_ERRWJ2
 26765                                  	;JMP	SHORT UPDATE
 26766                                  
 26767                                  KILLFIL:
 26768 0000452B 31DB                    	XOR     BX,BX
 26769 0000452D 06                      	PUSH    ES
 26770 0000452E C43E[9E05]              	LES     DI,[THISSFT]
 26771                                  	;mov	[es:di+19h],bx
 26772 00004532 26895D19                	MOV	[ES:DI+SF_ENTRY.sf_cluspos],BX
 26773                                  	;mov	[es:di+35h],bx ; 04/05/2019
 26774 00004536 26895D35                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],BX
 26775                                  	;xchg	bx,[es:di+0Bh]
 26776 0000453A 26875D0B                	XCHG    BX,[ES:DI+SF_ENTRY.sf_firclus]
 26777 0000453E 07                      	POP	ES
 26778                                  
 26779 0000453F 09DB                    	OR	BX,BX
 26780                                  	;JZ	short UPDATEJ
 26781                                  	; 16/12/2022
 26782 00004541 74A5                    	jz	short UPDATE
 26783                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26784                                  	;jz	short UPDATEJ
 26785                                  
 26786                                  ;; 10/23/86 FastOpen update
 26787 00004543 06                      	PUSH	ES              ; since first cluster # is 0
 26788 00004544 55                      	PUSH	BP              ; we must delete the old cache entry
 26789 00004545 50                      	PUSH	AX
 26790 00004546 51                      	PUSH	CX
 26791 00004547 52                      	PUSH	DX
 26792 00004548 C42E[8A05]              	LES	BP,[THISDPB]             ; get current DPB
 26793                                  	; 15/12/2022
 26794 0000454C 268A5600                	mov	dl,[ES:BP] ; mov dl,[es:bp+0]
 26795                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26796                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; get current drive
 26797 00004550 89D9                    	MOV	CX,BX                    ; first cluster #
 26798 00004552 B402                    	MOV	AH,2                     ; delete cache entry by drive:firclus
 26799 00004554 E835E8                  	call	FastOpen_Update          ; call fastopen
 26800 00004557 5A                      	POP	DX
 26801 00004558 59                      	POP	CX
 26802 00004559 58                      	POP	AX
 26803 0000455A 5D                      	POP	BP
 26804 0000455B 07                      	POP	ES
 26805                                  ;; 10/23/86 FastOpen update
 26806                                  
 26807 0000455C E84013                  	call	RELEASE
 26808 0000455F 72C7                    	JC	short SET_ACC_ERRWJ
 26809                                  UPDATEJ:
 26810                                  	; 20/11/2022
 26811 00004561 EB85                    	JMP	short UPDATE ; 10/08/2018
 26812                                  
 26813                                  ;Break   <DskWrtBufPurge -- Disk Write Buffer Purge>
 26814                                  ;----------------------------------------------------------------------------
 26815                                  ;
 26816                                  ; Procedure Name : DskWrtBufPurge
 26817                                  ;
 26818                                  ; Inputs:
 26819                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
 26820                                  ;	     sectors, also termed an "Extent".)
 26821                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 26822                                  ;       ES:BP -> Drive Parameter Block (DPB).
 26823                                  ;
 26824                                  ; Function:
 26825                                  ;       Purge the Buffer Queue and the Secondary Cache of any buffers which
 26826                                  ;	are in Extent; they are being over-written.
 26827                                  ;
 26828                                  ; Outputs:
 26829                                  ;       (Same as Input.)
 26830                                  ; Uses:
 26831                                  ;       All registers except DS,AX,SI,DI preserved.
 26832                                  ;       SS override for all global variables.
 26833                                  ;----------------------------------------------------------------------------
 26834                                  ;M039: Created
 26835                                  
 26836                                  ;procedure   DskWrtBufPurge,NEAR
 26837                                  ;
 26838                                  ;ASSUME  DS:NOTHING
 26839                                  
 26840                                  ; 04/05/2019 - Retro DOS v4.0
 26841                                  ; DOSCODE:7C0Eh (MSDOS 6.21, MSDOS.SYS)
 26842                                  
 26843                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26844                                  ; DOSCODE:7BD4h (MSDOS 5.0, MSDOS.SYS) 
 26845                                  
 26846                                  DskWrtBufPurge:
 26847                                  	;SaveReg <bx,cx>
 26848 00004563 53                      	push	bx
 26849 00004564 51                      	push	cx
 26850                                  
 26851 00004565 368B1E[0706]            	mov	bx,[ss:HIGH_SECTOR]	;BX:DX = Extent start (sector #).
 26852 0000456A 89DE                    	mov	si,bx
 26853 0000456C 01D1                    	add	cx,dx
 26854 0000456E 83D600                  	adc	si,0                    ;SI:CX = Extent end + 1.
 26855                                  
 26856                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26857                                  	;;mov	al,[es:bp+0]
 26858                                  	;mov	al,[es:bp+DPB.DRIVE]
 26859                                  	; 15/12/2022
 26860 00004571 268A4600                	mov	al,[es:bp]
 26861                                  
 26862                                  ;	BX:DX = Extent start.
 26863                                  ;	SI:CX = Extent end + 1.
 26864                                  ;	AL = Drive #
 26865                                  
 26866 00004575 36833E[7700]00          	cmp	word [ss:SC_CACHE_COUNT],0 ;Secondary cache in-use?
 26867 0000457B 7431                    	je	short nosc		; -no, jump.
 26868                                  
 26869                                  ;	If any of the sectors to be written are in the secondary cache (SC),
 26870                                  ;	invalidate the entire SC. (This is an optimization; we really only
 26871                                  ;	need to invalidate those sectors which intersect, but that's slower.)
 26872                                  
 26873 0000457D 363A06[9C12]            	cmp	al,[ss:CurSC_DRIVE]	;Same drive?
 26874 00004582 752A                    	jne	short nosc		; -no, jump.
 26875                                  
 26876 00004584 50                      	push    ax
 26877 00004585 36A1[010E]              	mov     ax,[ss:CurSC_SECTOR]
 26878 00004589 368B3E[030E]            	mov     di,[ss:CurSC_SECTOR+2]	;DI:AX = SC start.
 26879                                  
 26880                                  	;Cmp32	si,cx,di,ax		;Extent end < SC start?
 26881                                  	;jbe	short sc5		; -yes, jump.
 26882                                  
 26883 0000458E 39FE                    	cmp	si,di
 26884 00004590 7502                    	jne	short sc01
 26885 00004592 39C1                    	cmp	cx,ax
 26886                                  sc01: 
 26887 00004594 7617                    	jbe	short sc5	
 26888                                  
 26889 00004596 360306[7700]            	add	ax,[ss:SC_CACHE_COUNT]
 26890 0000459B 83D700                  	adc	di,0                    ;DI:AX = SC end + 1.
 26891                                  	
 26892                                  	;Cmp32	bx,dx,di,ax             ;Extent start > SC end?
 26893                                  	;jae	short sc5		; -yes, jump.
 26894                                  
 26895 0000459E 39FB                    	cmp	bx,di
 26896 000045A0 7502                    	jne	short sc02
 26897 000045A2 39C2                    	cmp	dx,ax
 26898                                  sc02:
 26899 000045A4 7307                    	jnb	short sc5
 26900                                  
 26901 000045A6 36C706[050E]0000        	mov	word [ss:SC_STATUS],0	;Extent intersects SC: invalidate SC.
 26902                                  sc5:	
 26903 000045AD 58                      	pop     ax
 26904                                  
 26905                                  ;	Free any buffered sectors which are in Extent; they are being over-
 26906                                  ;	written.
 26907                                  
 26908                                  nosc:	
 26909 000045AE E8331D                  	call	GETCURHEAD		;DS:DI -> first buffer in queue.
 26910                                  
 26911                                  _bufq:	
 26912                                  	;cmpo	al,[di+4]
 26913 000045B1 3A4504                  	cmp     al,[di+BUFFINFO.buf_ID] ;Same drive?
 26914 000045B4 7527                    	jne	short bufq5		; -no, jump.
 26915                                  
 26916                                  ;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 26917                                  ;       ja	short bufq5		;Jump if Extent start > buffer sector.
 26918                                  
 26919                                  	;cmp	bx,[di+8]
 26920 000045B6 3B5D08                  	cmp	bx,[di+BUFFINFO.buf_sector+2]
 26921 000045B9 7503                    	jne	short bufq04
 26922                                  	;cmp	dx,[di+6]
 26923 000045BB 3B5506                  	cmp	dx,[di+BUFFINFO.buf_sector]
 26924                                  bufq04:
 26925 000045BE 771D                    	ja	short bufq5
 26926                                  
 26927                                  ;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 26928                                  ;       jbe	short bufq5		;Jump if Extent end < buffer sector.
 26929                                  
 26930                                  	;cmp	si,[di+8]
 26931 000045C0 3B7508                  	cmp	si,[di+BUFFINFO.buf_sector+2]
 26932 000045C3 7503                    	jne	short bufq05
 26933                                  	;cmp	cx,[di+6]
 26934 000045C5 3B4D06                  	cmp	cx,[di+BUFFINFO.buf_sector]
 26935                                  bufq05:
 26936 000045C8 7613                    	jbe	short bufq5
 26937                                  
 26938                                  ;	Buffer's sector is in Extent, so free it; it is being over-written.
 26939                                  
 26940                                  	;test	byte [di+5],40h
 26941 000045CA F6450540                	test	byte [di+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty?
 26942 000045CE 7403                    	jz	short bufq4		; -no, jump.
 26943 000045D0 E89E1F                  	call	DEC_DIRTY_COUNT		; -yes, decrement dirty count.
 26944                                  bufq4:
 26945                                  	;mov	word [di+4],20FFh
 26946 000045D3 C74504FF20              	mov     word [di+BUFFINFO.buf_ID],((buf_visit<<8)|0FFh)
 26947                                  
 26948 000045D8 E81B1D                  	call	SCANPLACE
 26949 000045DB EB02                    	jmp     short bufq6
 26950                                  bufq5: 
 26951 000045DD 8B3D                    	mov     di,[di]
 26952                                  	;mov	di,[di+BUFFINFO.buf_next]
 26953                                  bufq6: 
 26954 000045DF 363B3E[A512]            	cmp	di,[ss:FIRST_BUFF_ADDR]	;Scanned entire buffer queue?
 26955 000045E4 75CB                    	jne	short _bufq		; --no, go do next buffer.
 26956                                  	
 26957                                  	;RestoreReg <cx,bx>
 26958 000045E6 59                      	pop	cx
 26959 000045E7 5B                      	pop	bx
 26960 000045E8 C3                      	retn
 26961                                  
 26962                                  ;EndProc DskWrtBufPurge
 26963                                  
 26964                                  ;Break   <DIV32 -- PERFORM 32 BIT DIVIDE>
 26965                                  ;----------------------------------------------------------------------------
 26966                                  ;
 26967                                  ; Procedure Name : DIV32
 26968                                  ;
 26969                                  ; Inputs:
 26970                                  ;       DX:AX = 32 bit dividend   BX= divisor
 26971                                  ; Function:
 26972                                  ;       Perform 32 bit division:  DX:AX/BX = CX:AX + DX (rem.)
 26973                                  ; Outputs:
 26974                                  ;       CX:AX = quotient , DX= remainder
 26975                                  ; Uses:
 26976                                  ;       All registers except AX,CX,DX preserved.
 26977                                  ;----------------------------------------------------------------------------
 26978                                  ;M039: DIV32 optimized for divisor of 512 (common sector size).
 26979                                  
 26980                                  ; 04/05/2019 - Retro DOS v4.0
 26981                                  ; DOSCODE:7C94h (MSDOS 6.21, MSDOS.SYS)
 26982                                  
 26983                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26984                                  ; DOSCODE:7C5Ah (MSDOS 5.0, MSDOS.SYS) 
 26985                                  
 26986                                  DIV32:
 26987 000045E9 81FB0002                	cmp	bx,512
 26988 000045ED 7515                    	jne	short div5
 26989                                  
 26990 000045EF 89D1                    	mov	cx,dx
 26991 000045F1 89C2                    	mov	dx,ax           ; CX:AX = Dividend
 26992 000045F3 81E2FF01                	and	dx,(512-1)      ; DX = Remainder
 26993 000045F7 88E0                    	mov	al,ah
 26994 000045F9 88CC                    	mov	ah,cl
 26995 000045FB 88E9                    	mov	cl,ch
 26996 000045FD 30ED                    	xor	ch,ch
 26997 000045FF D1E9                    	shr	cx,1
 26998 00004601 D1D8                    	rcr	ax,1
 26999 00004603 C3                      	retn
 27000                                  div5:	
 27001 00004604 89C1                    	mov	cx,ax
 27002 00004606 89D0                    	mov	ax,dx
 27003 00004608 31D2                    	xor	dx,dx
 27004 0000460A F7F3                    	div	bx              ; 0:AX/BX
 27005 0000460C 91                      	xchg	cx,ax
 27006 0000460D F7F3                    	div	bx              ; DX:AX/BX
 27007 0000460F C3                      	retn
 27008                                  
 27009                                  ;Break   <SHR32 -- PERFORM 32 BIT SHIFT RIGHT>
 27010                                  ;----------------------------------------------------------------------------
 27011                                  ;
 27012                                  ; Procedure Name : SHR32
 27013                                  ;
 27014                                  ; Inputs:
 27015                                  ;	DX:AX = 32 bit sector number
 27016                                  ; Function:
 27017                                  ;       Perform 32 bit shift right
 27018                                  ; Outputs:
 27019                                  ;	AX = cluster number
 27020                                  ;	ZF = 1 if no error
 27021                                  ;	   = 0 if error (cluster number > 64k)
 27022                                  ; Uses:
 27023                                  ;       DX,CX
 27024                                  ;---------------------------------------------------------------------------
 27025                                  ; M017	- SHR32 rewritten for better performance
 27026                                  ; M039	- Additional optimization
 27027                                  
 27028                                  ; 04/05/2019 - Retro DOS v4.0
 27029                                  ; DOSCODE:7CBBh (MSDOS 6.21, MSDOS.SYS)
 27030                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27031                                  ; DOSCODE:7C81h (MSDOS 5.0, MSDOS.SYS) 
 27032                                  
 27033                                  SHR32:
 27034                                  	;mov	cl,[es:bp+5]
 27035 00004610 268A4E05                	mov	cl,[ES:BP+DPB.CLUSTER_SHIFT]
 27036 00004614 30ED                    	xor	ch,ch	    ;ZF=1
 27037 00004616 E306                    	jcxz	norota
 27038                                  
 27039                                  rotashft2:
 27040 00004618 D1EA                    	shr	dx,1	    ;ZF reflects state of DX.
 27041 0000461A D1D8                    	rcr	ax,1	    ;ZF not affected.
 27042 0000461C E2FA                    	loop	rotashft2
 27043                                  norota:
 27044 0000461E C3                      	retn
 27045                                  
 27046                                  ;============================================================================
 27047                                  ; DIR.ASM, MSDOS 6.0, 1991
 27048                                  ;============================================================================
 27049                                  ; 27/07/2018 - Retro DOS v3.0
 27050                                  ; 19/05/2019 - Retro DOS v4.0 
 27051                                  
 27052                                  ;	TITLE	DIR - Directory and path cracking
 27053                                  ;	NAME	Dir
 27054                                  
 27055                                  ;Break	<FINDENTRY -- LOOK FOR AN ENTRY>
 27056                                  ;---------------------------------------------------------------------------
 27057                                  ;
 27058                                  ; Procedure Name : FINDENTRY,SEARCH
 27059                                  ;
 27060                                  ; Inputs:
 27061                                  ;	[THISDPB] set
 27062                                  ;	[SECCLUSPOS] = 0
 27063                                  ;	[DIRSEC] = Starting directory sector number
 27064                                  ;	[CLUSNUM] = Next cluster of directory
 27065                                  ;	[CLUSFAC] = Sectors/Cluster
 27066                                  ;	[NAME1] = Name to look for
 27067                                  ; Function:
 27068                                  ;	Find file name in disk directory.
 27069                                  ;	"?" matches any character.
 27070                                  ; Outputs:
 27071                                  ;	Carry set if name not found
 27072                                  ;	ELSE
 27073                                  ;	Zero set if attributes match (always except when creating)
 27074                                  ;	AH = Device ID (bit 7 set if not disk)
 27075                                  ;	[THISDPB] = Base of drive parameters
 27076                                  ;	DS = DOSGROUP
 27077                                  ;	ES = DOSGROUP
 27078                                  ;	[CURBUF+2]:BX = Pointer into directory buffer
 27079                                  ;	[CURBUF+2]:SI = Pointer to First Cluster field in directory entry
 27080                                  ;	[CURBUF] has directory record with match
 27081                                  ;	[NAME1] has file name
 27082                                  ;	[LASTENT] is entry number of the entry
 27083                                  ; All other registers destroyed.
 27084                                  ;----------------------------------------------------------------------------
 27085                                  
 27086                                  ;hkn; called from rename.asm and dir2.asm. DS must be already set up at
 27087                                  ;hkn; this point.
 27088                                  
 27089                                  SEARCH:
 27090                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27091                                  	; DOSCODE:7C90h (MSDOS 5.0, MSDOS.SYS) 
 27092                                  
 27093                                  	; 19/05/2019 - Retro DOS v4.0
 27094                                  	; DOSCODE:7CCA (MSDOS 6.21, MSDOS.SYS)
 27095                                  
 27096                                  	; 27/07/2018 - Retro DOS v3.0
 27097                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 45B3h 
 27098                                  	; 15/03/2018 - Retro DOS v2.0
 27099                                  
 27100                                  	; 24/01/2024
 27101                                  
 27102                                  	;entry	FindEntry
 27103                                  FINDENTRY:
 27104 0000461F E87005                  	call	STARTSRCH
 27105 00004622 A0[6B05]                	MOV	AL,[ATTRIB]
 27106                                  	;and	al,9Eh
 27107 00004625 24DE                    	AND	AL,~attr_ignore		; Ignore useless bits
 27108                                  	;cmp	al,8
 27109 00004627 3C08                    	CMP	AL,attr_volume_id	; Looking for vol ID only ?
 27110 00004629 7503                    	JNZ	short NOTVOLSRCH	; No
 27111 0000462B E8EB01                  	CALL	SETROOTSRCH		; Yes force search of root
 27112                                  NOTVOLSRCH:
 27113 0000462E E8FA00                  	CALL	GETENTRY
 27114                                  	;JNC	short SRCH
 27115                                  	;JMP	SETESRET
 27116                                  	; 24/01/2024
 27117 00004631 723F                    	jc	short SETESRET
 27118                                  
 27119                                  	;entry	Srch
 27120                                  SRCH:
 27121 00004633 1E                      	PUSH	DS
 27122 00004634 8E1E[E405]              	MOV	DS,[CURBUF+2]
 27123                                  
 27124                                  ;	(DS:BX) = directory entry address
 27125                                  
 27126 00004638 8A27                    	mov	ah,[BX]
 27127                                  	;MOV	AH,[BX+dir_entry.dir_name] ; mov ah,[bx+0]
 27128 0000463A 08E4                    	OR	AH,AH			; End of directory?
 27129 0000463C 7437                    	JZ	short FREE
 27130                                  
 27131                                  ;hkn; SS override
 27132 0000463E 363A26[7F05]            	CMP	AH,[SS:DELALL]		; Free entry?
 27133 00004643 7430                    	JZ	short FREE
 27134                                  	;test	byte [bx+0Bh],8
 27135 00004645 F6470B08                	TEST	byte [BX+dir_entry.dir_attr],attr_volume_id
 27136                                  					; Volume ID file?
 27137 00004649 7405                    	JZ	short CHKFNAM 		; NO
 27138                                  
 27139                                  ;hkn; SS override
 27140 0000464B 36FE06[7B05]            	INC	BYTE [SS:VOLID]
 27141                                  CHKFNAM:
 27142                                  ;	Context ES
 27143 00004650 8CD6                    	MOV	SI,SS
 27144 00004652 8EC6                    	MOV	ES,SI
 27145 00004654 89DE                    	MOV	SI,BX
 27146                                  
 27147                                  ;hkn; NAME1 is in DOSDATA
 27148 00004656 BF[4B05]                	MOV	DI,NAME1
 27149                                  ;;;;; 7/29/86
 27150                                  
 27151                                  ;hkn; SS override for NAME1
 27152                                  	;CMP	BYTE [SS:NAME1],0E5H	; special char check
 27153                                  	;JNZ	short NO_E5
 27154                                  	;MOV	BYTE [SS:NAME1],05H
 27155                                  	; 22/09/2023
 27156 00004659 26803DE5                	cmp	byte [es:di],0E5h
 27157 0000465D 7504                    	jnz	short NO_E5
 27158 0000465F 26C60505                	mov	byte [es:di],05h
 27159                                  NO_E5:
 27160                                  ;;;;; 7/29/86
 27161 00004663 E86100                  	CALL	MetaCompare
 27162 00004666 7429                    	JZ	short FOUND
 27163 00004668 1F                      	POP	DS
 27164                                  
 27165                                  	;entry	NEXTENT
 27166                                  NEXTENT:
 27167 00004669 C42E[8A05]              	LES	BP,[THISDPB]
 27168 0000466D E86600                  	CALL	NEXTENTRY
 27169 00004670 73C1                    	JNC	short SRCH
 27170                                  	;JMP	SHORT SETESRET
 27171                                  	; 24/01/2024
 27172                                  SETESRET:
 27173 00004672 16                      	PUSH	SS
 27174 00004673 07                      	POP	ES
 27175 00004674 C3                      	retn
 27176                                  FREE:
 27177 00004675 1F                      	POP	DS
 27178 00004676 8B0E[4803]              	MOV	CX,[LASTENT]
 27179 0000467A 3B0E[D805]              	CMP	CX,[ENTFREE]
 27180 0000467E 7304                    	JAE	short TSTALL
 27181 00004680 890E[D805]              	MOV	[ENTFREE],CX
 27182                                  TSTALL:
 27183 00004684 3A26[7F05]              	CMP	AH,[DELALL]		; At end of directory?
 27184                                  NEXTENTJ:
 27185 00004688 74DF                    	je	short NEXTENT 		; No - continue search
 27186 0000468A 890E[DA05]              	MOV	[ENTLAST],CX
 27187 0000468E F9                      	STC
 27188 0000468F EBE1                    	JMP	SHORT SETESRET
 27189                                  
 27190                                  FOUND:
 27191                                  ; We have a file with a matching name. We must now consider the attributes:
 27192                                  ; ATTRIB	Action
 27193                                  ; ------	------
 27194                                  ; Volume_ID	Is Volume_ID in test?
 27195                                  ; Otherwise	If no create then Is ATTRIB+extra superset of test?
 27196                                  ;		If create then Is ATTRIB equal to test?
 27197                                  
 27198 00004691 8A2C                    	MOV	CH,[SI] 		; Attributes of file
 27199 00004693 1F                      	POP	DS
 27200 00004694 8A26[6B05]              	MOV	AH,[ATTRIB]		; Attributes of search
 27201                                  	;and	ah,9Eh
 27202 00004698 80E4DE                  	AND	AH,~attr_ignore
 27203                                  	;lea	si,[si+15]
 27204 0000469B 8D740F                  	LEA	SI,[SI+dir_entry.dir_first-dir_entry.dir_attr]
 27205                                  					; point to first cluster field
 27206                                  	;test	ch,8
 27207 0000469E F6C508                  	TEST	CH,attr_volume_id	; Volume ID file?
 27208 000046A1 7409                    	JZ	short check_one_volume_id ; Nope check other attributes
 27209                                  	;test	ah,8
 27210 000046A3 F6C408                  	TEST	AH,attr_volume_id	; Can we find Volume ID?
 27211                                  	;JZ	short NEXTENTJ		; Nope, (not even $FCB_CREATE)
 27212                                  	; 16/12/2022
 27213 000046A6 74C1                    	jz	short NEXTENT ; 19/05/2019
 27214                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27215                                  	;JZ	short NEXTENTJ
 27216 000046A8 30E4                    	XOR	AH,AH			; Set zero flag for $FCB_CREATE
 27217 000046AA EB11                    	JMP	SHORT RETFF		; Found Volume ID
 27218                                  check_one_volume_id:
 27219                                  	;CMP	ah,8
 27220 000046AC 80FC08                  	CMP	AH,attr_volume_id	; Looking only for Volume ID?
 27221                                  	;JZ	short NEXTENTJ		; Yes, continue search
 27222                                  	; 16/12/2022
 27223 000046AF 74B8                    	je	short NEXTENT ; 19/05/2019
 27224                                  	;JZ	short NEXTENTJ
 27225 000046B1 E8F204                  	CALL	MatchAttributes
 27226 000046B4 7407                    	JZ	SHORT RETFF
 27227 000046B6 F606[7E05]FF            	TEST	BYTE [CREATING],-1	; Pass back mismatch if creating
 27228                                  	; 16/12/2022
 27229                                  	;JZ	short NEXTENTJ		; Otherwise continue searching
 27230 000046BB 74AC                    	jz	short NEXTENT ; 19/05/2019
 27231                                  RETFF:
 27232 000046BD C42E[8A05]              	LES	BP,[THISDPB]
 27233                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27234                                  	;MOV	AH,[ES:BP+DPB.DRIVE]  ; mov ah,[es:bp+0]
 27235                                  	; 15/12/2022
 27236 000046C1 268A6600                	MOV	AH,[ES:BP]
 27237                                  ;SETESRET:
 27238                                  	;PUSH	SS
 27239                                  	;POP	ES
 27240                                  	;retn
 27241                                  	; 24/01/2024
 27242 000046C5 EBAB                    	jmp	short SETESRET
 27243                                  
 27244                                  ;----------------------------------------------------------------------------
 27245                                  ;
 27246                                  ; Procedure Name : MetaCompare
 27247                                  ;
 27248                                  ; Inputs:
 27249                                  ;	DS:SI -> 11 character FCB style name NO '?'
 27250                                  ;	    Typically this is a directory entry. It MUST be in upper case
 27251                                  ;	ES:DI -> 11 character FCB style name with possible '?'
 27252                                  ;	    Typically this is a FCB or SFT. It MUST be in upper case
 27253                                  ; Function:
 27254                                  ;	Compare FCB style names allowing for ? match to any char
 27255                                  ; Outputs:
 27256                                  ;	Zero if match else NZ
 27257                                  ; Destroys CX,SI,DI all others preserved
 27258                                  ;----------------------------------------------------------------------------
 27259                                  
 27260                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27261                                  	; DOSCODE:7D3Fh (MSDOS 5.0, MSDOS.SYS) 
 27262                                  
 27263                                  MetaCompare:
 27264 000046C7 B90B00                  	MOV	CX,11
 27265                                  WILDCRD:
 27266 000046CA F3A6                    	REPE	CMPSB
 27267 000046CC 7407                    	JZ	short MetaRet 		; most of the time we will fail.
 27268                                  CHECK_META:
 27269 000046CE 26807DFF3F              	CMP	BYTE [ES:DI-1],"?"
 27270 000046D3 74F5                    	JZ	short WILDCRD
 27271                                  MetaRet:
 27272 000046D5 C3                       	retn				; Zero set, Match
 27273                                  
 27274                                  ;Break	<NEXTENTRY -- STEP THROUGH DIRECTORY>
 27275                                  ;----------------------------------------------------------------------------
 27276                                  ;
 27277                                  ; Procedure Name : NEXTENTRY
 27278                                  ;
 27279                                  ; Inputs:
 27280                                  ;	Same as outputs of GETENTRY, above
 27281                                  ; Function:
 27282                                  ;	Update BX, and [LASTENT] for next directory entry.
 27283                                  ;	Carry set if no more.
 27284                                  ;----------------------------------------------------------------------------
 27285                                  
 27286                                  NEXTENTRY:
 27287                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27288                                  	; DOSCODE:7D4Eh (MSDOS 5.0, MSDOS.SYS) 
 27289                                  
 27290                                  	; 19/05/2019 - Retro DOS v4.0
 27291                                  	; DOSCODE:7D88h (MSDOS 6.21, MSDOS.SYS)
 27292                                  
 27293                                  	; 27/07/2018 - Retro DOS v3.0
 27294                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 4671h 
 27295                                  	; 15/03/2018 - Retro DOS v2.0
 27296                                  
 27297 000046D6 A1[4803]                	MOV	AX,[LASTENT]
 27298 000046D9 3B06[DA05]              	CMP	AX,[ENTLAST]
 27299 000046DD 7422                    	JZ	short NONE
 27300 000046DF 40                      	INC	AX
 27301                                  	;ADD	BX,32
 27302 000046E0 8D5F20                  	LEA	BX,[BX+32]
 27303 000046E3 39D3                    	CMP	BX,DX
 27304                                  	; 21/11/2022 - MSDOS 5.0 MSDOS.SYS (DOSCODE:7D5Dh)
 27305                                  	;JB	short HAVIT ; MSDOS 6.0 src (dir.asm)
 27306                                  	; 16/12/2022
 27307 000046E5 751C                    	jne	short HAVIT ; MSDOS 6.21 (DOSCODE:7D97h)
 27308 000046E7 8A1E[7305]              	MOV	BL,[SECCLUSPOS]
 27309 000046EB FEC3                    	INC	BL
 27310 000046ED 3A1E[7705]              	CMP	BL,[CLUSFAC]
 27311 000046F1 7215                    	JB	short SAMECLUS
 27312 000046F3 8B1E[DC05]              	MOV	BX,[NXTCLUSNUM]
 27313 000046F7 E80C18                  	call	IsEOF
 27314 000046FA 7305                    	JAE	short NONE
 27315                                  	; 23/07/2019
 27316 000046FC 83FB02                  	CMP	BX,2
 27317                                  	;JB	short NONE
 27318                                  	;JMP	short GETENT
 27319                                  	; 16/12/2022
 27320 000046FF 732D                    	jnb	short GETENT
 27321                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27322                                  	;JB	short NONE
 27323                                  	;JMP	short GETENT
 27324                                  NONE:
 27325 00004701 F9                      	STC
 27326 00004702 C3                      	retn
 27327                                  HAVIT:
 27328 00004703 A3[4803]                	MOV	[LASTENT],AX
 27329 00004706 F8                      	CLC
 27330                                  nextentry_retn:
 27331 00004707 C3                      	retn
 27332                                  SAMECLUS:
 27333 00004708 881E[7305]              	MOV	[SECCLUSPOS],BL
 27334 0000470C A3[4803]                	MOV	[LASTENT],AX
 27335 0000470F 1E                      	PUSH	DS
 27336 00004710 C53E[E205]              	LDS	DI,[CURBUF]
 27337                                  	; 19/05/2019
 27338                                  	; MSDOS 6.0
 27339                                  	;;mov	dx,[di+8]
 27340                                  	; 23/09/2023
 27341                                  	;MOV	DX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
 27342                                  ;hkn; SS override
 27343                                  	;MOV	[SS:HIGH_SECTOR],DX 		;AN000; >32mb
 27344                                  	; 23/09/2023
 27345 00004714 8B7508                  	mov	si,[di+BUFFINFO.buf_sector+2]	
 27346                                  	
 27347                                  	;mov	dx,[di+6]
 27348 00004717 8B5506                  	MOV	DX,[DI+BUFFINFO.buf_sector]	;AN000; >32mb
 27349                                  	;inc	dx ; MSDOS 3.3
 27350                                  	; MSDOS 6.0
 27351                                  	;ADD	DX,1				;AN000; >32mb
 27352                                  	;ADC	word [SS:HIGH_SECTOR],0 	;AN000; >32mb
 27353                                  	; 23/09/2023
 27354 0000471A 42                      	inc	dx
 27355 0000471B 7501                    	jnz	short nextexntry_fc
 27356 0000471D 46                      	inc	si
 27357                                  	;inc	word [SS:HIGH_SECTOR]
 27358                                  nextexntry_fc:
 27359                                  	; 23/09/2023
 27360 0000471E 368936[0706]            	mov	[SS:HIGH_SECTOR],si
 27361                                  	; MSDOS 3.3 & MSDOS 6.0
 27362 00004723 1F                      	POP	DS
 27363 00004724 E847F8                  	call	FIRSTCLUSTER
 27364 00004727 31DB                    	XOR	BX,BX
 27365 00004729 EB23                    	JMP	short SETENTRY
 27366                                  
 27367                                  ;----------------------------------------------------------------------------
 27368                                  ;
 27369                                  ; Procedure Name : GETENTRY
 27370                                  ;
 27371                                  ; Inputs:
 27372                                  ;	[LASTENT] has directory entry
 27373                                  ;	ES:BP points to drive parameters
 27374                                  ;	[DIRSEC],[CLUSNUM],[CLUSFAC],[ENTLAST] set for DIR involved
 27375                                  ; Function:
 27376                                  ;	Locates directory entry in preparation for search
 27377                                  ;	GETENT provides entry for passing desired entry in AX
 27378                                  ; Outputs:
 27379                                  ;	[CURBUF+2]:BX = Pointer to next directory entry in CURBUF
 27380                                  ;	[CURBUF+2]:DX = Pointer to first byte after end of CURBUF
 27381                                  ;	[LASTENT] = New directory entry number
 27382                                  ;	[NXTCLUSNUM],[SECCLUSPOS] set via DIRREAD
 27383                                  ;	Carry set if error (currently user FAILed to I 24)
 27384                                  ;----------------------------------------------------------------------------
 27385                                  
 27386                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27387                                  GETENTRY:
 27388                                  	; 27/07/2018 - Retro DOS v3.0
 27389 0000472B A1[4803]                	MOV	AX,[LASTENT]
 27390                                  
 27391                                  	;entry	GETENT
 27392                                  GETENT:
 27393 0000472E A3[4803]                	MOV	[LASTENT],AX
 27394                                  ;
 27395                                  ; Convert the entry number in AX into a byte offset from the beginning of the
 27396                                  ; directory.
 27397                                  ;
 27398 00004731 B105                    	mov	cl,5			; shift left by 5 = mult by 32
 27399 00004733 D3C0                    	rol	ax,cl			; keep hight order bits
 27400 00004735 89C2                    	mov	dx,ax
 27401                                  	; 19/05/2019 - Retro DOS v4.0
 27402                                  	;and	ax,0FFE0h
 27403                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27404                                  	;and	ax,~(32-1)		; mask off high order bits
 27405                                  	; 16/12/2022
 27406 00004737 24E0                    	and	al,0E0h ; ~31
 27407 00004739 83E21F                  	and	dx,1Fh
 27408                                  	;and	dx,32-1			; mask off low order bits
 27409                                  ;
 27410                                  ; DX:AX contain the byte offset of the required directory entry from the
 27411                                  ; beginning of the directory. Convert this to a sector number. Round the
 27412                                  ; sector size down to a multiple of 32.
 27413                                  ;
 27414                                  	;mov	bx,[es:bp+2]
 27415 0000473C 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
 27416 00004740 80E3E0                  	and	bl,0E0h
 27417                                  	;AND	BL,255-31		; Must be multiple of 32
 27418 00004743 F7F3                    	DIV	BX
 27419 00004745 89D3                    	MOV	BX,DX			; Position within sector
 27420 00004747 53                      	PUSH	BX
 27421 00004748 E8CFF7                  	call	DIRREAD
 27422 0000474B 5B                      	POP	BX
 27423                                  	;retc
 27424 0000474C 72B9                    	jc	short nextentry_retn	
 27425                                  SETENTRY:
 27426 0000474E 8B16[E205]              	MOV	DX,[CURBUF]
 27427                                  	;add	dx,16 ; MSDOS 3.3
 27428                                  	;add	dx,20 ; MSDOS 6.0 
 27429 00004752 83C218                  	ADD	DX,BUFINSIZ
 27430 00004755 01D3                    	ADD	BX,DX
 27431                                  	;add	dx,[es:bp+2]
 27432 00004757 26035602                	ADD	DX,[ES:BP+DPB.SECTOR_SIZE]  ; Always clears carry
 27433                                  	; 29/12/2022
 27434                                  	; MSDOS 6.21 MSDOS.SYS contains a 'CLC' here, at DOSCODE:7E15h
 27435 0000475B F8                      	clc
 27436 0000475C C3                      	retn
 27437                                  
 27438                                  ;----------------------------------------------------------------------------
 27439                                  
 27440                                  ; 23/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 27441                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:8933h
 27442                                  
 27443                                  sft_fcb_table:
 27444 0000475D 00<rep 14h>             	times 20 db 0
 27445                                  sftfcb.cluster:
 27446 00004771 00000000                	dd	0
 27447                                  sftfcb.direntry:
 27448 00004775 0000                    	dw	0
 27449                                  sftfcb_entry_size equ $ - sftfcb.cluster ; = 6
 27450                                  
 27451 00004777 00<rep 72h>             	times 114 db 0	; 6*20 = 120 ; entry size = 6 bytes 
 27452                                  
 27453                                  SRCH_CLUSTER:
 27454 000047E9 0000                    	dw	0
 27455                                  SRCH_CLUSTER_HW:
 27456 000047EB 0000                    	dw	0
 27457                                  
 27458                                  ;----------------------------------------------------------------------------
 27459                                  
 27460                                  ;Break	<SETDIRSRCH SETROOTSRCH -- Set Search environments>
 27461                                  ;----------------------------------------------------------------------------
 27462                                  ;
 27463                                  ; Procedure Name : SETDIRSRCH,SETROOTSRCH
 27464                                  ;
 27465                                  ; Inputs:
 27466                                  ;	BX cluster number of start of directory
 27467                                  ;	ES:BP Points to DPB
 27468                                  ;	DI next cluster number from fastopen extended info. DOS 3.3 only
 27469                                  ; Function:
 27470                                  ;	Set up a directory search
 27471                                  ; Outputs:
 27472                                  ;	[DIRSTART] = BX
 27473                                  ;	[CLUSFAC],[CLUSNUM],[SECCLUSPOS],[DIRSEC] set
 27474                                  ;	Carry set if error (currently user FAILed to I 24)
 27475                                  ; destroys AX,DX,BX
 27476                                  ;----------------------------------------------------------------------------
 27477                                  
 27478                                  ; 23/01/2024 - Retro DOS v5.0
 27479                                  %if 0
 27480                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27481                                  SETDIRSRCH:
 27482                                  	OR	BX,BX
 27483                                  	JZ	short SETROOTSRCH
 27484                                  	MOV	[DIRSTART],BX
 27485                                  	;mov	al,[es:bp+4]
 27486                                  	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
 27487                                  	INC	AL
 27488                                  	MOV	[CLUSFAC],AL
 27489                                  
 27490                                  ; DOS 3.3 for FastOPen	F.C. 6/12/86
 27491                                  	;SAVE	<SI>
 27492                                  	push	si
 27493                                  	;test	byte [FastOpenFlg],2
 27494                                  	TEST	byte [FastOpenFlg],Lookup_Success
 27495                                  	JNZ	short UNP_OK
 27496                                  
 27497                                  ; DOS 3.3 for FastOPen	F.C. 6/12/86
 27498                                  	;invoke	UNPACK
 27499                                  	call	UNPACK
 27500                                  	JNC	short UNP_OK
 27501                                  	;RESTORE <SI>
 27502                                  	pop	si
 27503                                  	;return
 27504                                  	retn
 27505                                  
 27506                                  UNP_OK:
 27507                                  	MOV	[CLUSNUM],DI
 27508                                  	MOV	DX,BX
 27509                                  	XOR	BL,BL
 27510                                  	MOV	[SECCLUSPOS],BL
 27511                                  	;invoke	FIGREC
 27512                                  	call	FIGREC
 27513                                  	;RESTORE <SI>
 27514                                  	pop	si
 27515                                  	
 27516                                  	; 19/05/2019 - Retro DOS v4.0
 27517                                  
 27518                                  	; MSDOS 6.0
 27519                                  	;PUSH	DX			   ;AN000; >32mb
 27520                                  	;MOV	DX,[HIGH_SECTOR]	   ;AN000; >32mb
 27521                                  	;MOV	[DIRSEC+2],DX		   ;AN000; >32mb
 27522                                  	;POP	DX			   ;AN000; >32mb
 27523                                  
 27524                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27525                                  	;push	dx
 27526                                  	;mov	dx,[HIGH_SECTOR]
 27527                                  	;mov	[DIRSEC+2],dx
 27528                                  	;pop	dx
 27529                                  	;MOV	[DIRSEC],dx
 27530                                  	; 16/12/2022
 27531                                  	mov	ax,[HIGH_SECTOR]
 27532                                  	mov	[DIRSEC+2],AX
 27533                                  	MOV	[DIRSEC],DX
 27534                                  
 27535                                  	; 16/12/2022
 27536                                  	; cf=0 (at the return of FIGREC)
 27537                                  	;CLC
 27538                                  	retn
 27539                                  
 27540                                  	;entry	SETROOTSRCH
 27541                                  SETROOTSRCH:
 27542                                  	XOR	AX,AX
 27543                                  	MOV	[DIRSTART],AX
 27544                                  	; 22/09/2023
 27545                                  	mov	[DIRSEC+2],ax ; 0
 27546                                  	MOV	[SECCLUSPOS],AL
 27547                                  	DEC	AX
 27548                                  	MOV	[CLUSNUM],AX
 27549                                  	;mov	ax,[es:bp+0Bh]
 27550                                  	MOV	AX,[ES:BP+DPB.FIRST_SECTOR]
 27551                                  	; 19/05/2019
 27552                                  	;;mov	dx,[es:bp+10h] ; MSDOS 3.3
 27553                                  	;mov	dx,[es:bp+11h] ; MSDOS 6.0
 27554                                  	MOV	DX,[ES:BP+DPB.DIR_SECTOR]
 27555                                  	SUB	AX,DX
 27556                                  	MOV	[CLUSFAC],AL
 27557                                  	MOV	[DIRSEC],DX		      ;F.C. >32mb
 27558                                  	; 22/09/2023
 27559                                  	; MSDOS 6.0
 27560                                  	;MOV	WORD [DIRSEC+2],0	      ;F.C. >32mb
 27561                                  	CLC
 27562                                  	retn
 27563                                  %else
 27564                                  	;;;
 27565                                  	; 23/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 27566                                  	; PCDOS 7.1 IBMDOS.COM - 8A27h
 27567                                  	;;;
 27568                                  SETDIRSRCH:
 27569 000047ED A1[F50A]                	mov	ax,[ROOTCLUST_HW]
 27570                                  	;cmp	word [ROOTCLUST_HW],0
 27571 000047F0 21C0                    	and	ax,ax	
 27572 000047F2 7504                    	jnz	short SETDIRSRCH_FAT32
 27573                                  	
 27574 000047F4 09DB                    	or	bx,bx
 27575                                  	;jz	short SETROOTSRCH
 27576 000047F6 7423                    	jz	short SETROOTSRCH2 ; ax = 0
 27577                                  SETDIRSRCH_FAT32:
 27578                                  	;mov	ax,[ROOTCLUST_HW]
 27579 000047F8 A3[E30A]                	mov	[DIRSTART_HW],ax
 27580 000047FB A3[EF0A]                	mov	[CLUSTNUM_HW],ax
 27581                                  
 27582 000047FE 891E[C205]              	mov	[DIRSTART],bx
 27583                                  	;mov	al,[es:bp+4]
 27584 00004802 268A4604                	mov	al,[es:bp+DPB.CLUSTER_MASK]
 27585                                  	;inc	al
 27586 00004806 40                      	inc	ax
 27587 00004807 A2[7705]                	mov	[CLUSFAC],al
 27588                                  
 27589 0000480A 56                      	push	si
 27590                                  	;test	byte [FastOpenFlg],2
 27591 0000480B F606[6D12]02            	test	byte [FastOpenFlg],Lookup_Success
 27592 00004810 7538                    	jnz	short UNP_OK
 27593                                  
 27594 00004812 E80817                  	call	UNPACK
 27595 00004815 7333                    	jnc	short UNP_OK
 27596                                  
 27597 00004817 5E                      	pop	si
 27598 00004818 C3                      	retn
 27599                                  
 27600                                  SETROOTSRCH:
 27601 00004819 31C0                    	xor	ax,ax ; 0
 27602                                  SETROOTSRCH2:
 27603 0000481B A3[F50A]                	mov	[ROOTCLUST_HW],ax ;0
 27604                                  	;cmp	word [es:bp+0Fh],0
 27605 0000481E 2639460F                	cmp	[es:bp+DPB.FAT_SIZE],ax ; 0
 27606 00004822 755A                    	jnz	short SETROOTSRCH_FAT ; not FAT32
 27607                                  SETROOTSRCH_FAT32:
 27608                                  	;mov	bx,[es:bp+37h]
 27609 00004824 268B5E37                	mov	bx,[es:bp+DPB.ROOT_CLUSTER+2]
 27610 00004828 891E[F50A]              	mov	[ROOTCLUST_HW],bx
 27611                                  	;cmp	bx,[es:bp+2Fh]
 27612 0000482C 263B5E2F                	cmp	bx,[es:bp+DPB.LAST_CLUSTER+2]
 27613                                  	;mov	bx,[es:bp+35h]
 27614 00004830 268B5E35                	mov	bx,[es:bp+DPB.ROOT_CLUSTER]
 27615 00004834 7504                    	jne	short sdsrch_fat32_1
 27616                                  	;cmp	bx,[es:bp+2Dh]
 27617 00004836 263B5E2D                	cmp	bx,[es:bp+DPB.LAST_CLUSTER]
 27618                                  sdsrch_fat32_1:
 27619 0000483A 770C                    	ja	short sdsrch_fat32_3 ; **
 27620 0000483C 833E[F50A]00            	cmp	word [ROOTCLUST_HW],0
 27621                                  	;jnz	short sdsrtch_fat32_2
 27622 00004841 75B5                    	jnz	short SETDIRSRCH_FAT32
 27623 00004843 83FB02                  	cmp	bx,2
 27624                                  	;jb	short sdsrch_fat32_3
 27625                                  sdsrch_fat32_2:
 27626                                  	;jmp	SETDIRSRCH_FAT32
 27627 00004846 73B0                    	jnb	short SETDIRSRCH_FAT32
 27628                                  
 27629                                  sdsrch_fat32_3:
 27630 00004848 F9                      	stc	; **
 27631                                  	;jmp	short setdirsrch_retn
 27632 00004849 C3                      	retn
 27633                                  
 27634                                  UNP_OK:
 27635                                  	; CCONTENT_HW:DI = Contents of FAT for given cluster
 27636                                  	;			(from UNPACK)
 27637 0000484A 893E[BC05]              	mov	[CLUSNUM],di
 27638 0000484E 8B16[F30A]              	mov	dx,[CCONTENT_HW]
 27639 00004852 8916[E50A]              	mov	[CLUSNUM_HW],dx
 27640 00004856 2E891E[E947]            	mov	[cs:SRCH_CLUSTER],bx ; Directory start cluster number
 27641                                  				; for searching/locating (directory entry)
 27642 0000485B 8B16[EF0A]              	mov	dx,[CLUSTNUM_HW]
 27643 0000485F 2E8916[EB47]            	mov	[cs:SRCH_CLUSTER_HW],dx
 27644                                  
 27645 00004864 89DA                    	mov	dx,bx
 27646 00004866 30DB                    	xor	bl,bl
 27647 00004868 881E[7305]              	mov	[SECCLUSPOS],bl
 27648                                  
 27649                                  	;CLUSTNUM_HW:DX = Physical cluster number (to FIGREC)
 27650                                  
 27651 0000486C E8570F                  	call	FIGREC
 27652                                  
 27653 0000486F 8B36[0706]              	mov	si,[HIGH_SECTOR]
 27654 00004873 8936[C005]              	mov	[DIRSEC+2],si
 27655 00004877 5E                      	pop	si
 27656                                  SETROOTSRCH3:
 27657 00004878 8916[BE05]              	mov	[DIRSEC],dx ; *
 27658                                  	
 27659                                  	;pop	si
 27660 0000487C F8                      	clc	; (this may not be needed,
 27661                                  		; FIGREC clears cf except an abnormal sector calc overflow)
 27662 0000487D C3                      	retn
 27663                                  
 27664                                  SETROOTSRCH_FAT:
 27665                                  	;xor	ax,ax
 27666 0000487E A3[C005]                	mov	[DIRSEC+2],ax ; 0
 27667 00004881 A3[C205]                	mov	[DIRSTART],ax ; 0
 27668 00004884 A3[E30A]                	mov	[DIRSTART_HW],ax ; 0
 27669 00004887 2EA3[EB47]              	mov	[cs:SRCH_CLUSTER_HW],ax ; 0
 27670 0000488B 40                      	inc	ax		; search start dir cluster num = 1
 27671                                  				; (root directory)
 27672 0000488C 2EA3[E947]              	mov	[cs:SRCH_CLUSTER],ax ; 1 ; FAT root directory (<2)
 27673 00004890 48                      	dec	ax ; 0
 27674 00004891 A2[7305]                	mov	[SECCLUSPOS],al
 27675 00004894 48                      	dec	ax ; -1
 27676 00004895 A3[BC05]                	mov	[CLUSNUM],ax ; 0FFFFh
 27677 00004898 A3[E50A]                	mov	[CLUSNUM_HW],ax ; 0FFFFh
 27678                                  
 27679                                  	;mov	ax,[es:bp+0Bh]
 27680 0000489B 268B460B                	mov	ax,[es:bp+DPB.FIRST_SECTOR]
 27681                                  	;mov	dx,[es:bp+11h]
 27682 0000489F 268B5611                	mov	dx,[es:bp+DPB.DIR_SECTOR]
 27683 000048A3 29D0                    	sub	ax,dx
 27684 000048A5 A2[7705]                	mov	[CLUSFAC],al
 27685                                  	;mov	[DIRSEC],dx ; *
 27686                                  	;clc
 27687                                  ;setdirsrch_retn:
 27688                                  	;retn
 27689 000048A8 EBCE                    	jmp	short SETROOTSRCH3
 27690                                  	;;;
 27691                                  %endif
 27692                                  
 27693                                  ;----------------------------------------------------------------------------
 27694                                  
 27695                                  ; 23/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 27696                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:8A90h
 27697                                  
 27698                                  ; set SFT number and entry in the new internal table (only for FCB calls)
 27699                                  
 27700                                  set_sftfcb_entry:
 27701 000048AA 50                      	push	ax
 27702 000048AB 51                      	push	cx
 27703 000048AC 52                      	push	dx
 27704 000048AD 53                      	push	bx
 27705                                  
 27706                                  	;push	bp
 27707                                  	;push	si
 27708                                  	;push	di              ; ES:DI = SFT entry
 27709                                  
 27710 000048AE E84B00                  	call	find_sft_entry_number
 27711                                  				; ax = SFT entry index number
 27712                                  				;      of the last SFT entry
 27713 000048B1 31DB                    	xor	bx,bx
 27714 000048B3 B91400                  	mov	cx,20		; find empty entry (slot) in the table
 27715                                  	; Retro DOS v5.0
 27716 000048B6 31D2                    	xor	dx,dx ; *
 27717                                  set_sftfcbe_1:
 27718                                  	;;cmp	cs:(sftfcb_cluster+2)[bx],0
 27719                                  	;cmp	word [cs:bx+sftfcb.cluster+2],0
 27720                                  				; directory (search) starting cluster, hw
 27721 000048B8 2E3997[7347]            	cmp	[cs:bx+sftfcb.cluster+2],dx ; 0
 27722 000048BD 7505                    	jnz	short set_sftfcbe_2
 27723                                  	;;cmp	cs:sftfcb_cluster[bx], 
 27724                                  	;cmp	word [cs:bx+sftfcb.cluster],0
 27725                                  				; directory (search) starting cluster, lw
 27726 000048BF 2E3997[7147]            	cmp	[cs:bx+sftfcb.cluster],dx ; 0
 27727                                  set_sftfcbe_2:
 27728 000048C4 752C                    	jnz	short set_sftfcbe_3
 27729                                  				; not empty (sfcb table) entry
 27730                                  	; Retro DOS v5.0
 27731                                  	;push	cx
 27732                                  
 27733 000048C6 2E8B0E[E947]            	mov	cx,[cs:SRCH_CLUSTER]
 27734                                  				; search start dir cluster number
 27735                                  	;mov	cs:sftfcb_cluster[bx],cx
 27736 000048CB 2E898F[7147]            	mov	[cs:bx+sftfcb.cluster],cx
 27737                                  				; directory start cluster
 27738 000048D0 2E8B0E[EB47]            	mov     cx,[cs:SRCH_CLUSTER_HW]
 27739                                  	
 27740                                  	; PCDOS 7.1 BUG! (This would be '[cs:bx:sftfcb.cluster+2],cx')
 27741                                  	; Erdogan Tan - 23/01/2024
 27742                                  	;mov	cs:sftfcb_cluster[bx]
 27743                                  	;mov	[cs:bx:sftfcb.cluster],cx ; PCDOS 7.1 IBMDOS.COM - DOSCODE:8ABFh
 27744                                  	; Retro DOS v5.0
 27745 000048D5 2E898F[7347]            	mov	[cs:bx+sftfcb.cluster+2],cx
 27746                                  
 27747                                  	;pop	cx
 27748                                  
 27749                                  	;mov	dx,[ss:LASTENT]	; LAST (found) entry in the directory
 27750                                  	;;mov	cs:sftfcb_direntry[bx],dx
 27751                                  	;mov	[cs:bx+sftfcb.direntry],dx
 27752                                  				; directory entry number
 27753 000048DA 368B0E[4803]            	mov	cx,[ss:LASTENT]
 27754 000048DF 2E898F[7547]            	mov	[cs:bx+sftfcb.direntry],cx	
 27755                                  
 27756 000048E4 93                      	xchg	ax,bx
 27757                                  	;xor	dx,dx ; *
 27758                                  	; dx = 0
 27759 000048E5 B90600                  	mov	cx,6		; sftfcb table has 6 byte entries
 27760 000048E8 F7F1                    	div	cx
 27761 000048EA 93                      	xchg	ax,bx
 27762 000048EB 2E8887[5D47]            	mov	[cs:bx+sft_fcb_table], al
 27763                                  				; put SFT entry number in SFT-FCB
 27764                                  				; table (offset is FCB index number 0 to 19)
 27765 000048F0 EB05                    	jmp     short set_setfcbe_4
 27766                                  set_sftfcbe_3:
 27767                                  	;add	bx,6
 27768 000048F2 83C306                  	add	bx,sftfcb_entry_size ; 6
 27769 000048F5 E2C1                    	loop	set_sftfcbe_1
 27770                                  
 27771                                  set_setfcbe_4:
 27772                                  	;pop	di
 27773                                  	;pop	si
 27774                                  	;pop	bp
 27775                                  	
 27776 000048F7 5B                      	pop	bx
 27777 000048F8 5A                      	pop	dx
 27778 000048F9 59                      	pop	cx
 27779 000048FA 58                      	pop	ax
 27780 000048FB C3                      	retn
 27781                                  
 27782                                  ;----------------------------------------------------------------------------
 27783                                  
 27784                                  ; 24/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 27785                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:8AECh
 27786                                  
 27787                                  find_sft_entry_number:
 27788 000048FC C3                      	retn
 27789                                  
 27790                                  ;----------------------------------------------------------------------------
 27791                                  
 27792                                  ; 24/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 27793                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:8B22h
 27794                                  
 27795                                  int_2Fh_1230h:
 27796 000048FD C3                      	retn
 27797                                  
 27798                                  ;----------------------------------------------------------------------------
 27799                                  
 27800                                  ; 24/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 27801                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:8B6Dh
 27802                                  
 27803                                  SFT_FREE:
 27804 000048FE C3                      	retn
 27805                                  
 27806                                  ;----------------------------------------------------------------------------
 27807                                  
 27808                                  ;============================================================================
 27809                                  ; DIR2.ASM, MSDOS 6.0, 1991
 27810                                  ;============================================================================
 27811                                  ; 27/07/2018 - Retro DOS v3.0
 27812                                  ; 19/05/2019 - Retro DOS v4.0 
 27813                                  
 27814                                  ;	TITLE	DIR2 - Directory and path cracking
 27815                                  ;	NAME	Dir2
 27816                                  
 27817                                  ;Break	<GETPATH -- PARSE A WFP>
 27818                                  ;----------------------------------------------------------------------------
 27819                                  ;
 27820                                  ; Procedure Name : GETPATH
 27821                                  ;
 27822                                  ; Inputs:
 27823                                  ;	[WFP_START] Points to WFP string ("d:\" must be first 3 chars, NUL
 27824                                  ;		terminated; d:/ (note forward slash) indicates a real device).
 27825                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 27826                                  ;		( = -1 if current dir not involved, else
 27827                                  ;		 Points to first char after last "/" of current dir part)
 27828                                  ;	[THISCDS] Points to CDS being used
 27829                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 27830                                  ;	[NoSetDir] set
 27831                                  ;	[THISDPB] set to DPB if disk otherwise garbage.
 27832                                  ; Function:
 27833                                  ;	Crack the path
 27834                                  ; Outputs:
 27835                                  ;	Sets EXTERR_LOCUS = errLOC_Disk if disk file
 27836                                  ;	Sets EXTERR_LOCUS = errLOC_Unk if char device
 27837                                  ;	ID1 field of [THISCDS] updated appropriately
 27838                                  ;	[ATTRIB] = [SATTRIB]
 27839                                  ;	ES:BP Points to DPB
 27840                                  ;	Carry set if bad path
 27841                                  ;	   SI Points to path element causing failure
 27842                                  ;	   Zero set
 27843                                  ;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
 27844                                  ;	      start a search on the last directory
 27845                                  ;	      CL is zero if there is a bad name in the path
 27846                                  ;	      CL is non-zero if the name was simply not found
 27847                                  ;		 [ENTFREE] may have free spot in directory
 27848                                  ;		 [NAME1] is the name.
 27849                                  ;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
 27850                                  ;	   Zero reset
 27851                                  ;	      File in middle of path or bad name in path or attribute mismatch
 27852                                  ;		or path too long or malformed path
 27853                                  ;	ELSE
 27854                                  ;	   [CurBuf] = -1 if root directory
 27855                                  ;	   [CURBUF] contains directory record with match
 27856                                  ;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
 27857                                  ;	   [CURBUF+2]:SI Points into [CURBUF] to dir_first field for entry
 27858                                  ;	   AH = device ID
 27859                                  ;	      bit 7 of AH set if device SI and BX
 27860                                  ;	      will point DOSGROUP relative The firclus
 27861                                  ;	      field of the device entry contains the device pointer
 27862                                  ;	   [NAME1] Has name looked for
 27863                                  ;	   If last element is a directory zero is set and:
 27864                                  ;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
 27865                                  ;	      are set up to start a search on it.
 27866                                  ;	      unless [NoSetDir] is non zero in which case the return is
 27867                                  ;	      like that for a file (except for zero flag)
 27868                                  ;	   If last element is a file zero is reset
 27869                                  ;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
 27870                                  ;	      [LASTENT], [ENTLAST] are set to continue search of last
 27871                                  ;	      directory for furthur matches on NAME1 via the NEXTENT
 27872                                  ;	      entry point in FindEntry (or GETENT entry in GETENTRY in
 27873                                  ;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
 27874                                  ; DS preserved, Others destroyed
 27875                                  ;---------------------------------------------------------------------------
 27876                                  
 27877                                  ;hkn; called from delete.asm, finfo.asm, mknode.asm and rename.asm.
 27878                                  ;hkn; DS already set up at this point.
 27879                                  
 27880                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27881                                  GETPATH:
 27882                                  	;mov	word [CREATING],0E500h
 27883 000048FF C706[7E05]00E5          	MOV	WORD [CREATING],DIRFREE*256+0 ; Not Creating, not DEL *.*
 27884                                  
 27885                                  ; Same as GetPath only CREATING and DELALL already set
 27886                                  
 27887                                  	;entry	GetPathNoSet
 27888                                  GetPathNoSet:
 27889                                  	;mov	byte [EXTERR_LOCUS],2	
 27890 00004905 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 27891 0000490A C706[E205]FFFF          	MOV	word [CURBUF],-1	; initial setting
 27892                                  
 27893                                  ; See if the input indicates a device that has already been detected. If so,
 27894                                  ; go build the guy quickly. Otherwise, let findpath find the device.
 27895                                  
 27896 00004910 8B3E[B205]              	MOV	DI,[WFP_START]		; point to the beginning of the name
 27897                                  	;cmp	word [DI+1],5C3Ah
 27898                                  	;CMP	WORD [DI+1],'\' << 8 + ':'
 27899 00004914 817D013A5C              	cmp	word [DI+1],':\'
 27900 00004919 7438                    	JZ	short CrackIt
 27901                                  
 27902                                  ; Let ChkDev find it in the device list
 27903                                  
 27904 0000491B 83C703                  	ADD	DI,3
 27905                                  	; 18/08/2018
 27906                                  	;MOV	SI,DI			; let CHKDEV see the original name
 27907                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27908                                  	; 16/12/2022
 27909                                  	;mov	si,di ; not required ! (it is written in CHKDEV proc already!)
 27910 0000491E E8AB00                  	CALL	CHKDEV
 27911 00004921 722E                    	JC	short InternalError
 27912                                  
 27913                                  Build_devJ:
 27914 00004923 A0[6D05]                	MOV	AL,[SATTRIB]
 27915 00004926 A2[6B05]                	MOV	[ATTRIB],AL
 27916                                  	;mov	byte [EXTERR_LOCUS],1
 27917 00004929 C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; In the particular case of
 27918                                  					; "finding" a char device
 27919                                  					; set LOCUS to Unknown. This makes
 27920                                  					; certain idiotic problems reported
 27921                                  					; by a certain 3 letter OEM go away.
 27922                                  
 27923                                  ; Take name in name1 and pack it back into where wfp_start points. This
 27924                                  ; guarantees wfp_start pointing to a canonical representation of a device.
 27925                                  ; We are allowed to do this as GetPath is *ALWAYS* called before entering a
 27926                                  ; wfp into the share set.
 27927                                  ;
 27928                                  ; We copy chars from name1 to wfp_start remembering the position of the last
 27929                                  ; non-space seen +1.  This position is kept in DX.
 27930                                  
 27931                                  ;hkn; SS is DOSDATA
 27932 0000492E 16                      	push	ss
 27933 0000492F 07                      	pop	es
 27934                                  
 27935                                  ;hkn; NAME1 is in DOSDATA
 27936 00004930 BE[4B05]                	mov	si,NAME1
 27937 00004933 8B3E[B205]              	mov	di,[WFP_START]
 27938 00004937 89FA                    	mov	dx,di
 27939 00004939 B90800                  	mov	cx,8			; 8 chars in device name
 27940                                  MoveLoop:
 27941 0000493C AC                      	lodsb
 27942 0000493D AA                      	stosb
 27943 0000493E 3C20                    	cmp	al," "
 27944 00004940 7402                    	jz	short NoSave
 27945                                  
 27946 00004942 89FA                    	mov	dx,di
 27947                                  NoSave:
 27948 00004944 E2F6                    	loop	MoveLoop
 27949                                  
 27950                                  ; DX is the position of the last seen non-space + 1. We terminate the name
 27951                                  ; at this point.
 27952                                  
 27953 00004946 89D7                    	mov	di,dx
 27954 00004948 C60500                  	mov	byte [di],0		; end of string
 27955 0000494B E8C402                  	call	Build_device_ent	; Clears carry sets zero
 27956 0000494E FEC0                    	INC	AL			; reset zero
 27957 00004950 C3                      	retn
 27958                                  
 27959                                  InternalError:
 27960                                  InternalError_loop:
 27961 00004951 EBFE                    	JMP	short InternalError_loop	; freeze
 27962                                  
 27963                                  ; Start off at the correct spot. Optimize if the current dir part is valid.
 27964                                  
 27965                                  CrackIt:
 27966 00004953 8B36[B605]              	MOV	SI,[CURR_DIR_END]	; get current directory pointer
 27967 00004957 83FEFF                  	CMP	SI,-1			; valid?
 27968 0000495A 7503                    	JNZ	short LOOK_SING		; Yes, use it.
 27969 0000495C 8D7503                  	LEA	SI,[DI+3]		; skip D:\.
 27970                                  LOOK_SING:
 27971                                  	;mov	byte [ATTRIB],16h
 27972 0000495F C606[6B05]16            	MOV	byte [ATTRIB],attr_directory+attr_system+attr_hidden
 27973                                  					; Attributes to search through Dirs
 27974 00004964 C43E[A205]              	LES	DI,[THISCDS]
 27975 00004968 B8FFFF                  	MOV	AX,-1
 27976                                  	;mov	bx,[es:di+73]
 27977 0000496B 268B5D49                	MOV	BX,[ES:DI+curdir.ID]
 27978 0000496F 8B36[B605]              	MOV	SI,[CURR_DIR_END]
 27979                                  
 27980                                  ; AX = -1
 27981                                  ; BX = cluster number of current directory. THis number is -1 if the media
 27982                                  ;      has been uncertainly changed.
 27983                                  ; SI = offset in DOSGroup into path to end of current directory text. This
 27984                                  ;      may be -1 if no current directory part has been used.
 27985                                  
 27986 00004973 39C6                    	CMP	SI,AX			; if Current directory is not part
 27987 00004975 743B                    	JZ	short NO_CURR_D		; then we must crack from root
 27988 00004977 39C3                    	CMP	BX,AX			; is the current directory cluster valid
 27989                                  
 27990                                  ; DOS 3.3  6/25/86
 27991 00004979 7437                    	JZ	short NO_CURR_D		; no, crack form the root
 27992                                  	;test	byte [FastOpenFlg],1
 27993 0000497B F606[6D12]01            	TEST	byte [FastOpenFlg],FastOpen_Set ; for fastopen ?
 27994 00004980 743D                    	JZ	short GOT_SEARCH_CLUSTER	; no
 27995 00004982 06                      	PUSH	ES			; save registers
 27996 00004983 57                      	PUSH	DI
 27997 00004984 51                      	PUSH	CX
 27998 00004985 FF74FF                  	PUSH	word [SI-1]		; save \ and 1st char of next element
 27999 00004988 56                      	PUSH	SI
 28000 00004989 53                      	PUSH	BX
 28001                                  
 28002 0000498A C644FF00                	MOV	BYTE [SI-1],0		; call fastopen to look up cur dir info
 28003 0000498E 8B36[B205]              	MOV	SI,[WFP_START]
 28004                                  
 28005                                  ;hkn; FastOpenTable, Dir_Info_Buff & FastOpen_Ext_Info are in DOSDATA
 28006 00004992 BB[6312]                	MOV	BX,FastOpenTable
 28007 00004995 BF[970D]                	MOV	DI,Dir_Info_Buff
 28008 00004998 B9[8C0D]                	MOV	CX,FastOpen_Ext_Info
 28009                                  	;mov	al,1
 28010 0000499B B001                    	MOV	AL,FONC_Look_up
 28011 0000499D 1E                      	PUSH	DS
 28012 0000499E 07                      	POP	ES
 28013                                  	;call	far [BX+2]
 28014 0000499F FF5F02                  	CALL	far [BX+fastopen_entry.name_caching]
 28015 000049A2 7203                    	JC	short GO_Chk_end1 	;fastopen not installed, or wrong drive.
 28016                                  					; Go to Got_Srch_cluster
 28017                                  	; 29/12/2022
 28018                                  	;CMP	BYTE [SI],0		;fastopen has current dir info?
 28019                                  	;JE	short GO_Chk_end	;yes. Go to got_search_cluster
 28020                                  	;stc
 28021                                  	;jmp	short GO_Chk_end	;Go to No_Curr_D
 28022                                  
 28023 000049A4 803C01                  	cmp	byte [si],1
 28024                                  GO_Chk_end1:	; 29/12/2022
 28025 000049A7 F5                      	cmc 
 28026                                  	; [si] = 0 -> cf = 0
 28027                                  	; [si] > 0 -> cf = 1
 28028                                  
 28029                                  ;GO_Chk_end1:
 28030                                  	; 29/12/2022
 28031                                  	;clc
 28032                                  
 28033                                  GO_Chk_end:				; restore registers
 28034 000049A8 5B                      	POP	BX
 28035 000049A9 5E                      	POP	SI
 28036 000049AA 8F44FF                  	POP	word [SI-1]
 28037 000049AD 59                      	POP	CX
 28038 000049AE 5F                      	POP	DI
 28039 000049AF 07                      	POP	ES
 28040 000049B0 730D                    	JNC	short GOT_SEARCH_CLUSTER ; crack based on cur dir
 28041                                  
 28042                                  ; DOS 3.3  6/25/86
 28043                                  ;
 28044                                  ; We must cract the path beginning at the root. Advance pointer to beginning
 28045                                  ; of path and go crack from root.
 28046                                  
 28047                                  NO_CURR_D:
 28048 000049B2 8B36[B205]              	MOV	SI,[WFP_START]
 28049 000049B6 8D7403                  	LEA	SI,[SI+3]		; Skip "d:/"
 28050 000049B9 C42E[8A05]              	LES	BP,[THISDPB]		; Get ES:BP
 28051 000049BD EB3B                    	JMP	short ROOTPATH
 28052                                  
 28053                                  ; We are able to crack from the current directory part. Go set up for search
 28054                                  ; of specified cluster.
 28055                                  
 28056                                  GOT_SEARCH_CLUSTER:
 28057 000049BF C42E[8A05]              	LES	BP,[THISDPB]		; Get ES:BP
 28058 000049C3 E827FE                  	call	SETDIRSRCH
 28059                                  	;JC	short SETFERR
 28060                                  	;JMP	short FINDPATH
 28061                                  	; 16/12/2022
 28062 000049C6 7342                    	jnc	short FINDPATH ; 17/08/2018
 28063                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28064                                  	;JC	short SETFERR
 28065                                  	;JMP	short FINDPATH
 28066                                  SETFERR:
 28067 000049C8 30C9                    	XOR	CL,CL			; set zero
 28068 000049CA F9                      	STC
 28069 000049CB C3                      	retn
 28070                                  
 28071                                  ;---------------------------------------------------------------------------
 28072                                  ;
 28073                                  ; Procedure Name : ChkDev
 28074                                  ;
 28075                                  ; Check to see if the name at DS:DI is a device. Returns carry set if not a
 28076                                  ;   device.
 28077                                  ; Blasts CX,SI,DI,AX,BX
 28078                                  ;---------------------------------------------------------------------------
 28079                                  
 28080                                  CHKDEV:
 28081 000049CC 89FE                    	MOV	SI,DI
 28082 000049CE 8CD7                    	MOV	DI,SS
 28083 000049D0 8EC7                    	MOV	ES,DI
 28084                                  
 28085 000049D2 BF[4B05]                	MOV	DI,NAME1
 28086 000049D5 B90900                  	MOV	CX,9
 28087                                  TESTLOOP:
 28088 000049D8 E84910                  	call	GETLET
 28089                                  
 28090 000049DB 3C2E                    	CMP	AL,'.'
 28091 000049DD 740E                    	JZ	short TESTDEVICE
 28092 000049DF E89810                  	call	PATHCHRCMP
 28093 000049E2 7407                    	JZ	short NOTDEV
 28094 000049E4 08C0                    	OR	AL,AL
 28095 000049E6 7405                    	JZ	short TESTDEVICE
 28096                                  
 28097 000049E8 AA                      	STOSB
 28098 000049E9 E2ED                    	LOOP	TESTLOOP
 28099                                  NOTDEV:
 28100 000049EB F9                      	STC
 28101 000049EC C3                      	retn
 28102                                  
 28103                                  TESTDEVICE:
 28104                                  	;ADD	CX,2
 28105                                  	; 24/09/2023
 28106 000049ED 41                      	inc	cx
 28107 000049EE 41                      	inc	cx
 28108 000049EF B020                    	MOV	AL,' '
 28109 000049F1 F3AA                    	REP	STOSB
 28110 000049F3 8CD0                    	MOV	AX,SS
 28111 000049F5 8ED8                    	MOV	DS,AX
 28112                                  	;call	DEVNAME
 28113                                  	;retn
 28114                                  	; 18/12/2022
 28115 000049F7 E9B901                  	jmp	DEVNAME
 28116                                  
 28117                                  ;Break	<ROOTPATH, FINDPATH -- PARSE A PATH>
 28118                                  ;----------------------------------------------------------------------------
 28119                                  ;
 28120                                  ; Procedure Name : ROOTPATH,FINDPATH
 28121                                  ;
 28122                                  ; Inputs:
 28123                                  ;	Same as FINDPATH but,
 28124                                  ;	SI Points to asciz string of path which is assumed to start at
 28125                                  ;		the root (no leading '/').
 28126                                  ; Function:
 28127                                  ;	Search from root for path
 28128                                  ; Outputs:
 28129                                  ;	Same as FINDPATH but:
 28130                                  ;	If root directory specified, [CURBUF] and [NAME1] are NOT set, and
 28131                                  ;	[NoSetDir] is ignored.
 28132                                  ;----------------------------------------------------------------------------
 28133                                  
 28134                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28135                                  	; DOSCODE:7F47h (MSDOS 5.0, MSDOS.SYS)
 28136                                  
 28137                                  ROOTPATH:
 28138 000049FA E81CFE                  	call	SETROOTSRCH
 28139                                  	; 24/09/2023
 28140 000049FD 30E4                    	xor	ah,ah
 28141                                  	;CMP	BYTE [SI],0
 28142 000049FF 3824                    	cmp	[si],ah ; 0
 28143 00004A01 7507                    	JNZ	short FINDPATH
 28144                                  
 28145                                  ; Root dir specified
 28146 00004A03 A0[6D05]                	MOV	AL,[SATTRIB]
 28147 00004A06 A2[6B05]                	MOV	[ATTRIB],AL
 28148                                  	; 24/09/2023
 28149                                  	;XOR	AH,AH			; Sets "device ID" byte, sets zero
 28150                                  					; (dir), clears carry.
 28151 00004A09 C3                      	retn
 28152                                  
 28153                                  ; Inputs:
 28154                                  ;	[ATTRIB] Set to get through directories
 28155                                  ;	[SATTRIB] Set to find last element
 28156                                  ;	ES:BP Points to DPB
 28157                                  ;	SI Points to asciz string of path (no leading '/').
 28158                                  ;	[SECCLUSPOS] = 0
 28159                                  ;	[DIRSEC] = Phys sec # of first sector of directory
 28160                                  ;	[CLUSNUM] = Cluster # of next cluster
 28161                                  ;	[CLUSFAC] = Sectors per cluster
 28162                                  ;	[NoSetDir] set
 28163                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 28164                                  ;		( = -1 if current dir not involved, else
 28165                                  ;		 Points to first char after last "/" of current dir part)
 28166                                  ;	[THISCDS] Points to CDS being used
 28167                                  ;	[CREATING] and [DELALL] set
 28168                                  ; Function:
 28169                                  ;	Parse path name
 28170                                  ; Outputs:
 28171                                  ;	ID1 field of [THISCDS] updated appropriately
 28172                                  ;	[ATTRIB] = [SATTRIB]
 28173                                  ;	ES:BP Points to DPB
 28174                                  ;	[THISDPB] = ES:BP
 28175                                  ;	Carry set if bad path
 28176                                  ;	   SI Points to path element causing failure
 28177                                  ;	   Zero set
 28178                                  ;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
 28179                                  ;	      start a search on the last directory
 28180                                  ;	      CL is zero if there is a bad name in the path
 28181                                  ;	      CL is non-zero if the name was simply not found
 28182                                  ;		 [ENTFREE] may have free spot in directory
 28183                                  ;		 [NAME1] is the name.
 28184                                  ;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
 28185                                  ;	   Zero reset
 28186                                  ;	      File in middle of path or bad name in path
 28187                                  ;		or path too long or malformed path
 28188                                  ;	ELSE
 28189                                  ;	   [CURBUF] contains directory record with match
 28190                                  ;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
 28191                                  ;	   [CURBUF+2]:SI Points to fcb_FIRCLUS field for entry
 28192                                  ;	   [NAME1] Has name looked for
 28193                                  ;	   AH = device ID
 28194                                  ;	      bit 7 of AH set if device SI and BX
 28195                                  ;	      will point DOSGROUP relative The firclus
 28196                                  ;	      field of the device entry contains the device pointer
 28197                                  ;	   If last element is a directory zero is set and:
 28198                                  ;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
 28199                                  ;	      are set up to start a search on it,
 28200                                  ;	      unless [NoSetDir] is non zero in which case the return is
 28201                                  ;	      like that for a file (except for zero flag)
 28202                                  ;	   If last element is a file zero is reset
 28203                                  ;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
 28204                                  ;	      [LASTENT], [ENTLAST] are set to continue search of last
 28205                                  ;	      directory for furthur matches on NAME1 via the NEXTENT
 28206                                  ;	      entry point in FindEntry (or GETENT entry in GETENTRY in
 28207                                  ;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
 28208                                  ; Destroys all other registers
 28209                                  
 28210                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28211                                  	; DOSCODE:7F58h (MSDOS 5.0, MSDOS.SYS)
 28212                                  
 28213                                      	;entry	FINDPATH
 28214                                  FINDPATH:
 28215 00004A0A 06                      	PUSH	ES			; Save ES:BP
 28216 00004A0B 56                      	PUSH	SI
 28217 00004A0C 89F7                    	MOV	DI,SI
 28218 00004A0E 8B0E[C205]              	MOV	CX,[DIRSTART]		; Get start clus of dir being searched
 28219 00004A12 833E[B605]FF            	CMP	word [CURR_DIR_END],-1
 28220 00004A17 740E                    	JZ	short NOIDS		; No current dir part
 28221 00004A19 3B3E[B605]              	CMP	DI,[CURR_DIR_END]
 28222 00004A1D 7508                    	JNZ	short NOIDS		; Not to current dir end yet
 28223 00004A1F C43E[A205]              	LES	DI,[THISCDS]
 28224                                  	;mov	[es:di+73],cx
 28225 00004A23 26894D49                	MOV	[ES:DI+curdir.ID],CX	; Set current directory currency
 28226                                  NOIDS:
 28227                                  
 28228                                  ; Parse the name off of DS:SI into NAME1. AL = 1 if there was a meta
 28229                                  ; character in the string. CX,DI may be destroyed.
 28230                                  ;
 28231                                  ;	invoke	NAMETRANS
 28232                                  ;	MOV	CL,AL
 28233                                  ;
 28234                                  ; The above is the slow method. The name has *already* been munged by
 28235                                  ; TransPath so no special casing needs to be done. All we do is try to copy
 28236                                  ; the name until ., \ or 0 is hit.
 28237                                  
 28238 00004A27 8CD0                    	MOV	AX,SS
 28239 00004A29 8EC0                    	MOV	ES,AX
 28240                                  
 28241                                  ;hkn; Name1 is in DOSDATA
 28242 00004A2B BF[4B05]                	MOV	DI,NAME1
 28243 00004A2E B82020                  	MOV	AX,'  ' ; 2020h
 28244 00004A31 AA                      	STOSB
 28245 00004A32 AB                      	STOSW
 28246 00004A33 AB                      	STOSW
 28247 00004A34 AB                      	STOSW
 28248 00004A35 AB                      	STOSW
 28249 00004A36 AB                      	STOSW
 28250                                  
 28251                                  ;hkn; Name1 is in DOSDATA
 28252 00004A37 BF[4B05]                	MOV	DI,NAME1
 28253 00004A3A 30E4                    	XOR	AH,AH			; bits for CL
 28254                                  GetNam:
 28255                                  	; 19/05/2019 - Retro DOS v4.0
 28256                                  	;INC	CL ; ?*! ; MSDOS 6.0	;AN000; KK increment volid count
 28257                                  
 28258                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28259                                  	; 16/12/2022
 28260                                  	;inc	cl ; not required !	
 28261                                  	
 28262 00004A3C AC                      	LODSB
 28263 00004A3D 3C2E                    	CMP	AL,'.'	; 2Eh
 28264 00004A3F 7412                    	JZ	short _SetExt
 28265 00004A41 08C0                    	OR	AL,AL
 28266 00004A43 7424                    	JZ	short _GetDone
 28267 00004A45 3C5C                    	CMP	AL,'\'	; 5Ch
 28268 00004A47 7420                    	JZ	short _GetDone
 28269 00004A49 3C3F                    	CMP	AL,'?'	; 3Fh
 28270 00004A4B 7503                    	JNZ	short StoNam
 28271 00004A4D 80CC01                  	OR	AH,1
 28272                                  StoNam: 
 28273 00004A50 AA                      	STOSB
 28274 00004A51 EBE9                    	JMP	short GetNam
 28275                                  _SetExt:
 28276 00004A53 BF[5305]                	MOV	DI,NAME1+8
 28277                                  GetExt:
 28278 00004A56 AC                      	LODSB
 28279 00004A57 08C0                    	OR	AL,AL
 28280 00004A59 740E                    	JZ	short _GetDone
 28281 00004A5B 3C5C                    	CMP	AL,'\'
 28282 00004A5D 740A                    	JZ	short _GetDone
 28283 00004A5F 3C3F                    	CMP	AL,'?'
 28284 00004A61 7503                    	JNZ	short StoExt
 28285 00004A63 80CC01                  	OR	AH,1
 28286                                  StoExt: 
 28287 00004A66 AA                      	STOSB
 28288 00004A67 EBED                    	JMP	short GetExt
 28289                                  _GetDone:
 28290 00004A69 4E                      	DEC	SI
 28291 00004A6A 88E1                    	MOV	CL,AH  ; 0 or 1 ; 29/12/2022
 28292 00004A6C 80C980                  	OR	CL,80H
 28293 00004A6F 5F                      	POP	DI			; Start of this element
 28294 00004A70 07                      	POP	ES			; Restore ES:BP
 28295 00004A71 39FE                    	CMP	SI,DI
 28296 00004A73 7503                    	JNZ	short check_device
 28297 00004A75 E9E200                  	JMP	_BADPATH		; NUL parse (two delims most likely)
 28298                                  check_device:
 28299 00004A78 56                      	PUSH	SI			; Start of next element
 28300                                  	;MOV	AL,[SI]
 28301                                  	;OR	AL,AL
 28302                                  	; 23/09/2023
 28303 00004A79 803C00                  	cmp	byte [si],0
 28304 00004A7C 7508                    	JNZ	short NOT_LAST
 28305                                  
 28306                                  ; for last element of the path switch to the correct search attributes
 28307                                  
 28308 00004A7E 8A3E[6D05]              	MOV	BH,[SATTRIB]
 28309 00004A82 883E[6B05]              	MOV	[ATTRIB],BH
 28310                                  
 28311                                  NOT_LAST:
 28312                                  
 28313                                  ; check name1 to see if we have a device...
 28314                                  
 28315 00004A86 06                      	PUSH	ES			; Save ES:BP
 28316                                  
 28317                                  ;hkn; SS is DOSDATA
 28318                                  	;context ES
 28319 00004A87 16                      	push	ss
 28320 00004A88 07                      	pop	es
 28321 00004A89 E82701                  	call	DEVNAME 		; blast BX
 28322 00004A8C 07                      	POP	ES			; Restore ES:BP
 28323 00004A8D 720B                    	JC	short FindFile		; Not a device
 28324 00004A8F 08C0                    	OR	AL,AL			; Test next char again
 28325 00004A91 7403                    	JZ	short GO_BDEV
 28326 00004A93 E9C800                  	JMP	FILEINPATH		; Device name in middle of path
 28327                                  
 28328                                  GO_BDEV:
 28329 00004A96 5E                      	POP	SI			; Points to NUL at end of path
 28330 00004A97 E989FE                  	JMP	Build_devJ
 28331                                  
 28332                                  FindFile:
 28333                                  ;;;; 7/28/86
 28334 00004A9A 803E[4B05]E5            	CMP	BYTE [NAME1],0E5H	; if 1st char = E5
 28335 00004A9F 7505                    	JNZ	short NOE5		; no
 28336 00004AA1 C606[4B05]05            	MOV	BYTE [NAME1],05H	; change it to 05
 28337                                  NOE5:
 28338                                  ;;;; 7/28/86
 28339 00004AA6 57                      	PUSH	DI			; Start of this element
 28340 00004AA7 06                      	PUSH	ES			; Save ES:BP
 28341 00004AA8 51                      	PUSH	CX			; CL return from NameTrans
 28342                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 28343                                  
 28344 00004AA9 E89502                  	CALL	LookupPath		; call fastopen to get dir entry
 28345 00004AAC 7303                    	JNC	short DIR_FOUND		; found dir entry
 28346                                  
 28347                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 28348 00004AAE E86EFB                  	call	FINDENTRY
 28349                                  DIR_FOUND:
 28350 00004AB1 59                      	POP	CX
 28351 00004AB2 07                      	POP	ES
 28352 00004AB3 5F                      	POP	DI
 28353 00004AB4 7303                    	JNC	short LOAD_BUF
 28354 00004AB6 E9CA00                  	JMP	BADPATHPOP
 28355                                  
 28356                                  LOAD_BUF:
 28357 00004AB9 C53E[E205]              	LDS	DI,[CURBUF]
 28358                                  	;test	byte [bx+0Bh],10h
 28359 00004ABD F6470B10                	TEST	BYTE [BX+dir_entry.dir_attr],attr_directory
 28360 00004AC1 7503                    	JNZ	short GO_NEXT 		; DOS 3.3
 28361 00004AC3 E99800                  	JMP	FILEINPATH		; Error or end of path
 28362                                  
 28363                                  ; if we are not setting the directory, then check for end of string
 28364                                  
 28365                                  GO_NEXT:
 28366                                  ;hkn; SS override
 28367 00004AC6 36803E[4C03]00          	CMP	BYTE [SS:NoSetDir],0
 28368 00004ACC 7423                    	JZ	short SetDir
 28369 00004ACE 89FA                    	MOV	DX,DI			; Save pointer to entry
 28370 00004AD0 8CD9                    	MOV	CX,DS
 28371                                  
 28372                                  ;hkn; SS is DOSDATA
 28373                                  	;context DS
 28374 00004AD2 16                      	push	ss
 28375 00004AD3 1F                      	pop	ds
 28376 00004AD4 5F                      	POP	DI			; Start of next element
 28377                                  	; 19/05/2019 - Retro DOS v4.0
 28378                                  	; MSDOS 6.0
 28379 00004AD5 F606[6D12]01            	TEST	byte [FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
 28380 00004ADA 740B                    	JZ	short _nofast			; the FastOpen
 28381 00004ADC F606[6D12]02            	TEST	byte [FastOpenFlg],Lookup_Success ; Lookup just happened
 28382 00004AE1 7404                    	JZ	short _nofast			; no
 28383 00004AE3 8B3E[B70D]              	MOV	DI,[Next_Element_Start]	; no need to insert it again
 28384                                  _nofast:
 28385 00004AE7 803D00                  	CMP	BYTE [DI],0
 28386                                  	;;JNZ	short NEXT_ONE		; DOS 3.3
 28387                                  	;;JMP	_SETRET  ; retn		; Got it
 28388                                  	;retn	; 05/09/2018
 28389                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28390                                  	;jmp	_SETRET
 28391                                  	; 16/12/2022
 28392 00004AEA 7421                    	jz	short _SETRET
 28393                                  
 28394                                  NEXT_ONE:
 28395 00004AEC 57                      	PUSH	DI			; Put start of next element back on stack
 28396 00004AED 89D7                    	MOV	DI,DX
 28397 00004AEF 8ED9                    	MOV	DS,CX			; Get back pointer to entry
 28398                                  SetDir:
 28399 00004AF1 8B14                    	MOV	DX,[SI] 		; Dir_first
 28400                                  
 28401                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 28402 00004AF3 1E                      	PUSH	DS		      ; save [curbuf+2]
 28403                                  ;hkn; SS is DOSDATA
 28404 00004AF4 16                      	push	ss
 28405 00004AF5 1F                      	pop	ds		      ; set DS Dosgroup
 28406                                  	;test	byte [FastOpenFlg],2
 28407 00004AF6 F606[6D12]02            	TEST	byte [FastOpenFlg],Lookup_Success
 28408 00004AFB 7411                    	JZ	short DO_NORMAL	      ; fastopen not in memory or path not
 28409 00004AFD 89D3                    	MOV	BX,DX		      ; not found
 28410 00004AFF 8B3E[BC05]              	MOV	DI,[CLUSNUM]	      ; clusnum was set in LookupPath
 28411 00004B03 50                      	PUSH	AX		      ; save device id (AH)
 28412 00004B04 E8E6FC                  	call	SETDIRSRCH
 28413 00004B07 58                      	POP	AX		      ; restore device id (AH)
 28414 00004B08 83C402                  	ADD	SP,2		      ; pop ds in stack
 28415 00004B0B EB37                    	JMP	short FAST_OPEN_SKIP
 28416                                  
 28417                                  	; 16/12/2022
 28418                                  _SETRET:
 28419 00004B0D C3                      	retn
 28420                                  
 28421                                  DO_NORMAL:
 28422 00004B0E 1F                      	POP	DS			; DS = [curbuf + 2]
 28423                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 28424                                  
 28425 00004B0F 29FB                    	SUB	BX,DI			; Offset into sector of start of entry
 28426 00004B11 29FE                    	SUB	SI,DI			; Offset into sector of dir_first
 28427 00004B13 53                      	PUSH	BX
 28428 00004B14 50                      	PUSH	AX
 28429 00004B15 56                      	PUSH	SI
 28430 00004B16 51                      	PUSH	CX
 28431                                  	;push	word [di+6]
 28432 00004B17 FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector]	;AN000;>32mb
 28433                                  	; 19/05/2019
 28434                                  	; MSDOS 6.0
 28435                                  	;push	word [di+8]
 28436 00004B1A FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;AN000;>32mb
 28437 00004B1D 89D3                    	MOV	BX,DX
 28438                                  
 28439                                  ;hkn; SS is DOSDATA
 28440                                  	;context DS
 28441 00004B1F 16                      	push	ss
 28442 00004B20 1F                      	pop	ds
 28443                                  	;invoke	SETDIRSRCH		; This uses UNPACK which might blow
 28444 00004B21 E8C9FC                  	call	SETDIRSRCH		; the entry sector buffer
 28445                                  	; 19/05/2019
 28446                                  	; MSDOS 6.0
 28447 00004B24 8F06[0706]              	POP	word [HIGH_SECTOR]
 28448 00004B28 5A                      	POP	DX
 28449 00004B29 7203                    	JC	short SKIP_GETB
 28450                                  	; 22/09/2023
 28451                                  	;;mov	byte [ALLOWED],18h
 28452                                  	;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 28453                                  	;XOR	AL,AL ; *
 28454                                  	;;invoke GETBUFFR		; Get the entry buffer back
 28455                                  	;call	GETBUFFR
 28456 00004B2B E82818                  	call	GETBUFFER ; * ; pre-read
 28457                                  SKIP_GETB:
 28458 00004B2E 59                      	POP	CX
 28459 00004B2F 5E                      	POP	SI
 28460 00004B30 58                      	POP	AX
 28461 00004B31 5B                      	POP	BX
 28462 00004B32 7305                    	JNC	short SET_THE_BUF
 28463 00004B34 5F                      	POP	DI			; Start of next element
 28464 00004B35 89FE                    	MOV	SI,DI			; Point with SI
 28465 00004B37 EB21                    	JMP	SHORT _BADPATH
 28466                                  
 28467                                  SET_THE_BUF:
 28468 00004B39 E837F4                  	call	SET_BUF_AS_DIR
 28469 00004B3C 8B3E[E205]              	MOV	DI,[CURBUF]
 28470 00004B40 01FE                    	ADD	SI,DI			; Get the offsets back
 28471 00004B42 01FB                    	ADD	BX,DI
 28472                                  ; DOS 3.3 FastOpen 6/12/86  F.C.
 28473                                  FAST_OPEN_SKIP:
 28474 00004B44 5F                      	POP	DI			; Start of next element
 28475 00004B45 E89D02                  	CALL	InsertPath		; insert dir entry info
 28476                                  ; DOS 3.3 FastOpen 6/12/86  F.C.
 28477 00004B48 8A05                    	MOV	AL,[DI]
 28478 00004B4A 08C0                    	OR	AL,AL
 28479 00004B4C 74BF                    	JZ	short _SETRET		; At end
 28480 00004B4E 47                      	INC	DI			; Skip over "/"
 28481 00004B4F 89FE                    	MOV	SI,DI			; Point with SI
 28482 00004B51 E8260F                  	call	PATHCHRCMP
 28483 00004B54 7503                    	JNZ	short find_bad_name	; oops
 28484 00004B56 E9B1FE                  	JMP	FINDPATH		; Next element
 28485                                  
 28486                                  find_bad_name:
 28487 00004B59 4E                      	DEC	SI			; Undo above INC to get failure point
 28488                                  _BADPATH:
 28489 00004B5A 30C9                    	XOR	CL,CL			; Set zero
 28490 00004B5C EB2C                    	JMP	SHORT BADPRET
 28491                                  
 28492                                  FILEINPATH:
 28493 00004B5E 5F                      	POP	DI			; Start of next element
 28494                                  
 28495                                  ;hkn; SS is DOSDATA
 28496                                  	;context DS			; Got to from one place with DS gone
 28497 00004B5F 16                      	push	ss
 28498 00004B60 1F                      	pop	ds
 28499                                  
 28500                                  ; DOS 3.3 FastOpen
 28501                                  	;test	byte [FastOpenFlg],1
 28502 00004B61 F606[6D12]01            	TEST	byte [FastOpenFlg],FastOpen_Set  ; do this here is we don't want to
 28503 00004B66 740B                    	JZ	short NO_FAST		; device info to fastopen
 28504                                  	;test	byte [FastOpenFlg],2
 28505 00004B68 F606[6D12]02            	TEST	byte [FastOpenFlg],Lookup_Success
 28506 00004B6D 7404                    	JZ	short NO_FAST
 28507 00004B6F 8B3E[B70D]              	MOV	DI,[Next_Element_Start]  ; This takes care of one time lookup
 28508                                  					 ; success
 28509                                  NO_FAST:
 28510                                  ; DOS 3.3 FastOpen
 28511 00004B73 8A05                    	MOV	AL,[DI]
 28512 00004B75 08C0                    	OR	AL,AL
 28513 00004B77 7404                    	JZ	short INCRET
 28514 00004B79 89FE                    	MOV	SI,DI			; Path too long
 28515 00004B7B EB0D                    	JMP	SHORT BADPRET
 28516                                  
 28517                                  INCRET:
 28518                                  ; DOS 3.3 FasOpen 6/12/86  F.C.
 28519                                  
 28520 00004B7D E86502                  	CALL   InsertPath		; insert dir entry info
 28521                                  
 28522                                  ; DOS 3.3 FasOpen 6/12/86  F.C.
 28523 00004B80 FEC0                    	INC	AL			; Reset zero
 28524                                  	; 16/12/2022	
 28525                                  ;_SETRET:
 28526 00004B82 C3                      	retn
 28527                                  
 28528                                  BADPATHPOP:
 28529 00004B83 5E                      	POP	SI			; Start of next element
 28530 00004B84 8A04                    	MOV	AL,[SI]
 28531 00004B86 89FE                    	MOV	SI,DI			; Start of bad element
 28532 00004B88 08C0                    	OR	AL,AL			; zero if bad element is last, non-zero if path too long
 28533                                  BADPRET:
 28534 00004B8A A0[6D05]                	MOV	AL,[SATTRIB]
 28535 00004B8D A2[6B05]                	MOV	[ATTRIB],AL		; Make sure return correct
 28536 00004B90 F9                      	STC
 28537 00004B91 C3                      	retn
 28538                                  
 28539                                  ;Break	<STARTSRCH -- INITIATE DIRECTORY SEARCH>
 28540                                  ;---------------------------------------------------------------------------
 28541                                  ;
 28542                                  ; Procedure Name : STARTSRCH
 28543                                  ;
 28544                                  ; Inputs:
 28545                                  ;	[THISDPB] Set
 28546                                  ; Function:
 28547                                  ;	Set up a search for GETENTRY and NEXTENTRY
 28548                                  ; Outputs:
 28549                                  ;	ES:BP = Drive parameters
 28550                                  ;	Sets up LASTENT, ENTFREE=ENTLAST=-1, VOLID=0
 28551                                  ; Destroys ES,BP,AX
 28552                                  ;--------------------------------------------------------------------------
 28553                                  
 28554                                  STARTSRCH:
 28555 00004B92 C42E[8A05]              	LES	BP,[THISDPB]
 28556 00004B96 31C0                    	XOR	AX,AX
 28557 00004B98 A3[4803]                	MOV	[LASTENT],AX
 28558 00004B9B A2[7B05]                	MOV	[VOLID],AL		; No volume ID found
 28559 00004B9E 48                      	DEC	AX
 28560 00004B9F A3[D805]                	MOV	[ENTFREE],AX
 28561 00004BA2 A3[DA05]                	MOV	[ENTLAST],AX
 28562 00004BA5 C3                      	retn
 28563                                  
 28564                                  ;BREAK <MatchAttributes - the final check for attribute matching>
 28565                                  ;----------------------------------------------------------------------------
 28566                                  ; Procedure Name : MatchAttributes
 28567                                  ;
 28568                                  ; Input:    [Attrib] = attribute to search for
 28569                                  ;	    CH = found attribute
 28570                                  ; Output:   JZ <match>
 28571                                  ;	    JNZ <nomatch>
 28572                                  ; Registers modified: noneski
 28573                                  ;----------------------------------------------------------------------------
 28574                                  
 28575                                  MatchAttributes:
 28576 00004BA6 50                      	PUSH	AX
 28577                                  
 28578                                  ;hkn; SS override
 28579 00004BA7 36A0[6B05]              	MOV	AL,[ss:ATTRIB]		; AL <- SearchSet
 28580 00004BAB F6D0                    	NOT	AL			; AL <- SearchSet'
 28581 00004BAD 20E8                    	AND	AL,CH			; AL <- SearchSet' and FoundSet
 28582                                  	;and	al,16h
 28583 00004BAF 2416                    	AND	AL,attr_all	; AL <- SearchSet' and FoundSet and Important
 28584                                  ;
 28585                                  ; the result is non-zero if an attribute is not in the search set
 28586                                  ; and in the found set and in the important set. This means that we do not
 28587                                  ; have a match. Do a JNZ <nomatch> or JZ <match>
 28588                                  ;
 28589 00004BB1 58                      	POP	AX
 28590 00004BB2 C3                      	retn
 28591                                  
 28592                                  ; 19/05/2019 - Retro DOS v4.0
 28593                                  ; DOSCODE:8148h (MSDOS 6.21, MSDOS.SYS)
 28594                                  
 28595                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28596                                  ; DOSCODE:810Dh (MSDOS 5.0, MSDOS.SYS)
 28597                                  
 28598                                  ;Break <DevName - Look for name of device>
 28599                                  ;---------------------------------------------------------------------------
 28600                                  ;
 28601                                  ; Procedure Name : DevName
 28602                                  ;
 28603                                  ; Inputs:
 28604                                  ;	DS,ES:DOSDATA
 28605                                  ;	Filename in NAME1
 28606                                  ;	ATTRIB set so that we can error out if looking for Volume IDs
 28607                                  ; Function:
 28608                                  ;	Determine if file is in list of I/O drivers
 28609                                  ; Outputs:
 28610                                  ;	Carry set if not a device
 28611                                  ;	ELSE
 28612                                  ;	Zero flag set
 28613                                  ;	BH = Bit 7,6 = 1, bit 5 = 0 (cooked mode)
 28614                                  ;	     bits 0-4 set from low byte of attribute word
 28615                                  ;	DEVPT = DWORD pointer to Device header of device
 28616                                  ; BX destroyed, others preserved
 28617                                  ;---------------------------------------------------------------------------
 28618                                  
 28619                                  DEVNAME:
 28620                                  	; 28/07/2018 - Retro DOS v3.0
 28621                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 49FBh
 28622                                  
 28623 00004BB3 56                      	PUSH	SI
 28624 00004BB4 57                      	PUSH	DI
 28625 00004BB5 51                      	PUSH	CX
 28626 00004BB6 50                      	PUSH	AX
 28627                                  
 28628                                  ; E5 special code
 28629 00004BB7 FF36[4B05]              	PUSH	WORD [NAME1]
 28630 00004BBB 803E[4B05]05            	CMP	byte [NAME1],5
 28631 00004BC0 7505                    	JNZ	short NOKTR
 28632 00004BC2 C606[4B05]E5            	MOV	byte [NAME1],0E5h
 28633                                  NOKTR:
 28634                                  	;test	byte [ATTRIB],8
 28635 00004BC7 F606[6B05]08            	TEST	byte [ATTRIB],attr_volume_id
 28636                                  					; If looking for VOL id don't find devs
 28637 00004BCC 7521                    	JNZ	short RET31
 28638                                  
 28639                                  ;hkn; NULDEV is in DOSDATA
 28640 00004BCE BE[4800]                	MOV	SI,NULDEV
 28641                                  LOOKIO:
 28642                                  	; 21/11/2022
 28643                                  	;test	byte [SI+SYSDEV.ATT+1],80h
 28644                                  	; 17/12/2022
 28645                                  	;test	byte [si+5],80h
 28646 00004BD1 F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8)
 28647                                  	;;test	word [si+4],8000h
 28648                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP
 28649 00004BD5 7411                    	JZ	short SKIPDEV 		; Skip block devices (NET and LOCAL)
 28650 00004BD7 89F0                    	MOV	AX,SI
 28651                                  	;add	si,10
 28652 00004BD9 83C60A                  	ADD	SI,SYSDEV.NAME
 28653                                  
 28654                                  ;hkn; NAME1 is in DOSDATA
 28655 00004BDC BF[4B05]                	MOV	DI,NAME1
 28656 00004BDF B90400                  	MOV	CX,4			; All devices are 8 letters
 28657 00004BE2 F3A7                    	REPE	CMPSW			; Check for name in list
 28658 00004BE4 89C6                    	MOV	SI,AX
 28659 00004BE6 7415                    	JZ	short IOCHK		; Found it?
 28660                                  SKIPDEV:
 28661 00004BE8 C534                    	LDS	SI,[SI]			; Get address of next device
 28662 00004BEA 83FEFF                  	CMP	SI,-1			; At end of list?
 28663 00004BED 75E2                    	JNZ	short LOOKIO
 28664                                  RET31:	
 28665 00004BEF F9                      	STC				; Not found
 28666                                  RETNV:	
 28667 00004BF0 8CD1                    	MOV	CX,SS
 28668 00004BF2 8ED9                    	MOV	DS,CX
 28669                                  
 28670 00004BF4 8F06[4B05]              	POP	WORD [NAME1]
 28671 00004BF8 58                      	POP	AX
 28672 00004BF9 59                      	POP	CX
 28673 00004BFA 5F                      	POP	DI
 28674 00004BFB 5E                      	POP	SI
 28675 00004BFC C3                      	RETN
 28676                                  
 28677                                  IOCHK:
 28678                                  ;hkn; SS override for DEVPT
 28679 00004BFD 368C1E[9C05]            	MOV	[SS:DEVPT+2],DS		; Save pointer to device
 28680                                  	;mov	bh,[si+4]
 28681 00004C02 8A7C04                  	MOV	BH,[SI+SYSDEV.ATT]
 28682 00004C05 80CFC0                  	OR	BH,0C0h
 28683 00004C08 80E7DF                  	and	bh,0DFh
 28684                                  	;AND	BH,~(020h)		; Clears Carry
 28685 00004C0B 368936[9A05]            	MOV	[SS:DEVPT],SI
 28686 00004C10 EBDE                    	JMP	short RETNV
 28687                                  
 28688                                  ;BREAK <Build_device_ent - Make a Directory entry>
 28689                                  ;---------------------------------------------------------------------------
 28690                                  ; Procedure Name : Build_device_ent
 28691                                  ;
 28692                                  ; Inputs:
 28693                                  ;	[NAME1] has name
 28694                                  ;	BH is attribute field (supplied by DEVNAME)
 28695                                  ;	[DEVPT] points to device header (supplied by DEVNAME)
 28696                                  ; Function:
 28697                                  ;	Build a directory entry for a device at DEVFCB
 28698                                  ; Outputs:
 28699                                  ;	BX points to DEVFCB
 28700                                  ;	SI points to dir_first field
 28701                                  ;	AH = input BH
 28702                                  ;	AL = 0
 28703                                  ;	dir_first = DEVPT
 28704                                  ;	Zero Set, Carry Clear
 28705                                  ; DS,ES,BP preserved, others destroyed
 28706                                  ;--------------------------------------------------------------------------
 28707                                  
 28708                                  Build_device_ent:
 28709 00004C12 B82020                  	MOV	AX,"  " ; 2020h
 28710                                  
 28711                                  ;hkn; DEVFCB is in DOSDATA
 28712 00004C15 BF[5305]                	MOV	DI,DEVFCB+8		; Point to extent field
 28713                                  
 28714                                  ;	Fill dir_ext  BUGBUG - use ERRNZs for this stuff!
 28715                                  
 28716 00004C18 AB                      	STOSW
 28717 00004C19 AA                      	STOSB				; Blank out extent field
 28718                                  	;mov	al,40h
 28719 00004C1A B040                    	MOV	AL,attr_device
 28720                                  
 28721                                  ;	Fill Dir_attr
 28722                                  
 28723 00004C1C AA                      	STOSB				; Set attribute field
 28724 00004C1D 31C0                    	XOR	AX,AX
 28725 00004C1F B90A00                  	MOV	CX,10
 28726                                  
 28727                                  ; Fill dir_pad
 28728                                  
 28729 00004C22 F3AB                    	REP	STOSW			; Fill rest with zeros
 28730 00004C24 E845BF                  	call	DATE16
 28731                                  
 28732                                  ;hkn; DEVFCB is in DOSDATA
 28733 00004C27 BF[6105]                	MOV	DI,DEVFCB+dir_entry.dir_time ; 09/08/2018
 28734 00004C2A 92                      	XCHG	AX,DX
 28735                                  
 28736                                  ; Fill dir_time
 28737                                  
 28738 00004C2B AB                      	STOSW
 28739 00004C2C 92                      	XCHG	AX,DX
 28740                                  
 28741                                  ; Fill dir_date
 28742                                  
 28743 00004C2D AB                      	STOSW
 28744 00004C2E 89FE                    	MOV	SI,DI			; SI points to dir_first field
 28745 00004C30 A1[9A05]                	MOV	AX,[DEVPT]
 28746                                  
 28747                                  ; Fill dir_first
 28748                                  
 28749 00004C33 AB                      	STOSW				; Dir_first points to device
 28750 00004C34 A1[9C05]                	MOV	AX,[DEVPT+2]
 28751                                  ;
 28752                                  ; Fill dir_size_l
 28753                                  ;
 28754 00004C37 AB                      	STOSW
 28755 00004C38 88FC                    	MOV	AH,BH			; Put device atts in AH
 28756                                  
 28757                                  ;hkn; DEVFCB is in DOSDATA
 28758 00004C3A BB[4B05]                	MOV	BX,DEVFCB
 28759 00004C3D 30C0                    	XOR	AL,AL			; Set zero, clear carry
 28760 00004C3F C3                      	retn
 28761                                  
 28762                                  ;Break	<ValidateCDS - given a CDS, validate the media and the current directory>
 28763                                  ;----------------------------------------------------------------------------
 28764                                  ;
 28765                                  ;   ValidateCDS - Get current CDS. Splice it. Call FatReadCDS to check
 28766                                  ;   media. If media has been changed, do DOS_Chdir to validate path.
 28767                                  ;   If invalid, reset original CDS to root.
 28768                                  ;
 28769                                  ;   Inputs:	ThisCDS points to CDS of interest
 28770                                  ;		SS:DI points to temp buffer
 28771                                  ;   Outputs:	The current directory string is validated on the appropriate
 28772                                  ;		    drive
 28773                                  ;		ThisDPB changed
 28774                                  ;		ES:DI point to CDS
 28775                                  ;		Carry set if error (currently user FAILed to I 24)
 28776                                  ;   Registers modified: all
 28777                                  ;----------------------------------------------------------------------------
 28778                                  
 28779                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28780                                  	; DOSCODE:819Bh (MSDOS 5.0, MSDOS.SYS)
 28781                                  
 28782                                  ValidateCDS:
 28783                                  	; 19/05/2019 - Retro DOS v4.0
 28784                                  	; 28/07/2018 - Retro DOS v3.0
 28785                                  
 28786                                     %define  Temp	[bp-2]	; word
 28787                                     %define  SaveCDS	[bp-6]	; dword
 28788                                     %define  SaveCDSL	[bp-6]	; word
 28789                                     %define  SaveCDSH	[bp-4]	; word
 28790                                  
 28791                                  	;Enter
 28792 00004C40 55                      	push	bp
 28793 00004C41 89E5                    	mov	bp,sp
 28794 00004C43 83EC06                  	sub	sp,6
 28795                                  
 28796 00004C46 897EFE                  	MOV	Temp,DI
 28797                                  
 28798                                  ;hkn; SS override
 28799 00004C49 36C536[A205]            	LDS	SI,[SS:THISCDS]
 28800 00004C4E 8976FA                  	MOV	SaveCDSL,SI
 28801 00004C51 8C5EFC                  	MOV	SaveCDSH,DS
 28802                                  	;EnterCrit critDisk
 28803 00004C54 E8ACCC                  	call	ECritDisk
 28804                                  	; 21/11/2022
 28805                                  	;test	byte [SI+curdir.flags+1],80h
 28806                                  	;test	word [si+67],8000h
 28807                                  	; 17/12/2022
 28808                                  	;test	byte [SI+68],80h
 28809 00004C57 F6444480                	test	byte [SI+curdir.flags+1],(curdir_isnet>>8)
 28810                                  	;TEST	word [SI+curdir.flags],curdir_isnet	; Clears carry
 28811 00004C5B 7403                    	JZ	short _DoSplice
 28812 00004C5D E99200                  	JMP	FatFail
 28813                                  _DoSplice:
 28814 00004C60 30D2                    	XOR	DL,DL
 28815 00004C62 368616[4C03]            	XCHG	DL,[SS:NoSetDir]
 28816                                  
 28817                                  ;hkn; SS is DOSDATA
 28818                                  	;Context ES
 28819 00004C67 16                      	push	ss
 28820 00004C68 07                      	pop	es
 28821                                  	;Invoke	FStrcpy
 28822 00004C69 E86CCB                  	call	FStrCpy
 28823 00004C6C 8B76FE                  	MOV	SI,Temp
 28824                                  
 28825                                  ;hkn; SS is DOSDATA
 28826                                  	;Context DS
 28827 00004C6F 16                      	push	ss
 28828 00004C70 1F                      	pop	ds	
 28829                                  	;Invoke	Splice
 28830 00004C71 E8972B                  	call	Splice
 28831                                  
 28832                                   ;hkn; SS is DOSDATA
 28833                                  	;Context DS			;   FatReadCDS (ThisCDS);
 28834 00004C74 16                      	push	ss
 28835 00004C75 1F                      	pop	ds
 28836 00004C76 8816[4C03]              	MOV	[NoSetDir],DL
 28837 00004C7A C43E[A205]              	LES	DI,[THISCDS]
 28838                                  	;SAVE	<BP>
 28839 00004C7E 55                      	push	bp
 28840                                  	;Invoke	FATREAD_CDS
 28841 00004C7F E83214                  	call	FATREAD_CDS	
 28842                                  	;RESTORE <BP>
 28843 00004C82 5D                      	pop	bp
 28844 00004C83 726D                    	JC	short FatFail
 28845                                  
 28846 00004C85 C536[A205]              	LDS	SI,[THISCDS]		;   if (ThisCDS->ID == -1) {
 28847                                  	;cmp	word [si+73],-1
 28848 00004C89 837C49FF                	CMP	word [SI+curdir.ID],-1
 28849 00004C8D 7555                    	JNZ	short RestoreCDS
 28850                                  
 28851                                  ;hkn; SS is DOSDATA
 28852                                  	;Context ES
 28853 00004C8F 16                      	push	ss
 28854 00004C90 07                      	pop	es
 28855                                  
 28856                                  ;hkn; SS override
 28857                                  	;SAVE	<wfp_Start>		;	t = wfp_Start;
 28858 00004C91 36FF36[B205]            	push	word [SS:WFP_START]
 28859                                  	;cmp	si,[bp-6]
 28860 00004C96 3B76FA                  	CMP	SI,SaveCDSL		; if not spliced
 28861 00004C99 750B                    	JNZ	short DoChdir
 28862                                  	;mov	di,[bp-2]
 28863 00004C9B 8B7EFE                  	MOV	DI,Temp
 28864                                  
 28865                                  ;hkn; SS override
 28866 00004C9E 36893E[B205]            	MOV	[SS:WFP_START],DI	;	wfp_start = d;
 28867                                  	;Invoke	FStrCpy 		;	strcpy (d, ThisCDS->Text);
 28868 00004CA3 E832CB                  	call	FStrCpy
 28869                                  DoChdir:
 28870                                  ;hkn; SS is DOSDATA
 28871                                  	;Context DS
 28872 00004CA6 16                      	push	ss
 28873 00004CA7 1F                      	pop	ds
 28874                                  	;SAVE	<<WORD PTR SAttrib>,BP> ;	c = DOSChDir ();
 28875 00004CA8 FF36[6D05]              	push	word [SATTRIB]
 28876 00004CAC 55                      	push	bp
 28877                                  	;Invoke	DOS_ChDir
 28878 00004CAD E8A8ED                  	call	DOS_CHDIR
 28879                                  	;RESTORE <BP,BX,wfp_start>	;	wfp_Start = t;
 28880 00004CB0 5D                      	pop	bp
 28881 00004CB1 5B                      	pop	bx
 28882 00004CB2 8F06[B205]              	pop	word [WFP_START]
 28883 00004CB6 881E[6D05]              	MOV	[SATTRIB],BL
 28884 00004CBA C576FA                  	LDS	SI,SaveCDS
 28885 00004CBD 730F                    	JNC	short SetCluster	;	if (c == -1) {
 28886                                  
 28887                                  ;hkn; SS override for THISCDS
 28888 00004CBF 368936[A205]            	MOV	[SS:THISCDS],SI		;	    ThisCDS = TmpCDS;
 28889 00004CC4 368C1E[A405]            	MOV	[SS:THISCDS+2],DS
 28890 00004CC9 31C9                    	XOR	CX,CX			;	    TmpCDS->text[3] = c = 0;
 28891 00004CCB 884C03                  	MOV	[SI+3],CL		;	    }
 28892                                  SetCluster:
 28893                                  	;mov	word [si+73],0FFFFh
 28894 00004CCE C74449FFFF              	MOV	word [SI+curdir.ID],-1	;	TmpCDS->ID = -1;
 28895 00004CD3 36C536[A205]            	LDS	SI,[SS:THISCDS]		;	ThisCDS->ID = c;
 28896                                  	; 21/11/2022
 28897                                  	;test	byte [si+curdir.flags+1],20h
 28898                                  	; 19/05/2019
 28899                                  	; MSDOS 6.0
 28900                                  	; 17/12/2022
 28901                                  	;test	byte [si+68],20h
 28902 00004CD8 F6444420                	test	byte [SI+curdir.flags+1],(curdir_splice>>8)	
 28903                                  	;;test	word [si+67],2000h
 28904                                  	;TEST	word [SI+curdir.flags],curdir_splice ;AN000;;MS. for Join and Subst
 28905 00004CDC 7403                    	JZ	short _setdirclus		     ;AN000;;MS.
 28906 00004CDE B9FFFF                  	MOV	CX,-1				     ;AN000;;MS.
 28907                                  _setdirclus:
 28908                                  	;mov	[si+73],cx
 28909 00004CE1 894C49                  	MOV	[SI+curdir.ID],CX	;	}
 28910                                  RestoreCDS:
 28911 00004CE4 C47EFA                  	LES	DI,SaveCDS
 28912 00004CE7 36893E[A205]            	MOV	[SS:THISCDS],DI
 28913 00004CEC 368C06[A405]            	MOV	[SS:THISCDS+2],ES
 28914 00004CF1 F8                      	CLC
 28915                                  FatFail:
 28916                                  	;LeaveCrit critDisk
 28917 00004CF2 E83BCC                  	call	LCritDisk
 28918                                  
 28919                                  	;les	di,[bp-6]
 28920 00004CF5 C47EFA                  	LES	DI,SaveCDS
 28921                                  	;Leave
 28922 00004CF8 89EC                    	mov	sp,bp
 28923 00004CFA 5D                      	pop	bp
 28924 00004CFB C3                      	retn
 28925                                  
 28926                                  ; 28/07/2018 - Retro DOS v3.0
 28927                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - offset 43BDh
 28928                                  
 28929                                  ;Break	<CheckThisDevice - Check for being a device>
 28930                                  ;---------------------------------------------------------------------------
 28931                                  ;
 28932                                  ;   CheckThisDevice - Examine the area at DS:SI to see if there is a valid
 28933                                  ;   device specified. We will return carry if there is a device present. 
 28934                                  ;   The forms of devices we will recognize are:
 28935                                  ;
 28936                                  ;	[path]device
 28937                                  ;
 28938                                  ;   Note that the drive letter has *already* been removed. All other forms
 28939                                  ;   are not considered to be devices. If such a device is found we change
 28940                                  ;   the source pointer to point to the device component.
 28941                                  ;
 28942                                  ;   Inputs:	ES is DOSDATA
 28943                                  ;		DS:SI contains name
 28944                                  ;   Outputs:	ES is DOSDATA
 28945                                  ;		DS:SI point to name or device
 28946                                  ;		Carry flag set if device was found
 28947                                  ;		Carry flag reset otherwise
 28948                                  ;   Registers Modified: all except ES:DI, DS
 28949                                  ;----------------------------------------------------------------------------
 28950                                  
 28951                                  CheckThisDevice:
 28952 00004CFC 57                      	push	di
 28953 00004CFD 56                      	push	si
 28954 00004CFE 89F7                    	MOV	DI,SI
 28955                                  
 28956                                  ; Check for presence of \dev\ (Dam multiplan!)
 28957                                  
 28958 00004D00 8A04                    	MOV	AL,[SI]
 28959 00004D02 E8750D                  	call	PATHCHRCMP		; is it a path char?
 28960 00004D05 7517                    	JNZ	short ParseDev		; no, go attempt to parse device
 28961 00004D07 46                      	INC	SI			; simulate LODSB
 28962                                  
 28963                                  ; We have the leading path separator. Look for DEV part.
 28964                                  
 28965 00004D08 AD                      	LODSW
 28966 00004D09 0D2020                  	OR	AX,2020h
 28967 00004D0C 3D6465                  	cmp	ax,"de"
 28968                                  	;CMP	AX,"e"<< 8 + "d"
 28969 00004D0F 752D                    	JNZ	short NotDevice		; not "de", assume not device
 28970 00004D11 AC                      	LODSB
 28971 00004D12 0C20                    	OR	AL,20h
 28972 00004D14 3C76                    	CMP	AL,"v"                  ; Not "v", assume not device
 28973 00004D16 7526                    	JNZ	short NotDevice
 28974 00004D18 AC                      	LODSB
 28975 00004D19 E85E0D                  	call	PATHCHRCMP		; do we have the last path separator?
 28976 00004D1C 7520                    	JNZ	short NotDevice		; no. go for it.
 28977                                  
 28978                                  ; DS:SI now points to a potential drive. Preserve them as NameTrans advances
 28979                                  ; SI and DevName may destroy DS.
 28980                                  
 28981                                  ParseDev:
 28982 00004D1E 1E                      	push	ds
 28983 00004D1F 56                      	push	si			; preserve the source pointer
 28984 00004D20 E8950C                  	call	NameTrans		; advance DS:SI
 28985 00004D23 803C00                  	CMP	BYTE [SI],0		; parse entire string?
 28986 00004D26 F9                      	STC				; simulate a Carry return from DevName
 28987 00004D27 750B                    	JNZ	short SkipSearch	; no parse. simulate a file return.
 28988                                  
 28989                                  ;hkn; SS is DOSDATA
 28990 00004D29 16                      	push	ss
 28991 00004D2A 1F                      	pop	ds
 28992                                  
 28993                                  ; M026 - start - fix ported from ROMDOS2 for bug # 2849
 28994                                  ;
 28995                                  ; SR;
 28996                                  ; We have to set Attrib before invoking DevName. Otherwise, the value from
 28997                                  ; a previous DOS call is used and DevName thinks it is not a device if the
 28998                                  ; old call set the volume attribute bit.
 28999                                  
 29000 00004D2B A0[6D05]                	mov	al,[SATTRIB]
 29001 00004D2E A2[6B05]                	mov	[ATTRIB],al		;set Attrib for DevName
 29002                                  
 29003                                  ; M026 - end
 29004                                  
 29005 00004D31 E87FFE                  	call	DEVNAME
 29006                                  
 29007                                  SkipSearch:
 29008 00004D34 5E                      	pop	si
 29009 00004D35 1F                      	pop	ds
 29010                                  
 29011                                  ; SI points to the beginning of the potential device. If we have a device
 29012                                  ; then we do not change SI. If we have a file, then we reset SI back to the
 29013                                  ; original value. At this point Carry set indicates FILE.
 29014                                  
 29015                                  CheckReturn:
 29016 00004D36 5F                      	pop	di			; get original SI
 29017 00004D37 7302                    	JNC	short Check_Done	; if device then do not reset pointer
 29018 00004D39 89FE                    	MOV	SI,DI
 29019                                  Check_Done:
 29020 00004D3B 5F                      	pop	di
 29021 00004D3C F5                      	CMC				; invert carry. Carry => device
 29022 00004D3D C3                      	retn
 29023                                  NotDevice:
 29024 00004D3E F9                      	STC
 29025 00004D3F EBF5                    	JMP	short CheckReturn
 29026                                  
 29027                                  ;BREAK <LookupPath - call fastopen to get dir entry info>
 29028                                  ;-----------------------------------------------------------------------------
 29029                                  ;
 29030                                  ; Procedure Name : LookupPath
 29031                                  ;
 29032                                  ; Output  DS:SI -> path name,
 29033                                  ;	  ES:DI -> dir entry info buffer
 29034                                  ;	  ES:CX -> extended dir info buffer
 29035                                  ;
 29036                                  ;	  carry flag clear : tables pointed by ES:DI and ES:CX are filled by
 29037                                  ;			     FastOpen, DS:SI points to char just one after
 29038                                  ;			     the last char of path name which is fully or
 29039                                  ;			     partially found in FastOPen
 29040                                  ;	  carry flag set : FastOpen not in memory or path name not found
 29041                                  ;
 29042                                  ;----------------------------------------------------------------------------
 29043                                  
 29044                                  LookupPath:
 29045                                  ;	PUSH	AX
 29046                                  
 29047                                  ;hkn; SS override
 29048                                  	;test	byte [ss:FastOpenFlg],1
 29049 00004D41 36F606[6D12]01          	TEST	byte [ss:FastOpenFlg],FastOpen_Set  ; flg is set in DOSOPEN
 29050 00004D47 7503                    	JNZ	short FASTINST			    ; and this routine is
 29051                                  NOLOOK:
 29052 00004D49 E99700                  	JMP	NOLOOKUP			    ; executed once
 29053                                  
 29054                                  FASTINST:
 29055                                  ;hkn; SS override
 29056                                  	;test	byte [ss:FastOpenFlg],8
 29057 00004D4C 36F606[6D12]08          	TEST	byte [ss:FastOpenFlg],No_Lookup	    ; no more lookup?
 29058 00004D52 75F5                    	JNZ	short NOLOOK			    ; yes
 29059                                  
 29060 00004D54 BB[6312]                	MOV	BX,FastOpenTable		    ; get fastopen related tab
 29061                                  
 29062                                  ;hkn; SS override
 29063 00004D57 368B36[B205]            	MOV	SI,[SS:WFP_START]		    ; si points to path name
 29064 00004D5C BF[970D]                	MOV	DI,Dir_Info_Buff
 29065 00004D5F B9[8C0D]                	MOV	CX,FastOpen_Ext_Info
 29066 00004D62 B001                    	MOV	AL,FONC_Look_up 		    ; al = 1
 29067 00004D64 1E                      	PUSH	DS
 29068 00004D65 07                      	POP	ES
 29069                                  
 29070                                  ;hkn; SS override
 29071                                  	;call	far [bx+2]
 29072 00004D66 FF5F02                  	CALL	far [BX+fastopen_entry.name_caching] ;call fastopen
 29073 00004D69 7267                    	JC	short NOTFOUND			    ; fastopen not in memory
 29074                                  
 29075 00004D6B 8D5CFE                  	LEA	BX,[SI-2]
 29076                                  
 29077                                  ;hkn; SS override
 29078 00004D6E 363B1E[B205]            	CMP	BX,[SS:WFP_START]		    ; path found ?
 29079 00004D73 745D                    	JZ	short NOTFOUND			    ; no
 29080                                  
 29081                                  	; 19/05/2019 - Retro DOS v4.0
 29082                                  
 29083                                  	; MSDOS 6.0				    ; fully or partially found
 29084 00004D75 803C00                  	CMP	BYTE [SI],0			    ;AN000;FO.
 29085 00004D78 751A                    	JNZ	short parfnd			    ;AN000;FO.; partiallyfound
 29086 00004D7A 51                      	PUSH	CX				    ;AN000;FO.; is attribute matched ?
 29087                                  
 29088                                  ;hkn; SS override for attrib/sattrib
 29089 00004D7B 368A0E[6B05]            	MOV	CL,[ss:ATTRIB]			    ;AN000;FO.;
 29090 00004D80 368A2E[6D05]            	MOV	CH,[ss:SATTRIB]			    ;AN000;FO.; attrib=sattrib
 29091 00004D85 36882E[6B05]            	MOV	[ss:ATTRIB],CH			    ;AN000;FO.;
 29092                                  	;mov	ch,[es:di+0Bh]
 29093 00004D8A 268A6D0B                	MOV	CH,[ES:DI+dir_entry.dir_attr]	    ;AN000;FO.;
 29094 00004D8E E815FE                  	call	MatchAttributes 		    ;AN000;FO.;
 29095                                  ;;;	MOV	[ss:ATTRIB],CL			    ;AN001;FO.; restore attrib
 29096 00004D91 59                      	POP	CX				    ;AN000;FO.;
 29097 00004D92 754F                    	JNZ	short NOLOOKUP			    ;AN000;FO.; not matched
 29098                                  parfnd:
 29099                                  
 29100                                  ;hkn; SS override
 29101 00004D94 368936[B70D]            	MOV	[SS:Next_Element_Start],SI	    ; save si
 29102 00004D99 89CB                    	MOV	BX,CX
 29103                                  	; MSDOS 6.0
 29104                                  	;mov	ax,[bx+7]
 29105 00004D9B 8B4707                  	MOV	AX,[BX+FEI.lastent]		    ;AN000;;FO. restore lastentry
 29106                                  ;hkn; SS override for LASTENT, DIRSTART, CLUSNUM
 29107 00004D9E 36A3[4803]              	MOV	[SS:LASTENT],AX			    ;AN000;;FO.
 29108 00004DA2 8B4709                  	MOV	AX,[BX+FEI.dirstart]		    ;AN001;;FO. restore dirstart
 29109 00004DA5 36A3[C205]              	MOV	[SS:DIRSTART],AX		    ;AN001;;FO.
 29110                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29111                                  	;;mov	ax,[bx+3] ; MSDOS 3.3
 29112                                  	;mov	ax,[bx+5] ; MSDOS 6.0
 29113 00004DA9 8B4705                  	MOV	AX,[BX+FEI.clusnum]		    ; restore next cluster num
 29114 00004DAC 36A3[BC05]              	MOV	[SS:CLUSNUM],AX			    ;
 29115                                  
 29116 00004DB0 06                      	PUSH	ES				    ; save ES
 29117                                  ;hkn; SS override
 29118 00004DB1 36C41E[8A05]            	LES	BX,[SS:THISDPB]			    ; put drive id
 29119 00004DB6 268A27                  	mov	ah,[ES:BX] ; 15/08/2018
 29120                                  	;MOV	AH,[ES:BX+DPB.DRIVE]		    ; in AH for DOOPEN
 29121 00004DB9 07                      	POP	ES				    ; pop ES
 29122                                  ;SR;
 29123                                  ; We cannot have a root dir if we have come here. So, we zero out CurBuf to
 29124                                  ;indicate it is not a root dir
 29125                                  
 29126 00004DBA 36C706[E205]0000        	mov	word [SS:CURBUF],0		    ; indicate not root dir
 29127 00004DC1 368C06[E405]            	MOV	WORD [SS:CURBUF+2],ES		    ; [curbuf+2].bx points to
 29128 00004DC6 89FB                    	MOV	BX,DI				    ; start of entry
 29129                                  	;lea	si,[di+1Ah]
 29130 00004DC8 8D751A                  	LEA	SI,[DI+dir_entry.dir_first]	    ; [curbuf+2]:si points to
 29131                                  						    ; dir_first field in the
 29132                                  						    ; dir entry
 29133                                  ;hkn; SS override for FastOpenFlg
 29134                                  	;or	byte [ss:FastOpenFlg],12h ; 29/12/2022
 29135 00004DCB 36800E[6D12]12          	OR	byte [SS:FastOpenFlg],Lookup_Success+Set_For_Search
 29136                                  ;	POP	AX
 29137 00004DD1 C3                      	RETN
 29138                                  NOTFOUND:
 29139 00004DD2 83F8FF                  	CMP	AX,-1				    ; not in memory ?
 29140 00004DD5 7506                    	JNZ	short Partial_Success 		    ; yes, in memory
 29141 00004DD7 36C606[6D12]00          	MOV	byte [SS:FastOpenFlg],0		    ; no more fastopen
 29142                                  Partial_Success:
 29143                                  	;and	byte [SS:FastOpenFlg],0FBh
 29144 00004DDD 368026[6D12]FB          	AND	byte [SS:FastOpenFlg],Special_Fill_Reset
 29145                                  NOLOOKUP:
 29146                                  ;	POP	AX
 29147 00004DE3 F9                      	STC
 29148 00004DE4 C3                      	RETN
 29149                                  
 29150                                  ;BREAK <InsertPath - call fastopen to insert dir entry info>
 29151                                  ;-----------------------------------------------------------------------------
 29152                                  ;
 29153                                  ; Procedure Name : InsertPath
 29154                                  ; Input:  FastOpen_Set flag set when from DOSOPEN otherwise 0
 29155                                  ;	  Lookup_Success flag set when got dir entry info from FASTOPEN
 29156                                  ;	  DS = DOSDATA
 29157                                  ; Output: FastOPen_Ext_Info is set and path dir info is inserted
 29158                                  ;
 29159                                  ;-----------------------------------------------------------------------------
 29160                                  
 29161                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29162                                  
 29163                                  InsertPath:
 29164 00004DE5 9C                      	PUSHF
 29165                                  ;hkn; SS override for FastOpenFlag
 29166                                  	;test	byte [SS:FastOpenFlg], 1
 29167 00004DE6 36F606[6D12]01          	TEST	byte [SS:FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
 29168 00004DEC 7479                    	JZ	short GET_NEXT_ELEMENT		; the FastOpen
 29169                                  	;test	byte [ss:FastOpenFlg],2
 29170 00004DEE 36F606[6D12]02          	TEST	byte [SS:FastOpenFlg],Lookup_Success ; Lookup just happened
 29171 00004DF4 740D                    	JZ	short INSERT_DIR_INFO		; no
 29172                                  	;and	byte [ss:FastOpenFlg],0FDh
 29173 00004DF6 368026[6D12]FD          	AND	byte [SS:FastOpenFlg],Lookup_Reset  ; we got dir info from fastopen so
 29174 00004DFC 368B3E[B70D]            	MOV	DI,[SS:Next_Element_Start]	; no need to insert it again
 29175 00004E01 EB5E                    	JMP	short GET_NEXT2
 29176                                  INSERT_DIR_INFO:				; save registers
 29177 00004E03 1E                      	PUSH	DS
 29178 00004E04 06                      	PUSH	ES
 29179 00004E05 53                      	PUSH	BX
 29180 00004E06 56                      	PUSH	SI
 29181 00004E07 57                      	PUSH	DI
 29182 00004E08 51                      	PUSH	CX
 29183 00004E09 50                      	PUSH	AX
 29184                                  
 29185                                  ;hkn; SS override
 29186 00004E0A 36C53E[E205]            	LDS	DI,[SS:CURBUF]			; DS:DI -> buffer header
 29187 00004E0F BE[8C0D]                	MOV	SI,FastOpen_Ext_Info
 29188                                  	;mov	ax,[di+6]
 29189 00004E12 8B4506                  	MOV	AX,[DI+BUFFINFO.buf_sector]	; get directory sector
 29190                                  	; MSDOS 6.0
 29191                                  	;mov	[ss:si+1],ax
 29192 00004E15 36894401                	MOV	[SS:SI+FEI.dirsec],AX 		;AN000; >32mb save dir sector
 29193                                  	; 19/05/2019 - Retro DOS v4.0
 29194 00004E19 8B4508                  	MOV	AX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
 29195                                  
 29196                                  ;hkn; SS is DOSDATA
 29197 00004E1C 16                      	push	ss
 29198 00004E1D 1F                      	pop	ds
 29199                                  	; MSDOS 3.3	
 29200                                  	;;mov	[si+1],ax	
 29201                                  	;MOV	[SI+FEI.dirsec],AX
 29202                                  	; MSDOS 6.0
 29203                                  	;mov	[si+3],ax
 29204 00004E1E 894403                  	MOV	[SI+FEI.dirsec+2],AX		;AN000;>32mb save high dir sector
 29205                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29206 00004E21 A1[BC05]                	MOV	AX,[CLUSNUM]		; save next cluster number
 29207                                  	;;mov	[si+5],ax ; MSDOS 6.0
 29208                                  	;mov	[si+3],ax ; MSDOS 3.3
 29209 00004E24 894405                  	MOV	[SI+FEI.clusnum],AX
 29210                                  	; MSDOS 6.0
 29211 00004E27 A1[4803]                	MOV	AX,[LASTENT]		;AN000;FO. save lastentry for search first
 29212                                  	;mov	[si+7],ax
 29213 00004E2A 894407                  	MOV	[SI+FEI.lastent],AX	;AN000;FO.
 29214 00004E2D A1[C205]                	MOV	AX,[DIRSTART]		;AN001;FO. save  for search first
 29215                                  	;mov	[si+9],ax
 29216 00004E30 894409                  	MOV	[SI+FEI.dirstart],AX	;AN001;FO.
 29217                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29218 00004E33 89D8                    	MOV	AX,BX
 29219                                  	;;add	di,16  ; MSDOS 3.3
 29220                                  	;add	di,20  ; MSDOS 6.0
 29221 00004E35 83C718                  	ADD	DI,BUFINSIZ		; DS:DI -> start of data in buffer
 29222 00004E38 29F8                    	SUB	AX,DI			; AX=BX relative to start of sector
 29223                                  	;mov	cl,32
 29224 00004E3A B120                    	MOV	CL,dir_entry.size
 29225 00004E3C F6F1                    	DIV	CL
 29226                                  	;MOV	[SI+FEI.dirpos],AL	; save directory entry # in buffer
 29227 00004E3E 8804                    	mov	[si],al
 29228                                  
 29229 00004E40 1E                      	PUSH	DS
 29230 00004E41 07                      	POP	ES
 29231                                  
 29232 00004E42 8E1E[E405]              	MOV	DS,[CURBUF+2]
 29233 00004E46 89DF                    	MOV	DI,BX			; DS:DI -> dir entry info
 29234                                  	;cmp	word [di+1Ah],0
 29235 00004E48 837D1A00                	CMP	word [DI+dir_entry.dir_first],0 
 29236                                  					; never insert info when file is empty
 29237 00004E4C 740C                    	JZ	short SKIP_INSERT	; e.g. newly created file
 29238                                  
 29239 00004E4E 56                      	PUSH	SI			; ES:BX -> extended info
 29240 00004E4F 5B                      	POP	BX
 29241                                  
 29242                                  	;mov	al,2
 29243 00004E50 B002                    	MOV	AL,FONC_insert		; call fastopen insert operation
 29244 00004E52 BE[6312]                	MOV	SI,FastOpenTable
 29245                                  	;call	far [es:si+2]	 ; call dword ptr es:[si+2] ; 29/12/2022
 29246                                  	; 07/12/2022
 29247 00004E55 26FF5C02                	CALL	far [ES:SI+fastopen_entry.name_caching]
 29248                                  
 29249 00004E59 F8                      	CLC
 29250                                  SKIP_INSERT:
 29251 00004E5A 58                      	POP	AX
 29252 00004E5B 59                      	POP	CX			; restore registers
 29253 00004E5C 5F                      	POP	DI
 29254 00004E5D 5E                      	POP	SI
 29255 00004E5E 5B                      	POP	BX
 29256 00004E5F 07                      	POP	ES
 29257 00004E60 1F                      	POP	DS
 29258                                  GET_NEXT2:
 29259                                  	;or	[ss:FastOpenFlg],8
 29260 00004E61 36800E[6D12]08          	OR	byte [SS:FastOpenFlg],No_Lookup
 29261                                  					; we got dir info from fastopen so
 29262                                  GET_NEXT_ELEMENT:
 29263 00004E67 9D                      	POPF
 29264 00004E68 C3                      	RETN
 29265                                  
 29266                                  ;============================================================================
 29267                                  ; DEV.ASM (MSDOS 6.0, 1991)
 29268                                  ;============================================================================
 29269                                  ; 17/07/2018 - Retro DOS v3.0
 29270                                  ; 30/04/2019 - Retro DOS v4.0
 29271                                  
 29272                                  ;**	Misc Routines to do 1-12 low level I/O and call devices
 29273                                  
 29274                                  ; Offset 12B8h of IBMDOS.COM (MSDOS 3.3), 1987
 29275                                  
 29276                                  ;DOSCODE:8401h (MSDOS 6.21, MSDOS.SYS)
 29277                                  
 29278                                  ;Public DEV001S, DEV001E 		; Pathgen labels
 29279                                  ;DEV001s:
 29280                                  ;		length of packets
 29281 00004E69 160E160D0F0E            LenTab:	 DB	DRDWRHL, DRDNDHL, DRDWRHL, DSTATHL, DFLSHL, DRDNDHL
 29282                                  ;LenTab: db	22,14,22,13,15,14
 29283                                  
 29284                                  ;	Error Function
 29285                                  
 29286                                  CmdTab:
 29287 00004E6F 8604                    	DB	86h, DEVRD	; 0 input
 29288 00004E71 8605                    	DB	86h, DEVRDND	; 1 input status
 29289 00004E73 8708                    	DB	87h, DEVWRT	; 2 output
 29290 00004E75 870A                    	DB	87h, DEVOST	; 3 output status
 29291 00004E77 8607                    	DB	86h, DEVIFL	; 4 input flush
 29292 00004E79 8605                    	DB	86h, DEVRDND	; 5 input status with system WAIT
 29293                                  
 29294                                  ; Offset 12BEh of IBMDOS.COM (MSDOS 3.3), 1987
 29295                                  
 29296                                  ;CmdTab:
 29297                                  ;	db	86h, 4
 29298                                  ;	db	86h, 5
 29299                                  ;	db	87h, 8
 29300                                  ;	db	87h, 10
 29301                                  ;	db	86h, 7
 29302                                  ;	db	86h, 5
 29303                                  
 29304                                  ;DEV001E:
 29305                                  
 29306                                  ; 30/04/2019 - Retro DOS v4.0
 29307                                  ; DOSCODE:8413h (MSDOS 6.21, MSDOS.SYS)
 29308                                  
 29309                                  ;Break	<IOFUNC -- DO FUNCTION 1-12 I/O>
 29310                                  ;----------------------------------------------------------------------------
 29311                                  ;
 29312                                  ; Procedure Name : IOFUNC
 29313                                  ;
 29314                                  ; Inputs:
 29315                                  ;	DS:SI Points to SFT
 29316                                  ;	AH is function code
 29317                                  ;		= 0 Input
 29318                                  ;		= 1 Input Status
 29319                                  ;		= 2 Output
 29320                                  ;		= 3 Output Status
 29321                                  ;		= 4 Flush
 29322                                  ;		= 5 Input Status - System WAIT invoked for K09 if no char
 29323                                  ;				   present.
 29324                                  ;	AL = character if output
 29325                                  ; Function:
 29326                                  ;	Perform indicated I/O to device or file
 29327                                  ; Outputs:
 29328                                  ;	AL is character if input
 29329                                  ;	If a status call
 29330                                  ;		zero set if not ready
 29331                                  ;		zero reset if ready (character in AL for input status)
 29332                                  ; For regular files:
 29333                                  ;	Input Status
 29334                                  ;		Gets character but restores position
 29335                                  ;		Zero set on EOF
 29336                                  ;	Input
 29337                                  ;		Gets character advances position
 29338                                  ;		Returns ^Z on EOF
 29339                                  ;	Output Status
 29340                                  ;		Always ready
 29341                                  ; AX altered, all other registers preserved
 29342                                  ;----------------------------------------------------------------------------
 29343                                  
 29344                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29345                                  ; DOSCODE:83D8h (MSDOS 5.0, MSDOS.SYS)
 29346                                  
 29347                                  IOFUNC:
 29348 00004E7B 368C16[8C03]            	MOV	[SS:IOXAD+2],SS		; SS override for IOXAD, IOSCNT, 
 29349                                  					; DEVIOBUF
 29350 00004E80 36C706[8A03][BC03]      	MOV	WORD [SS:IOXAD],DEVIOBUF
 29351 00004E87 36C706[8E03]0100        	MOV	WORD [SS:IOSCNT],1
 29352 00004E8E 36A3[BC03]              	MOV	WORD [SS:DEVIOBUF],AX
 29353                                  	;test	byte [si+6],80h
 29354                                  	;TEST	word [SI+SF_ENTRY.sf_flags],sf_isnet ; 8000h
 29355 00004E92 F6440680                	test	byte [SI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 29356 00004E96 7403                    	JZ	short IOTO22		;AN000;
 29357 00004E98 E9A500                  	JMP	IOTOFILE		;AN000;
 29358                                  IOTO22:
 29359                                  	;test	word [si+5],80h
 29360                                  	;TEST	word [SI+SF_ENTRY.sf_flags],devid_device 
 29361 00004E9B F6440580                	test	byte [SI+SF_ENTRY.sf_flags],devid_device	
 29362 00004E9F 7503                    	JNZ	short IOTO33		;AN000;
 29363 00004EA1 E99C00                  	JMP	IOTOFILE		;AN000;
 29364                                  IOTO33:
 29365 00004EA4 06                      	push	es ; * (MSDOS 6.21)
 29366 00004EA5 E8B0B5                  	call	save_world
 29367 00004EA8 8CDA                    	MOV	DX,DS
 29368 00004EAA 8CD3                    	MOV	BX,SS
 29369 00004EAC 8EDB                    	MOV	DS,BX
 29370 00004EAE 8EC3                    	MOV	ES,BX
 29371 00004EB0 31DB                    	XOR	BX,BX
 29372 00004EB2 80FC05                  	cmp	ah,5		    ; system wait enabled?
 29373 00004EB5 7503                    	jnz	short _no_sys_wait
 29374                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29375                                  	; 16/12/2022
 29376 00004EB7 80CF04                  	or	bh,04h
 29377                                  	;or	bx,0400H	    ; Set bit 10 in status word for driver
 29378                                  				    ; It is up to device driver to carry out
 29379                                  				    ; appropriate action.
 29380                                  _no_sys_wait:
 29381 00004EBA 891E[7F03]              	MOV	[IOCALL_REQSTAT],BX
 29382 00004EBE 31DB                    	XOR	BX,BX
 29383 00004EC0 881E[8903]              	MOV	[IOMED],BL
 29384                                  
 29385 00004EC4 88E3                    	MOV	BL,AH		 	; get function
 29386 00004EC6 2E8AA7[694E]            	MOV	AH,[cs:BX+LenTab]
 29387 00004ECB D1E3                    	SHL	BX,1
 29388 00004ECD 2E8B8F[6F4E]            	MOV	CX,[cs:BX+CmdTab]
 29389 00004ED2 BB[7C03]                	MOV	BX,IOCALL ; DOSDATA:037Ch
 29390 00004ED5 8826[7C03]              	MOV	[IOCALL_REQLEN],AH
 29391 00004ED9 882E[7E03]              	MOV	[IOCALL_REQFUNC],CH
 29392                                  
 29393 00004EDD 8EDA                    	MOV	DS,DX
 29394 00004EDF E86B01                  	CALL	DEVIOCALL
 29395 00004EE2 368B3E[7F03]            	MOV	DI,[SS:IOCALL_REQSTAT]	; SS override
 29396 00004EE7 21FF                    	and	di,di
 29397 00004EE9 7834                    	js	short DevErr
 29398                                  OKDevIO:
 29399 00004EEB 8CD0                    	MOV	AX,SS
 29400 00004EED 8ED8                    	MOV	DS,AX
 29401                                  
 29402                                  	;cmp	ch,5
 29403 00004EEF 80FD05                  	CMP	CH,DEVRDND
 29404 00004EF2 7506                    	JNZ	short DNODRD
 29405 00004EF4 A0[8903]                	MOV	AL,[IORCHR]
 29406 00004EF7 A2[BC03]                	MOV	[DEVIOBUF],AL
 29407                                  
 29408                                  DNODRD: 
 29409 00004EFA 8A26[8003]              	MOV	AH,[IOCALL_REQSTAT+1]
 29410 00004EFE F6D4                    	NOT	AH			; Zero = busy, not zero = ready
 29411                                  	;and	ah,2
 29412 00004F00 80E402                  	AND	AH,STBUI>>8
 29413                                  
 29414                                  QuickReturn:				;AN000; 2/13/KK
 29415 00004F03 E83BB5                  	call	restore_world
 29416 00004F06 07                      	pop	es ; * (MSDOS 6.21)
 29417                                  
 29418                                  	; SR;
 29419                                  	; We return ax = -1 if the user failed on I24. This is the case if 
 29420                                  	; IoStatFail = -1 (set after return from the I24)
 29421                                  
 29422                                  	; MSDOS 6.0
 29423 00004F07 9C                      	pushf
 29424 00004F08 36A0[8300]              	mov	al,[ss:IoStatFail]	;assume fail error
 29425 00004F0C 98                      	cbw				;sign extend to word
 29426 00004F0D 83F8FF                  	cmp	ax,-1
 29427 00004F10 7507                    	jne	short not_fail_ret
 29428 00004F12 36FE06[8300]            	inc	byte [ss:IoStatFail]
 29429 00004F17 9D                      	popf
 29430 00004F18 C3                      	retn
 29431                                  
 29432                                  not_fail_ret:
 29433 00004F19 36A1[BC03]              	mov	ax,[ss:DEVIOBUF]	;ss override
 29434 00004F1D 9D                      	popf
 29435 00004F1E C3                      	retn
 29436                                  
 29437                                  DevErr:
 29438 00004F1F 88CC                    	MOV	AH,CL
 29439 00004F21 E88E0D                  	call	CHARHARD
 29440 00004F24 3C01                    	CMP	AL,1
 29441 00004F26 7507                    	JNZ	short NO_RETRY
 29442 00004F28 E816B5                  	call	restore_world
 29443                                  	; 12/05/2019
 29444 00004F2B 07                      	pop	es ; * (MSDOS 6.21)		
 29445 00004F2C E94CFF                  	JMP	IOFUNC	; 10/08/2018
 29446                                  
 29447                                  NO_RETRY:
 29448                                  	; Know user must have wanted Ignore OR Fail. Make sure device shows ready
 29449                                  	; ready so that DOS doesn't get caught in a status loop when user 
 29450                                  	; simply wants to ignore the error.
 29451                                  	;
 29452                                  	; SR; If fail wanted by user set ax to special value (ax = -1). This 
 29453                                  	; should be checked by the caller on return
 29454                                  
 29455                                  					; SS override
 29456 00004F2F 368026[8003]FD          	and	byte [SS:IOCALL_REQSTAT+1],0FDh
 29457                                  	;AND	BYTE [SS:IOCALL_REQSTAT+1],~(STBUI>>8)
 29458                                  
 29459                                  	; SR;
 29460                                  	; Check if user failed
 29461                                  
 29462                                  	; MSDOS 6.0
 29463 00004F35 3C03                    	cmp	al,3
 29464 00004F37 7505                    	jnz	short not_fail
 29465 00004F39 36FE0E[8300]            	dec	byte [ss:IoStatFail]	;set flag indicating fail on I24
 29466                                  not_fail:
 29467 00004F3E EBAB                    	JMP	short OKDevIO
 29468                                  
 29469                                  IOTOFILE:
 29470 00004F40 08E4                    	OR	AH,AH
 29471 00004F42 7421                    	JZ	short IOIN
 29472 00004F44 FECC                    	DEC	AH
 29473 00004F46 7405                    	JZ	short IOIST
 29474 00004F48 FECC                    	DEC	AH
 29475 00004F4A 7411                    	JZ	short IOUT
 29476                                  IOUT_retn:	; 18/12/2022
 29477 00004F4C C3                      	retn				; NON ZERO FLAG FOR OUTPUT STATUS
 29478                                  IOIST:
 29479                                  	;push	word [si+15h]
 29480 00004F4D FF7415                  	PUSH	WORD [SI+SF_ENTRY.sf_position]   ; Save position
 29481                                  	;push	word [si+17h]
 29482 00004F50 FF7417                  	PUSH	WORD [SI+SF_ENTRY.sf_position+2]
 29483 00004F53 E80F00                  	CALL	IOIN
 29484                                  	;pop	word [si+17h]
 29485 00004F56 8F4417                  	POP	WORD [SI+SF_ENTRY.sf_position+2] ; Restore position
 29486                                  	;pop	word [si+15h]
 29487 00004F59 8F4415                  	POP	WORD [SI+SF_ENTRY.sf_position]
 29488 00004F5C C3                      	retn
 29489                                  IOUT:
 29490 00004F5D E82500                  	CALL	SETXADDR
 29491 00004F60 E83EEE                  	call	DOS_WRITE
 29492                                  	;CALL	RESTXADDR	; If you change this into a jmp don't
 29493                                  	; 18/12/2022
 29494 00004F63 EB52                    	jmp	RESTXADDR
 29495                                  ;IOUT_retn:
 29496                                  	;retn			; come crying to me when things don't
 29497                                  				; work ARR
 29498                                  IOIN:
 29499 00004F65 E81D00                  	CALL	SETXADDR
 29500                                  					; SS override for DOS34_FLAG
 29501                                  	;OR	word [SS:DOS34_FLAG],Disable_EOF_I24	;AN000;
 29502                                  	;or	word [ss:DOS34_FLAG],40h
 29503                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29504                                  	; 16/12/2022
 29505 00004F68 36800E[1106]40          	or	byte [ss:DOS34_FLAG],40h 
 29506 00004F6E E807EC                  	CALL	DOS_READ
 29507                                  	;AND	word [SS:DOS34_FLAG],NO_Disable_EOF_I24 ;AN000;
 29508                                  	;and	word [SS:DOS34_FLAG],0FFBFh
 29509                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29510                                  	; 16/12/2022
 29511 00004F71 368026[1106]BF          	and	byte [SS:DOS34_FLAG],0BFh ; 07/12/2022
 29512 00004F77 09C9                    	OR	CX,CX			; Check EOF
 29513 00004F79 E83B00                  	CALL	RESTXADDR
 29514                                  					; SS override
 29515 00004F7C 36A0[BC03]              	MOV	AL,[SS:DEVIOBUF]	; Get byte from trans addr
 29516 00004F80 75CA                    	jnz	short IOUT_retn	
 29517 00004F82 B01A                    	MOV	AL,1AH			; ^Z if no bytes
 29518 00004F84 C3                      	retn
 29519                                  
 29520                                  SETXADDR:
 29521                                  					; SS override
 29522 00004F85 368F06[6C03]            	POP	WORD [SS:CALLSCNT]	; Return address
 29523                                  
 29524 00004F8A 06                      	push	es ; * (MSDOS 6.21)
 29525                                  
 29526 00004F8B E8CAB4                  	call	save_world
 29527                                  					; SS override for DMAADD and THISSFT
 29528                                  	; 24/09/2023
 29529                                  	;PUSH	WORD [SS:DMAADD]	; Save Disk trans addr
 29530                                  	;PUSH	WORD [SS:DMAADD+2]
 29531 00004F8E 368C1E[A005]            	MOV	[SS:THISSFT+2],DS
 29532                                  
 29533 00004F93 16                      	push	ss
 29534 00004F94 1F                      	pop	ds
 29535                                  
 29536                                  	; 24/09/2023
 29537 00004F95 FF36[2C03]              	push	word [DMAADD]
 29538 00004F99 FF36[2E03]              	push	word [DMAADD+2]
 29539                                  
 29540 00004F9D 8936[9E05]              	MOV	[THISSFT],SI		; Finish setting SFT pointer
 29541 00004FA1 8B0E[8C03]              	MOV	CX,[IOXAD+2]
 29542 00004FA5 890E[2E03]              	MOV	[DMAADD+2],CX
 29543 00004FA9 8B0E[8A03]              	MOV	CX,[IOXAD]
 29544 00004FAD 890E[2C03]              	MOV	[DMAADD],CX		; Set byte trans addr
 29545 00004FB1 8B0E[8E03]              	MOV	CX,[IOSCNT]		; ioscnt specifies length of buffer
 29546 00004FB5 EB10                    	JMP	SHORT RESTRET		; RETURN ADDRESS
 29547                                  
 29548                                  RESTXADDR:
 29549 00004FB7 8F06[6C03]              	POP	WORD [CALLSCNT]		; Return address
 29550 00004FBB 8F06[2E03]              	POP	WORD [DMAADD+2]		; Restore Disk trans addr
 29551 00004FBF 8F06[2C03]              	POP	WORD [DMAADD]
 29552                                  
 29553 00004FC3 E87BB4                  	call	restore_world
 29554                                  
 29555 00004FC6 07                      	pop	es ; * (MSDOS 6.21)
 29556                                  					; SS override
 29557                                  RESTRET:
 29558 00004FC7 36FF26[6C03]            	JMP	WORD [SS:CALLSCNT]	; Return address
 29559                                  
 29560                                  ; DOSCODE:8569h (MSDOS 6.21, MSDOS.SYS)
 29561                                  ; 21/11/2022
 29562                                  ; DOSCODE:852Eh (MSDOS 5.0, MSDOS.SYS)
 29563                                  
 29564                                  ;Break <DEV_OPEN_SFT, DEV_CLOSE_SFT - OPEN or CLOSE A DEVICE>
 29565                                  
 29566                                  ;----------------------------------------------------------------------------
 29567                                  ;**	Dev_Open_SFT - Open the Device for an SFT
 29568                                  ;
 29569                                  ;	Dev_Open_SFT issues an open call to the device associated with
 29570                                  ;	the SFT.
 29571                                  ;
 29572                                  ;	ENTRY	(ES:DI) = SFT
 29573                                  ;	EXIT	none
 29574                                  ;	USES	all
 29575                                  ;----------------------------------------------------------------------------
 29576                                  
 29577                                  DEV_OPEN_SFT:
 29578 00004FCC 06                      	push	es ; * (MSDOS 6.21)
 29579 00004FCD E888B4                  	call	save_world
 29580                                  	;mov	al,0Dh	
 29581 00004FD0 B00D                    	MOV	AL,DEVOPN
 29582 00004FD2 EB06                    	JMP	SHORT DO_OPCLS
 29583                                  
 29584                                  ;----------------------------------------------------------------------------
 29585                                  ; Procedure Name : DEV_CLOSE_SFT
 29586                                  ;
 29587                                  ; Inputs:
 29588                                  ;	ES:DI Points to SFT
 29589                                  ; Function:
 29590                                  ;	Issue a CLOSE call to the correct device
 29591                                  ; Outputs:
 29592                                  ;	None
 29593                                  ; ALL preserved
 29594                                  ;----------------------------------------------------------------------------
 29595                                  
 29596                                  DEV_CLOSE_SFT:
 29597 00004FD4 06                      	push	es ; * (MSDOS 6.21)
 29598 00004FD5 E880B4                  	call	save_world
 29599                                  	;mov	al,0Eh	
 29600 00004FD8 B00E                    	MOV	AL,DEVCLS
 29601                                  
 29602                                  	; Main entry for device open and close. AL contains the function 
 29603                                  	; requested. Subtlety: if Sharing is NOT loaded then we do NOT issue 
 29604                                  	; open/close to block devices. This allows networks to function but 
 29605                                  	; does NOT hang up with bogus change-line code.
 29606                                  
 29607                                  	;entry	DO_OPCLS
 29608                                  DO_OPCLS:
 29609                                  	; Is the SFT for the net? If so, no action necessary.
 29610                                  
 29611                                  	; MSDOS 6.0
 29612                                  	;test	word [es:di+5],8000h
 29613                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 29614 00004FDA 26F6450680              	test	byte [es:di+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 29615 00004FDF 7567                    	jnz	short OPCLS_DONE	; NOP on net SFTs
 29616 00004FE1 30E4                    	XOR	AH,AH			; Unit
 29617                                  	;test	byte [es:di+5],80h
 29618 00004FE3 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 29619                                  	;les	di,[es:di+7]
 29620 00004FE8 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get DPB or device
 29621 00004FEC 7513                    	JNZ	short GOT_DEV_ADDR
 29622                                  
 29623                                  	; We are about to call device open/close on a block driver. If no 
 29624                                  	; sharing then just short circuit to done.
 29625                                  	
 29626                                  	; MSDOS 6.0
 29627                                  					; SS override
 29628 00004FEE 36803E[0303]01          	CMP	byte [ss:fShare],1	;AN010; /NC or no SHARE
 29629 00004FF4 7652                    	JBE	short OPCLS_DONE	;AN010; yes
 29630                                  
 29631                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29632                                  	;mov	ah,[es:di+1]
 29633 00004FF6 268A6501                	MOV	AH,[ES:DI+DPB.UNIT]	; (ah) = unit
 29634 00004FFA 268A0D                  	mov	cl,[es:di]
 29635                                  	;MOV	CL,[ES:DI+DPB.DRIVE]	; (cl) = drive
 29636                                  	;;les	di,[es:di+12h] ; MSDOS 3.3
 29637                                  	;les	di,[es:di+13h] ; MSDOS 6.0
 29638 00004FFD 26C47D13                	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Get device
 29639                                  GOT_DEV_ADDR:				; ES:DI -> device
 29640                                  	;test	word [es:di+4],800h
 29641                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL
 29642 00005001 26F6450508              	test	byte [ES:DI+SYSDEV.ATT+1],(DEVOPCL>>8)
 29643 00005006 7440                    	JZ	short OPCLS_DONE	; Device can't
 29644 00005008 06                      	PUSH	ES
 29645 00005009 1F                      	POP	DS
 29646 0000500A 89FE                    	MOV	SI,DI			; DS:SI -> device
 29647                                  
 29648                                  OPCLS_RETRY:
 29649                                  	;Context ES
 29650 0000500C 16                      	push	ss
 29651 0000500D 07                      	pop	es
 29652                                  					; DEVCALL is in DOSDATA
 29653 0000500E BF[5A03]                	MOV	DI,DEVCALL
 29654                                  
 29655 00005011 89FB                    	MOV	BX,DI
 29656 00005013 50                      	PUSH	AX
 29657                                  	;mov	al,13
 29658 00005014 B00D                    	MOV	AL,DOPCLHL
 29659 00005016 AA                      	STOSB				; Length
 29660 00005017 58                      	POP	AX
 29661 00005018 86E0                    	XCHG	AH,AL
 29662 0000501A AA                      	STOSB				; Unit
 29663 0000501B 86E0                    	XCHG	AH,AL
 29664 0000501D AA                      	STOSB				; Command
 29665 0000501E 26C7050000              	MOV	WORD [ES:DI],0		; Status
 29666 00005023 50                      	PUSH	AX			; Save Unit,Command
 29667                                  	;invoke	DEVIOCALL2
 29668 00005024 E82900                  	call	DEVIOCALL2
 29669                                  
 29670                                  	;mov	di,[es:bx+3]
 29671 00005027 268B7F03                	MOV	DI,[ES:BX+SRHEAD.REQSTAT]
 29672                                  	;test	di,8000h
 29673                                  	;jz	short OPCLS_DONEP	
 29674 0000502B 21FF                    	and	di,di
 29675 0000502D 7918                    	jns	short OPCLS_DONEP	; No error
 29676                                  	; 21/11/2022
 29677                                  	;test	word [si+4],8000h
 29678                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP
 29679                                  	;test	word [si+5],80h
 29680 0000502F F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8)
 29681 00005033 7404                    	JZ	short BLKDEV
 29682 00005035 B486                    	MOV	AH,86H			; Read error in data, Char dev
 29683 00005037 EB04                    	JMP	SHORT HRDERR
 29684                                  BLKDEV:
 29685 00005039 88C8                    	MOV	AL,CL			; Drive # in AL
 29686 0000503B B406                    	MOV	AH,6			; Read error in data, Blk dev
 29687                                  HRDERR:
 29688                                  	;invoke	CHARHARD
 29689 0000503D E8720C                  	call	CHARHARD
 29690 00005040 3C01                    	cmp	al,1
 29691 00005042 7503                    	jne	short OPCLS_DONEP	; IGNORE or FAIL
 29692                                  					;  Note that FAIL is essentually IGNORED
 29693 00005044 58                      	POP	AX			; Get back Unit, Command
 29694 00005045 EBC5                    	JMP	short OPCLS_RETRY
 29695                                  OPCLS_DONEP:
 29696 00005047 58                      	POP	AX			; Clean stack
 29697                                  OPCLS_DONE:
 29698 00005048 E8F6B3                  	call	restore_world
 29699 0000504B 07                      	pop	es ; * (MSDOS 6.21)
 29700 0000504C C3                      	retn
 29701                                  
 29702                                  ; 30/04/2019 - Retro DOS v4.0
 29703                                  ; DOSCODE:85EAh (MSDOS 6.21, MSDOS.SYS)
 29704                                  
 29705                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29706                                  ; DOSCODE:85AFh (MSDOS 5.0, MSDOS.SYS)
 29707                                  
 29708                                  ;Break	<DEVIOCALL, DEVIOCALL2 - CALL A DEVICE>
 29709                                  ;----------------------------------------------------------------------------
 29710                                  ;**	DevIoCall  - Call Device
 29711                                  ;
 29712                                  ;	ENTRY	DS:SI Points to device SFT
 29713                                  ;		ES:BX Points to request data
 29714                                  ;	EXIT	DS:SI -> Device driver
 29715                                  ;	USES	DS:SI,AX
 29716                                  ;----------------------------------------------------------------------------
 29717                                  ;**	DevIoCall2 - Call Device
 29718                                  ;
 29719                                  ;	ENTRY	DS:SI Points to DPB
 29720                                  ;		ES:BX Points to request data
 29721                                  ;	EXIT	DS:SI -> Device driver
 29722                                  ;	USES	DS:SI,AX
 29723                                  ;----------------------------------------------------------------------------
 29724                                  
 29725                                  DEVIOCALL:
 29726                                  					; SS override for CALLSSEC, 
 29727                                  	;lds	si,[si+7]		; CALLNEWSC, HIGH_SECTOR & CALLDEVAD
 29728 0000504D C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 29729                                  
 29730                                  	;entry	DEVIOCALL2
 29731                                  DEVIOCALL2:
 29732                                  	;EnterCrit critDevice
 29733 00005050 E8EEC8                  	call	ECritDevice
 29734                                  
 29735                                  	; MSDOS 6.0
 29736                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP ;AN000; >32mb block device ?
 29737                                  	;test	byte [si+5],80h
 29738 00005053 F6440580                	test	byte [si+SYSDEV.ATT+1],(DEVTYP>>8)
 29739 00005057 7548                    	jnz	short chardev2		;AN000; >32mb no
 29740                                  
 29741                                  	; 16/12/2022
 29742                                  	; 22/11/2022
 29743 00005059 268A4702                	mov	al,[ES:BX+SRHEAD.REQFUNC] ; [es:bx+2]
 29744 0000505D 3C04                    	cmp	al,DEVRD	; 4
 29745 0000505F 7408                    	je	short chkext	
 29746 00005061 3C08                    	cmp	al,DEVWRT	; 8
 29747 00005063 7404                    	je	short chkext
 29748 00005065 3C09                    	cmp	al,DEVWRTV	; 9
 29749 00005067 7538                    	jne	short chardev2
 29750                                  
 29751                                  	; 16/12/2022
 29752                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29753                                  	;;cmp	byte [es:bx+2],4
 29754                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVRD  ;AN000; >32mb read ?
 29755                                  	;JZ	short chkext		;AN000; >32mb   yes
 29756                                  	;;cmp	byte [es:bx+2],8
 29757                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRT ;AN000; >32mb write ?
 29758                                  	;JZ	short chkext		;AN000; >32mb   yes
 29759                                  	;;cmp	byte [es:bx+2],9
 29760                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRTV
 29761                                  	;				;AN000; >32mb write/verify ?
 29762                                  	;JNZ	short chardev2		;AN000; >32mb no
 29763                                  chkext:
 29764 00005069 E89900                  	CALL	RW_SC			;AN000;LB. use secondary cache if there
 29765 0000506C 7255                    	JC	short dev_exit		;AN000;LB. done
 29766                                  
 29767                                  	;test	byte [si+4],2
 29768 0000506E F6440402                	TEST	byte [SI+SYSDEV.ATT],EXTDRVR ;AN000;>32mb extended driver?
 29769 00005072 741D                    	JZ	short chksector		;AN000;>32mb   no
 29770 00005074 26800708                	ADD	BYTE [ES:BX],8		;AN000;>32mb   make length to 30
 29771 00005078 36A1[6E03]              	MOV	AX,[SS:CALLSSEC]	;AN000;>32mb
 29772 0000507C 36C706[6E03]FFFF        	MOV	word [SS:CALLSSEC],-1	;AN000;>32mb   old sector  =-1
 29773 00005083 36A3[7403]              	MOV	[SS:CALLNEWSC],AX	;AN000;>32mb   new sector  =
 29774 00005087 36A1[0706]              	MOV	AX,[SS:HIGH_SECTOR]	;AN000; >32mb  low sector,high sector
 29775 0000508B 36A3[7603]              	MOV	[SS:CALLNEWSC+2],AX	;AN000; >32mb
 29776 0000508F EB10                    	JMP	short chardev2		;AN000; >32mb
 29777                                  chksector:				;AN000; >32mb
 29778 00005091 36833E[0706]00          	CMP	word [SS:HIGH_SECTOR],0	;AN000; >32mb   if >32mb
 29779 00005097 7408                    	JZ	short chardev2		;AN000; >32mb   then fake error
 29780                                  	;mov	word [es:bx+3],8107h
 29781 00005099 26C747030781            	MOV	word [ES:BX+SRHEAD.REQSTAT],STERR+STDON+error_I24_not_DOS_disk 
 29782                                  					;AN000; >32mb
 29783 0000509F EB22                    	JMP	SHORT dev_exit		;AN000; >32mb
 29784                                  
 29785                                  chardev2:				;AN000;
 29786                                  	; As above only DS:SI points to device header on entry, and DS:SI is 
 29787                                  	; preserved
 29788                                  
 29789                                  	;mov	ax,[si+6]
 29790 000050A1 8B4406                  	MOV	AX,[SI+SYSDEV.STRAT]
 29791 000050A4 36A3[7803]              	MOV	[SS:CALLDEVAD],AX
 29792 000050A8 368C1E[7A03]            	MOV	[SS:CALLDEVAD+2],DS
 29793 000050AD 36FF1E[7803]            	CALL	far [SS:CALLDEVAD]
 29794                                  
 29795                                  	;mov	ax,[si+8]
 29796 000050B2 8B4408                  	MOV	AX,[SI+SYSDEV.INT]
 29797 000050B5 36A3[7803]              	MOV	[SS:CALLDEVAD],AX
 29798 000050B9 36FF1E[7803]            	CALL	far [SS:CALLDEVAD]
 29799                                  
 29800                                  	; MSDOS 6.0
 29801 000050BE E83A01                  	CALL	VIRREAD 		;AN000;LB. move data from SC to buffer
 29802 000050C1 72DE                    	JC	short chardev2		;AN000;LB. bad sector or exceeds max sec
 29803                                  
 29804                                  dev_exit:
 29805                                  	;LeaveCrit critDevice
 29806                                  	;call	LCritDevice
 29807                                  	;retn
 29808                                  	; 18/12/2022
 29809 000050C3 E98CC8                  	jmp	LCritDevice
 29810                                  
 29811                                  ; DOSCODE:8669h (MSDOS 6.21, MSDOS.SYS)
 29812                                  ; 22/11/2022
 29813                                  ; DOSCODE:862Eh (MSDOS 5.0, MSDOS.SYS)
 29814                                  
 29815                                  ;Break	<SETREAD, SETWRITE -- SET UP HEADER BLOCK>
 29816                                  ;---------------------------------------------------------------------------
 29817                                  ;
 29818                                  ; Procedure Name : SETREAD, SETWRITE
 29819                                  ;
 29820                                  ; Inputs:
 29821                                  ;	DS:BX = Transfer Address
 29822                                  ;	CX = Record Count
 29823                                  ;	DX = Starting Record
 29824                                  ;	AH = Media Byte
 29825                                  ;	AL = Unit Code
 29826                                  ; Function:
 29827                                  ;	Set up the device call header at DEVCALL
 29828                                  ; Output:
 29829                                  ;	ES:BX Points to DEVCALL
 29830                                  ; No other registers effected
 29831                                  ;
 29832                                  ;---------------------------------------------------------------------------
 29833                                  
 29834                                  SETREAD:
 29835 000050C6 57                      	PUSH	DI
 29836 000050C7 51                      	PUSH	CX
 29837 000050C8 50                      	PUSH	AX
 29838 000050C9 B104                    	MOV	CL,DEVRD ; mov cl,4
 29839                                  SETCALLHEAD:
 29840 000050CB B016                    	MOV	AL,DRDWRHL ; mov al,16h
 29841 000050CD 16                      	PUSH	SS
 29842 000050CE 07                      	POP	ES
 29843                                  					; DEVCALL is in DOSDATA
 29844 000050CF BF[5A03]                	MOV	DI,DEVCALL
 29845                                  
 29846 000050D2 AA                      	STOSB				; length
 29847 000050D3 58                      	POP	AX			; 
 29848 000050D4 AA                      	STOSB				; Unit
 29849 000050D5 50                      	PUSH	AX
 29850 000050D6 88C8                    	MOV	AL,CL
 29851 000050D8 AA                      	STOSB				; Command code
 29852 000050D9 31C0                    	XOR	AX,AX
 29853 000050DB AB                      	STOSW				; Status
 29854 000050DC 83C708                  	ADD	DI,8			; Skip link fields
 29855 000050DF 58                      	POP	AX
 29856 000050E0 86E0                    	XCHG	AH,AL
 29857 000050E2 AA                      	STOSB				; Media byte
 29858 000050E3 86C4                    	XCHG	AL,AH
 29859 000050E5 50                      	PUSH	AX
 29860 000050E6 89D8                    	MOV	AX,BX
 29861 000050E8 AB                      	STOSW
 29862                                  
 29863 000050E9 8CD8                    	MOV	AX,DS
 29864 000050EB AB                      	STOSW				; Transfer addr
 29865                                  
 29866 000050EC 59                      	POP	CX			; Real AX
 29867 000050ED 58                      	POP	AX			; Real CX
 29868 000050EE AB                      	STOSW				; Count
 29869                                  
 29870 000050EF 92                      	XCHG	AX,DX			; AX=Real DX, DX=real CX, CX=real AX
 29871 000050F0 AB                      	STOSW				; Start
 29872 000050F1 91                      	XCHG	AX,CX
 29873 000050F2 87D1                    	XCHG	DX,CX
 29874 000050F4 5F                      	POP	DI
 29875                                  					; DEVCALL is in DOSDATA
 29876 000050F5 BB[5A03]                	MOV	BX,DEVCALL
 29877 000050F8 C3                      	retn
 29878                                  
 29879                                  	;entry	SETWRITE
 29880                                  SETWRITE:
 29881                                  
 29882                                  ; Inputs:
 29883                                  ;	DS:BX = Transfer Address
 29884                                  ;	CX = Record Count
 29885                                  ;	DX = Starting Record
 29886                                  ;	AH = Media Byte
 29887                                  ;	AL = Unit Code
 29888                                  ; Function:
 29889                                  ;	Set up the device call header at DEVCALL
 29890                                  ; Output:
 29891                                  ;	ES:BX Points to DEVCALL
 29892                                  ; No other registers effected
 29893                                  
 29894 000050F9 57                      	PUSH	DI
 29895 000050FA 51                      	PUSH	CX
 29896 000050FB 50                      	PUSH	AX
 29897 000050FC B108                    	MOV	CL,DEVWRT ; mov cl,8
 29898 000050FE 36020E[FF02]            	ADD	CL,[SS:VERFLG]		; SS override
 29899 00005103 EBC6                    	JMP	SHORT SETCALLHEAD
 29900                                  
 29901                                  ; 30/04/2019 - Retro DOS v4.0
 29902                                  ; DOSCODE:86A8h (MSDOS 6.21, MSDOS.SYS)
 29903                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29904                                  ; DOSCODE:866Dh (MSDOS 5.0, MSDOS.SYS)
 29905                                  
 29906                                  ;Break	<RW_SC -- Read Write Secondary Cache>
 29907                                  ;---------------------------------------------------------------------------
 29908                                  ;
 29909                                  ; Procedure Name : RW_SC
 29910                                  ;
 29911                                  ; Inputs:
 29912                                  ;	 [SC_CACHE_COUNT]= secondary cache count
 29913                                  ;	 [SC_STATUS]= SC validity status
 29914                                  ;	 [SEQ_SECTOR]= last sector read
 29915                                  ; Function:
 29916                                  ;	Read from or write through secondary cache
 29917                                  ; Output:
 29918                                  ;	ES:BX Points to DEVCALL
 29919                                  ;	carry clear, I/O is not done
 29920                                  ;		     [SC_FLAG]=1 if continuos sectors will be read
 29921                                  ;	carry set, I/O is done
 29922                                  ;
 29923                                  ;----------------------------------------------------------------------------
 29924                                  
 29925                                  RW_SC:
 29926                                  	; SS override for all variables used.
 29927                                  	
 29928 00005105 36833E[7700]00          	CMP	word [ss:SC_CACHE_COUNT],0  ;AN000;LB. secondary cache exists?
 29929 0000510B 7421                    	JZ	short scexit4		    ;AN000;LB. no, do nothing
 29930 0000510D 36833E[6C03]01          	CMP	word [ss:CALLSCNT],1	    ;AN000;LB. sector count = 1 (buffer I/O)
 29931 00005113 7519                    	JNZ	short scexit4 		    ;AN000;LB. no, do nothing
 29932 00005115 51                      	PUSH	CX			    ;AN000;LB.
 29933 00005116 52                      	PUSH	DX			    ;AN000;LB. yes
 29934 00005117 1E                      	PUSH	DS			    ;AN000;LB. save registers
 29935 00005118 56                      	PUSH	SI			    ;AN000;LB.
 29936 00005119 06                      	PUSH	ES			    ;AN000;LB.
 29937 0000511A 57                      	PUSH	DI			    ;AN000;LB.
 29938                                  
 29939 0000511B 368B16[6E03]            	MOV	DX,[ss:CALLSSEC]	    ;AN000;LB. starting sector
 29940 00005120 36803E[5C03]04          	CMP	BYTE [ss:DEVCALL_REQFUNC],DEVRD ;AN000;LB. read ?
 29941 00005126 7408                    	JZ	short doread		    ;AN000;LB. yes
 29942 00005128 E8BE00                  	CALL	INVALIDATE_SC		    ;AN000;LB. invalidate SC
 29943 0000512B E98B00                  	JMP	scexit2 		    ;AN000;LB. back to normal
 29944                                  scexit4:				    ;AN000;
 29945 0000512E F8                      	CLC				    ;AN000;LB. I/O not done yet
 29946 0000512F C3                      	retn				    ;AN000;LB.
 29947                                  doread: 				    ;AN000;
 29948 00005130 E82001                  	CALL	SC2BUF			    ;AN000;LB. check if in SC
 29949 00005133 720A                    	JC	short readSC		    ;AN000;LB.
 29950 00005135 36C706[5D03]0001        	MOV	word [ss:DEVCALL_REQSTAT],STDON ;AN000;LB. fake done and ok
 29951 0000513C F9                      	STC				    ;AN000;LB. set carry
 29952 0000513D EB68                    	JMP	short saveseq 		    ;AN000;LB. save seq. sector #
 29953                                  readSC: 				    ;AN000;
 29954 0000513F 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]   	    ;AN000;LB. subtract sector num from
 29955 00005143 368B0E[6E03]            	MOV	CX,[ss:CALLSSEC]	    ;AN000;LB. saved sequential sector
 29956 00005148 362B0E[FA0D]            	SUB	CX,[ss:SEQ_SECTOR]    	    ;AN000;LB. number
 29957 0000514D 361B06[FC0D]            	SBB	AX,[ss:SEQ_SECTOR+2]  	    ;AN000;LB.
 29958                                  	; 24/09/2023
 29959                                  	;CMP	AX,0			    ;AN000;LB. greater than 64K
 29960 00005152 7552                    	JNZ	short saveseq2		    ;AN000;LB. yes,save seq. sector #
 29961                                  chklow: 						
 29962 00005154 83F901                  	CMP	CX,1			    ;AN000;LB. <= 1
 29963 00005157 774D                    	JA	short saveseq2		    ;AN000;LB. no, not sequential
 29964 00005159 36C706[050E]FFFF        	MOV	word [ss:SC_STATUS],-1	    ;AN000;LB. presume all SC valid
 29965 00005160 36A1[7700]              	MOV	AX,[ss:SC_CACHE_COUNT]	    ;AN000;LB. yes, sequential
 29966 00005164 36A3[6C03]              	MOV	[ss:CALLSCNT],AX	    ;AN000;LB. read continuous sectors
 29967                                  readsr:
 29968 00005168 36A1[6A03]              	MOV	AX,[ss:CALLXAD+2]	    ;AN000;LB. save buffer addr
 29969 0000516C 36A3[0E06]              	MOV	[ss:TEMP_VAR2],AX	    ;AN000;LB. in temp vars
 29970 00005170 36A1[6803]              	MOV	AX,[ss:CALLXAD]	    	    ;AN000;LB.
 29971 00005174 36A3[0C06]              	MOV	[ss:TEMP_VAR],AX	    ;AN000;LB.
 29972                                  
 29973 00005178 36A1[7300]              	MOV	AX,[ss:SC_CACHE_PTR]	    ;AN000;LB. use SC cache addr as
 29974 0000517C 36A3[6803]              	MOV	[ss:CALLXAD],AX		    ;AN000;LB. transfer addr
 29975 00005180 36A1[7500]              	MOV	AX,[ss:SC_CACHE_PTR+2]	    ;AN000;LB.
 29976 00005184 36A3[6A03]              	MOV	[ss:CALLXAD+2],AX	    ;AN000;LB.
 29977 00005188 36C606[070E]01          	MOV	byte [ss:SC_FLAG],1	    ;AN000;LB. flag it for later;
 29978 0000518E 36A0[000E]              	MOV	AL,[ss:SC_DRIVE]	    ;AN000;LB. current drive
 29979 00005192 36A2[9C12]              	MOV	[ss:CurSC_DRIVE],AL	    ;AN000;LB. set current drive
 29980 00005196 36A1[6E03]              	MOV	AX,[ss:CALLSSEC]	    ;AN000;LB. current sector
 29981 0000519A 36A3[010E]              	MOV	[ss:CurSC_SECTOR],AX	    ;AN000;LB. set current sector
 29982 0000519E 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;LB.
 29983 000051A2 36A3[030E]              	MOV	[ss:CurSC_SECTOR+2],AX	    ;AN000;LB.
 29984                                  saveseq2:				    ;AN000;
 29985 000051A6 F8                      	CLC				    ;AN000;LB. clear carry
 29986                                  saveseq:				    ;AN000;	
 29987 000051A7 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;LB. save current sector #
 29988 000051AB 36A3[FC0D]              	MOV	[ss:SEQ_SECTOR+2],AX	    ;AN000;LB. for access mode ref.
 29989 000051AF 36A1[6E03]              	MOV	AX,[ss:CALLSSEC]	    ;AN000;LB.	
 29990 000051B3 36A3[FA0D]              	MOV	[ss:SEQ_SECTOR],AX 	    ;AN000;LB.	
 29991 000051B7 EB01                    	JMP	short scexit 		    ;AN000;LB.	
 29992                                  scexit2:				    ;AN000;LB.
 29993 000051B9 F8                      	CLC				    ;AN000;LB.	clear carry
 29994                                  scexit: 				    ;AN000;		
 29995 000051BA 5F                      	POP	DI			    ;AN000;LB.
 29996 000051BB 07                      	POP	ES			    ;AN000;LB. restore registers
 29997 000051BC 5E                      	POP	SI			    ;AN000;LB.
 29998 000051BD 1F                      	POP	DS			    ;AN000;LB.
 29999 000051BE 5A                      	POP	DX			    ;AN000;LB.
 30000 000051BF 59                      	POP	CX			    ;AN000;LB.
 30001 000051C0 C3                      	retn				    ;AN000;LB.
 30002                                  
 30003                                  ;Break	<IN_SC -- check if in secondary cache>
 30004                                  ;--------------------------------------------------------------------------
 30005                                  ;
 30006                                  ; Procedure Name : IN_SC
 30007                                  ;
 30008                                  ; Inputs:  [SC_DRIVE]= requesting drive
 30009                                  ;	   [CURSC_DRIVE]= current SC drive
 30010                                  ;	   [CURSC_SECTOR]= starting scetor # of SC
 30011                                  ;	   [SC_CACHE_COUNT]= SC count
 30012                                  ;	   [HIGH_SECTOR]:DX= sector number
 30013                                  ; Function:
 30014                                  ;	Check if the sector is in secondary cache
 30015                                  ; Output:
 30016                                  ;	carry clear, in SC
 30017                                  ;	   CX= the index in the secondary cache
 30018                                  ;	carry set, not in SC
 30019                                  ;
 30020                                  ;---------------------------------------------------------------------------
 30021                                  
 30022                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30023                                  IN_SC:
 30024                                  	; SS override for all variables used
 30025 000051C1 36A0[000E]              	MOV	AL,[ss:SC_DRIVE]	    ;AN000;;LB. current drive
 30026 000051C5 363A06[9C12]            	CMP	AL,[ss:CurSC_DRIVE]	    ;AN000;;LB. same as SC drive
 30027 000051CA 751B                    	JNZ	short outrange2		    ;AN000;;LB. no
 30028 000051CC 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;;LB. subtract sector num from
 30029 000051D0 89D1                    	MOV	CX,DX			    ;AN000;;LB. secondary starting sector
 30030 000051D2 362B0E[010E]            	SUB	CX,[ss:CurSC_SECTOR]        ;AN000;;LB. number
 30031 000051D7 361B06[030E]            	SBB	AX,[ss:CurSC_SECTOR+2]      ;AN000;;LB.
 30032                                  	; 24/09/2023
 30033                                  	;CMP	AX,0			    ;AN000;;LB. greater than 64K
 30034 000051DC 7509                    	JNZ	short outrange2		    ;AN000;;LB. yes
 30035 000051DE 363B0E[7700]            	CMP	CX,[ss:SC_CACHE_COUNT]	    ;AN000;;LB. greater than SC count
 30036 000051E3 7302                    	JAE	short outrange2		    ;AN000;;LB. yes
 30037 000051E5 F8                      	CLC				    ;AN000;;LB. clear carry
 30038                                  	;JMP	short inexit		    ;AN000;;LB. in SC
 30039                                  	; 16/12/2022
 30040 000051E6 C3                      	retn	; 30/04/2019
 30041                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30042                                  	;jmp	short inexit
 30043                                  
 30044                                  outrange2:				    ;AN000;;LB. set carry
 30045 000051E7 F9                      	STC				    ;AN000;;LB.
 30046                                  inexit: 				    ;AN000;;LB.
 30047 000051E8 C3                      	retn				    ;AN000;;LB.
 30048                                  
 30049                                  ;Break	<INVALIDATE_SC - invalide secondary cache>
 30050                                  ;---------------------------------------------------------------------------
 30051                                  ;
 30052                                  ; Procedure Name : Invalidate_Sc
 30053                                  ;
 30054                                  ; Inputs:  [SC_DRIVE]= requesting drive
 30055                                  ;	   [CURSC_DRIVE]= current SC drive
 30056                                  ;	   [CURSC_SECTOR]= starting scetor # of SC
 30057                                  ;	   [SC_CACHE_COUNT]= SC count
 30058                                  ;	   [SC_STATUS]= SC status word
 30059                                  ;	   [HIGH_SECTOR]:DX= sector number
 30060                                  ;
 30061                                  ; Function:
 30062                                  ;	invalidate secondary cache if in there
 30063                                  ; Output:
 30064                                  ;	[SC_STATUS] is updated
 30065                                  ;---------------------------------------------------------------------------
 30066                                  
 30067                                  INVALIDATE_SC:
 30068                                  	; SS override for all variables used
 30069                                  
 30070 000051E9 E8D5FF                  	CALL	IN_SC			    ;AN000;;LB. in secondary cache
 30071 000051EC 720C                    	JC	short outrange		    ;AN000;;LB. no
 30072 000051EE B80100                  	MOV	AX,1			    ;AN000;;LB. invalidate the sector
 30073 000051F1 D3E0                    	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
 30074 000051F3 F7D0                    	NOT	AX			    ;AN000;;LB.
 30075 000051F5 362106[050E]            	AND	[ss:SC_STATUS],AX	    ;AN000;;LB. save the status
 30076                                  outrange:				    ;AN000;;LB.
 30077 000051FA C3                      	retn				    ;AN000;;LB.
 30078                                  
 30079                                  ; DOSCODE:87A5h (MSDOS 6.21, MSDOS.SYS)
 30080                                  ; 22/11/2022
 30081                                  ; DOSCODE:876Ah (MSDOS 5.0, MSDOS.SYS)
 30082                                  
 30083                                  ;Break	<VIRREAD- virtually read data into buffer>
 30084                                  ;--------------------------------------------------------------------------
 30085                                  ;
 30086                                  ; Procedure Name : SC_FLAG
 30087                                  ;
 30088                                  ; Inputs:  SC_FLAG = 0, no sectors were read into SC
 30089                                  ;		     1, continuous sectors were read into SC
 30090                                  ; Function:
 30091                                  ;	   Move data from SC to buffer
 30092                                  ; Output:
 30093                                  ;	 carry clear, data is moved to buffer
 30094                                  ;	 carry set, bad sector or exceeds maximum sector
 30095                                  ;	   SC_FLAG =0
 30096                                  ;	   CALLSCNT=1
 30097                                  ;	   SC_STATUS= -1 if succeeded
 30098                                  ;     
 30099                                  ;		       0 if failed
 30100                                  ;--------------------------------------------------------------------------
 30101                                  
 30102                                  VIRREAD:
 30103                                  	; SS override for all variables used
 30104                                  
 30105 000051FB 36803E[070E]00          	CMP	byte [ss:SC_FLAG],0	    ;AN000;;LB. from SC fill
 30106 00005201 744E                    	JZ	short sc2end		    ;AN000;;LB. no
 30107 00005203 36A1[0E06]              	MOV	AX,[ss:TEMP_VAR2]	    ;AN000;;LB. restore buffer addr
 30108 00005207 36A3[6A03]              	MOV	[ss:CALLXAD+2],AX	    ;AN000;;LB.
 30109 0000520B 36A1[0C06]              	MOV	AX,[ss:TEMP_VAR]	    ;AN000;;LB.
 30110 0000520F 36A3[6803]              	MOV	[ss:CALLXAD],AX		    ;AN000;;LB.
 30111 00005213 36C606[070E]00          	MOV	byte [ss:SC_FLAG],0	    ;AN000;;LB. reset sc_flag
 30112 00005219 36C706[6C03]0100        	MOV	word [ss:CALLSCNT],1	    ;AN000;;LB. one sector transferred
 30113                                  
 30114                                  	;TEST	word [SS:DEVCALL_REQSTAT],STERR ;AN000;;LB. error?
 30115 00005220 36F606[5E03]80          	test	byte [ss:DEVCALL_REQSTAT+1],(STERR>>8) ; 80h
 30116 00005226 7513                    	JNZ	short scerror 		    ;AN000;;LB. yes
 30117 00005228 1E                      	PUSH	DS			    ;AN000;;LB.
 30118 00005229 56                      	PUSH	SI			    ;AN000;;LB.
 30119 0000522A 06                      	PUSH	ES			    ;AN000;;LB.
 30120 0000522B 57                      	PUSH	DI			    ;AN000;;LB.
 30121 0000522C 52                      	PUSH	DX			    ;AN000;;LB.
 30122 0000522D 51                      	PUSH	CX			    ;AN000;;LB.
 30123 0000522E 31C9                    	XOR	CX,CX			    ;AN000;;LB. we want first sector in SC
 30124 00005230 E83100                  	CALL	SC2BUF2 		    ;AN000;;LB. move data from SC to buf
 30125 00005233 59                      	POP	CX
 30126 00005234 5A                      	POP	DX			    ;AN000;;LB.
 30127 00005235 5F                      	POP	DI			    ;AN000;;LB.
 30128 00005236 07                      	POP	ES			    ;AN000;;LB.
 30129 00005237 5E                      	POP	SI			    ;AN000;;LB.
 30130 00005238 1F                      	POP	DS			    ;AN000;;LB.
 30131 00005239 EB16                    	JMP	SHORT sc2end		    ;AN000;;LB. return
 30132                                  scerror:				    ;AN000;
 30133 0000523B 36C706[6C03]0100        	MOV	word [ss:CALLSCNT],1	    ;AN000;;LB. reset sector count to 1
 30134 00005242 36C706[050E]0000        	MOV	word [ss:SC_STATUS],0	    ;AN000;;LB. invalidate all SC sectors
 30135 00005249 36C606[9C12]FF          	MOV	byte [ss:CurSC_DRIVE],-1    ;AN000;;LB. invalidate drive
 30136 0000524F F9                      	STC				    ;AN000;;LB. carry set
 30137 00005250 C3                      	retn				    ;AN000;;LB.
 30138                                  sc2end: 				    ;AN000;
 30139 00005251 F8                      	CLC				    ;AN000;;LB. carry clear
 30140 00005252 C3                      	retn				    ;AN000;;LB.
 30141                                  
 30142                                  ; 30/04/2019 - Retro  DOS v4.0
 30143                                  ; DOSCODE:87FDh (MSDOS 6.21, MSDOS.SYS)
 30144                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30145                                  ; DOSCODE:87C2h (MSDOS 5.0, MSDOS.SYS)
 30146                                  
 30147                                  ;Break	<SC2BUF- move data from SC to buffer>
 30148                                  ;----------------------------------------------------------------------------
 30149                                  ;
 30150                                  ; Procedure Name : SC2BUF
 30151                                  ;
 30152                                  ; Inputs:  [SC_STATUS] = SC validity status
 30153                                  ;	   [SC_SECTOR_SIZE] = request sector size
 30154                                  ;	   [SC_CACHE_PTR] = pointer to SC
 30155                                  ; Function:
 30156                                  ;	   Move data from SC to buffer
 30157                                  ; Output:
 30158                                  ;	   carry clear, in SC  and data is moved
 30159                                  ;	   carry set, not in SC and data is not moved
 30160                                  ;---------------------------------------------------------------------------
 30161                                  
 30162                                  SC2BUF:
 30163                                  	; SS override for all variables used
 30164 00005253 E86BFF                  	CALL	IN_SC			    ;AN000;LB. in secondary cache
 30165                                  	;JC	short noSC		    ;AN000;LB. no
 30166                                  	; 24/09/2023
 30167 00005256 723D                    	jc	short sexit
 30168 00005258 B80100                  	MOV	AX,1			    ;AN000;LB. check if valid sector
 30169 0000525B D3E0                    	SHL	AX,CL			    ;AN000;LB. in the secondary cache
 30170 0000525D 368506[050E]            	TEST	[ss:SC_STATUS],AX	    ;AN000;LB.
 30171 00005262 7430                    	JZ	short noSC		    ;AN000;LB. invalid
 30172                                  ;entry SC2BUF2
 30173                                  SC2BUF2:				    ;AN000;
 30174                                  	;MOV	AX,CX			    ;AN000;LB. times index with
 30175                                  	;MUL	word [ss:SC_SECTOR_SIZE]    ;AN000;LB. sector size
 30176                                  	; 24/09/2023
 30177 00005264 36A1[FE0D]              	mov	ax,[ss:SC_SECTOR_SIZE]
 30178 00005268 91                      	xchg	ax,cx ; cx = [ss:SC_SECTOR_SIZE]
 30179 00005269 F7E1                    	mul	cx
 30180 0000526B 360306[7300]            	ADD	AX,[ss:SC_CACHE_PTR]	    ;AN000;LB. add SC starting addr
 30181 00005270 361316[7500]            	ADC	DX,[ss:SC_CACHE_PTR+2]	    ;AN000;LB.
 30182 00005275 8EDA                    	MOV	DS,DX			    ;AN000;LB. DS:SI-> SC sector addr
 30183 00005277 89C6                    	MOV	SI,AX			    ;AN000;LB.
 30184 00005279 368E06[6A03]            	MOV	ES,[ss:CALLXAD+2]		    ;AN000;LB. ES:DI-> buffer addr
 30185 0000527E 368B3E[6803]            	MOV	DI,[ss:CALLXAD]		    ;AN000;LB.
 30186                                  	; 24/09/2023
 30187                                  	;MOV	CX,[ss:SC_SECTOR_SIZE]	    ;AN000;LB. count= sector size
 30188 00005283 D1E9                    	SHR	CX,1			    ;AN000;LB. may use DWORD move for 386
 30189                                  ;entry MOVWORDS
 30190                                  MOVWORDS:				    ;AN000;
 30191 00005285 36803E[6A00]00          	CMP	byte [ss:DDMOVE],0	    ;AN000;LB. 386 ?
 30192 0000528B 7403                    	JZ	short nodd		    ;AN000;LB. no
 30193 0000528D D1E9                    	SHR	CX,1			    ;AN000;LB. words/2
 30194 0000528F 66                      	DB	66H			    ;AN000;LB. use double word move
 30195                                  nodd:
 30196 00005290 F3A5                    	REP	MOVSW			    ;AN000;LB. move to buffer
 30197 00005292 F8                      	CLC				    ;AN000;LB. clear carry
 30198 00005293 C3                      	retn				    ;AN000;LB. exit
 30199                                  noSC:					    ;AN000;
 30200 00005294 F9                      	STC				    ;AN000;LB. set carry
 30201                                  sexit:					    ;AN000;
 30202 00005295 C3                      	retn				    ;AN000;LB.
 30203                                  
 30204                                  ;============================================================================
 30205                                  ; MKNODE.ASM, MSDOS 6.0, 1991
 30206                                  ;============================================================================
 30207                                  ; 29/07/2018 - Retro DOS v3.0
 30208                                  ; 19/05/2019 - Retro DOS v4.0
 30209                                  
 30210                                  ;	TITLE	MKNODE - Node maker
 30211                                  ;	NAME	MKNODE
 30212                                  
 30213                                  ;**	MKNODE.ASM
 30214                                  ;----------------------------------------------------------------------------
 30215                                  ;	Low level routines for making a new local file system node
 30216                                  ;	and filling in an SFT from a directory entry
 30217                                  ;
 30218                                  ;	BUILDDIR
 30219                                  ;	SETDOTENT
 30220                                  ;	MakeNode
 30221                                  ;	NEWENTRY
 30222                                  ;	FREEENT
 30223                                  ;	NEWDIR
 30224                                  ;	DOOPEN
 30225                                  ;	RENAME_MAKE
 30226                                  ;	CHECK_VIRT_OPEN
 30227                                  ;
 30228                                  ;	Revision history:
 30229                                  ;
 30230                                  ;	 AN000	version 4.0  Jan. 1988
 30231                                  ;	 A004	PTM 3680  --- Make SFT NAME field offset same as 3.30
 30232                                  
 30233                                  ;Break   <BUILDDIR,NEWDIR -- ALLOCATE DIRECTORIES>
 30234                                  ;----------------------------------------------------------------------------
 30235                                  ;
 30236                                  ; Procedure Name : BUILDDIR,NEWDIR
 30237                                  ;
 30238                                  ; Inputs:
 30239                                  ;       ES:BP Points to DPB
 30240                                  ;       [THISSFT] Set if using NEWDIR entry point
 30241                                  ;               (used by ALLOCATE)
 30242                                  ;       [LASTENT] current last valid entry number in directory if no free
 30243                                  ;               entries
 30244                                  ;       [DIRSTART] Points to first cluster of dir (0 means root)
 30245                                  ; Function:
 30246                                  ;       Grow directory if no free entries and not root
 30247                                  ; Outputs:
 30248                                  ;       CARRY SET IF FAILURE
 30249                                  ;       ELSE
 30250                                  ;          AX entry number of new entry
 30251                                  ;          If a new dir [DIRSTART],[CLUSFAC],[CLUSNUM],[DIRSEC] set
 30252                                  ;               AX = first entry of new dir
 30253                                  ;       GETENT should be called to set [LASTENT]
 30254                                  ;
 30255                                  ;----------------------------------------------------------------------------
 30256                                  
 30257                                  ; 19/05/2019 - Retro DOS v4.0
 30258                                  ; DOSCODE:8845h (MSDOS 6.21, MSDOS.SYS)
 30259                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30260                                  ; DOSCODE:880Ah (MSDOS 6.21, MSDOS.SYS)
 30261                                  
 30262                                  ; 24/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 MSDOS.SYS)
 30263                                  ; DOSCODE:8845h (MSDOS 6.22, MSDOS.SYS)
 30264                                  
 30265                                  BUILDDIR:
 30266                                  	; 29/07/2018 - Retro DOS v3.0
 30267                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 4E66h
 30268                                  
 30269 00005296 A1[D805]                        MOV     AX,[ENTFREE]
 30270 00005299 83F8FF                          CMP     AX,-1 ; 0FFFFh
 30271                                  	;JZ	short CHECK_IF_ROOT
 30272                                          ;CLC
 30273                                          ;retn
 30274                                  	; 24/09/2023
 30275 0000529C 7507                    	jne	short builddir_cmc_retn  ; cf=1 (will be 0)
 30276                                  
 30277                                  CHECK_IF_ROOT:
 30278 0000529E 833E[C205]00                    CMP     word [DIRSTART],0
 30279 000052A3 7502                            JNZ	short NEWDIR
 30280                                          ;STC
 30281                                  	; 24/09/2023
 30282                                  	; [DIRSTART]=0, cf=0, zf=1 (cf will be 1 after cmc instruction)
 30283                                  builddir_cmc_retn:
 30284                                  	; 24/09/2023
 30285 000052A5 F5                      	cmc	; cf=1 <-> cf=0
 30286                                  builddir_retn:
 30287 000052A6 C3                              retn				; Can't grow root
 30288                                  
 30289                                  	;entry   NEWDIR
 30290                                  NEWDIR: 
 30291 000052A7 8B1E[C205]              	MOV     BX,[DIRSTART]
 30292 000052AB 09DB                            OR      BX,BX
 30293 000052AD 7405                            JZ	short NULLDIR
 30294 000052AF E82806                  	call	GETEOF
 30295 000052B2 72F2                            jc	short builddir_retn	; Screw up
 30296                                  NULLDIR:
 30297 000052B4 B90100                          MOV     CX,1
 30298 000052B7 E83905                  	call	ALLOCATE
 30299 000052BA 72EA                            jc	short  builddir_retn
 30300 000052BC 8B16[C205]                      MOV     DX,[DIRSTART]
 30301 000052C0 09D2                            OR      DX,DX
 30302 000052C2 750D                            JNZ	short ADDINGDIR
 30303 000052C4 E826F5                  	call	SETDIRSRCH
 30304 000052C7 72DD                            jc	short  builddir_retn
 30305 000052C9 C706[4803]FFFF                  MOV     word [LASTENT],-1
 30306 000052CF EB29                            JMP     SHORT GOTDIRREC
 30307                                  ADDINGDIR:
 30308 000052D1 53                              PUSH    BX
 30309 000052D2 8B1E[BC05]                      MOV     BX,[CLUSNUM]
 30310 000052D6 E82D0C                          call	IsEOF
 30311 000052D9 5B                              POP     BX
 30312 000052DA 7217                            JB	short NOTFIRSTGROW
 30313                                  ;;;; 10/17/86 update CLUSNUM in the fastopen cache
 30314 000052DC 891E[BC05]                      MOV     [CLUSNUM],BX
 30315                                  	; 24/09/2023
 30316                                  	;PUSH	CX ; (not necessary)
 30317 000052E0 50                      	PUSH	AX
 30318 000052E1 55                      	PUSH	BP
 30319 000052E2 B401                            MOV     AH,1			; CLUSNUM update
 30320                                  	; 15/12/2022
 30321 000052E4 268A5600                	mov	dl,[ES:BP] ; 09/09/2018
 30322                                          ; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30323                                  	;;mov	dl,[es:bp+0]
 30324                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; drive #
 30325 000052E8 8B0E[C205]                      MOV     CX,[DIRSTART]		; first cluster #
 30326 000052EC 89DD                            MOV     BP,BX 			; CLUSNUM
 30327 000052EE E89BDA                  	call	FastOpen_Update
 30328 000052F1 5D                              POP     BP
 30329 000052F2 58                              POP     AX
 30330                                  	; 24/09/2023
 30331                                          ;POP	CX
 30332                                  
 30333                                  ;;;; 10/17/86 update CLUSNUM in the fastopen cache
 30334                                  NOTFIRSTGROW:
 30335 000052F3 89DA                            MOV     DX,BX
 30336 000052F5 30DB                            XOR     BL,BL
 30337 000052F7 E8CC04                  	call	FIGREC
 30338                                  GOTDIRREC:
 30339                                  	;mov	cl,[es:bp+4]
 30340 000052FA 268A4E04                        MOV     CL,[ES:BP+DPB.CLUSTER_MASK]
 30341 000052FE FEC1                            INC     CL
 30342 00005300 30ED                            XOR     CH,CH
 30343                                  ZERODIR:
 30344 00005302 51                              PUSH    CX
 30345                                  	; 22/09/2023
 30346                                  	;;mov	byte [ALLOWED],18h
 30347                                          ;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 30348 00005303 B0FF                            MOV     AL,0FFH
 30349                                          ;call	GETBUFFR
 30350 00005305 E85010                          call	GETBUFFRD ; *
 30351 00005308 7302                    	JNC	short GET_SSIZE
 30352 0000530A 59                              POP     CX
 30353 0000530B C3                              retn
 30354                                  
 30355                                  GET_SSIZE:
 30356                                  	;mov	cx,[es:bp+2]
 30357 0000530C 268B4E02                        MOV     CX,[ES:BP+DPB.SECTOR_SIZE]
 30358 00005310 06                              PUSH    ES
 30359 00005311 C43E[E205]                      LES     DI,[CURBUF]
 30360                                  	;or	byte [es:di+5],4
 30361 00005315 26804D0504                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
 30362 0000531A 57                              PUSH    DI
 30363                                  	;;add	di,16	; MSDOS 3.3
 30364                                  	;add	di,20	; MSDOS 6.0	
 30365 0000531B 83C718                          ADD     DI,BUFINSIZ
 30366 0000531E 31C0                            XOR     AX,AX
 30367 00005320 D1E9                            SHR     CX,1
 30368 00005322 F3AB                            REP     STOSW
 30369 00005324 7301                            JNC	short EVENZ
 30370 00005326 AA                              STOSB
 30371                                  EVENZ:
 30372 00005327 5F                              POP     DI
 30373                                  
 30374                                  	; MSDOS 6.0
 30375 00005328 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 30376                                  					;LB. if already dirty		  ;AN000;
 30377 0000532D 7508                            JNZ	short yesdirty7		;LB.  don't increment dirty count ;AN000;
 30378 0000532F E83912                          call	INC_DIRTY_COUNT		;LB. 				  ;AN000;
 30379                                          
 30380                                  	;or	byte [es:di+5],40h
 30381 00005332 26804D0540              	OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 30382                                  yesdirty7:
 30383 00005337 07                              POP	ES
 30384 00005338 59                              POP	CX
 30385                                  
 30386                                  	; 19/05/2019 - Retro DOS v4.0
 30387                                  
 30388                                  	; MSDOS 3.3
 30389                                  	;INC	DX
 30390                                  
 30391                                  	; MSDOS 6.0
 30392                                  	; 24/09/2023
 30393                                  	;add	dx,1
 30394                                  	;;adc	word [HIGH_SECTOR],0
 30395                                  	;; 24/09/2023
 30396                                  	;; ax=0
 30397                                  	;adc	[HIGH_SECTOR],ax ; 0
 30398                                  	; 24/09/2023
 30399 00005339 42                      	inc	dx
 30400 0000533A 7504                    	jnz	short loop_zerodir
 30401 0000533C FF06[0706]              	inc	word [HIGH_SECTOR]
 30402                                  loop_zerodir:
 30403 00005340 E2C0                            LOOP    ZERODIR
 30404                                  
 30405 00005342 A1[4803]                        MOV     AX,[LASTENT]
 30406 00005345 40                              INC     AX
 30407                                  	; 24/09/2023
 30408                                  	; cf=0
 30409                                  	;CLC
 30410 00005346 C3                              retn
 30411                                  
 30412                                  ;--------------------------------------------------------------------------
 30413                                  ;
 30414                                  ; Procedure Name : SETDOTENT
 30415                                  ;
 30416                                  ; set up a . or .. directory entry for a directory.
 30417                                  ;
 30418                                  ;   Inputs:     ES:DI point to the beginning of a directory entry.
 30419                                  ;               AX contains ". " or ".."
 30420                                  ;               DX contains first cluster of entry
 30421                                  ;
 30422                                  ;----------------------------------------------------------------------------
 30423                                  
 30424                                  SETDOTENT:
 30425                                  ;	Fill in name field
 30426 00005347 AB                              STOSW
 30427 00005348 B90400                          MOV     CX,4
 30428 0000534B B82020                          MOV     AX,"  " ; 2020h
 30429 0000534E F3AB                            REP     STOSW
 30430 00005350 AA                              STOSB
 30431                                  
 30432                                  ;	Set up attribute
 30433                                  	;mov	al, 10h
 30434 00005351 B010                            MOV     AL,attr_directory
 30435 00005353 AA                              STOSB
 30436                                  
 30437                                  ;	Initialize time and date of creation
 30438 00005354 83C70A                          ADD     DI,10
 30439 00005357 8B36[9E05]                      MOV     SI,[THISSFT]
 30440                                  	;mov	ax,[si+0Dh]
 30441 0000535B 8B440D                          MOV     AX,[SI+SF_ENTRY.sf_time]
 30442 0000535E AB                              STOSW
 30443                                  	;mov	ax,[si+0Fh]
 30444 0000535F 8B440F                          MOV     AX,[SI+SF_ENTRY.sf_date]
 30445 00005362 AB                      	STOSW
 30446                                  
 30447                                  ;	Set up first cluster field
 30448 00005363 89D0                            MOV     AX,DX
 30449 00005365 AB                              STOSW
 30450                                  
 30451                                  ;	0 file size
 30452 00005366 31C0                            XOR     AX,AX
 30453 00005368 AB                              STOSW
 30454 00005369 AB                              STOSW
 30455 0000536A C3                              retn
 30456                                  
 30457                                  ;Break   <MAKENODE -- CREATE A NEW NODE>
 30458                                  ;---------------------------------------------------------------------------
 30459                                  ;
 30460                                  ; Procedure Name : MakeNode
 30461                                  ;
 30462                                  ; Inputs:
 30463                                  ;       AL - attribute to create
 30464                                  ;       AH = 0 if it is ok to truncate a file already by this name
 30465                                  ;	AH != 0 if truncation not allowed (prexisting file is an error)
 30466                                  ;               (AH ignored on dirs and devices)
 30467                                  ;
 30468                                  ;        NOTE: When making a DIR or volume ID, AH need not be set since
 30469                                  ;               a name already existant is ALWAYS an error in these cases.
 30470                                  ;
 30471                                  ;       [WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 30472                                  ;               terminated)
 30473                                  ;       [CURR_DIR_END] Points to end of Current dir part of string
 30474                                  ;               ( = -1 if current dir not involved, else
 30475                                  ;                Points to first char after last "/" of current dir part)
 30476                                  ;       [THISCDS] Points to CDS being used
 30477                                  ;       [THISSFT] Points to an empty SFT. EXCEPT sf_mode filled in.
 30478                                  ; Function:
 30479                                  ;       Make a new node
 30480                                  ; Outputs:
 30481                                  ;       Sets EXTERR_LOCUS = errLOC_Disk or errLOC_Unk via GetPathNoset
 30482                                  ;       CARRY SET IF ERROR
 30483                                  ;          AX = 1 A node by this name exists and is a directory
 30484                                  ;          AX = 2 A new node could not be created
 30485                                  ;          AX = 3 A node by this name exists and is a disk file
 30486                                  ;               (AH was NZ on input)
 30487                                  ;          AX = 4 Bad Path
 30488                                  ;               SI return from GetPath maintained
 30489                                  ;          AX = 5 Attribute mismatch
 30490                                  ;          AX = 6 Sharing Violation
 30491                                  ;               (INT 24 generated ALWAYS since create is always compat mode
 30492                                  ;          AX = 7 file not found for Extended Open (not exists and fails)
 30493                                  ;       ELSE
 30494                                  ;          AX = 0 Disk Node
 30495                                  ;          AX = 3 Device Node (error in some cases)
 30496                                  ;          [DIRSTART],[DIRSEC],[CLUSFAC],[CLUSNUM] set to directory
 30497                                  ;               containing new node.
 30498                                  ;          [CURBUF+2]:BX Points to entry
 30499                                  ;          [CURBUF+2]:SI Points to entry.dir_first
 30500                                  ;          [THISSFT] is filled in
 30501                                  ;               sf_mode = unchanged.
 30502                                  ;          Attribute byte in entry is input AL
 30503                                  ; DS preserved, others destroyed
 30504                                  ;
 30505                                  ;-------------------------------------------------------------------------
 30506                                  
 30507                                  ; 19/05/2019 - Retro DOS v4.0
 30508                                  ; DOSCODE:8925h (MSDOS 6.21, MSDOS.SYS)
 30509                                  
 30510                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30511                                  ; DOSCODE:88EAh (MSDOS 5.0, MSDOS.SYS)
 30512                                  
 30513                                  MakeNode:
 30514                                  	;mov	word [CREATING],0E5FFh
 30515 0000536B C706[7E05]FFE5          	MOV	WORD [CREATING],DIRFREE*256 + 0FFh ; Creating, not DEL *.*
 30516 00005371 50                              PUSH    AX              ; Save AH value
 30517 00005372 C606[4C03]00            	MOV	byte [NoSetDir],0
 30518 00005377 A2[6D05]                	MOV	[SATTRIB],AL
 30519 0000537A E888F5                  	call	GetPathNoSet
 30520 0000537D 88CA                            MOV     DL,CL           ; Save CL info
 30521 0000537F 89C1                            MOV     CX,AX           ; Device ID to CH
 30522 00005381 58                              POP     AX              ; Get back AH
 30523 00005382 732E                            JNC	short make_exists ; File existed
 30524 00005384 7505                            JNZ	short make_err_4 ; Path bad
 30525 00005386 80FA80                          CMP     DL,80h          ; Check "CL" return from GETPATH
 30526 00005389 7406                            JZ	short make_type	; Name simply not found, and no metas
 30527                                  make_err_4:
 30528 0000538B B004                            MOV     AL,4            ; case 1 bad path
 30529                                  make_err_ret:
 30530 0000538D 30E4                            XOR     AH,AH
 30531 0000538F F9                              STC
 30532                                  ;make_retn:	; 22/11/2022
 30533 00005390 C3                              retn
 30534                                  
 30535                                          ;entry	RENAME_MAKE     ; Used by DOS_RENAME to "copy" a node
 30536                                  RENAME_MAKE:
 30537                                  make_type:
 30538                                  ;Extended Open hooks
 30539                                  	; MSDOS 6.0
 30540                                  	;TESTB	EXTOPEN_ON,EXT_OPEN_ON	;FT. from extended open		;AN000;
 30541 00005391 F606[F605]01            	test	byte [EXTOPEN_ON],EXT_OPEN_ON ; 1
 30542 00005396 7411                    	JZ	short make_type2	;FT. no				;AN000;
 30543 00005398 800E[F605]04            	OR	byte [EXTOPEN_ON],EXT_FILE_NOT_EXISTS ; 4
 30544                                  					;FT. set for extended open ;AN000;
 30545                                  	;TESTB	EXTOPEN_FLAG,0F0H	;FT. not exists and fails	;AN000;
 30546 0000539D F606[F405]F0            	test	byte [EXTOPEN_FLAG],0F0h
 30547 000053A2 7505                    	JNZ	short make_type2	;FT. no				;AN000;
 30548 000053A4 F9                      	STC				;FT. set carry			;AN000;
 30549 000053A5 B80700                  	MOV    AX,7			;FT. file not found		;AN000;
 30550                                  	; 22/11/2022
 30551                                  make_retn:
 30552                                  	;return
 30553 000053A8 C3                      	retn				;FT.				;AN000;
 30554                                  
 30555                                  ;	Extended Open hooks
 30556                                  
 30557                                  make_type2:
 30558 000053A9 C43E[9E05]                      LES     DI,[THISSFT]
 30559 000053AD 31C0                            XOR     AX,AX           ; nothing exists Disk Node
 30560 000053AF F9                              STC                     ; Not found
 30561 000053B0 EB5A                            JMP     short make_new
 30562                                  
 30563                                  ; The node exists. It may be either a device, directory or file:
 30564                                  ;   Zero set => directory
 30565                                  ;   High bit of CH on => device
 30566                                  ;   else => file
 30567                                  
 30568                                  make_exists:
 30569 000053B2 7448                            JZ	short make_exists_dir
 30570 000053B4 B003                            MOV     AL,3            ; file exists type 3  (error or device node)
 30571                                  	;test	byte [ATTRIB],18h
 30572 000053B6 F606[6B05]18            	TEST	byte [ATTRIB],attr_volume_id+attr_directory
 30573 000053BB 753B                            JNZ	short make_err_ret_5
 30574                                  				; Cannot already exist as Disk or Device Node
 30575                                                                  ;       if making DIR or Volume ID
 30576 000053BD 08ED                            OR      CH,CH
 30577 000053BF 781A                            JS	short make_share ; No further checks on attributes if device
 30578 000053C1 08E4                            OR      AH,AH
 30579 000053C3 75C8                            JNZ	short make_err_ret ; truncating NOT OK (AL = 3)
 30580 000053C5 51                              PUSH    CX              ; Save device ID
 30581 000053C6 8E06[E405]                      MOV     ES,[CURBUF+2]
 30582                                  	;mov	ch,[es:bx+0Bh]
 30583 000053CA 268A6F0B                        MOV     CH,[ES:BX+dir_entry.dir_attr] ; Get file attributes
 30584                                  	;test	ch,1
 30585 000053CE F6C501                  	test	CH,attr_read_only
 30586 000053D1 7524                            JNZ	short make_err_ret_5P ; Cannot create on read only files
 30587 000053D3 E8D0F7                  	call	MatchAttributes
 30588 000053D6 59                              POP     CX              ; Devid back in CH
 30589 000053D7 751F                            JNZ	short make_err_ret_5 ; Attributes not ok
 30590 000053D9 30C0                            XOR     AL,AL           ; AL = 0, Disk Node
 30591                                  make_share:
 30592 000053DB 30E4                            XOR     AH,AH
 30593 000053DD 50                              PUSH    AX              ; Save Disk or Device node
 30594 000053DE 51                              PUSH    CX              ; Save Device ID
 30595 000053DF 88EC                            MOV     AH,CH           ; Device ID to AH
 30596 000053E1 E84501                          CALL    DOOPEN          ; Fill in SFT for share check
 30597 000053E4 C43E[9E05]                      LES     DI,[THISSFT]
 30598 000053E8 56                      	push	si
 30599 000053E9 53                      	push	bx		; Save CURBUF pointers
 30600 000053EA E8A129                  	call	ShareEnter
 30601 000053ED 735A                            jnc	short MakeEndShare
 30602                                  
 30603                                  ; User failed request.
 30604 000053EF 5B                      	pop	bx
 30605 000053F0 5E                      	pop	si
 30606 000053F1 59                      	pop	cx
 30607 000053F2 58                      	pop	ax
 30608                                  
 30609                                  Make_Share_ret:
 30610 000053F3 B006                            MOV     AL,6
 30611 000053F5 EB96                            JMP	short make_err_ret
 30612                                  
 30613                                  make_err_ret_5P:
 30614 000053F7 59                              POP     CX              ; Get back device ID
 30615                                  make_err_ret_5:
 30616 000053F8 B005                            MOV     AL,5            ; Attribute mismatch
 30617                                          ; 22/11/2022
 30618 000053FA EB91                    	JMP     short make_err_ret
 30619                                  
 30620                                  make_exists_dir:
 30621 000053FC B001                            MOV     AL,1            ; exists as directory, always an error
 30622                                  	; 22/11/2022
 30623 000053FE EB8D                    	JMP     short make_err_ret
 30624                                  
 30625                                  make_save:
 30626 00005400 50                              PUSH    AX              ; Save whether Disk or File
 30627 00005401 89C8                            MOV     AX,CX           ; Device ID to AH
 30628 00005403 E87400                          CALL    NEWENTRY
 30629 00005406 58                              POP     AX              ; 0 if Disk, 3 if File
 30630 00005407 739F                            jnc	short make_retn
 30631 00005409 B002                            MOV     AL,2            ; create failed case 2
 30632                                  make_save_retn:
 30633 0000540B C3                              retn
 30634                                  
 30635                                  make_new:
 30636 0000540C E8F1FF                          call    make_save
 30637 0000540F 72FA                            jc	short make_save_retn	; case 2 fail
 30638                                  	;test	byte [ATTRIB],10h
 30639 00005411 F606[6B05]10            	test	BYTE [ATTRIB],attr_directory
 30640 00005416 75F3                            jnz	short make_save_retn	; Don't "open" directories,
 30641                                  					; so don't tell the sharer about them
 30642 00005418 50                      	push	ax
 30643 00005419 53                      	push	bx
 30644 0000541A 56                      	push	si		
 30645 0000541B E87029                          call	ShareEnter
 30646 0000541E 5E                      	pop	si
 30647 0000541F 5B                      	pop	bx
 30648 00005420 58                      	pop	ax
 30649 00005421 73E8                    	jnc	short make_save_retn
 30650                                  
 30651                                  ; We get here by having the user FAIL a share problem. Typically a failure of
 30652                                  ; this nature is an out-of-space or an internal error. We clean up as best as
 30653                                  ; possible: delete the newly created directory entry and return share_error.
 30654                                  
 30655 00005423 50                              PUSH    AX
 30656 00005424 C43E[E205]                      LES     DI,[CURBUF]
 30657                                  	;mov	byte [es:bx],0E5h
 30658 00005428 26C607E5                	MOV	BYTE [ES:BX],DIRFREE	; nuke newly created entry.
 30659                                  	
 30660                                  	; MSDOS 6.0
 30661                                  	;test	byte [es:di+5],40h
 30662 0000542C 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 30663                                  					;LB. if already dirty		  ;AN000;
 30664 00005431 7508                            JNZ	short yesdirty8		;LB.  don't increment dirty count ;AN000;
 30665                                  	; 22/11/2022
 30666 00005433 E83511                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 30667                                  	;or	byte [es:di+5],40h
 30668 00005436 26804D0540                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty ; flag buffer as dirty
 30669                                  yesdirty8:
 30670 0000543B C42E[8A05]                      LES     BP,[THISDPB]
 30671                                  	; 15/12/2022
 30672 0000543F 268A4600                        mov	al,[ES:BP]
 30673                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30674                                  	;;mov	al,[es:bp+0]
 30675                                  	;MOV	AL,[ES:BP+DPB.DRIVE]	; get drive for flush
 30676 00005443 E81410                          call	FLUSHBUF		; write out buffer.
 30677 00005446 58                              POP     AX
 30678 00005447 EBAA                            jmp	short Make_Share_ret
 30679                                  
 30680                                  ; We have found an existing file. We have also entered it into the share set.
 30681                                  ; At this point we need to call newentry to correctly address the problem of
 30682                                  ; getting rid of old data (create an existing file) or creating a new
 30683                                  ; directory entry (create a new file). Unfortunately, this operation may
 30684                                  ; result in an INT 24 that the user doesn't return from, thus locking the file
 30685                                  ; irretrievably into the share set. The correct solution is for us to LEAVE
 30686                                  ; the share set now, do the operation and then reassert the share access.
 30687                                  ;
 30688                                  ; We are allowed to do this! There is no window! After all, we are in
 30689                                  ; critDisk here and for someone else to get in, they must enter critDisk also.
 30690                                  
 30691                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30692                                  	; DOSCODE:89C8h (MSDOS 5.0, MSDOS.SYS)
 30693                                  
 30694                                  MakeEndShare:
 30695 00005449 C43E[9E05]                      LES     DI,[THISSFT]		; grab SFT
 30696 0000544D 31C0                            XOR     AX,AX
 30697 0000544F E8B1C4                  	call	ECritSFT
 30698 00005452 268705                  	xchg	AX,[ES:DI]
 30699                                  	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 30700 00005455 50                      	push	ax
 30701 00005456 57                      	push	di
 30702 00005457 06                      	push	es
 30703 00005458 9C                              PUSHF
 30704 00005459 E82D29                          call	ShareEnd                ; remove sharing
 30705 0000545C 9D                              POPF
 30706 0000545D 07                      	pop	es
 30707 0000545E 5F                      	pop	di
 30708 0000545F 268F05                          pop	word [ES:DI]	
 30709                                  	;pop	word [ES:DI+SF_ENTRY.sf_ref_count]
 30710 00005462 E8CBC4                  	call	LCritSFT
 30711                                  	; 22/11/2022
 30712                                  	; DOSCODE:89E4h (MSDOS 5.0, MSDOS.SYS)
 30713 00005465 5B                      	pop	bx
 30714 00005466 5E                      	pop	si
 30715 00005467 59                      	pop	cx
 30716 00005468 58                      	pop	ax
 30717 00005469 E894FF                          CALL    make_save
 30718                                  
 30719                                  ; If the user failed, we do not reenter into the sharing set.
 30720                                  
 30721 0000546C 729D                            jc	short make_save_retn	; bye if error
 30722 0000546E 50                      	push	ax
 30723 0000546F 53                      	push	bx
 30724 00005470 56                      	push	si
 30725 00005471 9C                              PUSHF
 30726 00005472 E81929                          call	ShareEnter
 30727 00005475 9D                              POPF
 30728 00005476 5E                      	pop	si
 30729 00005477 5B                      	pop	bx
 30730 00005478 58                      	pop	ax
 30731                                  
 30732                                  ; If Share_check fails, then we have an internal ERROR!!!!!
 30733                                  
 30734                                  makeendshare_retn:
 30735 00005479 C3                              retn
 30736                                  
 30737                                  ;---------------------------------------------------------------------------
 30738                                  ;
 30739                                  ; Procedure Name : NEWENTRY
 30740                                  ;
 30741                                  ; Inputs:
 30742                                  ;       [THISSFT] set
 30743                                  ;       [THISDPB] set
 30744                                  ;       [LASTENT] current last valid entry number in directory if no free
 30745                                  ;               entries
 30746                                  ;       [VOLID] set if a volume ID was found during search
 30747                                  ;	Attrib Contains attributes for new file
 30748                                  ;       [DIRSTART] Points to first cluster of dir (0 means root)
 30749                                  ;       CARRY FLAG INDICATES STATUS OF SEARCH FOR FILE
 30750                                  ;               NC means file existed (device)
 30751                                  ;               C  means file did not exist
 30752                                  ;       AH = Device ID byte
 30753                                  ;       If FILE
 30754                                  ;           [CURBUF+2]:BX points to start of directory entry
 30755                                  ;           [CURBUF+2]:SI points to dir_first of directory entry
 30756                                  ;       If device
 30757                                  ;           DS:BX points to start of "fake" directory entry
 30758                                  ;           DS:SI points to dir_first of "fake" directory entry
 30759                                  ;               (has DWORD pointer to device header)
 30760                                  ; Function:
 30761                                  ;       Make a new directory entry
 30762                                  ;       If an old one existed it is truncated first
 30763                                  ; Outputs:
 30764                                  ;       Carry set if error
 30765                                  ;               Can't grow dir, atts didn't match, attempt to make 2nd
 30766                                  ;               vol ID, user FAILed to I 24
 30767                                  ;       else
 30768                                  ;               outputs of DOOPEN
 30769                                  ; DS, BX, SI preserved (meaning on SI BX, not value), others destroyed
 30770                                  ;
 30771                                  ;----------------------------------------------------------------------------
 30772                                  
 30773                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30774                                  	; DOSCODE:89F9h (MSDOS 5.0, MSDOS.SYS)
 30775                                  
 30776                                  NEWENTRY:
 30777 0000547A C42E[8A05]                      LES     BP,[THISDPB]
 30778 0000547E 7315                            JNC	short EXISTENT	
 30779 00005480 803E[4A03]00                    CMP     byte [FAILERR],0
 30780                                  	;STC
 30781                                          ;jnz	short makeendshare_retn	; User FAILed, node might exist
 30782                                          ; 24/09/2023
 30783 00005485 750C                    	jnz	short ERRRET3
 30784 00005487 E80CFE                  	CALL    BUILDDIR        ; Try to build dir
 30785 0000548A 72ED                            jc	short makeendshare_retn	; Failed
 30786 0000548C E89FF2                          call	GETENT          ; Point at that free entry
 30787 0000548F 72E8                            jc	short makeendshare_retn	; Failed
 30788 00005491 EB0E                            JMP     SHORT FREESPOT
 30789                                  
 30790                                  ERRRET3:
 30791 00005493 F9                              STC
 30792                                  newentry_retn:
 30793 00005494 C3                              retn
 30794                                  
 30795                                  EXISTENT:
 30796 00005495 08E4                            OR      AH,AH           ; Check if file is I/O device
 30797 00005497 7903                            JNS	short NOT_DEV1
 30798 00005499 E98D00                          JMP     DOOPEN          ; If so, proceed with open
 30799                                  
 30800                                  NOT_DEV1:
 30801 0000549C E82901                          call	FREEENT		; Free cluster chain
 30802 0000549F 72F3                            jc	short newentry_retn ; Failed
 30803                                  FREESPOT:
 30804                                  	;test	byte [ATTRIB],8
 30805 000054A1 F606[6B05]08            	test	BYTE [ATTRIB],attr_volume_id
 30806 000054A6 7407                            JZ	short NOTVOLID
 30807 000054A8 803E[7B05]00                    CMP     BYTE [VOLID],0
 30808 000054AD 75E4                            JNZ	short ERRRET3	; Can't create a second volume ID
 30809                                  NOTVOLID:
 30810 000054AF 8E06[E405]                      MOV     ES,[CURBUF+2]
 30811 000054B3 89DF                            MOV     DI,BX
 30812                                  
 30813 000054B5 BE[4B05]                        MOV     SI,NAME1
 30814                                  
 30815 000054B8 B90500                          MOV     CX,5
 30816 000054BB F3A5                            REP     MOVSW
 30817 000054BD A4                              MOVSB                   ; Move name into dir entry
 30818 000054BE A0[6B05]                	MOV	AL,[ATTRIB]
 30819 000054C1 AA                      	STOSB                   ; Attributes
 30820                                  
 30821                                  ;; File Tagging for Create DOS 4.00
 30822 000054C2 B105                            MOV     CL,5            ;FT. assume normal FBUGBUG	;AN000;
 30823                                  ;; File Tagging for Create DOS 4.00
 30824                                  
 30825 000054C4 31C0                            XOR     AX,AX
 30826 000054C6 F3AB                            REP     STOSW           ; Zero pad
 30827 000054C8 E8A1B6                          call	DATE16
 30828 000054CB 92                              XCHG    AX,DX
 30829 000054CC AB                              STOSW                   ; dir_time
 30830 000054CD 92                              XCHG    AX,DX
 30831 000054CE AB                              STOSW                   ; dir_date
 30832 000054CF 31C0                            XOR     AX,AX
 30833 000054D1 57                              PUSH    DI              ; Correct SI input value
 30834                                  				; 	(recomputed for new buffer)
 30835 000054D2 AB                              STOSW                   ; Zero dir_first and size
 30836 000054D3 AB                              STOSW
 30837 000054D4 AB                              STOSW
 30838                                  updnxt:
 30839 000054D5 8B36[E205]              	MOV	SI,[CURBUF]
 30840                                  
 30841                                  	; 19/05/2019 - Retro DOS v4.0
 30842                                  
 30843                                  	; MSDOS 6.0
 30844 000054D9 26F6440540              	TEST	byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
 30845                                  				;LB. if already dirty		  ;AN000;
 30846 000054DE 7508                            JNZ	short yesdirty9	;LB.  don't increment dirty count ;AN000;
 30847 000054E0 E88810                          call	INC_DIRTY_COUNT	;LB.				  ;AN000;
 30848                                          
 30849                                  	;or	byte [es:si+5],40h
 30850 000054E3 26804C0540              	OR      byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
 30851                                  yesdirty9:
 30852 000054E8 C42E[8A05]                      LES     BP,[THISDPB]
 30853                                  	; 15/12/2022
 30854 000054EC 268A4600                	MOV	AL,[ES:BP]
 30855                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30856                                  	;;mov	al,[es:bp+0]
 30857                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; Sets AH value again (in AL)
 30858 000054F0 50                              PUSH    AX
 30859 000054F1 53                              PUSH    BX
 30860                                  
 30861                                  ; If we have a file, we need to increment the open ref. count so that
 30862                                  ; we have some protection against invalid media changes if an Int 24
 30863                                  ; error occurs.
 30864                                  ; Do nothing for a device.
 30865                                  
 30866 000054F2 06                      	push	es
 30867 000054F3 57                      	push	di
 30868 000054F4 C43E[9E05]                      LES     DI,[THISSFT]
 30869                                  	;test	word [es:di+5],80h
 30870                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 30871 000054F8 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 30872 000054FD 751A                            jnz	short GotADevice
 30873 000054FF 1E                      	push	ds
 30874 00005500 53                      	push	bx
 30875 00005501 C51E[8A05]                      LDS     BX,[THISDPB]
 30876                                  	;mov	[es:di+7],bx
 30877 00005505 26895D07                        MOV     [ES:DI+SF_ENTRY.sf_devptr],BX
 30878 00005509 8CDB                            MOV     BX,DS
 30879                                  	;mov	[es:di+9],bx
 30880 0000550B 26895D09                        MOV     [ES:DI+SF_ENTRY.sf_devptr+2],BX
 30881 0000550F 5B                      	pop	bx
 30882 00005510 1F                      	pop	ds ; need to use DS for segment later on
 30883 00005511 E8B8FA                  	call	DEV_OPEN_SFT    ; increment ref. count
 30884 00005514 C606[A20A]01                    mov	byte [VIRTUAL_OPEN],1; set flag
 30885                                  GotADevice:
 30886 00005519 5F                      	pop	di
 30887 0000551A 07                      	pop	es
 30888                                  
 30889 0000551B E83C0F                          call	FLUSHBUF
 30890 0000551E E8EF00                          Call    CHECK_VIRT_OPEN ; decrement ref. count            ;AN000;
 30891 00005521 5B                              POP     BX
 30892 00005522 58                              POP     AX
 30893 00005523 5E                              POP     SI              ; Get SI input back
 30894 00005524 88C4                            MOV     AH,AL           ; Get I/O driver number back
 30895 00005526 7301                    	jnc	short DOOPEN    ; Failed
 30896 00005528 C3                      	retn
 30897                                  	
 30898                                  ;NOTE FALL THROUGH
 30899                                  
 30900                                  ; DOSCODE:8AE4h (MSDOS 6.21, MSDOS.SYS)
 30901                                  
 30902                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30903                                  ; DOSCODE:8AA9h (MSDOS 5.0, MSDOS.SYS)
 30904                                  
 30905                                  ; DOOPEN
 30906                                  ;----------------------------------------------------------------------------
 30907                                  ;
 30908                                  ; Inputs:
 30909                                  ;       [THISDPB] points to DPB if file
 30910                                  ;       [THISSFT] points to SFT being used
 30911                                  ;       AH = Device ID byte
 30912                                  ;       If FILE
 30913                                  ;           [CURBUF+2]:BX points to start of directory entry
 30914                                  ;           [CURBUF+2]:SI points to dir_first of directory entry
 30915                                  ;       If device
 30916                                  ;           DS:BX points to start of "fake" directory entry
 30917                                  ;           DS:SI points to dir_first of "fake" directory entry
 30918                                  ;               (has DWORD pointer to device header)
 30919                                  ; Function:
 30920                                  ;       Fill in SFT from dir entry
 30921                                  ; Outputs:
 30922                                  ;       CARRY CLEAR
 30923                                  ;       sf_ref_count and sf_mode fields not altered
 30924                                  ;       sf_flags high byte = 0
 30925                                  ;       sf_flags low byte = AH except
 30926                                  ;       sf_flags Bit 6 set (not dirty or not EOF)
 30927                                  ;       sf_attr sf_date sf_time sf_name set from entry
 30928                                  ;       sf_position = 0
 30929                                  ;       If device
 30930                                  ;           sf_devptr = dword at dir_first (pointer to device header)
 30931                                  ;           sf_size = 0
 30932                                  ;       If file
 30933                                  ;           sf_firclus sf_size set from entry
 30934                                  ;           sf_devptr = [THISDPB]
 30935                                  ;           sf_cluspos = 0
 30936                                  ;           sf_lstclus = sf_firclus
 30937                                  ;           sf_dirsec sf_dirpos set
 30938                                  ; DS,SI,BX preserved, others destroyed
 30939                                  ;
 30940                                  ;----------------------------------------------------------------------------
 30941                                  
 30942                                  	;entry	DOOPEN
 30943                                  DOOPEN:
 30944                                  ;	Generate and store attribute
 30945                                  
 30946 00005529 88E6                            MOV     DH,AH           ; AH to different place
 30947 0000552B C43E[9E05]                      LES     DI,[THISSFT]
 30948                                  	;add	di,4
 30949 0000552F 83C704                          ADD     DI,SF_ENTRY.sf_attr ; Skip ref_count and mode fields
 30950                                  	; 24/09/2023
 30951 00005532 31C0                    	xor	ax,ax
 30952                                  	;XOR	AL,AL		; Assume it's a device, devices have an
 30953                                  				;   attribute of 0 (for R/O testing etc).
 30954 00005534 08F6                            OR      DH,DH           ; See if our assumption good.
 30955 00005536 7807                            JS	short DEV_SFT1	; If device DS=DOSGROUP
 30956 00005538 8E1E[E405]                      MOV     DS,[CURBUF+2]
 30957                                  	;mov	al,[BX+0Bh]
 30958 0000553C 8A470B                          MOV     AL,[BX+dir_entry.dir_attr]
 30959                                  				; If file, get attrib from dir entry
 30960                                  DEV_SFT1:
 30961 0000553F AA                              STOSB                   ; sf_attr, ES:DI -> sf_flags
 30962                                  
 30963                                  ;	Generate and store flags word
 30964                                  
 30965                                  	; 24/09/2023
 30966                                  	;XOR	AX,AX
 30967                                          ; ah=0
 30968 00005540 88F0                    	MOV     AL,DH
 30969                                  	;or	al,40h
 30970 00005542 0C40                            OR      AL,devid_file_clean
 30971 00005544 AB                              STOSW                   ; sf_flags, ES:DI -> sf_devptr
 30972                                  
 30973                                  ;	Generate and store device pointer
 30974                                  
 30975 00005545 1E                              PUSH    DS
 30976                                  	;lds	ax,[bx+1Ah]
 30977 00005546 C5471A                          LDS     AX,[BX+dir_entry.dir_first] ; Assume device
 30978 00005549 08F6                            OR      DH,DH
 30979 0000554B 7805                            JS	short DEV_SFT2
 30980                                  
 30981                                  ;hkn; SS override
 30982 0000554D 36C506[8A05]                    LDS     AX,[SS:THISDPB]	; Was file
 30983                                  DEV_SFT2:
 30984 00005552 AB                              STOSW 			; store offset
 30985 00005553 8CD8                            MOV     AX,DS
 30986 00005555 1F                              POP     DS
 30987 00005556 AB                      	STOSW			; store segment
 30988                                  				; ES:DI -> sf_firclus
 30989                                  
 30990                                  ;	Generate pointer to, generate and store first cluster 
 30991                                  ;	(irrelevant for devices)
 30992                                  
 30993 00005557 56                              PUSH    SI              ; Save pointer to dir_first
 30994 00005558 A5                              MOVSW                   ; dir_first -> sf_firclus
 30995                                                                  ; DS:SI -> dir_size_l, ES:DI -> sf_time
 30996                                  
 30997                                  ;	Copy time/date of last modification
 30998                                  
 30999                                  	;sub	si,6
 31000 00005559 83EE06                          SUB     SI,dir_entry.dir_size_l - dir_entry.dir_time 
 31001                                  				; DS:SI->dir_time
 31002 0000555C A5                              MOVSW                   ; dir_time -> sf_time
 31003                                                                  ; DS:SI -> dir_date, ES:DI -> sf_date
 31004 0000555D A5                              MOVSW                   ; dir_date -> sf_date
 31005                                                                  ; DS:SI -> dir_first, ES:DI -> sf_size
 31006                                  
 31007                                  ;	Generate and store file size (0 for devices)
 31008                                  
 31009 0000555E AD                              LODSW                   ; skip dir_first, DS:SI -> dir_size_l
 31010 0000555F AD                              LODSW                   ; dir_size_l in AX , DS:SI -> dir_size_h
 31011 00005560 89C1                            MOV     CX,AX           ; dir_size_l in CX
 31012 00005562 AD                              LODSW                   ; dir_size_h (size AX:CX), DS:SI -> ????
 31013 00005563 08F6                            OR      DH,DH
 31014 00005565 7904                            JNS	short FILE_SFT1
 31015 00005567 31C0                            XOR     AX,AX
 31016 00005569 89C1                            MOV     CX,AX           ; Devices are open ended
 31017                                  FILE_SFT1:
 31018 0000556B 91                              XCHG    AX,CX
 31019 0000556C AB                              STOSW                   ; Low word of sf_size
 31020 0000556D 91                              XCHG    AX,CX
 31021 0000556E AB                              STOSW                   ; High word of sf_size
 31022                                                                  ; ES:DI -> sf_position
 31023                                  ; Initialize position to 0
 31024                                  
 31025 0000556F 31C0                            XOR     AX,AX
 31026 00005571 AB                              STOSW
 31027 00005572 AB                              STOSW                   ; sf_position
 31028                                                                  ; ES:DI -> sf_cluspos
 31029                                  
 31030                                  ; Generate cluster optimizations for files
 31031                                  
 31032 00005573 08F6                            OR      DH,DH
 31033 00005575 7843                            JS	short DEV_SFT3
 31034 00005577 AB                              STOSW                   ; sf_cluspos ; 19h
 31035                                  	;mov	ax,[bx+1Ah]
 31036 00005578 8B471A                          MOV     AX,[BX+dir_entry.dir_first]
 31037                                  	; 19/05/2019
 31038                                  	; MSDOS 3.3
 31039                                  	;STOSW 			; sf_lstclus ; 1Bh
 31040                                  	; MSDOS 6.0
 31041 0000557B 57                              PUSH	DI              ;AN004; save dirsec offset
 31042                                  	;sub	di,1Bh
 31043 0000557C 83EF1B                          SUB	DI,SF_ENTRY.sf_dirsec	;AN004; es:di -> SFT
 31044                                  	;mov	[es:di+35h],ax
 31045 0000557F 26894535                        MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX	;AN004; save it
 31046 00005583 5F                              POP	DI              ;AN004; restore dirsec offset
 31047                                  
 31048                                  ; DOS 3.3  FastOpen  6/13/86
 31049                                  
 31050 00005584 1E                      	PUSH	DS
 31051                                  
 31052                                  ;hkn; SS is DOSDATA
 31053 00005585 16                      	push	ss
 31054 00005586 1F                      	pop	ds
 31055                                  	;test	byte [FastOpenFlg],4
 31056 00005587 F606[6D12]04            	TEST	byte [FastOpenFlg],Special_Fill_Set
 31057 0000558C 7411                    	JZ	short Not_FastOpen
 31058                                  
 31059                                  ;hkn; FastOpen_Ext_Info is in DOSDATA
 31060 0000558E BE[8C0D]                        MOV     SI,FastOpen_Ext_Info
 31061                                  
 31062                                  	;mov	ax,[si+1]
 31063 00005591 8B4401                          MOV     AX,[SI+FEI.dirsec]
 31064 00005594 AB                              STOSW                   ; sf_dirsec
 31065                                  	; MSDOS 6.0
 31066                                  	;mov	ax,[si+3]
 31067 00005595 8B4403                          MOV	AX,[SI+FEI.dirsec+2]
 31068                                  				;;; changed for >32mb
 31069 00005598 AB                              STOSW                   ; sf_dirsec
 31070                                  	; 19/08//2018
 31071 00005599 8A04                    	mov	al,[SI]
 31072                                          ;MOV	AL,[SI+FEI.dirpos] ; mov al,[SI+0]
 31073 0000559B AA                              STOSB                   ; sf_dirpos
 31074 0000559C 1F                              POP	DS
 31075                                          ;JMP	short Next_Name
 31076                                  	; 24/09/2023
 31077 0000559D EB1E                    	jmp	short FILE_SFT2  ; cf=0 (after 'test' instruction)
 31078                                  
 31079                                  ; DOS 3.3  FastOpen  6/13/86
 31080                                  
 31081                                  Not_FastOpen:
 31082                                          ;POP     DS		; normal path
 31083                                  
 31084                                  ;hkn; SS override
 31085                                  	;MOV	SI,[SS:CURBUF]	; DS:SI->buffer header
 31086                                  	; 16/12/2022
 31087                                  	; 28/07/2019
 31088 0000559F 8B36[E205]              	mov	si,[CURBUF]
 31089 000055A3 1F                      	pop	ds
 31090                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 31091                                  	;pop	ds
 31092                                  	;mov	si,[ss:CURBUF]
 31093                                  	
 31094                                  	;mov	ax,[si+6]
 31095 000055A4 8B4406                          MOV     AX,[SI+BUFFINFO.buf_sector]     ;F.C. >32mb ;AN000;
 31096 000055A7 AB                              STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
 31097                                  	; 19/05/2019        
 31098                                  	; MSDOS 6.0
 31099                                  	;mov	ax,[si+8]
 31100 000055A8 8B4408                  	MOV	AX,[SI+BUFFINFO.buf_sector+2]	;F.C. >32mb ;AN000;
 31101 000055AB AB                              STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
 31102                                          
 31103 000055AC 89D8                    	MOV     AX,BX
 31104                                  	;;add	si,16	; MSDOS 3.3	
 31105                                  	;add	si,20	; MSDOS 6.0
 31106 000055AE 83C618                          ADD     SI,BUFINSIZ     ; DS:SI-> start of data in buffer
 31107 000055B1 29F0                            SUB     AX,SI           ; AX = BX relative to start of sector
 31108                                          ;mov	cl,32
 31109 000055B3 B120                    	MOV     CL,dir_entry.size
 31110 000055B5 F6F1                            DIV     CL
 31111 000055B7 AA                              STOSB                   ; sf_dirpos
 31112                                  Next_Name:
 31113 000055B8 EB03                            JMP     SHORT FILE_SFT2
 31114                                  
 31115                                  	; 24/09/2023
 31116                                  	; cf=0 (after 'or' instruction)
 31117                                  DEV_SFT3:
 31118                                  	;add	di,7
 31119 000055BA 83C707                          ADD     DI,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
 31120                                  FILE_SFT2:
 31121                                  
 31122                                  ; Copy in the object's name
 31123                                  
 31124 000055BD 89DE                            MOV     SI,BX           ; DS:SI points to dir_name
 31125 000055BF B90B00                          MOV     CX,11
 31126 000055C2 F3A4                            REP     MOVSB           ; sf_name
 31127 000055C4 5E                              POP     SI              ; recover DS:SI -> dir_first
 31128                                  
 31129                                  ;hkn; SS is DOSDATA
 31130 000055C5 16                              push	ss
 31131 000055C6 1F                      	pop	ds
 31132                                  	; 24/09/2023
 31133                                  	; cf=0
 31134                                          ;CLC
 31135 000055C7 C3                              retn
 31136                                  
 31137                                  ;---------------------------------------------------------------------------
 31138                                  ;
 31139                                  ; Procedure Name : FREEENT
 31140                                  ;
 31141                                  ; Inputs:
 31142                                  ;       ES:BP -> DPB
 31143                                  ;       [CURBUF] Set
 31144                                  ;       [CURBUF+2]:BX points to directory entry
 31145                                  ;       [CURBUF+2]:SI points to above dir_first
 31146                                  ; Function:
 31147                                  ;       Free the cluster chain for the entry if present
 31148                                  ; Outputs:
 31149                                  ;       Carry set if error (currently user FAILed to I 24)
 31150                                  ;       (NOTE dir_firclus and dir_size_l/h are wrong)
 31151                                  ; DS BX SI ES BP preserved (BX,SI in meaning, not value) others destroyed
 31152                                  ;---------------------------------------------------------------------------
 31153                                  
 31154                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31155                                  FREEENT:
 31156 000055C8 1E                              PUSH    DS
 31157 000055C9 C53E[E205]                      LDS     DI,[CURBUF]
 31158 000055CD 8B0C                            MOV     CX,[SI]         ; Get pointer to clusters
 31159                                  	; 19/05/2019 - Retro DOS v4.0
 31160                                  	; MSDOS 6.0
 31161 000055CF 8B5508                  	MOV	DX,[DI+BUFFINFO.buf_sector+2]  ;F.C. >32mb	;AN000;
 31162                                  ;hkn; SS override
 31163 000055D2 368916[0706]                    MOV	[SS:HIGH_SECTOR],DX		;F.C. >32mb	;AN000;
 31164 000055D7 8B5506                          MOV     DX,[DI+BUFFINFO.buf_sector]
 31165 000055DA 1F                              POP     DS
 31166 000055DB 83F902                  	CMP	CX,2
 31167 000055DE 722E                            JB	short RET1	; Was 0 length file (or mucked Firclus if CX=1)
 31168                                  	;cmp	cx,[es:bp+0Dh]
 31169 000055E0 263B4E0D                        CMP     CX,[ES:BP+DPB.MAX_CLUSTER]
 31170 000055E4 7728                            JA	short RET1	; Treat like zero length file (firclus mucked)
 31171 000055E6 29FB                            SUB     BX,DI
 31172 000055E8 53                              PUSH    BX              ; Save offset
 31173 000055E9 FF36[0706]              	PUSH	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
 31174 000055ED 52                              PUSH    DX              ; Save sector number
 31175 000055EE 89CB                            MOV     BX,CX
 31176 000055F0 E8AC02                          call	RELEASE         ; Free any data allocated
 31177 000055F3 5A                              POP     DX
 31178 000055F4 8F06[0706]                      POP	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
 31179 000055F8 7302                            JNC	short GET_BUF_BACK
 31180 000055FA 5B                              POP     BX
 31181                                  freeent_retn:
 31182 000055FB C3                              retn			; Screw up
 31183                                  
 31184                                  GET_BUF_BACK:
 31185                                  	; 22/09/2023
 31186                                  	;;mov	byte [ALLOWED],18h
 31187                                          ;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 31188                                          ;XOR	AL,AL ; *
 31189                                  	;call	GETBUFFR        ; Get sector back
 31190 000055FC E8570D                  	call	GETBUFFER ; * ; pre read      
 31191                                  
 31192 000055FF 5B                      	POP     BX              ; Get offset back
 31193 00005600 72F9                            jc	short freeent_retn
 31194 00005602 E86EE9                  	call	SET_BUF_AS_DIR
 31195 00005605 031E[E205]                      ADD     BX,[CURBUF]	; Correct it for new buffer
 31196 00005609 89DE                            MOV     SI,BX
 31197                                  	;add	si,1Ah
 31198 0000560B 83C61A                          ADD     SI,dir_entry.dir_first	; Get corrected SI
 31199                                  RET1:
 31200 0000560E F8                              CLC
 31201 0000560F C3                              retn
 31202                                  
 31203                                  ;---------------------------------------------------------------------------
 31204                                  ;
 31205                                  ; Procedure Name : CHECK_VIRT_OPEN
 31206                                  ;
 31207                                  ; CHECK_VIRT_OPEN checks to see if we had performed a "virtual open" (by
 31208                                  ; examining the flag [VIRTUAL_OPEN] to see if it is 1). If we did, then
 31209                                  ; it calls Dev_Close_SFT to decrement the ref. count. It also resets the
 31210                                  ; flag [VIRTUAL_OPEN].
 31211                                  ; No registers affected (including flags).
 31212                                  ; On input, [THISSFT] points to current SFT.
 31213                                  ;
 31214                                  ;---------------------------------------------------------------------------
 31215                                  
 31216                                  CHECK_VIRT_OPEN:
 31217 00005610 50                      	PUSH    AX
 31218 00005611 9F                              lahf                    ; preserve flags
 31219 00005612 803E[A20A]00                    CMP     byte [VIRTUAL_OPEN],0
 31220 00005617 7410                            JZ	short ALL_CLOSED
 31221 00005619 C606[A20A]00                    mov     byte [VIRTUAL_OPEN],0	; reset flag
 31222 0000561E 06                      	push	es
 31223 0000561F 57                      	push	di
 31224 00005620 C43E[9E05]                      LES     DI,[THISSFT]
 31225 00005624 E8ADF9                          call	DEV_CLOSE_SFT
 31226 00005627 5F                      	pop	di
 31227 00005628 07                      	pop	es
 31228                                  
 31229                                  ALL_CLOSED:
 31230 00005629 9E                              sahf                    ; restore flags
 31231 0000562A 58                              POP     AX
 31232 0000562B C3                              retn
 31233                                  
 31234                                  ;============================================================================
 31235                                  ; ROM.ASM, MSDOS 6.0, 1991
 31236                                  ;============================================================================
 31237                                  ; 29/07/2018 - Retro DOS v3.0
 31238                                  ; 20/05/2019 - Retro DOS v4.0
 31239                                  
 31240                                  ;	TITLE	ROM - Miscellaneous routines
 31241                                  ;	NAME	ROM
 31242                                  
 31243                                  ;**	Misc Low level routines for doing simple FCB computations, Cache
 31244                                  ;       reads and writes, I/O optimization, and FAT allocation/deallocation
 31245                                  ;
 31246                                  ;	SKPCLP
 31247                                  ;	FNDCLUS
 31248                                  ;	BUFSEC
 31249                                  ;	BUFRD
 31250                                  ;	BUFWRT
 31251                                  ;	NEXTSEC
 31252                                  ;	OPTIMIZE
 31253                                  ;	FIGREC
 31254                                  ;	ALLOCATE
 31255                                  ;	RESTFATBYT
 31256                                  ;	RELEASE
 31257                                  ;	RELBLKS
 31258                                  ;	GETEOF
 31259                                  ;
 31260                                  ;	Modification history:
 31261                                  ;
 31262                                  ;		Created: ARR 30 March 1983
 31263                                  ;               M039: DB 10/25/90 - Disk read/write optimization.
 31264                                  
 31265                                  ;Break   <FNDCLUS -- Skip over allocation units>
 31266                                  ;--------------------------------------------------------------------------
 31267                                  ;
 31268                                  ; Procedure Name : FNDCLUS
 31269                                  ;
 31270                                  ; Inputs:
 31271                                  ;       CX = No. of clusters to skip
 31272                                  ;       ES:BP = Base of drive parameters
 31273                                  ;       [THISSFT] point to SFT
 31274                                  ; Outputs:
 31275                                  ;       BX = Last cluster skipped to
 31276                                  ;       CX = No. of clusters remaining (0 unless EOF)
 31277                                  ;       DX = Position of last cluster
 31278                                  ;       Carry set if error (currently user FAILed to I 24)
 31279                                  ; DI destroyed. No other registers affected.
 31280                                  ;--------------------------------------------------------------------------
 31281                                  
 31282                                  ; 20/05/2019 - Retro DOS v4.0
 31283                                  ; DOSCODE:8BF2h (MSDOS 6.21, MSDOS.SYS)
 31284                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31285                                  ; DOSCODE:8BB7h (MSDOS 5.0, MSDOS.SYS)
 31286                                  
 31287                                  FNDCLUS:
 31288 0000562C 06                      	PUSH	ES
 31289 0000562D C43E[9E05]                      LES     DI,[THISSFT]		; setup addressability to SFT
 31290                                  	;;mov	bx,[es:di+1Bh] ; MSDOS 3.3
 31291                                  	;mov	bx,[es:di+35h] ; MSDOS 6.0
 31292 00005631 268B5D35                	MOV	BX,[ES:DI+SF_ENTRY.sf_lstclus]
 31293                                  	;mov	dx,[es:di+19h]
 31294 00005635 268B5519                        MOV     DX,[ES:DI+SF_ENTRY.sf_cluspos]
 31295 00005639 09DB                    	OR	BX,BX
 31296 0000563B 7424                    	JZ	short NOCLUS
 31297                                  
 31298 0000563D 29D1                            SUB     CX,DX
 31299 0000563F 7308                            JNB	short FINDIT
 31300                                  
 31301 00005641 01D1                            ADD     CX,DX
 31302 00005643 31D2                            XOR     DX,DX
 31303                                  	;mov	bx,[es:di+0Bh]
 31304 00005645 268B5D0B                        MOV     BX,[ES:DI+SF_ENTRY.sf_firclus]
 31305                                  FINDIT:
 31306 00005649 07                              POP	ES
 31307 0000564A E313                    	JCXZ	RET9
 31308                                  
 31309                                  	;entry	SKPCLP
 31310                                  SKPCLP:
 31311 0000564C E8CE08                  	call	UNPACK
 31312 0000564F 7214                            jc	short fndclus_retn	; retc
 31313                                  
 31314                                  	; 09/09/2018
 31315                                  
 31316                                  	; MSDOS 3.3
 31317                                  	;push	bx
 31318                                  	;mov	bx,di
 31319                                  	;call	IsEOF
 31320                                  	;pop	bx	
 31321                                  	;jae	short RET9
 31322                                  
 31323                                  	; 20/05/2019 - Retro DOS v4.0
 31324                                  
 31325                                  	; MSDOS 6.0
 31326 00005651 87DF                    	xchg	bx,di
 31327 00005653 E8B008                  	call	IsEOF
 31328 00005656 87DF                    	xchg	bx,di
 31329 00005658 7305                    	jae	short RET9
 31330                                  
 31331 0000565A 87DF                            XCHG    BX,DI
 31332 0000565C 42                              INC     DX
 31333                                  
 31334 0000565D E2ED                    	LOOP	SKPCLP			; RMFS
 31335                                  RET9:	
 31336 0000565F F8                      	CLC
 31337 00005660 C3                              retn
 31338                                  NOCLUS:
 31339 00005661 07                              POP	ES
 31340 00005662 41                              INC	CX
 31341 00005663 4A                              DEC	DX
 31342 00005664 F8                              CLC
 31343                                  
 31344                                  fndclus_retn:
 31345 00005665 C3                              retn
 31346                                  
 31347                                  ;Break  <BUFSEC -- BUFFER A SECTOR AND SET UP A TRANSFER>
 31348                                  ;--------------------------------------------------------------------------
 31349                                  ;
 31350                                  ; Procedure Name : BUFSEC
 31351                                  ;
 31352                                  ; Inputs:
 31353                                  ;       AH = priority of buffer
 31354                                  ;       AL = 0 if buffer must be read, 1 if no pre-read needed
 31355                                  ;       ES:BP = Base of drive parameters
 31356                                  ;       [CLUSNUM] = Physical cluster number
 31357                                  ;       [SECCLUSPOS] = Sector position of transfer within cluster
 31358                                  ;       [BYTCNT1] = Size of transfer
 31359                                  ; Function:
 31360                                  ;       Insure specified sector is in buffer, flushing buffer before
 31361                                  ;       read if necessary.
 31362                                  ; Outputs:
 31363                                  ;       ES:DI = Pointer to buffer
 31364                                  ;       SI = Pointer to transfer address
 31365                                  ;       CX = Number of bytes
 31366                                  ;       [NEXTADD] updated
 31367                                  ;       [TRANS] set to indicate a transfer will occur
 31368                                  ;       Carry set if error (user FAILed to I 24)
 31369                                  ;--------------------------------------------------------------------------
 31370                                  
 31371                                  BUFSEC:
 31372 00005666 8B16[BC05]                      MOV     DX,[CLUSNUM]
 31373 0000566A 8A1E[7305]                      MOV     BL,[SECCLUSPOS]
 31374                                  	;mov	byte [ALLOWED],38h
 31375 0000566E C606[4B03]38                    MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY+Allowed_IGNORE
 31376 00005673 E85001                          CALL    FIGREC
 31377 00005676 E8E40C                  	call	GETBUFFR
 31378 00005679 72EA                            jc	short fndclus_retn
 31379                                  
 31380 0000567B C606[7405]01                    MOV     BYTE [TRANS],1	; A transfer is taking place
 31381 00005680 8B36[B805]                      MOV     SI,[NEXTADD]
 31382 00005684 89F7                            MOV     DI,SI
 31383 00005686 8B0E[D205]                      MOV     CX,[BYTCNT1]
 31384 0000568A 01CF                            ADD     DI,CX
 31385 0000568C 893E[B805]                      MOV     [NEXTADD],DI
 31386 00005690 C43E[E205]                      LES     DI,[CURBUF]
 31387                                  	;or	byte [es:di+5],8
 31388 00005694 26804D0508                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDATA
 31389                                  	;;lea	di,[di+16] ; MSDOS 3.3 
 31390                                  	;lea	di,[di+20] ; MSDOS 6.0
 31391 00005699 8D7D18                          LEA     DI,[DI+BUFINSIZ]        ; Point to buffer
 31392 0000569C 033E[CC05]                      ADD     DI,[BYTSECPOS]
 31393 000056A0 F8                              CLC
 31394 000056A1 C3                              retn
 31395                                  
 31396                                  ;Break   <BUFRD, BUFWRT -- PERFORM BUFFERED READ AND WRITE>
 31397                                  
 31398                                  ;---------------------------------------------------------------------------
 31399                                  ;
 31400                                  ; Procedure Name : BUFRD
 31401                                  ;
 31402                                  ; Do a partial sector read via one of the system buffers
 31403                                  ; ES:BP Points to DPB
 31404                                  ; Carry set if error (currently user FAILed to I 24)
 31405                                  ;
 31406                                  ; DS - set to DOSDATA
 31407                                  ;
 31408                                  ;----------------------------------------------------------------------------
 31409                                  
 31410                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31411                                  	; 20/05/2019 - Retro DOS v4.0
 31412                                  BUFRD:
 31413 000056A2 06                              PUSH	ES
 31414 000056A3 31C0                            xor	ax, ax			; pre-read sector
 31415 000056A5 E8BEFF                          CALL    BUFSEC
 31416 000056A8 7303                            JNC	short BUF_OK
 31417                                  
 31418                                  BUF_IO_FAIL:				; this label used by BUFWRT also
 31419 000056AA 07                              POP	ES
 31420 000056AB EB2B                            JMP     SHORT RBUFPLACED
 31421                                  
 31422                                  BUF_OK:
 31423 000056AD 8CC3                            MOV     BX,ES
 31424 000056AF 8E06[2E03]                      MOV     ES,[DMAADD+2]
 31425 000056B3 8EDB                            MOV     DS,BX
 31426 000056B5 87FE                    	XCHG    DI,SI
 31427 000056B7 D1E9                            SHR     CX,1
 31428                                  ;M039
 31429                                  	; MSDOS 3.3
 31430                                  	;JNC	short EVENRD
 31431                                  	;MOVSB
 31432                                  ;EVENRD:
 31433                                  	;REP     MOVSW
 31434                                  
 31435                                  ;	CX = # of whole WORDs ; CF=1 if odd # of bytes.
 31436                                  ;       DS:SI-> Source within Buffer.
 31437                                  ;       ES:DI-> Destination within Transfer memory block.
 31438                                  
 31439                                  	; MSDOS 6.0
 31440 000056B9 F3A5                    	rep	movsw			;Copy Buffer to Transfer memory.
 31441                                  	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 31442                                  	;rep	movsb                   ;Copy last byte.
 31443                                  	; 16/12/2022
 31444 000056BB 7301                    	jnc	short EVENRD ; **** 20/05/2019
 31445 000056BD A4                      	movsb ; ****
 31446                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 31447                                  	;adc	cx,0
 31448                                  	;rep	movsb
 31449                                  ;M039
 31450                                  EVENRD: ; ****
 31451 000056BE 07                              POP	ES
 31452                                  ;hkn; SS override
 31453 000056BF 36C53E[E205]                    LDS     DI,[SS:CURBUF]
 31454                                  	;;lea	bx,[di+16]
 31455                                  	;lea	bx,[di+20] ; MSDOS 6.0
 31456 000056C4 8D5D18                  	LEA     BX,[DI+BUFINSIZ]
 31457 000056C7 29DE                            SUB     SI,BX                   ; Position in buffer
 31458 000056C9 E8310C                          call	PLACEBUF
 31459                                  	;cmp	si,[es:bp+2]
 31460 000056CC 263B7602                	CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Read Last byte?
 31461 000056D0 7205                            JB	short RBUFPLACEDC	; No, leave buf where it is
 31462                                  ;M039
 31463                                  	; MSDOS 3.3
 31464                                  	;call	PLACEHEAD               ; Make it prime candidate for chucking
 31465                                                                          ;  even though it is MRU.
 31466                                          ; MSDOS 6.0
 31467 000056D2 36893E[6D00]            	MOV	[ss:BufferQueue],DI	; Make it prime candidate for
 31468                                  ;M039					; chucking even though it is MRU.
 31469                                  
 31470                                  RBUFPLACEDC:
 31471 000056D7 F8                              CLC
 31472                                  RBUFPLACED:
 31473 000056D8 16                      	push	ss
 31474 000056D9 1F                      	pop	ds
 31475 000056DA C3                              retn
 31476                                  
 31477                                  ;----------------------------------------------------------------------------
 31478                                  ;
 31479                                  ; Procedure : BUFWRT
 31480                                  ;
 31481                                  ; Do a partial sector write via one of the system buffers
 31482                                  ; ES:BP Points to DPB
 31483                                  ; Carry set if error (currently user FAILed to I 24)
 31484                                  ;
 31485                                  ; DS - set to DOSDATA
 31486                                  ;
 31487                                  ;----------------------------------------------------------------------------
 31488                                  
 31489                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31490                                  	; 20/05/2019 - Retro DOS v4.0
 31491                                  BUFWRT:
 31492                                          ;MOV     AX,[SECPOS]
 31493                                          ; MSDOS 6.0
 31494                                  	;ADD	AX,1            	; Set for next sector
 31495                                          ;MOV	[SECPOS],AX 		;F.C. >32mb	;AN000;
 31496                                          ;ADC	word [SECPOS+2],0	;F.C. >32mb	;AN000;
 31497                                          ; 24/09/2023
 31498 000056DB FF06[C405]              	inc	word [SECPOS]
 31499 000056DF 7504                    	jnz	short bufw_secpos
 31500 000056E1 FF06[C605]              	inc	word [SECPOS+2]
 31501                                  bufw_secpos:
 31502 000056E5 A1[C605]                	MOV	AX,[SECPOS+2]		;F.C. >32mb	;AN000;
 31503 000056E8 3B06[CA05]                      CMP	AX,[VALSEC+2]		;F.C. >32mb	;AN000;
 31504 000056EC B001                            MOV	AL,1			;F.C. >32mb	;AN000;
 31505 000056EE 770F                            JA	short NOREAD		;F.C. >32mb	;AN000;
 31506 000056F0 720B                            JB	short _doread		;F.C. >32mb	;AN000;
 31507 000056F2 A1[C405]                        MOV	AX,[SECPOS]		;F.C. >32mb	;AN000;
 31508                                  
 31509                                  	; MSDOS 3.3
 31510                                  	;INC	AX
 31511                                  	;MOV	[SECPOS],AX ; 09/09/2018
 31512                                  
 31513                                  	; 20/05/2019
 31514                                  	; MSDOS 3.3 & MSDOS 6.0
 31515 000056F5 3B06[C805]                      CMP     AX,[VALSEC]		; Has sector been written before?
 31516 000056F9 B001                            MOV     AL,1
 31517 000056FB 7702                            JA	short NOREAD		; Skip preread if SECPOS>VALSEC
 31518                                  _doread:
 31519 000056FD 30C0                            XOR     AL,AL
 31520                                  NOREAD:
 31521 000056FF 06                              PUSH	ES
 31522 00005700 E863FF                          CALL    BUFSEC
 31523 00005703 72A5                    	JC	short BUF_IO_FAIL
 31524 00005705 8E1E[2E03]                      MOV     DS,[DMAADD+2]
 31525 00005709 D1E9                            SHR     CX,1
 31526                                  ;M039
 31527                                  	; MSDOS 3.3
 31528                                  	;JNC	short EVENWRT ; 09/09/2018
 31529                                  	;MOVSB
 31530                                  ;EVENWRT:
 31531                                  	;REP	MOVSW
 31532                                  
 31533                                  ;	CX = # of whole WORDs; CF=1 if odd # of bytes.
 31534                                  ;       DS:SI-> Source within Transfer memory block.
 31535                                  ;       ES:DI-> Destination within Buffer.
 31536                                  
 31537                                  	; MSDOS 6.0
 31538 0000570B F3A5                    	rep	movsw			;Copy Transfer memory to Buffer.
 31539                                  	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 31540                                  	;rep	movsb                   ;Copy last byte.
 31541                                  	; 16/12/2022
 31542 0000570D 7301                    	jnc	short EVENWRT ; **** 20/05/2019
 31543 0000570F A4                      	movsb ; ****
 31544                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 31545                                  	;adc	cx,0
 31546                                  	;rep	movsb
 31547                                  ;M039
 31548                                  EVENWRT: ; ****
 31549 00005710 07                              POP	ES
 31550                                  
 31551                                  ;hkn; SS override
 31552 00005711 36C51E[E205]                    LDS     BX,[SS:CURBUF]
 31553                                  
 31554                                  	; MSDOS 6.0
 31555 00005716 F6470540                        TEST	byte [BX+BUFFINFO.buf_flags],buf_dirty
 31556                                  					;LB. if already dirty		  ;AN000;
 31557 0000571A 7507                            JNZ	short yesdirty10	;LB.  don't increment dirty count ;AN000;
 31558 0000571C E84C0E                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 31559                                  	
 31560                                  	;or	byte [bx+5],40h
 31561 0000571F 804F0540                        OR	byte [BX+BUFFINFO.buf_flags],buf_dirty
 31562                                  yesdirty10:
 31563                                  	;;lea	si,[bx+16]
 31564                                  	;lea	si,[bx+20] ; MSDOS 6.0
 31565 00005723 8D7718                          LEA     SI,[BX+BUFINSIZ]
 31566 00005726 29F7                            SUB     DI,SI                   ; Position in buffer
 31567                                  ;M039
 31568                                  	; MSDOS 3.3
 31569                                  	;MOV	SI,DI
 31570                                  	;MOV	DI,BX
 31571                                  	;call	PLACEBUF
 31572                                  	;;cmp	si,[es:bp+2]
 31573                                  	;CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
 31574                                  	;JB	short WBUFPLACED	; No, leave buf where it is
 31575                                  	;call	PLACEHEAD               ; Make it prime candidate for chucking
 31576                                                                          ;  even though it is MRU.
 31577                                  	; MSDOS 6.0
 31578                                  	;cmp	di,[es:bp+2]
 31579 00005728 263B7E02                	CMP	di,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
 31580 0000572C 7205                            JB	short WBUFPLACED	; No, leave buf where it is
 31581 0000572E 36891E[6D00]                    MOV	[ss:BufferQueue],BX	; Make it prime candidate for
 31582                                  					; chucking even though it is MRU.
 31583                                  ;M039
 31584                                  
 31585                                  WBUFPLACED:
 31586 00005733 F8                              CLC
 31587 00005734 16                      	push	ss
 31588 00005735 1F                      	pop	ds
 31589 00005736 C3                              retn
 31590                                  
 31591                                  ;Break   <NEXTSEC -- Compute next sector to read or write>
 31592                                  ;---------------------------------------------------------------------------
 31593                                  ;
 31594                                  ; Procedure Name : NEXTSEC
 31595                                  ;
 31596                                  ; Compute the next sector to read or write
 31597                                  ; ES:BP Points to DPB
 31598                                  ;
 31599                                  ;---------------------------------------------------------------------------
 31600                                  
 31601                                  NEXTSEC:
 31602 00005737 F606[7405]FF            	test	byte [TRANS],0FFh ; -1 
 31603 0000573C 7426                            JZ	short CLRET
 31604                                  
 31605 0000573E A0[7305]                        MOV     AL,[SECCLUSPOS]
 31606 00005741 FEC0                            INC     AL
 31607                                  	;cmp	al,[es:bp+4]
 31608 00005743 263A4604                        CMP     AL,[ES:BP+DPB.CLUSTER_MASK]
 31609 00005747 7618                            JBE	short SAVPOS
 31610                                  
 31611 00005749 8B1E[BC05]                      MOV     BX,[CLUSNUM]
 31612 0000574D E8B607                          call	IsEOF
 31613 00005750 7314                            JAE	short NONEXT
 31614                                  
 31615 00005752 E8C807                          call	UNPACK
 31616 00005755 720F                            JC	short NONEXT
 31617                                  clusgot:
 31618 00005757 893E[BC05]                      MOV     [CLUSNUM],DI
 31619 0000575B FF06[BA05]                      INC     word [LASTPOS]
 31620 0000575F B000                            MOV     AL,0
 31621                                  SAVPOS:
 31622 00005761 A2[7305]                        MOV     [SECCLUSPOS],AL
 31623                                  CLRET:
 31624 00005764 F8                              CLC
 31625 00005765 C3                              retn
 31626                                  NONEXT:
 31627 00005766 F9                              STC
 31628 00005767 C3                              retn
 31629                                  
 31630                                  ;Break	<OPTIMIZE -- DO A USER DISK REQUEST WELL>
 31631                                  ;----------------------------------------------------------------------------
 31632                                  ;
 31633                                  ; Procedure Name : OPTIMIZE
 31634                                  ;
 31635                                  ; Inputs:
 31636                                  ;       BX = Physical cluster
 31637                                  ;       CX = No. of records
 31638                                  ;       DL = sector within cluster
 31639                                  ;       ES:BP = Base of drive parameters
 31640                                  ;       [NEXTADD] = transfer address
 31641                                  ; Outputs:
 31642                                  ;       AX = No. of records remaining
 31643                                  ;       BX = Transfer address
 31644                                  ;       CX = No. or records to be transferred
 31645                                  ;       DX = Physical sector address            (LOW)
 31646                                  ;       [HIGH_SECTOR] = Physical sector address (HIGH)
 31647                                  ;       DI = Next cluster
 31648                                  ;       [CLUSNUM] = Last cluster accessed
 31649                                  ;       [NEXTADD] updated
 31650                                  ;       Carry set if error (currently user FAILed to I 24)
 31651                                  ; ES:BP unchanged. Note that segment of transfer not set.
 31652                                  ;
 31653                                  ;---------------------------------------------------------------------------
 31654                                  
 31655                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31656                                  OPTIMIZE:
 31657 00005768 52                      	PUSH    DX
 31658 00005769 53                              PUSH    BX
 31659                                  	;mov	al,[es:bp+4]
 31660 0000576A 268A4604                        MOV     AL,[ES:BP+DPB.CLUSTER_MASK]
 31661 0000576E FEC0                            INC     AL              ; Number of sectors per cluster
 31662 00005770 88C4                            MOV     AH,AL
 31663 00005772 28D0                            SUB     AL,DL           ; AL = Number of sectors left in first cluster
 31664 00005774 89CA                            MOV     DX,CX
 31665                                  	;MOV	CX,0
 31666                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 31667                                  	; 16/12/2022
 31668 00005776 31C9                    	xor	cx,cx	; sub cx,cx
 31669                                  OPTCLUS:
 31670                                  ; AL has number of sectors available in current cluster
 31671                                  ; AH has number of sectors available in next cluster
 31672                                  ; BX has current physical cluster
 31673                                  ; CX has number of sequential sectors found so far
 31674                                  ; DX has number of sectors left to transfer
 31675                                  ; ES:BP Points to DPB
 31676                                  ; ES:SI has FAT pointer
 31677                                  
 31678                                  do_norm3:
 31679 00005778 E8A207                          call	UNPACK
 31680 0000577B 7236                            JC	short OP_ERR
 31681                                  clusgot2:
 31682 0000577D 00C1                    	ADD	CL,AL
 31683 0000577F 80D500                          ADC     CH,0
 31684 00005782 39D1                            CMP     CX,DX
 31685 00005784 7332                            JAE	short BLKDON
 31686 00005786 88E0                            MOV     AL,AH
 31687 00005788 43                              INC     BX
 31688 00005789 39DF                            CMP     DI,BX
 31689 0000578B 74EB                            JZ	short OPTCLUS
 31690 0000578D 4B                              DEC     BX
 31691                                  FINCLUS:
 31692 0000578E 891E[BC05]                      MOV     [CLUSNUM],BX    ; Last cluster accessed
 31693 00005792 29CA                            SUB     DX,CX           ; Number of sectors still needed
 31694 00005794 52                              PUSH    DX
 31695 00005795 89C8                            MOV     AX,CX
 31696                                  	;mul	word[ES:BP+2]
 31697 00005797 26F76602                        MUL	word [ES:BP+DPB.SECTOR_SIZE] 
 31698                                  				; Number of sectors times sector size
 31699 0000579B 8B36[B805]                      MOV     SI,[NEXTADD]
 31700 0000579F 01F0                            ADD     AX,SI           ; Adjust by size of transfer
 31701 000057A1 A3[B805]                        MOV     [NEXTADD],AX
 31702 000057A4 58                              POP     AX              ; Number of sectors still needed
 31703 000057A5 5A                              POP     DX              ; Starting cluster
 31704 000057A6 29D3                            SUB     BX,DX           ; Number of new clusters accessed
 31705 000057A8 011E[BA05]                      ADD     [LASTPOS],BX
 31706 000057AC 5B                              POP     BX              ; BL = sector position within cluster
 31707 000057AD E81600                  	call	FIGREC
 31708 000057B0 89F3                            MOV     BX,SI
 31709                                  	; 24/09/2023
 31710                                  	; cf=0 (at the return of FIGREC)
 31711                                  	;CLC
 31712 000057B2 C3                              retn
 31713                                  OP_ERR:
 31714 000057B3 83C404                          ADD     SP,4
 31715 000057B6 F9                      	STC
 31716 000057B7 C3                              retn
 31717                                  BLKDON:
 31718 000057B8 29D1                            SUB     CX,DX           ; Number of sectors in cluster we don't want
 31719 000057BA 28CC                            SUB     AH,CL           ; Number of sectors in cluster we accepted
 31720 000057BC FECC                            DEC     AH              ; Adjust to mean position within cluster
 31721 000057BE 8826[7305]                      MOV     [SECCLUSPOS],AH
 31722 000057C2 89D1                            MOV     CX,DX           ; Anyway, make the total equal to the request
 31723 000057C4 EBC8                            JMP     SHORT FINCLUS
 31724                                  
 31725                                  ;Break	<FIGREC -- Figure sector in allocation unit>
 31726                                  ;---------------------------------------------------------------------------
 31727                                  ;
 31728                                  ; Procedure Name : FIGREC
 31729                                  ;
 31730                                  ; Inputs:
 31731                                  ;       DX = Physical cluster number
 31732                                  ;       BL = Sector position within cluster
 31733                                  ;       ES:BP = Base of drive parameters
 31734                                  ; Outputs:
 31735                                  ;       DX = physical sector number           (LOW)
 31736                                  ;       [HIGH_SECTOR] Physical sector address (HIGH)
 31737                                  ; No other registers affected.
 31738                                  ;
 31739                                  ;---------------------------------------------------------------------------
 31740                                  
 31741                                  	; 10/06/2019
 31742                                  	; 20/05/2019 - Retro DOS v4.0
 31743                                  	; DOSCODE:8D96h (MSDOS 6.21, MSDOS.SYS)
 31744                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31745                                  	; DOSCODE:8D5Bh (MSDOS 5.0, MSDOS.SYS)	
 31746                                  FIGREC:
 31747 000057C6 51                              PUSH    CX
 31748                                  	;mov	cl,[es:bp+5]
 31749 000057C7 268A4E05                        MOV     CL,[ES:BP+DPB.CLUSTER_SHIFT]
 31750 000057CB 4A                              DEC     DX
 31751 000057CC 4A                              DEC     DX
 31752                                  
 31753                                  	; MSDOS 3.3
 31754                                  	;SHL	DX,CL
 31755                                  
 31756                                  ;hkn; SS override HIGH_SECTOR
 31757                                  	; MSDOS 6.0
 31758 000057CD 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0		;F.C. >32mb
 31759                                  	; 24/09/2023
 31760 000057D4 30ED                    	xor	ch,ch				;F.C. >32mb
 31761 000057D6 08C9                    	OR	CL,CL				;F.C. >32mb
 31762 000057D8 740C                    	JZ	short noshift			;F.C. >32mb
 31763 000057DA 30ED                    	XOR	CH,CH				;F.C. >32mb
 31764                                  rotleft:					;F.C. >32mb
 31765 000057DC F8                      	CLC					;F.C. >32mb
 31766 000057DD D1D2                    	RCL	DX,1				;F.C. >32mb
 31767                                  	; 10/06/2019
 31768 000057DF 36D116[0706]            	RCL	word [ss:HIGH_SECTOR],1		;F.C. >32mb
 31769 000057E4 E2F6                    	LOOP	rotleft				;F.C. >32mb
 31770                                  noshift:
 31771                                  	; MSDOS 3.3 & MSDOS 6.0
 31772 000057E6 08DA                            OR      DL,BL
 31773                                  	;add	dx,[es:bp+0Bh]
 31774 000057E8 2603560B                        ADD     DX,[ES:BP+DPB.FIRST_SECTOR]
 31775                                  	; MSDOS 6.0
 31776                                  	; 10/06/2019
 31777                                  	;ADC	word [ss:HIGH_SECTOR],0		;F.C. >32mb
 31778                                  	; 24/09/2023
 31779                                  	; cx=0
 31780 000057EC 36110E[0706]            	ADC	word [ss:HIGH_SECTOR],cx ; 0
 31781                                  
 31782                                  	; MSDOS 3.3 & MSDOS 6.0
 31783 000057F1 59                      	POP     CX
 31784                                  figrec_retn:
 31785 000057F2 C3                              retn
 31786                                  
 31787                                  ; 20/05/2019 - Retro DOS v4.0
 31788                                  ; DOSCODE:8DC2h (MSDOS 6.21, MSDOS.SYS)
 31789                                  
 31790                                  ; 30/07/2018 - Retro DOS v3.0
 31791                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 
 31792                                  
 31793                                  ;Break   <ALLOCATE -- Assign disk space>
 31794                                  ;---------------------------------------------------------------------------
 31795                                  ;
 31796                                  ; Procedure Name : ALLOCATE - Allocate Disk Space
 31797                                  ;
 31798                                  ;   ALLOCATE is called to allocate disk clusters. The new clusters are
 31799                                  ;   FAT-chained onto the end of the existing file.
 31800                                  ;
 31801                                  ;   The DPB contains the cluster # of the last free cluster allocated
 31802                                  ;   (dpb_next_free). We start at this cluster and scan towards higher
 31803                                  ;   numbered clusters, looking for the necessary free blocks.
 31804                                  ;
 31805                                  ;   Once again, fancy terminology gets in the way of correct coding. When
 31806                                  ;   using next_free, start scanning AT THAT POINT and not the one following it.
 31807                                  ;   This fixes the boundary condition bug when only free = next_free = 2.
 31808                                  ;
 31809                                  ;       If we get to the end of the disk without satisfaction:
 31810                                  ;
 31811                                  ;           if (dpb_next_free == 2) then we've scanned the whole disk.
 31812                                  ;               return (insufficient_disk_space)
 31813                                  ;           ELSE
 31814                                  ;               dpb_next_free = 2; start scan over from the beginning.
 31815                                  ;
 31816                                  ;   Note that there is no multitasking interlock. There is no race when
 31817                                  ;   examining the entrys in an in-core FAT block since there will be no
 31818                                  ;   context switch. When UNPACK context switches while waiting for a FAT read
 31819                                  ;   we are done with any in-core FAT blocks, so again there is no race. The
 31820                                  ;   only special concern is that V2 and V3 MSDOS left the last allocated
 31821                                  ;   cluster as "00"; marking it EOF only when the entire alloc request was
 31822                                  ;   satisfied. We can't allow another activation to think this cluster is
 31823                                  ;   free, so we give it a special temporary mark to show that it is, indeed,
 31824                                  ;   allocated.
 31825                                  ;
 31826                                  ;   Note that when we run out of space this algorithem will scan from
 31827                                  ;   dpb_next_free to the end, then scan from cluster 2 through the end,
 31828                                  ;   redundantly scanning the later part of the disk. This only happens when
 31829                                  ;   we run out of space, so sue me.
 31830                                  ;
 31831                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
 31832                                  ;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
 31833                                  ;                                                                          ;
 31834                                  ;   The use of FATBYT and RESTFATBYT is somewhat mysterious. Here is the
 31835                                  ;   explanation:
 31836                                  ;
 31837                                  ;   In the NUL file case (sf_firclus currently 0) ALLOCATE is called with
 31838                                  ;   entry BX = 0. What needs to be done in this case is to stuff the cluster
 31839                                  ;   number of the first cluster allocated in sf_firclus when the ALLOCATE is
 31840                                  ;   complete. THIS VALUE IS SAVED TEMPORARILY IN CLUSTER 0, HENCE THE CURRENT
 31841                                  ;   VALUE IN CLUSTER 0 MUST BE SAVED AND RESTORED. This is a side effect of
 31842                                  ;   the fact that PACK and UNPACK don't treat requests for clusters 0 and 1 as
 31843                                  ;   errors. This "stuff" is done by the call to PACK which is right before
 31844                                  ;   the
 31845                                  ;           LOOP   findfre         ; alloc more if needed
 31846                                  ;   instruction when the first cluster is allocated to the nul file. The
 31847                                  ;   value is recalled from cluster 0 and stored at sf_firclus at ads4:
 31848                                  ;
 31849                                  ;   This method is obviously useless (because it is non-reentrant) for
 31850                                  ;   multitasking, and will have to be changed. Storing the required value on
 31851                                  ;   the stack is recommended. Setting sf_firclus at the PACK of cluster 0
 31852                                  ;   (instead of actually doing the PACK) is BAD because it doesn't handle
 31853                                  ;   problems with INT 24 well.
 31854                                  ;
 31855                                  ;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
 31856                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
 31857                                  ;                                                                          ;
 31858                                  ;       ENTRY   BX = Last cluster of file (0 if null file)
 31859                                  ;               CX = No. of clusters to allocate
 31860                                  ;               ES:BP = Base of drive parameters
 31861                                  ;               [THISSFT] = Points to SFT
 31862                                  ;
 31863                                  ;       EXIT    'C' set if insufficient space
 31864                                  ;                 [FAILERR] can be tested to see the reason for failure
 31865                                  ;                 CX = max. no. of clusters that could be added to file
 31866                                  ;               'C' clear if space allocated
 31867                                  ;                 BX = First cluster allocated
 31868                                  ;                 FAT is fully updated
 31869                                  ;                 sf_FIRCLUS field of SFT set if file was null
 31870                                  ;
 31871                                  ;       USES    ALL but SI, BP
 31872                                  
 31873                                  ;callmagic  proc near
 31874                                  ;       push    ds                             ;push segment of routine 
 31875                                  ;       push    Offset MagicPatch              ;push offset for routine
 31876                                  ;       retf                                   ;simulate jmp far
 31877                                  ;                                              ;far return address is on
 31878                                  ;                                              ;stack, so far return from
 31879                                  ;                                              ;call will return this routine
 31880                                  ;callmagic  endp
 31881                                  
 31882                                  
 31883                                  ; 25/09/2023
 31884                                  %if 0
 31885                                  callmagic:
 31886                                  	push	ds
 31887                                  	push	MagicPatch
 31888                                  	retf	
 31889                                  %endif
 31890                                  
 31891                                  ALLOCATE:
 31892                                  	; 10/09/2018
 31893                                  ;BEGIN MAGICDRV MODIFICATIONS
 31894                                  ;
 31895                                  ;7/5/92 scottq
 31896                                  ;
 31897                                  ;This is the disk compression patch location which allows
 31898                                  ;the disk compression software to fail allocations if the
 31899                                  ;FAT would allows allocation, but the free space for compressed
 31900                                  ;data would not.
 31901                                  ;        
 31902                                  ;;;	call    far ptr MAGICPATCH
 31903                                  ;;; We cannot do a far call since we cannot have fix-ups[romdos,hidos],
 31904                                  ;;; but we do know the segment and offset of the routine
 31905                                  ;;; so simulate a far call to dosdata:magicpatch
 31906                                  ;;; note dosassume above, so DS -> dosdata
 31907                                  
 31908                                  	; MSDOS 6.0
 31909                                          ;clc				;clear carry so we fall through
 31910                                  	;				;if no patch is present
 31911                                  	;push	cs			;push segment for far return
 31912                                          ;call	callmagic		;this is a near call
 31913                                          ;jnc	short Regular_Allocate_Path
 31914                                  	;jmp	Disk_Full_Return
 31915                                  
 31916                                  ; 25/09/2023
 31917                                  %if 0
 31918                                  	clc
 31919                                  	push	cs
 31920                                  	call	callmagic
 31921                                  	jnc	short Regular_Allocate_Path
 31922                                  	jmp	Disk_Full_Return
 31923                                  Regular_Allocate_Path:
 31924                                  %endif
 31925                                  
 31926                                  	; 20/05/2019 - Retro DOS v4.0
 31927                                  ;END MAGICDRV MODIFICATIONS
 31928                                  
 31929                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31930                                  	; DOSCODE:8D87h (MSDOS 5.0, MSDOS.SYS)
 31931                                  
 31932 000057F3 53                              PUSH    BX                      ; save (bx)
 31933 000057F4 31DB                            XOR     BX,BX
 31934 000057F6 E82407                  	call	UNPACK
 31935 000057F9 893E[9605]                      MOV     [FATBYT],DI             ; save correct cluster 0 value
 31936 000057FD 5B                              POP     BX
 31937 000057FE 72F2                            jc	short figrec_retn	; abort if error   [INTERR?]
 31938                                  
 31939 00005800 51                              PUSH    CX
 31940 00005801 53                              PUSH    BX
 31941                                  
 31942 00005802 89DA                            MOV     DX,BX
 31943                                  	;;mov	bx,[es:bp+1Ch]  ; MSDOS 3.3
 31944                                  	;mov	bx,[es:bp+1Dh]	; MSDOS 6.0
 31945 00005804 268B5E1D                        mov     bx,[ES:BP+DPB.NEXT_FREE]
 31946 00005808 83FB02                          cmp     bx,2
 31947 0000580B 7709                            ja	short FINDFRE
 31948                                  
 31949                                  ;   couldn't find enough free space beyond dpb_next_free, or dpb_next_free is
 31950                                  ;   <2 or >dpb_max_clus. Reset it and restart the scan
 31951                                  
 31952                                  ads1:
 31953                                  	;;mov	word [es:bp+1Ch],2 ; MSDOS 3.3
 31954                                  	;mov	word [es:bp+1Dh],2 ; MSDOS 6.0
 31955 0000580D 26C7461D0200                    mov     word [ES:BP+DPB.NEXT_FREE],2
 31956 00005813 BB0100                          mov     bx,1                    ; Counter next instruction so first
 31957                                                                          ;       cluster examined is 2
 31958                                  
 31959                                  ;   Scanning both forwards and backwards for a free cluster
 31960                                  ;
 31961                                  ;       (BX) = forwards scan pointer
 31962                                  ;       (CX) = clusters remaining to be allocated
 31963                                  ;       (DX) = current last cluster in file
 31964                                  ;       (TOS) = last cluster of file
 31965                                  
 31966                                  FINDFRE:
 31967 00005816 43                              INC     BX
 31968                                  	;cmp	bx,[es:bp+0Dh]
 31969 00005817 263B5E0D                        CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 31970 0000581B 7757                    	ja	short ads7	; at end of disk
 31971 0000581D E8FD06                          call	UNPACK          ; check out this cluster
 31972 00005820 722F                            jc	short ads4	; FAT error             [INTERR?]
 31973 00005822 75F2                            jnz	short FINDFRE	; not free, keep on truckin
 31974                                  
 31975                                  ;   Have found a free cluster. Chain it to the file
 31976                                  ;
 31977                                  ;       (BX) = found free cluster #
 31978                                  ;       (DX) = current last cluster in file
 31979                                  
 31980                                  	;;mov	[es:bp+1Ch],bx
 31981                                  	;mov	[es:bp+1Dh],bx ; MSDOS 6.0
 31982 00005824 26895E1D                        mov	[ES:BP+DPB.NEXT_FREE],bx ; next time start search here
 31983 00005828 92                              xchg    ax,dx           ; save (dx) in ax
 31984 00005829 BA0100                          mov     dx,1            ; mark this free guy as "1"
 31985 0000582C E84207                  	call	PACK            ; set special "temporary" mark
 31986 0000582F 7220                            jc	short ads4	; FAT error             [INTERR?]
 31987                                  	;;cmp	word [es:bp+1Eh],-1
 31988                                          ;cmp	word [es:bp+1Fh],-1 ; MSDOS 6.0
 31989 00005831 26837E1FFF              	CMP	word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
 31990 00005836 7404                            JZ	short NO_ALLOC	; No
 31991                                  	;;dec	word [es:bp+1Eh]
 31992                                          ;dec	word [es:bp+1Fh] ; MSDOS 6.0
 31993 00005838 26FF4E1F                        DEC     word [ES:BP+DPB.FREE_CNT] ; Reduce free count by 1
 31994                                  NO_ALLOC:
 31995 0000583C 92                              xchg    ax,dx           ; (dx) = current last cluster in file
 31996 0000583D 87DA                            XCHG    BX,DX
 31997 0000583F 89D0                            MOV     AX,DX
 31998 00005841 E82D07                  	call	PACK            ; link free cluster onto file
 31999                                                                  ;  CAVEAT.. On Nul file, first pass stuffs
 32000                                                                  ;    cluster 0 with FIRCLUS value.
 32001 00005844 720B                            jc	short ads4	; FAT error [INTERR?]
 32002 00005846 93                              xchg    BX,AX           ; (BX) = last one we looked at
 32003 00005847 89DA                            mov     dx,bx           ; (dx) = current end of file
 32004 00005849 E2CB                            LOOP    FINDFRE         ; alloc more if needed
 32005                                  
 32006                                  ;   We've successfully extended the file. Clean up and exit
 32007                                  ;
 32008                                  ;       (BX) = last cluster in file
 32009                                  
 32010 0000584B BAFFFF                          MOV     DX,0FFFFH
 32011 0000584E E82007                  	call	PACK            ; mark last cluster EOF
 32012                                  
 32013                                  ;   Note that FAT errors jump here to clean the stack and exit. This saves us
 32014                                  ;   2 whole bytes. Hope its worth it...
 32015                                  ;
 32016                                  ;       'C' set if error
 32017                                  ;       calling (BX) and (CX) pushed on stack
 32018                                  
 32019                                  ads4:   
 32020 00005851 5B                      	POP     BX
 32021 00005852 59                              POP     CX              ; Don't need this stuff since we're successful
 32022 00005853 729D                            jc	short figrec_retn
 32023 00005855 E8C506                          call	UNPACK          ; Get first cluster allocated for return
 32024                                                                  ; CAVEAT... In nul file case, UNPACKs cluster 0.
 32025 00005858 7298                            jc	short figrec_retn
 32026 0000585A E83200                  	call	RESTFATBYT      ; Restore correct cluster 0 value
 32027 0000585D 7293                            jc	short figrec_retn
 32028 0000585F 87DF                            XCHG    BX,DI           ; (DI) = last cluster in file upon our entry
 32029 00005861 09FF                            OR      DI,DI           ; clear 'C'
 32030 00005863 758D                    	jnz	short figrec_retn ; we were extending an existing file
 32031                                  
 32032                                  ;   We were doing the first allocation for a new file. Update the SFT cluster
 32033                                  ;   info
 32034                                  dofastk:
 32035                                  	; 20/05/2019
 32036                                  	; MSDOS 6.0
 32037                                  	;push	dx ; * MSDOS 6.0
 32038                                  	;;mov	dl,[es:bp+0]
 32039                                  	;;MOV	DL,[ES:BP+DPB.DRIVE]	; get drive #
 32040                                  	;mov	dl,[es:bp]
 32041                                  
 32042                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 32043                                  	; DOSCODE:8DF9h (MSDOS 5.0, MSDOS.SYS)
 32044                                  	
 32045                                  	; 16/12/2022
 32046                                  	;push	dx ; *
 32047                                  	;mov	dl,[ES:BP+DPB.DRIVE] 
 32048                                  	; 15/12/2022
 32049                                  	;mov	dl,[es:bp]
 32050                                  	
 32051                                  	; MSDOS 3.3 & MSDOS 6.0
 32052 00005865 06                      	PUSH	ES
 32053 00005866 C43E[9E05]              	LES     DI,[THISSFT]
 32054                                  	;mov	[es:di+0Bh],bx
 32055 0000586A 26895D0B                	MOV     [ES:DI+SF_ENTRY.sf_firclus],BX
 32056                                  	;;mov	[es:di+1Bh],bx ; MSDOS 3.3
 32057                                  	;mov	[es:di+35h],bx ; MSDOS 6.0
 32058 0000586E 26895D35                	MOV     [ES:DI+SF_ENTRY.sf_lstclus],BX
 32059 00005872 07                      	POP	ES
 32060                                  	;retn
 32061                                  
 32062                                  	;pop	dx ; * MSDOS 6.0
 32063                                  
 32064                                  	; 16/12/2022
 32065                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 32066                                  	;pop	dx ; *
 32067                                  
 32068 00005873 C3                      	retn	
 32069                                  
 32070                                  ;** we're at the end of the disk, and not satisfied. See if we've scanned ALL
 32071                                  ;   of the disk...
 32072                                  
 32073                                  ads7:   
 32074 00005874 26837E1D02              	cmp	word [ES:BP+DPB.NEXT_FREE],2
 32075 00005879 7592                    	jnz	short ads1	; start scan from front of disk
 32076                                  
 32077                                  ;   Sorry, we've gone over the whole disk, with insufficient luck. Lets give
 32078                                  ;   the space back to the free list and tell the caller how much he could have
 32079                                  ;   had.  We have to make sure we remove the "special mark" we put on the last
 32080                                  ;   cluster we were able to allocate, so it doesn't become orphaned.
 32081                                  ;
 32082                                  ;       (CX) = clusters remaining to be allocated
 32083                                  ;       (TOS) = last cluster of file (before call to ALLOCATE)
 32084                                  ;       (TOS+1) = # of clusters wanted to allocate
 32085                                  
 32086 0000587B 5B                              POP     BX              ; (BX) = last cluster of file
 32087 0000587C BAFFFF                          MOV     DX,0FFFFH
 32088 0000587F E81F00                  	call	RELBLKS         ; give back any clusters just alloced
 32089 00005882 58                              POP     AX              ; No. of clusters requested
 32090                                                                  ; Don't "retc". We are setting Carry anyway,
 32091                                                                  ;   Alloc failed, so proceed with return CX
 32092                                                                  ;   setup.
 32093 00005883 29C8                            SUB     AX,CX           ; AX=No. of clusters allocated
 32094 00005885 E80700                  	call	RESTFATBYT      ; Don't "retc". We are setting Carry anyway,
 32095                                                                  ;   Alloc failed.
 32096                                  Disk_Full_Return:               ;label added for magic patch 8-6-92 scottq
 32097                                          ; MSDOS 6.0
 32098 00005888 C606[0B06]01            	MOV	byte [DISK_FULL],1 ;MS. indicating disk full
 32099 0000588D F9                              STC
 32100 0000588E C3                              retn
 32101                                  
 32102                                  ;-----------------------------------------------------------------------
 32103                                  ;
 32104                                  ; Procedure Name : RESTFATBYT
 32105                                  ;
 32106                                  ; SEE ALLOCATE CAVEAT
 32107                                  ;       Carry set if error (currently user FAILed to I 24)
 32108                                  ;-----------------------------------------------------------------------
 32109                                  
 32110                                  RESTFATBYT:
 32111 0000588F 53                              PUSH    BX
 32112 00005890 52                              PUSH    DX
 32113 00005891 57                              PUSH    DI
 32114 00005892 31DB                            XOR     BX,BX
 32115 00005894 8B16[9605]                      MOV     DX,[FATBYT]
 32116 00005898 E8D606                  	call	PACK
 32117 0000589B 5F                              POP     DI
 32118 0000589C 5A                              POP     DX
 32119 0000589D 5B                              POP     BX
 32120                                  ; 16/12/2022
 32121                                  ; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 32122                                  ;RELEASE_flush:
 32123 0000589E C3                      	retn
 32124                                  
 32125                                  ;Break	<RELEASE -- DEASSIGN DISK SPACE>
 32126                                  ;---------------------------------------------------------------------------
 32127                                  ;
 32128                                  ; Procedure Name : RELEASE
 32129                                  ;
 32130                                  ; Inputs:
 32131                                  ;       BX = Cluster in file
 32132                                  ;       ES:BP = Base of drive parameters
 32133                                  ; Function:
 32134                                  ;       Frees cluster chain starting with [BX]
 32135                                  ;       Carry set if error (currently user FAILed to I 24)
 32136                                  ; AX,BX,DX,DI all destroyed. Other registers unchanged.
 32137                                  ;
 32138                                  ;-----------------------------------------------------------------------------
 32139                                  
 32140                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32141                                  	; 20/05/2019 - Retro DOS v4.0
 32142                                  RELEASE:
 32143 0000589F 31D2                            XOR     DX,DX
 32144                                  
 32145                                  	;entry	RELBLKS
 32146                                  RELBLKS:
 32147                                  
 32148                                  ;   Enter here with DX=0FFFFH to put an end-of-file mark in the first cluster
 32149                                  ;   and free the rest in the chain.
 32150                                  
 32151 000058A1 E87906                  	call	UNPACK
 32152 000058A4 7224                    	jc	short RELEASE_flush
 32153 000058A6 7422                    	jz	short RELEASE_flush
 32154 000058A8 89F8                            MOV     AX,DI
 32155 000058AA 52                              PUSH    DX
 32156 000058AB E8C306                  	call	PACK
 32157 000058AE 5A                              POP     DX
 32158 000058AF 7219                    	jc	short RELEASE_flush
 32159 000058B1 09D2                            OR      DX,DX
 32160 000058B3 750B                            JNZ	short NO_DEALLOC	; Was putting EOF mark
 32161                                  	;;cmp	word [es:bp+1Eh],-1 ; MSDOS 3.3
 32162                                  	;cmp	word [es:bp+1Fh],-1 ; MSDOS 6.0
 32163 000058B5 26837E1FFF              	CMP     word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
 32164 000058BA 7404                            JZ	short NO_DEALLOC	; No
 32165 000058BC 26FF461F                        INC	word [ES:BP+DPB.FREE_CNT] ; Increase free count by 1
 32166                                  NO_DEALLOC:
 32167 000058C0 89C3                            MOV     BX,AX
 32168 000058C2 48                              dec     ax              ; check for "1"
 32169 000058C3 7405                    	jz	short RELEASE_flush	; is last cluster of incomplete chain
 32170 000058C5 E83E06                  	call	IsEOF
 32171 000058C8 72D5                            JB	short RELEASE	; Carry clear if JMP not taken
 32172                                  
 32173                                  	; 16/12/2022
 32174                                  ; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 32175                                  ;%if 0
 32176                                  RELEASE_flush:
 32177                                  	; MSDOS 6.0
 32178 000058CA 268A4600                	mov	al,[es:bp]
 32179                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 32180 000058CE 56                      	push	si		; FLUSHBUF may trash these and we guarantee
 32181 000058CF 51                      	push	cx		;  them to be preserved.
 32182 000058D0 06                      	push	es
 32183 000058D1 55                      	push	bp
 32184 000058D2 E8850B                  	call	FLUSHBUF	; commit buffers for this drive
 32185 000058D5 5D                      	pop	bp
 32186 000058D6 07                      	pop	es
 32187 000058D7 59                      	pop	cx
 32188 000058D8 5E                      	pop	si
 32189                                  ;%endif
 32190                                  RET12:
 32191 000058D9 C3                      	retn
 32192                                  
 32193                                  ;Break	<GETEOF -- Find the end of a file>
 32194                                  ;------------------------------------------------------------------------
 32195                                  ;
 32196                                  ; Procedure Name : GETEOF
 32197                                  ;
 32198                                  ; Inputs:
 32199                                  ;       ES:BP Points to DPB
 32200                                  ;       BX = Cluster in a file
 32201                                  ;       DS = CS
 32202                                  ; Outputs:
 32203                                  ;       BX = Last cluster in the file
 32204                                  ;       Carry set if error (currently user FAILed to I 24)
 32205                                  ; DI destroyed. No other registers affected.
 32206                                  ;
 32207                                  ;--------------------------------------------------------------------------
 32208                                  
 32209                                  GETEOF:
 32210 000058DA E84006                  	call	UNPACK
 32211 000058DD 72FA                            jc	short RET12
 32212 000058DF 53                              PUSH    BX
 32213 000058E0 89FB                            MOV     BX,DI
 32214 000058E2 E82106                  	call	IsEOF
 32215 000058E5 5B                              POP     BX
 32216 000058E6 73F1                            JAE     short RET12
 32217 000058E8 89FB                            MOV     BX,DI
 32218 000058EA EBEE                            JMP     short GETEOF
 32219                                  
 32220                                  ;============================================================================
 32221                                  ; FCB.ASM, MSDOS 6.0, 1991
 32222                                  ;============================================================================
 32223                                  ; 30/07/2018 - Retro DOS v3.0
 32224                                  ; 20/05/2019 - Retro DOS v4.0
 32225                                  
 32226                                  ;	TITLE	FCB - FCB parse calls for MSDOS
 32227                                  ;	NAME	FCB
 32228                                  
 32229                                  ;**	FCB.ASM - Low level routines for parsing names into FCBs and analyzing
 32230                                  ;		  filename characters
 32231                                  ;
 32232                                  ;	MakeFcb
 32233                                  ;	NameTrans
 32234                                  ;	PATHCHRCMP
 32235                                  ;	GetLet
 32236                                  ;	UCase
 32237                                  ;	GetLet3
 32238                                  ;	GetCharType
 32239                                  ;	TESTKANJ
 32240                                  ;	NORMSCAN
 32241                                  ;	DELIM
 32242                                  ;
 32243                                  ;	Revision history:
 32244                                  ;
 32245                                  ;		A000  version 4.00  Jan. 1988
 32246                                  ;	
 32247                                  ;	M048 - access FILE_UCASE_TAB using DS rather than SS.
 32248                                  
 32249                                  TableLook	EQU	-1
 32250                                  
 32251                                  SCANSEPARATOR	EQU	1
 32252                                  DRVBIT		EQU	2
 32253                                  NAMBIT		EQU	4
 32254                                  EXTBIT		EQU	8
 32255                                  
 32256                                  ;----------------------------------------------------------------------------
 32257                                  ;
 32258                                  ; Procedure : MakeFcb
 32259                                  ;
 32260                                  ;----------------------------------------------------------------------------
 32261                                  
 32262                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32263                                  	; DOSCODE:8E77h (MSDOS 5.0, MSDOS.SYS)
 32264                                  MAKEFCB:
 32265                                  ;hkn; SS override
 32266 000058EC 36C606[4E03]00          	MOV	BYTE [SS:SpaceFlag],0
 32267 000058F2 30D2                    	XOR	DL,DL		; Flag--not ambiguous file name
 32268                                  	;test	al,2
 32269 000058F4 A802                    	test	AL,DRVBIT	; Use current drive field if default?
 32270 000058F6 7504                    	JNZ	short DEFDRV
 32271 000058F8 26C60500                	MOV	BYTE [ES:DI],0	; No - use default drive
 32272                                  DEFDRV:
 32273 000058FC 47                      	INC	DI
 32274 000058FD B90800                  	MOV	CX,8
 32275                                  	;test	al,4
 32276 00005900 A804                    	test	AL,NAMBIT	; Use current name fields as default?
 32277 00005902 93                      	XCHG	AX,BX		; Save bits in BX
 32278 00005903 B020                    	MOV	AL," "
 32279 00005905 7404                    	JZ	short FILLB	; If not, go fill with blanks
 32280 00005907 01CF                    	ADD	DI,CX
 32281 00005909 31C9                    	XOR	CX,CX		; Don't fill any
 32282                                  FILLB:
 32283 0000590B F3AA                    	REP	STOSB
 32284 0000590D B103                    	MOV	CL,3
 32285 0000590F F6C308                  	test	BL,EXTBIT	; Use current extension as default
 32286 00005912 7404                    	JZ	short FILLB2
 32287 00005914 01CF                    	ADD	DI,CX
 32288 00005916 31C9                    	XOR	CX,CX
 32289                                  FILLB2:
 32290 00005918 F3AA                    	REP	STOSB
 32291 0000591A 91                      	XCHG	AX,CX		; Put zero in AX
 32292 0000591B AB                      	STOSW
 32293 0000591C AB                      	STOSW			; Initialize two words after to zero
 32294 0000591D 83EF10                  	SUB	DI,16		; Point back at start
 32295                                  	;test	bl,1
 32296 00005920 F6C301                  	test	BL,SCANSEPARATOR; Scan off separators if not zero
 32297 00005923 7409                    	JZ	short SKPSPC
 32298 00005925 E88800                  	CALL	SCANB		; Peel off blanks and tabs
 32299 00005928 E82201                  	CALL	DELIM		; Is it a one-time-only delimiter?
 32300 0000592B 7504                    	JNZ	short NOSCAN
 32301 0000592D 46                      	INC	SI		; Skip over the delimiter
 32302                                  SKPSPC:
 32303 0000592E E87F00                  	CALL	SCANB		; Always kill preceding blanks and tabs
 32304                                  NOSCAN:
 32305 00005931 E8F000                  	CALL	GETLET
 32306 00005934 761E                    	JBE	short NODRV	; Quit if termination character
 32307 00005936 803C3A                  	CMP	BYTE [SI],":"	; Check for potential drive specifier
 32308 00005939 7519                    	JNZ	short NODRV
 32309 0000593B 46                      	INC	SI		; Skip over colon
 32310 0000593C 2C40                    	SUB	AL,"@"          ; Convert drive letter to drive number (A=1)
 32311 0000593E 760F                    	JBE	short BADDRV	; Drive letter out of range
 32312                                  
 32313 00005940 50                      	PUSH	AX
 32314 00005941 E8501B                  	call	GetVisDrv
 32315 00005944 58                      	POP	AX
 32316 00005945 730A                    	JNC	short HAVDRV
 32317                                  
 32318                                  	; 20/05/2019 - Retro DOS v4.0
 32319                                  	; MSDOS 6.0
 32320                                  ;hkn; SS override
 32321 00005947 36803E[1006]1A          	CMP	byte [SS:DrvErr],error_not_DOS_disk ; 1Ah
 32322                                  					; if not FAT drive ;AN000;
 32323 0000594D 7402                    	JZ	short HAVDRV		; assume ok	   ;AN000;
 32324                                  BADDRV:
 32325 0000594F B2FF                    	MOV	DL,-1
 32326                                  HAVDRV:
 32327 00005951 AA                      	STOSB			; Put drive specifier in first byte
 32328 00005952 46                      	INC	SI
 32329 00005953 4F                      	DEC	DI		; Counteract next two instructions
 32330                                  NODRV:
 32331 00005954 4E                      	DEC	SI		; Back up
 32332 00005955 47                      	INC	DI		; Skip drive byte
 32333                                  
 32334                                  	;entry	NORMSCAN
 32335                                  NORMSCAN:
 32336 00005956 B90800                  	MOV	CX,8
 32337 00005959 E82200                  	CALL	GETWORD 	; Get 8-letter file name
 32338 0000595C 803C2E                  	CMP	BYTE [SI],"."
 32339 0000595F 7510                    	JNZ	short NODOT
 32340 00005961 46                      	INC	SI		; Skip over dot if present
 32341                                  
 32342                                  	; 24/09/2023
 32343                                  	;mov	cx,3
 32344 00005962 B103                    	mov	cl,3	; ch=0
 32345                                  
 32346                                  	; MSDOS 6.0
 32347                                  ;hkn; SS override
 32348                                  	;TEST	word [SS:DOS34_FLAG],DBCS_VOLID2 ; 100h ;AN000;
 32349                                  	; 10/06/2019
 32350 00005964 36F606[1206]01          	test	byte [SS:DOS34_FLAG+1],(DBCS_VOLID2>>8) ; 1
 32351 0000596A 7402                    	JZ	short VOLOK				;AN000;
 32352 0000596C A4                      	MOVSB			; 2nd byte of DBCS	;AN000;
 32353                                  	; 24/09/2023
 32354                                  	;MOV	CX,2					;AN000;
 32355 0000596D 49                      	dec	cx  ; cx=2
 32356                                  	;JMP	SHORT contvol				;AN000;
 32357                                  VOLOK:
 32358                                  	;MOV	CX,3		; Get 3-letter extension
 32359                                  contvol:
 32360 0000596E E81300                  	CALL	MUSTGETWORD
 32361                                  NODOT:
 32362 00005971 88D0                    	MOV	AL,DL
 32363                                  
 32364                                  	; MSDOS 6.0
 32365                                  	;and	word [ss:DOS34_FLAG],0FEFFh
 32366                                  	; 18/12/2022
 32367 00005973 368026[1206]FE          	and	byte [ss:DOS34_FLAG+1],0FEh ; (~DBCS_VOLID2)>>8
 32368                                  	;and	word [ss:DOS34_FLAG],~DBCS_VOLID2 ; ### BUG FIX ###
 32369                                  
 32370 00005979 C3                      	retn
 32371                                  
 32372                                  NONAM:
 32373 0000597A 01CF                    	ADD	DI,CX
 32374 0000597C 4E                      	DEC	SI
 32375 0000597D C3                      	retn
 32376                                  
 32377                                  GETWORD:
 32378 0000597E E8A300                  	CALL	GETLET		
 32379 00005981 76F7                    	JBE	short NONAM	; Exit if invalid character
 32380 00005983 4E                      	DEC	SI
 32381                                  
 32382                                  ;	UGH!!! Horrible bug here that should be fixed at some point:
 32383                                  ;	If the name we are scanning is longer than CX, we keep on reading!
 32384                                  
 32385                                  MUSTGETWORD:
 32386 00005984 E89D00                  	CALL	GETLET
 32387                                  
 32388                                  ;	If spaceFlag is set then we allow spaces in a pathname
 32389                                  
 32390                                  ;IF NOT TABLELOOK
 32391                                  ;	JB	short FILLNAM  ; MSDOS 3.3
 32392                                  ;ENDIF
 32393 00005987 750C                    	JNZ	short MustCheckCX
 32394                                  
 32395                                  ;hkn; SS override
 32396 00005989 36F606[4E03]FF          	test	BYTE [SS:SpaceFlag],0FFh
 32397 0000598F 7419                    	JZ	short FILLNAM
 32398 00005991 3C20                    	CMP	AL," "
 32399 00005993 7515                    	JNZ	short FILLNAM
 32400                                  
 32401                                  MustCheckCX:
 32402 00005995 E3ED                    	JCXZ	MUSTGETWORD
 32403 00005997 49                      	DEC	CX
 32404 00005998 3C2A                    	CMP	AL,"*"          ; Check for ambiguous file specifier
 32405 0000599A 7504                    	JNZ	short NOSTAR
 32406 0000599C B03F                    	MOV	AL,"?"
 32407 0000599E F3AA                    	REP	STOSB
 32408                                  NOSTAR:
 32409 000059A0 AA                      	STOSB
 32410 000059A1 3C3F                    	CMP	AL,"?"
 32411 000059A3 75DF                    	JNZ	short MUSTGETWORD
 32412 000059A5 80CA01                  	OR	DL,1		; Flag ambiguous file name
 32413 000059A8 EBDA                    	JMP	short MUSTGETWORD
 32414                                  FILLNAM:
 32415 000059AA B020                    	MOV	AL," "
 32416 000059AC F3AA                    	REP	STOSB
 32417 000059AE 4E                      	DEC	SI
 32418 000059AF C3                      	retn
 32419                                  
 32420                                  SCANB:
 32421 000059B0 AC                      	LODSB
 32422 000059B1 E8A100                  	CALL	SPCHK
 32423 000059B4 74FA                    	JZ	short SCANB
 32424 000059B6 4E                      	DEC	SI
 32425                                  scanb_retn:
 32426 000059B7 C3                      	retn
 32427                                  
 32428                                  ;----------------------------------------------------------------------------
 32429                                  ;
 32430                                  ; Procedure Name : NameTrans
 32431                                  ;
 32432                                  ; NameTrans is used by FindPath to scan off an element of a path. We must
 32433                                  ; allow spaces in pathnames
 32434                                  ;
 32435                                  ;   Inputs:	DS:SI points to start of path element
 32436                                  ;   Outputs:	Name1 has unpacked name, uppercased
 32437                                  ;		ES = DOSGroup
 32438                                  ;		DS:SI advanced after name
 32439                                  ;   Registers modified: DI,AX,DX,CX
 32440                                  ;
 32441                                  ;----------------------------------------------------------------------------
 32442                                  
 32443                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32444                                  	; 20/05/2019 - Retro DOS v4.0
 32445                                  NameTrans:
 32446                                  ;hkn; SS override
 32447 000059B8 36C606[4E03]01          	MOV	BYTE [SS:SpaceFlag],1
 32448 000059BE 16                      	push	ss
 32449 000059BF 07                      	pop	es
 32450                                  
 32451                                  ;hkn; NAME1 is in DOSDATA
 32452 000059C0 BF[4B05]                	MOV	DI,NAME1
 32453 000059C3 57                      	PUSH	DI
 32454 000059C4 B82020                  	MOV	AX,'  '
 32455 000059C7 B90500                  	MOV	CX,5
 32456 000059CA AA                      	STOSB
 32457 000059CB F3AB                    	REP	STOSW		; Fill "FCB" at NAME1 with spaces
 32458 000059CD 30C0                    	XOR	AL,AL		; Set stuff for NORMSCAN
 32459 000059CF 88C2                    	MOV	DL,AL
 32460 000059D1 AA                      	STOSB
 32461 000059D2 5F                      	POP	DI
 32462                                  
 32463 000059D3 E880FF                  	CALL	NORMSCAN
 32464                                  
 32465                                  ;hkn; SS override for NAME1
 32466 000059D6 36803E[4B05]E5          	CMP	byte [SS:NAME1],0E5H
 32467 000059DC 75D9                    	jnz	short scanb_retn
 32468 000059DE 36C606[4B05]05          	MOV	byte [SS:NAME1],5 ; Magic name translation
 32469 000059E4 C3                      	retn
 32470                                  
 32471                                  ;Break	<GETLET, DELIM -- CHECK CHARACTERS AND CONVERT>
 32472                                  ;============================================================================
 32473                                  
 32474                                  ; 20/05/2019 - Retro DOS v4.0
 32475                                  ; DOSCODE:8FD2h (MSDOS 6.21, MSDOS.SYS)
 32476                                  
 32477                                  ;If TableLook
 32478                                  
 32479                                  ;hkn; Table	SEGMENT
 32480                                  ;	PUBLIC	CharType
 32481                                  ;----------------------------------------------------------------------------
 32482                                  
 32483                                  ; Character type table for file name scanning
 32484                                  ; Table provides a mapping of characters to validity bits.
 32485                                  ; Four bits are provided for each character. Values 7Dh and above
 32486                                  ; have all bits set, so that part of the table is chopped off, and
 32487                                  ; the translation routine is responsible for screening these values.
 32488                                  ; The bit values are defined in DOSSYM.INC
 32489                                  
 32490                                  ;	      ; ^A and NUL
 32491                                  ;CharType:
 32492                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32493                                  ;	      ; ^C and ^B
 32494                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32495                                  ;	      ; ^E and ^D
 32496                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32497                                  ;	      ; ^G and ^F
 32498                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32499                                  ;	      ; TAB and BS
 32500                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM+FSPCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32501                                  ;	      ; ^K and ^J
 32502                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32503                                  ;	      ; ^M and ^L
 32504                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32505                                  ;	      ; ^O and ^N
 32506                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32507                                  ;	      ; ^Q and ^P
 32508                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32509                                  ;	      ; ^S and ^R
 32510                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32511                                  ;	      ; ^U and ^T
 32512                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32513                                  ;	      ; ^W and ^V
 32514                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32515                                  ;	      ; ^Y and ^X
 32516                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32517                                  ;	      ; ESC and ^Z
 32518                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32519                                  ;	      ; ^] and ^;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32521                                  ;	      ; ^_ and ^^
 32522                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32523                                  ;	      ; ! and SPACE
 32524                                  ;	 db   LOW (NOT FCHK+FDELIM+FSPCHK)
 32525                                  ;	      ; # and "
 32526                                  ;	 db   LOW (NOT FFCB+FCHK)
 32527                                  ;	      ; $ - )
 32528                                  ;	 db   3 dup (0FFh)
 32529                                  ;	      ; + and *
 32530                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR 0Fh
 32531                                  ;	      ; - and '
 32532                                  ;	 db   NOT (FFCB+FCHK+FDELIM)
 32533                                  ;	      ; / and .
 32534                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FCHK) AND 0Fh
 32535                                  ;	      ; 0 - 9
 32536                                  ;	 db   5 dup (0FFh)
 32537                                  ;	      ; ; and :
 32538                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
 32539                                  ;	      ; = and <
 32540                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
 32541                                  ;	      ; ? and >
 32542                                  ;	 db   NOT FFCB+FCHK+FDELIM
 32543                                  ;	      ; A - Z
 32544                                  ;	 db   13 dup (0FFh)
 32545                                  ;	      ; \ and [
 32546                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR 0Fh
 32547                                  ;	      ; ^ and ]
 32548                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 32549                                  ;	      ; _ - {
 32550                                  ;	 db   15 dup (0FFh)
 32551                                  ;	      ; } and |
 32552                                  ;	 db   NOT FFCB+FCHK+FDELIM
 32553                                  
 32554                                  ;CharType_last equ ($ - CharType) * 2	; This is the value of the last
 32555                                  ;					; character in the table
 32556                                  
 32557                                  ;FCHK	equ 1		; normal name char, no chks needed
 32558                                  ;FDELIM	equ 2		; is a delimiter
 32559                                  ;FSPCHK	equ 4		; set if character is not a space or equivalent
 32560                                  ;FFCB	equ 8		; is valid in an FCB
 32561                                  
 32562                                  ; DOSCODE:8FD2h (MSDOS 6.21, MSDOS.SYS)
 32563                                  ;----------------------------------------------------------------------------
 32564                                  ; DOSCODE:8F76h (MSDOS 5.0, MSDOS.SYS)
 32565                                  
 32566                                  CharType: ; 63 bytes
 32567 000059E5 6666666606666666                db  66h, 66h, 66h, 66h, 06h, 66h, 66h, 66h ; 0-7
 32568 000059ED 6666666666666666        	db  66h, 66h, 66h, 66h, 66h, 66h, 66h, 66h ; 8-15
 32569 000059F5 F8F6FFFFFF4FF46E        	db 0F8h,0F6h,0FFh,0FFh,0FFh, 4Fh,0F4h, 6Eh ; 16-23
 32570 000059FD FFFFFFFFFF4444F4        	db 0FFh,0FFh,0FFh,0FFh,0FFh, 44h, 44h,0F4h ; 24-31
 32571 00005A05 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh ; 32-39
 32572 00005A0D FFFFFFFFFF6F66FF        	db 0FFh,0FFh,0FFh,0FFh,0FFh, 6Fh, 66h,0FFh ; 40-47
 32573 00005A15 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh ; 48-55
 32574 00005A1D FFFFFFFFFFFFF4          	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0F4h	   ; 56-62
 32575                                  
 32576                                  CharType_last equ ($ - CharType) * 2
 32577                                  
 32578                                  ; Offset 12CAh of IBMDOS.COM (MSDOS 3.3), 1987
 32579                                  ;----------------------------------------------------------------------------
 32580                                  ;CharType:
 32581                                  ;       db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 32582                                  ;	db 0F6h,0F0h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 32583                                  ;	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 32584                                  ;	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 32585                                  ;	db 0F8h,0FFh,0F6h,0FFh,0FFh,0FFh,0FFh,0FFh
 32586                                  ;	db 0FFh,0FFh,0FFh,0F4h,0F4h,0FFh,0FEh,0F6h
 32587                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32588                                  ;	db 0FFh,0FFh,0F4h,0F4h,0F4h,0F4h,0F4h,0FFh
 32589                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32590                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32591                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32592                                  ;	db 0FFh,0FFh,0FFh,0F6h,0F6h,0F6h,0FFh,0FFh
 32593                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32594                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32595                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32596                                  ;	db 0FFh,0FFh,0FFh,0FFh,0F4h,0FFh,0FFh,0FFh
 32597                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32598                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32599                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32600                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32601                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32602                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32603                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32604                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32605                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32606                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32607                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32608                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32609                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32610                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32611                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32612                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 32613                                  
 32614                                  ;hkn; Table	ENDS
 32615                                  
 32616                                  ;ENDIF
 32617                                  
 32618                                  ; 20/05/2019 - Retro DOS v4.0
 32619                                  ; DOSCODE:9011h (MSDOS 6.21, MSDOS.SYS)
 32620                                  
 32621                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32622                                  ; DOSCODE:8FB5h (MSDOS 5.0, MSDOS.SYS)
 32623                                  
 32624                                  ;----------------------------------------------------------------------------
 32625                                  ;
 32626                                  ; Procedure Names : GetLet, UCase, GetLet3
 32627                                  ;
 32628                                  ; These routines take a character, convert it to upper case, and check
 32629                                  ; for delimiters.  Three different entry points:
 32630                                  ;	GetLet -  DS:[SI] = character to convert
 32631                                  ;	UCase  -  AL = character to convert
 32632                                  ;	GetLet3 - AL = character
 32633                                  ;		  [BX] = translation table to use
 32634                                  ;
 32635                                  ;	Exit (in all cases) : AL = upper case character
 32636                                  ;			      CY set if char is control char other than TAB
 32637                                  ;			      ZF set if char is a delimiter
 32638                                  ;	Uses : AX, flags
 32639                                  ;
 32640                                  ; NOTE: This routine exists in a fast table lookup version, and a slow
 32641                                  ; inline version.  Return with carry set is only possible in the inline
 32642                                  ; version. The table lookup version is the one in use.
 32643                                  ;
 32644                                  ;----------------------------------------------------------------------------
 32645                                  
 32646                                  ; This entry point has character at [SI]
 32647                                  
 32648                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5517h
 32649                                  GETLET:	
 32650 00005A24 AC                      	LODSB
 32651                                  
 32652                                  ; This entry point has character in AL
 32653                                  
 32654                                  	;entry	UCase
 32655                                  UCase:	
 32656                                  	; 09/08/2018
 32657                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5518h
 32658                                  _UCase:
 32659 00005A25 53                      	PUSH	BX
 32660 00005A26 BB[850B]                	MOV	BX,FILE_UCASE_TAB+2
 32661                                  
 32662                                  ; Convert the character in AL to upper case
 32663                                  
 32664                                  gl_0:
 32665 00005A29 3C61                    	CMP	AL,"a"
 32666 00005A2B 7214                    	JB	short gl_2	; Already upper case, go check type
 32667 00005A2D 3C7A                    	CMP	AL,"z"
 32668 00005A2F 7702                    	JA	short gl_1
 32669 00005A31 2C20                    	SUB	AL,20H		; Convert to upper case
 32670                                  
 32671                                  ; Map European character to upper case
 32672                                  
 32673                                  gl_1:
 32674 00005A33 3C80                    	CMP	AL,80H
 32675 00005A35 720A                    	JB	short gl_2	; Not EuroChar, go check type
 32676 00005A37 2C80                    	SUB	AL,80H		; translate to upper case with this index
 32677                                  
 32678                                  	; M048 - Start 
 32679                                  	; Lantastic call Ucase thru int 2f without setting SS to DOSDATA.
 32680                                  	; So we shall set up DS and to access FILE_UCASE_TAB in BX and also 
 32681                                  	; preserve it.
 32682                                  
 32683                                  	; 09/08/2018 - Retro DOS v3.0
 32684                                  	; MSDOS 3.3
 32685                                  	;;XLAT	BYTE [CS:BX]	; ds as file_ucase_tab is in DOSDATA
 32686                                  	;CS	XLAT
 32687                                  
 32688                                  	; 20/05/2019 - Retro DOS v4.0
 32689                                  
 32690                                  	; MSDOS 6.0
 32691 00005A39 1E                      	push	ds
 32692                                  	;getdseg <ds>
 32693 00005A3A 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 32694 00005A3F D7                      	XLAT			; ds as file_ucase_tab is in DOSDATA
 32695 00005A40 1F                      	pop	ds
 32696                                  
 32697                                  	; M048 - End
 32698                                  
 32699                                  ; Now check the type
 32700                                  
 32701                                  ;If TableLook
 32702                                  gl_2:
 32703                                  	; 20/05/2019 - Retro DOS v4.0
 32704 00005A41 50                      	PUSH	AX
 32705                                  
 32706                                  	; MSDOS 3.3
 32707                                  	;mov	bx,CharType
 32708                                  	;; 09/08/2018
 32709                                  	;;xlat	byte [cs:bx]
 32710                                  	;cs	xlat	
 32711                                  	
 32712                                  	; MSDOS 6.0
 32713 00005A42 E81800                  	CALL	GetCharType	; returns type flags in AL
 32714                                  	
 32715                                  	;test	al,1	
 32716 00005A45 A801                    	TEST	AL,FCHK 	; test for normal character
 32717 00005A47 58                      	POP	AX
 32718                                  
 32719 00005A48 5B                      	POP	BX
 32720 00005A49 C3                      	RETN
 32721                                  
 32722                                  ; This entry has character in AL and lookup table in BX
 32723                                  
 32724                                  	; MSDOS 6.0
 32725                                  ;	;entry GetLet3
 32726                                  GETLET3: ; 10/08/2018
 32727 00005A4A 53                      	PUSH	BX
 32728 00005A4B EBDC                    	JMP	short gl_0
 32729                                  ;ELSE
 32730                                  ;
 32731                                  ;gl_2:
 32732                                  ;	POP	BX
 32733                                  ;	CMP	AL,"."
 32734                                  ;	retz
 32735                                  ;	CMP	AL,'"'
 32736                                  ;	retz
 32737                                  ;	CALL	PATHCHRCMP
 32738                                  ;	retz
 32739                                  ;	CMP	AL,"["
 32740                                  ;	retz
 32741                                  ;	CMP	AL,"]"
 32742                                  ;	retz
 32743                                  ;ENDIF
 32744                                  
 32745                                  ;---------------------------------------------------------------------
 32746                                  ;
 32747                                  ; DELIM - check if character is a delimiter
 32748                                  ;	Entry : AX = character to check
 32749                                  ;	Exit  : ZF set if character is not a delimiter
 32750                                  ;	Uses  : Flags
 32751                                  ;
 32752                                  ;--------------------------------------------------------------------
 32753                                  
 32754                                  	;entry	DELIM
 32755                                  DELIM:
 32756                                  ;IF TableLook
 32757                                  	; 20/05/2019 - Retro DOS v4.0
 32758 00005A4D 50                      	PUSH	AX
 32759                                  
 32760                                  	; MSDOS 3.3
 32761                                  	;push	bx
 32762                                  	;mov	bx,CharType
 32763                                  	;;09/08/2018
 32764                                  	;;xlat	byte [cs:bx]
 32765                                  	;cs	xlat
 32766                                  	;pop	bx
 32767                                  
 32768                                  	; MSDOS 6.0
 32769 00005A4E E80C00                  	CALL	GetCharType
 32770                                  	
 32771                                  	;test	al,2
 32772 00005A51 A802                    	TEST	AL,FDELIM
 32773 00005A53 58                      	POP	AX
 32774 00005A54 C3                      	RETN
 32775                                  ;ELSE
 32776                                  ;	CMP	AL,":"
 32777                                  ;	retz
 32778                                  ;
 32779                                  ;	CMP	AL,"<"
 32780                                  ;	retz
 32781                                  ;	CMP	AL,"|"
 32782                                  ;	retz
 32783                                  ;	CMP	AL,">"
 32784                                  ;	retz
 32785                                  ;
 32786                                  ;	CMP	AL,"+"
 32787                                  ;	retz
 32788                                  ;	CMP	AL,"="
 32789                                  ;	retz
 32790                                  ;	CMP	AL,";"
 32791                                  ;	retz
 32792                                  ;	CMP	AL,","
 32793                                  ;	retz
 32794                                  ;ENDIF
 32795                                  
 32796                                  ;-------------------------------------------------------------------------
 32797                                  ;
 32798                                  ;  SPCHK - checks to see if a character is a space or equivalent
 32799                                  ;	Entry : AL = character to check
 32800                                  ;	Exit  : ZF set if character is a space
 32801                                  ;	Uses  : flags
 32802                                  ;
 32803                                  ;-------------------------------------------------------------------------
 32804                                  
 32805                                  	;entry SPCHK
 32806                                  SPCHK:
 32807                                  ;IF TableLook
 32808                                  	; 20/05/2019 - Retro DOS v4.0
 32809 00005A55 50                      	PUSH	AX
 32810                                  
 32811                                  	; MSDOS 3.3
 32812                                  	;push	bx
 32813                                  	;mov	bx,CharType
 32814                                  	;; 09/08/2018
 32815                                  	;;xlat	byte [cs:bx]
 32816                                  	;cs	xlat
 32817                                  	;pop	bx
 32818                                  
 32819                                  	; MSDOS 6.0
 32820 00005A56 E80400                  	CALL	GetCharType
 32821                                  	
 32822                                  	;test	al,4
 32823 00005A59 A804                    	TEST	AL,FSPCHK
 32824 00005A5B 58                      	POP	AX
 32825 00005A5C C3                      	RETN
 32826                                  ;ELSE
 32827                                  ;	CMP	AL,9		; Filter out tabs too
 32828                                  ;	retz
 32829                                  ;; WARNING! " " MUST be the last compare
 32830                                  ;	CMP	AL," "
 32831                                  ;	return
 32832                                  ;ENDIF
 32833                                  
 32834                                  ;-------------------------------------------------------------------------
 32835                                  ;
 32836                                  ;  GetCharType - return flag bits indicating character type
 32837                                  ;	Bits are defined in DOSSYM.INC. Uses lookup table
 32838                                  ;	defined above at label CharType.
 32839                                  ;
 32840                                  ;	Entry : AL = character to return type flags for
 32841                                  ;	Exit  : AL = type flags
 32842                                  ;	Uses  : AL, flags
 32843                                  ;
 32844                                  ;-------------------------------------------------------------------------
 32845                                  
 32846                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32847                                  
 32848                                  	; 20/05/2019 - Retro DOS v4.0
 32849                                  	; MSDOS 6.0
 32850                                  GetCharType:
 32851                                  	;cmp	al,7Eh
 32852 00005A5D 3C7E                    	cmp	al,CharType_last 	; beyond end of table?
 32853 00005A5F 7316                    	jae	short gct_90		; return standard value
 32854                                  
 32855 00005A61 53                      	push	bx
 32856 00005A62 BB[E559]                	mov	bx,CharType		; load lookup table
 32857 00005A65 D0E8                    	shr	al,1			; adjust for half-byte table entry size
 32858                                  	;xlat	cs:[bx] 		; get flags
 32859 00005A67 2ED7                    	cs	xlat	
 32860 00005A69 5B                      	pop	bx
 32861                                  
 32862                                  ; carry clear from previous shift means we want the low nibble.  Otherwise
 32863                                  ; we have to shift the flags down to the low nibble
 32864                                  
 32865 00005A6A 7308                    	jnc	short gct_80		; carry clear, no shift needed
 32866                                  
 32867 00005A6C D0E8                    	shr	al,1			; we want high nibble, shift it down
 32868 00005A6E D0E8                    	shr	al,1
 32869 00005A70 D0E8                    	shr	al,1
 32870 00005A72 D0E8                    	shr	al,1
 32871                                  gct_80:
 32872 00005A74 240F                    	and	al,0Fh			; clear the unused nibble
 32873 00005A76 C3                      	retn
 32874                                  gct_90:
 32875 00005A77 B00F                    	mov	al,0Fh			; set all flags
 32876 00005A79 C3                      	retn
 32877                                  
 32878                                  ;----------------------------------------------------------------------------
 32879                                  ;
 32880                                  ; Procedure : PATHCHRCMP
 32881                                  ;
 32882                                  ;----------------------------------------------------------------------------
 32883                                  
 32884                                  PATHCHRCMP:
 32885 00005A7A 3C2F                    	CMP	AL,'/'
 32886 00005A7C 7606                    	JBE	short PathRet
 32887 00005A7E 3C5C                    	CMP	AL,'\'
 32888 00005A80 C3                      	retn
 32889                                  GotFor:
 32890 00005A81 B05C                    	MOV	AL,'\'
 32891 00005A83 C3                      	retn
 32892                                  PathRet:
 32893 00005A84 74FB                    	JZ	short GotFor
 32894 00005A86 C3                      	retn
 32895                                  
 32896                                  ;============================================================================
 32897                                  ; MSCRTLC.ASM, MSDOS 6.0, 1991
 32898                                  ;============================================================================
 32899                                  ; 30/07/2018 - Retro DOS v3.0
 32900                                  ; 29/04/2019 - Retro DOS v4.0
 32901                                  
 32902                                  ; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11, CTRLC.ASM, 1983)
 32903                                  
 32904                                  ;**	MSCTRLC.ASM - ^C and error handler for MSDOS
 32905                                  
 32906                                  ;	TITLE	Control C detection, Hard error and EXIT routines
 32907                                  ;	NAME	IBMCTRLC
 32908                                  
 32909                                  ;**	Low level routines for detecting special characters on CON input,
 32910                                  ;	the ^C exit/int code, the Hard error INT 24 code, the
 32911                                  ;	process termination code, and the INT 0 divide overflow handler.
 32912                                  ;
 32913                                  ;	FATAL
 32914                                  ;	FATAL1
 32915                                  ;	reset_environment
 32916                                  ;	DSKSTATCHK
 32917                                  ;	SPOOLINT
 32918                                  ;	STATCHK
 32919                                  ;	CNTCHAND
 32920                                  ;	DIVOV
 32921                                  ;	CHARHARD
 32922                                  ;	HardErr
 32923                                  ;
 32924                                  ;	Revision history:
 32925                                  ;
 32926                                  ;	    AN000	version 4.0   Jan 1988
 32927                                  ;	    A002	PTM    -- dir >lpt3 hangs
 32928                                  ;	    A003	PTM 3957- fake version for IBMCAHE.COM
 32929                                  ;
 32930                                  ; 	M011: NEC's 8086 clone chip uses Intel's undocumented bit number in
 32931                                  ;	      flags register. In order to return to user normally DOS used to
 32932                                  ;	      move F202 into flags, which sets bit number 1 in flags uncondit-
 32933                                  ;	      ionally. Now it is modified to maintain the state of bit 1.
 32934                                  ;
 32935                                  ; 	M024: suppressed fail and ignore options if not in the middle of int 
 32936                                  ;	      24 and if Ctrl P or ctrl printscrn is pressed in routine 
 32937                                  ;	      charhard.
 32938                                  
 32939                                  ; 29/04/2019 - Retro DOS v4.0
 32940                                  	; MSDOS 6.0
 32941                                  ;		public	LowInt23Addr		
 32942                                  LowInt23Addr: ;	LABEL	DWORD
 32943 00005A87 [3111]0000              	DW	LowInt23, 0
 32944                                  
 32945                                  ;		public	LowInt24Addr
 32946                                  LowInt24Addr: ;	LABEL	DWORD
 32947 00005A8B [4511]0000              	DW	LowInt24, 0
 32948                                  
 32949                                  ;		public	LowInt28Addr
 32950                                  LowInt28Addr: ;	LABEL	DWORD
 32951 00005A8F [5911]0000              	DW	LowInt28, 0
 32952                                  
 32953                                  ;Break	<Checks for ^C in CON I/O>
 32954                                  
 32955                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32956                                  ; 05/05/2019 - Retro DOS v4.0
 32957                                  
 32958                                  ;---------------------------------------------------------------------------
 32959                                  ;
 32960                                  ; Procedure Name : DSKSTATCHK
 32961                                  ;
 32962                                  ; Check for ^C if only one level in
 32963                                  ;
 32964                                  ;---------------------------------------------------------------------------
 32965                                  
 32966                                          ;procedure DSKSTATCHK,NEAR ; Check for ^C if only one level in
 32967                                  
 32968                                  DSKSTATCHK:        
 32969                                  	;CMP	BYTE [INDOS],1
 32970 00005A93 36803E[2103]01                  CMP     BYTE [SS:INDOS],1 ; 15/03/2018
 32971                                  	;retnz			; Do NOTHING
 32972                                  	; 16/12/2022
 32973 00005A99 7534                    	JNZ	SHORT _RET37 ; Retro DOS v2.0 - 04/03/2018         
 32974                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 32975                                  	;jz	short _RET37 ; dskstatchk1
 32976                                  	;retn
 32977                                  ;_RET37:
 32978                                  ;dskstatchk1:
 32979 00005A9B 51                      	PUSH    CX
 32980 00005A9C 06                              PUSH    ES
 32981 00005A9D 53                              PUSH    BX
 32982 00005A9E 1E                              PUSH    DS
 32983 00005A9F 56                              PUSH    SI
 32984                                          
 32985                                  	;PUSH	CS
 32986                                          ;POP	ES
 32987                                          ;PUSH	CS
 32988                                          ;POP	DS
 32989                                  
 32990 00005AA0 8CD3                    	MOV	BX,SS		; SS is DOSDATA. ES:BX must be set up
 32991 00005AA2 8EC3                    	MOV	ES,BX		; for deviocall2
 32992 00005AA4 8EDB                    	MOV	DS,BX
 32993                                  
 32994                                  	; 16/12/2022
 32995                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 32996                                  
 32997                                  	; 05/05/2019
 32998                                  	;MOV	BYTE [ss:DSKSTCOM],DEVRDND
 32999                                          ;MOV	BYTE [ss:DSKSTCALL],DRDNDHL
 33000                                  	;mov	word [ss:DSKSTST],0
 33001                                  
 33002                                  	; 16/12/2022
 33003                                  	; 25/06/2019
 33004 00005AA6 C606[9403]05            	MOV	BYTE [DSKSTCOM],DEVRDND	 ; 5
 33005 00005AAB C606[9203]0E                    MOV	BYTE [DSKSTCALL],DRDNDHL ; 14
 33006 00005AB0 C706[9503]0000          	mov	word [DSKSTST],0
 33007                                  
 33008 00005AB6 BB[9203]                        MOV     BX,DSKSTCALL
 33009                                  
 33010                                  	;LDS	SI,[ss:BCON]
 33011                                          ; 25/062019
 33012 00005AB9 C536[3200]              	lds	si,[BCON]
 33013                                  
 33014                                  ; 16/12/2022
 33015                                  ;	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 33016                                  ;	mov	byte [ss:DSKSTCOM],DEVRDND  ; 5
 33017                                  ;       mov	byte [ss:DSKSTCALL],DRDNDHL ; 14
 33018                                  ;	mov	word [ss:DSKSTST],0
 33019                                  ;	mov	bx,DSKSTCALL
 33020                                  ;	lds	si,[ss:BCON]
 33021                                  
 33022 00005ABD E890F5                  	CALL	DEVIOCALL2
 33023                                   	; 15/03/2018
 33024                                  	;;test	word [ss:DSKSTST],200h
 33025                                          ;TEST	WORD [SS:DSKSTST],STBUI
 33026                                  	; 05/05/2019
 33027 00005AC0 36F606[9603]02          	test	byte [ss:DSKSTST+1],(STBUI>>8) ; 2
 33028 00005AC6 7408                    	jz	short _GotCh		; No characters available
 33029                                  
 33030 00005AC8 30C0                            XOR     AL,AL                   ; Set zero
 33031                                  RET36:
 33032 00005ACA 5E                              POP     SI
 33033 00005ACB 1F                              POP     DS
 33034 00005ACC 5B                              POP     BX
 33035 00005ACD 07                              POP     ES
 33036 00005ACE 59                              POP     CX
 33037                                  	; 16/12/2022
 33038                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 33039                                  _RET37:
 33040 00005ACF C3                              RETN
 33041                                  
 33042                                  _GotCh:
 33043 00005AD0 36A0[9F03]                      MOV     AL,[SS:DSKCHRET]	; SS override
 33044                                  
 33045 00005AD4 3C03                            CMP     AL,"C"-"@" ; cmp al,3
 33046 00005AD6 75F2                            JNZ     SHORT RET36
 33047 00005AD8 36C606[9403]04                  MOV     BYTE [SS:DSKSTCOM],DEVRD
 33048 00005ADE 36C606[9203]16                  MOV     BYTE [SS:DSKSTCALL],DRDWRHL
 33049 00005AE4 36880E[9F03]                    MOV     [SS:DSKCHRET],CL
 33050                                  	; 09/09/2018
 33051 00005AE9 36C706[9503]0000        	MOV	word [SS:DSKSTST],0
 33052 00005AF0 36C706[A403]0100        	MOV	word [SS:DSKSTCNT],1
 33053 00005AF7 E856F5                  	CALL	DEVIOCALL2              ; Eat the ^C
 33054 00005AFA 5E                              POP     SI
 33055 00005AFB 1F                              POP     DS
 33056 00005AFC 5B                              POP     BX                      ; Clean stack
 33057 00005AFD 07                              POP     ES
 33058 00005AFE 59                              POP     CX
 33059 00005AFF E9CF00                          JMP	CNTCHAND ; 10/08/2018
 33060                                  
 33061                                  	; 05/05/2019
 33062                                  NOSTOP:
 33063                                  	; MSDOS 6.0
 33064 00005B02 3C10                    	CMP	AL,"P"-"@"
 33065 00005B04 7509                    	JNZ	short check_next
 33066                                  				    	; SS override
 33067 00005B06 36803E[E10D]00          	CMP	BYTE [SS:SCAN_FLAG],0	; ALT_Q ?
 33068 00005B0C 7405                    	JZ	short INCHKJ		; no
 33069                                  check_end:	; 24/09/2023
 33070 00005B0E C3                      	retn
 33071                                  check_next:
 33072                                  	;IF	NOT TOGLPRN
 33073                                  	;CMP	AL,"N"-"@"
 33074                                  	;JZ	short INCHKJ
 33075                                  	;ENDIF
 33076                                  
 33077 00005B0F 3C03                    	CMP	AL,"C"-"@"
 33078                                  	; 24/09/2023
 33079                                  	;JZ	short INCHKJ
 33080                                  ;check_end:
 33081                                  	;retn
 33082 00005B11 75FB                    	jnz	short check_end
 33083                                  
 33084                                  	; 24/09/2023
 33085                                  	; 08/09/2018
 33086                                  INCHKJ:	; 10/08/2018
 33087 00005B13 E9A500                  	jmp	INCHK
 33088                                  
 33089                                  	; MSDOS 3.3
 33090                                          ;CMP     AL,"P"-"@"  ; cmp al,16
 33091                                          ;JZ	short INCHKJ
 33092                                  
 33093                                  	; 15/04/2018
 33094                                          ;;IF	NOT TOGLPRN
 33095                                          ;CMP	AL,"N"-"@"
 33096                                          ;JZ	SHORT INCHKJ
 33097                                          ;;ENDIF
 33098                                  	
 33099                                  	;CMP     AL,"C"-"@"  ; cmp al,3
 33100                                          ;JZ	short INCHKJ
 33101                                  	;RETN
 33102                                  
 33103                                  ;	; 08/09/2018
 33104                                  ;INCHKJ:; 10/08/2018
 33105                                  ;	JMP	INCHK
 33106                                  
 33107                                  ;----------------------------------------------------------------------------
 33108                                  ;
 33109                                  ; Procedure Name : SpoolInt
 33110                                  ;
 33111                                  ; SpoolInt - signal processes that the DOS is truly idle. We are allowed to
 33112                                  ; do this ONLY if we are working on a 1-12 system call AND if we are not in
 33113                                  ; the middle of an INT 24.
 33114                                  ;
 33115                                  ;----------------------------------------------------------------------------
 33116                                  
 33117                                  SPOOLINT:
 33118 00005B16 9C                              PUSHF
 33119                                  	; 15/03/2018
 33120 00005B17 36803E[5803]00                  CMP     BYTE [SS:IDLEINT],0	; SS override
 33121 00005B1D 7423                            JZ      SHORT POPFRET
 33122 00005B1F 36803E[2003]00                  CMP     BYTE [SS:ERRORMODE],0
 33123 00005B25 751B                            JNZ     SHORT POPFRET		;No spool ints in error mode
 33124                                  
 33125                                  	; 30/07/2018
 33126                                  
 33127                                  	; Note that we are going to allow an external program to issue system 
 33128                                  	; calls at this time. We MUST preserve IdleInt across this.
 33129                                  
 33130 00005B27 36FF36[5803]            	PUSH	WORD [SS:IDLEINT]
 33131                                  
 33132                                  	; 05/05/2019 - Retro DOS v4.0
 33133                                   
 33134                                  	; MSDOS 6.0
 33135 00005B2C 36803E[870D]00          	cmp	byte [SS:DosHasHMA],0	; Q: is dos running in HMA (M021)
 33136 00005B32 7504                    	jne	short do_low_int28	; Y: the int must be done from low mem
 33137 00005B34 CD28                    	INT	int_spooler  ; int 28h 	; N: Execute user int 28 handler
 33138 00005B36 EB05                    	jmp	short spool_ret_addr
 33139                                  
 33140                                  do_low_int28:
 33141                                  	;call	far [ss:LowInt28Addr]
 33142 00005B38 2EFF1E[8F5A]            	call	far [cs:LowInt28Addr]	; 05/05/2019
 33143                                  
 33144                                  spool_ret_addr:
 33145                                  	;INT	int_spooler		; INT 28h
 33146                                  
 33147 00005B3D 368F06[5803]            	POP	WORD [SS:IDLEINT]
 33148                                  POPFRET:
 33149 00005B42 9D                              POPF
 33150                                  _RET18:  
 33151 00005B43 C3                      	RETN
 33152                                  
 33153                                  ; 05/05/2019 - Retro DOS v4.0
 33154                                  ; DOSCODE:9137h (MSDOS 6.21, MSDOS.SYS)
 33155                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33156                                  ; DOSCODE:90DBh (MSDOS 5.0, MSDOS.SYS)
 33157                                  
 33158                                  ;----------------------------------------------------------------------------
 33159                                  ;
 33160                                  ; Procedure Name : STATCHK
 33161                                  ;
 33162                                  ;----------------------------------------------------------------------------
 33163                                  
 33164                                  STATCHK:
 33165 00005B44 E84CFF                          CALL	DSKSTATCHK              ; Allows ^C to be detected under
 33166                                                                          ; input redirection
 33167 00005B47 53                              PUSH    BX
 33168 00005B48 31DB                            XOR     BX,BX
 33169 00005B4A E8A7E3                          CALL	GET_IO_SFT
 33170 00005B4D 5B                              POP     BX
 33171 00005B4E 72F3                            JC      SHORT _RET18
 33172                                  
 33173 00005B50 B401                            MOV     AH,1
 33174 00005B52 E826F3                          CALL	IOFUNC
 33175 00005B55 74BF                            JZ      SHORT SPOOLINT
 33176 00005B57 3C13                            CMP     AL,'S'-'@'
 33177 00005B59 75A7                            JNZ     SHORT NOSTOP
 33178                                  
 33179                                  	; 05/05/2019
 33180                                  	; MSDOS 6.0			; SS override
 33181 00005B5B 36803E[E10D]00          	CMP	BYTE [SS:SCAN_FLAG],0	; AN000; ALT_R ?
 33182 00005B61 75AB                    	JNZ	short check_end		; AN000; yes
 33183                                  
 33184 00005B63 30E4                            XOR     AH,AH
 33185 00005B65 E813F3                          CALL	IOFUNC                  ; Eat Cntrl-S
 33186 00005B68 EB4A                            JMP     SHORT PAUSOSTRT
 33187                                  PRINTOFF:
 33188                                  PRINTON:
 33189 00005B6A 36F616[FE02]            	NOT	BYTE [SS:PFLAG] ; 14/03/2018
 33190                                  
 33191                                  	; 30/07/2018 - Retro DOS v3.0
 33192 00005B6F 53                      	PUSH	BX
 33193 00005B70 BB0400                  	MOV	BX,4
 33194 00005B73 E87EE3                  	call	GET_IO_SFT
 33195 00005B76 5B                      	POP	BX
 33196 00005B77 72CA                    	jc	short _RET18
 33197 00005B79 06                      	PUSH	ES
 33198 00005B7A 57                      	PUSH	DI
 33199 00005B7B 1E                      	PUSH	DS
 33200 00005B7C 07                      	POP	ES
 33201 00005B7D 89F7                    	MOV	DI,SI			; ES:DI -> SFT
 33202                                  	;test	word [es:di+5],800h
 33203                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_net_spool
 33204                                  	; 05/05/2019
 33205 00005B7F 26F6450608              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_net_spool>>8)
 33206 00005B84 7418                    	JZ	short NORM_PR 		; Not redirected, echo is OK
 33207                                  
 33208                                  	;Callinstall NetSpoolEchoCheck,MultNet,38,<AX>,<AX> 
 33209                                  					; See if allowed
 33210 00005B86 50                      	push	ax
 33211 00005B87 B82611                  	mov	ax,1126h
 33212 00005B8A CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - ???
 33213                                  			; Return: CF set on error, AX = error code
 33214                                  			; STACK unchanged
 33215 00005B8C 58                      	pop	ax
 33216                                  
 33217 00005B8D 730F                    	JNC	short NORM_PR 		; Echo is OK
 33218                                  
 33219                                  					; SS override
 33220 00005B8F 36C606[FE02]00          	MOV	BYTE [SS:PFLAG],0	; If not allowed, disable echo
 33221                                  
 33222                                  	;Callinstall NetSpoolClose,MultNet,36,<AX>,<AX> ; and close
 33223                                  
 33224 00005B95 50                      	push    ax
 33225 00005B96 B82411                  	mov     ax,1124h
 33226 00005B99 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - ???
 33227                                  			; ES:DI -> SFT, SS = DOS CS
 33228 00005B9B 58                      	pop     ax
 33229                                  
 33230 00005B9C EB10                    	JMP	SHORT RETP6
 33231                                  NORM_PR:
 33232 00005B9E 36803E[FE02]00          	CMP	BYTE [SS:PFLAG],0	; SS override
 33233 00005BA4 7505                    	JNZ	short PRNOPN
 33234 00005BA6 E82BF4                  	call	DEV_CLOSE_SFT
 33235 00005BA9 EB03                    	JMP	SHORT RETP6
 33236                                  PRNOPN:
 33237 00005BAB E81EF4                  	call	DEV_OPEN_SFT
 33238                                  RETP6:
 33239 00005BAE 5F                      	POP	DI
 33240 00005BAF 07                      	POP	ES
 33241                                  STATCHK_RETN:
 33242 00005BB0 C3                              RETN
 33243                                  PAUSOLP:
 33244 00005BB1 E862FF                          CALL    SPOOLINT
 33245                                  PAUSOSTRT:
 33246 00005BB4 B401                            MOV     AH,1
 33247 00005BB6 E8C2F2                          CALL	IOFUNC
 33248 00005BB9 74F6                            JZ      SHORT PAUSOLP
 33249                                  INCHK:
 33250 00005BBB 53                              PUSH    BX
 33251 00005BBC 31DB                            XOR     BX,BX
 33252 00005BBE E833E3                          CALL	GET_IO_SFT
 33253 00005BC1 5B                              POP     BX
 33254 00005BC2 72EC                            JC      SHORT STATCHK_RETN ; 30/07/2018
 33255 00005BC4 30E4                            XOR     AH,AH
 33256 00005BC6 E8B2F2                          CALL	IOFUNC
 33257                                  	; 30/07/2018
 33258                                  	; MSDOS 3.3
 33259                                          ;CMP	AL,'P'-'@' ;cmp al,16
 33260                                          ;JNZ	SHORT NOPRINT
 33261                                  
 33262                                  	;cmp	byte [SS:SCAN_FLAG],0
 33263                                  	;JZ	SHORT PRINTON	
 33264                                  	;mov	byte [ss:SCAN_FLAG],0
 33265                                  
 33266                                  	; 05/05/2019
 33267                                  	; MSDOS 6.0
 33268 00005BC9 3C10                    	CMP	AL,"P"-"@"
 33269                                  	;;;;  7/14/86	ALT_Q key fix
 33270 00005BCB 749D                    	JZ	short PRINTON		; no! must be CTRL_P
 33271                                  ;NOPRINT:	
 33272                                  	;IF	NOT TOGLPRN
 33273                                  	;CMP	AL,"N"-"@"
 33274                                  	;JZ	short PRINTOFF
 33275                                  	;ENDIF
 33276 00005BCD 3C03                    	CMP	AL,"C"-"@" ; cmp al,3 
 33277                                  	;retnz
 33278 00005BCF 75DF                    	jnz	short STATCHK_RETN
 33279                                  
 33280                                  	; !! NOTE: FALL THROUGH !!
 33281                                  
 33282                                  ;---------------------------------------------------------------------------
 33283                                  ;
 33284                                  ; Procedure Name : CNTHAND ( CTRLC_C HANDLER )
 33285                                  ;
 33286                                  ; "^C" and CR/LF is printed. Then the user registers are restored and the
 33287                                  ; user CTRL-C handler is executed. At this point the top of the stack has 1)
 33288                                  ; the interrupt return address should the user CTRL-C handler wish to allow
 33289                                  ; processing to continue; 2) the original interrupt return address to the code
 33290                                  ; that performed the function call in the first place. If the user CTRL-C
 33291                                  ; handler wishes to continue, it must leave all registers unchanged and RET
 33292                                  ; (not IRET) with carry CLEAR. If carry is SET then an terminate system call
 33293                                  ; is simulated.
 33294                                  ;
 33295                                  ;---------------------------------------------------------------------------
 33296                                  
 33297                                  CNTCHAND:
 33298                                  	; MSDOS 6.0			; SS override
 33299                                  					; AN002; from RAWOUT
 33300                                  	;TEST	word [SS:DOS34_FLAG],CTRL_BREAK_FLAG  
 33301                                  	;JNZ	short around_deadlock 	; AN002;
 33302                                  
 33303                                  	; 05/05/2019 - Retro DOS v4.0
 33304                                  	; (MSDOS 6.21 MSDOS.SYS DOSCODE:91C4h, 29/12/2022)
 33305 00005BD1 36F606[1206]02          	TEST	byte [SS:DOS34_FLAG+1],(CTRL_BREAK_FLAG>>8)  ; 2 
 33306 00005BD7 7508                    	JNZ	short around_deadlock 	; AN002;
 33307                                  
 33308 00005BD9 B003                            MOV     AL,3			; Display "^C"
 33309 00005BDB E803C1                          CALL	BUFOUT
 33310 00005BDE E89EBF                          CALL	CRLF
 33311                                  around_deadlock:
 33312 00005BE1 16                              PUSH    SS
 33313 00005BE2 1F                              POP     DS
 33314 00005BE3 803E[5703]00                    CMP     BYTE [CONSWAP],0
 33315 00005BE8 7403                            JZ      SHORT NOSWAP
 33316 00005BEA E871DF                          CALL	SWAPBACK
 33317                                  NOSWAP:
 33318 00005BED FA                      	CLI				; Prepare to play with stack
 33319 00005BEE 8E16[8605]              	MOV	SS,[USER_SS]		; User stack now restored
 33320 00005BF2 8B26[8405]              	MOV	SP,[USER_SP]
 33321 00005BF6 E848A8                          CALL	restore_world       ; User registers now restored
 33322                                  
 33323                                  	; 30/07/2018 - Retro DOS v3.0 
 33324                                  	; MSDOS 3.3 (IBMDOS.COM - Offset 56ACh)
 33325                                          ; 14/03/2018 - Retro DOS v2.0
 33326                                  	;MOV	BYTE [CS:INDOS],0	
 33327                                          ;MOV	BYTE [CS:ERRORMODE],0
 33328                                          ;MOV	[CS:ConC_Spsave],SP
 33329                                  	;clc	;30/07/2018
 33330                                          ;INT	int_ctrl_c ; 23h    ; Execute user Ctrl-C handler
 33331                                  	;;int	23h	; DOS - CONTROL "C" EXIT ADDRESS
 33332                                  			; Return: return via RETF 2 with CF set
 33333                                  			; DOS will abort program with errorlevel 0
 33334                                  			; else
 33335                                  			; interrupted DOS call continues
 33336                                  
 33337                                  	; 05/05/2019 - Retro DOS v4.0
 33338                                  	; MSDOS 6.0 (MSDOS 6.21, MSDOS.SYS,91ECh) 
 33339                                  
 33340                                  	; CS was used to address these variables. We have to use DOSDATA
 33341                                  	
 33342 00005BF9 07                      	pop	es ; *	; MSDOS 6.21 (MSDOS.SYS, DOSCODE:91ECh)
 33343                                  			; (pop es, after 'call restore_world')	
 33344 00005BFA 1E                      	push	ds
 33345                                  	;getdseg <ds>			; ds -> dosdata
 33346 00005BFB 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 33347 00005C00 C606[2103]00            	mov	byte [INDOS],0		; Go to known state
 33348 00005C05 C606[2003]00            	mov	byte [ERRORMODE],0
 33349 00005C0A 8926[3203]              	mov	[ConC_Spsave],SP	; save his SP
 33350                                  	; User SP has changed because of push. Adjust for it
 33351 00005C0E 8306[3203]02            	add	word [ConC_Spsave],2
 33352                                  
 33353 00005C13 803E[870D]00            	cmp	byte [DosHasHMA],0	; Q: is dos running in HMA (M021)
 33354 00005C18 1F                       	pop	ds	; restore ds
 33355 00005C19 7505                    	jne	short do_low_int23	; Y: the int must be done from low mem
 33356 00005C1B F8                      	CLC				
 33357 00005C1C CD23                    	INT	int_ctrl_c  ; int 23h	; N: Execute user Ctrl-C handler
 33358 00005C1E EB06                    	jmp	short ctrlc_ret_addr
 33359                                  
 33360                                  	; 05/05/2019
 33361                                  do_low_int23:
 33362 00005C20 F8                      	clc
 33363 00005C21 2EFF1E[875A]            	call	far [cs:LowInt23Addr]	
 33364                                  
 33365                                  	; 30/07/2018 
 33366                                  
 33367                                  	; MSDOS 3.3 (IBMDOS.COM - Offset 56C0h)
 33368                                  
 33369                                  ; The user has returned to us. The circumstances we allow are:
 33370                                  ;
 33371                                  ;   IRET	We retry the operation by redispatching the system call
 33372                                  ;   CLC/RETF	POP the stack and retry
 33373                                  ;   ... 	Exit the current process with ^C exit
 33374                                  ;
 33375                                  ; User's may RETURN to us and leave interrupts on. 
 33376                                  ; Turn 'em off just to be sure
 33377                                  
 33378                                  ctrlc_ret_addr: ; 05/05/2019
 33379                                  
 33380 00005C26 FA                      	CLI
 33381                                  
 33382                                  	; MSDOS 3.3 
 33383                                  	;MOV	[CS:USER_IN_AX],ax	; save the AX
 33384                                  	;PUSHF				; and the flags (maybe new call)
 33385                                  	;POP	AX
 33386                                  
 33387                                  	; 05/05/2019
 33388                                  	; MSDOS 6.0
 33389                                  
 33390                                  	; We have to use DOSDATA for these variables. Previously CS was used 
 33391                                  
 33392 00005C27 50                      	push	ax
 33393 00005C28 8CD8                    	mov	ax,ds
 33394                                  	;getdseg <ds>			; ds -> dosdata
 33395 00005C2A 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 33396 00005C2F A3[840D]                	mov	[TEMPSEG],ax
 33397 00005C32 58                      	pop	ax
 33398 00005C33 A3[3A03]                	MOV	[USER_IN_AX],ax		; save the AX
 33399 00005C36 9C                      	pushf				; and the flags (maybe new call)
 33400 00005C37 58                      	pop	ax
 33401                                  
 33402                                  ; See if the input stack is identical to the output stack
 33403                                  
 33404                                  	; MSDOS 3.3
 33405                                  	;CMP	SP,[CS:ConC_Spsave]
 33406                                  	;JNZ     SHORT ctrlc_try_new ; current SP not the same as saved SP
 33407                                  
 33408                                  	; MSDOS 6.0
 33409 00005C38 3B26[3203]              	CMP	SP,[ConC_Spsave]
 33410 00005C3C 750A                    	JNZ     SHORT ctrlc_try_new ; current SP not the same as saved SP
 33411                                  
 33412                                  ; Repeat the operation by redispatching the system call.
 33413                                  
 33414                                  ctrlc_repeat:
 33415                                  	; MSDOS 3.3
 33416                                  	;MOV	AX,[CS:USER_IN_AX]
 33417                                  	; 05/05/2019
 33418                                  	; MSDOS 6.0
 33419 00005C3E A1[3A03]                	mov	ax,[USER_IN_AX]
 33420 00005C41 8E1E[840D]              	mov	ds,[TEMPSEG]		; restore ds and original sp
 33421                                  	; MSDOS 3.3 & MSDOS 6.0 
 33422                                  	;transfer COMMAND
 33423                                  COMMANDJ:
 33424 00005C45 E9A9A6                  	JMP	COMMAND
 33425                                  
 33426                                  ; The current SP is NOT the same as the input SP. Presume that he 
 33427                                  ; RETF'd leaving some flags on the stack and examine the input
 33428                                  
 33429                                  ctrlc_try_new:
 33430 00005C48 83C402                  	ADD	SP,2			; pop those flags
 33431                                  	;;test	ax,1
 33432                                  	;TEST	AX,f_Carry		; did he return with carry?
 33433 00005C4B A801                    	test	al,f_Carry ; test al,1
 33434 00005C4D 74EF                    	JZ	short ctrlc_repeat	; no carry set, just retry
 33435                                  
 33436                                  	; MSDOS 6.0
 33437 00005C4F 8E1E[840D]              	mov	ds,[TEMPSEG]		; restore ds
 33438                                  
 33439                                  	; Well...  time to abort the user.  
 33440                                  	; Signal a ^C exit and use the EXIT system call..
 33441                                  
 33442                                  ctrlc_abort:
 33443                                  	; MSDOS 3.3
 33444                                          ;;MOV	AX,(EXIT SHL 8) + 0
 33445                                          ;MOV	AX, (EXIT*256) + 0  ; 4C00h
 33446                                  	;mov	byte [CS:DidCTRLC],0FFh ; 14/03/2018
 33447                                          ;transfer COMMAND	    ; give up by faking $EXIT
 33448                                  	;;JMP	SHORT COMMANDJ
 33449                                  	;JMP	COMMAND
 33450                                  
 33451                                  	; 05/05/2019 - Retro DOS v4.0
 33452                                  	; MSDOS 6.0
 33453 00005C53 B8004C                  	MOV	AX,(EXIT<<8)+0  ; 4C00h
 33454 00005C56 1E                      	push	ds
 33455                                  	;getdseg <ds>			; ds -> dosdata
 33456 00005C57 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]	
 33457 00005C5C C606[4D03]FF            	MOV	byte [DidCTRLC],-1 ; 0FFh
 33458 00005C61 1F                      	pop	ds
 33459                                  	;transfer COMMAND		; give up by faking $EXIT
 33460 00005C62 EBE1                    	JMP	SHORT COMMANDJ
 33461                                  	;JMP	COMMAND
 33462                                  
 33463                                  ;Break	<DIVISION OVERFLOW INTERRUPT>
 33464                                  ;----------------------------------------------------------------------------
 33465                                  ;
 33466                                  ; Procedure Name : DIVOV
 33467                                  ;
 33468                                  ; Default handler for division overflow trap
 33469                                  ;
 33470                                  ;----------------------------------------------------------------------------
 33471                                  
 33472                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33473                                  DIVOV: 
 33474                                  	; 05/05/2019 - Retro DOS v4.0
 33475                                  	; 30/07/2018
 33476                                  	; 07/07/2018 - Retro DOS v3.0
 33477 00005C64 BE[1D0A]                	mov	si,DIVMES
 33478 00005C67 2E8B1E[300A]            	mov	bx,[cs:DivMesLen]
 33479                                  	;mov	ax,cs
 33480                                  	;mov	ss,ax
 33481                                  	; 05/05/2019
 33482                                  	;getdseg <ss>		; we are in an ISR, flag is CLI
 33483 00005C6C 2E8E16[0700]            	mov	ss,[cs:DosDSeg]
 33484 00005C71 BC[A007]                	mov     sp,AUXSTACK
 33485                                  	;call	RealDivOv ; MSDOS 3.3
 33486 00005C74 E80200                  	call	_OUTMES ; MSDOS 6.0
 33487 00005C77 EBDA                    	jmp	short ctrlc_abort  ; Use Ctrl-C abort on divide overflow
 33488                                  
 33489                                  ; 30/07/2018
 33490                                  
 33491                                  ; MSDOS 6.0
 33492                                  ;---------------------------------------------------------------------------
 33493                                  ;
 33494                                  ; Procedure Name : OutMes
 33495                                  ;
 33496                                  ;
 33497                                  ; OutMes: perform message output
 33498                                  ; Inputs:   SS:SI points to message
 33499                                  ;	    BX has message length
 33500                                  ; Outputs:  message to BCON
 33501                                  ;
 33502                                  ;Actually, cs:si points to the message now. The segment address is filled in
 33503                                  ;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
 33504                                  ;NB. This procedure is called only from DIVOV. -SR
 33505                                  ;
 33506                                  ;---------------------------------------------------------------------------
 33507                                  
 33508                                  ;MSDOS 3.3
 33509                                  ;---------------------------------------------------------------------------
 33510                                  ; RealDivOv: perform actual divide overflow stuff.
 33511                                  ; Inputs:   none
 33512                                  ; Outputs:  message to BCON
 33513                                  ;---------------------------------------------------------------------------
 33514                                  
 33515                                  	; 05/05/2019 - Retro DOS v4.0
 33516                                  	; DOSCODE:926Ch (MSDOS 6.21, MSDOS.SYS)
 33517                                  
 33518                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33519                                  	; DOSCODE:9210h (MSDOS 5.0, MSDOS.SYS)
 33520                                  
 33521                                  ;---------------------------------------------------------------------------
 33522                                  ;
 33523                                  ; Procedure Name : OutMes
 33524                                  ;
 33525                                  ; OutMes: perform message output
 33526                                  ; Inputs:   SS:SI points to message
 33527                                  ;	    BX has message length
 33528                                  ; Outputs:  message to BCON
 33529                                  ;
 33530                                  ;Actually, cs:si points to the message now. The segment address is filled in
 33531                                  ;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
 33532                                  ;NB. This procedure is called only from DIVOV. -SR
 33533                                  ;
 33534                                  ;---------------------------------------------------------------------------
 33535                                  
 33536                                  	; 30/07/2018
 33537                                  	; MSDOS 6.0
 33538                                  _OUTMES:
 33539                                  	; MSDOS 3.3
 33540                                  ;RealDivOv:
 33541                                  	; 07/07/2018 - Retro DOS v3.0
 33542                                          ;Context ES
 33543 00005C79 16                      	push	ss ; 05/05/2019
 33544                                  	;PUSH	CS ; 30/07/2018		; get ES addressability
 33545 00005C7A 07                      	POP	ES
 33546                                          ;Context DS
 33547 00005C7B 16                      	push	ss ; 05/05/2019	
 33548                                  	;PUSH	CS ; 30/07/2018		; get DS addressability
 33549 00005C7C 1F                      	POP	DS
 33550 00005C7D C606[9403]08                    MOV     BYTE [DSKSTCOM],DEVWRT
 33551 00005C82 C606[9203]16                    MOV     BYTE [DSKSTCALL],DRDWRHL
 33552 00005C87 C706[9503]0000                  MOV     WORD [DSKSTST],0
 33553                                  	; BX = [DivMesLen] = 19
 33554 00005C8D 891E[A403]                      MOV     [DSKSTCNT],BX
 33555 00005C91 BB[9203]                        MOV     BX,DSKSTCALL
 33556 00005C94 8936[A003]                      MOV     [DSKCHRET+1],SI		; transfer address (need an EQU)
 33557                                  	; 08/09/2018
 33558                                  	;mov	[DEVIOBUF_PTR],si
 33559                                  	; MSDOS 6.0
 33560                                  					; CS is used for string, fill in 
 33561                                  					; segment address 
 33562 00005C98 8C0E[A203]              	MOV	[DSKCHRET+3],CS
 33563                                  
 33564 00005C9C C536[3200]                      LDS     SI,[BCON]
 33565 00005CA0 E8ADF3                          CALL	DEVIOCALL2
 33566                                  
 33567                                  	;; 14/03/2018
 33568                                          ;;MOV	WORD [CS:DSKCHRET+1],DEVIOBUF
 33569                                  	;; 08/09/2018
 33570                                  	;mov	word [CS:DEVIOBUF_PTR],DEVIOBUF
 33571                                          ;MOV	WORD [CS:DSKSTCNT],1
 33572                                          
 33573                                  	; 05/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 33574                                  
 33575                                  	; ES still points to DOSDATA. ES is
 33576                                  					; not destroyed by deviocall2. So use
 33577                                  					; ES override.
 33578                                  
 33579 00005CA3 26C706[A003][BC03]      	MOV	WORD [ES:DSKCHRET+1],DEVIOBUF
 33580 00005CAA 26C706[A403]0100        	MOV	WORD [ES:DSKSTCNT],1
 33581                                  
 33582 00005CB1 C3                      	RETN
 33583                                  
 33584                                  ;Break	<CHARHRD,HARDERR,ERROR -- HANDLE DISK ERRORS AND RETURN TO USER>
 33585                                  ;---------------------------------------------------------------------------
 33586                                  ;
 33587                                  ; Procedure Name : CHARHARD
 33588                                  ;
 33589                                  ;
 33590                                  ; Character device error handler
 33591                                  ; Same function as HARDERR
 33592                                  ;
 33593                                  ;---------------------------------------------------------------------------
 33594                                  
 33595                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33596                                  CHARHARD:
 33597                                  	; 05/05/2019 - Retro DOS v4.0
 33598                                  	; 30/07/2018
 33599                                  	; 08/07/2018 - Retro DOS v3.0
 33600                                  
 33601                                  	; MSDOS 6.0
 33602                                  		   			; M024 - start
 33603 00005CB2 36803E[2003]00          	cmp	byte [SS:ERRORMODE], 0	; Q: are we in the middle of int 24
 33604                                  	;jne	short @f		; Y: allow fail
 33605 00005CB8 750B                    	jne	short chard1
 33606                                  
 33607 00005CBA 80CC10                  	OR	AH,Allowed_RETRY ; 10h	; assume ctrl p
 33608                                  
 33609 00005CBD 36F606[FE02]FF          	test	byte [ss:PFLAG],-1	; Q: has ctrl p been pressed
 33610 00005CC3 7503                    	jnz	short ctrlp		; Y: 
 33611                                  ;@@:
 33612                                  chard1:					; M024 - end
 33613                                  	; MSDOS 6.0 & MSDOS 3.3
 33614                                  
 33615                                  ; Character device error handler
 33616                                  ; Same function as HARDERR
 33617                                  
 33618                                  	;or	ah,38h
 33619 00005CC5 80CC38                  	or	ah,Allowed_IGNORE+Allowed_RETRY+Allowed_FAIL
 33620                                  ctrlp:			; SS override for Allowed and EXITHOLD
 33621 00005CC8 368826[4B03]            	mov	[SS:ALLOWED],ah
 33622                                  
 33623                                  	; 15/03/2018
 33624 00005CCD 368C06[8205]                    MOV     [SS:EXITHOLD+2],ES
 33625 00005CD2 36892E[8005]                    MOV     [SS:EXITHOLD],BP
 33626 00005CD7 56                              PUSH    SI
 33627                                  	;and	di,0FFh
 33628 00005CD8 81E7FF00                        AND     DI,STECODE
 33629 00005CDC 8CDD                            MOV     BP,DS                   ;Device pointer is BP:SI
 33630 00005CDE E86400                          CALL    FATALC
 33631 00005CE1 5E                              POP     SI
 33632                                  	;return
 33633 00005CE2 C3                              RETN
 33634                                  
 33635                                  ;---------------------------------------------------------------------------
 33636                                  ;
 33637                                  ; Procedure Name : HardErr
 33638                                  ;
 33639                                  ; Hard disk error handler. Entry conditions:
 33640                                  ;	DS:BX = Original disk transfer address
 33641                                  ;	DX = Original logical sector number
 33642                                  ;	CX = Number of sectors to go (first one gave the error)
 33643                                  ;	AX = Hardware error code
 33644                                  ;	DI = Original sector transfer count	
 33645                                  ;	ES:BP = Base of drive parameters
 33646                                  ;	[READOP] = 0 for read, 1 for write
 33647                                  ;	Allowed Set with allowed responses to this error (other bits MUST BE 0)
 33648                                  ; Output:
 33649                                  ;	[FAILERR] will be set if user responded FAIL
 33650                                  ;
 33651                                  ;--------------------------------------------------------------------------
 33652                                  
 33653                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33654                                  HARDERR:
 33655                                  	; 05/05/2019 - Retro DOS v4.0
 33656                                  	; 30/07/2018
 33657                                  	; 08/07/2018 - Retro DOS v3.0
 33658 00005CE3 97                      	XCHG    AX,DI                   ; Error code in DI, count in AX
 33659                                          ;and	di,0FFh
 33660 00005CE4 81E7FF00                	AND     DI,STECODE              ; And off status bits
 33661                                          ;CMP	DI,WRECODE		; Write Protect Error?
 33662                                  	;cmp	di,0
 33663 00005CE8 83FF00                  	cmp	DI,error_I24_write_protect ; Write Protect Error?
 33664 00005CEB 750A                            JNZ     short NOSETWRPERR
 33665 00005CED 50                              PUSH    AX
 33666                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 33667                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 33668                                          ;;MOV	AL,[ES:BP+0]
 33669                                  	; 15/12/2022
 33670 00005CEE 268A4600                	mov	al,[ES:BP]
 33671                                          	; 15/03/2018
 33672 00005CF2 36A2[2203]                      MOV     [SS:WPERR],AL		; Flag drive with WP error
 33673 00005CF6 58                              POP     AX
 33674                                  NOSETWRPERR:
 33675 00005CF7 29C8                            SUB     AX,CX                   ; Number of sectors successfully transferred
 33676 00005CF9 01C2                            ADD     DX,AX                   ; First sector number to retry
 33677 00005CFB 52                              PUSH    DX
 33678                                  	; 08/07/2018
 33679                                          ;MUL	word [ES:BP+2] 		; Number of bytes transferred
 33680 00005CFC 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE]
 33681 00005D00 5A                              POP     DX
 33682 00005D01 01C3                            ADD     BX,AX                   ; First address for retry
 33683 00005D03 30E4                            XOR     AH,AH                   ; Flag disk section in error
 33684                                          ;CMP	DX,[ES:BP+6] 		; In reserved area?
 33685 00005D05 263B5606                	CMP	DX,[ES:BP+DPB.FIRST_FAT]
 33686 00005D09 721A                            JB      SHORT ERRINT
 33687 00005D0B FEC4                            INC     AH                      ; Flag for FAT
 33688                                          ;CMP	DX,[ES:BP+10H] ; MSDOS 3.3
 33689                                  	;cmp	dx,[ES:BP+11h] ; MSDOS 6.0 - 05/05/2019 	
 33690 00005D0D 263B5611                	CMP	DX,[ES:BP+DPB.DIR_SECTOR]  ; In FAT?  
 33691 00005D11 7308                    	JAE	short TESTDIR 		; No
 33692                                  		 ; Err in FAT must force recomp of freespace
 33693                                  	;mov	word [ES:BP+1Eh],-1 ; MSDOS 3.3
 33694                                  	;mov	word [ES:BP+1Fh],-1 ; MSDOS 6.0 - 05/05/2019 
 33695 00005D13 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1
 33696 00005D19 EB0A                    	JMP	SHORT ERRINT
 33697                                  TESTDIR:
 33698 00005D1B FEC4                            INC     AH
 33699                                          ;CMP	DX,[ES:BP+0BH]		; In directory?
 33700 00005D1D 263B560B                	CMP	DX,[ES:BP+DPB.FIRST_SECTOR] 
 33701 00005D21 7202                            JB      SHORT ERRINT
 33702 00005D23 FEC4                            INC     AH                      ; Must be in data area
 33703                                  ERRINT:
 33704 00005D25 D0E4                            SHL     AH,1                    ; Make room for read/write bit
 33705 00005D27 360A26[7505]                    OR      AH,[SS:READOP] ; 15/03/2018
 33706                                  
 33707                                  	; 15/08/2018
 33708                                  					; SS override for allowed and EXITHOLD
 33709 00005D2C 360A26[4B03]            	OR	AH,[SS:ALLOWED]		; Set the allowed_ bits
 33710                                  
 33711                                          ;entry   FATAL
 33712                                  FATAL:
 33713                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 33714                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 33715                                          ;;MOV	AL,[ES:BP+0]		; Get drive number
 33716                                  	; 15/12/2022
 33717 00005D31 268A4600                	MOV	AL,[ES:BP]        
 33718                                  
 33719                                  	;entry   FATAL1
 33720                                  FATAL1:  
 33721                                  	; 15/03/2018      
 33722 00005D35 368C06[8205]            	MOV     [SS:EXITHOLD+2],ES
 33723 00005D3A 36892E[8005]                    MOV     [SS:EXITHOLD],BP	; The only things we preserve	
 33724                                  	;LES	SI,[ES:BP+12H] ; MSDOS 3.3
 33725                                  	;LES	SI,[ES:BP+13H] ; MSDOS 6.0 - 05/05/2019
 33726 00005D3F 26C47613                	LES	SI,[ES:BP+DPB.DRIVER_ADDR]
 33727 00005D43 8CC5                            MOV     BP,ES                   ; BP:SI points to the device involved
 33728                                  
 33729                                  	; DI has the INT-24-style extended error. We now map the error code 
 33730                                  	; for this into the normalized get extended error set by using the 
 33731                                  	; ErrMap24 table as a translate table. Note that we translate ONLY 
 33732                                  	; the device returned codes and leave all others beyond the look up 
 33733                                  	; table alone.
 33734                                  
 33735                                  	; 08/07/2018 - Retro DOS v3.0
 33736                                  FATALC:
 33737 00005D45 E89701                  	call	SET_I24_EXTENDED_ERROR
 33738                                  	;cmp	di,0Ch
 33739 00005D48 83FF0C                  	CMP	DI,error_I24_gen_failure
 33740 00005D4B 7603                    	JBE	short GOT_RIGHT_CODE	; Error codes above gen_failure get
 33741 00005D4D BF0C00                  	MOV	DI,error_I24_gen_failure; mapped to gen_failure. Real codes
 33742                                  					;  Only come via GetExtendedError
 33743                                  ;** ----------------------------------------------------------------
 33744                                  ;
 33745                                  ; Entry point used by REDIRector on Network I 24 errors.
 33746                                  ;
 33747                                  ;	ASSUME	DS:NOTHING,ES:NOTHING,SS:DOSDATA
 33748                                  ;
 33749                                  ; ALL I 24 regs set up. ALL Extended error info SET. ALLOWED Set.
 33750                                  ;     EXITHOLD set for restore of ES:BP.
 33751                                  ; ------------------------------------------------------------------
 33752                                  	;entry	NET_I24_ENTRY
 33753                                  NET_I24_ENTRY:
 33754                                  GOT_RIGHT_CODE:
 33755 00005D50 36803E[2003]00          	CMP     BYTE [SS:ERRORMODE],0	; No INT 24s if already INT 24
 33756 00005D56 7404                            JZ	SHORT NoSetFail
 33757 00005D58 B003                    	MOV	AL,3
 33758 00005D5A EB6C                    	JMP	short FailRet
 33759                                  NoSetFail:
 33760 00005D5C 368926[8805]                    MOV     [SS:CONTSTK],SP		; SS override
 33761 00005D61 16                              PUSH	SS
 33762 00005D62 07                              POP	ES
 33763                                      
 33764                                  	; Wango!!! We may need to free some user state info... In 
 33765                                  	; particular, we may have locked down a JFN for a user and he may 
 33766                                  	; NEVER return to us. Thus,we need to free it here and then 
 33767                                  	; reallocate it when we come back.
 33768                                  
 33769 00005D63 36833E[AA05]FF          	CMP	word [SS:SFN],-1 ; 0FFFFh
 33770 00005D69 740C                    	JZ	short _NoFree
 33771 00005D6B 1E                      	push	ds
 33772 00005D6C 56                      	push	si
 33773 00005D6D 36C536[AE05]            	LDS	SI,[SS:PJFN]
 33774 00005D72 C604FF                  	MOV	BYTE [SI],0FFH
 33775 00005D75 5E                      	pop	si
 33776 00005D76 1F                      	pop	ds
 33777                                  
 33778                                  _NoFree:
 33779 00005D77 FA                      	CLI
 33780                                  					; Prepare to play with stack
 33781 00005D78 36FE06[2003]                    INC     BYTE [SS:ERRORMODE]	; Flag INT 24 in progress
 33782 00005D7D 36FE0E[2103]                    DEC     BYTE [SS:INDOS]		; INT 24 handler might not return
 33783                                  
 33784                                  	; 05/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 33785                                  
 33786                                  	;; Extended Open hooks
 33787                                  					; AN000;IFS.I24 error disabled
 33788                                  	;test	byte [ss:EXTOPEN_ON],2
 33789 00005D82 36F606[F605]02          	TEST	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF 
 33790 00005D88 7404                    	JZ	short i24yes		; AN000;IFS.no
 33791                                  faili24:				; AN000;
 33792 00005D8A B003                    	MOV	AL,3			; AN000;IFS.fake fail
 33793 00005D8C EB29                    	JMP	short passi24 		; AN000;IFS.exit
 33794                                  i24yes: 				; AN000;
 33795                                  	;; Extended Open hooks
 33796                                  
 33797 00005D8E 368E16[8605]                    MOV     SS,[SS:USER_SS]
 33798 00005D93 268B26[8405]                    MOV     SP,[ES:USER_SP]         ; User stack pointer restored
 33799                                  
 33800                                  	;;int	24h	
 33801                                          ;IN	int_fatal_abort		; Fatal error interrupt vector,
 33802                                  					; must preserve ES
 33803                                  	; 05/05/2019
 33804 00005D98 26803E[870D]00          	cmp	byte [es:DosHasHMA], 0	; Q: is dos running in HMA (M021)
 33805 00005D9E 7504                    	jne	short do_low_int24	; Y: the int must be done from low mem
 33806 00005DA0 CD24                    	INT	int_fatal_abort 	; Fatal error interrupt vector, 
 33807                                  					; must preserve ES
 33808 00005DA2 EB05                    	jmp	short criterr_ret_addr
 33809                                  
 33810                                  do_low_int24:
 33811                                  	; 05/05/2019
 33812                                  	; MSDOS 6.0
 33813 00005DA4 2EFF1E[8B5A]            	call    far [cs:LowInt24Addr]
 33814                                  criterr_ret_addr:
 33815 00005DA9 268926[8405]                    MOV     [ES:USER_SP],SP         ; restore our stack
 33816 00005DAE 268C16[8605]                    MOV     [ES:USER_SS],SS
 33817 00005DB3 8CC5                            MOV     BP,ES
 33818 00005DB5 8ED5                            MOV     SS,BP
 33819                                  passi24:
 33820 00005DB7 368B26[8805]                    MOV     SP,[SS:CONTSTK]
 33821 00005DBC 36FE06[2103]                    INC     BYTE [SS:INDOS]		; Back in the DOS
 33822 00005DC1 36C606[2003]00                  MOV     BYTE [SS:ERRORMODE],0	; Back from INT 24
 33823 00005DC7 FB                              STI
 33824                                  FailRet:
 33825 00005DC8 36C42E[8005]                    LES     BP,[SS:EXITHOLD]
 33826                                  	
 33827                                  	; 08/07/2018
 33828                                  
 33829                                  	; Triage the user's reply.
 33830                                  
 33831 00005DCD 3C01                    	CMP	AL,1
 33832 00005DCF 723D                    	JB	short CheckIgnore	; 0 => ignore
 33833 00005DD1 7445                    	JZ	short CheckRetry	; 1 => retry
 33834 00005DD3 3C03                    	CMP	AL,3			; 3 => fail
 33835 00005DD5 754B                    	JNZ	short DoAbort 		; 2, invalid => abort
 33836                                  
 33837                                  	; The reply was fail. See if we are allowed to fail.
 33838                                  
 33839                                  				; SS override for ALLOWED, EXTOPEN_ON, 
 33840                                  				; ALLOWED, FAILERR, WPERR, SFN, pJFN
 33841                                  	;test	byte [ss:ALLOWED],8
 33842 00005DD7 36F606[4B03]08          	test	byte [ss:ALLOWED],Allowed_FAIL ; Can we?
 33843 00005DDD 7443                    	jz	short DoAbort	; No, do abort
 33844                                  DoFail:
 33845 00005DDF B003                    	MOV	AL,3		; just in case...
 33846                                  				; AN000;EO. I24 error disabled
 33847                                  	; 05/05/2019
 33848                                  	;(MSDOS 6.0, MSCTRLC.ASM, 1991)
 33849 00005DE1 36F606[F605]02          	test	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF ; 2
 33850 00005DE7 7505                    	jnz	short CleanUp 		; AN000;EO. no
 33851                                  	
 33852 00005DE9 36FE06[4A03]            	inc	byte [SS:FAILERR]	; Tell everybody
 33853                                  CleanUp:
 33854 00005DEE 36C606[2203]FF          	MOV	byte [SS:WPERR],-1
 33855 00005DF4 36833E[AA05]FF          	CMP	word [SS:SFN],-1
 33856                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 33857                                  	;jnz	short CleanUp2
 33858                                  	;retn
 33859                                  	; 17/12/2022
 33860 00005DFA 7411                    	jz	short Cleanup_retn ; 08/07/2018 - Retro DOS v3.0
 33861                                  CleanUp2:
 33862 00005DFC 1E                      	push	ds
 33863 00005DFD 56                      	push	si
 33864 00005DFE 50                      	push	ax
 33865 00005DFF 36A1[AA05]              	MOV	AX,[ss:SFN]
 33866 00005E03 36C536[AE05]            	LDS	SI,[ss:PJFN]
 33867 00005E08 8804                    	MOV	[SI],AL
 33868 00005E0A 58                      	pop	ax
 33869 00005E0B 5E                      	pop	si
 33870 00005E0C 1F                      	pop	ds
 33871                                  Cleanup_retn:
 33872 00005E0D C3                      	retn
 33873                                  
 33874                                  	; The reply was IGNORE. See if we are allowed to ignore.
 33875                                  
 33876                                  CheckIgnore:
 33877                                  	;test	byte [ss:ALLOWED],20h
 33878 00005E0E 36F606[4B03]20          	test	byte [ss:ALLOWED],Allowed_IGNORE ; Can we?
 33879 00005E14 74C9                    	jz	short DoFail			 ; No, do fail
 33880 00005E16 EBD6                    	jmp	short CleanUp
 33881                                  
 33882                                  	; The reply was RETRY. See if we are allowed to retry.
 33883                                  
 33884                                  CheckRetry:
 33885                                  	;test	byte [ss:ALLOWED],10h
 33886 00005E18 36F606[4B03]10          	test	byte [ss:ALLOWED],Allowed_RETRY	; Can we?
 33887 00005E1E 74BF                    	jz	short DoFail			; No, do fail
 33888 00005E20 EBCC                    	JMP	short CleanUp
 33889                                  
 33890                                  	; The reply was ABORT.
 33891                                  DoAbort:
 33892 00005E22 16                      	push	ss
 33893 00005E23 1F                      	pop	ds
 33894                                  
 33895 00005E24 803E[5703]00            	CMP	byte [CONSWAP],0
 33896 00005E29 7403                    	JZ	short NOSWAP2
 33897 00005E2B E830DD                  	call	SWAPBACK
 33898                                  NOSWAP2:
 33899                                  	; See if we are to truly abort. If we are in the process of aborting, 
 33900                                  	; turn this abort into a fail.
 33901                                  
 33902                                  	;test	[fAborting],0FFh
 33903                                  	;jnz	short DoFail
 33904                                  
 33905 00005E2E 803E[5903]00            	cmp	byte [fAborting],0
 33906 00005E33 75AA                    	JNZ	short DoFail
 33907                                  
 33908                                  	; Set return code
 33909                                  
 33910 00005E35 C606[7C05]02            	MOV	BYTE [EXIT_TYPE],EXIT_HARD_ERROR ; 2
 33911 00005E3A 30C0                    	XOR	AL,AL
 33912                                  
 33913                                  	; we are truly aborting the process. Go restore information from 
 33914                                  	; the PDB as necessary.
 33915                                  
 33916 00005E3C E9BF0D                  	jmp	exit_inner
 33917                                  
 33918                                  ;** --------------------------------------------------------------------------
 33919                                  ;
 33920                                  ; reset_environment checks the DS value against the CurrentPDB. If they are
 33921                                  ; different, then an old-style return is performed. If they are the same,
 33922                                  ; then we release jfns and restore to parent. We still use the PDB at DS:0 as
 33923                                  ; the source of the terminate addresses.
 33924                                  ;
 33925                                  ; Some subtlety: We are about to issue a bunch of calls that *may* generate
 33926                                  ; INT 24s. We *cannot* allow the user to restart the abort process; we may
 33927                                  ; end up aborting the wrong process or turn a terminate/stay/resident into a
 33928                                  ; normal abort and leave interrupt handlers around. What we do is to set a
 33929                                  ; flag that will indicate that if any abort code is seen, we just continue the
 33930                                  ; operation. In essence, we dis-allow the abort response.
 33931                                  ;
 33932                                  ; output:   none.
 33933                                  ; ----------------------------------------------------------------------------
 33934                                  
 33935                                  	;entry	reset_environment
 33936                                  	
 33937                                  reset_environment:
 33938                                  	; 30/07/2018 - Retro DOS v3.0
 33939                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 588Ah 
 33940                                  
 33941                                  ;***	invoke	Reset_Version		; AN007 ;MS. reset version number
 33942                                  
 33943 00005E3F 1E                      	PUSH	DS			; save PDB of process
 33944                                  
 33945                                  	; There are no critical sections in force. Although we may enter 
 33946                                  	; here with critical sections locked down, they are no longer 
 33947                                  	; relevant. We may safely free all allocated resources.
 33948                                  
 33949 00005E40 B482                    	MOV	AH,82h
 33950                                  		; Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7
 33951                                  	;int	2Ah 	
 33952 00005E42 CD2A                    	INT	int_IBM
 33953                                  
 33954                                  					; SS override
 33955 00005E44 36C606[5903]FF          	MOV	byte [SS:fAborting],-1	; signal abort in progress
 33956                                  
 33957                                  					; DOS 4.00 doesn't need it
 33958                                  	;CallInstall NetResetEnvironment, MultNET, 34  
 33959                                  					; Allow REDIR to clear some stuff
 33960                                  					; On process exit.
 33961 00005E4A B82211                  	mov     ax, 1122h
 33962 00005E4D CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
 33963                                  			; SS = DOS CS
 33964                                  	;mov	al,22h	
 33965 00005E4F B022                    	MOV	AL,int_terminate
 33966 00005E51 E82DB1                  	call	_$GET_INTERRUPT_VECTOR	; and who to go to
 33967                                  
 33968 00005E54 59                      	POP	CX			; get ThisPDB
 33969 00005E55 06                      	push	es
 33970 00005E56 53                      	push	bx			; save return address
 33971                                  
 33972 00005E57 368B1E[3003]            	MOV	BX,[SS:CurrentPDB] 	; get currentPDB
 33973 00005E5C 8EDB                    	MOV	DS,BX
 33974 00005E5E A11600                  	MOV	AX,[PDB.PARENT_PID]	; get parentPDB
 33975                                  
 33976                                  	; AX = parentPDB, BX = CurrentPDB, CX = ThisPDB
 33977                                  	; Only free handles if AX <> BX and BX = CX and [exit_code].upper 
 33978                                  	; is not Exit_keep_process
 33979                                  	
 33980 00005E61 39D8                    	CMP	AX,BX
 33981 00005E63 7418                    	JZ	short reset_return	; parentPDB = CurrentPDB
 33982 00005E65 39CB                    	CMP	BX,CX
 33983 00005E67 7514                    	JNZ	short reset_return	; CurrentPDB <> ThisPDB
 33984 00005E69 50                      	PUSH	AX			; save parent
 33985                                  
 33986                                  					; SS override
 33987                                  	;cmp	byte [SS:EXIT_TYPE],3
 33988 00005E6A 36803E[7C05]03          	CMP	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS ; 15/08/2018
 33989 00005E70 7406                    	JZ	short reset_to_parent 	; keeping this process
 33990                                  
 33991                                  	; We are truly removing a process. Free all allocation blocks 
 33992                                  	; belonging to this PDB
 33993                                  
 33994                                  	;invoke	arena_free_process
 33995 00005E72 E8C10D                  	call	arena_free_process
 33996                                  
 33997                                  	; Kill off remainder of this process. Close file handles and signal 
 33998                                  	; to relevant network folks that this process is dead. Remember that 
 33999                                  	; CurrentPDB is STILL the current process!
 34000                                  
 34001                                  	;invoke	DOS_ABORT
 34002 00005E75 E85ED8                  	call	DOS_ABORT
 34003                                  
 34004                                  reset_to_parent:
 34005                                  					; SS override
 34006 00005E78 368F06[3003]            	POP	word [SS:CurrentPDB]	; set up process as parent
 34007                                  
 34008                                  reset_return:				; come here for normal return
 34009                                  	;Context DS			; DS is used to refer to DOSDATA  
 34010 00005E7D 16                      	push	ss
 34011 00005E7E 1F                      	pop	ds	
 34012                                  
 34013 00005E7F B0FF                    	MOV	AL,-1
 34014                                  
 34015                                  	; make sure that everything is clean In this case ignore any errors, 
 34016                                  	; we cannot "FAIL" the abort, the program being aborted is dead.
 34017                                  
 34018                                  	;EnterCrit critDisk
 34019 00005E81 E87FBA                  	call	ECritDisk
 34020                                  	;invoke	FLUSHBUF
 34021 00005E84 E8D305                  	call	FLUSHBUF
 34022                                  	;LeaveCrit critDisk
 34023 00005E87 E8A6BA                  	call	LCritDisk
 34024                                  
 34025                                  	; Decrement open ref. count if we had done a virtual open earlier.
 34026                                  
 34027 00005E8A E883F7                  	call	CHECK_VIRT_OPEN
 34028 00005E8D FA                      	CLI
 34029 00005E8E C606[2103]00            	MOV	BYTE [INDOS],0		; Go to known state
 34030 00005E93 C606[2203]FF            	MOV	BYTE [WPERR],-1		; Forget about WP error
 34031 00005E98 C606[5903]00            	MOV	byte [fAborting],0	; let aborts occur
 34032 00005E9D 8F06[8005]              	POP	WORD [EXITHOLD]
 34033 00005EA1 8F06[8205]              	POP	WORD [EXITHOLD+2]
 34034                                  
 34035                                  	; Snake into multitasking... Get stack from CurrentPDB person
 34036                                  
 34037 00005EA5 8E1E[3003]              	MOV	DS,[CurrentPDB]
 34038 00005EA9 8E163000                	MOV	SS,[PDB.USER_STACK+2]
 34039 00005EAD 8B262E00                	MOV	SP,[PDB.USER_STACK]
 34040                                  
 34041 00005EB1 E88DA5                  	call	restore_world
 34042                                  
 34043                                  	; 05/05/2019
 34044 00005EB4 07                      	pop	es ; * ; MSDOS 6.21 (DOSCODE:94A8h, MSDOS.SYS)
 34045                                  
 34046                                  	; MSDOS 6.0
 34047 00005EB5 50                      	push	ax			; set up ds, but save ds in TEMPSEG 
 34048 00005EB6 8CD8                    	mov	ax,ds			; and not on stack.
 34049                                  	;getdseg <ds>			; ds -> dosdata
 34050 00005EB8 2E8E1E[0700]            	mov	ds,[cs:DosDSeg] 
 34051 00005EBD A3[840D]                	mov	[TEMPSEG],ax
 34052 00005EC0 58                      	pop	ax
 34053                                  					; set up ds to DOSDATA
 34054                                  	;MOV	[CS:USER_SP],AX ; MSDOS 3.3
 34055 00005EC1 A3[8405]                	mov	[USER_SP],ax
 34056                                  
 34057 00005EC4 58                      	POP	AX			; suck off CS:IP of interrupt...
 34058 00005EC5 58                      	POP	AX
 34059 00005EC6 58                      	POP	AX
 34060                                  
 34061                                  ; M011 : BEGIN
 34062                                  
 34063                                  	; MSDOS 3.3
 34064                                  ;	MOV	AX,0F202h	; STI
 34065                                  
 34066                                  	; MSDOS 6.0
 34067 00005EC7 9F                      	LAHF
 34068 00005EC8 86E0                    	XCHG	AH,AL
 34069 00005ECA 2402                    	AND	AL,2
 34070 00005ECC B4F2                    	MOV	AH,0F2h
 34071                                  
 34072                                  ; M011 : END
 34073                                  
 34074                                  	; MSDOS 3.3 (& MSDOS 6.0)
 34075 00005ECE 50                      	PUSH	AX
 34076                                   
 34077                                  	;PUSH	word [CS:EXITHOLD+2]
 34078                                  	;PUSH	word [CS:EXITHOLD]
 34079                                  	
 34080                                  	; MSDOS 6.0
 34081 00005ECF FF36[8205]              	PUSH	word [EXITHOLD+2]
 34082 00005ED3 FF36[8005]              	PUSH	word [EXITHOLD]
 34083                                  
 34084                                  	;MOV	AX,[CS:USER_SP]
 34085                                  
 34086                                  	; MSDOS 6.0
 34087 00005ED7 A1[8405]                	MOV	AX,[USER_SP]
 34088 00005EDA 8E1E[840D]              	mov	ds,[TEMPSEG]	; restore ds
 34089                                  
 34090 00005EDE CF                      	IRET			; Long return back to user terminate address
 34091                                  
 34092                                  ;---------------------------------------------------------------------------
 34093                                  ;
 34094                                  ; Procedure Name : SET_I24_EXTENDED_ERROR
 34095                                  ;
 34096                                  ; This routine handles extended error codes.
 34097                                  ; Input : DI = error code from device
 34098                                  ; Output: All EXTERR fields are set
 34099                                  ;
 34100                                  ;--------------------------------------------------------------------------
 34101                                  
 34102                                  SET_I24_EXTENDED_ERROR:
 34103 00005EDF 50                      	PUSH	AX
 34104                                  					; ErrMap24End is in DOSDATA
 34105 00005EE0 B8[020F]                	MOV	AX,ErrMap24End
 34106 00005EE3 2D[F20E]                	SUB	AX,ErrMap24
 34107                                  					; Change to dosdata to access 
 34108                                  					; ErrMap24 and EXTERR -SR
 34109                                  	; 05/05/2019 - Retro DOS v4.0
 34110                                  	
 34111                                  	; MSDOS 6.0
 34112 00005EE6 1E                      	push	ds
 34113                                  	;getdseg <ds>			; ds ->dosdata
 34114 00005EE7 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 34115                                  
 34116                                  	; AX is the index of the first unavailable error. Do not translate 
 34117                                  	; if greater or equal to AX.
 34118                                  
 34119 00005EEC 39C7                    	CMP	DI,AX
 34120 00005EEE 89F8                    	MOV	AX,DI
 34121 00005EF0 7306                    	JAE	short NoTrans
 34122                                  
 34123                                  	;MOV	AL,[CS:DI+ErrMap24]  ; MSDOS 3.3
 34124 00005EF2 8A85[F20E]              	mov	al,[ErrMap24+di] ; MSDOS 6.0
 34125 00005EF6 30E4                    	XOR	AH,AH
 34126                                  NoTrans:
 34127                                  	;MOV	[CS:EXTERR],AX
 34128 00005EF8 A3[2403]                	mov	[EXTERR],AX
 34129 00005EFB 1F                      	pop	ds
 34130                                  	;assume	ds:nothing
 34131 00005EFC 58                      	POP	AX
 34132                                  
 34133                                  	; Now Extended error is set correctly. Translate it to get correct 
 34134                                  	; error locus class and recommended action.
 34135                                  
 34136 00005EFD 56                      	PUSH	SI
 34137                                  					; ERR_TABLE_24 is in DOSCODE 
 34138 00005EFE BE[A20E]                	MOV	SI,ERR_TABLE_24
 34139 00005F01 E8AFA7                  	call	CAL_LK			; Set other extended error fields
 34140 00005F04 5E                      	POP	SI
 34141 00005F05 C3                      	retn
 34142                                  
 34143                                  ;============================================================================
 34144                                  ; FAT.ASM, MSDOS 6.0, 1991
 34145                                  ;============================================================================
 34146                                  ; 30/07/2018 - Retro DOS v3.0
 34147                                  ; 20/05/2019 - Retro DOS v4.0
 34148                                  
 34149                                  ;	TITLE	FAT - FAT maintenance routines
 34150                                  ;	NAME	FAT
 34151                                  
 34152                                  ;**	FAT.ASM
 34153                                  ;----------------------------------------------------------------------------
 34154                                  ;	Low level local device routines for performing disk change sequence,
 34155                                  ;	setting cluster validity, and manipulating the FAT
 34156                                  ;
 34157                                  ;	IsEof
 34158                                  ;	UNPACK
 34159                                  ;	PACK
 34160                                  ;	MAPCLUSTER
 34161                                  ;	FATREAD_SFT
 34162                                  ;	FATREAD_CDS
 34163                                  ;	FAT_operation
 34164                                  ;
 34165                                  ;	Revision history:
 34166                                  ;
 34167                                  ;	  AN000  version Jan. 1988
 34168                                  ;	   A001  PTM	      -- disk changed for look ahead buffers
 34169                                  ;
 34170                                  ;	M014 - if a request for pack\unpack cluster 0 is made we write\read
 34171                                  ;	       from CL0FATENTRY rather than disk.
 34172                                  
 34173                                  ; DOSCODE:94FAh (MSDOS 6.21, MSDOS.SYS)
 34174                                  
 34175                                  ;Break <IsEOF - check the quantity in BX for EOF>
 34176                                  ;----------------------------------------------------------------------------
 34177                                  ;
 34178                                  ; Procedure Name : IsEOF
 34179                                  ;
 34180                                  ; IsEOF - check the fat value in BX for eof.
 34181                                  ;
 34182                                  ;   Inputs:	ES:BP point to DPB
 34183                                  ;		BX has fat value
 34184                                  ;   Outputs:	JAE eof
 34185                                  ;   Registers modified: none
 34186                                  ;
 34187                                  ;---------------------------------------------------------------------------
 34188                                  
 34189                                  IsEOF:
 34190                                  	;cmp	word [es:bp+0Dh],0FF6h
 34191 00005F06 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; is this 16 bit fat?
 34192 00005F0C 730B                    	JAE	short EOF16			; yes, check for eof there
 34193                                  
 34194                                  ;J.K. 8/27/86
 34195                                  ;Modified to accept 0FF0h as an eof. This is to handle the diskfull case
 34196                                  ;of any media that has "F0"(Other) as a MediaByte.
 34197                                  ;Hopely, this does not create any side effect for those who may use any value
 34198                                  ;other than "FF8-FFF" as an EOF for their own file.
 34199                                  
 34200 00005F0E 81FBF00F                	cmp	bx,0FF0h
 34201 00005F12 7404                    	je	short IsEOF_other
 34202                                  
 34203 00005F14 81FBF80F                	CMP	BX,0FF8h		; do the 12 bit compare
 34204                                  IsEOF_other:
 34205 00005F18 C3                      	retn
 34206                                  EOF16:
 34207 00005F19 83FBF8                  	CMP	BX,0FFF8h		; 16 bit compare
 34208 00005F1C C3                      	retn
 34209                                  
 34210                                  ; DOSCODE:9511h (MSDOS 6.21, MSDOS.SYS)
 34211                                  
 34212                                  ;Break	<UNPACK -- UNPACK FAT ENTRIES>
 34213                                  ;---------------------------------------------------------------------------
 34214                                  ;
 34215                                  ; Procedur Name : UNPACK
 34216                                  ;
 34217                                  ; Inputs:
 34218                                  ;	BX = Cluster number (may be full 16-bit quantity)
 34219                                  ;	ES:BP = Base of drive parameters
 34220                                  ; Outputs:
 34221                                  ;	DI = Contents of FAT for given cluster (may be full 16-bit quantity)
 34222                                  ;	Zero set means DI=0 (free cluster)
 34223                                  ;	Carry set means error (currently user FAILed to I 24)
 34224                                  ; SI Destroyed, No other registers affected. Fatal error if cluster too big.
 34225                                  ;
 34226                                  ; NOTE: if BX = 0 then DI = contents of CL0FATENTRY
 34227                                  ;
 34228                                  ;----------------------------------------------------------------------------
 34229                                  	
 34230                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34231                                  	; DOSCODE:94B5h (MSDOS 5.0, MSDOS.SYS)
 34232                                  
 34233                                  	; 20/05/2019 - Retro DOS v4.0
 34234                                  UNPACK:
 34235                                  	; MSDOS 6.0			; M014 - Start
 34236 00005F1D 09DB                    	or	bx, bx			; Q: are we unpacking cluster 0
 34237 00005F1F 7507                    	jnz	short up_cont		; N: proceed with normal unpack
 34238 00005F21 8B3E[8100]              	mov	di,[CL0FATENTRY]	; Y: return value in CL0FATENTRY
 34239 00005F25 09FF                    	or	di,di 			; return z if di=0
 34240 00005F27 C3                      	retn				; done
 34241                                  up_cont:				; M014 - End
 34242                                  	; MSDOS 3.3 & MSDOS 6.0
 34243                                  	;cmp	bx,[es:bp+0Dh]
 34244 00005F28 263B5E0D                	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 34245 00005F2C 7726                    	JA	short HURTFAT
 34246 00005F2E E8D600                  	CALL	MAPCLUSTER
 34247 00005F31 721E                    	jc	short _DoContext
 34248 00005F33 8B3D                    	MOV	DI,[DI]
 34249 00005F35 750E                    	JNZ	short High12		; MZ if high 12 bits, go get 'em
 34250 00005F37 268B760D                	MOV	SI,[ES:BP+DPB.MAX_CLUSTER] ; MZ is this 16-bit fat?
 34251 00005F3B 81FEF60F                	CMP	SI,4096-10
 34252 00005F3F 720C                    	JB	short Unpack12		; MZ No, go 'AND' off bits
 34253 00005F41 09FF                    	OR	DI,DI			; MZ set zero condition code, clears carry
 34254 00005F43 EB0C                    	JMP	SHORT _DoContext 	; MZ go do context
 34255                                  High12:
 34256 00005F45 D1EF                    	SHR	DI,1
 34257 00005F47 D1EF                    	SHR	DI,1
 34258 00005F49 D1EF                    	SHR	DI,1
 34259 00005F4B D1EF                    	SHR	DI,1
 34260                                  Unpack12:
 34261 00005F4D 81E7FF0F                	AND	DI,0FFFh		; Clears carry
 34262                                  _DoContext:
 34263 00005F51 16                      	PUSH	SS
 34264 00005F52 1F                      	POP	DS
 34265 00005F53 C3                      	retn
 34266                                  HURTFAT:
 34267                                  	;;mov	word [es:bp+1Eh],0FFFFh
 34268                                  	;mov	word [es:bp+1Fh],0FFFFh  ; MSDOS 6.0
 34269 00005F54 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; Err in FAT must force recomp of freespace
 34270 00005F5A 50                      	PUSH	AX
 34271 00005F5B B488                    	MOV	AH,Allowed_FAIL+80h ; 88h
 34272                                  
 34273                                  ;hkn; SS override
 34274 00005F5D 36C606[4B03]08          	MOV	byte [SS:ALLOWED],Allowed_FAIL ; 8
 34275                                  ;
 34276                                  ; Signal Bad FAT to INT int_fatal_abort handler. We have an invalid cluster.
 34277                                  ;
 34278 00005F63 BFFF0F                  	MOV	DI,0FFFh		; In case INT int_fatal_abort returns (it shouldn't)
 34279 00005F66 E8C8FD                  	call	FATAL
 34280 00005F69 3C03                    	CMP	AL,3
 34281 00005F6B F8                      	CLC
 34282 00005F6C 7501                    	JNZ	short OKU_RET 		; Try to ignore bad FAT
 34283 00005F6E F9                      	STC				; User said FAIL
 34284                                  OKU_RET:
 34285 00005F6F 58                      	POP	AX
 34286                                  hurtfat_retn:
 34287 00005F70 C3                      	retn
 34288                                  
 34289                                  ; DOSCODE:9565h (MSDOS 6.21, MSDOS.SYS)
 34290                                  
 34291                                  ;Break	<PACK -- PACK FAT ENTRIES>
 34292                                  ;----------------------------------------------------------------------------
 34293                                  ;
 34294                                  ; Procedure Name : PACK
 34295                                  ;
 34296                                  ; Inputs:
 34297                                  ;	BX = Cluster number
 34298                                  ;	DX = Data
 34299                                  ;	ES:BP = Pointer to drive DPB
 34300                                  ; Outputs:
 34301                                  ;	The data is stored in the FAT at the given cluster.
 34302                                  ;	SI,DX,DI all destroyed
 34303                                  ;	Carry set means error (currently user FAILed to I 24)
 34304                                  ;	No other registers affected
 34305                                  ;
 34306                                  ; NOTE: if BX = 0 then data in DX is stored in CL0FATENTRY.
 34307                                  ;
 34308                                  ;---------------------------------------------------------------------------
 34309                                  
 34310                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34311                                  	; 20/05/2019 - Retro DOS v4.0
 34312                                  PACK:
 34313                                  	; MSDOS 6.0			; M014 - start
 34314 00005F71 09DB                    	or	bx,bx			; Q: are we packing cluster 0
 34315 00005F73 7505                    	jnz	short p_cont		; N: proceed with normal pack
 34316 00005F75 8916[8100]              	mov	[CL0FATENTRY],dx	; Y: place value in CL0FATENTRY
 34317 00005F79 C3                      	retn				; done
 34318                                  p_cont:					; M014 - end
 34319                                  	; MSDOS 3.3 & MSDOS 6.0
 34320 00005F7A E88A00                  	CALL	MAPCLUSTER
 34321 00005F7D 72D2                    	JC	short _DoContext
 34322 00005F7F 8B35                    	MOV	SI,[DI]
 34323 00005F81 740B                    	JZ	short ALIGNED 		; byte (not nibble) aligned
 34324 00005F83 51                      	PUSH	CX			; move data to upper 12 bits
 34325 00005F84 B104                    	MOV	CL,4
 34326 00005F86 D3E2                    	SHL	DX,CL
 34327 00005F88 59                      	POP	CX
 34328 00005F89 83E60F                  	AND	SI,0FH			; leave in original low 4 bits
 34329 00005F8C EB14                    	JMP	SHORT PACKIN
 34330                                  ALIGNED:
 34331                                  	;cmp	word [es:bp+0Dh],0FF6h
 34332 00005F8E 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ 16 bit fats?
 34333 00005F94 730A                    	JAE	short Pack16		; MZ yes, go clobber original data
 34334 00005F96 81E600F0                	AND	SI,0F000h		; MZ leave in upper 4 bits of original
 34335 00005F9A 81E2FF0F                	AND	DX,0FFFh		; MZ store only 12 bits
 34336 00005F9E EB02                    	JMP	SHORT PACKIN		; MZ go store
 34337                                  Pack16:
 34338 00005FA0 31F6                    	XOR	SI,SI			; MZ no original data
 34339                                  PACKIN:
 34340 00005FA2 09D6                    	OR	SI,DX
 34341 00005FA4 8935                    	MOV	[DI],SI
 34342                                  
 34343                                  ;hkn; SS override
 34344 00005FA6 36C536[E205]            	LDS	SI,[SS:CURBUF]
 34345                                  	; MSDOS 6.0
 34346 00005FAB F6440540                	TEST	byte [SI+BUFFINFO.buf_flags],buf_dirty
 34347                                  					;LB. if already dirty		  ;AN000;
 34348 00005FAF 7507                    	JNZ	short yesdirty11	;LB.  don't increment dirty count ;AN000;
 34349                                  	; 10/06/2019
 34350 00005FB1 E8B705                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 34351                                  	
 34352                                  	;or	byte [si+5],40h
 34353 00005FB4 804C0540                	OR	byte [SI+BUFFINFO.buf_flags],buf_dirty
 34354                                  yesdirty11:				;LB.				;AN000;
 34355                                  ;hkn; SS override
 34356 00005FB8 36803E[7805]00          	CMP	BYTE [SS:CLUSSPLIT],0	; 15/08/2018
 34357                                  ;hkn; SS is DOSDATA
 34358 00005FBE 16                      	push	ss
 34359 00005FBF 1F                      	pop	ds
 34360 00005FC0 74AE                    	jz	short hurtfat_retn	; Carry clear
 34361 00005FC2 50                      	PUSH	AX
 34362 00005FC3 53                      	PUSH	BX
 34363 00005FC4 51                      	PUSH	CX
 34364 00005FC5 A1[8E05]                	MOV	AX,[CLUSSAVE]
 34365 00005FC8 8E1E[E405]              	MOV	DS,[CURBUF+2]
 34366                                  	;;;add	si,16 ; MSDOS 3.3
 34367                                  	;;add	si,20 ; MSDOS 6.0
 34368                                  	; 02/01/2024
 34369                                  	;add	si,24 ; PCDOS 7.1 
 34370 00005FCC 83C618                  	ADD	SI,BUFINSIZ
 34371 00005FCF 8824                    	MOV	[SI],AH
 34372                                  ;hkn; SS is DOSDATA
 34373                                  	;Context DS
 34374 00005FD1 16                      	push	ss
 34375 00005FD2 1F                      	pop	ds
 34376                                  	
 34377 00005FD3 50                      	PUSH	AX
 34378                                  	
 34379                                  	; MSDOS 6.0
 34380 00005FD4 8B16[9205]              	MOV	DX,[CLUSSEC+2]		;F.C. >32mb			;AN000;
 34381 00005FD8 8916[0706]              	MOV	[HIGH_SECTOR],DX	;F.C. >32mb			;AN000;
 34382                                  
 34383                                  	; MSDOS 3.3 & MSDOS 6.0
 34384 00005FDC 8B16[9005]              	MOV	DX,[CLUSSEC]
 34385                                  
 34386                                  	;MOV	SI,1	  ; *
 34387                                  	;XOR	AL,AL     ; *
 34388                                  	;call	GETBUFFRB ; *
 34389                                  	; 22/09/2023
 34390 00005FE0 E86C03                  	call	GETBUFFRA ; *
 34391                                  
 34392 00005FE3 58                      	POP	AX
 34393 00005FE4 721B                    	JC	short POPP_RET
 34394 00005FE6 C53E[E205]              	LDS	DI,[CURBUF]
 34395                                  	
 34396                                  	; MSDOS 6.0
 34397 00005FEA F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
 34398                                  					;LB. if already dirty		  ;AN000;
 34399 00005FEE 7507                    	JNZ	short yesdirty12	;LB.  don't increment dirty count ;AN000;
 34400 00005FF0 E87805                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 34401                                  	
 34402                                  	;or	byte [di+5],40h
 34403 00005FF3 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty 
 34404                                  yesdirty12:
 34405                                  	;;;add	di,16
 34406                                  	;;add	di,20 ; MSDOS 6.0
 34407                                  	;ADD	DI,BUFINSIZ
 34408                                  	;DEC	DI
 34409                                  	; 02/01/2024 - Retro DOS v5.0
 34410                                  	;add	di,23 ; PCDOS 7.1
 34411 00005FF7 83C717                  	add	di,BUFINSIZ-1 ; 23 ; PCDOS 7.1 IBMDOS.COM
 34412                                  	
 34413                                  	;add	di,[es:bp+2]
 34414 00005FFA 26037E02                	ADD	DI,[ES:BP+DPB.SECTOR_SIZE]
 34415 00005FFE 8805                    	MOV	[DI],AL
 34416 00006000 F8                      	CLC
 34417                                  POPP_RET:
 34418 00006001 16                      	PUSH	SS
 34419 00006002 1F                      	POP	DS
 34420 00006003 59                      	POP	CX
 34421 00006004 5B                      	POP	BX
 34422 00006005 58                      	POP	AX
 34423 00006006 C3                      	retn
 34424                                  
 34425                                  ; 31/07/2018 - Retro DOS v3.0
 34426                                  
 34427                                  ;Break	<MAPCLUSTER - BUFFER A FAT SECTOR>
 34428                                  ;---------------------------------------------------------------------------
 34429                                  ;
 34430                                  ; Procedure Name : MAPCLUSTER
 34431                                  ;
 34432                                  ; Inputs:
 34433                                  ;	ES:BP Points to DPB
 34434                                  ;	BX Is cluster number
 34435                                  ; Function:
 34436                                  ;	Get a pointer to the cluster
 34437                                  ; Outputs:
 34438                                  ;	DS:DI Points to contents of FAT for given cluster
 34439                                  ;	DS:SI Points to start of buffer
 34440                                  ;	Zero Not set if cluster data is in high 12 bits of word
 34441                                  ;	Zero set if cluster data is in low 12 or 16 bits
 34442                                  ;	Carry set if failed.
 34443                                  ; SI is destroyed.
 34444                                  ;
 34445                                  ;---------------------------------------------------------------------------
 34446                                  
 34447                                  	; 20/05/2019 - Retro DOS v4.0
 34448                                  	; DOSCODE:9601h (MSDOS 6.21, MSDOS.SYS)
 34449                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34450                                  	; DOSCODE:95A5h (MSDOS 5.0, MSDOS.SYS)
 34451                                  
 34452                                  MAPCLUSTER:
 34453                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5A15h
 34454 00006007 C606[7805]00            	MOV	BYTE [CLUSSPLIT],0
 34455                                  	;SAVE	<AX,BX,CX,DX>
 34456 0000600C 50                      	push	ax
 34457 0000600D 53                      	push	bx
 34458 0000600E 51                      	push	cx
 34459 0000600F 52                      	push	dx
 34460 00006010 89D8                    	MOV	AX,BX			; AX = BX
 34461 00006012 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10  ; MZ 16 bit fat?
 34462 00006018 7302                    	JAE	short Map16		; MZ yes, do 16 bit algorithm
 34463 0000601A D1E8                    	SHR	AX,1			; AX = BX/2
 34464                                  Map16:	
 34465                                  	; MSDOS 6.0			; MZ skip prev => AX=2*BX
 34466 0000601C 31FF                    	XOR	DI,DI ; *		; >32mb fat ;AN000;
 34467                                  	; MSDOS 3.3 (& MSDOS 6.0)
 34468 0000601E 01D8                    	ADD	AX,BX			; AX = 1.5*fat = byte offset in fat
 34469 00006020 11FF                    	ADC	DI,DI ; * MSDOS 6.0	; >32mb fat ;DI is zero before op;AN000;
 34470 00006022 268B4E02                	MOV	CX,[ES:BP+DPB.SECTOR_SIZE]
 34471                                  
 34472                                  ;IF FastDiv
 34473                                  ;
 34474                                  ; Gross hack: 99% of all disks have 512 bytes per sector. We test for this
 34475                                  ; case and apply a really fast algorithm to get the desired results
 34476                                  ;
 34477                                  ; Divide method takes 157+4*4=173 (MOV and DIV)
 34478                                  ; Fast method takes 39+20*4=119
 34479                                  ;
 34480                                  ; This saves a bunch.
 34481                                  
 34482 00006026 81F90002                	CMP	CX,512			; 4  Is this 512 byte sector?
 34483 0000602A 7510                    	jne	short _DoDiv		; 4  for no jump
 34484 0000602C 89C2                    	MOV	DX,AX			; 2  get set for remainder
 34485 0000602E 81E2FF01                	AND	DX,512-1		; 4  Form remainder
 34486 00006032 88E0                    	MOV	AL,AH			; 2  Quotient in formation in AL
 34487                                  	; MDOS 3.3
 34488                                  	;shr	al,1	
 34489                                  	; MDOS 6.0
 34490 00006034 D1EF                    	shr	di,1			; 2
 34491 00006036 D0D8                    	rcr	al,1			; 2
 34492                                  	; MDOS 3.3 (& MSDOS 6.0)
 34493 00006038 30E4                    	xor	ah,ah			; 3
 34494 0000603A EB04                    	jmp	short DivDone		; 16
 34495                                  _DoDiv:
 34496                                  ;ENDIF
 34497                                  	; MSDOS 3.3
 34498                                  	;xor	dx,dx
 34499                                  	; MSDOS 6.0
 34500 0000603C 89FA                    	mov	dx,di			; 2
 34501                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 34502 0000603E F7F1                    	DIV	CX			; 155 AX is FAT sector # DX is sector index
 34503                                  ;IF FastDiv
 34504                                  DivDone:
 34505                                  ;ENDIF
 34506                                  	;add	ax,[es:bp+6]
 34507 00006040 26034606                	ADD	AX,[ES:BP+DPB.FIRST_FAT]
 34508 00006044 49                      	DEC	CX			; CX is sector size - 1
 34509                                  	;SAVE	<AX,DX,CX>
 34510 00006045 50                      	push	ax
 34511 00006046 52                      	push	dx
 34512 00006047 51                      	push	cx
 34513 00006048 89C2                    	MOV	DX,AX
 34514                                  
 34515                                  	; MSDOS 6.0
 34516                                  	; 22/09/2023
 34517                                  	;MOV	word [HIGH_SECTOR],0 ; *! ;F.C. >32mb  low sector #
 34518                                  	;
 34519                                  	; MDOS 3.3 (& MSDOS 6.0)
 34520                                  	;XOR	AL,AL	   ; *
 34521                                  	;MOV	SI,1	   ; *
 34522                                  	;;invoke GETBUFFRB ; *
 34523                                  	;call	GETBUFFRB  ; *
 34524                                  	; 22/09/2023
 34525 0000604A E8FC02                  	call	GETBUFFRC  ; *!
 34526                                  
 34527                                  	;RESTORE <CX,AX,DX>		; CX is sec siz-1, AX is offset in sec
 34528 0000604D 59                      	pop	cx
 34529 0000604E 58                      	pop	ax
 34530 0000604F 5A                      	pop	dx
 34531 00006050 724C                    	JC	short MAP_POP
 34532                                  
 34533 00006052 C536[E205]              	LDS	SI,[CURBUF]
 34534                                  	;;lea	di,[si+16]
 34535                                  	;lea	di,[si+20] ; MSDOS 6.0
 34536 00006056 8D7C18                  	LEA	DI,[SI+BUFINSIZ]
 34537 00006059 01C7                    	ADD	DI,AX
 34538 0000605B 39C8                    	CMP	AX,CX
 34539 0000605D 752C                    	JNZ	short MAPRET
 34540 0000605F 8A05                    	MOV	AL,[DI]
 34541                                  	;Context DS		 	;hkn; SS is DOSDATA
 34542 00006061 16                      	push	ss
 34543 00006062 1F                      	pop	ds	
 34544 00006063 FE06[7805]              	INC	BYTE [CLUSSPLIT]
 34545 00006067 A2[8E05]                	MOV	[CLUSSAVE],AL
 34546 0000606A 8916[9005]              	MOV	[CLUSSEC],DX
 34547                                  	; MSDOS 6.0
 34548 0000606E C706[9205]0000          	MOV	WORD [CLUSSEC+2],0      ;F.C. >32mb	;AN000;
 34549 00006074 42                      	INC	DX
 34550                                  
 34551                                  	; 22/09/2023
 34552                                  	;MOV	word [HIGH_SECTOR],0 ; *! ;F.C. >32mb FAT sector <32mb ;AN000;
 34553                                  	;
 34554                                  	; MDOS 3.3 (& MSDOS 6.0)
 34555                                  	;XOR	AL,AL	   ; *
 34556                                  	;MOV	SI,1	   ; *
 34557                                  	;;invoke GETBUFFRB ; *
 34558                                  	;call	GETBUFFRB  ; *
 34559                                  	; 22/09/2023
 34560 00006075 E8D102                  	call	GETBUFFRC  ; *!
 34561 00006078 7224                    	JC	short MAP_POP
 34562                                  
 34563 0000607A C536[E205]              	LDS	SI,[CURBUF]
 34564 0000607E 8D7C18                  	LEA	DI,[SI+BUFINSIZ]
 34565 00006081 8A05                    	MOV	AL,[DI]
 34566                                  	;Context DS			;hkn; SS is DOSDATA
 34567 00006083 16                      	push	ss
 34568 00006084 1F                      	pop	ds
 34569 00006085 A2[8F05]                	MOV	[CLUSSAVE+1],AL
 34570                                  
 34571                                  ;hkn; CLUSSAVE is in DOSDATA
 34572 00006088 BF[8E05]                	MOV	DI,CLUSSAVE
 34573                                  MAPRET:
 34574                                  	;RESTORE <DX,CX,BX>
 34575 0000608B 5A                      	pop	dx
 34576 0000608C 59                      	pop	cx
 34577 0000608D 5B                      	pop	bx
 34578 0000608E 31C0                    	XOR	AX,AX			; MZ allow shift to clear carry
 34579 00006090 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ is this 16-bit fat?
 34580 00006096 7302                    	JAE	short MapSet		; MZ no, set flags
 34581 00006098 89D8                    	MOV	AX,BX
 34582                                  MapSet:
 34583 0000609A A801                    	TEST	AL,1			; set zero flag if not on boundary
 34584                                  	;RESTORE <AX>
 34585 0000609C 58                      	pop	ax
 34586 0000609D C3                      	retn
 34587                                  
 34588                                  MAP_POP:
 34589                                  	;RESTORE <DX,CX,BX,AX>
 34590 0000609E 5A                      	pop	dx
 34591 0000609F 59                      	pop	cx
 34592 000060A0 5B                      	pop	bx
 34593 000060A1 58                      	pop	ax
 34594                                  fatread_sft_retn: ; 17/12/2022
 34595 000060A2 C3                      	retn
 34596                                  
 34597                                  ; 20/05/2019 - Retro DOS v4.0
 34598                                  ; DOSCODE:96B3h (MSDOS 6.21, MSDOS.SYS)
 34599                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34600                                  ; DOSCODE:9657h (MSDOS 5.0, MSDOS.SYS)
 34601                                  
 34602                                  ;Break	<FATREAD_SFT/FATREAD_CDS -- CHECK DRIVE GET FAT>
 34603                                  ;----------------------------------------------------------------------------
 34604                                  ;
 34605                                  ; Procedure Name : FATREAD_SFT
 34606                                  ;
 34607                                  ; Inputs:
 34608                                  ;	ES:DI points to an SFT for the drive of interest (local only,
 34609                                  ;		giving a NET SFT will produce system crashing results).
 34610                                  ;	DS DOSDATA
 34611                                  ; Function:
 34612                                  ;	Can be used by an SFT routine (like CLOSE) to invalidate buffers
 34613                                  ;	if disk changed.
 34614                                  ;	In other respects, same as FATREAD_CDS.
 34615                                  ;	(note ES:DI destroyed!)
 34616                                  ; Outputs:
 34617                                  ;	Carry set if error (currently user FAILed to I 24)
 34618                                  ; NOTE: This routine may cause FATREAD_CDS to "miss" a disk change
 34619                                  ;	as far as invalidating curdir_ID is concerned.
 34620                                  ;	Since getting a true disk changed on this call is a screw up
 34621                                  ;	anyway, that's the way it goes.
 34622                                  ;
 34623                                  ;---------------------------------------------------------------------------
 34624                                  
 34625                                  FATREAD_SFT:
 34626 000060A3 26C46D07                	LES	BP,[ES:DI+SF_ENTRY.sf_devptr]
 34627                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34628                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
 34629                                  	; 15/12/2022
 34630 000060A7 268A4600                	mov	AL,[ES:BP]
 34631 000060AB A2[7605]                	MOV	[THISDRV],AL
 34632 000060AE E8B6A5                  	call	GOTDPB			; Set THISDPB
 34633                                  	;CALL	FAT_GOT_DPB
 34634                                  	; 17/12/2022
 34635 000060B1 E99F00                  	jmp	FAT_GOT_DPB
 34636                                  ;fatread_sft_retn:
 34637                                  	;retn
 34638                                  
 34639                                  ;----------------------------------------------------------------------------
 34640                                  ;
 34641                                  ; Procedure Name : FATREAD_CDS
 34642                                  ;
 34643                                  ; Inputs:
 34644                                  ;	DS:DOSDATA
 34645                                  ;	ES:DI points to an CDS for the drive of interest (local only,
 34646                                  ;		giving a NET or NUL CDS will produce system crashing results).
 34647                                  ; Function:
 34648                                  ;	If disk may have been changed, media is determined and buffers are
 34649                                  ;	flagged invalid. If not, no action is taken.
 34650                                  ; Outputs:
 34651                                  ;	ES:BP = Drive parameter block
 34652                                  ;	THISDPB = ES:BP
 34653                                  ;	THISDRV set
 34654                                  ;	Carry set if error (currently user FAILed to I 24)
 34655                                  ; DS preserved , all other registers destroyed
 34656                                  ;
 34657                                  ;---------------------------------------------------------------------------
 34658                                  
 34659                                  	; 20/05/2019 - Retro DOS v4.0
 34660                                  	; DOSCODE:96C5h (MSDOS 6.21, MSDOS.SYS)
 34661                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34662                                  	; DOSCODE:9669h (MSDOS 5.0, MSDOS.SYS)
 34663                                  
 34664                                  FATREAD_CDS:
 34665 000060B4 06                      	PUSH	ES
 34666 000060B5 57                      	PUSH	DI
 34667                                  	;les	bp,[es:di+45h]
 34668 000060B6 26C46D45                	LES	BP,[ES:DI+curdir.devptr]
 34669                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34670                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
 34671                                  	; 15/12/2022
 34672 000060BA 268A4600                	mov	AL,[ES:BP]
 34673 000060BE A2[7605]                	MOV	[THISDRV],AL
 34674 000060C1 E8A3A5                  	call	GOTDPB			;Set THISDPB
 34675 000060C4 E88C00                  	CALL	FAT_GOT_DPB
 34676 000060C7 5F                      	POP	DI			;Get back CDS pointer
 34677 000060C8 07                      	POP	ES
 34678 000060C9 72D7                    	jc	short fatread_sft_retn
 34679 000060CB 7538                    	JNZ	short NO_CHANGE		;Media NOT changed
 34680                                  
 34681                                  ;	Media changed. We now need to find all CDS structures which use this
 34682                                  ;	DPB and invalidate their ID pointers.
 34683                                  
 34684                                  MED_CHANGE:
 34685 000060CD 31C0                    	XOR	AX,AX
 34686 000060CF 48                      	DEC	AX			; AX = -1
 34687 000060D0 1E                      	PUSH	DS
 34688 000060D1 8A0E[4700]              	MOV	CL,[CDSCOUNT]
 34689 000060D5 30ED                    	XOR	CH,CH			; CX is number of structures
 34690                                  	;lds	si,[es:di+45h]
 34691 000060D7 26C57545                	LDS	SI,[ES:DI+curdir.devptr] ; Find all CDS with this devptr
 34692                                  
 34693                                  ;hkn; SS override
 34694                                  
 34695                                  ;	Find all CDSs with this DevPtr
 34696                                  ;
 34697                                  ;	(ax) = -1
 34698                                  ;	(ds:si) = DevPtr
 34699                                  
 34700 000060DB 36C43E[3C00]            	LES	DI,[SS:CDSADDR]		; (es:di) = CDS pointer
 34701                                  frcd20: 
 34702                                  	;;test	word [es:di+43h],8000h
 34703                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 34704 000060E0 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 34705 000060E5 7518                    	JNZ	short frcd25		; Leave NET guys alone!!
 34706                                  
 34707                                  	; MSDOS 3.3
 34708                                  	;push	es
 34709                                  	;push	di
 34710                                  	;les	di,[es:di+45h]
 34711                                  	;;les	di,[ES:DI+curdir.devptr]
 34712                                  	;call	POINTCOMP
 34713                                  	;pop	di
 34714                                  	;pop	es
 34715                                  	;jnz	short frcd25
 34716                                  
 34717                                  	; MSDOS 6.0
 34718 000060E7 263B7545                	cmp	si,[ES:DI+curdir.devptr]
 34719 000060EB 7512                    	jne	short frcd25		; no match
 34720 000060ED 8CDB                    	mov	bx,ds
 34721 000060EF 263B5D47                	cmp	bx,[ES:DI+curdir.devptr+2]
 34722 000060F3 750A                    	jne	short frcd25		; CDS not for this drive
 34723                                  
 34724                                  	; MSDOS 3.3 (& MSDOS 6.0)
 34725                                  	;test	[es:di+49h],ax
 34726 000060F5 26854549                	test	[ES:DI+curdir.ID],AX
 34727 000060F9 7404                    	JZ	short frcd25		; If root (0), leave root
 34728                                  	;mov	[es:di+49h],ax
 34729 000060FB 26894549                	MOV	[ES:DI+curdir.ID],AX	; else invalid
 34730                                  frcd25:	
 34731                                  	;;add	di,81  ; MSDOS 3.3
 34732                                  	;add	di,88  ; MSDOS 6.0	 
 34733 000060FF 83C758                  	ADD	DI,curdir.size		; Point to next CDS
 34734 00006102 E2DC                    	LOOP	frcd20
 34735 00006104 1F                      	POP	DS
 34736                                  NO_CHANGE:
 34737 00006105 C42E[8A05]              	LES	BP,[THISDPB]
 34738 00006109 F8                      	CLC
 34739 0000610A C3                      	retn
 34740                                  
 34741                                  ;----------------------------------------------------------------------------
 34742                                  ; 05/01/2024 - Retro DOS 5.0
 34743                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:0A7Fh
 34744                                  ;;;
 34745                                  chk_set_first_access:
 34746 0000610B 26837E0F00              	cmp	word [es:bp+0Fh],0	; DPB.FATSIZE
 34747 00006110 750D                    	jnz	short chk_set_fa_1	; FAT (FAT12 or FAT16)
 34748                                  					; FAT32
 34749 00006112 26837E21FF              	cmp	word [es:bp+21h],0FFFFh	; DPB.FREE_CNT_HW
 34750 00006117 26C74621FFFF            	mov	word [es:bp+21h],0FFFFh	; High word of free cluster count
 34751 0000611D 7505                    	jne	short chk_set_fa_2
 34752                                  chk_set_fa_1:
 34753 0000611F 26837E1FFF              	cmp	word [es:bp+1Fh],0FFFFh	; DPB.FREE_CNT
 34754                                  chk_set_fa_2:
 34755 00006124 26C7461FFFFF            	mov	word [es:bp+1Fh],0FFFFh	; Count of free clusters, -1 if unknown
 34756 0000612A 7405                    	je	short chk_set_fa_3
 34757 0000612C 26804E1801              	or	byte [es:bp+18h],1	; DPB.FIRST_ACCESS
 34758                                  chk_set_fa_3:
 34759 00006131 C3                      	retn
 34760                                  ;;;
 34761                                  ;----------------------------------------------------------------------------
 34762                                  
 34763                                  
 34764                                  ;Break	<Fat_Operation - miscellaneous fat stuff>
 34765                                  ;----------------------------------------------------------------------------
 34766                                  ;
 34767                                  ; Procedure Name : FAT_operation
 34768                                  ;
 34769                                  ;----------------------------------------------------------------------------
 34770                                  
 34771                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34772                                  
 34773                                  FAT_operation:
 34774                                  	; 31/07/2018 - Retro DOS v3.0
 34775                                  FATERR:
 34776                                  	;mov	word [es:bp+1Eh],-1
 34777                                  	;mov	word [es:bp+1Fh],-1 ; MSDOS 6.0
 34778 00006132 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 
 34779                                  					; Err in FAT must force recomp of freespace
 34780                                  	;and	di,0FFh
 34781 00006138 81E7FF00                	AND	DI,STECODE		; Put error code in DI
 34782                                  	;mov	byte [ALLOWED],18h
 34783 0000613C C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 34784                                  	;mov	ah,1Ah
 34785 00006141 B41A                    	MOV	AH,2+Allowed_FAIL+Allowed_RETRY ; While trying to read FAT
 34786 00006143 A0[7605]                	MOV	AL,[THISDRV]		; Tell which drive
 34787 00006146 E8ECFB                  	call	FATAL1
 34788 00006149 C42E[8A05]              	LES	BP,[THISDPB]
 34789 0000614D 3C03                    	CMP	AL,3
 34790 0000614F 7502                    	JNZ	short FAT_GOT_DPB	; User said retry
 34791 00006151 F9                      	STC				; User said FAIL
 34792 00006152 C3                      	retn
 34793                                  
 34794                                  FAT_GOT_DPB:
 34795                                  	;Context DS			;hkn; SS is DOSDATA
 34796 00006153 16                      	push	ss
 34797 00006154 1F                      	pop	ds
 34798                                  	;mov	al,0Fh
 34799 00006155 B00F                    	MOV	AL,DMEDHL
 34800                                  	;mov	ah,[es:bp+1]
 34801 00006157 268A6601                	MOV	AH,[ES:BP+DPB.UNIT]
 34802 0000615B A3[5A03]                	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018 
 34803 0000615E C606[5C03]01            	MOV	BYTE [DEVCALL_REQFUNC],DEVMDCH
 34804 00006163 C706[5D03]0000          	MOV	word [DEVCALL_REQSTAT],0
 34805                                  	;;mov	al,[es:bp+16h]
 34806                                  	;mov	al,[es:bp+17h] ; MSDOS 6.0
 34807 00006169 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 34808 0000616D A2[6703]                	MOV	[CALLMED],AL
 34809 00006170 06                      	PUSH	ES
 34810 00006171 1E                      	PUSH	DS
 34811                                  
 34812                                  ;hkn; DEVCALL is in DOSDATA
 34813 00006172 BB[5A03]                	MOV	BX,DEVCALL
 34814                                  	;;lds	si,[es:bp+12h]
 34815                                  	;lds	si,[es:bp+13h] ; MSDOS 6.0
 34816 00006175 26C57613                	LDS	SI,[ES:BP+DPB.DRIVER_ADDR] ; DS:SI Points to device header
 34817 00006179 07                      	POP	ES			; ES:BX Points to call header
 34818 0000617A E8D3EE                  	call	DEVIOCALL2
 34819                                  	;Context DS		 	;hkn; SS is DOSDATA
 34820 0000617D 16                      	push	ss
 34821 0000617E 1F                      	pop	ds
 34822 0000617F 07                      	POP	ES			; Restore ES:BP
 34823 00006180 8B3E[5D03]              	MOV	DI,[DEVCALL_REQSTAT]
 34824                                  	;test	di,8000h
 34825                                  	;jnz	short FATERR
 34826 00006184 09FF                    	or	di,di
 34827 00006186 78AA                    	js	short FATERR		; have error
 34828 00006188 30E4                    	XOR	AH,AH
 34829                                  	;xchg	ah,[es:bp+17h] ; MSDOS 3.3
 34830                                  	;xchg	ah,[es:bp+18h] ; MSDOS 6.0
 34831 0000618A 26866618                	XCHG	AH,[ES:BP+DPB.FIRST_ACCESS] ; Reset dpb_first_access
 34832 0000618E A0[7605]                	MOV	AL,[THISDRV]		; Use physical unit number
 34833                                  ; See if we had changed volume id by creating one on the diskette
 34834 00006191 3806[A10A]              	cmp	[VOLCHNG_FLAG],AL
 34835 00006195 7508                    	jnz	short CHECK_BYT
 34836 00006197 C606[A10A]FF            	mov	byte [VOLCHNG_FLAG],-1
 34837 0000619C E9A500                  	jmp	GOGETBPB		; Need to get device driver to read in
 34838                                  					; new volume label.
 34839                                  CHECK_BYT:
 34840 0000619F 0A26[6803]              	OR	AH,[CALLRBYT]
 34841                                  	;JNS	short CHECK_ZR		; ns = 0 or 1
 34842                                  	;JMP	short NEWDSK
 34843                                  	; 17/12/2022
 34844 000061A3 7863                    	js	short NEWDSK
 34845                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34846                                  	;JNS	short CHECK_ZR		; ns = 0 or 1
 34847                                  	;JMP	short NEWDSK
 34848                                  
 34849                                  CHECK_ZR:
 34850 000061A5 743B                    	JZ	short CHKBUFFDIRT	; jump if I don't know
 34851                                  	; 24/09/2023
 34852                                  	; cf=0 (after 'or' instruction)
 34853                                  	;CLC
 34854 000061A7 C3                      	retn				; If Media not changed (NZ)
 34855                                  
 34856                                  DISK_CHNG_ERR:
 34857 000061A8 06                      	PUSH	ES
 34858 000061A9 55                      	PUSH	BP
 34859                                  	;;les	bp,[es:bp+12h]
 34860                                  	;les	bp,[es:bp+13h] ; MSDOS 6.0
 34861 000061AA 26C46E13                	LES	BP,[ES:BP+DPB.DRIVER_ADDR] ; Get device pointer
 34862                                  	;;test	word [es:bp+4],800h
 34863                                  	;TEST	word [ES:BP+SYSDEV.ATT],DEVOPCL ; Did it set vol id?
 34864 000061AE 26F6460508              	test	byte [es:bp+SYSDEV.ATT+1],(DEVOPCL>>8)
 34865 000061B3 5D                      	POP	BP
 34866 000061B4 07                      	POP	ES
 34867 000061B5 7426                    	JZ	short FAIL_OPJ2		; Nope, FAIL
 34868 000061B7 1E                      	PUSH	DS			; Save buffer pointer for ignore
 34869 000061B8 57                      	PUSH	DI
 34870 000061B9 16                      	push	ss			;hkn; SS is DOSDATA
 34871 000061BA 1F                      	pop	ds
 34872                                  	;mov	byte [ALLOWED],18h
 34873 000061BB C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 34874 000061C0 06                      	PUSH	ES
 34875 000061C1 C43E[6903]              	LES	DI,[CALLVIDM]		; Get volume ID pointer
 34876 000061C5 8C06[2A03]              	MOV	[EXTERRPT+2],ES
 34877 000061C9 07                      	POP	ES
 34878 000061CA 893E[2803]              	MOV	[EXTERRPT],DI
 34879                                  	;mov	ax,0Fh
 34880 000061CE B80F00                  	MOV	AX,error_I24_wrong_disk
 34881 000061D1 C606[7505]01            	MOV	byte [READOP],1		; Write
 34882                                  	;invoke	HARDERR
 34883 000061D6 E80AFB                  	call	HARDERR
 34884 000061D9 5F                      	POP	DI			; Get back buffer for ignore
 34885 000061DA 1F                      	POP	DS
 34886 000061DB 3C03                    	CMP	AL,3
 34887                                  FAIL_OPJ2:
 34888 000061DD 741C                    	JZ	short FAIL_OP
 34889 000061DF E971FF                  	JMP	FAT_GOT_DPB		; Retry
 34890                                  
 34891                                  CHKBUFFDIRT:
 34892                                  	; 20/05/2019 - Retro DOS v4.0
 34893                                  
 34894                                  	; MSDOS 3.3
 34895                                  	;lds	di,[BUFFHEAD]
 34896                                  
 34897                                  	; MSDOS 6.0
 34898 000061E2 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0	; any dirty buffers ? ;hkn;
 34899 000061E8 741E                    	je	short NEWDSK			; no, skip the check
 34900 000061EA E8F700                  	call	GETCURHEAD			; get pointer to first buffer
 34901                                  nbuffer:
 34902                                  	;cmp	al,[di+4]
 34903 000061ED 384504                  	cmp	[di+BUFFINFO.buf_ID],al	; Unit OK ?
 34904 000061F0 750D                    	jne	short lfnxt			; no, go for next buffer
 34905                                  	;test   byte [di+5],40h
 34906 000061F2 F6450540                	TEST	byte [di+BUFFINFO.buf_flags],buf_dirty	; is the buffer dirty ?
 34907 000061F6 7407                    	jz	short lfnxt			; no, go for next buffer
 34908                                  	;Context DS
 34909 000061F8 16                      	push	ss
 34910 000061F9 1F                      	pop	ds
 34911                                  	; 24/09/2023
 34912                                  	; cf=0 (after 'test' instruction)
 34913                                  	;clc
 34914 000061FA C3                      	retn
 34915                                  
 34916                                  FAIL_OP:					; This label & code is here
 34917                                  	;Context DS				;  for reachability
 34918 000061FB 16                      	push	ss
 34919 000061FC 1F                      	pop	ds
 34920 000061FD F9                      	STC
 34921 000061FE C3                      	retn
 34922                                  
 34923                                  lfnxt:
 34924                                  	; 15/08/2018 - Retro DOS v3.0
 34925                                  	; MSDOS 3.3
 34926                                  	;lds	di,[di]
 34927                                  
 34928                                  	; 20/05/2019 - Retro DOS v4.0
 34929 000061FF 8B3D                    	mov	di,[di]
 34930                                  	;;mov	di,[di+BUFFINFO.buf_next]	; get next buffer
 34931                                  	
 34932                                  	; MSDOS 3.3
 34933                                  	;cmp	di,-1
 34934                                  	;jne	short nbuffer
 34935                                  	
 34936                                  	; MSDOS 6.0
 34937 00006201 36393E[A512]            	cmp	[ss:FIRST_BUFF_ADDR],di		; is this where we started ?;hkn;
 34938 00006206 75E5                    	jne	short nbuffer			; no, check this guy also
 34939                                  
 34940                                  ; If no dirty buffers, assume Media changed
 34941                                  NEWDSK:
 34942                                  	;;mov	word [es:bp+1Eh],0FFFFh  ; MSDOS 3.3
 34943                                  	;mov	word [es:bp+1Fh],0FFFFh  ; MSDOS 6.0
 34944 00006208 26C7461FFFFF            	mov	word [ES:BP+DPB.FREE_CNT],-1	; Media changed, must
 34945                                  						;  recompute
 34946                                  	; MSDOS 3.3
 34947                                  	;call	SETVISIT
 34948                                  	; MSDOS 6.0
 34949 0000620E E8D300                  	call	 GETCURHEAD
 34950                                  nxbuffer:
 34951                                  	; MSDOS 3.3
 34952                                  	;or 	byte [di+5],20h
 34953                                  	; MSDOS 3.3 & MSDOS 6.0
 34954                                  	;cmp	[di+4],al
 34955 00006211 384504                  	cmp	[DI+BUFFINFO.buf_ID],al		; This drive ?
 34956 00006214 7510                    	jne	short lfnxt2
 34957                                  	;test	byte [di+5],40h
 34958 00006216 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 34959 0000621A 758C                    	jnz	short DISK_CHNG_ERR
 34960                                  	;mov	word [di+4],20FFh
 34961 0000621C C74504FF20              	mov	word [DI+BUFFINFO.buf_ID],(buf_visit*256)+0FFh ; free up
 34962 00006221 E8D200                  	call	SCANPLACE
 34963                                  	; MSDOS 6.0
 34964 00006224 EB02                    	jmp	short skpbuff
 34965                                  lfnxt2:
 34966 00006226 8B3D                    	mov	di,[di]
 34967                                  	;mov	di,[di+BUFFINFO.buf_next]
 34968                                  skpbuff:
 34969                                  	; MSDOS 6.0
 34970 00006228 363B3E[A512]            	cmp	di,[ss:FIRST_BUFF_ADDR]					;hkn;
 34971 0000622D 75E2                    	jne	short nxbuffer
 34972                                  
 34973 0000622F 36833E[7700]00          	CMP	word [ss:SC_CACHE_COUNT],0 ;LB.  look ahead buffers ?	;AN001;
 34974 00006235 740D                    	JZ	short GOGETBPB		;LB.  no			;AN001;
 34975 00006237 363A06[9C12]            	CMP	AL,[ss:CurSC_DRIVE]	;LB.  same as changed drive	;AN001;
 34976 0000623C 7506                    	JNZ	short GOGETBPB		;LB.  no			;AN001;
 34977 0000623E 36C606[9C12]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ;LB.  invalidate look ahead buffers ;AN000;
 34978                                  ;lfnxt2:
 34979                                  	; MSDOS 3.3
 34980                                  	;call	SKIPVISIT
 34981                                  	;jnz	short nxbuffer
 34982                                  GOGETBPB:
 34983                                  	; MSDOS 3.3 & MSDOS 6.0
 34984                                  	;;lds	di,[es:bp+12h]
 34985                                  	;lds	di,[es:bp+13h] ; MSDOS 6.0	
 34986 00006244 26C57E13                	LDS	DI,[ES:BP+DPB.DRIVER_ADDR]
 34987                                  	; 20/05/2019
 34988                                  	;test	word [di+4],2000h
 34989                                  	;TEST	word [DI+SYSDEV.ATT],ISFATBYDEV
 34990 00006248 F6450520                	TEST	byte [DI+SYSDEV.ATT+1],(ISFATBYDEV>>8)
 34991 0000624C 7510                    	JNZ	short GETFREEBUF
 34992                                  	;context DS	    		;hkn; SS is DOSDATA
 34993 0000624E 16                      	push	ss
 34994 0000624F 1F                      	pop	ds
 34995 00006250 BB0200                  	MOV	BX,2
 34996 00006253 E8C7FC                  	CALL	UNPACK			; Read the first FAT sector into CURBUF
 34997                                  FAIL_OPJ:
 34998 00006256 72A3                    	JC	short FAIL_OP
 34999 00006258 C53E[E205]              	LDS	DI,[CURBUF]
 35000 0000625C EB13                    	JMP	SHORT GOTGETBUF
 35001                                  
 35002                                  GETFREEBUF:
 35003 0000625E 06                      	PUSH	ES			; Get a free buffer for BIOS to use
 35004 0000625F 55                      	PUSH	BP
 35005                                  	; MSDOS 3.3
 35006                                  	;LDS	DI,[SS:BUFFHEAD] ; 15/08/2018
 35007                                  	; MSDOS 6.0
 35008 00006260 31D2                    	XOR	DX,DX			;LB.  fake to get 1st	  ;AN000;
 35009                                  ;hkn; SS override
 35010 00006262 368916[0706]            	MOV	[SS:HIGH_SECTOR],DX ; 0	;LB.  buffer addr	  ;AN000;
 35011 00006267 E87A00                  	call	GETCURHEAD		;LB.			  ;AN000;
 35012                                  	; MSDOS 3.3 & MSDOS 6.0
 35013 0000626A E85502                  	call	BUFWRITE
 35014 0000626D 5D                      	POP	BP
 35015 0000626E 07                      	POP	ES
 35016                                  	;JC	short FAIL_OPJ
 35017 0000626F 728A                    	jc	short FAIL_OP
 35018                                  GOTGETBUF:
 35019                                  	;;add	di,16
 35020                                  	;add	di,20 ; MSDOS 6.0
 35021 00006271 83C718                  	ADD	DI,BUFINSIZ
 35022                                  
 35023                                  ;hkn; SS override
 35024 00006274 368C1E[6A03]            	MOV	[SS:CALLXAD+2],DS
 35025                                  	;Context DS			;hkn; SS is DOSDATA
 35026 00006279 16                      	push	ss
 35027 0000627A 1F                      	pop	ds
 35028 0000627B 893E[6803]              	MOV	[CALLXAD],DI
 35029                                  	;mov	al,16h
 35030 0000627F B016                    	MOV	AL,DBPBHL
 35031                                  	;mov	ah,[es:bp+1]
 35032 00006281 268A6601                	MOV	AH,[ES:BP+DPB.UNIT]
 35033 00006285 A3[5A03]                	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018
 35034 00006288 C606[5C03]02            	MOV	BYTE [DEVCALL_REQFUNC],DEVBPB
 35035 0000628D C706[5D03]0000          	MOV	word [DEVCALL_REQSTAT],0
 35036                                  	;;mov	al,[es:bp+16h]
 35037                                  	;mov	al,[es:bp+17h]
 35038 00006293 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 35039 00006297 A2[6703]                	MOV	[CALLMED],AL
 35040 0000629A 06                      	PUSH	ES
 35041 0000629B 1E                      	PUSH	DS
 35042                                  	;;push	word [es:bp+14h]
 35043                                  	;push	word [es:bp+15h] ; MSDOS 6.0
 35044 0000629C 26FF7615                	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR+2]
 35045                                  	;;push	word [es:bp+12h]
 35046                                  	;push	word [es:bp+13h] ; MSDOS 6.0
 35047 000062A0 26FF7613                	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR]
 35048                                  
 35049                                  ;hkn; DEVCALL is in DOSDATA
 35050 000062A4 BB[5A03]                	MOV	BX,DEVCALL
 35051 000062A7 5E                      	POP	SI
 35052 000062A8 1F                      	POP	DS			; DS:SI Points to device header
 35053 000062A9 07                      	POP	ES			; ES:BX Points to call header
 35054                                  	;invoke	DEVIOCALL2
 35055 000062AA E8A3ED                  	call	DEVIOCALL2
 35056 000062AD 07                      	POP	ES			; Restore ES:BP
 35057                                  	;Context DS
 35058 000062AE 16                      	push	ss		 	;hkn; SS is DOSDATA
 35059 000062AF 1F                      	pop	ds
 35060 000062B0 8B3E[5D03]              	MOV	DI,[DEVCALL_REQSTAT]
 35061                                  	; MSDOS 3.3
 35062                                  	;test	di,8000h
 35063                                  	;jnz	short FATERRJ
 35064                                  	; MSDOS 6.0
 35065 000062B4 09FF                    	or	di,di
 35066 000062B6 7829                    	js	short FATERRJ 		; have error
 35067                                  	;;mov	al,[es:bp+16h]
 35068                                  	;mov	al,[es:bp+17h]  ; MSDOS 6.0
 35069 000062B8 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 35070 000062BC C536[6C03]              	LDS	SI,[CALLBPB]
 35071                                  	;;mov	word [es:bp+1Ch],0
 35072                                  	;mov	word [es:bp+1Dh],0 ; MSDOS 6.0
 35073 000062C0 26C7461D0000            	MOV	word [ES:BP+DPB.NEXT_FREE],0 ; recycle scanning pointer
 35074                                  	;invoke	$SETDPB
 35075 000062C6 E8B2B1                  	call	_$SETDPB
 35076                                  
 35077                                  ;hkn; SS override
 35078 000062C9 36C53E[6803]            	LDS	DI,[SS:CALLXAD]		; Get back buffer pointer
 35079                                  	;mov	al,[es:bp+8]
 35080 000062CE 268A4608                	MOV	AL,[ES:BP+DPB.FAT_COUNT]
 35081                                  
 35082                                  	; MSDOS 3.3
 35083                                  	;;mov	ah,[es:bp+0Fh]
 35084                                  	;MOV	AH,[ES:BP+DPB.FAT_SIZE]
 35085                                  	;;mov	[DI-8],ax
 35086                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AX
 35087                                  
 35088                                  	; MSDOS 6.0
 35089                                  	;mov	[di-0Ah],al
 35090 000062D2 8845F2                  	MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AL 
 35091                                  						;>32mb		  ;AN000;
 35092                                  	;mov	ax,[es:bp+0Fh]
 35093 000062D5 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE]		;>32mb
 35094                                  	;mov	[di-9h],ax			  ;AC000;
 35095 000062D9 8945F3                  	MOV	[DI+BUFFINFO.buf_wrtcntinc-BUFINSIZ],AX 
 35096                                  					;>32mb Correct buffer info ;AC000;
 35097                                  	;Context DS			;hkn; SS is DOSDATA
 35098 000062DC 16                      	push	ss
 35099 000062DD 1F                      	pop	ds
 35100 000062DE 30C0                    	XOR	AL,AL			;Media changed (Z), Carry clear
 35101 000062E0 C3                      	retn
 35102                                  
 35103                                  FATERRJ: 
 35104 000062E1 E94EFE                  	JMP	FATERR
 35105                                  
 35106                                  ;============================================================================
 35107                                  ; STDBUF.ASM
 35108                                  ;============================================================================
 35109                                  ; Retro DOS v2.0 - 12/03/2018
 35110                                  
 35111                                  ;
 35112                                  ; Standard buffer management for MSDOS
 35113                                  ;
 35114                                  
 35115                                  ;.xlist
 35116                                  ;.xcref
 35117                                  ;INCLUDE STDSW.ASM
 35118                                  ;.cref
 35119                                  ;.list
 35120                                  
 35121                                  ;TITLE	STDBUF - MSDOS buffer management
 35122                                  ;NAME	STDBUF
 35123                                  
 35124                                  ;INCLUDE BUF.ASM
 35125                                  
 35126                                  ;============================================================================
 35127                                  ; BUF.ASM
 35128                                  ;============================================================================
 35129                                  ; 31/07/2018 - Retro DOS v3.0
 35130                                  ; Retro DOS v2.0 - 12/03/2018
 35131                                  ;
 35132                                  ; buffer management for MSDOS
 35133                                  ;
 35134                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
 35135                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
 35136                                  ;
 35137                                  ;SUBTTL SETVISIT,SKIPVISIT -- MANAGE BUFFER SCANS
 35138                                  ;
 35139                                  ;SETVISIT:
 35140                                  ;	; 31/07/2018 - Retro DOS v3.0
 35141                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CAFh
 35142                                  ;; Inputs:
 35143                                  ;;      None
 35144                                  ;; Function:
 35145                                  ;;      Set up a scan of I/O buffers
 35146                                  ;; Outputs:
 35147                                  ;;      All visit flags = 0
 35148                                  ;;              NOTE: This pre-scan is needed because a hard disk error
 35149                                  ;;                    may cause a scan to stop in the middle leaving some
 35150                                  ;;                    visit flags set, and some not set.
 35151                                  ;;      DS:DI Points to [BUFFHEAD]
 35152                                  ;; No other registers altered
 35153                                  ;
 35154                                  ;       LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
 35155                                  ;	PUSH    AX
 35156                                  ;       ;;XOR	AX,AX	  ;; MSDOS 2.11
 35157                                  ;	;mov	al,0DFh
 35158                                  ;	mov	al,~buf_visit
 35159                                  ;SETLOOP:
 35160                                  ;       ;;MOV	[DI+7],AL ;; MSDOS 2.11
 35161                                  ;	;and	[DI+5],al
 35162                                  ;	AND	[DI+BUFFINFO.buf_flags],AL
 35163                                  ;       LDS     DI,[DI]
 35164                                  ;       CMP     DI,-1
 35165                                  ;       JNZ     SHORT SETLOOP
 35166                                  ;       POP     AX ; 09/09/2018
 35167                                  ;	LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
 35168                                  ;SVISIT_RETN:
 35169                                  ;       RETN
 35170                                  ;
 35171                                  ;SKIPVISIT:
 35172                                  ;	; 31/07/2018 - Retro DOS v3.0
 35173                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CC8h
 35174                                  ;
 35175                                  ;; Inputs:
 35176                                  ;;      DS:DI Points to a buffer
 35177                                  ;; Function:
 35178                                  ;;      Skip visited buffers
 35179                                  ;; Outputs:
 35180                                  ;;      DS:DI Points to next unvisited buffer
 35181                                  ;;      Zero is set if skip to LAST buffer
 35182                                  ;; No other registers altered
 35183                                  ;
 35184                                  ;       CMP     DI,-1
 35185                                  ;       ;retz
 35186                                  ;       JZ	SHORT SVISIT_RETN
 35187                                  ;
 35188                                  ;	;;CMP	BYTE [DI+7],1 ;; MSDOS 2.11
 35189                                  ;       ;;;retnz
 35190                                  ;       ;;JNZ	SHORT SVISIT_RETN
 35191                                  ;
 35192                                  ;	;test	byte [di+5],20h
 35193                                  ;	TEST	byte [DI+BUFFINFO.buf_flags],buf_visit	
 35194                                  ;	JNZ	short SKIPLOOP
 35195                                  ;	
 35196                                  ;	push	ax
 35197                                  ;	or	al,1
 35198                                  ;	pop	ax
 35199                                  ;	retn	
 35200                                  ;
 35201                                  ;SKIPLOOP:
 35202                                  ;	LDS     DI,[DI]
 35203                                  ;       JMP     SHORT SKIPVISIT
 35204                                  
 35205                                  ;============================================================================
 35206                                  ; BUF.ASM, MSDOS 6.0, 1991
 35207                                  ;============================================================================
 35208                                  ; 31/07/2018 - Retro DOS v3.0
 35209                                  ; 04/05/2019 - Retro DOS v4.0
 35210                                  
 35211                                  ;	TITLE	BUF - MSDOS buffer management
 35212                                  ;	NAME	BUF
 35213                                  
 35214                                  ;**	BUF.ASM - Low level routines for buffer cache management
 35215                                  ;
 35216                                  ;	GETCURHEAD
 35217                                  ;	ScanPlace
 35218                                  ;	PLACEBUF
 35219                                  ;	PLACEHEAD
 35220                                  ;	PointComp
 35221                                  ;	GETBUFFR
 35222                                  ;	GETBUFFRB
 35223                                  ;	FlushBuf
 35224                                  ;	BufWrite
 35225                                  ;	SET_RQ_SC_PARMS
 35226                                  ;
 35227                                  ;	Revision history:
 35228                                  ;
 35229                                  ;		AN000  version 4.00  Jan. 1988
 35230                                  ;		A004   PTM 3765 -- Disk reset failed
 35231                                  ;		M039 DB 10/17/90 - Disk write optimization
 35232                                  ;		I001   5.0 PTR 722211 - Preserve CY when in buffer in HMA
 35233                                  
 35234                                  ;Break	<GETCURHEAD -- Get current buffer header>
 35235                                  ;----------------------------------------------------------------------------
 35236                                  ; Procedure Name : GetCurHead
 35237                                  ; Inputs:
 35238                                  ;	 No Inputs
 35239                                  ; Function:
 35240                                  ;	Returns the pointer to the first buffer in Queue
 35241                                  ;	and updates FIRST_BUFF_ADDR
 35242                                  ;       and invalidates LASTBUFFER (recency pointer)
 35243                                  ; Outputs:
 35244                                  ;	DS:DI = pointer to the first buffer in Queue
 35245                                  ;	FIRST_BUFF_ADDR = offset ( DI ) of First buffer in Queue
 35246                                  ;       LASTBUFFER = -1
 35247                                  ; No other registers altered
 35248                                  ;----------------------------------------------------------------------------
 35249                                  
 35250                                  ; 04/05/2019 - Retro DOS v4.0
 35251                                  ; DOSCODE:98D2h (MSDOS 6.21, MSDOS.SYS)
 35252                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35253                                  ; DOSCODE:9876h (MSDOS 5.0, MSDOS.SYS)
 35254                                  
 35255                                  GETCURHEAD:
 35256 000062E4 36C53E[6D00]            	lds	di,[ss:BufferQueue]	; Pointer to the first buffer
 35257 000062E9 36C706[1E00]FFFF        	mov	word [ss:LastBuffer],-1	; invalidate last buffer
 35258 000062F0 36893E[A512]            	mov	[ss:FIRST_BUFF_ADDR],di	; save first buffer address
 35259 000062F5 C3                      	retn
 35260                                  
 35261                                  ;Break	<SCANPLACE, PLACEBUF -- PUT A BUFFER BACK IN THE POOL>
 35262                                  ;----------------------------------------------------------------------------
 35263                                  ; Procedure Name : ScanPlace
 35264                                  ; Inputs:
 35265                                  ;	Same as PLACEBUF
 35266                                  ; Function:
 35267                                  ;	Save scan location and call PLACEBUF
 35268                                  ; Outputs:
 35269                                  ;	DS:DI Points to saved scan location
 35270                                  ; All registers, except DS:DI, preserved.
 35271                                  ;----------------------------------------------------------------------------
 35272                                  ;M039: Rewritten to preserve registers.
 35273                                  
 35274                                  ;SCANPLACE:
 35275                                  ;	; 31/07/2018 - Retro DOS v3.0
 35276                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
 35277                                  ;	push	es
 35278                                  ;	les	si,[di]
 35279                                  ;	;les	si,[DI+BUFFINFO.buf_link]
 35280                                  ;	call	PLACEBUF
 35281                                  ;	push	es
 35282                                  ;	pop	ds
 35283                                  ;	mov	di,si
 35284                                  ;	pop	es
 35285                                  ;scanplace_retn:
 35286                                  ;	retn	
 35287                                  	
 35288                                  	; MSDOS 6.0
 35289                                  SCANPLACE:
 35290 000062F6 FF35                    	push	word [di]
 35291                                  	;push	word [di+BUFFINFO.buf_next] ;Save scan location
 35292 000062F8 E80200                  	call	PLACEBUF
 35293 000062FB 5F                      	pop	di
 35294 000062FC C3                      	retn
 35295                                  
 35296                                  ;----------------------------------------------------------------------------
 35297                                  ; Procedure Name : PlaceBuf
 35298                                  ; Input:
 35299                                  ;	DS:DI points to buffer (DS->BUFFINFO array, DI=offset in array)
 35300                                  ; Function:
 35301                                  ;	Remove buffer from queue and re-insert it in proper place.
 35302                                  ; NO registers altered
 35303                                  ;----------------------------------------------------------------------------
 35304                                  
 35305                                  ;procedure PLACEBUF,NEAR
 35306                                  
 35307                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35308                                  	; 20/05/2019 - Retro DOS v4.0
 35309                                  PLACEBUF:
 35310                                  	; 31/07/2018 - Retro DOS v3.0
 35311                                  
 35312                                  	; MSDOS 6.0
 35313 000062FD 50                      	push	AX			;Save only regs we modify	;AN000;
 35314 000062FE 53                      	push	BX							;AN000;
 35315                                  	; 23/09/2023
 35316                                  	;push	SI							;AN000;
 35317                                  	
 35318 000062FF 8B05                    	mov	ax,[di]
 35319                                  	;mov	ax,[di+BUFFINFO.buf_next]
 35320 00006301 368B1E[6D00]            	mov	bx,[ss:BufferQueue]	; bx = offset of head of list;smr;SS Override
 35321                                  	
 35322 00006306 39D8                    	cmp	ax,bx				;Buf = last?		;AN000;
 35323 00006308 7422                    	je	short nret			;Yes, special case	;AN000;
 35324 0000630A 39DF                    	cmp	di,bx				;Buf = first?		;AN000;
 35325 0000630C 7506                    	jne	short not_first 		;Yes, special case	;AN000;
 35326 0000630E 36A3[6D00]              	mov	[ss:BufferQueue],ax		;smr;SS Override
 35327 00006312 EB18                    	jmp	short nret 			;Continue with repositioning;AN000;
 35328                                  not_first:
 35329                                  	; 23/09/2023
 35330 00006314 56                      	push	si
 35331                                  	;mov	si,[di+2]
 35332 00006315 8B7502                  	mov	SI,[DI+BUFFINFO.buf_prev]	;No, SI = prior Buf	;AN000;
 35333 00006318 8904                    	mov	[si],ax
 35334                                  	;mov	[SI+BUFFINFO.buf_next],AX	; ax has di->buf_next	;AN000;
 35335 0000631A 96                      	xchg	si,ax
 35336                                  	;mov	[si+2],ax
 35337 0000631B 894402                  	mov	[SI+BUFFINFO.buf_prev],AX	;			;AN000;
 35338                                  	
 35339 0000631E 8B7702                  	mov	SI,[BX+BUFFINFO.buf_prev]	;SI-> last buffer	;AN000;
 35340 00006321 893C                    	mov	[si],di
 35341                                  	;mov	[SI+BUFFINFO.buf_next],DI	;Add Buf to end of list ;AN000;
 35342 00006323 897F02                  	mov	[BX+BUFFINFO.buf_prev],DI				;AN000;
 35343 00006326 897502                  	mov	[DI+BUFFINFO.buf_prev],SI	;Update link in Buf too	;AN000;
 35344 00006329 891D                    	mov	[di],bx
 35345                                  	;mov	[DI+BUFFINFO.buf_next],BX				;AN000;
 35346                                  	; 23/09/2023
 35347 0000632B 5E                      	pop	si
 35348                                  nret:	
 35349                                  	; 23/09/2023							;AN000;
 35350                                  	;pop	SI							;AN000;
 35351 0000632C 5B                      	pop	BX							;AN000;
 35352 0000632D 58                      	pop	AX							;AN000;
 35353                                  									;AN000;
 35354                                  	;cmp	byte [di+4],0FFh
 35355 0000632E 807D04FF                	cmp	byte [di+BUFFINFO.buf_ID],-1	; Buffer FREE?		;AN000;
 35356 00006332 7505                            jne	short pbx			; M039: -no, jump.
 35357 00006334 36893E[6D00]            	mov	[ss:BufferQueue],di		; M039: -yes, make it LRU.
 35358                                  pbx:	
 35359 00006339 C3                      	retn								;AN000;
 35360                                  
 35361                                  	; 31/07/2018 - Retro DOS v3.0
 35362                                  
 35363                                  	; MSDOS 3.3
 35364                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
 35365                                  
 35366                                  ;PLACEBUF:
 35367                                  ;	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
 35368                                  ;	
 35369                                  ;       CALL	save_world
 35370                                  ;       LES     CX,[DI]
 35371                                  ;       CMP     CX,-1           	; Buf is LAST?
 35372                                  ;       JZ      SHORT NRET		; Buffer already last
 35373                                  ;       MOV     BP,ES           	; Pointsave = Buf.nextbuf
 35374                                  ;       PUSH    DS
 35375                                  ;       POP     ES              	; Buf is ES:DI
 35376                                  ;	; 15/03/2018
 35377                                  ;       LDS     SI,[SS:BUFFHEAD] 	; Curbuf = HEAD
 35378                                  ;       CALL    POINTCOMP       	; Buf == HEAD?
 35379                                  ;       JNZ     SHORT BUFLOOP
 35380                                  ;       MOV     [SS:BUFFHEAD],CX
 35381                                  ;       MOV     [SS:BUFFHEAD+2],BP	; HEAD = Pointsave
 35382                                  ;       JMP     SHORT LOOKEND
 35383                                  ;BUFLOOP:
 35384                                  ;	; 31/07/2018
 35385                                  ;	mov	ax,ds
 35386                                  ;	mov	bx,si
 35387                                  ;	;lds	si,[SI+BUFFINFO.buf_link]
 35388                                  ;       LDS     SI,[SI]
 35389                                  ;       CALL    POINTCOMP
 35390                                  ;       jnz	short BUFLOOP
 35391                                  ;	;
 35392                                  ;	mov	ds,ax
 35393                                  ;	mov	si,bx
 35394                                  ;	mov	[SI],cx
 35395                                  ;	;mov	[SI+BUFFINFO.buf_link],cx   ; If Curbuf.nextbuf == buf
 35396                                  ;	mov	[SI+2],bp
 35397                                  ;	;mov	[BX+BUFFINFO.buf_link+2],bp ; Curbuf.nextbuf = Pointsave
 35398                                  ;LOOKEND:
 35399                                  ;	mov	ax,ds
 35400                                  ;	mov	bx,si
 35401                                  ;       LDS     SI,[SI]
 35402                                  ;       CMP     SI,-1
 35403                                  ;       jnz     short LOOKEND
 35404                                  ;GOTHEEND:
 35405                                  ;       mov	ds,ax
 35406                                  ;	mov	[BX],di
 35407                                  ;	MOV     [BX+2],ES 		; Curbuf.nextbuf = Buf
 35408                                  ;       MOV     WORD [ES:DI],-1
 35409                                  ;	;mov	word [ES:DI+BUFFINFO.buf_link],-1
 35410                                  ;       MOV     WORD [ES:DI+2],-1 	; Buf is LAST
 35411                                  ;	;mov	word [ES:DI+BUFFINFO.buf_link+2],-1
 35412                                  ;NRET:
 35413                                  ;       CALL	restore_world
 35414                                  ;	
 35415                                  ;	;cmp	byte [di+4],-1
 35416                                  ;	cmp	byte [DI+BUFFINFO.buf_ID],-1  ; Free buffer ?
 35417                                  ;	jnz     short scanplace_retn
 35418                                  ;	call    PLACEHEAD
 35419                                  ;	retn
 35420                                  
 35421                                  ;EndProc PLACEBUF
 35422                                  
 35423                                  ;M039 - Removed PLACEHEAD.
 35424                                  ;----------------------------------------------------------------------------
 35425                                  ; places buffer at head
 35426                                  ;  NOTE:::::: ASSUMES THAT BUFFER IS CURRENTLY THE LAST
 35427                                  ;	ONE IN THE LIST!!!!!!!
 35428                                  ; BUGBUG ---- this routine can be removed because it has only
 35429                                  ; BUGBUG ---- one instruction. This routine is called from
 35430                                  ; BUGBUG ---- 3 places. ( Size = 3*3+6 = 15 bytes )
 35431                                  ; BUGBUG ---- if coded in line = 3 * 5 = 15 bytes
 35432                                  ; BUGBUG ---- But kept as it is for modularity
 35433                                  ;----------------------------------------------------------------------------
 35434                                  ;procedure   PLACEHEAD,NEAR
 35435                                  ;	mov	word ptr [BufferQueue], di
 35436                                  ;	ret
 35437                                  ;EndProc PLACEHEAD
 35438                                  ;M039
 35439                                  
 35440                                  ;----------------------------------------------------------------------------
 35441                                  ; Procedure Name : PLACEHEAD
 35442                                  ;
 35443                                  ; SAME AS PLACEBUF except places buffer at head
 35444                                  ;----------------------------------------------------------------------------
 35445                                  
 35446                                  	; MSDOS 3.3 (Retro DOS v3.0)
 35447                                  	; 05/09/2018
 35448                                  	; MSDOS 2.11 (Retro DOS v2.0)
 35449                                  ;PLACEHEAD:
 35450                                  ;	; 31/07/2018 - Retro DOS v3.0
 35451                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D4Ah
 35452                                  ;
 35453                                  ;       CALL	save_world
 35454                                  ;       PUSH	DS
 35455                                  ;       POP	ES
 35456                                  ;	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
 35457                                  ;       LDS     SI,[SS:BUFFHEAD]
 35458                                  ;	; 31/07/2018 - Retro DOS v3.0 (MSDOS 3.3)
 35459                                  ;	CALL    POINTCOMP
 35460                                  ;       JZ      SHORT GOTHEEND2
 35461                                  ;	MOV	[ES:DI],SI
 35462                                  ;	;mov	[ES:DI+BUFFINFO.buf_link],si
 35463                                  ;       MOV	[ES:DI+2],DS
 35464                                  ;	;mov	[ES:DI+BUFFINFO.buf_link+2],ds
 35465                                  ;       MOV	[SS:BUFFHEAD],DI
 35466                                  ;       MOV	[SS:BUFFHEAD+2],ES
 35467                                  ;LOOKEND2:
 35468                                  ;       mov	ax,ds
 35469                                  ;	mov	bx,si
 35470                                  ;	;lds	si,[SI+BUFFINFO.buf_link]
 35471                                  ;       LDS     SI,[SI]
 35472                                  ;       CALL    POINTCOMP
 35473                                  ;       JNZ	SHORT LOOKEND2 ; 05/09/2018
 35474                                  ;       mov	ds,ax
 35475                                  ;	mov	word [bx],-1
 35476                                  ;	;mov	word [BX+BUFFINFO.buf_link],-1
 35477                                  ;	mov	word [bx+2],-1
 35478                                  ;	;mov	word [BX+BUFFINFO.buf_link+2],-1
 35479                                  ;GOTHEEND2:
 35480                                  ;      	call	restore_world
 35481                                  ;placehead_retn:
 35482                                  ;	retn
 35483                                  
 35484                                  ; 20/05/2019 - Retro DOS v4.0
 35485                                  ; DOSCODE:9928h (MSDOS 6.21, MSDOS.SYS)
 35486                                  
 35487                                  ;Break	<POINTCOMP -- 20 BIT POINTER COMPARE>
 35488                                  ;----------------------------------------------------------------------------
 35489                                  ;
 35490                                  ; Procedure Name : PointComp
 35491                                  ; Inputs:
 35492                                  ;         DS:SI & ES:DI
 35493                                  ; Function:
 35494                                  ;          Checks for ((SI==DI) && (ES==DS))
 35495                                  ;	   Assumes that pointers are normalized for the
 35496                                  ;	   same segment
 35497                                  ;
 35498                                  ; Compare DS:SI to ES:DI (or DS:DI to ES:SI) for equality
 35499                                  ; DO NOT USE FOR < or >
 35500                                  ; No Registers altered
 35501                                  ;
 35502                                  ;----------------------------------------------------------------------------
 35503                                  
 35504                                  POINTCOMP:
 35505                                  	; 31/07/2018 - Retro DOS v3.0
 35506                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D84h
 35507 0000633A 39FE                    	CMP	SI,DI
 35508 0000633C 750A                    	jnz	short _ret_label	; return if nz
 35509                                  	;jnz	short placehead_retn 
 35510 0000633E 51                      	PUSH	CX
 35511 0000633F 52                      	PUSH	DX
 35512 00006340 8CD9                    	MOV	CX,DS
 35513 00006342 8CC2                    	MOV	DX,ES
 35514 00006344 39D1                    	CMP	CX,DX
 35515 00006346 5A                      	POP	DX
 35516 00006347 59                      	POP	CX
 35517                                  _ret_label:
 35518 00006348 C3                      	retn
 35519                                  
 35520                                  ; 01/08/2018 - Retro DOS v3.0
 35521                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D93h 
 35522                                  
 35523                                  ;Break	<GETBUFFR, GETBUFFRB -- GET A SECTOR INTO A BUFFER>
 35524                                  
 35525                                  ;**	GetBuffr - Get a non-FAT Sector into a Buffer
 35526                                  ;----------------------------------------------------------------------------
 35527                                  ;	GetBuffr does normal ( non-FAT ) sector buffering
 35528                                  ;	It gets the specified local sector into one of the I/O buffers
 35529                                  ;	and shuffles the queue
 35530                                  ; 
 35531                                  ;	ENTRY	(AL) = 0 means sector must be pre-read
 35532                                  ;		       ELSE no pre-read
 35533                                  ;		(DX) = Desired physical sector number	      (LOW)
 35534                                  ;		HIGH_SECTOR = Desired physical sector number (HIGH)
 35535                                  ;		(ES:BP) = Pointer to drive parameters
 35536                                  ;		ALLOWED set in case of INT 24
 35537                                  ;	EXIT	'C' set if error (user FAIL response to INT24)
 35538                                  ;		'C' clear if OK
 35539                                  ;		CURBUF Points to the Buffer for the sector
 35540                                  ;		    the buffer type bits OF buf_flags = 0, caller must set it
 35541                                  ;	USES	AX, BX, CX, SI, DI, Flags
 35542                                  ;----------------------------------------------------------------------------
 35543                                  
 35544                                  ;**	GetBuffrb - Get a FAT Sector into a Buffer
 35545                                  ;----------------------------------------------------------------------------
 35546                                  ;	GetBuffrb reads a sector from the FAT file system's FAT table.
 35547                                  ;	It gets the specified sector into one of the I/O buffers
 35548                                  ;	and shuffles the queue. We need a special entry point so that
 35549                                  ;	we can read the alternate FAT sector if the first read fails, also
 35550                                  ;	so we can mark the buffer as a FAT sector.
 35551                                  ; 
 35552                                  ;	ENTRY	(AL) = 0 means sector must be pre-read
 35553                                  ;		       ELSE no pre-read
 35554                                  ;		(DX) = Desired physical sector number	     (LOW)
 35555                                  ;		(SI) != 0
 35556                                  ;		HIGH_SECTOR = Desired physical sector number (HIGH)
 35557                                  ;		(ES:BP) = Pointer to drive parameters
 35558                                  ;		ALLOWED set in case of INT 24
 35559                                  ;	EXIT	'C' set if error (user FAIL response to INT24)
 35560                                  ;		'C' clear if OK
 35561                                  ;		CUR ddBUF Points to the Buffer for the sector
 35562                                  ;		    the buffer type bits OF buf_flags = 0, caller must set it
 35563                                  ;	USES	AX, BX, CX, SI, DI, Flags
 35564                                  ;----------------------------------------------------------------------------
 35565                                  
 35566                                  	; 22/09/2023 - RetroDOS v4.2 MSDOS.SYS (optimization)
 35567                                  GETBUFFRC:
 35568 00006349 C706[0706]0000          	mov	word [HIGH_SECTOR],0
 35569                                  GETBUFFRA:
 35570 0000634F 30C0                    	xor	al,al
 35571 00006351 BE0100                  	mov	si,1
 35572 00006354 EB09                    	jmp	short GETBUFFRB
 35573                                  
 35574                                  	; 22/09/2023
 35575                                  GETBUFFER:
 35576 00006356 30C0                    	xor	al,al
 35577                                  GETBUFFRD:
 35578                                  	;mov	byte [ALLOWED],18h
 35579 00006358 C606[4B03]18            	mov	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 35580                                  
 35581                                  	; 20/05/2019 - Retro DOS v4.0
 35582                                  	; DOSCODE:9937h (MSDOS 6.21, MSDOS.SYS)
 35583                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35584                                  	; DOSCODE:98DBh (MSDOS 5.0, MSDOS.SYS)
 35585                                  GETBUFFR:
 35586 0000635D 31F6                    	XOR	SI,SI
 35587                                  
 35588                                  ;	This entry point is called for FAT buffering with SI != 0
 35589                                  
 35590                                  GETBUFFRB:
 35591 0000635F A3[9405]                	MOV	[PREREAD],AX			; save pre-read flag
 35592                                  	; 15/12/2022
 35593 00006362 268A4600                	mov	al,[ES:BP]
 35594                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 35595                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
 35596 00006366 C53E[1E00]              	LDS	DI,[LastBuffer]			; Get the recency pointer
 35597                                  	; MSDOS 6.0
 35598                                  ;hkn; SS override
 35599 0000636A 368B0E[0706]            	MOV	CX,[SS:HIGH_SECTOR]		; F.C. >32mb	;AN000;
 35600                                  
 35601                                  ;	See if this is the buffer that was most recently returned.
 35602                                  ;	A big performance win if it is.
 35603                                  
 35604 0000636F 83FFFF                  	CMP	DI,-1				; Recency pointer valid?
 35605 00006372 7412                    	je	short getb5			; No
 35606                                  	;cmp	dx,[di+6]
 35607 00006374 3B5506                  	CMP	DX,[DI+BUFFINFO.buf_sector]
 35608 00006377 750D                    	JNZ	short getb5			; Wrong sector
 35609                                  	
 35610                                  	; MSDOS 6.0
 35611                                  	;cmp	cx,[di+8]
 35612 00006379 3B4D08                  	CMP	CX,[DI+BUFFINFO.buf_sector+2]	; F.C. >32mb	;AN000;
 35613 0000637C 7508                    	JNZ	short getb5			; F.C. >32mb	;AN000;
 35614                                  	
 35615                                  	;cmp	al,[di+4]
 35616 0000637E 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 35617                                  	;JZ	getb35				; Just asked for same buffer
 35618 00006381 7503                    	jnz	short getb5
 35619                                  	;jmp	getb35
 35620                                  	; 17/12/2022
 35621                                  	; 28/07/2019
 35622 00006383 E9C700                  	jmp	getb35x
 35623                                  	; 07/12/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 35624                                  	;jmp	getb35
 35625                                  
 35626                                  ;	It's not the buffer most recently returned. See if it's in the
 35627                                  ;	cache.
 35628                                  ;
 35629                                  ;	(cx:dx) = sector #
 35630                                  ;	(al) = drive #
 35631                                  ;	(si) = 0 iff non fat sector, != 0 if FAT sector read
 35632                                  ;	??? list may be incomplete ???
 35633                                  
 35634                                  getb5:	
 35635                                  	; MSDOS 3.3
 35636                                  	;lds	di,[SS:BUFFHEAD]
 35637                                  	; MSDOS 6.0
 35638 00006386 E85BFF                  	CALL	GETCURHEAD			; get Q Head
 35639                                  getb10:	
 35640                                  	;cmp	dx,[di+6]
 35641 00006389 3B5506                  	CMP	DX,[DI+BUFFINFO.buf_sector]
 35642 0000638C 750D                    	jne	short getb12			; wrong sector lo
 35643                                  	
 35644                                  	; MSDOS 6.0
 35645                                  	;cmp	cx,[di+8]
 35646 0000638E 3B4D08                  	CMP	CX,[DI+BUFFINFO.buf_sector+2]
 35647 00006391 7508                    	jne	short getb12			; wrong sector hi
 35648                                  	
 35649                                  	;cmp	al,[di+4]
 35650 00006393 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 35651                                  	;je	short getb25 ; 05/09/2018	; Found the requested sector
 35652 00006396 7503                    	jne	short getb12
 35653 00006398 E98C00                  	jmp	getb25
 35654                                  getb12:	
 35655                                  	; MSDOS 3.3
 35656                                  	;;mov	di,[DI]
 35657                                  	;;;mov	di,[DI+BUFFINFO.buf_link]
 35658                                  	;
 35659                                  	; 15/08/2018
 35660                                  	;lds	di,[di]
 35661                                  
 35662                                  	;cmp	di,-1 ; 0FFFFh
 35663                                  	;jne	short getb10
 35664                                  	;lds	di,[SS:BUFFHEAD]
 35665                                  
 35666                                  	; MSDOS 6.0
 35667 0000639B 8B3D                    	mov	di,[di]
 35668                                  	;mov	DI,[DI+BUFFINFO.BUF_NEXT]
 35669 0000639D 363B3E[A512]            	cmp	DI,[SS:FIRST_BUFF_ADDR]		; back at the front again?
 35670 000063A2 75E5                    	jne	short getb10			; no, continue looking
 35671                                  
 35672                                  ;	The requested sector is not available in the buffers. DS:DI now points
 35673                                  ;	to the first buffer in the Queue. Flush the first buffer & read in the
 35674                                  ;	new sector into it.
 35675                                  ;
 35676                                  ;	BUGBUG - what goes on here? Isn't the first guy the most recently
 35677                                  ;	used guy? Shuld be for fast lookup. If he is, we shouldn't take
 35678                                  ;	him, we should take LRU. And the above lookup shouldn't be
 35679                                  ;	down a chain, but should be hashed.
 35680                                  ;
 35681                                  ;	(DS:DI) = first buffer in the queue
 35682                                  ;	(CX:DX) = sector # we want
 35683                                  ;	(si) = 0 iff non fat sector, != 0 if FAT sector read
 35684                                  
 35685                                  	; MSDOS 3.3 & MSDOS 6.0
 35686                                  ;hkn; SS override
 35687 000063A4 51                      	PUSH	CX  ; MSDOS 6.0
 35688 000063A5 56                      	push	si
 35689 000063A6 52                      	push	dx
 35690 000063A7 55                      	push	bp
 35691 000063A8 06                      	push	es
 35692 000063A9 E81601                  	CALL	BUFWRITE			; Write out the dirty buffer
 35693 000063AC 07                      	pop	es
 35694 000063AD 5D                      	pop	bp
 35695 000063AE 5A                      	pop	dx
 35696 000063AF 5E                      	pop	si
 35697 000063B0 368F06[0706]            	POP	word [SS:HIGH_SECTOR]  ; MSDOS 6.0
 35698                                  	;jc	short getbx			; if got hard error
 35699 000063B5 7303                    	jnc	short getb13
 35700 000063B7 E99D00                  	jmp	getbx
 35701                                  
 35702                                  getb13:
 35703                                  	; MSDOS 6.0
 35704 000063BA E88F01                  	CALL	SET_RQ_SC_PARMS 		; set parms for secondary cache
 35705                                  
 35706                                  ;	We're ready to read in the buffer, if need be. If the caller
 35707                                  ;	wanted to just *write* the buffer then we'll skip reading it in.
 35708                                  
 35709 000063BD 30E4                    	XOR	AH,AH				; initial flags
 35710                                  ;hkn; SS override
 35711                                  	;test	byte [ss:PREREAD],0FFh
 35712                                  	;jnz	short getb20
 35713 000063BF 363826[9405]            	CMP	[SS:PREREAD],ah ; 0		; am to Read in the new sector?
 35714 000063C4 7549                    	JNZ	short getb20			; no, we're done
 35715                                  	;;lea	bx,[di+16] ; MSDOS 3.3
 35716                                  	;lea	bx,[di+20] ; MSDOS 6.0
 35717 000063C6 8D5D18                  	LEA	BX,[DI+BUFINSIZ] 		; (ds:bx) = data address
 35718                                  	;MOV	CX,1
 35719                                  	; 22/09/2023
 35720 000063C9 29C9                    	sub	cx,cx ; 0
 35721 000063CB 56                      	push	si
 35722 000063CC 57                      	push	di
 35723 000063CD 52                      	push	dx
 35724                                  	; MSDOS 6.0
 35725 000063CE 06                      	push	es ; ***
 35726                                  
 35727                                  ; Note: As far as I can tell, all disk reads into buffers go through
 35728                                  ;	this point. -mrw 10/88
 35729                                  	
 35730                                  	;cmp	byte [ss:BuffInHMA],0	; is buffers in HMA?
 35731                                  	; 22/09/2023
 35732 000063CF 36380E[7900]            	cmp	[ss:BuffInHMA],cl ; 0
 35733 000063D4 7407                    	jz	short getb14
 35734 000063D6 1E                      	push	ds ; **
 35735 000063D7 53                      	push	bx ; *
 35736 000063D8 36C51E[7A00]            	lds	bx,[ss:LoMemBuff]	; Then let's read it into scratch buff
 35737                                  getb14:
 35738                                  ;M039: Eliminated redundant HMA code.
 35739                                  
 35740                                  	; 22/09/2023
 35741 000063DD 41                      	inc	cx ; cx = 1
 35742                                  
 35743                                  	; MSDOS 3.3 (& MSDOS 6.0)
 35744 000063DE 09F6                    	OR	SI,SI			; FAT sector ?
 35745 000063E0 7407                    	JZ	short getb15		
 35746                                  
 35747 000063E2 E89BDB                  	call	FATSECRD
 35748                                  	;mov	ah,2
 35749 000063E5 B402                    	MOV	AH,buf_isFAT		; Set buf_flags
 35750                                  
 35751 000063E7 EB05                    	JMP	SHORT getb17		; Buffer is marked free if read barfs
 35752                                  
 35753                                  getb15:
 35754 000063E9 E8C0DB                  	call	DREAD			; Buffer is marked free if read barfs
 35755 000063EC B400                    	MOV	AH,0			; Set buf_flags to no type, DO NOT XOR!
 35756                                  getb17:
 35757                                  	; 17/12/2022	
 35758                                  ; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 35759                                  ;%if 0
 35760                                  	; MSDOS 6.0							  ;I001
 35761 000063EE 9C                      	pushf								  ;I001
 35762 000063EF 36803E[7900]00          	cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ? ;I001
 35763 000063F5 7411                    	jz	short not_in_hma	; no				  ;I001
 35764                                  	;mov	cx,[es:bp+2]
 35765 000063F7 268B4E02                	mov	cx,[ES:BP+DPB.SECTOR_SIZE]				  ;I001
 35766 000063FB D1E9                    	shr	cx,1							  ;I001
 35767 000063FD 9D                      	popf				; Retrieve possible CY from DREAD ;I001
 35768 000063FE 89DE                    	mov	si,bx							  ;I001
 35769 00006400 5F                      	pop	di ; *							  ;I001
 35770 00006401 07                      	pop	es ; **							  ;I001
 35771 00006402 FC                      	cld								  ;I001
 35772 00006403 9C                      	pushf				; Preserve possible CY from DREAD ;I001
 35773 00006404 F3A5                    	rep	movsw			; move the contents of scratch buf;I001
 35774 00006406 06                      	push	es							  ;I001
 35775 00006407 1F                      	pop	ds							  ;I001
 35776                                  ;%endif
 35777                                  
 35778                                  ; 17/12/2022
 35779                                  %if 0
 35780                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 35781                                  	; MSDOS 5.0
 35782                                  	pushf
 35783                                  	cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ?
 35784                                  	jz	short not_in_hma	; no
 35785                                  	popf
 35786                                  	mov	cx,[ES:BP+DPB.SECTOR_SIZE]
 35787                                  	shr	cx,1
 35788                                  	mov	si,bx
 35789                                  	pop	di ; *
 35790                                  	pop	es ; **
 35791                                  	cld
 35792                                  	rep	movsw
 35793                                  	push	es
 35794                                  	pop	ds
 35795                                  	jmp	short getb19 ; 27/11/2022
 35796                                  %endif
 35797                                  
 35798                                  not_in_hma:								  ;I001
 35799 00006408 9D                      	popf							 	  ;I001
 35800                                  getb19:
 35801 00006409 07                      	pop	es ; ***
 35802 0000640A 5A                      	pop	dx
 35803 0000640B 5F                      	pop	di
 35804 0000640C 5E                      	pop	si
 35805 0000640D 7248                    	JC	short getbx
 35806                                  
 35807                                  ;	The buffer has the data setup in it (if we were to read)
 35808                                  ;	Setup the various buffer fields
 35809                                  ;
 35810                                  ;	(ds:di) = buffer address
 35811                                  ;	(es:bp) = DPB address
 35812                                  ;	(HIGH_SECTOR:DX) = sector #
 35813                                  ;	(ah) = BUF_FLAGS value
 35814                                  ;	(si) = 0 if non fat sector, != 0 if FAT sector read
 35815                                  
 35816                                  ;hkn; SS override
 35817                                  getb20:	; MSDOS 6.0
 35818 0000640F 368B0E[0706]            	MOV	CX,[SS:HIGH_SECTOR]
 35819                                  	;mov	[di+8],cx
 35820 00006414 894D08                  	MOV	[DI+BUFFINFO.buf_sector+2],CX
 35821                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 35822                                   	;mov	[di+6],dx
 35823 00006417 895506                  	MOV	[DI+BUFFINFO.buf_sector],DX
 35824                                  	;;mov	[di+0Ah],bp  ; MSDOS 3.3
 35825                                  	;mov	[di+0Dh],bp  ; MSDOS 6.0
 35826 0000641A 896D0F                  	MOV	[DI+BUFFINFO.buf_DPB],BP
 35827                                  	;;mov	[di+0Ch],es
 35828                                  	;mov	[di+0Fh],es  ; MSDOS 6.0
 35829 0000641D 8C4511                  	MOV	[DI+BUFFINFO.buf_DPB+2],ES
 35830                                  	; 15/12/2022
 35831 00006420 268A4600                	mov	al,[es:bp]
 35832                                  	;mov	al,[es:bp+0]
 35833                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35834                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 35835                                  	;mov	[di+4],ax
 35836 00006424 894504                  	MOV	[DI+BUFFINFO.buf_ID],AX		; Set ID and Flags
 35837                                  getb25:	
 35838                                  	; MSDOS 3.3
 35839                                  	;mov     ax,1
 35840                                  
 35841                                  	; MSDOS 6.0
 35842                                  	;mov	byte [di+0Ah],1
 35843 00006427 C6450A01                	MOV	byte [DI+BUFFINFO.buf_wrtcnt],1	; Default to not a FAT sector ;AC000;
 35844 0000642B 31C0                    	XOR	AX,AX
 35845                                  
 35846                                  	; MSDOS 3.3 (& MSDOS 6.0)
 35847 0000642D 09F6                    	OR	SI,SI				; FAT sector ?
 35848 0000642F 740B                    	JZ	short getb30
 35849                                  
 35850                                  	;mov	al,[es:bp+8]
 35851 00006431 268A4608                	MOV	AL,[ES:BP+DPB.FAT_COUNT]	; update number of copies of
 35852                                  	
 35853                                  	; MSDOS 6.0
 35854 00006435 88450A                  	MOV	[DI+BUFFINFO.buf_wrtcnt],AL	;  this sector present on disk
 35855                                  	;mov	ax,[es:bp+0Fh]
 35856 00006438 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE]		; offset of identical FAT
 35857                                  						;  sectors
 35858                                  	; MSDOS 3.3
 35859                                  	;;mov	ah,[es:bp+0Fh]
 35860                                  	;MOV	AH,[ES:BP+DPB.FAT_SIZE]
 35861                                  
 35862                                  ;	BUGBUG - dos 6 can clean this up by not setting wrtcntinc unless wrtcnt
 35863                                  ;		is set
 35864                                  
 35865                                  getb30:	
 35866                                  	; MSDOS 6.0
 35867                                  	;mov	[di+0Bh],ax
 35868 0000643C 89450B                  	MOV	[DI+BUFFINFO.buf_wrtcntinc],AX
 35869                                  
 35870                                  	; MSDOS 3.3
 35871                                  	;;mov	[di+8],ax ; 15/08/2018	
 35872                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt],AX
 35873                                  
 35874 0000643F E8BBFE                  	CALL	PLACEBUF
 35875                                  
 35876                                  ;hkn; SS override for next 4
 35877                                  getb35: 
 35878                                  	; 17/12/2022
 35879                                  	; 07/12/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 35880                                  	; MSDOS 3.3 & MSDOS 5.0 & MSDOS 6.0
 35881                                  	;MOV	[SS:CURBUF+2],DS
 35882                                  	;MOV	[SS:LastBuffer+2],DS
 35883                                  	;MOV	[SS:CURBUF],DI
 35884                                  	;MOV	[SS:LastBuffer],DI
 35885                                  	;CLC
 35886                                  
 35887                                  	; 17/12/2022
 35888                                  	; 07/12/2022
 35889                                  	; Retro DOS v4.0
 35890 00006442 368C1E[2000]            	mov	[ss:LastBuffer+2],ds
 35891 00006447 36893E[1E00]            	mov	[ss:LastBuffer],di
 35892 0000644C F8                      	clc
 35893                                  getb35x: ; 28/07/2019
 35894 0000644D 368C1E[E405]            	MOV	[ss:CURBUF+2],ds
 35895 00006452 36893E[E205]            	MOV	[ss:CURBUF],di
 35896                                  
 35897                                  ;	Return with 'C' set appropriately
 35898                                  ;	(dx) = caller's original value
 35899                                  
 35900                                  getbx:	
 35901 00006457 16                      	push	ss
 35902 00006458 1F                      	pop	ds
 35903                                  	;retn
 35904                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 35905                                  getbuffrb_retn:
 35906                                  ;flushbuf_retn:	; 17/12/2022
 35907 00006459 C3                      	retn
 35908                                  
 35909                                  ;Break	<FLUSHBUF -- WRITE OUT DIRTY BUFFERS>
 35910                                  ;----------------------------------------------------------------------------
 35911                                  ; Input:
 35912                                  ;	DS = DOSGROUP
 35913                                  ;	AL = Physical unit number local buffers only
 35914                                  ;	   = -1 for all units and all remote buffers
 35915                                  ; Function:
 35916                                  ;	Write out all dirty buffers for unit, and flag them as clean
 35917                                  ;	Carry set if error (user FAILed to I 24)
 35918                                  ;	    Flush operation completed.
 35919                                  ; DS Preserved, all others destroyed (ES too)
 35920                                  ;----------------------------------------------------------------------------
 35921                                  
 35922                                  	; 20/05/2019 - Retro DOS v4.0
 35923                                  	; DOSCODE:9A35h (MSDOS 6.21, MSDOS.SYS)
 35924                                  
 35925                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35926                                  	; DOSCODE:99DAh (MSDOS 5.0, MSDOS.SYS)
 35927                                  FLUSHBUF:
 35928                                  	; MSDOS 3.3
 35929                                  	;;mov	ah,-1 ; 01/08/2018 - Retro DOS v3.0
 35930                                  	;lds	di,[BUFFHEAD]
 35931                                  
 35932                                  	; MSDOS 6.0
 35933 0000645A E887FE                  	call	GETCURHEAD
 35934                                  	;TEST	word [ss:DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
 35935 0000645D 36F606[1106]04          	TEST	byte [ss:DOS34_FLAG],FROM_DISK_RESET ; 4
 35936 00006463 7508                    	jnz	short scan_buf_queue
 35937 00006465 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0			;hkn;
 35938 0000646B 7423                    	je	short end_scan
 35939                                  	
 35940                                  scan_buf_queue:
 35941 0000646D E82900                  	call	CHECKFLUSH
 35942                                  	;push	ax  ; MSDOS 3.3
 35943                                  	; MSDOS 6.0
 35944                                  	;mov	ah,[di+4]
 35945 00006470 8A6504                  	mov	ah,[DI+BUFFINFO.buf_ID]
 35946 00006473 363826[2203]            	cmp	[SS:WPERR],ah					;hkn;
 35947 00006478 7408                    	je	short free_the_buf
 35948                                  	;TEST	word [ss:DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
 35949 0000647A 36F606[1106]04          	TEST	byte [ss:DOS34_FLAG],FROM_DISK_RESET ; 4
 35950 00006480 7405                    	jz	short dont_free_the_buf
 35951                                  	; MSDOS 3.3
 35952                                  	;;mov	al,[di+4]
 35953                                  	;mov	al,[DI+BUFFINFO.buf_ID]
 35954                                  	;cmp	[SS:WPERR],al					;hkn;
 35955                                  	; 15/08/2018
 35956                                  	;jne	short dont_free_the_buf	
 35957                                  free_the_buf:
 35958                                  	; MSDOS 6.0 (& MSDOS 3.3)
 35959 00006482 C74504FF00              	mov	word [DI+BUFFINFO.buf_ID],00FFh
 35960                                  dont_free_the_buf:
 35961                                  	;pop	ax  ; MSDOS 3.3 	   	
 35962                                  
 35963                                  	; MSDOS 3.3
 35964                                  	;mov	di,[DI]
 35965                                  	;;mov	di,[DI+BUFFINFO.buf_link] ; .buf_next
 35966                                  	;
 35967                                  	; 15/08/2018
 35968                                  	;lds	di,[di]
 35969                                  	;
 35970                                  	;cmp	di,-1 ; 0FFFFh
 35971                                  	;jnz	short scan_buf_queue 
 35972                                  	
 35973                                  	; MSDOS 6.0
 35974 00006487 8B3D                    	mov	di,[di]
 35975                                  	;mov	di,[DI+BUFFINFO.buf_next] ; .buf_link
 35976 00006489 363B3E[A512]            	cmp	di,[SS:FIRST_BUFF_ADDR]				;hkn;
 35977 0000648E 75DD                    	jne	short scan_buf_queue
 35978                                  
 35979                                  end_scan:
 35980 00006490 16                      	push	ss
 35981 00006491 1F                      	pop	ds
 35982                                  	; 01/08/2018 - Retro DOS v3.0
 35983                                  	;cmp	byte [FAILERR],0
 35984                                  	;jne	short bad_flush
 35985                                  	;retn
 35986                                  ;bad_flush:
 35987                                  	;stc
 35988                                  	;retn
 35989                                  
 35990                                  	; 17/12/2022
 35991                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 35992                                  	; 01/08/2018 - Retro DOS v3.0
 35993 00006492 803E[4A03]01            	cmp	byte [FAILERR],1
 35994 00006497 F5                      	cmc
 35995                                  flushbuf_retn:
 35996 00006498 C3                      	retn
 35997                                  	
 35998                                  	; 17/12/2022
 35999                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 36000                                  	;cmp	byte [FAILERR],0
 36001                                  	;jne	short bad_flush
 36002                                  	;retn
 36003                                  ;bad_flush:
 36004                                  	;stc
 36005                                  	;retn
 36006                                  
 36007                                  ;----------------------------------------------------------------------------
 36008                                  ;
 36009                                  ; Procedure Name : CHECKFLUSH
 36010                                  ;
 36011                                  ; Inputs : AL - Drive number, -1 means do not check for drive
 36012                                  ;	   DS:DI - pointer to buffer
 36013                                  ;
 36014                                  ; Function : Write out a buffer if it is dirty
 36015                                  ;
 36016                                  ; Carry set if problem (currently user FAILed to I 24)
 36017                                  ;
 36018                                  ;----------------------------------------------------------------------------
 36019                                  
 36020                                  CHECKFLUSH:
 36021                                  	; MSDOS 6.0
 36022 00006499 B4FF                    	mov	ah,-1	; 01/08/2018 Retro DOS v3.0
 36023                                  	;cmp	[di+4],ah
 36024 0000649B 386504                  	CMP	[DI+BUFFINFO.buf_ID],AH
 36025 0000649E 74F8                    	jz	short flushbuf_retn	; Skip free buffer, carry clear
 36026 000064A0 38C4                    	CMP	AH,AL			; 
 36027 000064A2 7406                    	JZ	short DOBUFFER		; do this buffer
 36028                                  	;cmp	al,[di+4]
 36029 000064A4 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 36030 000064A7 F8                      	CLC
 36031 000064A8 75EE                    	jnz	short flushbuf_retn	; Buffer not for this unit or SFT
 36032                                  DOBUFFER:
 36033                                  	;test	byte [di+5],40h
 36034 000064AA F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 36035 000064AE 74E8                    	jz	short flushbuf_retn	; Buffer not dirty, carry clear by TEST
 36036 000064B0 50                      	PUSH	AX
 36037                                  	;push	word [di+4]
 36038 000064B1 FF7504                  	PUSH	WORD [DI+BUFFINFO.buf_ID]
 36039 000064B4 E80B00                  	CALL	BUFWRITE
 36040 000064B7 58                      	POP	AX
 36041 000064B8 7206                    	JC	short LEAVE_BUF		; Leave buffer marked free (lost).
 36042                                  	;and	ah,0BFh
 36043 000064BA 80E4BF                  	AND	AH,~buf_dirty		; Buffer is clean, clears carry
 36044                                  	;mov	[di+4],ax
 36045 000064BD 894504                  	MOV	[DI+BUFFINFO.buf_ID],AX
 36046                                  LEAVE_BUF:
 36047 000064C0 58                      	POP	AX			; Search info
 36048                                  checkflush_retn:
 36049 000064C1 C3                      	retn
 36050                                  
 36051                                  ;Break	<BUFWRITE -- WRITE OUT A BUFFER IF DIRTY>
 36052                                  ;----------------------------------------------------------------------------
 36053                                  ;
 36054                                  ;	BufWrite writes a buffer to the disk, if it's dirty.
 36055                                  ;
 36056                                  ;	ENTRY	DS:DI Points to the buffer
 36057                                  ;
 36058                                  ;	EXIT	Buffer marked free
 36059                                  ;		Carry set if error (currently user FAILed to I 24)
 36060                                  ;
 36061                                  ;	USES	All buf DS:DI
 36062                                  ;		HIGH_SECTOR
 36063                                  ;----------------------------------------------------------------------------
 36064                                  
 36065                                  	; 20/05/2019 - Retro DOS v4.0
 36066                                  	; DOSCODE:9AA0h (MSDOS 6.21, MSDOS.SYS)
 36067                                  
 36068                                  
 36069                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36070                                  	; DOSCODE:9A45h (MSDOS 5.0, MSDOS.SYS)
 36071                                  
 36072                                  BUFWRITE:
 36073                                  	; 10/09/2018
 36074                                  	; 01/08/2018 - Retro DOS v3.0
 36075                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E94h
 36076 000064C2 B8FF00                  	MOV	AX,00FFH
 36077                                  	;xchg	ax,[di+4]
 36078 000064C5 874504                  	XCHG	AX,[DI+BUFFINFO.buf_ID]	; Free, in case write barfs
 36079 000064C8 3CFF                    	CMP	AL,0FFH
 36080 000064CA 74F5                    	jz      short checkflush_retn	; Buffer is free, carry clear.
 36081                                  	;test	ah,40h
 36082 000064CC F6C440                  	test	AH,buf_dirty
 36083 000064CF 74F0                    	jz      short checkflush_retn	; Buffer is clean, carry clear.
 36084                                  	; MSDOS 6.0
 36085 000064D1 E89D00                  	call	DEC_DIRTY_COUNT 	; LB. decrement dirty count
 36086                                  
 36087                                  ;hkn; SS override
 36088 000064D4 363A06[2203]            	CMP	AL,[SS:WPERR]
 36089 000064D9 74E6                    	jz      short checkflush_retn	; If in WP error zap buffer
 36090                                  
 36091                                  ;hkn; SS override
 36092                                  	; MSDOS 6.0
 36093 000064DB 36A2[000E]              	MOV	[SS:SC_DRIVE],AL	;LB. set it for invalidation ;AN000;
 36094                                  	
 36095                                  	;;les	bp,[di+10] ; MSDOS 3.3
 36096                                  	;les	bp,[di+13] ; MSDOS 6.0
 36097 000064DF C46D0F                  	LES	BP,[DI+BUFFINFO.buf_DPB]
 36098                                  	;;lea	bx,[di+16]
 36099                                  	;lea	bx,[di+20] ; MSDOS 6.0
 36100 000064E2 8D5D18                  	LEA	BX,[DI+BUFINSIZ]	; Point at buffer
 36101                                  	;mov	dx,[di+6]
 36102 000064E5 8B5506                  	MOV	DX,[DI+BUFFINFO.buf_sector] ;F.C. >32mb		;AN000;
 36103                                  	
 36104                                  	; MSDOS 6.0
 36105                                  	;mov	cx,[di+8]
 36106 000064E8 8B4D08                  	MOV	CX,[DI+BUFFINFO.buf_sector+2] ;F.C. >32mb	;AN000;
 36107                                  
 36108                                  ;hkn; SS override
 36109 000064EB 36890E[0706]            	MOV	[SS:HIGH_SECTOR],CX	;F.C. >32mb		;AN000;
 36110 000064F0 8A4D0A                  	MOV	CL,[DI+BUFFINFO.buf_wrtcnt] ;>32mb		;AC000;
 36111                                  	; MSDOS 3.3
 36112                                  	;; mov	cx,[DI+8]
 36113                                  	;mov	cx,[DI+BUFFINFO.buf_wrtcnt]
 36114                                  	;MOV	AL,CH			; [DI+BUFFINFO.buf_wrtcntinc]
 36115 000064F3 30ED                    	XOR	CH,CH
 36116                                  	;;mov	ah,ch ; MSDOS 3.3
 36117                                  
 36118                                  ;hkn; SS override for ALLOWED
 36119                                  	;mov	byte [SS:ALLOWED],18h
 36120 000064F5 36C606[4B03]18          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
 36121                                  	;test	byte [di+5],8
 36122                                  	; MSDOS 6.0 (& Retro DOS 3.0)
 36123                                  	;test	ah,8
 36124 000064FB F6C408                  	test	AH,buf_isDATA
 36125 000064FE 7406                    	JZ	short NO_IGNORE
 36126                                  	;or	byte [SS:ALLOWED],20h
 36127 00006500 36800E[4B03]20          	OR	byte [SS:ALLOWED],Allowed_IGNORE
 36128                                  NO_IGNORE:
 36129                                  	;xor	ah,ah ; 10/09/2018 (MSDOS 3.3, Retro DOS v3.0)
 36130                                  	; MSDOS 6.0
 36131                                  	;mov	ax,[di+11]
 36132 00006506 8B450B                  	MOV	AX,[DI+BUFFINFO.buf_wrtcntinc]	;>32mb		;AC000;
 36133                                  
 36134 00006509 57                      	PUSH	DI		; Save buffer pointer
 36135 0000650A 31FF                    	XOR	DI,DI		; Indicate failure
 36136                                  
 36137 0000650C 1E                      	push	ds ; *
 36138 0000650D 53                      	push	bx ; **
 36139                                  WRTAGAIN:
 36140 0000650E 57                      	push	di ; ***
 36141 0000650F 51                      	push	cx ; ****
 36142 00006510 50                      	push	ax ; *****
 36143                                  	;MOV	CX,1
 36144                                  	; 17/12/2022
 36145                                  	; ch = 0
 36146 00006511 B101                    	mov	cl,1 ; 24/07/2019
 36147                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 36148                                  	;mov	cx,1
 36149 00006513 53                      	push	bx ; ******
 36150 00006514 52                      	push	dx ; *******
 36151 00006515 1E                      	push	ds ; ********
 36152                                  
 36153                                  ; Note: As far as I can tell, all disk reads into buffers go through this point. -mrw 10/88
 36154                                  
 36155                                  	; MSDOS 6.0
 36156                                  	;cmp	byte [ss:BuffInHMA],0 ; 10/06/2019
 36157                                  	; 22/09/2023
 36158 00006516 36382E[7900]            	cmp	[ss:BuffInHMA],ch ; 0
 36159 0000651B 7418                    	jz	short NBUFFINHMA
 36160 0000651D 51                      	push	cx
 36161 0000651E 06                      	push	es
 36162 0000651F 89DE                    	mov	si,bx
 36163 00006521 268B4E02                	mov	cx,[es:bp+DPB.SECTOR_SIZE]
 36164 00006525 D1E9                    	shr	cx,1
 36165 00006527 36C43E[7A00]            	les	di,[ss:LoMemBuff] ; 10/06/2019
 36166 0000652C 89FB                    	mov	bx,di
 36167 0000652E FC                      	cld
 36168 0000652F F3A5                    	rep	movsw
 36169 00006531 06                      	push	es
 36170 00006532 1F                      	pop	ds
 36171 00006533 07                      	pop	es
 36172 00006534 59                      	pop	cx
 36173                                  NBUFFINHMA:
 36174 00006535 E8D4DA                  	call	DWRITE		; Write out the dirty buffer
 36175 00006538 1F                      	pop	ds ; ********
 36176 00006539 5A                      	pop	dx ; *******
 36177 0000653A 5B                      	pop	bx ; ******
 36178 0000653B 58                      	pop	ax ; *****
 36179 0000653C 59                      	pop	cx ; ****
 36180 0000653D 5F                      	pop	di ; ***
 36181 0000653E 7201                    	JC	short NOSET
 36182 00006540 47                      	INC	DI		; If at least ONE write succeedes, the operation
 36183                                  NOSET:				;	succeedes.
 36184 00006541 01C2                    	ADD	DX,AX
 36185 00006543 E2C9                    	LOOP	WRTAGAIN
 36186 00006545 5B                      	pop	bx ; **
 36187 00006546 1F                      	pop	ds ; *
 36188                                  	;OR	DI,DI		; Clears carry
 36189                                  	;JNZ	short BWROK	; At least one write worked
 36190                                  	;STC			; DI never got INCed, all writes failed.
 36191                                  	; 22/09/2023
 36192 00006547 83FF01                  	cmp	di,1
 36193                                  BWROK:	
 36194 0000654A 5F                      	POP	DI
 36195 0000654B C3                      	retn
 36196                                  
 36197                                  ;**	Set_RQ_SC_Parms - Set Secondary Cache Parameters
 36198                                  ;----------------------------------------------------------------------------
 36199                                  ;	Set_RQ_SC_Parms sets the sector size and drive number value
 36200                                  ;	for the secondary cache. This updates SC_SECTOR_SIZE &
 36201                                  ;	SC_DRIVE even if SC is disabled to save the testing
 36202                                  ;	code and time
 36203                                  ;
 36204                                  ;	ENTRY	ES:BP = drive parameter block
 36205                                  ;
 36206                                  ;	EXIT	[SC_SECTOR_SIZE]= drive sector size
 36207                                  ;		[SC_DRIVE]= drive #
 36208                                  ;
 36209                                  ;	USES	Flags
 36210                                  ;----------------------------------------------------------------------------
 36211                                  
 36212                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36213                                  ; 04/05/2019 - Retro DOS v4.0
 36214                                  
 36215                                  SET_RQ_SC_PARMS:
 36216                                  ;hkn; SS override for all variables used in this procedure.
 36217 0000654C 50                      	push	ax
 36218                                  	;mov	ax,[es:bp+2]
 36219 0000654D 268B4602                	MOV	ax,[ES:BP+DPB.SECTOR_SIZE]	; save sector size
 36220 00006551 36A3[FE0D]              	MOV	[ss:SC_SECTOR_SIZE],ax
 36221                                  	;;mov	al,[es:bp+0]
 36222                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 36223                                  	;MOV	al,[ES:BP+DPB.DRIVE]		; save drive #
 36224                                  	; 15/12/2022
 36225 00006555 268A4600                	mov	al,[ES:BP]
 36226 00006559 36A2[000E]              	MOV	[ss:SC_DRIVE],al
 36227 0000655D 58                      	pop	ax
 36228                                  srspx:	
 36229 0000655E C3                      	retn					;LB. return
 36230                                  
 36231                                  ; 01/02/2024 - Retro DOS v5.0
 36232                                  ;----------------------------------------------------------------------------
 36233                                  ; PCDOS 7.1 IBMDOS.COM - DOSCODE:AD58h
 36234                                  
 36235                                  SET_BUF_DIRTY:                          ; ...
 36236                                  	;test	byte [es:di+5],40h
 36237 0000655F 26F6450540              	test	byte [es:di+BUFFINFO.buf_flags],buf_dirty
 36238 00006564 750A                    	jnz	short yesdirty2
 36239                                  	;or	byte [es:di+5],40h
 36240 00006566 26804D0540              	or	byte [es:di+BUFFINFO.buf_flags],buf_dirty
 36241                                  
 36242                                  ;INC_DIRTY_COUNT:
 36243                                  ;	inc     word [ss:DirtyBufferCount]
 36244                                  ;yesdirty2:
 36245                                  ;	retn
 36246                                  
 36247                                  ;Break	<INC_DIRTY_COUNT-increment dirty count>
 36248                                  ;----------------------------------------------------------------------------
 36249                                  ; Input:
 36250                                  ;	none
 36251                                  ; Function:
 36252                                  ;	increment dirty buffers count
 36253                                  ; Output:
 36254                                  ;	dirty buffers count is incremented
 36255                                  ;
 36256                                  ; All registers preserved
 36257                                  ;----------------------------------------------------------------------------
 36258                                  
 36259                                  INC_DIRTY_COUNT:
 36260                                  ;; BUGBUG  ---- remove this routine
 36261                                  ;; BUGBUG ---- only one instruction is needed (speed win, space loose)
 36262 0000656B 36FF06[7100]            	inc	word [ss:DirtyBufferCount]	;hkn;
 36263                                  yesdirty2:	; 01/02/2024
 36264 00006570 C3                      	retn
 36265                                  
 36266                                  ;Break	<DEC_DIRTY_COUNT-decrement dirty count>
 36267                                  ;----------------------------------------------------------------------------
 36268                                  ; Input:
 36269                                  ;	none
 36270                                  ; Function:
 36271                                  ;	decrement dirty buffers count
 36272                                  ; Output:
 36273                                  ;	dirty buffers count is decremented
 36274                                  ;
 36275                                  ; All registers preserved
 36276                                  ;----------------------------------------------------------------------------
 36277                                  
 36278                                  DEC_DIRTY_COUNT:
 36279 00006571 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0 ;hkn;
 36280 00006577 7405                    	jz	short ddcx		; BUGBUG - shouldn't it be an
 36281 00006579 36FF0E[7100]            	dec	word [ss:DirtyBufferCount] 
 36282                                  					; error condition to underflow here? ;hkn;
 36283                                  ddcx:	
 36284 0000657E C3                      	retn
 36285                                  
 36286                                  ;============================================================================
 36287                                  ; MSPROC.ASM, MSDOS 6.0, 1992
 36288                                  ;============================================================================
 36289                                  ; 02/08/2018 - Retro DOS v3.0
 36290                                  ; 29/04/2019 - Retro DOS v4.0
 36291                                  
 36292                                  ; (15/04/2018 - RetrO DOS v2.0, MSDOS 2.11 - PROC.ASM - 1983)
 36293                                  
 36294                                  ; Pseudo EXEC system call for DOS
 36295                                  
 36296                                  ;	TITLE	MSPROC - process maintenance
 36297                                  ;	NAME	MSPROC
 36298                                  
 36299                                  ; =========================================================================
 36300                                  ;**	Process related system calls and low level routines for DOS 2.X.
 36301                                  ;	I/O specs are defined in DISPATCH.
 36302                                  ;
 36303                                  ;	$WAIT
 36304                                  ;	$EXEC
 36305                                  ;	$Keep_process
 36306                                  ;	Stay_resident
 36307                                  ;	$EXIT
 36308                                  ;	$ABORT
 36309                                  ;	abort_inner
 36310                                  ;
 36311                                  ;	Modification history:
 36312                                  ;
 36313                                  ;		Created: ARR 30 March 1983
 36314                                  ;		AN000	version 4.0 jan. 1988
 36315                                  ;		A007	PTM 3957 - fake vesrion for IBMCACHE.COM
 36316                                  ;		A008	PTM 4070 - fake version for MS WINDOWS
 36317                                  ;
 36318                                  ;		M000	added support for loading programs into UMBs 7/9/90
 36319                                  ;
 36320                                  ;		M004 - MS PASCAL 3.2 support. Please see under tag M003 in 
 36321                                  ;		       dossym.inc. 7/30/90
 36322                                  ;		M005 - Support for EXE programs with out STACK segment and 
 36323                                  ;		       with resident size < 64K - 256 bytes. A 256 byte 
 36324                                  ;		       stack is provided at the end of the program. Note that
 36325                                  ;		       only SP is changed.
 36326                                  ;		M020 - Fix for Rational bug for details see exepatch.asm
 36327                                  ;
 36328                                  ;		M028 - 4b04 implementation
 36329                                  ;
 36330                                  ;		M029 - Support for EXEs without stack rewritten. If EXE is
 36331                                  ;			in memory block >= 64K, sp = 0. If memory block
 36332                                  ;			obtained is <64K, point sp at the end of the memory
 36333                                  ;			block. For EXEs smaller than 64K, 256 bytes are still
 36334                                  ;			added for a stack segment which may be needed if it
 36335                                  ;			is loaded in low memory situations.
 36336                                  ;
 36337                                  ;		M030 - Fixing bug in EXEPACPATCH & changing 4b04 to 4b05
 36338                                  ;
 36339                                  ;		M040 - Bug #3052. The environment sizing code would flag a
 36340                                  ;			a bad environment if it reached 32767 bytes. Changed
 36341                                  ;			to allow 32768 bytes of environment.
 36342                                  ;
 36343                                  ;		M047 - Release the allocated UMB when we failed to load a 
 36344                                  ;		       COM file high. Also ensure that if the biggest block
 36345                                  ;		       into which we load the com file is less than 64K then
 36346                                  ;		       we provide atleast 256 bytes of stack to the user.
 36347                                  ;
 36348                                  ;		M050 - Made Lie table search CASE insensitive
 36349                                  ;
 36350                                  ;		M060 - Removed special version table from the kernal and
 36351                                  ;                      put it in a device drive which puts the address
 36352                                  ;                      in the DOS DATA area location UU_IFS_DOS_CALL
 36353                                  ;		       as a DWORD.
 36354                                  ;
 36355                                  ;		M063 - Modified UMB support. If the HIGH_ONLY bit is set on
 36356                                  ;		       entry do not try to load low if there is no space in
 36357                                  ;		       UMBs.
 36358                                  ;
 36359                                  ;		M068 - Support for copy protect apps. Call ChkCopyProt to 
 36360                                  ;		       set a20off_count. Set bit EXECA20BIT in DOS_FLAG. Also
 36361                                  ;		       change return address to LeaveDos if AL=5.
 36362                                  ;
 36363                                  ;               20-Jul-1992 bens  Added ifdef RESTRICTED_BUILD code that
 36364                                  ;                      controls building a version of MSDOS.SYS that only
 36365                                  ;                      runs programs from a fixed list (defined in the
 36366                                  ;                      file RESTRICT.INC).  Search for "RESTRICTED_BUILD"
 36367                                  ;                      for details.  This feature is used to build a
 36368                                  ;                      "special" version of DOS that can be handed out to
 36369                                  ;                      OEM/ISV customers as part of a "service" disk.
 36370                                  ;
 36371                                  ; =========================================================================
 36372                                  
 36373                                  ;SAVEXIT  EQU  10
 36374                                  
 36375                                  ;BREAK	<$WAIT - return previous process error code>
 36376                                  ; =========================================================================
 36377                                  ;	$WAIT - Return previous process error code.
 36378                                  ;
 36379                                  ;	Assembler usage:
 36380                                  ;
 36381                                  ;	    MOV     AH, WaitProcess
 36382                                  ;	    INT     int_command
 36383                                  ;
 36384                                  ;	ENTRY	none
 36385                                  ;	EXIT	(ax) = exit code
 36386                                  ;	USES	all
 36387                                  ; =========================================================================
 36388                                  
 36389                                  	; 20/05/2019 - Retro DOS v4.0
 36390                                  	; DOSCODE:9B55h (MSDOS 6.21, MSDOS.SYS)
 36391                                  
 36392                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36393                                  	; DOSCODE:9A5Ah (MSDOS 5.0, MSDOS.SYS)	
 36394                                  _$WAIT:
 36395                                  	; 02/08/2018 - Retro DOS v3.0
 36396                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E1h
 36397                                  
 36398 0000657F 31C0                    	xor	AX,AX
 36399 00006581 368706[3403]            	xchg	AX,[ss:exit_code]
 36400 00006586 E9E7A0                  	jmp	SYS_RET_OK
 36401                                  
 36402                                  ; =========================================================================
 36403                                  ;BREAK <$exec - load/go a program>
 36404                                  ;	EXEC.ASM - EXEC System Call
 36405                                  ;
 36406                                  ;
 36407                                  ; Assembler usage:
 36408                                  ;	    lds     DX, Name
 36409                                  ;	    les     BX, Blk
 36410                                  ;	    mov     AH, Exec
 36411                                  ;	    mov     AL, FUNC
 36412                                  ;	    int     INT_COMMAND
 36413                                  ;
 36414                                  ;	AL  Function
 36415                                  ;	--  --------
 36416                                  ;	 0  Load and execute the program.
 36417                                  ;	 1  Load, create the program header but do not
 36418                                  ;	    begin execution.
 36419                                  ;	 3  Load overlay. No header created.
 36420                                  ;
 36421                                  ;	    AL = 0 -> load/execute program
 36422                                  ;
 36423                                  ;	    +---------------------------+
 36424                                  ;	    | WORD segment address of	|
 36425                                  ;	    | environment.		|
 36426                                  ;	    +---------------------------+
 36427                                  ;	    | DWORD pointer to ASCIZ	|
 36428                                  ;	    | command line at 80h	|
 36429                                  ;	    +---------------------------+
 36430                                  ;	    | DWORD pointer to default	|
 36431                                  ;	    | FCB to be passed at 5Ch	|
 36432                                  ;	    +---------------------------+
 36433                                  ;	    | DWORD pointer to default	|
 36434                                  ;	    | FCB to be passed at 6Ch	|
 36435                                  ;	    +---------------------------+
 36436                                  ;
 36437                                  ;	    AL = 1 -> load program
 36438                                  ;
 36439                                  ;	    +---------------------------+
 36440                                  ;	    | WORD segment address of	|
 36441                                  ;	    | environment.		|
 36442                                  ;	    +---------------------------+
 36443                                  ;	    | DWORD pointer to ASCIZ	|
 36444                                  ;	    | command line at 80h	|
 36445                                  ;	    +---------------------------+
 36446                                  ;	    | DWORD pointer to default	|
 36447                                  ;	    | FCB to be passed at 5Ch	|
 36448                                  ;	    +---------------------------+
 36449                                  ;	    | DWORD pointer to default	|
 36450                                  ;	    | FCB to be passed at 6Ch	|
 36451                                  ;	    +---------------------------+
 36452                                  ;	    | DWORD returned value of	|
 36453                                  ;	    | CS:IP			|
 36454                                  ;	    +---------------------------+
 36455                                  ;	    | DWORD returned value of	|
 36456                                  ;	    | SS:IP			|
 36457                                  ;	    +---------------------------+
 36458                                  ;
 36459                                  ;	    AL = 3 -> load overlay
 36460                                  ;
 36461                                  ;	    +---------------------------+
 36462                                  ;	    | WORD segment address where|
 36463                                  ;	    | file will be loaded.	|
 36464                                  ;	    +---------------------------+
 36465                                  ;	    | WORD relocation factor to |
 36466                                  ;	    | be applied to the image.	|
 36467                                  ;	    +---------------------------+
 36468                                  ;
 36469                                  ; Returns:
 36470                                  ;	    AX = error_invalid_function
 36471                                  ;	       = error_bad_format
 36472                                  ;	       = error_bad_environment
 36473                                  ;	       = error_not_enough_memory
 36474                                  ;	       = error_file_not_found
 36475                                  ; =========================================================================
 36476                                  ;
 36477                                  ;   Revision history:
 36478                                  ;
 36479                                  ;	 A000	version 4.00  Jan. 1988
 36480                                  ;
 36481                                  ; =========================================================================
 36482                                  
 36483                                  Exec_Internal_Buffer		EQU	OPENBUF
 36484                                  Exec_Internal_Buffer_Size	EQU	(128+128+53+curdirLen)
 36485                                  
 36486                                  ; =========================================================================
 36487                                  
 36488                                  ;IF1		; warning message on buffers
 36489                                  ;%out	Please make sure that the following are contiguous and of the
 36490                                  ;%out	following sizes:
 36491                                  ;%out
 36492                                  ;%out	OpenBuf     128
 36493                                  ;%out	RenBuf	    128
 36494                                  ;%out	SearchBuf    53
 36495                                  ;%out	DummyCDS    curdirLen
 36496                                  ;ENDIF
 36497                                  
 36498                                  ; =========================================================================
 36499                                  
 36500                                  ; =========================================================================
 36501                                  ;
 36502                                  ; =========================================================================
 36503                                  
 36504                                  	; 20/05/2019 - Retro DOS v4.0
 36505                                  	; DOSCODE:9B5Fh (MSDOS 6.21, MSDOS.SYS)
 36506                                  
 36507                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36508                                  	; DOSCODE:9B04h (MSDOS 5.0, MSDOS.SYS)
 36509                                  	
 36510                                  _$EXEC:
 36511                                  	; 02/08/2018 - Retro DOS v3.0
 36512                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5EF1h
 36513                                  
 36514                                  EXEC001S:
 36515                                  	;LocalVar    Exec_Blk		,DWORD
 36516                                  	;LocalVar    Exec_Func		,BYTE
 36517                                  	;LocalVar    Exec_Load_High	,BYTE
 36518                                  	;LocalVar    Exec_FH		,WORD
 36519                                  	;LocalVar    Exec_Rel_Fac	,WORD
 36520                                  	;LocalVar    Exec_Res_Len_Para	,WORD
 36521                                  	;LocalVar    Exec_Environ	,WORD
 36522                                  	;LocalVar    Exec_Size		,WORD
 36523                                  	;LocalVar    Exec_Load_Block	,WORD
 36524                                  	;LocalVar    Exec_DMA		,WORD
 36525                                  	;LocalVar    ExecNameLen 	,WORD
 36526                                  	;LocalVar    ExecName		,DWORD
 36527                                  	;
 36528                                  	;LocalVar    Exec_DMA_Save	,WORD
 36529                                  	;LocalVar    Exec_NoStack	,BYTE
 36530                                  
 36531                                  	; MSDOS 3.3 (& MSDOS 6.0)
 36532                                  	;%define	Exec_Blk	dword [bp-4]
 36533                                  	%define		Exec_Blk	[bp-4] ; 09/08/2018
 36534                                  	%define		Exec_BlkL	word [bp-4]	
 36535                                  	%define		Exec_BlkH	word [bp-2]
 36536                                  	%define		Exec_Func	byte [bp-5]
 36537                                  	%define		Exec_Load_High	byte [bp-6]
 36538                                  	%define		Exec_FH		word [bp-8]
 36539                                  	%define		Exec_Rel_Fac	word [bp-10]
 36540                                  	%define		Exec_Res_Len_Para word [bp-12]
 36541                                  	%define		Exec_Environ	word [bp-14]
 36542                                  	%define		Exec_Size	word [bp-16]
 36543                                  	%define		Exec_Load_Block	word [bp-18]
 36544                                  	%define		Exec_DMA	word [bp-20]
 36545                                  	%define		ExecNameLen	word [bp-22]
 36546                                  	;%define	ExecName	dword [bp-26]
 36547                                  	%define		ExecName	[bp-26] ; 09/08/2018
 36548                                  	%define		ExecNameL	word [bp-26]	
 36549                                  	%define		ExecNameH	word [bp-24]
 36550                                  	; MSDOS 6.0
 36551                                  	%define		Exec_DMA_Save	word [bp-28]
 36552                                  	%define		Exec_NoStack	byte [bp-29]
 36553                                  	
 36554                                  	; ==================================================================
 36555                                  	; validate function
 36556                                  	; ==================================================================
 36557                                  		      	
 36558                                  	; M068 - Start
 36559                                  	;
 36560                                  	; Reset the A20OFF_COUNT to 0. This is done as there is a 
 36561                                  	; possibility that the count may not be decremented all the way to
 36562                                  	; 0. A typical case is if the program for which we intended to keep 
 36563                                  	; the A20  off for a sufficiently long time (A20OFF_COUNT int 21 
 36564                                  	; calls), exits pre-maturely due to error conditions.
 36565                                  
 36566                                  	; MSDOS 6.0
 36567 00006589 36C606[8500]00          	mov	byte [SS:A20OFF_COUNT], 0
 36568                                  
 36569                                  	; If al=5 (ExecReady) we'll change the return address on the stack	
 36570                                  	; to be LeaveDos in msdisp.asm. This ensures that the EXECA20OFF
 36571                                  	; bit set in DOS_FLAG by ExceReady is not cleared in msdisp.asm
 36572                                  
 36573 0000658F 3C05                    	cmp	al,5			; Q: is this ExecReady call
 36574                                  	;jne	short @f
 36575 00006591 7505                    	jne	short Exec_@f		; N: continue
 36576                                  					; Y: change ret addr. to LeaveDos.
 36577 00006593 59                      	pop	cx			; Note CX is not input to ExecReady
 36578 00006594 B9[F603]                	mov	cx,LeaveDOS
 36579 00006597 51                      	push	cx
 36580                                  ;@@:
 36581                                  Exec_@f:
 36582                                  	; M068 - End
 36583                                  	
 36584                                  	;Enter
 36585                                  
 36586 00006598 55                      	push	bp
 36587 00006599 89E5                    	mov	bp,sp
 36588                                  	;;sub	sp,26	; MSDOS 3.3
 36589                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)	
 36590                                  	;sub	sp,29	; MSDOS 6.0 (& MSDOS 6.21)
 36591                                  	; 17/12/2022
 36592                                  	; 20/05/2019
 36593 0000659B 83EC1E                  	sub	sp,30	; Retro DOS v4.0	
 36594                                  
 36595                                  	; MSDOS 6.0
 36596 0000659E 3C05                    	cmp	AL,5			; only 0, 1, 3 or 5 are allowed ;M028
 36597                                  					; M030
 36598 000065A0 7614                    	jna	short Exec_Check_2
 36599                                  
 36600                                  	; MSDOS 3.3
 36601                                  	;cmp	AL,3
 36602                                  	;jna	short Exec_Check_2
 36603                                  
 36604                                  Exec_Bad_Fun:
 36605 000065A2 36C606[2303]01          	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; 1
 36606                                  					; Extended Error Locus	;smr;SS Override
 36607                                  	;mov	al,1
 36608 000065A8 B001                    	mov	al,error_invalid_function
 36609                                  
 36610                                  Exec_Ret_Err:
 36611                                  	;Leave
 36612 000065AA 89EC                    	mov	sp,bp
 36613 000065AC 5D                      	pop	bp
 36614                                  	;transfer SYS_RET_ERR
 36615 000065AD E9CAA0                  	jmp	SYS_RET_ERR
 36616                                  
 36617                                  	; MSDOS 6.0
 36618                                  ExecReadyJ:
 36619 000065B0 E8FD17                  	call	ExecReady		; M028
 36620 000065B3 E90504                  	jmp	norm_ovl		; do a Leave & xfer sysret_OK ; M028
 36621                                  
 36622                                  Exec_Check_2:
 36623 000065B6 3C02                    	cmp	AL,2			
 36624 000065B8 74E8                    	je	short Exec_Bad_Fun
 36625                                  
 36626                                  	; MSDOS 6.0
 36627 000065BA 3C04                    	cmp	al,4			; 2 & 4 are not allowed
 36628 000065BC 74E4                    	je	short Exec_Bad_Fun
 36629                                  	
 36630 000065BE 3C05                    	cmp	al,5			; M028 ; M030
 36631 000065C0 74EE                    	je	short ExecReadyJ	; M028
 36632                                  
 36633                                  	;mov	[bp-4],bx
 36634 000065C2 895EFC                  	mov	Exec_BlkL,BX		; stash args
 36635                                  	;mov	[bp-2],es
 36636 000065C5 8C46FE                  	mov	Exec_BlkH,ES
 36637                                  	;mov	[bp-5],al
 36638 000065C8 8846FB                  	mov	Exec_Func,AL
 36639                                  	;mov	byte [bp-6],0
 36640 000065CB C646FA00                	mov	Exec_Load_High,0
 36641                                  
 36642                                  	;mov	[bp-26],dx
 36643 000065CF 8956E6                  	mov	ExecNameL,DX		; set up length of exec name
 36644                                  	;mov	[bp-24],ds
 36645 000065D2 8C5EE8                  	mov	ExecNameH,DS
 36646 000065D5 89D6                    	mov	SI,DX			; move pointer to convenient place
 36647                                  	;invoke	DStrLen
 36648 000065D7 E815B2                  	call	DStrLen
 36649                                  	;mov	[bp-22],cx
 36650 000065DA 894EEA                  	mov	ExecNameLen,CX		; save length
 36651                                  
 36652                                  	; MSDOS 6.0
 36653 000065DD 36A0[0203]              	mov	al,[ss:AllocMethod]	; M063: save alloc method in 
 36654 000065E1 36A2[8400]              	mov	[ss:ALLOCMSAVE],al	; M063: AllocMsave
 36655                                  
 36656 000065E5 30C0                    	xor	AL,AL			; open for reading
 36657 000065E7 55                      	push	BP
 36658                                  
 36659                                  	; MSDOS 6.0
 36660                                  	;or	byte [ss:DOS_FLAG],1
 36661 000065E8 36800E[8600]01          	or	byte [ss:DOS_FLAG],EXECOPEN ; this flag is set to indicate to 
 36662                                  					; the redir that this open call is
 36663                                  					; due to an exec.
 36664                                  
 36665                                  	;invoke	$OPEN			; is the file there?
 36666 000065EE E80513                  	call	_$OPEN
 36667                                  
 36668                                  	; MSDOS 6.0
 36669 000065F1 9C                      	pushf
 36670                                  	; 02/06/2019
 36671                                  	;and	byte [ss:DOS_FLAG],0FEh
 36672 000065F2 368026[8600]FE          	and	byte [ss:DOS_FLAG],~EXECOPEN ; reset flag
 36673 000065F8 9D                      	popf
 36674                                  
 36675 000065F9 5D                      	pop	BP
 36676                                  
 36677                                  	; MSDOS 3.3 & MSDOS 6.0
 36678 000065FA 72AE                    	jc	short Exec_Ret_Err
 36679                                  
 36680                                  	;mov	[bp-8],ax
 36681 000065FC 8946F8                  	mov	Exec_FH,AX
 36682 000065FF 89C3                    	mov	BX,AX
 36683 00006601 30C0                    	xor	AL,AL
 36684                                  	;invoke	$Ioctl
 36685 00006603 E8A8C2                  	call	_$IOCTL
 36686 00006606 7207                    	jc	short Exec_BombJ
 36687                                  
 36688                                  	;test	dl,80h
 36689 00006608 F6C280                  	test	DL,devid_ISDEV
 36690 0000660B 740A                    	jz	short Exec_Check_Environ
 36691                                  
 36692                                  	;mov	al,2
 36693 0000660D B002                    	mov	AL,error_file_not_found
 36694                                  Exec_BombJ:
 36695 0000660F E9CA00                  	jmp	Exec_Bomb
 36696                                  
 36697                                  BadEnv:
 36698                                  	;mov	al,0Ah
 36699 00006612 B00A                    	mov	AL,error_bad_environment
 36700 00006614 E9C500                  	jmp	Exec_Bomb
 36701                                  
 36702                                  Exec_Check_Environ:
 36703                                  	;mov	word [bp-18],0
 36704 00006617 C746EE0000              	mov	Exec_Load_Block,0
 36705                                  	;mov	word [bp-14],0
 36706 0000661C C746F20000              	mov	Exec_Environ,0
 36707                                  					; overlays... no environment
 36708                                  	;test	byte [bp-5],2
 36709 00006621 F646FB02                	test	Exec_Func,exec_func_overlay
 36710 00006625 7552                    	jnz	short Exec_Read_Header
 36711                                  
 36712                                  	;lds	si,[bp-4]
 36713 00006627 C576FC                  	lds	SI,Exec_Blk		; get block
 36714 0000662A 8B04                    	mov	ax,[SI]
 36715                                  	;mov	AX,[SI+EXEC1.ENVIRON]	; address of environ
 36716 0000662C 09C0                    	or	AX,AX
 36717 0000662E 750C                    	jnz	short Exec_Scan_Env
 36718                                  
 36719 00006630 368E1E[3003]            	mov	DS,[SS:CurrentPDB]	;smr;SS Override
 36720                                  	;mov	ax,[44]
 36721 00006635 A12C00                  	mov	AX,[PDB.ENVIRON]
 36722                                  
 36723                                  ; MSDOS 6.0
 36724                                  ;---------------------------------------------BUG 92 4/30/90-----------------
 36725                                  ;
 36726                                  ; Exec_environ is being correctly initialized after the environment has been
 36727                                  ; allocated and copied form the parent's env. It must not be initialized here.
 36728                                  ; Because if the call to $alloc below fails Exec_dealloc will deallocate the
 36729                                  ; parent's environment.
 36730                                  ;	mov	Exec_Environ,AX
 36731                                  ;
 36732                                  ;----------------------------------------------------------------------------
 36733                                  
 36734                                  	;mov	[bp-14],ax
 36735                                  	;mov	Exec_Environ,ax
 36736                                  
 36737 00006638 09C0                    	or	AX,AX
 36738 0000663A 743D                    	jz	short Exec_Read_Header
 36739                                  
 36740                                  Exec_Scan_Env:
 36741 0000663C 8EC0                    	mov	ES,AX
 36742 0000663E 31FF                    	xor	DI,DI
 36743                                  	;mov	cx,7FFFh ; MSDOS 3.3
 36744 00006640 B90080                  	mov	CX,8000h ; MSDOS 6.0	; at most 32k of environment ;M040
 36745 00006643 30C0                    	xor	AL,AL
 36746                                  
 36747                                  Exec_Get_Environ_Len:
 36748 00006645 F2AE                    	repnz	scasb			; find that nul byte
 36749 00006647 75C9                    	jnz	short BadEnv
 36750                                  
 36751 00006649 49                      	dec	CX			; Dec CX for the next nul byte test
 36752 0000664A 78C6                    	js	short BadEnv		; gone beyond the end of the environment
 36753                                  
 36754 0000664C AE                      	scasb				; is there another nul byte?
 36755 0000664D 75F6                    	jnz	short Exec_Get_Environ_Len ; no, scan some more
 36756                                  
 36757 0000664F 57                      	push	DI
 36758                                  	;lea	bx,[DI+11h]
 36759 00006650 8D5D11                  	lea	BX,[DI+0Fh+2]
 36760                                  	;add	bx,[bp-22]
 36761 00006653 035EEA                  	add	BX,ExecNameLen		; BX <- length of environment
 36762                                  					; remember argv[0] length
 36763                                  					; round up and remember argc
 36764 00006656 B104                    	mov	CL,4
 36765 00006658 D3EB                    	shr	BX,CL			; number of paragraphs needed
 36766 0000665A 06                      	push	ES
 36767                                  	;invoke	$Alloc			; can we get the space?
 36768 0000665B E84406                  	call	_$ALLOC
 36769 0000665E 1F                      	pop	DS
 36770 0000665F 59                      	pop	CX
 36771                                  
 36772                                  	;jnc	short Exec_Save_Environ
 36773                                  	;jmp	SHORT Exec_No_Mem	; nope... cry and sob
 36774                                  	; 17/12/2022
 36775 00006660 7274                    	jc	short Exec_No_Mem ; 02/06/2019
 36776                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 36777                                  	;jnc	short Exec_Save_Environ
 36778                                  	;jmp	SHORT Exec_No_Mem
 36779                                  
 36780                                  Exec_Save_Environ:
 36781 00006662 8EC0                    	mov	ES,AX
 36782                                  	;mov	[bp-14],ax
 36783 00006664 8946F2                  	mov	Exec_Environ,AX 	; save him for a rainy day
 36784 00006667 31F6                    	xor	SI,SI
 36785 00006669 89F7                    	mov	DI,SI
 36786 0000666B F3A4                    	rep	movsb			; copy the environment
 36787 0000666D B80100                  	mov	AX,1
 36788 00006670 AB                      	stosw
 36789                                  	;lds	si,[bp-26]
 36790 00006671 C576E6                  	lds	SI,ExecName
 36791                                  	;mov	cx,[bp-22]
 36792 00006674 8B4EEA                  	mov	CX,ExecNameLen
 36793 00006677 F3A4                    	rep	movsb
 36794                                  
 36795                                  Exec_Read_Header:
 36796                                  	; We read in the program header into the above data area and
 36797                                  	; determine where in this memory the image will be located.
 36798                                  
 36799                                  	;Context DS
 36800 00006679 16                      	push	ss
 36801 0000667A 1F                      	pop	ds
 36802                                  	;mov	cx,26
 36803 0000667B B91A00                  	mov	CX,exec_header_len	; header size
 36804 0000667E BA[0D10]                	mov	DX,exec_signature
 36805 00006681 06                      	push	ES
 36806 00006682 1E                      	push	DS
 36807 00006683 E88304                  	call	ExecRead
 36808 00006686 1F                      	pop	DS
 36809 00006687 07                      	pop	ES
 36810 00006688 7250                    	jc	short Exec_Bad_File
 36811                                  
 36812 0000668A 09C0                    	or	AX,AX
 36813 0000668C 744C                    	jz	short Exec_Bad_File
 36814                                  	;cmp	ax,26
 36815 0000668E 83F81A                  	cmp	AX,exec_header_len	; did we read the right number?
 36816 00006691 7519                    	jnz	short Exec_Com_Filej	; yep... continue
 36817                                  
 36818 00006693 F706[1910]FFFF          	test	word [exec_max_BSS],-1 	; indicate load high?
 36819 00006699 7504                    	jnz	short Exec_Check_Sig
 36820                                  
 36821                                  	;mov	byte [bp-6],0FFh
 36822 0000669B C646FAFF                	mov	Exec_Load_High,-1
 36823                                  
 36824                                  Exec_Check_Sig:
 36825 0000669F A1[0D10]                	mov	AX,[exec_signature]	; rms;NSS
 36826                                  	;cmp	ax,5A4Dh ; 'MZ'
 36827 000066A2 3D4D5A                  	cmp	AX,exe_valid_signature	; zibo arises!
 36828 000066A5 7408                    	jz	short Exec_Save_Start 	; assume com file if no signature
 36829                                  
 36830                                  	;cmp	ax,4D5Ah ; 'ZM'
 36831 000066A7 3D5A4D                  	cmp	AX,exe_valid_old_signature ; zibo arises!
 36832 000066AA 7403                    	jz	short Exec_Save_Start 	; assume com file if no signature
 36833                                  
 36834                                  Exec_Com_Filej:
 36835 000066AC E9E901                  	jmp	Exec_Com_File
 36836                                  
 36837                                  	; We have the program header... determine memory requirements
 36838                                  
 36839                                  Exec_Save_Start:
 36840 000066AF A1[1110]                	mov	AX,[exec_pages]		; get 512-byte pages	;rms;NSS
 36841 000066B2 B105                    	mov	CL,5			; convert to paragraphs
 36842 000066B4 D3E0                    	shl	AX,CL
 36843 000066B6 2B06[1510]              	sub	AX,[exec_par_dir] 	; AX = size in paragraphs ;rms;NSS
 36844                                  	;mov	[bp-12],ax
 36845 000066BA 8946F4                  	mov	Exec_Res_Len_Para,AX
 36846                                  
 36847                                  		; Do we need to allocate memory?
 36848                                  		; Yes if function is not load-overlay
 36849                                  
 36850                                  	;test	byte [bp-5],2
 36851 000066BD F646FB02                	test	Exec_Func,exec_func_overlay
 36852 000066C1 7445                    	jz	short Exec_Allocate	; allocation of space
 36853                                  
 36854                                  		; get load address from block
 36855                                  
 36856                                  	;les	di,[bp-4]
 36857 000066C3 C47EFC                  	les	DI,Exec_Blk
 36858 000066C6 268B05                  	mov	ax,[es:di]
 36859                                  	;mov	AX,[ES:DI+EXEC3.load_addr]
 36860                                  	;mov	[bp-20],ax
 36861 000066C9 8946EC                  	mov	Exec_DMA,AX
 36862                                  
 36863                                  	; 17/12/2022
 36864                                  	;;mov	ax,[es:di+2]
 36865                                  	;mov	AX,[ES:DI+EXEC3.reloc_fac]
 36866                                  	;;mov	[bp-10],ax
 36867                                  	;mov	Exec_Rel_Fac,AX
 36868                                  
 36869                                  	; 17/12/2022
 36870                                  	; 30/11/2022 (!most proper code!)
 36871                                  	;mov	dx,[es:di+2]
 36872 000066CC 268B5502                	mov	dx,[ES:DI+EXEC3.reloc_fac]
 36873                                  	;mov	[bp-10],dx
 36874 000066D0 8956F6                  	mov	Exec_Rel_Fac,dx
 36875                                  	; ax = Exec_DMA
 36876 000066D3 E9DE00                  	jmp	Exec_Find_Res
 36877                                  
 36878                                  ; 17/12/2022
 36879                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 36880                                  ; 27/09/2023
 36881                                  %if 0
 36882                                  	; 02/06/2019 - Retro DOS v4.0
 36883                                  	;mov	ax,[bp-20]  ; *+*
 36884                                  	mov	AX,Exec_DMA ; *+*
 36885                                  	; 10/08/2018
 36886                                  	jmp	Exec_Find_Res		; M000
 36887                                  %endif
 36888                                  
 36889                                  Exec_No_Mem:
 36890                                  	;mov	al,8
 36891 000066D6 B008                    	mov	AL,error_not_enough_memory
 36892 000066D8 EB02                    	jmp	short Exec_Bomb
 36893                                  
 36894                                  Exec_Bad_File:
 36895                                  	;mov	al,0Bh
 36896 000066DA B00B                    	mov	AL,error_bad_format
 36897                                  
 36898                                  Exec_Bomb:
 36899                                  	;mov	bx,[bp-8]
 36900 000066DC 8B5EF8                  	mov	BX,Exec_FH
 36901 000066DF E84004                  	call	Exec_Dealloc
 36902                                  	;LeaveCrit CritMem
 36903 000066E2 E84BB2                  	call	LCritMEM
 36904                                  	;save	<AX,BP>
 36905 000066E5 50                      	push	ax
 36906 000066E6 55                      	push	bp
 36907                                  	;invoke	$CLOSE
 36908 000066E7 E83D0A                  	call	_$CLOSE
 36909                                  	;restore <BP,AX>
 36910 000066EA 5D                      	pop	bp
 36911 000066EB 58                      	pop	ax
 36912 000066EC E9BBFE                  	jmp	Exec_Ret_Err
 36913                                  
 36914                                  Exec_Chk_Mem: 
 36915                                  
 36916                                  	; 24/09/2023
 36917                                  	; ds = DOSDATA
 36918                                  ; 17/12/2022
 36919                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 36920                                  ;%if 0
 36921                                  	; MSDOS 6.0    			; M063 - Start
 36922                                  	;mov	al,[ss:AllocMethod]	; save current alloc method in ax
 36923                                  	; 10/06/2019
 36924 000066EF A0[0203]                	mov	al,[AllocMethod]
 36925                                  	;mov	bl,[ss:ALLOCMSAVE]
 36926 000066F2 8A1E[8400]              	mov	bl,[ALLOCMSAVE]
 36927                                  	;mov	[ss:AllocMethod],bl	; restore original allocmethod
 36928 000066F6 881E[0203]              	mov	[AllocMethod],bl
 36929                                  	
 36930 000066FA F6C340                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 36931 000066FD 75D7                    	jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
 36932                                  	;				; N: continue
 36933                                  	;
 36934 000066FF A840                    	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 36935 00006701 74D3                    	jz	short Exec_No_Mem	; N: no memory 
 36936                                  	; 02/06/2019
 36937                                  	;mov	ax,[ss:SAVE_AX]		; Y: restore ax and
 36938 00006703 A1[8A00]                	mov	ax,[SAVE_AX]
 36939                                  	;jmp	short Exec_Norm_Alloc	;    Try again
 36940                                  					; M063 - End
 36941 00006706 EB2B                    	jmp	short Exec_Norm_Alloc1
 36942                                  ;%endif
 36943                                  
 36944                                  ; 17/12/2022
 36945                                  %if 0
 36946                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 36947                                  	; MSDOS 6.0    			; M063 - Start
 36948                                  	mov	al,[ss:AllocMethod]	; save current alloc method in ax
 36949                                  	mov	bl,[ss:ALLOCMSAVE]
 36950                                  	mov	[ss:AllocMethod],bl	; restore original allocmethod
 36951                                  
 36952                                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 36953                                  	jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
 36954                                  	;				; N: continue
 36955                                  	;
 36956                                  	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 36957                                  	jz	short Exec_No_Mem	; N: no memory 
 36958                                  
 36959                                  	mov	ax,[ss:SAVE_AX]		; Y: restore ax and
 36960                                  	jmp	short Exec_Norm_Alloc	;    Try again
 36961                                  					; M063 - End
 36962                                  %endif
 36963                                  
 36964                                  Exec_Allocate:
 36965                                  	; 09/09/2018
 36966                                  
 36967                                  	; M005 - START
 36968                                  	; If there is no STACK segment for this exe file and if this
 36969                                  	; not an overlay and the resident size is less than 64K - 
 36970                                  	; 256 bytes we shall add 256 bytes to the programs 
 36971                                  	; resident memory requirement and set Exec_SP to this value.
 36972                                  	
 36973                                  	; 17/12/2022
 36974 00006708 29DB                    	sub	bx,bx ; 0	
 36975                                  
 36976                                  	; MSDOS 6.0
 36977                                  	;;mov	byte [bp-29],0
 36978                                  	;mov	Exec_NoStack,0
 36979                                  	; 17/12/2022
 36980 0000670A 885EE3                  	mov	Exec_NoStack,bl ; 0
 36981 0000670D 391E[1B10]              	cmp	[exec_SS],bx ; 0
 36982                                  	;cmp	word [exec_SS],0	; Q: is there a stack seg
 36983 00006711 7511                    	jne	short ea1		; Y: continue normal processing
 36984 00006713 391E[1D10]              	cmp	[exec_SP],bx ; 0
 36985                                  	;cmp	word [exec_SP],0	; Q: is there a stack ptr
 36986 00006717 750B                    	jne	short ea1		; Y: continue normal processing
 36987                                  
 36988                                  	;inc	byte [bp-29]
 36989 00006719 FE46E3                  	inc	Exec_NoStack
 36990 0000671C 3DF00F                  	cmp	ax,1000h-10h		; Q: is this >= 64K-256 bytes
 36991 0000671F 7303                    	jae	short ea1		; Y: don't set Exec_SP
 36992                                  
 36993 00006721 83C010                  	add	ax,10h			; add 10h paras to mem requirement
 36994                                  ea1:
 36995                                  	; M005 - END
 36996                                  
 36997                                  	; MSDOS 6.0			; M000 - start
 36998                                  	; 20/05/2019
 36999                                  	; (ds = ss = DOSDATA)
 37000 00006724 F606[0203]80            	test	byte [AllocMethod],HIGH_FIRST ; 80h
 37001                                  					; Q: is the alloc strat high_first
 37002 00006729 7405                    	jz	short Exec_Norm_Alloc	; N: normal allocate
 37003                                  					; Y: set high_only bit
 37004 0000672B 800E[0203]40            	or	byte [AllocMethod],HIGH_ONLY ; 40h
 37005                                  					; M000 - end
 37006                                  Exec_Norm_Alloc:
 37007 00006730 A3[8A00]                	mov	[SAVE_AX],ax		; M000: save ax for possible 2nd  
 37008                                  Exec_Norm_Alloc1:	; 02/06/2019
 37009                                  					; M000: attempt at allocating memory
 37010                                  	; MSDOS 3.3
 37011                                  	;push	ax			; M000
 37012                                  
 37013 00006733 BBFFFF                  	mov	BX,0FFFFh		; see how much room in arena
 37014 00006736 1E                      	push	DS
 37015                                  	;invoke	$Alloc			; should have carry set and BX has max
 37016 00006737 E86805                  	call	_$ALLOC
 37017 0000673A 1F                      	pop	DS
 37018                                  
 37019                                  	; MSDOS 6.0
 37020 0000673B A1[8A00]                	mov	AX,[SAVE_AX]		; M000
 37021                                  	; MSDOS 3.3
 37022                                  	;pop	ax			; M000
 37023                                  
 37024 0000673E 83C010                  	add	AX,10h			; room for header
 37025 00006741 83FB11                  	cmp	BX,11h			; enough room for a header
 37026                                  	; MSDOS 6.0
 37027 00006744 72A9                    	jb	short Exec_Chk_Mem	; M000
 37028                                  	; MSDOS 3.3	
 37029                                  	;jb	short Exec_No_Mem
 37030                                  
 37031 00006746 39D8                    	cmp	AX,BX			; is there enough for bare image?
 37032                                  	; MSDOS 6.0
 37033 00006748 77A5                    	ja	short Exec_Chk_Mem	; M000
 37034                                  	; MSDOS 3.3
 37035                                  	;ja	short Exec_No_Mem
 37036                                  
 37037                                  	;test	byte [bp-6],0FFh
 37038 0000674A F646FAFF                	test	Exec_Load_High,-1	; if load high, use max
 37039 0000674E 7518                    	jnz	short Exec_BX_Max	; use max
 37040                                  
 37041                                  	; 09/09/2018
 37042                                  
 37043 00006750 0306[1710]              	add	AX,[exec_min_BSS] 	; go for min allocation;rms;NSS
 37044                                  	; MSDOS 6.0
 37045 00006754 7299                    	jc	short Exec_Chk_Mem		; M000
 37046                                  	; MSDOS 3.3
 37047                                  	;jc	short Exec_No_Mem
 37048                                  
 37049 00006756 39D8                    	cmp	AX,BX			; enough space?
 37050                                  	; MSDOS 6.0
 37051 00006758 7795                    	ja	short Exec_Chk_Mem	; M000: nope...	
 37052                                  	; MSDOS 3.3
 37053                                  	;ja	short Exec_No_Mem
 37054                                  
 37055 0000675A 2B06[1710]              	sub	AX,[exec_min_BSS] 	; rms;NSS
 37056 0000675E 0306[1910]              	add	AX,[exec_max_BSS] 	; go for the MAX
 37057 00006762 7204                    	jc	short Exec_BX_Max
 37058                                  
 37059 00006764 39D8                    	cmp	AX,BX
 37060 00006766 7602                    	jbe	short Exec_Got_Block
 37061                                  
 37062                                  Exec_BX_Max:
 37063 00006768 89D8                    	mov	AX,BX
 37064                                  
 37065                                  Exec_Got_Block:
 37066                                  	; 03/08/2018 - Retro DOS v3.0
 37067                                  
 37068 0000676A 1E                      	push	DS
 37069 0000676B 89C3                    	mov	BX,AX
 37070                                  	;mov	[bp-16],bx
 37071 0000676D 895EF0                  	mov	Exec_Size,BX
 37072                                  	;invoke	$Alloc			; get the space
 37073 00006770 E82F05                  	call	_$ALLOC
 37074 00006773 1F                      	pop	DS
 37075                                  	; MSDOS 6.0
 37076                                  	;jc	short Exec_Chk_Mem	; M000
 37077                                  	; MSDOS 3.3
 37078                                  	;;jc	short Exec_No_Mem
 37079                                  	; 20/05/2019
 37080 00006774 7303                    	jnc	short ea0
 37081 00006776 E976FF                  	jmp	Exec_Chk_Mem
 37082                                  ea0:
 37083                                  	; MSDOS 6.0
 37084 00006779 8A0E[8400]              	mov	cl,[ALLOCMSAVE]		; M063: 
 37085 0000677D 880E[0203]              	mov	[AllocMethod],cl	; M063: restore allocmethod
 37086                                  
 37087                                  ;M029; Begin changes
 37088                                  ; This code does special handling for programs with no stack segment. If so,
 37089                                  ;check if the current block is larger than 64K. If so, we do not modify
 37090                                  ;Exec_SP. If smaller than 64K, we make Exec_SP = top of block. In either
 37091                                  ;case Exec_SS is not changed.
 37092                                  
 37093                                  	; MSDOS 6.0
 37094                                  	;cmp	byte [bp-29],0
 37095 00006781 807EE300                	cmp	Exec_NoStack,0
 37096                                  	;je	@f
 37097 00006785 7412                    	je	short ea2
 37098                                  
 37099 00006787 81FB0010                	cmp	bx,1000h		; Q: >= 64K memory block
 37100                                  	;jae	@f			; Y: Exec_SP = 0
 37101 0000678B 730C                    	jae	short ea2
 37102                                  
 37103                                  ;Make Exec_SP point at the top of the memory block
 37104                                  
 37105 0000678D B104                    	mov	cl,4
 37106 0000678F D3E3                    	shl	bx,cl			; get byte offset
 37107 00006791 81EB0001                	sub	bx,100h			; take care of PSP
 37108 00006795 891E[1D10]              	mov	[exec_SP],bx		; Exec_SP = top of block
 37109                                  ea2:
 37110                                  ;@@:
 37111                                  ;M029; end changes
 37112                                  
 37113                                  	;mov	[bp-18],ax
 37114 00006799 8946EE                  	mov	Exec_Load_Block,AX
 37115 0000679C 83C010                  	add	AX,10h
 37116                                  	;test	byte [bp-6],0FFh
 37117 0000679F F646FAFF                	test	Exec_Load_High,-1
 37118 000067A3 7409                    	jz	short Exec_Use_AX	; use ax for load info
 37119                                  
 37120                                  	;add	ax,[bp-16]
 37121 000067A5 0346F0                  	add	AX,Exec_Size		; go to end
 37122                                  	;sub	ax,[bp-12]
 37123 000067A8 2B46F4                  	sub	AX,Exec_Res_Len_Para	; drop off header
 37124 000067AB 83E810                  	sub	AX,10h			; drop off pdb
 37125                                  
 37126                                  Exec_Use_AX:
 37127                                  	;mov	[bp-10],ax
 37128 000067AE 8946F6                  	mov	Exec_Rel_Fac,AX 	; new segment
 37129                                  	;mov	[bp-20],ax
 37130 000067B1 8946EC                  	mov	Exec_DMA,AX ; *+*	; beginning of dma
 37131                                  
 37132                                  	; Determine the location in the file of the beginning of
 37133                                  	; the resident
 37134                                  
 37135                                  ; 17/12/2022
 37136                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 37137                                  ;%if 0
 37138                                  
 37139                                  Exec_Find_Res:
 37140                                  	; MSDOS 6.0
 37141                                  	;;mov	dx,[bp-20]
 37142                                  	;mov	DX,Exec_DMA ; *+*
 37143                                  	;;mov	[bp-28],dx
 37144                                  	;mov	Exec_DMA_Save,DX
 37145                                  
 37146                                  	; 17/12/2022
 37147                                  	; AX = Exec_DMA
 37148                                  
 37149                                  	; 02/06/2019 - Retro DOS v4.0
 37150                                  	;mov	[bp-28],ax ; *+*
 37151 000067B4 8946E4                  	mov	Exec_DMA_Save,AX ; *+*
 37152                                  
 37153                                  ;%endif
 37154                                  
 37155                                  ; 17/12/2022
 37156                                  %if 0
 37157                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 37158                                  Exec_Find_Res:
 37159                                  	;mov	dx,[bp-20]
 37160                                  	mov	DX,Exec_DMA ; *+*
 37161                                  	;mov	[bp-28],dx
 37162                                  	mov	Exec_DMA_Save,DX
 37163                                  %endif
 37164                                  
 37165                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37166 000067B7 8B16[1510]              	mov	DX,[exec_par_dir]
 37167 000067BB 52                      	push	DX
 37168 000067BC B104                    	mov	CL,4
 37169 000067BE D3E2                    	shl	DX,CL			; low word of location
 37170 000067C0 58                      	pop	AX
 37171 000067C1 B10C                    	mov	CL,12
 37172 000067C3 D3E8                    	shr	AX,CL			; high word of location
 37173 000067C5 89C1                    	mov	CX,AX			; CX <- high
 37174                                  
 37175                                  		; Read in the resident image (first, seek to it)
 37176                                  	;mov	bx,[bp-8]
 37177 000067C7 8B5EF8                  	mov	BX,Exec_FH
 37178 000067CA 1E                      	push	DS
 37179 000067CB 30C0                    	xor	AL,AL
 37180                                  	;invoke	$Lseek			; Seek to resident
 37181 000067CD E8D30A                  	call	_$LSEEK
 37182 000067D0 1F                      	pop	DS
 37183 000067D1 7303                    	jnc	short Exec_Big_Read
 37184                                  
 37185 000067D3 E906FF                  	jmp	Exec_Bomb
 37186                                  
 37187                                  Exec_Big_Read:				; Read resident into memory
 37188                                  	;mov	bx,[bp-12]
 37189 000067D6 8B5EF4                  	mov	BX,Exec_Res_Len_Para
 37190 000067D9 81FB0010                	cmp	BX,1000h		; Too many bytes to read?
 37191 000067DD 7203                    	jb	short Exec_Read_OK
 37192                                  
 37193 000067DF BBE00F                  	mov	BX,0FE0h		; Max in one chunk FE00 bytes
 37194                                  
 37195                                  Exec_Read_OK:
 37196                                  	;sub	[bp-12],bx
 37197 000067E2 295EF4                  	sub	Exec_Res_Len_Para,BX	; We read (soon) this many
 37198 000067E5 53                      	push	BX
 37199 000067E6 B104                    	mov	CL,4
 37200 000067E8 D3E3                    	shl	BX,CL			; Get count in bytes from paras
 37201 000067EA 89D9                    	mov	CX,BX			; Count in correct register
 37202 000067EC 1E                      	push	DS
 37203                                  	;mov	ds,[bp-20]
 37204 000067ED 8E5EEC                  	mov	DS,Exec_DMA		; Set up read buffer
 37205                                  
 37206 000067F0 31D2                    	xor	DX,DX
 37207 000067F2 51                      	push	CX			; Save our count
 37208 000067F3 E81303                  	call	ExecRead
 37209 000067F6 59                      	pop	CX			; Get old count to verify
 37210 000067F7 1F                      	pop	DS
 37211 000067F8 7248                    	jc	short Exec_Bad_FileJ
 37212                                  
 37213 000067FA 39C1                    	cmp	CX,AX			; Did we read enough?
 37214 000067FC 5B                      	pop	BX			; Get paragraph count back
 37215 000067FD 7408                    	jz	short ExecCheckEnd	; and do reloc if no more to read
 37216                                  
 37217                                  	; The read did not match the request. If we are off by 512
 37218                                  	; bytes or more then the header lied and we have an error.
 37219                                  
 37220 000067FF 29C1                    	sub	CX,AX
 37221 00006801 81F90002                	cmp	CX,512
 37222 00006805 733B                    	jae	short Exec_Bad_FileJ
 37223                                  
 37224                                  	; We've read in CX bytes... bump DTA location
 37225                                  
 37226                                  ExecCheckEnd:
 37227                                  	;add	[bp-20],bx
 37228 00006807 015EEC                  	add	Exec_DMA,BX		; Bump dma address
 37229                                  	;test	word [bp-12],0FFFFh
 37230 0000680A F746F4FFFF              	test	Exec_Res_Len_Para,-1
 37231 0000680F 75C5                    	jnz	short Exec_Big_Read
 37232                                  
 37233                                  	; The image has now been read in. We must perform relocation
 37234                                  	; to the current location.
 37235                                  
 37236                                  exec_do_reloc:
 37237                                  	;mov	cx,[bp-10]
 37238 00006811 8B4EF6                  	mov	CX,Exec_Rel_Fac
 37239 00006814 A1[1B10]                	mov	AX,[exec_SS]		; get initial SS ;rms;NSS
 37240 00006817 01C8                    	add	AX,CX			; and relocate him
 37241 00006819 A3[0710]                	mov	[exec_init_SS],AX 	; rms;NSS
 37242                                  
 37243 0000681C A1[1D10]                	mov	AX,[exec_SP]		; initial SP ;rms;NSS
 37244 0000681F A3[0510]                	mov	[exec_init_SP],AX 	; rms;NSS
 37245                                  
 37246 00006822 C406[2110]              	les	AX,[exec_IP]		; rms;NSS
 37247 00006826 A3[0910]                	mov	[exec_init_IP],AX 	; rms;NSS
 37248 00006829 8CC0                    	mov	AX,ES			; rms;NSS
 37249 0000682B 01C8                    	add	AX,CX			; relocated...
 37250 0000682D A3[0B10]                	mov	[exec_init_CS],AX 	; rms;NSS
 37251                                  
 37252 00006830 31C9                    	xor	CX,CX
 37253 00006832 8B16[2510]              	mov	DX,[exec_rle_table]	; rms;NSS
 37254                                  	;mov	bx,[bp-8]
 37255 00006836 8B5EF8                  	mov	BX,Exec_FH
 37256 00006839 1E                      	push	DS
 37257 0000683A 31C0                    	xor	AX,AX
 37258                                  	;invoke	$Lseek
 37259 0000683C E8640A                  	call	_$LSEEK
 37260 0000683F 1F                      	pop	DS
 37261 00006840 7303                    	jnc	short exec_get_entries
 37262                                  
 37263                                  Exec_Bad_FileJ:
 37264 00006842 E995FE                  	jmp	Exec_Bad_File
 37265                                  
 37266                                  exec_get_entries:
 37267 00006845 8B16[1310]              	mov	DX,[exec_rle_count]	; Number of entries left ;rms;NSS
 37268                                  
 37269                                  exec_read_reloc:
 37270 00006849 52                      	push	DX
 37271                                  	;mov	dx,OPENBUF
 37272 0000684A BA[BE03]                	mov	DX,Exec_Internal_Buffer
 37273                                  	;;mov	cx,388 ; MSDOS 3.3 ; (390>>2)<<2
 37274                                  	;mov	cx,396 ; MSDOS 6.0
 37275 0000684D B98C01                  	mov	CX,((Exec_Internal_Buffer_Size)/4)*4 ; (397>>2)<<2
 37276 00006850 1E                      	push	DS
 37277 00006851 E8B502                  	call	ExecRead
 37278 00006854 07                      	pop	ES
 37279 00006855 5A                      	pop	DX
 37280 00006856 72EA                    	jc	short Exec_Bad_FileJ
 37281                                  
 37282                                  	;;mov	cx,97 ;  MSDOS 3.3 ; (390>>2)
 37283                                  	;mov	cx,99 ;  MSDOS 6.0
 37284 00006858 B96300                  	mov	CX,(Exec_Internal_Buffer_Size)/4 ; (397>>2)
 37285                                  					; Pointer to byte location in header
 37286                                  	;mov	di,OPENBUF
 37287 0000685B BF[BE03]                	mov	DI,Exec_Internal_Buffer
 37288                                  	;mov	si,[bp-10]
 37289 0000685E 8B76F6                  	mov	SI,Exec_Rel_Fac 	; Relocate a single address
 37290                                  
 37291                                  exec_reloc_one:
 37292 00006861 09D2                    	or	DX,DX			; Any more entries?
 37293 00006863 7416                    	jz	short Exec_Set_PDBJ
 37294                                  
 37295                                  exec_get_addr:
 37296 00006865 26C51D                  	lds	BX,[ES:DI]		; Get ra/sa of entry
 37297 00006868 8CD8                    	mov	AX,DS			; Relocate address of item
 37298                                  
 37299                                  	; MSDOS 6.0
 37300                                  ;;;;;;	add	AX,SI  ; MSDOS 3.3
 37301                                  	;add	ax,[bp-28]
 37302 0000686A 0346E4                  	add	AX,Exec_DMA_Save
 37303                                  
 37304 0000686D 8ED8                    	mov	DS,AX
 37305 0000686F 0137                    	add	[BX],SI
 37306 00006871 83C704                  	add	DI,4
 37307 00006874 4A                      	dec	DX
 37308 00006875 E2EA                    	loop	exec_reloc_one		; End of internal buffer?
 37309                                  
 37310                                  	; We've exhausted a single buffer's worth. Read in the next
 37311                                  	; piece of the relocation table.
 37312                                  
 37313 00006877 06                      	push	ES
 37314 00006878 1F                      	pop	DS
 37315 00006879 EBCE                    	jmp	short exec_read_reloc
 37316                                  
 37317                                  Exec_Set_PDBJ:
 37318                                  	; MSDOS 6.0
 37319                                  	
 37320                                  	; We now determine if this is a buggy exe packed file and if 
 37321                                  	; so we patch in the right code. Note that fixexepatch will
 37322                                  	; point to a ret if dos loads low. The load segment as 
 37323                                  	; determined above will be in exec_dma_save
 37324                                  	
 37325 0000687B 06                      	push	es
 37326 0000687C 50                      	push	ax			; M030
 37327 0000687D 51                      	push	cx			; M030
 37328                                  	;mov	es,[bp-28]
 37329 0000687E 8E46E4                  	mov	es,Exec_DMA_Save
 37330 00006881 36A1[0B10]              	mov	ax,[ss:exec_init_CS]	; M030
 37331 00006885 368B0E[0910]            	mov	cx,[ss:exec_init_IP]	; M030
 37332 0000688A 36FF16[880D]            	call	word [ss:FixExePatch]
 37333                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37334                                  	; (MSDOS 5.0 MSDOS.SYS does not contain 'Rational386Patch')
 37335                                  	;call	word [ss:Rational386PatchPtr]
 37336 0000688F 59                      	pop	cx			; M030
 37337 00006890 58                      	pop	ax			; M030
 37338 00006891 07                      	pop	es
 37339                                  
 37340 00006892 E9DE00                  	jmp	Exec_Set_PDB
 37341                                  
 37342                                  Exec_No_Memj:
 37343 00006895 E93EFE                  	jmp	Exec_No_Mem
 37344                                  
 37345                                  	; we have a .COM file. First, determine if we are merely
 37346                                  	; loading an overlay.
 37347                                  
 37348                                  Exec_Com_File:
 37349                                  	;test	byte [bp-5],2
 37350 00006898 F646FB02                	test	Exec_Func,exec_func_overlay
 37351 0000689C 742D                    	jz	short Exec_Alloc_Com_File
 37352                                  	;lds	si,[bp-4]
 37353 0000689E C576FC                  	lds	SI,Exec_Blk		; get arg block
 37354 000068A1 AD                      	lodsw				; get load address
 37355                                  	;mov	[bp-20],ax
 37356 000068A2 8946EC                  	mov	Exec_DMA,AX
 37357 000068A5 B8FFFF                  	mov	AX,0FFFFh
 37358 000068A8 EB63                    	jmp	short Exec_Read_Block	; read it all!
 37359                                  
 37360                                  Exec_Chk_Com_Mem:			
 37361                                  	; MSDOS 6.0	     		; M063 - Start
 37362 000068AA 36A0[0203]              	mov	al,[ss:AllocMethod]	; save current alloc method in ax
 37363 000068AE 368A1E[8400]            	mov	bl,[ss:ALLOCMSAVE]
 37364 000068B3 36881E[0203]            	mov	[ss:AllocMethod],bl	; restore original allocmethod
 37365 000068B8 F6C340                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 37366 000068BB 75D8                    	jnz	short Exec_No_Memj	; Y: no space in UMBs. Quit
 37367                                  					; N: continue
 37368                                  	
 37369 000068BD A840                    	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 37370 000068BF 74D4                    	jz	short Exec_No_Memj	; N: no memory 
 37371                                  	
 37372                                  	;mov	ax,[bp-18]
 37373 000068C1 8B46EE                  	mov	ax,Exec_Load_Block	; M047: ax = block we just allocated	
 37374 000068C4 31DB                    	xor	bx,bx			; M047: bx => free arena
 37375 000068C6 E87502                  	call	ChangeOwner		; M047: free this block
 37376                                  	
 37377 000068C9 EB0E                    	jmp	short Exec_Norm_Com_Alloc
 37378                                  					; M063 - End
 37379                                  	
 37380                                  	; We must allocate the max possible size block (ick!)
 37381                                  	; and set up CS=DS=ES=SS=PDB pointer, IP=100, SP=max
 37382                                  	; size of block.
 37383                                  
 37384                                  Exec_Alloc_Com_File:
 37385                                  	; MSDOS 6.0			; M000 -start
 37386 000068CB 36F606[0203]80          	test	byte [ss:AllocMethod],HIGH_FIRST ; 80h
 37387                                  					; Q: is the alloc strat high_first
 37388 000068D1 7406                    	jz	short Exec_Norm_Com_Alloc ; N: normal allocate
 37389                                  					; Y: set high_only bit
 37390 000068D3 36800E[0203]40          	or	byte [ss:AllocMethod],HIGH_ONLY ; 40h
 37391                                  					; M000 - end
 37392                                  Exec_Norm_Com_Alloc:			; M000
 37393                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37394 000068D9 BBFFFF                  	mov	BX,0FFFFh
 37395                                  	;invoke	$Alloc			; largest piece available as error
 37396 000068DC E8C303                  	call	_$ALLOC
 37397 000068DF 09DB                    	or	BX,BX
 37398                                  	; MSDOS 6.0
 37399 000068E1 74C7                    	jz	short Exec_Chk_Com_Mem	; M000
 37400                                  	; MSDOS 3.3
 37401                                  	;jz	short Exec_No_Memj
 37402                                  
 37403                                  	;mov	[bp-16],bx
 37404 000068E3 895EF0                  	mov	Exec_Size,BX		; save size of allocation block
 37405 000068E6 53                      	push	BX
 37406                                  	;invoke	$ALLOC			; largest piece available
 37407 000068E7 E8B803                  	call	_$ALLOC
 37408 000068EA 5B                      	pop	BX			; get size of block...
 37409                                  	;mov	[bp-18],ax
 37410 000068EB 8946EE                  	mov	Exec_Load_Block,AX
 37411                                  
 37412 000068EE 83C010                  	add	AX,10h			; increment for header
 37413                                  	;mov	[bp-20],ax
 37414 000068F1 8946EC                  	mov	Exec_DMA,AX
 37415                                  
 37416 000068F4 31C0                    	xor	AX,AX			; presume 64K read...
 37417 000068F6 81FB0010                	cmp	BX,1000h		; 64k or more in block?
 37418 000068FA 730E                    	jae	short Exec_Read_Com	; yes, read only 64k
 37419                                  
 37420 000068FC 89D8                    	mov	AX,BX			; convert size to bytes
 37421 000068FE B104                    	mov	CL,4
 37422 00006900 D3E0                    	shl	AX,CL
 37423                                  	; 17/12/2022
 37424                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37425                                  	;			(MSDOS 5.0, MSDOS.SYS compatibility)
 37426                                  	; MSDOS 5.0
 37427                                  	;cmp	AX,100h   
 37428                                  	; 02/06/2019 - Retro DOS v4.0
 37429                                  	; MSDOS 6.0
 37430                                          ; 17/12/2022
 37431 00006902 3D0002                  	cmp	AX,200h                 ; enough memory for PSP and stack?
 37432 00006905 76A3                    	jbe	short Exec_Chk_Com_Mem	; M000: jump if not
 37433                                  	;;jbe	short Exec_No_Memj	; M000: jump if not
 37434                                  	;; Retro DOS v3.0 modification (on MSDOS 6.0 code) -03/08/2018-
 37435                                  	;;jbe	short Exec_Chk_Com_Mem	; M000: jump if not
 37436                                  	;jbe	short Exec_No_Memj	; M000: jump if not
 37437                                  
 37438                                  					; M047: size of the block is < 64K
 37439 00006907 2D0001                  	sub	ax,100h			; M047: reserve 256 bytes for stack
 37440                                  
 37441                                  Exec_Read_Com:
 37442                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37443 0000690A 2D0001                  	sub	AX,100h 		; remember size of psp
 37444                                  Exec_Read_Block:
 37445 0000690D 50                      	push	AX			; save number to read
 37446                                  	;mov	bx,[bp-8]
 37447 0000690E 8B5EF8                  	mov	BX,Exec_FH		; of com file
 37448 00006911 31C9                    	xor	CX,CX			; but seek to 0:0
 37449 00006913 89CA                    	mov	DX,CX
 37450 00006915 31C0                    	xor	AX,AX			; seek relative to beginning
 37451                                  	;invoke	$Lseek			; back to beginning of file
 37452 00006917 E88909                  	call	_$LSEEK
 37453 0000691A 59                      	pop	CX			; number to read
 37454                                  	;mov	ds,[bp-20]
 37455 0000691B 8E5EEC                  	mov	DS,Exec_DMA
 37456 0000691E 31D2                    	xor	DX,DX
 37457 00006920 51                      	push	CX
 37458 00006921 E8E501                  	call	ExecRead
 37459 00006924 5E                      	pop	SI			; get number of bytes to read
 37460 00006925 7303                    	jnc	short OkRead
 37461 00006927 E9B0FD                  	jmp	Exec_Bad_File
 37462                                  
 37463                                  	; 10/09/2018
 37464                                  OkRead:
 37465 0000692A 39F0                    	cmp	AX,SI			; did we read them all?
 37466                                  	; MSDOS 6.0
 37467                                  	;jz	short Exec_Chk_Com_Mem	; M00: exactly the wrong number...no 
 37468                                  	; MSDOS 3.3
 37469                                  	;;jz	short Exec_No_Memj	; M00: exactly the wrong number...
 37470 0000692C 7503                    	jne	short OkRead2
 37471 0000692E E979FF                  	jmp	Exec_Chk_Com_Mem
 37472                                  OkRead2:
 37473                                  	; MSDOS 6.0
 37474 00006931 368A1E[8400]            	mov	bl,[ss:ALLOCMSAVE]	; M063
 37475 00006936 36881E[0203]            	mov	[ss:AllocMethod],bl	; M063: restore alloc method
 37476                                  
 37477                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37478                                  	;test	byte [bp-5],2
 37479 0000693B F646FB02                	test	Exec_Func,exec_func_overlay
 37480 0000693F 7532                    	jnz	short Exec_Set_PDB	; no starto, chumo!
 37481                                  
 37482                                  	;mov	ax,[bp-20]
 37483 00006941 8B46EC                  	mov	AX,Exec_DMA
 37484 00006944 83E810                  	sub	AX,10h
 37485 00006947 36A3[0B10]              	mov	[SS:exec_init_CS],AX
 37486 0000694B 36C706[0910]0001        	mov	word [SS:exec_init_IP],100h ; initial IP is 100h
 37487                                  
 37488                                  	; SI is AT MOST FF00h. Add FE to account for PSP - word
 37489                                  	; of 0 on stack.
 37490                                  
 37491 00006952 81C6FE00                	add	SI,0FEh 		; make room for stack
 37492                                  
 37493                                  	; MSDOS 6.0
 37494 00006956 83FEFE                  	cmp	si,0FFFEh		; M047: Q: was there >= 64K available
 37495 00006959 7404                    	je	short Exec_St_Ok	; M047: Y: stack is fine
 37496 0000695B 81C60001                	add	si,100h			; M047: N: add the xtra 100h for stack
 37497                                  
 37498                                  Exec_St_Ok:
 37499                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37500 0000695F 368936[0510]            	mov	[SS:exec_init_SP],SI 	; max value for read is also SP!;smr;SS Override
 37501 00006964 36A3[0710]              	mov	[SS:exec_init_SS],AX 					;smr;SS Override
 37502 00006968 8ED8                    	mov	DS,AX
 37503 0000696A C7040000                	mov	WORD [SI],0		; 0 for return
 37504                                  
 37505                                  	; MSDOS 6.0
 37506                                  
 37507                                  	; M068
 37508                                  	;
 37509                                  	; We now determine if this is a Copy Protected App. If so the 
 37510                                  	; A20OFF_COUNT is set to 6. Note that ChkCopyProt will point to a 
 37511                                  	; a ret if DOS is loaded low. Also DS contains the load segment.
 37512                                  
 37513 0000696E 36FF16[6100]            	call	word [ss:ChkCopyProt]	
 37514                                  
 37515                                  Exec_Set_PDB:
 37516                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37517                                  	;mov	bx,[bp-8]
 37518 00006973 8B5EF8                  	mov	BX,Exec_FH		; we are finished with the file.
 37519 00006976 E8A901                  	call	Exec_Dealloc
 37520 00006979 55                      	push	BP
 37521                                  	;invoke	$Close			; release the jfn
 37522 0000697A E8AA07                  	call	_$CLOSE
 37523 0000697D 5D                      	pop	BP
 37524 0000697E E89301                  	call	Exec_Alloc
 37525                                  	;test	byte [bp-5],2
 37526 00006981 F646FB02                	test	Exec_Func,exec_func_overlay
 37527 00006985 743A                    	jz	short Exec_Build_Header
 37528                                  
 37529                                  	; MSDOS 6.0
 37530 00006987 E8C201                  	call	Scan_Execname
 37531 0000698A E8D601                  	call	Scan_Special_Entries
 37532                                  ;SR;
 37533                                  ;The current lie strategy uses the PSP to store the lie version. However,
 37534                                  ;device drivers are loaded as overlays and have no PSP. To handle them, we
 37535                                  ;use the Sysinit flag provided by the BIOS as part of a structure pointed at
 37536                                  ;by BiosDataPtr. If this flag is set, the overlay call has been issued from
 37537                                  ;Sysinit and therefore must be a device driver load. We then get the lie 
 37538                                  ;version for this driver and put it into the Sysinit PSP. When the driver
 37539                                  ;issues the version check, it gets the lie version until the next overlay
 37540                                  ;call is issued.
 37541                                  
 37542 0000698D 36803E[A210]00          	cmp	byte [ss:DriverLoad],0	;was Sysinit processing done?
 37543 00006993 7426                    	je	short norm_ovl		;yes, no special handling
 37544 00006995 56                      	push	si
 37545 00006996 06                      	push	es
 37546 00006997 36C436[A310]            	les	si,[ss:BiosDataPtr]	;get ptr to BIOS data block
 37547                                  	 
 37548                                  	; (es:si points to 'SysinitPresent' address/flag in retrodos4.s) 
 37549 0000699C 26803C00                	cmp	byte [es:si],0		;in Sysinit?
 37550 000069A0 7411                    	je	short sysinit_done	;no, Sysinit is finished
 37551                                  	
 37552 000069A2 368E06[3003]            	mov	es,[ss:CurrentPDB]	;es = current PSP (Sysinit PSP)
 37553 000069A7 36FF36[020F]            	push	word [ss:SPECIAL_VERSION]
 37554 000069AC 268F064000              	pop	word [es:PDB.Version]	;store lie version in Sysinit PSP
 37555                                  		;;; PDB.VERSION
 37556 000069B1 EB06                    	jmp	short setver_done
 37557                                  sysinit_done:
 37558 000069B3 36C606[A210]00          	mov	byte [ss:DriverLoad],0	;Sysinit done,special handling off
 37559                                  setver_done:
 37560 000069B9 07                      	pop	es
 37561 000069BA 5E                      	pop	si
 37562                                  norm_ovl:
 37563                                  	;leave
 37564 000069BB 89EC                    	mov	sp,bp		
 37565 000069BD 5D                      	pop	bp
 37566                                  
 37567                                  	;transfer SYS_RET_OK		; overlay load -> done
 37568 000069BE E9AF9C                  	jmp	SYS_RET_OK
 37569                                  
 37570                                  Exec_Build_Header:
 37571                                  	;mov	dx,[bp-18]
 37572 000069C1 8B56EE                  	mov	DX,Exec_Load_Block
 37573                                  					; assign the space to the process
 37574                                  	;mov	si,1
 37575 000069C4 BE0100                  	mov	SI,ARENA.OWNER		; pointer to owner field
 37576                                  	;mov	ax,[bp-14]
 37577 000069C7 8B46F2                  	mov	AX,Exec_Environ 	; get environ pointer
 37578 000069CA 09C0                    	or	AX,AX
 37579 000069CC 7405                    	jz	short No_Owner		; no environment
 37580                                  
 37581 000069CE 48                      	dec	AX			; point to header
 37582 000069CF 8ED8                    	mov	DS,AX
 37583 000069D1 8914                    	mov	[SI],DX 		; assign ownership
 37584                                  No_Owner:
 37585                                  	;mov	ax,[bp-18]
 37586                                  	;mov	AX,Exec_Load_Block	; get load block pointer
 37587                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37588                                  	; 17/12/2022
 37589 000069D3 89D0                    	mov	ax,dx ; 06/06/2019
 37590                                  	;mov	ax,Exec_Load_Block	; get load block pointer
 37591                                  	
 37592 000069D5 48                      	dec	AX
 37593 000069D6 8ED8                    	mov	DS,AX			; point to header
 37594 000069D8 8914                    	mov	[SI],DX 		; assign ownership
 37595                                  
 37596                                  	; MSDOS 6.0
 37597 000069DA 1E                      	push	DS			;AN000;MS. make ES=DS
 37598 000069DB 07                      	pop	ES			;AN000;MS.
 37599                                  	;mov	di,8
 37600 000069DC BF0800                  	mov	DI,ARENA.NAME		;AN000;MS. ES:DI points to destination
 37601 000069DF E86A01                  	call	Scan_Execname		;AN007;MS. parse execname
 37602                                  					;	   ds:si->name, cx=name length
 37603 000069E2 51                      	push	CX			;AN007;;MS. save for fake version
 37604 000069E3 56                      	push	SI			;AN007;;MS. save for fake version
 37605                                  
 37606                                  MoveName:				;AN000;
 37607 000069E4 AC                      	lodsb				;AN000;;MS. get char
 37608 000069E5 3C2E                    	cmp	AL,'.'			;AN000;;MS. is '.' ,may be name.exe
 37609 000069E7 7408                    	jz	short Mem_Done		;AN000;;MS. no, move to header
 37610                                  					;AN000;
 37611 000069E9 AA                      	stosb				;AN000;;MS. move char
 37612                                  					; MSKK bug fix - limit length copied
 37613 000069EA 83FF10                  	cmp	di,16 ; ARENAHEADERSIZE	; end of memory arena block?
 37614 000069ED 7302                    	jae	short Mem_Done		; jump if so
 37615                                  	;
 37616 000069EF E2F3                    	loop	MoveName		;AN000;;MS. continue
 37617                                  Mem_Done:				;AN000;
 37618 000069F1 30C0                    	xor	AL,AL			;AN000;;MS. make ASCIIZ
 37619                                  	;cmp	di,16
 37620 000069F3 83FF10                  	cmp	DI,ARENAHEADERSIZE ; 16 ;AN000;MS. if not all filled
 37621 000069F6 7301                    	jae	short Fill8		;AN000;MS.
 37622                                  	
 37623 000069F8 AA                      	stosb				;AN000;MS.
 37624                                  	
 37625                                  Fill8:					;AN000;
 37626 000069F9 5E                      	pop	SI			;AN007;MS. ds:si -> file name
 37627 000069FA 59                      	pop	CX			;AN007;MS.
 37628                                  	
 37629 000069FB E86501                  	call	Scan_Special_Entries	;AN007;MS.
 37630                                  
 37631                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37632 000069FE 52                      	push	DX
 37633                                  	;mov	si,[bp-16]
 37634 000069FF 8B76F0                  	mov	SI,Exec_Size
 37635 00006A02 01D6                    	add	SI,DX
 37636                                  	;Invoke	$Dup_PDB		; ES is now PDB
 37637 00006A04 E84FAC                  	call	_$DUP_PDB
 37638 00006A07 5A                      	pop	DX
 37639                                  
 37640                                  	;push	word [bp-14]
 37641 00006A08 FF76F2                  	push	Exec_Environ
 37642                                  	;pop	WORD [ES:2Ch]
 37643 00006A0B 268F062C00              	pop	word [ES:PDB.ENVIRON]
 37644                                  
 37645                                  	; MSDOS 6.0			; *** Added for DOS 5.00
 37646                                  					; version number in PSP
 37647 00006A10 36FF36[020F]             	push	word [ss:SPECIAL_VERSION] ; Set the DOS version number to
 37648 00006A15 268F064000              	pop	word [ES:PDB.Version]	; to be used for this application
 37649                                  		; PDB.VERSION
 37650                                  
 37651                                  	; MSDOS 3.3 (& MSDOS 6.0)	; set up proper command line stuff
 37652                                  	;lds	si,[bp-4]
 37653 00006A1A C576FC                  	lds	SI,Exec_Blk		; get the block
 37654 00006A1D 1E                      	push	DS			; save its location
 37655 00006A1E 56                      	push	SI
 37656                                  	;lds	si,[si+6]
 37657 00006A1F C57406                  	lds	SI,[SI+EXEC0.5C_FCB]	; get the 5c fcb
 37658                                  
 37659                                  	; DS points to user space 5C FCB
 37660                                  
 37661 00006A22 B90C00                  	mov	CX,12			; copy drive, name and ext
 37662 00006A25 51                      	push	CX
 37663 00006A26 BF5C00                  	mov	DI,5Ch
 37664 00006A29 8A1C                    	mov	BL,[SI]
 37665 00006A2B F3A4                    	rep	movsb
 37666                                  
 37667                                  	; DI = 5Ch + 12 = 5Ch + 0Ch = 68h
 37668                                  
 37669 00006A2D 31C0                    	xor	AX,AX			; zero extent, etc for CPM
 37670 00006A2F AB                      	stosw
 37671 00006A30 AB                      	stosw
 37672                                  
 37673                                  	; DI = 5Ch + 12 + 4 = 5Ch + 10h = 6Ch
 37674                                  
 37675 00006A31 59                      	pop	CX
 37676 00006A32 5E                      	pop	SI			; get block
 37677 00006A33 1F                      	pop	DS
 37678 00006A34 1E                      	push	DS			; save (again)
 37679 00006A35 56                      	push	SI
 37680                                  	;lds	si,[si+0Ah]
 37681 00006A36 C5740A                  	lds	SI,[SI+EXEC0.6C_FCB]	; get 6C FCB
 37682                                  
 37683                                  	; DS points to user space 6C FCB
 37684                                  
 37685 00006A39 8A3C                    	mov	BH,[SI] 		; do same as above
 37686 00006A3B F3A4                    	rep	movsb
 37687 00006A3D AB                      	stosw
 37688 00006A3E AB                      	stosw
 37689 00006A3F 5E                      	pop	SI			; get block (last time)
 37690 00006A40 1F                      	pop	DS
 37691                                  	;ld	si,[si+2]
 37692 00006A41 C57402                  	lds	SI,[SI+EXEC0.COM_LINE]	; command line
 37693                                  
 37694                                  	; DS points to user space 80 command line
 37695                                  
 37696 00006A44 80C980                  	or	CL,80h
 37697 00006A47 89CF                    	mov	DI,CX
 37698 00006A49 F3A4                    	rep	movsb			; Wham!
 37699                                  
 37700                                  	; Process BX into default AX (validity of drive specs on args).
 37701                                  	; We no longer care about DS:SI.
 37702                                  
 37703 00006A4B FEC9                    	dec	CL			; get 0FFh in CL
 37704 00006A4D 88F8                    	mov	AL,BH
 37705 00006A4F 30FF                    	xor	BH,BH
 37706                                  	;invoke	GetVisDrv
 37707 00006A51 E8400A                  	call	GetVisDrv
 37708 00006A54 7302                    	jnc	short Exec_BL
 37709                                  
 37710 00006A56 88CF                    	mov	BH,CL
 37711                                  
 37712                                  Exec_BL:
 37713 00006A58 88D8                    	mov	AL,BL
 37714 00006A5A 30DB                    	xor	BL,BL
 37715                                  	;invoke	GetVisDrv
 37716 00006A5C E8350A                  	call	GetVisDrv
 37717 00006A5F 7302                    	jnc	short Exec_Set_Return
 37718                                  
 37719 00006A61 88CB                    	mov	BL,CL
 37720                                  
 37721                                  Exec_Set_Return:
 37722                                  	;invoke	Get_User_Stack			; get his return address
 37723 00006A63 E8119A                  	call	Get_User_Stack
 37724                                  
 37725                                  	;push	word [si+14h]
 37726 00006A66 FF7414                  	push	word [SI+user_env.user_CS]	; suck out the CS and IP
 37727                                  	;push	word [si+12h]
 37728 00006A69 FF7412                  	push	word [SI+user_env.user_IP]
 37729                                  	;push	word [si+14h]
 37730 00006A6C FF7414                  	push	word [SI+user_env.user_CS]	; suck out the CS and IP
 37731                                  	;push	word [si+12h]
 37732 00006A6F FF7412                  	push	word [SI+user_env.user_IP]
 37733                                  	;pop	word [ES:0Ah]
 37734 00006A72 268F060A00              	pop	WORD [ES:PDB.EXIT]
 37735                                  	;pop	word [ES:0Ch]
 37736 00006A77 268F060C00              	pop	WORD [ES:PDB.EXIT+2]
 37737                                  
 37738 00006A7C 31C0                    	xor	AX,AX
 37739 00006A7E 8ED8                    	mov	DS,AX
 37740                                  					; save them where we can get them
 37741                                  					; later when the child exits.
 37742                                  	;pop	word [88h]
 37743 00006A80 8F068800                	pop	word [addr_int_terminate] ; 22h*4
 37744                                  	;pop	word [90h]
 37745 00006A84 8F068A00                	pop	word [addr_int_terminate+2] ; (22h*4)+2
 37746                                  
 37747 00006A88 36C706[2C03]8000        	mov	WORD [SS:DMAADD],80h	; SS Override
 37748 00006A8F 368E1E[3003]            	mov	DS,[SS:CurrentPDB]	; SS Override
 37749 00006A94 368C1E[2E03]            	mov	[SS:DMAADD+2],DS	; SS Override
 37750                                  
 37751                                  	;test	byte [bp-5],1
 37752 00006A99 F646FB01                	test	Exec_Func,exec_func_no_execute
 37753 00006A9D 7427                    	jz	short exec_go
 37754                                  
 37755 00006A9F 36C536[0510]            	lds	SI,[SS:exec_init_SP]	; get stack SS Override
 37756                                  	;les	di,[bp-4]
 37757 00006AA4 C47EFC                  	les	DI,Exec_Blk		; and block for return
 37758                                  	;mov	[es:di+10h],ds
 37759 00006AA7 268C5D10                	mov	[ES:DI+EXEC1.SS],DS	; return SS
 37760                                  
 37761 00006AAB 4E                      	dec	SI			; 'push' default AX
 37762 00006AAC 4E                      	dec	SI
 37763 00006AAD 891C                    	mov	[SI],BX 		; save default AX reg
 37764                                  	;mov	[es:di+0Eh], si
 37765 00006AAF 2689750E                	mov	[ES:DI+EXEC1.SP],SI	; return 'SP'
 37766                                  
 37767 00006AB3 36C506[0910]            	lds	AX,[SS:exec_init_IP]	; SS Override
 37768                                  	;mov	[es:di+14h],ds
 37769 00006AB8 268C5D14                	mov	[ES:DI+EXEC1.CS],DS	; initial entry stuff
 37770                                  	;mov	[es:di+12h],ax
 37771 00006ABC 26894512                	mov	[ES:DI+EXEC1.IP],AX
 37772                                  	
 37773                                  	;leave
 37774 00006AC0 89EC                    	mov	sp,bp
 37775 00006AC2 5D                      	pop	bp	
 37776                                  
 37777                                  	;transfer SYS_RET_OK
 37778 00006AC3 E9AA9B                  	jmp	SYS_RET_OK
 37779                                  
 37780                                  exec_go:
 37781 00006AC6 36C536[0910]            	lds	SI,[SS:exec_init_IP]	; get entry point SS Override
 37782 00006ACB 36C43E[0510]            	les	DI,[SS:exec_init_SP]	; new stack SS Override
 37783 00006AD0 8CC0                    	mov	AX,ES
 37784                                  
 37785                                  	; MSDOS 6.0
 37786 00006AD2 36803E[870D]00          	cmp	byte [SS:DosHasHMA],0	; Q: is dos in HMA (M021)
 37787 00006AD8 741A                    	je	short Xfer_To_User	; N: transfer control to user
 37788                                  
 37789 00006ADA 1E                      	push	ds			; Y: control must go to low mem stub
 37790                                  		
 37791 00006ADB 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]		;    where we disable a20 and Xfer 
 37792                                  					;    control to user 
 37793 00006AE0 800E[8600]04            	or	byte [DOS_FLAG],EXECA20OFF ; M068:
 37794                                  					; M004: Set bit to signal int 21
 37795                                  					; ah = 25 & ah= 49. See dossym.inc 
 37796                                  					; under TAG M003 & M009 for 
 37797                                  					; explanation
 37798 00006AE5 8916[6300]              	mov	[A20OFF_PSP],dx		; M068: set the PSP for which A20 is
 37799                                  					; M068: going to be turned OFF.
 37800                                  	
 37801 00006AE9 8CD8                    	mov	ax,ds			; ax = segment of low mem stub
 37802 00006AEB 1F                      	pop	ds
 37803                                  	
 37804 00006AEC 50                      	push	ax			; ret far into the low mem stub
 37805 00006AED B8[5F11]                	mov	ax,disa20_xfer
 37806 00006AF0 50                      	push	ax
 37807 00006AF1 8CC0                    	mov	AX,ES			; restore ax
 37808 00006AF3 CB                      	retf
 37809                                  
 37810                                  Xfer_To_User:
 37811                                  	; DS:SI points to entry point
 37812                                  	; AX:DI points to initial stack
 37813                                  	; DX has PDB pointer
 37814                                  	; BX has initial AX value
 37815                                  
 37816 00006AF4 FA                      	cli
 37817                                  	; 15/08/2018
 37818 00006AF5 36C606[2103]00          	mov	BYTE [SS:INDOS],0	; SS Override
 37819                                  
 37820 00006AFB 8ED0                    	mov	SS,AX			; set up user's stack
 37821 00006AFD 89FC                    	mov	SP,DI			; and SP
 37822 00006AFF FB                      	sti
 37823                                  
 37824 00006B00 1E                      	push	DS			; fake long call to entry
 37825 00006B01 56                      	push	SI
 37826 00006B02 8EC2                    	mov	ES,DX			; set up proper seg registers
 37827 00006B04 8EDA                    	mov	DS,DX
 37828 00006B06 89D8                    	mov	AX,BX			; set up proper AX
 37829                                  
 37830 00006B08 CB                      	retf
 37831                                  
 37832                                  ; 04/08/2018 - Retro DOS v3.0
 37833                                  
 37834                                  ;----------------------------------------------------------------------------
 37835                                  ;
 37836                                  ;----------------------------------------------------------------------------
 37837                                  
 37838                                  ExecRead:
 37839 00006B09 E81600                  	CALL	Exec_Dealloc
 37840                                  	;mov	bx,[bp-8]
 37841 00006B0C 8B5EF8                  	MOV	bx,Exec_FH
 37842                                  
 37843 00006B0F 55                      	PUSH	BP
 37844 00006B10 E82507                  	call	_$READ
 37845 00006B13 5D                      	POP	BP
 37846                                  
 37847                                  	;CALL	Exec_Alloc
 37848                                  	;retn
 37849                                  	; 18/12/2022
 37850                                  	;jmp	short Exec_Alloc
 37851                                  
 37852                                  ; 18/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS) 
 37853                                  
 37854                                  ;----------------------------------------------------------------------------
 37855                                  ;
 37856                                  ;----------------------------------------------------------------------------
 37857                                  
 37858                                  Exec_Alloc:
 37859 00006B14 53                      	push	BX
 37860                                  	;mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
 37861                                  	; 20/05/2019 - Retro DOS v4.0
 37862                                  	; MSDOS 6.0
 37863 00006B15 368B1E[3003]            	mov	bx,[SS:CurrentPDB]  ; SS Override
 37864 00006B1A E81000                  	call	ChangeOwners
 37865 00006B1D E810AE                  	call	LCritMEM
 37866 00006B20 5B                      	pop	BX
 37867 00006B21 C3                      	retn
 37868                                  
 37869                                  ;----------------------------------------------------------------------------
 37870                                  ;
 37871                                  ;----------------------------------------------------------------------------
 37872                                  
 37873                                  Exec_Dealloc:
 37874 00006B22 53                      	push	BX
 37875                                  	;mov	bx,0
 37876 00006B23 29DB                    	sub	BX,BX		; (bx) = ARENA_OWNER_SYSTEM
 37877 00006B25 E8DBAD                  	call	ECritMEM
 37878 00006B28 E80200                  	call	ChangeOwners
 37879 00006B2B 5B                      	pop	BX
 37880 00006B2C C3                      	retn
 37881                                  
 37882                                  ; 18/12/2022
 37883                                  %if 0
 37884                                  ;----------------------------------------------------------------------------
 37885                                  ;
 37886                                  ;----------------------------------------------------------------------------
 37887                                  
 37888                                  Exec_Alloc:
 37889                                  	push	BX
 37890                                  	;mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
 37891                                  	; 20/05/2019 - Retro DOS v4.0
 37892                                  	; MSDOS 6.0
 37893                                  	mov	bx,[SS:CurrentPDB]  ; SS Override
 37894                                  	call	ChangeOwners
 37895                                  	call	LCritMEM
 37896                                  	pop	BX
 37897                                  	retn
 37898                                  
 37899                                  %endif
 37900                                  
 37901                                  ;----------------------------------------------------------------------------
 37902                                  ;
 37903                                  ;----------------------------------------------------------------------------
 37904                                  
 37905                                  ChangeOwners:
 37906 00006B2D 9C                      	pushf
 37907 00006B2E 50                      	push	AX
 37908                                  	;mov	ax,[bp-14]
 37909 00006B2F 8B46F2                  	mov	AX,Exec_Environ
 37910 00006B32 E80900                  	call	ChangeOwner
 37911                                  	;mov	ax,[bp-18]
 37912 00006B35 8B46EE                  	mov	AX,Exec_Load_Block
 37913 00006B38 E80300                  	call	ChangeOwner
 37914 00006B3B 58                      	pop	AX
 37915 00006B3C 9D                      	popf
 37916                                  chgown_retn:
 37917 00006B3D C3                      	retn
 37918                                  
 37919                                  ;----------------------------------------------------------------------------
 37920                                  ;
 37921                                  ;----------------------------------------------------------------------------
 37922                                  
 37923                                  ChangeOwner:
 37924 00006B3E 09C0                    	or	AX,AX			; is area allocated?
 37925 00006B40 74FB                    	jz	short chgown_retn	; no, do nothing
 37926 00006B42 48                      	dec	AX
 37927 00006B43 1E                      	push	DS
 37928 00006B44 8ED8                    	mov	DS,AX
 37929 00006B46 891E0100                	mov	[ARENA.OWNER],BX
 37930 00006B4A 1F                      	pop	DS
 37931 00006B4B C3                      	retn
 37932                                  
 37933                                  ;----------------------------------------------------------------------------
 37934                                  ;
 37935                                  ;----------------------------------------------------------------------------
 37936                                  
 37937                                  ; 20/05/2019 - Retro DOS v4.0
 37938                                  
 37939                                  	; MSDOS 6.0
 37940                                  Scan_Execname:
 37941 00006B4C C576E6                  	lds	SI,ExecName		; DS:SI points to name
 37942                                  Scan_Execname1:				; M028
 37943                                  Save_Begin:				;
 37944 00006B4F 89F1                    	mov	CX,SI			; CX= starting addr
 37945                                  Scan0:					;
 37946 00006B51 AC                      	lodsb				; get char
 37947                                  
 37948 00006B52 3C3A                    	cmp	AL,':'			; is ':' , may be A:name
 37949 00006B54 74F9                    	jz	short Save_Begin	; yes, save si
 37950 00006B56 3C5C                    	cmp	AL,'\'                  ; is '\', may be A:\name
 37951 00006B58 74F5                    	jz	short Save_Begin	; yes, save si
 37952 00006B5A 3C00                    	cmp	AL,0			; is end of name
 37953 00006B5C 75F3                    	jnz	short Scan0		; no, continue scanning
 37954 00006B5E 29CE                    	sub	SI,CX			; get name's length
 37955 00006B60 87F1                    	xchg	SI,CX			; cx= length, si= starting addr
 37956                                  
 37957 00006B62 C3                      	retn
 37958                                  
 37959                                  ;----------------------------------------------------------------------------
 37960                                  ;
 37961                                  ;----------------------------------------------------------------------------
 37962                                  
 37963                                  ; 20/05/2019 - Retro DOS v4.0
 37964                                  
 37965                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37966                                  ; DOSCODE:A0EDh (MSDOS 5.0, MSDOS.SYS)
 37967                                  
 37968                                  	; MSDOS 6.0
 37969                                  
 37970                                  Scan_Special_Entries:
 37971                                  
 37972 00006B63 49                      	dec	CX			; cx= name length
 37973                                  ;M060	mov	DI,[Special_Entries]	; es:di -> addr of special entries
 37974                                  					;reset to current version
 37975                                  	;mov	word [ss:SPECIAL_VERSION],1406h 
 37976                                  				; (MSDOS 6.21, MSDOS.SYS, DOSCODE:A14Eh)
 37977                                  	;mov	word [ss:SPECIAL_VERSION],5
 37978                                  				; (MSDOS 5.0, MSDOS.SYS, DOSCODE:A0EEh)
 37979                                  
 37980                                  				; 5 for Retro DOS 4.0 (01/12/2022, MSDOS 5.0)
 37981 00006B64 36C706[020F]070A        	mov	word [ss:SPECIAL_VERSION],(MINOR_VERSION<<8)+MAJOR_VERSION
 37982                                  				; 0005h for Retro DOS v4.1 (MSDOS 5.0)
 37983                                  				; 24/09/2023
 37984                                  				; 1606h for Retro DOS v4.2 (MSDOS 6.22)
 37985                                  ;***	call	Reset_Version
 37986                                  
 37987                                  ;M060	push	SS
 37988                                  ;M060	pop	ES
 37989                                  
 37990 00006B6B 36C43E[5D00]            	les	DI,[SS:UU_IFS_DOS_CALL]	;M060; ES:DI --> Table in SETVER.SYS
 37991 00006B70 8CC0                    	mov	AX,ES			;M060; First do a NULL ptr check to
 37992 00006B72 09F8                    	or	AX,DI			;M060; be sure the table exists
 37993 00006B74 7427                    	jz	short End_List		;M060; If ZR then no table
 37994                                  
 37995                                  GetEntries:
 37996 00006B76 268A05                  	mov	AL,[ES:DI]		; end of list
 37997 00006B79 08C0                    	or	AL,AL
 37998 00006B7B 7420                    	jz	short End_List		; yes
 37999                                  
 38000 00006B7D 36893E[0E06]            	mov	[ss:TEMP_VAR2],DI	; save di
 38001 00006B82 38C8                    	cmp	AL,CL			; same length ?
 38002 00006B84 751B                    	jnz	short SkipOne 		; no
 38003                                  
 38004 00006B86 47                      	inc	DI			; es:di -> special name
 38005 00006B87 51                      	push	CX			; save length and name addr
 38006 00006B88 56                      	push	SI
 38007                                  
 38008                                  ; M050 - BEGIN
 38009                                  
 38010 00006B89 50                      	push	ax			; save len
 38011                                  sse_next_char:
 38012 00006B8A AC                      	lodsb
 38013 00006B8B E897EE                  	call	UCase
 38014 00006B8E AE                      	scasb
 38015 00006B8F 750D                    	jne	short Not_Matched
 38016 00006B91 E2F7                    	loop	sse_next_char
 38017                                  	
 38018                                  ;	repz	cmpsb			; same name ?
 38019                                  ;	jnz	short Not_Matched	; no
 38020                                  
 38021 00006B93 58                      	pop	ax			; take len off the stack
 38022                                  
 38023                                  ; M050 - END
 38024                                  
 38025 00006B94 268B05                  	mov	AX,[ES:DI]		; get special version
 38026 00006B97 36A3[020F]              	mov	[ss:SPECIAL_VERSION],AX	; save it
 38027                                  
 38028                                  ;***	mov	AL,[ES:DI+2]		; get fake count
 38029                                  ;***	mov	[ss:FAKE_COUNT],AL 	; save it
 38030                                  
 38031 00006B9B 5E                      	pop	SI
 38032 00006B9C 59                      	pop	CX
 38033                                  	; 18/12/2022
 38034                                  	;jmp	SHORT End_List
 38035                                  
 38036                                  	; 18/12/2022
 38037                                  End_List:
 38038 00006B9D C3                      	retn
 38039                                  
 38040                                  Not_Matched:
 38041 00006B9E 58                      	pop	ax			; get len from stack ; M050
 38042 00006B9F 5E                      	pop	SI			; restore si,cx
 38043 00006BA0 59                      	pop	CX
 38044                                  
 38045                                  SkipOne:
 38046 00006BA1 368B3E[0E06]            	mov	DI,[ss:TEMP_VAR2]	; restore old di use SS Override
 38047 00006BA6 30E4                    	xor	AH,AH			; position to next entry
 38048 00006BA8 01C7                    	add	DI,AX
 38049                                  
 38050 00006BAA 83C703                  	add	DI,3			; DI -> next entry length
 38051                                  ;***	add	DI,4			; DI -> next entry length
 38052                                  
 38053 00006BAD EBC7                    	jmp	short GetEntries
 38054                                  
 38055                                  	; 18/12/2022
 38056                                  ;End_List:
 38057                                  	;retn
 38058                                  
 38059                                  ; 04/08/2018 - Retro DOS v3.0
 38060                                  ; IBMDOS.COm (MSDOS 3.3, 1987) - Offset 633Dh
 38061                                  
 38062                                  ;----------------------------------------------------------------------------
 38063                                  ;SUBTTL Terminate and stay resident handler
 38064                                  ;
 38065                                  ; Input:    DX is  an  offset  from  CurrentPDB  at which to
 38066                                  ;	    truncate the current block.
 38067                                  ;
 38068                                  ; output:   The current block is truncated (expanded) to be [DX+15]/16
 38069                                  ;	    paragraphs long.  An exit is simulated via resetting CurrentPDB
 38070                                  ;	    and restoring the vectors.
 38071                                  ;
 38072                                  ;----------------------------------------------------------------------------
 38073                                  
 38074                                  	; 20/05/2019 - Retro DOS v4.0
 38075                                  	; DOSCODE:A19Bh (MSDOS 6.21, MSDOS.SYS)
 38076                                  
 38077                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 38078                                  	; DOSCODE:A13Bh (MSDOS 5.0, MSDOS.SYS)
 38079                                  
 38080                                  _$KEEP_PROCESS:
 38081 00006BAF 50                      	push	AX			; keep exit code around
 38082                                  	;mov	byte [SS:EXIT_TYPE],3
 38083 00006BB0 36C606[7C05]03          	mov	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS
 38084 00006BB6 368E06[3003]            	mov	ES,[SS:CurrentPDB]
 38085 00006BBB 83FA06                  	cmp	DX,6h			; keep enough space around for system
 38086 00006BBE 7303                    	jae	short Keep_Shrink	; info
 38087                                  
 38088 00006BC0 BA0600                  	mov	DX,6h
 38089                                  
 38090                                  Keep_Shrink:
 38091 00006BC3 89D3                    	mov	BX,DX
 38092 00006BC5 53                      	push	BX
 38093 00006BC6 06                      	push	ES
 38094 00006BC7 E82E02                  	call	_$SETBLOCK		; ignore return codes.
 38095 00006BCA 1F                      	pop	DS
 38096 00006BCB 5B                      	pop	BX
 38097 00006BCC 7207                    	jc	short Keep_Done		; failed on modification
 38098                                  
 38099 00006BCE 8CD8                    	mov	AX,DS
 38100 00006BD0 01D8                    	add	AX,BX
 38101                                  	;mov	[2],ax
 38102 00006BD2 A30200                  	mov	[PDB.BLOCK_LEN],AX	;PBUGBUG
 38103                                  
 38104                                  Keep_Done:
 38105 00006BD5 58                      	pop	AX
 38106 00006BD6 EB26                    	jmp	SHORT exit_inner	; and let abort take care of the rest
 38107                                  
 38108                                  ;----------------------------------------------------------------------------
 38109                                  ;
 38110                                  ;----------------------------------------------------------------------------
 38111                                  
 38112                                  STAY_RESIDENT:
 38113                                  	;mov	ax,3100h
 38114 00006BD8 B80031                  	mov	AX,(KEEP_PROCESS<<8)+0 ; Lower part is return code;PBUGBUG
 38115 00006BDB 83C20F                  	add	DX,15
 38116 00006BDE D1DA                    	rcr	DX,1
 38117 00006BE0 B103                    	mov	CL,3
 38118 00006BE2 D3EA                    	shr	DX,CL
 38119                                  
 38120 00006BE4 E90A97                  	jmp	COMMAND
 38121                                  
 38122                                  ;----------------------------------------------------------------------------
 38123                                  ;SUBTTL $EXIT - return to parent process
 38124                                  ;   Assembler usage:
 38125                                  ;	    MOV     AL, code
 38126                                  ;	    MOV     AH, Exit
 38127                                  ;	    INT     int_command
 38128                                  ;   Error return:
 38129                                  ;	    None.
 38130                                  ;
 38131                                  ;----------------------------------------------------------------------------
 38132                                  
 38133                                  	; 20/05/2019 - Retro DOS v4.0
 38134                                  	; DOSCODE:A1D3h (MSDOS 6.21, MSDOS.SYS)
 38135                                  
 38136                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 38137                                  	; DOSCODE:A173h (MSDOS 5.0, MSDOS.SYS)
 38138                                  _$EXIT:
 38139                                  	; 04/08/2018 - Retro DOS v3.0
 38140                                  	; IBMDOSDOS.COM (MSDOS 3.3, 1987) - Offset 6375h
 38141 00006BE7 30E4                    	xor	AH,AH
 38142 00006BE9 368626[4D03]            	xchg	AH,[SS:DidCTRLC]
 38143 00006BEE 08E4                    	or	AH,AH
 38144                                  	;mov	BYTE [SS:EXIT_TYPE],0
 38145 00006BF0 36C606[7C05]00          	mov	BYTE [SS:EXIT_TYPE],EXIT_TERMINATE
 38146 00006BF6 7406                    	jz	short exit_inner
 38147                                  	;mov	BYTE [SS:EXIT_TYPE],1
 38148 00006BF8 36C606[7C05]01          	mov	BYTE [SS:EXIT_TYPE],EXIT_CTRL_C
 38149                                  
 38150                                  	;entry	Exit_inner
 38151                                  exit_inner:
 38152 00006BFE E87698                  	call	Get_User_Stack		;PBUGBUG
 38153                                  
 38154 00006C01 36FF36[3003]            	push	word [ss:CurrentPDB]
 38155                                  	;pop	word [si+14h]
 38156 00006C06 8F4414                  	pop	word [SI+user_env.user_CS] ;PBUGBUG
 38157 00006C09 EB08                    	jmp	short abort_inner
 38158                                  
 38159                                  ;BREAK <$ABORT -- Terminate a process>
 38160                                  ;----------------------------------------------------------------------------
 38161                                  ; Inputs:
 38162                                  ;	user_CS:00 must point to valid program header block
 38163                                  ; Function:
 38164                                  ;	Restore terminate and Cntrl-C addresses, flush buffers and transfer
 38165                                  ;	to the terminate address
 38166                                  ; Returns:
 38167                                  ;	TO THE TERMINATE ADDRESS
 38168                                  ;----------------------------------------------------------------------------
 38169                                  
 38170                                  _$ABORT:
 38171 00006C0B 30C0                    	xor	AL,AL
 38172                                  	;mov	byte [SS:EXIT_TYPE],0
 38173                                  	;mov	byte [SS:EXIT_TYPE],AL ; = 0
 38174 00006C0D 36C606[7C05]00          	mov	byte [SS:EXIT_TYPE],EXIT_ABORT
 38175                                  
 38176                                  	; abort_inner must have AL set as the exit code! The exit type
 38177                                  	; is retrieved from exit_type. Also, the PDB at user_CS needs
 38178                                  	; to be correct as the one that is terminating.
 38179                                  
 38180                                  abort_inner:
 38181 00006C13 368A26[7C05]            	mov	AH,[SS:EXIT_TYPE]
 38182 00006C18 36A3[3403]              	mov	[SS:exit_code],AX
 38183 00006C1C E85898                  	call	Get_User_Stack
 38184                                  
 38185                                  	;mov	ds,[si+14h]
 38186 00006C1F 8E5C14                  	mov	DS,[SI+user_env.user_CS] ; set up old interrupts ;PBUGBUG
 38187 00006C22 31C0                    	xor	AX,AX
 38188 00006C24 8EC0                    	mov	ES,AX
 38189                                  	;mov	si,10
 38190 00006C26 BE0A00                  	mov	SI,SAVEXIT
 38191                                  	;mov	di,88h
 38192 00006C29 BF8800                  	mov	DI,addr_int_terminate
 38193 00006C2C A5                      	movsw
 38194 00006C2D A5                      	movsw
 38195 00006C2E A5                      	movsw
 38196 00006C2F A5                      	movsw
 38197 00006C30 A5                      	movsw
 38198 00006C31 A5                      	movsw
 38199 00006C32 E90AF2                  	jmp	reset_environment
 38200                                  
 38201                                  ;----------------------------------------------------------------------------
 38202                                  ;
 38203                                  ; fixexepatch will point to this is DOS loads low. 
 38204                                  ;
 38205                                  ;----------------------------------------------------------------------------
 38206                                  ; MSDOS 6.0
 38207                                  
 38208                                  ; 29/04/2019 - Retro DOS v4.0
 38209                                  ; DOSCODE:A221h (MSDOS 6.21, MSDOS.SYS)
 38210                                  
 38211                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 38212                                  ; DOSCODE:A1C1h (MSDOS 5.0, MSDOS.SYS)
 38213                                  
 38214                                  RetExePatch: ; proc near
 38215                                  	
 38216 00006C35 C3                      	retn
 38217                                  
 38218                                  ;============================================================================
 38219                                  ; ALLOC.ASM, MSDOS 6.0, 1991
 38220                                  ;============================================================================
 38221                                  ; 04/08/2018 - Retro DOS v3.0
 38222                                  ; 14/05/2019 - Retro DOS v4.0
 38223                                  
 38224                                  ;	TITLE ALLOC.ASM - memory arena manager	NAME Alloc
 38225                                  
 38226                                  ;**
 38227                                  ;	Microsoft Confidential
 38228                                  ;	Copyright (C) Microsoft Corporation 1991
 38229                                  ;	All Rights Reserved.
 38230                                  ;
 38231                                  ;	Memory related system calls and low level routines for MSDOS 2.X.
 38232                                  ;	I/O specs are defined in DISPATCH.
 38233                                  ;
 38234                                  ;	$ALLOC
 38235                                  ;	$SETBLOCK
 38236                                  ;	$DEALLOC
 38237                                  ;	$AllocOper
 38238                                  ;	arena_free_process
 38239                                  ;	arena_next
 38240                                  ;	check_signature
 38241                                  ;	Coalesce
 38242                                  ;
 38243                                  ;	Modification history:
 38244                                  ;
 38245                                  ;	    Created: ARR 30 March 1983
 38246                                  ;
 38247                                  ;	    Revision: M000 - added support for allocing UMBs. 7/9/90
 38248                                  ;		      M003 - added support for link/unlink UMBs from
 38249                                  ;			     DOS arena chain. 7/18/90
 38250                                  ;		      M009 - Added error returns invalid function and 
 38251                                  ;			     arena trashed in set link state call.
 38252                                  ;		      M010 - Release UMB arenas allocated to current PDB
 38253                                  ;			     if UMB_HEAD is initialized.
 38254                                  ;
 38255                                  ;		      M016 - MACE utilities mkeyrate.com version 1.0 
 38256                                  ;			     support. Please see under M009 in 
 38257                                  ;			     ..\inc\dossym.inc. 8/31/90.
 38258                                  ;
 38259                                  ;		      M061 - In GetLastArena, if linking in UMBs check to make
 38260                                  ;			     sure that umb_head arena is valid and also make
 38261                                  ;			     sure that the previous arena is pointing to 
 38262                                  ;			     umb_head.
 38263                                  ;
 38264                                  ;		      M064 - allow HIGH_ONLY bit to be set by a call to 
 38265                                  ;			     set allloc strategy.
 38266                                  ;			     use STRAT_MASK to mask out bits 6 & 7 of 
 38267                                  ;			     bx in AllocSetStrat.
 38268                                  ;
 38269                                  ;		      M068 - use a count value (A20OFF_COUNT) rather than
 38270                                  ;			     a bit to indicate to dos dispatcher to turn
 38271                                  ;			     a20 off before iret. See M016.
 38272                                  ;
 38273                                  
 38274                                  ;	BREAK	<memory allocation utility routines>
 38275                                  
 38276                                  
 38277                                  ; 15/04/2018 - Retro DOS v2.0
 38278                                  ;----------------------------------------------------------------------------
 38279                                  ; xenix memory calls for MSDOS
 38280                                  ;
 38281                                  ; CAUTION: The following routines rely on the fact that arena_signature and
 38282                                  ; arena_owner_system are all equal to zero and are contained in DI.
 38283                                  ;
 38284                                  ;INCLUDE DOSSEG.ASM
 38285                                  
 38286                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
 38287                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
 38288                                  
 38289                                  ;.xlist
 38290                                  ;.xcref
 38291                                  ;INCLUDE DOSSYM.ASM
 38292                                  ;INCLUDE DEVSYM.ASM
 38293                                  ;.cref
 38294                                  ;.list
 38295                                  
 38296                                  ;TITLE ALLOC.ASM - memory arena manager
 38297                                  ;NAME Alloc
 38298                                  
 38299                                  ;SUBTTL memory allocation utility routines
 38300                                  ;PAGE
 38301                                  ;
 38302                                  ; arena data
 38303                                  ;
 38304                                  ;       i_need  arena_head,WORD         ; seg address of start of arena
 38305                                  ;       i_need  CurrentPDB,WORD         ; current process data block addr
 38306                                  ;       i_need  FirstArena,WORD         ; first free block found
 38307                                  ;       i_need  BestArena,WORD          ; best free block found
 38308                                  ;       i_need  LastArena,WORD          ; last free block found
 38309                                  ;       i_need  AllocMethod,BYTE        ; how to alloc first(best)last
 38310                                  
 38311                                  ;**	Arena_Free_Process
 38312                                  ;----------------------------------------------------------------------------
 38313                                  ;	Free all arena blocks allocated to a prOcess
 38314                                  ;
 38315                                  ;	ENTRY	(bx) = PID of process
 38316                                  ;	EXIT	none
 38317                                  ;	USES	????? BUGBUG
 38318                                  ;----------------------------------------------------------------------------
 38319                                  
 38320                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 38321                                  	; DOSCODE:A1C2h (MSDOS 5.0, MSDOS.SYS)
 38322                                  
 38323                                  arena_free_process:
 38324                                  	; 14/05/2019 - Retro DOS v4.0
 38325                                  	; 04/08/2018 - Retro DOS v3.0
 38326 00006C36 36A1[2400]                      MOV	AX,[SS:arena_head]
 38327                                  arena_free_process_start:
 38328 00006C3A BF0000                  	MOV     DI,ARENA.SIGNATURE ; 0
 38329                                  	;MOV	AX,[SS:arena_head] ; 15/04/2018  
 38330 00006C3D E83000                          CALL	check_signature         ; ES <- AX, check for valid block
 38331                                  
 38332                                  arena_free_process_loop:
 38333                                          ;retc
 38334 00006C40 723D                            JC	SHORT AFP_RETN	; Retro DOS v2.0 - 05/03/2018
 38335 00006C42 06                      	PUSH    ES
 38336 00006C43 1F                              POP     DS
 38337                                  	;cmp	[1],bx 
 38338 00006C44 391E0100                        CMP     [ARENA.OWNER],BX	; is block owned by pid?
 38339 00006C48 7504                            JNZ     SHORT arena_free_next	; no, skip to next
 38340                                  	;mov	[1],di
 38341 00006C4A 893E0100                        MOV     [ARENA.OWNER],DI	; yes... free him
 38342                                  
 38343                                  arena_free_next:
 38344                                  	;cmp	byte [di],5Ah ;'Z'
 38345 00006C4E 803D5A                          CMP     BYTE [DI],arena_signature_end
 38346                                                                          ; end of road, Jack?
 38347                                          ;retz				; never come back no more
 38348                                  	;JZ	SHORT AFP_RETN  ; MSDOS 3.3 (& MSDOS 2.11)
 38349                                  	; 14/05/2019
 38350                                  	; MSDOS 6.0
 38351 00006C51 7405                    	jz	short arena_chk_umbs
 38352                                          
 38353 00006C53 E81300                  	CALL    arena_next              ; next item in ES/AX carry set if trash
 38354 00006C56 EBE8                            JMP     SHORT arena_free_process_loop
 38355                                  
 38356                                  	; MSDOS 6.0
 38357                                  arena_chk_umbs:				; M010 - Start
 38358                                  	; 20/05/2019
 38359 00006C58 36A1[8C00]              	mov	ax,[ss:UMB_HEAD]	; ax = umb_head
 38360 00006C5C 83F8FF                  	cmp	ax,0FFFFh		; Q: is umb_head initialized
 38361 00006C5F 741E                    	je	short ret_label		; N: we're done
 38362                                  	
 38363 00006C61 8CDF                    	mov	di,ds			; di = last arena
 38364 00006C63 39C7                    	cmp	di,ax			; Q: is last arena above umb_head
 38365 00006C65 7318                    	jae	short ret_label		; Y: we've scanned umbs also. done.
 38366 00006C67 EBD1                    	jmp	short arena_free_process_start
 38367                                  					; M010 - End
 38368                                  ;AFP_RETN:
 38369                                  ;	RETN
 38370                                  
 38371                                  ;	BREAK	<Arena Helper Routines>
 38372                                  
 38373                                  ;**	Arena_Next - Find Next item in Arena
 38374                                  ;----------------------------------------------------------------------------
 38375                                  ;	ENTRY	DS - pointer to block head
 38376                                  ;		(di) = 0
 38377                                  ;	EXIT	AX,ES - pointers to next head
 38378                                  ;		'C' set iff arena damaged
 38379                                  ;----------------------------------------------------------------------------
 38380                                  
 38381                                  arena_next:
 38382 00006C69 8CD8                            MOV     AX,DS                   ; AX <- current block
 38383 00006C6B 03060300                        ADD     AX,[ARENA.SIZE]		; AX <- AX + current block length
 38384 00006C6F 40                              INC     AX                      ; remember that header!
 38385                                  
 38386                                  ;       fall into check_signature and return
 38387                                  ;
 38388                                  ;       CALL    check_signature         ; ES <- AX, carry set if error
 38389                                  ;       RETN
 38390                                  
 38391                                  ;**	Check_Signature - Check Memory Block Signature
 38392                                  ;----------------------------------------------------------------------------
 38393                                  ;	ENTRY	(AX) = address of block header
 38394                                  ;		(di) = 0
 38395                                  ;	EXIT	 ES = AX
 38396                                  ;		'C' clear if signature good
 38397                                  ;		'C' set if signature bad
 38398                                  ;	USES	ES, Flags
 38399                                  ;----------------------------------------------------------------------------
 38400                                  
 38401                                  check_signature:        
 38402                                  
 38403 00006C70 8EC0                    	MOV     ES,AX                   ; ES <- AX
 38404                                  	;cmp	byte [es:di],4Dh ; 'M'
 38405 00006C72 26803D4D                        CMP     BYTE [ES:DI],arena_signature_normal
 38406                                                                          ; IF next signature = not_end THEN
 38407 00006C76 7407                            JZ      SHORT check_signature_ok ;   GOTO ok
 38408                                  	;cmp 	byte [es:di],5Ah ; 'Z'
 38409 00006C78 26803D5A                        CMP     BYTE [ES:DI],arena_signature_end
 38410                                                                          ; IF next signature = end then
 38411 00006C7C 7401                            JZ      SHORT check_signature_ok ;   GOTO ok
 38412 00006C7E F9                              STC                             ; set error
 38413                                  ret_label: ; MSDOS 6.0
 38414                                  AFP_RETN:
 38415                                   	; Retro DOS v2.0 - 05/03/2018
 38416                                  check_signature_ok:
 38417                                  COALESCE_RETN:
 38418 00006C7F C3                      	RETN
 38419                                  
 38420                                  ;**	Coalesce - Combine free blocks ahead with current block
 38421                                  ;----------------------------------------------------------------------------
 38422                                  ;	Coalesce adds the block following the argument to the argument block,
 38423                                  ;	iff it's free.  Coalesce is usually used to join free blocks, but
 38424                                  ;	some callers (such as $setblock) use it to join a free block to it's
 38425                                  ;	preceeding allocated block.
 38426                                  ;
 38427                                  ;	ENTRY	(ds) = pointer to the head of a free block
 38428                                  ;		(di) = 0
 38429                                  ;	EXIT	'C' clear if OK
 38430                                  ;		  (ds) unchanged, this block updated
 38431                                  ;		  (ax) = address of next block, IFF not at end
 38432                                  ;		'C' set if arena trashed
 38433                                  ;	USES	(cx)
 38434                                  ;----------------------------------------------------------------------------
 38435                                          
 38436                                  Coalesce:
 38437                                  	;cmp	byte [di],5Ah ; 'Z'
 38438 00006C80 803D5A                  	CMP     BYTE [DI],arena_signature_end
 38439                                                                          ; IF current signature = END THEN
 38440                                          ;retz				;   GOTO ok
 38441 00006C83 74FA                            jz	short COALESCE_RETN
 38442 00006C85 E8E1FF                  	CALL    arena_next              ; ES, AX <- next block, Carry set if error
 38443                                          ;retc				; IF no error THEN GOTO check
 38444 00006C88 72F5                    	jc	short COALESCE_RETN
 38445                                  
 38446                                  coalesce_check:
 38447                                  	;cmp	[es:1],di
 38448 00006C8A 26393E0100                      CMP     [ES:ARENA.OWNER],DI
 38449                                          ;retnz				; IF next block isnt free THEN return
 38450 00006C8F 75EE                            JNZ	SHORT COALESCE_RETN
 38451                                  	;mov	cx,[ES:3]
 38452 00006C91 268B0E0300              	MOV     CX,[ES:ARENA.SIZE]	; CX <- next block size
 38453 00006C96 41                              INC     CX                      ; CX <- CX + 1 (for header size)
 38454                                          ;ADD	[3],CX
 38455 00006C97 010E0300                	ADD     [ARENA.SIZE],CX		; current size <- current size + CX
 38456 00006C9B 268A0D                          MOV     CL,[ES:DI]              ; move up signature
 38457 00006C9E 880D                            MOV     [DI],CL
 38458 00006CA0 EBDE                            JMP     SHORT Coalesce		; try again
 38459                                  
 38460                                  ; 04/08/2018 - Retro DOS v3.0
 38461                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 641Fh
 38462                                  
 38463                                  ;	BREAK  <$Alloc - allocate space in memory>
 38464                                  
 38465                                  ; MSDOS 6.0
 38466                                  ;----------------------------------------------------------------------------
 38467                                  ;**	$Alloc - Allocate Memory Space
 38468                                  ;
 38469                                  ;	$Alloc services the INT21 that allocates memory space to a program.
 38470                                  ;	Alloc returns a pointer to a free block of memory that
 38471                                  ;	has the requested size in paragraphs.
 38472                                  ;
 38473                                  ;	If the allocation strategy is HIGH_FIRST or HIGH_ONLY memory is 
 38474                                  ;	scanned from umb_head if not from arena_head. If the strategy is
 38475                                  ; 	HIGH_FIRST the scan is continued from arena_head if a block of 
 38476                                  ;	appropriate size is not found in the UMBs. If the strategy is 
 38477                                  ;	HIGH_FIRST+HIGH_ONLY only the UMBs are scanned for memory.
 38478                                  ;
 38479                                  ;	In either case if bit 0 of UmbFlag is not initialized then the scan
 38480                                  ;	starts from arena_head.
 38481                                  ;
 38482                                  ;	Assembler usage:
 38483                                  ;           MOV     BX,size
 38484                                  ;           MOV     AH,Alloc
 38485                                  ;           INT     21h
 38486                                  ;
 38487                                  ;	BUGBUG - a lot can be done to improve performance. We can set marks
 38488                                  ;	so that we start searching the arena at it's first non-trivial free
 38489                                  ;	block, we can peephole the code, etc. (We can move some subr calls
 38490                                  ;	inline, etc.) I assume that this is called rarely and that the arena
 38491                                  ;	doesn't have too many memory objects in it beyond the first free one.
 38492                                  ;	verify that this is true; if so, this can stay as is
 38493                                  ;
 38494                                  ;	ENTRY	(bx) = requested size, in bytes
 38495                                  ;		(DS) = (ES) = DOSGROUP
 38496                                  ;	EXIT	'C' clear if memory allocated
 38497                                  ;		  (ax:0) = address of requested memory
 38498                                  ;		'C' set if request failed
 38499                                  ;		  (AX) = error_not_enough_memory
 38500                                  ;		    (bx) = max size we could have allocated
 38501                                  ;		  (ax) = error_arena_trashed
 38502                                  ;	USES	All
 38503                                  ;----------------------------------------------------------------------------
 38504                                  
 38505                                  ; MSDOS 2.11 (& MSDOS 3.3)
 38506                                  ;----------------------------------------------------------------------------
 38507                                  ;SUBTTL $Alloc - allocate space in memory
 38508                                  ;
 38509                                  ;   Assembler usage:
 38510                                  ;           MOV     BX,size
 38511                                  ;           MOV     AH,Alloc
 38512                                  ;           INT     21h
 38513                                  ;         AX:0 is pointer to allocated memory
 38514                                  ;         BX is max size if not enough memory
 38515                                  ;
 38516                                  ;   Description:
 38517                                  ;           Alloc returns  a  pointer  to  a  free  block of
 38518                                  ;       memory that has the requested  size  in  paragraphs.
 38519                                  ;
 38520                                  ;   Error return:
 38521                                  ;           AX = error_not_enough_memory
 38522                                  ;              = error_arena_trashed
 38523                                  ;----------------------------------------------------------------------------
 38524                                  
 38525                                  ; DOSCODE:A28Eh (MSDOS 6.21, MSDOS.SYS)
 38526                                  
 38527                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 38528                                  ; DOSCODE:A22Eh (MSDOS 5.0, MSDOS.SYS)
 38529                                  
 38530                                  _$ALLOC:
 38531                                  	; 25/05/2019 (Procedure has been checked and confirmed)
 38532                                  	; 14/05/2019 - Retro DOS v4.0
 38533                                  	; 04/08/2018 - Retro DOS v3.0
 38534                                  	;EnterCrit critMem
 38535 00006CA2 E85EAC                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 38536                                  
 38537                                  ; 17/12/2022
 38538                                  ; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38539                                  ;%if 0
 38540                                  	; 14/05/2019
 38541 00006CA5 16                      	push	ss
 38542 00006CA6 1F                      	pop	ds
 38543                                  
 38544                                  	; MSDOS 6.0
 38545                                  	;mov	ax,[ss:arena_head]
 38546                                  	;mov	[ss:START_ARENA],ax	; assume LOW_FIRST
 38547                                  
 38548 00006CA7 A1[2400]                	mov	ax,[arena_head]
 38549 00006CAA A3[8E00]                	mov	[START_ARENA],ax			
 38550                                  	
 38551                                  	;test	byte [ss:AllocMethod],HIGH_FIRST+HIGH_ONLY
 38552 00006CAD F606[0203]C0            	test	byte [AllocMethod],HIGH_FIRST+HIGH_ONLY
 38553                                  					; Q: should we start scanning from 
 38554                                  					;    UMB's
 38555 00006CB2 740D                    	jz	short norm_alloc	; N: scan from arena_head
 38556                                  		
 38557                                  	;;cmp	word [ss:UMB_HEAD],-1	; Q: Has umb_head been initialized
 38558                                  	;cmp	word [UMB_HEAD],-1
 38559                                  	;je	short norm_alloc	; N: scan from arena_head
 38560                                  
 38561                                  	;test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 38562 00006CB4 F606[8900]01            	test	byte [UMBFLAG],LINKSTATE ; 1
 38563 00006CB9 7406                    	jz	short norm_alloc	; N: scan from arena_head
 38564                                  	
 38565                                  	;mov	ax,[ss:UMB_HEAD]
 38566                                  	;mov	[ss:START_ARENA],ax	; start_arena = umb_head
 38567 00006CBB A1[8C00]                	mov	ax,[UMB_HEAD]
 38568 00006CBE A3[8E00]                	mov	[START_ARENA],ax
 38569                                  					; M000 - end
 38570                                  norm_alloc:
 38571 00006CC1 31C0                            XOR     AX,AX
 38572 00006CC3 89C7                            MOV     DI,AX
 38573                                  	; 15/03/2018
 38574                                          ;MOV	[SS:FirstArena],AX	; init the options
 38575                                          ;MOV	[SS:BestArena],AX
 38576                                          ;MOV	[SS:LastArena],AX
 38577                                  	; 14/05/2019
 38578 00006CC5 A3[4003]                	MOV	[FirstArena],AX		; init the options
 38579 00006CC8 A3[4203]                        MOV	[BestArena],AX
 38580 00006CCB A3[4403]                        MOV	[LastArena],AX
 38581 00006CCE 50                              PUSH    AX                      ; alloc_max <- 0
 38582                                  	; 04/08/2018
 38583                                  start_scan:
 38584                                  	;MOV	AX,[SS:arena_head]	; AX <- beginning of arena
 38585                                  	;MOV	AX,[arena_head]
 38586                                  
 38587                                  	; 14/05/2019	
 38588                                  	; MSDOS 6.0
 38589                                  	;mov	ax,[SS:START_ARENA]	; M000: AX <- beginning of arena
 38590 00006CCF A1[8E00]                	mov	ax,[START_ARENA]
 38591                                  
 38592                                  	; 27/09/2023 (BugFix) (*) 
 38593                                  	; ( jump from 'alloc_chk' (ds<>ss, ax = [SS:START_ARENA]))
 38594                                  start_scan_x:
 38595                                  
 38596 00006CD2 E89BFF                  	CALL    check_signature         ; ES <- AX, carry set if error
 38597 00006CD5 7236                            JC      SHORT alloc_err		; IF error THEN GOTO err
 38598                                  
 38599                                  ;%endif
 38600                                  
 38601                                  ; 17/12/2022
 38602                                  %if 0
 38603                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38604                                  
 38605                                  	; MSDOS 6.0
 38606                                  	mov	ax,[ss:arena_head]
 38607                                  	mov	[ss:START_ARENA],ax	; assume LOW_FIRST
 38608                                  
 38609                                  	test	byte [ss:AllocMethod],HIGH_FIRST+HIGH_ONLY
 38610                                  					; Q: should we start scanning from 
 38611                                  					;    UMB's
 38612                                  	jz	short norm_alloc	; N: scan from arena_head
 38613                                  		
 38614                                  	;cmp	word [ss:UMB_HEAD],-1	; Q: Has umb_head been initialized
 38615                                  	;je	short norm_alloc	; N: scan from arena_head
 38616                                  
 38617                                  	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 38618                                  	jz	short norm_alloc	; N: scan from arena_head
 38619                                  	
 38620                                  	mov	ax,[ss:UMB_HEAD]
 38621                                  	mov	[ss:START_ARENA],ax	; start_arena = umb_head
 38622                                  					; M000 - end
 38623                                  norm_alloc:
 38624                                          XOR     AX,AX
 38625                                          MOV     DI,AX
 38626                                  	; 15/03/2018
 38627                                  	MOV	[SS:FirstArena],AX	; init the options
 38628                                  	MOV	[SS:BestArena],AX
 38629                                  	MOV	[SS:LastArena],AX
 38630                                          PUSH    AX                      ; alloc_max <- 0
 38631                                  	; 04/08/2018
 38632                                  start_scan:
 38633                                  	;MOV	AX,[SS:arena_head]	; AX <- beginning of arena
 38634                                  	; 14/05/2019	
 38635                                  	; MSDOS 6.0
 38636                                  	mov	ax,[SS:START_ARENA]	; M000: AX <- beginning of arena
 38637                                  	CALL    check_signature         ; ES <- AX, carry set if error
 38638                                          JC      SHORT alloc_err		; IF error THEN GOTO err
 38639                                  %endif
 38640                                  
 38641                                  alloc_scan:
 38642 00006CD7 06                              PUSH    ES
 38643 00006CD8 1F                              POP     DS                      ; DS <- ES
 38644 00006CD9 393E0100                        CMP     [ARENA.OWNER],DI ; 0
 38645 00006CDD 7469                            JZ      SHORT alloc_free	; IF current block is free THEN examine
 38646                                  
 38647                                  alloc_next:
 38648                                  	; MSDOS 6.0			; M000 - start 
 38649 00006CDF 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 38650 00006CE5 741C                    	jz	short norm_strat	; N: see if we reached last arena
 38651                                  	
 38652 00006CE7 36F606[0203]80          	test	byte [ss:AllocMethod],HIGH_FIRST
 38653                                  					; Q: is alloc strategy high_first
 38654 00006CED 7414                    	jz	short norm_strat	; N: see if we reached last arena
 38655 00006CEF 36A1[8E00]              	mov	ax,[ss:START_ARENA]
 38656 00006CF3 363B06[2400]            	cmp	ax,[ss:arena_head]	; Q: did we start scan from 
 38657                                  					;    arena_head
 38658 00006CF8 7509                    	jne	short norm_strat	; N: see if we reached last arena
 38659 00006CFA 8CD8                    	mov	ax,ds			; ax = current block
 38660 00006CFC 363B06[8C00]            	cmp	ax,[ss:UMB_HEAD]	; Q: check against umb_head 
 38661 00006D01 EB03                    	jmp	short alloc_chk_end
 38662                                  
 38663                                  norm_strat:
 38664                                  	;cmp	byte [di],5Ah ; 'Z'
 38665 00006D03 803D5A                          CMP     BYTE [DI],arena_signature_end
 38666                                                                          ; IF current block is last THEN
 38667                                  alloc_chk_end:
 38668 00006D06 740E                            JZ      SHORT alloc_end		;   GOTO end
 38669 00006D08 E85EFF                          CALL    arena_next              ; AX, ES <- next block, Carry set if error
 38670 00006D0B 73CA                            JNC     SHORT alloc_scan	; IF no error THEN GOTO scan
 38671                                  
 38672                                  alloc_err:
 38673 00006D0D 58                              POP     AX
 38674                                  
 38675                                  alloc_trashed:
 38676                                  	;LeaveCrit critMem
 38677 00006D0E E81FAC                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0	
 38678                                          ;error	error_arena_trashed
 38679                                  	;mov	al,7
 38680 00006D11 B007                    	MOV	AL,error_arena_trashed
 38681                                  alloc_errj:
 38682 00006D13 E96499                  	JMP	SYS_RET_ERR
 38683                                  
 38684                                  alloc_end:
 38685                                  	; 18/05/2019
 38686 00006D16 36833E[4003]00                  CMP	WORD [SS:FirstArena],0
 38687 00006D1C 7403                    	jz	short alloc_chk 
 38688 00006D1E E98400                  	jmp	alloc_do_split
 38689                                  
 38690                                  alloc_chk:
 38691                                  	; MSDOS 6.0
 38692 00006D21 36A1[2400]              	mov	ax,[ss:arena_head]
 38693 00006D25 363B06[8E00]            	cmp	ax,[ss:START_ARENA]	; Q: started scanning from arena_head
 38694 00006D2A 740E                    	je	short alloc_fail	; Y: not enough memory
 38695                                  					; N:
 38696                                  					; Q: is the alloc strat HIGH_ONLY
 38697 00006D2C 36F606[0203]40          	test 	byte [ss:AllocMethod],HIGH_ONLY
 38698 00006D32 7506                    	jnz	short alloc_fail	; Y: return size of largest UMB
 38699                                  	
 38700 00006D34 36A3[8E00]              	mov	[ss:START_ARENA],ax	; N: start scanning from arena_head
 38701                                  	; 27/09/2023 (*)
 38702 00006D38 EB98                    	jmp	short start_scan_x ; (*) ; (BugFix)
 38703                                  	;jmp	short start_scan
 38704                                  					; M000 - end
 38705                                  
 38706                                  alloc_fail:
 38707                                          ;invoke Get_User_Stack
 38708 00006D3A E83A97                          CALL	Get_User_Stack
 38709 00006D3D 5B                      	POP     BX
 38710                                          ;MOV	[SI].user_BX,BX
 38711                                  	;MOV	[SI+2],BX
 38712 00006D3E 895C02                  	mov	[SI+user_env.user_BX],bx
 38713                                  	;LeaveCrit critMem
 38714 00006D41 E8ECAB                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 38715                                  	;error	error_not_enough_memory
 38716                                  	;mov	al,8
 38717 00006D44 B008                    	MOV	AL,error_not_enough_memory
 38718                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38719 00006D46 EBCB                    	jmp	short alloc_errj
 38720                                  	;JMP	SYS_RET_ERR
 38721                                  
 38722                                  alloc_free:
 38723 00006D48 E835FF                          CALL    Coalesce		; add following free block to current
 38724 00006D4B 72C0                            JC	SHORT alloc_err		; IF error THEN GOTO err
 38725 00006D4D 8B0E0300                        MOV     CX,[ARENA.SIZE]
 38726 00006D51 5A                              POP     DX                      ; check for max found size
 38727 00006D52 39D1                            CMP     CX,DX
 38728 00006D54 7602                            JNA     SHORT alloc_test
 38729 00006D56 89CA                            MOV     DX,CX
 38730                                  
 38731                                  alloc_test:
 38732 00006D58 52                              PUSH    DX
 38733 00006D59 39CB                            CMP     BX,CX                   ; IF BX > size of current block THEN
 38734 00006D5B 7782                    	JA      SHORT alloc_next	;   GOTO next
 38735                                  
 38736                                  	; 15/03/2018
 38737 00006D5D 36833E[4003]00                  CMP     WORD [SS:FirstArena],0
 38738 00006D63 7505                    	JNZ	SHORT alloc_best
 38739 00006D65 368C1E[4003]                    MOV     [SS:FirstArena],DS	; save first one found	
 38740                                  alloc_best:
 38741 00006D6A 36833E[4203]00                  CMP     WORD [SS:BestArena],0
 38742 00006D70 740E                            JZ      SHORT alloc_make_best	; initial best
 38743 00006D72 06                              PUSH	ES
 38744 00006D73 368E06[4203]                    MOV     ES,[SS:BestArena]
 38745 00006D78 26390E0300                      CMP     [ES:ARENA.SIZE],CX	; is size of best larger than found?
 38746 00006D7D 07                              POP	ES
 38747 00006D7E 7605                            JBE     SHORT alloc_last
 38748                                  alloc_make_best:
 38749 00006D80 368C1E[4203]                    MOV     [SS:BestArena],DS	; assign best
 38750                                  alloc_last:
 38751 00006D85 368C1E[4403]                    MOV     [SS:LastArena],DS 	; assign last
 38752 00006D8A E952FF                          JMP     alloc_next
 38753                                  ;
 38754                                  ; split the block high
 38755                                  ;
 38756                                  alloc_do_split_high:
 38757 00006D8D 368E1E[4403]                    MOV     DS,[SS:LastArena]
 38758 00006D92 8B0E0300                        MOV     CX,[ARENA.SIZE]
 38759 00006D96 29D9                            SUB     CX,BX
 38760 00006D98 8CDA                            MOV     DX,DS
 38761 00006D9A 7449                            JE      SHORT alloc_set_owner	; sizes are equal, no split
 38762 00006D9C 01CA                            ADD     DX,CX                   ; point to next block
 38763 00006D9E 8EC2                            MOV     ES,DX                   ; no decrement!
 38764 00006DA0 49                              DEC     CX
 38765 00006DA1 87D9                            XCHG    BX,CX                   ; bx has size of lower block
 38766 00006DA3 EB2B                            JMP     SHORT alloc_set_sizes	; cx has upper (requested) size
 38767                                  ;
 38768                                  ; we have scanned memory and have found all appropriate blocks
 38769                                  ; check for the type of allocation desired; first and best are identical
 38770                                  ; last must be split high
 38771                                  ;
 38772                                  alloc_do_split:
 38773                                  
 38774                                  ; 17/12/2022
 38775                                  ; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38776                                  ;%if 0
 38777                                  	; 14/05/2019
 38778                                  	; MSDOS 6.0			; M000 - start
 38779                                  	;xor	cx,cx
 38780 00006DA5 368A0E[0203]            	mov	cl,[ss:AllocMethod]
 38781                                  	;and	cx,STRAT_MASK ; 0FF3Fh	; mask off bit 7
 38782 00006DAA 80E13F                  	and	cl,3Fh
 38783                                  	;cmp	cx,BEST_FIT ; 1		; Q; is the alloc strategy best_fit
 38784 00006DAD 80F901                  	cmp	cl,BEST_FIT
 38785 00006DB0 77DB                    	ja	short alloc_do_split_high
 38786                                  ;%endif
 38787                                  
 38788                                  	; 17/12/2022
 38789                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38790                                  	; MSDOS 6.0 & MSDOS 5.0
 38791                                  	;xor	cx,cx
 38792                                  	;mov	cl,[ss:AllocMethod]
 38793                                  	;and	cx,STRAT_MASK ; 0FF3Fh	; mask off bit 7
 38794                                  	;cmp	cx,BEST_FIT ; 1		; Q; is the alloc strategy best_fit
 38795                                  	;ja	short alloc_do_split_high
 38796                                  
 38797                                  	; 15/03/2018
 38798                                          ;;CMP	BYTE [SS:AllocMethod], 1
 38799                                  	; 04/08/2018
 38800                                  	;CMP	BYTE [SS:AllocMethod],BEST_FIT
 38801                                          ;JA	SHORT alloc_do_split_high
 38802                                          
 38803 00006DB2 368E1E[4003]            	MOV     DS,[SS:FirstArena]        
 38804 00006DB7 7205                    	JB      SHORT alloc_get_size
 38805 00006DB9 368E1E[4203]            	MOV     DS,[SS:BestArena]
 38806                                  
 38807                                  alloc_get_size:
 38808 00006DBE 8B0E0300                        MOV     CX,[ARENA.SIZE]
 38809 00006DC2 29D9                            SUB     CX,BX                   ; get room left over
 38810 00006DC4 8CD8                            MOV     AX,DS
 38811 00006DC6 89C2                            MOV     DX,AX                   ; save for owner setting
 38812 00006DC8 741B                            JE      SHORT alloc_set_owner	; IF BX = size THEN (don't split)
 38813 00006DCA 01D8                            ADD     AX,BX
 38814 00006DCC 40                              INC     AX                      ; remember the header
 38815 00006DCD 8EC0                            MOV     ES,AX                   ; ES <- DS + BX (new header location)
 38816 00006DCF 49                              DEC     CX                      ; CX <- size of split block
 38817                                  alloc_set_sizes:
 38818 00006DD0 891E0300                        MOV     [ARENA.SIZE],BX		; current size <- BX
 38819 00006DD4 26890E0300                      MOV     [ES:ARENA.SIZE],CX      ; split size <- CX
 38820                                  	;mov	bl,4Dh ; 'M'
 38821 00006DD9 B34D                            MOV     BL,arena_signature_normal
 38822 00006DDB 861D                            XCHG    BL,[DI]			; current signature <- 4D
 38823 00006DDD 26881D                          MOV     [ES:DI],BL		; new block sig <- old block sig
 38824 00006DE0 26893E0100                      MOV     [ES:ARENA.OWNER],DI
 38825                                  
 38826                                  alloc_set_owner:
 38827 00006DE5 8EDA                            MOV     DS,DX
 38828 00006DE7 36A1[3003]                      MOV     AX,[SS:CurrentPDB] ; 15/03/2018
 38829 00006DEB A30100                          MOV     [ARENA.OWNER],AX
 38830 00006DEE 8CD8                            MOV     AX,DS
 38831 00006DF0 40                              INC     AX
 38832 00006DF1 5B                              POP     BX
 38833                                  	;LeaveCrit critMem
 38834 00006DF2 E83BAB                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 38835                                  	
 38836                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38837                                  alloc_ok:
 38838                                          ;transfer SYS_RET_OK
 38839 00006DF5 E97898                  	JMP	SYS_RET_OK
 38840                                  
 38841                                  ;	BREAK $SETBLOCK - change size of an allocated block (if possible)
 38842                                  
 38843                                  ; MSDOS 6.0
 38844                                  ;----------------------------------------------------------------------------
 38845                                  ;**	$SETBLOCK - Change size of an Allocated Block
 38846                                  ;
 38847                                  ;	Setblock changes the size of an allocated block. First, we coalesce
 38848                                  ;	any following free space onto this block; then we try to trim the
 38849                                  ;	block down to the size requested.
 38850                                  ;
 38851                                  ;	Note that if the guy wants to grow the block but that growth fails,
 38852                                  ;	we still go ahead and coalesce any trailing free blocks onto it.
 38853                                  ;	Thus the maximum-size-possible value that we return has already
 38854                                  ;	been allocated! This is a bug, dare we fix it? BUGBUG
 38855                                  ;
 38856                                  ;	NOTE - $SETBLOCK is in bed with $ALLOC and jumps into $ALLOC to
 38857                                  ;		finish it's work. For this reason we build the allocsf
 38858                                  ;		structure on the frame, to make us compatible with $ALLOCs
 38859                                  ;		code.
 38860                                  ;
 38861                                  ;	ENTRY	(es) = segment of old block
 38862                                  ;		(bx) = newsize
 38863                                  ;		(ah) = SETBLOCK
 38864                                  ;
 38865                                  ;	EXIT	'C' clear if OK
 38866                                  ;		'C' set if error
 38867                                  ;		  (ax) = error_invalid_block
 38868                                  ;		       = error_arena_trashed
 38869                                  ;		       = error_not_enough_memory
 38870                                  ;		       = error_invalid_function
 38871                                  ;		  (bx) = maximum size possible, iff (ax) = error_not_enough_memory
 38872                                  ;	USES	???? BUGBUG
 38873                                  ;----------------------------------------------------------------------------
 38874                                  
 38875                                  ; MSDOS 2.11 (& MSDOS 3.3)
 38876                                  ;----------------------------------------------------------------------------
 38877                                  ;SUBTTL $SETBLOCK - change size of an allocated block (if possible)
 38878                                  ;
 38879                                  ;   Assembler usage:
 38880                                  ;           MOV     ES,block
 38881                                  ;           MOV     BX,newsize
 38882                                  ;           MOV     AH,setblock
 38883                                  ;           INT     21h
 38884                                  ;         if setblock fails for growing, BX will have the maximum
 38885                                  ;         size possible
 38886                                  ;   Error return:
 38887                                  ;           AX = error_invalid_block
 38888                                  ;              = error_arena_trashed
 38889                                  ;              = error_not_enough_memory
 38890                                  ;              = error_invalid_function
 38891                                  ;----------------------------------------------------------------------------
 38892                                  
 38893                                  _$SETBLOCK:        
 38894                                  	; 04/08/2018 - Retro DOS v3.0
 38895                                  	;EnterCrit   critMem
 38896 00006DF8 E808AB                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 38897                                  
 38898 00006DFB BF0000                  	MOV     DI,ARENA.SIGNATURE
 38899 00006DFE 8CC0                            MOV     AX,ES
 38900 00006E00 48                              DEC     AX
 38901 00006E01 E86CFE                          CALL    check_signature
 38902 00006E04 7303                            JNC     SHORT setblock_grab
 38903                                  
 38904                                  setblock_bad:
 38905 00006E06 E905FF                          JMP     alloc_trashed
 38906                                  
 38907                                  setblock_grab:
 38908 00006E09 8ED8                            MOV     DS,AX
 38909 00006E0B E872FE                          CALL    Coalesce
 38910 00006E0E 72F6                            JC      SHORT setblock_bad
 38911 00006E10 8B0E0300                        MOV     CX,[ARENA.SIZE]
 38912 00006E14 51                              PUSH    CX
 38913 00006E15 39CB                            CMP     BX,CX
 38914 00006E17 76A5                            JBE     SHORT alloc_get_size
 38915 00006E19 E91EFF                          JMP     alloc_fail
 38916                                  
 38917                                  ;	BREAK $DEALLOC - free previously allocated piece of memory
 38918                                  
 38919                                  ; MSDOS 6.0
 38920                                  ;----------------------------------------------------------------------------
 38921                                  ;**	$DEALLOC - Free Heap Memory
 38922                                  ;
 38923                                  ;	ENTRY	(es) = address of item
 38924                                  ;
 38925                                  ;	EXIT	'C' clear of OK
 38926                                  ;		'C' set if error
 38927                                  ;		  (AX) = error_invalid_block
 38928                                  ;	USES	???? BUGBUG
 38929                                  
 38930                                  ; MSDOS 2.11 (& MSDOS 3.3)
 38931                                  ;----------------------------------------------------------------------------
 38932                                  ;SUBTTL $DEALLOC - free previously allocated piece of memory
 38933                                  ;
 38934                                  ;   Assembler usage:
 38935                                  ;           MOV     ES,block
 38936                                  ;           MOV     AH,dealloc
 38937                                  ;           INT     21h
 38938                                  ;
 38939                                  ;   Error return:
 38940                                  ;           AX = error_invalid_block
 38941                                  ;              = error_arena_trashed
 38942                                  ;---------------------------------------------------------------------------- 
 38943                                  
 38944                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38945                                  _$DEALLOC:
 38946                                  	; 14/05/2019 - Retro DOS v4.0    
 38947                                  	; 04/08/2018 - Retro DOS v3.0
 38948                                  	;EnterCrit   critMem
 38949 00006E1C E8E4AA                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 38950                                  
 38951                                  	; MSDOS 6.0			; M016, M068 - Start
 38952 00006E1F 36F606[8600]04          	test	byte [ss:DOS_FLAG],EXECA20OFF
 38953                                  					; Q: was the previous call an int 21
 38954                                  					;    exec call
 38955 00006E25 740D                    	jz	short deallocate	; N: continue
 38956 00006E27 36803E[8500]00          	cmp	byte [ss:A20OFF_COUNT], 0 ; Q: is count 0
 38957 00006E2D 7505                    	jne	short deallocate	; N: continue
 38958                                  	;mov	byte [ss:A20OFF_COUNT], 1 ; Y: set count to 1
 38959                                  	; 25/09/2023
 38960 00006E2F 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]
 38961                                  deallocate:				; M016, M068 - End
 38962 00006E34 BF0000                  	MOV     DI,ARENA.SIGNATURE ; = 0
 38963 00006E37 8CC0                            MOV     AX,ES
 38964 00006E39 48                              DEC     AX
 38965 00006E3A E833FE                          CALL    check_signature
 38966 00006E3D 720A                            JC      SHORT dealloc_err
 38967 00006E3F 26893E0100                      MOV     [ES:ARENA.OWNER],DI
 38968                                  	;LeaveCrit critMem
 38969 00006E44 E8E9AA                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 38970                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38971                                          ;transfer SYS_RET_OK
 38972                                  dealloc_ok:
 38973 00006E47 EBAC                    	jmp	short alloc_ok
 38974                                  	;JMP	SYS_RET_OK
 38975                                  
 38976                                  dealloc_err:
 38977                                  	;LeaveCrit critMem
 38978 00006E49 E8E4AA                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 38979                                          ;error	error_invalid_block
 38980                                  	;mov	al,9
 38981 00006E4C B009                    	MOV	AL,error_invalid_block
 38982                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38983                                  dealloc_errj:
 38984                                  AllocOperErrj:	; 17/12/2022
 38985 00006E4E E92998                  	JMP	SYS_RET_ERR
 38986                                  
 38987                                  ;	BREAK $AllocOper - get/set allocation mechanism
 38988                                  
 38989                                  ; MSDOS 6.0
 38990                                  ;----------------------------------------------------------------------------
 38991                                  ;**	$AllocOper - Get/Set Allocation Mechanism
 38992                                  ;
 38993                                  ;	Assembler usage:
 38994                                  ;           MOV     AH,AllocOper
 38995                                  ;           MOV     BX,method
 38996                                  ;           MOV     AL,func
 38997                                  ;           INT     21h
 38998                                  ;
 38999                                  ;	ENTRY	
 39000                                  ;		(al) = 0
 39001                                  ;		  Get allocation Strategy in (ax)
 39002                                  ;
 39003                                  ;		(al) = 1, (bx) = method = zw0000xy
 39004                                  ;		  Set allocation strategy.
 39005                                  ;		   w  = 1  => HIGH_ONLY
 39006                                  ;		   z  = 1  => HIGH_FIRST
 39007                                  ;		   xy = 00 => FIRST_FIT
 39008                                  ;		      = 01 => BEST_FIT
 39009                                  ;		      = 10 => LAST_FIT
 39010                                  ;
 39011                                  ;		(al) = 2
 39012                                  ;		  Get UMB link state in (al)
 39013                                  ;
 39014                                  ;		(al) = 3
 39015                                  ;		  Set UMB link state
 39016                                  ;		   (bx) = 0 => Unlink UMBs
 39017                                  ;		   (bx) = 1 => Link UMBs
 39018                                  ;
 39019                                  ;
 39020                                  ;	EXIT	'C' clear if OK
 39021                                  ;
 39022                                  ;		 if (al) = 0
 39023                                  ;		  (ax) = existing method
 39024                                  ;		 if (al) = 1
 39025                                  ;		  Sets allocation strategy
 39026                                  ;		 if (al) = 2
 39027                                  ;		  (al) = 0 => UMBs not linked
 39028                                  ;		  (al) = 1 => UMBs linked in
 39029                                  ;		 if (al) = 3
 39030                                  ;		  Links/Unlinks the UMBs into DOS chain
 39031                                  ;
 39032                                  ;		'C' set if error
 39033                                  ;		  AX = error_invalid_function
 39034                                  ;
 39035                                  ;	Rev. M000 - added support for HIGH_FIRST in (al) = 1. 7/9/90
 39036                                  ; 	Rev. M003 - added functions (al) = 2 and (al) = 3. 7/18/90
 39037                                  ;	Rev. M009 - (al) = 3 will return 'invalid function' in ax if
 39038                                  ;		    umbhead has'nt been initialized by sysinit and 'trashed
 39039                                  ;		    arena' if an arena sig is damaged.
 39040                                  ;----------------------------------------------------------------------------
 39041                                  
 39042                                  ; MSDOS 2.11 (& MSDOS 3.3)
 39043                                  ;----------------------------------------------------------------------------
 39044                                  ;SUBTTL $AllocOper - get/set allocation mechanism
 39045                                  ;
 39046                                  ;   Assembler usage:
 39047                                  ;           MOV     AH,AllocOper
 39048                                  ;           MOV     BX,method
 39049                                  ;           MOV     AL,func
 39050                                  ;           INT     21h
 39051                                  ;
 39052                                  ;   Error return:
 39053                                  ;           AX = error_invalid_function
 39054                                  ;----------------------------------------------------------------------------
 39055                                  
 39056                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39057                                  _$ALLOCOPER:
 39058                                  	; 14/05/2019 - Retro DOS v4.0
 39059                                  	; MSDOS 6.0
 39060 00006E51 08C0                    	or	al,al ; 0
 39061 00006E53 741E                    	jz	short AllocGetStrat
 39062                                  	; 17/12/2022
 39063                                  	;cmp	al,1
 39064                                  	;jz	short AllocSetStrat
 39065                                  
 39066                                  	; 01/12/2022
 39067                                  	;cmp	al, 2
 39068                                  	;jb	short AllocSetStrat
 39069                                  	;ja	short AllocSetLink
 39070                                  	;;jmp	short AllocGetLink
 39071                                  ;AllocGetLink:
 39072                                  	; MSDOS 6.0
 39073                                  	;mov	al,[ss:UMBFLAG]		; return link state in al
 39074                                  	;and 	al,LINKSTATE		
 39075                                  	;;transfer SYS_RET_OK
 39076                                  	;jmp	SYS_RET_OK
 39077                                  
 39078 00006E55 3C02                    	cmp	al,2
 39079                                  	; 17/12/2022
 39080 00006E57 7223                    	jb	short AllocSetStrat ; al = 1
 39081 00006E59 7432                    	je	short AllocGetLink
 39082                                  
 39083                                  	;cmp	al,2
 39084                                  	;jz	short AllocGetLink
 39085 00006E5B 3C03                    	cmp	al,3
 39086 00006E5D 7436                    	jz	short AllocSetLink
 39087                                  
 39088                                  	; 15/04/2018
 39089                                  	;CMP	AL,1
 39090                                          ;JB	SHORT AllocOperGet
 39091                                          ;JZ	SHORT AllocOperSet
 39092                                  
 39093                                  AllocOperError:
 39094                                  	; 04/08/2018 - Retro DOS v3.0
 39095                                  	; MSDOS 3.3 (& MSDOS 6.0)	; Extended Error Locus	
 39096                                  	;mov	byte [ss:EXTERR_LOCUS],5
 39097 00006E5F 36C606[2303]05                  MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
 39098                                  	;error	error_invalid_function
 39099                                  	;mov	al,1
 39100 00006E65 B001                    	MOV	AL,error_invalid_function
 39101                                  	; 17/12/2022
 39102                                  ;AllocOperErrj:
 39103                                  	;JMP	SYS_RET_ERR
 39104                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39105                                  	;jmp	short dealloc_errj
 39106                                  	; 17/12/2022
 39107 00006E67 EBE5                    	jmp	short AllocOperErrj
 39108                                  
 39109                                  AllocArenaError:
 39110                                  	; MSDOS 6.0
 39111 00006E69 36C606[2303]05          	MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
 39112                                  					; M009: Extended Error Locus
 39113                                  	;error	error_arena_trashed	; M009:
 39114                                  	;mov	al,7
 39115 00006E6F B007                    	MOV	AL,error_arena_trashed
 39116                                  	;JMP	SYS_RET_ERR
 39117 00006E71 EBDB                    	jmp	short AllocOperErrj ; 17/12/2022
 39118                                  
 39119                                  AllocGetStrat: 
 39120                                  	; MSDOS 6.0
 39121                                  AllocOperGet:
 39122 00006E73 36A0[0203]                      MOV     AL,[SS:AllocMethod]
 39123 00006E77 30E4                            XOR     AH,AH
 39124                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39125                                  	;transfer SYS_RET_OK
 39126                                  AllocOperOk:
 39127                                  	; 17/12/2022
 39128                                  	;jmp	short dealloc_ok
 39129 00006E79 E9F497                  	JMP	SYS_RET_OK
 39130                                  
 39131                                  AllocSetStrat: 
 39132                                  	; 14/05/2019
 39133                                  	; MSDOS 6.0
 39134 00006E7C 53                      	push	bx			; M000 - start
 39135                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39136                                  	;and	bx,STRAT_MASK ; 0FF3Fh	; M064: mask off bit 6 & 7
 39137                                  	; 17/12/2022
 39138 00006E7D 80E33F                  	and	bl,3Fh
 39139 00006E80 83FB02                  	cmp	bx,2			; BX must be 0-2
 39140                                  	;cmp	bl,2
 39141 00006E83 5B                      	pop	bx			; M000 - end
 39142 00006E84 77D9                    	ja	short AllocOperError
 39143                                  
 39144                                  AllocOperSet:
 39145 00006E86 36881E[0203]                    MOV     [SS:AllocMethod],BL
 39146                                    	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39147                                  	;transfer SYS_RET_OK
 39148                                  AllocOperOkj:
 39149 00006E8B EBEC                    	jmp	short AllocOperOk
 39150                                  	;JMP	SYS_RET_OK
 39151                                  
 39152                                  AllocGetLink:
 39153                                  	; MSDOS 6.0
 39154 00006E8D 36A0[8900]              	mov	al,[ss:UMBFLAG]		; return link state in al
 39155                                  	;and	al,1
 39156 00006E91 2401                    	and 	al,LINKSTATE		
 39157                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39158                                  	;transfer SYS_RET_OK
 39159                                  AllocOperOkj2:
 39160                                  	; 17/12/2022
 39161 00006E93 EBE4                    	jmp	short AllocOperOk
 39162                                  	;jmp	short AllocOperOkj
 39163                                  	;;JMP	SYS_RET_OK
 39164                                  
 39165                                  AllocSetLink:
 39166                                  	; MSDOS 6.0			; M009 - start
 39167 00006E95 368B0E[8C00]            	mov	cx,[ss:UMB_HEAD]	; cx = umb_head
 39168 00006E9A 83F9FF                  	cmp	cx,0FFFFh		; Q: has umb_head been initialized
 39169 00006E9D 74C0                    	je	short AllocOperError	; N: error
 39170                                  					; Y: continue
 39171                                  					; M009 - end
 39172 00006E9F 83FB01                  	cmp	bx,1			
 39173 00006EA2 7204                    	jb	short UnlinkUmbs
 39174 00006EA4 741C                    	jz	short LinkUmbs
 39175                                  	
 39176 00006EA6 EBB7                    	jmp	short AllocOperError
 39177                                  	
 39178                                  UnlinkUmbs:
 39179                                  	;test	byte [ss:UMBFLAG],1
 39180 00006EA8 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: umbs unlinked?
 39181 00006EAE 7410                    	jz	short unlinked		; Y: return 
 39182                                  	
 39183 00006EB0 E82900                  	call	GetLastArena		; get arena before umb_head in DS
 39184 00006EB3 72B4                    	jc	short AllocArenaError	; M009: arena trashed
 39185                                  	
 39186                                  					; make it last
 39187 00006EB5 C60600005A              	mov	byte [0],arena_signature_end
 39188                                  	
 39189                                  	;and	byte [ss:UMBFLAG],0FEh
 39190 00006EBA 368026[8900]FE          	and	byte [ss:UMBFLAG],~LINKSTATE ; indicate unlink'd state in umbflag
 39191                                  	
 39192                                  unlinked:
 39193                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39194                                  	;transfer SYS_RET_OK
 39195                                  	; 17/12/2022
 39196 00006EC0 EBB7                    	jmp	short AllocOperOk
 39197                                  	;jmp	short AllocOperOkj2
 39198                                  	;;JMP	SYS_RET_OK
 39199                                  
 39200                                  LinkUmbs:
 39201 00006EC2 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: umbs linked?
 39202 00006EC8 7510                    	jnz	short linked		; Y: return
 39203                                  	
 39204 00006ECA E80F00                  	call	GetLastArena		; get arena before umb_head
 39205 00006ECD 729A                    	jc	short AllocArenaError	; M009: arena trashed
 39206                                  	
 39207                                  					; make it normal. M061: ds points to
 39208                                  					; arena before umb_head
 39209 00006ECF C60600004D              	mov	byte [0],arena_signature_normal
 39210                                  	
 39211 00006ED4 36800E[8900]01          	or	byte [ss:UMBFLAG],LINKSTATE ; indicate link'd state in umbflag
 39212                                  linked:
 39213                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39214                                  	;transfer SYS_RET_OK
 39215                                  	; 17/12/2022
 39216 00006EDA EB9D                    	jmp	short AllocOperOk
 39217                                  	;jmp	short unlinked
 39218                                  	;;JMP	SYS_RET_OK
 39219                                  
 39220                                  ; MSDOS 6.0
 39221                                  ;--------------------------------------------------------------------------
 39222                                  ; Procedure Name : GetLastArena		-  M003
 39223                                  ;
 39224                                  ; Inputs	 : cx = umb_head
 39225                                  ;
 39226                                  ;
 39227                                  ; Outputs	 : If UMBs are linked
 39228                                  ;			ES = umb_head
 39229                                  ;			DS = arena before umb_head
 39230                                  ;		   else
 39231                                  ;			DS = last arena
 39232                                  ;			ES = next arena. will be umb_head if NC.
 39233                                  ;
 39234                                  ;		   CY if error
 39235                                  ;
 39236                                  ; Uses		 : DS, ES, DI, BX
 39237                                  ;--------------------------------------------------------------------------
 39238                                  
 39239                                  ; 14/05/2019 - Retro DOS v4.0
 39240                                  ; DOSCODE:A4D6h (MSDOS 6.21, MSDOS.SYS)
 39241                                  
 39242                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39243                                  ; DOSCODE:A476h (MSDOS 5.0, MSDOS.SYS)
 39244                                  	
 39245                                  GetLastArena:
 39246 00006EDC 50                      	push	ax			; save ax
 39247                                  
 39248 00006EDD 36A1[2400]              	mov	ax,[ss:arena_head]
 39249 00006EE1 8EC0                    	mov	es,ax			; es = arena_head
 39250 00006EE3 31FF                    	xor	di,di
 39251                                  
 39252 00006EE5 26803D5A                	cmp     byte [es:di],arena_signature_end
 39253                                  					; Q: is this the last arena
 39254 00006EE9 7419                    	je	short GLA_done		; Y: return last arena in ES		
 39255                                  					
 39256                                  GLA_next:
 39257 00006EEB 8ED8                    	mov	ds,ax
 39258 00006EED E879FD                  	call	arena_next		; ax, es -> next arena
 39259                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39260                                  	;jc	short GLA_err
 39261                                  	; 17/12/2022
 39262 00006EF0 7228                    	jc	short GLA_err2
 39263                                  
 39264 00006EF2 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are UMBs linked
 39265 00006EF8 7506                    	jnz	short GLA_chkumb	; Y: terminating condition is 
 39266                                  					;    umb_head
 39267                                  					; N: terminating condition is 05Ah
 39268                                  
 39269 00006EFA 26803D5A                	cmp     byte [es:di],arena_signature_end
 39270                                  					; Q: is this the last arena
 39271 00006EFE EB02                    	jmp	short GLA_@f
 39272                                  GLA_chkumb:
 39273 00006F00 39C8                    	cmp	ax,cx			; Q: is this umb_head
 39274                                  GLA_@f:
 39275 00006F02 75E7                    	jne	short GLA_next		; N: get next arena
 39276                                  
 39277                                  GLA_done:
 39278                                  					; M061 - Start
 39279 00006F04 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are UMBs linked
 39280 00006F0A 750B                    	jnz	short GLA_ret		; Y: we're done
 39281                                  					; N: let us confirm that the next 
 39282                                  					;    arena is umb_head
 39283 00006F0C 8ED8                    	mov	ds,ax
 39284 00006F0E E858FD                  	call	arena_next		; ax, es -> next arena
 39285                                  	;jc	short GLA_err
 39286 00006F11 7207                    	jc	short GLA_err2
 39287 00006F13 39C8                    	cmp	ax,cx			; Q: is this umb_head
 39288 00006F15 7502                    	jne	short GLA_err		; N: error
 39289                                  					; M061 - End
 39290                                  GLA_ret:
 39291                                  	; 17/12/2022				
 39292                                  	;clc
 39293                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39294                                  	;clc
 39295 00006F17 58                      	pop	ax			; M061
 39296 00006F18 C3                      	retn				; M061
 39297                                  
 39298                                  GLA_err:
 39299 00006F19 F9                      	stc				; M061
 39300                                  GLA_err2:
 39301 00006F1A 58                      	pop	ax
 39302 00006F1B C3                      	retn
 39303                                  
 39304                                  ;============================================================================
 39305                                  ; SRVCALL.ASM, MSDOS 6.0, 1991
 39306                                  ;============================================================================
 39307                                  ; 04/08/2018 - Retro DOS v3.0
 39308                                  
 39309                                  ;	TITLE SRVCALL - Server DOS call
 39310                                  ;	NAME  SRVCALL
 39311                                  
 39312                                  ;**	SRVCALL.ASM - Server DOS call functions
 39313                                  ;
 39314                                  ;
 39315                                  ;	$ServerCall
 39316                                  ;
 39317                                  ;	Modification history:
 39318                                  ;
 39319                                  ;	    Created: ARR 08 August 1983
 39320                                  
 39321                                  ;AsmVars <Installed>
 39322                                  
 39323                                  ;include dpl.asm
 39324                                  
 39325                                  ;Installed = TRUE
 39326                                  
 39327                                  ; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 39328                                  ; ---------------------------------------------------------------------------
 39329                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39330                                  
 39331                                  ;BREAK <ServerCall -- Server DOS call>
 39332                                  
 39333                                  ; DOSCODE:A517h (MSDOS 6.21, MSDOS.SYS)
 39334                                  ; DOSCODE:A4B7h (MSDOS 5.0, MSDOS.SYS)
 39335                                  
 39336                                  ;hkn; TABLE	SEGMENT
 39337                                  ;Public SRVC001S,SRVC001E
 39338                                  ;SRVC001S label byte
 39339                                  
 39340                                  SRVC001S:
 39341                                  
 39342 00006F1C [206F]                  SERVERTAB:	dw	SERVER_DISP
 39343 00006F1E [726F]                  SERVERLEAVE:	dw	SERVERRETURN
 39344 00006F20 0B                      SERVER_DISP:	db	(SERVER_DISP_END-SERVER_DISP-1)/2 ; = 11
 39345 00006F21 [DA6F]                  		dw	SRV_CALL	; 0
 39346 00006F23 [736F]                  		dw	COMMIT_ALL	; 1
 39347 00006F25 [A96F]                  		dw	CLOSE_NAME	; 2
 39348 00006F27 [B46F]                  		dw	CLOSE_UID	; 3
 39349 00006F29 [BB6F]                  		dw	CLOSE_UID_PID	; 4
 39350 00006F2B [C26F]                  		dw	GET_LIST	; 5
 39351 00006F2D [1B70]                  		dw	GET_DOS_DATA	; 6
 39352 00006F2F [3F70]                  		dw	SPOOL_OPER	; 7
 39353 00006F31 [3F70]                  		dw	SPOOL_OPER	; 8
 39354 00006F33 [3F70]                  		dw	SPOOL_OPER	; 9
 39355 00006F35 [4B70]                  		dw	_$SetExtendedError  ; 10
 39356                                  
 39357                                  SERVER_DISP_END:  ;  LABEL BYTE
 39358                                  
 39359                                  ;SRVC001E label byte
 39360                                  
 39361                                  SRVC001E:
 39362                                  
 39363                                  ;hkn; TABLE	ENDS
 39364                                  
 39365                                  ;----------------------------------------------------------------------------
 39366                                  ;
 39367                                  ; Procedure Name : $ServerCall
 39368                                  ;
 39369                                  ; Inputs:
 39370                                  ;	DS:DX -> DPL  (except calls 7,8,9)
 39371                                  ; Function:
 39372                                  ;	AL=0	Server DOS call
 39373                                  ;	AL=1	Commit All files
 39374                                  ;	AL=2	Close file by name (SHARING LOADED ONLY) DS:DX in DPL -> name
 39375                                  ;	AL=3	Close all files for DPL_UID
 39376                                  ;	AL=4	Close all files for DPL_UID/PID_PID
 39377                                  ;	AL=5	Get open file list entry
 39378                                  ;		    IN: BX File Index
 39379                                  ;			CX User Index
 39380                                  ;		    OUT:ES:DI -> Name
 39381                                  ;			BX = UID
 39382                                  ;		    CX = # locked blocks held by this UID
 39383                                  ;	AL=6	Get DOS data area
 39384                                  ;		    OUT: DS:SI -> Start
 39385                                  ;			CX size in bytes of swap if indos
 39386                                  ;			DX size in bytes of swap always
 39387                                  ;	AL=7	Get truncate flag
 39388                                  ;	AL=8	Set truncate flag
 39389                                  ;	AL=9	Close all spool files
 39390                                  ;	AL=10	SetExtendedError
 39391                                  ;
 39392                                  ;----------------------------------------------------------------------------
 39393                                  
 39394                                  _$ServerCall:
 39395                                  	; 13/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39396                                  	; DOSCODE:A4D2h (MSDOS 5.0 MSDOS.SYS)		
 39397                                  	; 10/06/2019
 39398                                  	; 29/04/2019 - Retro DOS v4.0
 39399                                  	; DOSCODE:A532h (MSDOS 6.21 MSDOS.SYS)
 39400                                  
 39401                                  	; 05/08/2018 - Retro DOS v3.0
 39402                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 657Bh
 39403 00006F37 3C07                    	CMP	AL,7
 39404 00006F39 7204                    	JB	short SET_STUFF
 39405 00006F3B 3C09                    	CMP	AL,9
 39406 00006F3D 761A                    	JBE	short NO_SET_ID		; No DPL on calls 7,8,9
 39407                                  SET_STUFF:
 39408 00006F3F 89D6                    	MOV	SI,DX			; Point to DPL with DS:SI
 39409                                  	;mov	bx,[si+12h]
 39410 00006F41 8B5C12                  	MOV	BX,[SI+DPL.UID]
 39411                                  
 39412                                  	; MSDOS 6.0
 39413                                  ;SR;
 39414                                  ; WIN386 updates the USER_ID itself. If WIN386 is present we skip the updating
 39415                                  ; of USER_ID
 39416                                  
 39417 00006F44 36F606[A110]01          	test	byte [SS:IsWin386],1
 39418 00006F4A 7505                    	jnz	short skip_win386
 39419                                  
 39420                                  ;hkn; SS override for user_id and proc_id
 39421                                  	; 15/08/2018
 39422 00006F4C 36891E[3E03]            	MOV	[SS:USER_ID],BX		; Set UID
 39423                                  
 39424                                  skip_win386:
 39425 00006F51 8B5C14                  	MOV	BX,[SI+DPL.PID]
 39426 00006F54 36891E[3C03]            	MOV	[SS:PROC_ID],BX		; Set process ID
 39427                                  NO_SET_ID:
 39428                                  	; 10/06/2019 - Retro DOS v4.0
 39429 00006F59 2EFF36[1E6F]            	PUSH	word [cs:SERVERLEAVE]	; push return address
 39430 00006F5E 2EFF36[1C6F]            	PUSH	word [cS:SERVERTAB]	; push table address
 39431 00006F63 50                      	PUSH	AX
 39432 00006F64 E8AFA8                  	call	TableDispatch
 39433                                  
 39434                                  ;hkn; SS override
 39435                                  	;mov 	byte [SS:EXETERR_LOCUS],1
 39436 00006F67 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 39437                                  	;error	error_invalid_function
 39438                                  	;mov	al,1
 39439 00006F6D B001                    	MOV	AL,error_invalid_function
 39440                                  servercall_error:
 39441 00006F6F E90897                  	JMP	SYS_RET_ERR
 39442                                  
 39443                                  SERVERRETURN:
 39444 00006F72 C3                      	retn
 39445                                  
 39446                                  ; Commit - iterate through the open file list and make sure that the
 39447                                  ; directory entries are correctly updated.
 39448                                  
 39449                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39450                                  COMMIT_ALL:
 39451 00006F73 31DB                    	XOR	BX,BX			;   for (i=0; ThisSFT=getSFT(i); i++)
 39452 00006F75 16                      	push	ss
 39453 00006F76 1F                      	pop	ds
 39454 00006F77 E889A9                  	call	ECritSFT		; Gonna scan SFT cache, lock it down
 39455                                  CommitLoop:
 39456 00006F7A 53                      	push	bx
 39457 00006F7B E82401                  	call	SFFromSFN
 39458 00006F7E 7222                    	JC	short CommitDone
 39459 00006F80 26833D00                	cmp	word [es:di],0
 39460                                  	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],0
 39461                                  					; if (ThisSFT->refcount != 0)
 39462 00006F84 7418                    	JZ	short CommitNext
 39463                                  	;cmp	word [es:di],0FFFFh ; -1
 39464 00006F86 26833DFF                	cmp	word [ES:DI],sf_busy
 39465                                  	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],sf_busy  
 39466                                  					; BUSY SFTs have god knows what
 39467 00006F8A 7412                    	JZ	short CommitNext	;   in them.
 39468                                  	; 17/12/2022
 39469 00006F8C 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8) ; 80h
 39470                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet ; 8000h
 39471 00006F91 750B                    	JNZ	short CommitNext	;  Skip Network SFTs so the SERVER
 39472                                  					;	doesn't deadlock
 39473 00006F93 893E[9E05]              	MOV	[THISSFT],DI
 39474 00006F97 8C06[A005]              	MOV	[THISSFT+2],ES
 39475 00006F9B E85AC9                  	call	DOS_COMMIT		;	DOSCommit ();
 39476                                  CommitNext:
 39477 00006F9E 5B                      	pop	bx
 39478 00006F9F 43                      	INC	BX
 39479 00006FA0 EBD8                    	JMP	short CommitLoop
 39480                                  CommitDone:
 39481 00006FA2 E88BA9                  	call	LCritSFT
 39482 00006FA5 5B                      	pop	bx
 39483                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39484                                  Commit_Ok:
 39485 00006FA6 E9C796                  	jmp	SYS_RET_OK
 39486                                  	
 39487                                  
 39488                                  CLOSE_NAME:
 39489                                  
 39490                                  ;if installed
 39491                                  
 39492                                  ;hkn; SS override
 39493                                  	;call	far [ss:MFTcloN]
 39494 00006FA9 36FF1E[A400]            	Call	far [SS:JShare+(5*4)] ; 5 = MFTcloN
 39495                                  ;else
 39496                                  ;	Call	MFTcloN
 39497                                  ;endif
 39498                                  
 39499                                  CheckReturns:
 39500 00006FAE 7202                    	JC	short func_err
 39501                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39502                                  	;transfer SYS_RET_OK
 39503                                  Commit_Okj:
 39504 00006FB0 EBF4                    	jmp	short Commit_Ok
 39505                                  	;jmp	SYS_RET_OK
 39506                                  
 39507                                  func_err:
 39508                                  	;transfer SYS_RET_ERR
 39509                                  	;jmp	SYS_RET_ERR
 39510 00006FB2 EBBB                    	jmp	short servercall_error
 39511                                  
 39512                                  CLOSE_UID:
 39513                                  
 39514                                  ;if installed
 39515                                  ;hkn; SS override
 39516                                  	;call	far [ss:MFTclU]
 39517 00006FB4 36FF1E[9C00]            	Call	far [SS:JShare+(3*4)] ; 3 = MTFTclu
 39518                                  ;else
 39519                                  ;	Call	MFTclU
 39520                                  ;endif
 39521 00006FB9 EBF3                    	JMP	short CheckReturns
 39522                                  
 39523                                  CLOSE_UID_PID:
 39524                                  
 39525                                  ;if installed
 39526                                  ;hkn; SS override
 39527                                  	;call	far [ss:MFTCloseP]
 39528 00006FBB 36FF1E[A000]            	Call	far [SS:JShare+(4*4)] ; 4 = MFTCloseP 
 39529                                  ;else
 39530                                  ;	Call	MFTCloseP
 39531                                  ;endif
 39532 00006FC0 EBEC                    	JMP	short CheckReturns
 39533                                  
 39534                                  GET_LIST:
 39535                                  
 39536                                  ;if installed
 39537                                  ;hkn; SS override
 39538                                  	;call	far [ss:MFT_get]
 39539 00006FC2 36FF1E[B400]            	Call	far [SS:JShare+(9*4)] ; 9 = MFT_get
 39540                                  ;else
 39541                                  ;	Call	MFT_get
 39542                                  ;endif
 39543 00006FC7 72E9                    	JC	short func_err
 39544 00006FC9 E8AB94                  	call	Get_User_Stack
 39545                                  	;mov	[si+2],bx
 39546 00006FCC 895C02                  	MOV	[SI+user_env.user_BX],BX
 39547                                  	;mov	[si+10],di
 39548 00006FCF 897C0A                  	MOV	[SI+user_env.user_DI],DI
 39549                                  	;mov	[si+16],es
 39550 00006FD2 8C4410                  	MOV	[SI+user_env.user_ES],ES
 39551                                  SetCXOK:
 39552                                  	;mov	[si+4],cx
 39553 00006FD5 894C04                  	MOV	[SI+user_env.user_CX],CX
 39554                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39555                                  	;transfer SYS_RET_OK
 39556                                  Commit_Okj2:
 39557                                  	; 17/12/2022
 39558 00006FD8 EBCC                    	jmp	short Commit_Ok
 39559                                  	;jmp	short Commit_Okj
 39560                                  	;;jmp	SYS_RET_OK
 39561                                  
 39562                                  SRV_CALL:
 39563 00006FDA 58                      	POP	AX			; get rid of call to $srvcall
 39564 00006FDB 1E                      	push	ds
 39565 00006FDC 56                      	push	si
 39566 00006FDD E89794                  	call	Get_User_Stack
 39567 00006FE0 5F                      	pop	di
 39568 00006FE1 07                      	pop	es
 39569                                  
 39570                                  ; DS:SI point to stack
 39571                                  ; ES:DI point to DPL
 39572                                  
 39573 00006FE2 E810A8                  	call	XCHGP
 39574                                  
 39575                                  ; DS:SI point to DPL
 39576                                  ; ES:DI point to stack
 39577                                  ;
 39578                                  ; We now copy the registers from DPL to save stack
 39579                                  
 39580 00006FE5 56                      	push	si
 39581 00006FE6 B90600                  	MOV	CX,6
 39582 00006FE9 F3A5                    	REP	MOVSW			; Put in AX,BX,CX,DX,SI,DI
 39583 00006FEB 47                      	INC	DI
 39584 00006FEC 47                      	INC	DI			; Skip user_BP
 39585 00006FED A5                      	MOVSW				; DS
 39586 00006FEE A5                      	MOVSW				; ES
 39587 00006FEF 5E                      	pop	si			; DS:SI -> DPL
 39588 00006FF0 8B04                    	mov	ax,[SI]
 39589                                  	;MOV	AX,[SI+DPL.AX]
 39590                                  	;mov	bx,[si+2]
 39591 00006FF2 8B5C02                  	MOV	BX,[SI+DPL.BX]
 39592                                  	;mov	cx,[si+4]
 39593 00006FF5 8B4C04                  	MOV	CX,[SI+DPL.CX]
 39594                                  	;mov	dx,[si+6]
 39595 00006FF8 8B5406                  	MOV	DX,[SI+DPL.DX]
 39596                                  	;mov	di,[si+10]
 39597 00006FFB 8B7C0A                  	MOV	DI,[SI+DPL.DI]
 39598                                  	;mov	es,[si+14]
 39599 00006FFE 8E440E                  	MOV	ES,[SI+DPL.ES]
 39600                                  	;push	word [si+8]
 39601 00007001 FF7408                  	PUSH	word [SI+DPL.SI]
 39602                                  	;mov	ds,[si+12]
 39603 00007004 8E5C0C                  	MOV	DS,[SI+DPL.DS]
 39604 00007007 5E                      	POP	SI
 39605                                  
 39606                                  ;hkn; SS override for next 3
 39607 00007008 368C1E[EC05]            	MOV	[SS:SAVEDS],DS
 39608 0000700D 36891E[EA05]            	MOV	[SS:SAVEBX],BX
 39609 00007012 36C606[7205]FF          	MOV	byte [SS:FSHARING],-1	; set no redirect flag
 39610 00007018 E95A93                  	jmp	REDISP
 39611                                  
 39612                                  GET_DOS_DATA:
 39613 0000701B 16                      	push	ss
 39614 0000701C 07                      	pop	es
 39615 0000701D BF[2003]                	MOV     DI,SWAP_START
 39616 00007020 B9[AC0A]                	MOV     CX,SWAP_END
 39617 00007023 BA[3A03]                	MOV     DX,SWAP_ALWAYS
 39618 00007026 29F9                    	SUB     CX,DI
 39619 00007028 29FA                    	SUB     DX,DI
 39620 0000702A D1E9                    	SHR     CX,1                    ; div by 2, remainder in carry
 39621 0000702C 83D100                  	ADC     CX,0                    ; div by 2 + round up
 39622 0000702F D1E1                    	SHL     CX,1                    ; round up to 2 boundary.
 39623 00007031 E84394                  	call	Get_User_Stack
 39624                                  	;mov	[si+14],es
 39625 00007034 8C440E                  	MOV     [SI+user_env.user_DS],ES
 39626                                  	;mov	[si+8],di
 39627 00007037 897C08                  	MOV     [SI+user_env.user_SI],DI
 39628                                  	;mov	[si+6],dx
 39629 0000703A 895406                  	MOV     [SI+user_env.user_DX],DX
 39630 0000703D EB96                    	JMP	short SetCXOK
 39631                                  
 39632                                  SPOOL_OPER:
 39633                                  	;CallInstall NETSpoolOper,MultNET,37,AX,BX
 39634                                  
 39635 0000703F 50                      	push    ax
 39636 00007040 B82511                  	mov     ax,1125h
 39637 00007043 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
 39638                                  			; STACK: WORD subfunction
 39639                                  			; Return: CF set on error, AX = error code
 39640                                  			; STACK unchanged
 39641 00007045 5B                      	pop	bx
 39642                                  	; 17/12/2022
 39643                                  	;JC	short func_err2
 39644 00007046 7390                    	jnc	short Commit_Okj2
 39645                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39646                                  	;;jmp	SYS_RET_OK
 39647                                  	;jmp	short Commit_Okj2
 39648                                  	
 39649                                  func_err2:
 39650 00007048 E92F96                  	jmp	SYS_RET_ERR
 39651                                  
 39652                                  ;Break	<$SetExtendedError - set extended error for later retrieval>
 39653                                  ;--------------------------------------------------------------------------
 39654                                  ;
 39655                                  ; Procedure Name : $SetExtendedError
 39656                                  ;
 39657                                  ; $SetExtendedError takes extended error information and loads it up for the
 39658                                  ; next extended error call. This is used by interrupt-level proccessors to
 39659                                  ; mask their actions.
 39660                                  ;
 39661                                  ;   Inputs: DS:SI points to DPL which contains all registers
 39662                                  ;   Outputs: none
 39663                                  ;
 39664                                  ;---------------------------------------------------------------------------
 39665                                  
 39666                                  _$SetExtendedError:
 39667                                  
 39668                                  ;hkn; SS override for all variables used
 39669                                  
 39670 0000704B 8B04                    	mov	ax,[si]
 39671                                  	;MOV	AX,[SI+DPL.AX]
 39672 0000704D 36A3[2403]              	MOV	[SS:EXTERR],AX
 39673                                  	;mov	ax,[si+10]
 39674 00007051 8B440A                  	MOV	AX,[SI+DPL.DI]
 39675 00007054 36A3[2803]              	MOV	[SS:EXTERRPT],AX
 39676                                  	;mov	ax,[si+14]
 39677 00007058 8B440E                  	MOV	AX,[SI+DPL.ES]
 39678 0000705B 36A3[2A03]              	MOV	[SS:EXTERRPT+2],AX
 39679                                  	;mov	ax,[si+2]
 39680 0000705F 8B4402                  	MOV	AX,[SI+DPL.BX]
 39681 00007062 36A3[2603]              	MOV	[SS:EXTERR_ACTION],AX
 39682                                  	;mov	ax,[si+4]
 39683 00007066 8B4404                  	MOV	AX,[SI+DPL.CX]
 39684 00007069 368826[2303]            	MOV	[SS:EXTERR_LOCUS],AH
 39685 0000706E C3                      	retn
 39686                                  
 39687                                  ;============================================================================
 39688                                  ; UTIL.ASM, MSDOS 6.0, 1991
 39689                                  ;============================================================================
 39690                                  ; 05/08/2018 - Retro DOS v3.0
 39691                                  ; 05/05/2019 - Retro DOS v4.0
 39692                                  
 39693                                  ;**	Handle related utilities for MSDOS 2.X.
 39694                                  ;----------------------------------------------------------------------------
 39695                                  ;	pJFNFromHandle	written
 39696                                  ;	SFFromHandle	written
 39697                                  ;	SFFromSFN	written
 39698                                  ;	JFNFree 	written
 39699                                  ;	SFNFree 	written
 39700                                  ;
 39701                                  ;	Modification history:
 39702                                  ;
 39703                                  ;	    Created: MZ 1 April 1983
 39704                                  ;----------------------------------------------------------------------------
 39705                                  
 39706                                  ;	BREAK	<pJFNFromHandle - return pointer to JFN table entry>
 39707                                  
 39708                                  ;**	pJFNFromHandle - Translate Handle to Pointer to JFN
 39709                                  ;----------------------------------------------------------------------------
 39710                                  ;	pJFNFromHandle takes a file handle and turns that into a pointer to
 39711                                  ;	the JFN entry (i.e., to a byte holding the internal file handle #)
 39712                                  ;
 39713                                  ;	NOTE:
 39714                                  ;	  This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
 39715                                  ;	  at DOSINIT time with SS NOT DOSGROUP
 39716                                  ;
 39717                                  ;	ENTRY	(bx) = handle
 39718                                  ;	EXIT	'C' clear if ok
 39719                                  ;		  (es:di) = address of JFN value
 39720                                  ;		'C' set if error
 39721                                  ;		  (ax) = error code
 39722                                  ;	USES	AX, DI, ES, Flags
 39723                                  ;----------------------------------------------------------------------------
 39724                                  
 39725                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39726                                  
 39727                                  pJFNFromHandle:
 39728                                  	; 05/05/2019 - Retro DOS v4.0
 39729                                  	;getdseg <es>			; es -> dosdata
 39730 0000706F 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 39731                                  	
 39732                                  	;MOV	ES,[cs:CurrentPDB]	; get user process data block
 39733 00007074 268E06[3003]            	mov	es,[es:CurrentPDB]
 39734                                  
 39735                                  	;cmp	bx,[ES:32h]
 39736 00007079 263B1E3200              	CMP	BX,[ES:PDB.JFN_Length]	; is handle greater than allocated
 39737 0000707E 7204                    	JB	short pjfn10		; no, get offset
 39738                                  ReturnCarry_inv_hndl: ; 05/08/2018 - Retro DOS v3.0
 39739                                  	;mov	al,6
 39740 00007080 B006                    	MOV     AL,error_invalid_handle ; appropriate error
 39741                                  ReturnCarry:
 39742 00007082 F9                      	STC                             ; signal error
 39743 00007083 C3                      	retn				; go back
 39744                                  pjfn10: 
 39745                                  	;les	di,[es:34h]
 39746 00007084 26C43E3400              	LES	DI,[ES:PDB.JFN_Pointer]	; get pointer to beginning of table
 39747 00007089 01DF                    	ADD	DI,BX			; add in offset, clear 'C'
 39748                                  	;clc
 39749                                  pJFNFromHandle_error:
 39750 0000708B C3                      	retn
 39751                                  
 39752                                  ;BREAK <SFFromHandle - return pointer (or error) to SF entry from handle>
 39753                                  ;----------------------------------------------------------------------------
 39754                                  ;
 39755                                  ; Procedure Name : SFFromHandle
 39756                                  ;
 39757                                  ; SFFromHandle - Given a handle, get JFN and then index into SF table
 39758                                  ;
 39759                                  ;   Input:      BX has handle
 39760                                  ;   Output:     Carry Set
 39761                                  ;                   AX has error code
 39762                                  ;               Carry Reset
 39763                                  ;                   ES:DI has pointer to SF entry
 39764                                  ;   Registers modified: If error, AX,ES, else ES:DI
 39765                                  ; NOTE:
 39766                                  ;   This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
 39767                                  ;       at DOSINIT time with SS NOT DOSGROUP
 39768                                  ;
 39769                                  ;----------------------------------------------------------------------------
 39770                                  
 39771                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39772                                  
 39773                                  SFFromHandle:
 39774 0000708C E8E0FF                  	CALL	pJFNFromHandle		; get jfn pointer
 39775                                  	;retc				; return if error
 39776 0000708F 72FA                    	jc	short pJFNFromHandle_error
 39777 00007091 26803DFF                	CMP     BYTE [ES:DI],-1		; unused handle
 39778                                  	;JNZ	short GetSF		; nope, suck out SF
 39779                                  	;;mov	al,6
 39780                                  	;MOV	AL,error_invalid_handle ; appropriate error
 39781                                  	;jmp	short ReturnCarry	; signal it
 39782                                  	; 17/12/2022
 39783                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39784 00007095 74E9                    	jz	short ReturnCarry_inv_hndl ; Retro DOS v3.0 modification
 39785                                  	;JNZ	short GetSF		; nope, suck out SF
 39786                                  	;;mov	al,6
 39787                                  	;MOV	AL,error_invalid_handle ; appropriate error
 39788                                  	;jmp	short ReturnCarry	; signal it
 39789                                  GetSF:
 39790 00007097 53                      	push	bx			; save handle
 39791 00007098 268A1D                  	MOV     BL,[ES:DI]		; get SFN
 39792 0000709B 30FF                    	XOR     BH,BH                   ; ignore upper half
 39793 0000709D E80200                  	CALL    SFFromSFN               ; get real sf spot
 39794 000070A0 5B                      	pop	bx			; restore
 39795 000070A1 C3                      	retn                        	; say goodbye
 39796                                  
 39797                                  ;BREAK <SFFromSFN - index into SF table for SFN>
 39798                                  
 39799                                  ;**	SFFromSFN - Get an SF Table entry from an SFN
 39800                                  ;----------------------------------------------------------------------------
 39801                                  ;	SFFromSfn uses an SFN to index an entry into the SF table. This
 39802                                  ;	is more than just a simple index instruction because the SF table
 39803                                  ;	can be made up of multiple pieces chained together. We follow the
 39804                                  ;	chain to the right piece and then do the index operation.
 39805                                  ;
 39806                                  ;   NOTE:
 39807                                  ;	This routine is called from SFFromHandle which is called
 39808                                  ;       at DOSINIT time with SS NOT DOSGROUP
 39809                                  ;
 39810                                  ;	ENTRY	BX has SF index
 39811                                  ;	EXIT	'C' clear if OK
 39812                                  ;		  ES:DI points to SF entry
 39813                                  ;		'C' set if index too large
 39814                                  ;	USES	BX, DI, ES
 39815                                  ;----------------------------------------------------------------------------
 39816                                  
 39817                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39818                                  
 39819                                  SFFromSFN:
 39820                                  	; 05/05/2019 - Retro DOS v4.0
 39821                                  	;getdseg <es>			; es -> dosdata
 39822 000070A2 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 39823                                  
 39824                                  	;LES	DI,[CS:SFT_ADDR]	; (es:di) = start of SFT table
 39825 000070A7 26C43E[2A00]            	les	di,[es:SFT_ADDR]
 39826                                  sfsfn5:	
 39827                                  	;cmp	bx,[es:di+4]
 39828 000070AC 263B5D04                	CMP	BX,[ES:DI+SFT.SFCount]	; is handle in this table?
 39829 000070B0 720E                    	JB	short sfsfn7		; yes, go grab it
 39830                                  	;sub	bx,[es:di+4]
 39831 000070B2 262B5D04                	SUB     BX,[ES:DI+SFT.SFCount]
 39832 000070B6 26C43D                  	les	di,[es:di] ; 14/08/2018
 39833                                  	;LES	DI,[ES:DI+SFT.SFLink]	; get next table segment
 39834 000070B9 83FFFF                  	CMP     DI,-1                   ; end of tables?
 39835 000070BC 75EE                    	JNZ	short sfsfn5		; no, try again
 39836 000070BE F9                      	STC
 39837 000070BF C3                      	retn				; return with error, not found
 39838                                  sfsfn7:
 39839 000070C0 50                      	push	ax
 39840                                  	;mov	ax,53 ; MSDOS 3.3
 39841                                  	;mov	ax,59 ; MSDOS 6.0
 39842                                  	;MOV	AX,SF_ENTRY.size	; put it in a nice place
 39843                                  	
 39844                                  	; 17/12/2022
 39845 000070C1 B03B                    	mov	al,SF_ENTRY.size ; 28/05/2019
 39846                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39847                                  	;mov	ax,SF_ENTRY.size ; 59
 39848                                  	
 39849 000070C3 F6E3                    	MUL	BL			; (ax) = offset into this SF block
 39850 000070C5 01C7                    	ADD	DI,AX			; add base of SF block
 39851 000070C7 58                      	pop	ax
 39852                                  	;add	di,6
 39853 000070C8 83C706                  	ADD	DI,SFT.SFTable		; offset into structure, 'C' cleared
 39854 000070CB C3                      	retn				; return with 'C' clear
 39855                                  
 39856                                  ;	BREAK <JFNFree - return a jfn pointer if one is free>
 39857                                  
 39858                                  ;**	JFNFree - Find a Free JFN Slot
 39859                                  ;----------------------------------------------------------------------------
 39860                                  ;	JFNFree scansthrough the JFN table and returnsa pointer to a free slot
 39861                                  ;
 39862                                  ;	ENTRY	(ss) = DOSDATA
 39863                                  ;	EXIT	'C' clear if OK
 39864                                  ;		  (bx) = new handle
 39865                                  ;		  (es:di) = pointer to JFN slot
 39866                                  ;		'C' set if error
 39867                                  ;		  (al) = error code
 39868                                  ;	USES	bx, di, es, flags
 39869                                  ;----------------------------------------------------------------------------
 39870                                  
 39871                                  JFNFree:
 39872 000070CC 31DB                    	XOR	BX,BX			; (bx) = initial JFN to try
 39873                                  jfnf1:	
 39874 000070CE E89EFF                  	CALL	pJFNFromHandle		; get the appropriate handle
 39875 000070D1 7209                    	JC	short jfnf5		; no more handles
 39876 000070D3 26803DFF                	CMP     BYTE [ES:DI],-1		; free?
 39877 000070D7 7405                    	je	short jfnfx		; yes, carry is clear
 39878 000070D9 43                      	INC     BX                      ; no, next handle
 39879 000070DA EBF2                    	JMP	short jfnf1		; and try again
 39880                                  
 39881                                  	; Error. 'C' set
 39882                                  jfnf5:	
 39883                                  	;mov	al,4
 39884 000070DC B004                    	MOV	AL,error_too_many_open_files
 39885                                  jfnfx:	
 39886 000070DE C3                      	retn				; bye
 39887                                  
 39888                                  ;	BREAK <SFNFree - Allocate a free SFN>
 39889                                  
 39890                                  ;**	SFNFree - Allocate a Free SFN/SFT
 39891                                  ;----------------------------------------------------------------------------
 39892                                  ;	SFNFree scans through the sf table looking for a free entry
 39893                                  ;	If it finds one it partially allocates it by setting SFT_REF_COUNT = -1
 39894                                  ;
 39895                                  ;	The problem is that we want to mark the SFT busy so that other threads
 39896                                  ;	can't allocate the SFT before we're finished marking it up.  However,
 39897                                  ;	we can't just mark it busy because we may get blown out of our open
 39898                                  ;	by INT24 and leave the thing orphaned.	To solve this we mark it
 39899                                  ;	"allocation in progress" by setting SFT_REF_COUNT = -1.  If we see
 39900                                  ;	an SFT with this value we look to see if it belongs to this user
 39901                                  ;	and process.  If it does belong to us then it must be an orphan
 39902                                  ;	and we reclaim it.
 39903                                  ;
 39904                                  ;	BUGBUG - improve the performance. I guess it's smaller to call SFFromSFN
 39905                                  ;		over and over, but we could at least set a high water mark...
 39906                                  ;		cause an N^2 loop calling slow SFFromSFN is real slow, too slow
 39907                                  ;		even though this is not a frequently called routine - jgl
 39908                                  ;
 39909                                  ;	ENTRY	(ss) = DOSDATA
 39910                                  ;	EXIT	'C' clear if no error
 39911                                  ;		  (bx) = SFN
 39912                                  ;		  (es:di) = pointer to SFT
 39913                                  ;		  es:[di].SFT_REF_COUNT = -1
 39914                                  ;		'C' set if error
 39915                                  ;		  (al) = error code
 39916                                  ;	USES	bx, di, es, Flags
 39917                                  ;----------------------------------------------------------------------------
 39918                                  
 39919                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39920                                  	; DOSCODE:A682h (MSDOS 5.0 MSDOS.SYS)
 39921                                  
 39922                                  SFNFree:
 39923                                  	; 12/08/2018
 39924                                  	; 05/08/2018 - Retro DOS v3.0
 39925                                  	;
 39926                                  	; MSDOS 6.0
 39927 000070DF 50                      	push	ax
 39928 000070E0 31DB                    	xor	bx,bx			; (bx) = SFN to consider
 39929                                  sfnf5:	
 39930 000070E2 53                      	push	bx
 39931 000070E3 E8BCFF                  	call	SFFromSFN		; get the potential handle
 39932 000070E6 5B                      	pop	bx
 39933 000070E7 723A                    	jc	short sfnf95		; no more free SFNs
 39934 000070E9 26833D00                	cmp	word [ES:DI],0
 39935                                  	;cmp	word [ES:DI+SF_ENTRY.sf_Ref_Count],0 ; free?
 39936 000070ED 741D                    	je	short sfnf20			; yep, got one
 39937                                  	
 39938                                  	;cmp	word [es:di],0FFFFh ; -1
 39939 000070EF 26833DFF                	cmp	word [ES:DI],sf_busy
 39940                                  	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
 39941 000070F3 7403                    	je	short sfnf10		; special busy mark
 39942                                  sfnf7:	
 39943 000070F5 43                      	inc	bx			; try the next one
 39944 000070F6 EBEA                    	jmp	short sfnf5
 39945                                  
 39946                                  ;	The SFT has the special "busy" mark; if it belongs to us then
 39947                                  ;	it was abandoned during a earlier call and we can use it.
 39948                                  ;
 39949                                  ;	(bx)	= SFN
 39950                                  ;	(es:di) = pointer to SFT
 39951                                  ;	(TOS)	= caller's (ax)
 39952                                  
 39953                                  sfnf10:	
 39954 000070F8 36A1[3E03]              	mov	ax,[SS:USER_ID]
 39955                                  	;cmp	[es:di+2Fh],ax
 39956 000070FC 2639452F                	cmp	[ES:DI+SF_ENTRY.sf_UID],ax
 39957 00007100 75F3                    	jnz	short sfnf7		; not ours
 39958 00007102 36A1[3C03]              	mov	ax,[SS:PROC_ID]
 39959                                  	;cmp	[es:di+31h],ax
 39960 00007106 26394531                	cmp	[ES:DI+SF_ENTRY.sf_PID],ax
 39961 0000710A 75E9                    	jnz	short sfnf7		; can't use this one, try the next
 39962                                  
 39963                                  ;	We have an SFT to allocate
 39964                                  ;
 39965                                  ;	(bx)	= SFN
 39966                                  ;	(es:di) = pointer to SFT
 39967                                  ;	(TOS)	= caller's (ax)
 39968                                  
 39969                                  sfnf20:
 39970                                  	; cf = 0 ;; Retro DOS v3.0
 39971                                  
 39972                                  	;mov	word [es:di],0FFFFh
 39973 0000710C 26C705FFFF              	mov	word [ES:DI],sf_busy
 39974                                  					; make sure that this is allocated
 39975                                  	;mov	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
 39976                                  
 39977 00007111 36A1[3E03]              	mov	ax,[SS:USER_ID]
 39978                                  	;mov	[es:di+2Fh],ax
 39979 00007115 2689452F                	mov	[ES:DI+SF_ENTRY.sf_UID],ax
 39980 00007119 36A1[3C03]              	mov	ax,[SS:PROC_ID]
 39981                                  	;mov	[es:di+31h],ax
 39982 0000711D 26894531                	mov	[ES:DI+SF_ENTRY.sf_PID],ax
 39983                                  sfnf21: ;; Retro DOS v3.0
 39984                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39985                                  	;pop	ax
 39986                                  	;;clc
 39987                                  	;retn				; return with no error
 39988                                  	; 17/12/2022
 39989 00007121 58                      	pop	ax
 39990                                  	;clc
 39991 00007122 C3                      	retn
 39992                                  
 39993                                  ;**	Error - no more free SFNs
 39994                                  ;
 39995                                  ;	'C' set
 39996                                  ;	(TOS) = saved ax
 39997                                  
 39998                                  sfnf95: 
 39999 00007123 58                      	pop	ax
 40000                                  	;mov	al,4
 40001 00007124 B004                    	mov	al,error_too_many_open_files
 40002 00007126 C3                      	retn				; return with 'C' and error
 40003                                  
 40004                                  ;============================================================================
 40005                                  ; HANDLE.ASM, MSDOS 6.0, 1991
 40006                                  ;============================================================================
 40007                                  ; 13/07/2018 - Retro DOS v3.0
 40008                                  ; 20/05/2019 - Retro DOS v4.0
 40009                                  
 40010                                  ; DOSCODE:A72Bh (MSDOS 6.21, MSDOS.SYS)
 40011                                  
 40012                                  ;	BREAK <$Close - return a handle to the system>
 40013                                  ;----------------------------------------------------------------------------
 40014                                  ;
 40015                                  ;**	$Close - Close a file Handle
 40016                                  ;
 40017                                  ;	BUGBUG - close gets called a LOT with invalid handles - sizzle that
 40018                                  ;		path
 40019                                  ;
 40020                                  ;	Assembler usage:
 40021                                  ;	    MOV     BX, handle
 40022                                  ;	    MOV     AH, Close
 40023                                  ;	    INT     int_command
 40024                                  ;
 40025                                  ;	ENTRY	(bx) = handle
 40026                                  ;	EXIT	<normal INT21 return convention>
 40027                                  ;	USES	all
 40028                                  ;
 40029                                  ;----------------------------------------------------------------------------
 40030                                  
 40031                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40032                                  ; DOSCODE:A6CBh (MSDOS 5.0 MSDOS.SYS)
 40033                                  
 40034                                  _$CLOSE:
 40035                                  ;	Grab the SFT pointer from the JFN.
 40036                                  
 40037 00007127 E85A02                  	call	CheckOwner		; get system file entry
 40038 0000712A 722B                    	jc	short CloseError	; error return
 40039 0000712C 16                      	push	ss
 40040 0000712D 1F                      	pop	ds			; For DOS_CLOSE
 40041 0000712E 893E[9E05]              	MOV	[THISSFT],DI		; save offset of pointer
 40042 00007132 8C06[A005]              	MOV	[THISSFT+2],ES		; save segment value
 40043                                  
 40044                                  ; DS:SI point to JFN table entry.
 40045                                  ; ES:DI point to SFT
 40046                                  ;
 40047                                  ; We now examine the user's JFN entry; If the file was a 70-mode file (network
 40048                                  ; FCB, we examine the ref count on the SFT;  if it was 1, we free the JFN.
 40049                                  ; If the file was not a net FCB, we free the JFN too.
 40050                                  
 40051                                  	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],1
 40052 00007136 26833D01                	cmp	word [ES:DI],1		; will the SFT become free?
 40053 0000713A 740A                    	jz	short FreeJFN 		; yes, free JFN anyway.
 40054                                  	;mov	al,[ES:DI+2]
 40055 0000713C 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 40056                                  	;and	al,0F0h
 40057 00007140 24F0                    	AND	AL,SHARING_MASK
 40058                                  	;cmp	al,70h
 40059 00007142 3C70                    	CMP	AL,SHARING_NET_FCB
 40060 00007144 7407                    	JZ	short PostFree		; 70-mode and big ref count => free it
 40061                                  
 40062                                  ; The JFN must be freed.  Get the pointer to it and replace the contents with
 40063                                  ; -1.
 40064                                  
 40065                                  FreeJFN:
 40066 00007146 E826FF                  	call	pJFNFromHandle		;   d = pJFN (handle);
 40067 00007149 26C605FF                	MOV	BYTE [ES:DI],0FFh	; release the JFN
 40068                                  PostFree:
 40069                                  
 40070                                  ; ThisSFT is correctly set, we have DS = DOSDATA. Looks OK for a DOS_CLOSE!
 40071                                  
 40072 0000714D E8F5C5                  	call	DOS_CLOSE
 40073                                  
 40074                                  ; DOS_Close may return an error. If we see such an error, we report it but
 40075                                  ; the JFN stays closed because DOS_Close always frees the SFT!
 40076                                  
 40077 00007150 7205                    	JC	short CloseError
 40078                                  	;mov	ah,3Eh
 40079 00007152 B43E                    	MOV	AH,CLOSE		; MZ Bogus multiplan fix
 40080                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40081                                  CloseOk:
 40082 00007154 E91995                  	jmp	SYS_RET_OK
 40083                                  CloseError:
 40084 00007157 E92095                  	jmp	SYS_RET_ERR
 40085                                  
 40086                                  ;	BREAK <$Commit - commit the file>
 40087                                  ;----------------------------------------------------------------------------
 40088                                  ;
 40089                                  ;**	$Commit - Commit a File
 40090                                  ;
 40091                                  ;	$Commit "commits" a file to disk - all of it's buffers are
 40092                                  ;	flushed out.  BUGBUG - I'm pretty sure that $Commit doesn't update
 40093                                  ;	the directory entry, etc., so this commit is pretty useless. check
 40094                                  ;	and fix this!! jgl
 40095                                  ;
 40096                                  ;	Assembler usage:
 40097                                  ;	    MOV     BX, handle
 40098                                  ;	    MOV     AH, Commit
 40099                                  ;	    INT     int_command
 40100                                  ;
 40101                                  ;	ENTRY	(bx) = handle
 40102                                  ;	EXIT	none
 40103                                  ;	USES	all
 40104                                  ;;----------------------------------------------------------------------------
 40105                                  
 40106                                  _$COMMIT:
 40107                                  ;	Grab the SFT pointer from the JFN.
 40108                                  
 40109 0000715A E82702                  	call	CheckOwner		; get system file entry
 40110 0000715D 7213                    	JC	short CommitError	; error return
 40111 0000715F 16                      	push	ss
 40112 00007160 1F                      	pop	ds			; For DOS_COMMIT
 40113 00007161 893E[9E05]              	MOV	[THISSFT],DI		; save offset of pointer
 40114 00007165 8C06[A005]              	MOV	[THISSFT+2],ES		; save segment value
 40115                                  
 40116                                  ;	ThisSFT is correctly set, we have DS = DOSDATA. Looks OK for a DOS_COMMIT
 40117                                  ;
 40118                                  ;	ES:DI point to SFT
 40119                                  
 40120 00007169 E88CC7                  	call	DOS_COMMIT
 40121 0000716C 7204                    	JC	short CommitError
 40122                                  	; 07/12/2022
 40123                                  	;jc	short CloseError
 40124                                  	;mov	ah,68h
 40125 0000716E B468                    	MOV	AH,COMMIT
 40126                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40127                                  	;jmp	SYS_RET_OK
 40128                                  CommitOk:
 40129 00007170 EBE2                    	jmp	short CloseOk	
 40130                                  
 40131                                  CommitError:
 40132                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40133                                  	;jmp	SYS_RET_ERR
 40134 00007172 EBE3                    	jmp	short CloseError
 40135                                  
 40136                                  ;	BREAK <$ExtHandle - extend handle count>
 40137                                  
 40138                                  ;**	$ExtHandle - Extend Handle Count
 40139                                  ;----------------------------------------------------------------------------
 40140                                  ;	Assembler usage:
 40141                                  ;	    MOV     BX, Number of Opens Allowed (MAX=65534;66535 is
 40142                                  ;	    MOV     AX, 6700H			 reserved to mark SFT
 40143                                  ;	    INT     int_command 		 busy )
 40144                                  ;
 40145                                  ;	ENTRY	(bx) = new number of handles
 40146                                  ;	EXIT	'C' clear if OK
 40147                                  ;		'C' set iff err
 40148                                  ;		  (ax) = error code
 40149                                  ;			 AX = error_not_enough_memory
 40150                                  ;			      error_too_many_open_files
 40151                                  ;	USES	all
 40152                                  ;----------------------------------------------------------------------------
 40153                                  
 40154                                  _$ExtHandle:
 40155 00007174 31ED                    	XOR	BP,BP			; 0: enlarge   1: shrink  2:psp
 40156                                  	;cmp	bx,20
 40157 00007176 83FB14                  	CMP	BX,FILPERPROC
 40158 00007179 7303                    	JAE	short exth2		; Don't set less than FilPerProc no
 40159 0000717B BB1400                  	MOV	BX,FILPERPROC
 40160                                  exth2:	
 40161 0000717E 368E06[3003]            	MOV	ES,[ss:CurrentPDB]	; get user process data block;smr;SS Override
 40162                                  	;mov	cx,[ES:32h]
 40163 00007183 268B0E3200              	MOV	CX,[ES:PDB.JFN_Length]	; get number of handle allowed
 40164 00007188 39CB                    	CMP	BX,CX			; the requested == current
 40165 0000718A 7455                    	JE	short ok_done 		; yes and exit
 40166 0000718C 7722                    	JA	short larger		; go allocate new table
 40167                                  
 40168                                  ;	We're going to shrink the # of handles available
 40169                                  
 40170 0000718E BD0100                  	MOV	BP,1			; shrink
 40171                                  	;mov	ds,[ES:36h]
 40172 00007191 268E1E3600              	MOV	DS,[ES:PDB.JFN_Pointer+2] ;
 40173 00007196 89DE                    	MOV	SI,BX			;
 40174 00007198 29D9                    	SUB	CX,BX			; get difference
 40175                                  
 40176                                  ;	BUGBUG - code a SCASB here, should be a bit smaller
 40177                                  chck_handles:
 40178 0000719A 803CFF                  	CMP	BYTE [SI],-1		; scan through handles to ensure close
 40179 0000719D 753D                    	JNZ	short too_many_files	; status
 40180 0000719F 46                      	INC	SI
 40181 000071A0 E2F8                    	LOOP	chck_handles
 40182 000071A2 83FB14                  	CMP	BX,FILPERPROC		; = 20
 40183 000071A5 7709                    	JA	short larger		; no
 40184                                  
 40185 000071A7 BD0200                  	MOV	BP,2			; psp
 40186                                  	;mov	di,24
 40187 000071AA BF1800                  	MOV	DI,PDB.JFN_TABLE	; es:di -> jfn table in psp
 40188 000071AD 53                      	PUSH	BX
 40189 000071AE EB1D                    	JMP	short movhandl
 40190                                  
 40191                                  larger:
 40192 000071B0 83FBFF                  	CMP	BX,-1			; 65535 is not allowed
 40193 000071B3 747F                    	JZ	short invalid_func	; 10/08/2018
 40194 000071B5 F8                      	CLC
 40195 000071B6 53                      	PUSH	BX			; save requested number
 40196 000071B7 83C30F                  	ADD	BX,0FH			; adjust to paragraph boundary
 40197 000071BA B104                    	MOV	CL,4
 40198                                  	;ror	bx,cl			; MSDOS 3.3
 40199 000071BC D3DB                    	RCR	BX,CL			; DOS 4.00 fix		;AC000;
 40200 000071BE 81E3FF1F                	AND	BX,1FFFH		; clear most 3 bits
 40201                                  
 40202 000071C2 55                      	PUSH	BP
 40203 000071C3 E8DCFA                  	call	_$ALLOC			; allocate memory
 40204 000071C6 5D                      	POP	BP
 40205 000071C7 7266                    	JC	short no_memory		; not enough meory
 40206                                  
 40207 000071C9 8EC0                    	MOV	ES,AX			; es:di points to new table memory
 40208 000071CB 31FF                    	XOR	DI,DI
 40209                                  movhandl:
 40210 000071CD 368E1E[3003]            	MOV	DS,[ss:CurrentPDB] 	; get user PDB address	;smr;SS Override
 40211                                  
 40212 000071D2 F7C50300                	test	BP,3			; enlarge ?
 40213 000071D6 740C                    	JZ	short enlarge 		; yes
 40214 000071D8 59                      	POP	CX			; cx = the amount you shrink
 40215 000071D9 51                      	PUSH	CX
 40216 000071DA EB0C                    	JMP	short copy_hand
 40217                                  
 40218                                  ;	Done.  'C' clear
 40219                                  
 40220                                  ; 17/12/2022
 40221                                  ;ok_done:
 40222                                  ;	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40223                                  ;	;jmp	short CommitOk
 40224                                  ;	; 17/12/2022
 40225                                  ;	jmp	SYS_RET_OK
 40226                                  
 40227                                  too_many_files:
 40228                                  	;mov	al,4
 40229 000071DC B004                    	MOV	AL,error_too_many_open_files
 40230                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40231                                  	;jmp	SYS_RET_ERR
 40232                                  CommitErrorj:
 40233                                  	;jmp	short CommitError
 40234                                  	; 17/12/2022
 40235 000071DE E99994                  	jmp	SYS_RET_ERR
 40236                                  
 40237                                  ; 17/12/2022 
 40238                                  ok_done:
 40239                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40240                                  	;jmp	short CommitOk
 40241                                  	; 17/12/2022
 40242 000071E1 E98C94                  	jmp	SYS_RET_OK
 40243                                  
 40244                                  enlarge:
 40245                                  	;mov	cx,[32h]
 40246 000071E4 8B0E3200                	MOV	CX,[PDB.JFN_Length]	; get number of old handles
 40247                                  copy_hand:
 40248 000071E8 89CA                    	MOV	DX,CX
 40249                                  	;lds	si,[34h]
 40250 000071EA C5363400                	LDS	SI,[PDB.JFN_Pointer]	; get old table pointer
 40251 000071EE F3A4                    	REP	MOVSB			; copy infomation to new table
 40252 000071F0 59                      	POP	CX			; get new number of handles
 40253 000071F1 51                      	PUSH	CX			; save it again
 40254 000071F2 29D1                    	SUB	CX,DX			; get the difference
 40255 000071F4 B0FF                    	MOV	AL,-1			; set availability to handles
 40256 000071F6 F3AA                    	REP	STOSB
 40257 000071F8 368E1E[3003]            	MOV	DS,[ss:CurrentPDB] 	; get user process data block;smr;SS Override
 40258                                  	;cmp	word [34h],0
 40259 000071FD 833E340000              	CMP	WORD [PDB.JFN_Pointer],0 ; check if original table pointer
 40260 00007202 750D                    	JNZ	short update_info	; yes, go update PDB entries
 40261 00007204 55                      	PUSH	BP
 40262 00007205 1E                      	PUSH	DS			; save old table segment
 40263 00007206 06                      	PUSH	ES			; save new table segment
 40264 00007207 8E063600                	MOV	ES,[PDB.JFN_Pointer+2]	; get old table segment
 40265 0000720B E80EFC                  	call	_$DEALLOC		; deallocate old table meomory
 40266 0000720E 07                      	POP	ES			; restore new table segment
 40267 0000720F 1F                      	POP	DS			; restore old table segment
 40268 00007210 5D                      	POP	BP
 40269                                  
 40270                                  update_info:
 40271 00007211 F7C50200                	test	BP,2			; psp?
 40272 00007215 7408                    	JZ	short non_psp 		; no
 40273                                  	;mov	word [34h],18h ; 24
 40274 00007217 C70634001800            	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE ; restore
 40275 0000721D EB06                    	JMP	short final
 40276                                  non_psp:
 40277                                  	;mov	word [34h],0
 40278 0000721F C70634000000            	MOV	WORD [PDB.JFN_Pointer],0 ; new table pointer offset always 0
 40279                                  final:
 40280                                  	;mov	[36h],es	
 40281 00007225 8C063600                	MOV	[PDB.JFN_Pointer+2],ES	; update table pointer segment
 40282                                  	;pop	word [32h]
 40283 00007229 8F063200                	POP	word [PDB.JFN_Length]	; restore new number of handles
 40284                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40285                                  	;jmp	SYS_RET_OK
 40286                                  ok_done_j:
 40287 0000722D EBB2                    	jmp	short ok_done
 40288                                  
 40289                                  no_memory:
 40290 0000722F 5B                      	POP	BX			; clean stack
 40291                                  	;mov	al,8
 40292 00007230 B008                    	MOV	AL,error_not_enough_memory
 40293                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40294                                  	;jmp	SYS_RET_ERR
 40295                                  CommitErrorj2:
 40296 00007232 EBAA                    	jmp	short CommitErrorj
 40297                                  
 40298                                  invalid_func:
 40299                                  	;mov	al,1
 40300 00007234 B001                    	MOV	AL,error_invalid_function
 40301                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40302                                  	;jmp	SYS_RET_ERR
 40303                                  CommitErrorj3:
 40304                                  	;jmp	short CommitErrorj2
 40305                                  	; 17/12/2022
 40306 00007236 EBA6                    	jmp	short CommitErrorj
 40307                                  
 40308                                  ; 20/05/2019 - Retro DOS v4.0
 40309                                  ; DOSCODE:A83Ah (MSDOS 6.21, MSDOS.SYS)
 40310                                  
 40311                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40312                                  ; DOSCODE:A7DAh (MSDOS 5.0 MSDOS.SYS)
 40313                                  
 40314                                  ;	BREAK <$READ - Read from a file handle>
 40315                                  ;----------------------------------------------------------------------------
 40316                                  ;
 40317                                  ;**	$Read - Read from a File Handle
 40318                                  ;
 40319                                  ;   Assembler usage:
 40320                                  ;
 40321                                  ;	LDS	DX, buf
 40322                                  ;	MOV	CX, count
 40323                                  ;	MOV	BX, handle
 40324                                  ;	MOV	AH, Read
 40325                                  ;	INT	int_command
 40326                                  ;	  AX has number of bytes read
 40327                                  ;
 40328                                  ;	ENTRY	(bx) = file handle
 40329                                  ;		(cx) = byte count
 40330                                  ;		(ds:dx) = buffer address
 40331                                  ;	EXIT	Through system call return so that to user:
 40332                                  ;		  'C' clear if OK
 40333                                  ;		    (ax) = bytes read
 40334                                  ;		  'C' set if error
 40335                                  ;		    (ax) = error code
 40336                                  ;
 40337                                  ;----------------------------------------------------------------------------
 40338                                  
 40339                                  _$READ:
 40340 00007238 BE[783B]                	MOV	SI,DOS_READ
 40341                                  ReadDo:
 40342 0000723B E831FE                  	call	pJFNFromHandle
 40343 0000723E 7208                    	JC	short ReadError
 40344                                  
 40345 00007240 268A05                  	MOV	AL,[ES:DI]
 40346 00007243 E83E01                  	call	CheckOwner		; get the handle
 40347 00007246 7303                    	JNC	short ReadSetup		; no errors do the operation
 40348                                  
 40349                                  ;	Have an error. 'C' set
 40350                                  
 40351                                  ReadError:
 40352                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40353                                  	;;jmp	SYS_RET_ERR		; go to error traps
 40354                                  	;jmp	short CommitErrorj3
 40355                                  	; 17/12/2022
 40356 00007248 E92F94                  	jmp	SYS_RET_ERR
 40357                                  
 40358                                  ReadSetup:
 40359 0000724B 36893E[9E05]            	MOV	[ss:THISSFT],DI		; save offset of pointer;smr;SS Override
 40360 00007250 368C06[A005]            	MOV	[ss:THISSFT+2],ES	; save segment value	;smr;SS Override
 40361                                  	; 20/05/2019 - Retro DOS v4.0
 40362                                  	; MSDOS 6.0 
 40363                                  ;; Extended Open
 40364                                  	;test	byte [es:di+3],20h
 40365 00007255 26F6450320              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],(INT_24_ERROR>>8)
 40366                                  						 ;AN000;;EO. need i24
 40367 0000725A 7406                    	JZ	short needi24 		     	 ;AN000;;EO. yes
 40368 0000725C 36800E[F605]02          	OR	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF ; 2
 40369                                  					;AN000;;EO. set it off;smr;SS Override
 40370                                  needi24:				;AN000;
 40371                                  ;; Extended Open
 40372 00007262 36FF36[2C03]            	push	word [SS:DMAADD]
 40373 00007267 36FF36[2E03]            	push	word [SS:DMAADD+2]	;smr;SS Override
 40374                                  
 40375                                  ;;;;;	BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
 40376                                  
 40377                                  	; 26/07/2019
 40378                                  
 40379                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40380                                  	;
 40381                                  	; (It is not necessary to call 'Align_Buffer' proc here/below because
 40382                                  	; there is not another caller; it is better to put the code in this proc
 40383                                   	; here instead of calling it as a subroutine; but I have modified code
 40384                                  	; here for MSDOS 5.0 MSDOS.SYS address compatibility)
 40385                                  
 40386                                  	; MSDOS 6.0
 40387 0000726C E81300                  	CALL	Align_Buffer		;AN000;MS. align user's buffer
 40388                                  	
 40389                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40390                                  	; MSDOS 3.3
 40391                                  	;MOV	BX,DX			; copy offset
 40392                                  	;push	cx			; don't stomp on count
 40393                                  	;MOV	CL,4			; bits to shift bytes->para
 40394                                  	;SHR	BX,CL			; get number of paragraphs
 40395                                  	;pop	cx			; get count back
 40396                                  	;MOV	AX,DS			; get original segment
 40397                                  	;ADD	AX,BX			; get new segment
 40398                                  	;MOV	DS,AX			; in seg register
 40399                                  	;AND	DX,0Fh			; normalize offset
 40400                                  	;MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 40401                                  	;MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 40402                                  						;smr;SS Override
 40403                                  ;;;;;	END BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
 40404                                  	
 40405 0000726F 16                      	push	ss			; go for DOS addressability
 40406 00007270 1F                      	pop	ds
 40407                                  
 40408 00007271 FFD6                    	CALL	SI ; DOS_READ		; indirect call to operation
 40409                                  
 40410 00007273 8F06[2E03]              	pop	word [DMAADD+2]
 40411 00007277 8F06[2C03]              	pop	word [DMAADD]
 40412                                  	;JNC	short READ_OK		;AN002;
 40413                                  	;JMP	short ReadError		;AN002; if error, say bye bye
 40414                                  	; 17/12/2022
 40415 0000727B 72CB                    	jc	short ReadError
 40416                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40417                                  	;jnc	short READ_OK		;AN002;
 40418                                  	;jmp	short ReadError
 40419                                  
 40420                                  READ_OK:
 40421 0000727D 89C8                    	MOV	AX,CX			; get correct return in correct reg
 40422                                  Read_Okj:
 40423                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40424                                  	;;jmp	SYS_RET_OK		; successful return
 40425                                  	;jmp	short ok_done_j
 40426                                  	; 17/12/2022
 40427 0000727F E9EE93                  	jmp	SYS_RET_OK
 40428                                  
 40429                                  ; 13/07/2018 - Retro DOS v3.0
 40430                                  
 40431                                  ;----------------------------------------------------------------------------
 40432                                  
 40433                                  ;   Input: DS:DX points to user's buffer addr
 40434                                  ;   Function: rearrange segment and offset for READ/WRITE buffer
 40435                                  ;   Output: [DMAADD] set
 40436                                  
 40437                                  ; 20/05/2019 - Retro DOS v4.0
 40438                                  ; 26/07/2019
 40439                                  ;	; MSDOS 6.0
 40440                                  ;Align_Buffer:
 40441                                  ;	MOV	BX,DX			; copy offset
 40442                                  ;	push	cx			; don't stomp on count
 40443                                  ;	MOV	CL,4			; bits to shift bytes->para
 40444                                  ;	SHR	BX,CL			; get number of paragraphs
 40445                                  ;	pop	cx			; get count back
 40446                                  ;	MOV	AX,DS			; get original segment
 40447                                  ;	ADD	AX,BX			; get new segment
 40448                                  ;	MOV	DS,AX			; in seg register
 40449                                  ;	AND	DX,0Fh			; normalize offset
 40450                                  ;	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 40451                                  ;	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 40452                                  ;						;smr;SS Override
 40453                                  ;	retn
 40454                                  
 40455                                  ; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40456                                  Align_Buffer:
 40457 00007282 89D3                    	MOV	BX,DX			; copy offset
 40458 00007284 51                      	push	cx			; don't stomp on count
 40459 00007285 B104                    	MOV	CL,4			; bits to shift bytes->para
 40460 00007287 D3EB                    	SHR	BX,CL			; get number of paragraphs
 40461 00007289 59                      	pop	cx			; get count back
 40462 0000728A 8CD8                    	MOV	AX,DS			; get original segment
 40463 0000728C 01D8                    	ADD	AX,BX			; get new segment
 40464 0000728E 8ED8                    	MOV	DS,AX			; in seg register
 40465 00007290 83E20F                  	AND	DX,0Fh			; normalize offset
 40466 00007293 368916[2C03]            	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 40467 00007298 368C1E[2E03]            	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 40468                                  						;smr;SS Override
 40469 0000729D C3                      	retn
 40470                                  
 40471                                  ; 20/05/2019 - Retro DOS v4.0
 40472                                  ; DOSCODE:A8A0h (MSDOS 6.21, MSDOS.SYS)
 40473                                  
 40474                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40475                                  ; DOSCODE:A840h (MSDOS 5.0 MSDOS.SYS)
 40476                                  
 40477                                  ;BREAK <$WRITE - write to a file handle>
 40478                                  ;----------------------------------------------------------------------------
 40479                                  ;
 40480                                  ;   Assembler usage:
 40481                                  ;	    LDS     DX, buf
 40482                                  ;	    MOV     CX, count
 40483                                  ;	    MOV     BX, handle
 40484                                  ;	    MOV     AH, Write
 40485                                  ;	    INT     int_command
 40486                                  ;	  AX has number of bytes written
 40487                                  ;   Errors:
 40488                                  ;	    AX = write_invalid_handle
 40489                                  ;	       = write_access_denied
 40490                                  ;
 40491                                  ;   Returns in register AX
 40492                                  ;
 40493                                  ;----------------------------------------------------------------------------
 40494                                  
 40495                                  _$WRITE:
 40496 0000729E BE[A13D]                	MOV	SI,DOS_WRITE
 40497 000072A1 EB98                    	JMP	short ReadDo
 40498                                  
 40499                                  ;BREAK <$LSEEK - move r/w pointer>
 40500                                  ;----------------------------------------------------------------------------
 40501                                  ;
 40502                                  ;   Assembler usage:
 40503                                  ;	    MOV     DX, offsetlow
 40504                                  ;	    MOV     CX, offsethigh
 40505                                  ;	    MOV     BX, handle
 40506                                  ;	    MOV     AL, method
 40507                                  ;	    MOV     AH, LSeek
 40508                                  ;	    INT     int_command
 40509                                  ;	  DX:AX has the new location of the pointer
 40510                                  ;   Error returns:
 40511                                  ;	    AX = error_invalid_handle
 40512                                  ;	       = error_invalid_function
 40513                                  ;   Returns in registers DX:AX
 40514                                  ;
 40515                                  ;----------------------------------------------------------------------------
 40516                                  
 40517                                  ; 21/05/2019 - Retro DOS v4.0
 40518                                  ; DOSCODE:A8A5h (MSDOS 6.21, MSDOS.SYS)
 40519                                  
 40520                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40521                                  ; DOSCODE:A845h (MSDOS 5.0 MSDOS.SYS)
 40522                                  
 40523                                  _$LSEEK:
 40524 000072A3 E8DE00                  	call	CheckOwner		; get system file entry
 40525                                  
 40526                                  	; 17/12/2022
 40527                                  ;LSeekError:
 40528                                  	;JNC	short CHKOWN_OK		;AN002;
 40529                                  	;JMP	short ReadError		;AN002; error return
 40530                                  	; 17/12/2022
 40531                                  	; 02/06/2019
 40532 000072A6 72A0                    	jc	short ReadError
 40533                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40534                                  	;JNC	short CHKOWN_OK		;AN002;
 40535                                  	;JMP	short ReadError		;AN002; error return
 40536                                  
 40537                                  CHKOWN_OK:
 40538                                  					;AN002;
 40539 000072A8 3C02                    	CMP	AL,2			; is the seek value correct?
 40540 000072AA 760A                    	JBE	short LSeekDisp		; yes, go dispatch
 40541                                  	;mov	byte [ss:EXTERR_LOCUS],1 
 40542 000072AC 36C606[2303]01          	MOV	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 40543                                  					;smr;SS Override
 40544                                  	;mov	al,1
 40545 000072B2 B001                    	mov	al,error_invalid_function ; invalid method
 40546                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40547                                  LSeekError2:
 40548 000072B4 EB92                    	jmp	short ReadError
 40549                                  
 40550                                  LSeekDisp:
 40551 000072B6 3C01                    	CMP	AL,1			; best way to dispatch; check middle
 40552 000072B8 720A                    	JB	short LSeekStore	; just store CX:DX
 40553 000072BA 771B                    	JA	short LSeekEOF		; seek from end of file
 40554                                  	;add	dx,[es:di+21]
 40555 000072BC 26035515                	ADD	DX,[ES:DI+SF_ENTRY.sf_position]
 40556                                  	;adc	cx,[es:di+23]
 40557 000072C0 26134D17                	ADC	CX,[ES:DI+SF_ENTRY.sf_position+2]
 40558                                  LSeekStore:
 40559 000072C4 89C8                    	MOV	AX,CX			; AX:DX
 40560 000072C6 92                      	XCHG	AX,DX			; DX:AX is the correct value
 40561                                  LSeekSetpos:
 40562                                  	;mov	[es:di+21],ax
 40563 000072C7 26894515                	MOV	[ES:DI+SF_ENTRY.sf_position],AX
 40564                                  	;mov	[es:di+23],dx
 40565 000072CB 26895517                	MOV	[ES:DI+SF_ENTRY.sf_position+2],DX
 40566 000072CF E8A591                  	call	Get_User_Stack
 40567                                  	;mov	[si+6],dx
 40568 000072D2 895406                  	MOV	[SI+user_env.user_DX],DX ; return DX:AX
 40569                                  	;jmp	SYS_RET_OK		; successful return
 40570                                  	; 25/06/2019
 40571                                  	;jmp	SYS_RET_OK_clc
 40572                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40573                                  	;jmp	SYS_RET_OK_clc
 40574                                  LSeekOk:
 40575 000072D5 EBA8                    	jmp     short Read_Okj
 40576                                  
 40577                                  LSeekEOF:
 40578                                  	;;test	word [es:di+5],8000h
 40579                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 40580                                  	; 21/05/2019 - Retro DOS v4.0
 40581 000072D7 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 40582 000072DC 750A                    	JNZ	short Check_LSeek_Mode	; Is Net
 40583                                  LOCAL_LSeek:
 40584                                  	;add	dx,[es:di+17]
 40585 000072DE 26035511                	ADD	DX,[ES:DI+SF_ENTRY.sf_size]
 40586                                  	;adc	cx,[es:di+19]
 40587 000072E2 26134D13                	ADC	CX,[ES:DI+SF_ENTRY.sf_size+2]
 40588 000072E6 EBDC                    	JMP	short LSeekStore	; go and set the position
 40589                                  
 40590                                  Check_LSeek_Mode:
 40591                                  	;;test	word [es:di+2],8000h
 40592                                  	;test	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 40593                                  	; 21/05/2019
 40594 000072E8 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 40595 000072ED 75EF                    	JNZ	short LOCAL_LSeek	; FCB treated like local file
 40596                                  	;mov	ax,[es:di+2]
 40597 000072EF 268B4502                	MOV	AX,[ES:DI+SF_ENTRY.sf_mode]
 40598                                  	;and	ax, 0F0h
 40599 000072F3 25F000                  	AND	AX,SHARING_MASK
 40600                                  	;cmp	ax,40h
 40601 000072F6 83F840                  	CMP	AX,SHARING_DENY_NONE
 40602 000072F9 7405                    	JZ	short NET_LSEEK		; LSEEK exported in this mode
 40603                                  	;cmp	ax,30h
 40604 000072FB 83F830                  	CMP	AX,SHARING_DENY_READ
 40605 000072FE 75DE                    	JNZ	short LOCAL_LSeek	; Treated like local Lseek
 40606                                  NET_LSEEK:
 40607                                  ;	JMP	short LOCAL_LSeek
 40608                                  ; REMOVE ABOVE INSTRUCTION TO ENABLE DCR 142
 40609                                  	;CallInstall Net_Lseek,MultNET,33
 40610                                  	;JNC	short LSeekSetPos
 40611                                  
 40612 00007300 B82111                  	mov     ax,1121h
 40613 00007303 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE
 40614                                  			; CX:DX = offset (in bytes) from end
 40615                                  			; ES:DI -> SFT, SFT DPB field -> DPB of drive with file
 40616                                  			; SS = DOS CS
 40617                                  			; Return: CF set on error
 40618                                  			; CF clear if successful, DX:AX = new file position
 40619 00007305 73C0                    	jnb     short LSeekSetpos
 40620                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40621                                  	;jmp	SYS_RET_ERR
 40622                                  ;LSeekError3:
 40623                                  	; 17/12/2022
 40624                                  LSeekError:
 40625                                  	;jmp	short LSeekError2
 40626                                  DupErr:	; 17/12/2022
 40627 00007307 E97093                  	jmp	SYS_RET_ERR
 40628                                  
 40629                                  ;BREAK <FileTimes - modify write times on a handle>
 40630                                  ;----------------------------------------------------------------------------
 40631                                  ;
 40632                                  ;   Assembler usage:
 40633                                  ;	    MOV AH, FileTimes (57H)
 40634                                  ;	    MOV AL, func
 40635                                  ;	    MOV BX, handle
 40636                                  ;	; if AL = 1 then then next two are mandatory
 40637                                  ;	    MOV CX, time
 40638                                  ;	    MOV DX, date
 40639                                  ;	    INT 21h
 40640                                  ;	; if AL = 0 then CX/DX has the last write time/date
 40641                                  ;	; for the handle.
 40642                                  ;
 40643                                  ;	AL=02		 get extended attributes
 40644                                  ;	   BX=handle
 40645                                  ;	   CX=size of buffer (0, return max size )
 40646                                  ;	   DS:SI query list (si=-1, selects all EA)
 40647                                  ;	   ES:DI buffer to hold EA list
 40648                                  ;
 40649                                  ;	AL=03		 get EA name list
 40650                                  ;	   BX=handle
 40651                                  ;	   CX=size of buffer (0, return max size )
 40652                                  ;	   ES:DI buffer to hold name list
 40653                                  ;
 40654                                  ;	AL=04		 set extended attributes
 40655                                  ;	   BX=handle
 40656                                  ;	   ES:DI buffer of EA list
 40657                                  ;
 40658                                  ;
 40659                                  ;   Error returns:
 40660                                  ;	    AX = error_invalid_function
 40661                                  ;	       = error_invalid_handle
 40662                                  ;
 40663                                  ;----------------------------------------------------------------------------
 40664                                  
 40665                                  ; 21/05/2019 - Retro DOS v4.0
 40666                                  ; DOSCODE:A90Dh (MSDOS 6.21, MSDOS.SYS)
 40667                                  
 40668                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40669                                  ; DOSCODE:A8ADh (MSDOS 5.0 MSDOS.SYS)
 40670                                  
 40671                                  _$FILE_TIMES:
 40672                                  	; 13/07/2018 - Retro DOS v3.0
 40673                                  
 40674                                  	; MSDOS 3.3
 40675                                  	;cmp	al,2			; correct subfunction ?
 40676                                  	;jb	short ft1
 40677                                  
 40678                                  	;;mov	byte [ss:EXTERR_LOCUS], 1
 40679                                  	;mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 40680                                  						;SS Overr
 40681                                  	;;mov	al,1
 40682                                  	;mov	al,error_invalid_function ; give bad return
 40683                                  	;jmp	SYS_RET_ERR
 40684                                  
 40685                                  	; MSDOS 6.0
 40686 0000730A 3C02                    	cmp	al,2			; correct subfunction ?
 40687 0000730C 7340                    	jae	short inval_func
 40688                                  ;ft1:
 40689 0000730E E87300                  	call	CheckOwner		; get sft
 40690                                  	; 17/12/2022
 40691 00007311 72F4                    	jc	short LSeekError	; bad handle
 40692                                  
 40693 00007313 08C0                    	or	al,al			; get time/date ?
 40694 00007315 7515                    	jnz	short ft_set_time
 40695                                  
 40696                                  ;------ here we get the time & date from the sft for the user
 40697                                  
 40698 00007317 FA                      	cli				; is this cli/sti reqd ? BUGBUG
 40699                                  	;mov	cx,[es:di+13]
 40700 00007318 268B4D0D                	mov	cx,[es:di+SF_ENTRY.sf_time] ; get the time
 40701                                  	;mov	dx,[es:di+15]
 40702 0000731C 268B550F                	mov	dx,[es:di+SF_ENTRY.sf_date] ;  & date
 40703 00007320 FB                      	sti
 40704 00007321 E85391                  	call	Get_User_Stack
 40705                                  	;mov	[si+4],cx
 40706 00007324 894C04                  	mov	[si+user_env.user_CX],cx
 40707                                  	;mov	[si+6],dx
 40708 00007327 895406                  	mov	[si+user_env.user_DX],dx
 40709 0000732A EB1F                    	jmp	short ok_ret
 40710                                  
 40711                                  ;------ here we set the time in sft
 40712                                  
 40713                                  ft_set_time:
 40714 0000732C E8D4A5                  	call    ECritSFT
 40715                                  	;mov	[es:di+13],cx
 40716 0000732F 26894D0D                	mov	[es:di+SF_ENTRY.sf_time],cx ; drop in new time
 40717                                  	;mov	[es:di+15],dx
 40718 00007333 2689550F                	mov	[es:di+SF_ENTRY.sf_date],dx ;  and date	
 40719                                  
 40720 00007337 31C0                    	xor	ax, ax
 40721 00007339 36FF1E[C800]            	call	far [ss:JShare+(14*4)] ; 14 = ShSU	; SS Override
 40722                                  
 40723                                  ;------ set the flags in SFT entry
 40724                                  	;and	word [es:di+5],0FFBFh
 40725                                  	; 18/12/2022
 40726                                  	;and	byte [es:di+5],0BFh
 40727 0000733E 26806505BF              	and	byte [es:di+SF_ENTRY.sf_flags],~devid_file_clean
 40728                                  	;and	word [es:di+SF_ENTRY.sf_flags],~devid_file_clean 
 40729                                  							; mark file as dirty
 40730                                  	;or	word [es:di+5],4000h
 40731                                  	; 17/12/2022
 40732                                  	;or	byte [es:di+6],40h
 40733 00007343 26804D0640              	or	byte [es:di+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8)
 40734                                  	;or	word [es:di+SF_ENTRY.sf_flags],sf_close_nodate
 40735                                  							; ask close not to
 40736                                  							;   bother about date
 40737                                  							;   and time
 40738 00007348 E8E5A5                  	call	LCritSFT
 40739                                  ok_ret:
 40740                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40741                                  	; 17/12/2022
 40742 0000734B E92293                  	jmp	SYS_RET_OK
 40743                                  	;jmp	short LSeekOk
 40744                                  
 40745                                  inval_func:
 40746                                  	;mov	byte [ss:EXTERR_LOCUS],1
 40747 0000734E 36C606[2303]01          	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 40748                                  						;SS Overr
 40749                                  	;mov	al,1
 40750 00007354 B001                    	mov	al,error_invalid_function ; give bad return
 40751                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40752                                  ft_error:
 40753                                  	;;jmp	SYS_RET_ERR
 40754                                  	;jmp	short LSeekError3
 40755                                  	; 17/12/2022
 40756 00007356 EBAF                    	jmp	short LSeekError
 40757                                  
 40758                                  ; 21/05/2019 - Retro DOS v4.0
 40759                                  ; DOSCODE:A95Bh (MSDOS 6.21, MSDOS.SYS)
 40760                                  
 40761                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40762                                  ; DOSCODE:A8FBh (MSDOS 5.0 MSDOS.SYS)
 40763                                  
 40764                                  ;BREAK <$DUP - duplicate a jfn>
 40765                                  ;----------------------------------------------------------------------------
 40766                                  ;
 40767                                  ;   Assembler usage:
 40768                                  ;	    MOV     BX, fh
 40769                                  ;	    MOV     AH, Dup
 40770                                  ;	    INT     int_command
 40771                                  ;	  AX has the returned handle
 40772                                  ;   Errors:
 40773                                  ;	    AX = dup_invalid_handle
 40774                                  ;	       = dup_too_many_open_files
 40775                                  ;
 40776                                  ;----------------------------------------------------------------------------
 40777                                  
 40778                                  _$DUP:
 40779 00007358 89D8                    	MOV	AX,BX			; save away old handle in AX
 40780 0000735A E86FFD                  	call	JFNFree 		; free handle? into ES:DI, new in BX
 40781                                  DupErrorCheck:
 40782 0000735D 72A8                    	JC	short DupErr		; nope, bye
 40783 0000735F 06                      	push	es
 40784 00007360 57                      	push	di			; save away SFT
 40785 00007361 5E                      	pop	si			; into convenient place DS:SI
 40786 00007362 1F                      	pop	ds
 40787 00007363 93                      	XCHG	AX,BX			; get back old handle
 40788 00007364 E81D00                  	call	CheckOwner		; get sft in ES:DI
 40789 00007367 729E                    	JC	short DupErr		; errors go home
 40790 00007369 E877BD                  	call	DOS_Dup_Direct
 40791 0000736C E800FD                  	call	pJFNFromHandle		; get pointer
 40792 0000736F 268A1D                  	MOV	BL,[ES:DI]		; get SFT number
 40793 00007372 881C                    	MOV	[SI],BL			; stuff in new SFT
 40794                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40795                                  	;jmp	SYS_RET_OK		; and go home
 40796 00007374 EBD5                    	jmp	short ok_ret
 40797                                  
 40798                                  	; 17/12/2022
 40799                                  ;DupErr:
 40800                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40801                                  	;;jmp	SYS_RET_ERR
 40802                                  	;jmp	short ft_error
 40803                                  
 40804                                  ;BREAK <$DUP2 - force a dup on a particular jfn>
 40805                                  ;----------------------------------------------------------------------------
 40806                                  ;
 40807                                  ;   Assembler usage:
 40808                                  ;	    MOV     BX, fh
 40809                                  ;	    MOV     CX, newfh
 40810                                  ;	    MOV     AH, Dup2
 40811                                  ;	    INT     int_command
 40812                                  ;   Error returns:
 40813                                  ;	    AX = error_invalid_handle
 40814                                  ;
 40815                                  ;----------------------------------------------------------------------------
 40816                                  
 40817                                  _$DUP2:
 40818 00007376 53                      	push	bx
 40819 00007377 51                      	push	cx			; save source
 40820 00007378 89CB                    	MOV	BX,CX			; get one to close
 40821 0000737A E8AAFD                  	call	_$CLOSE			; close destination handle
 40822 0000737D 5B                      	pop	bx
 40823 0000737E 58                      	pop	ax			; old in AX, new in BX
 40824 0000737F E8EDFC                  	call	pJFNFromHandle		; get pointer
 40825 00007382 EBD9                    	JMP	short DupErrorCheck	; check error and do dup
 40826                                  
 40827                                  ;Break	<CheckOwner - verify ownership of handles from server>
 40828                                  ;----------------------------------------------------------------------------
 40829                                  ;   CheckOwner - Due to the ability of the server to close file handles for a
 40830                                  ;   process without the process knowing it (delete/rename of open files, for
 40831                                  ;   example), it is possible for the redirector to issue a call to a handle
 40832                                  ;   that it soes not rightfully own. We check here to make sure that the
 40833                                  ;   issuing process is the owner of the SFT. At the same time, we do a
 40834                                  ;   SFFromHandle to really make sure that the SFT is good.
 40835                                  ;
 40836                                  ;	ENTRY	BX has the handle
 40837                                  ;		User_ID is the current user
 40838                                  ;	EXIT	Carry Clear => ES:DI points to SFT
 40839                                  ;		Carry Set => AX has error code
 40840                                  ;	USES	none
 40841                                  ;----------------------------------------------------------------------------
 40842                                  
 40843                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40844                                  	; 21/05/2019 - Retro DOS v4.0
 40845                                  CheckOwner:
 40846                                  	; 13/07/2018 - Retro DOS v3.0
 40847                                  
 40848 00007384 E805FD                  	call	SFFromHandle
 40849 00007387 721B                    	jc	short co_ret_label	; retc
 40850                                  
 40851 00007389 50                      	push	ax
 40852                                  
 40853                                  	; MSDOS 6.0
 40854                                  
 40855                                  ;SR; WIN386 patch - Do not check for USER_ID for using handles since these 
 40856                                  ;SR; are shared across multiple VMs in win386.
 40857                                  
 40858 0000738A 36F606[A110]01          	test	byte [ss:IsWin386],1 ; 02/06/2019
 40859 00007390 7404                    	jz	short no_win386		;win386 is not present
 40860 00007392 31C0                    	xor	ax,ax			;set the zero flag
 40861 00007394 EB08                    	jmp	short _skip_win386	
 40862                                  
 40863                                  no_win386:
 40864 00007396 36A1[3E03]              	mov	ax,[SS:USER_ID]		;smr;SS Override
 40865                                  	;cmp	ax,[es:di+47]
 40866 0000739A 263B452F                	cmp	ax,[es:di+SF_ENTRY.sf_UID]
 40867                                  
 40868                                  _skip_win386:
 40869 0000739E 58                      	pop	ax
 40870                                  	
 40871                                  	; 17/12/2022
 40872 0000739F 7403                    	jz	short co_ret_label
 40873                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 40874                                  	;jnz	short CheckOwner_err
 40875                                  	;retn
 40876                                  	
 40877                                  CheckOwner_err:
 40878                                  	;mov	al,6
 40879 000073A1 B006                    	mov	al,error_invalid_handle
 40880 000073A3 F9                      	stc
 40881                                  
 40882                                  co_ret_label:
 40883 000073A4 C3                      	retn
 40884                                  
 40885                                  ;============================================================================
 40886                                  ; MACRO.ASM, MSDOS 6.0, 1991
 40887                                  ;============================================================================
 40888                                  ; Retro	DOS v3.0 - 11/07/2018
 40889                                  ; 21/05/2019 - Retro DOS v4.0
 40890                                  
 40891                                  ;	TITLE	MACRO - Pathname and macro related internal routines
 40892                                  ;	NAME	MACRO
 40893                                  
 40894                                  ;	Microsoft Confidential
 40895                                  ;	Copyright (C) Microsoft Corporation 1991
 40896                                  ;	All Rights Reserved.
 40897                                  
 40898                                  ;**	MACRO.ASM
 40899                                  ;
 40900                                  ;	$AssignOper
 40901                                  ;	FIND_DPB
 40902                                  ;	InitCDS
 40903                                  ;	$UserOper
 40904                                  ;	GetVisDrv
 40905                                  ;	GetThisDrv
 40906                                  ;	GetCDSFromDrv
 40907                                  ;
 40908                                  ;   Revision history:
 40909                                  ;
 40910                                  ;	Created: MZ 4 April 1983
 40911                                  ;		 MZ 18 April 1983   Make TransFCB handle extended FCBs
 40912                                  ;		 AR 2 June 1983     Define/Delete macro for NET redir.
 40913                                  ;		 MZ 3 Nov 83	    Fix InitCDS to reset length to 2
 40914                                  ;		 MZ 4 Nov 83	    Fix NetAssign to use STRLEN only
 40915                                  ;		 MZ 18 Nov 83	    Rewrite string processing for subtree
 40916                                  ;				    aliasing.
 40917                                  ;
 40918                                  ;   MSDOS performs several types of name translation. First, we maintain for
 40919                                  ;   each valid drive letter the text of the current directory on that drive.
 40920                                  ;   For invalid drive letters, there is no current directory so we pretend to
 40921                                  ;   be at the root. A current directory is either the raw local directory
 40922                                  ;   (consisting of drive:\path) or a local network directory (consisting of
 40923                                  ;   \\machine\path. There is a limit on the point to which a .. is allowed.
 40924                                  ;
 40925                                  ;   Given a path, MSDOS will transform this into a real from-the-root path
 40926                                  ;   without . or .. entries. Any component that is > 8.3 is truncated to
 40927                                  ;   this and all * are expanded into ?'s.
 40928                                  ;
 40929                                  ;   The second part of name translation involves subtree aliasing. A list of
 40930                                  ;   subtree pairs is maintained by the external utility SUBST. The results of
 40931                                  ;   the previous 'canonicalization' are then examined to see if any of the
 40932                                  ;   subtree pairs is a prefix of the user path. If so, then this prefix is
 40933                                  ;   replaced with the other subtree in the pair.
 40934                                  ;
 40935                                  ;   A third part involves mapping this "real" path into a "physical" path.  A
 40936                                  ;   list of drive/subtree pairs are maintained by the external utility JOIN.
 40937                                  ;   The output of the previous translation is examined to see if any of the
 40938                                  ;   subtrees in this list are a prefix of the string. If so, then the prefix
 40939                                  ;   is replaced by the appropriate drive letter. In this manner, we can
 40940                                  ;   'mount' one device under another.
 40941                                  ;
 40942                                  ;   The final form of name translation involves the mapping of a user's
 40943                                  ;   logical drive number into the internal physical drive. This is
 40944                                  ;   accomplished by converting the drive number into letter:CON, performing
 40945                                  ;   the above translation and then converting the character back into a drive
 40946                                  ;   number.
 40947                                  ;
 40948                                  ;   There are two main entry points: TransPath and TransFCB. TransPath will
 40949                                  ;   take a path and form the real text of the pathname with all . and ..
 40950                                  ;   removed. TransFCB will translate an FCB into a path and then invoke
 40951                                  ;   TransPath.
 40952                                  ;
 40953                                  ;	A000	version 4.00  Jan. 1988
 40954                                  
 40955                                  ;Installed = TRUE
 40956                                  
 40957                                  ;	I_need	ThisCDS,DWORD		; pointer to CDS used
 40958                                  ;	I_need	CDSAddr,DWORD		; pointer to CDS table
 40959                                  ;	I_need	CDSCount,BYTE		; number of CDS entries
 40960                                  ;	I_need	CurDrv,BYTE		; current macro assignment (old
 40961                                  ;					; current drive)
 40962                                  ;	I_need	NUMIO,BYTE		; Number of physical drives
 40963                                  ;	I_need	fSharing,BYTE		; TRUE => no redirection allowed
 40964                                  ;	I_need	DummyCDS,80h		; buffer for dummy cds
 40965                                  ;	I_need	DIFFNAM,BYTE		; flag for MyName being set
 40966                                  ;	I_need	MYNAME,16		; machine name
 40967                                  ;	I_need	MYNUM,WORD		; machine number
 40968                                  ;	I_need	DPBHEAD,DWORD		; beginning of DPB chain
 40969                                  ;	I_need	EXTERR_LOCUS,BYTE	; Extended Error Locus
 40970                                  ;	I_need	DrvErr,BYTE		; drive error
 40971                                  
 40972                                  ;BREAK <$AssignOper -- Set up a Macro>
 40973                                  ;----------------------------------------------------------------------------
 40974                                  ; Inputs:
 40975                                  ;	AL = 00 get assign mode 		    (ReturnMode)
 40976                                  ;	AL = 01 set assign mode 		    (SetMode)
 40977                                  ;	AL = 02 get attach list entry		    (GetAsgList)
 40978                                  ;	AL = 03 Define Macro (attch start)
 40979                                  ;	    BL = Macro type
 40980                                  ;	       = 0 alias
 40981                                  ;	       = 1 file/device
 40982                                  ;	       = 2 drive
 40983                                  ;	       = 3 Char device -> network
 40984                                  ;	       = 4 File device -> network
 40985                                  ;	    DS:SI -> ASCIZ source name
 40986                                  ;	    ES:DI -> ASCIZ destination name
 40987                                  ;	AL = 04 Cancel Macro
 40988                                  ;	    DS:SI -> ASCIZ source name
 40989                                  ;	AL = 05 Modified get attach list entry
 40990                                  ;	AL = 06 Get ifsfunc item
 40991                                  ;	AL = 07 set in_use of a drive's CDS
 40992                                  ;	     DL = drive number, 0=default  0=A,,
 40993                                  ;	AL = 08 reset in_use of a drive's CDS
 40994                                  ;	     DL = drive number, 0=A, 1=B,,,
 40995                                  ; Function:
 40996                                  ;	Do macro stuff
 40997                                  ; Returns:
 40998                                  ;	Std Xenix style error return
 40999                                  ;----------------------------------------------------------------------------
 41000                                  
 41001                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41002                                  	; 21/05/2019 - Retro DOS v4.0
 41003                                  _$AssignOper:
 41004                                  	; MSDOS 6.0
 41005 000073A5 3C07                    	CMP	AL,7			      ; set in_use ?		;AN000;
 41006 000073A7 7525                    	JNZ	short chk08		      ; no			;AN000;
 41007                                  srinuse:								;AN000;
 41008 000073A9 50                      	PUSH	AX			      ; save al 		;AN000;
 41009 000073AA 88D0                    	MOV	AL,DL			      ; AL= drive id		;AN000;
 41010 000073AC E85601                  	CALL	GetCDSFromDrv		      ; ds:si -> cds		;AN000;
 41011 000073AF 58                      	POP	AX			      ; 			;AN000;
 41012 000073B0 7216                    	JC	short baddrv		      ; bad drive		;AN000;
 41013                                  	;cmp	word [si+45h],0
 41014 000073B2 837C4500                	CMP	WORD [SI+curdir.devptr],0     ; dpb ptr =0 ?		;AN000;
 41015 000073B6 7410                    	JZ	short baddrv		      ;     no			;AN000;
 41016 000073B8 3C07                    	CMP	AL,7			      ; set ?			;AN000;
 41017 000073BA 7506                    	JNZ	short resetdrv		      ; no			;AN000;
 41018                                  	;or	word [si+43h],4000h
 41019                                  	; 17/12/2022
 41020                                  	;or	byte [si+44h],40h
 41021 000073BC 804C4440                	or	byte [SI+curdir.flags+1],(curdir_inuse>>8)
 41022                                  	;OR	word [SI+curdir.flags],curdir_inuse ; set in_use	;AN000;
 41023 000073C0 EB19                    	JMP	SHORT okdone		      ; 			;AN000;
 41024                                  resetdrv:
 41025                                  	;and	word [si+43h],0BFFFh					;AN000;
 41026                                  	; 18/12/2022
 41027 000073C2 806444BF                	and	byte [SI+curdir.flags+1],0BFh ; (~curdir_inuse)>>8
 41028                                  	;AND	word [SI+curdir.flags],~curdir_inuse ; reset in_use	;AN000;
 41029 000073C6 EB13                    	JMP	SHORT okdone		      ; 			;AN000;
 41030                                  
 41031                                  	; 17/12/2022
 41032                                  baddrv: 								;AN000;
 41033 000073C8 B80F00                  	MOV	AX,error_invalid_drive	      ; error			;AN000;
 41034                                  
 41035                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41036                                  	;JMP	SHORT ASS_ERR		      ; 			;AN000;
 41037                                  	; 17/12/2022
 41038                                  	; 21/05/2019
 41039                                  ASS_ERR:
 41040 000073CB E9AC92                  	jmp	SYS_RET_ERR
 41041                                  
 41042                                  chk08:									;AN000;
 41043 000073CE 3C08                    	CMP	AL,8			      ; reset inuse ?		;AN000;
 41044 000073D0 74D7                    	JZ	short srinuse 		      ; yes			;AN000;
 41045                                  
 41046                                    ;IF	NOT INSTALLED
 41047                                  	;transfer NET_ASSOPER
 41048                                    ;ELSE
 41049                                  	; MSDOS 3.3 (& MSDOS 6.0)
 41050 000073D2 50                      	PUSH	AX
 41051                                  	;mov	ax,111Eh
 41052                                  	;MOV	AX,(MultNET SHL 8) OR 30
 41053 000073D3 B81E11                  	mov	ax,(MultNET*256)+30
 41054 000073D6 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
 41055                                  			; SS = DOS CS
 41056                                  			; STACK: WORD function to execute
 41057                                  			; Return: CF set on error, AX = error code
 41058                                  			; STACK unchanged
 41059 000073D8 5B                      	POP	BX			; Don't zap error code in AX
 41060 000073D9 72F0                    	JC	short ASS_ERR
 41061                                  okdone:
 41062 000073DB E99292                  	jmp	SYS_RET_OK
 41063                                  
 41064                                  	; 17/12/2022
 41065                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41066                                  ;ASS_ERR:
 41067                                  	;jmp	SYS_RET_ERR
 41068                                  
 41069                                    ;ENDIF
 41070                                  
 41071                                  ;Break <FIND_DPB - Find a DPB from a drive number>
 41072                                  ;----------------------------------------------------------------------------
 41073                                  ;**	FIND_DPB - Find a DPB from a Drive #
 41074                                  ;
 41075                                  ;	ENTRY	AL has drive number A = 0
 41076                                  ;	EXIT	'C' set
 41077                                  ;		    No DPB for this drive number
 41078                                  ;		'C' clear
 41079                                  ;		    DS:SI points to DPB for drive
 41080                                  ;	USES	SI, DS, Flags
 41081                                  ;----------------------------------------------------------------------------
 41082                                  
 41083                                  	; 21/05/2019 - Retro DOS v4.0
 41084                                  FIND_DPB:
 41085 000073DE 36C536[2600]            	LDS	SI,[SS:DPBHEAD]		;smr;SS Override
 41086                                  fdpb5:	
 41087 000073E3 83FEFF                  	CMP	SI,-1
 41088 000073E6 7409                    	JZ	short fdpb10
 41089 000073E8 3A04                    	cmp	al,[si]
 41090                                  	;CMP	AL,[SI+DPB.DRIVE]
 41091 000073EA 7406                    	jz	short ret_label15	; Carry clear (retz)
 41092                                  	;;lds	si,[si+18h] ; MSDOS 3.3
 41093                                  	;lds	si,[si+19h] ; MSDOS 6.0
 41094 000073EC C57419                  	LDS	SI,[SI+DPB.NEXT_DPB]
 41095 000073EF EBF2                    	JMP	short fdpb5
 41096                                  fdpb10:	
 41097 000073F1 F9                      	STC
 41098                                  ret_label15:
 41099 000073F2 C3                      	retn
 41100                                  
 41101                                  ;	Break <InitCDS - set up an empty CDS>
 41102                                  ;----------------------------------------------------------------------------
 41103                                  ;**	InitCDS - Setup an Empty CDS
 41104                                  ;
 41105                                  ;	ENTRY	ThisCDS points to CDS
 41106                                  ;		AL has uppercase drive letter
 41107                                  ;	EXIT	ThisCDS is now empty
 41108                                  ;		(ES:DI) = CDS
 41109                                  ;		'C' set if no DPB associated with drive
 41110                                  ;	USES	AH,ES,DI, Flags
 41111                                  ;----------------------------------------------------------------------------
 41112                                  
 41113                                  ; 21/05/2019 - Retro DOS v4.0
 41114                                  ; DOSCODE:A9FDh (MSDOS 6.21, MSDOS.SYS)
 41115                                  
 41116                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41117                                  ; DOSCODE:A99Dh (MSDOS 5.0, MSDOS.SYS)
 41118                                  
 41119                                  InitCDS:
 41120                                  	; 19/08/2018
 41121                                  	; 05/08/2018 - Retro DOS v3.0
 41122                                  	; MSDOS 6.0
 41123 000073F3 50                      	push	ax			; save (AL) for caller
 41124 000073F4 36C43E[A205]            	LES	DI,[SS:THISCDS]		; (es:di) = CDS address
 41125                                  	;mov	word [es:di+67],0
 41126 000073F9 26C745430000            	MOV	word [ES:DI+curdir.flags],0 ; "free" CDS
 41127 000073FF 2C40                    	SUB	AL,"A"-1                ; A = 1
 41128 00007401 363806[4600]            	CMP	[SS:NUMIO],AL		;smr;SS Override
 41129 00007406 7236                    	JC	short icdsx		; Drive does not map a physical drive
 41130 00007408 48                      	dec	ax			; (AL) = 0 if A, 1 if B, etc.
 41131 00007409 50                      	PUSH	AX			; save drive number for later
 41132 0000740A 0441                    	add	al,"A"
 41133 0000740C B43A                    	MOV	AH,':'
 41134 0000740E 268905                  	mov	[ES:DI],ax
 41135                                  	;MOV	[ES:DI+curdir.text],AX 	; set "x:"
 41136                                  	;mov	ax,"\"
 41137                                  	;mov	[es:di+2],ax
 41138                                  	;MOV	word [ES:DI+curdir.text+2],"\"	; NUL terminate
 41139 00007411 26C745025C00            	mov	word [ES:DI+curdir.text+2],005Ch ; 19/08/2018
 41140                                  	;or	word [es:di+67],4000h
 41141                                  	;or	byte [es:di+68],40h
 41142 00007417 26804D4440              	OR	byte [ES:DI+curdir.flags+1],(curdir_inuse>>8)
 41143 0000741C 29C0                    	sub	ax,ax
 41144                                  	;MOV	[es:di+73],ax ; 0
 41145 0000741E 26894549                	MOV	[ES:DI+curdir.ID],ax
 41146                                  	;mov	[es:di+75],ax ; 0
 41147 00007422 2689454B                	MOV	[ES:DI+curdir.ID+2],ax
 41148 00007426 B002                    	mov	al,2
 41149                                  	;mov	[es:di+79],aX ; 2
 41150 00007428 2689454F                	MOV	[ES:DI+curdir.end],ax
 41151 0000742C 58                      	POP	AX			; (al) = drive number
 41152 0000742D 1E                      	push	ds
 41153 0000742E 56                      	push	si
 41154 0000742F E8ACFF                  	call	FIND_DPB
 41155 00007432 7208                    	JC	short icds5		; OOOOPPPPPSSSS!!!!
 41156                                  	;mov	[es:di+69],si
 41157 00007434 26897545                	MOV	[ES:DI+curdir.devptr],SI
 41158                                  	;mov	[es:di+71],ds
 41159 00007438 268C5D47                	MOV	[ES:DI+curdir.devptr+2],DS
 41160                                  icds5:	
 41161 0000743C 5E                      	pop	si
 41162 0000743D 1F                      	pop	ds
 41163                                  icdsx:	
 41164 0000743E 58                      	pop	ax
 41165                                  RET45:
 41166 0000743F C3                      	retn
 41167                                  
 41168                                  ;Break <$UserOper - get/set current user ID (for net)>
 41169                                  ;----------------------------------------------------------------------------
 41170                                  ;   $UserOper - retrieve or initiate a user id string.	MSDOS will only
 41171                                  ;	maintain this string and do no verifications.
 41172                                  ;
 41173                                  ;   Inputs:	AL has function type (0-get 1-set 2-printer-set 3-printer-get
 41174                                  ;				      4-printer-set-flags,5-printer-get-flags)
 41175                                  ;		DS:DX is user string pointer (calls 1,2)
 41176                                  ;		ES:DI is user buffer (call 3)
 41177                                  ;		BX is assign index (calls 2,3,4,5)
 41178                                  ;		CX is user number (call 1)
 41179                                  ;		DX is flag word (call 4)
 41180                                  ;   Outputs:	If AL = 0 then the current user string is written to DS:DX
 41181                                  ;			and user CX is set to the user number
 41182                                  ;		If AL = 3 then CX bytes have been put at input ES:DI
 41183                                  ;		If AL = 5 then DX is flag word
 41184                                  ;----------------------------------------------------------------------------
 41185                                  
 41186                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41187                                  	; 21/05/2019 - Retro DOS v4.0
 41188                                  _$UserOper:
 41189                                  	; 05/08/2018 - Retro DOS v3.0
 41190                                  	; MSDOS 6.0 (& MSDOS 3.3)
 41191 00007440 50                      	PUSH	AX
 41192 00007441 2C01                    	SUB	AL,1			; quick dispatch on 0,1
 41193 00007443 58                      	POP	AX
 41194 00007444 7211                    	JB	short UserGet 		; return to user the string
 41195 00007446 742E                    	JZ	short UserSet 		; set the current user
 41196 00007448 3C05                    	CMP	AL,5			; test for 2,3,4 or 5
 41197 0000744A 763D                    	JBE	short UserPrint		; yep
 41198                                  	;mov	byte [ss:EXTERR_LOCUS],1
 41199 0000744C 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ;smr;SS Override 
 41200                                  					; Extended Error Locus
 41201                                  	;error	error_invalid_function	; not 0,1,2,3
 41202                                  	;mov	al,1
 41203 00007452 B001                    	MOV	AL,error_invalid_function
 41204                                  useroper_error:
 41205                                  	; 17/12/2022
 41206                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41207 00007454 E92392                  	JMP	SYS_RET_ERR
 41208                                  	;jmp	short ASS_ERR
 41209                                  
 41210                                  UserGet:
 41211                                  ; Transfer MYNAME to DS:DX
 41212                                  ; Set Return CX to MYNUM
 41213 00007457 1E                      	PUSH	DS			; switch registers
 41214 00007458 07                      	POP	ES
 41215 00007459 89D7                    	MOV	DI,DX			; destination
 41216 0000745B 368B0E[0E00]            	MOV	CX,[SS:MYNUM]		; Get number	;smr;SS Override
 41217 00007460 E81490                  	call	Get_User_Stack
 41218                                  	;mov	[si+4],cx
 41219 00007463 894C04                  	MOV	[SI+user_env.user_CX],CX ; Set number return
 41220 00007466 16                      	push	ss			; point to DOSDATA
 41221 00007467 1F                      	pop	ds
 41222 00007468 BE[0503]                	MOV	SI,MYNAME		; point source to user string
 41223                                  UserMove:
 41224 0000746B B90F00                  	MOV	CX,15
 41225 0000746E F3A4                    	REP	MOVSB			; blam.
 41226 00007470 31C0                    	XOR	AX,AX			; 16th byte is 0
 41227 00007472 AA                      	STOSB
 41228                                  UserBye:
 41229 00007473 E9FA91                  	jmp	SYS_RET_OK		; no errors here
 41230                                  
 41231                                  UserSet:
 41232                                  ; Transfer DS:DX to MYNAME
 41233                                  ; CX to MYNUM
 41234 00007476 36890E[0E00]            	MOV	[SS:MYNUM],CX				;smr;SS Override
 41235 0000747B 89D6                    	MOV	SI,DX			; user space has source
 41236 0000747D 16                      	push	ss
 41237 0000747E 07                      	pop	es
 41238 0000747F BF[0503]                	MOV	DI,MYNAME		; point dest to user string
 41239 00007482 36FE06[0403]            	INC	byte [SS:DIFFNAM]	; signal change ;smr;SS Override
 41240 00007487 EBE2                    	JMP	short UserMove
 41241                                  
 41242                                  UserPrint:
 41243                                  
 41244                                    ;IF NOT Installed
 41245                                    ;	transfer PRINTER_GETSET_STRING
 41246                                    ;ELSE
 41247 00007489 50                      	PUSH	AX
 41248                                  	;mov	ax,111Fh
 41249                                  	;MOV	AX,(MultNET SHL 8) OR 31
 41250 0000748A B81F11                  	mov	ax,(MultNET<<8)|31
 41251 0000748D CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
 41252                                  			; STACK: WORD function
 41253                                  			; Return: CF set on error, AX = error code
 41254                                  			; STACK unchanged
 41255 0000748F 5A                      	POP	DX			; Clean stack
 41256                                  	;JNC	short OKPA
 41257 00007490 73E1                    	jnc	short UserBye ; 21/05/2019
 41258                                  	; 17/12/2022
 41259 00007492 EBC0                    	jmp	short useroper_error
 41260                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41261                                  	;jnb     short OKPA
 41262                                  	;jmp     short useroper_error
 41263                                  
 41264                                  	; 17/12/2022
 41265                                  ;OKPA:
 41266                                  ;	jmp	short UserBye
 41267                                  
 41268                                    ;ENDIF
 41269                                  
 41270                                  
 41271                                  ;Break	<GetVisDrv - return visible drive>
 41272                                  ;----------------------------------------------------------------------------
 41273                                  ;   GetVisDrv - correctly map non-spliced inuse drives
 41274                                  ;
 41275                                  ;   Inputs:	AL has drive identifier (0=default)
 41276                                  ;   Outputs:	Carry Set - invalid drive/macro
 41277                                  ;		Carry Clear - AL has physical drive (0=A)
 41278                                  ;		    ThisCDS points to CDS
 41279                                  ;   Registers modified: AL
 41280                                  ;----------------------------------------------------------------------------
 41281                                  
 41282                                  	; 21/05/2019 - Retro DOS v4.0
 41283                                  	; DOSCODE:AA9Fh (MSDOS 6.21, MSDOS.SYS)
 41284                                  
 41285                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41286                                  	; DOSCODE:AA3Fh (MSDOS 5.0, MSDOS.SYS)	
 41287                                  GetVisDrv:
 41288                                  	; 05/08/2018 - Retro DOS v3.0
 41289                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6839h
 41290 00007494 E81900                  	CALL	GETTHISDRV		; get inuse drive
 41291 00007497 72A6                    	jc	short RET45
 41292 00007499 1E                      	push	ds
 41293 0000749A 56                      	push	si
 41294 0000749B 36C536[A205]            	LDS	SI,[SS:THISCDS]		;smr;SS Override
 41295                                  	;test	word [si+67],2000h
 41296                                  	; 17/12/2022
 41297                                  	;test	byte [si+68],20h
 41298 000074A0 F6444420                	test	byte [SI+curdir.flags+1],(curdir_splice>>8)
 41299                                  	;TEST	word [SI+curdir.flags],curdir_splice
 41300 000074A4 5E                      	pop	si
 41301 000074A5 1F                      	pop	ds
 41302 000074A6 7497                    	jz	short RET45		; if not spliced, return OK
 41303                                  	; MSDOS 6.0
 41304                                  	;mov	byte [ss:DrvErr],0Fh
 41305 000074A8 36C606[1006]0F          	MOV	byte [SS:DrvErr],error_invalid_drive ;IFS. ;AN000;smr;SS Override
 41306 000074AE F9                      	STC				; signal error
 41307 000074AF C3                      	retn
 41308                                  
 41309                                  ;Break <Getthisdrv - map a drive designator (0=def, 1=A...)>
 41310                                  ;----------------------------------------------------------------------------
 41311                                  ;   GetThisDrv - look through a set of macros and return the current drive and
 41312                                  ;	macro pointer
 41313                                  ;
 41314                                  ;   Inputs:	AL has drive identifier (1=A, 0=default)
 41315                                  ;   Outputs:
 41316                                  ;		Carry Set - invalid drive/macro
 41317                                  ;		Carry Clear - AL has physical drive (0=A)
 41318                                  ;		   ThisCDS points to macro
 41319                                  ;   Registers modified: AL
 41320                                  ;----------------------------------------------------------------------------
 41321                                  
 41322                                  	; 21/05/2019 - Retro DOS v4.0
 41323                                  	; DOSCODE:AABCh (MSDOS 6.21, MSDOS.SYS)
 41324                                  
 41325                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41326                                  	; DOSCODE:AA5Ch (MSDOS 5.0, MSDOS.SYS)	
 41327                                  GETTHISDRV:
 41328                                  	; 05/08/2018
 41329                                  	; 12/07/2018 - Retro DOS v3.0
 41330                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6850h
 41331                                  	; MSDOS 3.3 (& MSDOS 6.0)
 41332 000074B0 08C0                    	OR	AL,AL			; are we using default drive?
 41333 000074B2 7505                    	JNZ	SHORT GTD10		; no, go get the CDS pointers
 41334 000074B4 36A0[3603]              	MOV	AL,[SS:CURDRV]		; get the current drive
 41335                                  	;INC	ax			; Counteract next instruction
 41336                                  	; 04/09/2018
 41337                                  	;inc	al
 41338                                  	; 07/12/2022
 41339 000074B8 40                      	inc	ax
 41340                                  GTD10:	
 41341                                  	;DEC	AX
 41342                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41343 000074B9 48                      	dec	ax			; 0 = A
 41344                                  	;dec	al
 41345 000074BA 1E                      	PUSH	DS			; save world
 41346 000074BB 56                      	PUSH	SI
 41347                                  	;mov	byte [ss:EXTERR_LOCUS],2
 41348 000074BC 36C606[2303]02          	MOV	BYTE [SS:EXTERR_LOCUS],errLOC_Disk		;smr;SS Override
 41349 000074C2 36F606[7205]FF          	TEST	BYTE [SS:FSHARING],-1	; Logical or Physical?	;smr;SS Override
 41350 000074C8 7420                    	JZ	SHORT GTD20		; Logical
 41351 000074CA 50                      	PUSH	AX
 41352 000074CB 06                      	PUSH	ES
 41353 000074CC 57                      	PUSH	DI
 41354 000074CD 36C706[A205][F304]      	MOV	WORD [SS:THISCDS],DUMMYCDS ;smr;SS Override
 41355                                  	;mov	[SS:THISCDS+2],CS ; MSDOS 3.3
 41356 000074D4 368C16[A405]            	MOV	[SS:THISCDS+2],SS ; MSDOS 6.0 ;ThisCDS = &DummyCDS;smr;
 41357 000074D9 0441                    	ADD	AL,'A'
 41358 000074DB E815FF                  	CALL	InitCDS			; InitCDS(c);
 41359                                  	;test	word [es:di+67],4000h
 41360                                  	; 17/12/2022
 41361                                  	;test	byte [es:di+68],40h
 41362 000074DE 26F6454440              	test	byte [ES:DI+curdir.flags+1],(curdir_inuse>>8)
 41363                                  	;TEST	WORD [ES:DI+curdir.flags],curdir_inuse	; Clears carry
 41364 000074E3 5F                      	POP	DI
 41365 000074E4 07                      	POP	ES
 41366 000074E5 58                      	POP	AX
 41367 000074E6 740D                    	JZ	SHORT GTD30		; Not a physical drive.
 41368 000074E8 EB18                    	JMP	SHORT GTDX		; carry clear
 41369                                  GTD20:
 41370 000074EA E81800                  	CALL	GetCDSFromDrv
 41371 000074ED 7206                    	JC	SHORT GTD30	; Unassigned CDS -> return error already set
 41372                                  	;test	word [si+43h],4000h
 41373                                  	; 17/12/2022
 41374                                  	;test	byte [si+44h],40h
 41375 000074EF F6444440                	test	byte [SI+curdir.flags+1],(curdir_inuse>>8)
 41376                                  	;TEST	WORD [SI+curdir.flags],curdir_inuse ; Clears Carry
 41377 000074F3 750D                    	JNZ	SHORT GTDX		; carry clear
 41378                                  GTD30:	
 41379                                  	; 21/05/2019
 41380                                  	; MSDOS 6.0
 41381 000074F5 B00F                    	MOV	AL,error_invalid_drive	; invalid FAT drive
 41382 000074F7 36A2[1006]              	MOV	BYTE [ss:DrvErr],AL	; save this for IOCTL
 41383                                  	; MSDOS 3.3 (.& MSDOS 6.0)
 41384 000074FB 36C606[2303]01          	MOV	BYTE [ss:EXTERR_LOCUS],errLOC_Unk
 41385 00007501 F9                      	STC
 41386                                  GTDX:	
 41387 00007502 5E                      	POP	SI			; restore world
 41388 00007503 1F                      	POP	DS
 41389 00007504 C3                      	RETN
 41390                                   
 41391                                  
 41392                                  ;Break <GetCDSFromDrv - convert a drive number to a CDS pointer>
 41393                                  ;----------------------------------------------------------------------------
 41394                                  ;   GetCDSFromDrv - given a physical drive number, convert it to a CDS
 41395                                  ;	pointer, returning an error if the drive number is greater than the
 41396                                  ;	number of CDS's
 41397                                  ;
 41398                                  ;   Inputs:	AL is physical unit # A=0...
 41399                                  ;   Outputs:	Carry Set if Bad Drive
 41400                                  ;		Carry Clear
 41401                                  ;		    DS:SI -> CDS
 41402                                  ;		    [THISCDS] = DS:SI
 41403                                  ;   Registers modified: DS,SI
 41404                                  ;----------------------------------------------------------------------------
 41405                                  
 41406                                  	; 21/05/2019 - Retro DOS v4.0
 41407                                  GetCDSFromDrv:
 41408 00007505 363A06[4700]            	CMP	AL,[SS:CDSCOUNT]	; is this a valid designator;smr;SS Override
 41409                                  	;JB	SHORT GetCDS	; cf=1	; yes, go get the macro
 41410                                  	;STC				; signal error
 41411                                  	;RETN				; bye
 41412                                  	; 23/09/2023
 41413 0000750A F5                      	cmc	; cf=1 <-> cf=0
 41414 0000750B 7217                    	jc	short GetCDS_retn
 41415                                  GetCDS:
 41416                                  	; 23/09/2023
 41417                                  	;PUSH	BX
 41418 0000750D 50                      	PUSH	AX
 41419 0000750E 36C536[3C00]            	LDS	SI,[SS:CDSADDR]		; get pointer to table	;smr;SS Override
 41420                                  	;mov	bl,81 ; MSDOS 3.3
 41421                                  	;mov	bl,88 ; MSDOS 6.0 
 41422                                  	; 23/09/2023
 41423                                  	;MOV	BL,curdir.size		; size in convenient spot
 41424                                  	;MUL	BL			; get net offset
 41425 00007513 B458                    	mov	ah,curdir.size
 41426 00007515 F6E4                    	mul	ah
 41427 00007517 01C6                    	ADD	SI,AX ; *		; convert to true pointer
 41428 00007519 368936[A205]            	MOV	[SS:THISCDS],SI		; store convenient offset;smr;SS Override
 41429 0000751E 368C1E[A405]            	MOV	[SS:THISCDS+2],DS	; store convenient segment;smr;SS Override
 41430 00007523 58                      	POP	AX
 41431                                  	; 23/09/2023
 41432                                  	;POP	BX
 41433                                  	; (cf must be 0 here) ; *
 41434                                  	;CLC				; no error
 41435                                  GetCDS_retn:
 41436 00007524 C3                      	RETN				; bye!
 41437                                  
 41438                                  ;============================================================================
 41439                                  ; MACRO2.ASM, MSDOS 6.0, 1991
 41440                                  ;============================================================================
 41441                                  ; Retro	DOS v3.0 - 12/07/2018
 41442                                  ; 22/05/2019 - Retro DOS v4.0
 41443                                  
 41444                                  ;BREAK <TransFCB - convert an FCB into a path, doing substitution>
 41445                                  ;----------------------------------------------------------------------------
 41446                                  ;   TransFCB - Copy an FCB from DS:DX into a reserved area doing all of the
 41447                                  ;       gritty substitution.
 41448                                  ;
 41449                                  ;   Inputs:     DS:DX - pointer to FCB
 41450                                  ;               ES:DI - point to destination
 41451                                  ;   Outputs:    Carry Set - invalid path in final map
 41452                                  ;               Carry Clear - FCB has been mapped into ES:DI
 41453                                  ;                   Sattrib is set from possibly extended FCB
 41454                                  ;                   ExtFCB set if extended FCB found
 41455                                  ;   Registers modified: most
 41456                                  ;----------------------------------------------------------------------------
 41457                                  
 41458                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41459                                  TransFCB:
 41460                                  	; 22/05/2019 - Retro DOS v4.0
 41461                                  	; 12/07/2018 - Retro DOS v3.0
 41462                                  	;LocalVar FCBTmp,16
 41463                                  	;ENTER
 41464 00007525 55                      	push	bp
 41465 00007526 89E5                    	mov	bp,sp
 41466                                  	;sub	sp,15	; MSDOS 3.3
 41467 00007528 83EC10                  	sub	sp,16	; MSDOS 6.0
 41468 0000752B 16                      	push	ss
 41469 0000752C 07                      	pop	es
 41470 0000752D 06                      	push	es
 41471 0000752E 57                      	push	di
 41472                                  	;lea	di,[bp-15] ; MSDOS 3.3
 41473                                  	;LEA	DI,FCBTmp 
 41474 0000752F 8D7EF0                  	lea	di,[bp-16]		; point to FCB temp area
 41475 00007532 36C606[6C05]00          	mov	byte [SS:EXTFCB],0	; no extended FCB found ;smr;SS Override
 41476 00007538 36C606[6D05]00          	mov	byte [SS:SATTRIB],0	; default search attributes;smr;SS Override
 41477 0000753E E834AD                  	call	GetExtended             ; get FCB, extended or not
 41478                                  	; 06/12/2022
 41479 00007541 740D                    	jz	short GetDrive		; not an extended FCB, get drive
 41480 00007543 8A44FF                  	mov	AL,[SI-1]               ; get attributes
 41481 00007546 36A2[6D05]              	mov	[SS:SATTRIB],AL		; store search attributes;smr;SS Override
 41482 0000754A 36C606[6C05]FF          	mov	byte [SS:EXTFCB],-1	; signal extended FCB  ;smr;SS Override
 41483                                  GetDrive:
 41484 00007550 AC                      	lodsb				; get drive byte
 41485 00007551 E85CFF                  	call	GETTHISDRV
 41486 00007554 722A                    	jc	short BadPack
 41487 00007556 E87303                  	call	TextFromDrive           ; convert 0-based drive to text
 41488                                  
 41489                                  ; Scan the source to see if there are any illegal chars
 41490                                  
 41491                                  	;mov	bx,CharType		; load lookup table
 41492 00007559 B90B00                  	mov	cx,11
 41493 0000755C 56                      	push	si			; back over name, ext
 41494                                  FCBScan:
 41495 0000755D AC                      	lodsb				; get a byte
 41496                                  	
 41497                                  	; 09/08/2018
 41498                                  	;;xlat	byte [es:bx]
 41499                                  	;es	xlat
 41500                                  
 41501                                  	; 22/05/2019 - Retro DOS v4.0	
 41502 0000755E E8FCE4                  	call	GetCharType		; get flags
 41503                                  
 41504                                  	;test	al,8	
 41505 00007561 A808                    	test	al,FFCB
 41506 00007563 741B                    	jz	short BadPack
 41507                                  NextCh: 
 41508 00007565 E2F6                    	loop	FCBScan
 41509 00007567 5E                      	pop	si
 41510 00007568 89FB                    	mov	bx,di
 41511 0000756A E866B1                  	call	PackName                ; crunch the path
 41512 0000756D 5F                      	pop	di			; get original destination
 41513 0000756E 07                      	pop	es
 41514 0000756F 16                      	push	ss			; get DS addressability
 41515 00007570 1F                      	pop	ds
 41516                                  	;lea	si,[bp-15] ; MSDOS 3.3
 41517                                  	;LEA	SI,FCBTmp		; point at new pathname
 41518 00007571 8D76F0                  	lea	si,[bp-16]
 41519 00007574 803F00                  	cmp	byte [bx],0
 41520 00007577 7407                    	jz	short BadPack
 41521 00007579 55                      	push	bp
 41522 0000757A E80E00                  	call	TransPathSet            ; convert the path
 41523 0000757D 5D                      	pop	bp
 41524 0000757E 7303                    	jnc	short FCBRet		; bye with transPath error code
 41525                                  BadPack:
 41526 00007580 F9                      	STC
 41527                                  	;mov	al,3
 41528 00007581 B003                    	MOV     AL,error_path_not_found
 41529                                  FCBRet: 
 41530                                  	;LEAVE
 41531 00007583 89EC                    	mov	sp,bp
 41532 00007585 5D                      	pop	bp
 41533                                  TransPath_retn:
 41534 00007586 C3                      	retn
 41535                                  
 41536                                  ; 12/07/2018 - Retro DOS v3.0
 41537                                  
 41538                                  ;BREAK <TransPath - copy a path, do string sub and put in current dir>
 41539                                  ;----------------------------------------------------------------------------
 41540                                  ;
 41541                                  ;   TransPath - copy a path from DS:SI to ES:DI, performing component string
 41542                                  ;       substitution, insertion of current directory and fixing . and ..
 41543                                  ;       entries. Perform splicing. Allow input string to match splice
 41544                                  ;       exactly.
 41545                                  ;
 41546                                  ;   TransPathSet - Same as above except No splicing is performed if input path
 41547                                  ;       matches splice.
 41548                                  ;
 41549                                  ;   TransPathNoSet - No splicing/local using is performed at all.
 41550                                  ;
 41551                                  ;   The following anomalous behaviour is required:
 41552                                  ;
 41553                                  ;       Drive letters on devices are ignored. (set up DummyCDS)
 41554                                  ;       Paths on devices are ignored. (truncate to 0-length)
 41555                                  ;       Raw net I/O sets ThisCDS => NULL.
 41556                                  ;       fSharing => dummyCDS and no subst/splice. Only canonicalize.
 41557                                  ;
 41558                                  ;   Other behaviour:
 41559                                  ;
 41560                                  ;       ThisCDS set up.
 41561                                  ;       FatRead done on local CDS.
 41562                                  ;       ValidateCDS done on local CDS.
 41563                                  ;
 41564                                  ;   Brief flowchart:
 41565                                  ;
 41566                                  ;       if fSharing then
 41567                                  ;           set up DummyCDS (ThisCDS)
 41568                                  ;           canonicalize (sets cMeta)
 41569                                  ;           splice
 41570                                  ;           fatRead
 41571                                  ;           return
 41572                                  ;       if \\ or d:\\ lead then
 41573                                  ;           set up null CDS (ThisCDS)
 41574                                  ;           canonicalize (sets cMeta)
 41575                                  ;           return
 41576                                  ;       if device then
 41577                                  ;           set up dummyCDS (ThisCDS)
 41578                                  ;           canonicalize (sets cMeta)
 41579                                  ;           return
 41580                                  ;       if file then
 41581                                  ;           getCDS (sets (ThisCDS) from name)
 41582                                  ;           validateCDS (may reset current dir)
 41583                                  ;           Copy current dir
 41584                                  ;           canonicalize (set cMeta)
 41585                                  ;           splice
 41586                                  ;           generate correct CDS (ThisCDS)
 41587                                  ;           if local then
 41588                                  ;               fatread
 41589                                  ;           return
 41590                                  ;
 41591                                  ;   Inputs:     DS:SI - point to ASCIZ string path
 41592                                  ;               DI - point to buffer in DOSDATA
 41593                                  ;   Outputs:    Carry Set - invalid path specification: too many .., bad
 41594                                  ;                   syntax, etc. or user FAILed to I 24.
 41595                                  ;               WFP_Start - points to beginning of buffer
 41596                                  ;               Curr_Dir_End - points to end of current dir in path
 41597                                  ;               DS - DOSDATA
 41598                                  ;   Registers modified: most
 41599                                  ;
 41600                                  ;----------------------------------------------------------------------------
 41601                                  
 41602                                  ; 22/05/2019
 41603                                  ; 13/05/2019 - Retro DOS v4.0
 41604                                  ; DOSCODE:AB99h (MSDOS 6.21, MSDOS.SYS)
 41605                                  
 41606                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41607                                  ; DOSCODE:AB39h (MSDOS 5.0, MSDOS.SYS)
 41608                                  
 41609                                  TransPath:
 41610 00007587 30C0                    	XOR     AL,AL
 41611 00007589 EB02                    	JMP     SHORT SetSplice
 41612                                  TransPathSet:
 41613 0000758B B0FF                    	MOV     AL,-1
 41614                                  SetSplice:
 41615 0000758D 36A2[4C03]              	MOV	[SS:NoSetDir],AL	;   NoSetDir = !fExact; ;smr;SS Override
 41616 00007591 B0FF                    	MOV     AL,-1
 41617                                  TransPathNoSet:
 41618 00007593 36A2[7105]              	MOV	[SS:FSPLICE],AL		;   fSplice = TRUE;     ;smr;SS Override
 41619 00007597 36C606[7A05]FF          	MOV	byte [ss:CMETA],-1      			;smr;SS Override
 41620 0000759D 36893E[B205]            	MOV     [SS:WFP_START],DI 				;smr;SS Override
 41621 000075A2 36C706[B605]FFFF        	MOV	word [SS:CURR_DIR_END],-1 ; crack from start	;smr;SS Override
 41622 000075A9 16                      	push	ss
 41623 000075AA 07                      	pop	es
 41624                                  	;lea	bp,[di+134]
 41625 000075AB 8DAD8600                	LEA     BP,[DI+TEMPLEN]         ; end of buffer
 41626                                  ;
 41627                                  ; if this is through the server dos call, fsharing is set. We set up a
 41628                                  ; dummy cds and let the operation go.
 41629                                  ;
 41630 000075AF 36F606[7205]FF          	TEST	byte [SS:FSHARING],-1	; if no sharing		;smr;SS Override
 41631 000075B5 7435                    	JZ	short CheckUNC		; skip to UNC check
 41632                                  ;
 41633                                  ; ES:DI point to buffer
 41634                                  ;
 41635 000075B7 E8FC02                  	CALL	DriveFromText           ; get drive and advance DS:SI
 41636 000075BA E8F3FE                  	call	GETTHISDRV              ; Set ThisCDS and convert to 0-based
 41637 000075BD 722A                    	jc	short NoPath
 41638 000075BF E80A03                  	CALL	TextFromDrive		; drop in new
 41639 000075C2 8D5D01                  	LEA	BX,[DI+1]               ; backup limit
 41640 000075C5 E83401                  	CALL	Canonicalize            ; copy and canonicalize
 41641 000075C8 72BC                    	jc	short TransPath_retn	; errors
 41642                                  ;
 41643                                  ; Perform splices for net guys.
 41644                                  ;
 41645 000075CA 16                      	push	ss
 41646 000075CB 1F                      	pop	ds
 41647 000075CC 8B36[B205]              	MOV     SI,[WFP_START] 		; point to name
 41648 000075D0 F606[7105]FF            	TEST	byte [FSPLICE],-1
 41649 000075D5 7403                    	JZ	short NoServerSplice
 41650 000075D7 E83102                  	CALL    Splice
 41651                                  NoServerSplice:
 41652 000075DA 16                      	push	ss
 41653 000075DB 1F                      	pop	ds                      ; for FATREAD
 41654 000075DC C43E[A205]              	LES     DI,[THISCDS]		; for fatread
 41655 000075E0 E820A3                  	call	ECritDisk
 41656 000075E3 E8CEEA                  	call	FATREAD_CDS
 41657 000075E6 E847A3                  	call	LCritDisk
 41658                                  NoPath:
 41659                                  	;mov	al,3
 41660 000075E9 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 41661 000075EB C3                      	retn				; any errors are in Carry flag
 41662                                  
 41663                                  ; Let the network decide if the name is for a spooled device. It will map
 41664                                  ; the name if so.
 41665                                  
 41666                                  CheckUNC:
 41667 000075EC 36C706[A205]FFFF        	MOV     WORD [SS:THISCDS],-1	; NULL thisCDS		;smr;SS Override
 41668                                  	;CallInstall NetSpoolCheck,MultNET,35
 41669 000075F3 B82311                  	mov	ax,1123h
 41670 000075F6 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
 41671                                  			; DS:SI -> ASCIZ filename to canonicalize
 41672                                  			; ES:DI -> 128-byte buffer for qualified name
 41673                                  			; Return: CF set if not resolved
 41674 000075F8 7329                    	JNC	short UNCDone
 41675                                  
 41676                                  ; At this point the name is either a UNC-style name (prefixed with two leading
 41677                                  ; \\s) or is a local file/device. Remember that if a net-spooled device was
 41678                                  ; input, then the name has been changed to the remote spooler by the above net
 41679                                  ; call. Also, there may be a drive in front of the \\.
 41680                                  
 41681                                  NO_CHECK:
 41682 000075FA E8B902                  	CALL    DriveFromText		; eat drive letter
 41683 000075FD 50                      	PUSH    AX                      ; save it
 41684 000075FE 8B04                    	MOV     AX,[SI]			; get first two bytes of path
 41685 00007600 E877E4                  	call    PATHCHRCMP              ; convert to normal form
 41686 00007603 86E0                    	XCHG    AH,AL                   ; swap for second byte
 41687 00007605 E872E4                  	call    PATHCHRCMP              ; convert to normal form
 41688 00007608 751F                    	JNZ	short CheckDevice	; not a path char
 41689 0000760A 38C4                    	CMP     AH,AL                   ; are they same?
 41690 0000760C 751B                    	JNZ	short CheckDevice	; nope
 41691                                  
 41692                                  ; We have a UNC request. We must copy the string up to the beginning of the
 41693                                  ; local machine root path
 41694                                  
 41695 0000760E 58                      	POP     AX
 41696 0000760F A5                      	MOVSW                           ; get the lead \\.
 41697                                  UNCCpy:
 41698 00007610 AC                      	LODSB                           ; get a byte
 41699 00007611 E811E4                   	call	UCase                   ;AN000;; convert the char
 41700 00007614 08C0                    	OR      AL,AL
 41701 00007616 740E                    	JZ	short UNCTerm		; end of string. All done.
 41702 00007618 E85FE4                  	call    PATHCHRCMP              ; is it a path char?
 41703 0000761B 89FB                    	MOV     BX,DI                   ; backup position
 41704 0000761D AA                      	STOSB
 41705 0000761E 75F0                    	JNZ	short UNCCpy		; no, go copy
 41706 00007620 E8D900                  	CALL    Canonicalize            ; wham (and set cMeta)
 41707                                  UNCDone:
 41708 00007623 16                      	push	ss
 41709 00007624 1F                      	pop	ds
 41710 00007625 C3                       	retn				; return error code
 41711                                  UNCTerm:
 41712 00007626 AA                      	STOSB                           ;AN000;
 41713 00007627 EBFA                    	JMP	short UNCDone		;AN000;
 41714                                  
 41715                                  CheckDevice:
 41716                                  
 41717                                  ; Check DS:SI for device. First eat any path stuff
 41718                                  
 41719 00007629 58                      	POP     AX                      ; retrieve drive info
 41720 0000762A 803C00                  	CMP     BYTE [SI],0		; check for null file
 41721 0000762D 7504                    	JNZ	short CheckPath
 41722                                  	;mov	al,2 
 41723 0000762F B002                    	MOV     AL,error_file_not_found ; bad file error
 41724 00007631 F9                      	STC                             ; signal error on null input
 41725 00007632 C3                      	RETN				; bye!
 41726                                  CheckPath:
 41727 00007633 50                      	push	ax
 41728 00007634 55                      	push	bp			; save drive number
 41729                                  
 41730                                  
 41731                                  ; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41732                                  %if 0
 41733                                  	; MSDOS 6.0
 41734                                  ;;;BUGBUG BUG 10-26-1992 scottq
 41735                                  ;;;This is a hack for the CDROM extensions (2.1) who scan looking
 41736                                  ;;;for the following POP BP == 5Dh (restore <bp,ax>).
 41737                                  ;;;The problem is that a direct call to CheckThisDevice can (and did)
 41738                                  ;;;end up having a 5D in the opcode's displacement field. The
 41739                                  ;;;scanning code would choke on this thinking it was a POP BP instruction.
 41740                                  ;;;
 41741                                  ;;;What we do here is do a call to a function that is less than 5Dh
 41742                                  ;;;bytes away (and assert its not exactly 5D away) that jmps (transfers)
 41743                                  ;;;to the correct function. This cannot accidently insert a 5Dh.
 41744                                  ;;;
 41745                                  ;;;More info:
 41746                                  ;;;  This particular scan is begun at the UNCdone label for 32 bytes
 41747                                  ;;;looking for pop BP, so you cannot put a 5D between here and there.
 41748                                  ;;;
 41749                                  	call	no5Dshere
 41750                                  start5Dhack:
 41751                                  ;following is replaced with 5Dhack code--Invoke CheckThisDevice
 41752                                  backfrom5Dhack:
 41753                                  
 41754                                  %endif
 41755                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41756                                  	; Note: 'call no5Dshere' is not required for MSDOS 5.0 MSDOS.SYS
 41757 00007635 E8C4D6                  	call    CheckThisDevice	; E8h,6Fh,0D6h
 41758                                  
 41759 00007638 5D                      	pop	bp
 41760 00007639 58                      	pop	ax			; get drive letter back
 41761 0000763A 731C                    	JNC	short DoFile		; yes we have a file.
 41762                                  
 41763                                  ; We have a device. AX has drive letter. At this point we may fake a CDS ala
 41764                                  ; sharing DOS call. We know by getting here that we are NOT in a sharing DOS
 41765                                  ; call.
 41766                                  
 41767 0000763C 36C606[7205]FF          	MOV	byte [SS:FSHARING],-1	; simulate sharing dos call;smr;SS Override
 41768 00007642 E86BFE                  	call	GETTHISDRV              ; set ThisCDS and init DUMMYCDS
 41769 00007645 36C606[7205]00          	MOV     byte [SS:FSHARING],0	;                       ;smr;SS Override
 41770                                  
 41771                                  ; Now that we have noted that we have a device, we put it into a form that
 41772                                  ; getpath can understand. Normally getpath requires d:\ to begin the input
 41773                                  ; string. We relax this to state that if the d:\ is present then the path
 41774                                  ; may be a file. If D:/ (note the forward slash) is present then we have
 41775                                  ; a device.
 41776                                  
 41777 0000764B E87E02                  	CALL    TextFromDrive
 41778 0000764E B02F                    	MOV     AL,'/'                  ; path sep.
 41779 00007650 AA                      	STOSB
 41780 00007651 E875A1                  	call	StrCpy			; move remainder of string
 41781                                  
 41782 00007654 F8                      	CLC                             ; everything OK.
 41783 00007655 16                      	push	ss
 41784 00007656 1F                      	pop	ds                      ; remainder of OK stuff
 41785                                  DoFile_retn:
 41786 00007657 C3                      	retn
 41787                                  
 41788                                  ; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41789                                  %if 0
 41790                                  
 41791                                  no5Dshere:
 41792                                  	; 10/08/2018
 41793                                  	jmp	CheckThisDevice		; snoop for device
 41794                                  %endif
 41795                                  
 41796                                  ;.erre (no5Dshere - start5Dhack - 5D)
 41797                                  
 41798                                  ; We have a file. Get the raw CDS.
 41799                                  
 41800                                  DoFile:
 41801                                  	; MSDOS 3.3 (& MSDOS 6.0)
 41802                                  
 41803 00007658 E839FE                  	call	GetVisDrv               ; get proper CDS
 41804                                  	;mov	al,3 
 41805 0000765B B003                    	MOV     AL,error_path_not_found ; Set up for possible bad file error
 41806 0000765D 72F8                    	jc	short DoFile_retn  ; CARRY set -> bogus drive/spliced
 41807                                  
 41808                                  ; ThisCDS has correct CDS. DS:SI advanced to point to beginning of path/file.
 41809                                  ; Make sure that CDS has valid directory; ValidateCDS requires a temp buffer
 41810                                  ; Use the one that we are going to use (ES:DI).
 41811                                  
 41812                                  	;SAVE    <DS,SI,ES,DI>		; save all string pointers.
 41813 0000765F 1E                      	push	ds
 41814 00007660 56                      	push	si
 41815 00007661 06                      	push	es
 41816 00007662 57                      	push	di
 41817 00007663 E8DAD5                  	call	ValidateCDS             ; poke CDS and make everything OK
 41818                                  	;RESTORE <DI,ES,SI,DS>		; get back pointers
 41819 00007666 5F                      	pop	di
 41820 00007667 07                      	pop	es
 41821 00007668 5E                      	pop	si
 41822 00007669 1F                      	pop	ds
 41823                                  	;mov	al,3
 41824 0000766A B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 41825                                  	;retc				; someone failed an operation
 41826 0000766C 72E9                    	jc	short DoFile_retn
 41827                                  
 41828                                  ; ThisCDS points to correct CDS. It contains the correct text of the
 41829                                  ; current directory. Copy it in.
 41830                                  
 41831 0000766E 1E                      	push	ds
 41832 0000766F 56                      	push	si
 41833 00007670 36C536[A205]            	LDS     SI,[SS:THISCDS]		; point to CDS	;smr;SS Override
 41834 00007675 89FB                    	MOV     BX,DI                   ; point to destination
 41835                                  	;add	bx,[si+79] ; MSDOS 6.0
 41836 00007677 035C4F                  	ADD     BX,[SI+curdir.end]	; point to backup limit
 41837                                  	;lea	bp,[di+134]
 41838 0000767A 8DAD8600                	LEA     BP,[DI+TEMPLEN]         ; regenerate end of buffer
 41839                                  					;AN000;
 41840 0000767E E857A1                  	call	FStrCpy                 ; copy string. ES:DI point to end
 41841 00007681 4F                      	DEC     DI                      ; point to NUL byte
 41842                                  
 41843                                  ; Make sure that there is a path char at end.
 41844                                  
 41845 00007682 B05C                    	MOV     AL,'\'
 41846 00007684 263845FF                	CMP     [ES:DI-1],AL
 41847 00007688 7401                    	JZ	short GetOrig
 41848 0000768A AA                      	STOSB
 41849                                  
 41850                                  ; Now get original string.
 41851                                  
 41852                                  GetOrig:
 41853 0000768B 4F                      	DEC     DI                      ; point to path char
 41854 0000768C 5E                      	pop	si
 41855 0000768D 1F                      	pop	ds
 41856                                  
 41857                                  ; BX points to the end of the root part of the CDS (at where a path char
 41858                                  ; should be). Now, we decide whether we use this root or extend it with the
 41859                                  ; current directory. See if the input string begins with a leading 
 41861 0000768E E8D000                  	CALL    PathSep                 ; is DS:SI a path sep?
 41862 00007691 7511                    	JNZ	short PathAssure	; no, DI is correct. Assure a path char
 41863 00007693 08C0                    	OR      AL,AL                   ; end of string?
 41864 00007695 7410                    	JZ	short DoCanon		; yes, skip.
 41865                                  ;
 41866                                  ; The string does begin with a \. Reset the beginning of the canonicalization
 41867                                  ; to this root. Make sure that there is a path char there and advance the
 41868                                  ; source string over all leading \'s.
 41869                                  ;
 41870 00007697 89DF                    	MOV     DI,BX                   ; back up to root point.
 41871                                  SkipPath:
 41872 00007699 AC                      	LODSB
 41873 0000769A E8DDE3                  	call    PATHCHRCMP
 41874 0000769D 74FA                    	JZ	short SkipPath
 41875 0000769F 4E                      	DEC     SI
 41876 000076A0 08C0                    	OR      AL,AL
 41877 000076A2 7403                    	JZ	short DoCanon
 41878                                  
 41879                                  ; DS:SI start at some file name. ES:DI points at some path char. Drop one in
 41880                                  ; for yucks.
 41881                                  
 41882                                  PathAssure:
 41883 000076A4 B05C                    	MOV     AL,'\'	; 5Ch
 41884 000076A6 AA                      	STOSB
 41885                                  
 41886                                  ; ES:DI point to the correct spot for canonicalization to begin.
 41887                                  ; BP is the max extent to advance DI
 41888                                  ; BX is the backup limit for ..
 41889                                  
 41890                                  DoCanon:
 41891 000076A7 E85200                  	CALL    Canonicalize            ; wham.
 41892                                  	;retc				; badly formatted path.
 41893 000076AA 72AB                    	jc	short DoFile_retn
 41894                                  
 41895                                  ; The string has been moved to ES:DI. Reset world to DOS context, pointers
 41896                                  ; to wfp_start and do string substitution. BP is still the max position in
 41897                                  ; buffer.
 41898                                  
 41899 000076AC 16                      	push	ss
 41900 000076AD 1F                      	pop	ds
 41901 000076AE 8B3E[B205]              	MOV     DI,[WFP_START]		; DS:SI point to string
 41902 000076B2 C536[A205]              	LDS     SI,[THISCDS]		; point to CDS
 41903 000076B6 E81B02                  	CALL    PathPref                ; is there a prefix?
 41904 000076B9 7514                    	JNZ	short DoSplice		; no, do splice
 41905                                  
 41906                                  ; We have a match. Check to see if we ended in a path char.
 41907                                  
 41908 000076BB 8A44FF                  	MOV     AL,[SI-1]		; last char to match
 41909 000076BE E8B9E3                  	call    PATHCHRCMP              ; did we end on a path char? (root)
 41910 000076C1 740C                    	JZ	short DoSplice		; yes, no current dir here.
 41911                                  Pathline:                               ; 2/13/KK
 41912 000076C3 26803D00                	CMP     BYTE [ES:DI],0		; end at NUL?
 41913 000076C7 7406                    	JZ	short DoSplice
 41914 000076C9 47                      	INC     DI                      ; point to after current path char
 41915 000076CA 36893E[B605]            	MOV     [SS:CURR_DIR_END],DI	; point to correct spot ;smr;SS Override
 41916                                  
 41917                                  ; Splice the result.
 41918                                  
 41919                                  DoSplice:
 41920 000076CF 16                      	push	ss
 41921 000076D0 1F                      	pop	ds			; back to DOSDATA
 41922 000076D1 8B36[B205]              	MOV     SI,[WFP_START]		; point to beginning of string
 41923 000076D5 31C9                    	XOR     CX,CX
 41924 000076D7 F606[7105]FF            	TEST	byte [FSPLICE],-1
 41925 000076DC 7403                    	JZ	short SkipSplice
 41926 000076DE E82A01                  	CALL    Splice                  ; replaces in place.
 41927                                  SkipSplice:
 41928                                  
 41929                                  ; The final thing is to assure ourselves that a FATREAD is done on the local
 41930                                  ; device.
 41931                                  
 41932 000076E1 16                      	push	ss
 41933 000076E2 1F                      	pop	ds
 41934 000076E3 C43E[A205]              	LES     DI,[THISCDS]		; point to correct drive
 41935                                  	;test	word [es:di+67],8000h
 41936                                  	; 17/12/2022
 41937                                  	;test	byte [es:di+68],80h
 41938 000076E7 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8 ; 04/12/2022
 41939                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet ; 8000h
 41940 000076EC 750D                    	JNZ	short Done		; net, no fatread necessary (retnz)
 41941 000076EE E30B                    	JCXZ    Done
 41942 000076F0 E810A2                  	call	ECritDisk
 41943 000076F3 E8BEE9                  	call	FATREAD_CDS
 41944 000076F6 E837A2                  	call	LCritDisk
 41945                                  	;mov	al, 3
 41946 000076F9 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 41947                                  Done:   
 41948 000076FB C3                      	retn                         ; any errors in carry flag.
 41949                                  
 41950                                  ; 13/07/2018
 41951                                  
 41952                                  ;BREAK <Canonicalize - copy a path and remove . and .. entries>
 41953                                  ;----------------------------------------------------------------------------
 41954                                  ;   Canonicalize - copy path removing . and .. entries.
 41955                                  ;
 41956                                  ;   Inputs:     DS:SI - point to ASCIZ string path
 41957                                  ;               ES:DI - point to buffer
 41958                                  ;               BX - backup limit (offset from ES) points to slash
 41959                                  ;               BP - end of buffer
 41960                                  ;   Outputs:    Carry Set - invalid path specification: too many .., bad
 41961                                  ;                   syntax, etc.
 41962                                  ;               Carry Clear -
 41963                                  ;                   DS:DI - advanced to end of string
 41964                                  ;                   ES:DI - advanced to end of canonicalized form after nul
 41965                                  ;   Registers modified: AX CX DX (in addition to those above)
 41966                                  ;----------------------------------------------------------------------------
 41967                                  
 41968                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41969                                  
 41970                                  Canonicalize:
 41971                                  
 41972                                  ; We copy all leading path separators.
 41973                                  
 41974 000076FC AC                      	LODSB                           ;   while (PathChr (*s))
 41975 000076FD E87AE3                  	call    PATHCHRCMP
 41976 00007700 7507                    	JNZ	short CanonDec
 41977 00007702 39EF                    	CMP     DI,BP                   ;       if (d > dlim)
 41978 00007704 7319                    	JAE	short CanonBad		;           goto error;
 41979 00007706 AA                      	STOSB
 41980 00007707 EBF3                    	JMP	short Canonicalize	;           *d++ = *s++;
 41981                                  CanonDec:
 41982 00007709 4E                      	DEC     SI
 41983                                  
 41984                                  ; Main canonicalization loop. We come here with DS:SI pointing to a textual
 41985                                  ; component (no leading path separators) and ES:DI being the destination
 41986                                  ; buffer.
 41987                                  
 41988                                  CanonLoop:
 41989                                  
 41990                                  ; If we are at the end of the source string, then we need to check to see that
 41991                                  ; a potential drive specifier is correctly terminated with a path sep char.
 41992                                  ; Otherwise, do nothing
 41993                                  
 41994 0000770A 31C0                    	XOR     AX,AX
 41995 0000770C 3804                    	CMP     [SI],AL                 ;       if (*s == 0) {
 41996 0000770E 751A                    	JNZ	short DoComponent
 41997 00007710 26807DFF3A              	CMP     BYTE [ES:DI-1],':'	;           if (d[-1] == ':')
 41998 00007715 7505                    	JNZ	short DoTerminate
 41999 00007717 B05C                    	MOV     AL,'\'                  ;               *d++ = '\';
 42000 00007719 AA                      	STOSB
 42001 0000771A 88E0                    	MOV     AL,AH
 42002                                  DoTerminate:
 42003 0000771C AA                      	STOSB                           ;           *d++ = 0;
 42004 0000771D F8                      	CLC                             ;           return (0);
 42005 0000771E C3                      	retn
 42006                                  
 42007                                  CanonBad:
 42008 0000771F E8CB01                  	CALL	ScanPathChar            ; check for path chars in rest of string
 42009                                  	;mov	al,3
 42010 00007722 B003                    	MOV     AL,error_path_not_found ; Set up for bad path error
 42011 00007724 7402                    	JZ	short PathEnc		; path character encountered in string
 42012                                  	;mov	al,2
 42013 00007726 B002                    	MOV     AL,error_file_not_found ; Set bad file error
 42014                                  PathEnc:
 42015 00007728 F9                      	STC
 42016                                  CanonBad_retn:
 42017 00007729 C3                      	retn
 42018                                  
 42019                                  ; We have a textual component that we must copy. We uppercase it and truncate
 42020                                  ; it to 8.3
 42021                                  
 42022                                  DoComponent:                            ;           }
 42023 0000772A E85000                  	CALL    CopyComponent		;       if (!CopyComponent (s, d))
 42024 0000772D 72FA                    	jc	short CanonBad_retn	;           return (-1);
 42025                                  
 42026                                  ; We special case the . and .. cases.  These will be backed up.
 42027                                  
 42028                                  	;CMP	WORD PTR ES:[DI],'.' + (0 SHL 8)
 42029 0000772F 26833D2E                	CMP	WORD [ES:DI],002Eh
 42030 00007733 7408                    	JZ	short Skip1
 42031                                  	;CMP	WORD PTR ES:[DI],'..'
 42032 00007735 26813D2E2E              	CMP     WORD [ES:DI],2E2Eh
 42033 0000773A 750A                    	JNZ	short CanonNormal
 42034 0000773C 4F                      	DEC     DI                      ;           d--;
 42035                                  Skip1:  
 42036 0000773D E82A00                  	CALL    SkipBack                ;           SkipBack ();
 42037                                  	;mov	al,3
 42038 00007740 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 42039 00007742 72E5                    	jc	short CanonBad_retn
 42040 00007744 EB02                    	JMP     short CanonPath         ;           }
 42041                                  
 42042                                  ; We have a normal path. Advance destination pointer over it.
 42043                                  
 42044                                  CanonNormal:                            ;       else
 42045 00007746 01CF                    	ADD     DI,CX                   ;           d += ct;
 42046                                  
 42047                                  ; We have successfully copied a component. We are now pointing at a path
 42048                                  ; sep char or are pointing at a nul or are pointing at something else.
 42049                                  ; If we point at something else, then we have an error.
 42050                                  
 42051                                  CanonPath:
 42052 00007748 E81600                  	CALL    PathSep
 42053 0000774B 75D2                    	JNZ	short CanonBad		; something else...
 42054                                  
 42055                                  ; Copy the first path char we see.
 42056                                  
 42057 0000774D AC                      	LODSB                           ; get the char
 42058 0000774E E829E3                  	call    PATHCHRCMP              ; is it path char?
 42059 00007751 75B6                    	JNZ	short CanonDec		; no, go test for nul
 42060 00007753 39EF                    	CMP     DI,BP                   ; beyond buffer end?
 42061 00007755 73C8                    	JAE	short CanonBad		; yep, error.
 42062 00007757 AA                      	STOSB                           ; copy the one byte
 42063                                  
 42064                                  ; Skip all remaining path chars
 42065                                  
 42066                                  CanonPathLoop:
 42067 00007758 AC                      	LODSB                           ; get next byte
 42068 00007759 E81EE3                  	call    PATHCHRCMP              ; path char again?
 42069 0000775C 74FA                    	JZ	short CanonPathLoop	; yep, grab another
 42070 0000775E 4E                      	DEC     SI                      ; back up
 42071 0000775F EBA9                    	JMP	short  CanonLoop	; go copy component
 42072                                  
 42073                                  ;BREAK <PathSep - determine if char is a path separator>
 42074                                  ;----------------------------------------------------------------------------
 42075                                  ;   PathSep - look at DS:SI and see if char is / \ or NUL
 42076                                  ;   Inputs:     DS:SI - point to a char
 42077                                  ;   Outputs:    AL has char from DS:SI (/ => \)
 42078                                  ;               Zero set if AL is / \ or NUL
 42079                                  ;               Zero reset otherwise
 42080                                  ;   Registers modified: AL
 42081                                  ;----------------------------------------------------------------------------
 42082                                  
 42083                                  PathSep:
 42084 00007761 8A04                    	MOV     AL,[SI]                 ; get the character
 42085                                  PathSepGotCh:				; already have character
 42086 00007763 08C0                    	OR      AL,AL                   ; test for zero
 42087 00007765 74C2                    	jz	short CanonBad_retn	; return if equal to zero (NUL)
 42088                                  	;call	PATHCHRCMP              ; check for path character
 42089                                  	;retn				; and return HIS determination
 42090                                  	; 18/12/2022
 42091 00007767 E910E3                  	jmp	PATHCHRCMP
 42092                                  
 42093                                  
 42094                                  ;BREAK <SkipBack - move backwards to a path separator>
 42095                                  ;----------------------------------------------------------------------------
 42096                                  ;   SkipBack - look at ES:DI and backup until it points to a / ;   Inputs:     ES:DI - point to a char
 42098                                  ;               BX has current directory back up limit (point to a / \)
 42099                                  ;   Outputs:    ES:DI backed up to point to a path char
 42100                                  ;               AL has char from output ES:DI (path sep if carry clear)
 42101                                  ;               Carry set if illegal backup
 42102                                  ;               Carry Clear if ok
 42103                                  ;   Registers modified: DI,AL
 42104                                  ;----------------------------------------------------------------------------
 42105                                  
 42106                                  SkipBack:
 42107 0000776A 39DF                    	CMP     DI,BX                   ;   while (TRUE) {
 42108 0000776C 720B                    	JB	short SkipBad		;       if (d < dlim)
 42109 0000776E 4F                      	DEC     DI                      ;           goto err;
 42110 0000776F 268A05                  	MOV     AL,[ES:DI]		;       if (pathchr (*--d))
 42111 00007772 E805E3                  	call    PATHCHRCMP              ;           break;
 42112 00007775 75F3                    	JNZ	short SkipBack		;       }
 42113 00007777 F8                      	CLC                             ;   return (0);
 42114 00007778 C3                      	retn				;
 42115                                  SkipBad:                                ;err:
 42116                                  	;mov	al,3
 42117 00007779 B003                    	MOV     AL,error_path_not_found ; bad path error
 42118 0000777B F9                      	STC                             ;   return (-1);
 42119 0000777C C3                      	retn				;
 42120                                  
 42121                                  ;Break <CopyComponent - copy out a file path component>
 42122                                  ;----------------------------------------------------------------------------
 42123                                  ;   CopyComponent - copy a file component from a path string (DS:SI) into ES:DI
 42124                                  ;
 42125                                  ;   Inputs:     DS:SI - source path
 42126                                  ;               ES:DI - destination
 42127                                  ;               ES:BP - end of buffer
 42128                                  ;   Outputs:    Carry Set - too long
 42129                                  ;               Carry Clear - DS:SI moved past component
 42130                                  ;                   CX has length of destination
 42131                                  ;   Registers modified: AX,CX,DX
 42132                                  ;----------------------------------------------------------------------------
 42133                                  
 42134                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42135                                  
 42136                                  CopyComponent:
 42137                                  
 42138                                  %define CopyBP	 [BP]		; word
 42139                                  %define CopyD	 [BP+2]		; dword
 42140                                  %define CopyDoff [BP+2]		; word
 42141                                  %define CopyS	 [BP+6]		; dword
 42142                                  %define CopySoff [BP+6]		; word
 42143                                  %define CopyTemp [BP+10]	; byte
 42144                                  
 42145 0000777D 83EC0E                  	SUB     SP,14                   ; room for temp buffer
 42146 00007780 1E                      	push	ds
 42147 00007781 56                      	push	si
 42148 00007782 06                      	push	es
 42149 00007783 57                      	push	di
 42150 00007784 55                      	push	bp
 42151 00007785 89E5                    	MOV     BP,SP
 42152 00007787 B42E                    	MOV     AH,'.'
 42153 00007789 AC                      	LODSB
 42154 0000778A AA                      	STOSB
 42155 0000778B 38E0                    	CMP     AL,AH                   ;   if ((*d++=*s++) == '.') {
 42156 0000778D 7518                    	JNZ	short NormalComp
 42157 0000778F E8CFFF                  	CALL    PathSep                 ;       if (!pathsep(*s))
 42158 00007792 740B                    	JZ	short NulTerm
 42159                                  TryTwoDot:
 42160 00007794 AC                      	LODSB                           ;           if ((*d++=*s++) != '.'
 42161 00007795 AA                      	STOSB
 42162 00007796 38E0                    	CMP     AL,AH
 42163 00007798 7557                    	JNZ	short CopyBad
 42164 0000779A E8C4FF                  	CALL    PathSep
 42165 0000779D 7552                    	JNZ	short CopyBad		;               || !pathsep (*s))
 42166                                  NulTerm:                                ;               return -1;
 42167 0000779F 30C0                    	XOR     AL,AL                   ;       *d++ = 0;
 42168 000077A1 AA                      	STOSB
 42169 000077A2 897606                  	MOV     CopySoff,SI
 42170 000077A5 EB47                    	JMP     SHORT _GoodRet		;       }
 42171                                  NormalComp:                             ;   else {
 42172 000077A7 8B7606                  	MOV     SI,CopySoff ; [bp+6]
 42173 000077AA E80BE2                  	call	NameTrans               ;       s = NameTrans (s, Name1);
 42174 000077AD 3B7606                  	CMP     SI,CopySoff             ;       if (s == CopySOff)
 42175 000077B0 743F                    	JZ	short CopyBad		;           return (-1);
 42176 000077B2 36F606[7205]FF          	TEST	byte [SS:FSHARING],-1	;       if (!fSharing) {;smr;SS Override
 42177 000077B8 7510                    	JNZ	short DoPack
 42178 000077BA 80E201                  	AND     DL,1                    ;           cMeta += fMeta;
 42179 000077BD 360016[7A05]            	ADD	[ss:CMETA],DL		;           if (cMeta > 0);smr;SS Override
 42180 000077C2 7F2D                    	JG	short CopyBad		;               return (-1);
 42181 000077C4 7504                    	JNZ	short DoPack		;           else
 42182 000077C6 08D2                    	OR      DL,DL                   ;           if (cMeta == 0 && fMeta == 0)
 42183 000077C8 742F                    	JZ	short CopyBadPath	;               return (-1);
 42184                                  DoPack:                                 ;           }
 42185 000077CA 897606                  	MOV     CopySoff,SI ; [bp+6]
 42186 000077CD 16                      	push	ss
 42187 000077CE 1F                      	pop	ds
 42188 000077CF BE[4B05]                	MOV     SI,NAME1
 42189 000077D2 8D7E0A                  	LEA     DI,CopyTemp ; [bp+10]
 42190 000077D5 57                      	push	di
 42191 000077D6 E8FAAE                  	call	PackName                ;       PackName (Name1, temp);
 42192 000077D9 5F                      	pop	di
 42193 000077DA E804A0                  	call	StrLen                  ;       if (strlen(temp)+d > bp)
 42194 000077DD 49                      	DEC     CX
 42195 000077DE 034E02                  	ADD     CX,CopyDoff ; [bp+2]
 42196                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42197                                  	;cmp	cx,[bp+0]
 42198                                  	; 15/12/2022
 42199                                  	;cmp	cx,[bp]
 42200 000077E1 3B4E00                  	CMP	CX,CopyBP   ; [bp+0]
 42201 000077E4 730B                    	JAE	short CopyBad		;           return (-1);
 42202 000077E6 89FE                    	MOV     SI,DI                   ;       strcpy (d, temp);
 42203 000077E8 C47E02                  	LES     DI,CopyD    ; [bp+2]	
 42204 000077EB E8EA9F                  	call	FStrCpy
 42205                                  _GoodRet:				;       }
 42206 000077EE F8                      	CLC
 42207 000077EF EB0B                    	JMP     SHORT CopyEnd           ;   return 0;
 42208                                  CopyBad:
 42209 000077F1 F9                      	STC
 42210 000077F2 E8F800                  	CALL    ScanPathChar            ; check for path chars in rest of string
 42211                                  	;mov	al,2
 42212 000077F5 B002                    	MOV     AL,error_file_not_found ; Set up for bad file error
 42213 000077F7 7503                    	JNZ	short CopyEnd
 42214                                  CopyBadPath:
 42215 000077F9 F9                      	STC
 42216                                  	;mov	al,3
 42217 000077FA B003                    	MOV     AL,error_path_not_found ; Set bad path error
 42218                                  CopyEnd:
 42219 000077FC 5D                      	pop	bp
 42220 000077FD 5F                      	pop	di
 42221 000077FE 07                      	pop	es
 42222 000077FF 5E                      	pop	si
 42223 00007800 1F                      	pop	ds
 42224 00007801 9F                      	LAHF
 42225 00007802 83C40E                  	ADD     SP,14                   ; reclaim temp buffer
 42226 00007805 E8D99F                  	call	StrLen
 42227 00007808 49                      	DEC     CX
 42228 00007809 9E                      	SAHF
 42229 0000780A C3                      	retn
 42230                                  
 42231                                  ; 14/05/2019 - Retro DOS v4.0
 42232                                  ; DOSCODE:AE22h (MSDOS 6.21, MSDOS.SYS)
 42233                                  
 42234                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42235                                  ; DOSCODE:ADBFh (MSDOS 5.0, MSDOS.SYS)
 42236                                  
 42237                                  ;Break <Splice - pseudo mount by string substitution>
 42238                                  ;----------------------------------------------------------------------------
 42239                                  ;   Splice - take a string and substitute a prefix if one exists. Change
 42240                                  ;       ThisCDS to point to physical drive CDS.
 42241                                  ;   Inputs:     DS:SI point to string
 42242                                  ;               NoSetDir = TRUE => exact matches with splice fail
 42243                                  ;   Outputs:    DS:SI points to thisCDS
 42244                                  ;               ES:DI points to DPB
 42245                                  ;               String at DS:SI may be reduced in length by removing prefix
 42246                                  ;               and substituting drive letter.
 42247                                  ;               CX = 0 If no splice done
 42248                                  ;               CX <> 0 otherwise
 42249                                  ;               ThisCDS points to proper CDS if spliced, otherwise it is
 42250                                  ;                   left alone
 42251                                  ;               ThisDPB points to proper DPB
 42252                                  ;   Registers modified: DS:SI, ES:DI, BX,AX,CX
 42253                                  ;----------------------------------------------------------------------------
 42254                                  
 42255                                  Splice:
 42256 0000780B 36F606[5A00]FF          	TEST	byte [SS:SPLICES],-1	;smr;SS Override
 42257 00007811 7469                    	JZ	short AllDone
 42258 00007813 36FF36[A205]            	push	word [SS:THISCDS]
 42259 00007818 36FF36[A405]            	push	word [SS:THISCDS+2]	; TmpCDS = ThisCDS;smr;SS Override
 42260 0000781D 1E                      	push	ds
 42261 0000781E 56                      	push	si
 42262 0000781F 5F                      	pop	di
 42263 00007820 07                      	pop	es
 42264 00007821 31C0                    	XOR     AX,AX                   ;   for (i=1; s = GetCDSFromDrv (i); i++)
 42265                                  SpliceScan:
 42266 00007823 E8DFFC                  	call	GetCDSFromDrv
 42267 00007826 724A                    	JC	short SpliceDone
 42268 00007828 FEC0                    	INC     AL
 42269                                  	; 17/12/2022
 42270                                  	;test	byte [si+68],20h
 42271 0000782A F6444420                	test	byte [si+curdir.flags+1],curdir_splice>>8 ; 04/12/2022
 42272                                  	;;test	word [si+67],2000h
 42273                                  	;TEST	word [SI+curdir.flags],curdir_splice
 42274 0000782E 74F3                    	JZ	short SpliceScan 	;       if ( Spliced (i) ) {
 42275 00007830 57                      	push	di
 42276 00007831 E8A000                  	CALL    PathPref                ;           if (!PathPref (s, d))
 42277 00007834 7403                    	JZ	short SpliceFound	;
 42278                                  SpliceSkip:
 42279 00007836 5F                      	pop	di
 42280 00007837 EBEA                    	JMP	short SpliceScan	;               continue;
 42281                                  SpliceFound:
 42282 00007839 26803D00                	CMP     BYTE [ES:DI],0		;           if (*s || NoSetDir) {
 42283 0000783D 7508                    	JNZ	short SpliceDo
 42284 0000783F 36F606[4C03]FF          	TEST	byte [ss:NoSetDir],-1			;smr;SS Override
 42285 00007845 75EF                    	JNZ	short SpliceSkip
 42286                                  SpliceDo:
 42287 00007847 89FE                    	MOV     SI,DI                   ;               p = src + strlen (p);
 42288 00007849 06                      	push	es
 42289 0000784A 1F                      	pop	ds
 42290 0000784B 5F                      	pop	di
 42291 0000784C E87F00                  	CALL	TextFromDrive1          ;               src = TextFromDrive1(src,i);
 42292 0000784F 36A1[B605]              	MOV     AX,[SS:CURR_DIR_END]			;smr;SS Override
 42293 00007853 09C0                    	OR      AX,AX
 42294 00007855 7808                    	JS	short NoPoke
 42295 00007857 01F8                    	ADD     AX,DI                   ;               curdirend += src-p;
 42296 00007859 29F0                    	SUB     AX,SI
 42297 0000785B 36A3[B605]              	MOV     [SS:CURR_DIR_END],AX			;smr;SS Override
 42298                                  NoPoke:
 42299 0000785F 803C00                  	CMP     BYTE [SI],0		;               if (*p)
 42300 00007862 7503                    	JNZ	short SpliceCopy	;                   *src++ = '\\';
 42301 00007864 B05C                    	MOV     AL,"\"
 42302 00007866 AA                      	STOSB
 42303                                  SpliceCopy:                             ;               strcpy (src, p);
 42304 00007867 E86E9F                  	call	FStrCpy
 42305 0000786A 83C404                  	ADD     SP,4                    ; throw away saved stuff
 42306 0000786D 80C901                  	OR      CL,1                    ; signal splice done.
 42307 00007870 EB0C                    	JMP     SHORT DoSet             ;               return;
 42308                                  SpliceDone:                             ;               }
 42309 00007872 368F06[A405]            	pop	word [SS:THISCDS+2]     ;   ThisCDS = TmpCDS;
 42310 00007877 368F06[A205]            	pop	word [SS:THISCDS]			;smr;SS Override
 42311                                  AllDone:
 42312 0000787C 31C9                    	XOR     CX,CX
 42313                                  DoSet:
 42314 0000787E 36C536[A205]            	LDS     SI,[SS:THISCDS]		;   ThisDPB = ThisCDS->devptr;;smr;SS Override
 42315                                  	;les	di,[si+69]
 42316 00007883 C47C45                  	LES     DI,[SI+curdir.devptr]	
 42317 00007886 36893E[8A05]            	MOV	[SS:THISDPB],DI				;smr;SS Override
 42318 0000788B 368C06[8C05]            	MOV	[SS:THISDPB+2],ES			;smr;SS Override
 42319                                  Splice_retn:
 42320 00007890 C3                      	retn
 42321                                  
 42322                                  ; 15/05/2019 - Retro DOS v4.0
 42323                                  ; DOSCODE:AEA9h (MSDOS 6.21, MSDOS.SYS)
 42324                                  
 42325                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42326                                  ; DOSCODE:AE46h (MSDOS 5.0, MSDOS.SYS)
 42327                                  
 42328                                  ;Break <$NameTrans - partially process a name>
 42329                                  ;----------------------------------------------------------------------------
 42330                                  ;   $NameTrans - allow users to see what names get mapped to. This call
 42331                                  ;   performs only string substitution and canonicalization, not splicing.  Due
 42332                                  ;   to Transpath playing games with devices, we need to insure that the output
 42333                                  ;   has drive letter and : in it.
 42334                                  ;
 42335                                  ;   Inputs:     DS:SI - source string for translation
 42336                                  ;               ES:DI - pointer to buffer
 42337                                  ;   Outputs:
 42338                                  ;       Carry Clear
 42339                                  ;               Buffer at ES:DI is filled in with data
 42340                                  ;               ES:DI point byte after nul byte at end of dest string in buffer
 42341                                  ;       Carry Set
 42342                                  ;               AX = error_path_not_found
 42343                                  ;   Registers modified: all
 42344                                  ;----------------------------------------------------------------------------
 42345                                  
 42346                                  _$NameTrans:
 42347 00007891 1E                      	push	ds
 42348 00007892 56                      	push	si
 42349 00007893 06                      	push	es
 42350 00007894 57                      	push	di
 42351 00007895 51                      	push	cx ; MSDOS 6.0
 42352                                  	
 42353                                  	; MSDOS 6.0	
 42354                                  ; M027 - Start
 42355                                  ;
 42356                                  ; Sattrib must be set up with default values here. Otherwise, the value from
 42357                                  ; a previous DOS call is used for attrib and DevName thinks it is not a 
 42358                                  ; device if the old call set the volume attribute bit. Note that devname in
 42359                                  ; dir2.asm gets ultimately called by Transpath. See also M026. Also save
 42360                                  ; and restore CX.
 42361                                  
 42362                                  	;mov	ch,16h
 42363 00007896 B516                    	mov     ch,attr_hidden+attr_system+attr_directory
 42364 00007898 E8B902                  	call	SetAttrib
 42365                                  
 42366                                  ; M027 - End
 42367                                  
 42368                                  	; MSDOS 3.3 (& MSDOS 6.0)
 42369 0000789B BF[BE03]                	MOV     DI,OPENBUF
 42370 0000789E E8E6FC                  	CALL    TransPath               ; to translation (everything)
 42371 000078A1 59                      	pop	cx ; MSDOS 6.0
 42372 000078A2 5F                      	pop     di
 42373 000078A3 07                      	pop	es
 42374 000078A4 5E                      	pop     si
 42375 000078A5 1F                      	pop     ds
 42376 000078A6 7303                    	JNC	short TransOK
 42377 000078A8 E9CF8D                  	jmp	SYS_RET_ERR
 42378                                  TransOK:
 42379 000078AB BE[BE03]                	MOV     SI,OPENBUF
 42380 000078AE 16                      	push	ss
 42381 000078AF 1F                      	pop	ds
 42382                                  ;GotText:
 42383 000078B0 E8259F                  	call	FStrCpy
 42384 000078B3 E9BA8D                  	jmp	SYS_RET_OK
 42385                                  
 42386                                  ;Break   <DriveFromText - return drive number from a text string>
 42387                                  ;----------------------------------------------------------------------------
 42388                                  ;   DriveFromText - examine DS:SI and remove a drive letter, advancing the
 42389                                  ;   pointer.
 42390                                  ;
 42391                                  ;   Inputs:     DS:SI point to a text string
 42392                                  ;   Outputs:    AL has drive number
 42393                                  ;               DS:SI advanced
 42394                                  ;   Registers modified: AX,SI.
 42395                                  ;----------------------------------------------------------------------------
 42396                                  
 42397                                  DriveFromText:
 42398 000078B6 30C0                    	XOR     AL,AL                   ;       drive = 0;
 42399                                  	;CMP	BYTE [SI],0		;       if (*s &&
 42400                                  	; 23/09/2023
 42401 000078B8 3804                    	cmp	[si],al ; 0
 42402 000078BA 74D4                    	jz	short Splice_retn
 42403 000078BC 807C013A                	CMP     BYTE [SI+1],':'		;           s[1] == ':') {
 42404 000078C0 75CE                    	jnz	short Splice_retn
 42405 000078C2 AD                      	LODSW                           ;           drive = (*s | 020) - 'a'+1;
 42406 000078C3 0C20                    	OR      AL,20h
 42407                                  	;sub	al,60h
 42408 000078C5 2C60                    	SUB     AL,'a'-1                ;           s += 2;
 42409 000078C7 75C7                    	jnz	short Splice_retn
 42410 000078C9 B0FF                    	MOV	AL,-1                   ; nuke AL...
 42411                                  	; 23/09/2023
 42412                                  	;dec	al ; -1
 42413 000078CB C3                      	retn				;           }
 42414                                  
 42415                                  ;Break   <TextFromDrive - convert a drive number to a text string>
 42416                                  ;----------------------------------------------------------------------------
 42417                                  ;   TextFromDrive - turn AL into a drive letter: and put it at es:di with
 42418                                  ;   trailing :. TextFromDrive1 takes a 1-based number.
 42419                                  ;
 42420                                  ;   Inputs:     AL has 0-based drive number
 42421                                  ;   Outputs:    ES:DI advanced
 42422                                  ;   Registers modified: AX
 42423                                  ;----------------------------------------------------------------------------
 42424                                  
 42425                                  TextFromDrive:
 42426 000078CC FEC0                    	INC     AL
 42427                                  TextFromDrive1:
 42428                                  	;add	al,40h
 42429 000078CE 0440                    	ADD     AL,'A'-1                ;   *d++ = drive-1+'A';
 42430 000078D0 B43A                    	MOV     AH,":"	; 3Ah           ;   strcat (d, ":");
 42431 000078D2 AB                      	STOSW
 42432                                  PathPref_retn:
 42433 000078D3 C3                      	retn
 42434                                  
 42435                                  ;Break   <PathPref - see if one path is a prefix of another>
 42436                                  ;----------------------------------------------------------------------------
 42437                                  ;   PathPref - compare DS:SI with ES:DI to see if one is the prefix of the
 42438                                  ;   other.  Remember that only at a pathchar break are we allowed to have a
 42439                                  ;   prefix: A:\ and A:\FOO
 42440                                  ;
 42441                                  ;   Inputs:     DS:SI potential prefix
 42442                                  ;               ES:DI string
 42443                                  ;   Outputs:    Zero set => prefix found
 42444                                  ;                   DI/SI advanced past matching part
 42445                                  ;               Zero reset => no prefix, DS/SI garbage
 42446                                  ;   Registers modified: CX
 42447                                  ;----------------------------------------------------------------------------
 42448                                  
 42449                                  PathPref:
 42450 000078D4 E8189F                  	call	DStrLen                 ; get length
 42451 000078D7 49                      	DEC     CX                      ; do not include nul byte
 42452 000078D8 F3A6                    	REPZ    CMPSB                   ; compare
 42453 000078DA 75F7                    	jnz	short PathPref_retn	; if NZ then return NZ
 42454 000078DC 50                      	push	ax			; save char register
 42455 000078DD 8A44FF                  	MOV     AL,[SI-1]               ; get last byte to match
 42456 000078E0 E897E1                  	call    PATHCHRCMP              ; is it a path char (Root!)
 42457 000078E3 7406                    	JZ	short Prefix		; yes, match root (I hope)
 42458                                  NotSep:                                 ; 2/13/KK
 42459 000078E5 268A05                  	MOV     AL,[ES:DI]		; get next char to match
 42460 000078E8 E878FE                  	CALL    PathSepGotCh            ; was it a pathchar?
 42461                                  Prefix:
 42462 000078EB 58                      	pop	ax			; get back original
 42463 000078EC C3                      	retn
 42464                                  
 42465                                  ;Break   <ScanPathChar - see if there is a path character in a string>
 42466                                  ;----------------------------------------------------------------------------
 42467                                  ;     ScanPathChar - search through the string (pointed to by DS:SI) for
 42468                                  ;     a path separator.
 42469                                  ;
 42470                                  ;     Input:    DS:SI target string (null terminated)
 42471                                  ;     Output:   Zero set => path separator encountered in string
 42472                                  ;               Zero clear => null encountered
 42473                                  ;     Registers modified: SI
 42474                                  ;----------------------------------------------------------------------------
 42475                                  
 42476                                  ScanPathChar:
 42477 000078ED AC                      	LODSB                           ; fetch a character
 42478 000078EE E872FE                  	call    PathSepGotCh
 42479 000078F1 75FA                    	JNZ	short ScanPathChar	; not \, / or NUL => go back for more
 42480                                  	;call	PATHCHRCMP              ; path separator?
 42481                                  	;retn
 42482                                  	; 18/12/2022
 42483 000078F3 E984E1                  	jmp	PATHCHRCMP
 42484                                  
 42485                                  ;============================================================================
 42486                                  ; FILE.ASM, MSDOS 6.0, 1991
 42487                                  ;============================================================================
 42488                                  ; 14/07/2018 - Retro DOS v3.0
 42489                                  
 42490                                  ; 13/05/2019 - Retro DOS v4.0
 42491                                  ; DOSCODE:AF10h (MSDOS 6.21, MSDOS.SYS)
 42492                                  
 42493                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42494                                  ; DOSCODE:AEADh (MSDOS 5.0, MSDOS.SYS)
 42495                                  
 42496                                  ; MSDOS 2.11
 42497                                  ;BREAK <$Open - open a file handle>
 42498                                  ;----------------------------------------------------------------------------
 42499                                  ;   Assembler usage:
 42500                                  ;           LDS     DX, Name
 42501                                  ;           MOV     AH, Open
 42502                                  ;           MOV     AL, access
 42503                                  ;           INT     int_command
 42504                                  ;
 42505                                  ;       ACCESS          Function
 42506                                  ;       ------          --------
 42507                                  ;       open_for_read   file is opened for reading
 42508                                  ;       open_for_write  file is opened for writing
 42509                                  ;       open_for_both   file is opened for both reading and writing.
 42510                                  ;
 42511                                  ;   Error returns:
 42512                                  ;           AX = error_invalid_access
 42513                                  ;              = error_file_not_found
 42514                                  ;              = error_access_denied
 42515                                  ;              = error_too_many_open_files
 42516                                  ;----------------------------------------------------------------------------
 42517                                  
 42518                                  ; MSDOS 6.0
 42519                                  ;	BREAK <$Open - open a file from a path string>
 42520                                  ;----------------------------------------------------------------------------
 42521                                  ;
 42522                                  ;**	$OPen - Open a File
 42523                                  ;
 42524                                  ;	given a path name in DS:DX and an open mode in AL, $Open opens the
 42525                                  ;	file and and returns a handle
 42526                                  ;
 42527                                  ;	ENTRY	(DS:DX) = pointer to asciz name
 42528                                  ;		(AL) = open mode
 42529                                  ;	EXIT	'C' clear if OK
 42530                                  ;		  (ax) = file handle
 42531                                  ;		'C' set if error
 42532                                  ;		  (ax) = error code
 42533                                  ;	USES	all
 42534                                  ;
 42535                                  ;----------------------------------------------------------------------------
 42536                                  
 42537                                  ; 13/05/2019 - Retro DOS v4.0
 42538                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42539                                  
 42540                                  _$OPEN:       
 42541 000078F6 30E4                    	xor	ah,ah  ; MSDOS 6.0	
 42542                                  _$Open2:
 42543                                  	;mov	ch,16h
 42544 000078F8 B516                    	mov	ch,attr_hidden+attr_system+attr_directory
 42545 000078FA E85702                  	call	SetAttrib
 42546 000078FD B9[2032]                	mov	cx,DOS_OPEN
 42547                                  
 42548                                  	;xor	ah,ah  ; MSDOS 3.3
 42549                                  
 42550 00007900 50                      	push	ax
 42551                                  
 42552                                  ;*	General file open/create code. The $CREATE call and the various
 42553                                  ;	$OPEN calls all come here.
 42554                                  ;
 42555                                  ;	We'll share a lot of the standard stuff of allocating SFTs, cracking
 42556                                  ;	path names, etc., and then dispatch to our individual handlers.
 42557                                  ;	WARNING - this info and list is just a guess, not definitive - jgl
 42558                                  ;
 42559                                  ;	(TOS) = create mode
 42560                                  ;	(CX) = address of routine to call to do actual function
 42561                                  ;	(DS:DX) = ASCIZ name
 42562                                  ;	SAttrib = Attribute mask
 42563                                  
 42564                                  ;	Get a free SFT and mark it "being allocated"
 42565                                  
 42566                                  AccessFile:
 42567 00007901 E8FF9F                  	call	ECritSFT
 42568 00007904 E8D8F7                  	call	SFNFree			; get a free sfn
 42569 00007907 E826A0                  	call	LCritSFT
 42570 0000790A 7214                    	jc	short OpenFailJ		; oops, no free sft's
 42571 0000790C 36891E[AA05]            	MOV	[SS:SFN],BX		; save the SFN for later;smr;SS Override
 42572 00007911 36893E[9E05]            	MOV	[SS:THISSFT],DI		; save the SF offset	;smr;SS Override
 42573 00007916 368C06[A005]            	MOV	[SS:THISSFT+2],ES	; save the SF segment	;smr;SS Override
 42574                                  
 42575                                  ;	Find a free area in the user's JFN table.
 42576                                  
 42577 0000791B E8AEF7                  	call	JFNFree			; get a free jfn
 42578 0000791E 7303                    	jnc	short SaveJFN
 42579                                  OpenFailJ:
 42580 00007920 E99300                  	JMP	OpenFail		; there were free JFNs... try SFN
 42581                                  
 42582                                  SaveJFN:
 42583 00007923 36893E[AE05]            	mov	[ss:PJFN],DI		; save the jfn offset	;smr;SS Override
 42584 00007928 368C06[B005]            	MOV	[ss:PJFN+2],ES		; save the jfn segment	;smr;SS Override
 42585 0000792D 36891E[AC05]            	MOV	[ss:JFN],BX		; save the jfn itself	;smr;SS Override
 42586                                  
 42587                                  ;	We have been given an JFN. We lock it down to prevent other tasks from
 42588                                  ;	reusing the same JFN.
 42589                                  
 42590 00007932 368B1E[AA05]            	MOV	BX,[ss:SFN]					;smr;SS Override
 42591 00007937 26881D                  	MOV	[ES:DI],BL		; assign the JFN
 42592 0000793A 89D6                    	MOV	SI,DX			; get name in appropriate place
 42593 0000793C BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 42594 0000793F 51                      	push	cx			; save routine to call
 42595 00007940 E844FC                  	call	TransPath		; convert the path
 42596 00007943 5B                      	pop	bx			; (bx) = routine to call
 42597                                  
 42598 00007944 36C536[9E05]            	LDS	SI,[SS:THISSFT]					;smr;SS Override
 42599 00007949 720A                    	JC	short OpenCleanJ	; no error, go and open file
 42600 0000794B 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1				;smr;SS Override
 42601 00007951 7404                    	JZ	short SetSearch
 42602                                  	;mov	al,2
 42603 00007953 B002                    	MOV	AL,error_file_not_found ; no meta chars allowed
 42604                                  OpenCleanJ:
 42605 00007955 EB50                    	JMP	short OpenClean
 42606                                  
 42607                                  SetSearch:
 42608 00007957 58                      	pop	ax			; Mode (Open), Attributes (Create)
 42609                                  
 42610                                  ;	We need to get the new inheritance bits.
 42611                                  
 42612 00007958 31C9                    	xor	cx,cx
 42613                                  	; MSDOS 6.0
 42614                                  	;mov	[si+2],cx ; 0
 42615 0000795A 894C02                  	MOV	[SI+SF_ENTRY.sf_mode],cx ; initialize mode field to 0
 42616                                  	;mov    [si+51],cx ; 0
 42617 0000795D 894C33                  	MOV	[SI+SF_ENTRY.sf_MFT],cx	 ; clean out sharing info
 42618                                  	;
 42619 00007960 81FB[2032]              	CMP	BX,DOS_OPEN
 42620 00007964 7509                    	JNZ	short _DoOper
 42621                                  	;test   al,80h
 42622 00007966 A880                    	test	AL,SHARING_NO_INHERIT	; look for no inher
 42623 00007968 7405                    	JZ	short _DoOper ; 10/08/2018
 42624 0000796A 247F                    	AND	AL,7Fh			; mask off inherit bit
 42625                                  	;mov	cx,1000h
 42626 0000796C B90010                  	MOV	CX,sf_no_inherit
 42627                                  _DoOper:
 42628                                  	;; MSDOS 3.3
 42629                                  	;;mov	word [si+2], 0
 42630                                  	;;mov	word [si+33h], 0
 42631                                  	;MOV	word [SI+SF_ENTRY.sf_mode],0
 42632                                  	;MOV	word [SI+SF_ENTRY.sf_MFT],0
 42633                                  
 42634                                  	; MSDOS 6.0
 42635                                  ;**	Check if this is an extended open. If so you must set the
 42636                                  ;	modes in sf_mode. Call Set_EXT_mode to do all this. See
 42637                                  ;	Set_EXT_mode in creat.asm
 42638                                  
 42639                                  	; MSDOS 6.0
 42640                                  	;SAVE	<di, es>                ;M022 conditional removed here
 42641 0000796F 57                      	push	di
 42642 00007970 06                      	push	es
 42643 00007971 1E                      	push	ds
 42644 00007972 07                      	pop	es
 42645 00007973 56                      	push	si
 42646 00007974 5F                      	pop	di			; (es:di) = SFT address
 42647 00007975 E894B8                  	call	Set_EXT_mode
 42648                                  	;RESTORE <es, di>
 42649 00007978 07                      	pop	es
 42650 00007979 5F                      	pop	di
 42651                                  
 42652                                  	;Context DS
 42653 0000797A 16                      	push	ss
 42654 0000797B 1F                      	pop	ds	
 42655                                  
 42656 0000797C 51                      	push	cx
 42657 0000797D FFD3                    	CALL	BX			; blam!
 42658 0000797F 59                      	pop	cx
 42659 00007980 C536[9E05]              	LDS	SI,[THISSFT]
 42660 00007984 721A                    	JC	short OpenE2		;AN000;FT. chek extended open hooks first
 42661                                  	;jc	short OpenE ; MSDOS 3.3
 42662                                  
 42663                                  ;	The SFT was successfully opened. Remove busy mark.
 42664                                  
 42665                                  OpenOK:
 42666                                  	;MOV	word [SI+SF_ENTRY.sf_ref_count],1
 42667 00007986 C7040100                	mov	word [SI],1
 42668                                  	;or	[SI+5],cx
 42669 0000798A 094C05                  	OR	[SI+SF_ENTRY.sf_flags],CX ; set no inherit bit if necessary
 42670                                  
 42671                                  ; If the open mode is 70, we scan the system for other SFT's with the same
 42672                                  ; contents. If we find one, then we can 'collapse' thissft onto the already
 42673                                  ; opened one. Otherwise we use this new one. We compare uid/pid/mode/mft
 42674                                  ;
 42675                                  ; Since this is only relevant on sharer systems, we stick this code into the
 42676                                  ; sharer.
 42677                                  
 42678 0000798D 36A1[AC05]              	MOV	AX,[ss:JFN]				;smr;SS Override
 42679 00007991 36FF1E[C000]            	Call	far [ss:JShare+(12*4)]	; 12 = ShCol	;smr;SS Override
 42680                                  
 42681 00007996 36C706[AA05]FFFF        	MOV	word [ss:SFN],-1	; clear out sfn pointer	;smr;SS Override
 42682                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42683                                  OpenOkj:
 42684 0000799D E9D08C                  	jmp	SYS_RET_OK		; bye with no errors
 42685                                  
 42686                                  	; MSDOS 6.0
 42687                                  ;Extended Open hooks check
 42688                                  OpenE2:					;AN000;;EO.
 42689 000079A0 83F857                  	CMP	AX,error_invalid_parameter ;AN000;;EO. IFS extended open ?
 42690 000079A3 7503                    	JNZ	short OpenE		;AN000;;EO. no.
 42691 000079A5 EB11                    	JMP	short OpenCritLeave	;AN000;;EO. keep handle
 42692                                  
 42693                                  ;	Extended Open hooks check
 42694                                  ;
 42695                                  ;	AL has error code.  Stack has argument to dos_open/dos_create.
 42696                                  
 42697                                  OpenClean:
 42698 000079A7 5B                      	pop	bx			; clean off stack
 42699                                  OpenE:
 42700                                  	;MOV	word [SI+SF_ENTRY.sf_ref_count],0 ; release SFT
 42701 000079A8 C7040000                	mov	word [SI],0
 42702 000079AC 36C536[AE05]            	LDS	SI,[ss:PJFN]		;smr;SS Override
 42703 000079B1 C604FF                  	MOV	BYTE [SI],0FFh		; free the SFN...
 42704 000079B4 EB02                    	JMP	SHORT OpenCritLeave
 42705                                  
 42706                                  OpenFail:
 42707 000079B6 FB                      	STI
 42708 000079B7 59                      	pop	cx			; Clean stack
 42709                                  OpenCritLeave:
 42710 000079B8 36C706[AA05]FFFF        	MOV	word [SS:SFN],-1	; remove mark.
 42711                                  
 42712                                  	; MSDOS 6.0
 42713                                  ; File Tagging DOS 4.00
 42714 000079BF 36833E[2403]25          	CMP	word [SS:EXTERR],error_Code_Page_Mismatched
 42715                                  					;AN000;;FT. code page mismatch
 42716 000079C5 7503                    	JNZ	short NORERR	  	;AN000;;FT. no
 42717 000079C7 E9B88C                  	jmp	From_GetSet		;AN000;;FT. yes
 42718                                  NORERR: 				;AN000;
 42719                                  ; File Tagging DOS 4.00
 42720                                  
 42721 000079CA E9AD8C                  	jmp	SYS_RET_ERR		; no free, return error
 42722                                  
 42723                                  ; MSDOS 2.11
 42724                                  ;BREAK <$CREAT - creat a new file and open him for input>
 42725                                  ;----------------------------------------------------------------------------
 42726                                  ;   Assembler usage:
 42727                                  ;           LDS     DX, name
 42728                                  ;           MOV     AH, Creat
 42729                                  ;           MOV     CX, access
 42730                                  ;           INT     21h
 42731                                  ;       ; AX now has the handle
 42732                                  ;
 42733                                  ;   Error returns:
 42734                                  ;           AX = error_access_denied
 42735                                  ;              = error_path_not_found
 42736                                  ;              = error_too_many_open_files
 42737                                  ;----------------------------------------------------------------------------
 42738                                  
 42739                                  ; MSDOS 6.0
 42740                                  ;	BREAK <$Creat - create a brand-new file>
 42741                                  ;----------------------------------------------------------------------------
 42742                                  ;
 42743                                  ;**	$Creat - Create a File
 42744                                  ;
 42745                                  ;	$Creat creates the directory entry specified in DS:DX and gives it the
 42746                                  ;	initial attributes contained in CX
 42747                                  ;
 42748                                  ;	ENTRY	(DS:DX) = ASCIZ path name
 42749                                  ;		(CX) = initial attributes
 42750                                  ;	EXIT	'C' set if error
 42751                                  ;		  (ax) = error code
 42752                                  ;		'C' clear if OK
 42753                                  ;		  (ax) = file handle
 42754                                  ;	USES	all
 42755                                  ;
 42756                                  ;----------------------------------------------------------------------------
 42757                                  
 42758                                  _$CREAT:
 42759 000079CD 51                      	push	cx			; Save attributes on stack
 42760 000079CE B9[EF30]                	mov	CX,DOS_CREATE		; routine to call
 42761                                  AccessSet:
 42762                                  	;mov	byte [ss:SATTRIB],6
 42763 000079D1 36C606[6D05]06          	mov	byte [ss:SATTRIB],attr_hidden+attr_system ;smr;SS Override
 42764                                  	; 10/08/2018
 42765 000079D7 E927FF                  	JMP	AccessFile		; use good ol' open
 42766                                  
 42767                                  ; MSDOS 6.0 (MSDOS 3.3)
 42768                                  ;	BREAK <$CHMOD - change file attributes>
 42769                                  ;----------------------------------------------------------------------------
 42770                                  ;
 42771                                  ;**	$CHMOD - Change File Attributes
 42772                                  ;
 42773                                  ;   Assembler usage:
 42774                                  ;	    LDS     DX, name
 42775                                  ;	    MOV     CX, attributes
 42776                                  ;	    MOV     AL,func (0=get, 1=set)
 42777                                  ;	    INT     21h
 42778                                  ;   Error returns:
 42779                                  ;	    AX = error_path_not_found
 42780                                  ;	    AX = error_access_denied
 42781                                  ;
 42782                                  ;----------------------------------------------------------------------------
 42783                                  
 42784                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42785                                  _$CHMOD:
 42786                                  	; 05/08/2018 - Retro DOS v3.0
 42787                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6FCCh ,
 42788 000079DA BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 42789 000079DD 50                      	push	ax
 42790 000079DE 51                      	push	cx			; save function and attributes
 42791 000079DF 89D6                    	MOV	SI,DX			; get things in appropriate places
 42792 000079E1 E8A7FB                  	call	TransPathSet		; get correct path
 42793 000079E4 59                      	pop	cx
 42794 000079E5 58                      	pop	ax			; and get function and attrs back
 42795 000079E6 7257                    	JC	short ChModErr		; errors get mapped to path not found
 42796 000079E8 16                      	push	ss			; set up for later possible calls
 42797 000079E9 1F                      	pop	ds
 42798 000079EA 803E[7A05]FF            	CMP	byte [CMETA],-1
 42799 000079EF 754E                    	JNZ	short ChModErr
 42800                                  	;mov	byte [SATTRIB],16h
 42801 000079F1 C606[6D05]16            	MOV	byte [SATTRIB],attr_hidden+attr_system+attr_directory
 42802 000079F6 2C01                    	SUB	AL,1			; fast way to discriminate
 42803 000079F8 720B                    	JB	short ChModGet		; 0 -> go get value
 42804 000079FA 7417                    	JZ	short ChModSet		; 1 -> go set value
 42805                                  	;mov	byte [EXTERR_LOCUS],1
 42806 000079FC C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 42807                                  	;mov	al,1
 42808 00007A01 B001                    	mov	al,error_invalid_function ; bad value
 42809                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42810                                  chmod_errj:	
 42811                                  	;;jmp	SYS_RET_ERR
 42812                                  	;jmp	short ChModE	
 42813 00007A03 EBC5                    	jmp	short NORERR	; 06/12/2022
 42814                                  ChModGet:
 42815 00007A05 E8E0B5                  	call	GET_FILE_INFO		; suck out the ol' info
 42816 00007A08 7237                    	JC	short ChModE		; error codes are already set for ret
 42817 00007A0A E86A8A                  	call	Get_User_Stack		; point to user saved vaiables
 42818                                  	;mov	[SI+4],ax
 42819 00007A0D 894404                  	MOV	[SI+user_env.user_CX],AX ; return the attributes
 42820                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility
 42821                                  OpenOkj2:
 42822                                  	; 17/12/2022
 42823                                  	;;jmp	SYS_RET_OK		; say sayonara
 42824                                  	;jmp	short OpenOkj
 42825                                  	; 25/06/2019
 42826 00007A10 E9608C                  	jmp	SYS_RET_OK_clc
 42827                                  
 42828                                  ChModSet:
 42829 00007A13 89C8                    	MOV	AX,CX			; get attrs in position
 42830 00007A15 E82EB6                  	call	SET_FILE_ATTRIBUTE	; go set
 42831 00007A18 7227                    	JC	short ChModE		; errors are set
 42832                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility
 42833                                  	;jmp	SYS_RET_OK
 42834                                  OpenOkj3:
 42835                                  	;jmp	short OpenOkj2
 42836                                  	; 17/12/2022
 42837 00007A1A E9538C                  	jmp	SYS_RET_OK
 42838                                  
 42839                                  ; 17/12/2022
 42840                                  %if 0
 42841                                  ChModErr:
 42842                                  NotFound:	; 17/12/2022
 42843                                  	;mov	al,3
 42844                                  	mov	al,error_path_not_found
 42845                                  ChModE:
 42846                                  UnlinkE:	; 17/12/2022
 42847                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42848                                  	;;jmp	SYS_RET_ERR
 42849                                  	;jmp	short chmod_errj
 42850                                  	; 17/12/2022
 42851                                  	jmp	short NORERR
 42852                                  %endif
 42853                                  
 42854                                  ; 22/05/2019 - Retro DOS v4.0
 42855                                  ; DOSCODE:B039h (MSDOS 6.21, MSDOS.SYS)
 42856                                  
 42857                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42858                                  ; DOSCODE:AFD6h (MSDOS 5.0, MSDOS.SYS)
 42859                                  
 42860                                  ;	BREAK <$UNLINK - delete a file entry>
 42861                                  ;----------------------------------------------------------------------------
 42862                                  ;
 42863                                  ;**	$UNLINK - Delete a File
 42864                                  ;
 42865                                  ;
 42866                                  ;	Assembler usage:
 42867                                  ;	    LDS     DX, name
 42868                                  ;	    IF VIA SERVER DOS CALL
 42869                                  ;	     MOV     CX,SEARCH_ATTRIB
 42870                                  ;	    MOV     AH, Unlink
 42871                                  ;	    INT     21h
 42872                                  ;
 42873                                  ;	ENTRY	(ds:dx) = path name
 42874                                  ;		(cx) = search_attribute, if via server_dos
 42875                                  ;	EXIT	'C' clear if no error
 42876                                  ;		'C' set if error
 42877                                  ;		  (ax) = error code
 42878                                  ;			= error_file_not_found
 42879                                  ;			= error_access_denied
 42880                                  ;
 42881                                  ;----------------------------------------------------------------------------
 42882                                  
 42883                                  _$UNLINK:
 42884 00007A1D 51                      	push	cx			; Save possible CX input parm
 42885 00007A1E 89D6                    	MOV	SI,DX			; Point at input string
 42886 00007A20 BF[BE03]                	MOV	DI,OPENBUF		; temp spot for path
 42887 00007A23 E865FB                  	call	TransPathSet		; go get normalized path
 42888 00007A26 59                      	pop	cx
 42889 00007A27 7216                    	JC	short ChModErr		; badly formed path
 42890 00007A29 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1	; meta chars?	;smr;SS Override
 42891 00007A2F 750E                    	JNZ	short NotFound
 42892 00007A31 16                      	push	ss
 42893 00007A32 1F                      	pop	ds
 42894                                  	;mov	ch,6
 42895 00007A33 B506                    	mov	ch,attr_hidden+attr_system ; unlink appropriate files
 42896 00007A35 E81C01                  	call	SetAttrib
 42897 00007A38 E84EB1                  	call	DOS_DELETE		; remove that file
 42898                                  	;JC	short UnlinkE 		; error is there
 42899                                  	; 17/12/2022
 42900 00007A3B 728D                    	jc	short NORERR
 42901                                  
 42902                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42903                                  UnlinkOk:
 42904                                  	;jmp	SYS_RET_OK		; okey doksy
 42905 00007A3D EBDB                    	jmp	short OpenOkj3
 42906                                  
 42907                                  	; 17/12/2022
 42908                                  ChModErr:	; 17/12/2022
 42909                                  NotFound:
 42910                                  	;mov	al,3
 42911 00007A3F B003                    	MOV	AL,error_path_not_found
 42912                                  ChModE:		; 17/12/2022
 42913                                  UnlinkE:
 42914                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42915                                  	;;jmp	SYS_RET_ERR		; bye
 42916                                  	;jmp	short ChModE
 42917                                  	; 17/12/2022
 42918 00007A41 EB87                    	jmp	short NORERR
 42919                                  
 42920                                  ;BREAK <$RENAME - move directory entries around>
 42921                                  ;----------------------------------------------------------------------------
 42922                                  ;
 42923                                  ;   Assembler usage:
 42924                                  ;	    LDS     DX, source
 42925                                  ;	    LES     DI, dest
 42926                                  ;	    IF VIA SERVER DOS CALL
 42927                                  ;	      MOV   CX,SEARCH_ATTRIB
 42928                                  ;	    MOV     AH, Rename
 42929                                  ;	    INT     21h
 42930                                  ;
 42931                                  ;   Error returns:
 42932                                  ;	    AX = error_file_not_found
 42933                                  ;	       = error_not_same_device
 42934                                  ;	       = error_access_denied
 42935                                  ;
 42936                                  ;----------------------------------------------------------------------------
 42937                                  
 42938                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42939                                  _$RENAME:
 42940                                  	; MSDOS 3.3 (& MSDOS 6.0)
 42941 00007A43 51                      	push	cx
 42942 00007A44 1E                      	push	ds
 42943 00007A45 52                      	push	dx			; save source and possible CX arg
 42944 00007A46 06                      	PUSH	ES
 42945 00007A47 1F                      	POP	DS			; move dest to source
 42946 00007A48 89FE                    	MOV	SI,DI			; save for offsets
 42947 00007A4A BF[3E04]                	MOV	DI,RENBUF
 42948 00007A4D E83BFB                  	call	TransPathSet		; munge the paths
 42949 00007A50 36FF36[B205]            	PUSH	word [ss:WFP_START]	; get pointer	;smr;SS Override
 42950 00007A55 368F06[B405]            	POP	word [ss:REN_WFP]	; stash it	;smr;SS Override
 42951 00007A5A 5E                      	pop	si
 42952 00007A5B 1F                      	pop	ds
 42953 00007A5C 59                      	pop	cx			; get back source and possible CX arg
 42954                                  epjc2:	
 42955 00007A5D 72E0                    	JC	short ChModErr		; get old error
 42956 00007A5F 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1			;smr;SS Override
 42957 00007A65 75D8                    	JNZ	short NotFound
 42958 00007A67 51                      	push	cx			; Save possible CX arg
 42959 00007A68 BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 42960 00007A6B E81DFB                  	call	TransPathSet		; wham
 42961 00007A6E 59                      	pop	cx
 42962 00007A6F 72EC                    	JC	short epjc2
 42963 00007A71 16                      	push	ss
 42964 00007A72 1F                      	pop	ds
 42965 00007A73 803E[7A05]FF            	CMP	byte [CMETA],-1
 42966 00007A78 72C5                    	JB	short NotFound
 42967                                  
 42968                                  	; MSDOS 6.0
 42969 00007A7A FF36[A205]              	PUSH	WORD [THISCDS]		   ;AN000;;MS.save thiscds
 42970 00007A7E FF36[A405]              	PUSH	WORD [THISCDS+2]	   ;AN000;;MS.
 42971 00007A82 BF[BE03]                	MOV	DI,OPENBUF		   ;AN000;;MS.
 42972 00007A85 16                      	PUSH	SS			   ;AN000;;MS.
 42973 00007A86 07                      	POP	ES			   ;AN000;;MS.es:di-> source
 42974 00007A87 30C0                    	XOR	AL,AL			   ;AN000;;MS.scan all CDS
 42975                                  rnloop: 				   ;AN000;
 42976 00007A89 E879FA                  	call	GetCDSFromDrv		   ;AN000;;MS.
 42977 00007A8C 7210                    	JC	short dorn		   ;AN000;;MS.	end of CDS
 42978 00007A8E E8169D                  	call	StrCmp			   ;AN000;;MS.	current dir ?
 42979 00007A91 7404                    	JZ	short rnerr		   ;AN000;;MS.	yes
 42980 00007A93 FEC0                    	INC	AL			   ;AN000;;MS.	next
 42981 00007A95 EBF2                    	JMP	short rnloop		   ;AN000;;MS.
 42982                                  rnerr:					   ;AN000;
 42983 00007A97 83C404                  	ADD	SP,4			   ;AN000;;MS. pop thiscds
 42984                                  	;error	error_current_directory    ;AN000;;MS.
 42985 00007A9A B010                    	mov	al,error_current_directory 
 42986                                  	;jmp	SYS_RET_ERR
 42987                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42988 00007A9C EBA3                    	jmp	short UnlinkE
 42989                                  dorn:					   ;AN000;
 42990 00007A9E 368F06[A405]            	POP	WORD [SS:THISCDS+2]	   ;AN000;;MS.;PBUGBUG;SS REQD??
 42991 00007AA3 368F06[A205]            	POP	WORD [SS:THISCDS]	   ;AN000;;MS.;PBUGBUG;SS REQD??
 42992                                  
 42993 00007AA8 16                      	push	ss
 42994 00007AA9 1F                      	pop	ds
 42995                                  
 42996                                  	; MSDOS 3.3 (& MSDOS 6.0)
 42997                                  	;mov	ch,16h
 42998 00007AAA B516                    	mov	ch,attr_directory+attr_hidden+attr_system
 42999                                  					; rename appropriate files
 43000 00007AAC E8A500                  	call	SetAttrib
 43001 00007AAF E8EAB2                  	call	DOS_RENAME		; do the deed
 43002 00007AB2 728D                    	JC	short UnlinkE 		; errors
 43003                                  
 43004                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43005                                  	;jmp	SYS_RET_OK
 43006 00007AB4 EB87                    	jmp	short UnlinkOk
 43007                                  
 43008                                  
 43009                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43010                                  
 43011                                  ; 14/07/2018 - Retro DOS v3.0
 43012                                  ; MSDOS 3.3 (& MSDOS 6.0)
 43013                                  
 43014                                  ;Break <$CreateNewFile - Create a new directory entry>
 43015                                  ;----------------------------------------------------------------------------
 43016                                  ;   CreateNew - Create a new directory entry.  Return a file handle if there
 43017                                  ;	was no previous directory entry, and fail if a directory entry with
 43018                                  ;	the same name existed previously.
 43019                                  ;
 43020                                  ;   Inputs:	DS:DX point to an ASCIZ file name
 43021                                  ;		CX contains default file attributes
 43022                                  ;   Outputs:	Carry Clear:
 43023                                  ;		    AX has file handle opened for read/write
 43024                                  ;		Carry Set:
 43025                                  ;		    AX has error code
 43026                                  ;   Registers modified: All
 43027                                  ;----------------------------------------------------------------------------
 43028                                  
 43029                                  _$CreateNewFile:
 43030 00007AB6 51                      	push	cx			; Save attributes on stack
 43031 00007AB7 B9[B631]                	MOV	CX,DOS_Create_New	; routine to call
 43032 00007ABA E914FF                  	JMP	AccessSet		; use good ol' open
 43033                                  
 43034                                  ;**	BinToAscii - convert a number to a string.
 43035                                  ;----------------------------------------------------------------------------
 43036                                  ;	BinToAscii converts a 16 bit number into a 4 ascii characters.
 43037                                  ;	This routine is used to generate temp file names so we don't spend
 43038                                  ;	the time and code needed for a true hex number, we just use
 43039                                  ;	A thorugh O.
 43040                                  ;
 43041                                  ;	ENTRY	(ax) = value
 43042                                  ;		(es:di) = destination
 43043                                  ;	EXIT	(es:di) updated by 4
 43044                                  ;	USES	cx, di, flags
 43045                                  ;----------------------------------------------------------------------------
 43046                                  
 43047                                  ; MSDOS 3.3
 43048                                  ;BinToAscii:
 43049                                  ;	mov     cx,4
 43050                                  ;bta5:
 43051                                  ;	push    cx
 43052                                  ;	mov     cl,4
 43053                                  ;	rol     ax,cl
 43054                                  ;	push    ax
 43055                                  ;	and     al,0Fh
 43056                                  ;	add     al,'0'
 43057                                  ;	cmp     al,'9'
 43058                                  ;	jbe     short bta6
 43059                                  ;	add     al,7
 43060                                  ;bta6: 
 43061                                  ;	stosb
 43062                                  ;	pop     ax
 43063                                  ;	pop     cx
 43064                                  ;	loop    bta5
 43065                                  ;	retn
 43066                                  
 43067                                  ; MSDOS 6.0
 43068                                  BinToAscii:
 43069 00007ABD B90404                  	mov	cx,404h			; (ch) = digit counter, (cl) = shift cnt
 43070                                  bta5:	
 43071 00007AC0 D3C0                    	ROL	AX,CL			; move leftmost nibble into rightmost
 43072 00007AC2 50                      	push	ax			; preserve remainder of digits
 43073 00007AC3 240F                    	AND	AL,0Fh			; grab low nibble
 43074 00007AC5 0441                    	ADD	AL,'A'			; turn into ascii
 43075 00007AC7 AA                      	STOSB				; drop in the character
 43076 00007AC8 58                      	pop	ax			; (ax) = shifted number
 43077 00007AC9 FECD                    	dec	ch
 43078 00007ACB 75F3                    	jnz	short bta5		; process 4 digits
 43079 00007ACD C3                      	retn
 43080                                  
 43081                                  ;Break	<$CreateTempFile - create a unique name>
 43082                                  ;----------------------------------------------------------------------------
 43083                                  ;   $CreateTemp - given a directory, create a unique name in that directory.
 43084                                  ;	Method used is to get the current time, convert to a name and attempt
 43085                                  ;	a create new. Repeat until create new succeeds.
 43086                                  ;
 43087                                  ;   Inputs:	DS:DX point to a null terminated directory name.
 43088                                  ;		CX  contains default attributes
 43089                                  ;   Outputs:	Unique name is appended to DS:DX directory.
 43090                                  ;		AX has handle
 43091                                  ;   Registers modified: all
 43092                                  ;----------------------------------------------------------------------------
 43093                                  
 43094                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43095                                  
 43096                                  _$CreateTempFile:
 43097                                  	;Enter
 43098 00007ACE 55                      	push	bp
 43099 00007ACF 89E5                    	mov	bp,sp
 43100                                  
 43101                                  	;LocalVar  EndPtr,DWORD
 43102                                  	;LocalVar  FilPtr,DWORD
 43103                                  	;LocalVar  Attr,WORD
 43104                                  
 43105 00007AD1 83EC0A                  	sub	sp,10
 43106                                  
 43107                                  	;test	cx,0FFD8h
 43108 00007AD4 F7C1D8FF                	test	CX,~attr_changeable
 43109 00007AD8 7405                    	JZ	short OKatts		; Ok if no non-changeable bits set
 43110                                  
 43111                                  ; We need this "hook" here to detect these cases (like user sets one both of
 43112                                  ; vol_id and dir bits) because of the structure of the or $CreateNewFile loop
 43113                                  ; below. The code loops on error_access_denied, but if one of the non
 43114                                  ; changeable attributes is specified, the loop COULD be infinite or WILL be
 43115                                  ; infinite because CreateNewFile will fail with access_denied always. Thus we
 43116                                  ; need to detect these cases before getting to the loop.
 43117                                  
 43118                                  	;mov	ax, 5
 43119 00007ADA B80500                  	MOV	AX,error_access_denied
 43120 00007ADD EB69                    	JMP	SHORT SETTMPERR
 43121                                  
 43122                                  OKatts:
 43123                                  	;MOV	attr,CX 		; save attribute
 43124 00007ADF 894EF6                  	mov     [bp-10],cx
 43125                                  	;MOV	FilPtrL,DX		; pointer to file
 43126 00007AE2 8956F8                  	mov	[bp-8],dx
 43127                                  	;MOV	FilPtrH,DS
 43128 00007AE5 8C5EFA                  	mov	[bp-6],ds
 43129                                  	;MOV	EndPtrH,DS		; seg pointer to end of dir
 43130 00007AE8 8C5EFE                  	mov	[bp-2],ds
 43131 00007AEB 1E                      	PUSH	DS
 43132 00007AEC 07                      	POP	ES			; destination for nul search
 43133 00007AED 89D7                    	MOV	DI,DX
 43134 00007AEF 89F9                    	MOV	CX,DI
 43135 00007AF1 F7D9                    	NEG	CX			; number of bytes remaining in segment
 43136                                  	; MSDOS 6.0
 43137 00007AF3 09C9                    	OR	CX,CX			;AN000;MS. cx=0 ? ds:dx on segment boundary
 43138 00007AF5 7501                    	JNZ	short okok		;AN000;MS. no
 43139                                  	;MOV	CX,-1			;AN000;MS.
 43140                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43141                                  	; 17/12/2022
 43142 00007AF7 49                      	dec	cx  ; mov cx,-1
 43143                                  	;mov	cx,-1 ; 0FFFh
 43144                                  okok:					;AN000;
 43145 00007AF8 31C0                    	XOR	AX,AX			;AN000;
 43146 00007AFA F2AE                    	REPNZ	SCASB			;AN000;
 43147                                  					;AN000;
 43148 00007AFC 4F                      	DEC	DI			; point back to the null
 43149 00007AFD 268A45FF                	MOV	AL,[ES:DI-1]		; Get char before the NUL
 43150 00007B01 E876DF                  	call	PATHCHRCMP		; Is it a path separator?
 43151 00007B04 7403                    	JZ	short SETENDPTR		; Yes
 43152                                  STOREPTH:
 43153 00007B06 B05C                    	MOV	AL,'\'
 43154 00007B08 AA                      	STOSB				; Add a path separator (and INC DI)
 43155                                  SETENDPTR:
 43156                                  	;MOV	EndPtrL,DI		; pointer to the tail
 43157 00007B09 8856FC                  	mov	[bp-4],dl
 43158                                  CreateLoop:
 43159 00007B0C 16                      	push	ss			; let ReadTime see variables
 43160 00007B0D 1F                      	pop	ds
 43161 00007B0E 55                      	push	bp
 43162 00007B0F E88490                  	call	READTIME		; go get time
 43163 00007B12 5D                      	pop	bp
 43164                                  ;
 43165                                  ; Time is in CX:DX. Go drop it into the string.
 43166                                  ;
 43167                                  	;les	di,EndPtr		; point to the string
 43168 00007B13 C47EFC                  	les	di,[BP-4]
 43169 00007B16 89C8                    	mov	ax,cx
 43170 00007B18 E8A2FF                  	call	BinToAscii		; store upper word
 43171 00007B1B 89D0                    	mov	ax,dx
 43172 00007B1D E89DFF                  	call	BinToAscii		; store lower word
 43173 00007B20 30C0                    	xor	al,al
 43174 00007B22 AA                      	STOSB				; nul terminate
 43175                                  	;LDS	DX,FilPtr		; get name
 43176 00007B23 C556F8                  	lds	dx,[bp-8]
 43177                                  	;MOV	CX,Attr 		; get attr
 43178 00007B26 8B4EF6                  	mov	cx,[bp-10]
 43179 00007B29 55                      	push	bp
 43180 00007B2A E889FF                  	CALL	_$CreateNewFile		; try to create a new file
 43181 00007B2D 5D                      	pop	bp
 43182 00007B2E 7319                    	JNC	short CreateDone	; failed, go try again
 43183                                  
 43184                                  ; The operation failed and the error has been mapped in AX. Grab the extended
 43185                                  ; error and figure out what to do.
 43186                                  
 43187                                  	;; MSDOS 3.3			; M049 - start
 43188                                  ;;	mov	ax,[ss:EXTERR]				;smr;SS Override
 43189                                  ;;	cmp	al,error_file_exists
 43190                                  ;;	jz	short CreateLoop	; file existed => try with new name
 43191                                  ;;	cmp	al,error_access_denied
 43192                                  ;;	jz	short CreateLoop	; access denied (attr mismatch)
 43193                                  
 43194                                  	; MSDOS 6.0
 43195                                  	;cmp	al,50h
 43196 00007B30 3C50                    	CMP	AL,error_file_exists	; Q: did file already exist
 43197 00007B32 74D8                    	JZ	short CreateLoop	; Y: try again
 43198                                  	;cmp	al,5
 43199 00007B34 3C05                    	CMP	AL,error_access_denied	; Q: was it access denied
 43200 00007B36 7510                    	JNZ	short SETTMPERR		; N: Error out
 43201                                  					; Y: Check to see if we got this due
 43202                                  					;    to the network drive. Note that
 43203                                  					;    the redir will set the exterr
 43204                                  					;    to error_cannot_make if this is 
 43205                                  					;    so. 
 43206 00007B38 36803E[2403]41          	CMP	byte [SS:EXTERR],error_net_access_denied ; M069
 43207                                  					; See if it's REALLY an att mismatch
 43208 00007B3E 7408                    	je	short SETTMPERR		; no, network error, stop
 43209                                  ;M070
 43210                                  ; If the user failed on an I24, we do not want to try again
 43211                                  ;
 43212 00007B40 36803E[2403]53          	cmp	byte [SS:EXTERR],error_FAIL_I24 ;User failed on I24? ;M070
 43213                                  	;je	short SETTMPERR		;yes, do not try again ;M070
 43214                                  
 43215                                  	;jmp	short CreateLoop	;attr mismatch, try again ;M070
 43216                                  	; 17/12/2022
 43217 00007B46 75C4                    	jne	short CreateLoop ; 10/06/2019 
 43218                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43219                                  	;jz	short SETTMPERR
 43220                                  	;jmp	short CreateLoop
 43221                                  
 43222                                  ;;	MOV	AL,error_access_denied	; Return this "extended" error
 43223                                  					; M049 - end
 43224                                  SETTMPERR:
 43225 00007B48 F9                      	STC
 43226                                  CreateDone:
 43227                                  	;Leave
 43228 00007B49 89EC                    	mov	sp,bp
 43229 00007B4B 5D                      	pop	bp
 43230 00007B4C 7203                    	JC	short CreateFail
 43231 00007B4E E91F8B                  	jmp	SYS_RET_OK		; success!
 43232                                  CreateFail:
 43233 00007B51 E9268B                  	jmp	SYS_RET_ERR
 43234                                  
 43235                                  ;   SetAttrib will set the search attribute (SAttrib) either to the normal
 43236                                  ;   (CH) or to the value in CL if the current system call is through
 43237                                  ;   serverdoscall.
 43238                                  ;
 43239                                  ;   Inputs:	fSharing == FALSE => set sattrib to CH
 43240                                  ;		fSharing == TRUE => set sattrib to CL
 43241                                  ;   Outputs:	none
 43242                                  ;   Registers changed:	CX
 43243                                  
 43244                                  SetAttrib:
 43245 00007B54 36F606[7205]FF          	test	byte [SS:FSHARING],-1		;smr;SS Override
 43246 00007B5A 7502                    	jnz	short Set
 43247 00007B5C 88E9                    	mov	cl,ch
 43248                                  Set:
 43249 00007B5E 36880E[6D05]            	mov	byte [ss:SATTRIB],cl		;smr;SS Override
 43250 00007B63 C3                      	retn
 43251                                  
 43252                                  ; 14/07/2018 - Retro DOS v3.0
 43253                                  ; MSDOS 6.0
 43254                                  
 43255                                  ; 29/04/2019 - Retro DOS v4.0
 43256                                  
 43257                                  ;Break	<Extended_Open- Extended open the file>
 43258                                  ;----------------------------------------------------------------------------
 43259                                  ; Input: AL= 0 reserved  AH=6CH
 43260                                  ;	 BX= mode
 43261                                  ;	 CL= create attribute  CH=search attribute (from server)
 43262                                  ;	 DX= flag
 43263                                  ;	 DS:SI = file name
 43264                                  ;	 ES:DI = parm list
 43265                                  ;			   DD  SET EA list (-1) null
 43266                                  ;			   DW  n  parameters
 43267                                  ;			   DB  type (TTTTTTLL)
 43268                                  ;			   DW  IOMODE
 43269                                  ; Function: Extended Open
 43270                                  ; Output: carry clear
 43271                                  ;		     AX= handle
 43272                                  ;		     CX=1 file opened
 43273                                  ;			2 file created/opened
 43274                                  ;			3 file replaced/opened
 43275                                  ;	  carry set: AX has error code
 43276                                  ;----------------------------------------------------------------------------
 43277                                  
 43278                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43279                                  _$Extended_Open:			  ;AN000;
 43280                                  	;ASSUME	CS:DOSCODE,SS:DOSDATA	  ;AN000;
 43281 00007B64 368916[F405]            	MOV	[SS:EXTOPEN_FLAG],DX	  ;AN000;EO. save ext. open flag;smr;SS Override
 43282 00007B69 36C706[F705]0000        	MOV	word [SS:EXTOPEN_IO_MODE],0 ;AN000;EO. initialize IO mode;smr;SS Override
 43283                                  	; 17/12/2022
 43284 00007B70 F6C6FE                  	test	dh,0FEh ; 04/12/2022 
 43285                                  	;;test	dx,0FE00h
 43286                                  	;TEST	DX,RESERVED_BITS_MASK	  ;AN000;EO. reserved bits 0  ?
 43287 00007B73 7545                    	JNZ	short ext_inval2	  ;AN000;EO. no
 43288 00007B75 88D4                    	MOV	AH,DL			  ;AN000;EO. make sure flag is right
 43289 00007B77 80FA00                  	CMP	DL,0			  ;AN000;EO. all fail ?
 43290 00007B7A 743E                    	JZ	short ext_inval2	  ;AN000;EO. yes, error
 43291                                  	;and	dl,0Fh
 43292 00007B7C 80E20F                  	AND	DL,EXISTS_MASK		  ;AN000;EO. get exists action byte
 43293 00007B7F 80FA02                  	CMP	DL,2			  ;AN000;EO, > 02
 43294 00007B82 7736                    	JA	short ext_inval2	  ;AN000;EO. yes ,error
 43295                                  	;and	ah,0F0h
 43296 00007B84 80E4F0                  	AND	AH,NOT_EXISTS_MASK	  ;AN000;EO. get no exists action byte
 43297 00007B87 80FC10                  	CMP	AH,10H			  ;AN000;EO. > 10
 43298 00007B8A 772E                    	JA	short ext_inval2	  ;AN000;EO. yes error
 43299                                  
 43300 00007B8C 368C06[FB05]            	MOV	[SS:SAVE_ES],ES		  ;AN000;EO. save API parms;smr;SS Override
 43301 00007B91 36893E[F905]            	MOV	[SS:SAVE_DI],DI		  ;AN000;EO.;smr;SS Override
 43302 00007B96 36FF36[F405]            	PUSH	word [SS:EXTOPEN_FLAG]	  ;AN000;EO.;smr;SS Override
 43303 00007B9B 368F06[FD05]            	POP	word [SS:SAVE_DX]	  ;AN000;EO.;smr;SS Override
 43304 00007BA0 36890E[FF05]            	MOV	[SS:SAVE_CX],CX		  ;AN000;EO.;smr;SS Override
 43305 00007BA5 36891E[0106]            	MOV	[SS:SAVE_BX],BX		  ;AN000;EO.;smr;SS Override
 43306 00007BAA 368C1E[0506]            	MOV	[SS:SAVE_DS],DS		  ;AN000;EO.;smr;SS Override
 43307 00007BAF 368936[0306]            	MOV	[SS:SAVE_SI],SI		  ;AN000;EO.;smr;SS Override
 43308 00007BB4 89F2                    	MOV	DX,SI			  ;AN000;EO. ds:dx points to file name
 43309 00007BB6 89D8                    	MOV	AX,BX			  ;AN000;EO. ax= mode
 43310 00007BB8 EB0A                    	JMP	SHORT goopen2		  ;AN000;;EO. do normal
 43311                                  ext_inval2:				  ;AN000;;EO.
 43312                                  	;mov	al,1
 43313 00007BBA B001                    	mov	al,error_invalid_function ;AN000;EO.. invalid function
 43314                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43315                                  eo_err:
 43316                                  	;jmp	SYS_RET_ERR
 43317 00007BBC EB93                    	jmp	short CreateFail
 43318                                  
 43319                                  ext_inval_parm:				  ;AN000;EO..
 43320 00007BBE 59                      	POP	CX			  ;AN000;EO..  pop up satck
 43321 00007BBF 5E                      	POP	SI			  ;AN000;EO..
 43322                                  	;error	error_invalid_data	  ;AN000;EO..  invalid parms
 43323                                  	;mov	al,13
 43324 00007BC0 B00D                    	mov	al,error_invalid_data
 43325                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43326                                  	;;jmp	SYS_RET_ERR
 43327                                  	;jmp	short eo_err
 43328                                  	; 17/12/2022
 43329 00007BC2 EB8D                    	jmp	short CreateFail
 43330                                  
 43331                                  	; 17/12/2022	
 43332                                  ;error_return:				  ;AN000;EO.
 43333                                  ;	retn				  ;AN000;EO.. return with error
 43334                                  
 43335                                  goopen2:				  ;AN000;
 43336                                  	; 17/12/2022
 43337                                  	;test	bh,20h				 
 43338 00007BC4 F6C720                  	test	bh,INT_24_ERROR>>8 ; 04/12/2022
 43339                                  	;;test	bx,2000h
 43340                                  	;TEST	BX,INT_24_ERROR		  ;AN000;EO.. disable INT 24 error ?
 43341 00007BC7 7406                    	JZ	short goopen		  ;AN000;EO.. no
 43342                                  	;or	byte [SS:EXTOPEN_ON],2
 43343 00007BC9 36800E[F605]02          	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_I24_OFF ;AN000;EO.. set bit to disable;smr;SS Override
 43344                                  goopen:					  ;AN000;
 43345                                  	;or	byte [SS:EXTOPEN_ON],1 
 43346 00007BCF 36800E[F605]01          	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_ON  ;AN000;EO.. set Extended Open active;smr;SS Override
 43347                                  	;AND	word [SS:EXTOPEN_FLAG],0FFh  ;AN000;EO.create new ?;smr;SS Override
 43348                                  	; 18/12/2022
 43349 00007BD5 36C606[F505]00          	mov	byte [SS:EXTOPEN_FLAG+1],0 ; AND word [SS:EXTOPEN_FLAG],0FFh
 43350                                  	;cmp	word [SS:EXTOPEN_FLAG],10h
 43351 00007BDB 36833E[F405]10          	CMP	word [SS:EXTOPEN_FLAG],EXT_EXISTS_FAIL+EXT_NEXISTS_CREATE ;AN000;FT.;smr;SS Override
 43352 00007BE1 7516                    	JNZ	short chknext 		  ;AN000;;EO. no
 43353 00007BE3 E8D0FE                  	call	_$CreateNewFile		  ;AN000;;EO. yes
 43354 00007BE6 723F                    	JC	short error_return	  ;AN000;;EO. error
 43355                                  
 43356 00007BE8 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
 43357 00007BEE 7438                    	JZ	short ok_return2	  ;AN000;;EO. yes
 43358                                  	;mov	word [SS:EXTOPEN_FLAG],2
 43359 00007BF0 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED ;AN000;EO. creted/opened;smr;SS Override
 43360 00007BF7 EB7F                    	JMP	setXAttr		  ;AN000;;EO. set XAs
 43361                                  
 43362                                  	; 17/12/2022
 43363                                  ;ok_return2:
 43364                                  ;	jmp	SYS_RET_OK		  ;AN000;;EO.
 43365                                  
 43366                                  chknext:
 43367                                  	; 17/12/2022
 43368 00007BF9 36F606[F405]01          	test	byte [SS:EXTOPEN_FLAG],EXT_EXISTS_OPEN ; 1
 43369                                  	;;test	word [SS:EXTOPEN_FLAG],1
 43370                                  	;TEST	word [SS:EXTOPEN_FLAG],EXT_EXISTS_OPEN ;AN000;;EO. exists open;smr;SS Override
 43371 00007BFF 752A                    	JNZ	short exist_open	  ;AN000;;EO. yes
 43372 00007C01 E8C9FD                  	call	_$CREAT			  ;AN000;;EO. must be replace open
 43373 00007C04 7221                    	JC	short error_return	  ;AN000;;EO. return with error
 43374 00007C06 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
 43375 00007C0C 741A                    	JZ	short ok_return2	  ;AN000;;EO. yes
 43376 00007C0E 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED ;AN000;EO. prsume create/open;smr;SS Override
 43377 00007C15 36F606[F605]04          	TEST	byte [SS:EXTOPEN_ON],EXT_FILE_NOT_EXISTS ;AN000;;EO. file not exists ?;smr;SS Override
 43378 00007C1B 755B                    	JNZ	short setXAttr		  ;AN000;;EO. no
 43379 00007C1D 36C706[F405]0300        	MOV	word [SS:EXTOPEN_FLAG],ACTION_REPLACED_OPENED ;AN000;;EO. replaced/opened;smr;SS Override
 43380 00007C24 EB52                    	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
 43381                                  error_return2:
 43382 00007C26 F9                      	STC 				  ; Set Carry again to flag error ;AN001;
 43383                                  error_return:	 ;17/12/2022
 43384 00007C27 C3                      	retn				  ;AN000;;EO. return with error
 43385                                  
 43386                                  	; 17/12/2022
 43387                                  ok_return:
 43388                                  ok_return2:
 43389 00007C28 E9458A                  	jmp	SYS_RET_OK
 43390                                  
 43391                                  exist_open:				  ;AN000;
 43392 00007C2B 36F606[7205]FF          	test	byte [SS:FSHARING],-1	  ;AN000;;EO. server doscall?;smr;SS Override
 43393 00007C31 7402                    	jz	short noserver		  ;AN000;;EO. no
 43394 00007C33 88E9                    	MOV	CL,CH			  ;AN000;;EO. cl=search attribute
 43395                                  noserver:
 43396 00007C35 E8C0FC                  	call	_$Open2			  ;AN000;;EO. do open
 43397 00007C38 732F                    	JNC	short ext_ok		  ;AN000;;EO.
 43398 00007C3A 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. error and IFS call;smr;SS Override
 43399 00007C40 74E4                    	JZ	short error_return2	  ;AN000;;EO. return with error
 43400                                  local_extopen:
 43401                                  	;cmp	ax,2
 43402 00007C42 83F802                  	CMP	AX,error_file_not_found   ;AN000;;EO. file not found error
 43403 00007C45 75DF                    	JNZ	short error_return2	  ;AN000;;EO. no,
 43404                                  	;;test	word [SS:EXTOPEN_FLAG],10h
 43405                                  	; 17/12/2022
 43406 00007C47 36F606[F405]10          	test	byte [SS:EXTOPEN_FLAG],EXT_NEXISTS_CREATE ; 10h
 43407                                  	;TEST	word [SS:EXTOPEN_FLAG],EXT_NEXISTS_CREATE ;AN000;;EO. want to fail;smr;SS Override
 43408                                  	;JNZ	short do_creat		  ;AN000;;EO. yes
 43409                                  	;JMP	short extexit 		  ;AN000;;EO. yes
 43410                                  	; 17/12/2022
 43411 00007C4D 745D                    	jz	short extexit ; 10/06/2019
 43412                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43413                                  	;jnz	short do_creat
 43414                                  	;jmp	short extexit
 43415                                  do_creat:
 43416 00007C4F 368B0E[FF05]            	MOV	CX,[SS:SAVE_CX]		  ;AN000;;EO. get ds:dx for file name;smr;SS Override
 43417 00007C54 36C536[0306]            	LDS	SI,[SS:SAVE_SI]		  ;AN000;;EO. cx = attribute;smr;SS Override
 43418 00007C59 89F2                    	MOV	DX,SI			  ;AN000;;EO.
 43419 00007C5B E86FFD                  	call	_$CREAT			  ;AN000;;EO. do create
 43420 00007C5E 724C                    	JC	short extexit 		  ;AN000;;EO. error
 43421                                  	;mov	word [SS:EXTOPEN_FLAG],2
 43422 00007C60 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED
 43423                                  					  ;AN000;;EO. is created/opened;smr;SS Override
 43424 00007C67 EB0F                    	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
 43425                                  
 43426                                  ext_ok:
 43427 00007C69 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS call ?;smr;SS Override
 43428 00007C6F 74B7                    	JZ	short ok_return		  ;AN000;;EO. yes
 43429                                  	;mov	word [SS:EXTOPEN_FLAG],1
 43430 00007C71 36C706[F405]0100        	MOV	word [SS:EXTOPEN_FLAG],ACTION_OPENED ;AN000;;EO. opened;smr;SS Override
 43431                                  setXAttr:
 43432                                  	; 29/04/2019
 43433 00007C78 50                      	push	ax
 43434 00007C79 E8FB87                  	call	Get_User_Stack		  ;AN000;;EO.
 43435 00007C7C 36A1[F405]              	MOV	AX,[SS:EXTOPEN_FLAG]	  ;AN000;;EO.;smr;SS Override
 43436                                  	;mov	[si+4],ax
 43437 00007C80 894404                  	MOV	[SI+user_env.user_CX],AX  ;AN000;;EO. set action code for cx
 43438 00007C83 58                      	pop	ax			  ;AN000;;EO.
 43439 00007C84 8904                    	mov	[si],ax
 43440                                  	;MOV	[SI+user_env.user_AX],AX  ;AN000;;EO. set handle for ax
 43441                                  	; 17/12/2022
 43442 00007C86 EBA0                    	jmp	short ok_return
 43443                                  ;ok_return:				  ;AN000;
 43444                                  	;jmp	SYS_RET_OK		  ;AN000;;EO.
 43445                                  
 43446                                  extexit2:				  ;AN000; ERROR RECOVERY
 43447 00007C88 5B                      	POP	BX			  ;AN000;EO. close the handle
 43448 00007C89 50                      	PUSH	AX			  ;AN000;EO. save error code from set XA
 43449                                  	;cmp	word [SS:EXTOPEN_FLAG],2
 43450 00007C8A 36833E[F405]02          	CMP	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED
 43451                                  					  ;AN000;EO. from create;smr;SS Override
 43452 00007C90 750C                    	JNZ	short justopen		  ;AN000;EO.
 43453 00007C92 36C536[0306]            	LDS	SI,[SS:SAVE_SI]		  ;AN000;EO. cx = attribute;smr;SS Override
 43454 00007C97 C514                    	LDS	DX,[SI]			  ;AN000;EO.
 43455 00007C99 E881FD                  	call	_$UNLINK 		  ;AN000;EO. delete the file
 43456 00007C9C EB03                    	JMP	SHORT reserror		  ;AN000;EO.
 43457                                  
 43458                                  justopen:				  ;AN000;
 43459 00007C9E E886F4                  	call	_$CLOSE			  ;AN000;EO. pretend never happend
 43460                                  reserror:				  ;AN000;
 43461 00007CA1 58                      	POP	AX			  ;AN000;EO. restore error code from set XA
 43462 00007CA2 EB08                    	JMP	SHORT extexit		  ;AN000;EO.
 43463                                  
 43464                                  ext_file_unfound:			  ;AN000;
 43465                                  	;mov	ax,2
 43466 00007CA4 B80200                  	MOV	AX,error_file_not_found   ;AN000;EO.
 43467 00007CA7 EB03                    	JMP	SHORT extexit		  ;AN000;EO.
 43468                                  ext_inval:				  ;AN000;
 43469                                  	;mov	ax,1
 43470 00007CA9 B80100                  	MOV	AX,error_invalid_function ;AN000;EO.
 43471                                  lockoperr:	; 17/12/2022
 43472                                  extexit:
 43473 00007CAC E9CB89                  	jmp	SYS_RET_ERR		  ;AN000;EO.
 43474                                  
 43475                                  ;============================================================================
 43476                                  ; LOCK.ASM, MSDOS 6.0, 1991
 43477                                  ;============================================================================
 43478                                  ; 14/07/2018 - Retro DOS v3.0
 43479                                  ; 22/05/2019 - Retro DOS v4.0
 43480                                  
 43481                                  ;BREAK <$LockOper - Lock Calls>
 43482                                  ;----------------------------------------------------------------------------
 43483                                  ;
 43484                                  ;   Assembler usage:
 43485                                  ;	    MOV     BX, Handle	       (DOS 3.3)
 43486                                  ;	    MOV     CX, OffsetHigh
 43487                                  ;	    MOV     DX, OffsetLow
 43488                                  ;	    MOV     SI, LengthHigh
 43489                                  ;	    MOV     DI, LengthLow
 43490                                  ;	    MOV     AH, LockOper
 43491                                  ;	    MOV     AL, Request
 43492                                  ;	    INT     21h
 43493                                  ;
 43494                                  ;   Error returns:
 43495                                  ;	    AX = error_invalid_handle
 43496                                  ;	       = error_invalid_function
 43497                                  ;	       = error_lock_violation
 43498                                  ;
 43499                                  ;   Assembler usage:
 43500                                  ;	    MOV     AX, 5C??	       (DOS 4.00)
 43501                                  ;
 43502                                  ;				    0? lock all
 43503                                  ;				    8? lock write
 43504                                  ;				    ?2 lock multiple
 43505                                  ;				    ?3 unlock multiple
 43506                                  ;				    ?4 lock/read
 43507                                  ;				    ?5 write/unlock
 43508                                  ;				    ?6 add (lseek EOF/lock/write/unlock)
 43509                                  ;	    MOV     BX, Handle
 43510                                  ;	    MOV     CX, count or size
 43511                                  ;	    LDS     DX, buffer
 43512                                  ;	    INT     21h
 43513                                  ;
 43514                                  ;   Error returns:
 43515                                  ;	    AX = error_invalid_handle
 43516                                  ;	       = error_invalid_function
 43517                                  ;	       = error_lock_violation
 43518                                  ;
 43519                                  ;----------------------------------------------------------------------------
 43520                                  
 43521                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43522                                  _$LockOper:
 43523 00007CAF 3C01                    	CMP	AL,1
 43524 00007CB1 770B                    	JA	short lock_bad_func
 43525                                  
 43526 00007CB3 57                      	PUSH	DI			       ; Save LengthLow
 43527 00007CB4 E8D5F3                  	call	SFFromHandle		       ; ES:DI -> SFT
 43528 00007CB7 731D                    	JNC	short lock_do 		       ; have valid handle
 43529 00007CB9 5F                      	POP	DI			       ; Clean stack
 43530                                  	;mov	al,6
 43531 00007CBA B006                    	mov	al,error_invalid_handle
 43532                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43533                                  ;lockoperr:
 43534                                  	;jmp	SYS_RET_ERR
 43535                                  	; 17/12/2022
 43536 00007CBC EBEE                    	jmp	short lockoperr ; jmp SYS_RET_ERR
 43537                                  
 43538                                  lock_bad_func:
 43539                                  	;mov	byte [ss:EXTERR_LOCUS],1
 43540 00007CBE 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus;smr;SS Override
 43541                                  	;mov	al,1
 43542 00007CC4 B001                    	mov	al,error_invalid_function
 43543                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43544                                  lockoperrj:
 43545                                  	;jmp	SYS_RET_ERR
 43546 00007CC6 EBE4                    	jmp	short lockoperr
 43547                                  
 43548                                  	; 22/05/2019 - Retro DOS v4.0
 43549                                  
 43550                                  	; MSDOS 6.0 
 43551                                  ; Align_buffer call has been deleted, since it corrupts the DTA (6/5/88) P5013
 43552                                  ; Dead code deleted, MD, 23 Mar 90
 43553                                  
 43554                                  ;lock_do:
 43555                                  ;	; MSDOS 3.3
 43556                                  ;	or	al,al
 43557                                  ;	pop	ax
 43558                                  ;	jz	short DOS_Lock
 43559                                  ;DOS_Unlock:
 43560                                  ;	;test	word [es:di+5],8000h
 43561                                  ;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 43562                                  ;	JZ	short LOCAL_UNLOCK
 43563                                  ;	push    ax
 43564                                  ;	mov     ax,110Bh
 43565                                  ;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
 43566                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 43567                                  ;			; STACK: WORD low word of size, ES:DI -> SFT for file
 43568                                  ;			; SFT DPB field -> DPB of drive containing file
 43569                                  ;			; Return: CF set error
 43570                                  ;	pop     bx
 43571                                  ;	jmp     short ValChk
 43572                                  ;
 43573                                  ;LOCAL_UNLOCK:
 43574                                  ;	Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 43575                                  ;ValChk:
 43576                                  ;	JNC	short Lock_OK
 43577                                  ;lockerror:
 43578                                  ;	jmp	SYS_RET_ERR
 43579                                  ;Lock_OK:
 43580                                  ;	;MOV	AX,[SS:Temp_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 43581                                  ;	jmp	SYS_RET_OK
 43582                                  ;DOS_Lock:
 43583                                  ;	;test	word [es:di+5],8000h
 43584                                  ;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 43585                                  ;	JZ	short LOCAL_LOCK
 43586                                  ;	;CallInstall NET_XLock,MultNET,10
 43587                                  ;	mov     ax, 110Ah
 43588                                  ;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 43589                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 43590                                  ;			; STACK: WORD low word of size, ES:DI -> SFT
 43591                                  ;			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 43592                                  ;			; Return: CF set error
 43593                                  ;	JMP	short ValChk
 43594                                  ;
 43595                                  ;LOCAL_LOCK:
 43596                                  ;	Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 43597                                  ;	JMP	short ValChk
 43598                                  
 43599                                  ; 17/12/2022
 43600                                  LOCAL_UNLOCK:
 43601                                  	; MSDOS 3.3
 43602                                  	;Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 43603                                  	; MSDOS 6.0
 43604 00007CC8 FF1E[AC00]              	Call	far [JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 43605                                  ValChk:
 43606 00007CCC 7302                    	JNC	short Lock_OK
 43607                                  lockerror:
 43608                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43609                                  	;;jmp	SYS_RET_ERR
 43610                                  	;jmp	short lockoperrj
 43611                                  	; 17/12/2022
 43612 00007CCE EBDC                    	jmp	short lockoperr	; jmp SYS_RET_ERR
 43613                                  Lock_OK:
 43614                                  	;MOV	AX,[SS:TEMP_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 43615                                  	; 10/06/2019
 43616 00007CD0 A1[0C06]                	mov	ax,[TEMP_VAR]
 43617 00007CD3 E99A89                  	jmp	SYS_RET_OK
 43618                                  
 43619                                  	; 22/05/2019
 43620                                  lock_do:
 43621                                  	; MSDOS 6.0
 43622 00007CD6 89C3                    	MOV	BX,AX				; save AX
 43623 00007CD8 BD[A903]                	MOV	BP,Lock_Buffer			; get DOS LOCK buffer
 43624                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43625                                  	;;mov	[bp+0],dx
 43626                                  	;MOV	[BP+LockBuf.Lock_position],DX	; set low offset
 43627                                  	; 15/12/2022
 43628 00007CDB 895600                  	mov	[bp],dx
 43629                                  	;mov	[bp+2],cx
 43630 00007CDE 894E02                  	MOV	[BP+LockBuf.Lock_position+2],CX; set high offset
 43631 00007CE1 59                      	POP	CX				; get low length
 43632                                  	;mov	[bp+4],cx
 43633 00007CE2 894E04                  	MOV	[BP+LockBuf.Lock_length],CX	; set low length
 43634                                  	;mov	[bp+6],si
 43635 00007CE5 897606                  	MOV	[BP+LockBuf.Lock_length+2],SI	; set high length
 43636 00007CE8 B90100                  	MOV	CX,1				; one range
 43637                                  
 43638                                  ;	PUSH	CS				;
 43639                                  ;	POP	DS				; DS:DX points to
 43640                                  
 43641 00007CEB 16                      	push	ss
 43642 00007CEC 1F                      	pop	ds
 43643                                  
 43644 00007CED 89EA                    	MOV	DX,BP				; Lock_Buffer
 43645                                  	;test	al,1
 43646 00007CEF A801                    	TEST	AL,UNLOCK_ALL			; function 1
 43647                                  	;JNZ	short DOS_Unlock		; yes
 43648                                  	;JMP	short DOS_Lock			; function 0
 43649                                  	; 17/12/2022
 43650                                  	; 10/06/2019
 43651 00007CF1 740E                    	jz	short DOS_Lock
 43652                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43653                                  	;JNZ	short DOS_Unlock
 43654                                  	;JMP	short DOS_Lock
 43655                                  
 43656                                  DOS_Unlock:
 43657                                  	;;test	word [es:di+5],8000h
 43658                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 43659 00007CF3 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 43660 00007CF8 74CE                    	JZ	short LOCAL_UNLOCK
 43661                                  
 43662                                  lock_unlock: ; 22/05/2019
 43663                                  	
 43664                                  	;CallInstall Net_Xlock,MultNET,10
 43665                                  	
 43666                                  	; MSDOS 3.3
 43667                                  	;mov     ax,110Bh
 43668                                  	;int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
 43669                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 43670                                  			; STACK: WORD low word of size, ES:DI -> SFT for file
 43671                                  			; SFT DPB field -> DPB of drive containing file
 43672                                  			; Return: CF set error
 43673                                  	; MSDOS 6.0
 43674 00007CFA B80A11                  	mov     ax,110Ah
 43675 00007CFD CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 43676                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 43677                                  			; STACK: WORD low word of size, ES:DI -> SFT
 43678                                  			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 43679                                  			; Return: CF set error
 43680                                  
 43681 00007CFF EBCB                    	JMP	SHORT ValChk
 43682                                  
 43683                                  ; 17/12/2022
 43684                                  %if 0
 43685                                  LOCAL_UNLOCK:
 43686                                  	; MSDOS 3.3
 43687                                  	;Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 43688                                  	; MSDOS 6.0
 43689                                  	Call	far [JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 43690                                  ValChk:
 43691                                  	JNC	short Lock_OK
 43692                                  lockerror:
 43693                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43694                                  	;jmp	SYS_RET_ERR
 43695                                  	jmp	short lockoperrj
 43696                                  Lock_OK:
 43697                                  	;MOV	AX,[SS:TEMP_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 43698                                  	; 10/06/2019
 43699                                  	mov	ax,[TEMP_VAR]
 43700                                  	jmp	SYS_RET_OK
 43701                                  %endif
 43702                                  
 43703                                  DOS_Lock:
 43704                                  	;;test	word [es:di+5],8000h
 43705                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 43706 00007D01 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 43707 00007D06 7407                    	JZ	short LOCAL_LOCK
 43708                                  
 43709                                  	;CallInstall NET_XLock,MultNET,10
 43710                                  
 43711 00007D08 B80A11                  	mov     ax,110Ah
 43712 00007D0B CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 43713                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 43714                                  			; STACK: WORD low word of size, ES:DI -> SFT
 43715                                  			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 43716                                  			; Return: CF set error
 43717                                  
 43718 00007D0D EBBD                    	JMP	short ValChk
 43719                                  
 43720                                  LOCAL_LOCK:
 43721                                  	; MSDOS 3.3
 43722                                  	;Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 43723                                  	; MSDOS 6.0
 43724 00007D0F FF1E[A800]              	Call	far [JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 43725                                  
 43726 00007D13 EBB7                    	JMP	short ValChk
 43727                                  
 43728                                  ; 14/07/2018 - Retro DOS v3.0
 43729                                  ; LOCK_CHECK
 43730                                  ;MSDOS 6.0 (& MSDOS 3.3)
 43731                                  
 43732                                  ;----------------------------------------------------------------------------
 43733                                  ; Inputs:
 43734                                  ;	Outputs of SETUP
 43735                                  ;	[USER_ID] Set
 43736                                  ;	[PROC_ID] Set
 43737                                  ; Function:
 43738                                  ;	Check for lock violations on local I/O
 43739                                  ;	Retries are attempted with sleeps in between
 43740                                  ; Outputs:
 43741                                  ;    Carry clear
 43742                                  ;	Operation is OK
 43743                                  ;    Carry set
 43744                                  ;	A lock violation detected
 43745                                  ; Outputs of SETUP preserved
 43746                                  ;----------------------------------------------------------------------------
 43747                                  
 43748                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43749                                  	; 22/05/2019 - Retro DOS v4.0
 43750                                  LOCK_CHECK:
 43751 00007D15 8B1E[1A00]              	MOV	BX,[RetryCount]	; Number retries
 43752                                  LockRetry:
 43753 00007D19 53                      	push	bx		; save regs
 43754 00007D1A 50                      	push	ax ; MSDOS 6.0
 43755                                  
 43756                                  	;MSDOS 3.3
 43757                                  	;Call	far [ss:JShare+(8*4)]	; 8 = chk_block
 43758                                  	;MSDOS 6.0
 43759 00007D1B FF1E[B000]              	Call	far [JShare+(8*4)]	; 8 = chk_block
 43760                                  
 43761 00007D1F 58                      	pop	ax ; MSDOS 6.0
 43762 00007D20 5B                      	pop	bx		; restrore regs
 43763 00007D21 7307                    	jnc	short lc_ret_label ; There are no locks (retnc)
 43764                                  LockN:
 43765 00007D23 E8D69A                  	call	Idle		; wait a while
 43766 00007D26 4B                      	DEC	BX		; remember a retry
 43767 00007D27 75F0                    	JNZ	short LockRetry	; more retries left...
 43768 00007D29 F9                      	STC
 43769                                  lc_ret_label:
 43770 00007D2A C3                      	retn
 43771                                  
 43772                                  ; 14/07/2018 - Retro DOS v3.0
 43773                                  ; LOCK_VIOLATION
 43774                                  ;MSDOS 6.0 (& MSDOS 3.3)
 43775                                  
 43776                                  ;----------------------------------------------------------------------------
 43777                                  ; Inputs:
 43778                                  ;	[THISDPB] set
 43779                                  ;	[READOP] indicates whether error on read or write
 43780                                  ; Function:
 43781                                  ;	Handle Lock violation on compatibility (FCB) mode SFTs
 43782                                  ; Outputs:
 43783                                  ;	Carry set if user says FAIL, causes error_lock_violation
 43784                                  ;	Carry clear if user wants a retry
 43785                                  ;
 43786                                  ; DS, ES, DI, CX preserved, others destroyed
 43787                                  ;----------------------------------------------------------------------------
 43788                                  
 43789                                  LOCK_VIOLATION:
 43790 00007D2B 1E                      	PUSH	DS
 43791 00007D2C 06                      	PUSH	ES
 43792 00007D2D 57                      	PUSH	DI
 43793 00007D2E 51                      	PUSH	CX
 43794                                  	;mov	ax,21h
 43795 00007D2F B82100                  	MOV	AX,error_lock_violation
 43796                                  	;mov	byte [ALLOWED],18h
 43797 00007D32 C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 43798 00007D37 C42E[8A05]              	LES	BP,[THISDPB]
 43799 00007D3B BF0100                  	MOV	DI,1		; Fake some registers
 43800 00007D3E 89F9                    	MOV	CX,DI
 43801                                  	;mov	dx,[es:bp+11]
 43802 00007D40 268B560B                	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
 43803 00007D44 E89CDF                  	call	HARDERR
 43804 00007D47 59                      	POP	CX
 43805 00007D48 5F                      	POP	DI
 43806 00007D49 07                      	POP	ES
 43807 00007D4A 1F                      	POP	DS
 43808 00007D4B 3C01                    	CMP	AL,1
 43809 00007D4D 74DB                    	jz	short lc_ret_label ; 1 = retry, carry clear
 43810 00007D4F F9                      	STC
 43811 00007D50 C3                      	retn
 43812                                  
 43813                                  ; 14/07/2018 - Retro DOS v3.0
 43814                                  
 43815                                  ;----------------------------------------------------------------------------
 43816                                  
 43817                                  ;	do a retz to return error
 43818                                  
 43819                                  	; 22/05/2019 - Retro DOS v4.0
 43820                                  CheckShare:
 43821                                  	; MSDOS 3.3
 43822                                  	;cmp	byte [cs:fShare],0
 43823                                  	;retn
 43824                                  
 43825                                  	; MSDOS 6.0
 43826 00007D51 1E                      	push	ds			;smr;
 43827                                  	;getdseg <ds>			; ds -> dosdata
 43828 00007D52 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 43829 00007D57 803E[0303]00            	cmp	byte [fShare],0
 43830 00007D5C 1F                      	pop	ds			;smr;
 43831 00007D5D C3                      	retn
 43832                                  	
 43833                                  ;============================================================================
 43834                                  ; SHARE.ASM, MSDOS 6.0, 1991
 43835                                  ;============================================================================
 43836                                  ; 14/07/2018 - Retro DOS v3.0
 43837                                  ; 22/05/2019 - Retro DOS v4.0
 43838                                  
 43839                                  ; SHARE_CHECK
 43840                                  ;----------------------------------------------------------------------------
 43841                                  ; Inputs:
 43842                                  ;       [THISSFT] Points to filled in local file/device SFT for new
 43843                                  ;               instance of file sf_mode ALWAYS has mode (even on FCB SFTs)
 43844                                  ;       [WFP_START] has full path of name
 43845                                  ;       [USER_ID] Set
 43846                                  ;       [PROC_ID] Set
 43847                                  ; Function:
 43848                                  ;       Check for sharing violations on local file/device access
 43849                                  ; Outputs:
 43850                                  ;    Carry clear
 43851                                  ;       Sharing approved
 43852                                  ;    Carry set
 43853                                  ;       A sharing violation detected
 43854                                  ;           AX is error code
 43855                                  ; USES    ALL but DS
 43856                                  ;----------------------------------------------------------------------------
 43857                                  
 43858                                  	; 22/05/2019 - Retro DOS v4.0
 43859                                  SHARE_CHECK:
 43860                                  	; 26/07/2019
 43861 00007D5E FF1E[9400]              	call	far [JShare+(1*4)] 	; 1 = MFT_Enter
 43862                                  shchk_retn:
 43863 00007D62 C3                      	retn
 43864                                  
 43865                                  ; SHARE_VIOLATION
 43866                                  ;----------------------------------------------------------------------------
 43867                                  ; Inputs:
 43868                                  ;       [THISDPB] Set
 43869                                  ;       AX has error code
 43870                                  ; Function:
 43871                                  ;       Handle Sharing errors
 43872                                  ; Outputs:
 43873                                  ;       Carry set if user says FAIL, causes error_sharing_violation
 43874                                  ;       Carry clear if user wants a retry
 43875                                  ;
 43876                                  ; DS, ES, DI preserved, others destroyed
 43877                                  ;----------------------------------------------------------------------------
 43878                                  
 43879                                  SHARE_VIOLATION:
 43880 00007D63 1E                      	PUSH    DS
 43881 00007D64 06                      	PUSH	ES
 43882 00007D65 57                      	PUSH    DI
 43883 00007D66 C606[7505]00            	MOV     byte [READOP],0		; All share errors are reading
 43884                                  	;mov	byte [ALLOWED],18h
 43885 00007D6B C606[4B03]18            	MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 43886 00007D70 C42E[8A05]              	LES     BP,[THISDPB]
 43887 00007D74 BF0100                  	MOV     DI,1			; Fake some registers
 43888 00007D77 89F9                    	MOV     CX,DI
 43889                                  	;mov	dx,[es:bp+17]
 43890 00007D79 268B5611                	MOV     DX,[ES:BP+DPB.DIR_SECTOR]
 43891 00007D7D E863DF                  	call	HARDERR
 43892 00007D80 5F                      	POP     DI
 43893 00007D81 07                      	POP	ES
 43894 00007D82 1F                      	POP     DS
 43895 00007D83 3C01                    	CMP     AL,1
 43896 00007D85 74DB                    	jz	short shchk_retn	; 1 = retry, carry clear
 43897 00007D87 F9                      	STC
 43898 00007D88 C3                      	retn
 43899                                  
 43900                                  ;----------------------------------------------------------------------------
 43901                                  ;   ShareEnd - terminate sharing info on a particular SFT/UID/PID. This does
 43902                                  ;       NOT perform a close, it merely asserts that the sharing information
 43903                                  ;       for the SFT/UID/PID may be safely released.
 43904                                  ;
 43905                                  ;   Inputs:     ES:DI points to an SFT
 43906                                  ;   Outputs:    None
 43907                                  ;   Registers modified: all except DS,ES,DI
 43908                                  ;----------------------------------------------------------------------------
 43909                                  
 43910                                  ShareEnd:
 43911                                  	; 26/07/2019
 43912 00007D89 FF1E[9800]              	call	far [JShare+(2*4)]	; 2 = MFTClose
 43913 00007D8D C3                      	retn
 43914                                  
 43915                                  ;Break <ShareEnter - attempt to enter a node into the sharing set>
 43916                                  ;----------------------------------------------------------------------------
 43917                                  ;   ShareEnter - perform a retried entry of a nodde into the sharing set. If
 43918                                  ;   the max number of retries is exceeded, we notify the user via int 24.
 43919                                  ;
 43920                                  ;   Inputs:     ThisSFT points to the SFT
 43921                                  ;               WFP_Start points to the WFP
 43922                                  ;   Outputs:    Carry clear => successful entry
 43923                                  ;               Carry set => failed system call
 43924                                  ;   Registers modified: all
 43925                                  ;----------------------------------------------------------------------------
 43926                                  
 43927                                  ShareEnter:
 43928 00007D8E 51                      	push	cx
 43929                                  retry:
 43930 00007D8F 8B0E[1A00]              	mov     cx,[RetryCount]
 43931                                  attempt:
 43932 00007D93 C43E[9E05]              	les     di,[THISSFT]		; grab sft
 43933 00007D97 31C0                    	XOR     AX,AX
 43934                                   	;mov	[es:di+51],axfff
 43935 00007D99 26894533                	MOV     [ES:DI+SF_ENTRY.sf_MFT],AX ; indicate free SFT
 43936 00007D9D 51                      	push	cx
 43937 00007D9E E8BDFF                  	call    SHARE_CHECK             ; attempt to enter into the sharing set
 43938 00007DA1 59                      	pop	cx
 43939 00007DA2 730A                    	jnc	short done		; success, let the user see this
 43940 00007DA4 E8559A                  	call	Idle                    ; wait a while
 43941 00007DA7 E2EA                    	loop    attempt                 ; go back for another attempt
 43942 00007DA9 E8B7FF                  	call    SHARE_VIOLATION         ; signal the problem to the user
 43943 00007DAC 73E1                    	jnc	short retry		; user said to retry, go do it
 43944                                  done:
 43945 00007DAE 59                      	pop	cx
 43946 00007DAF C3                      	retn
 43947                                  
 43948                                  ;============================================================================
 43949                                  ; EXEPATCH.ASM (MSDOS 6.0, 1991)
 43950                                  ;============================================================================
 43951                                  ; 29/04/2019 - Retro DOS 4.0
 43952                                  
 43953                                  ;** EXEPATCH.ASM 
 43954                                  ;----------------------------------------------------------------------------
 43955                                  ;	Contains the foll:
 43956                                  ;
 43957                                  ;		- code to find and overlay buggy unpack code
 43958                                  ;		- new code to be overlayed on buggy unpack code 
 43959                                  ;		- old code sequence to identify buggy unpack code
 43960                                  ;
 43961                                  ;	Revision history:
 43962                                  ;
 43963                                  ;		Created: 5/14/90
 43964                                  ;----------------------------------------------------------------------------
 43965                                  
 43966                                  ;----------------------------------------------------------------------------
 43967                                  ;
 43968                                  ; M020 : Fix for rational bug - for details see routine header
 43969                                  ; M028 : 4b04 implementation
 43970                                  ; M030 : Fixing bug in EXEPACKPATCH (EXEC_CS is an un-relocated value)
 43971                                  ; M032 : set turnoff bit only if DOS in HMA.
 43972                                  ; M033 : if IP < 2 then not exepacked.
 43973                                  ; M046 : support for a 4th version of exepacked files.
 43974                                  ; M068 : support for copy protected apps.
 43975                                  ; M071 : use A20OFF_COUNT of 10.
 43976                                  ;
 43977                                  ;----------------------------------------------------------------------------
 43978                                  
 43979                                  PATCH1_COM_OFFSET	EQU	06CH
 43980                                  PATCH1_OFFSET		EQU	028H
 43981                                  PATCH1_CHKSUM		EQU	0EF4EH
 43982                                  CHKSUM1_LEN		EQU	11CH/2 ; 142
 43983                                  
 43984                                  PATCH2_COM_OFFSET	EQU	076H
 43985                                  PATCH2_OFFSET		EQU	032H
 43986                                  
 43987                                  	; The strings that start at offset 076h have two possible 
 43988                                  	; check sums that are defined as PATCH2_CHKSUM PATCH2A_CHKSUM
 43989                                  
 43990                                  PATCH2_CHKSUM		EQU	78B2H
 43991                                  CHKSUM2_LEN		EQU	119H/2
 43992                                  PATCH2A_CHKSUM		EQU	1C47H		; M046
 43993                                  CHKSUM2A_LEN		EQU	103H/2		; M046
 43994                                  
 43995                                  PATCH3_COM_OFFSET	EQU	074H
 43996                                  PATCH3_OFFSET		EQU	032H
 43997                                  PATCH3_CHKSUM		EQU	4EDEH
 43998                                  CHKSUM3_LEN		EQU	117H/2
 43999                                  
 44000                                  ;**	Data structure passed for ExecReady call
 44001                                  ;
 44002                                  ;struc ERStruc
 44003                                  ; .ER_Reserved:	resw	1	; reserved, should be zero
 44004                                  ; .ER_Flags:	resw	1
 44005                                  ; .ER_ProgName:	resd	1	; ptr to ASCIIZ str of prog name
 44006                                  ; .ER_PSP:	resw	1	; PSP of the program
 44007                                  ; .ER_StartAddr: resd	1	; Start CS:IP of the program
 44008                                  ; .ER_ProgSize:	resd	1	; Program size including PSP
 44009                                  ; .size:
 44010                                  ;endstruc
 44011                                  
 44012                                  ;DOSCODE SEGMENT
 44013                                  
 44014                                  	; 22/05/2019 - Retro DOS v4.0
 44015                                  	; DOSCODE:B3DDh (MSDOS 6.21, MSDOS.SYS)
 44016                                  
 44017                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 44018                                  	; DOSCODE:B37Ah (MSDOS 5.0, MSDOS.SYS)
 44019                                  
 44020                                  ; M028 - BEGIN
 44021                                  
 44022                                  ;--------------------------------------------------------------------------
 44023                                  ;
 44024                                  ;	Procedure Name		: ExecReady
 44025                                  ;
 44026                                  ;	Input			: DS:DX -> ERStruc (see exe.inc)
 44027                                  ;
 44028                                  ;--------------------------------------------------------------------------
 44029                                  
 44030                                  ExecReady:
 44031 00007DB0 89D6                    	mov	si,dx			; move the pointer into a friendly one
 44032                                  	;;test	word [si+2],1
 44033                                  	; 17/12/2022
 44034 00007DB2 F6440201                	test	byte [si+ERStruc.ER_Flags],ER_EXE ; 1
 44035                                  	;test	word [si+ERStruc.ER_Flags],ER_EXE ; COM or EXE ?
 44036 00007DB6 7413                    	jz	short er_setver		; only setver for .COM files
 44037                                  
 44038                                  	;mov	ax,[si+8]
 44039 00007DB8 8B4408                  	mov	ax,[si+ERStruc.ER_PSP]
 44040 00007DBB 83C010                  	add	ax,10h
 44041 00007DBE 8EC0                    	mov	es,ax
 44042                                  
 44043                                  	;mov	cx,[si+10]
 44044 00007DC0 8B4C0A                  	mov	cx,[si+ERStruc.ER_StartAddr]   ; M030
 44045                                  	;mov	cx,[si+12]
 44046 00007DC3 8B440C                  	mov	ax,[si+ERStruc.ER_StartAddr+2] ; M030
 44047                                  
 44048                                  	;call	[ss:FixExePatch]
 44049 00007DC6 36FF16[880D]            	call	word [ss:FixExePatch] ; 28/12/2022
 44050                                  	
 44051                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 44052                                  	;call	[ss:Rational386PatchPtr]
 44053                                  
 44054                                  er_setver:
 44055                                  	;;test	word [si+2],2		; Q: is this an overlay
 44056                                  	; 17/12/2022
 44057 00007DCB F6440202                	test	byte [si+ERStruc.ER_Flags],ER_OVERLAY ; 2
 44058                                  	;test	word [si+ERStruc.ER_Flags],ER_OVERLAY
 44059 00007DCF 7518                    	jnz	short er_chkdoshi	; Y: set A20OFF_COUNT if DOS high
 44060                                  					; N: set up lie version first
 44061 00007DD1 1E                      	push	ds
 44062 00007DD2 56                      	push	si
 44063                                  	;lds	si,[si+4]
 44064 00007DD3 C57404                  	lds	si,[si+ERStruc.ER_ProgName]
 44065 00007DD6 E876ED                  	call	Scan_Execname1
 44066 00007DD9 E887ED                  	call	Scan_Special_Entries
 44067 00007DDC 5E                      	pop	si
 44068 00007DDD 1F                      	pop	ds
 44069                                  	;mov	es,[si+8]
 44070 00007DDE 8E4408                  	mov	es,[si+ERStruc.ER_PSP]
 44071 00007DE1 36A1[020F]              	mov	ax,[ss:SPECIAL_VERSION]
 44072 00007DE5 26A34000                	mov	[es:PDB.Version],ax
 44073                                  
 44074                                  er_chkdoshi:
 44075 00007DE9 36803E[870D]00          	cmp	byte [ss:DosHasHMA],0	; M032: Q: is dos in HMA (M021)
 44076 00007DEF 741F                    	je	short er_done		; M032: N: done
 44077                                  
 44078                                  					; M068 - Start
 44079                                  	;mov	ax,[si+8]
 44080 00007DF1 8B4408                  	mov	ax,[si+ERStruc.ER_PSP]	; ax = PSP
 44081                                  
 44082                                  	;or	byte [ss:DOS_FLAG],4
 44083 00007DF4 36800E[8600]04          	or	byte [ss:DOS_FLAG],EXECA20OFF ; Set bit to signal int 21
 44084                                  					; ah = 25 & ah= 49. See dossym.inc 
 44085                                  					; under TAG M003 & M009 for 
 44086                                  					; explanation
 44087                                  	;;test	word [si+2],1
 44088                                  	; 17/12/2022
 44089 00007DFA F6440201                	test	byte [si+ERStruc.ER_Flags],ER_EXE ; 1
 44090                                  	;test	word [si+ERStruc.ER_Flags],ER_EXE ; Q: COM file
 44091 00007DFE 7507                    	jnz	short er_setA20		; N: inc a20off_count, set 
 44092                                  					;    a20off_psp and ret
 44093 00007E00 1E                         	push	ds
 44094 00007E01 8ED8                    	mov	ds,ax			; DS = load segment of com file.
 44095 00007E03 E88E02                  	call	IsCopyProt		; check if copy protected
 44096 00007E06 1F                      	pop	ds
 44097                                  
 44098                                  er_setA20:
 44099                                  	; We need to inc the A20OFF_COUNT here. Note that if the count
 44100                                  	; is non-zero at this point it indicates that the A20 is to be 
 44101                                  	; turned off for that many int 21 calls made by the app. In 
 44102                                  	; addition the A20 has to be turned off when we exit from this 
 44103                                  	; call. Hence the inc.
 44104                                  
 44105 00007E07 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]		
 44106 00007E0C 36A3[6300]              	mov	[ss:A20OFF_PSP],ax	; set the PSP for which A20 is to be
 44107                                  					; turned OFF.
 44108                                  er_done:				; M068 - End
 44109 00007E10 31C0                    	xor	ax,ax
 44110 00007E12 C3                      	retn
 44111                                  
 44112                                  ; M028 - END
 44113                                  
 44114                                  
 44115                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 44116                                  %if 0
 44117                                  
 44118                                  ;----------------------------------------------------------------------------
 44119                                  ;
 44120                                  ; procedure : Rational386Patch
 44121                                  ;
 44122                                  ; Older versions of the Rational DOS Extender have several bugs which trash
 44123                                  ; 386 registers (usually just the high word of 32 bit registers) during
 44124                                  ; interrupt processing. Lotus 123 3.1+ is a popular application that uses a
 44125                                  ; version of the Rational extender with the 32 bit register trashing bugs.
 44126                                  ;
 44127                                  ; This routine applies patches to the Rational DOS Extender to work around
 44128                                  ; most of the register trashing bugs.
 44129                                  ;
 44130                                  ; Note that there are additional register trashing bugs not fixed by these
 44131                                  ; patches. In particular, the high word of ESP and the FS and GS registers
 44132                                  ; may be modified on interrupts.
 44133                                  ;
 44134                                  ; There are two different Rational DOS Extender patchs in this module.
 44135                                  ; Rational386Patch is to correct 386 register trashing bugs on 386 or later
 44136                                  ; processors. This patch code is executed when MS-DOS is running on a 386
 44137                                  ; or later processor, regardless of whether MS-DOS is running in the HMA
 44138                                  ; or not.
 44139                                  ;
 44140                                  ; The other Rational patch routine (RationalPatch, below) fixes a register
 44141                                  ; trashing problem on 286 processors, and is only executed if MS-DOS is
 44142                                  ; running in the HMA.
 44143                                  ;
 44144                                  ; This patch detection and replacement is based on an example supplied by
 44145                                  ; Ben Williams at Rational.
 44146                                  ;
 44147                                  ;----------------------------------------------------------------------------
 44148                                  
 44149                                  ; 22/05/2019 - Retro DOS v4.0
 44150                                  ; DOSCODE:B448h (MSDOS 6.21, MSDOS.SYS)
 44151                                  
 44152                                  ;----------------------------------------------------------------------------
 44153                                  ;
 44154                                  ; INPUT : ES = segment where program got loaded
 44155                                  ;
 44156                                  ;----------------------------------------------------------------------------
 44157                                  
 44158                                  rpFind1:
 44159                                  	db	0FAh, 0E4h, 21h, 60h, 33h, 0C0h, 0E6h, 43h, 8Bh, 16h
 44160                                  
 44161                                  rpFind1Len equ	$ - rpFind1
 44162                                  
 44163                                  ;	cli
 44164                                  ;	in	al, 21h
 44165                                  ;	pusha
 44166                                  ;	xor	ax, ax
 44167                                  ;	out	43h, al
 44168                                  ;	mov	dx, ...
 44169                                  
 44170                                  rpFind1a:
 44171                                  	db	0B0h, 0Eh, 0E6h, 37h, 33h, 0C0h, 0E6h, 0F2h
 44172                                  
 44173                                  rpFind1aLen equ	$ - rpFind1a
 44174                                  
 44175                                  ;	mov	al, 0Eh
 44176                                  ;	out	37h, al
 44177                                  ;	xor	ax, ax
 44178                                  ;	out	0F2h, al
 44179                                  
 44180                                  ; bug # 1 -- loss of high EAX on 386+ if not VCPI or DPMI
 44181                                  
 44182                                  rpFind2:
 44183                                  	db	0Fh, 20h, 0C0h
 44184                                  
 44185                                  rpFind2Len equ	$ - rpFind2
 44186                                  
 44187                                  ;	mov	eax, cr0	;may be preceeded by PUSH CX (51h)
 44188                                  
 44189                                  rpFind3:
 44190                                  	db	0Fh, 22h, 0C0h, 0EAh
 44191                                  
 44192                                  rpFind3Len equ	$ - rpFind3
 44193                                  
 44194                                  ;	mov	cr0, eax	;may be preceeded by POP CX (59h)
 44195                                  ;	jmp	far ptr xxx	;change far ptr to go to replace3
 44196                                  ;	mov	ss, bx		;8E D3 ... and come back at or after this
 44197                                  
 44198                                  ; note, there is no rpRepl1 string
 44199                                  
 44200                                  rpRepl2:
 44201                                   	db	66h, 50h, 51h, 0Fh, 20h, 0C0h
 44202                                  
 44203                                  rpRepl2Len equ	$ - rpRepl2
 44204                                  
 44205                                  ;	push	eax
 44206                                  ;	push	cx
 44207                                  ;	mov	eax, cr0
 44208                                  
 44209                                  rpRepl3:
 44210                                  	db	8Eh, 0D3h, 59h, 66h, 58h
 44211                                  
 44212                                  rpRepl3Len equ	$ - rpRepl3
 44213                                  
 44214                                  ;	mov	ss, bx
 44215                                  ;	pop	cx
 44216                                  ;	pop	eax
 44217                                  
 44218                                  ; bug # 2 -- loss of high EAX and ESI on 386+ only if VCPI
 44219                                  
 44220                                  rpFind4:
 44221                                  	db	93h, 58h, 8Bh, 0CCh
 44222                                  
 44223                                  rpFind4Len equ	$ - rpFind4
 44224                                  
 44225                                  ;	xchg	bx, ax
 44226                                  ;	pop	ax
 44227                                  ;	mov	cx, sp
 44228                                  
 44229                                  rpFind5:
 44230                                  	db	0B8h, 0Ch, 0DEh, 0CDh, 67h, 8Bh, 0E1h, 0FFh, 0E3h
 44231                                  
 44232                                  rpFind5Len equ	$ - rpFind5
 44233                                  
 44234                                  ;	mov	ax, DE0Ch
 44235                                  ;	int	67h
 44236                                  ;	mov	sp, cx
 44237                                  ;	jmp	bx
 44238                                  
 44239                                  rpRepl4:
 44240                                  	db	93h, 58h, 8Bh, 0CCh
 44241                                  	db	02Eh, 066h, 0A3h
 44242                                  
 44243                                  rpRepl4o1Len equ $ - rpRepl4
 44244                                  
 44245                                  	db	00h, 00h
 44246                                  	db	02Eh, 066h, 89h, 36h
 44247                                  
 44248                                  rpRepl4o2Len equ $ - rpRepl4
 44249                                  
 44250                                  	db	00h, 00h
 44251                                  
 44252                                  rpRepl4Len equ	$ - rpRepl4
 44253                                  
 44254                                  ;	xchg	bx, ax
 44255                                  ;	pop	ax
 44256                                  ;	mov	cx, sp
 44257                                  ;	mov	dword ptr cs:[xxxx], eax
 44258                                  ;	mov	dword ptr cs:[xxxx], esi
 44259                                  
 44260                                  rpRepl5:
 44261                                  	db	8Bh, 0E1h
 44262                                  	db	2Eh, 66h, 0A1h
 44263                                  
 44264                                  rpRepl5o1Len equ $ - rpRepl5
 44265                                  
 44266                                  	db	00h, 00h
 44267                                  	db	2Eh, 66h, 8Bh, 36h
 44268                                  
 44269                                  rpRepl5o2Len equ $ - rpRepl5
 44270                                  
 44271                                  	db	00h, 00h
 44272                                  	db	0FFh, 0E3h
 44273                                  
 44274                                  rpRepl5Len equ	$ - rpRepl5
 44275                                  
 44276                                  ;	mov	sp, cx
 44277                                  ;	mov	eax, dword ptr cs:[xxxx]
 44278                                  ;	mov	esi, dword ptr cs:[xxxx]
 44279                                  ;	jmp	bx
 44280                                  
 44281                                  ; bug # 3 -- loss of high EAX, EBX, ECX, EDX on 386+ only if VCPI
 44282                                  
 44283                                  rpFind6:
 44284                                  	db	0FAh, 52h, 51h
 44285                                  
 44286                                  rpFind6Len equ	$ - rpFind6
 44287                                  
 44288                                  ;	cli
 44289                                  ;	push	dx
 44290                                  ;	push	cx
 44291                                  
 44292                                  rpFind7a:
 44293                                  	db	0B8h, 0Ch, 0DEh, 66h, 26h, 0FFh, 1Eh
 44294                                  
 44295                                  rpFind7aLen equ	$ - rpFind7a
 44296                                  
 44297                                  ;	mov	ax, 0DE0Ch
 44298                                  ;	call	fword ptr es:[xxxx]
 44299                                  
 44300                                  rpFind7b:
 44301                                  	db	59h, 5Ah, 5Bh
 44302                                  
 44303                                  rpFind7bLen equ	$ - rpFind7b
 44304                                  
 44305                                  ;	pop	cx
 44306                                  ;	pop	dx
 44307                                  ;	pop	bx
 44308                                  
 44309                                  rpRepl6 :
 44310                                  	db	0FAh, 66h, 50h, 66h, 53h, 66h, 51h, 66h, 52h
 44311                                  
 44312                                  rpRepl6Len equ	$ - rpRepl6
 44313                                  
 44314                                  ;	cli
 44315                                  ;	push	eax
 44316                                  ;	push	ebx
 44317                                  ;	push	ecx
 44318                                  ;	push	edx
 44319                                  
 44320                                  rpRepl7:
 44321                                  	db	66h, 5Ah, 66h, 59h, 66h, 5Bh, 66h, 58h, 5Bh
 44322                                  
 44323                                  rpRepl7Len equ	$ - rpRepl7
 44324                                  
 44325                                  ;	pop	edx
 44326                                  ;	pop	ecx
 44327                                  ;	pop	ebx
 44328                                  ;	pop	eax
 44329                                  ;	pop	bx
 44330                                  
 44331                                  ; bug # 4 -- loss of high EAX and EBX on 386+ only if VCPI
 44332                                  
 44333                                  rpFind8:
 44334                                   	db	60h, 06h, 1Eh, 0B8h, 00h, 00h, 8Eh, 0D8h
 44335                                  
 44336                                  rpFind8Len equ	$ - rpFind8
 44337                                  
 44338                                  ;	pusha
 44339                                  ;	push	es
 44340                                  ;	push	ds
 44341                                  ;	mov	ax, dgroup	;jump back to here from replace8
 44342                                  ;	mov	ds, ax
 44343                                  
 44344                                  rpFind9 :
 44345                                  	db	1Fh, 07h, 61h
 44346                                  
 44347                                  rpFind9Len equ	$ - rpFind9
 44348                                  
 44349                                  ;	pop	ds
 44350                                  ;	pop	es
 44351                                  ;	popa
 44352                                  
 44353                                  rpRepl8:
 44354                                   	db	66h, 60h, 06h, 1Eh
 44355                                  
 44356                                  rpRepl8Len equ	$ - rpRepl8
 44357                                  
 44358                                  ;	pushad
 44359                                  ;	push	es
 44360                                  ;	push	ds
 44361                                  
 44362                                  rpRepl9:
 44363                                  	db	1Fh, 07h, 66h, 61h, 0C3h
 44364                                  
 44365                                  rpRepl9Len equ	$ - rpRepl9
 44366                                  
 44367                                  ;	pop	ds
 44368                                  ;	pop	es
 44369                                  ;	popad
 44370                                  ;	retn			;no need to jmp back to main-line
 44371                                  
 44372                                  ;----------------------------------------------------------------------------
 44373                                  
 44374                                  struc SearchPair
 44375                                   .sp_off1: resw 1	; offset of 1st search string
 44376                                   .sp_len1: resw 1	; length of 1st search string
 44377                                   .sp_off2: resw 1	; 2nd string
 44378                                   .sp_len2: resw 1	; 2nd string
 44379                                   .sp_diff: resw 1	; max difference between offsets
 44380                                   .size:
 44381                                  endstruc
 44382                                  
 44383                                  ;rpBug1Strs SearchPair	<offset rpFind2, rpFind2Len, offset rpFind3, rpFind3Len, 20h>
 44384                                  
 44385                                  rpBug1Strs:
 44386                                  	dw	rpFind2
 44387                                  	dw	rpFind2Len ; 3
 44388                                  	dw	rpFind3
 44389                                  	dw	rpFind3Len ; 4
 44390                                  	dw	20h
 44391                                  
 44392                                  ;rpBug2Strs SearchPair	<offset rpFind4, rpFind4Len, offset rpFind5, rpFind5Len, 80h>
 44393                                  
 44394                                  rpBug2Strs:
 44395                                  	dw	rpFind4
 44396                                  	dw	rpFind4Len ; 4
 44397                                  	dw	rpFind5
 44398                                  	dw	rpFind5Len ; 9
 44399                                  	dw	80h
 44400                                  
 44401                                  ;rpBug3Strs SearchPair	<offset rpFind6, rpFind6Len, offset rpFind7a, rpFind7aLen, 80h>
 44402                                  
 44403                                  rpBug3Strs:
 44404                                  	dw	rpFind6
 44405                                  	dw	rpFind6Len ; 3
 44406                                  	dw	rpFind7a
 44407                                  	dw	rpFind7aLen ; 7
 44408                                  	dw	80h
 44409                                  
 44410                                  ;rpBug4Strs SearchPair	<offset rpFind8, 4, offset rpFind9, rpFind9Len, 80h>
 44411                                  
 44412                                  rpBug4Strs:
 44413                                  	dw	rpFind8
 44414                                  	dw	4
 44415                                  	dw	rpFind9
 44416                                  	dw	rpFind9Len ; 3
 44417                                  	dw	80h
 44418                                  
 44419                                  ;----------------------------------------------------------------------------
 44420                                  
 44421                                  struc StackVars
 44422                                   .sv_wVersion:	resw 1		; Rational extender version #
 44423                                   .sv_cbCodeSeg: resw 1		; code seg size to scan
 44424                                   .sv_pPatch:	resw 1		; offset of next avail patch byte
 44425                                   .size:
 44426                                  endstruc
 44427                                  
 44428                                  ;----------------------------------------------------------------------------
 44429                                  
 44430                                  ; 22/05/2019 - Retro DOS v4.0
 44431                                  
 44432                                  Rational386Patch:
 44433                                  	; Do a few quick checks to see if this looks like a Rational
 44434                                  	; Extended application. Hopefully this will quickly weed out
 44435                                  	; most non Rational apps.
 44436                                  
 44437                                  	cmp	word [es:0],395		; version number goes here - versions
 44438                                  	jae	short rp3QuickOut	;   3.95+ don't need patching
 44439                                  
 44440                                  	cmp	word [es:0Ch],20h	; always has this value here
 44441                                  	jne	short rp3QuickOut
 44442                                  
 44443                                  	push	ax
 44444                                  
 44445                                  	mov	ax,18h 			; extender has 18h at
 44446                                  	cmp	[es:24],ax		;   offsets 24, 28, & 36
 44447                                  	jne	short rp3QO_ax
 44448                                  	cmp	[es:28],ax
 44449                                  	jne	short rp3QO_ax
 44450                                  	cmp	[es:36],ax
 44451                                  	je	short rp3Maybe
 44452                                  rp3QO_ax:
 44453                                  	pop	ax
 44454                                  rp3QuickOut:
 44455                                  	retn
 44456                                  
 44457                                  ; It might be the rational extender, do more extensive checking
 44458                                  
 44459                                  rp3Maybe:
 44460                                  	cld
 44461                                  	push	bx			; note ax pushed above
 44462                                  	push	cx
 44463                                  	push	dx
 44464                                  	push	si
 44465                                  	push	di
 44466                                  	push	es
 44467                                  	push	ds			; we use all of them
 44468                                  	push	bp
 44469                                  	sub	sp,StackVars.size  ; 6	; make space for stack variables
 44470                                  	mov	bp,sp
 44471                                  
 44472                                  	push	cs
 44473                                  	pop	ds
 44474                                  
 44475                                  	mov	ax,[es:0]		; save version #
 44476                                  	;mov	[bp+StackVars.sv_wVersion],ax
 44477                                  	mov	[bp],ax	
 44478                                  					; check that binary version # matches
 44479                                  	call	VerifyVersion		;   ascii string
 44480                                  	jne	short rp3Exit_j
 44481                                  
 44482                                  ; Looks like this is it, find where to put the patch code.  The
 44483                                  ; patch will be located on top of Rational code specific to 80286
 44484                                  ; processors, so these patchs MUST NOT be applied if running on
 44485                                  ; an 80286 system.
 44486                                  
 44487                                  	; Rational says the code to patch will never be beyond offset 46xxh
 44488                                  
 44489                                  	mov	cx,4500h		; force search len to 4700h (searches
 44490                                  	;mov	[bp+2],cx
 44491                                  	mov	[bp+StackVars.sv_cbCodeSeg],cx	; start at offset 200h)
 44492                                  
 44493                                  	mov	es,[es:20h]		; es=code segment
 44494                                  
 44495                                  	mov	si,rpFind1		; string to find
 44496                                  	mov	dx,rpFind1Len ; 10	; length to match
 44497                                  	call	ScanCodeSeq		; look for code seq
 44498                                  	jz	short rpGotPatch
 44499                                  
 44500                                  ; According to Rational, some very old versions of the extender may not
 44501                                  ; have the find1 code sequence. If the find1 code wasn't found above,
 44502                                  ; try an alternative patch area which is on top of NEC 98xx switching code.
 44503                                  
 44504                                  	mov	si,rpFind1a
 44505                                  	mov	dx,rpFind1aLen  ;8
 44506                                  	call	ScanCodeSeq
 44507                                  	jz	short rpGotPatch
 44508                                  
 44509                                  rp3Exit_j:
 44510                                  	jmp	rp3Exit
 44511                                  
 44512                                  ; Found the location to write patch code! DI = offset in code seg.
 44513                                  
 44514                                  rpGotPatch:
 44515                                  	;mov	[bp+4],di
 44516                                  	mov	[bp-StackVars.sv_pPatch],di	; save patch pointer
 44517                                  
 44518                                  ;----------------------------------------------------------------------------
 44519                                  ; Bug # 1 -- loss of high EAX on 386+ if not VCPI or DPMI
 44520                                  
 44521                                  	;cmp	word [bp+0],381
 44522                                  	;cmp	word [bp+StackVars.sv_wVersion],381 ; only need bug 1 if version
 44523                                  	cmp	word [bp],381
 44524                                  	jae	short rpBug2			;   < 3.81
 44525                                  
 44526                                  	mov	bx,rpBug1Strs			; locate find2 & find3 code
 44527                                  	call	FindBadCode
 44528                                  	jc	short rpBug2
 44529                                  
 44530                                  ; si = rpFind2 offset, di = rpFind3 offset
 44531                                  
 44532                                  	push	di
 44533                                  	mov	di,si				; rpFind2 offset
 44534                                  	mov	dx,rpFind2Len ; 3
 44535                                  
 44536                                  	cmp	byte [es:di-1],51h	 	; find2 preceeded by push cx?
 44537                                  	jne	short rp_no_cx
 44538                                  
 44539                                  	dec	di				;   yes, gobble up push cx too
 44540                                  	inc	dx
 44541                                  rp_no_cx:
 44542                                  	mov	si,rpRepl2			; patch out find2 sequence
 44543                                  	mov	cx,rpRepl2Len  ; 6
 44544                                  	call	GenPatch
 44545                                  
 44546                                  	pop	di				; rpFind3 offset
 44547                                  	cmp	byte [es:di-1],59h 		; find3 preceeded by pop cx?
 44548                                  	jne	short rp_no_cx2
 44549                                  
 44550                                  	mov	byte [es:di-1],90h		;   yes, no-op it
 44551                                  rp_no_cx2:
 44552                                  	;mov	ax,[bp+4]
 44553                                  	mov	ax,[bp+StackVars.sv_pPatch]	; change offset of far jmp
 44554                                  	;mov	[es:di+4],ax
 44555                                  	mov	[es:di+rpFind3Len],ax		;   to go to patch code
 44556                                  
 44557                                  	push	di				; save find3 offset
 44558                                  	mov	si,rpRepl3			; copy repl3 to patch area
 44559                                  	mov	cx,rpRepl3Len ; 5
 44560                                  	call	CopyPatch
 44561                                  
 44562                                  	pop	bx				; find3 offset
 44563                                  	add	bx,rpFind3Len+4	 ; 8		; skip over find3 and far jmp
 44564                                  	call	GenJump 			; jmp back from patch area
 44565                                  	;mov	[bp+4],di
 44566                                  	mov	[bp+StackVars.sv_pPatch], di	;   to main-line, update patch
 44567                                  						;   area pointer
 44568                                  
 44569                                  ;----------------------------------------------------------------------------
 44570                                  ; Bug # 2 -- loss of high regs on 386+ under VCPI only
 44571                                  
 44572                                  rpBug2:
 44573                                  	mov	bx,rpBug2Strs			; locate find4 & find5 code
 44574                                  	call	FindBadCode
 44575                                  	jc	short rpBug3
 44576                                  
 44577                                  ; si = rpFind4 offset, di = rpFind5 offset
 44578                                  
 44579                                  	;push	word [bp+4]
 44580                                  	push	word [bp+StackVars.sv_pPatch]	; save current patch pointer
 44581                                  						;   (where repl4 goes)
 44582                                  	push	di				; save find5 offset
 44583                                  
 44584                                  	mov	di,si
 44585                                  	mov	dx,rpFind4Len ; 4
 44586                                  	mov	si,rpRepl4
 44587                                  	mov	cx,rpRepl4Len ; 15
 44588                                  	call	GenPatch			; patch out find4 code
 44589                                  
 44590                                  	pop	di				; find5 offset
 44591                                  	add	di,5				; keep 5 bytes of find5 code
 44592                                  	;mov	bx,[bp+4]
 44593                                  	mov	bx,[bp+StackVars.sv_pPatch]	; jump to patch area
 44594                                  	push	bx				; save repl5 location
 44595                                  	call	GenJump
 44596                                  
 44597                                  	mov	si,rpRepl5			; copy repl5 code to patch
 44598                                  	mov	cx,rpRepl5Len  ; 15		;   area -- it has a jmp bx
 44599                                  	call	CopyPatch			;   so no need to jmp back to
 44600                                  						;   main-line code
 44601                                  
 44602                                  ; patches have been made, now update the patch code to store/load dwords just
 44603                                  ; after the code in the patch area
 44604                                  
 44605                                  	pop	di				; repl5 location
 44606                                  	pop	si				; repl4 location
 44607                                  
 44608                                  	;mov	ax,[bp+4]
 44609                                  	mov	ax,[bp+StackVars.sv_pPatch]	; (where dwords go)
 44610                                  
 44611                                  	;mov	[es:si+7],ax
 44612                                  	mov	[es:si+rpRepl4o1Len],ax		; offset for EAX
 44613                                  	;mov	[es:di+5],ax
 44614                                  	mov	[es:di+rpRepl5o1Len],ax
 44615                                  	add	ax,4
 44616                                  	;mov	[es:si+0Dh],ax
 44617                                  	mov	[es:si+rpRepl4o2Len],ax		; offset for ESI
 44618                                  	;mov	[es:di+0Bh],ax
 44619                                  	mov	[es:di+rpRepl5o2Len],ax
 44620                                  
 44621                                  	;add	word [bp+4],8
 44622                                  	add	word [bp+StackVars.sv_pPatch],8	; reserve space for 2 dwords in
 44623                                  						; patch area
 44624                                  
 44625                                  ;----------------------------------------------------------------------------
 44626                                  ; Bug # 3 -- loss of high regs on 386+ under VCPI only
 44627                                  
 44628                                  rpBug3:
 44629                                  	mov	bx,rpBug3Strs			; locate find6 & find7a code
 44630                                  	call	FindBadCode
 44631                                  	jc	short rpBug4
 44632                                  
 44633                                  	;add	di,9
 44634                                  	add	di,rpFind7aLen + 2		; skip over offset in find7a
 44635                                  	push	si				;   code and locate find7b
 44636                                  	mov	si,rpFind7b			;   sequence
 44637                                  	mov	dx,rpFind7bLen ; 3
 44638                                  	call	ScanCodeSeq_di
 44639                                  	pop	si
 44640                                  	jnz	short rpBug4
 44641                                  
 44642                                  	push	di				; save find7b code offset
 44643                                  
 44644                                  	mov	di,si
 44645                                  	mov	dx,rpFind6Len ; 3
 44646                                  	mov	si,rpRepl6
 44647                                  	mov	cx,rpRepl6Len ; 9
 44648                                  	call	GenPatch			; patch out find6 code
 44649                                  
 44650                                  	pop	di
 44651                                  	mov	dx,rpFind7bLen ; 3
 44652                                  	mov	si,rpRepl7
 44653                                  	mov	cx,rpRepl7Len ; 9
 44654                                  	call	GenPatch			; patch out find7b code
 44655                                  
 44656                                  ;----------------------------------------------------------------------------
 44657                                  ; Bug # 4 -- loss of high regs on 386+ under VCPI only
 44658                                  
 44659                                  rpBug4:
 44660                                  	;cmp	word [bp+0],360
 44661                                  	;cmp	word [bp+StackVars.sv_wVersion],360 ; only applies if 
 44662                                  	cmp	word [bp],360
 44663                                  	jbe	short rp3Exit 			; version > 3.60 and < 3.95
 44664                                  
 44665                                  	mov	bx,rpBug4Strs			; locate find8 & find9 code
 44666                                  	call	FindBadCode
 44667                                  	jc	short rp3Exit
 44668                                  
 44669                                  	push	di				; save find9 code offset
 44670                                  
 44671                                  	mov	di,si
 44672                                  	mov	dx,3
 44673                                  	mov	si,rpRepl8
 44674                                  	mov	cx,rpRepl8Len ; 4
 44675                                  	call	GenPatch			; patch out find8 code
 44676                                  
 44677                                  	pop	di				; find9 offset
 44678                                  	;mov	bx,[bp+4]
 44679                                  	mov	bx,[bp+StackVars.sv_pPatch]	; patch find9 to jmp to
 44680                                  	call	GenJump 			;   patch area
 44681                                  
 44682                                  	mov	si,rpRepl9			; copy replacement code to
 44683                                  	mov	cx,rpRepl9Len ; 5		;   patch area--it does a RET
 44684                                  	call	CopyPatch			;   so no jmp back to main-line
 44685                                  
 44686                                  rp3Exit:
 44687                                  	add	sp,StackVars.size
 44688                                  	pop	bp
 44689                                  	pop	ds
 44690                                  	pop	es
 44691                                  	pop	di
 44692                                  	pop	si
 44693                                  	pop	dx
 44694                                  	pop	cx
 44695                                  	pop	bx
 44696                                  	pop	ax
 44697                                  	retn
 44698                                  
 44699                                  ;----------------------------------------------------------------------------
 44700                                  ;
 44701                                  ; FindBadCode
 44702                                  ;
 44703                                  ; Searches Rational code segment looking for a pair of find strings (all
 44704                                  ; patches have at least two find strings).
 44705                                  ;
 44706                                  ; Entry:
 44707                                  ;	ES    = code segment to search
 44708                                  ;	DS:BX = search pair structure for this search
 44709                                  ;	[bp].sv_cbCodeSeg = length of code seg to search
 44710                                  ;
 44711                                  ; Exit:
 44712                                  ;	CY flag clear if both strings found, and
 44713                                  ;	SI    = offset in ES of 1st string
 44714                                  ;	DI    = offset in ES of 2nd string
 44715                                  ;	CY set if either string not found, or strings too far apart
 44716                                  ;
 44717                                  ; Used:
 44718                                  ;	CX
 44719                                  ;
 44720                                  ;----------------------------------------------------------------------------
 44721                                  
 44722                                  ;struc SearchPair
 44723                                  ; .sp_off1: resw 1	; offset of 1st search string
 44724                                  ; .sp_len1: resw 1	; length of 1st search string
 44725                                  ; .sp_off2: resw 1	; 2nd string
 44726                                  ; .sp_len2: resw 1	; 2nd string
 44727                                  ; .sp_diff: resw 1	; max difference between offsets
 44728                                  ; .size:
 44729                                  ;endstruc
 44730                                  
 44731                                  FindBadCode:
 44732                                  	;mov	cx,[bp+2]
 44733                                  	mov	cx,[bp+StackVars.sv_cbCodeSeg]	; search length
 44734                                  
 44735                                  	mov	si,[bx]	; mov si,[bx+0]
 44736                                  	;mov	si,[bx+Searchpair.sp_off1] ; ds:si -> search string
 44737                                  	
 44738                                  	;mov	dx,[bx+2]
 44739                                  	mov	dx,[bx+SearchPair.sp_len1] ; dx = search len
 44740                                  	call	ScanCodeSeq
 44741                                  	jnz	short fbc_error		; done if 1st not found
 44742                                  
 44743                                  	push	di			; save 1st string offset
 44744                                  
 44745                                  	;mov	si,[bx+4]
 44746                                  	mov	si,[bx+SearchPair.sp_off2]
 44747                                  	;mov	dx,[bx+6]
 44748                                  	mov	dx,[bx+SearchPair.sp_len2]
 44749                                  	call	ScanCodeSeq_di		; don't change flags after this!
 44750                                  
 44751                                  	pop	si			; restore 1st string offset
 44752                                  	jnz	short fbc_error
 44753                                  
 44754                                  	mov	ax,di			; sanity check that
 44755                                  	sub	ax,si			;   si < di && di - si <= allowed diff
 44756                                  	jc	short fbc_error
 44757                                  	;cmp	ax,[bx+8]
 44758                                  	cmp	ax,[bx+SearchPair.sp_diff]
 44759                                  	ja	short fbc_error
 44760                                  
 44761                                  	clc
 44762                                  	retn
 44763                                  
 44764                                  fbc_error:
 44765                                  	stc
 44766                                  	retn
 44767                                  
 44768                                  ;----------------------------------------------------------------------------
 44769                                  ;
 44770                                  ; GenPatch
 44771                                  ;
 44772                                  ; Generate a patch sequence. 1) insert a jump at the buggy code location
 44773                                  ; (jumps to the patch code area), 2) copy the selected patch code to the
 44774                                  ; patch area, 3) insert a jump from the patch area back to the main-line
 44775                                  ; code.
 44776                                  ;
 44777                                  ; Entry:
 44778                                  ;	ES:DI = start of buggy code to be patched
 44779                                  ;	DX    = length of buggy code to be patched
 44780                                  ;	DS:SI = replacement patch code
 44781                                  ;	CX    = length of replacement patch code
 44782                                  ;	[bp].sv_pPatch = offset in ES of where to copy patch code
 44783                                  ;
 44784                                  ; Exit:
 44785                                  ;	DI, [bp].sv_pPatch = byte after generated patch code
 44786                                  ;
 44787                                  ; Used:
 44788                                  ;	AX, BX, SI, Flags
 44789                                  ;
 44790                                  ;----------------------------------------------------------------------------
 44791                                  
 44792                                  GenPatch:
 44793                                  	push	di			;save offset of buggy code
 44794                                  
 44795                                  	;mov	bx,[bp+4]
 44796                                  	mov	bx,[bp+StackVars.sv_pPatch]
 44797                                  					;jump from buggy code to patch area
 44798                                  	call	GenJump
 44799                                  
 44800                                  	call	CopyPatch		;copy replacement code to patch area
 44801                                  
 44802                                  	pop	bx			;offset of buggy code + buggy code
 44803                                  	add	bx,dx			;  length = return from patch offset
 44804                                  
 44805                                  	call	GenJump 		;jump from patch area back to main-
 44806                                  	;mov	[bp+4],di
 44807                                  	mov	[bp+StackVars.sv_pPatch],di
 44808                                  					;  line code, update patch pointer
 44809                                  	retn
 44810                                  
 44811                                  ;----------------------------------------------------------------------------
 44812                                  ;
 44813                                  ; CopyPatch
 44814                                  ;
 44815                                  ; Copies patch code to patch location.
 44816                                  ;
 44817                                  ; Entry:
 44818                                  ;	DS:SI = patch code to be copied
 44819                                  ;	ES    = segment of code to patch
 44820                                  ;	CX    = length of code to copy
 44821                                  ;	[bp].sv_pPatch = offset in ES of where to copy patch code
 44822                                  ;
 44823                                  ; Exit:
 44824                                  ;	DI, [bp].sv_pPatch = byte after copied patch code
 44825                                  ;
 44826                                  ; Used:
 44827                                  ;	SI, Flags
 44828                                  ;
 44829                                  ;----------------------------------------------------------------------------
 44830                                  
 44831                                  CopyPatch:
 44832                                  	push	cx
 44833                                  	;mov	di,[bp+4]
 44834                                  	mov	di,[bp+StackVars.sv_pPatch] ;patch pointer is the dest offset
 44835                                  	cld
 44836                                  	rep movsb
 44837                                  	pop	cx
 44838                                  	;mov	[bp+4],di
 44839                                  	mov	[bp+StackVars.sv_pPatch],di ;update net pointer location
 44840                                  	retn
 44841                                  
 44842                                  ;----------------------------------------------------------------------------
 44843                                  ;
 44844                                  ; GenJump
 44845                                  ;
 44846                                  ; Generates a rel16 JMP instruction at location 'from' to location 'to'.
 44847                                  ;
 44848                                  ; Entry:
 44849                                  ;	ES:DI = from location (where to put jmp instruction)
 44850                                  ;	BX    = to location (where to jump to)
 44851                                  ;
 44852                                  ; Exit:
 44853                                  ;	DI = byte after generated jump
 44854                                  ;
 44855                                  ; Used:
 44856                                  ;	AX
 44857                                  ;
 44858                                  ;----------------------------------------------------------------------------
 44859                                  
 44860                                  GenJump:
 44861                                  	mov	al,0E9h		; jmp rel16 opcode
 44862                                  	stosb
 44863                                  
 44864                                  	mov	ax,bx		; calc offset to 'to' location
 44865                                  	sub	ax,di
 44866                                  	sub	ax,2
 44867                                  
 44868                                  	stosw			; output offset
 44869                                  
 44870                                  	retn
 44871                                  
 44872                                  ;----------------------------------------------------------------------------
 44873                                  ;
 44874                                  ; ScanCodeSeq
 44875                                  ;
 44876                                  ; Looks for a pattern pointed to by DS:SI & len DX in ES:200 to ES:200+CX-1
 44877                                  ;
 44878                                  ; returns in ES:DI the start of the pattern if Zero flag is set
 44879                                  ;
 44880                                  ;----------------------------------------------------------------------------
 44881                                  
 44882                                  ScanCodeSeq:
 44883                                  	mov	di,200h
 44884                                  ScanCodeSeq_di:
 44885                                  	push	cx
 44886                                  	sub	cx,dx
 44887                                  	inc	cx
 44888                                  scsagain:
 44889                                  	push	si
 44890                                  	push	di
 44891                                  	push	cx
 44892                                  	mov	cx,dx
 44893                                  	rep	cmpsb
 44894                                  	pop	cx
 44895                                  	pop	di
 44896                                  	pop	si
 44897                                  	je	short scsfound
 44898                                  	inc	di
 44899                                  	loop	scsagain
 44900                                  scsfound:
 44901                                  	pop	cx
 44902                                  vvexit:		; 18/12/2022
 44903                                  	retn
 44904                                  	
 44905                                  ;----------------------------------------------------------------------------
 44906                                  ;
 44907                                  ; VerifyVersion
 44908                                  ;
 44909                                  ; Checks whether the binary version from ES:0 matches the ASCII version
 44910                                  ; from ES:2A.
 44911                                  ;
 44912                                  ;       Entry: AX = binary version number 
 44913                                  ;       Exit : Z flag set if version numbers match
 44914                                  ;
 44915                                  ;----------------------------------------------------------------------------
 44916                                  
 44917                                  VerifyVersion:
 44918                                  	mov	si,[es:2Ah]		; offset of version number
 44919                                  					;  in ascii
 44920                                  	mov	bl,10
 44921                                  	add	si,3			; point to last digit
 44922                                  
 44923                                  	call	VVDigit
 44924                                  	jne	short vvexit
 44925                                  	call	VVDigit
 44926                                  	jne	short vvexit
 44927                                  	cmp	byte [es:si],'.'
 44928                                  	jne	short vvexit
 44929                                  	dec	si
 44930                                  	;call	VVDigit
 44931                                  	; 18/12/2022
 44932                                  	;jmp	short VVDigit
 44933                                  ;vvexit:
 44934                                  	;retn
 44935                                  VVDigit:
 44936                                  	div	bl
 44937                                  	add	ah,'0'
 44938                                  	dec	si
 44939                                  	cmp	[es:si+1],ah
 44940                                  	mov	ah,0			; do not xor or sub we need Z
 44941                                  	retn
 44942                                  
 44943                                  %endif
 44944                                  
 44945                                  ;-----------------------------------------------------------------------
 44946                                  
 44947                                  ; 23/05/2019 - Retro DOS v4.0
 44948                                  ; DOSCODE:B702h (MSDOS 6.21, MSDOS.SYS)
 44949                                  
 44950                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 44951                                  ; DOSCODE:B3E0h (MSDOS 5.0, MSDOS.SYS)
 44952                                  
 44953                                  exepatch_start:	 ; label byte
 44954                                  
 44955                                  	; The following is the code that'll be layed over the buggy unpack
 44956                                  	; code.
 44957                                  str1:
 44958 00007E13 06                      	db  06h	  		;push	es		 
 44959 00007E14 8CD8                    	db  8Ch,0D8h		;mov	ax,ds 
 44960                                  
 44961                                  first_stop equ	$-str1
 44962                                  			
 44963 00007E16 2BC2                    	db  2Bh, 0C2h		;sub	ax, dx			
 44964                                  
 44965                                  first:  ; label	byte
 44966                                  
 44967 00007E18 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 44968 00007E1A 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 44969 00007E1C BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 44970 00007E1F 57                      	db  57h	    		;push	di
 44971 00007E20 B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 44972 00007E23 B0FF                    	db  0B0h,0FFh 		;mov	al,0FFH 		
 44973 00007E25 F3AE                    	db  0F3h,0AEh 		;repz	scasb			
 44974 00007E27 47                      	db  47h	    		;inc	di			
 44975 00007E28 8BF7                    	db  8Bh,0F7h  		;mov	si,di			
 44976 00007E2A 5F                      	db  5Fh	    		;pop	di
 44977 00007E2B 58                      	db  58h	    		;pop	ax
 44978                                  
 44979                                  second_stop equ	$-first
 44980                                  
 44981 00007E2C 2BC2                    	db  2Bh,0C2h  		;sub	ax, dx			
 44982                                  
 44983                                  second: ; label	byte
 44984                                  
 44985 00007E2E 8EC0                    	db  8Eh,0C0h  		;mov	es,ax			
 44986                                  		    		;NextRec:				
 44987 00007E30 B90402                  	db  0B9h,04h,02h	;mov	cx, 0204h
 44988                                  		    		;norm_agn:				
 44989 00007E33 8BC6                    	db  8Bh,0C6h		;mov	ax,si			
 44990 00007E35 F7D0                    	db  0F7h,0D0h		;not	ax		
 44991 00007E37 D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 44992 00007E39 7413                    	db  74h,13h		;jz	short SI_ok			
 44993 00007E3B 8CDA                    	db  8Ch,0DAh		;mov	dx,ds			
 44994 00007E3D 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H
 44995 00007E40 2BD0                    	db  2Bh,0D0h		;sub	dx,ax			
 44996 00007E42 7308                    	db  73h,08h		;jnc	short SItoDS			
 44997 00007E44 F7DA                    	db  0F7h,0DAh		;neg	dx			
 44998 00007E46 D3E2                    	db  0D3h,0E2h		;shl	dx,cl			
 44999 00007E48 2BF2                    	db  2Bh,0F2h		;sub	si,dx			
 45000 00007E4A 33D2                    	db  33h,0D2h		;xor	dx,dx			
 45001                                  				;SItoDS: 				
 45002 00007E4C 8EDA                    	db  8Eh,0DAh		;mov	ds,dx		
 45003                                  				;SI_ok:					
 45004 00007E4E 87F7                    	db  87h,0F7h		;xchg	si,di			
 45005 00007E50 1E                      	db  1Eh			;push	ds			
 45006 00007E51 06                      	db  06h			;push	es			
 45007 00007E52 1F                      	db  1Fh			;pop	ds			
 45008 00007E53 07                      	db  07h			;pop	es			
 45009 00007E54 FECD                    	db  0FEh,0CDh		;dec	ch			
 45010 00007E56 75DB                    	db  75h,0DBh		;jnz	short norm_agn		
 45011 00007E58 AC                      	db  0ACh		;lodsb			
 45012 00007E59 92                      	db  92h			;xchg	dx,ax
 45013 00007E5A 4E                      	db  4Eh			;dec	si
 45014 00007E5B AD                      	db  0ADh		;lodsw			
 45015 00007E5C 8BC8                    	db  8Bh,0C8h		;mov	cx,ax		
 45016 00007E5E 46                      	db  46h			;inc	si		
 45017 00007E5F 8AC2                    	db  8Ah,0C2h		;mov	al,dl		
 45018 00007E61 24FE                    	db  24h,0FEh		;and	al,0FEH		
 45019 00007E63 3CB0                    	db  3Ch,0B0h		;cmp	al,RPTREC
 45020 00007E65 7505                    	db  75h,05h		;jne	short TryEnum
 45021 00007E67 AC                      	db  0ACh		;lodsb				
 45022 00007E68 F3AA                    	db  0F3h,0AAh		;rep stosb			
 45023                                  
 45024                                  ;	db  0EBh,07h,90h	;jmp	short TryNext
 45025 00007E6A EB06                    	db  0EBh,06h		;jmp	short TryNext
 45026                                  
 45027                                  				;TryEnum:
 45028 00007E6C 3CB2                    	db  3Ch,0B2h		;cmp	al,ENMREC
 45029 00007E6E 756C                    	db  75h,6Ch		;jne	short CorruptExe		
 45030 00007E70 F3A4                    	db  0F3h,0A4h		;rep movsb			
 45031                                  				;TryNext:
 45032                                  
 45033 00007E72 92                      	db  92h			;xchg	dx,ax
 45034                                  ;	db  8Ah,0C2h		;mov	al,dl			
 45035                                  
 45036 00007E73 A801                    	db  0A8h,01h		;test	al,1			
 45037 00007E75 74B9                    	db  74h,0B9h		;jz	short NextRec			
 45038 00007E77 9090                    	db  90h,90h		;nop,nop
 45039                                  	
 45040                                  last_stop equ $-second
 45041                                  size_str1 equ $-str1
 45042                                  
 45043                                  	; The following is the code that we need to look for in the exe
 45044                                  	; file.
 45045                                  
 45046                                  scan_patch1: ; label byte
 45047                                  
 45048 00007E79 8CC3                    	db  8Ch,0C3h		;mov	bx,es			
 45049 00007E7B 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 45050 00007E7D 2BC2                    	db  2Bh,0C2h		;sub	ax,dx
 45051 00007E7F 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 45052 00007E81 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 45053 00007E83 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 45054 00007E86 B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 45055 00007E89 B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 45056 00007E8B F3AE                    	db  0F3h,0AEh		;repz	scasb			
 45057 00007E8D 47                      	db  47h			;inc	di			
 45058 00007E8E 8BF7                    	db  8Bh,0F7h		;mov	si,di
 45059 00007E90 8BC3                    	db  8Bh,0C3h		;mov	ax,bx			
 45060 00007E92 2BC2                    	db  2Bh,0C2h		;sub	ax, dx
 45061 00007E94 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 45062 00007E96 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 45063                                  				;NextRec:
 45064 00007E99 B104                    	db  0B1h,04h		;mov	cl,4
 45065 00007E9B 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 45066 00007E9D F7D0                    	db  0F7h,0D0h		;not	ax		
 45067 00007E9F D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 45068 00007EA1 7409                    	db  74h,09h		;jz	short SI_ok
 45069 00007EA3 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 45070 00007EA5 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 45071 00007EA7 8EDA                    	db  8Eh,0DAh		;mov	ds,dx		
 45072 00007EA9 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H	       
 45073                                  	       			;SI_ok:
 45074 00007EAC 8BC7                    	db  8Bh,0C7h		;mov	ax,di		
 45075 00007EAE F7D0                    	db  0F7h,0D0h		;not	ax
 45076 00007EB0 D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 45077 00007EB2 7409                    	db  74h,09h		;jz	short DI_ok
 45078 00007EB4 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 45079 00007EB6 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 45080 00007EB8 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 45081 00007EBA 83CFF0                  	db  83h,0CFh,0F0h	;or	di,0FFF0H
 45082                                  				;DI_ok:
 45083                                  
 45084                                  size_scan_patch1 equ $-scan_patch1
 45085                                  
 45086                                  scan_patch2: ; label byte
 45087                                  			
 45088 00007EBD 8CC3                    	db  8Ch,0C3h		;mov	bx,es			
 45089 00007EBF 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 45090 00007EC1 48                      	db  48h			;dec	ax
 45091 00007EC2 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 45092 00007EC4 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 45093 00007EC6 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 45094 00007EC9 B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 45095 00007ECC B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 45096 00007ECE F3AE                    	db  0F3h,0AEh		;repz	scasb			
 45097 00007ED0 47                      	db  47h			;inc	di			
 45098 00007ED1 8BF7                    	db  8Bh,0F7h		;mov	si,di
 45099 00007ED3 8BC3                    	db  8Bh,0C3h		;mov	ax,bx			
 45100 00007ED5 48                      	db  48h			;dec	ax
 45101 00007ED6 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 45102 00007ED8 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH		
 45103                                  				;NextRec:
 45104 00007EDB B104                    	db  0B1h,04h		;mov	cl,4
 45105 00007EDD 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 45106 00007EDF F7D0                    	db  0F7h,0D0h		;not	ax		
 45107 00007EE1 D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 45108 00007EE3 740A                    	db  74h,0Ah		;jz	short SI_ok
 45109 00007EE5 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 45110 00007EE7 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 45111 00007EE9 8EDA                    	db  8Eh,0DAh		;mov	ds,dx		
 45112 00007EEB 81CEF0FF                	db  81h,0CEh,0F0h,0FFh
 45113                                  				;or	si,0FFF0H
 45114                                  				;SI_ok:
 45115 00007EEF 8BC7                    	db  8Bh,0C7h		;mov	ax,di		
 45116 00007EF1 F7D0                    	db  0F7h,0D0h		;not	ax
 45117 00007EF3 D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 45118 00007EF5 740A                    	db  74h,0Ah		;jz	short DI_ok
 45119 00007EF7 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 45120 00007EF9 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 45121 00007EFB 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 45122 00007EFD 81CFF0FF                	db  81h,0CFh,0F0h,0FFh
 45123                                  				;or	di,0FFF0H
 45124                                  				;DI_ok:
 45125                                  
 45126                                  size_scan_patch2 equ $-scan_patch2
 45127                                  
 45128                                  scan_patch3: ; label byte
 45129                                  
 45130 00007F01 8CC3                    	db  8Ch,0C3h		;mov	bx,es			
 45131 00007F03 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 45132 00007F05 48                      	db  48h			;dec	ax
 45133 00007F06 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 45134 00007F08 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 45135 00007F0A BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 45136 00007F0D B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 45137 00007F10 B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 45138 00007F12 F3AE                    	db  0F3h,0AEh		;repz	scasb			
 45139 00007F14 47                      	db  47h			;inc	di			
 45140 00007F15 8BF7                    	db  8Bh,0F7h		;mov	si,di
 45141 00007F17 8BC3                    	db  8Bh,0C3h		;mov	ax,bx			
 45142 00007F19 48                      	db  48h			;dec	ax
 45143 00007F1A 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 45144 00007F1C BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH		
 45145                                  				;NextRec:
 45146 00007F1F B104                    	db  0B1h,04h		;mov	cl,4
 45147 00007F21 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 45148 00007F23 F7D0                    	db  0F7h,0D0h		;not	ax		
 45149 00007F25 D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 45150 00007F27 7409                    	db  74h,09h		;jz	short SI_ok
 45151 00007F29 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 45152 00007F2B 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 45153 00007F2D 8EDA                    	db  8Eh,0DAh		;mov	ds,dx	
 45154 00007F2F 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H	
 45155                                  				;SI_ok:
 45156 00007F32 8BC7                    	db  8Bh,0C7h		;mov	ax,di		
 45157 00007F34 F7D0                    	db  0F7h,0D0h		;not	ax
 45158 00007F36 D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 45159 00007F38 7409                    	db  74h,09h		;jz	short DI_ok
 45160 00007F3A 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 45161 00007F3C 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 45162 00007F3E 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 45163 00007F40 83CFF0                  	db  83h,0CFh,0F0h	;or	di,0FFF0H
 45164                                  				;DI_ok:
 45165                                  
 45166                                  size_scan_patch3 equ $-scan_patch3
 45167                                  
 45168                                  scan_com: ; label byte
 45169                                  
 45170 00007F43 AC                      	db  0ACh		;lodsb			
 45171 00007F44 8AD0                    	db  8Ah,0D0h		;mov	dl,al		
 45172 00007F46 4E                      	db  4Eh			;dec	si
 45173 00007F47 AD                      	db  0ADh		;lodsw			
 45174 00007F48 8BC8                    	db  8Bh,0C8h		;mov	cx,ax		
 45175 00007F4A 46                      	db  46h			;inc	si		
 45176 00007F4B 8AC2                    	db  8Ah,0C2h		;mov	al,dl		
 45177 00007F4D 24FE                    	db  24h,0FEh		;and	al,0FEH		
 45178 00007F4F 3CB0                    	db  3Ch,0B0h		;cmp	al,RPTREC
 45179 00007F51 7506                    	db  75h,06h		;jne	short TryEnum
 45180 00007F53 AC                      	db  0ACh		;lodsb				
 45181 00007F54 F3AA                    	db  0F3h,0AAh		;rep stosb			
 45182 00007F56 EB0790                  	db  0EBh,07h,90h	;jmp	short TryNext
 45183                                  				;TryEnum:
 45184 00007F59 3CB2                    	db  3Ch,0B2h		;cmp	al,ENMREC
 45185 00007F5B 756B                    	db  75h,6Bh		;jne	short CorruptExe		
 45186 00007F5D F3A4                    	db  0F3h,0A4h		;rep movsb			
 45187                                  				;TryNext:
 45188 00007F5F 8AC2                    	db  8Ah,0C2h		;mov	al,dl			
 45189 00007F61 A801                    	db  0A8h,01h		;test	al,1			
 45190                                  ;	db  74h,0BAh		;jz	short NextRec			
 45191                                  
 45192                                  size_scan_com	equ	$-scan_com
 45193                                  
 45194                                  ;-----------------------------------------------------------------------
 45195                                  
 45196                                  ; 23/05/2019 - Retro DOS v4.0
 45197                                  ; DOSCODE:B852h (MSDOS 6.21, MSDOS.SYS)
 45198                                  
 45199                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45200                                  ; DOSCODE:B530h (MSDOS 5.0, MSDOS.SYS)
 45201                                  
 45202                                  ExePatch:
 45203                                  	; 28/12/2022 - Retro DOS v4.1
 45204                                  	;call	ExePackPatch
 45205                                  	;;call	word [ss:RationalPatchPtr]
 45206                                  	;retn
 45207                                  	; 28/12/2022
 45208                                  	;jmp	short ExePackPatch
 45209                                  
 45210                                  ;-----------------------------------------------------------------------
 45211                                  ;
 45212                                  ; Procedure Name 	: ExePackPatch
 45213                                  ;
 45214                                  ; Inputs	 	: DS 			-> DOSDATA
 45215                                  ;			  ES:0 			-> read in image
 45216                                  ;			  ax:cx = start cs:ip of program
 45217                                  ; Output		:		
 45218                                  ;
 45219                                  ;	1. If ES <= 0fffh
 45220                                  ;	   2. if exepack signature ('RB') found
 45221                                  ;	      3. if common code to patch compares (for 3 diff. versions)
 45222                                  ;	       	 4. if rest of the code & checksum compares
 45223                                  ;	  	    5. overlay buggy code with code in 
 45224                                  ;		       doscode:str1.
 45225                                  ;		 6. endif
 45226                                  ;	      7. endif
 45227                                  ;	   8. endif
 45228                                  ;	9. endif
 45229                                  ;
 45230                                  ;
 45231                                  ; Uses			: NONE
 45232                                  ;
 45233                                  ;-----------------------------------------------------------------------
 45234                                  		
 45235                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45236                                  	; 23/05/2019 - Retro DOS v4.0	
 45237                                  ExePackPatch:
 45238 00007F63 53                      	push	bx
 45239 00007F64 8CC3                    	mov	bx,es			; bx has load segment
 45240 00007F66 81FBFF0F                	cmp	bx,0FFFh		; Q: is the load segment > 64K
 45241 00007F6A 7602                    	jbe	short ep_cont		; N: 
 45242 00007F6C 5B                      	pop	bx			; Y: no need to patch
 45243 00007F6D C3                      	retn
 45244                                  ep_cont:
 45245 00007F6E 1E                      	push	ds
 45246 00007F6F 06                      	push	es
 45247 00007F70 50                      	push	ax
 45248 00007F71 51                      	push	cx
 45249 00007F72 56                      	push	si
 45250 00007F73 57                      	push	di
 45251                                  	
 45252                                  		; M033 - start
 45253                                  		; exepacked programs have an IP of 12h (>=2)
 45254                                  
 45255 00007F74 83E902                  	sub	cx,2			; Q: is IP >=2 
 45256 00007F77 7303                    	jnb	short epp_1		; N: exit
 45257 00007F79 E9C500                  	jmp	ep_notpacked
 45258                                  					; ax:cx now points to location of
 45259                                  					; 'RB' if this is an exepacked file.
 45260                                  		; M033 - end
 45261                                  epp_1:
 45262 00007F7C 89CF                    	mov	di,cx
 45263 00007F7E 8EC0                    	mov	es,ax
 45264 00007F80 36893E[8700]            	mov	[ss:UNPACK_OFFSET],di	; save pointer to 'RB' in 
 45265                                  					; unpack_offset
 45266                                  
 45267 00007F85 26813D5242              	cmp	word [es:di],'RB' ; 4252h
 45268                                  	;ljne	ep_notpacked
 45269 00007F8A 7403                    	je	short epp_2
 45270 00007F8C E9B200                  	jmp	ep_notpacked
 45271                                  epp_2:
 45272 00007F8F 0E                      	push	cs
 45273 00007F90 1F                      	pop	ds			; set ds to cs
 45274                                  
 45275                                  	;add	di,6Ch
 45276 00007F91 83C76C                  	add	di,PATCH1_COM_OFFSET	; es:di -> points to place in packed 
 45277                                  					;          file where we hope to find
 45278                                  					;	   scan string. 
 45279                                  
 45280 00007F94 E8B200                  	call	chk_common_str		; check for match
 45281                                  
 45282 00007F97 7524                    	jnz	short ep_chkpatch2	; Q: does the patch match
 45283                                  					; N: check at patch2_offset
 45284                                  					; Y: check for rest of patch string
 45285 00007F99 BE[797E]                	mov	si,scan_patch1
 45286                                  					; ds:si -> scan string 
 45287 00007F9C 368B3E[8700]            	mov	di,[ss:UNPACK_OFFSET]	; restore di to point to 'RB'
 45288                                  
 45289                                  	;add	di,28h
 45290                                  	; 07/12/2022
 45291 00007FA1 83C728                  	add	di,PATCH1_OFFSET	; es:di -> points to place in packed 
 45292                                  					;          file where we hope to find
 45293                                  					;	   scan string. 
 45294                                  	;mov	cx,68
 45295 00007FA4 B94400                  	mov	cx,size_scan_patch1
 45296                                  	;mov	bx,142
 45297 00007FA7 BB8E00                  	mov	bx,CHKSUM1_LEN
 45298                                  	;mov	ax,0EF4Eh
 45299 00007FAA B84EEF                  	mov	ax,PATCH1_CHKSUM
 45300 00007FAD E8AD00                  	call	chk_patchsum		; check if patch and chk sum compare
 45301 00007FB0 7208                    	jc	short ep_done1		; Q: did we pass the test
 45302                                  					; N: exit
 45303                                  					; Y: overlay code with new 
 45304 00007FB2 BE[137E]                	mov	si,str1
 45305                                  	;mov	cx,102
 45306 00007FB5 B96600                  	mov	cx,size_str1
 45307                                  	
 45308 00007FB8 F3A4                    	rep	movsb
 45309                                  ep_done1:
 45310 00007FBA E98400                  	jmp	ep_done
 45311                                  
 45312                                  ep_chkpatch2:
 45313                                  	;mov	di,76h
 45314 00007FBD BF7600                  	mov	di,PATCH2_COM_OFFSET	; es:di -> possible location of patch
 45315                                  					; in another version of unpack
 45316 00007FC0 E88600                  	call	chk_common_str		; check for match
 45317                                  
 45318 00007FC3 7544                    	jnz	short ep_chkpatch3	; Q: does the patch match
 45319                                  					; N: check for patch3_offset
 45320                                  					; Y: check for rest of patch string
 45321                                  
 45322 00007FC5 BE[BD7E]                	mov	si,scan_patch2
 45323                                  					; ds:si -> scan string 
 45324                                  	;mov	di,32h
 45325 00007FC8 BF3200                  	mov	di,PATCH2_OFFSET	; es:di -> points to place in packed 
 45326                                  					;          file where we hope to find
 45327                                  	;mov	cx,68			;	   scan string. 
 45328 00007FCB B94400                  	mov	cx,size_scan_patch2
 45329                                  	;mov	bx,140
 45330 00007FCE BB8C00                  	mov	bx,CHKSUM2_LEN
 45331                                  	;mov	ax,78B2h
 45332 00007FD1 B8B278                  	mov	ax,PATCH2_CHKSUM
 45333 00007FD4 E88600                  	call	chk_patchsum		; check if patch and chk sum compare
 45334                                  
 45335                                  					; M046 - Start
 45336                                  					; Q: did we pass the test
 45337 00007FD7 7311                    	jnc	short ep_patchcode2		; Y: overlay code with new 
 45338                                  					; N: try with a different chksum
 45339                                  
 45340 00007FD9 BE[BD7E]                	mov	si,scan_patch2
 45341                                  					; ds:si -> scan string 
 45342                                  	;mov	cx,68
 45343 00007FDC B94400                  	mov	cx,size_scan_patch2
 45344                                  	;mov	bx,129
 45345 00007FDF BB8100                  	mov	bx,CHKSUM2A_LEN
 45346                                  	;mov	ax,1C47h
 45347 00007FE2 B8471C                  	mov	ax,PATCH2A_CHKSUM
 45348 00007FE5 E87500                  	call	chk_patchsum		; check if patch and chk sum compare
 45349                                  					; Q: did we pass the test
 45350 00007FE8 7257                    	jc	short ep_notpacked		; N: try with a different chksum
 45351                                  					; Y: overlay code with new 
 45352                                  						
 45353                                  ep_patchcode2:			       	; M046 - End
 45354 00007FEA BE[137E]                	mov	si,str1
 45355                                  	;mov	cx,3
 45356 00007FED B90300                  	mov	cx,first_stop
 45357 00007FF0 F3A4                    	rep	movsb
 45358 00007FF2 B89048                  	mov	ax,4890h		; ax = opcodes for dec ax, nop
 45359 00007FF5 AB                      	stosw
 45360 00007FF6 83C602                  	add	si,2
 45361                                  	;mov	cx,20
 45362 00007FF9 B91400                  	mov	cx,second_stop
 45363 00007FFC F3A4                    	rep	movsb
 45364 00007FFE AB                      	stosw				; put in dec ax and nop
 45365 00007FFF 83C602                  	add	si,2
 45366                                  	;mov	cx,75
 45367 00008002 B94B00                  	mov	cx,last_stop
 45368 00008005 F3A4                    	rep	movsb
 45369 00008007 EB38                    	jmp	short ep_done
 45370                                  
 45371                                  ep_chkpatch3:
 45372                                  	;mov	di,74h
 45373 00008009 BF7400                  	mov	di,PATCH3_COM_OFFSET	; es:di -> possible location of patch
 45374                                  					; in another version of unpack
 45375 0000800C E83A00                  	call	chk_common_str		; check for match
 45376                                  
 45377 0000800F 7530                    	jnz	short ep_notpacked	; Q: does the patch match
 45378                                  					; N: exit
 45379                                  					; Y: check for rest of patch string
 45380 00008011 BE[017F]                	mov	si,scan_patch3
 45381                                  					; ds:si -> scan string 
 45382                                  	;mov	di,32h
 45383 00008014 BF3200                  	mov	di,PATCH3_OFFSET	; es:di -> points to place in packed 
 45384                                  					;          file where we hope to find
 45385                                  					;	   scan string. 
 45386                                  	;mov	cx,66
 45387 00008017 B94200                  	mov	cx,size_scan_patch3
 45388                                  	;mov	bx,139
 45389 0000801A BB8B00                  	mov	bx,CHKSUM3_LEN
 45390                                  	;mov	ax,4EDEh
 45391 0000801D B8DE4E                  	mov	ax,PATCH3_CHKSUM
 45392 00008020 E83A00                  	call	chk_patchsum		; check if patch and chk sum compare
 45393 00008023 721C                    	jc	short ep_notpacked	; Q: did we pass the test
 45394                                  					; N: exit
 45395                                  					; Y: overlay code with new 
 45396 00008025 BE[137E]                	mov	si,str1
 45397                                  	;mv	cx,3
 45398 00008028 B90300                  	mov	cx,first_stop
 45399 0000802B F3A4                    	rep	movsb
 45400 0000802D B048                    	mov	al,48h			; al = opcode for dec ax
 45401 0000802F AA                      	stosb
 45402 00008030 83C602                  	add	si,2
 45403                                  	;mov	cx,20
 45404 00008033 B91400                  	mov	cx,second_stop
 45405 00008036 F3A4                    	rep	movsb
 45406 00008038 AA                      	stosb				; put in dec ax
 45407 00008039 83C602                  	add	si,2
 45408                                  	;mov	cx,75
 45409 0000803C B94B00                  	mov	cx,last_stop
 45410 0000803F F3A4                    	rep	movsb
 45411                                  
 45412                                  ep_notpacked:
 45413                                  	;stc
 45414                                  ep_done:
 45415 00008041 5F                      	pop	di
 45416 00008042 5E                      	pop	si
 45417 00008043 59                      	pop	cx
 45418 00008044 58                      	pop	ax
 45419 00008045 07                      	pop	es
 45420 00008046 1F                      	pop	ds
 45421 00008047 5B                      	pop	bx
 45422 00008048 C3                      	retn
 45423                                  
 45424                                  ;-------------------------------------------------------------------------
 45425                                  ;
 45426                                  ; 	Procedure Name	: chk_common_str
 45427                                  ;
 45428                                  ;	Input		: DS = DOSCODE
 45429                                  ;			; ES:DI points to string in packed file
 45430                                  ;
 45431                                  ;	Output		; Z if match else NZ
 45432                                  ;
 45433                                  ;-------------------------------------------------------------------------
 45434                                  
 45435                                  	; 23/05/2019 - Retro DOS v4.0
 45436                                  chk_common_str:
 45437 00008049 BE[437F]                	mov	si,scan_com
 45438                                  					; ds:si -> scan string 
 45439                                  	;mov	cx,32
 45440 0000804C B92000                  	mov	cx,size_scan_com
 45441                                  
 45442 0000804F F3A6                    	repe	cmpsb	       
 45443                                  
 45444                                  					; M046 - start
 45445                                  	; a fourth possible version of these exepacked programs have a 
 45446                                  	; 056h instead of 06Bh. See scan_com above
 45447                                  	;
 45448                                  	; 	db  75h, 6Bh		;jne CorruptExe		
 45449                                  	;
 45450                                  	; If the mismatch at this point is due to a 56h instead of 6Bh 
 45451                                  	; we shall try to match the rest of the string
 45452                                  	;
 45453                                  
 45454 00008051 7409                    	jz	short ccs_done
 45455 00008053 26807DFF56              	cmp	byte [es:di-1],56h
 45456 00008058 7502                    	jnz	short ccs_done
 45457                                  
 45458 0000805A F3A6                    	repe	cmpsb	    
 45459                                  ccs_done:				; M046 - end
 45460 0000805C C3                      	retn
 45461                                  
 45462                                  ;-------------------------------------------------------------------------
 45463                                  ;
 45464                                  ;	Procedure Name	: chk_patchsum
 45465                                  ;
 45466                                  ;	Input		: DS:SI -> string we're looking for
 45467                                  ;			: ES:DI -> offset in packed file
 45468                                  ;			: CX 	= scan length
 45469                                  ;			: BX	= length of check sum
 45470                                  ;			: AX 	= value of check sum
 45471                                  ;
 45472                                  ;	Output		: if patch & check sum compare
 45473                                  ;				NC
 45474                                  ;			  else
 45475                                  ;				CY
 45476                                  ;
 45477                                  ;	Uses		: AX, BX, CX, SI
 45478                                  ;
 45479                                  ;-------------------------------------------------------------------------
 45480                                  
 45481                                  	; 23/05/2019 - Retro DOS v4.0
 45482                                  chk_patchsum:
 45483 0000805D 57                      	push	di
 45484                                  
 45485 0000805E F3A6                    	repe	cmpsb			   
 45486                                  
 45487 00008060 7518                    	jnz	short cp_fail		; Q: does the patch match
 45488                                  					; N: exit
 45489                                  					; Y:	
 45490                                  
 45491                                  		; we do a check sum starting from the location of the 
 45492                                  		; exepack signature 'RB' up to 11c/2 bytes, the end of the
 45493                                  		; unpacking code.
 45494                                  
 45495 00008062 368B3E[8700]            	mov	di,[ss:UNPACK_OFFSET]	; di -> start of unpack code
 45496 00008067 89D9                    	mov	cx,bx			; cx = length of check sum
 45497                                  
 45498 00008069 89C3                    	mov	bx,ax			; save check sum passed to us in bx
 45499 0000806B 31C0                    	xor	ax,ax
 45500                                  ep_chksum:
 45501 0000806D 260305                  	add	ax,[es:di]
 45502 00008070 83C702                  	add	di,2
 45503 00008073 E2F8                    	loop	ep_chksum
 45504                                  
 45505 00008075 5F                      	pop	di			; restore di
 45506                                  
 45507 00008076 39D8                    	cmp	ax,bx		 	; Q: does the check sum match
 45508                                  	;jne	short cp_fail		; N: exit
 45509                                  					; Y: 
 45510                                  	; 25/09/2023
 45511                                  	;clc	
 45512                                  	;retn
 45513 00008078 74E2                    	je	short ccs_done ; cf=0
 45514                                  	
 45515                                  cp_fail:
 45516 0000807A F9                      	stc
 45517 0000807B C3                      	retn
 45518                                  
 45519                                  ; 28/12/2022 - Retro DOS v4.1
 45520                                  %if 0
 45521                                  ;--------------------------------------------------------------------------- 
 45522                                  
 45523                                  
 45524                                  ; M020 : BEGIN
 45525                                  ;
 45526                                  ;---------------------------------------------------------------------------
 45527                                  ;
 45528                                  ; procedure : RationalPatch
 45529                                  ;
 45530                                  ; A routine (in Ration DOS extender) which is invoked at hardware interrupts
 45531                                  ; clobbers CX register on 286 machines. (123 release 3 uses Rational DOS
 45532                                  ; extender). This routine identifies Buggy Rational EXEs and fixes the bug.
 45533                                  ;
 45534                                  ; THE BUG is in the following code sequence:
 45535                                  ;
 45536                                  ;8b 0e 10 00	mov	cx, ds:[10h]		; delay count
 45537                                  ;90		even				; word align
 45538                                  ;e2 fe		loop	$			; wait		CLOBBERS CX
 45539                                  ;e8 xx xx	call	set_A20			; enable A20
 45540                                  ;
 45541                                  ; This patch routine replaces the mov & the loop with a far call into a
 45542                                  ; routine in DOS data segment which is in low memory (because A20 line
 45543                                  ; is off). The routine (RatBugCode) in DOS data saves & restores CX around
 45544                                  ; a mov & loop.
 45545                                  ;
 45546                                  ; Identification of Buggy Rational EXE
 45547                                  ; ====================================
 45548                                  ;
 45549                                  ; (ALL OFFSETS ARE IN THE PROGRAM SECTION - EXCLUDING THE EXE HEADER)
 45550                                  ;
 45551                                  ; OFFSET				Contains
 45552                                  ; ------				--------
 45553                                  ; 0000h			100 times Version number in binary
 45554                                  ;			bug exists in version 3.48 thru 3.83 (both inclusive)
 45555                                  ;
 45556                                  ; 000ah			the WORDS : 0000h, 0020h, 0000h, 0040h, 0001h
 45557                                  ;
 45558                                  ; 002ah			offset where version number is stored in ASCII
 45559                                  ;				e.g. '3.48A'
 45560                                  ;
 45561                                  ; 0030h			offset of copyright string. Copyright strings either
 45562                                  ;			start with "DOS/16M Copyright...." or
 45563                                  ;			"Copyright.....". The string contains
 45564                                  ;			"Rational Systems, Inc."
 45565                                  ;
 45566                                  ; 0020h			word : Paragraph offset of the buggy code segment
 45567                                  ;				from the program image
 45568                                  ; 0016h			word : size of buggy code segment
 45569                                  ;
 45570                                  ;	Buggy code is definite to start after offset 200h in its segment
 45571                                  ;
 45572                                  ;----------------------------------------------------------------------------
 45573                                  
 45574                                  ; 23/05/2019 - Retro DOS v4.0
 45575                                  ; DOSCODE:B976h (MSDOS 6.21, MSDOS.SYS)
 45576                                  
 45577                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45578                                  ; DOSCODE:B654h (MSDOS 5.0, MSDOS.SYS)
 45579                                  
 45580                                  RScanPattern1:
 45581                                  	db	0, 0, 20h, 0, 0, 0, 40h, 0, 1, 0
 45582                                  
 45583                                  RLen1 equ $ - RScanPattern1
 45584                                  
 45585                                  RScanPattern2:
 45586                                  	db	8Bh, 0Eh, 10h, 00h, 90h, 0E2h, 0FEh, 0E8h
 45587                                  
 45588                                  RLen2 equ $ - RScanPattern2
 45589                                  
 45590                                  RScanPattern3:
 45591                                  	db	8Bh, 0Eh, 10h, 00h, 0E2h, 0FEh, 0E8h
 45592                                  
 45593                                  RLen3 equ $ - RScanPattern2
 45594                                  
 45595                                  ; DOSCODE:B98Fh (MSDOS 6.21, MSDOS.SYS)
 45596                                  ; DOSCODE:B66Dh (MSDOS 5.0, MSDOS.SYS)
 45597                                  
 45598                                  ;----------------------------------------------------------------------------
 45599                                  ;
 45600                                  ; INPUT : ES = segment where program got loaded
 45601                                  ;
 45602                                  ;----------------------------------------------------------------------------
 45603                                  
 45604                                  RationalPatch:
 45605                                  	cld
 45606                                  	push	ax
 45607                                  	push	bx
 45608                                  	push	cx
 45609                                  	push	dx
 45610                                  	push	si
 45611                                  	push	di
 45612                                  	push	es
 45613                                  	push	ds			; we use all of them
 45614                                  	mov	di,0Ah			; look for pat1 at offset 0Ah
 45615                                  	push	cs
 45616                                  	pop	ds
 45617                                  	
 45618                                  	mov	si,RScanPattern1
 45619                                  	;mov	cx,10
 45620                                  	mov	cx,RLen1
 45621                                  	rep	cmpsb			; do we have the pattern ?
 45622                                  	jne	short rpexit
 45623                                  	mov	ax,[es:0]
 45624                                  	cmp	ax,348			; is it a buggy version ?
 45625                                  	jb	short rpexit
 45626                                  	cmp	ax,383			; is it a buggy version
 45627                                  	ja	short rpexit
 45628                                  
 45629                                  	call	VerifyVersion
 45630                                  	jne	short rpexit
 45631                                  
 45632                                  	mov	cx,[es:16h]		; Length of buggy code seg
 45633                                  	sub	cx,200h			; Length we search (we start
 45634                                  					;  at offset 200h)
 45635                                  	mov	es,[es:20h]		; es=buggy code segment
 45636                                  	mov	si,RScanPattern2
 45637                                  	;mov	dx,8	
 45638                                  	mov	dx,RLen2
 45639                                  	call	ScanCodeSeq		; look for code seq with nop
 45640                                  	jz	short rpfound
 45641                                  
 45642                                  	mov	si,RScanPattern3
 45643                                  	;mov	dx,15
 45644                                  	mov	dx,RLen3
 45645                                  	call	ScanCodeSeq		; look for code seq w/o nop
 45646                                  	jnz	short rpexit
 45647                                  
 45648                                  rpfound:
 45649                                  	
 45650                                  ;	we set up a far call into DOS data
 45651                                  ;	dx has the length of the code seq we were searching for
 45652                                  
 45653                                  	mov	al,9Ah			; far call opcode
 45654                                  	stosb
 45655                                  	mov	ax,RatBugCode
 45656                                  	stosw
 45657                                  	mov	ax,ss
 45658                                  	stosw
 45659                                  	mov	cx,dx
 45660                                  	sub	cx,6			; filler (with NOPs)
 45661                                  	mov	al,90h
 45662                                  	rep	stosb
 45663                                  rpexit:
 45664                                  	pop	ds
 45665                                  	pop	es
 45666                                  	pop	di
 45667                                  	pop	si
 45668                                  	pop	dx
 45669                                  	pop	cx
 45670                                  	pop	bx
 45671                                  	pop	ax
 45672                                  	retn
 45673                                  
 45674                                  ; M020 END
 45675                                  
 45676                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45677                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
 45678                                  
 45679                                  ; DOSCODE:B6D8h (MSDOS 5.0, MSDOS.SYS)
 45680                                  
 45681                                  ;----------------------------------------------------------------------------
 45682                                  ;
 45683                                  ; ScanCodeSeq
 45684                                  ;
 45685                                  ; Looks for a pattern pointed to by DS:SI & len DX in ES:200 to ES:200+CX-1
 45686                                  ;
 45687                                  ; returns in ES:DI the start of the pattern if Zero flag is set
 45688                                  ;
 45689                                  ;----------------------------------------------------------------------------
 45690                                  
 45691                                  ScanCodeSeq:
 45692                                  	; 17/12/2022
 45693                                  	mov	di,200h
 45694                                  ;ScanCodeSeq_di:
 45695                                  	push	cx
 45696                                  	sub	cx,dx
 45697                                  	inc	cx
 45698                                  	; 17/12/2022
 45699                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 45700                                  	;mov	di,200h
 45701                                  scsagain:
 45702                                  	push	si
 45703                                  	push	di
 45704                                  	push	cx
 45705                                  	mov	cx,dx
 45706                                  	rep	cmpsb
 45707                                  	pop	cx
 45708                                  	pop	di
 45709                                  	pop	si
 45710                                  	je	short scsfound
 45711                                  	inc	di
 45712                                  	loop	scsagain
 45713                                  scsfound:
 45714                                  	pop	cx
 45715                                  vvexit:		; 18/12/2022
 45716                                  	retn
 45717                                  
 45718                                  
 45719                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45720                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
 45721                                  
 45722                                  ; DOSCODE:B6F0h (MSDOS 5.0, MSDOS.SYS)
 45723                                  
 45724                                  ;----------------------------------------------------------------------------
 45725                                  ;
 45726                                  ; VerifyVersion
 45727                                  ;
 45728                                  ; Checks whether the binary version from ES:0 matches the ASCII version
 45729                                  ; from ES:2A.
 45730                                  ;
 45731                                  ;       Entry: AX = binary version number 
 45732                                  ;       Exit : Z flag set if version numbers match
 45733                                  ;
 45734                                  ;----------------------------------------------------------------------------
 45735                                  
 45736                                  VerifyVersion:
 45737                                  	mov	si,[es:2Ah]		; offset of version number
 45738                                  					;  in ascii
 45739                                  	mov	bl,10
 45740                                  	add	si,3			; point to last digit
 45741                                  
 45742                                  	call	VVDigit
 45743                                  	jne	short vvexit
 45744                                  	call	VVDigit
 45745                                  	jne	short vvexit
 45746                                  	cmp	byte [es:si],'.' ; 2Eh
 45747                                  	jne	short vvexit
 45748                                  	dec	si
 45749                                  	;call	VVDigit
 45750                                  	; 18/12/2022
 45751                                  	;jmp	short VVDigit
 45752                                  ;vvexit:
 45753                                  	;retn
 45754                                  VVDigit:
 45755                                  	div	bl
 45756                                  	add	ah,'0' ; 30h
 45757                                  	dec	si
 45758                                  	cmp	[es:si+1],ah
 45759                                  	mov	ah,0			; do not xor or sub we need Z
 45760                                  	retn
 45761                                  
 45762                                  ;--------------------------------------------------------------------------- 
 45763                                  %endif	; 28/12/2022
 45764                                  
 45765                                  ;---------------------------------------------------------------------------
 45766                                  ;
 45767                                  ;	M068
 45768                                  ;
 45769                                  ; 	Procedure Name	: IsCopyProt
 45770                                  ;
 45771                                  ;	Inputs		: DS:100 -> start of com file just read in
 45772                                  ;
 45773                                  ;	Outputs		: sets the A20OFF_COUNT variable to 10 if 
 45774                                  ;			  the program loaded in DS:100 uses a MICROSOFT
 45775                                  ;			  copy protect scheme that relies on the A20 line
 45776                                  ;			  being turned off for it's scheme to work.
 45777                                  ;
 45778                                  ;			  Note: The int 21 function dispatcher will turn 
 45779                                  ;				a20 off, if the A20OFF_COUNT is non-zero 
 45780                                  ;				and dec the A20OFF_COUNT before	iretting 
 45781                                  ;				to the user. 
 45782                                  ;
 45783                                  ;	Uses		: ES, DI, SI, CX
 45784                                  ;
 45785                                  ;---------------------------------------------------------------------------
 45786                                  
 45787                                  ; 23/05/2019 - Retro DOS v4.0
 45788                                  
 45789                                  CPStartOffset	EQU	0175h
 45790                                  CPID1Offset	EQU	011Bh
 45791                                  CPID2Offset	EQU	0173h
 45792                                  CPID3Offset	EQU	0146h
 45793                                  CPID4Offset	EQU	0124h
 45794                                  ID1		EQU	05343h
 45795                                  ID2		EQU	05044h
 45796                                  ID3		EQU	0F413h
 45797                                  ID4		EQU	08000h
 45798                                  
 45799                                  ; DOSCODE:B9FAh (MSDOS 6.21, MSDOS.SYS)
 45800                                  
 45801                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45802                                  ; DOSCODE:B71Ch (MSDOS 5.0, MSDOS.SYS)
 45803                                  
 45804                                  CPScanPattern:
 45805 0000807C 89264801                	db	89h,26h,48h,01h		 ; mov [148],sp
 45806 00008080 8C0E4C01                	db	8Ch,0Eh,4Ch,01h		 ; mov [14C],cs
 45807 00008084 C7064A010001            	db	0C7h,06h,4Ah,01h,00h,01h ; mov [14A],100h 
 45808 0000808A 8C0E1301                	db 	8Ch,0Eh,13h,01h		 ; mov [113],cs
 45809 0000808E B82001                  	db	0B8h,20h,01h		 ; mov ax,120h
 45810 00008091 BE0001                  	db	0BEh,00h,01h		 ; mov si,100h
 45811                                  
 45812                                  CPSPlen	EQU $ - CPScanPattern
 45813                                  
 45814                                  ; DOSCODE:BA12h (MSDOS 6.21, MSDOS.SYS)
 45815                                  ; DOSCODE:B734h (MSDOS 5.0, MSDOS.SYS)
 45816                                  
 45817                                  IsCopyProt:
 45818 00008094 813E1B014353            	cmp	word [CPID1Offset],ID1
 45819 0000809A 752D                    	jne	short CP_done
 45820                                  
 45821 0000809C 813E73014450            	cmp	word [CPID2Offset],ID2
 45822 000080A2 7525                    	jne	short CP_done
 45823                                  
 45824 000080A4 813E460113F4            	cmp	word [CPID3Offset],ID3
 45825 000080AA 751D                    	jne	short CP_done
 45826                                  
 45827 000080AC 813E24010080            	cmp	word [CPID4Offset],ID4
 45828 000080B2 7515                    	jne	short CP_done
 45829                                  
 45830 000080B4 0E                      	push	cs
 45831 000080B5 07                      	pop	es
 45832 000080B6 BF[7C80]                	mov	di,CPScanPattern	; es:di -> Pattern to find
 45833                                  
 45834 000080B9 BE7501                  	mov	si,CPStartOffset	; ds:si -> possible location 
 45835                                  					; of pattern
 45836                                  
 45837 000080BC B91800                  	mov	cx,CPSPlen ; 24		; cx = length of pattern
 45838 000080BF F3A6                    	repe	cmpsb
 45839 000080C1 7506                    	jnz	short CP_done
 45840                                  
 45841 000080C3 36C606[8500]0A          	mov	byte [ss:A20OFF_COUNT],0Ah ; M071
 45842                                  CP_done:
 45843 000080C9 C3                      	retn
 45844                                  	
 45845                                  ;DOSCODE ENDS
 45846                                  
 45847                                  	;END
 45848                                  
 45849                                  ;----------------------------------------------------------------------------
 45850                                  
 45851                                  ;align 2 ; 05/09/2018 (Error!)
 45852                                  
 45853                                  ; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45854                                  ;align 16 ; 08/09/2018 (OK.)
 45855                                  align 2
 45856                                  
 45857                                  ; 06/08/2018 - Retro DOS v3.0
 45858                                  ;============================================================================
 45859                                  ; MSINIT.ASM
 45860                                  ;============================================================================
 45861                                  ; 22/04/2019 - Retro DOS v4.0 (MSINIT.ASM, MSDOS 6.0, 1991)
 45862                                  ;
 45863                                  ; MAIN ENTRY FOR DOS INITIALIZATION
 45864                                  ;
 45865                                  	; 15/07/2018 - Retro DOS v3.0
 45866                                  	; (MSDOS 3.3, IBMDOS.COM, 1987)
 45867                                  
 45868                                  ; temp iret instruction
 45869                                  
 45870                                  
 45871                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45872                                  ; DOSCODE:B76Ah (MSDOS 5.0, MSDOS.SYS)
 45873                                  
 45874                                  initiret: ; MSDOS 6.0
 45875                                  SYSBUF:
 45876                                  ;IRETT: ; 06/05/2019
 45877 000080CA CF                      	iret
 45878                                  
 45879                                  ; 22/04/2019 - Retro DOS v4.0
 45880                                  
 45881                                  ; pointer to the BIOS data segment that will be available just to the
 45882                                  ; initialization code
 45883                                  
 45884 000080CB 7000                    InitBioDataSeg:	dw 70h ; KERNEL_SEGMENT = 0070h
 45885                                  
 45886                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45887                                  ; DOSCODE:B76Dh (MSDOS 5.0, MSDOS.SYS)
 45888                                  
 45889                                  ; Convert AX from a number of bytes to a number of paragraphs (round up).
 45890                                  
 45891                                  ParaRound:
 45892 000080CD 83C00F                  	add	ax, 15
 45893 000080D0 D1D8                    	rcr	ax, 1
 45894 000080D2 D1E8                    	shr	ax, 1
 45895 000080D4 D1E8                    	shr	ax, 1
 45896 000080D6 D1E8                    	shr	ax, 1
 45897 000080D8 C3                      	retn
 45898                                  
 45899                                  ; MAIN ENTRY FOR DOS INITIALIZATION
 45900                                  
 45901                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45902                                  	; DOSCODE:B779h (MSDOS 5.0, MSDOS.SYS)
 45903                                  	
 45904                                  	; 30/05/2019
 45905                                  	; 22/04/2019 - Retro DOS v4.0
 45906                                  	; 07/07/2018 - Retro DOS v3.0
 45907                                  	; Retro DOS v2.0 - 03/03/2018
 45908                                  	; 03/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45909                                  	; MSDOS 5.0 - MSDOS.SYS, offset 79A9h
 45910                                  DOSINIT:
 45911                                  	; MSDOS 6.21 - MSDOS.SYS, offset 7C77h
 45912                                  	;
 45913                                  	; Far call from SYSINIT
 45914                                  	; DX = Memory size in paragraphs
 45915                                  	; DS:SI = [DEVICE_LIST] (SYSINIT.S) 
 45916                                  	;	  (Retro DOS v2.0, 16/03/2018)
 45917                                  	;
 45918                                  	; ES:DI = ptr to BIOS communication block (sysinit3.s)
 45919                                  	;	  (Retro DOS v4.0, 20/04/2019)
 45920                                  
 45921 000080D9 FA                              CLI
 45922 000080DA FC                              CLD
 45923                                  
 45924                                  	; 03/11/2022
 45925                                  	;push	dx ; 30/05/2019		; save parameters from BIOS
 45926                                  	
 45927                                  	; 17/12/2022
 45928                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 45929                                  	;push	dx ; =*=		; save parameters from BIOS
 45930                                  	
 45931 000080DB 56                      	push	si
 45932 000080DC 1E                      	push	ds
 45933 000080DD 57                      	push	di			;save di (ptr to BiosComBlock)
 45934                                  
 45935 000080DE 8CC3                    	mov	bx,es			;bx:di = ptr to BiosComBlock
 45936                                  
 45937                                  ; First, move the DOS data segment to its final location in low memory
 45938                                  
 45939                                  	;;mov	ax,0BF69h ; MSDOS 6.21 MSDOS.SYS, file offset 7C7Fh
 45940                                  	;mov	ax,0BC77h ; MSDOS 5.0 MSDOS.SYS, file offset 79B1h	
 45941 000080E0 B8[5A85]                	mov	ax,MEMSTRT		; get offset of end of init code
 45942                                  
 45943                                  	;add	ax,15	; 0Fh		; round to nearest paragraph
 45944                                  	;and	ax,~15	; 0FFF0h	; boundary
 45945                                  
 45946                                  	;mov	si,ax			; si = offset of DOSDATA in current 
 45947                                  					; code segment
 45948                                  
 45949                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 45950 000080E3 83C00F                  	add	ax,15			; round to nearest paragraph
 45951 000080E6 83E0F0                  	and	ax,~15			; boundary
 45952                                  
 45953 000080E9 89C6                    	mov	si,ax			; si = offset of DOSDATA in current 
 45954                                  					; code segment
 45955                                  	; 05/12/2022
 45956                                  	; 30/04/2019 - Retro DOS v4.0
 45957                                  	;xor	si,si
 45958                                  	
 45959 000080EB 8CC8                    	mov	ax,cs
 45960 000080ED 8ED8                    	mov	ds,ax			; ds = current code segment
 45961                                  					; DS:SI now points to dosdata
 45962                                  
 45963                                  	;mov	es,[cs:0BA49h] ; MSDOS 6.21 IO.SYS, offset 7C8Eh 
 45964                                  	;mov	es,[cs:InitBioDataSeg]	; First access to DosDataSg in
 45965                                  					;  BData segment. Cannot use
 45966                                  					;  getdseg macro here!!!
 45967                                  	; 17/12/2022
 45968 000080EF 8E06[CB80]              	mov	es,[InitBioDataSeg]
 45969                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 45970                                  	;mov	es,[cs:InitBioDataSeg]  ; ds = cs !
 45971                                  
 45972                                  	;mov	es,[es:3]
 45973 000080F3 268E060300              	mov	es,[es:DosDataSg]	; Get free location in low memory
 45974                                  
 45975 000080F8 31FF                    	xor	di,di			; ES:DI now points to RAM data
 45976                                  
 45977                                  	;mov	cx,4970  ; Offset 0BA78h in MSDOS 6.21 MSDOS.SYS)
 45978                                  	;mov	cx,4976  ; 25/05/2019
 45979                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45980                                  	;mov	cx,4962
 45981                                  	;mov	cx,MSDAT001E		; get end of dosdata = size of dosdata
 45982 000080FA B96D14                  	mov	cx,DOSDATASIZE ; = 4962 for MSDOS 5.0 MSDOS.SYS
 45983 000080FD F3A4                    	rep	movsb			; move data to final location
 45984                                  	
 45985 000080FF 5F                      	pop	di			; restore ptr to BiosComBlock
 45986 00008100 1F                      	pop	ds			; restore parms from BIOS
 45987 00008101 5E                      	pop	si
 45988                                  	; 17/12/2022
 45989                                  	;pop	dx ; 30/05/2019	
 45990                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 45991                                  	;pop	dx ; =*=		
 45992                                  
 45993 00008102 06                      	push	es
 45994 00008103 1E                      	push	ds
 45995 00008104 07                      	pop	es			; es:si -> device chain
 45996 00008105 1F                      	pop	ds			; ds points to dosdata
 45997                                  
 45998                                  ;SR;
 45999                                  ;We get a ptr to the BIOS exchange data block. This has been setup right 
 46000                                  ;now so that the EXEC call knows when SysInit is present to do the special
 46001                                  ;lie table handling for device drivers. This can be expanded later on to
 46002                                  ;establish a communication block from the BIOS to the DOS.
 46003                                  
 46004                                  	;mov	[1040h],di	; Offset 0BA87h in MSDOS 6.21 MSDOS.SYS)
 46005                                  	;mov	[1042h],bx
 46006 00008106 893E[A310]              	mov	[BiosDataPtr],di
 46007 0000810A 891E[A510]              	mov	[BiosDataPtr+2],bx	; save ptr to BiosComBlock
 46008                                  
 46009 0000810E 2E8C1E[0700]            	mov	[cs:DosDSeg],ds		; set pointer to dosdata in code seg
 46010                                  
 46011                                  	; Set the segment of Lowint23/24/28Addr in msctrlc.asm to dosdata
 46012                                  
 46013 00008113 2E8C1E[895A]            	mov	[cs:LowInt23Addr+2],ds	; set pointers in code seg
 46014 00008118 2E8C1E[8D5A]            	mov	[cs:LowInt24Addr+2],ds
 46015 0000811D 2E8C1E[915A]            	mov	[cs:LowInt28Addr+2],ds
 46016                                  
 46017                                  	;mov	[346h],dx	; MSDOS 6.21 DOSDATA addresses
 46018                                  	;mov	[584h],sp
 46019                                  	;mov	[586h],ss
 46020 00008122 8916[4603]                  	mov	[ENDMEM],dx	; =*=
 46021 00008126 8926[8405]              	mov	[USER_SP],sp
 46022 0000812A 8C16[8605]              	mov	[USER_SS],ss
 46023                                  
 46024 0000812E 8CD8                    	mov	ax,ds		; set up ss:sp to dosdata:dskstack
 46025 00008130 8ED0                    	mov	ss,ax
 46026                                  
 46027                                  	;mov	sp,920h		; MSDOS 6.21 DOSDATA address
 46028                                  	;mov	sp,offset dosdata:dskstack
 46029 00008132 BC[2009]                	mov	sp,DSKSTACK
 46030                                  
 46031                                  ;M023
 46032                                  ; Init patch ptrs to default values
 46033                                  
 46034                                  	;mov	word [1212h],RetExePatch
 46035                                  	;mov	word [1214h],RetExePatch
 46036                                  	;mov	word [61h],RetExePatch
 46037 00008135 C706[880D][356C]        	mov	word [FixExePatch],RetExePatch	; M023
 46038                                  	; 28/12/2022 - Retro DOS v4.1
 46039                                  	;mov	word [RationalPatchPtr],RetExePatch ; M023
 46040 0000813B C706[6100][356C]        	mov	word [ChkCopyProt],RetExePatch	; M068
 46041                                  
 46042                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46043                                  %if 0	; 19/09/2023
 46044                                  
 46045                                  ; Setup to call 386 Rational DOS Extender patch routine if running on
 46046                                  ; a 386 or later. Unlike other patches, this is not dependent on MS-DOS
 46047                                  ; running in the HMA.
 46048                                  
 46049                                  	call	WhatCPUType	; get cpu type (0 < 286,1==286,2 >= 386)
 46050                                  	cmp	al,2		;   386 or later?
 46051                                  	mov	ax,Rational386Patch
 46052                                  	jae	short di_set_patch
 46053                                  	mov	ax,RetExePatch	; < 386, don't need this patch
 46054                                  di_set_patch:
 46055                                  	mov	[Rational386PatchPtr],ax ; patch routine or RET instr.
 46056                                  
 46057                                  %endif
 46058                                  	; Set up the variable temp_dosloc to point to the dos code segment
 46059                                  
 46060 00008141 8CC8                    	mov	ax,cs		; ax = current segment of DOS code
 46061                                  
 46062                                  	; ax now holds segment of DOS code
 46063 00008143 A3[AA0A]                	mov	[TEMP_DOSLOC],ax   ; store temp location of DOS
 46064                                  
 46065 00008146 8C06[4A00]              	mov	word [NULDEV+2],es ; nuldev -> points to device chain
 46066 0000814A 8936[4800]              	mov	word [NULDEV],si
 46067                                  ;SR;
 46068                                  ; There are some locations in the Win386 instance data structures
 46069                                  ; which need to be set up with the DOS data segment. First, initialize
 46070                                  ; the segment part of the instance table pointer in the SIS.
 46071                                  
 46072                                  	;mov	[0FF2h],ds ; [Win386_Info+14+2]	
 46073 0000814E 8C1E[3710]              	mov	[Win386_Info+Win386_SIS.Instance_Data_Ptr+2],ds
 46074                                  
 46075                                  ; Now initialize the segment part of the pointer to the data in each
 46076                                  ; instance table entry.
 46077                                  
 46078 00008152 56                      	push	si		; preserve pointer to device chain
 46079                                  	; 18/12/2022
 46080                                  	; cx = 0
 46081 00008153 B107                    	mov	cl,7
 46082                                  	;mov	cx,7		; There are 7 entries in the instance table
 46083                                  				; M019
 46084                                  	;mov	si,0FF6h ; offset (dosdata:Instance_Table+2)
 46085 00008155 BE[3F10]                	mov	si,Instance_Table+2 ; point si to segment field
 46086                                  Instance_init_loop:
 46087 00008158 8C1C                    	mov	[si],ds		; set offset in instance entry
 46088                                  	;add	si,6
 46089 0000815A 83C606                  	add	si,size_of_Win386_IIS ; move on to next entry
 46090 0000815D E2F9                    	loop	Instance_init_loop
 46091                                  
 46092                                  ;Initialize the WIN386 2.xx instance table with the DOS data segment value
 46093                                  
 46094                                  	; 18/12/2022
 46095 0000815F B105                    	mov	cl,5
 46096                                  	;mov	cx,5		; There are five entries in the instance table
 46097                                  
 46098                                  	;mov	si,(offset dosdata:OldInstanceJunk) + 6
 46099                                  	;mov	si,11EDh	; point si to segment field
 46100 00008161 BE[3212]                	mov	si,OldInstanceJunk+6
 46101                                  OldInstance_init_loop:
 46102 00008164 8C1C                    	mov	[si],ds		; set offset in instance entry
 46103 00008166 83C606                  	add	si,6		; move on to next entry
 46104 00008169 E2F9                    	loop	OldInstance_init_loop
 46105 0000816B 5E                      	pop	si		; restore pointer to device chain
 46106                                  
 46107                                  ; End of WIN386 2.xx compatibility bullshit
 46108                                  
 46109                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46110                                  %if 0	
 46111                                     	; 30/04/2019
 46112                                  	;push	es
 46113                                  	;pop	ds
 46114                                  			; ds:si points to console device
 46115                                  
 46116                                  	; 24/04/2019 - Retro DOS v4.0
 46117                                  
 46118                                  	; 15/07/2018
 46119                                  	; MSDOS 3.3 (IBMDOS.COM, 1987)
 46120                                  	; (Set INT 2Ah handler address to an 'IRET')
 46121                                  
 46122                                  	; need crit vector inited to use deviocall
 46123                                  	;push	ds			; preserve segment of device chain
 46124                                  	push	es ; 30/04/2019
 46125                                  
 46126                                  %endif
 46127                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46128 0000816C 06                      	push	es
 46129                                  	; 17/12/2022
 46130                                  	;pop	ds
 46131                                  	;push	ds
 46132                                  
 46133 0000816D 31C0                    	xor	ax,ax
 46134 0000816F 8ED8                    	mov	ds,ax			; point DS to int vector table
 46135 00008171 B8[CA80]                	mov	ax,initiret
 46136                                  	;mov	[0A8h],ax  ; [2Ah*4]
 46137 00008174 A3A800                  	mov	[addr_int_ibm],ax
 46138 00008177 8CC8                    	mov	ax,cs
 46139                                  	;mov	[0AAh],ax  ; [(2Ah*4)+2] 		
 46140 00008179 A3AA00                  	mov	[addr_int_ibm+2],ax
 46141 0000817C 1F                      	pop	ds			; restore segment of device chain
 46142                                  
 46143 0000817D E81C02                  	call	CHARINIT  		; initialize console driver
 46144 00008180 56                      	push	si			; save pointer to header
 46145                                  
 46146 00008181 16                      	push	ss			; move pointer to dos data...
 46147 00008182 07                      	pop	es			; ...into ES
 46148                                  
 46149                                  	;initialize sft for file 0 (CON)
 46150                                  
 46151                                          ; 07/07/2018 - Retro DOS v3.0
 46152                                  	; 24/04/2019 - Retro DOS v4.0
 46153                                  	;mov	di,SFTABL+6 
 46154 00008183 BF[D200]                	MOV     DI,SFTABL+SFT.SFTable	; Point to sft 0
 46155 00008186 B80300                          MOV     AX,3
 46156 00008189 AB                              STOSW           	; Refcount
 46157 0000818A FEC8                            DEC     AL
 46158 0000818C AB                              STOSW           	; Access rd/wr, compatibility
 46159 0000818D 30C0                            XOR     AL,AL
 46160 0000818F AA                              STOSB           	; attribute
 46161                                  	;mov	al,0C3h
 46162 00008190 B0C3                    	mov	al,devid_device_EOF|devid_device|ISCIN|ISCOUT
 46163 00008192 AB                      	STOSW			; flags
 46164 00008193 89F0                            mov	ax,si
 46165 00008195 AB                              stosw			; device pointer in devptr	
 46166 00008196 8CD8                            mov	ax,ds
 46167 00008198 AB                      	stosw
 46168 00008199 31C0                    	xor	ax,ax	; 0
 46169 0000819B AB                      	stosw			; firclus
 46170 0000819C AB                      	stosw			; time
 46171 0000819D AB                      	stosw			; date
 46172 0000819E 48                      	dec	ax	; -1
 46173 0000819F AB                      	stosw			; size
 46174 000081A0 AB                      	stosw
 46175 000081A1 40                      	inc	ax	; 0
 46176 000081A2 AB                      	stosw			; position
 46177 000081A3 AB                      	stosw
 46178                                  	;add	di,7
 46179 000081A4 83C707                  	add	di,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
 46180                                  				; point at name
 46181                                  	;add	si,10
 46182 000081A7 83C60A                  	add	si,SYSDEV.NAME	; sdevname
 46183                                  				; point to name
 46184 000081AA B90400                  	mov	cx,4
 46185 000081AD F3A5                    	rep	movsw		; name
 46186 000081AF B103                    	mov	cl,3
 46187 000081B1 B020                    	mov	al," "
 46188 000081B3 F3AA                    	rep	stosb		; extension
 46189                                  
 46190 000081B5 5E                      	pop	si		; get back pointer to header
 46191                                  
 46192                                  				; mark device as CON I/O
 46193                                  	; 15/07/2018
 46194                                          ;OR	BYTE [SI+4],ISCIN|ISCOUT ; or byte [si+4],3
 46195 000081B6 804C0403                	OR	BYTE [SI+SYSDEV.ATT],ISCIN|ISCOUT
 46196                                  	; 12/03/2018
 46197                                  	;mov	[ss:32h],si
 46198 000081BA 368936[3200]            	MOV     [SS:BCON],SI
 46199                                  	;mov	[ss:34h],ds
 46200 000081BF 368C1E[3400]                    MOV     [SS:BCON+2],DS
 46201                                  
 46202                                  	; initialize each device until the clock device is found
 46203                                  
 46204                                  CHAR_INIT_LOOP:
 46205 000081C4 C534                            LDS     SI,[SI]			; AUX device
 46206 000081C6 E8D301                  	call	CHARINIT 
 46207                                         	;15/07/2018
 46208                                  	;test	byte [SI+4],8
 46209 000081C9 F6440408                	TEST    BYTE [SI+SYSDEV.ATT],ISCLOCK
 46210 000081CD 74F5                            JZ      SHORT CHAR_INIT_LOOP
 46211                                  	; 12/03/2018
 46212                                  	;mov	[ss:2Eh],si
 46213 000081CF 368936[2E00]                    MOV     [SS:BCLOCK],SI
 46214                                  	;mov	[ss:30h],ds
 46215 000081D4 368C1E[3000]                    MOV     [SS:BCLOCK+2],DS
 46216                                          ;MOV	BP,MEMSTRT ; Retro DOS 3.0 ; ES:BP points to DPB
 46217                                  
 46218                                  	;mov	bp,4970			; bp = pointer to free mem
 46219                                  	;mov	bp,4976  ; 25/05/2019 - Retro DOS v4.0
 46220                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
 46221                                  	;mov	bp,4962 ; (MSDOS 5.0 MSDOS.SYS)
 46222 000081D9 BD6D14                  	mov	bp,MSDAT001E		; es:bp points to dpb area
 46223                                  
 46224 000081DC 36892E[2600]            	mov	[ss:DPBHEAD],bp		; set offset of pointer to DPB's
 46225 000081E1 368C06[2800]            	mov	[ss:DPBHEAD+2],es	; set segment of pointer to DPB's
 46226                                  PERDRV:
 46227                                  	;lds	si,[SI+SYSDEV.NEXT] ; 15/07/2018
 46228 000081E6 C534                            LDS	SI,[SI]			; Next device
 46229 000081E8 83FEFF                          CMP	SI,-1	; 0FFFFh
 46230 000081EB 7479                    	JZ	SHORT CONTINIT
 46231                                  
 46232 000081ED E8AC01                          call	CHARINIT
 46233                                  
 46234                                  	; Retro DOS v2.0 - 16/03/2018 (NOTE for 'CHARINIT' return):
 46235                                  	; [CALLUNIT] = Number of drives for (Disk) Block Dev Driver ([DRVMAX])
 46236                                  	;           (..When the command is 'DSK$INIT', as in 'CHARINIT')
 46237                                  	; [CALLBPB] = [DEVCALL.COUNT] = Address of the BPB (DEVCALL offset 18)
 46238                                  	; (REF: MSDOS 3.3 MSBIO2.ASM, MSDATA.INC, MSDISK.ASM, MSBIO1.ASM)
 46239                                  	; (.. !DSK$IN' in MSBIO1.ASM)
 46240                                  	; DEVCALL.MEDIA = CALLUNIT (DEVCALL offset 13)
 46241                                  
 46242                                          ; 15/07/2018
 46243                                  	;test	word [SI+4],8000h		; DEVTYP
 46244                                          ; 17/12/2022
 46245                                  	;test	byte [SI+5],80h
 46246 000081F0 F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8) ; 80h
 46247                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP ; 8000h
 46248 000081F4 75F0                    	JNZ     SHORT PERDRV			; Skip any other character devs
 46249                                  
 46250 000081F6 368A0E[6703]                    MOV	CL,[SS:CALLUNIT] ; 12/03/2018
 46251 000081FB 30ED                    	XOR     CH,CH
 46252                                          ; 07/07/2018
 46253                                  	;MOV	[SI+10],CL		; Number of units in name field
 46254 000081FD 884C0A                  	mov	[si+SYSDEV.NAME],cl	; sdevname        
 46255 00008200 368A16[4600]            	MOV     DL,[SS:NUMIO]	; 15/03/2018
 46256 00008205 30F6                    	XOR     DH,DH
 46257 00008207 36000E[4600]            	ADD	[SS:NUMIO],CL	; 12/03/2018
 46258 0000820C 1E                      	PUSH    DS
 46259 0000820D 56                              PUSH    SI
 46260 0000820E 36C51E[6C03]            	LDS	BX,[SS:CALLBPB]	; 12/03/2018
 46261                                  
 46262                                  PERUNIT:
 46263 00008213 8B37                            MOV     SI,[BX]                 ; DS:SI Points to BPB
 46264 00008215 43                              INC     BX
 46265 00008216 43                              INC     BX                      ; On to next BPB
 46266                                  	; 15/12/2022
 46267                                  	; 07/07/2018
 46268                                          ;mov	[ES:BP+DPB.DRIVE],DL
 46269 00008217 26885600                	MOV     [ES:BP],DL
 46270                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46271                                  	;;mov	[ES:BP+0],DL
 46272                                  	;mov	[ES:BP+DPB.DRIVE],DL
 46273                                  
 46274                                  	;MOV	[ES:BP+1],DH
 46275 0000821B 26887601                	MOV	[ES:BP+DPB.UNIT],DH
 46276 0000821F 53                              PUSH    BX
 46277 00008220 51                              PUSH    CX
 46278 00008221 52                              PUSH    DX
 46279                                  
 46280                                          ;invoke	$SETDPB
 46281 00008222 E85692                          CALL	_$SETDPB		; build DPB!
 46282                                  
 46283                                  	; 07/07/2018
 46284                                  	;MOV	AX,[ES:BP+2]
 46285 00008225 268B4602                	mov	ax,[ES:BP+DPB.SECTOR_SIZE]
 46286                                          ; 12/03/2018
 46287 00008229 363B06[3600]            	CMP	AX,[SS:MAXSEC]		; Q:is this the largest sector so far
 46288 0000822E 7604                    	JBE     SHORT NOTMAX		; N:
 46289 00008230 36A3[3600]              	MOV	[SS:MAXSEC],AX		; Y: save it in maxsec
 46290                                  NOTMAX:					
 46291                                  	; set the next dpb field in the currently built bpb
 46292                                  	; and mark as never accessed
 46293                                          
 46294                                  	; 24/04/2019
 46295 00008234 89E8                    	mov	ax,bp			; get pointer to DPB
 46296                                  	;add	ax,33
 46297 00008236 83C03D                  	add	ax,DPBSIZ		; advance pointer to next DPB
 46298                                  					; set seg & offset of next DPB
 46299                                  	;mov	[es:bp+25],ax
 46300 00008239 26894619                	mov	[es:bp+DPB.NEXT_DPB],ax
 46301                                  	;mov	[es:bp+27],es
 46302 0000823D 268C461B                	mov	[es:bp+DPB.NEXT_DPB+2],es
 46303                                  					; mark as never accessed
 46304                                  	;mov	byte [es:bp+24],0FFh
 46305 00008241 26C64618FF              	mov	byte [es:bp+DPB.FIRST_ACCESS],-1
 46306                                  
 46307 00008246 5A                      	POP     DX
 46308 00008247 59                              POP     CX
 46309 00008248 5B                              POP     BX
 46310 00008249 8CD8                            MOV     AX,DS                   ; save segment of bpb array
 46311 0000824B 5E                              POP     SI
 46312 0000824C 1F                              POP     DS
 46313                                  					; ds:si -> device header
 46314                                  					; store it in the corresponding dpb
 46315                                  	; 07/07/2018
 46316                                          ;MOV	[ES:BP+19],SI ; 24/04/2019
 46317 0000824D 26897613                	mov	[ES:BP+DPB.DRIVER_ADDR],si
 46318                                          ;MOV	[ES:BP+21],DS ; 24/04/2019
 46319 00008251 268C5E15                	mov	[ES:BP+DPB.DRIVER_ADDR+2],ds
 46320                                  
 46321 00008255 1E                              PUSH    DS			; save pointer to device header
 46322 00008256 56                              PUSH    SI
 46323 00008257 FEC6                            INC     DH			; inc unit #
 46324 00008259 FEC2                            INC     DL			; inc drive #
 46325 0000825B 8ED8                            MOV     DS,AX			; restore segment of BPB array
 46326                                          ;add	bp,33 ; 24/04/2019
 46327 0000825D 83C53D                  	ADD     BP,DPBSIZ		; advance pointer to next dpb
 46328 00008260 E2B1                    	LOOP    PERUNIT			; process all units in each driver
 46329                                          
 46330 00008262 5E                      	POP     SI			; restore pointer to device header
 46331 00008263 1F                              POP     DS
 46332 00008264 EB80                    	JMP	PERDRV			; process all drivers in chain
 46333                                  
 46334                                  CONTINIT:
 46335                                  	; 24/04/2019
 46336                                  	;sub	bp,33			; set link in last DPB to -1
 46337 00008266 83ED3D                  	sub	bp,DPBSIZ		; back up to last dpb
 46338                                  					; set last link offset & segment
 46339                                  	;mov	word [bp+25],0FFFFh
 46340 00008269 C74619FFFF              	mov	word [bp+DPB.NEXT_DPB],-1
 46341                                  	;mov	word [bp+27],0FFFFh
 46342 0000826E C7461BFFFF              	mov	word [bp+DPB.NEXT_DPB+2],-1
 46343                                  	;add	bp,33
 46344 00008273 83C53D                  	add	BP,DPBSIZ		; advance to free memory again
 46345                                  					; the DPB chain is done.  
 46346 00008276 16                      	push	ss
 46347 00008277 1F                      	pop	ds
 46348                                  
 46349 00008278 89E8                    	mov	ax,bp
 46350 0000827A E850FE                  	call	ParaRound		; round up to segment
 46351                                  
 46352 0000827D 8CDA                    	mov	dx,ds			; dx = dosdata segment
 46353 0000827F 01C2                    	add	dx,ax			; dx = ds+ax first free segment
 46354                                  
 46355 00008281 BB0F00                  	mov	bx,0Fh
 46356                                  	
 46357                                  	; 24/05/2019
 46358                                  	;mov	cx,[ENDMEM]
 46359                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46360                                  	; 17/12/2022
 46361                                  	;mov	cx,[ENDMEM] 
 46362                                  					; set seg inpacketto dosdata					
 46363 00008284 8C1E[A203]              	mov	[DSKCHRET+3],ds ; mov [DOSSEG_INIT],ds 
 46364                                  
 46365                                  ; Patch in the segments of the interrupt vectors with current code segment.
 46366                                  ; Also patch in the segment of the pointers in the dosdata area.
 46367                                  ;
 46368                                  ; Note: Formerly, temp_dosloc was initialized to -1 until after these
 46369                                  ; calls were done. The procedure patch_misc_segments is called multiple
 46370                                  ; times, and relies on temp_dosloc being initialized to -1 as a flag
 46371                                  ; for the first invocation. Thus, we must set it to -1 for this call.
 46372                                  
 46373 00008288 52                      	push	dx			; preserve first free segment
 46374                                  
 46375 00008289 A1[AA0A]                	mov	ax,[TEMP_DOSLOC]	; ax = segment to patch in 
 46376 0000828C 8EC0                    	mov	es,ax			; es = segment of DOS
 46377 0000828E C706[AA0A]FFFF          	mov	word [TEMP_DOSLOC],-1	; -1 means first call to patch_misc_segments
 46378                                  
 46379 00008294 E8AF01                  	call	patch_vec_segments	; uses AX as doscode segment
 46380 00008297 E8E401                  	call	patch_misc_segments	; patch in segments for sharer and 
 46381                                  					; other tables with seg in ES.
 46382                                  	; 17/12/2022
 46383                                  	; cx = 0
 46384 0000829A 8C06[AA0A]              	mov	[TEMP_DOSLOC],es	; put back segment of dos code
 46385                                  
 46386 0000829E 5A                      	pop	dx			; restore first free segment
 46387                                  
 46388                                  ; We shall now proceed to set the offsets of the interrupt vectors handled
 46389                                  ; by DOS to their appropriate values in DOSCODE. In case the DOS loads in
 46390                                  ; HIMEM the offsets also will be patched to their appropriate values in the
 46391                                  ; low_mem_stub by seg_reinit.
 46392                                  
 46393                                  	;xor	ax,ax ; 0
 46394                                  	;mov	ds,ax
 46395                                  	;mov	es,ax
 46396                                  	; 17/12/2022
 46397                                  	; cx = 0
 46398                                  	;xor	cx,cx ; 0
 46399 0000829F 8ED9                    	mov	ds,cx
 46400 000082A1 8EC1                    	mov	es,cx
 46401                                  
 46402                                  	; set the segment of int 24 vector that was 
 46403                                  	; left out by patch_vec_segments above.
 46404                                  
 46405                                  	; 17/12/2022
 46406                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46407                                  ;%if 0
 46408                                  	; 24/05/2019
 46409                                  	;;mov	di,90h
 46410                                  	;;mov	di,4*int_fatal_abort
 46411                                  	;mov	di,addr_int_fatal_abort
 46412 000082A3 BF9200                  	mov	di,addr_int_fatal_abort+2 ; 24/05/2019
 46413                                  
 46414 000082A6 36A1[AA0A]              	mov	ax,[ss:TEMP_DOSLOC]
 46415                                  	;mov	[di+2],ax  ; int 24h segment
 46416 000082AA 8905                    	mov	[di],ax ; 24/05/2019
 46417                                  
 46418                                  	;;mov	di,82h
 46419                                  	;mov	di,INTBASE+2
 46420                                  
 46421                                  ;%endif
 46422                                  	; 17/12/2022
 46423                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46424                                  	;;mov	di,90h
 46425                                  	;;mov	di,4*int_fatal_abort
 46426                                  	;mov	di,addr_int_fatal_abort
 46427                                  	;mov	ax,[ss:TEMP_DOSLOC]
 46428                                  	;mov	[di+2],ax  ; int 24h segment
 46429                                  	;;mov	di,82h
 46430                                  	;mov	di,INTBASE+2
 46431                                  
 46432                                  	; set default divide trap offset
 46433                                  
 46434                                  	;mov	word ptr ds:[0],offset doscode:divov
 46435 000082AC C7060000[645C]          	mov	word [0],DIVOV	
 46436                                  
 46437                                  	; set vectors 20-28 and 2a-3f to point to iret.
 46438                                  
 46439                                  	;mov	di,80h
 46440 000082B2 BF8000                  	mov	di,INTBASE
 46441                                  	;mov	ax,offset doscode:irett
 46442 000082B5 B8[CB02]                	mov	ax,IRETT
 46443                                  
 46444                                  	; 17/12/2022
 46445                                  	; cx = 0
 46446 000082B8 B109                    	mov	cl,9
 46447                                  	;mov	cx,9			; set 9 offsets (skip 2 between each)
 46448                                  					;   sets offsets for ints 20h-28h
 46449                                  iset1:
 46450 000082BA AB                      	stosw
 46451                                  	;add	di,2
 46452                                  	; 20/09/2023
 46453 000082BB 47                      	inc	di
 46454 000082BC 47                      	inc	di
 46455 000082BD E2FB                    	loop	iset1
 46456                                  
 46457 000082BF 83C704                  	add	di,4			; skip vector 29h
 46458                                  
 46459                                  ;	mov	cx,6			; set 6 offsets (skip 2 between each)
 46460                                  ;					;   sets offsets for ints 2ah-2fh
 46461                                  ;iset2:
 46462                                  ;	stosw
 46463                                  ;	add	di,2
 46464                                  ;	loop	iset2
 46465                                  
 46466                                  ; 30h & 31H is the CPM call entry point whose segment address is set up by
 46467                                  ; patch_vec_segments above. So skip it.
 46468                                  
 46469                                  ;	add	di,8			; skip vector 30h & 31h 
 46470                                  
 46471                                  	;;;
 46472                                  	; 06/05/2019 - Retro DOS v4.0
 46473                                  	;mov	cx,5			; set offsets for int 2Ah-2Eh
 46474                                  	; 17/12/2022
 46475 000082C2 B105                    	mov	cl,5 ; 28/06/2019
 46476                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46477                                  	;mov	cx,6
 46478                                  iset2:
 46479 000082C4 AB                      	stosw
 46480                                  	;add	di,2
 46481                                  	; 20/09/2023
 46482 000082C5 47                      	inc	di
 46483 000082C6 47                      	inc	di
 46484 000082C7 E2FB                    	loop	iset2
 46485                                  
 46486                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46487                                  	; 17/12/2022
 46488 000082C9 83C70C                  	add	di,12			; skip vectors 2Fh, 30h & 31h
 46489                                  	;add	di,8
 46490                                  	;;;
 46491                                  
 46492                                  	; 17/12/2022
 46493 000082CC B10E                    	mov	cl,14
 46494                                  	;mov	cx,14			; set 14 offsets (skip 2 between each)
 46495                                  					;   sets offsets for ints 32h-3fh
 46496                                  iset3:
 46497 000082CE AB                      	stosw
 46498                                  	;add	di,2
 46499                                  	; 20/09/2023
 46500 000082CF 47                      	inc	di
 46501 000082D0 47                      	inc	di
 46502 000082D1 E2FB                    	loop	iset3
 46503                                  
 46504                                  ;if installed
 46505                                  	; set the offset of int2f handler
 46506                                  	;mov	word [0BCh],INT2F
 46507 000082D3 C706BC00[3C07]          	mov	word [02Fh*4],INT2F
 46508                                  	; set segment to doscode as we have to do int 2f to check for XMS
 46509 000082D9 36A1[AA0A]              	mov	ax,[ss:TEMP_DOSLOC]	; get segment of doscode
 46510                                  	;mov	[0BEh],ax
 46511 000082DD A3BE00                  	mov	[(02Fh*4)+2],ax
 46512                                  ;endif
 46513                                  	; set up entry point call at vectors 30-31h. Note the segment of the 
 46514                                  	; long jump will be patched in by seg_reinit
 46515                                  
 46516                                  	;mov	byte [C0h],0EAh
 46517 000082E0 C606C000EA              	mov	byte [ENTRYPOINT],mi_long_jmp
 46518                                  	;mov	byte [C1h],CALL_ENTRY
 46519 000082E5 C706C100[CC02]          	mov	word [ENTRYPOINT+1],CALL_ENTRY
 46520                                  
 46521 000082EB C7068000[C502]          	mov	word [addr_int_abort],QUIT	; INT 20h
 46522 000082F1 C7068400[F102]          	mov	word [addr_int_command],COMMAND ; INT 21h
 46523 000082F7 C70688000001            	mov	word [addr_int_terminate],100h	; INT 22h
 46524 000082FD 89168A00                	mov	word [addr_int_terminate+2],dx	
 46525 00008301 C7069400[2D05]          	mov	word [addr_int_disk_read],ABSDRD   ; INT 25h
 46526 00008307 C7069800[DC05]          	mov	word [addr_int_disk_write],ABSDWRT ; INT 26h 
 46527 0000830D C7069C00[D86B]          	mov	word [addr_int_keep_process],STAY_RESIDENT ; INT 27h
 46528                                  
 46529 00008313 16                      	push	ss
 46530 00008314 1F                      	pop	ds
 46531                                  	
 46532                                  	; 24/05/2019
 46533                                  	;push	ss
 46534                                  	;pop	es
 46535                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46536                                  	; 17/12/2022
 46537                                  	;push	ss
 46538                                  	;pop	es
 46539                                  
 46540 00008315 52                      	push	dx			; remember address of arena
 46541                                  
 46542 00008316 42                      	inc	dx			; leave room for arena header
 46543                                  	;mov	[330h],dx
 46544 00008317 8916[3003]              	mov     [CurrentPDB],dx		; set current pdb
 46545                                  
 46546 0000831B 31FF                    	xor	di,di			; point es:di at end of memory
 46547 0000831D 8EC2                    	mov	es,dx			; ...where psp will be
 46548 0000831F 31C0                    	xor	ax,ax
 46549                                  	;mov	cx,80h			; psp is 128 words
 46550                                  	; 17/12/2022
 46551 00008321 B180                    	mov	cl,128 ; 28/06/2019
 46552                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46553                                  	;mov	cx,128
 46554                                  
 46555 00008323 F3AB                    	rep	stosw			; zero out psp area
 46556 00008325 A1[4603]                        mov     ax,[ENDMEM]
 46557                                  	
 46558                                  	; 17/12/2022
 46559                                  	; cx = 0
 46560 00008328 E8B293                  	call	SETMEM         	 	; build psp at dx; ax is memory size
 46561                                  
 46562                                  	; ds, es now point to PSP
 46563                                  
 46564 0000832B 16                      	push	ss
 46565 0000832C 1F                      	pop	ds
 46566                                  
 46567                                  	;mov	di,24
 46568 0000832D BF1800                  	mov	di,PDB.JFN_TABLE	; es:di -> pdb_jfn_table in psp
 46569 00008330 31C0                    	xor	ax,ax
 46570 00008332 AB                      	stosw
 46571 00008333 AA                      	stosb				; 0,1 and 2 are con device
 46572 00008334 B0FF                    	mov	al,0FFh
 46573                                  	;mov	cx,FILPERPROC-3 ; 17
 46574                                  	; 17/12/2022
 46575                                  	; cx = 4
 46576 00008336 B111                    	mov	cl,FILPERPROC-3 ; 17
 46577 00008338 F3AA                    	rep	stosb			; rest are unused
 46578                                  
 46579 0000833A 16                      	push	ss
 46580 0000833B 07                      	pop	es
 46581                                  					; must be set to print messages
 46582 0000833C 8C1E[2C00]              	mov	[SFT_ADDR+2],ds     
 46583                                  
 46584                                  ; after this point the char device functions for con will work for
 46585                                  ; printing messages
 46586                                  
 46587                                  	; 24/04/2019 - Retro DOS v4.0
 46588                                  
 46589                                  ; 12/05/2019
 46590                                  ;
 46591                                  ;write_version_msg:
 46592                                  ;
 46593                                  ;	;if	(not ibm)
 46594                                  ;	;mov	si,offset doscode:header
 46595                                  ;	mov	si,HEADER
 46596                                  ;outmes:
 46597                                  ;	;lods	cs:byte ptr [si]
 46598                                  ;	cs
 46599                                  ;	lodsb
 46600                                  ;	cmp	al,"$"
 46601                                  ;	je	short outdone
 46602                                  ;	call	OUTT
 46603                                  ;	jmp	short outmes
 46604                                  ;outdone:
 46605                                  ;	push	ss			; out stomps on segments
 46606                                  ;	pop	ds
 46607                                  ;	push	ss
 46608                                  ;	pop	es
 46609                                  ;	;endif
 46610                                  
 46611                                  	; at this point es is dosdata
 46612                                  
 46613                                  	; Fill in the segment addresses of sysinitvar and country_cdpg 
 46614                                  	; in sysinittable (ms_data.asm)
 46615                                  
 46616                                  	;mov	si,0D28h
 46617 00008340 BE[790D]                	mov	si,SysInitTable
 46618                                  
 46619                                  	; 17/12/2022
 46620                                  	; ds = es = ss
 46621                                  
 46622                                  	; 17/12/2022
 46623                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46624                                  ;%if 0
 46625                                  	;;mov	[es:si+6],es
 46626                                  	;mov	[es:si+SYSI_EXT.Country_Tab+2],es
 46627                                  	;;mov	[es:si+2],es
 46628                                  	;mov	[es:si+SYSI_EXT.SysInitVars+2],es
 46629                                  	
 46630 00008343 8C4406                  	mov	[si+SYSI_EXT.Country_Tab+2],es
 46631 00008346 8C4402                  	mov	[si+SYSI_EXT.SysInitVars+2],es
 46632                                  
 46633                                  	; buffhead -> dosdata:hashinitvar 
 46634                                  
 46635                                  	;mov	[es:BUFFHEAD+2],es	; BUGBUG - unused, remove this
 46636 00008349 8C06[3A00]              	mov	[BUFFHEAD+2],es
 46637                                  	;mov	si,offset dosdata:hashinitvar ; and all other references
 46638                                  	;mov	si,6Dh
 46639 0000834D BE[6D00]                	mov	si,HASHINITVAR
 46640                                  	;mov	[es:BUFFHEAD],si
 46641 00008350 8936[3800]              	mov	[BUFFHEAD],si
 46642                                  
 46643 00008354 5A                              pop     dx                      ; restore address of arena
 46644                                  
 46645                                  	;mov	[032Ch+2],dx
 46646 00008355 8916[2E03]                      mov     [DMAADD+2],dx
 46647                                  
 46648                                  	;mov	[es:arena_head],dx
 46649 00008359 8916[2400]              	mov	[arena_head],dx
 46650                                  
 46651                                  ;%endif
 46652                                  
 46653                                  ; 17/12/2022
 46654                                  %if 0
 46655                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 46656                                  	;;;
 46657                                  	;mov	[es:si+6],es
 46658                                  	mov	[es:si+SYSI_EXT.Country_Tab+2],es
 46659                                  	;mov	[es:si+2],es
 46660                                  	mov	[es:si+SYSI_EXT.SysInitVars+2],es
 46661                                  
 46662                                  	; buffhead -> dosdata:hashinitvar 
 46663                                  
 46664                                  	mov	[es:BUFFHEAD+2],es	; BUGBUG - unused, remove this
 46665                                  	;mov	si,offset dosdata:hashinitvar ; and all other references
 46666                                  	;mov	si,6Dh
 46667                                  	mov	si,HASHINITVAR
 46668                                  	mov	[es:BUFFHEAD],si
 46669                                  
 46670                                          pop     dx                      ; restore address of arena
 46671                                  
 46672                                  	;mov	[032Ch+2],dx
 46673                                          mov     [DMAADD+2],dx
 46674                                  
 46675                                  	mov	[es:arena_head],dx
 46676                                  	;;;
 46677                                  %endif
 46678                                  
 46679 0000835D 8EDA                            mov     ds,dx
 46680                                  
 46681                                  	;mov	byte [0],'Z'
 46682 0000835F C60600005A              	mov     byte [ARENA.SIGNATURE],arena_signature_end
 46683                                          ;mov	word [1],0
 46684 00008364 C70601000000            	mov     word [ARENA.OWNER],arena_owner_system
 46685                                  
 46686 0000836A 36A1[4603]                      mov     ax,[ss:ENDMEM]
 46687 0000836E 29D0                    	sub	ax,dx
 46688 00008370 48                              dec     ax
 46689 00008371 A30300                          mov     [ARENA.SIZE],ax
 46690                                  
 46691                                  	; point to sft 0
 46692                                  
 46693                                  	;mov	di,offset dosdata:sftabl + sftable
 46694                                  	;mov	di,SFTABL+6
 46695 00008374 BF[D200]                	mov	di,SFTABL+SFT.SFTable
 46696 00008377 B80300                          mov     ax,3
 46697 0000837A AB                              stosw           		; adjust refcount
 46698                                  
 46699                                  	; es:di is shared data area i.e., es:di -> dosdata:sysinttable
 46700                                  
 46701                                          ;mov	di,offset dosdata:sysinittable
 46702                                  	;mov	di,0D28h
 46703 0000837B BF[790D]                	mov	di,SysInitTable	
 46704                                  
 46705 0000837E 42                      	inc	dx			; advance dx from arena to psp
 46706 0000837F 8EDA                    	mov	ds,dx			; point ds to psp
 46707                                  
 46708                                  					; pass the address os seg_reinit 
 46709                                  					; in dx
 46710 00008381 BA[EF83]                	mov	dx,seg_reinit
 46711 00008384 B9[137E]                	mov	cx,exepatch_start
 46712 00008387 81E9[0000]              	sub	cx,_$STARTCODE		; cx = (doscode - exepatch) - dosinit
 46713                                  
 46714 0000838B B8[CA80]                	mov	ax,SYSBUF
 46715 0000838E 2D[0000]                	sub	ax,_$STARTCODE		; ax = size of doscode - dosinit
 46716                                  	
 46717 00008391 368B26[8405]                    mov     sp,[ss:USER_SP]		; use ss override for next 2
 46718 00008396 368E16[8605]                    mov     ss,[ss:USER_SS]
 46719                                  
 46720 0000839B CB                              retf
 46721                                  
 46722                                  ;
 46723                                  ; END OF DOSINIT
 46724                                  ;
 46725                                  ;--------------------------------------------------------------------------
 46726                                  
 46727                                  CHARINIT:
 46728                                  	; 24/04/2019 - Retro DOS v4.0
 46729                                  	; 07/07/2018 - Retro DOS v3.0
 46730                                  	;mov	byte [ss:035Ah],26 ; 1Ah
 46731 0000839C 36C606[5A03]1A                  MOV	BYTE [SS:DEVCALL_REQLEN],DINITHL
 46732                                  	;mov	byte [ss:035Bh],0
 46733 000083A2 36C606[5B03]00                  MOV	BYTE [SS:DEVCALL_REQUNIT],0
 46734                                  	;mov	byte [ss:035Ch],0
 46735 000083A8 36C606[5C03]00                  MOV	BYTE [SS:DEVCALL_REQFUNC],DEVINIT
 46736                                  	;mov	word [ss:035BD],0
 46737 000083AE 36C706[5D03]0000                MOV	WORD [SS:DEVCALL_REQSTAT],0
 46738 000083B5 06                              PUSH	ES
 46739 000083B6 53                              PUSH	BX
 46740 000083B7 50                              PUSH	AX
 46741 000083B8 BB[5A03]                        MOV	BX,DEVCALL
 46742                                          ;PUSH	CS
 46743 000083BB 16                      	PUSH	SS ; 30/04/2019
 46744 000083BC 07                              POP	ES
 46745 000083BD E890CC                          CALL	DEVIOCALL2	
 46746 000083C0 58                      	POP	AX
 46747 000083C1 5B                              POP	BX
 46748 000083C2 07                              POP	ES
 46749 000083C3 C3                              RETN
 46750                                  
 46751                                  ; 25/04/2019 - Retro DOS v4.0
 46752                                  
 46753                                  ;-----------------------------------------------------------------------------
 46754                                  ;
 46755                                  ;	check_XMM: routine to check presence of XMM driver
 46756                                  ;
 46757                                  ;	Exit:   Sets up the XMM entry point in XMMcontrol in DOSDATA
 46758                                  ;
 46759                                  ;	USED:	none
 46760                                  ;
 46761                                  ;-----------------------------------------------------------------------------
 46762                                  
 46763                                  check_XMM: ; proc near
 46764                                  ;
 46765                                  ; determine whether or not an XMM driver is installed
 46766                                  ;
 46767 000083C4 50                      	push	ax
 46768                                  	;mov	ax,(XMM_MULTIPLEX<<8)+XMM_INSTALL_CHECK
 46769 000083C5 B80043                  	mov	ax,4300h
 46770 000083C8 CD2F                    	int	2Fh
 46771                                  		; - Multiplex - XMS - INSTALLATION CHECK
 46772                                  		; Return: AL = 80h XMS driver installed
 46773                                  		; AL <> 80h no driver
 46774 000083CA 3C80                    	cmp	al,80h			; Q: installed
 46775 000083CC 751D                    	jne	short cXMM_no_driver	; N: set error, quit
 46776                                  ;
 46777                                  ; get the XMM control functions entry point, save it, we
 46778                                  ; need to call it later.
 46779                                  ;
 46780 000083CE 53                      	push	bx
 46781 000083CF 52                      	push	dx
 46782 000083D0 1E                      	push	ds
 46783 000083D1 06                      	push	es
 46784                                  	;mov	ax,(XMM_MULTIPLEX<<8)+XMM_FUNCTION_ADDR
 46785 000083D2 B81043                  	mov	ax,4310h
 46786 000083D5 CD2F                    	int	2Fh
 46787                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
 46788                                  		; Return: ES:BX -> driver entry point
 46789                                  
 46790 000083D7 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 46791                                  
 46792 000083DC 891E[AD11]              	mov	[XMMcontrol],bx
 46793 000083E0 8C06[AF11]              	mov	[XMMcontrol+2],es
 46794                                  cXMMexit:
 46795 000083E4 F8                      	clc
 46796 000083E5 07                      	pop	es
 46797 000083E6 1F                      	pop	ds
 46798 000083E7 5A                      	pop	dx
 46799 000083E8 5B                      	pop	bx
 46800 000083E9 58                      	pop	ax
 46801 000083EA C3                      	retn				; done
 46802                                  ;
 46803                                  ; set carry if XMM driver not present
 46804                                  ;
 46805                                  cXMM_no_driver:
 46806 000083EB F9                      	stc
 46807 000083EC 58                      	pop	ax
 46808 000083ED C3                      	retn
 46809                                  
 46810                                  ;-----------------------------------------------------------------------------
 46811                                  ;
 46812                                  ; Procedure Name : seg_reinit
 46813                                  ;
 46814                                  ; Inputs	 : ES has final dos code location
 46815                                  ;		   AX = 0 / 1
 46816                                  ;
 46817                                  ; Outputs	 : Patch in the sharer and other tables with seg in ES
 46818                                  ;		   if AX =0
 46819                                  ;		      if first entry
 46820                                  ;			 patch segment & offset of vectors with stub
 46821                                  ;			 and stub with segment in ES
 46822                                  ;		      else
 46823                                  ;			 patch stub with segment in ES
 46824                                  ;
 46825                                  ;		   else if AX = 1
 46826                                  ;			patch segment of vectors with segment in ES
 46827                                  ;
 46828                                  ; NOTE		 : This routine can be called at most twice!
 46829                                  ;
 46830                                  ; Regs Mod.	 : es, ax, di, cx, bx
 46831                                  ;-----------------------------------------------------------------------------
 46832                                  
 46833 000083EE 00                      num_entry: db	0		; keeps track of the # of times this routine
 46834                                  				; has been called. (0 or 1)
 46835                                  
 46836                                  	; 04/11/2022 - Retro DOS v4.0 (ref: MSDOS 5.0)
 46837                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BAB7h
 46838                                  	; 25/05/2019 - Retro DOS v4.0 (ref: MSDOS 6.21)
 46839                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:0BDA5h
 46840                                  
 46841                                  seg_reinit:	; proc	far
 46842 000083EF 1E                      	push	ds
 46843                                  
 46844 000083F0 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 46845                                  
 46846 000083F5 E88600                  	call	patch_misc_segments	; patch in segments for sharer and 
 46847                                  					; other tables with seg in ES.
 46848                                  	; 17/12/2022
 46849                                  	; cx = 0
 46850 000083F8 39C8                    	cmp	ax,cx ; 0
 46851                                  	;cmp	ax,0
 46852 000083FA 753D                    	jne	short patch_vec_seg	; patch vectors with segment in es
 46853                                  
 46854                                  	; 17/12/2022
 46855 000083FC 2E380E[EE83]            	cmp	[cs:num_entry],cl ; 0
 46856                                  	;cmp	byte [cs:num_entry],0	; Q: is it the first call to this
 46857 00008401 7508                    	jne	short second_entry	; N: just patch the stub with 
 46858                                  					;    segment in ES
 46859                                  					; Y: patch the vectors with stub
 46860 00008403 8CD8                    	mov	ax,ds
 46861 00008405 E83E00                  	call	patch_vec_segments	; patch the segment of vectors
 46862 00008408 E8BD00                  	call	patch_offset		; patch the offsets of vectors 
 46863                                  					; with those in the stub.
 46864                                  	; 17/12/2022
 46865                                  	; cx = 0
 46866                                  second_entry:
 46867 0000840B 8CC0                    	mov	ax,es			; patch the stub with segment in es
 46868                                  
 46869                                  	;mov	di,OFFSET DOSDATA:DOSINTTABLE
 46870                                  	;mov	di,1062h	; (same table addr for MSDOS 5.0 and MSDOS 6.21)
 46871 0000840D BF[AC10]                	mov	di,DOSINTTABLE
 46872                                  	; 17/12/2022
 46873                                  	; cx = 0
 46874                                  	;mov	cx,9
 46875 00008410 B109                    	mov	cl,9
 46876 00008412 1E                      	push	ds			
 46877 00008413 07                      	pop	es			; es:di -> DOSINTTABLE
 46878                                  
 46879                                  dosinttabloop:
 46880                                  	;add	di,2
 46881                                  	; 19/06/2023
 46882 00008414 47                      	inc	di
 46883 00008415 47                      	inc	di
 46884 00008416 AB                      	stosw
 46885 00008417 E2FB                    	loop	dosinttabloop	
 46886                                  
 46887                                  ; For ROMDOS, this routine will only be called when the DOS wants to
 46888                                  ; use the HMA, so we don't want to check CS
 46889                                  
 46890                                  ;ifndef ROMDOS
 46891 00008419 3D00F0                  	cmp	ax,0F000h		; Q: is the DOS running in the HMA
 46892 0000841C 7220                    	jb	short sr_done		; N: done
 46893                                  ;endif
 46894 0000841E E8A3FF                  	call	check_XMM		; Y: set up the XMS entry point
 46895 00008421 721B                    	jc	short sr_done		; failed to set up XMS do not do
 46896                                  					; A20 toggling in the stub.
 46897                                  	; 17/12/2022
 46898                                  	; cx = 0
 46899 00008423 E81D01                  	call	patch_in_nops		; enable the stub to check A20 state
 46900                                  ; M021-
 46901                                  	;mov	byte [1211h],1
 46902 00008426 C606[870D]01            	mov	byte [DosHasHMA],1	; set flag telling DOS control of HMA
 46903                                  				
 46904                                  					; set pointer to the routine that 
 46905                                  					; patches buggy exepacked code.
 46906                                  	;mov	[FixExePatch],offset DOSCODE:ExePatch
 46907 0000842B C706[880D][637F]        	mov	word [FixExePatch],ExePatch
 46908                                  					; M068: set pointer to the routine 
 46909                                  					; M068: that detects copy protected
 46910                                  					; M068: apps
 46911                                  	;mov	[ChkCopyProt],offset DOSCODE:IsCopyProt
 46912 00008431 C706[6100][9480]        	mov	word [ChkCopyProt],IsCopyProt
 46913                                  
 46914                                  	; 19/09/2023
 46915 00008437 EB05                    	jmp	short sr_done
 46916                                  
 46917                                  ; 28/12/2022 - Retro DOS v4.1
 46918                                  %if 0
 46919                                  ;----------------------------------------------------------------------------
 46920                                  
 46921                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:0BDF1h
 46922                                  
 46923                                  ;	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 46924                                  ;
 46925                                  ;; M020 - begin
 46926                                  ;
 46927                                  ;	call	WhatCPUType
 46928                                  ;	cmp	al,1
 46929                                  ;	jne	short sr_done 		; we need Rational Patch only
 46930                                  ;					;  on 286 systems
 46931                                  ;	;mov	[RationalPatchPtr],offset DOSCODE:RationalPatch
 46932                                  ;	mov	word [RationalPatchPtr],RationalPatch
 46933                                  ;
 46934                                  ;; M020 - end
 46935                                  ;
 46936                                  ;	jmp	short sr_done
 46937                                  ;
 46938                                  ;patch_vec_seg:				; patch vectors with segment in es
 46939                                  ;	mov	ax,es
 46940                                  ;	call	patch_vec_segments	; patch in DOSCODE for the segments
 46941                                  ;					; NOTE we don't have to patch the 
 46942                                  ;					; offsets as they have been already
 46943                                  ;					; set to the doscode offsets at
 46944                                  ;					; DOSINIT.
 46945                                  ;sr_done:
 46946                                  ;	mov	byte [cs:num_entry],1
 46947                                  ;	pop	ds
 46948                                  ;	retf	; ! far return !
 46949                                  
 46950                                  ;----------------------------------------------------------------------------
 46951                                  ;
 46952                                  ; Procedure Name : WhatCPUType
 46953                                  ;
 46954                                  ; Inputs	 : none
 46955                                  ;
 46956                                  ; Outputs	 : AL = 0 if CPU <  286
 46957                                  ;		      = 1 if CPU == 286
 46958                                  ;		      = 2 if CPU >= 386
 46959                                  ;
 46960                                  ; Regs. Mod.	 : AX
 46961                                  ;
 46962                                  ;----------------------------------------------------------------------------
 46963                                  
 46964                                  WhatCPUType:
 46965                                  	; 25/04/2019 - Retro DOS v4.0
 46966                                  	;get_cpu_type	; done with a MACRO which can't be generated > once
 46967                                  
 46968                                  	;CPUTYPE.INC (MSDOS 6.0, 1991)
 46969                                  
 46970                                  ; Note: this must be a macro, and not a subroutine in the BIOS since
 46971                                  ; 	it is called from both CODE and SYSINITSEG.
 46972                                  ;
 46973                                  ;------GET_CPU_TYPE-----------------------------------May, 88 by M.Williamson
 46974                                  ;  Returns: AX = 0 if 8086 or 8088
 46975                                  ;              = 1 if 80286
 46976                                  ;              = 2 if 80386
 46977                                  
 46978                                  	; 04/11/2022
 46979                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BB03h
 46980                                  
 46981                                  Get_CPU_Type:	;macro
 46982                                  	pushf
 46983                                  	push	bx			; preserve bx
 46984                                  	xor	bx,bx			; init bx to zero
 46985                                  
 46986                                  	xor	ax,ax			; 0000 into AX
 46987                                  	push	ax			; put it on the stack...
 46988                                  	popf				; ...then shove it into the flags
 46989                                  	pushf				; get it back out of the flags...
 46990                                  	pop	ax			; ...and into ax
 46991                                  	and	ax,0F000h		; mask off high four bits
 46992                                  	cmp	ax,0F000h		; was it all 1's?
 46993                                  	je	short cpu_8086		; aye; it's an 8086 or 8088
 46994                                  
 46995                                  	mov	ax,0F000h		; now try to set the high four bits..
 46996                                  	push	ax
 46997                                  	popf
 46998                                  	pushf
 46999                                  	pop	ax			; ...and see what happens
 47000                                  	and	ax,0F000h		; any high bits set ?
 47001                                  	jz	short cpu_286		; nay; it's an 80286
 47002                                  
 47003                                  cpu_386:				; bx starts as zero
 47004                                  	inc	bx			; inc twice if 386
 47005                                  cpu_286:				; just inc once if 286
 47006                                  	inc	bx
 47007                                  cpu_8086:				; don't inc at all if 086
 47008                                  	mov	ax,bx			; put CPU type value in ax
 47009                                  	pop	bx			; restore original bx
 47010                                  	popf
 47011                                  	
 47012                                  	;endm
 47013                                  
 47014                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS)
 47015                                  	retn	; 19/09/2023
 47016                                  
 47017                                  ; 19/09/2023
 47018                                  ;	; 04/11/2022
 47019                                  ;	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BB27h
 47020                                  ;	cmp	al,1
 47021                                  ;	jne	short sr_done 		; we need Rational Patch only
 47022                                  ;					;  on 286 systems
 47023                                  ;	mov	word [RationalPatchPtr],RationalPatch
 47024                                  
 47025                                  ;----------------------------------------------------------------------------
 47026                                  %endif	; 28/12/2022
 47027                                  
 47028                                  	; 19/09/2023
 47029                                  	;jmp	short sr_done
 47030                                  
 47031                                  patch_vec_seg:				; patch vectors with segment in es
 47032 00008439 8CC0                    	mov	ax,es
 47033 0000843B E80800                  	call	patch_vec_segments	; patch in DOSCODE for the segments
 47034                                  					; NOTE we don't have to patch the 
 47035                                  					; offsets as they have been already
 47036                                  					; set to the doscode offsets at
 47037                                  					; DOSINIT.
 47038                                  sr_done:
 47039 0000843E 2EC606[EE83]01          	mov	byte [cs:num_entry],1
 47040 00008444 1F                      	pop	ds
 47041 00008445 CB                      	retf	; ! far return !
 47042                                  
 47043                                  ;----------------------------------------------------------------------------
 47044                                  ;
 47045                                  ; Procedure Name : patch_vec_segments
 47046                                  ;
 47047                                  ; Inputs	 : ax -> has segment address to patch in
 47048                                  ;		   ds -> DOSDATA
 47049                                  ;
 47050                                  ; Outputs	 : Patches in AX as the segment for the following vectors:
 47051                                  ;			
 47052                                  ;			0,20-28,3a-3f
 47053                                  ;
 47054                                  ; Regs. Mod.	 : DI,CX,DX,AX
 47055                                  ;
 47056                                  ;----------------------------------------------------------------------------
 47057                                  
 47058                                  patch_vec_segments:
 47059                                  
 47060 00008446 06                      	push	es
 47061                                  
 47062 00008447 31C9                    	xor	cx,cx ; 0
 47063 00008449 8EC1                    	mov	es,cx
 47064                                  
 47065                                  	;mov	di,82h
 47066 0000844B BF8200                  	mov	di,INTBASE+2		; di -> segment of int 20 vector
 47067                                  
 47068 0000844E 26A30200                	mov	[es:2],ax		; segment of default divide trap handler
 47069                                  
 47070                                  					; set vectors 20 & 21
 47071                                  	; 04/11/2022
 47072                                  	;mov	cx,2
 47073                                  	; 17/12/2022
 47074                                  	;mov	cl,2
 47075                                  ps_set1:
 47076 00008452 AB                      	stosw	; int 20h segment
 47077                                  	;add	di,2
 47078                                  	; 17/12/2022
 47079 00008453 47                      	inc	di
 47080 00008454 47                      	inc	di
 47081                                  	;loop	ps_set1
 47082                                  
 47083                                  	; 17/12/2022
 47084 00008455 AB                      	stosw	; int 21h segment
 47085                                  	;inc	di
 47086                                  	;inc	di
 47087                                  
 47088                                  	;add	di,4			; skip int 22h vector
 47089 00008456 83C706                  	add	di,6 ; *
 47090                                  
 47091 00008459 AB                      	stosw				; set int 23h
 47092 0000845A 83C706                  	add	di,6			; skip int 24h
 47093                                  
 47094                                  					; set vectors 25-28 and 2a-3f 
 47095                                  	; 04/11/2022
 47096                                  	;mov	cx,4			; set 4 segments
 47097                                  	; 17/12/2022
 47098 0000845D B104                    	mov	cl,4
 47099                                  ps_set2:
 47100 0000845F AB                      	stosw				
 47101                                  	;add	di,2
 47102                                  	; 17/12/2022
 47103 00008460 47                      	inc	di
 47104 00008461 47                      	inc	di
 47105 00008462 E2FB                    	loop	ps_set2
 47106                                  
 47107 00008464 83C704                  	add	di,4			; skip int 29h vector (fast con) as it may
 47108                                  					;   already be set.
 47109                                  	; 04/11/2022
 47110                                  	;mov	cx,6			; set 6 segs (skip 2 between each)
 47111                                  	; 17/12/2022
 47112 00008467 B106                    	mov	cl,6			;  set segs for ints 2ah-2fh
 47113                                  ps_set3:
 47114 00008469 AB                      	stosw
 47115                                  	;add	di,2
 47116                                  	; 17/12/2022
 47117 0000846A 47                      	inc	di
 47118 0000846B 47                      	inc	di
 47119 0000846C E2FB                    	loop	ps_set3
 47120                                  
 47121                                  ; 30h & 31H is the CPM call entry point whose segment address is set up by
 47122                                  ; below. So skip it.
 47123                                  
 47124 0000846E 83C708                  	add	di,8			; skip vector 30h & 31h 
 47125                                  	
 47126                                  	; 04/11/2022
 47127                                  	;mov	cx,14			; set 14 segs (skip 2 between each)
 47128                                  	; 17/12/2022
 47129 00008471 B10E                    	mov	cl,14			;   sets segs for ints 32h-3fh
 47130                                  ps_set4:
 47131 00008473 AB                      	stosw
 47132                                  	;add	di,2
 47133                                  	; 17/12/2022
 47134 00008474 47                      	inc	di
 47135 00008475 47                      	inc	di
 47136 00008476 E2FB                    	loop	ps_set4
 47137                                  
 47138                                  ; set offset of int2f
 47139                                  
 47140                                  ;if installed
 47141                                  ;	mov	word ptr es:[02fh * 4],offset doscode:int2f
 47142                                  ;endif
 47143                                  	;mov	[es:0C3h],ax
 47144 00008478 26A3C300                	mov	[es:ENTRYPOINT+3],ax
 47145                                  	; 17/12/2022
 47146                                  	; cx = 0
 47147 0000847C 07                      	pop	es
 47148 0000847D C3                      	retn
 47149                                  
 47150                                  ;---------------------------------------------------------------------------
 47151                                  ;
 47152                                  ; Procedure Name : patch_misc_segments
 47153                                  ;
 47154                                  ; Inputs	 : es = segment to patch in
 47155                                  ;		   ds = dosdata
 47156                                  ;
 47157                                  ; outputs	 : patches in the sharer and other tables in the dos
 47158                                  ;		   with right dos code segment in es
 47159                                  ;
 47160                                  ; Regs Mod	 : DI,SI,CX
 47161                                  ;
 47162                                  ;---------------------------------------------------------------------------
 47163                                  
 47164                                  patch_misc_segments:
 47165                                  
 47166 0000847E 53                      	push	bx
 47167 0000847F 06                      	push	es
 47168 00008480 50                      	push	ax
 47169                                  
 47170 00008481 8CC0                    	mov	ax,es			; ax - > DOS segment
 47171                                  	
 47172 00008483 1E                      	push	ds
 47173 00008484 07                      	pop	es			; es -> DOSDATA
 47174                                  	
 47175                                  ; initialize the jump table for the sharer...
 47176                                  
 47177                                  	;mov	di,offset dosdata:jshare
 47178                                  	;mov	di,90h
 47179 00008485 BF[9000]                	mov	di,JShare
 47180                                  	;mov	bx,[0AAAh]
 47181 00008488 8B1E[AA0A]              	mov	bx,[TEMP_DOSLOC]	; bx = location to which the share
 47182                                  					; table was patched during the first
 47183                                  					; call to this routine
 47184 0000848C B90F00                  	mov	cx,15
 47185                                  jumptabloop:
 47186                                  	;add	di,2			; skip offset
 47187                                  	; 17/12/2022
 47188 0000848F 47                      	inc	di
 47189 00008490 47                      	inc	di
 47190 00008491 83FBFF                  	cmp	bx,-1 ; 0FFFFh		; Q: is this called for the 1st time
 47191 00008494 7405                    	je	short share_patch	; Y: patch in sharer table
 47192                                  					; N: 
 47193 00008496 263B1D                  	cmp	bx,[es:di]		; Q: has share been installed
 47194 00008499 7501                    	jne	short no_share_patch	; Y: don't patch in sharer table
 47195                                  share_patch:
 47196 0000849B AB                      	stosw				; drop in segment
 47197                                  no_share_patch:
 47198 0000849C E2F1                    	loop	jumptabloop
 47199                                  					; BUGBUG patching the country info 
 47200                                  					; with dosdata can be done inline
 47201                                  					; in dosinit.
 47202                                  					; for dos 3.3 country info
 47203                                  					; table address
 47204                                  
 47205                                  	;mov	si,offset dosdata:country_cdpg
 47206                                  	;mov	si,122Ah   
 47207 0000849E BE[5113]                	mov	si,COUNTRY_CDPG
 47208                                  					; initialize double word
 47209                                  					; pointers with dosdata in ds
 47210                                  	;mov	[si+4Fh],ds
 47211                                  	;mov	[si+54h],ds
 47212                                  	;mov	[si+59h],ds
 47213                                  	;mov	[si+5Eh],ds
 47214                                  	;mov	[si+80h],ds
 47215                                  	;mov	[si+63h],ds
 47216 000084A1 8C5C4F                  	mov	[si+DOS_CCDPG.ccUcase_ptr+2],ds    
 47217 000084A4 8C5C54                  	mov	[si+DOS_CCDPG.ccFileUcase_ptr+2],ds 
 47218 000084A7 8C5C59                  	mov	[si+DOS_CCDPG.ccFileChar_ptr+2],ds
 47219 000084AA 8C5C5E                  	mov	[si+DOS_CCDPG.ccCollate_ptr+2],ds
 47220 000084AD 8C9C8000                	mov	[si+DOS_CCDPG.ccMono_ptr+2],ds
 47221 000084B1 8C5C63                  	mov	[si+DOS_CCDPG.ccDBCS_ptr+2],ds	
 47222                                  
 47223                                  					; fastopen routines are in doscode
 47224                                  					; so patch with doscode seg in ax
 47225                                  
 47226                                  	;mov	si,offset dosdata:fastopentable
 47227                                  	;mov	si,0D30h
 47228 000084B4 BE[6312]                	mov	si,FastOpenTable
 47229                                  
 47230                                  	; 17/12/2022
 47231                                  	; bx = [TEMP_DOSLOC]
 47232 000084B7 83FBFF                  	cmp	bx,-1
 47233                                  	;cmp	word [TEMP_DOSLOC],-1	; Q: first time 
 47234 000084BA 7405                    	je	short fast_patch	; Y: patch segment
 47235                                  	;mov	cx,[TEMP_DOSLOC]
 47236                                  					; Q: has fastopen patched in it's
 47237                                  					;    segment
 47238                                  	; 17/12/2022
 47239 000084BC 3B5C04                  	cmp	bx,[si+fastopen_entry.name_caching+2]
 47240                                  	;;cmp	cx,[si+4]
 47241                                  	;cmp	cx,[si+fastopen_entry.name_caching+2]
 47242 000084BF 7503                    	jne	short no_fast_patch	; Y: don't patch in doscode seg
 47243                                  
 47244                                  fast_patch:
 47245                                  	;mov	[si+4],ax
 47246 000084C1 894404                  	mov	[si+fastopen_entry.name_caching+2],ax
 47247                                  no_fast_patch:
 47248                                  	; 17/12/2022
 47249                                  	; cx = 0
 47250 000084C4 58                      	pop	ax
 47251 000084C5 07                      	pop	es
 47252 000084C6 5B                      	pop	bx
 47253                                  
 47254 000084C7 C3                      	retn
 47255                                  
 47256                                  ;--------------------------------------------------------------------------
 47257                                  ;
 47258                                  ; Procedure Name : patch_offset
 47259                                  ; 
 47260                                  ; Inputs	 : NONE
 47261                                  ;
 47262                                  ; Outputs	 : Patches in the offsets in the low_mem_stub for vectors
 47263                                  ;		   0,20-28,3a-3f, and 30,31
 47264                                  ;
 47265                                  ;
 47266                                  ; Regs. Mod	 : AX,DI,CX
 47267                                  ;--------------------------------------------------------------------------
 47268                                  
 47269                                  patch_offset:
 47270 000084C8 06                      	push	es		; preserve es
 47271                                  
 47272 000084C9 31C0                    	xor	ax,ax
 47273 000084CB 8EC0                    	mov	es,ax
 47274                                  				; set default divide trap address
 47275                                  	;mov	word ptr es:[0],offset dosdata:ldivov	
 47276                                  	;mov	word [es:0],108Ah
 47277 000084CD 26C7060000[D410]        	mov	word [es:0],ldivov
 47278                                  
 47279                                  	;mov	di,80h
 47280 000084D4 BF8000                  	mov	di,INTBASE	; di-> offset of int 20 handler
 47281                                  	;mov	ax,offset dosdata:lirett
 47282                                  	;mov	ax,10DAh
 47283 000084D7 B8[2411]                	mov	ax,lirett
 47284                                  				; set vectors 20 & 21 to point to iret.
 47285                                  	; 17/12/2022
 47286                                  	; cx = 0
 47287                                  
 47288                                  	;mov	cx,2		; set 2 offsets (skip 2 between each)
 47289                                  po_iset1:
 47290 000084DA AB                      	stosw	; int 20h offset
 47291                                  	;add	di,2 ; *
 47292                                  	;loop	po_iset1
 47293                                  	; 17/12/2022
 47294 000084DB 47                      	inc	di
 47295 000084DC 47                      	inc	di
 47296 000084DD AB                      	stosw	; int 21h offset
 47297                                  
 47298                                  	;add	di,4		; skip vector 22h
 47299                                  	; 17/12/2022
 47300 000084DE 83C706                  	add	di,6 ; *	
 47301                                  
 47302 000084E1 AB                      	stosw			; set offset of 23h
 47303                                  	;add	di,6		; skip 24h
 47304                                  	; 19/09/2023
 47305 000084E2 83C712                  	add	di,18		; skip 23h segment and int 24-25-26-27h
 47306                                  
 47307                                  				; set vectors 25-28 and 2a-3f to iret.
 47308                                  	; 04/11/2022
 47309                                  	;mov	cx,4		; set 4 offsets (skip 2 between each)
 47310                                  	; 19/09/2023
 47311                                  	; 17/12/2022
 47312                                  	;mov	cl,4		;   sets offsets for ints 25h-28h
 47313                                  po_iset2:
 47314 000084E5 AB                      	stosw		; set offset for int 28h ; 19/09/2023
 47315                                  	;add	di,2
 47316                                  	; 19/09/2023
 47317                                  	; 17/12/2022
 47318                                  	;inc	di
 47319                                  	;inc	di
 47320                                  	; 19/09/2023
 47321                                  	;loop	po_iset2
 47322                                  
 47323                                  	;add	di,4		; skip vector 29h
 47324                                  	; 19/09/2023
 47325 000084E6 83C706                  	add	di,6	; skip int 28h segment and int 29h ; 19/09/2023
 47326                                  
 47327                                  	; 04/11/2022
 47328                                  	;mov	cx,6		; set 6 offsets (skip 2 between each)
 47329                                  	; 17/12/2022
 47330                                  	;mov	cl,6		;   sets offsets for ints 2ah-2fh
 47331 000084E9 B105                    	mov	cl,5		; sets offsets for ints 2Ah-2Eh
 47332                                  po_iset3:
 47333 000084EB AB                      	stosw
 47334                                  	;add	di,2
 47335                                  	; 17/12/2022
 47336 000084EC 47                      	inc	di
 47337 000084ED 47                      	inc	di
 47338 000084EE E2FB                    	loop	po_iset3
 47339                                  
 47340                                  ; 30h & 31H is the CPM call entry point whose offset address is set up by
 47341                                  ; below. So skip it.
 47342                                  
 47343                                  	;add	di,8		; skip vector 30h & 31h 
 47344                                  	; 17/12/2022
 47345 000084F0 83C70C                  	add	di,12		; skip vector 2Fh, 30h & 31h
 47346                                  
 47347                                  	; 04/11/2022
 47348                                  	;mov	cx,14		; set 14 offsets (skip 2 between each)
 47349                                  				;   sets offsets for ints 32h-3fh
 47350                                  	; 17/12/2022
 47351 000084F3 B10E                    	mov	cl,14 ; 26/06/2019
 47352                                  po_iset4:
 47353 000084F5 AB                      	stosw
 47354                                  	;add	di,2
 47355                                  	; 17/12/2022
 47356 000084F6 47                      	inc	di
 47357 000084F7 47                      	inc	di
 47358 000084F8 E2FB                    	loop	po_iset4
 47359                                  
 47360                                  ;if installed
 47361                                  	;mov	word ptr es:[02fh * 4],offset dosdata:lint2f
 47362                                  	;mov	word [es:0BCh],10C6h ; (MSDOS 5.0 & 6.21)
 47363 000084FA 26C706BC00[1011]        	mov	word [es:(2Fh*4)],lint2f
 47364                                  ;endif
 47365                                  
 47366                                  ; set up entry point call at vectors 30-31h
 47367                                  	;mov	byte [es:0C0h],0EAh
 47368 00008501 26C606C000EA            	mov	byte [es:ENTRYPOINT],mi_long_jmp
 47369                                  	;mov	word [es:0C1h],10D0h
 47370                                  
 47371 00008507 26C706C100[1A11]        	mov	word [es:ENTRYPOINT+1],lcall_entry
 47372                                  
 47373                                  							; 19/09/2023
 47374                                  	;mov	word [es:80h],1094h
 47375 0000850E 26C7068000[DE10]        	mov	word [es:addr_int_abort],lquit		; int 20h
 47376                                  	;mov	word [es:84h],109Eh
 47377 00008515 26C7068400[E810]        	mov	word [es:addr_int_command],lcommand	; int 21h
 47378                                  	;mov	word [es:94h],10A8h
 47379 0000851C 26C7069400[F210]        	mov	word [es:addr_int_disk_read],labsdrd	; int 25h  
 47380                                  	;mov	word [es:98h],10B2h
 47381 00008523 26C7069800[FC10]        	mov	word [es:addr_int_disk_write],labsdwrt	; int 26h
 47382                                  	;mov	word [es:9Ch],10BCh
 47383 0000852A 26C7069C00[0611]        	mov	word [es:addr_int_keep_process],lstay_resident	; int 27h
 47384                                  
 47385                                  	; 17/12/2022
 47386                                  	; CX = 0
 47387 00008531 07                      	pop	es		; restore es
 47388 00008532 C3                      	retn
 47389                                  
 47390                                  ;--------------------------------------------------------------------------
 47391                                  ;
 47392                                  ; 	Procedure Name	:	patch_in_nops
 47393                                  ;
 47394                                  ; 	Entry		: 	ES -> DOSDATA
 47395                                  ;
 47396                                  ;	Regs Mod	: 	cx, di
 47397                                  ;
 47398                                  ;	Description:
 47399                                  ;		This routine patches in 2 nops at the offsets specified in 
 47400                                  ;	patch_table. This basically enables the low mem stub to start 
 47401                                  ;	making XMS calls.
 47402                                  ;
 47403                                  ;--------------------------------------------------------------------------
 47404                                  
 47405                                  	; 04/11/2022
 47406                                  	; (MSDOS 5.0 MSDOS.SYS)
 47407                                  	; DOSCODE:0BC50h
 47408                                  
 47409                                  patch_table:	; label	byte
 47410                                  	;dw	offset dosdata:i0patch
 47411                                  	;dw	offset dosdata:i20patch
 47412                                  	;dw	offset dosdata:i21patch
 47413                                  	;dw	offset dosdata:i25patch
 47414                                  	;dw	offset dosdata:i26patch
 47415                                  	;dw	offset dosdata:i27patch
 47416                                  	;dw	offset dosdata:i2fpatch
 47417                                  	;dw	offset dosdata:cpmpatch
 47418 00008533 [D410]                  	dw	i0patch
 47419 00008535 [DE10]                  	dw	i20patch
 47420 00008537 [E810]                  	dw	i21patch
 47421 00008539 [F210]                  	dw	i25patch
 47422 0000853B [FC10]                  	dw	i26patch
 47423 0000853D [0611]                  	dw	i27patch
 47424 0000853F [1011]                  	dw	i2fpatch
 47425 00008541 [1A11]                  	dw	cpmpatch
 47426                                  
 47427                                  patch_table_size equ ($-patch_table)/2
 47428                                  
 47429                                  patch_in_nops:
 47430 00008543 50                      	push	ax
 47431 00008544 56                      	push	si
 47432 00008545 BE[3385]                	mov	si,patch_table
 47433 00008548 B89090                  	mov	ax,9090h ; nop, nop
 47434                                  	; 17/12/2022
 47435                                  	; cx = 0
 47436                                  	;mov	cx,8
 47437                                  	;mov	cx,patch_table_size ; 8
 47438 0000854B B108                    	mov	cl,patch_table_size ; 8
 47439                                  pin_loop:
 47440 0000854D 2E8B3C                  	mov	di,[cs:si]
 47441 00008550 AB                      	stosw
 47442                                  	;add	si,2
 47443                                  	; 17/12/2022
 47444 00008551 46                      	inc	si
 47445 00008552 46                      	inc	si
 47446 00008553 E2F8                    	loop	pin_loop
 47447 00008555 5E                      	pop	si
 47448 00008556 58                      	pop	ax
 47449 00008557 C3                      	retn
 47450                                  
 47451                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 47452                                  ; ---------------------------------------------------------------------------
 47453                                  ; MSDOS 5.0 - MSDOS.SYS offset BC77h, file offset 7EA7h
 47454                                  ; ---------------------------------------------------------------------------
 47455                                  
 47456                                  	; 05/12/2022 - temporary ; (paragraph alinment)
 47457                                  DOSCODE_END:
 47458                                  	;times	9 db 0	; db 9 dup(0)
 47459                                  	; 18/12/2022
 47460 00008558 0000                    	dw	0  ;	times 2 db 0
 47461                                  
 47462                                  ;align 16
 47463                                  	; DOSCODE:BC80h	(MSDOS 5.0 MSDOS.SYS file offset 7EB0h)
 47464                                  	; MSDOS.SYS file offset: 32432 (start of DOSDATA)
 47465                                  
 47466                                  ; ---------------------------------------------------------------------------
 47467                                  
 47468                                  
 47469                                  ;memstrt label word
 47470                                  ; ---------------------------------------------------------------------------
 47471                                  ; MSDOS 6.21 - MSDOS.SYS offset BF69h, file offset 8189h
 47472                                  ; ---------------------------------------------------------------------------
 47473                                  
 47474                                  MEMSTRT: ; 25/04/2019 - Retro DOS v4.0
 47475                                  
 47476                                  ; if not ROMDOS, then we close the dos code segment, otherwise we close
 47477                                  ; the dos initialization segment
 47478                                  
 47479                                  ;ifndef ROMDOS
 47480                                  
 47481                                  ;doscode ends
 47482                                  
 47483                                  ;else
 47484                                  
 47485                                  ;;dosinitseg ends
 47486                                  
 47487                                  ;endif ; ROMDOS
 47488                                  
 47489                                  ;============================================================================
 47490                                  
 47491                                  ; DPUBLIC <ParaRound, cXMM_no_driver, cXMMexit, char_init_loop, charinit>
 47492                                  ; DPUBLIC <check_XMM, continit, dosinttabloop, endlist>
 47493                                  ; DPUBLIC <initiret, iset1, iset2, jumptabloop, nxtentry>
 47494                                  ; DPUBLIC <notmax,  patch_offset, perdrv>
 47495                                  ; DPUBLIC <perunit, po_iset1, po_iset2, po_iset3>
 47496                                  ; DPUBLIC <ps_set1, ps_set2, ps_set3, seg_reinit>
 47497                                  ; DPUBLIC <sr_done, version_fake_table, xxx>
 47498                                  
 47499                                  ;; burasý doscode sonu
 47500                                  
 47501                                  ;============================================================================
 47502                                  ; DOSDATA
 47503                                  ;============================================================================
 47504                                  ; 29/04/2019 - Retro DOS 4.0
 47505                                  
 47506                                  ;[BITS 16]
 47507                                  
 47508                                  ;[ORG 0]
 47509                                  
 47510                                  ; 25/04/2019 - Retro DOS v4.0
 47511                                  
 47512                                  ;============================================================================
 47513                                  ; DOSDATA - MSDOS 6.21 - MSDOS.SYS Offset 0BF70h, file offset 8190h
 47514                                  ;============================================================================
 47515                                  
 47516                                  ;align 16
 47517                                  	; DOSDATA (MSDOS.SYS kernel DATA) segment starts here...
 47518                                  	; (4970 bytes for MSDOS 6.21)
 47519                                  	; (4976 bytes for Retro DOS v4.0, 25/05/2019 modification.)
 47520                                  
 47521                                  ;============================================================================
 47522                                  ; MSCONST.ASM (MSDOS 6.0, 1991)
 47523                                  ;============================================================================
 47524                                  ; 03/11/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 47525                                  ; 25/04/2019 - Retro DOS 4.0 (MSDOS 6.21)
 47526                                  ; 16/07/2018 - Retro DOS 3.0	
 47527                                  
 47528                                  ;Break <Initialized data and data used at DOS initialization>
 47529                                  ;----------------------------------------------------------------------------
 47530                                  
 47531                                  ; We need to identify the parts of the data area that are relevant to tasks
 47532                                  ; and those that are relevant to the system as a whole. Under 3.0, the system
 47533                                  ; data will be gathered with the system code. The process data under 2.x will
 47534                                  ; be available for swapping and under 3.0 it will be allocated per-process.
 47535                                  ;
 47536                                  ; The data that is system data will be identified by [SYSTEM] in the comments
 47537                                  ; describing that data item.
 47538                                  
 47539                                  ;DOSDATA SEGMENT
 47540                                  
 47541                                  ; 04/11/2022
 47542                                  ;[ORG 0]
 47543                                  
 47544                                  ; ----------------------------------------------------------------------------
 47545                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 47546                                  ; ----------------------------------------------------------------------------
 47547                                  ; DOSDATA segment start offset from beginning of MSDOS.SYS file: 32432 (7EB0h)
 47548                                  ; (3DD0h+7EB0h = 0BC80h) - for MSDOS 5.0 kernel file -
 47549                                  ; ----------------------------------------------------------------------------
 47550                                  
 47551                                  ; 04/11/2022
 47552                                  
 47553                                  ;DOSDATA:0000h
 47554                                  
 47555 0000855A 90<rep 6h>              align 16
 47556                                  
 47557                                  ; ----------------------------------------------------------------------------
 47558                                  ; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 47559                                  ; ----------------------------------------------------------------------------
 47560                                  
 47561                                  segment .data  vstart=0 ; 06/12/2022
 47562                                  
 47563                                  ; ============================================================================
 47564                                  
 47565                                  ; 06/12/2022
 47566                                  ;DOSDATASTART equ $
 47567                                  DOSDATASTART:
 47568                                  
 47569                                  
 47570                                  ;hkn; add 4 bytes to get correct offsets since jmp has been removed in START
 47571                                  
 47572                                  	;; 03/11/2022
 47573                                  	;jmp	DOSINIT		; MSDOS 5.0 - MSDOS.SYS (DOSDATA:0000h)
 47574                                  
 47575                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 47576                                  	;db	4 dup (?)	
 47577 00000000 00<rep 4h>              	times	4 db 0
 47578                                  
 47579                                  	; 29/04/2019 - Retro DOS v4.0 modification
 47580                                  	;dw 	_$STARTCODE ; DOSCODE offset and/or size of DOSDATA
 47581                                  	;dw	0
 47582                                  
 47583                                  	;EVEN
 47584                                  
 47585                                  ;align 2
 47586                                  
 47587                                  ; WANGO!!! The following word is used by SHARE and REDIR to determin data
 47588                                  ; area compatability. This location must be incremented EACH TIME the data
 47589                                  ; area here gets mucked with.
 47590                                  ;
 47591                                  ; Also, do NOT change this position relative to DOSDATA:0.
 47592                                  
 47593                                  MSCT001S:	; LABEL BYTE
 47594                                  	
 47595                                  DataVersion:	
 47596 00000004 0100                    	dw	1	;AC000; [SYSTEM] version number for DOS DATA
 47597                                  
 47598                                  ;hkn; add 8 bytes to get correct offsets since BugTyp, BugLev and "BUG " has 
 47599                                  ;hkn; been removed to DOSCODE above
 47600                                  
 47601                                  ;M044
 47602                                  ; First part of save area for saving last para of Window memory
 47603                                  
 47604                                  WinoldPatch1:	; db 8 dup (?)	;M044
 47605 00000006 00<rep 8h>              	times	8 db 0
 47606                                  
 47607                                  	; MSDOS 6.21 DOSDATA:000Eh
 47608                                  MYNUM:			; Offset 000Eh
 47609 0000000E 0000                    	dw	0	; [SYSTEM] A number that goes with MYNAME
 47610                                  FCBLRU: 		; [SYSTEM] LRU count for FCB cache
 47611 00000010 0000                    	dw	0
 47612                                  OpenLRU:
 47613 00000012 0000                    	dw	0	; [SYSTEM] LRU count for FCB cache opens
 47614                                  OEM_HANDLER: 		
 47615 00000014 FFFFFFFF                	dd	-1	; [SYSTEM] Pointer to OEM handler code
 47616                                  
 47617                                  ;	BUGBUG - who uses LeaveAddr?  What if we want to rework the
 47618                                  ;;			way that we leave DOS???? - jgl
 47619                                  
 47620                                  LeaveAddr:
 47621 00000018 [F603]                  	dw	LeaveDOS  ; <<OFFSET DOSCODE:LeaveDOS>> ; [SYSTEM]
 47622                                  RetryCount:		
 47623 0000001A 0300                    	dw	3	; [SYSTEM] Share retries
 47624                                  RetryLoop:
 47625 0000001C 0100                    	dw	1	; [SYSTEM] Share retries
 47626                                  LastBuffer:
 47627 0000001E FFFFFFFF                	dd	-1	; [SYSTEM] Buffer queue recency pointer
 47628                                  CONTPOS:
 47629 00000022 0000                    	dw	0	; [SYSTEM] location in buffer of next read
 47630                                  arena_head:
 47631 00000024 0000                    	dw	0	; [SYSTEM] Segment # of first arena in memory
 47632                                  
 47633                                  ;; 16/07/2018
 47634                                  ;;***************************************************************************
 47635                                  ;; NOTE: INT 21H AH=52H !  (http://stanislavs.org/helppc/int_21-52.html)
 47636                                  ;;***************************************************************************
 47637                                  ;; INT 21,52 - Get Pointer to DOS "INVARS" (Undocumented)
 47638                                  ;;
 47639                                  ;;	AH = 52h
 47640                                  ;;
 47641                                  ;;	on return:
 47642                                  ;;	ES:BX = pointer to DOS "invars", a table of pointers used by DOS.
 47643                                  ;;		Known "invars" fields follow (varies with DOS version):
 47644                                  ;;
 47645                                  ;;	Offset Size		 Description
 47646                                  ;;
 47647                                  ;;	 -12   word   sharing retry count (DOS 3.1-3.3)
 47648                                  ;;	 -10   word   sharing retry delay  (DOS 3.1-3.3)
 47649                                  ;;	  -8   dword  pointer to current disk buffer (DOS 3.x)
 47650                                  ;;	  -4   word   pointer in DOS code segment of unread CON input;
 47651                                  ;;		      0 indicates no unread input (DOS 3.x)
 47652                                  ;;	  -2   word   segment of first Memory Control Block (MCB)
 47653                                  ;;	  00   dword  pointer to first DRIVE PARAMETER TABLE (A:) in chain
 47654                                  ;;	  04   dword  pointer to DOS System File Table (SFT)
 47655                                  ;;	  08   dword  pointer to $CLOCK device driver
 47656                                  ;;	  0C   dword  pointer to CON device driver
 47657                                  ;;	  10   byte   number of logical drives in system
 47658                                  ;;	  11   word   maximum bytes/block of any block device
 47659                                  ;;	  13   dword  pointer to DOS cache buffer header
 47660                                  ;;	  17 18bytes  NUL device header, first 4 bytes of device header
 47661                                  ;;		      point to the next device in device chain
 47662                                  ;;
 47663                                  ;;***************************************************************************
 47664                                  
 47665                                  ; The following block of data is used by SYSINIT. 
 47666                                  ; Do not change the order or size of this block
 47667                                  
 47668                                  ;SYSINITVAR:
 47669                                  ;----------------------------------------------------------------------------
 47670                                  SYSINITVARS:
 47671                                  DPBHEAD:
 47672 00000026 00000000                	dd	0	; [SYSTEM] Pointer to head of DPB-FAT list
 47673                                  SFT_ADDR:
 47674 0000002A [CC000000]              	dd	SFTABL	; [SYSTEM] Pointer to first SFT table
 47675                                  BCLOCK:
 47676 0000002E 00000000                	dd	0	; [SYSTEM] The CLOCK device
 47677                                  BCON:
 47678 00000032 00000000                	dd	0	; [SYSTEM] Console device entry points
 47679                                  MAXSEC:
 47680 00000036 8000                    	dw	128	; [SYSTEM] Maximum allowed sector size
 47681                                  BUFFHEAD:
 47682 00000038 00000000                	dd	0	; [SYSTEM] Pointer to head of buffer queue
 47683                                  CDSADDR:
 47684 0000003C 00000000                	dd	0	; [SYSTEM] Pointer to curdir structure table
 47685                                  SFTFCB:
 47686 00000040 00000000                	dd	0	; [SYSTEM] pointer to FCB cache table
 47687                                  KEEPCOUNT:
 47688 00000044 0000                    	dw	0	; [SYSTEM] count of FCB opens to keep
 47689                                  NUMIO:
 47690 00000046 00                      	db	0	; [SYSTEM] Number of disk tables
 47691                                  CDSCOUNT:
 47692 00000047 00                      	db	0	; [SYSTEM] Number of CDS structures in above
 47693                                  
 47694                                  ; A fake header for the NUL device
 47695                                  NULDEV:
 47696 00000048 00000000                	dd	0	; [SYSTEM] Link to rest of device list
 47697                                  	;dw	8004h
 47698 0000004C 0480                    	dw	DEVTYP|ISNULL ; [SYSTEM] Null device attributes
 47699 0000004E [160E]                  	dw	SNULDEV	; [SYSTEM] Strategy entry point
 47700 00000050 [1B0E]                  	dw	INULDEV	; [SYSTEM] Interrupt entry point
 47701 00000052 4E554C2020202020        	db	"NUL     " ; [SYSTEM] Name of null device
 47702                                  SPLICES:
 47703 0000005A 00                      	db	0	; [SYSTEM] TRUE => splices being done
 47704                                  
 47705                                  Special_Entries:
 47706 0000005B 0000                    	dw	0	; [SYSTEM] address of special entries ;AN000;
 47707                                  UU_IFS_DOS_CALL:
 47708 0000005D 00000000                	dd	0	; [SYSTEM] entry for IFS DOS service ;AN000;
 47709                                  ; 
 47710                                  ; UU_IFS_HEADER:
 47711                                  ; 	dd	0	; [SYSTEM] IFS header chain ;AN000;
 47712                                  
 47713                                  ChkCopyProt:
 47714 00000061 0000                    	dw	0	; M068
 47715                                  A20OFF_PSP:
 47716 00000063 0000                    	dw	0	; M068
 47717                                  BUFFERS_PARM1:
 47718 00000065 0000                    	dw	0	; [SYSTEM] value of BUFFERS= ,m	;AN000;
 47719                                  BUFFERS_PARM2:
 47720 00000067 0000                    	dw	0	; [SYSTEM] value of BUFFERS= ,n ;AN000;
 47721                                  BOOTDRIVE:
 47722 00000069 00                      	db	0	; [SYSTEM] the boot drive ;AN000;
 47723                                  DDMOVE:
 47724 0000006A 00                      	db	0 	; [SYSTEM] 1 if we need DWORD move ;AN000;
 47725                                  EXT_MEM_SIZE:
 47726 0000006B 0000                    	dw	0	; [SYSTEM] extended memory size	;AN000;
 47727                                  
 47728                                  HASHINITVAR: ; LABEL   WORD	; AN000;
 47729                                  ;
 47730                                  ; Replaced by next two declarations
 47731                                  ;
 47732                                  ;UU_BUF_HASH_PTR:
 47733                                  ;	dd	0	; [SYSTEM] buffer Hash table addr
 47734                                  ;UU_BUF_HASH_COUNT:
 47735                                  ;	dw	1	; [SYSTEM] number of Hash entries
 47736                                  
 47737                                  BufferQueue:
 47738 0000006D 00000000                	dd	0	; [SYSTEM] Head of the buffer Queue
 47739                                  DirtyBufferCount:
 47740 00000071 0000                    	dw	0	; [SYSTEM] Count of Dirty buffers in the Que
 47741                                  			; BUGBUG ---- change to byte
 47742                                  SC_CACHE_PTR:
 47743 00000073 00000000                	dd	0	; [SYSTEM] secondary cache pointer
 47744                                  SC_CACHE_COUNT:
 47745 00000077 0000                    	dw	0 	; [SYSTEM] secondary cache count
 47746                                  BuffInHMA:
 47747 00000079 00                      	db	0	; Flag to indicate that buffs are in HMA
 47748                                  LoMemBuff:
 47749 0000007A 00000000                	dd	0	; Ptr to intermediate buffer
 47750                                  			;  in Low mem when buffs are in HMA
 47751                                  ;
 47752                                  ; All variables which have UU_ as prefix can be reused for other
 47753                                  ; purposes and can be renamed. All these variables were used for
 47754                                  ; EMS support of Buffer Manager. Now they are useless for Buffer
 47755                                  ; manager ---- MOHANS
 47756                                  ;
 47757                                  	;I_am	UU_BUF_EMS_FIRST_PAGE,3,<0,0,0>  
 47758                                  UU_BUF_EMS_FIRST_PAGE:	
 47759 0000007E 000000                  	db	0,0,0	; holds the first page above 640K
 47760                                  
 47761                                  	;;I_am	UU_BUF_EMS_NPA640,WORD,<0> ; holds the number of pages 
 47762                                  ;UU_BUF_EMS_NPA640:			   ; above 640K	
 47763                                  ;	dw	0			
 47764                                  
 47765                                  CL0FATENTRY:
 47766 00000081 FFFF                    	dw	-1	; M014:	Holds the data that
 47767                                  			; is used in pack/unpack rts.
 47768                                  			; in fat.asm if cluster 0 is specified.
 47769                                  			; SR;
 47770                                  IoStatFail:
 47771 00000083 00                      	db	0	; IoStatFail has been added to 
 47772                                  			; record a fail on an I24 
 47773                                  			; issued from IOFUNC on a status call. 
 47774                                  
 47775                                  ;***	I_am	UU_BUF_EMS_MODE,BYTE,<-1>	; EMS mode 	;AN000;
 47776                                  ;***	I_am	UU_BUF_EMS_HANDLE,BYTE		; buffer EMS handle ;AN000;
 47777                                  ;***	I_am	UU_BUF_EMS_PAGE_FRAME,WORD ,<-1>; EMS page frame # ;AN000;
 47778                                  ;***	I_am	UU_BUF_EMS_SEG_CNT,WORD,<1>	; EMS seg count	;AN000;
 47779                                  ;***	I_am	UU_BUF_EMS_PFRAME,WORD		; EMS page frame seg address ;AN000;
 47780                                  ;***	I_am	UU_BUF_EMS_RESERV,WORD,<0> 	; reserved	;AN000;
 47781                                  ;
 47782                                  ;***	I_am	UU_BUF_EMS_MAP_BUFF,1,<0>	; this is not used to save the
 47783                                  						; state of the 	buffers page.
 47784                                  						; This one byte is retained to
 47785                                  						; keep the size of this data 
 47786                                  						; block the same.;
 47787                                  ALLOCMSAVE:
 47788 00000084 00                      	db	0	; M063: temp var. used to 
 47789                                  			; M063: save alloc method in
 47790                                  			; M063: msproc.asm
 47791                                  A20OFF_COUNT:
 47792 00000085 00                      	db	0	; M068: indiactes the # of 
 47793                                  			; M068: int 21 calls for 
 47794                                  			; M068: which A20 is off
 47795                                  DOS_FLAG:
 47796 00000086 00                      	db	0	; see DOSSYM.INC for Bit 
 47797                                  			; definitions
 47798                                  UNPACK_OFFSET:
 47799 00000087 0000                    	dw	0	; saves pointer to the start
 47800                                  			; of unpack code in exepatch.
 47801                                  			; asm.
 47802                                  UMBFLAG:
 47803 00000089 00                      	db	0 	; M003: bit 0 indicates the 
 47804                                  			; M003: link state of the UMBs
 47805                                  			; M003: whether linked or not 
 47806                                  			; M003: to the DOS arena chain
 47807                                  SAVE_AX:
 47808 0000008A 0000                    	dw	0	; M000: temp varibale to store ax
 47809                                  			; M000: in msproc.asm
 47810                                  UMB_HEAD:
 47811 0000008C FFFF                    	dw	-1	; M000: this is initialized to  
 47812                                  			; M000: the first umb arena by 
 47813                                  			; M000: BIOS sysinit.
 47814                                  START_ARENA:
 47815 0000008E 0100                    	dw	1	; M000: this is the first arena 
 47816                                  			; M000: from which DOS will 
 47817                                  			; M000: start its scan for alloc.
 47818                                  
 47819                                  ; End of SYSINITVar block
 47820                                  ;----------------------------------------------------------------------------
 47821                                  
 47822                                  ; 25/04/2019 - Retro DOS v4.0
 47823                                  
 47824                                  ; 16/07/2018
 47825                                  ; MSDOS 3.3 (& MDOS 6.0)
 47826                                  
 47827                                  ;
 47828                                  ; Sharer jump table
 47829                                  ;
 47830                                  
 47831                                  ;PUBLIC	JShare
 47832                                  	;EVEN
 47833                                  
 47834                                  ;JShare	LABEL	DWORD
 47835                                  ;	DW	OFFSET DOSCODE:BadCall, 0
 47836                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	1   MFT_enter
 47837                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	2   MFTClose
 47838                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	3   MFTclU
 47839                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	4   MFTCloseP
 47840                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	5   MFTCloN
 47841                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	6   set_block
 47842                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	7   clr_block
 47843                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	8   chk_block
 47844                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	9   MFT_get
 47845                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	10  ShSave
 47846                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	11  ShChk
 47847                                  ;	DW	OFFSET DOSCODE:OKCall , 0  ;	12  ShCol
 47848                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	13  ShCloseFile
 47849                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	14  ShSU
 47850                                  
 47851                                  align 2
 47852                                  
 47853                                  JShare:
 47854 00000090 [3607]0000              		DW	BadCall,0
 47855 00000094 [3A07]0000              MFT_enter:	DW	OKCall, 0  ; 1   MFT_enter
 47856 00000098 [3A07]0000              MFTClose:	DW	OKCall, 0  ; 2   MFTClose
 47857 0000009C [3607]0000              MFTclU:		DW	BadCall,0  ; 3   MFTclU
 47858 000000A0 [3607]0000              MFTCloseP:	DW	BadCall,0  ; 4   MFTCloseP
 47859 000000A4 [3607]0000              MFTCloN:	DW	BadCall,0  ; 5   MFTCloN
 47860 000000A8 [3607]0000              set_block:	DW	BadCall,0  ; 6   set_block
 47861 000000AC [3607]0000              clr_block:	DW	BadCall,0  ; 7   clr_block
 47862 000000B0 [3A07]0000              chk_block:	DW	OKCall, 0  ; 8   chk_block
 47863 000000B4 [3607]0000              MFT_get:	DW	BadCall,0  ; 9   MFT_get
 47864 000000B8 [3607]0000              ShSave:		DW	BadCall,0  ; 10  ShSave
 47865 000000BC [3607]0000              ShChk:		DW	BadCall,0  ; 11  ShChk
 47866 000000C0 [3A07]0000              ShCol:		DW	OKCall, 0  ; 12  ShCol
 47867 000000C4 [3607]0000              ShCloseFile:	DW	BadCall,0  ; 13  ShCloseFile
 47868 000000C8 [3607]0000              ShSU:		DW	BadCall,0  ; 14  ShSU
 47869                                  
 47870                                  
 47871                                  ;============================================================================
 47872                                  ; CONST2.ASM (MSDOS 6.0, 1991)
 47873                                  ;============================================================================
 47874                                  ; 25/04/2019 - Retro DOS 4.0 
 47875                                  ; 16/07/2018 - Retro DOS 3.0	
 47876                                  
 47877                                  ;Break <Initialized data and data used at DOS initialization>
 47878                                  ;----------------------------------------------------------------------------
 47879                                  
 47880                                  ; We need to identify the parts of the data area that are relevant to tasks
 47881                                  ; and those that are relevant to the system as a whole.  Under 3.0, the system
 47882                                  ; data will be gathered with the system code.  The process data under 2.x will
 47883                                  ; be available for swapping and under 3.0 it will be allocated per-process.
 47884                                  ;
 47885                                  ; The data that is system data will be identified by [SYSTEM] in the comments
 47886                                  ; describing that data item.
 47887                                  
 47888                                  ;DOSDATA SEGMENT WORD PUBLIC 'DATA'
 47889                                  
 47890                                  ;
 47891                                  ; Table of routines for assignable devices
 47892                                  ;
 47893                                  ; MSDOS allows assignment if the following standard devices:
 47894                                  ;   stdin  (usually CON input)
 47895                                  ;   stdout (usually CON output)
 47896                                  ;   auxin  (usually AUX input)
 47897                                  ;   auxout (usually AUX output)
 47898                                  ;   stdlpt (usually PRN output)
 47899                                  ;
 47900                                  ; SPECIAL NOTE:
 47901                                  ;   Status of a file is a strange idea. We choose to handle it in this manner:
 47902                                  ;   If we're not at end-of-file, then we always say that we have a character.
 47903                                  ;   Otherwise, we return ^Z as the character and set the ZERO flag. In this
 47904                                  ;   manner we can support program written under the old DOS (they use ^Z as EOF
 47905                                  ;   on devices) and programs written under the new DOS (they use the ZERO flag
 47906                                  ;   as EOF).
 47907                                  
 47908                                  ; Default SFTs for boot up
 47909                                  
 47910                                  		;PUBLIC	SFTABL
 47911                                  
 47912                                  SFTABL:	   ; LABEL   DWORD		; [SYSTEM] file table
 47913 000000CC FFFF                    		DW -1			; [SYSTEM] link to next table
 47914 000000CE FFFF                    		DW -1			; [SYSTEM] link seg to next table
 47915 000000D0 0500                    		DW sf_default_number	; [SYSTEM] Number of entries in table
 47916                                  		;times 295 db 0 ; MSDOS 6.0
 47917 000000D2 00<rep 127h>            		times (sf_default_number*sf_entry_size) db 0
 47918                                  
 47919                                  ; the next two variables relate to the position of the logical stdout/stdin
 47920                                  ; cursor. They are only meaningful when stdin/stdout are assigned to the
 47921                                  ; console.
 47922                                  		; DOSDATA:01F9h (MSDOS 6.21)
 47923 000001F9 00                      CARPOS:		db 0			; [SYSTEM] cursor position in stdin
 47924 000001FA 00                      STARTPOS:	db 0			; [SYSTEM] position of cursor at beginning
 47925                                  					;	   of buffered input call
 47926 000001FB 00<rep 80h>             INBUF:		times 128 db 0		; [SYSTEM] general device input buffer
 47927 0000027B 00<rep 83h>             CONBUF:		times 131 db 0		; [SYSTEM] The rest of INBUF and console buffer
 47928                                  		; DOSDATA:02FEh (MSDOS 6.21)
 47929 000002FE 00                      PFLAG:		db 0			; [SYSTEM] printer echoing flag
 47930 000002FF 00                      VERFLG:		db 0			; [SYSTEM] Initialize with verify off
 47931 00000300 03                      CHARCO:		db 00000011b		; [SYSTEM] Allows statchks every 4 chars...
 47932                                  switch_character:
 47933 00000301 2F                      chSwitch:	db '/'			; UNUSED - obsolete datum, can be reused
 47934 00000302 00                      AllocMethod:	db 0			; [SYSTEM] how to alloc first(best)last
 47935 00000303 00                      fShare:		db 0			; [SYSTEM] TRUE => sharing installed
 47936 00000304 01                      DIFFNAM:	db 1			; [SYSTEM] Indicates when MYNAME has changed
 47937 00000305 20<rep 10h>             MYNAME:		times 16 db 20h		; [SYSTEM] My network name
 47938                                  
 47939                                  ; The following table is a list of addresses that the sharer patches to be
 47940                                  ; PUSH AX to enable the critical sections
 47941                                  
 47942                                  		; DOSDATA:0315h (MSDOS 6.21)
 47943                                  
 47944                                  ;PUBLIC	CritPatch
 47945                                  
 47946                                  CritPatch:	; LABEL WORD
 47947                                  
 47948                                  ;IRP sect,<critDisk,critDevice>
 47949                                  
 47950                                  ;IF (NOT REDIRECTOR) AND (NOT SHAREF)
 47951                                  ;
 47952                                  ;SR; Change code patch address to a variable in data segment
 47953                                  ;
 47954                                  ;       dw OFFSET DOSDATA: redir_patch
 47955                                  ;       dw OFFSET DOSDATA: redir_patch
 47956                                  ;
 47957                                  ;;hkn	Short_Addr  E&sect
 47958                                  ;;hkn	Short_Addr  L&sect
 47959                                  ;
 47960                                  ;ELSE
 47961                                  ;	DW	0
 47962                                  ;	DW	0
 47963                                  ;ENDIF
 47964                                  ;ENDM
 47965                                  ;	DW	0
 47966                                  
 47967                                  	; 25/07/2019 - Retro DOS v4.0 (MSDOS 6.21)
 47968                                   
 47969 00000315 [860D]                  	dw 	redir_patch
 47970 00000317 [860D]                  	dw 	redir_patch			
 47971 00000319 [860D]                  	dw	redir_patch
 47972 0000031B [860D]                  	dw 	redir_patch
 47973                                  
 47974 0000031D 0000                    	dw	0
 47975                                  
 47976                                  ; WARNING!!! PRINT and PSPRINT *REQUIRE* ErrorMode to precede INDOS.
 47977                                  ; Also, IBM server 1.0 requires this also.
 47978                                  
 47979                                  	;EVEN			; Force swap area to start on word boundry
 47980 0000031F 90                      align 2
 47981                                  	;PUBLIC	SWAP_START
 47982                                  SWAP_START:	; LABEL BYTE
 47983 00000320 00                      ERRORMODE:	db 0		; Flag for INT 24 processing
 47984 00000321 00                      INDOS:		db 0		; DOS status for interrupt processing
 47985 00000322 FF                      WPERR:		db -1		; Write protect error flag
 47986 00000323 00                      EXTERR_LOCUS:	db 0		; Extended Error Locus
 47987 00000324 0000                    EXTERR:		dw 0		; Extended Error code
 47988                                  
 47989                                  ;WARNING Following two bytes Accessed as word in $GetExtendedError
 47990 00000326 00                      EXTERR_ACTION:	db 0		; Extended Error Action
 47991 00000327 00                      EXTERR_CLASS:	db 0		; Extended Error Class
 47992                                  ; end warning
 47993                                   
 47994 00000328 00000000                EXTERRPT:	dd 0		; Extended Error pointer
 47995                                  
 47996 0000032C 80000000                DMAADD:		dd 80h		; User's disk transfer address (disp/seg)
 47997 00000330 0000                    CurrentPDB:	dw 0		; Current process identifier
 47998 00000332 0000                    ConC_Spsave:	dw 0		; saved SP before ^C
 47999 00000334 0000                    exit_code:	dw 0		; exit code of last proc.
 48000 00000336 00                      CURDRV:		db 0		; Default drive (init A)
 48001 00000337 00                      CNTCFLAG:	db 0		; ^C check in dispatch disabled
 48002                                  ;				; F.C. 2/17/86
 48003 00000338 00                      CPSWFLAG:	db 0		; Code Page Switching Flag  DOS 4.00
 48004 00000339 00                      CPSWSAVE:	db 0		; copy of above in case of ABORT
 48005                                  ;align 2
 48006                                  SWAP_ALWAYS:	; 05/08/2018
 48007 0000033A 0000                    USER_IN_AX:	dw 0		; User INPUT AX value (used for
 48008                                  				;   extended error type stuff.
 48009                                  				;   NOTE: does not have Correct value on
 48010                                  				;   1-12, OEM, Get/Set CurrentPDB,
 48011                                  				;   GetExtendedError system calls)
 48012 0000033C 0000                    PROC_ID:	dw 0		; PID for sharing (0 = local)
 48013 0000033E 0000                    USER_ID:	dw 0		; Machine for sharing (0 = local)
 48014 00000340 0000                    FirstArena:	dw 0		; first free block found
 48015 00000342 0000                    BestArena:	dw 0		; best free block found
 48016 00000344 0000                    LastArena:	dw 0		; last free block found
 48017 00000346 0000                    ENDMEM:		dw 0		; End of memory used in DOSINIT
 48018 00000348 0000                    LASTENT:	dw 0		; Last entry for directory search
 48019 0000034A 00                      FAILERR:	db 0		; NZ if user did FAIL on I 24
 48020 0000034B 00                      ALLOWED:	db 0		; Allowed I 24 answers (see allowed_)
 48021 0000034C 00                      NoSetDir:	db 0		; true -> do not set directory
 48022 0000034D 00                      DidCTRLC:	db 0		; true -> we did a ^C exit
 48023 0000034E 00                      SpaceFlag:	db 0		; true -> embedded spaces are allowed in FC
 48024                                  
 48025                                  ; Warning!  The following items are accessed as a WORD in TIME.ASM
 48026                                  	;EVEN
 48027 0000034F 90                      align 2
 48028                                  		; DOSDATA:0350h (MSDOS 6.21)
 48029 00000350 00                      DAY:		db 0		; Day of month
 48030 00000351 00                      MONTH:		db 0		; Month of year
 48031 00000352 0000                    YEAR:		dw 0		; Year (with century)
 48032 00000354 FFFF                    DAYCNT:		dw -1		; Day count from beginning of year
 48033 00000356 00                      WEEKDAY:	db 0		; Day of week
 48034                                  ; end warning
 48035                                  
 48036 00000357 00                      CONSWAP:	db 0		; TRUE => console was swapped during device read
 48037 00000358 01                      IDLEINT:	db 1		; TRUE => idle int is allowed
 48038 00000359 00                      fAborting:	db 0		; TRUE => abort in progress
 48039                                  
 48040                                  ; Combination of all device call parameters
 48041                                  	;PUBLIC	DEVCALL 	;
 48042                                  ;DEVCALL SRHEAD	<>		; basic header for disk packet
 48043                                  DEVCALL: ; 08/08/2018
 48044 0000035A 00                      DEVCALL_REQLEN:  db 0 		;Length in bytes of request block
 48045 0000035B 00                      DEVCALL_REQUNIT: db 0		;Device unit number
 48046 0000035C 00                      DEVCALL_REQFUNC: db 0		;Type of request
 48047 0000035D 0000                    DEVCALL_REQSTAT: dw 0		;Status Word
 48048 0000035F 00<rep 8h>                       times 8 db 0		;Reserved for queue links
 48049                                  
 48050                                  	;PUBLIC	CALLUNIT
 48051                                  CALLUNIT: ; LABEL   BYTE	; unit number for disk
 48052                                  CALLFLSH: ; LABEL   WORD	;
 48053 00000367 00                      CALLMED:	db 0		; media byte
 48054                                  CALLBR:	  ; LABEL   DWORD	;
 48055                                  	;PUBLIC	CALLXAD 	;
 48056                                  CALLXAD:  ; LABEL   DWORD	;
 48057 00000368 00                      CALLRBYT:	db 0		;
 48058                                  	;PUBLIC	CALLVIDM	;
 48059                                  CALLVIDM: ; LABEL   DWORD	;
 48060 00000369 00<rep 3h>              	times 3 db 0	;
 48061                                  	;PUBLIC CallBPB		;
 48062                                  CALLBPB:  ; LABEL   DWORD	;
 48063                                  CALLSCNT:			;
 48064 0000036C 0000                    		dw 0		;
 48065                                  	;PUBLIC	CALLSSEC	;
 48066                                  CALLSSEC: ; LABEL   WORD	;
 48067 0000036E 0000                    		dw 0		;
 48068 00000370 00000000                CALLVIDRW:	dd 0		;
 48069                                  ;MSDOS 6.0
 48070 00000374 00000000                CALLNEWSC:	dd 0		; starting sector for >32mb
 48071 00000378 00000000                CALLDEVAD:	dd 0		; stash for device entry point
 48072                                  
 48073                                  ; Same as above for I/O calls	;
 48074                                  				;
 48075                                  	;PUBLIC	IOCall		;
 48076                                  ;IOCALL	SRHEAD	<>		;
 48077                                  IOCALL:	; 07/08/2018
 48078 0000037C 00                      IOCALL_REQLEN:	db 0		;Length in bytes of request block
 48079 0000037D 00                      IOCALL_REQUNIT:	db 0		;Device unit number
 48080 0000037E 00                      IOCALL_REQFUNC: db 0		;Type of request
 48081 0000037F 0000                    IOCALL_REQSTAT: dw 0		;Status Word
 48082 00000381 00<rep 8h>              	times 8	db 0		;Reserved for queue links
 48083                                  IOFLSH:	  ; LABEL   WORD	;
 48084                                          ;PUBLIC  IORCHR		;
 48085                                  IORCHR:	  ; LABEL   BYTE	;
 48086 00000389 00                      IOMED:		db 0		;
 48087 0000038A 00000000                IOXAD:		dd 0		;
 48088 0000038E 0000                    IOSCNT:		dw 0		;
 48089 00000390 0000                    IOSSEC:		dw 0		;
 48090                                  
 48091                                  ; Call struct for DSKSTATCHK	;
 48092 00000392 0E                      DSKSTCALL:	db DRDNDHL 	; = 14
 48093 00000393 00                      		db 0
 48094 00000394 05                      DSKSTCOM:	db DEVRDND	; = 5
 48095 00000395 0000                    DSKSTST:	dw 0		;
 48096 00000397 00<rep 8h>              	times 8	db 0		;
 48097 0000039F 00                      DSKCHRET:	db 0		;
 48098                                  
 48099                                  ;hkn; short_addr has been changed to provide offset in DOSCODE.
 48100                                  ;hkn; deviobuf is in DATA seg (DOSDATA)
 48101                                  ;hkn   short_addr  DEVIOBUF	;
 48102                                  	
 48103 000003A0 [BC03]                  DEVIOBUF_PTR	dw DEVIOBUF
 48104 000003A2 0000                    DOSSEG_INIT	dw 0		; DOS segment set at Init
 48105 000003A4 0100                    DSKSTCNT:	dw 1		;
 48106 000003A6 0000                    		dw 0		;
 48107                                  
 48108 000003A8 00                      CreatePDB:	db 0		; flag for creating a process
 48109                                  
 48110                                  ;MSDOS 6.0
 48111                                  Lock_Buffer:	; LABEL  DWORD	;MS. DOS Lock Buffer for Ext Lock
 48112 000003A9 00000000                		dd 0		;MS. position
 48113 000003AD 00000000                		dd 0		;MS. length
 48114                                  
 48115                                  ;hkn; the foll. was moved from dosmes.asm.
 48116                                  
 48117                                  ; 29/01/2024 Retro DOS v5.0 (PCDOS v7.1 IBMDOS.COM)
 48118                                  ; DOSDATA:03B1h
 48119 000003B1 90                      IOCTL_drvnum:	db 90h ; nop
 48120                                  
 48121                                  	;EVEN
 48122                                  align 2				; needed to maintain offsets
 48123                                  
 48124                                  		; DOSDATA:03B2h (MSDOS 6.21)
 48125                                  USERNUM:
 48126 000003B2 0000                     		dw 0		; 24 bit user number
 48127 000003B4 00                      		db 0
 48128                                  ;IF IBM
 48129                                  ;IF IBMCOPYRIGHT
 48130                                  ;OEMNUM:	DB 0		; 8 bit OEM number
 48131                                  ;ELSE
 48132                                  ;OEMNUM:	DB 0FFh		; 8 bit OEM number
 48133                                  ;ENDIF
 48134                                  ;ELSE
 48135 000003B5 FF                      OEMNUM:		DB 0FFh
 48136                                  ;ENDIF
 48137                                  
 48138                                  ;============================================================================
 48139                                  ; MS_DATA.ASM (MSDOS 6.0, 1991)
 48140                                  ;============================================================================
 48141                                  ; 25/04/2019 - Retro DOS 4.0
 48142                                  
 48143                                  ; Retro DOS v4.0 NOTE: (by Erdogan Tan, 25/04/2019)
 48144                                  ; ----------------------------------------------------------
 48145                                  ; This data section which was named as uninitialized data
 48146                                  ; (as overlayed by initialization code) but follows 
 48147                                  ; initialized data section from DOSDATA:03B6h address
 48148                                  ; (in otherwords, the method is different than MSDOS 3.3,
 48149                                  ; and there is not overlaying..)
 48150                                  ; **********************************************************
 48151                                  ; Reference: MSDOS 6.21 kernel DOSDATA section (4970 bytes)
 48152                                  ; follows DOSCODE section in the kernel file (MSDOS.SYS) 
 48153                                  ; (it is located at offset 0BF70h, file offset 0BF70h-3DE0h) 
 48154                                  ; but starts from offset 0 (ORG 0) and ends at offset 1370h.
 48155                                  ; TIMEBUF is at offset 03B6h.
 48156                                  ; **********************************************************	
 48157                                  
 48158                                  ;Break <Uninitialized data overlayed by initialization code>
 48159                                  ;----------------------------------------------------------------------------
 48160                                  ;DOSDATA    SEGMENT WORD PUBLIC 'DATA'
 48161                                  ; Init code overlaps with data area below
 48162                                  
 48163                                  ; 	ORG     0
 48164                                  
 48165                                  MSDAT001S:	; label byte
 48166                                  
 48167                                  ; DOSDATA:03B6h	; MSDOS 6.21 (MSDOS.SYS, file offset 0BF70h-3DE0h+3B6h)
 48168                                  TIMEBUF: ;	times 6 db 0
 48169 000003B6 0000<rep 3h>            	times 3 dw	0		; Time read from clock device
 48170 000003BC 0000                    DEVIOBUF:	dw	0		; Buffer for I/O under file assignment
 48171                                  
 48172                                  ; The following areas are used as temp buffer in EXEC system call
 48173                                  
 48174                                  ; DOSDATA:03BEh
 48175                                  OPENBUF: ;times 64  dw	0
 48176 000003BE 00<rep 80h>             	times	128 db	0		; buffer for name operations
 48177                                  RENBUF:	
 48178 0000043E 00<rep 80h>             	times	128 db	0		; buffer for rename destination
 48179                                  
 48180                                  ; Buffer for search calls
 48181                                  SEARCHBUF:	
 48182 000004BE 00<rep 35h>             	times	53  db	0		; internal search buffer
 48183                                  DUMMYCDS:  ;times 88 db 0
 48184 000004F3 00<rep 58h>             	times	curdirLen db 0
 48185                                  
 48186                                  ; End of contiguous buffer
 48187                                   
 48188                                  ; Temporary directory entry for use by many routines. Device directory
 48189                                  ; entries (bogus) are built here.
 48190                                  
 48191                                  ; DOSDATA:054Bh
 48192                                  
 48193                                  DEVFCB:	; LABEL   BYTE			; Uses NAME1, NAME2, combined
 48194                                  
 48195                                  ; WARNING..  do not alter position of NAME1 relative to DEVFCB
 48196                                  ; without first examining BUILD_DEVICE_ENT. Look carefully at DOS_RENAME
 48197                                  ; as well as it is the only guy who uses NAME2 and DESTSTART.
 48198                                  
 48199                                  NAME1:	
 48200 0000054B 00<rep Ch>                      times 	12 db	0		; File name buffer
 48201                                  NAME2:
 48202 00000557 00<rep Dh>              	times	13 db	0 		;
 48203                                  DESTSTART:
 48204 00000564 0000                    	dw	0			;
 48205                                          ;DB      ((SIZE DIR_ENTRY) - ($ - DEVFCB)) DUP (?)
 48206                                  	;times	5  db	0
 48207 00000566 00<rep 5h>              	times	((dir_entry.size)-($-DEVFCB)) db 0
 48208                                  
 48209                                  ; End Temporary directory entry.
 48210                                  
 48211 0000056B 00                      ATTRIB:	db	0		; storage for file attributes
 48212                                  EXTFCB:	
 48213 0000056C 00                      	db	0		; TRUE => extended FCB in use
 48214                                  SATTRIB:
 48215 0000056D 00                      	db	0		; Storage for search attributes
 48216                                  OPEN_ACCESS:
 48217 0000056E 00                      	db	0		; access of open system call
 48218                                  FOUNDDEL:
 48219 0000056F 00                      	db	0		; true => file was deleted
 48220                                  FOUND_DEV:
 48221 00000570 00                      	db	0		; true => search found a device
 48222                                  FSPLICE:
 48223 00000571 00                      	db	0		; true => do a splice in transpath
 48224                                  FSHARING:
 48225 00000572 00                      	db	0		; TRUE => no redirection
 48226                                  SECCLUSPOS:
 48227 00000573 00                      	db	0		; Position of first sector within cluster
 48228 00000574 00                      TRANS:	db	0		;
 48229 00000575 00                      READOP:	db	0		;
 48230                                  THISDRV:
 48231 00000576 00                      	db	0		;
 48232                                  CLUSFAC:
 48233 00000577 00                      	db	0		;
 48234                                  CLUSSPLIT:
 48235 00000578 00                      	db	0		;
 48236                                  INSMODE:
 48237 00000579 00                      	db	0		; true => insert mode in buffered read
 48238 0000057A 00                      CMETA:	db	0		; count of meta'ed components found
 48239 0000057B 00                      VOLID:	db	0		;
 48240                                  EXIT_TYPE:
 48241 0000057C 00                      	db	0		; type of exit...
 48242                                   
 48243                                  	;EVEN
 48244                                  
 48245 0000057D 90                      align 2
 48246                                  
 48247                                  ; DOSDATA:057Eh
 48248                                  
 48249                                  ; WARNING - the following two items are accessed as a word
 48250                                  
 48251                                  CREATING:
 48252 0000057E 00                      	db	0		; true => creating a file
 48253 0000057F 00                      DELALL:	db	0		; = 0 iff BUGBUG
 48254                                  				; = DIRFREE iff BUGBUG
 48255                                  EXITHOLD:
 48256 00000580 00000000                	dd	0		; Temp location for proc terminate
 48257                                  USER_SP:
 48258 00000584 0000                    	dw	0		; User SP for system call
 48259                                  USER_SS:
 48260 00000586 0000                    	dw	0		; User SS for system call
 48261                                  CONTSTK:
 48262 00000588 0000                    	dw	0		;
 48263                                  THISDPB:
 48264 0000058A 00000000                	dd	0		;
 48265                                  CLUSSAVE:
 48266 0000058E 0000                    	dw	0		;
 48267                                  CLUSSEC:
 48268 00000590 00000000                	dd	0		;>32mb			AC0000
 48269                                  PREREAD:
 48270 00000594 0000                    	dw	0		; 0 means preread; 1 means optional
 48271 00000596 0000                    FATBYT:	dw	0		; Used by ALLOCATE
 48272                                  FATBYTE:
 48273 00000598 0000                    	dw	0		; Used by $SLEAZEFUNC
 48274                                  ; DOSDATA:059Ah
 48275 0000059A 00000000                DEVPT:	dd	0		;
 48276                                  THISSFT:
 48277 0000059E 00000000                	dd	0		; Address of user SFT
 48278                                  THISCDS:
 48279 000005A2 00000000                	dd	0		; Address of current CDS
 48280                                  THISFCB:
 48281 000005A6 00000000                	dd	0		; Address of user FCB
 48282 000005AA FFFF                    SFN:	dw	-1		; SystemFileNumber found for accessfile
 48283 000005AC 0000                    JFN:	dw	0		; JobFileNumber found for accessfile
 48284 000005AE 00000000                PJFN:	dd	0		; PointerJobFileNumber found for accessfile
 48285                                  WFP_START:
 48286 000005B2 0000                    	dw	0		;
 48287                                  REN_WFP:
 48288 000005B4 0000                    	dw	0		;
 48289                                  CURR_DIR_END:
 48290 000005B6 0000                    	dw	0		;
 48291                                  NEXTADD:
 48292 000005B8 0000                    	dw	0		;
 48293                                  LASTPOS:
 48294 000005BA 0000                    	dw	0		;
 48295                                  CLUSNUM:
 48296 000005BC 0000                    	dw	0		;
 48297 000005BE 00000000                DIRSEC:	dd	0		;>32mb			AC0000
 48298                                  DIRSTART:
 48299 000005C2 0000                    	dw	0		;
 48300 000005C4 00000000                SECPOS:	dd	0		;>32mb Position of first sector accessed
 48301 000005C8 00000000                VALSEC:	dd	0		;>32mb Number of valid (previously written)
 48302                                                                  ; sectors
 48303                                  BYTSECPOS:
 48304 000005CC 0000                    	dw	0		; Position of first byte within sector
 48305                                  BYTPOS: ;times	4 db 0		; Byte position in file of access
 48306 000005CE 0000<rep 2h>                    times	2 dw 0
 48307                                  BYTCNT1:
 48308 000005D2 0000                    	dw	0		; No. of bytes in first sector
 48309                                  BYTCNT2:
 48310 000005D4 0000                    	dw	0		; No. of bytes in last sector
 48311 000005D6 0000                    SECCNT:	dw	0		; No. of whole sectors
 48312                                  ; DOSDATA:05D8h
 48313                                  ENTFREE:
 48314 000005D8 0000                    	dw	0		;
 48315                                  ENTLAST:
 48316 000005DA 0000                    	dw	0		;
 48317                                  NXTCLUSNUM:
 48318 000005DC 0000                    	dw	0		;
 48319                                  GROWCNT:
 48320 000005DE 00000000                	dd	0		;
 48321 000005E2 00000000                CURBUF:	dd	0		;
 48322 000005E6 00000000                CONSFT:	dd	0		; SFT of console swapped guy.
 48323 000005EA 0000                    SAVEBX:	dw	0		;
 48324 000005EC 0000                    SAVEDS:	dw	0		;
 48325                                  RESTORE_TMP:
 48326 000005EE 0000                    	dw	0		; return address for restore world
 48327 000005F0 0000                    NSS:	dw	0
 48328 000005F2 0000                    NSP:	dw	0
 48329                                  ; DOSDATA:05F4h
 48330                                  EXTOPEN_FLAG:
 48331 000005F4 0000                    	dw	0		;FT. extended open input flag	;AN000;
 48332                                  EXTOPEN_ON:
 48333 000005F6 00                      	db	0		;FT. extended open conditional flag ;AN000;
 48334                                  EXTOPEN_IO_MODE:
 48335 000005F7 0000                    	dw	0		;FT. extended open io mode	;AN000;
 48336                                  SAVE_DI:
 48337 000005F9 0000                    	dw	0		;FT. extended open saved DI	;AN000;
 48338                                  SAVE_ES:
 48339 000005FB 0000                    	dw	0		;FT. extended open saved ES	;AN000;
 48340                                  SAVE_DX:
 48341 000005FD 0000                    	dw	0		;FT. extended open saved DX	;AN000;
 48342                                  SAVE_CX:
 48343 000005FF 0000                    	dw	0		;FT. extended open saved CX	;AN000;
 48344                                  SAVE_BX:
 48345 00000601 0000                    	dw	0		;FT. extended open saved BX	;AN000;
 48346                                  SAVE_SI:
 48347 00000603 0000                    	dw	0		;FT. extended open saved SI	;AN000;
 48348                                  SAVE_DS:
 48349 00000605 0000                    	dw	0		;FT. extended open saved DS	;AN000;
 48350                                  
 48351                                  ; DOSDATA:0607h
 48352                                  
 48353                                  ; HIGH_SECTOR is a hack to allow passing 32-bit sector numbers where
 48354                                  ; we used to just pass 16 bits in a register. Now High_SECTOR holds
 48355                                  ; the high 16, the low 16 are still in the register.
 48356                                  
 48357                                  HIGH_SECTOR:	
 48358 00000607 0000                    	dw	0		;>32mb higher sector #		;AN000;
 48359                                  	; 25/09/2023
 48360                                  OffsetMagicPatch:
 48361                                  	;dw	MagicPatch	;scottq 8/6/92
 48362                                  	; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 48363 00000609 0000                    	dw	0
 48364                                  				;see dos\mpatch.asm
 48365                                  DISK_FULL:
 48366 0000060B 00                      	db	0		;>32mb indicating disk full when 1 ;AN000;
 48367                                  TEMP_VAR:
 48368 0000060C 0000                    	dw	0		; temporary variable for everyone ;AN000;
 48369                                  TEMP_VAR2:
 48370 0000060E 0000                    	dw	0		; temporary variable 2 for everyone ;AN000;
 48371 00000610 00                      DrvErr:	db	0		; used to save drive error	;AN000;
 48372                                  DOS34_FLAG:
 48373 00000611 0000                    	dw	0		; common flag for DOS 3.4	;AN000;
 48374                                  NO_FILTER_PATH:
 48375 00000613 00000000                	dd	0		; pointer to original path	;AN000;
 48376                                  NO_FILTER_DPATH:
 48377 00000617 00000000                	dd	0		; pointer to original path of destination ;AN000;
 48378                                  ; M008
 48379                                  AbsRdWr_SS:
 48380 0000061B 0000                    	dw	0		; INT 25/26 user stack segment
 48381                                  AbsRdWr_SP:
 48382 0000061D 0000                    	dw	0		; INT 25/26 user stack offset
 48383                                  
 48384                                  	; I_am   UU_Callback_flag,BYTE,<0>  ; Unused
 48385                                  ; M008
 48386                                  	; 01/01/2024 
 48387                                  	; PCDOS 7.1 IBMDOS.COM - DOSDATA:061Fh
 48388                                  	;db 	0
 48389                                   
 48390                                  ; make those pushes fast!!!
 48391                                  ;EVEN
 48392                                  
 48393 0000061F 90                      align 2
 48394                                  
 48395                                  StackSize   equ 180h  ; 384	; gross but effective
 48396                                  
 48397                                  ;StackSize  equ 300h  ;	768	; This is a "trial" change IBM hasn't
 48398                                  ;				; made up their minds about
 48399                                   
 48400                                  ; WARNING!!!! DskStack may grow into AUXSTACK due to interrupt service.
 48401                                  ; This is NO problem as long as AUXSTACK comes immediately before DSKSTACK
 48402                                  
 48403                                  RENAMEDMA:	; LABEL   BYTE	; See DOS_RENAME
 48404                                   
 48405 00000620 00<rep 180h>                    times	StackSize db	0	; db 384 dup(0) ;  PCDOS 7.1
 48406                                  AUXSTACK:			; LABEL   BYTE
 48407                                   
 48408 000007A0 00<rep 180h>                    times	StackSize db 	0	; db 384 dup(0) ;  PCDOS 7.1
 48409                                  DSKSTACK:			; LABEL   BYTE
 48410                                  	; 01/01/2024 - Retro DOS v5.0 (PCDOS 7.1 IBMDOS.COM)
 48411                                  	; (PCDOS 7.1 IBMDOS.COM - DOSDATA:0920h)
 48412                                  	;db '@#IBM:12.01.2003.build_1.32#@ IBMDOS.COM(USA)',0 
 48413                                  	;times	StackSize-($-DSKSTACK) db 0  ; db 338 dup(0) ; PCDOS 7.1
 48414 00000920 00<rep 180h>            	times	StackSize db 	0	;
 48415                                  IOSTACK:			; LABEL   BYTE
 48416                                  
 48417                                  ; DOSDATA:0AA0h 
 48418                                   
 48419                                  ; patch space for Boca folks.
 48420                                  ; Say What????!!! This does NOT go into the swappable area!
 48421                                  ; NOTE: We include the decl of ibmpatch in ms-dos even though it is not needed.
 48422                                  ;       This allows the REDIRector to work on either IBM or MS-DOS.
 48423                                   
 48424                                  IBMPATCH: ; label byte
 48425                                  PRINTER_FLAG:
 48426 00000AA0 00                      	db	0		; [SYSTEM] status of PRINT utility
 48427                                  VOLCHNG_FLAG:
 48428 00000AA1 00                      	db	0		; [SYSTEM] true if volume label created
 48429                                  VIRTUAL_OPEN:
 48430 00000AA2 00                      	db	0		; [SYSTEM] non-zero if we opened a virtual file
 48431                                   
 48432                                  ; Following 4 variables moved to MSDATA.asm from MSTABLE.asm (P4986)
 48433                                  
 48434                                  FSeek_drive:
 48435 00000AA3 00                      	db	0		;AN000; fastseek drive #
 48436                                  FSeek_firclus:
 48437 00000AA4 0000                    	dw	0		;AN000; fastseek first cluster #
 48438                                  FSeek_logclus:
 48439 00000AA6 0000                    	dw	0		;AN000; fastseek logical cluster #
 48440                                  FSeek_logsave:
 48441 00000AA8 0000                    	dw	0		;AN000; fastseek returned log clus #
 48442                                  
 48443                                  ; DOSDATA:0AAAh
 48444                                  
 48445                                  TEMP_DOSLOC:
 48446 00000AAA FFFF                    	dw	-1		;stores the temporary location of dos
 48447                                  				;at SYSINIT time.
 48448                                  SWAP_END:  ; LABEL   BYTE
 48449                                   
 48450                                  ; THE FOLLOWING BYTE MUST BE HERE, IMMEDIATELY FOLLOWING SWAP_END. IT CANNOT
 48451                                  ; BE USED. If the size of the swap data area is ODD, it will be rounded up
 48452                                  ; to include this byte.
 48453                                   
 48454                                  	; 05/01/2024
 48455                                  	;db	0
 48456                                  
 48457                                  ; DOSDATA:0AADh
 48458                                   
 48459                                  ;hkn;	DB	(512+80+32-(SWAP_END-ibmpatch)) DUP (?)
 48460                                  
 48461                                  ; ---------------------------------------------------------------------------
 48462                                  ; 05/01/2024 - Retro DOS v5.0 
 48463                                  ; PCDOS 7.1 IBMDOS.COM - DOSDATA:0AA5h
 48464                                  
 48465                                  	; 24/01/2024
 48466                                  LNE_COUNT:
 48467 00000AAC 0000                    	dw	0	; long name entry count (for file)
 48468                                  
 48469 00000AAE 00<rep Eh>              	times 14 db 0
 48470                                  
 48471                                  ENTLAST_PREV:
 48472 00000ABC 0000                    	dw	0	; previous ENTLAST (for long name search !?)
 48473                                  
 48474 00000ABE 00<rep 24h>             	times 36 db 0
 48475                                  
 48476                                  absdrw_extd:
 48477 00000AE2 00                      	db	0
 48478                                  DIRSTART_HW:
 48479 00000AE3 0000                    	dw	0
 48480                                  CLUSNUM_HW:
 48481 00000AE5 0000                    	dw	0
 48482                                  NXTCLUSNUM_HW:
 48483 00000AE7 0000                    	dw	0
 48484                                  LASTPOS_HW:
 48485 00000AE9 0000                    	dw	0
 48486                                  FATBYT_HW:
 48487 00000AEB 0000                    	dw	0
 48488                                  DESTSTART_HW:
 48489 00000AED 0000                    	dw	0
 48490                                  CLUSTNUM_HW:
 48491 00000AEF 0000                    	dw	0
 48492                                  CLUSDATA_HW:	; cluster data (0 = release, -1 = allocate) ; 30/01/2024
 48493 00000AF1 0000                    	dw	0
 48494                                  CCONTENT_HW:
 48495 00000AF3 0000                    	dw	0
 48496                                  ROOTCLUST_HW:
 48497 00000AF5 0000                    	dw	0
 48498                                  word_AF0:
 48499 00000AF7 0000                    	dw	0
 48500                                  CLUSTERS_HW:
 48501 00000AF9 0000                    	dw	0
 48502 00000AFB 0000                    	dw	0
 48503 00000AFD 0000                    	dw	0
 48504                                  CLSKIP_HW:
 48505 00000AFF 0000                    	dw	0
 48506                                  
 48507                                  ;DOSDATA    ENDS
 48508                                  
 48509                                  ;============================================================================
 48510                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
 48511                                  ;============================================================================
 48512                                  ; 27/04/2019 - Retro DOS 4.0
 48513                                  ; 16/07/2018 - Retro DOS 3.0
 48514                                  
 48515                                  ;DOSDATA Segment
 48516                                  
 48517                                  ; DOSDATA:0AADh (MSDOS 6.21, MSDOS.SYS)
 48518                                  
 48519                                  ; DOSDATA:0AFAh (PCDOS 7.1, IBMDOS.COM) ; 05/01/2024
 48520                                  
 48521                                  ;
 48522                                  ; upper case table
 48523                                  ; ---------------------------------------------------------------------------
 48524                                  UCASE_TAB:	; label   byte
 48525 00000B01 8000                    	dw	128
 48526 00000B03 809A45418E418F80        	db	128,154,069,065,142,065,143,128 
 48527 00000B0B 4545454949498E8F        	db	069,069,069,073,073,073,142,143
 48528 00000B13 9092924F994F5555        	db	144,146,146,079,153,079,085,085
 48529 00000B1B 59999A9B9C9D9E9F        	db	089,153,154,155,156,157,158,159
 48530 00000B23 41494F55A5A5A6A7        	db	065,073,079,085,165,165,166,167
 48531 00000B2B A8A9AAABACADAEAF        	db	168,169,170,171,172,173,174,175
 48532 00000B33 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 48533 00000B3B B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 48534 00000B43 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 48535 00000B4B C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 48536 00000B53 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 48537 00000B5B D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 48538 00000B63 E0E1E2E3E4E5E6E7        	db	224,225,226,227,228,229,230,231
 48539 00000B6B E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 48540 00000B73 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 48541 00000B7B F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 48542                                  ;
 48543                                  ; file upper case table
 48544                                  ; ---------------------------------------------------------------------------
 48545                                  FILE_UCASE_TAB:	; label  byte
 48546 00000B83 8000                    	dw	128
 48547 00000B85 809A45418E418F80        	db	128,154,069,065,142,065,143,128
 48548 00000B8D 4545454949498E8F        	db	069,069,069,073,073,073,142,143
 48549 00000B95 9092924F994F5555        	db	144,146,146,079,153,079,085,085
 48550 00000B9D 59999A9B9C9D9E9F        	db	089,153,154,155,156,157,158,159
 48551 00000BA5 41494F55A5A5A6A7        	db	065,073,079,085,165,165,166,167
 48552 00000BAD A8A9AAABACADAEAF        	db	168,169,170,171,172,173,174,175
 48553 00000BB5 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 48554 00000BBD B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 48555 00000BC5 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 48556 00000BCD C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 48557 00000BD5 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 48558 00000BDD D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 48559 00000BE5 E0E1E2E3E4E5E6E7        	db	224,225,226,227,228,229,230,231
 48560 00000BED E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 48561 00000BF5 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 48562 00000BFD F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 48563                                  ;
 48564                                  ; file char list
 48565                                  ; ---------------------------------------------------------------------------
 48566                                  FILE_CHAR_TAB:	; label  byte
 48567 00000C05 1600                    	dw	22				; length
 48568 00000C07 0100FF                  	db	1,0,255 			; include all
 48569 00000C0A 000020                  	db	0,0,20h 			; exclude 0 - 20h
 48570 00000C0D 020E2E222F5C5B5D3A-     	db	2,14,'."/\[]:|<>+=;,'           ; exclude 14 special
 48570 00000C16 7C3C3E2B3D3B2C     
 48571                                  	;db	24 dup (?)			; reserved
 48572 00000C1D 00<rep 18h>             	times	24 db 0
 48573                                  
 48574                                  ;
 48575                                  ; collate table
 48576                                  ; ---------------------------------------------------------------------------
 48577                                  COLLATE_TAB:	; label   byte
 48578 00000C35 0001                    	dw	256
 48579 00000C37 0001020304050607        	db	0,1,2,3,4,5,6,7
 48580 00000C3F 08090A0B0C0D0E0F        	db	8,9,10,11,12,13,14,15
 48581 00000C47 1011121314151617        	db	16,17,18,19,20,21,22,23
 48582 00000C4F 18191A1B1C1D1E1F        	db	24,25,26,27,28,29,30,31
 48583 00000C57 2021222324252627        	db	" ","!",'"',"#","$","%","&","'"
 48584 00000C5F 28292A2B2C2D2E2F        	db	"(",")","*","+",",","-",".","/"
 48585 00000C67 3031323334353637        	db	"0","1","2","3","4","5","6","7"
 48586 00000C6F 38393A3B3C3D3E3F        	db	"8","9",":",";","<","=",">","?"
 48587 00000C77 4041424344454647        	db	"@","A","B","C","D","E","F","G"
 48588 00000C7F 48494A4B4C4D4E4F        	db	"H","I","J","K","L","M","N","O"
 48589 00000C87 5051525354555657        	db	"P","Q","R","S","T","U","V","W"
 48590 00000C8F 58595A5B5C5D5E5F        	db	"X","Y","Z","[","\","]","^","_"
 48591 00000C97 6041424344454647        	db	"`","A","B","C","D","E","F","G"
 48592 00000C9F 48494A4B4C4D4E4F        	db	"H","I","J","K","L","M","N","O"
 48593 00000CA7 5051525354555657        	db	"P","Q","R","S","T","U","V","W"
 48594 00000CAF 58595A7B7C7D7E7F        	db	"X","Y","Z","{","|","}","~",127
 48595 00000CB7 4355454141414143        	db	"C","U","E","A","A","A","A","C"
 48596 00000CBF 4545454949494141        	db	"E","E","E","I","I","I","A","A"
 48597 00000CC7 4541414F4F4F5555        	db	"E","A","A","O","O","O","U","U"
 48598 00000CCF 594F552424242424        	db	"Y","O","U","$","$","$","$","$"
 48599 00000CD7 41494F554E4EA6A7        	db	"A","I","O","U","N","N",166,167
 48600 00000CDF 3FA9AAABAC212222        	db	"?",169,170,171,172,"!",'"','"'
 48601 00000CE7 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 48602 00000CEF B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 48603 00000CF7 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 48604 00000CFF C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 48605 00000D07 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 48606 00000D0F D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 48607 00000D17 E053                    	db	224,"S"
 48608 00000D19 E2E3E4E5E6E7            	db	226,227,228,229,230,231
 48609 00000D1F E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 48610 00000D27 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 48611 00000D2F F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 48612                                  
 48613                                  ; ------------------------------------------------<MSKK01>----------------------
 48614                                  
 48615                                  ; DOSDATA:0CE3h
 48616                                  
 48617                                  ; 29/04/2019
 48618                                  
 48619                                  ; dbcs is not supported in DOS 3.3
 48620                                  ;		   DBCS_TAB	    CC_DBCS <>
 48621                                  ;
 48622                                  ; DBCS for DOS 4.00			   2/12/KK
 48623                                  
 48624                                  DBCS_TAB:	; label byte		;AN000;  2/12/KK
 48625                                  ; ------------------------------------------------<MSKK01>----------------------
 48626                                  ;ifdef	DBCS
 48627                                  ; ifdef	  JAPAN
 48628                                  ;		dw	6		; <MSKK01>
 48629                                  ;		db	081h,09fh	; <MSKK01>
 48630                                  ;		db	0e0h,0fch	; <MSKK01>
 48631                                  ;		db	0,0		; <MSKK01>
 48632                                  ;
 48633                                  ;		db	0,0,0,0,0,0,0,0,0,0	; <MSKK01>
 48634                                  ; endif
 48635                                  ; ifdef	  TAIWAN
 48636                                  ;		dw	4		; <TAIWAN>
 48637                                  ;		db	081h,0FEh	; <TAIWAN>
 48638                                  ;		db	0,0		; <TAIWAN>
 48639                                  ;
 48640                                  ;		db	0,0,0,0,0,0,0,0,0,0,0,0
 48641                                  ; endif
 48642                                  ; ifdef   KOREA                         ; Keyl
 48643                                  ;               dw      4               ; <KOREA>
 48644                                  ;               db      0A1h,0FEh       ; <KOREA>
 48645                                  ;               db      0,0             ; <KOREA>
 48646                                  ;
 48647                                  ;		db	0,0,0,0,0,0,0,0,0,0,0,0
 48648                                  ;  endif
 48649                                  ;else
 48650 00000D37 0000                    		dw	0		;AN000;  2/12/KK   max number
 48651                                  		;db	16 dup(0)	;AN000;  2/12/KK
 48652 00000D39 00<rep 10h>             		times	16 db 0
 48653                                  
 48654                                  ;		dw	6		;  2/12/KK
 48655                                  ;		db	081h,09Fh	;  2/12/KK
 48656                                  ;		db	0E0h,0FCh	;  2/12/KK
 48657                                  ;		db	0,0		;  2/12/KK
 48658                                  ;
 48659                                  ;endif
 48660                                  ; ------------------------------------------------<MSKK01>----------------------
 48661                                  
 48662                                  ; DOSDATA:0CF5h
 48663                                  
 48664                                  ; ---------------------------------------------------------------------------
 48665                                  ;
 48666                                  ;CASE MAPPER ROUTINE FOR 80H-FFH character range, DOS 3.3
 48667                                  ;     ENTRY: AL = Character to map
 48668                                  ;     EXIT:  AL = The converted character
 48669                                  ; Alters no registers except AL and flags.
 48670                                  ; The routine should do nothing to chars below 80H.
 48671                                  ; ---------------------------------------------------------------------------
 48672                                  ; Example:
 48673                                  
 48674                                  MAP_CASE:
 48675                                  ;Procedure MAP_CASE,FAR
 48676                                  
 48677 00000D49 3C80                    	CMP	AL,80h
 48678 00000D4B 7301                    	JAE	short Map1	;Map no chars below 80H ever
 48679 00000D4D CB                      	RETF
 48680                                  Map1:
 48681 00000D4E 2C80                    	SUB	AL,80h		;Turn into index value
 48682 00000D50 1E                      	PUSH	DS
 48683 00000D51 53                      	PUSH	BX
 48684 00000D52 BB[030B]                	MOV	BX,UCASE_TAB+2
 48685                                  FINISH:
 48686 00000D55 0E                      	PUSH	CS		;Move to DS
 48687 00000D56 1F                      	POP	DS
 48688 00000D57 D7                      	XLAT			;Get upper case character
 48689 00000D58 5B                      	POP	BX
 48690 00000D59 1F                      	POP	DS
 48691                                  L_RET:	
 48692 00000D5A CB                      	RETF
 48693                                  
 48694                                  ;EndProc MAP_CASE
 48695                                  
 48696                                  ; ---------------------------------------------------------------------------
 48697                                  
 48698                                  ; The variables for ECS version are moved here for the same data alignments
 48699                                  ; as IBM-DOS and MS-DOS.
 48700                                  
 48701                                  InterChar:
 48702 00000D5B 00                      	db	0	; Interim character flag ( 1= interim)  ;AN000;
 48703                                  ;------- NOTE: NEXT TWO BYTES SOMETIMES USED AS A WORD !! -------------------
 48704                                  DUMMY:	; LABEL   WORD
 48705                                  InterCon:  
 48706 00000D5C 00                      	db	0	; Console in Interim mode ( 1= interim) ;AN000;
 48707                                  SaveCurFlg:
 48708 00000D5D 00                      	db	0	; Print, do not advance cursor flag     ;AN000;
 48709                                  
 48710                                  ; ---------------------------------------------------------------------------
 48711                                  
 48712                                  ; 17/01/2024 - Retro DOS v5.0
 48713                                  ;TEMPSEG:  dw	0	;hkn; used to store ds.
 48714                                  ;redir_patch:
 48715                                  ;	  db	0
 48716                                  
 48717                                  ; DOSDATA:0D0Dh
 48718                                  
 48719                                  Mark1:	; label byte
 48720                                  
 48721                                  ;IF2
 48722                                  ;	IF ((OFFSET MARK1) GT (OFFSET MSVERSION) )
 48723                                  ;		%OUT !DATA CORRUPTION!MARK1 OFFSET TOO BIG. RE-ORGANIZE DATA.
 48724                                  ;	ENDIF
 48725                                  ;ENDIF
 48726                                  
 48727 00000D5E 00<rep 5h>              	  times 5 db 0
 48728                                  
 48729                                  ;############################################################################
 48730                                  ;
 48731                                  ; ** HACK FOR DOS 4.0 REDIR **
 48732                                  ; 
 48733                                  ; The redir requires the following:
 48734                                  ;
 48735                                  ;	MSVERS	offset D12H
 48736                                  ;	YRTAB	offset D14H
 48737                                  ; 	MONTAB	offset D1CH
 48738                                  ;
 48739                                  ; WARNING! WARNING!
 48740                                  ; 
 48741                                  ; MARK1 SHOULD NOT BE >= 0D12H. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
 48742                                  ; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
 48743                                  ;
 48744                                  ; CURRENTLY MARK1 = 0D0DH
 48745                                  ;
 48746                                  ;############################################################################
 48747                                  
 48748                                  	;ORG	0D12h
 48749                                  
 48750                                  ; DOSDATA:0D12h (MSDOS 6.21, MSDOS.SYS)
 48751                                  
 48752                                  	;db	6
 48753                                  	;db	20
 48754                                  
 48755                                  	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
 48756                                  MSVERSION:				; MS-DOS version in hex for $GET_VERSION
 48757 00000D63 07                      MSMAJORV: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
 48758 00000D64 0A                      MSMINORV: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
 48759                                  
 48760                                  ; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
 48761                                  ;
 48762                                  ;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>
 48763                                  ;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 
 48764                                  
 48765                                  ; Days in year
 48766                                  
 48767                                  YRTAB:   
 48768 00000D65 C8A6                    	DB	200,166			; Leap year
 48769 00000D67 C8A5                    	DB	200,165
 48770 00000D69 C8A5                    	DB	200,165
 48771 00000D6B C8A5                    	DB	200,165
 48772                                  
 48773                                  ; Days of each month
 48774                                  
 48775                                  MONTAB:        
 48776 00000D6D 1F                      	DB      31                      ; January
 48777                                  february:
 48778 00000D6E 1C                      	DB	28 			; February--reset each 
 48779                                  					; time year changes
 48780 00000D6F 1F                              DB      31                      ; March
 48781 00000D70 1E                              DB      30                      ; April
 48782 00000D71 1F                              DB      31                      ; May
 48783 00000D72 1E                              DB      30                      ; June
 48784 00000D73 1F                              DB      31                      ; July
 48785 00000D74 1F                              DB      31                      ; August
 48786 00000D75 1E                              DB      30                      ; September
 48787 00000D76 1F                              DB      31                      ; October
 48788 00000D77 1E                              DB      30                      ; November
 48789 00000D78 1F                              DB      31                      ; December
 48790                                  
 48791                                  ;----------------THE FOLL. BLOCK MOVED FROM TABLE SEG IN MS_TABLE.ASM-------
 48792                                  
 48793                                  ; SYS init extended table,   DOS 3.3   F.C. 5/29/86
 48794                                  
 48795                                  SysInitTable:
 48796                                  	;dw	SYSINITVAR
 48797 00000D79 [2600]                  	dw	SYSINITVARS	; pointer to sysinit var
 48798 00000D7B 0000                            dw      0		; segment
 48799 00000D7D [5113]                          dw	COUNTRY_CDPG	; pointer to country tabl
 48800 00000D7F 0000                            dw      0		; segment of pointer
 48801                                  
 48802                                  	;;;
 48803                                  	; 17/01/2024 - Retro DOS v5.0
 48804                                  	; PCDOS 7.1 IBMDOS.COM - DOSDATA:0D60h
 48805                                  	;
 48806 00000D81 00<rep 3h>              	times	3 db 0
 48807                                  TEMPSEG:
 48808 00000D84 0000                    	dw	0
 48809                                  redir_patch:
 48810 00000D86 00                      	db	0
 48811                                  
 48812                                  ; 17/01/2024
 48813                                  %if 1
 48814                                  
 48815                                  ; M021-
 48816                                  ;
 48817                                  ; DosHasHMA - This flag is set by seg_reinit when the DOS actually
 48818                                  ; 	takes control of the HMA. When running, this word is a reliable
 48819                                  ;	indicator that the DOS is actually using HMA. You can't just use
 48820                                  ;	CS, because ROMDOS uses HMA with CS < F000.
 48821                                  
 48822                                  DosHasHMA:
 48823 00000D87 00                      	db	0
 48824                                  FixExePatch:
 48825 00000D88 0000                    	dw	0		; M012
 48826                                  
 48827                                  %endif
 48828                                  
 48829                                  UnknownPatch:
 48830 00000D8A 0000                    	dw	0
 48831                                  	;;;
 48832                                  
 48833                                  ; 17/01/2024
 48834                                  %if 0
 48835                                  
 48836                                  ; DOS 3.3 F.C. 6/12/86
 48837                                  ; FASTOPEN communications area DOS 3.3   F.C. 5/29/86
 48838                                  
 48839                                  FastTable:				; a better name
 48840                                  FastOpenTable:
 48841                                  	dw      2                       ; number of entries
 48842                                  	dw      FastRet			; pointer to ret instr.
 48843                                  	dw      0                       ; and will be modified by
 48844                                  	dw      FastRet			; FASTxxx when loaded in
 48845                                  	dw      0
 48846                                  
 48847                                  ; DOS 3.3 F.C. 6/12/86
 48848                                  
 48849                                  FastFlg:				; flags
 48850                                  FastOpenFlg:
 48851                                  	db	0			; don't change the foll: order
 48852                                  
 48853                                  %endif
 48854                                  
 48855                                  ; FastOpen_Ext_Info is used as a temporary storage for saving dirpos,dirsec
 48856                                  ; and clusnum which are filled by DOS 3.nc when calling FastOpen Insert
 48857                                  ; or filled by FastOPen when calling FastOpen Lookup
 48858                                  
 48859                                  FastOpen_Ext_Info: ; label  byte	;dirpos
 48860                                  	;db	SIZE FASTOPEN_EXTENDED_INFO dup(0)
 48861                                  	;times	11 db 0
 48862 00000D8C 00<rep Bh>              	times	FEI.size db 0
 48863                                  
 48864                                  ; Dir_Info_Buff is a dir entry buffer which is filled by FastOPen
 48865                                  ; when calling FastOpen Lookup
 48866                                  
 48867                                  Dir_Info_Buff:	; label  byte
 48868                                  	;db   	SIZE dir_entry dup (0)
 48869                                  	;times	32 db 0
 48870 00000D97 00<rep 20h>             	times	dir_entry.size db 0
 48871                                  
 48872                                  Next_Element_Start:
 48873 00000DB7 0000                    	dw	0			; save next element start offset
 48874                                  Del_ExtCluster:
 48875 00000DB9 0000                    	dw	0			; for dos_delete
 48876                                  
 48877                                  ; The following is a stack and its pointer for interrupt 2F which is used
 48878                                  ; by NLSFUNC. There is no significant use of this stack, we are just trying
 48879                                  ; not to destroy the INT 21 stack saved for the user.
 48880                                  
 48881                                  USER_SP_2F:	; LABEL  WORD
 48882 00000DBB [BD0D]                  	dw    	FAKE_STACK_2F
 48883                                  
 48884                                  Packet_Temp:	; label  word		; temporary packet used by readtime
 48885                                  DOS_TEMP:	; label  word		; temporary word
 48886                                  FAKE_STACK_2F:  
 48887                                  	; dw  14 dup (0)		; 12 register temporary storage
 48888 00000DBD 0000<rep Eh>            	times 14 dw 0
 48889                                  
 48890                                  Hash_Temp: 	;label  word		; temporary word
 48891                                  	;dw   4 dup (0)			; temporary hash table during config.sys
 48892 00000DD9 0000<rep 4h>            	times 4 dw 0
 48893                                              	
 48894                                  SCAN_FLAG:	
 48895 00000DE1 00                      	db     0			; flag to indicate key ALT_Q
 48896                                  DATE_FLAG:
 48897 00000DE2 0000                    	dw     0                	; flag to update the date
 48898                                  
 48899                                  FETCHI_TAG:	; label  word		; OBSOLETE - no longer used
 48900 00000DE4 0000                    	dw     0			; formerly part of IBM's piracy protection
 48901                                  
 48902                                  MSG_EXTERROR:	; label  DWORD 		; for system message addr
 48903 00000DE6 00000000                	dd     0               		; for extended error
 48904 00000DEA 00000000                	dd     0			; for parser
 48905 00000DEE 00000000                	dd     0			; for critical errror
 48906 00000DF2 00000000                	dd     0			; for IFS
 48907 00000DF6 00000000                	dd     0			; for code reduction
 48908                                  
 48909                                  SEQ_SECTOR:	; label  DWORD 		; last sector read
 48910 00000DFA FFFFFFFF                	dd     -1
 48911                                  SC_SECTOR_SIZE:
 48912 00000DFE 0000                    	dw	0			; sector size for SC
 48913                                  SC_DRIVE:
 48914 00000E00 00                      	db	0			; drive # for secondary cache
 48915                                  
 48916                                  ; 17/01/2024
 48917                                  ;CurSC_DRIVE:
 48918                                  ;	db	-1			; current SC drive
 48919                                                     
 48920                                  CurSC_SECTOR:
 48921 00000E01 00000000                	dd	0			; current SC starting sector         
 48922                                  SC_STATUS:
 48923 00000E05 0000                    	dw	0			; SC status word                     
 48924                                  SC_FLAG:
 48925 00000E07 00                      	db	0			; SC flag                            
 48926                                  AbsDskErr:
 48927 00000E08 0000                    	dw	0			; Storage for Abs dsk read/write err
 48928                                                                                            
 48929                                  NO_NAME_ID:	; label byte
 48930 00000E0A 4E4F204E414D452020-     	db	'NO NAME    '		; null media id
 48930 00000E13 2020               
 48931                                  
 48932                                  ;hkn; moved from TABLE segment in kstrin.asm
 48933                                  
 48934                                  KISTR001S:	; label	byte		; 2/17/KK
 48935 00000E15 00                      LOOKSIZ: DB	0			; 0 if byte, NZ if word	2/17/KK
 48936                                  KISTR001E:	; label	byte		; 2/17/KK
 48937                                  
 48938                                  ; the nul device driver used to be part of the code. However, since the 
 48939                                  ; header is in the data, and the entry points are only given as an offset,
 48940                                  ; the strategy and interrupt entry points must also be in the data now.
 48941                                  
 48942                                  ; DOSDATA:0DC6h
 48943                                  
 48944                                  SNULDEV:
 48945                                  ;procedure snuldev,far
 48946                                  	;or	word [es:bx+3],100h
 48947                                  	; 17/12/2022
 48948                                  	;or	byte [es:bx+4],01h
 48949                                  	; 05/01/2024 - Retro DOS v4.2 (*)
 48950                                  	; (Original MSDOS and RetroDOS DATA address compatibility) (*)
 48951                                  	;;or	byte [es:bx+SRHEAD.REQSTAT+1],(STDON>>8)
 48952                                  	;or	word [es:bx+SRHEAD.REQSTAT],STDON ; set done bit
 48953                                  	; 05/01/2024 - Retro DOS v5.0
 48954 00000E16 26804F0401              	or	byte [es:bx+SRHEAD.REQSTAT+1],(STDON>>8)
 48955                                  INULDEV:
 48956 00000E1B CB                      	retf				; must not be a return!
 48957                                  ;endproc snuldev
 48958                                  
 48959                                  ;M044
 48960                                  ; Second part of save area for saving last para of Windows memory
 48961                                  
 48962                                  ; 17/01/2024
 48963                                  ;WinoldPatch2:
 48964                                  ;	;db	8 dup (?)	; M044
 48965                                  ;	times	8 db 0	
 48966                                  
 48967                                  UmbSave2:
 48968                                  	;db	5 dup (?)	; M062
 48969 00000E1C 00<rep 5h>              	times	5 db 0
 48970                                  UmbSaveFlag:
 48971 00000E21 00                      	db	0		; M062
 48972                                  
 48973                                  ; DOSDATA:0DDBh
 48974                                  
 48975                                  Mark2:	; label byte
 48976                                  
 48977                                  ;IF2
 48978                                  ;	IF ((OFFSET MARK2) GT (OFFSET ERR_TABLE_21) )
 48979                                  ;		%OUT !DATA CORRUPTION!MARK2 OFFSET TOO BIG. RE-ORGANIZE DATA.
 48980                                  ;	ENDIF
 48981                                  ;ENDIF
 48982                                  
 48983                                  ;############################################################################
 48984                                  ;
 48985                                  ; ** HACK FOR DOS 4.0 REDIR **
 48986                                  ; 
 48987                                  ; The redir requires the following:
 48988                                  ;
 48989                                  ;	ERR_TABLE_21	offset DDBH
 48990                                  ;	ERR_TABLE_24	offset E5BH
 48991                                  ; 	ErrMap24	offset EABH
 48992                                  ;
 48993                                  ; WARNING! WARNING!
 48994                                  ;
 48995                                  ; MARK2 SHOULD NOT BE >= 0DDBH. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
 48996                                  ; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
 48997                                  ;
 48998                                  ; CURRENTLY MARK2 = 0DD0H
 48999                                  ;
 49000                                  ;############################################################################
 49001                                  
 49002                                  	;ORG	0DDBh
 49003                                  
 49004                                  ; DOSDATA:0DDBh (MSDOS 6.21, MSDOS.SYS)
 49005                                  
 49006                                  ; ---------------------------------------------------------------------------
 49007                                  ;
 49008                                  ; The following table defines CLASS ACTION and LOCUS info for the INT 21H
 49009                                  ; errors. Each entry is 4 bytes long:
 49010                                  ;
 49011                                  ;       Err#,Class,Action,Locus
 49012                                  ;
 49013                                  ; A value of 0FFh indicates a call specific value (ie. should already
 49014                                  ; be set). AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
 49015                                  ; THE END, IT IS ASSUMES THAT CLASS, ACTION, LOCUS IS ALREADY SET.
 49016                                  ;
 49017                                  ; ---------------------------------------------------------------------------
 49018                                  
 49019                                  ;ErrTab  Macro   err,class,action,locus
 49020                                  ;ifidn <locus>,<0FFh>
 49021                                  ;    DB  error_&err,errCLASS_&class,errACT_&action,0FFh
 49022                                  ;ELSE
 49023                                  ;    DB  error_&err,errCLASS_&class,errACT_&action,errLOC_&locus
 49024                                  ;ENDIF
 49025                                  ;ENDM
 49026                                  
 49027                                  ERR_TABLE_21: ; LABEL   BYTE
 49028 00000E22 010704FF                    DB  error_invalid_function,       errCLASS_Apperr,    errACT_Abort,    0FFh
 49029 00000E26 02080302                    DB  error_file_not_found,         errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 49030 00000E2A 03080302                    DB  error_path_not_found,         errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 49031 00000E2E 04010401                    DB  error_too_many_open_files,    errCLASS_OutRes,    errACT_Abort,    errLOC_Unk
 49032 00000E32 050303FF                    DB  error_access_denied,          errCLASS_Auth,      errACT_User,     0FFh
 49033 00000E36 06070401                    DB  error_invalid_handle,         errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 49034 00000E3A 07070505                    DB  error_arena_trashed,          errCLASS_Apperr,    errACT_Panic,    errLOC_Mem
 49035 00000E3E 08010405                    DB  error_not_enough_memory,      errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 49036 00000E42 09070405                    DB  error_invalid_block,          errCLASS_Apperr,    errACT_Abort,    errLOC_Mem
 49037 00000E46 0A070405                    DB  error_bad_environment,        errCLASS_Apperr,    errACT_Abort,    errLOC_Mem
 49038 00000E4A 0B090301                    DB  error_bad_format,             errCLASS_BadFmt,    errACT_User,     errLOC_Unk
 49039 00000E4E 0C070401                    DB  error_invalid_access,         errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 49040 00000E52 0D090401                    DB  error_invalid_data,           errCLASS_BadFmt,    errACT_Abort,    errLOC_Unk
 49041 00000E56 0F080302                    DB  error_invalid_drive,          errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 49042 00000E5A 10030302                    DB  error_current_directory,      errCLASS_Auth,      errACT_User,     errLOC_Disk
 49043 00000E5E 110D0302                    DB  error_not_same_device,        errCLASS_Unk,       errACT_User,     errLOC_Disk
 49044 00000E62 12080302                    DB  error_no_more_files,          errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 49045 00000E66 500C0302                    DB  error_file_exists,            errCLASS_Already,   errACT_User,     errLOC_Disk
 49046 00000E6A 200A0202                    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 49047 00000E6E 210A0202                    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 49048 00000E72 540104FF                    DB  error_out_of_structures,      errCLASS_OutRes,    errACT_Abort,    0FFh
 49049 00000E76 56030301                    DB  error_invalid_password,       errCLASS_Auth,      errACT_User,     errLOC_Unk
 49050 00000E7A 52010402                    DB  error_cannot_make,            errCLASS_OutRes,    errACT_Abort,    errLOC_Disk
 49051 00000E7E 32090303                    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,     errLOC_Net
 49052 00000E82 550C0303                    DB  error_already_assigned,       errCLASS_Already,   errACT_User,     errLOC_Net
 49053 00000E86 57090301                    DB  error_invalid_parameter,      errCLASS_BadFmt,    errACT_User,     errLOC_Unk
 49054 00000E8A 530D0401                    DB  error_FAIL_I24,               errCLASS_Unk,       errACT_Abort,    errLOC_Unk
 49055 00000E8E 24010405                    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 49056                                      ; MSDOS 6.0
 49057 00000E92 26010401                    DB  error_handle_EOF,             errCLASS_OutRes,    errACT_Abort,    errLOC_Unk ;AN000;
 49058 00000E96 27010401                    DB  error_handle_Disk_Full,       errCLASS_OutRes,    errACT_Abort,    errLOC_Unk ;AN000;
 49059 00000E9A 5A0D0402                    DB  error_sys_comp_not_loaded,    errCLASS_Unk,       errACT_Abort,    errLOC_Disk ;AN001;
 49060 00000E9E FFFFFFFF                    DB  0FFh,                         0FFH,       	  0FFH,       	   0FFh
 49061                                  
 49062                                  ; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D2Ah
 49063                                  ;ERR_TABLE_21:	db 1,7,4,0FFh
 49064                                  ;		db 2,8,3,2
 49065                                  ;		db 3,8,3,2
 49066                                  ;		db 4,1,4,1
 49067                                  ;		db 5,3,3,0FFh
 49068                                  ;		db 6,7,4,1
 49069                                  ;		db 7,7,5,5
 49070                                  ;		db 8,1,4,5
 49071                                  ;		db 9,7,4,5
 49072                                  ;		db 0Ah,7,4,5
 49073                                  ;		db 0Bh,9,3,1
 49074                                  ;		db 0Ch,7,4,1
 49075                                  ;		db 0Dh,9,4,1
 49076                                  ;		db 0Fh,8,3,2
 49077                                  ;		db 10h,3,3,2
 49078                                  ;		db 11h,0Dh,3,2
 49079                                  ;		db 12h,8,3,2
 49080                                  ;		db 50h,0Ch,3,2
 49081                                  ;		db 20h,0Ah,2,2
 49082                                  ;		db 21h,0Ah,2,2
 49083                                  ;		db 54h,1,4,0FFh
 49084                                  ;		db 56h,3,3,1
 49085                                  ;		db 52h,1,4,2
 49086                                  ;		db 32h,9,3,3
 49087                                  ;		db 55h,0Ch,3,3
 49088                                  ;		db 57h,9,3,1
 49089                                  ;		db 53h,0Dh,4,1
 49090                                  ;		db 24h,1,4,5
 49091                                  ; MSDOS 6.0 (MSDOS 6.21)
 49092                                  ;		db 26h,1,4,1
 49093                                  ;		db 27h,1,4,1
 49094                                  ;		db 5Ah,0Dh,4,2
 49095                                  ; MSDOS 6.0 & MSDOS 3.3
 49096                                  ;		db 0FFh,0FFh,0FFh,0FFh
 49097                                  
 49098                                  ; DOSDATA:0E5Bh (MSDOS 6.21, MSDOS.SYS)
 49099                                  
 49100                                  ; ---------------------------------------------------------------------------
 49101                                  ;
 49102                                  ; The following table defines CLASS ACTION and LOCUS info for the INT 24H
 49103                                  ; errors. Each entry is 4 bytes long:
 49104                                  ;
 49105                                  ;       Err#,Class,Action,Locus
 49106                                  ;
 49107                                  ; A Locus value of 0FFh indicates a call specific value (ie. should already
 49108                                  ; be set). AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
 49109                                  ; THE END.
 49110                                  ;
 49111                                  ; ---------------------------------------------------------------------------
 49112                                  
 49113                                  ERR_TABLE_24: ; LABEL   BYTE
 49114 00000EA2 130B0702                    DB  error_write_protect,          errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 49115 00000EA6 14040501                    DB  error_bad_unit,               errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 49116 00000EAA 150507FF                    DB  error_not_ready,              errCLASS_HrdFail,   errACT_IntRet,   0FFh
 49117 00000EAE 16040501                    DB  error_bad_command,            errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 49118 00000EB2 170B0402                    DB  error_CRC,                    errCLASS_Media,     errACT_Abort,    errLOC_Disk
 49119 00000EB6 18040501                    DB  error_bad_length,             errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 49120 00000EBA 19050102                    DB  error_seek,                   errCLASS_HrdFail,   errACT_Retry,    errLOC_Disk
 49121 00000EBE 1A0B0702                    DB  error_not_DOS_disk,           errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 49122 00000EC2 1B0B0402                    DB  error_sector_not_found,       errCLASS_Media,     errACT_Abort,    errLOC_Disk
 49123 00000EC6 1C020704                    DB  error_out_of_paper,           errCLASS_TempSit,   errACT_IntRet,   errLOC_SerDev
 49124 00000ECA 1D0504FF                    DB  error_write_fault,            errCLASS_HrdFail,   errACT_Abort,    0FFh
 49125 00000ECE 1E0504FF                    DB  error_read_fault,             errCLASS_HrdFail,   errACT_Abort,    0FFh
 49126 00000ED2 1F0D04FF                    DB  error_gen_failure,            errCLASS_Unk,       errACT_Abort,    0FFh
 49127 00000ED6 200A0202                    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 49128 00000EDA 210A0202                    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 49129 00000EDE 220B0702                    DB  error_wrong_disk,             errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 49130 00000EE2 32090303                    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,     errLOC_Net
 49131 00000EE6 23070401                    DB  error_FCB_unavailable,        errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 49132 00000EEA 24010405                    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 49133 00000EEE FF0D05FF                    DB	0FFh,                         errCLASS_Unk,       errACT_Panic,    0FFh
 49134                                  
 49135                                  ; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D9Eh
 49136                                  ;ERR_TABLE_24:	db 13h,0Bh,7,2
 49137                                  ;		db 14h,4,5,1
 49138                                  ;		db 15h,5,7,0FFh
 49139                                  ;		db 16h,4,5,1
 49140                                  ;		db 17h,0Bh,4,2
 49141                                  ;		db 18h,4,5,1
 49142                                  ;		db 19h,5,1,2
 49143                                  ;		db 1Ah,0Bh,7,2
 49144                                  ;		db 1Bh,0Bh,4,2
 49145                                  ;		db 1Ch,2,7,4
 49146                                  ;		db 1Dh,5,4,0FFh
 49147                                  ;		db 1Eh,5,4,0FFh
 49148                                  ;		db 1Fh,0Dh,4,0FFh
 49149                                  ;		db 20h,0Ah,2,2
 49150                                  ;		db 21h,0Ah,2,2
 49151                                  ;		db 22h,0Bh,7,2
 49152                                  ;		db 32h,9,3,3
 49153                                  ;		db 23h,7,4,1
 49154                                  ;		db 24h,1,4,5
 49155                                  ;		db 0FFh,0Dh,5,0FFh
 49156                                  
 49157                                  ; DOSDATA:0EABh (MSDOS 6.21, MSDOS.SYS)
 49158                                  
 49159                                  ; ---------------------------------------------------------------------------
 49160                                  ;
 49161                                  ; We need to map old int 24 errors and device driver errors into the new set
 49162                                  ; of errors. The following table is indexed by the new errors
 49163                                  ;
 49164                                  ; ---------------------------------------------------------------------------
 49165                                  
 49166                                  ;Public  ErrMap24
 49167                                  ErrMap24: ; Label   BYTE
 49168 00000EF2 13                          DB  error_write_protect	; 0
 49169 00000EF3 14                          DB  error_bad_unit		; 1
 49170 00000EF4 15                          DB  error_not_ready		; 2
 49171 00000EF5 16                          DB  error_bad_command	; 3
 49172 00000EF6 17                          DB  error_CRC		; 4
 49173 00000EF7 18                          DB  error_bad_length	; 5
 49174 00000EF8 19                          DB  error_seek		; 6
 49175 00000EF9 1A                          DB  error_not_DOS_disk	; 7
 49176 00000EFA 1B                          DB  error_sector_not_found	; 8
 49177 00000EFB 1C                          DB  error_out_of_paper	; 9
 49178 00000EFC 1D                          DB  error_write_fault	; A
 49179 00000EFD 1E                          DB  error_read_fault	; B
 49180 00000EFE 1F                          DB  error_gen_failure	; C
 49181 00000EFF 1F                          DB  error_gen_failure	; D  RESERVED
 49182 00000F00 1F                          DB  error_gen_failure	; E  RESERVED
 49183 00000F01 22                          DB  error_wrong_disk	; F
 49184                                  
 49185                                  ;ErrMap24: db 13h, 14h, 15h, 16h, 17h, 18h, 19h, 1Ah
 49186                                  ;	   db 1Bh, 1Ch, 1Dh, 1Eh, 1Fh, 1Fh, 1Fh, 22h
 49187                                  	
 49188                                  ErrMap24End: ; LABEL   BYTE
 49189                                  
 49190                                  ; DOSDATA:0E5Bh (MSDOS 6.21, MSDOS.SYS)
 49191                                  
 49192                                  ; ---------------------------------------------------------------------------
 49193                                  
 49194                                  ; 27/04/2019 - Retro DOS v4.0
 49195                                  
 49196                                  ; 17/01/2024
 49197                                  ;FIRST_BUFF_ADDR:
 49198                                  ;	dw	0			; first buffer address
 49199                                  
 49200                                  SPECIAL_VERSION:
 49201 00000F02 0000                    	dw	0			;AN006; used by INT 2F 47H
 49202                                  FAKE_COUNT:
 49203 00000F04 00<rep FFh>             	times 255 db 0			;AN008; fake version count
 49204                                  OLD_FIRSTCLUS:
 49205 00001003 0000                    	dw	0			;AN011; save old first cluster for fastopen
 49206                                  
 49207                                  ; ---------------------------------------------------------------------------
 49208                                  
 49209                                  ;smr; moved from TABLE segment in exec.asm
 49210                                  
 49211 00001005 0000                    exec_init_SP: dw 0
 49212 00001007 0000                    exec_init_SS: dw 0
 49213 00001009 0000                    exec_init_IP: dw 0
 49214 0000100B 0000                    exec_init_CS: dw 0
 49215                                  
 49216                                  exec_signature:
 49217 0000100D 0000                    	dw	0	; must contain 4D5A (yay zibo!)
 49218                                  exec_len_mod_512:
 49219 0000100F 0000                    	dw	0	; low 9 bits of length
 49220                                  exec_pages:
 49221 00001011 0000                    	dw	0	; number of 512b pages in file
 49222                                  exec_rle_count:
 49223 00001013 0000                    	dw	0	; count of reloc entries
 49224                                  exec_par_dir:
 49225 00001015 0000                    	dw	0	; number of paragraphs before image
 49226                                  exec_min_BSS:
 49227 00001017 0000                    	dw	0	; minimum number of para of BSS
 49228                                  exec_max_BSS:
 49229 00001019 0000                    	dw	0	; max number of para of BSS
 49230                                  exec_SS:
 49231 0000101B 0000                    	dw	0	; stack of image
 49232                                  exec_SP:
 49233 0000101D 0000                    	dw	0	; SP of image
 49234                                  exec_chksum:
 49235 0000101F 0000                    	dw	0	; checksum of file (ignored)
 49236                                  exec_IP:
 49237 00001021 0000                    	dw	0	; IP of entry
 49238                                  exec_CS:
 49239 00001023 0000                    	dw	0	; CS of entry
 49240                                  exec_rle_table:
 49241 00001025 0000                    	dw	0	; byte offset of reloc table
 49242                                  
 49243                                  exec_header_len	equ $-exec_signature			;PBUGBUG
 49244                                  
 49245                                  ;smr; eom
 49246                                  
 49247                                  ; ---------------------------------------------------------------------------
 49248                                  
 49249                                  ;SR;
 49250                                  ; WIN386 instance table for DOS
 49251                                  
 49252                                  Win386_Info:
 49253                                  	;db	3, 0
 49254                                  	; 17/01/2024 - PCDOS 7.1 IBMDOS.COM
 49255 00001027 0400                    	db	4, 0	; WIN386_SIS version
 49256 00001029 00000000                	dd	0	; .Next_Dev_Ptr
 49257                                  Win386_Inf_Virt_Dev_Ptr:
 49258 0000102D 00000000                	dd	0	; .Virt_Dev_File_Ptr
 49259 00001031 00000000                	dd	0	; .Reference_Data
 49260                                  Instance_Data_Ptr:
 49261 00001035 [3D10]0000              	dw	Instance_Table, 0
 49262                                  	; 17/01/2024 - PCDOS 7.1 IBMDOS.COM
 49263                                  	;;
 49264 00001039 [8310]0000              	dw	Unknown_Table, 0  ; (what is this and what for ?)
 49265                                  	;;
 49266                                  
 49267                                  Instance_Table:
 49268 0000103D [2200]00000200          	dw	CONTPOS, 0, 2
 49269 00001043 [3200]00000400          	dw	BCON, 0, 4
 49270 00001049 [F901]00000601          	dw	CARPOS, 0, 106h
 49271 0000104F [0003]00000100          	dw	CHARCO, 0, 1
 49272 00001055 [0510]00002200          	dw	exec_init_SP, 0, 34	; M074
 49273 0000105B [8900]00000100          	dw	UMBFLAG,0,1		; M019
 49274 00001061 [8C00]00000200          	dw	UMB_HEAD,0,2		; M019
 49275                                  	;;;
 49276                                  	; 17/01/2024 - PCDOS 7.1 IBMDOS.COM
 49277 00001067 [8600]C9000100          	dw	DOS_FLAG, 0C9h, 1
 49278 0000106D [DF13]C9000100          	dw	INDOS_FLAG, 0C9h, 1 ; (what for a 2nd INDOS flag, windows?)	
 49279 00001073 [E013]C9000100          	dw	DEVIO_IN_PROGRESS, 0C9h, 1
 49280                                  				; "devio call in progress" status flag ptr
 49281                                  	;;;
 49282 00001079 00000000                	dw	0, 0
 49283                                  
 49284                                  	;;;
 49285                                  	; 17/01/2024 - PCDOS 7.1 IBMDOS.COM
 49286 0000107D FFFF                    	dw	0FFFFh
 49287 0000107F FFFF                    	dw	0FFFFh
 49288                                  CL0FATENTRY_HW:
 49289 00001081 FFFF                    	dw	0FFFFh
 49290                                  Unknown_Table:
 49291 00001083 0000                    	dw	0
 49292 00001085 C900                    	dw	0C9h
 49293 00001087 [CC00]                  	dw	SFTABL		; DOSDATA:00CCh
 49294 00001089 [F901]                  	dw	CARPOS
 49295 0000108B C900                    	dw	0C9h
 49296 0000108D [7412]                  	dw	UNKNOWN1	; ? (points to DOSDATA:114Dh)
 49297 0000108F 0000                    	dw	0
 49298 00001091 0000                    	dw	0
 49299                                  	;;;
 49300                                  
 49301                                  ; M001; SR;
 49302                                  ; M001; On DOSMGR call ( cx == 0 ), we need to return a table of offsets of
 49303                                  ; M001; some DOS variables. Note that the only really important variable in
 49304                                  ; M001; this is User_Id. The other variables are needed only to patch stuff
 49305                                  ; M001; which does not need to be done in DOS 5.0. 
 49306                                  
 49307                                  ; 29/12/2022
 49308                                  ; (MSDOS 6.21 MSDOS.SYS DOSDATA:1022h)
 49309                                  
 49310                                  Win386_DOSVars:
 49311 00001093 05                      	db	5	;Major version 5 ; M001
 49312 00001094 00                      	db	0	;Minor version 0 ; M001
 49313 00001095 [EC05]                  	dw	SAVEDS	; M001
 49314 00001097 [EA05]                  	dw	SAVEBX	; M001
 49315 00001099 [2103]                  	dw	INDOS	; M001
 49316 0000109B [3E03]                  	dw	USER_ID	; M001
 49317 0000109D [1503]                  	dw	CritPatch ; M001
 49318 0000109F [8C00]                  	dw	UMB_HEAD ; M012
 49319                                  
 49320                                  ;SR;
 49321                                  ; Flag to indicate whether WIN386 is running or not
 49322                                  
 49323 000010A1 00                      IsWin386: db	0
 49324                                  
 49325                                  ;M018
 49326                                  ; This variable contains the path to the VxD device needed for Win386
 49327                                  
 49328                                  ; 09/01/2024
 49329                                  ;VxDpath: db	'c:\wina20.386',0	;M018
 49330                                  
 49331                                  ;End WIN386 support
 49332                                  
 49333                                  ; ---------------------------------------------------------------------------
 49334                                  
 49335                                  ;SR;
 49336                                  ; These variables have been added for the special lie support for device
 49337                                  ;drivers.
 49338                                  ;
 49339                                  
 49340                                  DriverLoad:	
 49341 000010A2 01                      	db	1	;initialized to do special handling
 49342                                  BiosDataPtr:
 49343 000010A3 00000000                	dd	0
 49344                                  
 49345                                  ; 29/12/2022 - Retro DOS v4.1
 49346                                  %if 0
 49347                                  
 49348                                  ; 27/04/2019 - Retro DOS v4.0
 49349                                  ; 04/11/2022
 49350                                  ; DOSDATA:1044h (MSDOS 6.21 & MSDOS 5.0, MSDOS.SYS)
 49351                                  
 49352                                  ;------------------------------------------------------------------------
 49353                                  ; Patch for Sidekick
 49354                                  ;
 49355                                  ; A documented method for finding the offset of the Errormode flag in the
 49356                                  ; dos swappable data area if for the app to scan in the dos segment (data)
 49357                                  ; for the following sequence of instructions.
 49358                                  ;
 49359                                  ; Ref: Part C, Article 11, pg 356 of MSDOS Encyclopedia
 49360                                  ;
 49361                                  ; The Offset of Errormode flag is 0320h
 49362                                  ;
 49363                                  ;------------------------------------------------------------------------
 49364                                  
 49365                                  	db	036h, 0F6h, 06h, 020h, 03h, 0FFh ; test ss:[errormode], -1
 49366                                  	db	075h, 0Ch			 ; jnz  NearLabel
 49367                                  	db	036h, 0FFh, 036h, 058h, 03h	 ; push ss:[NearWord]
 49368                                  	db	0CDh, 028h			 ; int  28h
 49369                                  
 49370                                  ;--------------------------------------------------------------------------
 49371                                  ; Patch for PortOfEntry - M036
 49372                                  ;
 49373                                  ; PortOfEntry by Sector Technology uses an un documented way of determining
 49374                                  ; the offset of Errormode flag. The following patch is to support them in
 49375                                  ; DOS 5.0. The corresponding code is actually in msdisp.asm
 49376                                  ;
 49377                                  ;---------------------------------------------------------------------------
 49378                                  
 49379                                  	db 	080h, 03Eh, 020h, 03h, 00h 	 ; cmp 	[errormode], 0
 49380                                  	db	075h, 037h			 ; jnz	NearLabel
 49381                                  	db 	0BCh, 0A0h, 0Ah		  	 ; mov	sp, dosdata:iostack
 49382                                  
 49383                                  %endif ; 29/12/2022
 49384                                  
 49385                                  ; DOSDATA:105Dh (MSDOS 6.21, MSDOS.SYS)
 49386                                  
 49387                                  ;--------------------------------------------------------------------------
 49388                                  
 49389                                  ;*** New FCB Implementation
 49390                                  ; This variable is used as a cache in the new FCB implementation to remember
 49391                                  ;the address of a local SFT that can be recycled for a regenerate operation
 49392                                  
 49393 000010A7 00000000                LocalSFT: dd	0		; 0 to indicate invalid pointer
 49394                                  
 49395                                  ;DOSDATA ENDS
 49396                                  
 49397                                  ;============================================================================
 49398                                  ; LMSTUB.ASM (MSDOS 6.0, 1991)
 49399                                  ;============================================================================
 49400                                  ; 27/04/2019 - Retro DOS 4.0
 49401                                  
 49402                                  ;DOSDATA  SEGMENT WORD PUBLIC 'DATA'
 49403                                  
 49404                                  ;---------------------------------------------------------------------------
 49405                                  ;	Low Memory Stub for DOS when DOS runs in HMA
 49406                                  ;----------------------------------------------------------------------------
 49407                                  	
 49408                                  	;db	90h
 49409                                  
 49410                                  	;EVEN
 49411 000010AB 90                      align 2
 49412                                  
 49413                                  ; DOSDATA:1062h (MSDOS 6.21, MSDOS.SYS)
 49414                                  
 49415                                  DOSINTTABLE:	; LABEL	DWORD
 49416                                  
 49417                                  	;DW	OFFSET DOSCODE:DIVOV 		, 0
 49418                                  	;DW	OFFSET DOSCODE:QUIT 		, 0
 49419                                  	;DW	OFFSET DOSCODE:COMMAND		, 0
 49420                                  	;DW	OFFSET DOSCODE:ABSDRD		, 0
 49421                                  	;DW	OFFSET DOSCODE:ABSDWRT		, 0
 49422                                  	;DW	OFFSET DOSCODE:Stay_resident	, 0
 49423                                  	;DW	OFFSET DOSCODE:INT2F		, 0
 49424                                  	;DW	OFFSET DOSCODE:CALL_ENTRY	, 0
 49425                                  	;DW	OFFSET DOSCODE:IRETT		, 0
 49426                                  	
 49427 000010AC [645C]0000              	dw	DIVOV 		, 0  ; DOSINTTABLE+0
 49428 000010B0 [C502]0000              	dw	QUIT 		, 0  ; DOSINTTABLE+4	
 49429 000010B4 [F102]0000              	dw	COMMAND		, 0  ; DOSINTTABLE+8
 49430 000010B8 [2D05]0000              	dw	ABSDRD		, 0  ; DOSINTTABLE+12
 49431 000010BC [DC05]0000              	dw	ABSDWRT		, 0  ; DOSINTTABLE+16
 49432 000010C0 [D86B]0000              	dw	STAY_RESIDENT	, 0  ; DOSINTTABLE+20
 49433 000010C4 [3C07]0000              	dw	INT2F		, 0  ; DOSINTTABLE+24
 49434 000010C8 [CC02]0000              	dw	CALL_ENTRY	, 0  ; DOSINTTABLE+28
 49435 000010CC [CB02]0000              	dw	IRETT		, 0  ; DOSINTTABLE+32
 49436                                  
 49437 000010D0 0000                    SS_Save: dw	0		; save user's stack segment
 49438 000010D2 0000                    SP_Save: dw	0		; save user's stack offset
 49439                                  
 49440                                  ;-------------------------------------------------------------------------
 49441                                  ;
 49442                                  ; LOW MEM STUB:
 49443                                  ;
 49444                                  ; The low mem stub contains the entry points into DOS for all interrupts
 49445                                  ; handled by DOS. This stub is installed if the user specifies that the
 49446                                  ; DOS load in HIMEM. Each entry point does this.
 49447                                  ;
 49448                                  ; 	1. if jmp to 8 has been patched out
 49449                                  ;	   2. if A20 OFF
 49450                                  ;	      3. Enable A20
 49451                                  ;	   4. else 
 49452                                  ;	      5. just go to dos entry
 49453                                  ;	   6. endif
 49454                                  ;	7. else
 49455                                  ;	   8. just go to dos entry
 49456                                  ;	9. endif
 49457                                  ;
 49458                                  ;--------------------------------------------------------------------------
 49459                                  
 49460                                  ; 27/04/2019 - Retro DOS v4.0
 49461                                  
 49462                                  ; DOSDATA:108Ah (MSDOS 6.21, MSDOS.SYS)
 49463                                  
 49464                                  ;--------------------------------------------------------------------------
 49465                                  ;
 49466                                  ; DIVIDE BY 0 handler
 49467                                  ;
 49468                                  ;--------------------------------------------------------------------------
 49469                                  
 49470                                  ldivov:
 49471                                  	; The following jump, skipping the XMS calls will be patched to 
 49472                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 49473                                  	; needed because the stub is installed even before the XMS driver
 49474                                  	; is loaded if the user specifies dos=high in the config.sys
 49475                                  i0patch:
 49476 000010D4 EB03                    	jmp	short divov_cont
 49477                                  
 49478 000010D6 E8D800                  	call	EnsureA20ON		; we must turn on A20 if OFF
 49479                                  divov_cont:
 49480 000010D9 2EFF2E[AC10]            	jmp	far [cs:DOSINTTABLE]	; jmp to DOS
 49481                                  
 49482                                  ;------------------------------------------------------------------------
 49483                                  ;
 49484                                  ; INT 20 Handler
 49485                                  ;
 49486                                  ; Here we do not have to set up the stack to return here as the abort call
 49487                                  ; will return to the address after the int 21 ah=4b call. This would be the
 49488                                  ; common exit point if A20 had been OFF (for TOGGLE DOS) and the A20 line
 49489                                  ; will be restored then.
 49490                                  ;
 49491                                  ;-------------------------------------------------------------------------
 49492                                  
 49493                                  lquit:
 49494                                  	; The following jump, skipping the XMS calls will be patched to 
 49495                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 49496                                  	; needed because the stub is installed even before the XMS driver
 49497                                  	; is loaded if the user specifies dos=high in the config.sys
 49498                                  i20patch:
 49499 000010DE EB03                    	jmp	short quit_cont
 49500                                  
 49501 000010E0 E8CE00                  	call	EnsureA20ON		; we must turn on A20 if OFF
 49502                                  quit_cont:
 49503 000010E3 2EFF2E[B010]            	jmp	far [cs:DOSINTTABLE+4]	; jump to DOS
 49504                                  
 49505                                  ;--------------------------------------------------------------------------
 49506                                  ;
 49507                                  ; INT 21 Handler
 49508                                  ;
 49509                                  ;--------------------------------------------------------------------------
 49510                                  
 49511                                  lcommand:
 49512                                  	; The following jump, skipping the XMS calls will be patched to 
 49513                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 49514                                  	; needed because the stub is installed even before the XMS driver
 49515                                  	; is loaded if the user specifies dos=high in the config.sys
 49516                                  i21patch:
 49517 000010E8 EB03                    	jmp	short command_cont
 49518                                  
 49519 000010EA E8C400                  	call	EnsureA20ON		; we must turn on A20 if OFF
 49520                                  command_cont:
 49521 000010ED 2EFF2E[B410]            	jmp	far [cs:DOSINTTABLE+8]	; jmp to DOS
 49522                                  
 49523                                  ;------------------------------------------------------------------------
 49524                                  ;
 49525                                  ; INT 25 
 49526                                  ;
 49527                                  ;----------------------------------------------------------------------------
 49528                                  
 49529                                  labsdrd:
 49530                                  	; The following jump, skipping the XMS calls will be patched to 
 49531                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 49532                                  	; needed because the stub is installed even before the XMS driver
 49533                                  	; is loaded if the user specifies dos=high in the config.sys
 49534                                  i25patch:
 49535 000010F2 EB03                    	jmp	short absdrd_cont
 49536                                  
 49537 000010F4 E8BA00                  	call	EnsureA20ON		; we must turn on A20 if OFF
 49538                                  absdrd_cont:
 49539 000010F7 2EFF2E[B810]            	jmp	far [cs:DOSINTTABLE+12]	; jmp to DOS
 49540                                  
 49541                                  ;-------------------------------------------------------------------------
 49542                                  ;
 49543                                  ; INT 26
 49544                                  ;
 49545                                  ;-----------------------------------------------------------------------
 49546                                  
 49547                                  labsdwrt:
 49548                                  	; The following jump, skipping the XMS calls will be patched to 
 49549                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 49550                                  	; needed because the stub is installed even before the XMS driver
 49551                                  	; is loaded if the user specifies dos=high in the config.sys
 49552                                  i26patch:
 49553 000010FC EB03                    	jmp	short absdwrt_cont
 49554                                  
 49555 000010FE E8B000                  	call	EnsureA20ON		; we must turn on A20 if OFF
 49556                                  absdwrt_cont:
 49557 00001101 2EFF2E[BC10]            	jmp	far [cs:DOSINTTABLE+16]	; jmp to DOS
 49558                                  
 49559                                  ;------------------------------------------------------------------------
 49560                                  ;
 49561                                  ; INT 27
 49562                                  ;
 49563                                  ;-----------------------------------------------------------------------
 49564                                  
 49565                                  lstay_resident:
 49566                                  	; The following jump, skipping the XMS calls will be patched to
 49567                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 49568                                  	; needed because the stub is installed even before the XMS driver
 49569                                  	; is loaded if the user specifies dos=high in the config.sys
 49570                                  i27patch:
 49571 00001106 EB03                    	jmp	short sr_cont
 49572                                  
 49573 00001108 E8A600                  	call	EnsureA20ON		; we must turn on A20 if OFF
 49574                                  sr_cont:
 49575 0000110B 2EFF2E[C010]            	jmp	far [cs:DOSINTTABLE+20]	; jmp to DOS
 49576                                  
 49577                                  ;-----------------------------------------------------------------------------
 49578                                  ;
 49579                                  ; INT 2f
 49580                                  ;
 49581                                  ;-------------------------------------------------------------------------
 49582                                  
 49583                                  lint2f:
 49584                                  	; The following jump, skipping the XMS calls will be patched to 
 49585                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 49586                                  	; needed because the stub is installed even before the XMS driver
 49587                                  	; is loaded if the user specifies dos=high in the config.sys
 49588                                  i2fpatch:
 49589 00001110 EB03                    	jmp	short int2f_cont
 49590                                  
 49591 00001112 E89C00                  	call	EnsureA20ON		; we must turn on A20 if OFF
 49592                                  int2f_cont:
 49593 00001115 2EFF2E[C410]            	jmp	far [cs:DOSINTTABLE+24]	; jmp to DOS
 49594                                  
 49595                                  ;-----------------------------------------------------------------------------
 49596                                  ;
 49597                                  ; CPM entry
 49598                                  ;
 49599                                  ;------------------------------------------------------------------------
 49600                                  
 49601                                  lcall_entry:
 49602                                  	; The following jump, skipping the XMS calls will be patched to 
 49603                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is
 49604                                  	; needed because the stub is installed even before the XMS driver
 49605                                  	; is loaded if the user specifies dos=high in the config.sys
 49606                                  cpmpatch:
 49607 0000111A EB03                    	jmp	short callentry_cont
 49608                                  
 49609 0000111C E89200                  	call	EnsureA20ON		; we must turn on A20 if OFF
 49610                                  callentry_cont:
 49611 0000111F 2EFF2E[C810]            	jmp	far [cs:DOSINTTABLE+28]	; jmp to DOS
 49612                                  
 49613                                  ;--------------------------------------------------------------------------
 49614                                  
 49615                                  lirett:
 49616 00001124 CF                      	iret
 49617                                  
 49618                                  ;---------------------------------------------------------------------------
 49619                                  ;
 49620                                  ; LowIntXX:
 49621                                  ;
 49622                                  ; Interrupts from DOS that pass control to a user program must be done from
 49623                                  ; low memory, as the user program may change the state of the A20 line or
 49624                                  ; they may require that the A20 line be OFF. The following piece of code is
 49625                                  ; far call'd from the following places in DOS:
 49626                                  ;
 49627                                  ;	1. msctrlc.asm where dos issues an int 23h (ctrlc)
 49628                                  ;	2. msctrlc.asm where dos issues an int 24h (critical error)
 49629                                  ;	3. msctrlc.asm where dos issues an int 28h (idle int)
 49630                                  ;
 49631                                  ; The int 23 and int 24 handlers may decide to do a far return instead of an
 49632                                  ; IRET ane leave the flags on the stack. Therefore we save the return address
 49633                                  ; before doing the ints and then do a far junp back into DOS.
 49634                                  ;
 49635                                  ;---------------------------------------------------------------------------
 49636                                  
 49637 00001125 00000000                DosRetAddr23:	dd	0
 49638 00001129 00000000                DosRetAddr24:	dd	0
 49639 0000112D 00000000                DosRetAddr28:	dd	0
 49640                                  
 49641                                  	; Execute int 23h from low memory
 49642                                  LowInt23:
 49643                                  					; save the return address that is on
 49644                                  					; the stack
 49645 00001131 2E8F06[2511]            	pop	word [cs:DosRetAddr23]
 49646 00001136 2E8F06[2711]            	pop	word [cs:DosRetAddr23+2]
 49647                                  
 49648 0000113B CD23                    	int	23h			; ctrl C
 49649                                  					; turn on A20 it has been turned OFF
 49650                                  					; by int 28/23/24 handler.
 49651                                  
 49652 0000113D E87100                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF 
 49653                                  
 49654 00001140 2EFF2E[2511]            	jmp	far [cs:DosRetAddr23]	; jump back to DOS
 49655                                  
 49656                                  
 49657                                  	; Execute int 24h from low memory
 49658                                  LowInt24:
 49659                                  					; save the return address that is on
 49660                                  					; the stack
 49661 00001145 2E8F06[2911]            	pop	word [cs:DosRetAddr24]
 49662 0000114A 2E8F06[2B11]            	pop	word [cs:DosRetAddr24+2]
 49663                                  
 49664 0000114F CD24                    	int	24h			; crit error
 49665                                  					; turn on A20 it has been turned OFF
 49666                                  					; by int 28/23/24 handler.
 49667                                  
 49668 00001151 E85D00                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF
 49669                                  
 49670 00001154 2EFF2E[2911]            	jmp	far [cs:DosRetAddr24]	; jump back to DOS
 49671                                  
 49672                                  
 49673                                   
 49674                                  	; Execute int 28h from low memory
 49675                                  LowInt28:
 49676 00001159 CD28                    	int	28h			; idle int
 49677                                  					; turn on A20 it has been turned OFF
 49678                                  					; by int 28/23/24 handler.
 49679                                  
 49680 0000115B E85300                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF
 49681                                  
 49682 0000115E CB                      	retf
 49683                                  
 49684                                  ; DOSDATA:1115h (MSDOS 6.21, MSDOS.SYS)
 49685                                  
 49686                                  ;-------------------------------------------------------------------------
 49687                                  ;
 49688                                  ; int 21 ah=4b (exec) call will jump to the following label before xferring
 49689                                  ; control to the exec'd program. We turn off A20 inorder to allow programs
 49690                                  ; that have been packed by the faulty exepack utility to unpack correctly.
 49691                                  ; This is so because exepac'd programs rely on address wrap.
 49692                                  ;
 49693                                  ;------------------------------------------------------------------------- 
 49694                                  
 49695                                  disa20_xfer:
 49696 0000115F E83F00                  	call	XMMDisableA20		; disable A20
 49697                                  
 49698                                  	; Look at msproc.asm at label exec_go for understanding the following:
 49699                                  
 49700                                  	; DS:SI points to entry point
 49701                                  	; AX:DI points to initial stack
 49702                                  	; DX has PDB pointer
 49703                                  	; BX has initial AX value
 49704                                  
 49705 00001162 FA                      	cli
 49706 00001163 2EC606[2103]00          	mov	byte [cs:INDOS],0	; SS Override
 49707                                  
 49708 00001169 8ED0                    	mov	SS,AX			; set up user's stack
 49709 0000116B 89FC                    	mov	SP,DI			; and SP
 49710 0000116D FB                      	sti
 49711                                  
 49712 0000116E 1E                      	push	DS			; fake long call to entry
 49713 0000116F 56                      	push	SI
 49714 00001170 8EC2                    	mov	ES,DX			; set up proper seg registers
 49715 00001172 8EDA                    	mov	DS,DX
 49716 00001174 89D8                    	mov	AX,BX			; set up proper AX
 49717 00001176 CB                      	retf
 49718                                  
 49719                                  ;-------------------------------------------------------------------------
 49720                                  ;
 49721                                  ; M003:
 49722                                  ;
 49723                                  ; If an int 21 ah=25 call is made immediately after an exec call, DOS will
 49724                                  ; come here, turn A20 OFF restore user stack and registers before returning
 49725                                  ; to user. This is done in dos\msdisp.asm. This has been done to support 
 49726                                  ; programs compiled with MS PASCAL 3.2. See under TAG M003 in DOSSYM.INC for
 49727                                  ; more info.	
 49728                                  ;
 49729                                  ; Also at this point DS is DOSDATA. So we can assume DS DOSDATA. Note that
 49730                                  ; SS is also DOS stack. It is important that we do the XMS call on DOS's
 49731                                  ; stack to avoid additional stack overhead for the user.
 49732                                  ;
 49733                                  ; -------------------------------------------------------------------------
 49734                                  
 49735                                  disa20_iret:
 49736 00001177 E82700                  	call	XMMDisableA20
 49737 0000117A FE0E[2103]              	dec	byte [INDOS]
 49738 0000117E 8E16[8605]              	mov	SS,[USER_SS]		; restore user stack
 49739 00001182 8B26[8405]              	mov	SP,[USER_SP]
 49740 00001186 89E5                    	mov	BP,SP
 49741                                  	;mov	[BP+user_env.user_AX],AL
 49742 00001188 884600                  	mov	[bp],al
 49743 0000118B A1[F205]                	mov	AX,[NSP]
 49744 0000118E A3[8405]                	mov	[USER_SP],AX
 49745 00001191 A1[F005]                	mov	AX,[NSS]
 49746 00001194 A3[8605]                	mov	[USER_SS],AX
 49747                                  
 49748 00001197 58                      	pop	AX			; restore user regs
 49749 00001198 5B                      	pop	BX
 49750 00001199 59                      	pop	CX
 49751 0000119A 5A                      	pop	DX
 49752 0000119B 5E                      	pop	SI
 49753 0000119C 5F                      	pop	DI
 49754 0000119D 5D                      	pop	BP
 49755 0000119E 1F                      	pop	DS
 49756 0000119F 07                      	pop	ES
 49757 000011A0 CF                      	iret
 49758                                  
 49759                                  ;**************************************************************************
 49760                                  ;***	XMMDisableA20 - switch 20th address line
 49761                                  ;
 49762                                  ;	This routine is used to disable the 20th address line in
 49763                                  ;	the system using XMM calls.
 49764                                  ;
 49765                                  ;	ENTRY	none		;ds = _DATA
 49766                                  ;	EXIT	A20 line disabled
 49767                                  ;	USES	NOTHING
 49768                                  ;
 49769                                  ;**************************************************************************
 49770                                  
 49771                                  XMMDisableA20:
 49772 000011A1 53                      	push	bx
 49773 000011A2 50                      	push	ax
 49774                                  	;mov	ah,XMM_LOCAL_DISABLE_A20
 49775 000011A3 B406                    	mov	ah,6
 49776 000011A5 2EFF1E[AD11]            	call	far [cs:XMMcontrol]
 49777 000011AA 58                      	pop	ax
 49778 000011AB 5B                      	pop	bx
 49779 000011AC C3                      	retn
 49780                                  
 49781                                  ; The entry point in the BIOS XMS driver is defined here.
 49782                                  
 49783                                  XMMcontrol:
 49784 000011AD 00000000                	dd	0
 49785                                  
 49786                                  ;--------------------------------------------------------------------------
 49787                                  ;
 49788                                  ;***	EnsureA20ON - Ensures that A20 is ON
 49789                                  ;
 49790                                  ;	This routine is used to query the A20 state in
 49791                                  ;	the system using XMM calls.
 49792                                  ;
 49793                                  ;	ENTRY: none
 49794                                  ;
 49795                                  ;	EXIT : A20 will be ON
 49796                                  ;		
 49797                                  ; 	USES : NONE
 49798                                  ;
 49799                                  ;--------------------------------------------------------------------------
 49800                                  
 49801                                  ; 19/09/2023
 49802                                  ;LowMemory:	; label dword		; Set equal to 0000:0080
 49803                                  ;	dw	00080h
 49804                                  ;	dw	00000h
 49805                                  ;
 49806                                  ;HighMemory:	; label dword
 49807                                  ;	dw	00090h			; Set equal to FFFF:0090
 49808                                  ;	dw	0FFFFh
 49809                                  
 49810                                  EnsureA20ON:
 49811 000011B1 9C                      	pushf
 49812 000011B2 1E                      	push    ds
 49813 000011B3 06                      	push	es
 49814 000011B4 51                      	push	cx
 49815 000011B5 56                      	push	si
 49816 000011B6 57                      	push	di
 49817                                  
 49818                                  	; 19/09/2023
 49819                                  	;lds	si,[cs:LowMemory]	; Compare the 4 words at 0000:0080
 49820                                  	;les	di,[cs:HighMemory]	; with the 4 at FFFF:0090
 49821                                  
 49822 000011B7 31FF                    	xor	di,di
 49823 000011B9 8EC7                    	mov	es,di
 49824 000011BB 4F                      	dec	di
 49825 000011BC BE9000                  	mov	si,90h	; 0FFFFh:0090h	; HighMemory
 49826 000011BF 8EDF                    	mov	ds,di
 49827 000011C1 BF8000                  	mov	di,80h ; 0000h:0080h	; LowMemory
 49828                                  	
 49829 000011C4 B90400                  	mov	cx,4
 49830 000011C7 FC                      	cld
 49831 000011C8 F3A7                    	repe    cmpsw
 49832                                  
 49833 000011CA 7407                    	jz	short EA20_OFF
 49834                                  EA20_RET:
 49835 000011CC 5F                      	pop	di
 49836 000011CD 5E                      	pop	si
 49837 000011CE 59                      	pop	cx
 49838 000011CF 07                      	pop	es
 49839 000011D0 1F                      	pop	ds
 49840 000011D1 9D                      	popf
 49841 000011D2 C3                      	retn
 49842                                  
 49843                                  EA20_OFF:
 49844                                  	; We are going to do the XMS call on the DOS's AuxStack.
 49845                                  	; NOTE: ints are disabled at this point.
 49846                                  
 49847 000011D3 53                      	push	bx
 49848 000011D4 50                      	push	ax
 49849                                  
 49850 000011D5 8CD0                    	mov	ax,ss			; save user's stack pointer
 49851 000011D7 2EA3[D010]              	mov	[cs:SS_Save],ax
 49852 000011DB 2E8926[D210]            	mov	[cs:SP_Save],sp
 49853 000011E0 8CC8                    	mov	ax,cs
 49854 000011E2 8ED0                    	mov	ss,ax
 49855 000011E4 BC[A007]                	mov	sp,AUXSTACK
 49856                                  					; ss:sp -> DOSDATA:AuxStack
 49857                                  	;mov	ah,XMM_LOCAL_ENABLE_A20
 49858 000011E7 B405                    	mov	ah,5
 49859 000011E9 2EFF1E[AD11]            	call	far [cs:XMMcontrol]
 49860 000011EE 09C0                    	or	ax,ax
 49861 000011F0 740F                    	jz	short XMMerror		; AX = 0 fatal error
 49862                                  
 49863 000011F2 2EA1[D010]              	mov	ax,[cs:SS_Save]		; restore user stack
 49864 000011F6 8ED0                    	mov	ss,ax
 49865 000011F8 2E8B26[D210]            	mov	sp,[cs:SP_Save]
 49866                                  
 49867 000011FD 58                      	pop	ax
 49868 000011FE 5B                      	pop	bx
 49869                                  
 49870 000011FF EBCB                    	jmp	short EA20_RET
 49871                                  
 49872                                  XMMerror:				; M006 - Start
 49873 00001201 B40F                    	mov	ah,0Fh			; get video mode
 49874 00001203 CD10                    	int	10h
 49875 00001205 3C07                    	cmp	al,7			; Q: are we an MDA
 49876 00001207 7406                    	je	short XMMcont			; Y: do not change mode
 49877 00001209 30E4                    	xor	ah,ah ; 0			; set video mode
 49878 0000120B B002                    	mov	al,02h			; 80 X 25 text
 49879 0000120D CD10                    	int	10h
 49880                                  XMMcont:
 49881 0000120F B405                    	mov	ah,05h			; set display page
 49882 00001211 30C0                    	xor	al,al			; page 0
 49883 00001213 CD10                    	int	10h
 49884                                  	
 49885 00001215 BE[3A13]                	mov	si,XMMERRMSG
 49886 00001218 0E                      	push	cs
 49887 00001219 1F                      	pop	ds
 49888 0000121A FC                      	cld				; clear direction flag
 49889                                  XMMprnt:
 49890 0000121B AC                      	lodsb
 49891 0000121C 3C24                    	cmp	al,'$'			; indicates end of XMMERRMSG
 49892 0000121E 7409                    	jz	short XMMStall		; function 0Eh	
 49893 00001220 B40E                    	mov	ah,0Eh
 49894 00001222 BB0700                  	mov	bx,7
 49895 00001225 CD10                    	int	10h
 49896 00001227 EBF2                    	jmp	short XMMprnt
 49897                                  
 49898                                  XMMStall:
 49899 00001229 FB                      	sti				; allow the user to warm boot
 49900 0000122A EBFD                    	jmp	short XMMStall		; M006 - End
 49901                                  
 49902                                  ;---------------------------------------------------------------------------
 49903                                  
 49904                                  ; 27/04/2019 - Retro DOS v4.0
 49905                                  
 49906                                  ; retrodos4.s ; offset 0Ch in BIOS segment (0070h)
 49907                                  ALTAH	equ 0Ch
 49908                                  
 49909                                  ;This has been put in for WIN386 2.XX support. The format of the instance 
 49910                                  ;table was different for this. Segments will be patched in at init time.
 49911                                  
 49912                                  OldInstanceJunk:
 49913 0000122C 7000                    	dw	70h	;segment of BIOS
 49914 0000122E 0000                    	dw	0	;indicate stacks in SYSINIT area
 49915 00001230 0600                    	dw	6	;6 instance items
 49916                                  
 49917                                  	;dw	0,offset dosdata:contpos, 2
 49918                                  	;dw	0,offset dosdata:bcon, 4
 49919                                  	;dw	0,offset dosdata:carpos,106h
 49920                                  	;dw	0,offset dosdata:charco, 1
 49921                                  	;dw	0,offset dosdata:exec_init_sp, 34               ;M032
 49922                                  	;dw	070h,offset BData:altah, 1	 ; altah byte in bios
 49923                                  
 49924 00001232 0000[2200]0200          	dw	0,CONTPOS,2
 49925 00001238 0000[3200]0400          	dw	0,BCON,4
 49926 0000123E 0000[F901]0601          	dw	0,CARPOS,106h
 49927 00001244 0000[0003]0100          	dw	0,CHARCO,1
 49928 0000124A 0000[0510]2200          	dw	0,exec_init_SP,34
 49929 00001250 70000C000100            	dw	70h,ALTAH,1	; altah byte in bios
 49930                                  
 49931                                  ;---------------------------------------------------------------------------
 49932                                  
 49933                                  ; 17/01/2024
 49934                                  %if 0
 49935                                  
 49936                                  ; M021-
 49937                                  ;
 49938                                  ; DosHasHMA - This flag is set by seg_reinit when the DOS actually
 49939                                  ; 	takes control of the HMA. When running, this word is a reliable
 49940                                  ;	indicator that the DOS is actually using HMA. You can't just use
 49941                                  ;	CS, because ROMDOS uses HMA with CS < F000.
 49942                                  
 49943                                  DosHasHMA:
 49944                                  	db	0
 49945                                  FixExePatch:
 49946                                  	dw	0		; M012
 49947                                  
 49948                                  %endif
 49949                                  
 49950                                  ; 28/12/2022 - Retro DOS v4.1
 49951                                  ;RationalPatchPtr:
 49952                                  ;	dw	0		; M012
 49953                                  
 49954                                  ; End M021
 49955                                  
 49956                                  ;---------------------------------------------------------------------------
 49957                                  
 49958                                  ; 28/12/2022 - Retro DOS v4.1
 49959                                  %if 0
 49960                                  
 49961                                  ; M020 Begin
 49962                                  
 49963                                  RatBugCode:	; proc	far
 49964                                  	push	cx
 49965                                  	mov	cx,[10h]
 49966                                  rbc_loop:
 49967                                  	;loop	$
 49968                                  	loop	rbc_loop
 49969                                  	pop	cx
 49970                                  	retf
 49971                                  		
 49972                                  ; M020 End
 49973                                  
 49974                                  %endif
 49975                                  
 49976                                  ;---------------------------------------------------------------------------
 49977                                  	
 49978                                  UmbSave1:
 49979                                  	;db	11 dup (?)	; M023
 49980 00001256 00<rep Bh>              	times	11 db 0
 49981                                  
 49982                                  ;---------------------------------------------------------------------------
 49983                                  ; 16/01/2024 - Retrodos v5.0
 49984                                  ; PCDOS 7.1 IBMDOS.COM
 49985                                  ; DOSDATA: 113Ah
 49986                                  
 49987                                  OLD_FIRSTCLUS_HW:
 49988 00001261 0000                    	dw	0
 49989                                  
 49990                                  ; 17/01/2024 
 49991                                  %if 1
 49992                                  
 49993                                  ; DOS 3.3 F.C. 6/12/86
 49994                                  ; FASTOPEN communications area DOS 3.3   F.C. 5/29/86
 49995                                  
 49996                                  FastTable:				; a better name
 49997                                  FastOpenTable:
 49998 00001263 0200                    	dw      2                       ; number of entries
 49999 00001265 [9A18]                  	dw      FastRet			; pointer to ret instr.
 50000 00001267 0000                    	dw      0                       ; and will be modified by
 50001 00001269 [9A18]                  	dw      FastRet			; FASTxxx when loaded in
 50002 0000126B 0000                    	dw      0
 50003                                  
 50004                                  ; DOS 3.3 F.C. 6/12/86
 50005                                  
 50006                                  FastFlg:				; flags
 50007                                  FastOpenFlg:
 50008 0000126D 00                      	db	0			; don't change the foll: order
 50009                                  
 50010                                  %endif
 50011 0000126E 000000000000            	db	0,0,0,0,0,0
 50012                                  UNKNOWN1:
 50013 00001274 0000                    	dw	0
 50014 00001276 0000000000              	db	0,0,0,0,0
 50015                                  PATHNAMELEN:
 50016 0000127B 4300                    	dw	67
 50017                                   
 50018 0000127D 0000000000000000        	db	0,0,0,0,0,0,0,0
 50019 00001285 0000000000000000        	db	0,0,0,0,0,0,0,0
 50020 0000128D 0000000000000000        	db	0,0,0,0,0,0,0,0
 50021 00001295 00000000000000          	db	0,0,0,0,0,0,0
 50022                                  
 50023                                  ; 17/01/2024
 50024                                  ; DOSDATA:1175h
 50025                                  CurSC_DRIVE:
 50026 0000129C FF                      	db	-1  ; 0FFh	; current SC drive
 50027                                  
 50028                                  ;M044
 50029                                  ; Second part of save area for saving last para of Windows memory
 50030                                  
 50031                                  ; 17/01/2024
 50032                                  WinoldPatch2:
 50033                                  	;db	8 dup (?)	; M044
 50034 0000129D 00<rep 8h>              	times	8 db 0	
 50035                                  
 50036                                  FIRST_BUFF_ADDR:
 50037 000012A5 0000                    	dw	0
 50038                                  
 50039                                  ;----------------------------------------------------------------------------
 50040                                  ; 17/01/2024 - Retrodos v5.0
 50041                                  ; PCDOS 7.1 IBMDOS.COM
 50042                                  ; DOSDATA:1180h
 50043                                  
 50044                                  %if 1
 50045                                  
 50046                                  ;============================================================================
 50047                                  ; WPATCH.INC (MSDOS 6.0, 1991)  ;;; Windows 3.1 patches ;;;
 50048                                  ;============================================================================
 50049                                  ; 27/04/2019 - Retro DOS 4.0
 50050                                  
 50051                                  ; DOSDATA:12CFh (MSDOS 6.21, MSDOS.SYS)
 50052                                  
 50053                                  ; Retro DOS v5.0
 50054                                  ; PCDOS 7.1 IBMDOS.COM - DOSDATA:1180h	
 50055                                  
 50056                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 50057                                  ; DOSDATA:12CFh (MSDOS 5.0, MSDOS.SYS)
 50058                                  
 50059                                  ; first and second DOS patches
 50060                                  ;	Non-console device read/write (system calls 3Fh and 40h)
 50061                                  ;
 50062                                  ; Code in disk.asm, 2 locations, one for read, one for write
 50063                                  ;	DVRDLP:
 50064                                  ;	DVWRTLP:
 50065                                  ;
 50066                                  ;
 50067                                  ; 036h	lds	si,SS:[????]				  ; ThisSFT
 50068                                  ;	lds	si,si+7 				  ; sf_devptr
 50069                                  ; 0E8h	call	????		<- "simulate" int28 event ; DSKSTATCHK
 50070                                  
 50071 000012A7 36C536                  DOSP1_ID:	db	036h,0C5h,036h
 50072 000012AA 3605C57407E8            DOSP1_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
 50073                                  DOSP1_ID_LEN	equ	$-DOSP1_ID
 50074                                  
 50075 000012B0 9090                    		db	90h, 90h
 50076                                  
 50077 000012B2 36C536                  DOSP12_ID:	db	036h,0C5h,036h
 50078 000012B5 3605C57407E8            DOSP12_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
 50079                                  DOSP12_ID_LEN	equ	$-DOSP1_ID
 50080                                  
 50081                                  ; DOSDATA:12E3h
 50082                                  
 50083                                  ; Third/Fourth DOS patch - System call 3Fh (Read) from console
 50084                                  ;
 50085                                  ; Code in disk.asm, 1 location
 50086                                  ;	GETBUF:
 50087                                  ;
 50088                                  ; 051h	push	cx	<- begin special int28 mode
 50089                                  ;	push	es
 50090                                  ;	push	di
 50091                                  ;	mov	dx,???? ; offset dosgroup:CONBUF
 50092                                  ;	call	????	; $STD_CON_STRING_INPUT
 50093                                  ;	pop	di
 50094                                  ;	pop	es
 50095                                  ; 059h	pop	cx	<- end special int28 mode
 50096                                  
 50097 000012BB 510657BA                DOSP3_ID:	db	051h,006h,057h,0BAh
 50098 000012BF 2902E8                  DOSP3_CONBUF:	db	029h,002h,0E8h
 50099                                  DOSP3_ID_LEN	equ	$-DOSP3_ID
 50100 000012C2 9AE35F07                		db	09Ah,0E3h,05Fh,007h	; ???? , pop di, pop es
 50101 000012C6 59                      DOSP4_ID:	db	059h			; pop cx
 50102                                  DOSP4_ID_OFF	equ	(DOSP4_ID - DOSP3_ID)
 50103                                  	
 50104                                  ; DOSDATA:12EFh
 50105                                  
 50106                                  ; Fifth DOS patch - System call 40h (Write) to console
 50107                                  ;
 50108                                  ; Code in disk.asm, 1 location
 50109                                  ;
 50110                                  ;		push	cx
 50111                                  ;      WRCONLP: lodsb
 50112                                  ;		cmp	al,1Ah
 50113                                  ;		jz	????
 50114                                  ;		call	????	<- "simulate" int28 event
 50115                                  ;		loop	WRCONLP
 50116                                  ;      CONEOF:	pop	ax
 50117                                  
 50118 000012C7 51                      DOSP5_ID:	db	051h			; push cx
 50119 000012C8 AC3C1A7405              		db	0ACh,03Ch,01Ah,074h,005h
 50120 000012CD E8                      		db	0E8h			; call
 50121                                  DOSP5_ID_LEN	equ	$-DOSP5_ID
 50122                                  
 50123                                  ; DOSDATA:12F6h
 50124                                  
 50125                                  ; Seventh DOS patch - System call entry, patch USER_ID with VMid for share
 50126                                  ;
 50127                                  ; Code in disp.asm, 1 location
 50128                                  ;
 50129                                  ;
 50130                                  ;	mov [SaveDS],ds
 50131                                  ;	mov [SaveBX],bx
 50132                                  ;	mov bx,cs
 50133                                  ;	mov ds,bx
 50134                                  ;	inc [indos]
 50135                                  ;	xor ax,ax
 50136                                  ;	mov [USER_ID],AX	<- Patch to set USER_ID to VMID
 50137                                  
 50138 000012CE 2E8C1E                  DOSP7_ID:	db	02Eh,08Ch,01Eh
 50139 000012D1 7E05                    DOSP7_SAVEDS:	db	07Eh,05h		; mov [SaveDS],ds
 50140 000012D3 2E891E                  		db	02Eh,089h,01Eh
 50141 000012D6 7C05                    DOSP7_SAVEBX:	db	07Ch,05h		; mov [SaveBX],bx
 50142 000012D8 8CCB                    		db	08Ch,0CBh		; mov bx,cs
 50143 000012DA 8EDB                    		db	08Eh,0DBh		; mov ds,bx
 50144 000012DC FE06                    		db	0FEh,006h
 50145 000012DE CF02                    DOSP7_INDOS:	db	0CFh,002h		; inc [indos]
 50146 000012E0 33C0                    		db	033h,0C0h		; xor ax,ax
 50147                                  DOSP7_ID_LEN	equ	$-DOSP7_ID
 50148                                  
 50149                                  ; DOSDATA:130Ah
 50150                                  
 50151                                  ; Eighth DOS patch - OWNER check in handle calls. For share, need to NOP test
 50152                                  ;
 50153                                  ; Code in handle.asm, 1 location in routine CheckOwner
 50154                                  ;
 50155                                  ;
 50156                                  ;
 50157                                  ;	push	ax
 50158                                  ;	mov	ax,ss:[USER_ID]     <- patch to XOR AX,AX to set zero
 50159                                  ;	cmp	ax,es:[di.sf_UID]   <- NOP
 50160                                  ;	pop	ax
 50161                                  ;	jz	????
 50162                                  
 50163 000012E2 50                      DOSP8_ID:	db	050h			; push ax
 50164 000012E3 36A1                    		db	036h,0A1h
 50165 000012E5 EA02                    DOSP8_USER_ID:	db	0EAh,002h		; mov  ax,ss:[USER_ID]
 50166 000012E7 263B45                  		db	026h,03Bh,045h		; cmp  ax,es:[di+2F]
 50167                                  DOSP8_ID_LEN	equ	$-DOSP8_ID
 50168 000012EA 2F58                    		db	02Fh,058h		; pop  ax
 50169                                  
 50170                                  ; DOSDATA:1314h
 50171                                  
 50172                                  ; 10th, 11th, 12th DOS patch - System call 3Fh (Read) in raw mode
 50173                                  ;
 50174                                  ;   Take RAW read to STDIN SFT and turn it into a polling loop doing
 50175                                  ;   a yeild when a character is not ready to be read.
 50176                                  ;
 50177                                  ; Code in disk.asm, 3 locations
 50178                                  ;
 50179                                  ;   DVRDRAW:
 50180                                  ;	    PUSH    ES
 50181                                  ;	    POP     DS
 50182                                  ;   ReadRawRetry:				<- Patch 10
 50183                                  ;	    MOV     BX,DI
 50184                                  ;	    XOR     AX,AX			<- Reenter #2
 50185                                  ;	    MOV     DX,AX
 50186                                  ;	    call    SETREAD
 50187                                  ;	    PUSH    DS				<- Reenter #1
 50188                                  ;	    LDS     SI,[THISSFT]
 50189                                  ;	    call    DEVIOCALL
 50190                                  ;	    MOV     DX,DI
 50191                                  ;	    MOV     AH,86H
 50192                                  ;	    MOV     DI,[DEVCALL.REQSTAT]
 50193                                  ;	    TEST    DI,STERR
 50194                                  ;	    JZ	    CRDROK
 50195                                  ;	    call    CHARHARD
 50196                                  ;	    MOV     DI,DX
 50197                                  ;	    OR	    AL,AL
 50198                                  ;	    JZ	    CRDROK
 50199                                  ;	    CMP     AL,3
 50200                                  ;	    JZ	    CRDFERR
 50201                                  ;	    POP     DS
 50202                                  ;	    JMP     ReadRawRetry
 50203                                  ;
 50204                                  ;   CRDFERR:
 50205                                  ;	    POP     DI				<- Patch 11
 50206                                  ;   DEVIOFERR:
 50207                                  ;	    LES     DI,[THISSFT]
 50208                                  ;	    jmp     SET_ACC_ERR_DS
 50209                                  ;
 50210                                  ;   CRDROK:
 50211                                  ;	    POP     DI				<- Patch 12
 50212                                  ;	    MOV     DI,DX
 50213                                  ;	    ADD     DI,[CALLSCNT]
 50214                                  ;	    JMP     SHORT ENDRDDEVJ3
 50215                                  
 50216 000012EC 061F                    DOSP10_ID:		db	006H,01FH
 50217                                  DOSP10_LOC_OFFSET	equ	$-DOSP10_ID
 50218 000012EE 8BDF                    DOSP10_LOC:		db	08BH,0DFH
 50219                                  DOSP10_REENT2_OFFSET	equ	$-DOSP10_LOC
 50220 000012F0 33C08BD0E8              			db	033H,0C0H,08BH,0D0H,0E8H
 50221                                  DOSP10_ID_LEN		equ	$-DOSP10_ID
 50222 000012F5 DF0E                    			db	0DFH,00EH
 50223                                  DOSP10_REENT1_OFFSET	equ	$-DOSP10_LOC
 50224 000012F7 1E36C5363605E8AF0E      			db	01EH,036H,0C5H,036H,036H,005H,0E8H,0AFH,00EH
 50225 00001300 8BD7B486368B3E          			db	08BH,0D7H,0B4H,086H,036H,08BH,03EH
 50226                                  DOSP10_PACKVAL_OFFSET	equ	$-DOSP10_ID
 50227 00001307 0903                    			db	009H,003H
 50228 00001309 F7C700807419E84717      			db	0F7H,0C7H,000H,080H,074H,019H,0E8H,047H,017H
 50229 00001312 8BFA0AC074103C0374-     			db	08BH,0FAH,00AH,0C0H,074H,010H,03CH,003H,074H,003H
 50229 0000131B 03                 
 50230 0000131C 1FEBCF                  			db	01FH,0EBH,0CFH
 50231                                  DOSP11_LOC_OFFSET	equ	$-DOSP10_ID
 50232 0000131F 5F                      			db	05FH
 50233                                  DOSP11_REENT_OFFSET	equ	$-DOSP10_LOC
 50234 00001320 36C43E3605E9A104        			db	036H,0C4H,03EH,036H,005H,0E9H,0A1H,004H
 50235                                  
 50236                                  DOSP12_LOC_OFFSET	equ	$-DOSP10_ID
 50237 00001328 5F8BFA                  			db	05FH,08BH,0FAH
 50238                                  ; DOSDATA:1353h
 50239                                  
 50240                                  ; 13th DOS patch - Actually a SYSINIT patch. Patches the stack fault code
 50241                                  ;		which prints the fatal stack fault error on DOS >= 3.20.
 50242                                  ;
 50243                                  ;	    Sets focus to current VM so user can see fatal message.
 50244                                  ;
 50245                                  ;
 50246                                  ;	l0: lodsb		<- Setfocus here
 50247                                  ;	    cmp al, '$'
 50248                                  ;	    je l1
 50249                                  ;	    mov bl, 7
 50250                                  ;	    mov ah, 0Eh
 50251                                  ;	    int 10h
 50252                                  ;	    jmp l0
 50253                                  ;	l1: jmp $
 50254                                  
 50255 0000132B AC                      DOSP13_ID:	db	0ACh			; l0: lodsb
 50256 0000132C 3C24                    		db	03Ch,024h		;     cmp al, '$'
 50257 0000132E 7408                    		db	074h,008h		;     je l1
 50258 00001330 B307                    		db	0B3h,007h		;     mov bl, 7
 50259 00001332 B40E                    		db	0B4h,00Eh		;     mov ah, 0Eh
 50260 00001334 CD10                    		db	0CDh,010h		;     int 10h
 50261 00001336 EBF3                    		db	0EBh,0F3h		;     jmp l0
 50262 00001338 EBFE                    		db	0EBh,0FEh		; l1: jmp $
 50263                                  DOSP13_ID_LEN	equ	$-DOSP13_ID
 50264                                  
 50265                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 50266                                  ; DOSDATA:1362h (MSDOS 5.0 MSDOS.SYS)
 50267                                  
 50268                                  ; 05/01/2024
 50269                                  %endif	; 05/11/2022
 50270                                  
 50271                                  ;----------------------------------------------------------------------------
 50272                                  
 50273                                  ; DOSDATA:122Ah
 50274                                  
 50275                                  Mark3:	; label byte
 50276                                  
 50277                                  ;IF2
 50278                                  ;	IF ((OFFSET MARK3) GT (OFFSET COUNTRY_CDPG) )
 50279                                  ;		%OUT !DATA CORRUPTION!MARK3 OFFSET TOO BIG. RE-ORGANIZE DATA.
 50280                                  ;	ENDIF
 50281                                  ;ENDIF
 50282                                  
 50283                                  ;----------------------------------------------------------------------------
 50284                                  
 50285                                  ; 27/04/2019 - Retro DOS v4.0
 50286                                  ; 05/01/2024 - Retro DOS v5.0
 50287                                  
 50288                                  ;include msdos.cl2			; XMMERRMSG
 50289                                  
 50290                                  ; DOSDATA:12B8h (MSDOS 6.22, MSDOS.SYS) ; 17/01/2024
 50291                                  ; DOSDATA:1213h (PCDOS 7.1, IBMDOS.COM) ; 05/01/2024
 50292                                  
 50293                                  XMMERRMSG:
 50294 0000133A 0D0A                    	db	0Dh,0Ah
 50295 0000133C 413230204861726477-     	db	'A20 Hardware Error',0Dh,0Ah,'$'
 50295 00001345 617265204572726F72-
 50295 0000134E 0D0A24             
 50296                                  
 50297                                  ;----------------------------------------------------------------------------
 50298                                  ; 17/01/2024 - Note: COUNTRY_CDPG must be at DOSDATA:122Ah (to 12B8h) addr
 50299                                  ; It is fixed at 122Ah in PCDOS 7.1 IBMDOS.COM and MSDOS 5.0-6.22 MSDOS.SYS					
 50300                                  ;----------------------------------------------------------------------------
 50301                                  
 50302                                  ;############################################################################
 50303                                  ;
 50304                                  ; ** HACK FOR DOS 4.0 REDIR **
 50305                                  ;
 50306                                  ; The dos 4.X redir requires that country_cdpg is at offset 0122ah. Any new
 50307                                  ; data variable that is to be added to DOSDATA must go in between Mark3
 50308                                  ; COUNTRY_CDPG if it can. 
 50309                                  ;
 50310                                  ; MARK3 SHOULD NOT BE > 122AH 
 50311                                  ;
 50312                                  ; As of 9/6/90, this area is FULL!
 50313                                  ;
 50314                                  ;############################################################################
 50315                                   
 50316                                  	;ORG	0122Ah
 50317                                  
 50318                                  ; DOSDATA:122Ah (MSDOS 6.21, MSDOS.SYS)
 50319                                  
 50320                                  ; 09/01/2024 - Retro DOS v5.0
 50321                                  ; PCDOS 7.1 IBMDOS.COM - DOSDATA:122Ah
 50322                                  
 50323                                  ; 17/01/2024
 50324                                  ; MSDOS 5.0  MSDOS.SYS - DOSDATA:122Ah
 50325                                  ; MSDOS 6.22 MSDOS.SYS - DOSDATA:122Ah
 50326                                  
 50327                                  ; The following table is used for DOS 3.3
 50328                                  ;DOS country and code page information is defined here for DOS 3.3.
 50329                                  ;The initial value for ccDosCountry is 1 (USA).
 50330                                  ;The initial value for ccDosCodepage is 850.
 50331                                  
 50332                                  ; country and code page information
 50333                                  ; ---------------------------------------------------------------------------
 50334                                  COUNTRY_CDPG:	; label  byte
 50335 00001351 0000000000000000        	db   0,0,0,0,0,0,0,0		; reserved words
 50336 00001359 5C434F554E5452592E-     	db   '\COUNTRY.SYS',0		; path name of country.sys
 50336 00001362 53595300           
 50337                                  	;db   51 dup (?)
 50338 00001366 00<rep 33h>             	times 51 db 0
 50339                                  ; ------------------------------------------------<MSKK01>-------------------
 50340                                  ;ifdef	DBCS
 50341                                  ;  ifdef JAPAN
 50342                                  ;	dw   932			; system code page id (JAPAN)
 50343                                  ;  endif
 50344                                  ;  ifdef TAIWAN
 50345                                  ;	dw   938			; system code page id (TAIWAN)
 50346                                  ;  endif
 50347                                  ;  ifdef KOREA
 50348                                  ;	dw   934			; system code page id (KOREA IBM)
 50349                                  ;  endif
 50350                                  ;else
 50351 00001399 B501                    	dw   437			; system code page id
 50352                                  ;endif
 50353                                  ; ------------------------------------------------<MSKK01>-------------------
 50354 0000139B 0600                    	dw   6				; number of entries
 50355                                  COUNTRY_CDPG_76: ; COUNTRY_CDPG + 76 
 50356 0000139D 02                      	db   SetUcase  ; 2		; Ucase type
 50357 0000139E [010B]                  	dw   UCASE_TAB			;pointer to upper case table
 50358 000013A0 0000                    	dw   0				; segment of poiter
 50359 000013A2 04                      	db   SetUcaseFile  ; 4		; Ucase file char type
 50360 000013A3 [830B]                  	dw   FILE_UCASE_TAB 		;pointer to file upper case table
 50361 000013A5 0000                    	dw   0				; segment of poiter
 50362 000013A7 05                      	db   SetFileList ; 5		; valid file chars type
 50363 000013A8 [050C]                  	dw   FILE_CHAR_TAB 		;pointer to valid file char tab
 50364 000013AA 0000                    	dw   0				; segment of poiter
 50365 000013AC 06                      	db   SetCollate	; 6		; collate type
 50366 000013AD [350C]                  	dw   COLLATE_TAB		;pointer to collate table
 50367 000013AF 0000                    	dw   0				; segment of poiter
 50368 000013B1 07                      	db   SetDBCS	; 7		;AN000; DBCS Ev			2/12/KK
 50369 000013B2 [370D]                  	dw   DBCS_TAB			;AN000;pointer to DBCS Ev table	2/12/KK
 50370 000013B4 0000                    	dw   0				;AN000; segment of pointer	2/12/KK
 50371 000013B6 01                      	db   SetCountryInfo  ; 1	; country info type
 50372 000013B7 2600                    	dw   NEW_COUNTRY_SIZE		; extended country info size
 50373                                  ; ------------------------------------------------<MSKK01>-------------------
 50374                                  ;ifdef	DBCS
 50375                                  ;	...... 
 50376                                  ;else
 50377                                  	; 09/01/2024 - Retro DOS v5.0
 50378                                  	; PCDOS 7.1 IBMDOS.COM - DOSDATA:1292h
 50379                                  _COUNTRY_ID:
 50380 000013B9 0100                    	dw   1				; USA country id
 50381 000013BB B501                    	dw   437			; USA system code page id
 50382                                  COUNTRY_CDPG_108: ; COUNTRY_CDPG + 108	
 50383 000013BD 0000                    	dw   0 				; date format
 50384 000013BF 2400000000              	db   '$',0,0,0,0		; currency symbol
 50385 000013C4 2C00                    	db   ',',0			; thousand separator
 50386 000013C6 2E00                    	db   '.',0			; decimal separator
 50387 000013C8 2D00                    	db   '-',0			; date separator
 50388 000013CA 3A00                    	db   ':',0			; time separator
 50389 000013CC 00                      	db   0				; currency format flag
 50390 000013CD 02                      	db   2				; # of digits in currency
 50391 000013CE 00                      	db   0 				; time format
 50392 000013CF [490D]                  	dw   MAP_CASE			; mono case routine entry point
 50393 000013D1 0000                    	dw   0				; segment of entry point
 50394 000013D3 2C00                    	db   ',',0			; data list separator
 50395 000013D5 000000000000000000-     	dw   0,0,0,0,0			; reserved
 50395 000013DE 00                 
 50396                                  ;endif
 50397                                  ; ------------------------------------------------<MSKK01>-------------------
 50398                                  
 50399                                  ;----------------------------------------------------------------------------
 50400                                  ; 01/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
 50401                                  
 50402                                  ; PCDOS 7.1 IBMDOS.COM - DOSDATA:12B8h
 50403                                  
 50404                                  INDOS_FLAG:
 50405 000013DF 00                      	db 0		; duplicated INDOS flag, what for ? 
 50406                                  			; (PCDOS 7.1 kernel CODE always updates it together
 50407                                  			; with 'INDOS' flag !?)
 50408                                  ; 09/01/2024
 50409                                  DEVIO_IN_PROGRESS:
 50410 000013E0 00                      	db 0
 50411                                  
 50412                                  ; 09/01/2024
 50413                                  ; PCDOS 7.1 IBMDOS.COM - DOSDATA:12BAh
 50414                                  ; ----------
 50415                                  ; INTERNATIONALIZATION INFORMATION
 50416                                  ;	 for Get/Set Extended Country Info functions
 50417                                  
 50418 000013E1 454E5500                _ENU:	db 'ENU',0
 50419 000013E5 55534100                _USA:	db 'USA',0
 50420 000013E9 5553                    _US:	db 'US'
 50421 000013EB 0100                    	dw 1
 50422 000013ED 0200                    	dw 2
 50423 000013EF 0000                    	dw 0
 50424 000013F1 414D00                  _AM:	db 'AM',0
 50425 000013F4 504D00                  _PM:	db 'PM',0
 50426                                  _MMDDYY:
 50427 000013F7 4D2F642F7979202020-     	db 'M/d/yy     dddd,MMMMdd,yyyy         '
 50427 00001400 2020646464642C4D4D-
 50427 00001409 4D4D64642C79797979-
 50427 00001412 202020202020202020 
 50428 0000141B 00                      	db 0
 50429 0000141C 00                      	db 0
 50430 0000141D 0000                    	dw 0
 50431                                  
 50432                                  ; 09/01/2024
 50433                                  ; PCDOS 7.1 IBMDOS.COM - DOSDATA:12F8h
 50434                                  
 50435                                  VxDpath:
 50436 0000141F 633A5C77696E613230-     	db 'c:\wina20.386',0
 50436 00001428 2E33383600         
 50437 0000142D 0000                    	dw 0
 50438                                  
 50439                                  ; 09/01/2024
 50440                                  ; PCDOS 7.1 IBMDOS.COM - DOSDATA:1308h
 50441                                  
 50442                                  drive_flags:
 50443 0000142F 00<rep 1Ah>             	times 26 db 0
 50444                                  		 
 50445 00001449 01                              db 1
 50446                                  BiosComBlockPtr:
 50447 0000144A 0000<rep 2h>            	times 2 dw 0
 50448 0000144E 00<rep 5h>              	times 5 db 0
 50449 00001453 0400                    	dw 4
 50450 00001455 [DF13]                  	dw INDOS_FLAG
 50451 00001457 [2F14]                  	dw drive_flags
 50452 00001459 [5D14]                  	dw NLS_YES	; "YN"
 50453 0000145B [6114]                  	dw unknown_zero_dd
 50454                                  NLS_YES:
 50455 0000145D 59                      	db 'Y'
 50456 0000145E 4E                      NLS_NO:	db 'N'
 50457                                  NLS_yes2:
 50458 0000145F 79                      	db 'y'
 50459                                  NLS_no2:
 50460 00001460 6E                      	db 'n'
 50461                                  
 50462                                  unknown_zero_dd:
 50463 00001461 00000000                	dd 0
 50464                                  
 50465                                  ; ---------------------------------------------------------------------------
 50466                                  
 50467                                  ; 27/04/2019 - Retro DOS v4.0
 50468                                  
 50469                                  ;include msdos.cl2			; XMMERRMSG
 50470                                  
 50471                                  ; DOSDATA:12B8h (MSDOS 6.21, MSDOS.SYS)
 50472                                  
 50473                                  ;XMMERRMSG:
 50474                                  ;	db	0Dh,0Ah
 50475                                  ;	db	'A20 Hardware Error',0Dh,0Ah,'$'
 50476                                  
 50477                                  ; DOSDATA ends
 50478                                  
 50479                                  ; 05/11/2022
 50480                                  ;----------------------------------------------------------------------------
 50481                                  ; End of MSDOS 5.0 MSDOS.SYS /// Retro DOS v4.0 (2022) - 05/11/2022
 50482                                  ;----------------------------------------------------------------------------
 50483                                  
 50484                                  ; 28/12/2022 - Retro DOS v4.1
 50485                                  ; (windows 3.1 and Rational Extender patches are removed/disabled)
 50486                                  ; (Windows 3.1 does not use the patches below if DOS version is MSDOS 5.0)
 50487                                  ;----------------------------------------------------------------------------
 50488                                  %if 0
 50489                                  
 50490                                  ;----------------------------------------------------------------------------
 50491                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 50492                                  
 50493                                  ;============================================================================
 50494                                  ; WPATCH.INC (MSDOS 6.0, 1991)  ;;; Windows 3.1 patches ;;;
 50495                                  ;============================================================================
 50496                                  ; 27/04/2019 - Retro DOS 4.0
 50497                                  
 50498                                  ;DOSDATA Segment
 50499                                  
 50500                                  ; DOSDATA:12CFh (MSDOS 6.21, MSDOS.SYS)
 50501                                  
 50502                                  ; Retro DOS v5.0
 50503                                  ; PCDOS 7.1 IBMDOS.COM - DOSDATA:1180h	
 50504                                  
 50505                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 50506                                  ; DOSDATA:12CFh (MSDOS 5.0, MSDOS.SYS)
 50507                                  
 50508                                  ; first and second DOS patches
 50509                                  ;	Non-console device read/write (system calls 3Fh and 40h)
 50510                                  ;
 50511                                  ; Code in disk.asm, 2 locations, one for read, one for write
 50512                                  ;	DVRDLP:
 50513                                  ;	DVWRTLP:
 50514                                  ;
 50515                                  ;
 50516                                  ; 036h	lds	si,SS:[????]				  ; ThisSFT
 50517                                  ;	lds	si,si+7 				  ; sf_devptr
 50518                                  ; 0E8h	call	????		<- "simulate" int28 event ; DSKSTATCHK
 50519                                  
 50520                                  DOSP1_ID:	db	036h,0C5h,036h
 50521                                  DOSP1_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
 50522                                  DOSP1_ID_LEN	equ	$-DOSP1_ID
 50523                                  
 50524                                  		db	90h, 90h
 50525                                  
 50526                                  DOSP12_ID:	db	036h,0C5h,036h
 50527                                  DOSP12_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
 50528                                  DOSP12_ID_LEN	equ	$-DOSP1_ID
 50529                                  
 50530                                  ; DOSDATA:12E3h
 50531                                  
 50532                                  ; Third/Fourth DOS patch - System call 3Fh (Read) from console
 50533                                  ;
 50534                                  ; Code in disk.asm, 1 location
 50535                                  ;	GETBUF:
 50536                                  ;
 50537                                  ; 051h	push	cx	<- begin special int28 mode
 50538                                  ;	push	es
 50539                                  ;	push	di
 50540                                  ;	mov	dx,???? ; offset dosgroup:CONBUF
 50541                                  ;	call	????	; $STD_CON_STRING_INPUT
 50542                                  ;	pop	di
 50543                                  ;	pop	es
 50544                                  ; 059h	pop	cx	<- end special int28 mode
 50545                                  
 50546                                  DOSP3_ID:	db	051h,006h,057h,0BAh
 50547                                  DOSP3_CONBUF:	db	029h,002h,0E8h
 50548                                  DOSP3_ID_LEN	equ	$-DOSP3_ID
 50549                                  		db	09Ah,0E3h,05Fh,007h	; ???? , pop di, pop es
 50550                                  DOSP4_ID:	db	059h			; pop cx
 50551                                  DOSP4_ID_OFF	equ	(DOSP4_ID - DOSP3_ID)
 50552                                  	
 50553                                  ; DOSDATA:12EFh
 50554                                  
 50555                                  ; Fifth DOS patch - System call 40h (Write) to console
 50556                                  ;
 50557                                  ; Code in disk.asm, 1 location
 50558                                  ;
 50559                                  ;		push	cx
 50560                                  ;      WRCONLP: lodsb
 50561                                  ;		cmp	al,1Ah
 50562                                  ;		jz	????
 50563                                  ;		call	????	<- "simulate" int28 event
 50564                                  ;		loop	WRCONLP
 50565                                  ;      CONEOF:	pop	ax
 50566                                  
 50567                                  DOSP5_ID:	db	051h			; push cx
 50568                                  		db	0ACh,03Ch,01Ah,074h,005h
 50569                                  		db	0E8h			; call
 50570                                  DOSP5_ID_LEN	equ	$-DOSP5_ID
 50571                                  
 50572                                  ; DOSDATA:12F6h
 50573                                  
 50574                                  ; Seventh DOS patch - System call entry, patch USER_ID with VMid for share
 50575                                  ;
 50576                                  ; Code in disp.asm, 1 location
 50577                                  ;
 50578                                  ;
 50579                                  ;	mov [SaveDS],ds
 50580                                  ;	mov [SaveBX],bx
 50581                                  ;	mov bx,cs
 50582                                  ;	mov ds,bx
 50583                                  ;	inc [indos]
 50584                                  ;	xor ax,ax
 50585                                  ;	mov [USER_ID],AX	<- Patch to set USER_ID to VMID
 50586                                  
 50587                                  DOSP7_ID:	db	02Eh,08Ch,01Eh
 50588                                  DOSP7_SAVEDS:	db	07Eh,05h		; mov [SaveDS],ds
 50589                                  		db	02Eh,089h,01Eh
 50590                                  DOSP7_SAVEBX:	db	07Ch,05h		; mov [SaveBX],bx
 50591                                  		db	08Ch,0CBh		; mov bx,cs
 50592                                  		db	08Eh,0DBh		; mov ds,bx
 50593                                  		db	0FEh,006h
 50594                                  DOSP7_INDOS:	db	0CFh,002h		; inc [indos]
 50595                                  		db	033h,0C0h		; xor ax,ax
 50596                                  DOSP7_ID_LEN	equ	$-DOSP7_ID
 50597                                  
 50598                                  ; DOSDATA:130Ah
 50599                                  
 50600                                  ; Eighth DOS patch - OWNER check in handle calls. For share, need to NOP test
 50601                                  ;
 50602                                  ; Code in handle.asm, 1 location in routine CheckOwner
 50603                                  ;
 50604                                  ;
 50605                                  ;
 50606                                  ;	push	ax
 50607                                  ;	mov	ax,ss:[USER_ID]     <- patch to XOR AX,AX to set zero
 50608                                  ;	cmp	ax,es:[di.sf_UID]   <- NOP
 50609                                  ;	pop	ax
 50610                                  ;	jz	????
 50611                                  
 50612                                  DOSP8_ID:	db	050h			; push ax
 50613                                  		db	036h,0A1h
 50614                                  DOSP8_USER_ID:	db	0EAh,002h		; mov  ax,ss:[USER_ID]
 50615                                  		db	026h,03Bh,045h		; cmp  ax,es:[di+2F]
 50616                                  DOSP8_ID_LEN	equ	$-DOSP8_ID
 50617                                  		db	02Fh,058h		; pop  ax
 50618                                  
 50619                                  ; DOSDATA:1314h
 50620                                  
 50621                                  ; 10th, 11th, 12th DOS patch - System call 3Fh (Read) in raw mode
 50622                                  ;
 50623                                  ;   Take RAW read to STDIN SFT and turn it into a polling loop doing
 50624                                  ;   a yeild when a character is not ready to be read.
 50625                                  ;
 50626                                  ; Code in disk.asm, 3 locations
 50627                                  ;
 50628                                  ;   DVRDRAW:
 50629                                  ;	    PUSH    ES
 50630                                  ;	    POP     DS
 50631                                  ;   ReadRawRetry:				<- Patch 10
 50632                                  ;	    MOV     BX,DI
 50633                                  ;	    XOR     AX,AX			<- Reenter #2
 50634                                  ;	    MOV     DX,AX
 50635                                  ;	    call    SETREAD
 50636                                  ;	    PUSH    DS				<- Reenter #1
 50637                                  ;	    LDS     SI,[THISSFT]
 50638                                  ;	    call    DEVIOCALL
 50639                                  ;	    MOV     DX,DI
 50640                                  ;	    MOV     AH,86H
 50641                                  ;	    MOV     DI,[DEVCALL.REQSTAT]
 50642                                  ;	    TEST    DI,STERR
 50643                                  ;	    JZ	    CRDROK
 50644                                  ;	    call    CHARHARD
 50645                                  ;	    MOV     DI,DX
 50646                                  ;	    OR	    AL,AL
 50647                                  ;	    JZ	    CRDROK
 50648                                  ;	    CMP     AL,3
 50649                                  ;	    JZ	    CRDFERR
 50650                                  ;	    POP     DS
 50651                                  ;	    JMP     ReadRawRetry
 50652                                  ;
 50653                                  ;   CRDFERR:
 50654                                  ;	    POP     DI				<- Patch 11
 50655                                  ;   DEVIOFERR:
 50656                                  ;	    LES     DI,[THISSFT]
 50657                                  ;	    jmp     SET_ACC_ERR_DS
 50658                                  ;
 50659                                  ;   CRDROK:
 50660                                  ;	    POP     DI				<- Patch 12
 50661                                  ;	    MOV     DI,DX
 50662                                  ;	    ADD     DI,[CALLSCNT]
 50663                                  ;	    JMP     SHORT ENDRDDEVJ3
 50664                                  
 50665                                  DOSP10_ID:		db	006H,01FH
 50666                                  DOSP10_LOC_OFFSET	equ	$-DOSP10_ID
 50667                                  DOSP10_LOC:		db	08BH,0DFH
 50668                                  DOSP10_REENT2_OFFSET	equ	$-DOSP10_LOC
 50669                                  			db	033H,0C0H,08BH,0D0H,0E8H
 50670                                  DOSP10_ID_LEN		equ	$-DOSP10_ID
 50671                                  			db	0DFH,00EH
 50672                                  DOSP10_REENT1_OFFSET	equ	$-DOSP10_LOC
 50673                                  			db	01EH,036H,0C5H,036H,036H,005H,0E8H,0AFH,00EH
 50674                                  			db	08BH,0D7H,0B4H,086H,036H,08BH,03EH
 50675                                  DOSP10_PACKVAL_OFFSET	equ	$-DOSP10_ID
 50676                                  			db	009H,003H
 50677                                  			db	0F7H,0C7H,000H,080H,074H,019H,0E8H,047H,017H
 50678                                  			db	08BH,0FAH,00AH,0C0H,074H,010H,03CH,003H,074H,003H
 50679                                  			db	01FH,0EBH,0CFH
 50680                                  DOSP11_LOC_OFFSET	equ	$-DOSP10_ID
 50681                                  			db	05FH
 50682                                  DOSP11_REENT_OFFSET	equ	$-DOSP10_LOC
 50683                                  			db	036H,0C4H,03EH,036H,005H,0E9H,0A1H,004H
 50684                                  
 50685                                  DOSP12_LOC_OFFSET	equ	$-DOSP10_ID
 50686                                  			db	05FH,08BH,0FAH
 50687                                  ; DOSDATA:1353h
 50688                                  
 50689                                  ; 13th DOS patch - Actually a SYSINIT patch. Patches the stack fault code
 50690                                  ;		which prints the fatal stack fault error on DOS >= 3.20.
 50691                                  ;
 50692                                  ;	    Sets focus to current VM so user can see fatal message.
 50693                                  ;
 50694                                  ;
 50695                                  ;	l0: lodsb		<- Setfocus here
 50696                                  ;	    cmp al, '$'
 50697                                  ;	    je l1
 50698                                  ;	    mov bl, 7
 50699                                  ;	    mov ah, 0Eh
 50700                                  ;	    int 10h
 50701                                  ;	    jmp l0
 50702                                  ;	l1: jmp $
 50703                                  
 50704                                  DOSP13_ID:	db	0ACh			; l0: lodsb
 50705                                  		db	03Ch,024h		;     cmp al, '$'
 50706                                  		db	074h,008h		;     je l1
 50707                                  		db	0B3h,007h		;     mov bl, 7
 50708                                  		db	0B4h,00Eh		;     mov ah, 0Eh
 50709                                  		db	0CDh,010h		;     int 10h
 50710                                  		db	0EBh,0F3h		;     jmp l0
 50711                                  		db	0EBh,0FEh		; l1: jmp $
 50712                                  DOSP13_ID_LEN	equ	$-DOSP13_ID
 50713                                  
 50714                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 50715                                  ; DOSDATA:1362h (MSDOS 5.0 MSDOS.SYS)
 50716                                  
 50717                                  ; 06/12/2022
 50718                                  ;DOSDATASIZE	equ  $ - DOSDATASTART ; 4962 bytes (1362h)
 50719                                  
 50720                                  ; DOSDATA ends
 50721                                  
 50722                                  ; 05/01/2024
 50723                                  %endif	; 05/11/2022
 50724                                  
 50725                                  ;============================================================================
 50726                                  ; MPATCH.ASM (MSDOS 6.0, 1993)
 50727                                  ;============================================================================
 50728                                  ; 27/04/2019 - Retro DOS 4.0
 50729                                  
 50730                                  ;mpatch.asm -- holds data patch location for callouts 
 50731                                  ; -- allocate cluster in rom.asm
 50732                                  ;
 50733                                  ; This area is pointed to by OffsetMagicPatch[609h] in fixed DOS data.
 50734                                  ; Currently, this location is used only by magicdrv.sys's patch to
 50735                                  ; cluster allocation, however it can be expanded to be used by other
 50736                                  ; patches. This is important since we have an easy-access pointer to
 50737                                  ; this location in OffsetMagicPatch. Magicdrv.sys is guaranteed to
 50738                                  ; only patch out a far call/retf, so any space after that could be
 50739                                  ; used as a patch by using OffsetMagicPatch+6. See rom.asm on how
 50740                                  ; to call out here.
 50741                                  ;
 50742                                  ; Currently, we allocate only the minimum space required for the 6
 50743                                  ; byte magicdrv patch, so if you change the dos data, you may want
 50744                                  ; to reserve space here if your new data will be position dependent
 50745                                  ; and would prohibit growing of this table.
 50746                                  ;       
 50747                                  ;history	-	created 8-7-92 by scottq
 50748                                  ;		-	added Rational386PatchPtr 2-1-93 by jimmat
 50749                                  ;
 50750                                  ;Exported Functions
 50751                                  ;==================
 50752                                  ;MagicPatch     -       callout patched by magidrv.sys for cluster allocations
 50753                                  
 50754                                  ; DosData Segment
 50755                                  
 50756                                  ; DOSDATA:1362h (MSDOS 6.21, MSDOS.SYS)
 50757                                  
 50758                                  ; ---------------------------------------------------------------------------
 50759                                  
 50760                                  ; Rational386PatchPtr points to either a RET instruction (80286 or less) or
 50761                                  ; a routine to fix buggy versions of the Rational DOS Extender (80386 or
 50762                                  ; greater). Added to this file because it needed to be somewhere and is
 50763                                  ; 'patch' related.
 50764                                  
 50765                                  Rational386PatchPtr:
 50766 00001465 0000                    	dw	0	; points to patch routine or RET instr.
 50767                                  ; ---------------------------------------------------------------------------
 50768                                  
 50769                                  MagicPatch:
 50770                                  ;MagicPatch proc far
 50771 00001467 CB                              retf            ;default is to just return to allocate
 50772 00001468 90                              nop             ;however, this code will be patched
 50773 00001469 90                              nop             ;by magicdrv.sys to
 50774 0000146A 90                              nop             ; call far ?:?     
 50775 0000146B 90                              nop             ; retf or perhaps just jmp far
 50776 0000146C 90                              nop             ;retf/nop take one byte, so we need six instructions
 50777                                                          ;for 6 byte patch
 50778                                  ;MagicPatch endp
 50779                                  
 50780                                  ; ---------------------------------------------------------------------------
 50781                                  
 50782                                  ;DosData Ends
 50783                                  
 50784                                  ; DOSDATA:136Ah
 50785                                  
 50786                                  ;----------------------------------------------------------------------------
 50787                                  
 50788                                  ;DOSDATALAST SEGMENT
 50789                                  
 50790                                  ; 29/04/2019 - Retro DOS v4.0
 50791                                  
 50792                                  ;----------------------------------------------------------------------------
 50793                                  ; 25/05/2019 - Retro DOS v4.0 Modification (paragraph alignment)
 50794                                  
 50795                                  ;db 0,1,12,64,19,0 ; ! Magic numbers !
 50796                                  
 50797                                  ;align 16
 50798                                  
 50799                                  ; !!! DOSDATA:1370h ; Retro DOS v4.0 only!
 50800                                  
 50801                                  ;----------------------------------------------------------------------------
 50802                                  
 50803                                  ; 05/01/2024
 50804                                  ;%endif	; 05/11/2022
 50805                                  
 50806                                  ; 05/12/2022
 50807                                  ;MSDAT001E:	; label byte
 50808                                  
 50809                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 50810                                  DOSDATAEND equ $
 50811                                  DOSDATASIZE equ DOSDATAEND - DOSDATASTART ; = 4962 for MSDOS 5.0 MSDOS.SYS
 50812                                  MSDAT001E equ DOSDATAEND - DOSDATASTART
 50813                                  
 50814                                  ;DOSDATALAST ENDS
 50815                                  
 50816                                  ; Retro DOS v4.0 by Erdogan Tan (Redevelopment of MSDOS 5.0 KERNEL via NASM)
 50817                                  ; DECEMBER 2022, ISTANBUL - TURKIYE.
 50818                                  ;============================================================================
 50819                                  ;	END
 50820                                  ;============================================================================
 50821                                  ; Retro DOS v4.0 by Erdogan Tan (Redevelopment of MSDOS 6.21 KERNEL via NASM)
 50822                                  ; -----------------------------
 50823                                  ; MAY 2019, ISTANBUL - TURKIYE.
