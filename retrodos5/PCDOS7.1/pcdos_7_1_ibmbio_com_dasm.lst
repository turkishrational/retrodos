MSLOAD:0000 ;
MSLOAD:0000 ; +-------------------------------------------------------------------------+
MSLOAD:0000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
MSLOAD:0000 ; |           Copyright (c) 2018 Hex-Rays, <support@hex-rays.com>           |
MSLOAD:0000 ; |                            Freeware version                             |
MSLOAD:0000 ; +-------------------------------------------------------------------------+
MSLOAD:0000 ;
MSLOAD:0000 ; Input SHA256 : D1C9E34AAFA2A65B8F74EEACE701B273E16D6B7FAE1368C1BA7A768B39EB4558
MSLOAD:0000 ; Input MD5    : D31B3F077E548791544DF2070469836E
MSLOAD:0000 ; Input CRC32  : 88D352C3
MSLOAD:0000
MSLOAD:0000 ; ---------------------------------------------------------------------------
MSLOAD:0000 ; File Name   : C:\Yedek\pcdos_7_1\IBMBIO.COM
MSLOAD:0000 ; Format      : Binary file
MSLOAD:0000 ; Base Address: 0000h Range: 0000h - AE70h Loaded length: AE70h
MSLOAD:0000
MSLOAD:0000                 .386
MSLOAD:0000                 .model flat
MSLOAD:0000
MSLOAD:0000 ; ===========================================================================
MSLOAD:0000
MSLOAD:0000 ; Segment type: Pure code
MSLOAD:0000 MSLOAD          segment byte public 'CODE' use16
MSLOAD:0000                 assume cs:MSLOAD
MSLOAD:0000                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
MSLOAD:0000
MSLOAD:0000 START$:
MSLOAD:0000                 jmp     short SaveInputValues
MSLOAD:0000 ; ---------------------------------------------------------------------------
MSLOAD:0002                 db 90h
MSLOAD:0003 SysVersionMajor db 7
MSLOAD:0004 SysVersionMinor db 10
MSLOAD:0005 NumHeads        dw 0                    ; DATA XREF: MSLOAD:00BB↓w
MSLOAD:0005                                         ; ReadSectors+9C↓r ...
MSLOAD:0007 ClusterSize     dw 0                    ; DATA XREF: MSLOAD:CalcFatSize↓w
MSLOAD:0007                                         ; MSLOAD:02A9↓r ...
MSLOAD:0009 StartSecL       dw 0                    ; DATA XREF: MSLOAD:0268↓w
MSLOAD:0009                                         ; MSLOAD:0278↓w ...
MSLOAD:000B StartSecH       dw 0                    ; DATA XREF: MSLOAD:0270↓w
MSLOAD:000B                                         ; MSLOAD:027C↓w ...
MSLOAD:000D TempH           dw 0                    ; DATA XREF: MSLOAD:0215↓w
MSLOAD:000D                                         ; MSLOAD:0224↓r ...
MSLOAD:000F TempCluster     dw 0                    ; DATA XREF: GetNextFatEntry+57↓w
MSLOAD:000F                                         ; GetNextFatEntry+6E↓r ...
MSLOAD:0011 LastFatSectorL  dw 0FFFFh               ; DATA XREF: GetFatSector+1D↓r
MSLOAD:0011                                         ; GetFatSector+23↓w
MSLOAD:0013 LastFatSectorH  dw 0FFFFh               ; DATA XREF: GetFatSector+17↓r
MSLOAD:0013                                         ; GetFatSector+26↓w
MSLOAD:0015 SectorCount     dw 0                    ; DATA XREF: MSLOAD:02B9↓w
MSLOAD:0015                                         ; MSLOAD:02EF↓w ...
MSLOAD:0017 FATSectorsL     dw 0                    ; DATA XREF: MSLOAD:00C4↓w
MSLOAD:0017                                         ; MSLOAD:not_big↓r ...
MSLOAD:0019 FATSectorsH     dw 0                    ; DATA XREF: MSLOAD:013A↓w
MSLOAD:0019                                         ; MSLOAD:01E0↓r
MSLOAD:001B HiddenSectorsL  dw 0                    ; DATA XREF: MSLOAD:00F4↓w
MSLOAD:001B                                         ; GetFatSector+2D↓r
MSLOAD:001D HiddenSectorsH  dw 0                    ; DATA XREF: MSLOAD:010E↓w
MSLOAD:001D                                         ; GetFatSector+31↓r
MSLOAD:001F BytesPerSec     dw 0                    ; DATA XREF: MSLOAD:00A0↓w
MSLOAD:001F                                         ; MSLOAD:0180↓r ...
MSLOAD:0021 ReservSectors   dw 0                    ; DATA XREF: MSLOAD:00EB↓w
MSLOAD:0021                                         ; MSLOAD:01D5↓r ...
MSLOAD:0023 CurrentClusterL dw 0                    ; DATA XREF: MSLOAD:0252↓w
MSLOAD:0023                                         ; MSLOAD:02C2↓w ...
MSLOAD:0025 CurrentClusterH dw 0                    ; DATA XREF: MSLOAD:024E↓w
MSLOAD:0025                                         ; MSLOAD:02C6↓w ...
MSLOAD:0027 NextBioLocation dw 0                    ; DATA XREF: MSLOAD:02E4↓w
MSLOAD:0027                                         ; MSLOAD:032F↓r ...
MSLOAD:0029 FirstSectorL    dw 0                    ; DATA XREF: MSLOAD:SaveInputValues↓w
MSLOAD:0029                                         ; MSLOAD:0264↓r ...
MSLOAD:002B FirstSectorH    dw 0                    ; DATA XREF: MSLOAD:0107↓w
MSLOAD:002B                                         ; MSLOAD:026C↓r ...
MSLOAD:002D TotalSectorsL   dw 0                    ; DATA XREF: MSLOAD:00FD↓w
MSLOAD:002D                                         ; MSLOAD:011A↓w ...
MSLOAD:002F TotalSectorsH   dw 0                    ; DATA XREF: MSLOAD:0121↓w
MSLOAD:002F                                         ; MSLOAD:01CE↓r
MSLOAD:0031 SecPerTrack     dw 0                    ; DATA XREF: MSLOAD:00B2↓w
MSLOAD:0031                                         ; ReadSectors+42↓r ...
MSLOAD:0033 BootDrive       db 0                    ; DATA XREF: MSLOAD:0053↓w
MSLOAD:0033                                         ; MSLOAD:034E↓r ...
MSLOAD:0034 FatType         db 0                    ; DATA XREF: MSLOAD:01C9↓w
MSLOAD:0034                                         ; MSLOAD:021F↓w ...
MSLOAD:0035 MediaByte       db 0                    ; DATA XREF: MSLOAD:004E↓w
MSLOAD:0035                                         ; MSLOAD:GoToBioInit↓r
MSLOAD:0036 EndOfFile       db 0                    ; DATA XREF: MSLOAD:0304↓r
MSLOAD:0036                                         ; GetNextFatEntry+6↓w ...
MSLOAD:0037 OrgDasdPtr      dd 0                    ; DATA XREF: MSLOAD:loc_5C↓w
MSLOAD:0037                                         ; MSLOAD:0359↓r ...
MSLOAD:003B FatSegment      dw 0                    ; DATA XREF: MSLOAD:018A↓w
MSLOAD:003B                                         ; GetNextFatEntry+1↓r
MSLOAD:003D SecPerCluster   db 0                    ; DATA XREF: MSLOAD:00A9↓w
MSLOAD:003D                                         ; MSLOAD:01B9↓r ...
MSLOAD:003E NumFats         db 0                    ; DATA XREF: MSLOAD:00D9↓w
MSLOAD:003E                                         ; MSLOAD:01E6↓r
MSLOAD:003F RootEntCnt      dw 0                    ; DATA XREF: MSLOAD:00E2↓w
MSLOAD:003F                                         ; MSLOAD:01FB↓r ...
MSLOAD:0041 RootClusterL    dw 0                    ; DATA XREF: MSLOAD:0143↓w
MSLOAD:0043 RootClusterH    dw 0                    ; DATA XREF: MSLOAD:014C↓w
MSLOAD:0043                                         ; BIOSDATA:1DF3↓r ...
MSLOAD:0045 FirstCluster    dw 2 dup(0)             ; DATA XREF: MSLOAD:008E↓w
MSLOAD:0045                                         ; MSLOAD:ReadInFirstCluster↓r ...
MSLOAD:0049 ; ---------------------------------------------------------------------------
MSLOAD:0049
MSLOAD:0049 SaveInputValues:                        ; CODE XREF: MSLOAD:START$↑j
MSLOAD:0049                                         ; DATA XREF: check_int13h_extensions+1F↓r ...
MSLOAD:0049                 mov     cs:FirstSectorL, bx ; Start sector # of data
MSLOAD:0049                                         ; (high word in ax and also in es)
MSLOAD:004E                 mov     cs:MediaByte, ch
MSLOAD:004E                                         ; DATA XREF: aux_init+7↓r
MSLOAD:004E                                         ; BPB_Media
MSLOAD:0053                 mov     cs:BootDrive, dl
MSLOAD:0053                                         ; DATA XREF: BIOSDATA:1E64↓r
MSLOAD:0053                                         ; BIOSDATA:2002↓r ...
MSLOAD:0053                                         ; BS_DrvNum
MSLOAD:0058
MSLOAD:0058 loc_58:                                 ; DATA XREF: ReadSectors+5C↓r
MSLOAD:0058                                         ; BIOSDATA:1B8A↓r ...
MSLOAD:0058                 pop     si              ; from BS code..
MSLOAD:0058                                         ; ss:sp = 0:7BE4h, bp = 7BECh
MSLOAD:0058                                         ; Clear stack and load disk parameters table in ds:si
MSLOAD:0058                                         ;
MSLOAD:0058                                         ; pop.. Original INT 1Eh vector address
MSLOAD:0059                 pop     ds
MSLOAD:005A                 pop     si              ; pop.. Original INT 1Eh disk table address
MSLOAD:005B                 pop     ds
MSLOAD:005C
MSLOAD:005C loc_5C:                                 ; DATA XREF: print_init+5↓r
MSLOAD:005C                 mov     word ptr cs:OrgDasdPtr, si
MSLOAD:0061                 push    ds
MSLOAD:0062                 pop     word ptr cs:OrgDasdPtr+2
MSLOAD:0062                                         ; DATA XREF: ReadSectors+6F↓r
MSLOAD:0062                                         ; BIOSDATA:SkipVDisk↓r
MSLOAD:0067                 xor     cx, cx          ; DATA XREF: BIOSDATA:1865↓r
MSLOAD:0067                                         ; read_real_date+5↓r ...
MSLOAD:0069                 mov     ds, cx          ; 0
MSLOAD:006B                 mov     es, cx          ; 0
MSLOAD:006D                 mov     si, word ptr ds:78h ; INT 1Eh disk parameters table address
MSLOAD:006D                                         ; (it is set by boot sector code)
MSLOAD:0071                 mov     ds, word ptr ds:78h+2
MSLOAD:0075
MSLOAD:0075 loc_75:                                 ; Sec9 ; new location of DSK_PARMS
MSLOAD:0075                 mov     di, 522h
MSLOAD:0078                 mov     cx, 14          ; (11+3 bytes for IBM rombios)
MSLOAD:007B                 cld
MSLOAD:007C                 rep movsb
MSLOAD:007E                 push    es
MSLOAD:007F                 pop     ds
MSLOAD:0080                 mov     word ptr ds:78h, 522h
MSLOAD:0080                                         ; DATA XREF: SYSINIT:05D8↓r
MSLOAD:0080                                         ; SYSINIT:05DC↓r ...
MSLOAD:0080                                         ; Offset Sec9
MSLOAD:0086                 mov     word ptr ds:78h+2, ds
MSLOAD:008A                 mov     cx, word ptr ds:51Ah ; LW of IBMBIO.COM (IO.SYS) first cluster
MSLOAD:008E                 mov     cs:FirstCluster, cx
MSLOAD:0093                 mov     cx, word ptr ds:514h ; HW of IBMBIO.COM (IO.SYS) first cluster
MSLOAD:0097                 mov     cs:FirstCluster+2, cx
MSLOAD:009C                 mov     cx, ds:7C0Bh    ; BPB_BytsPerSec ; 512
MSLOAD:00A0                 mov     cs:BytesPerSec, cx
MSLOAD:00A0                                         ; DATA XREF: con_writ+6↓r
MSLOAD:00A0                                         ; swpdsk:wrmsg_loop↓r
MSLOAD:00A5                 mov     cl, ds:7C0Dh    ; BPB_SecPerClus
MSLOAD:00A9                 mov     cs:SecPerCluster, cl
MSLOAD:00AE                 mov     cx, ds:7C18h    ; BPB_SecPerTrk
MSLOAD:00B2                 mov     cs:SecPerTrack, cx
MSLOAD:00B7                 mov     cx, ds:7C1Ah    ; BPB_NumHeads
MSLOAD:00BB                 mov     cs:NumHeads, cx ; DATA XREF: MSLOAD:017A↓r
MSLOAD:00BB                                         ; BIOSDATA:0821↓r ...
MSLOAD:00C0                 mov     cx, ds:7C16h    ; BPB_FATSz16
MSLOAD:00C4                 mov     cs:FATSectorsL, cx
MSLOAD:00C9                 mov     bl, ds:7C26h    ; BS_BootSig ; (FAT12 and FAT16)
MSLOAD:00CD                 or      cx, cx
MSLOAD:00CF                 jnz     short not_fat32
MSLOAD:00D1                 mov     bl, ds:7C42h    ; BS_BootSig ; (FAT32)
MSLOAD:00D5
MSLOAD:00D5 not_fat32:                              ; CODE XREF: MSLOAD:00CF↑j
MSLOAD:00D5                 mov     cl, ds:7C10h    ; BPB_NumFATs
MSLOAD:00D9                 mov     cs:NumFats, cl
MSLOAD:00DE                 mov     cx, ds:7C11h    ; BPB_RootEntCnt
MSLOAD:00E2                 mov     cs:RootEntCnt, cx
MSLOAD:00E7                 mov     cx, ds:7C0Eh    ; BPB_RsvdSecCnt
MSLOAD:00EB                 mov     cs:ReservSectors, cx
MSLOAD:00F0                 mov     cx, ds:7C1Ch    ; BPB_HiddSec
MSLOAD:00F4                 mov     cs:HiddenSectorsL, cx
MSLOAD:00F9                 mov     cx, ds:7C13h    ; BPB_TotSec16
MSLOAD:00FD                 mov     cs:TotalSectorsL, cx
MSLOAD:0102                 cmp     bl, 29h
MSLOAD:0105                 jnz     short Relocate  ; old boot sector,
MSLOAD:0105                                         ; no need to copy high words
MSLOAD:0107                 mov     cs:FirstSectorH, ax ; Start sector # of data, high word
MSLOAD:010B                 mov     ax, ds:7C1Eh    ; BPB_HiddSec+2
MSLOAD:010E                 mov     cs:HiddenSectorsH, ax
MSLOAD:0112                 cmp     cx, 0
MSLOAD:0115                 jnz     short not_big
MSLOAD:0117                 mov     ax, ds:7C20h    ; BPB_TotSec32
MSLOAD:011A                 mov     cs:TotalSectorsL, ax
MSLOAD:011E                 mov     ax, ds:7C22h    ; BPB_TotSec32+2
MSLOAD:0121                 mov     cs:TotalSectorsH, ax
MSLOAD:0125
MSLOAD:0125 not_big:                                ; CODE XREF: MSLOAD:0115↑j
MSLOAD:0125                 cmp     cs:FATSectorsL, 0
MSLOAD:012B                 jnz     short Relocate  ; FAT12 or FAT16 fs
MSLOAD:012D                 mov     cx, ds:7C24h    ; BPB_FATSz32 ; FAT32 fs
MSLOAD:0131                 mov     cs:FATSectorsL, cx
MSLOAD:0136                 mov     cx, ds:7C26h    ; BPB_FATSz32+2
MSLOAD:013A                 mov     cs:FATSectorsH, cx
MSLOAD:013F                 mov     cx, ds:7C2Ch    ; BPB_RootClus
MSLOAD:0143                 mov     cs:RootClusterL, cx
MSLOAD:0148                 mov     cx, ds:7C2Eh    ; BPB_RootClus+2
MSLOAD:014C                 mov     cs:RootClusterH, cx
MSLOAD:0151
MSLOAD:0151 Relocate:                               ; CODE XREF: MSLOAD:0105↑j
MSLOAD:0151                                         ; MSLOAD:012B↑j
MSLOAD:0151                 cld                     ; copy code from start to top of memory
MSLOAD:0151                                         ; the length to copy is EndOfLoader
MSLOAD:0151                                         ; jump to relocated code
MSLOAD:0152                 xor     si, si
MSLOAD:0154                 mov     di, si
MSLOAD:0156                 int     12h             ; MEMORY SIZE -
MSLOAD:0156                                         ; Return: AX = number of contiguous 1K blocks of memory
MSLOAD:0158                 mov     cl, 6
MSLOAD:015A                 shl     ax, cl
MSLOAD:015C                 xor     bx, bx          ; Check if an RPL program is present at TOM
MSLOAD:015C                                         ;  and do not tromp over it
MSLOAD:015E                 mov     ds, bx
MSLOAD:0160                 mov     bx, word ptr ds:0BCh ; 2Fh*4
MSLOAD:0164                 mov     ds, word ptr ds:0BEh ; 2Fh*4+2
MSLOAD:0168                 cmp     word ptr [bx+3], 5052h ; 'RP' ; 'RPL'
MSLOAD:016D                 jnz     short Skip_RPL
MSLOAD:016F                 cmp     byte ptr [bx+5], 4Ch ; 'L'
MSLOAD:0173                 jnz     short Skip_RPL
MSLOAD:0175                 mov     dx, ax          ; get TOM into DX
MSLOAD:0177                 mov     ax, 4A06h
MSLOAD:017A                 int     2Fh             ; Get new TOM from any RPL
MSLOAD:017C                 mov     ax, dx
MSLOAD:017E
MSLOAD:017E Skip_RPL:                               ; CODE XREF: MSLOAD:016D↑j
MSLOAD:017E                                         ; MSLOAD:0173↑j
MSLOAD:017E                 mov     cl, 4
MSLOAD:0180                 mov     dx, cs:BytesPerSec
MSLOAD:0185                 shr     dx, cl
MSLOAD:0187                 inc     dx
MSLOAD:0188                 sub     ax, dx
MSLOAD:018A                 mov     cs:FatSegment, ax
MSLOAD:018E                 mov     dx, 5F0h        ; Offset EndOfLoader (1520)
MSLOAD:0191                 shr     dx, cl
MSLOAD:0193                 inc     dx
MSLOAD:0194                 sub     ax, dx
MSLOAD:0196                 mov     es, ax
MSLOAD:0198                 push    cs
MSLOAD:0199                 pop     ds
MSLOAD:019A                 mov     cx, 1520        ; Loader size = EndofLoader - 0
MSLOAD:019D                 rep movsb
MSLOAD:019F                 push    es              ; Far jump to relocated MSLOAD code
MSLOAD:019F                                         ; (via retf, far return)
MSLOAD:01A0                 mov     ax, offset SetupStack
MSLOAD:01A3                 push    ax
MSLOAD:01A4                 retf
MSLOAD:01A5 ; ---------------------------------------------------------------------------
MSLOAD:01A5
MSLOAD:01A5 SetupStack:                             ; DATA XREF: MSLOAD:01A0↑o
MSLOAD:01A5                 mov     ax, cs
MSLOAD:01A7                 sub     ax, 40h         ; move ss to 400h backward for stack space
MSLOAD:01A7                                         ; then set sp to the end of this stack space
MSLOAD:01AA                 mov     ss, ax
MSLOAD:01AC                 assume ss:nothing
MSLOAD:01AC                 mov     sp, 400h
MSLOAD:01AF                 add     ax, 40h         ; ax = cs
MSLOAD:01B2                 mov     ds, ax
MSLOAD:01B4
MSLOAD:01B4 FindClusterSize:
MSLOAD:01B4                 mov     ax, ds:BytesPerSec
MSLOAD:01B7                 xor     bx, bx
MSLOAD:01B9                 mov     bl, ds:SecPerCluster
MSLOAD:01BD                 mul     bx
MSLOAD:01BF                 or      dx, dx
MSLOAD:01C1                 jz      short CalcFatSize
MSLOAD:01C3                 jmp     ErrorOut
MSLOAD:01C6 ; ---------------------------------------------------------------------------
MSLOAD:01C6
MSLOAD:01C6 CalcFatSize:                            ; CODE XREF: MSLOAD:01C1↑j
MSLOAD:01C6                 mov     ds:ClusterSize, ax ; cluster size in bytes
MSLOAD:01C9                 mov     ds:FatType, 1   ; FAT12
MSLOAD:01CE                 mov     dx, ds:TotalSectorsH
MSLOAD:01D2                 mov     ax, ds:TotalSectorsL
MSLOAD:01D5                 sub     ax, ds:ReservSectors
MSLOAD:01D9                 sbb     dx, 0           ; dx:ax = Total available sectors
MSLOAD:01DC                 mov     bx, ds:FATSectorsL
MSLOAD:01E0                 mov     cx, ds:FATSectorsH
MSLOAD:01E4                 push    ax
MSLOAD:01E5                 push    dx
MSLOAD:01E6                 mov     al, ds:NumFats  ; calculate total FAT sectors
MSLOAD:01E9                 xor     ah, ah
MSLOAD:01EB                 xchg    ax, cx
MSLOAD:01EC                 mul     cx
MSLOAD:01EE                 xchg    ax, cx
MSLOAD:01EF                 mul     bx
MSLOAD:01F1                 add     cx, dx
MSLOAD:01F3                 mov     bx, ax
MSLOAD:01F5                 pop     dx
MSLOAD:01F6                 pop     ax
MSLOAD:01F7                 sub     ax, bx
MSLOAD:01F9                 sbb     dx, cx          ; dx:ax = Total sectors - FAT sectors
MSLOAD:01FB                 mov     bx, ds:RootEntCnt
MSLOAD:01FF                 mov     cl, 4
MSLOAD:0201                 shr     bx, cl          ; 16 directory entries per sector
MSLOAD:0203                 sub     ax, bx
MSLOAD:0205                 sbb     dx, 0           ; dx:ax = data sectors
MSLOAD:0205                                         ; (Note: [RootEntCnt] is 0 for FAT32 fs)
MSLOAD:0208                 xor     cx, cx          ;
MSLOAD:0208                                         ; 32 bit divide by sectors per
MSLOAD:0208                                         ;  cluster to find total number
MSLOAD:0208                                         ;  of clusters.
MSLOAD:020A                 mov     cl, ds:SecPerCluster
MSLOAD:020E                 push    ax
MSLOAD:020F                 mov     ax, dx
MSLOAD:0211                 xor     dx, dx
MSLOAD:0213                 div     cx
MSLOAD:0215                 mov     ds:TempH, ax
MSLOAD:0218                 pop     ax
MSLOAD:0219                 div     cx
MSLOAD:021B                 mov     dx, ds:FirstCluster+2
MSLOAD:021F                 mov     ds:FatType, 0Bh ; set FAT type to FAT32 (CHS type disk R/W)
MSLOAD:0224                 cmp     ds:TempH, 0     ; is cluster count > 65535 ?
MSLOAD:0229                 jnz     short ReadInFirstCluster ; yes, it is (it must be) FAT32 fs
MSLOAD:022B                 cmp     ax, 0FFF6h      ; FAT16 limit (65536-10)
MSLOAD:022E                 jnb     short ReadInFirstCluster
MSLOAD:0230                 xor     dx, dx
MSLOAD:0232                 mov     ds:FirstCluster+2, dx ; clear HW of FirstCluster
MSLOAD:0236                 mov     ds:FatType, 1   ; set FAT type fo FAT12
MSLOAD:023B                 cmp     ax, 0FF6h       ; 4086 ; (4096-10)
MSLOAD:023E                 jb      short ReadInFirstCluster
MSLOAD:0240                 mov     ds:FatType, 4   ; set FAT type to FAT16
MSLOAD:0245
MSLOAD:0245 ReadInFirstCluster:                     ; CODE XREF: MSLOAD:0229↑j
MSLOAD:0245                                         ; MSLOAD:022E↑j ...
MSLOAD:0245                 mov     ax, ds:FirstCluster ; dx:ax = BIOS starting cluster
MSLOAD:0248                 sub     ax, 2           ; First cluster is 2 so
MSLOAD:0248                                         ; decrement to make 0 based
MSLOAD:024B                 sbb     dx, 0
MSLOAD:024E                 mov     ds:CurrentClusterH, dx ; Initialize to this cluster
MSLOAD:0252                 mov     ds:CurrentClusterL, ax
MSLOAD:0255                 mov     ax, 3           ; (Note: PCDOS 7.1 bs loads 1st 4 sectors of IBMBIO.COM)
MSLOAD:0255                                         ; If cluster size > 3, al = 0, ah <> 0
MSLOAD:0255                                         ; If cluster size = 2, al = 1, ah = 1
MSLOAD:0255                                         ; If cluster size = 1, al = 3, ah = 0
MSLOAD:0255                                         ; If ah = 0, nothing remaining in last cluster
MSLOAD:0258                 div     ds:SecPerCluster
MSLOAD:025C                 cmp     ah, 0
MSLOAD:025F                 jz      short SetNextClusterNum
MSLOAD:0261                 xor     ah, ah          ; Calculate sector to start reading from
MSLOAD:0261                                         ; in StartSecH and StartSecL
MSLOAD:0263                 push    ax              ; (*)
MSLOAD:0264                 mov     cx, ds:FirstSectorL
MSLOAD:0268                 mov     ds:StartSecL, cx
MSLOAD:026C                 mov     cx, ds:FirstSectorH
MSLOAD:0270                 mov     ds:StartSecH, cx
MSLOAD:0274                 mul     ds:SecPerCluster
MSLOAD:0278                 add     ds:StartSecL, ax
MSLOAD:027C                 adc     ds:StartSecH, 0 ; Add number of sectors already loaded
MSLOAD:027C                                         ;    to start sector
MSLOAD:0281                 mov     dx, ds:FirstCluster+2
MSLOAD:0285                 mov     ax, ds:FirstCluster
MSLOAD:0288                 sub     ax, 2
MSLOAD:028B                 sbb     dx, 0
MSLOAD:028E                 xor     bx, bx
MSLOAD:0290                 mov     bl, ds:SecPerCluster
MSLOAD:0294                 push    ax
MSLOAD:0295                 mov     ax, dx
MSLOAD:0297                 mul     bx
MSLOAD:0299                 xchg    ax, bx
MSLOAD:029A                 pop     dx
MSLOAD:029B                 mul     dx
MSLOAD:029D                 add     dx, bx
MSLOAD:029F                 add     ds:StartSecL, ax
MSLOAD:02A3                 adc     ds:StartSecH, dx
MSLOAD:02A7                 pop     ax              ; (*) number of clusters already loaded
MSLOAD:02A7                                         ; (0 or 1)
MSLOAD:02A7                                         ; (Note: if al=0, the 1st 4 sectors of the 1st cluster
MSLOAD:02A7                                         ;  will be loaded again! -PCDOS 7.1-)
MSLOAD:02A8                 push    ax
MSLOAD:02A9                 mul     ds:ClusterSize
MSLOAD:02AD                 mov     di, 700h        ; IBMBIO.COM (IO.SYS) loading address (segment = 0)
MSLOAD:02B0                 add     di, ax
MSLOAD:02B2                 xor     ax, ax
MSLOAD:02B4                 mov     es, ax
MSLOAD:02B6                 mov     al, ds:SecPerCluster ; read 1 cluster
MSLOAD:02B9                 mov     ds:SectorCount, ax
MSLOAD:02BC                 call    ReadSectors
MSLOAD:02BF                 pop     ax
MSLOAD:02C0                 inc     ax              ; +1 cluster loaded
MSLOAD:02C1
MSLOAD:02C1 SetNextClusterNum:                      ; CODE XREF: MSLOAD:025F↑j
MSLOAD:02C1                 inc     ax              ; ax = total clusters read in based 2
MSLOAD:02C2                 add     ds:CurrentClusterL, ax ; CurrentCluster = Last cluster read
MSLOAD:02C6                 adc     ds:CurrentClusterH, 0
MSLOAD:02CB                 dec     ax              ; ax = number of clusters loaded
MSLOAD:02CC
MSLOAD:02CC SaveLoadedBios:
MSLOAD:02CC                 push    ds
MSLOAD:02CD                 mul     ds:ClusterSize  ; Get total bytes loaded by this is always < 64k,
MSLOAD:02CD                                         ; so lower 16 bits ok
MSLOAD:02D1                 sub     ax, 5F0h        ; get portion of iosys loaded
MSLOAD:02D1                                         ; EndOfLoader ; (Offset EndOfLoader)-(Offset Start)
MSLOAD:02D4                 mov     cx, ax
MSLOAD:02D6                 mov     ax, 70h         ; Segment at 70h
MSLOAD:02D9                 mov     ds, ax
MSLOAD:02DB                 assume ds:nothing
MSLOAD:02DB                 mov     es, ax
MSLOAD:02DD                 assume es:nothing
MSLOAD:02DD                 mov     si, 5F0h        ; EndOfLoader
MSLOAD:02E0                 xor     di, di
MSLOAD:02E2                 rep movsb
MSLOAD:02E4                 mov     cs:NextBioLocation, di ; Save where location for next read
MSLOAD:02E9                 pop     ds
MSLOAD:02EA                 assume ds:nothing
MSLOAD:02EA
MSLOAD:02EA GetContigClusters:                      ; CODE XREF: MSLOAD:0348↓j
MSLOAD:02EA                 xor     ah, ah          ; go find clusters as long as they are contiguous
MSLOAD:02EC                 mov     al, ds:SecPerCluster
MSLOAD:02EF                 mov     ds:SectorCount, ax
MSLOAD:02F2                 push    ds:SectorCount
MSLOAD:02F6                 call    GetNextFatEntry ; Returns next cluster to read in di:ax
MSLOAD:02F9                 pop     ds:SectorCount
MSLOAD:02FD                 mov     ds:CurrentClusterL, ax
MSLOAD:0300                 mov     ds:CurrentClusterH, di
MSLOAD:0304                 cmp     ds:EndOfFile, 0FFh
MSLOAD:0309                 jz      short GoToBioInit
MSLOAD:030B                 xor     dx, dx
MSLOAD:030D                 sub     ax, 2           ; Zero base the cluster (32 bit as di:ax)
MSLOAD:0310                 sbb     di, dx
MSLOAD:0312                 xchg    ax, di          ; 32 bit multiplication
MSLOAD:0312                                         ; (dx:ax)*cx
MSLOAD:0313                 xor     ch, ch
MSLOAD:0315                 mov     cl, ds:SecPerCluster
MSLOAD:0319                 mul     cx
MSLOAD:031B                 xchg    ax, di
MSLOAD:031C                 mul     cx
MSLOAD:031E                 add     dx, di
MSLOAD:0320                 add     ax, ds:FirstSectorL
MSLOAD:0324                 adc     dx, ds:FirstSectorH
MSLOAD:0328                 mov     ds:StartSecL, ax
MSLOAD:032B                 mov     ds:StartSecH, dx
MSLOAD:032F                 mov     di, ds:NextBioLocation
MSLOAD:0333                 push    ds:SectorCount
MSLOAD:0337                 mov     ax, 70h
MSLOAD:033A                 mov     es, ax
MSLOAD:033C                 call    ReadSectors
MSLOAD:033F                 pop     ax
MSLOAD:0340                 mul     ds:BytesPerSec
MSLOAD:0344                 add     ds:NextBioLocation, ax
MSLOAD:0348                 jmp     short GetContigClusters
MSLOAD:034A ; ---------------------------------------------------------------------------
MSLOAD:034A
MSLOAD:034A GoToBioInit:                            ; CODE XREF: MSLOAD:0309↑j
MSLOAD:034A                 mov     ch, ds:MediaByte ; Set up required registers for iosys,
MSLOAD:034A                                         ;  then jump to it (70:0)
MSLOAD:034A                                         ;
MSLOAD:034A                                         ; Restore regs required for msint
MSLOAD:034E                 mov     dl, ds:BootDrive ; Physical drv number we booted from
MSLOAD:0352                 mov     bx, ds:FirstSectorL
MSLOAD:0356                 mov     ax, ds:FirstSectorH ; bx:ax = first data sector of disk
MSLOAD:0359                 lds     si, ds:OrgDasdPtr ; Set ds:si to Original INT 1Eh disk(ette) table address
MSLOAD:0359                                         ; and then push disk table address and INT 1Eh vector to stack
MSLOAD:0359                                         ; (set stack content just as at the start of MSLOAD)
MSLOAD:035D                 push    ds              ; INT 1Eh original table segment
MSLOAD:035E                 push    si              ; INT 1Eh original table offset
MSLOAD:035F                 xor     di, di          ; 0  ; INT 1Eh vector segment
MSLOAD:0361                 push    di
MSLOAD:0362                 mov     di, 78h         ; 1Eh*4 = 78h
MSLOAD:0365                 push    di              ; INT 1Eh vector offset
MSLOAD:0366                 jmp     far ptr 70h:0   ; Far jump to IoSysAddr (DOSBIOS)
MSLOAD:036B
MSLOAD:036B ; =============== S U B R O U T I N E =======================================
MSLOAD:036B
MSLOAD:036B
MSLOAD:036B check_int13h_extensions proc near       ; CODE XREF: ReadSectors+C↓p
MSLOAD:036B                 push    ax
MSLOAD:036C                 push    dx
MSLOAD:036D                 xor     ax, ax
MSLOAD:036F                 push    ax              ; zero (buffer offset 24)
MSLOAD:036F                                         ; (bytes per sector)
MSLOAD:0370                 mov     bx, sp
MSLOAD:0372                 sub     sp, 20
MSLOAD:0375                 push    ax              ; info flags
MSLOAD:0376                 mov     ax, 26          ; Result buffer size
MSLOAD:0379                 push    ax
MSLOAD:037A                 mov     si, sp
MSLOAD:037C                 mov     dl, ds:BootDrive
MSLOAD:0380                 mov     ah, 48h
MSLOAD:0382                 push    ds
MSLOAD:0383                 push    ss
MSLOAD:0384                 pop     ds
MSLOAD:0385                 assume ds:nothing
MSLOAD:0385                 cmp     dl, 0
MSLOAD:0388                 jge     short not_hard_disk
MSLOAD:038A                 int     13h             ; DISK - IBM/MS Extension - GET DRIVE PARAMETERS
MSLOAD:038A                                         ; (DL - drive, DS:SI - buffer)
MSLOAD:038C
MSLOAD:038C not_hard_disk:                          ; CODE XREF: check_int13h_extensions+1D↑j
MSLOAD:038C                 pop     ds
MSLOAD:038D                 assume ds:nothing
MSLOAD:038D                 mov     sp, bx
MSLOAD:038F                 pop     ax              ; bytes per sector, buffer offset 24
MSLOAD:0390                 jb      short int13h_ext_err
MSLOAD:0392                 cmp     ax, 512
MSLOAD:0395                 jz      short int13h_ext_err
MSLOAD:0397                 stc
MSLOAD:0398
MSLOAD:0398 int13h_ext_err:                         ; CODE XREF: check_int13h_extensions+25↑j
MSLOAD:0398                                         ; check_int13h_extensions+2A↑j
MSLOAD:0398                 pop     dx
MSLOAD:0399                 pop     ax
MSLOAD:039A                 retn
MSLOAD:039A check_int13h_extensions endp
MSLOAD:039A
MSLOAD:039B
MSLOAD:039B ; =============== S U B R O U T I N E =======================================
MSLOAD:039B
MSLOAD:039B
MSLOAD:039B ReadSectors     proc near               ; CODE XREF: MSLOAD:02BC↑p
MSLOAD:039B                                         ; MSLOAD:033C↑p ...
MSLOAD:039B                 mov     cx, 5
MSLOAD:039E
MSLOAD:039E TryRead:                                ; CODE XREF: ReadSectors+D8↓j
MSLOAD:039E                                         ; ReadSectors+DE↓j
MSLOAD:039E                 push    cx              ; (*)
MSLOAD:039F                 mov     ax, ds:StartSecL
MSLOAD:03A2                 mov     dx, ds:StartSecH
MSLOAD:03A6                 push    ax              ; (**)
MSLOAD:03A7                 call    check_int13h_extensions
MSLOAD:03AA                 jb      short chs_read
MSLOAD:03AC                 xor     si, si          ; LBA read
MSLOAD:03AE                 push    si              ; 0
MSLOAD:03AF                 push    si              ; 0
MSLOAD:03B0                 push    dx
MSLOAD:03B1                 push    ax              ; 0:0:dx:ax = start sector (8 bytes)
MSLOAD:03B2                 push    es
MSLOAD:03B3                 push    di              ; memory buffer address (seg:off)
MSLOAD:03B4                 push    ds:SectorCount  ; number of sectors to read
MSLOAD:03B8                 mov     bx, 16          ; size of DAP
MSLOAD:03BB                 push    bx
MSLOAD:03BC                 mov     si, sp
MSLOAD:03BE                 mov     ah, 42h
MSLOAD:03C0                 push    dx
MSLOAD:03C1                 mov     dl, ds:BootDrive
MSLOAD:03C5                 push    ds
MSLOAD:03C6                 push    ss
MSLOAD:03C7                 pop     ds
MSLOAD:03C8                 assume ds:nothing
MSLOAD:03C8                 int     13h             ; DISK - IBM/MS Extension - EXTENDED READ
MSLOAD:03C8                                         ; (DL - drive, DS:SI - disk address packet)
MSLOAD:03CA                 pop     ds
MSLOAD:03CB                 assume ds:nothing
MSLOAD:03CB                 pop     dx              ; sector number, hw
MSLOAD:03CC                 jb      short lba_read_err
MSLOAD:03CE                 pop     ax              ; size of DAP (disk address packet) = 16
MSLOAD:03CF                 pop     ax              ; number of sectors to read
MSLOAD:03D0                 push    ax              ; (**) discard ax on stack (StartSectorL)
MSLOAD:03D1                 add     sp, bx          ; sp points to cx (*)
MSLOAD:03D3                 pop     cx              ; remaining retry count value
MSLOAD:03D4                 jmp     ReadOk
MSLOAD:03D7 ; ---------------------------------------------------------------------------
MSLOAD:03D7
MSLOAD:03D7 lba_read_err:                           ; CODE XREF: ReadSectors+31↑j
MSLOAD:03D7                 add     sp, bx
MSLOAD:03D9
MSLOAD:03D9 chs_read:                               ; CODE XREF: ReadSectors+F↑j
MSLOAD:03D9                 mov     ax, dx          ; start sector, hw
MSLOAD:03DB                 xor     dx, dx
MSLOAD:03DD                 cmp     ds:SecPerTrack, ax ; hw of disk (LBA) address
MSLOAD:03DD                                         ; (must not be > sectors per track)
MSLOAD:03E1                 jnb     short DoDivide
MSLOAD:03E3
MSLOAD:03E3 ErrorOut:                               ; CODE XREF: MSLOAD:01C3↑j
MSLOAD:03E3                                         ; ReadSectors:ReadError↓j
MSLOAD:03E3                 push    cs
MSLOAD:03E4                 pop     ds
MSLOAD:03E5                 mov     si, offset NonSystemDiskMsg ; "\r\nNon-System disk or disk error\r\nRe"...
MSLOAD:03E8
MSLOAD:03E8 WriteTTY:                               ; CODE XREF: ReadSectors+58↓j
MSLOAD:03E8                 lodsb
MSLOAD:03E9                 or      al, al
MSLOAD:03EB                 jz      short wait_key_reboot
MSLOAD:03ED                 mov     ah, 0Eh
MSLOAD:03EF                 mov     bl, 7
MSLOAD:03F1                 int     10h             ; - VIDEO -
MSLOAD:03F3                 jmp     short WriteTTY
MSLOAD:03F5 ; ---------------------------------------------------------------------------
MSLOAD:03F5
MSLOAD:03F5 wait_key_reboot:                        ; CODE XREF: ReadSectors+50↑j
MSLOAD:03F5                 xor     ah, ah
MSLOAD:03F7                 int     16h             ; KEYBOARD -
MSLOAD:03F9                 xor     bx, bx
MSLOAD:03FB                 mov     ds, bx
MSLOAD:03FD                 les     bx, cs:OrgDasdPtr
MSLOAD:0402                 assume es:nothing
MSLOAD:0402                 mov     si, 78h ; 'x'
MSLOAD:0405                 mov     [si], bx
MSLOAD:0407                 mov     word ptr [si+2], es
MSLOAD:040A                 int     19h             ; DISK BOOT
MSLOAD:040A                                         ; causes reboot of disk system
MSLOAD:040C
MSLOAD:040C DoDivide:                               ; CODE XREF: ReadSectors+46↑j
MSLOAD:040C                 div     ds:SecPerTrack  ; 32 bit division
MSLOAD:0410                 mov     ds:TempH, ax
MSLOAD:0413                 pop     ax              ; start sector, lw
MSLOAD:0414                 div     ds:SecPerTrack
MSLOAD:0418                 mov     bx, ds:SecPerTrack
MSLOAD:041C                 sub     bx, dx          ; dx = start sector on (same) track
MSLOAD:041E                 mov     si, bx          ; sectors to read on (same) track (remain sectors)
MSLOAD:0420                 cmp     ds:SectorCount, si
MSLOAD:0424                 jnb     short GotLength
MSLOAD:0426                 mov     si, ds:SectorCount
MSLOAD:042A
MSLOAD:042A GotLength:                              ; CODE XREF: ReadSectors+89↑j
MSLOAD:042A                 inc     dl              ; Sector numbers are 1-based
MSLOAD:042C                 mov     bl, dl
MSLOAD:042E                 mov     dx, ds:TempH    ; dx:ax = Track
MSLOAD:0432                 push    ax
MSLOAD:0433                 mov     ax, dx
MSLOAD:0435                 xor     dx, dx
MSLOAD:0437                 div     ds:NumHeads     ; Start cyl in ax, head in dl
MSLOAD:043B                 mov     ds:TempH, ax
MSLOAD:043E                 pop     ax
MSLOAD:043F                 div     ds:NumHeads     ; [TempH]:ax = Cylinder, dx = Head
MSLOAD:043F                                         ;
MSLOAD:043F                                         ; At this moment, we assume that TempH = 0,
MSLOAD:043F                                         ; ax <= 1024, dx <= 255
MSLOAD:0443                 mov     dh, dl          ;
MSLOAD:0443                                         ; Issue one read request.
MSLOAD:0443                                         ; es:bx have the transfer address,
MSLOAD:0443                                         ; al is the number of sectors.
MSLOAD:0445                 mov     cl, 6
MSLOAD:0447                 shl     ah, cl          ; Shift cyl high bits up
MSLOAD:0449                 or      ah, bl          ; Mix in with sector bits
MSLOAD:044B                 mov     ch, al          ; Setup cyl low
MSLOAD:044D                 mov     cl, ah          ; Setup cyl/high - sector
MSLOAD:044F                 mov     bx, di          ; Get back OFFSET
MSLOAD:0451                 mov     dl, ds:BootDrive ; Get drive
MSLOAD:0455                 mov     ax, si          ; Get number of sectors to read (al)
MSLOAD:0457                 mov     ah, 2           ; Read
MSLOAD:0459                 push    ax              ; Save read count
MSLOAD:045A                 push    di
MSLOAD:045B                 int     13h             ; DISK - READ SECTORS INTO MEMORY
MSLOAD:045B                                         ; AL = number of sectors to read, CH = track, CL = sector
MSLOAD:045B                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
MSLOAD:045B                                         ; Return: CF set on error, AH = status, AL = number of sectors read
MSLOAD:045D                 pop     di
MSLOAD:045E                 pop     ax
MSLOAD:045F                 pop     cx
MSLOAD:0460                 jnb     short ReadOk
MSLOAD:0462                 mov     bx, di
MSLOAD:0464                 xor     ah, ah
MSLOAD:0466                 push    cx
MSLOAD:0467                 mov     dl, ds:BootDrive
MSLOAD:046B                 push    di
MSLOAD:046C                 int     13h             ; DISK - RESET DISK SYSTEM
MSLOAD:046C                                         ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
MSLOAD:046E                 pop     di
MSLOAD:046F                 pop     cx
MSLOAD:0470                 dec     cx              ; Get retry count back
MSLOAD:0471                 jz      short ReadError
MSLOAD:0473                 jmp     TryRead         ; DATA XREF: BIOSDATA:1712↓w
MSLOAD:0473                                         ; BIOSDATA:1720↓w ...
MSLOAD:0476 ; ---------------------------------------------------------------------------
MSLOAD:0476
MSLOAD:0476 ReadError:                              ; CODE XREF: ReadSectors+D6↑j
MSLOAD:0476                 jmp     ErrorOut
MSLOAD:0479 ; ---------------------------------------------------------------------------
MSLOAD:0479                 jmp     TryRead
MSLOAD:047C ; ---------------------------------------------------------------------------
MSLOAD:047C
MSLOAD:047C ReadOk:                                 ; CODE XREF: ReadSectors+39↑j
MSLOAD:047C                                         ; ReadSectors+C5↑j
MSLOAD:047C                 xor     ah, ah          ;  Mask out read command, just get # read
MSLOAD:047E                 sub     ds:SectorCount, ax ; Bump number down
MSLOAD:0482                 jz      short EndRead
MSLOAD:0484                 add     ds:StartSecL, ax ; Where to start next time
MSLOAD:0488                 adc     ds:StartSecH, 0
MSLOAD:048D                 xor     bx, bx          ; Get number sectors read
MSLOAD:048F                 mov     bl, al
MSLOAD:0491                 mov     ax, ds:BytesPerSec
MSLOAD:0494                 mul     bx              ; Get total bytes read
MSLOAD:0496                 add     di, ax          ; Add it to offset
MSLOAD:0498                 jmp     ReadSectors
MSLOAD:049B ; ---------------------------------------------------------------------------
MSLOAD:049B
MSLOAD:049B EndRead:                                ; CODE XREF: ReadSectors+E7↑j
MSLOAD:049B                 retn
MSLOAD:049B ReadSectors     endp ; sp-analysis failed
MSLOAD:049B
MSLOAD:049C
MSLOAD:049C ; =============== S U B R O U T I N E =======================================
MSLOAD:049C
MSLOAD:049C
MSLOAD:049C GetNextFatEntry proc near               ; CODE XREF: MSLOAD:02F6↑p
MSLOAD:049C                 push    es
MSLOAD:049D                 mov     ax, ds:FatSegment
MSLOAD:04A0                 mov     es, ax
MSLOAD:04A2                 mov     ds:EndOfFile, 0FFh ; END_OF_FILE ; Assume last cluster
MSLOAD:04A7                 mov     ax, ds:CurrentClusterL ; Get last cluster
MSLOAD:04AA                 mov     di, ds:CurrentClusterH
MSLOAD:04AE
MSLOAD:04AE chk_fat32_type:                         ; FAT32 (CHS) fs ?
MSLOAD:04AE                 cmp     ds:FatType, 0Bh
MSLOAD:04B3                 jnz     short chk_fat_type ; no
MSLOAD:04B5
MSLOAD:04B5 Got32Bit:                               ; Multiply cluster number by 4
MSLOAD:04B5                 add     ax, ax
MSLOAD:04B7                 adc     di, di
MSLOAD:04B9                 add     ax, ax
MSLOAD:04BB                 adc     di, di          ; Get the FAT offset (di:si)
MSLOAD:04BD                 mov     si, ax
MSLOAD:04BF                 call    GetFatSector
MSLOAD:04C2                 mov     ax, es:[bx]
MSLOAD:04C5                 mov     di, es:[bx+2]
MSLOAD:04C9                 cmp     di, 0FFFh       ; FAT32 cluster numbers are 28 bit numbers
MSLOAD:04C9                                         ; (higher 4 bits are -must be- zero)
MSLOAD:04CD                 jnz     short GotFAT32ClusterDone
MSLOAD:04CF                 cmp     ax, 0FFF8h
MSLOAD:04D2
MSLOAD:04D2 GotFAT32ClusterDone:                    ; CODE XREF: GetNextFatEntry+31↑j
MSLOAD:04D2                 jmp     short GotClusterDoneJ
MSLOAD:04D4 ; ---------------------------------------------------------------------------
MSLOAD:04D4
MSLOAD:04D4 chk_fat_type:                           ; CODE XREF: GetNextFatEntry+17↑j
MSLOAD:04D4                 cmp     ds:FatType, 1
MSLOAD:04D9                 jnz     short Got16Bit
MSLOAD:04DB
MSLOAD:04DB Got12Bit:
MSLOAD:04DB                 mov     si, ax
MSLOAD:04DD                 mov     dx, di
MSLOAD:04DF                 shr     dx, 1
MSLOAD:04E1                 rcr     ax, 1
MSLOAD:04E3                 add     si, ax
MSLOAD:04E5                 adc     di, dx          ; di:si = dx:ax * 1.5 = dx:ax + dx:ax/2
MSLOAD:04E7                 push    dx
MSLOAD:04E8                 xor     dx, dx
MSLOAD:04EA                 call    GetFatSector
MSLOAD:04ED                 pop     dx
MSLOAD:04EE                 jnz     short ClusterOk
MSLOAD:04F0                 mov     al, es:[bx]     ; Spitted cluster number,
MSLOAD:04F0                                         ;  read next FAT sector
MSLOAD:04F3                 mov     byte ptr ds:TempCluster, al
MSLOAD:04F6                 add     si, 1
MSLOAD:04F9                 adc     di, 0
MSLOAD:04FC                 push    dx
MSLOAD:04FD                 xor     dx, dx
MSLOAD:04FF                 call    GetFatSector    ; Read next fat sector
MSLOAD:0502                 pop     dx
MSLOAD:0503                 mov     al, byte ptr es:0
MSLOAD:0507                 mov     byte ptr ds:TempCluster+1, al
MSLOAD:050A                 mov     ax, ds:TempCluster
MSLOAD:050D                 jmp     short EvenOdd
MSLOAD:050F ; ---------------------------------------------------------------------------
MSLOAD:050F
MSLOAD:050F ClusterOk:                              ; CODE XREF: GetNextFatEntry+52↑j
MSLOAD:050F                 mov     ax, es:[bx]
MSLOAD:0512
MSLOAD:0512 EvenOdd:                                ; CODE XREF: GetNextFatEntry+71↑j
MSLOAD:0512                 test    cs:CurrentClusterL, 1
MSLOAD:0519                 jnz     short OddResult
MSLOAD:051B                 and     ax, 0FFFh
MSLOAD:051E                 jmp     short TestEOF
MSLOAD:0520 ; ---------------------------------------------------------------------------
MSLOAD:0520
MSLOAD:0520 OddResult:                              ; CODE XREF: GetNextFatEntry+7D↑j
MSLOAD:0520                 mov     cl, 4
MSLOAD:0522                 shr     ax, cl
MSLOAD:0524
MSLOAD:0524 TestEOF:                                ; CODE XREF: GetNextFatEntry+82↑j
MSLOAD:0524                 xor     di, di
MSLOAD:0526                 cmp     ax, 0FF8h
MSLOAD:0529                 jnb     short GotClusterDone
MSLOAD:052B                 jmp     short NotLastCluster
MSLOAD:052D ; ---------------------------------------------------------------------------
MSLOAD:052D
MSLOAD:052D Got16Bit:                               ; CODE XREF: GetNextFatEntry+3D↑j
MSLOAD:052D                 push    dx
MSLOAD:052E                 xor     dx, dx
MSLOAD:0530                 shl     ax, 1           ; Multiply cluster by 2
MSLOAD:0532                 adc     di, di
MSLOAD:0534                 mov     si, ax          ; Get the FAT offset (di:si)
MSLOAD:0536                 call    GetFatSector
MSLOAD:0539                 pop     dx
MSLOAD:053A                 xor     di, di          ; HW of cluster number is 0
MSLOAD:053C                 mov     ax, es:[bx]
MSLOAD:053F                 cmp     ax, 0FFF8h
MSLOAD:0542
MSLOAD:0542 GotClusterDoneJ:                        ; CODE XREF: GetNextFatEntry:GotFAT32ClusterDone↑j
MSLOAD:0542                 jnb     short GotClusterDone
MSLOAD:0544
MSLOAD:0544 NotLastCluster:                         ; CODE XREF: GetNextFatEntry+8F↑j
MSLOAD:0544                 mov     cs:EndOfFile, 0 ; NOT END_OF_FILE ; Assume not last cluster
MSLOAD:054A
MSLOAD:054A GotClusterDone:                         ; CODE XREF: GetNextFatEntry+8D↑j
MSLOAD:054A                                         ; GetNextFatEntry:GotClusterDoneJ↑j
MSLOAD:054A                 pop     es
MSLOAD:054B                 retn
MSLOAD:054B GetNextFatEntry endp
MSLOAD:054B
MSLOAD:054C
MSLOAD:054C ; =============== S U B R O U T I N E =======================================
MSLOAD:054C
MSLOAD:054C
MSLOAD:054C GetFatSector    proc near               ; CODE XREF: GetNextFatEntry+23↑p
MSLOAD:054C                                         ; GetNextFatEntry+4E↑p ...
MSLOAD:054C                 push    ax              ; di:si = byte offset in (entire) FAT
MSLOAD:054D                 push    si
MSLOAD:054E                 push    di
MSLOAD:054F                 mov     ax, di          ; 32 bit division (dx:ax/512)
MSLOAD:0551                 xor     dx, dx
MSLOAD:0553                 mov     cx, ds:BytesPerSec
MSLOAD:0557                 div     cx
MSLOAD:0559                 mov     bx, ax
MSLOAD:055B                 mov     ax, si
MSLOAD:055D                 mov     cx, ds:BytesPerSec
MSLOAD:0561                 div     cx              ; dx = byte offset in the FAT sector
MSLOAD:0563                 cmp     bx, ds:LastFatSectorH ; FAT32 (32 bit cluster numbers)
MSLOAD:0567                 jnz     short not_same_fat_sector
MSLOAD:0569                 cmp     ax, ds:LastFatSectorL ; The same fat sector?
MSLOAD:056D
MSLOAD:056D not_same_fat_sector:                    ; CODE XREF: GetFatSector+1B↑j
MSLOAD:056D                 jz      short SplitChk  ; Don't need to read it again.
MSLOAD:056F                 mov     ds:LastFatSectorL, ax
MSLOAD:0572                 mov     ds:LastFatSectorH, bx
MSLOAD:0576                 push    dx
MSLOAD:0577                 mov     dx, bx
MSLOAD:0579                 add     ax, ds:HiddenSectorsL
MSLOAD:057D                 adc     dx, ds:HiddenSectorsH
MSLOAD:0581                 add     ax, ds:ReservSectors
MSLOAD:0585                 adc     dx, 0
MSLOAD:0588                 mov     ds:StartSecL, ax
MSLOAD:058B                 mov     ds:StartSecH, dx
MSLOAD:058F                 mov     ds:SectorCount, 1
MSLOAD:0595                 xor     di, di          ; buffer address: es:0
MSLOAD:0597                 call    ReadSectors
MSLOAD:059A                 pop     dx
MSLOAD:059B                 mov     cx, ds:BytesPerSec
MSLOAD:059F
MSLOAD:059F SplitChk:                               ; CODE XREF: GetFatSector:not_same_fat_sector↑j
MSLOAD:059F                 dec     cx              ; cx = sector size - 1  (= 511)
MSLOAD:05A0                 cmp     dx, cx          ; If last byte of sector, splitted entry.
MSLOAD:05A2                 mov     bx, dx          ; set bx to dx
MSLOAD:05A4                 pop     di
MSLOAD:05A5                 pop     si
MSLOAD:05A6                 pop     ax
MSLOAD:05A7                 retn                    ; If zf = 1, it is splitted
MSLOAD:05A7 GetFatSector    endp                    ;  (next FAT12 sector will be read)
MSLOAD:05A7
MSLOAD:05A7 ; ---------------------------------------------------------------------------
MSLOAD:05A8 NonSystemDiskMsg db 0Dh,0Ah             ; DATA XREF: ReadSectors+4A↑o
MSLOAD:05A8                 db 'Non-System disk or disk error',0Dh,0Ah ; EndOfLoader (MSLOAD:05F0h)
MSLOAD:05A8                 db 'Replace and press any key when ready',0Dh,0Ah,0
MSLOAD:05A8 MSLOAD          ends
MSLOAD:05A8
BIOSDATA:0000 ; ---------------------------------------------------------------------------
BIOSDATA:0000 ; ===========================================================================
BIOSDATA:0000
BIOSDATA:0000 ; Segment type: Regular
BIOSDATA:0000 BIOSDATA        segment byte public 'BIOSDATA' use16
BIOSDATA:0000                 assume cs:BIOSDATA
BIOSDATA:0000                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
BIOSDATA:0000
BIOSDATA:0000 hdrv_pat:                               ; CODE XREF: BIOSDATA:0202↓j
BIOSDATA:0000                                         ; DATA XREF: BIOSDATA:1FCC↓w
BIOSDATA:0000                 jmp     init            ; BData_start
BIOSDATA:0000 ; ---------------------------------------------------------------------------
BIOSDATA:0003 DosDataSg       dw 0                    ; DATA XREF: cdev_entry+9↓r
BIOSDATA:0003                                         ; BIOSDATA:232E↓w
BIOSDATA:0005 bios_i2f        db 0EAh                 ; far jump to int_2f
BIOSDATA:0006                 dw offset i2f_handler
BIOSDATA:0008 bios_i2f_seg    dw 364h                 ; DATA XREF: BIOSCODE:0042↓w
BIOSDATA:0008                                         ; IOSYSCODESEG (IBMBIO.COM code segment)
BIOSDATA:0008                                         ; BIOSCODE (2F4h+070h) segment
BIOSDATA:000A romstartaddr    dw 0
BIOSDATA:000C altah           db 0                    ; DATA XREF: BIOSDATA:cbreak↓w
BIOSDATA:000C                                         ; BIOSDATA:07FC↓o ...
BIOSDATA:000D inHMA           db 0                    ; DATA XREF: cdev_entry↓r
BIOSDATA:000D                                         ; block13↓r ...
BIOSDATA:000E xms             dd 0                    ; DATA XREF: EnsureA20On+9↓r
BIOSDATA:000E                                         ; AllocHMA+10↓w ...
BIOSDATA:0012 ptrsav          dd 0                    ; DATA XREF: BIOSDATA:strategy↓w
BIOSDATA:0012                                         ; BIOSCODE:0065↓r ...
BIOSDATA:0016 auxbuf          db 4 dup(0)             ; DATA XREF: getbx+4↓o
BIOSDATA:001A zeroseg         dw 0                    ; DATA XREF: checksingle+45↓r
BIOSDATA:001A                                         ; checksingle+5F↓r ...
BIOSDATA:001C i13_ds          dw 0                    ; DATA XREF: block13:skipa20↓w
BIOSDATA:001C                                         ; block13+16↓r ...
BIOSDATA:001E prevoper        dw 0                    ; DATA XREF: BIOSCODE:ps2_special_stuff↓r
BIOSDATA:001E                                         ; BIOSCODE:18CD↓r ...
BIOSDATA:0020 number_of_sec   db 0                    ; DATA XREF: BIOSCODE:1950↓w
BIOSDATA:0020                                         ; BIOSCODE:ok11_op↓w
BIOSDATA:0021 auxnum          dw 0                    ; DATA XREF: BIOSCODE:005E↓w
BIOSDATA:0021                                         ; prnop↓r ...
BIOSDATA:0023 res_dev_list    dw offset auxdev2       ; DATA XREF: BIOSDATA:1F71↓o
BIOSDATA:0023                                         ; CONHeader
BIOSDATA:0023                                         ; HEADER FOR DEVICE "CON"
BIOSDATA:0025                 dw 70h
BIOSDATA:0027                 dw 8013h
BIOSDATA:0029                 dw offset strategy
BIOSDATA:002B                 dw offset con_entry
BIOSDATA:002D                 db 'CON     '
BIOSDATA:0035 auxdev2         dw offset prndev2       ; DATA XREF: BIOSDATA:res_dev_list↑o
BIOSDATA:0035                                         ; HEADER FOR DEVICE "AUX"
BIOSDATA:0037                 dw 70h
BIOSDATA:0039                 dw 8000h
BIOSDATA:003B off_62B         dw offset strategy
BIOSDATA:003D off_62D         dw offset aux0_entry
BIOSDATA:003F asc_62F         db 'AUX     '
BIOSDATA:0047 prndev2         dw offset timdev        ; DATA XREF: BIOSDATA:auxdev2↑o
BIOSDATA:0047                                         ; HEADER FOR DEVICE "PRN"
BIOSDATA:0049                 dw 70h
BIOSDATA:004B                 dw 0A0C0h
BIOSDATA:004D                 dw offset strategy
BIOSDATA:004F                 dw offset prn0_entry
BIOSDATA:0051                 db 'PRN     '
BIOSDATA:0059 timdev          dw offset dskdev        ; DATA XREF: BIOSDATA:prndev2↑o
BIOSDATA:0059                                         ; HEADER FOR DEVICE "CLOCK$"
BIOSDATA:005B                 dw 70h
BIOSDATA:005D                 dw 8008h
BIOSDATA:005F                 dw offset strategy
BIOSDATA:0061                 dw offset tim_entry
BIOSDATA:0063                 db 'CLOCK$  '
BIOSDATA:006B dskdev          dw offset com1dev       ; DATA XREF: BIOSDATA:timdev↑o
BIOSDATA:006B                                         ; HEADER FOR DISK DEVICES
BIOSDATA:006D                 dw 70h
BIOSDATA:006F                 dw 48C2h
BIOSDATA:0071                 dw offset strategy
BIOSDATA:0073                 dw offset dsk_entry
BIOSDATA:0075 drvmax          db 4                    ; DATA XREF: BIOSDATA:1FD5↓w
BIOSDATA:0075                                         ; BIOSDATA:loop_drive↓r ...
BIOSDATA:0075                                         ; maximum number of drives
BIOSDATA:0076 step_drv        db 0FEh                 ; DATA XREF: read_sector:okret2↓w
BIOSDATA:0076                                         ; Disk+50↓r ...
BIOSDATA:0076                                         ; -2 ; last drive accessed
BIOSDATA:0077 fhave96         db 0                    ; DATA XREF: BIOSDATA:20CF↓w
BIOSDATA:0077                                         ; BIOSDATA:212B↓w ...
BIOSDATA:0077                                         ; 96tpi support
BIOSDATA:0078 single          db 0                    ; DATA XREF: BIOSDATA:settwodrive↓w
BIOSDATA:0078                                         ; BIOSDATA:219C↓r ...
BIOSDATA:0078                                         ; used to detect single drive systems
BIOSDATA:0079 fhavek09        db 0                    ; DATA XREF: BIOSDATA:2302↓w
BIOSDATA:0079                                         ; con_rdnd+F↓r
BIOSDATA:0079                                         ; indicates if this is a k09 or not
BIOSDATA:0079                                         ; used by console driver.
BIOSDATA:007A fsetowner       db 0                    ; DATA XREF: checksingle+32↓r
BIOSDATA:007A                                         ; ioctl_getown+21↓w ...
BIOSDATA:007A                                         ; = 1 if we are setting the owner of a drive.
BIOSDATA:007A                                         ; (examined by checksingle)
BIOSDATA:007B com1dev         dw offset lpt1dev       ; DATA XREF: BIOSDATA:dskdev↑o
BIOSDATA:007B                                         ; Device Header for device "COM1"
BIOSDATA:007D                 dw 70h
BIOSDATA:007F                 dw 8000h
BIOSDATA:0081                 dw offset strategy
BIOSDATA:0083                 dw offset aux0_entry
BIOSDATA:0085                 db 'COM1    '
BIOSDATA:008D lpt1dev         dw offset lpt2dev       ; DATA XREF: BIOSDATA:com1dev↑o
BIOSDATA:008D                                         ; Device Header for device LPT1
BIOSDATA:008F                 dw 70h
BIOSDATA:0091                 dw 0A0C0h
BIOSDATA:0093                 dw offset strategy
BIOSDATA:0095                 dw offset prn1_entry
BIOSDATA:0097                 db 'LPT1    '
BIOSDATA:009F lpt2dev         dw offset lpt3dev       ; DATA XREF: BIOSDATA:lpt1dev↑o
BIOSDATA:009F                                         ; Device Header for device LPT2
BIOSDATA:00A1                 dw 70h
BIOSDATA:00A3                 dw 0A0C0h
BIOSDATA:00A5                 dw offset strategy
BIOSDATA:00A7                 dw offset prn2_entry
BIOSDATA:00A9                 db 'LPT2    '
BIOSDATA:00B1                 db 3 dup(0)
BIOSDATA:00B4 Orig13          dd 0                    ; DATA XREF: call_orig13+5↓r
BIOSDATA:00B4                                         ; BIOSDATA:1DB0↓w ...
BIOSDATA:00B4                                         ; to make Orig13 offset 0B4h
BIOSDATA:00B8 lpt3dev         dw offset com2dev       ; DATA XREF: BIOSDATA:lpt2dev↑o
BIOSDATA:00B8                                         ; Device Header for device LPT3
BIOSDATA:00BA                 dw 70h
BIOSDATA:00BC                 dw 0A0C0h
BIOSDATA:00BE                 dw offset strategy
BIOSDATA:00C0                 dw offset prn3_entry
BIOSDATA:00C2                 db 'LPT3    '
BIOSDATA:00CA com2dev         dw offset com3dev       ; DATA XREF: BIOSDATA:lpt3dev↑o
BIOSDATA:00CA                                         ; Device Header for device "COM2"
BIOSDATA:00CC                 dw 70h
BIOSDATA:00CE                 dw 8000h
BIOSDATA:00D0                 dw offset strategy
BIOSDATA:00D2                 dw offset aux1_entry
BIOSDATA:00D4                 db 'COM2    '
BIOSDATA:00DC com3dev         dw offset com4dev       ; DATA XREF: BIOSDATA:com2dev↑o
BIOSDATA:00DC                                         ; Device Header for device "COM3"
BIOSDATA:00DE                 dw 70h
BIOSDATA:00E0                 dw 8000h
BIOSDATA:00E2                 dw offset strategy
BIOSDATA:00E4                 dw offset aux2_entry
BIOSDATA:00E6                 db 'COM3    '
BIOSDATA:00EE com4dev         dw 0FFFFh               ; DATA XREF: BIOSDATA:com3dev↑o
BIOSDATA:00EE                                         ; Device Header for device "COM4"
BIOSDATA:00F0                 dw 70h
BIOSDATA:00F2                 dw 8000h
BIOSDATA:00F4                 dw offset strategy
BIOSDATA:00F6                 dw offset aux3_entry
BIOSDATA:00F8                 db 'COM4    '
BIOSDATA:0100 RomVectors      db 10h                  ; DATA XREF: BIOSDATA:0761↓o
BIOSDATA:0100                                         ; BIOSDATA:1D94↓o
BIOSDATA:0101 Old10           dd 0
BIOSDATA:0105                 db 13h
BIOSDATA:0106 Old13           dd 0                    ; DATA XREF: BIOSDATA:atd1↓r
BIOSDATA:0106                                         ; BIOSDATA:no_hookit↓r ...
BIOSDATA:010A                 db 15h
BIOSDATA:010B Old15           dd 0                    ; DATA XREF: BIOSDATA:Old15_j↓r
BIOSDATA:010F                 db 19h
BIOSDATA:0110 Old19           dd 0
BIOSDATA:0114                 db 1Bh
BIOSDATA:0115 Old1B           dd 0                    ; ;
BIOSDATA:0115                                         ; EndRomVectors equ $
BIOSDATA:0115                                         ; NUMROMVECTORS equ ((EndRomVectors - RomVectors)/5)
BIOSDATA:0115                                         ; ;
BIOSDATA:0119 start_bds       dw offset bds1          ; DATA XREF: BIOSDATA:2024↓o
BIOSDATA:0119                                         ; remap↓r ...
BIOSDATA:0119                                         ; Start of linked list of BDS's
BIOSDATA:011B                 dw 70h                  ; BIOSDATA segment
BIOSDATA:011D accesscount     db 0                    ; DATA XREF: Check_Time_Of_Access+12↓r
BIOSDATA:011D                                         ; Check_Time_Of_Access:timecheck_ret↓w ...
BIOSDATA:011E tim_drv         db 0FFh                 ; DATA XREF: BIOSCODE:05D4↓w
BIOSDATA:011E                                         ; BIOSCODE:0600↓r ...
BIOSDATA:011F medbyt          db 0                    ; DATA XREF: diskio+D↓w
BIOSDATA:011F                                         ; fat_check+3↓r
BIOSDATA:0120 rflag           db 2                    ; DATA XREF: BIOSCODE:dsk_writv↓w
BIOSDATA:0120                                         ; BIOSCODE:dsk_writ↓w ...
BIOSDATA:0120                                         ; 2 for read, 3 for write
BIOSDATA:0121 verify          db 0                    ; 1 if verify after write
BIOSDATA:0122 seccnt          dw 0                    ; DATA XREF: diskio+19↓w
BIOSDATA:0122                                         ; diskio+BF↓r ...
BIOSDATA:0124                 db 0                    ; -- pad where hardnum was
BIOSDATA:0125 dsktnum         db 1                    ; DATA XREF: BIOSDATA:1FD8↓w
BIOSDATA:0125                                         ; BIOSDATA:2245↓r ...
BIOSDATA:0125                                         ; number of diskette drives
BIOSDATA:0126 motorstartup    db 0                    ; DATA XREF: BIOSDATA:1F13↓w
BIOSDATA:0126                                         ; iosetup+20↓w ...
BIOSDATA:0126                                         ; value from table
BIOSDATA:0127 settlecurrent   db 0                    ; DATA XREF: iosetup+40↓w
BIOSDATA:0127                                         ; done+1F↓r
BIOSDATA:0127                                         ; value from table
BIOSDATA:0128 settleslow      db 0                    ; DATA XREF: iosetup+45↓w
BIOSDATA:0128                                         ; normspeed+9↓r
BIOSDATA:0128                                         ; slow settle value
BIOSDATA:0129 nextspeed       db 0                    ; value of speed to be used
BIOSDATA:012A save_head_sttl  db 0                    ; DATA XREF: read_sector+37↓w
BIOSDATA:012A                                         ; read_sector+4D↓r
BIOSDATA:012A                                         ; used by read_sector routine
BIOSDATA:012B save_eot        db 0                    ; DATA XREF: iosetup+23↓w
BIOSDATA:012B                                         ; done+18↓r
BIOSDATA:012B                                         ; saved eot from the default DPT
BIOSDATA:012C eot             db 9                    ; DATA XREF: BIOSDATA:201F↓w
BIOSDATA:012C                                         ; BIOSDATA:20AC↓r ...
BIOSDATA:012D dpt             dd 0                    ; DATA XREF: read_sector+2B↓r
BIOSDATA:012D                                         ; read_sector+51↓r ...
BIOSDATA:012D                                         ; pointer to Disk Parameter Table
BIOSDATA:0131 cursec          db 0                    ; DATA XREF: diskio+157↓w
BIOSDATA:0131                                         ; block+1D↓r ...
BIOSDATA:0131                                         ; current sector
BIOSDATA:0132 curhd           db 0                    ; DATA XREF: diskio+173↓w
BIOSDATA:0132                                         ; Disk+41↓r ...
BIOSDATA:0132                                         ; current head
BIOSDATA:0133 curtrk          dw 0                    ; DATA XREF: diskio+177↓w
BIOSDATA:0133                                         ; Disk+1F↓r ...
BIOSDATA:0133                                         ; current track
BIOSDATA:0135 spsav           dw 0                    ; DATA XREF: diskio+1D↓w
BIOSDATA:0135                                         ; Disk+13E↓r ...
BIOSDATA:0135                                         ; save the stack pointer
BIOSDATA:0137 formt_eot       db 8                    ; DATA XREF: SetDasd+5B↓w
BIOSDATA:0137                                         ; ToRom+21↓r
BIOSDATA:0137                                         ; eot used for format
BIOSDATA:0138 hdnum           db 0                    ; DATA XREF: BIOSCODE:110D↓w
BIOSDATA:0138                                         ; ToRom+47↓r
BIOSDATA:0138                                         ; head number
BIOSDATA:0139 trknum          dw 0                    ; DATA XREF: BIOSCODE:110A↓w
BIOSDATA:0139                                         ; ToRom:GotValidDpt↓r
BIOSDATA:0139                                         ; track being manipulated
BIOSDATA:013B gap_patch       db 50h                  ; DATA XREF: SetDasd+1A↓w
BIOSDATA:013B                                         ; SetDasd+3A↓w ...
BIOSDATA:013B                                         ; format gap patched into dpt
BIOSDATA:013C errin           db 0CCh                 ; DATA XREF: maperror+C↓o
BIOSDATA:013C                                         ; write fault (hard disk)
BIOSDATA:013D                 db 80h                  ; timeout (not ready)
BIOSDATA:013E                 db 40h                  ; seek failed
BIOSDATA:013F                 db 10h                  ; uncorrectable CRC or ECC error on read
BIOSDATA:0140                 db 8                    ; DMA overrun
BIOSDATA:0141                 db 6                    ; disk changed (floppy)
BIOSDATA:0142                 db 4                    ; sector not found/read error
BIOSDATA:0143                 db 3                    ; disk write-protected
BIOSDATA:0144                 db 1                    ; invalid function in AH or invalid parameter
BIOSDATA:0145                 db 0B2h                 ; volume not removable
BIOSDATA:0146 lsterr          db 0                    ; DATA XREF: maperror+6↓w
BIOSDATA:0147 errout          db 10                   ; write fault error
BIOSDATA:0148                 db 2                    ; no response (timeout)
BIOSDATA:0149                 db 6                    ; seek failure
BIOSDATA:014A                 db 4                    ; bad crc
BIOSDATA:014B                 db 4                    ; dma overrun
BIOSDATA:014C                 db 15                   ; invalid media change
BIOSDATA:014D                 db 8                    ; sector not found
BIOSDATA:014E                 db 0                    ; write attempt to write-protect disk
BIOSDATA:014F                 db 3                    ; unknown command error
BIOSDATA:0150                 db 3                    ; unknown command error
BIOSDATA:0151                 db 12                   ; general error
BIOSDATA:0152 disksector      db 174 dup(0)           ; DATA XREF: BIOSDATA:1C54↓o
BIOSDATA:0152                                         ; sethard+19A↓o ...
BIOSDATA:0152                                         ; 512 byte buffer
BIOSDATA:0200 ; ---------------------------------------------------------------------------
BIOSDATA:0200
BIOSDATA:0200 JB_sign:                                ; 'BJ' (nasm) ; dw 424Ah
BIOSDATA:0200                 dec     dx
BIOSDATA:0201                 inc     dx
BIOSDATA:0202                 jmp     hdrv_pat        ; jmp BData_start
BIOSDATA:0202 ; ---------------------------------------------------------------------------
BIOSDATA:0205 IBMBIOCOM$      db '@#IBM:12.01.2003.build_1.32#@ IBMBIO.COM(USA)',0
BIOSDATA:0233                 db 287 dup(0)
BIOSDATA:0352 bds1            dw offset bds2          ; DATA XREF: BIOSDATA:start_bds↑o
BIOSDATA:0352                                         ; dword link to next structure
BIOSDATA:0354                 dw 70h
BIOSDATA:0356                 db 0                    ; int 13h drive number
BIOSDATA:0357                 db 0                    ; logical drive letter
BIOSDATA:0358 fdrive1         dw 512                  ; DATA XREF: BIOSDATA:dskdrvs↓o
BIOSDATA:0358                                         ; physical sector size in bytes
BIOSDATA:035A                 db 0FFh                 ; sectors/allocation unit
BIOSDATA:035B                 dw 1                    ; reserved sectors for dos
BIOSDATA:035D                 db 2                    ; no of file allocation tables
BIOSDATA:035E                 dw 64                   ; number of root directory entries
BIOSDATA:0360                 dw 360                  ; number of sectors (at 512 bytes each)
BIOSDATA:0362                 db 0                    ; media descriptor, initially 0
BIOSDATA:0363                 dw 2                    ; number of fat sectors
BIOSDATA:0365                 dw 9                    ; sector limit (sectors per track)
BIOSDATA:0367                 dw 1                    ; head limit (number of heads - 1)
BIOSDATA:0369                 dd 0                    ; hidden sector count
BIOSDATA:036D                 dd 0                    ; number of sectors (32 bit)
BIOSDATA:0371                 dd 0                    ; BPB_FATSz32 ; FAT32 FAT size in sectors ; 4 bytes
BIOSDATA:0371                                         ;   BS_DrvNum ; FAT INT 13h drive number ; 1 byte
BIOSDATA:0371                                         ;   BS_Reserved1 ; FAT reserved byte = 0 ; 1 byte
BIOSDATA:0371                                         ;   BS_BootSig ; FAT Extended boot signature = 29h ; 1 byte
BIOSDATA:0371                                         ;   BS_VolID ; FAT Volume serial number ; 4 bytes
BIOSDATA:0375                 dw 0                    ; BPB_ExtFlags ; FAT32 Extended Flags
BIOSDATA:0377                 dw 0                    ; BPB_FSVer ; FAT32 fs/volume version
BIOSDATA:0379                 dd 0                    ; BPB_RootClus ; FAT32 root directory's first cluster number
BIOSDATA:037D                 dw 0FFFFh               ; BPB_FSInfo ; FAT32 FSINFO sector number = -1 (initial)
BIOSDATA:037F                 dw 0FFFFh               ; BPB_BkBootSec ; FAT32 backup boot sector number = -1 (initial)
BIOSDATA:0381                 db 12 dup(0)            ; BPB_Reserved  ; FAT32 reserved field = 0, 12 bytes
BIOSDATA:038D                 db 0                    ; true => large fats
BIOSDATA:038E                 dw 0                    ; open ref. count
BIOSDATA:0390                 db 3                    ; form factor
BIOSDATA:0391                 dw 20h                  ; various flags
BIOSDATA:0393                 dw 40                   ; number of cylinders
BIOSDATA:0395 recommended_bps dw 512                  ; recommended bps for this drive
BIOSDATA:0395                                         ; recbpb1
BIOSDATA:0397                 db 1
BIOSDATA:0398                 dw 1
BIOSDATA:039A                 db 2
BIOSDATA:039B                 dw 224                  ; number of root directory entries
BIOSDATA:039D                 dw 360
BIOSDATA:039F                 db 0F0h                 ; media descriptor, initially 0F0h
BIOSDATA:03A0                 dw 2
BIOSDATA:03A2                 dw 9
BIOSDATA:03A4                 dw 2
BIOSDATA:03A6                 dd 0
BIOSDATA:03AA                 dd 0
BIOSDATA:03AE                 dd 0
BIOSDATA:03B2                 dd 0
BIOSDATA:03B6                 dd 0
BIOSDATA:03BA                 dd 0FFFFFFFFh
BIOSDATA:03BE                 dd 0
BIOSDATA:03C2                 dd 0
BIOSDATA:03C6                 dd 0
BIOSDATA:03CA                 db 0FFh                 ; last track accessed on this drive
BIOSDATA:03CB                 dd 0FFFFFFFFh           ; keep these two contiguous (?)
BIOSDATA:03CF                 db 'NO NAME    ',0      ; volume id for this disk
BIOSDATA:03DB                 dd 0                    ; current volume serial from boot record
BIOSDATA:03DF                 db 'FAT12   ',0         ; current file system id from boot record
BIOSDATA:03E8 bds2            dw 0FFFFh               ; DATA XREF: BIOSDATA:bds1↑o
BIOSDATA:03EA                 dw 70h
BIOSDATA:03EC                 db 0
BIOSDATA:03ED                 db 0
BIOSDATA:03EE fdrive2         dw 512                  ; DATA XREF: BIOSDATA:053E↓o
BIOSDATA:03F0                 db 0FFh
BIOSDATA:03F1                 dw 1
BIOSDATA:03F3                 db 2
BIOSDATA:03F4                 dw 64
BIOSDATA:03F6                 dw 360
BIOSDATA:03F8                 db 0
BIOSDATA:03F9                 dw 2
BIOSDATA:03FB                 dw 9
BIOSDATA:03FD                 dw 1
BIOSDATA:03FF                 dd 0
BIOSDATA:0403                 dd 0
BIOSDATA:0407                 dd 0
BIOSDATA:040B                 dd 0
BIOSDATA:040F                 dd 0
BIOSDATA:0413                 dd 0FFFFFFFFh
BIOSDATA:0417                 dd 0
BIOSDATA:041B                 dd 0
BIOSDATA:041F                 dd 0
BIOSDATA:0423                 db 0
BIOSDATA:0424                 dw 0
BIOSDATA:0426                 db 3
BIOSDATA:0427                 dw 20h
BIOSDATA:0429                 dw 40
BIOSDATA:042B recbpb2         dw 512
BIOSDATA:042D                 db 1
BIOSDATA:042E                 dw 1
BIOSDATA:0430                 db 2
BIOSDATA:0431                 dw 224
BIOSDATA:0433                 dw 360
BIOSDATA:0435                 db 0F0h
BIOSDATA:0436                 dw 2
BIOSDATA:0438                 dw 9
BIOSDATA:043A                 dw 2
BIOSDATA:043C                 dd 0
BIOSDATA:0440                 dd 0
BIOSDATA:0444                 dd 0
BIOSDATA:0448                 dd 0
BIOSDATA:044C                 dd 0
BIOSDATA:0450                 dd 0FFFFFFFFh
BIOSDATA:0454                 dd 0
BIOSDATA:0458                 dd 0
BIOSDATA:045C                 dd 0
BIOSDATA:0460                 db 0FFh
BIOSDATA:0461                 dd 0FFFFFFFFh
BIOSDATA:0465                 db 'NO NAME    ',0
BIOSDATA:0471                 dd 0
BIOSDATA:0475                 db 'FAT12   ',0
BIOSDATA:047E keyrd_func      db 0                    ; DATA XREF: BIOSDATA:1FB9↓w
BIOSDATA:047E                                         ; chrin↓r ...
BIOSDATA:047F keysts_func     db 1                    ; DATA XREF: BIOSDATA:1FBF↓w
BIOSDATA:047F                                         ; con_rdnd+7↓r ...
BIOSDATA:0480 printdev        db 0                    ; DATA XREF: BIOSCODE:0061↓w
BIOSDATA:0480                                         ; BIOSCODE:029D↓r ...
BIOSDATA:0480                                         ; printer device index
BIOSDATA:0481 wait_count      dw 50h                  ; DATA XREF: BIOSCODE:02A3↓r
BIOSDATA:0481                                         ; BIOSCODE:02E1↓r ...
BIOSDATA:0481                                         ; retry counts for printers
BIOSDATA:0483                 dw 50h
BIOSDATA:0485                 dw 50h
BIOSDATA:0487                 dw 50h
BIOSDATA:0489 daycnt          dw 0                    ; DATA XREF: BIOSDATA:185A↓w
BIOSDATA:0489                                         ; cmos_clock_read+33↓w ...
BIOSDATA:0489                                         ; flag for updating daycnt
BIOSDATA:048B t_switch        db 0                    ; DATA XREF: GetTickCnt+6↓r
BIOSDATA:048B                                         ; doconf+A46↓w
BIOSDATA:048C havecmoscloc    db 0                    ; DATA XREF: cmos_clock_read:clock_present↓w
BIOSDATA:048C                                         ; BIOSCODE:03EE↓r ...
BIOSDATA:048D base_century    db 19                   ; DATA XREF: daycnttoday+C↓w
BIOSDATA:048D                                         ; daycnttoday:century20↓w ...
BIOSDATA:048E base_year       db 80                   ; DATA XREF: daycnttoday+32↓w
BIOSDATA:048E                                         ; daycnttoday+42↓w ...
BIOSDATA:048F month_table     db 31                   ; DATA XREF: read_real_date+9D↓o
BIOSDATA:048F                                         ; daycnttoday+6F↓o
BIOSDATA:0490 february        db 28                   ; DATA XREF: daycnttoday:leapyear↓w
BIOSDATA:0490                                         ; daycnttoday:month_done↓w
BIOSDATA:0491                 db 31
BIOSDATA:0492                 db 30
BIOSDATA:0493                 db 31
BIOSDATA:0494                 db 30
BIOSDATA:0495                 db 31
BIOSDATA:0496                 db 31
BIOSDATA:0497                 db 30
BIOSDATA:0498                 db 31
BIOSDATA:0499                 db 30
BIOSDATA:049A                 db 31
BIOSDATA:049B set_id_flag     db 0                    ; DATA XREF: get_bpb+10↓w
BIOSDATA:049B                                         ; get_bpb+1A↓r ...
BIOSDATA:049B                                         ; flag for getbp routine
BIOSDATA:049C start_sec_h     dw 0                    ; DATA XREF: getclus+F9↓w
BIOSDATA:049C                                         ; get_fat_sector+35↓w ...
BIOSDATA:049C                                         ; starting sector number high word
BIOSDATA:049E saved_word      dw 0                    ; DATA XREF: sethard+174↓w
BIOSDATA:049E                                         ; sethard+185↓r ...
BIOSDATA:049E                                         ; tempory saving place for a word
BIOSDATA:04A0 multrk_flag     dw 0                    ; DATA XREF: block+B↓r
BIOSDATA:04A0                                         ; Disk+88↓r ...
BIOSDATA:04A2 ec35_flag       db 0                    ; DATA XREF: BIOSCODE:18AA↓r
BIOSDATA:04A2                                         ; BIOSCODE:format_special_stuff_done↓r ...
BIOSDATA:04A2                                         ; flags for 3.5 inch disk drives
BIOSDATA:04A3 vretry_cnt      dw 0                    ; DATA XREF: diskio+C9↓w
BIOSDATA:04A3                                         ; diskio+128↓w ...
BIOSDATA:04A5 soft_ecc_cnt    dw 0                    ; DATA XREF: diskio+CD↓w
BIOSDATA:04A5                                         ; diskio:set_lbarw_5↓w ...
BIOSDATA:04A7 multitrk_format_flag db 0               ; DATA XREF: Disk:dskerr_nochangeline↓r
BIOSDATA:04A7                                         ; Disk+108↓w ...
BIOSDATA:04A7                                         ; multi track format request flag
BIOSDATA:04A8 xfer_seg        dw 0                    ; DATA XREF: diskio+2↓w
BIOSDATA:04A8                                         ; diskio+B8↓r ...
BIOSDATA:04A8                                         ; temp for transfer segment
BIOSDATA:04AA sectorspertrack dw 36                   ; DATA XREF: BIOSCODE:106D↓w
BIOSDATA:04AA                                         ; BIOSCODE:1116↓r ...
BIOSDATA:04AC tracktable      db 0, 0, 1, 2           ; DATA XREF: BIOSCODE:1088↓o
BIOSDATA:04AC                                         ; BIOSCODE:1113↓o ...
BIOSDATA:04AC                 db 0, 0, 2, 2
BIOSDATA:04AC                 db 0, 0, 3, 2
BIOSDATA:04AC                 db 0, 0, 4, 2
BIOSDATA:04AC                 db 0, 0, 5, 2
BIOSDATA:04AC                 db 0, 0, 6, 2
BIOSDATA:04AC                 db 0, 0, 7, 2
BIOSDATA:04AC                 db 0, 0, 8, 2
BIOSDATA:04AC                 db 0, 0, 9, 2
BIOSDATA:04AC                 db 0, 0, 10, 2
BIOSDATA:04AC                 db 0, 0, 11, 2
BIOSDATA:04AC                 db 0, 0, 12, 2
BIOSDATA:04AC                 db 0, 0, 13, 2
BIOSDATA:04AC                 db 0, 0, 14, 2
BIOSDATA:04AC                 db 0, 0, 15, 2
BIOSDATA:04AC                 db 0, 0, 16, 2
BIOSDATA:04AC                 db 0, 0, 17, 2
BIOSDATA:04AC                 db 0, 0, 18, 2
BIOSDATA:04AC                 db 0, 0, 19, 2
BIOSDATA:04AC                 db 0, 0, 20, 2
BIOSDATA:04AC                 db 0, 0, 21, 2
BIOSDATA:04AC                 db 0, 0, 22, 2
BIOSDATA:04AC                 db 0, 0, 23, 2
BIOSDATA:04AC                 db 0, 0, 24, 2
BIOSDATA:04AC                 db 0, 0, 25, 2
BIOSDATA:04AC                 db 0, 0, 26, 2
BIOSDATA:04AC                 db 0, 0, 27, 2
BIOSDATA:04AC                 db 0, 0, 28, 2
BIOSDATA:04AC                 db 0, 0, 29, 2
BIOSDATA:04AC                 db 0, 0, 30, 2
BIOSDATA:04AC                 db 0, 0, 31, 2
BIOSDATA:04AC                 db 0, 0, 32, 2
BIOSDATA:04AC                 db 0, 0, 33, 2
BIOSDATA:04AC                 db 0, 0, 34, 2
BIOSDATA:04AC                 db 0, 0, 35, 2
BIOSDATA:04AC                 db 0, 0, 36, 2
BIOSDATA:053C dskdrvs         dw offset fdrive1       ; DATA XREF: BIOSDATA:last_dskdrv_table↓o
BIOSDATA:053C                                         ; BIOSDATA:2050↓o ...
BIOSDATA:053E                 dw offset fdrive2
BIOSDATA:0540                 dw 52 dup(0)            ; times (((4*63)-144)-4) db 0
BIOSDATA:0540                                         ; 4*max_sectors_curr_sup-($-tracktable)-4 dup (0)
BIOSDATA:05A8 mediatype       db 0                    ; DATA XREF: BIOSCODE:1011↓w
BIOSDATA:05A8                                         ; SetDasd+32↓r
BIOSDATA:05A9 media_set_for_format db 0               ; DATA XREF: read_sector+22↓r
BIOSDATA:05A9                                         ; read_sector+45↓r ...
BIOSDATA:05A9                                         ; 1 if we have done an int 13h set media
BIOSDATA:05A9                                         ; type for format call
BIOSDATA:05AA had_format_error db 0                   ; DATA XREF: BIOSCODE:1151↓w
BIOSDATA:05AA                                         ; BIOSCODE:FormatFailed↓w ...
BIOSDATA:05AA                                         ; 1 if the previous format operation failed.
BIOSDATA:05AB tempdpt         dd 0FFFFFFFFh           ; DATA XREF: SetMediaForFormat+60↓w
BIOSDATA:05AB                                         ; RestoreOldDpt+11↓r ...
BIOSDATA:05AB                                         ; -1 ; temp disk base table
BIOSDATA:05AF model_byte      db 0FFh                 ; DATA XREF: BIOSDATA:1E71↓w
BIOSDATA:05AF                                         ; BIOSDATA:1E88↓w ...
BIOSDATA:05AF                                         ; model byte set at init time
BIOSDATA:05B0 secondary_model_byte db 0               ; DATA XREF: BIOSDATA:1E79↓w
BIOSDATA:05B0                                         ; cmosck+9↓r ...
BIOSDATA:05B1 int19sem        db 0                    ; DATA XREF: BIOSDATA:076F↓r
BIOSDATA:05B1                                         ; stackinit+37A↓w
BIOSDATA:05B1                                         ; indicate that all int 19h initialization is complete
BIOSDATA:05B1                                         ;
BIOSDATA:05B1                                         ; irp    aa,<02,08,09,0a,0b,0c,0d,0e,70,72,73,74,76,77>
BIOSDATA:05B1                                         ; public int19old&aa
BIOSDATA:05B1                                         ; db     aa&h       ; store the number as a byte
BIOSDATA:05B1                                         ; int19old&aa dd -1 ; original hardware int. vectors for int 19h.
BIOSDATA:05B1                                         ; endm
BIOSDATA:05B2 i19_lst         db 2                    ; DATA XREF: BIOSDATA:0775↓o
BIOSDATA:05B3 int19old02      dd 0FFFFFFFFh           ; DATA XREF: stackinit+A9↓o
BIOSDATA:05B3                                         ; Int19old&aa
BIOSDATA:05B3                                         ; db aa&h
BIOSDATA:05B3                                         ; dd -1 ; original hardware int. vectors for int 19h
BIOSDATA:05B7                 db 8
BIOSDATA:05B8 int19old08      dd 0FFFFFFFFh           ; DATA XREF: stackinit+B8↓o
BIOSDATA:05BC                 db 9
BIOSDATA:05BD int19old09      dd 0FFFFFFFFh           ; DATA XREF: stackinit+C7↓o
BIOSDATA:05C1                 db 0Ah
BIOSDATA:05C2 int19old0A      dd 0FFFFFFFFh           ; DATA XREF: stackinit+113↓o
BIOSDATA:05C6                 db 0Bh
BIOSDATA:05C7 int19old0B      dd 0FFFFFFFFh           ; DATA XREF: stackinit+153↓o
BIOSDATA:05CB                 db 0Ch
BIOSDATA:05CC int19old0C      dd 0FFFFFFFFh           ; DATA XREF: stackinit+193↓o
BIOSDATA:05D0                 db 0Dh
BIOSDATA:05D1 int19old0D      dd 0FFFFFFFFh           ; DATA XREF: stackinit+1D3↓o
BIOSDATA:05D5                 db 0Eh
BIOSDATA:05D6 int19old0E      dd 0FFFFFFFFh           ; DATA XREF: stackinit+213↓o
BIOSDATA:05DA                 db 70h
BIOSDATA:05DB int19old70      dd 0FFFFFFFFh           ; DATA XREF: stackinit+D6↓o
BIOSDATA:05DF                 db 72h
BIOSDATA:05E0 int19old72      dd 0FFFFFFFFh           ; DATA XREF: stackinit+253↓o
BIOSDATA:05E4                 db 73h
BIOSDATA:05E5 int19old73      dd 0FFFFFFFFh           ; DATA XREF: stackinit+293↓o
BIOSDATA:05E9                 db 74h
BIOSDATA:05EA int19old74      dd 0FFFFFFFFh           ; DATA XREF: stackinit+2D3↓o
BIOSDATA:05EE                 db 76h
BIOSDATA:05EF int19old76      dd 0FFFFFFFFh           ; DATA XREF: stackinit+313↓o
BIOSDATA:05F3                 db 77h
BIOSDATA:05F4 int19old77      dd 0FFFFFFFFh           ; DATA XREF: stackinit+353↓o
BIOSDATA:05F8 int6c_ret_addr  dd 0                    ; DATA XREF: BIOSDATA:184D↓w
BIOSDATA:05F8                                         ; BIOSDATA:1868↓r ...
BIOSDATA:05FC bin_date_time   db 0, 0, 0, 0           ; DATA XREF: read_real_date:read_ok↓w
BIOSDATA:05FC                                         ; read_real_date+50↓r ...
BIOSDATA:0600 daycnt2         dw 0                    ; DATA XREF: read_real_date+E↓w
BIOSDATA:0600                                         ; read_real_date+2D↓w ...
BIOSDATA:0602 cdev            dw offset chardev_entry ; DATA XREF: cdev_entry:ce_enter_codeseg↓r
BIOSDATA:0604 cdev_2          dw 364h                 ; DATA XREF: BIOSDATA:1B79↓r
BIOSDATA:0604                                         ; BIOSCODE:0037↓o
BIOSDATA:0604                                         ; BIOSCODE segment = 364h (for PCDOS 7.1 IBMBIO.COM)
BIOSDATA:0606 ttticks         dw offset time_to_ticks ; DATA XREF: read_real_time+34↓r
BIOSDATA:0606                                         ; BIOSCODE:0420↓r
BIOSDATA:0608                 dw 364h                 ; BIOSCODE segment (70h+2F4h)
BIOSDATA:060A i13x            dw offset i13z          ; DATA XREF: block13+11↓r
BIOSDATA:060C                 dw 364h                 ; BIOSCODE segment
BIOSDATA:060E ; ---------------------------------------------------------------------------
BIOSDATA:060E
BIOSDATA:060E cbreak:                                 ; DATA XREF: BIOSDATA:1EE1↓o
BIOSDATA:060E                 mov     cs:altah, 3     ; indicate break key set
BIOSDATA:0614
BIOSDATA:0614 intret:                                 ; DATA XREF: BIOSDATA:1EF6↓o
BIOSDATA:0614                                         ; BIOSDATA:resetintf↓o
BIOSDATA:0614                 iret
BIOSDATA:0615 ; ---------------------------------------------------------------------------
BIOSDATA:0615
BIOSDATA:0615 strategy:                               ; DATA XREF: BIOSDATA:0029↑o
BIOSDATA:0615                                         ; BIOSDATA:off_62B↑o ...
BIOSDATA:0615                 mov     word ptr cs:ptrsav, bx ; store es:bx (device driver request packet)
BIOSDATA:0615                                         ;      away at [ptrsav] for next driver function call
BIOSDATA:061A                 mov     word ptr cs:ptrsav+2, es
BIOSDATA:061F                 retf
BIOSDATA:0620 ; ---------------------------------------------------------------------------
BIOSDATA:0620
BIOSDATA:0620 con_entry:                              ; DATA XREF: BIOSDATA:002B↑o
BIOSDATA:0620                 call    cdev_entry
BIOSDATA:0620 ; ---------------------------------------------------------------------------
BIOSDATA:0623                 dw offset con_table
BIOSDATA:0625 ; ---------------------------------------------------------------------------
BIOSDATA:0625
BIOSDATA:0625 prn0_entry:                             ; DATA XREF: BIOSDATA:004F↑o
BIOSDATA:0625                 call    cdev_entry
BIOSDATA:0625 ; ---------------------------------------------------------------------------
BIOSDATA:0628                 dw offset prn_table
BIOSDATA:062A                 db 0, 0
BIOSDATA:062C ; ---------------------------------------------------------------------------
BIOSDATA:062C
BIOSDATA:062C prn1_entry:                             ; DATA XREF: BIOSDATA:0095↑o
BIOSDATA:062C                 call    cdev_entry
BIOSDATA:062C ; ---------------------------------------------------------------------------
BIOSDATA:062F                 dw offset prn_table
BIOSDATA:0631                 db 0, 1
BIOSDATA:0633 ; ---------------------------------------------------------------------------
BIOSDATA:0633
BIOSDATA:0633 prn2_entry:                             ; DATA XREF: BIOSDATA:00A7↑o
BIOSDATA:0633                 call    cdev_entry
BIOSDATA:0633 ; ---------------------------------------------------------------------------
BIOSDATA:0636                 dw offset prn_table     ; 364h:0FBh = BIOSCODE:0FBh = 70h:303Bh
BIOSDATA:0638                 db 1, 2
BIOSDATA:063A ; ---------------------------------------------------------------------------
BIOSDATA:063A
BIOSDATA:063A prn3_entry:                             ; DATA XREF: BIOSDATA:00C0↑o
BIOSDATA:063A                 call    cdev_entry
BIOSDATA:063A ; ---------------------------------------------------------------------------
BIOSDATA:063D                 dw offset prn_table
BIOSDATA:063F                 db 2, 3
BIOSDATA:0641 ; ---------------------------------------------------------------------------
BIOSDATA:0641
BIOSDATA:0641 aux0_entry:                             ; DATA XREF: BIOSDATA:off_62D↑o
BIOSDATA:0641                                         ; BIOSDATA:0083↑o
BIOSDATA:0641                 call    cdev_entry
BIOSDATA:0641 ; ---------------------------------------------------------------------------
BIOSDATA:0644                 dw offset aux_table
BIOSDATA:0646                 db 0
BIOSDATA:0647 ; ---------------------------------------------------------------------------
BIOSDATA:0647
BIOSDATA:0647 aux1_entry:                             ; DATA XREF: BIOSDATA:00D2↑o
BIOSDATA:0647                 call    cdev_entry
BIOSDATA:0647 ; ---------------------------------------------------------------------------
BIOSDATA:064A                 dw offset aux_table     ; 364h:130h = BIOSCODE:130h = 70h:3070h
BIOSDATA:064C                 db 1
BIOSDATA:064D ; ---------------------------------------------------------------------------
BIOSDATA:064D
BIOSDATA:064D aux2_entry:                             ; DATA XREF: BIOSDATA:00E4↑o
BIOSDATA:064D                 call    cdev_entry
BIOSDATA:064D ; ---------------------------------------------------------------------------
BIOSDATA:0650                 dw offset aux_table
BIOSDATA:0652                 db 2
BIOSDATA:0653 ; ---------------------------------------------------------------------------
BIOSDATA:0653
BIOSDATA:0653 aux3_entry:                             ; DATA XREF: BIOSDATA:00F6↑o
BIOSDATA:0653                 call    cdev_entry
BIOSDATA:0653 ; ---------------------------------------------------------------------------
BIOSDATA:0656                 dw offset aux_table
BIOSDATA:0658                 db 3
BIOSDATA:0659 ; ---------------------------------------------------------------------------
BIOSDATA:0659
BIOSDATA:0659 tim_entry:                              ; DATA XREF: BIOSDATA:0061↑o
BIOSDATA:0659                 call    cdev_entry
BIOSDATA:0659 ; ---------------------------------------------------------------------------
BIOSDATA:065C                 dw offset tim_table     ; 364h:147h ; BIOSCODE:147h ; 70h:3087h
BIOSDATA:065E ; ---------------------------------------------------------------------------
BIOSDATA:065E
BIOSDATA:065E dsk_entry:                              ; DATA XREF: BIOSDATA:0073↑o
BIOSDATA:065E                 call    cdev_entry
BIOSDATA:065E ; ---------------------------------------------------------------------------
BIOSDATA:0661                 dw offset DSKTBL        ; 364h:579h ; BIOSCODE:579h ; 70h:34B9h
BIOSDATA:0663
BIOSDATA:0663 ; =============== S U B R O U T I N E =======================================
BIOSDATA:0663
BIOSDATA:0663
BIOSDATA:0663 cdev_entry      proc near               ; CODE XREF: BIOSDATA:con_entry↑p
BIOSDATA:0663                                         ; BIOSDATA:prn0_entry↑p ...
BIOSDATA:0663                 cmp     cs:inHMA, 0
BIOSDATA:0669                 jz      short ce_enter_codeseg ; optimized for DOS in HMA
BIOSDATA:066B                 push    ax
BIOSDATA:066C                 mov     ax, cs:DosDataSg
BIOSDATA:0670                 cmp     word ptr cs:ptrsav+2, ax
BIOSDATA:0675                 pop     ax
BIOSDATA:0676                 jnz     short not_from_dos ; jump is coded this way to fall thru
BIOSDATA:0676                                         ; in 99.99% of the cases
BIOSDATA:0678
BIOSDATA:0678 ce_enter_codeseg:                       ; CODE XREF: cdev_entry+6↑j
BIOSDATA:0678                                         ; cdev_entry+1D↓j
BIOSDATA:0678                 jmp     dword ptr cs:cdev ; jmp far [cs:cdev]
BIOSDATA:067D ; ---------------------------------------------------------------------------
BIOSDATA:067D
BIOSDATA:067D not_from_dos:                           ; CODE XREF: cdev_entry+13↑j
BIOSDATA:067D                 call    EnsureA20On
BIOSDATA:0680                 jmp     short ce_enter_codeseg
BIOSDATA:0680 cdev_entry      endp
BIOSDATA:0680
BIOSDATA:0682
BIOSDATA:0682 ; =============== S U B R O U T I N E =======================================
BIOSDATA:0682
BIOSDATA:0682
BIOSDATA:0682 outchr          proc far                ; DATA XREF: BIOSDATA:1EEA↓o
BIOSDATA:0682                 push    ax              ; INT 29h handler
BIOSDATA:0683                 push    si
BIOSDATA:0684                 push    di
BIOSDATA:0685                 push    bp
BIOSDATA:0686                 push    bx
BIOSDATA:0687                 push    ds
BIOSDATA:0688                 xor     bx, bx          ; 0
BIOSDATA:068A                 cmp     cs:IsWin386, bl ; (are we in) windows ?
BIOSDATA:068F                 mov     ds, bx
BIOSDATA:0691                 assume ds:nothing
BIOSDATA:0691                 mov     ah, 0Eh
BIOSDATA:0693                 mov     bl, 7
BIOSDATA:0695                 jnz     short win_outchr ; Running on Windows
BIOSDATA:0697                 pushf                   ; far call (simulate INT)
BIOSDATA:0698                 cli
BIOSDATA:0699                 call    dword ptr ds:40h ; far call to INT 10h vector
BIOSDATA:069D                 jmp     short outchr_ok
BIOSDATA:069F ; ---------------------------------------------------------------------------
BIOSDATA:069F
BIOSDATA:069F win_outchr:                             ; CODE XREF: outchr+13↑j
BIOSDATA:069F                 int     10h             ; - VIDEO -
BIOSDATA:06A1
BIOSDATA:06A1 outchr_ok:                              ; CODE XREF: outchr+1B↑j
BIOSDATA:06A1                 pop     ds
BIOSDATA:06A2                 assume ds:nothing
BIOSDATA:06A2                 pop     bx
BIOSDATA:06A3                 pop     bp
BIOSDATA:06A4                 pop     di
BIOSDATA:06A5                 pop     si
BIOSDATA:06A6                 pop     ax
BIOSDATA:06A7                 iret
BIOSDATA:06A7 outchr          endp
BIOSDATA:06A7
BIOSDATA:06A7 ; ---------------------------------------------------------------------------
BIOSDATA:06A8                 db  50h ; P             ; 'PCI' signature
BIOSDATA:06A9                 db  43h ; C
BIOSDATA:06AA                 db  49h ; I
BIOSDATA:06AB Orig1A          dd 0                    ; DATA XREF: Int1A+5↓r
BIOSDATA:06AB                                         ; Int1A+F↓r ...
BIOSDATA:06AF
BIOSDATA:06AF ; =============== S U B R O U T I N E =======================================
BIOSDATA:06AF
BIOSDATA:06AF
BIOSDATA:06AF Int1A           proc far                ; DATA XREF: BIOSDATA:1DD4↓o
BIOSDATA:06AF                 cmp     ah, 4           ; (Y2K-fix)
BIOSDATA:06B2                 jz      short int1a_1   ; Reads the date from the computer's real-time clock
BIOSDATA:06B4                 jmp     cs:Orig1A       ; jmp far [cs:Orig1A]
BIOSDATA:06B9 ; ---------------------------------------------------------------------------
BIOSDATA:06B9
BIOSDATA:06B9 int1a_1:                                ; CODE XREF: Int1A+3↑j
BIOSDATA:06B9                 push    bp
BIOSDATA:06BA
BIOSDATA:06BA int1a_2:
BIOSDATA:06BA                 mov     bp, sp
BIOSDATA:06BC                 push    bp
BIOSDATA:06BD                 pushf
BIOSDATA:06BE                 call    cs:Orig1A
BIOSDATA:06C3                 jb      short int1a_4
BIOSDATA:06C5                 cmp     cl, 0           ; Year (BCD)
BIOSDATA:06C8                 jnz     short int1a_3
BIOSDATA:06CA                 cmp     ch, 19h         ; Century (BCD)
BIOSDATA:06CD                 jnz     short int1a_3
BIOSDATA:06CF                 mov     ch, 20h
BIOSDATA:06D1                 mov     ah, 5           ; Sets the date on the computer's real-time clock
BIOSDATA:06D3                 push    cx
BIOSDATA:06D4                 push    dx              ; dh = Month (BCD), dl = Day (BCD)
BIOSDATA:06D5                 pushf
BIOSDATA:06D6                 call    cs:Orig1A       ; call far [cs:Orig1A]
BIOSDATA:06DB                 pop     dx
BIOSDATA:06DC                 pop     cx
BIOSDATA:06DD                 jb      short int1a_4
BIOSDATA:06DF
BIOSDATA:06DF int1a_3:                                ; CODE XREF: Int1A+19↑j
BIOSDATA:06DF                                         ; Int1A+1E↑j
BIOSDATA:06DF                 pop     bp
BIOSDATA:06E0                 and     byte ptr [bp+6], 0FEh ; clear carry flag
BIOSDATA:06E4                 jmp     short int1a_5
BIOSDATA:06E6 ; ---------------------------------------------------------------------------
BIOSDATA:06E6
BIOSDATA:06E6 int1a_4:                                ; CODE XREF: Int1A+14↑j
BIOSDATA:06E6                                         ; Int1A+2E↑j
BIOSDATA:06E6                 pop     bp
BIOSDATA:06E7                 or      byte ptr [bp+6], 1 ; set carry flag
BIOSDATA:06EB
BIOSDATA:06EB int1a_5:                                ; CODE XREF: Int1A+35↑j
BIOSDATA:06EB                 pop     bp
BIOSDATA:06EC                 iret
BIOSDATA:06EC Int1A           endp
BIOSDATA:06EC
BIOSDATA:06ED
BIOSDATA:06ED ; =============== S U B R O U T I N E =======================================
BIOSDATA:06ED
BIOSDATA:06ED
BIOSDATA:06ED block13         proc far                ; DATA XREF: BIOSDATA:1DBC↓o
BIOSDATA:06ED                 cmp     cs:inHMA, 0
BIOSDATA:06F3                 jz      short skipa20
BIOSDATA:06F5                 call    EnsureA20On     ; assure a20 enabled
BIOSDATA:06F8
BIOSDATA:06F8 skipa20:                                ; CODE XREF: block13+6↑j
BIOSDATA:06F8                 mov     cs:i13_ds, ds   ; save caller's ds for call-through
BIOSDATA:06FD                 pushf                   ; fake interrupt
BIOSDATA:06FE                 call    dword ptr cs:i13x ; call through Bios_Code entry table
BIOSDATA:0703                 mov     ds, cs:i13_ds
BIOSDATA:0708                 retf    2
BIOSDATA:0708 block13         endp
BIOSDATA:0708
BIOSDATA:070B
BIOSDATA:070B ; =============== S U B R O U T I N E =======================================
BIOSDATA:070B
BIOSDATA:070B
BIOSDATA:070B call_orig13     proc far
BIOSDATA:070B                 mov     ds, ds:i13_ds   ; get caller's ds register
BIOSDATA:070F                 pushf
BIOSDATA:0710                 call    cs:Orig13
BIOSDATA:0715                 mov     cs:i13_ds, ds
BIOSDATA:071A                 push    cs
BIOSDATA:071B                 pop     ds              ; restore ds -> Bios_Data before return
BIOSDATA:071C                 assume ds:BIOSDATA
BIOSDATA:071C                 pushf
BIOSDATA:071D                 cmp     cs:inHMA, 0
BIOSDATA:0723                 jz      short corig13_popf_retf
BIOSDATA:0725                 call    EnsureA20On
BIOSDATA:0728
BIOSDATA:0728 corig13_popf_retf:                      ; CODE XREF: call_orig13+18↑j
BIOSDATA:0728                 popf
BIOSDATA:0729
BIOSDATA:0729 re_init:
BIOSDATA:0729                 retf
BIOSDATA:0729 call_orig13     endp
BIOSDATA:0729
BIOSDATA:072A
BIOSDATA:072A ; =============== S U B R O U T I N E =======================================
BIOSDATA:072A
BIOSDATA:072A
BIOSDATA:072A EnsureA20On     proc near               ; CODE XREF: cdev_entry:not_from_dos↑p
BIOSDATA:072A                                         ; block13+8↑p ...
BIOSDATA:072A                 call    IsA20Off
BIOSDATA:072D                 jnz     short enable_A20_ok
BIOSDATA:072F
BIOSDATA:072F EnableA20:                              ; A20 line is OFF
BIOSDATA:072F                 push    ax
BIOSDATA:0730                 push    bx
BIOSDATA:0731                 mov     ah, 5           ; local enable A20
BIOSDATA:0733                 call    cs:xms
BIOSDATA:0738                 pop     bx
BIOSDATA:0739                 pop     ax
BIOSDATA:073A
BIOSDATA:073A enable_A20_ok:                          ; CODE XREF: EnsureA20On+3↑j
BIOSDATA:073A                 retn
BIOSDATA:073A EnsureA20On     endp
BIOSDATA:073A
BIOSDATA:073B
BIOSDATA:073B ; =============== S U B R O U T I N E =======================================
BIOSDATA:073B
BIOSDATA:073B
BIOSDATA:073B IsA20Off        proc near               ; CODE XREF: EnsureA20On↑p
BIOSDATA:073B                 push    ds
BIOSDATA:073C                 push    es
BIOSDATA:073D                 push    cx
BIOSDATA:073E                 push    si
BIOSDATA:073F                 push    di
BIOSDATA:0740                 xor     di, di
BIOSDATA:0742                 mov     es, di
BIOSDATA:0744                 assume es:nothing
BIOSDATA:0744                 dec     di
BIOSDATA:0745                 mov     si, 90h
BIOSDATA:0748                 mov     ds, di          ; 0FFFFh:0090h ; HiMem
BIOSDATA:074A                 assume ds:nothing
BIOSDATA:074A                 mov     di, 80h         ; 0000h:0080h ; LoMem
BIOSDATA:074D
BIOSDATA:074D cpu386_cmpsd:                           ; DATA XREF: SYSINIT:0506↓o
BIOSDATA:074D                 nop
BIOSDATA:074E                 mov     cx, 8
BIOSDATA:0751                 repe cmpsw              ;
BIOSDATA:0751                                         ; zf = 0 -> A20 line is ON
BIOSDATA:0751                                         ; zf = 1 -> A20 line is OFF
BIOSDATA:0753                 pop     di
BIOSDATA:0754                 pop     si
BIOSDATA:0755                 pop     cx
BIOSDATA:0756                 pop     es
BIOSDATA:0757                 assume es:nothing
BIOSDATA:0757                 pop     ds
BIOSDATA:0758                 retn
BIOSDATA:0758 IsA20Off        endp
BIOSDATA:0758
BIOSDATA:0759 ; ---------------------------------------------------------------------------
BIOSDATA:0759
BIOSDATA:0759 int19:                                  ; DATA XREF: BIOSDATA:1DE8↓o
BIOSDATA:0759                 push    cs
BIOSDATA:075A                 pop     ds
BIOSDATA:075B                 assume ds:BIOSDATA
BIOSDATA:075B                 xor     cx, cx
BIOSDATA:075D                 mov     es, cx
BIOSDATA:075F                 assume es:nothing
BIOSDATA:075F                 mov     cl, 5
BIOSDATA:0761                 mov     si, offset RomVectors
BIOSDATA:0764
BIOSDATA:0764 _next_int:                              ; CODE XREF: BIOSDATA:076D↓j
BIOSDATA:0764                 lodsb                   ; get int number
BIOSDATA:0765                 cbw                     ; assume < 128
BIOSDATA:0766                 shl     ax, 1
BIOSDATA:0768                 shl     ax, 1           ; int * 4
BIOSDATA:076A                 xchg    ax, di
BIOSDATA:076B                 movsw
BIOSDATA:076C                 movsw                   ; install the saved vector
BIOSDATA:076D                 loop    _next_int
BIOSDATA:076F                 cmp     int19sem, cl    ; 0
BIOSDATA:0773                 jz      short doint19
BIOSDATA:0775                 mov     si, offset i19_lst ; stacks code has changed these hardware interrupt vectors
BIOSDATA:0775                                         ; stkinit in sysinit1 will initialize int19oldxx values
BIOSDATA:0778                 mov     cl, 14          ; num_i19
BIOSDATA:077A
BIOSDATA:077A i19_restore_loop:                       ; CODE XREF: BIOSDATA:i19_restor_1↓j
BIOSDATA:077A                 lodsb                   ; get interrupt number
BIOSDATA:077B                 cbw                     ; assume < 128
BIOSDATA:077C                 xchg    ax, di
BIOSDATA:077D                 lodsw                   ; get original vector offset
BIOSDATA:077E                 xchg    ax, bx          ; save it
BIOSDATA:077F                 lodsw
BIOSDATA:0780                 inc     bx              ; check for 0ffffh (unlikely segment)
BIOSDATA:0781                 jz      short i19_restor_1 ; opt no need to check selector too
BIOSDATA:0783                 dec     bx
BIOSDATA:0784                 add     di, di
BIOSDATA:0786                 add     di, di
BIOSDATA:0788                 xchg    ax, bx
BIOSDATA:0789                 stosw
BIOSDATA:078A                 xchg    ax, bx
BIOSDATA:078B                 stosw                   ; put the vector back
BIOSDATA:078C
BIOSDATA:078C i19_restor_1:                           ; CODE XREF: BIOSDATA:0781↑j
BIOSDATA:078C                 loop    i19_restore_loop
BIOSDATA:078E
BIOSDATA:078E doint19:                                ; CODE XREF: BIOSDATA:0773↑j
BIOSDATA:078E                 cmp     inHMA, cl       ; Is dos running from HMA ?
BIOSDATA:0792                 jz      short SkipVDisk ; no
BIOSDATA:0794                 call    EraseVDiskHead  ; Then erase our VDISK header at 1MB boundary
BIOSDATA:0794                                         ; Some m/c's (AST 386 & HP QS/16 do not clear
BIOSDATA:0794                                         ; the memory above 1MB during a warm boot.
BIOSDATA:0797
BIOSDATA:0797 SkipVDisk:                              ; CODE XREF: BIOSDATA:0792↑j
BIOSDATA:0797                 int     19h             ; DISK BOOT
BIOSDATA:0797                                         ; causes reboot of disk system
BIOSDATA:0799
BIOSDATA:0799 Int15:                                  ; DATA XREF: BIOSDATA:1DDE↓o
BIOSDATA:0799                 cmp     ax, 4F53h       ; del keystroke ?  (4F00h+DELKEY)
BIOSDATA:079C                 jz      short int15_1
BIOSDATA:079E
BIOSDATA:079E Old15_j:                                ; CODE XREF: BIOSDATA:07BF↓j
BIOSDATA:079E                 jmp     cs:Old15
BIOSDATA:07A3 ; ---------------------------------------------------------------------------
BIOSDATA:07A3
BIOSDATA:07A3 int15_1:                                ; CODE XREF: BIOSDATA:079C↑j
BIOSDATA:07A3                 push    ds
BIOSDATA:07A4                 push    ax
BIOSDATA:07A5                 xor     ax, ax
BIOSDATA:07A7                 mov     ds, ax
BIOSDATA:07A9                 assume ds:nothing
BIOSDATA:07A9                 mov     al, byte ptr ds:417h ; [KBFLAG]
BIOSDATA:07AC                 and     al, 0Ch         ; (CTRLSTATE | ALTSTATE)
BIOSDATA:07AE                 cmp     al, 0Ch         ; (CTRLSTATE | ALTSTATE)
BIOSDATA:07B0                 jnz     short int15_2
BIOSDATA:07B2                 cmp     cs:inHMA, ah    ; is DOS running from HMA ?
BIOSDATA:07B7                 jz      short int15_2   ; no
BIOSDATA:07B9                 call    EraseVDiskHead
BIOSDATA:07BC
BIOSDATA:07BC int15_2:                                ; CODE XREF: BIOSDATA:07B0↑j
BIOSDATA:07BC                                         ; BIOSDATA:07B7↑j
BIOSDATA:07BC                 pop     ax
BIOSDATA:07BD                 pop     ds
BIOSDATA:07BE                 assume ds:nothing
BIOSDATA:07BE                 stc
BIOSDATA:07BF                 jmp     short Old15_j
BIOSDATA:07C1
BIOSDATA:07C1 ; =============== S U B R O U T I N E =======================================
BIOSDATA:07C1
BIOSDATA:07C1
BIOSDATA:07C1 EraseVDiskHead  proc near               ; CODE XREF: BIOSDATA:0794↑p
BIOSDATA:07C1                                         ; BIOSDATA:07B9↑p
BIOSDATA:07C1                 push    cx
BIOSDATA:07C2                 push    di
BIOSDATA:07C3                 push    es
BIOSDATA:07C4                 call    EnsureA20On
BIOSDATA:07C7                 push    0FFFFh          ; HMA seg
BIOSDATA:07C9                 pop     es
BIOSDATA:07CA                 assume es:nothing
BIOSDATA:07CA                 mov     di, 10h         ; point to VDISK header
BIOSDATA:07CD                 mov     cx, di          ; size of vdisk header = 16
BIOSDATA:07CF                 xor     ax, ax
BIOSDATA:07D1                 rep stosw               ; clear it
BIOSDATA:07D3                 pop     es
BIOSDATA:07D4                 assume es:nothing
BIOSDATA:07D4                 pop     di
BIOSDATA:07D5                 pop     cx
BIOSDATA:07D6                 retn
BIOSDATA:07D6 EraseVDiskHead  endp
BIOSDATA:07D6
BIOSDATA:07D6 ; ---------------------------------------------------------------------------
BIOSDATA:07D7 FreeHMAPtr      dw 0FFFFh               ; DATA XREF: BIOSCODE:1799↓w
BIOSDATA:07D7                                         ; BIOSCODE:179F↓w ...
BIOSDATA:07D9 MoveDOSIntoHMA  dw offset FTRYTOMOVDOSHI
BIOSDATA:07D9                                         ; DATA XREF: HMAptr+15↓r
BIOSDATA:07D9                                         ; SYSINITSEG:FTRYTOMOVDOSHI
BIOSDATA:07DB MoveDOSIntoHMA_2 dw 544h                ; DATA XREF: SYSINIT:0518↓w
BIOSDATA:07DB                                         ; SYSINITSEG
BIOSDATA:07DD SysinitPresent  db 0                    ; DATA XREF: HMAptr+E↓r
BIOSDATA:07DD                                         ; SYSINIT:BiosComBlock↓o ...
BIOSDATA:07DE Win386_SI       db 3, 0                 ; DATA XREF: BIOSCODE:1754↓o
BIOSDATA:07E0 SI_Next         dd 0                    ; DATA XREF: BIOSCODE:174C↓w
BIOSDATA:07E0                                         ; BIOSCODE:1750↓w
BIOSDATA:07E4                 dd 0
BIOSDATA:07E8                 dd 0
BIOSDATA:07EC                 dw offset Instance_Table
BIOSDATA:07EE                 dw 70h
BIOSDATA:07F0 Instance_Table  dw 0                    ; DATA XREF: BIOSDATA:07EC↑o
BIOSDATA:07F0                                         ; print screen status
BIOSDATA:07F2                 dw 50h
BIOSDATA:07F4                 dw 2                    ; 2 bytes
BIOSDATA:07F6                 dw 0Eh                  ; ROM Basic data
BIOSDATA:07F8                 dw 50h
BIOSDATA:07FA                 dw 14h                  ; 20 bytes
BIOSDATA:07FC                 dw offset altah         ; a con device buffer
BIOSDATA:07FE                 dw 70h
BIOSDATA:0800                 dw 1
BIOSDATA:0802 NextStack       dw 2 dup(0)             ; DATA XREF: endfile+297↓w
BIOSDATA:0802                                         ; endfile+29D↓w
BIOSDATA:0802                                         ; pointer to next stack to be used
BIOSDATA:0806                 dw 2                    ; 2 bytes
BIOSDATA:0808 IT_StackLoc     dd 0                    ; DATA XREF: endfile+2A9↓w
BIOSDATA:0808                                         ; endfile+2B4↓w
BIOSDATA:0808                                         ; location of hardware stacks
BIOSDATA:080C IT_StackSize    dw 0                    ; DATA XREF: endfile+2C4↓w
BIOSDATA:080C                                         ; size of hardware stacks
BIOSDATA:080E                 dd 0                    ; terminate the instance table
BIOSDATA:0812 IsWin386        db 0                    ; DATA XREF: outchr+8↑r
BIOSDATA:0812                                         ; BIOSCODE:173A↓w ...
BIOSDATA:0812                                         ; Flag to indicate whether
BIOSDATA:0812                                         ; Win386 is running or not
BIOSDATA:0813 ; ---------------------------------------------------------------------------
BIOSDATA:0813
BIOSDATA:0813 V86_Crit_SetFocus:
BIOSDATA:0813                 push    di
BIOSDATA:0814                 push    es
BIOSDATA:0815                 push    bx
BIOSDATA:0816                 push    ax
BIOSDATA:0817                 xor     di, di
BIOSDATA:0819                 mov     es, di
BIOSDATA:081B                 assume es:nothing
BIOSDATA:081B
BIOSDATA:081B offset_081Bh:                           ; CODE XREF: doint+13↓P
BIOSDATA:081B                                         ; BIOSCODE:18D7↓P ...
BIOSDATA:081B                 mov     bx, 15h         ; Device ID of DOSMGR device
BIOSDATA:081E                 mov     ax, 1684h
BIOSDATA:0821                 int     2Fh             ; - Multiplex - MS WINDOWS - GET DEVICE API ENTRY POINT
BIOSDATA:0821                                         ; BX = virtual device (VxD) ID, ES:DI = 0000h:0000h
BIOSDATA:0821                                         ; Return: ES:DI -> VxD API entry point, or 0:0 if the VxD does not support an API
BIOSDATA:0823                 mov     ax, es
BIOSDATA:0825                 or      ax, di
BIOSDATA:0827                 jz      short Skip
BIOSDATA:0829                 push    cs
BIOSDATA:082A                 push    offset Skip
BIOSDATA:082D                 push    es
BIOSDATA:082E                 push    di              ; API far call address
BIOSDATA:082F                 mov     ax, 1           ; SetFocus function number
BIOSDATA:0832                 retf                    ; do the call
BIOSDATA:0833 ; ---------------------------------------------------------------------------
BIOSDATA:0833
BIOSDATA:0833 Skip:                                   ; CODE XREF: BIOSDATA:0827↑j
BIOSDATA:0833                                         ; DATA XREF: BIOSDATA:082A↑o
BIOSDATA:0833                 pop     ax
BIOSDATA:0834                 pop     bx
BIOSDATA:0835                 pop     es
BIOSDATA:0836                 assume es:nothing
BIOSDATA:0836                 pop     di
BIOSDATA:0837                 retf
BIOSDATA:0837 ; ---------------------------------------------------------------------------
BIOSDATA:0838 endfloppy       db 0                    ; DATA XREF: BIOSDATA:2263↓o
BIOSDATA:0839 offset_0839h    db 7 dup(0)             ; CODE XREF: SYSINIT:06EB↓P
BIOSDATA:0840 tmp_vid         db 'NO NAME    '        ; DATA XREF: read_volume_id+8↓o
BIOSDATA:0840                                         ; read_volume_id+7B↓o ...
BIOSDATA:084B harddrv         db 80h                  ; DATA XREF: BIOSDATA:1FCC↓o
BIOSDATA:084B                                         ; BIOSDATA:2259↓o
BIOSDATA:084C bdss            dw 0FFFFh               ; DATA XREF: BIOSDATA:end_of_bdss↓o
BIOSDATA:084C                                         ; BIOSDATA:2253↓o
BIOSDATA:084C                                         ; max_mini_dsk_num equ 23
BIOSDATA:084C                                         ; BDS_STRUC (2+max_mini_dsk_num) dup (<>)
BIOSDATA:084C                                         ; currently max. 25
BIOSDATA:084C                                         ; (MSDOS 6 BDS structure size = 100 bytes)
BIOSDATA:084C                                         ; (PCDOS 7.1 BDS structure size = 150 bytes)
BIOSDATA:084C                                         ; BDS.link
BIOSDATA:084E                 dw 0
BIOSDATA:0850                 db 80                   ; BDS.drivenum
BIOSDATA:0851                 db 3                    ; BDS.drivelet
BIOSDATA:0852                 dw 512                  ; BDS.BPB (BDS offset 6)
BIOSDATA:0852                                         ; 53 bytes BPB for FAT32 fs
BIOSDATA:0852                                         ; 25 bytes BPB for FAT16 and FAT12 fs
BIOSDATA:0852                                         ; .bytespersec
BIOSDATA:0854                 db 1                    ; .secperclus
BIOSDATA:0855                 dw 1                    ; .resectors
BIOSDATA:0857                 db 2                    ; .fats
BIOSDATA:0858                 dw 16                   ; .direntries
BIOSDATA:085A                 dw 0                    ; .totalsec16
BIOSDATA:085C                 db 0F8h                 ; .media
BIOSDATA:085D                 dw 1                    ; .fatsecs16
BIOSDATA:085F                 dw 0                    ; .secpertrack
BIOSDATA:0861                 dw 0                    ; .heads
BIOSDATA:0863                 dd 0                    ; .hiddensectors
BIOSDATA:0867                 dd 0                    ; .totalsecs32
BIOSDATA:0867                                         ; (End of FAT12/FAT16 BPB)
BIOSDATA:0867                                         ;
BIOSDATA:0867                                         ; FAT32 extensions to BDS
BIOSDATA:086B                 dd 0                    ; .fatsecs32 ; BPB_FATSz32 (BDS offset 31)
BIOSDATA:086F                 dw 0                    ; .extflags ; BPB_ExtFlags
BIOSDATA:0871                 dw 0                    ; .fsver ; BPB_FSVer
BIOSDATA:0873                 dd 0                    ; .rootdirclust ; BPB_RootClus (BDS offset 39)
BIOSDATA:0877                 dw 0FFFFh               ; .fsinfo ; BPB_FSInfo ; initialized to -1
BIOSDATA:0879                 dw 0FFFFh               ; .bkbootsec ; BPB_BkBootSec ; initialized to -1
BIOSDATA:087B                 db 12 dup(0)            ; .reserved ; BPB_Reserved (12 zero bytes)
BIOSDATA:0887                 db 0                    ; BDS.fatsiz (BDS offset 59)
BIOSDATA:0888                 dw 0                    ; BDS.opcnt
BIOSDATA:088A                 db 3
BIOSDATA:088B                 dw 20h                  ; BDS.flags (BDS offset 63)
BIOSDATA:088D                 dw 40
BIOSDATA:088F                 db 37 dup(0)
BIOSDATA:08B4                 dd 0FFFFFFFFh
BIOSDATA:08B8                 db 12 dup(0)
BIOSDATA:08C4                 db -1                   ; BDS.track (BDS offset 120)
BIOSDATA:08C5                 dw 1                    ; BDS.tim_lo ; BDS.bdsm_ismini
BIOSDATA:08C7                 dw 0                    ; BDS.tim_hi
BIOSDATA:08C9                 db 'NO NAME    ',0      ; BDS.volid
BIOSDATA:08D5                 dd 0                    ; BDS.vol_serial (BDS offset 137)
BIOSDATA:08D9                 db 'FAT12   ',0         ; BDS.filesys_id
BIOSDATA:08E2 bds_1           dw 0FFFFh
BIOSDATA:08E4                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:08E4                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:08E4                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:08E4                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:08E4                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:08E4                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:08E4                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:08E4                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:08E4                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:08E4                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:0978 bds_2           dw 0FFFFh
BIOSDATA:097A                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:097A                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:097A                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:097A                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:097A                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:097A                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:097A                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:097A                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:097A                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:097A                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:0A0E bds_3           dw 0FFFFh
BIOSDATA:0A10                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:0A10                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0A10                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:0A10                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:0A10                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0A10                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0A10                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0A10                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:0A10                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:0A10                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:0AA4 bds_4           dw 0FFFFh
BIOSDATA:0AA6                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:0AA6                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0AA6                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:0AA6                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:0AA6                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0AA6                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0AA6                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0AA6                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:0AA6                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:0AA6                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:0B3A                 dw 0FFFFh
BIOSDATA:0B3C                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:0B3C                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0B3C                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:0B3C                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:0B3C                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0B3C                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0B3C                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0B3C                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:0B3C                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:0B3C                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:0BD0                 dw 0FFFFh
BIOSDATA:0BD2                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:0BD2                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0BD2                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:0BD2                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:0BD2                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0BD2                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0BD2                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0BD2                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:0BD2                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:0BD2                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:0C66                 dw 0FFFFh
BIOSDATA:0C68                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:0C68                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0C68                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:0C68                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:0C68                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0C68                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0C68                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0C68                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:0C68                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:0C68                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:0CFC                 dw 0FFFFh
BIOSDATA:0CFE                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:0CFE                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0CFE                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:0CFE                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:0CFE                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0CFE                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0CFE                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0CFE                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:0CFE                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:0CFE                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:0D92                 dw 0FFFFh
BIOSDATA:0D94                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:0D94                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0D94                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:0D94                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:0D94                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0D94                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0D94                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0D94                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:0D94                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:0D94                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:0E28                 dw 0FFFFh
BIOSDATA:0E2A                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:0E2A                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0E2A                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:0E2A                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:0E2A                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0E2A                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0E2A                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0E2A                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:0E2A                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:0E2A                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:0EBE                 dw 0FFFFh
BIOSDATA:0EC0 byte_14B0       db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:0EC0                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0EC0                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:0EC0                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:0EC0                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0EC0                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0EC0                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0EC0                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:0EC0                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:0EC0                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:0F54                 dw 0FFFFh
BIOSDATA:0F56                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:0F56                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0F56                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:0F56                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:0F56                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0F56                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0F56                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0F56                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:0F56                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:0F56                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:0FEA                 dw 0FFFFh
BIOSDATA:0FEC                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:0FEC                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0FEC                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:0FEC                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:0FEC                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0FEC                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0FEC                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:0FEC                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:0FEC                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:0FEC                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:1080                 dw 0FFFFh
BIOSDATA:1082                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:1082                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1082                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:1082                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:1082                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1082                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1082                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1082                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:1082                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:1082                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:1116                 dw 0FFFFh
BIOSDATA:1118                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:1118                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1118                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:1118                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:1118                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1118                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1118                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1118                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:1118                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:1118                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:11AC                 dw 0FFFFh
BIOSDATA:11AE                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:11AE                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:11AE                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:11AE                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:11AE                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:11AE                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:11AE                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:11AE                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:11AE                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:11AE                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:1242                 dw 0FFFFh
BIOSDATA:1244                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:1244                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1244                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:1244                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:1244                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1244                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1244                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1244                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:1244                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:1244                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:12D8                 dw 0FFFFh
BIOSDATA:12DA                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:12DA                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:12DA                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:12DA                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:12DA                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:12DA                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:12DA                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:12DA                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:12DA                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:12DA                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:136E                 dw 0FFFFh
BIOSDATA:1370                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:1370                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1370                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:1370                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:1370                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1370                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1370                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1370                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:1370                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:1370                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:1404                 dw 0FFFFh
BIOSDATA:1406                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:1406                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1406                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:1406                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:1406                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1406                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1406                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1406                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:1406                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:1406                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:149A                 dw 0FFFFh
BIOSDATA:149C                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:149C                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:149C                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:149C                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:149C                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:149C                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:149C                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:149C                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:149C                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:149C                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:1530                 dw 0FFFFh
BIOSDATA:1532                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:1532                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1532                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:1532                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:1532                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1532                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1532                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:1532                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:1532                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:1532                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:15C6                 dw 0FFFFh
BIOSDATA:15C8                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:15C8                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:15C8                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:15C8                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:15C8                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:15C8                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:15C8                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:15C8                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:15C8                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:15C8                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:165C bds_24          dw 0FFFFh
BIOSDATA:165E                 db 0, 0, 50h, 3, 0, 2, 1, 1, 0, 2, 10h, 0, 0, 0, 0F8h
BIOSDATA:165E                 db 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:165E                 db 0, 0, 0, 0, 0, 0, 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0
BIOSDATA:165E                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 20h, 0, 28h
BIOSDATA:165E                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:165E                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:165E                 db 0, 0, 0FFh, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 0, 0, 0
BIOSDATA:165E                 db 0, 0, 0, 0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h
BIOSDATA:165E                 db 4Dh, 45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0, 46h, 41h
BIOSDATA:165E                 db 54h, 31h, 32h, 20h, 20h, 20h, 0
BIOSDATA:16F2 ; ---------------------------------------------------------------------------
BIOSDATA:16F2
BIOSDATA:16F2 ibm_disk_io:                            ; DATA XREF: BIOSDATA:228E↓o
BIOSDATA:16F2                 cmp     dl, 80h         ; main routine, fixes at rom bug
BIOSDATA:16F2                                         ; pass through floppy disk calls
BIOSDATA:16F5                 jb      short atd1
BIOSDATA:16F7                 cmp     ah, 2
BIOSDATA:16FA                 jz      short atd2      ; intercept call 02h (read sectors)
BIOSDATA:16FC                 cmp     ah, 0Ah         ; and call 0Ah (read long)
BIOSDATA:16FF                 jz      short atd2
BIOSDATA:1701
BIOSDATA:1701 atd1:                                   ; CODE XREF: BIOSDATA:16F5↑j
BIOSDATA:1701                 jmp     cs:Old13        ; use rom int 13h handler
BIOSDATA:1706 ; ---------------------------------------------------------------------------
BIOSDATA:1706
BIOSDATA:1706 atd2:                                   ; CODE XREF: BIOSDATA:16FA↑j
BIOSDATA:1706                                         ; BIOSDATA:16FF↑j
BIOSDATA:1706                 push    bx
BIOSDATA:1707                 push    cx
BIOSDATA:1708                 push    dx
BIOSDATA:1709                 push    di
BIOSDATA:170A                 push    ds
BIOSDATA:170B                 push    es
BIOSDATA:170C                 push    ax
BIOSDATA:170D                 mov     ax, 40h         ; rombios data segment
BIOSDATA:1710                 mov     ds, ax
BIOSDATA:1712                 assume ds:nothing
BIOSDATA:1712                 mov     byte ptr ds:74h, 0 ; [disk_status1]
BIOSDATA:1712                                         ; initially no error code
BIOSDATA:1717                 and     dl, 7Fh         ; mask to hard disk number
BIOSDATA:171A                 cmp     dl, ds:75h      ; [hf_num] ; 40h:75h
BIOSDATA:171E                 jb      short atd3      ; disk number in range
BIOSDATA:1720                 mov     byte ptr ds:74h, 1 ; [disk_status1]
BIOSDATA:1725                 jmp     short atd4      ; disk number out of range error, return
BIOSDATA:1727 ; ---------------------------------------------------------------------------
BIOSDATA:1727
BIOSDATA:1727 atd3:                                   ; CODE XREF: BIOSDATA:171E↑j
BIOSDATA:1727                 push    bx
BIOSDATA:1728                 mov     ax, es
BIOSDATA:172A                 shr     bx, 4           ; make es:bx to seg:000x form
BIOSDATA:172D                 add     ax, bx
BIOSDATA:172F                 mov     es, ax
BIOSDATA:1731                 pop     bx
BIOSDATA:1732                 and     bx, 0Fh
BIOSDATA:1735                 push    cs
BIOSDATA:1736                 call    check_dma
BIOSDATA:1739 ; ---------------------------------------------------------------------------
BIOSDATA:1739                 jb      short atd4      ; abort if dma across segment boundary
BIOSDATA:173B                 pop     ax
BIOSDATA:173C                 push    ax
BIOSDATA:173D                 call    setcmd          ; set up command block for disk op
BIOSDATA:1740 ; ---------------------------------------------------------------------------
BIOSDATA:1740                 mov     dx, 3F6h        ; hf_reg_port
BIOSDATA:1743                 out     dx, al          ; AT only. Fixed disk register
BIOSDATA:1744                 call    docmd           ; carry out command
BIOSDATA:1747 ; ---------------------------------------------------------------------------
BIOSDATA:1747
BIOSDATA:1747 atd4:                                   ; CODE XREF: BIOSDATA:1725↑j
BIOSDATA:1747                                         ; BIOSDATA:1739↑j
BIOSDATA:1747                 pop     ax
BIOSDATA:1748                 mov     ah, ds:74h      ; [disk_status1]
BIOSDATA:174C                 or      ah, ah
BIOSDATA:174E                 jz      short atd5
BIOSDATA:1750                 stc
BIOSDATA:1751
BIOSDATA:1751 atd5:                                   ; CODE XREF: BIOSDATA:174E↑j
BIOSDATA:1751                 pop     es
BIOSDATA:1752                 pop     ds
BIOSDATA:1753                 assume ds:nothing
BIOSDATA:1753                 pop     di
BIOSDATA:1754                 pop     dx
BIOSDATA:1755                 pop     cx
BIOSDATA:1756                 pop     bx
BIOSDATA:1757                 retf    2
BIOSDATA:175A
BIOSDATA:175A ; =============== S U B R O U T I N E =======================================
BIOSDATA:175A
BIOSDATA:175A ; Attributes: noreturn
BIOSDATA:175A
BIOSDATA:175A setcmd          proc near               ; CODE XREF: BIOSDATA:173D↑p
BIOSDATA:175A                 mov     ds:43h, al      ; [cmd_block+sec_cnt]
BIOSDATA:175D                 mov     byte ptr ds:48h, 20h
BIOSDATA:1762                 cmp     ah, 2           ; cmd_reg = 20h if function 02h (read)
BIOSDATA:1765                 jz      short setc1
BIOSDATA:1767                 mov     byte ptr ds:48h, 22h ; [cmd_block+cmd_reg]
BIOSDATA:1767                                         ; cmd_reg = 22h if function 0Ah (read long)
BIOSDATA:176C
BIOSDATA:176C setc1:                                  ; CODE XREF: setcmd+B↑j
BIOSDATA:176C                 mov     al, cl
BIOSDATA:176E                 and     al, 3Fh         ; mask sector number
BIOSDATA:1770                 mov     ds:44h, al      ; [cmd_block+sec_num]
BIOSDATA:1773                 mov     ds:45h, ch      ; [cmd_block+cyl_low]
BIOSDATA:1777                 mov     al, cl
BIOSDATA:1779                 shr     al, 6           ; get two high bits of cylinder number
BIOSDATA:177C                 mov     ds:46h, al      ; [cmd_block+cyl_high]
BIOSDATA:177F                 mov     ax, dx
BIOSDATA:1781                 shl     al, 4           ; drive number
BIOSDATA:1784                 and     ah, 0Fh
BIOSDATA:1787                 or      al, ah          ; head number
BIOSDATA:1789                 or      al, 0A0h        ; set ecc and 512 bytes per sector
BIOSDATA:178B                 mov     ds:47h, al      ; [cmd_block+drv_head]
BIOSDATA:178E                 push    es
BIOSDATA:178F                 push    bx
BIOSDATA:1790                 push    cs
BIOSDATA:1791                 call    get_vec
BIOSDATA:1794 ; ---------------------------------------------------------------------------
BIOSDATA:1794                 mov     ax, es:[bx+5]   ; [es:bx+fdp_precomp]
BIOSDATA:1794                                         ; write pre-comp from disk parameters
BIOSDATA:1798                 shr     ax, 2
BIOSDATA:179B                 mov     ds:42h, al      ; [cmd_block+pre_comp]
BIOSDATA:179E                 mov     al, es:[bx+8]   ; [es:bx+fdp_control]
BIOSDATA:179E                                         ; control byte modifier
BIOSDATA:17A2                 pop     bx
BIOSDATA:17A3                 pop     es
BIOSDATA:17A4                 mov     ah, ds:76h      ; [control_byte]
BIOSDATA:17A8                 and     ah, 0C0h        ; keep disable retry bits
BIOSDATA:17AB                 or      ah, al
BIOSDATA:17AD                 mov     ds:76h, ah
BIOSDATA:17B1                 retn
BIOSDATA:17B1 setcmd          endp
BIOSDATA:17B1
BIOSDATA:17B2
BIOSDATA:17B2 ; =============== S U B R O U T I N E =======================================
BIOSDATA:17B2
BIOSDATA:17B2 ; Attributes: noreturn
BIOSDATA:17B2
BIOSDATA:17B2 docmd           proc near               ; CODE XREF: BIOSDATA:1744↑p
BIOSDATA:17B2                 mov     di, bx
BIOSDATA:17B4                 push    cs
BIOSDATA:17B5                 call    command
BIOSDATA:17B8 ; ---------------------------------------------------------------------------
BIOSDATA:17B8                 jnz     short doc3
BIOSDATA:17BA
BIOSDATA:17BA doc1:                                   ; CODE XREF: docmd+3B↓j
BIOSDATA:17BA                 push    cs
BIOSDATA:17BB                 call    waitt           ; wait for controller to complete read
BIOSDATA:17BE ; ---------------------------------------------------------------------------
BIOSDATA:17BE                 jnz     short doc3
BIOSDATA:17C0                 mov     cx, 256
BIOSDATA:17C3                 mov     dx, 1F0h        ; hf_port
BIOSDATA:17C6                 cld
BIOSDATA:17C7                 cli
BIOSDATA:17C8
BIOSDATA:17C8 rsct_loop:                              ; CODE XREF: docmd+17↓j
BIOSDATA:17C8                 insw                    ; read in sector
BIOSDATA:17C9                 loop    rsct_loop
BIOSDATA:17CB                 sti
BIOSDATA:17CC                 test    byte ptr ds:48h, 2 ; [cmd_block+cmd_reg]
BIOSDATA:17D1                 jz      short doc2
BIOSDATA:17D3                 push    cs
BIOSDATA:17D4                 call    wait_drq
BIOSDATA:17D7 ; ---------------------------------------------------------------------------
BIOSDATA:17D7                 jb      short doc3
BIOSDATA:17D9                 mov     cx, 4           ; 4 bytes of ecc
BIOSDATA:17DC                 mov     dx, 1F0h
BIOSDATA:17DF                 cli
BIOSDATA:17E0                 rep insb                ; read in ecc
BIOSDATA:17E2                 sti
BIOSDATA:17E3
BIOSDATA:17E3 doc2:                                   ; CODE XREF: docmd+1F↑j
BIOSDATA:17E3                 push    cs
BIOSDATA:17E4                 call    check_status
BIOSDATA:17E7 ; ---------------------------------------------------------------------------
BIOSDATA:17E7                 jnz     short doc3
BIOSDATA:17E9                 dec     byte ptr ds:43h ; [cmd_block+sec_cnt]
BIOSDATA:17ED                 jnz     short doc1
BIOSDATA:17EF
BIOSDATA:17EF doc3:                                   ; CODE XREF: docmd+6↑j
BIOSDATA:17EF                                         ; docmd+C↑j ...
BIOSDATA:17EF                 retn
BIOSDATA:17EF docmd           endp
BIOSDATA:17EF
BIOSDATA:17F0
BIOSDATA:17F0 ; =============== S U B R O U T I N E =======================================
BIOSDATA:17F0
BIOSDATA:17F0 ; Attributes: noreturn
BIOSDATA:17F0
BIOSDATA:17F0 get_vec         proc near               ; CODE XREF: setcmd+37↑p
BIOSDATA:17F0                 push    0FF65h          ; get pointer to hard disk parameters
BIOSDATA:17F3                 jmp     far ptr 0F000h:2F8Eh
BIOSDATA:17F3 get_vec         endp
BIOSDATA:17F3
BIOSDATA:17F8
BIOSDATA:17F8 ; =============== S U B R O U T I N E =======================================
BIOSDATA:17F8
BIOSDATA:17F8 ; Attributes: noreturn
BIOSDATA:17F8
BIOSDATA:17F8 command         proc near               ; CODE XREF: docmd+3↑p
BIOSDATA:17F8                 push    0FF65h          ; send contents of cmd_block to disk controller
BIOSDATA:17FB                 jmp     far ptr 0F000h:2E1Eh
BIOSDATA:17FB command         endp
BIOSDATA:17FB
BIOSDATA:1800
BIOSDATA:1800 ; =============== S U B R O U T I N E =======================================
BIOSDATA:1800
BIOSDATA:1800 ; Attributes: noreturn
BIOSDATA:1800
BIOSDATA:1800 waitt           proc near               ; CODE XREF: docmd+9↑p
BIOSDATA:1800                 push    0FF65h          ; wait for disk interrupt
BIOSDATA:1803                 jmp     far ptr 0F000h:2E7Fh
BIOSDATA:1803 waitt           endp
BIOSDATA:1803
BIOSDATA:1808
BIOSDATA:1808 ; =============== S U B R O U T I N E =======================================
BIOSDATA:1808
BIOSDATA:1808 ; Attributes: noreturn
BIOSDATA:1808
BIOSDATA:1808 wait_drq        proc near               ; CODE XREF: docmd+22↑p
BIOSDATA:1808                 push    0FF65h          ; wait for data request
BIOSDATA:180B                 jmp     far ptr 0F000h:2EE2h
BIOSDATA:180B wait_drq        endp
BIOSDATA:180B
BIOSDATA:1810
BIOSDATA:1810 ; =============== S U B R O U T I N E =======================================
BIOSDATA:1810
BIOSDATA:1810 ; Attributes: noreturn
BIOSDATA:1810
BIOSDATA:1810 check_status    proc near               ; CODE XREF: docmd+32↑p
BIOSDATA:1810                 push    0FF65h          ; check hard disk status
BIOSDATA:1813                 jmp     far ptr 0F000h:2EF8h
BIOSDATA:1813 check_status    endp
BIOSDATA:1813
BIOSDATA:1818
BIOSDATA:1818 ; =============== S U B R O U T I N E =======================================
BIOSDATA:1818
BIOSDATA:1818 ; Attributes: noreturn
BIOSDATA:1818
BIOSDATA:1818 check_dma       proc near               ; CODE XREF: BIOSDATA:1736↑p
BIOSDATA:1818                 push    0FF65h          ; check for dma overrun 64k segment
BIOSDATA:181B                 jmp     far ptr 0F000h:2F69h
BIOSDATA:181B check_dma       endp
BIOSDATA:181B
BIOSDATA:1820 ; ---------------------------------------------------------------------------
BIOSDATA:1820
BIOSDATA:1820 endatrom:                               ; DATA XREF: BIOSDATA:228B↓o
BIOSDATA:1820                                         ; BIOSDATA:22E3↓o
BIOSDATA:1820                 cmp     ah, 15h         ; compaq_disk_io
BIOSDATA:1823                 ja      short mebbe_hookit
BIOSDATA:1825
BIOSDATA:1825 no_hookit:                              ; CODE XREF: BIOSDATA:182D↓j
BIOSDATA:1825                 jmp     cs:Old13
BIOSDATA:182A ; ---------------------------------------------------------------------------
BIOSDATA:182A
BIOSDATA:182A mebbe_hookit:                           ; CODE XREF: BIOSDATA:1823↑j
BIOSDATA:182A                 cmp     dl, 80h
BIOSDATA:182D                 jb      short no_hookit
BIOSDATA:182F                 push    ds
BIOSDATA:1830                 push    40h
BIOSDATA:1832                 pop     ds
BIOSDATA:1833                 assume ds:nothing
BIOSDATA:1833                 pushf
BIOSDATA:1834                 call    cs:Old13
BIOSDATA:1839                 pop     ds
BIOSDATA:183A                 assume ds:nothing
BIOSDATA:183A                 retf    2
BIOSDATA:183A ; ---------------------------------------------------------------------------
BIOSDATA:183D end_compaq_i13hook db 0                 ; DATA XREF: BIOSDATA:do_compaq_patch↓o
BIOSDATA:183E ; ---------------------------------------------------------------------------
BIOSDATA:183E
BIOSDATA:183E int_6Ch:                                ; DATA XREF: BIOSDATA:2315↓o
BIOSDATA:183E                 cmp     cs:inHMA, 0     ; The K09 requires the routines for reading the clock
BIOSDATA:183E                                         ; because of the suspend/resume facility.
BIOSDATA:1844                 jz      short int6c
BIOSDATA:1846                 mov     bx, offset EnsureA20On
BIOSDATA:1849                 call    bx ; EnsureA20On
BIOSDATA:184B
BIOSDATA:184B int6c:                                  ; CODE XREF: BIOSDATA:1844↑j
BIOSDATA:184B                 push    cs
BIOSDATA:184C                 pop     ds
BIOSDATA:184D                 assume ds:BIOSDATA
BIOSDATA:184D                 pop     word ptr int6c_ret_addr
BIOSDATA:1851                 pop     word ptr int6c_ret_addr+2
BIOSDATA:1855                 popf
BIOSDATA:1856                 call    read_real_date  ; get the date from the clock
BIOSDATA:1859                 cli
BIOSDATA:185A                 mov     daycnt, si      ; update dos copy of date
BIOSDATA:185E                 sti
BIOSDATA:185F                 call    read_real_time  ; get the time from the   rtc
BIOSDATA:1862                 cli
BIOSDATA:1863                 mov     ah, 1
BIOSDATA:1865                 int     1Ah             ; CLOCK - SET TIME OF DAY
BIOSDATA:1865                                         ; CX:DX = clock count
BIOSDATA:1865                                         ; Return: time of day set
BIOSDATA:1867                 sti
BIOSDATA:1868                 jmp     int6c_ret_addr  ; jmp far [int6c_ret_addr] ; long jump
BIOSDATA:186C
BIOSDATA:186C ; =============== S U B R O U T I N E =======================================
BIOSDATA:186C
BIOSDATA:186C
BIOSDATA:186C read_real_date  proc near               ; CODE XREF: BIOSDATA:1856↑p
BIOSDATA:186C                                         ; cmos_clock_read+2F↓p
BIOSDATA:186C                 push    ax
BIOSDATA:186D                 push    cx
BIOSDATA:186E                 push    dx
BIOSDATA:186F                 xor     ah, ah          ; throw away clock roll over
BIOSDATA:1871                 int     1Ah             ; CLOCK - GET TIME OF DAY
BIOSDATA:1871                                         ; Return: CX:DX = clock count
BIOSDATA:1871                                         ; AL = 00h if clock was read or written (via AH=0,1) since the previous
BIOSDATA:1871                                         ; midnight
BIOSDATA:1871                                         ; Otherwise, AL > 0
BIOSDATA:1873                 pop     dx
BIOSDATA:1874                 pop     cx
BIOSDATA:1875                 pop     ax
BIOSDATA:1876                 push    ax
BIOSDATA:1877                 push    bx
BIOSDATA:1878                 push    cx
BIOSDATA:1879                 push    dx
BIOSDATA:187A                 mov     daycnt2, 1
BIOSDATA:1880                 mov     ah, 4
BIOSDATA:1882                 int     1Ah             ; CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
BIOSDATA:1882                                         ; Return: DL = day in BCD
BIOSDATA:1882                                         ; DH = month in BCD
BIOSDATA:1882                                         ; CL = year in BCD
BIOSDATA:1882                                         ; CH = century (19h or 20h)
BIOSDATA:1884                 jnb     short read_ok
BIOSDATA:1886                 jmp     r_d_ret
BIOSDATA:1889 ; ---------------------------------------------------------------------------
BIOSDATA:1889
BIOSDATA:1889 read_ok:                                ; CODE XREF: read_real_date+18↑j
BIOSDATA:1889                 mov     bin_date_time, ch
BIOSDATA:188D                 mov     bin_date_time+1, cl
BIOSDATA:1891                 mov     bin_date_time+2, dh
BIOSDATA:1895                 mov     bin_date_time+3, dl
BIOSDATA:1899                 mov     daycnt2, 2      ; READ OF R-T CLOCK SUCCESSFUL
BIOSDATA:189F                 call    bcd_verify      ; verify bcd values in range
BIOSDATA:18A2                 jb      short r_d_ret   ; some value out of range
BIOSDATA:18A4                 mov     daycnt2, 3
BIOSDATA:18AA                 call    date_verify
BIOSDATA:18AD                 jb      short r_d_ret
BIOSDATA:18AF                 mov     daycnt2, 0
BIOSDATA:18B5                 call    in_bin
BIOSDATA:18B8                 mov     al, bin_date_time+1
BIOSDATA:18BB                 cbw
BIOSDATA:18BC                 cmp     bin_date_time, 20 ; 20th century?
BIOSDATA:18C1                 jnz     short century_19
BIOSDATA:18C3                 add     ax, 100         ; add in a century
BIOSDATA:18C6
BIOSDATA:18C6 century_19:                             ; CODE XREF: read_real_date+55↑j
BIOSDATA:18C6                 sub     ax, 80          ; subtract off 1-1-80
BIOSDATA:18C9                 mov     cl, 4           ; leap year every 4
BIOSDATA:18CB                 div     cl              ; al= # leap year blocks, ah= remainder
BIOSDATA:18CD                 mov     bl, ah          ; save odd years
BIOSDATA:18CF                 cbw                     ; zero ah
BIOSDATA:18D0                 mov     cx, 1461        ; 366+(3*365)
BIOSDATA:18D0                                         ; # of days in leap year blocks
BIOSDATA:18D3                 mul     cx
BIOSDATA:18D5                 mov     daycnt2, ax     ; SAVE COUNT OF DAYS
BIOSDATA:18D8                 mov     al, bl          ; get odd years count
BIOSDATA:18DA                 cbw
BIOSDATA:18DB                 or      ax, ax
BIOSDATA:18DD                 jz      short leap_year
BIOSDATA:18DF                 mov     cx, 365         ; days in year
BIOSDATA:18E2                 mul     cx
BIOSDATA:18E4                 add     daycnt2, ax     ; ADD ON DAYS IN ODD YEARS
BIOSDATA:18E8                 jmp     short leap_adjustment ; account for leap year
BIOSDATA:18E8                                         ; possibly account for a leap day
BIOSDATA:18EA ; ---------------------------------------------------------------------------
BIOSDATA:18EA
BIOSDATA:18EA leap_year:                              ; CODE XREF: read_real_date+71↑j
BIOSDATA:18EA                 cmp     bin_date_time+2, 2 ; is month february?
BIOSDATA:18EF                 jbe     short no_leap_adjustment ; jan or feb. no leap day yet
BIOSDATA:18F1
BIOSDATA:18F1 leap_adjustment:                        ; CODE XREF: read_real_date+7C↑j
BIOSDATA:18F1                 inc     daycnt2         ; account for leap day
BIOSDATA:18F5
BIOSDATA:18F5 no_leap_adjustment:                     ; CODE XREF: read_real_date+83↑j
BIOSDATA:18F5                 mov     cl, bin_date_time+3 ; get days of month
BIOSDATA:18F9                 xor     ch, ch
BIOSDATA:18FB                 dec     cx              ; because of offset from day 1, not day 0
BIOSDATA:18FC                 add     daycnt2, cx     ; GET DAYS IN MONTHS PRECEEDING
BIOSDATA:1900                 mov     cl, bin_date_time+2 ; get month
BIOSDATA:1904                 dec     cx              ; january starts at offset 0
BIOSDATA:1905                 jz      short r_d_ret
BIOSDATA:1907                 mov     ah, 0
BIOSDATA:1909                 mov     si, offset month_table
BIOSDATA:190C
BIOSDATA:190C r_d_sum_loop:                           ; CODE XREF: read_real_date+A5↓j
BIOSDATA:190C                 lodsb
BIOSDATA:190D                 add     daycnt2, ax
BIOSDATA:1911                 loop    r_d_sum_loop
BIOSDATA:1913
BIOSDATA:1913 r_d_ret:                                ; CODE XREF: read_real_date+1A↑j
BIOSDATA:1913                                         ; read_real_date+36↑j ...
BIOSDATA:1913                 mov     si, daycnt2
BIOSDATA:1917                 pop     dx
BIOSDATA:1918                 pop     cx
BIOSDATA:1919                 pop     bx
BIOSDATA:191A                 pop     ax
BIOSDATA:191B                 retn
BIOSDATA:191B read_real_date  endp
BIOSDATA:191B
BIOSDATA:191C ; ---------------------------------------------------------------------------
BIOSDATA:191C ; START OF FUNCTION CHUNK FOR read_real_time
BIOSDATA:191C
BIOSDATA:191C r_t_retj:                               ; CODE XREF: read_real_time+4↓j
BIOSDATA:191C                                         ; read_real_time+1A↓j ...
BIOSDATA:191C                 xor     cx, cx
BIOSDATA:191E                 xor     dx, dx
BIOSDATA:1920                 jmp     short r_t_ret
BIOSDATA:1920 ; END OF FUNCTION CHUNK FOR read_real_time
BIOSDATA:1922
BIOSDATA:1922 ; =============== S U B R O U T I N E =======================================
BIOSDATA:1922
BIOSDATA:1922
BIOSDATA:1922 read_real_time  proc near               ; CODE XREF: BIOSDATA:185F↑p
BIOSDATA:1922
BIOSDATA:1922 ; FUNCTION CHUNK AT BIOSDATA:191C SIZE 00000006 BYTES
BIOSDATA:1922
BIOSDATA:1922                 mov     ah, 2
BIOSDATA:1924                 int     1Ah             ; CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)
BIOSDATA:1924                                         ; Return: CH = hours in BCD
BIOSDATA:1924                                         ; CL = minutes in BCD
BIOSDATA:1924                                         ; DH = seconds in BCD
BIOSDATA:1926                 jb      short r_t_retj
BIOSDATA:1928                 mov     bin_date_time, ch
BIOSDATA:192C                 mov     bin_date_time+1, cl
BIOSDATA:1930                 mov     bin_date_time+2, dh
BIOSDATA:1934                 mov     bin_date_time+3, 0 ; unused for time
BIOSDATA:1939                 call    bcd_verify
BIOSDATA:193C                 jb      short r_t_retj
BIOSDATA:193E                 call    time_verify
BIOSDATA:1941                 jb      short r_t_retj
BIOSDATA:1943                 call    in_bin          ; from bcd to bin
BIOSDATA:1946                 mov     ch, bin_date_time
BIOSDATA:194A                 mov     cl, bin_date_time+1
BIOSDATA:194E                 mov     dh, bin_date_time+2
BIOSDATA:1952                 mov     dl, bin_date_time+3
BIOSDATA:1956                 call    dword ptr ttticks ; call far [ttticks]
BIOSDATA:1956                                         ; note: indirect far call
BIOSDATA:1956                                         ; cx:dx = number of ticks
BIOSDATA:1956                                         ; (at 18.2 ticks per sec.)
BIOSDATA:195A
BIOSDATA:195A r_t_ret:                                ; CODE XREF: read_real_time-2↑j
BIOSDATA:195A                 retn
BIOSDATA:195A read_real_time  endp
BIOSDATA:195A
BIOSDATA:195B
BIOSDATA:195B ; =============== S U B R O U T I N E =======================================
BIOSDATA:195B
BIOSDATA:195B
BIOSDATA:195B in_bin          proc near               ; CODE XREF: read_real_date+49↑p
BIOSDATA:195B                                         ; read_real_time+21↑p
BIOSDATA:195B                 mov     al, bin_date_time ; century or hours
BIOSDATA:195E                 call    bcd_to_bin
BIOSDATA:1961                 mov     bin_date_time, al
BIOSDATA:1964                 mov     al, bin_date_time+1 ; years or minutes
BIOSDATA:1967                 call    bcd_to_bin
BIOSDATA:196A                 mov     bin_date_time+1, al
BIOSDATA:196D                 mov     al, bin_date_time+2 ; months or seconds
BIOSDATA:1970                 call    bcd_to_bin
BIOSDATA:1973                 mov     bin_date_time+2, al
BIOSDATA:1976                 mov     al, bin_date_time+3 ; days (not used for time)
BIOSDATA:1979                 call    bcd_to_bin
BIOSDATA:197C                 mov     bin_date_time+3, al
BIOSDATA:197F                 retn
BIOSDATA:197F in_bin          endp
BIOSDATA:197F
BIOSDATA:1980
BIOSDATA:1980 ; =============== S U B R O U T I N E =======================================
BIOSDATA:1980
BIOSDATA:1980
BIOSDATA:1980 bcd_to_bin      proc near               ; CODE XREF: in_bin+3↑p
BIOSDATA:1980                                         ; in_bin+C↑p ...
BIOSDATA:1980                 mov     ah, al          ; bcd_to_bin converts two bcd nibbles in al
BIOSDATA:1980                                         ; (value <= 99.) to a binary representation in al
BIOSDATA:1982                 and     al, 0Fh
BIOSDATA:1984                 mov     cl, 4
BIOSDATA:1986                 shr     ah, cl
BIOSDATA:1988                 aad
BIOSDATA:198A                 retn
BIOSDATA:198A bcd_to_bin      endp
BIOSDATA:198A
BIOSDATA:198B
BIOSDATA:198B ; =============== S U B R O U T I N E =======================================
BIOSDATA:198B
BIOSDATA:198B
BIOSDATA:198B date_verify     proc near               ; CODE XREF: read_real_date+3E↑p
BIOSDATA:198B                 cmp     bin_date_time, 20h ; century check
BIOSDATA:1990                 ja      short date_error
BIOSDATA:1992                 jz      short century_20 ; jmp in 21th century
BIOSDATA:1994                 cmp     bin_date_time, 19h ; century check
BIOSDATA:1999                 jb      short date_error
BIOSDATA:199B                 cmp     bin_date_time+1, 80h ; year check
BIOSDATA:19A0                 jb      short date_error
BIOSDATA:19A2
BIOSDATA:19A2 century_20:                             ; CODE XREF: date_verify+7↑j
BIOSDATA:19A2                 cmp     bin_date_time+1, 99h ; year check
BIOSDATA:19A7                 ja      short date_error
BIOSDATA:19A9                 cmp     bin_date_time+2, 12h ; month check
BIOSDATA:19AE                 ja      short date_error
BIOSDATA:19B0                 cmp     bin_date_time+2, 0
BIOSDATA:19B5                 jbe     short date_error
BIOSDATA:19B7                 cmp     bin_date_time+3, 31h ; day check
BIOSDATA:19BC                 ja      short date_error
BIOSDATA:19BE                 cmp     bin_date_time+3, 0
BIOSDATA:19C3                 jbe     short date_error
BIOSDATA:19C5                 clc
BIOSDATA:19C6                 retn
BIOSDATA:19C7 ; ---------------------------------------------------------------------------
BIOSDATA:19C7
BIOSDATA:19C7 date_error:                             ; CODE XREF: date_verify+5↑j
BIOSDATA:19C7                                         ; date_verify+E↑j ...
BIOSDATA:19C7                 stc
BIOSDATA:19C8                 retn
BIOSDATA:19C8 date_verify     endp
BIOSDATA:19C8
BIOSDATA:19C9
BIOSDATA:19C9 ; =============== S U B R O U T I N E =======================================
BIOSDATA:19C9
BIOSDATA:19C9
BIOSDATA:19C9 time_verify     proc near               ; CODE XREF: read_real_time+1C↑p
BIOSDATA:19C9                 cmp     bin_date_time, 24h ; hour check
BIOSDATA:19CE                 ja      short time_error
BIOSDATA:19D0                 cmp     bin_date_time+1, 59h ; minute check
BIOSDATA:19D5                 ja      short time_error
BIOSDATA:19D7                 cmp     bin_date_time+2, 59h ; second check
BIOSDATA:19DC                 ja      short time_error
BIOSDATA:19DE                 clc
BIOSDATA:19DF                 retn
BIOSDATA:19E0 ; ---------------------------------------------------------------------------
BIOSDATA:19E0
BIOSDATA:19E0 time_error:                             ; CODE XREF: time_verify+5↑j
BIOSDATA:19E0                                         ; time_verify+C↑j ...
BIOSDATA:19E0                 stc
BIOSDATA:19E1                 retn
BIOSDATA:19E1 time_verify     endp
BIOSDATA:19E1
BIOSDATA:19E2
BIOSDATA:19E2 ; =============== S U B R O U T I N E =======================================
BIOSDATA:19E2
BIOSDATA:19E2
BIOSDATA:19E2 bcd_verify      proc near               ; CODE XREF: read_real_date+33↑p
BIOSDATA:19E2                                         ; read_real_time+17↑p
BIOSDATA:19E2                 mov     cx, 4           ; 4 bytes to check
BIOSDATA:19E5                 mov     bx, offset bin_date_time
BIOSDATA:19E8
BIOSDATA:19E8 bv_loop:                                ; CODE XREF: bcd_verify+23↓j
BIOSDATA:19E8                 mov     al, [bx]        ; get a bcd number (0..99)
BIOSDATA:19EA                 mov     ah, al
BIOSDATA:19EC                 and     ax, 0F00Fh      ; 10's place in high ah, 1's in al
BIOSDATA:19EC                                         ; is 1's place in range?
BIOSDATA:19EF                 cmp     al, 10
BIOSDATA:19F1                 ja      short bv_error  ; jmp out of range
BIOSDATA:19F3                 shr     ah, 1
BIOSDATA:19F5                 shr     ah, 1
BIOSDATA:19F7                 shr     ah, 1
BIOSDATA:19F9                 shr     ah, 1
BIOSDATA:19FB                 and     ah, 0Fh         ; get rid of any erroneous bits
BIOSDATA:19FE                 cmp     ah, 10          ; is 10's place in range
BIOSDATA:1A01                 ja      short bv_error  ; jmp out of range
BIOSDATA:1A03                 inc     bx              ; next byte
BIOSDATA:1A04                 dec     cx
BIOSDATA:1A05                 jnz     short bv_loop
BIOSDATA:1A07                 clc                     ; set success flag
BIOSDATA:1A08                 retn
BIOSDATA:1A09 ; ---------------------------------------------------------------------------
BIOSDATA:1A09
BIOSDATA:1A09 bv_error:                               ; CODE XREF: bcd_verify+F↑j
BIOSDATA:1A09                                         ; bcd_verify+1F↑j
BIOSDATA:1A09                 stc                     ; set error flag
BIOSDATA:1A0A                 retn
BIOSDATA:1A0A bcd_verify      endp
BIOSDATA:1A0A
BIOSDATA:1A0A ; ---------------------------------------------------------------------------
BIOSDATA:1A0B endk09          db 90h
BIOSDATA:1A0C drvfat          dw 0                    ; DATA XREF: BIOSDATA:1F31↓w
BIOSDATA:1A0C                                         ; BIOSDATA:2332↓r ...
BIOSDATA:1A0E First_Data_Sector dw 2 dup(0)           ; DATA XREF: BIOSDATA:1CEF↓w
BIOSDATA:1A0E                                         ; BIOSDATA:2377↓w ...
BIOSDATA:1A12 doscnt          dw 0                    ; DATA XREF: getclus+2↓w
BIOSDATA:1A12                                         ; getclus+D2↓w ...
BIOSDATA:1A14 fbigfat         db 0                    ; DATA XREF: BIOSDATA:236C↓w
BIOSDATA:1A14                                         ; BIOSDATA:2397↓r ...
BIOSDATA:1A15 fatloc          dw 0                    ; DATA XREF: BIOSDATA:1F60↓w
BIOSDATA:1A15                                         ; getclus+38↓r
BIOSDATA:1A17 init_bootseg    dw 0                    ; DATA XREF: BIOSDATA:1F67↓w
BIOSDATA:1A17                                         ; getboot↓r
BIOSDATA:1A19 rom_drv_num     db 80h                  ; DATA XREF: sethard:set2↓w
BIOSDATA:1A19                                         ; sethard+1BB↓r ...
BIOSDATA:1A1A md_sectorsize   dw 200h                 ; DATA XREF: BIOSDATA:2364↓w
BIOSDATA:1A1A                                         ; get_fat_sector+8↓r ...
BIOSDATA:1A1C temp_cluster    dw 0                    ; DATA XREF: getclus+79↓w
BIOSDATA:1A1C                                         ; getclus+8C↓r ...
BIOSDATA:1A1E last_fat_sec_num dw 0FFFFh              ; DATA XREF: get_fat_sector+29↓r
BIOSDATA:1A1E                                         ; get_fat_sector+30↓w
BIOSDATA:1A20 num_heads       dw 2                    ; DATA XREF: BIOSDATA:209D↓w
BIOSDATA:1A20                                         ; BIOSDATA:20EB↓w ...
BIOSDATA:1A22 sec_trk         db 9                    ; DATA XREF: BIOSDATA:20A9↓w
BIOSDATA:1A22                                         ; BIOSDATA:20F3↓w ...
BIOSDATA:1A23 num_cyln        dw 40                   ; DATA XREF: BIOSDATA:2063↓w
BIOSDATA:1A23                                         ; BIOSDATA:20A3↓w ...
BIOSDATA:1A25 fakefloppydrv   db 0                    ; DATA XREF: BIOSDATA:_set_fake_flpdrv↓w
BIOSDATA:1A25                                         ; BIOSDATA:2027↓r ...
BIOSDATA:1A26 Orig_Int1Eh_Table dw 2 dup(0)           ; DATA XREF: BIOSDATA:1C85↓r
BIOSDATA:1A26                                         ; BIOSDATA:1CE0↓w ...
BIOSDATA:1A26                                         ;
BIOSDATA:1A26                                         ; 08/08/2023
BIOSDATA:1A26                                         ; ; disktable.totalsectors: resd 1
BIOSDATA:1A26                                         ; ; disktable.shiftcount:   resb 1
BIOSDATA:1A26                                         ; ; disktable.secperclus:   resb 1
BIOSDATA:1A26                                         ; ; disktable.rdirentries:  resw 1
BIOSDATA:1A26                                         ; ; disktable.bigflag:      resw 1
BIOSDATA:1A2A disktable2      dw 0                    ; DATA XREF: copybpb_fat+10C↓o
BIOSDATA:1A2C                 dw 32680
BIOSDATA:1A2E                 dw 803h
BIOSDATA:1A30                 dw 512
BIOSDATA:1A32                 dw 0                    ; for compatibility. (32680 sectors, 16340 KB)
BIOSDATA:1A34                 dw 4
BIOSDATA:1A36                 dw 0
BIOSDATA:1A38                 dw 402h
BIOSDATA:1A3A                 dw 512
BIOSDATA:1A3C                 dw 40h                  ; covers upto 134 mb media. ; fbig = 40h
BIOSDATA:1A3C                                         ; (40000h sectors = 128 MB)
BIOSDATA:1A3E                 dw 8
BIOSDATA:1A40                 dw 0
BIOSDATA:1A42                 dw 803h
BIOSDATA:1A44                 dw 512
BIOSDATA:1A46                 dw 40h                  ; upto 268 mb (80000h sectors = 256 MB)
BIOSDATA:1A48                 dw 16
BIOSDATA:1A4A                 dw 0
BIOSDATA:1A4C                 dw 1004h
BIOSDATA:1A4E                 dw 512
BIOSDATA:1A50                 dw 40h                  ; upto 536 mb (100000h sectors = 512 MB)
BIOSDATA:1A52                 dw 32
BIOSDATA:1A54                 dw 0
BIOSDATA:1A56                 dw 2005h
BIOSDATA:1A58                 dw 512
BIOSDATA:1A5A                 dw 40h                  ; upto 1072 mb (200000h sectors = 1024 MB)
BIOSDATA:1A5C                 dw 64
BIOSDATA:1A5E                 dw 0
BIOSDATA:1A60                 dw 4006h
BIOSDATA:1A62                 dw 512
BIOSDATA:1A64                 dw 40h                  ; upto 2144 mb (400000h sectors = 2048 MB)
BIOSDATA:1A66                 dw 0FFFFh               ; if fs size > 2144 MB, it is FAT32 file system
BIOSDATA:1A68                 dw 0FFFFh
BIOSDATA:1A6A                 dw 803h                 ; cluster shift 3, sec per clust = 8
BIOSDATA:1A6C                 dw 0
BIOSDATA:1A6E                 dw 60h                  ; > 2144 MB ; FAT32 (fbigbig = 20h)
BIOSDATA:1A6E                                         ; (fbig and fbigbig flags are set)
BIOSDATA:1A6E                                         ; ;
BIOSDATA:1A70 rom_minidisk_num db 0                   ; DATA XREF: domini+1E↓w
BIOSDATA:1A70                                         ; domini+37↓r ...
BIOSDATA:1A71 hnum            db 0                    ; DATA XREF: BIOSDATA:2017↓w
BIOSDATA:1A71                                         ; BIOSDATA:dohard↓r ...
BIOSDATA:1A72 last_dskdrv_table dw offset dskdrvs     ; DATA XREF: BIOSDATA:1FDD↓w
BIOSDATA:1A72                                         ; BIOSDATA:2053↓w ...
BIOSDATA:1A74 end_of_bdss     dw offset bdss          ; DATA XREF: BIOSDATA:2056↓r
BIOSDATA:1A74                                         ; BIOSDATA:21F7↓r ...
BIOSDATA:1A76 mini_hdlim      dw 0                    ; DATA XREF: domini+2B↓w
BIOSDATA:1A76                                         ; find_mini_partition+4A↓r
BIOSDATA:1A78 mini_seclim     dw 0                    ; DATA XREF: domini+33↓w
BIOSDATA:1A78                                         ; find_mini_partition+50↓r
BIOSDATA:1A7A ld_p_number     dw 2BADh                ; DATA XREF: find_mini_partition+4↓w
BIOSDATA:1A7A                                         ; find_mini_partition:fmpnext↓w ...
BIOSDATA:1A7C bios_date       db '01/10/84',0         ; DATA XREF: BIOSDATA:227D↓o
BIOSDATA:1A85                 db 90h
BIOSDATA:1A86 bpb48t          dw 512                  ; DATA XREF: BIOSDATA:bpbtable↓o
BIOSDATA:1A88                 db 2
BIOSDATA:1A89                 dw 1
BIOSDATA:1A8B                 db 2
BIOSDATA:1A8C                 dw 112
BIOSDATA:1A8E                 dw 720
BIOSDATA:1A90                 db 0FDh
BIOSDATA:1A91                 dw 2
BIOSDATA:1A93                 dw 9
BIOSDATA:1A95                 dw 2
BIOSDATA:1A97                 dd 0
BIOSDATA:1A9B                 dd 0
BIOSDATA:1A9F                 db 28 dup(0)            ; FAT32 extensions (to BDS)
BIOSDATA:1ABB                 db 90h
BIOSDATA:1ABC bpb96t          dw 512                  ; DATA XREF: BIOSDATA:1B60↓o
BIOSDATA:1ABE                 db 1
BIOSDATA:1ABF                 dw 1
BIOSDATA:1AC1                 db 2
BIOSDATA:1AC2                 dw 224
BIOSDATA:1AC4                 dw 2400
BIOSDATA:1AC6                 db 0F9h
BIOSDATA:1AC7                 dw 7
BIOSDATA:1AC9                 dw 15
BIOSDATA:1ACB                 dw 2
BIOSDATA:1ACD                 dd 0
BIOSDATA:1AD1                 dd 0
BIOSDATA:1AD5                 db 28 dup(0)
BIOSDATA:1AF1                 db 90h
BIOSDATA:1AF2 bpb35           dw 512                  ; DATA XREF: BIOSDATA:1B62↓o
BIOSDATA:1AF2                                         ; BIOSDATA:1B64↓o ...
BIOSDATA:1AF4                 db 2
BIOSDATA:1AF5                 dw 1
BIOSDATA:1AF7                 db 2
BIOSDATA:1AF8                 dw 112
BIOSDATA:1AFA                 dw 1440
BIOSDATA:1AFC                 db 0F9h
BIOSDATA:1AFD                 dw 3
BIOSDATA:1AFF                 dw 9
BIOSDATA:1B01                 dw 2
BIOSDATA:1B03                 dd 0
BIOSDATA:1B07                 dd 0
BIOSDATA:1B0B                 db 28 dup(0)
BIOSDATA:1B27                 db 90h
BIOSDATA:1B28 bpb288          dw 512                  ; DATA XREF: BIOSDATA:1B70↓o
BIOSDATA:1B2A                 db 2
BIOSDATA:1B2B                 dw 1
BIOSDATA:1B2D                 db 2
BIOSDATA:1B2E                 dw 240
BIOSDATA:1B30                 dw 5760
BIOSDATA:1B32                 db 0F0h
BIOSDATA:1B33                 dw 9
BIOSDATA:1B35                 dw 36
BIOSDATA:1B37                 dw 2
BIOSDATA:1B39                 dd 0
BIOSDATA:1B3D                 dd 0
BIOSDATA:1B41                 db 28 dup(0)
BIOSDATA:1B5D                 db 90h
BIOSDATA:1B5E bpbtable        dw offset bpb48t        ; DATA XREF: setdrvparms+A0↓o
BIOSDATA:1B60                 dw offset bpb96t
BIOSDATA:1B62                 dw offset bpb35
BIOSDATA:1B64                 dw offset bpb35
BIOSDATA:1B66                 dw offset bpb35
BIOSDATA:1B68                 dw offset bpb35
BIOSDATA:1B6A                 dw offset bpb35
BIOSDATA:1B6C                 dw offset bpb35
BIOSDATA:1B6E                 dw offset bpb35
BIOSDATA:1B70                 dw offset bpb288
BIOSDATA:1B72 addr_of_bcretf  dw offset bc_retf       ; DATA XREF: BIOSDATA:call_bios_code↓r
BIOSDATA:1B74 ; ---------------------------------------------------------------------------
BIOSDATA:1B74
BIOSDATA:1B74 call_bios_code:                         ; CODE XREF: BIOSDATA:2339↓p
BIOSDATA:1B74                                         ; BIOSDATA:2340↓p ...
BIOSDATA:1B74                 push    cs:addr_of_bcretf ; set up near return to far return
BIOSDATA:1B79                 push    cs:cdev_2       ; [cs:cdev+2] ; push Bios_Code segment
BIOSDATA:1B7E                 push    bp
BIOSDATA:1B7F                 retf
BIOSDATA:1B7F ; ---------------------------------------------------------------------------
BIOSDATA:1B80 flp_drvs        db 0                    ; DATA XREF: BIOSDATA:1E10↓w
BIOSDATA:1B80                                         ; BIOSDATA:1E1D↓r ...
BIOSDATA:1B81 firstcluster_hw dw 0                    ; DATA XREF: BIOSDATA:1ED4↓w
BIOSDATA:1B81                                         ; BIOSDATA:2390↓r
BIOSDATA:1B83 Boot_Drv        db 0                    ; DATA XREF: BIOSDATA:1CF4↓w
BIOSDATA:1B83                                         ; BIOSDATA:1E51↓w ...
BIOSDATA:1B84 ; ---------------------------------------------------------------------------
BIOSDATA:1B84
BIOSDATA:1B84 cd_boot_option:                         ; CODE XREF: BIOSDATA:1D36↓p
BIOSDATA:1B84                 push    ax
BIOSDATA:1B85                 push    ds
BIOSDATA:1B86                 push    es
BIOSDATA:1B87                 push    dx
BIOSDATA:1B88
BIOSDATA:1B88 cdbo_1:                                 ; CODE XREF: BIOSDATA:1B92↓j
BIOSDATA:1B88                 mov     ah, 1
BIOSDATA:1B8A                 int     16h             ; KEYBOARD -
BIOSDATA:1B8C                 jz      short cdbo_2
BIOSDATA:1B8E                 xor     ah, ah
BIOSDATA:1B90                 int     16h             ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
BIOSDATA:1B90                                         ; Return: AH = scan code, AL = character
BIOSDATA:1B92                 jmp     short cdbo_1
BIOSDATA:1B94 ; ---------------------------------------------------------------------------
BIOSDATA:1B94
BIOSDATA:1B94 cdbo_2:                                 ; CODE XREF: BIOSDATA:1B8C↑j
BIOSDATA:1B94                 push    cs
BIOSDATA:1B95                 pop     ds
BIOSDATA:1B96                 mov     si, offset cd_boot_msg ; "\r\nPress the ENTER key to boot from CD"...
BIOSDATA:1B99                 lodsb
BIOSDATA:1B9A
BIOSDATA:1B9A cdbo_3:                                 ; CODE XREF: BIOSDATA:1BA4↓j
BIOSDATA:1B9A                 mov     bx, 7
BIOSDATA:1B9D                 mov     ah, 0Eh
BIOSDATA:1B9F                 int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
BIOSDATA:1B9F                                         ; AL = character, BH = display page (alpha modes)
BIOSDATA:1B9F                                         ; BL = foreground color (graphics modes)
BIOSDATA:1BA1                 lodsb
BIOSDATA:1BA2                 or      al, al
BIOSDATA:1BA4                 jnz     short cdbo_3
BIOSDATA:1BA6                 mov     ax, 40h
BIOSDATA:1BA9                 mov     ds, ax
BIOSDATA:1BAB                 assume ds:nothing
BIOSDATA:1BAB                 mov     bx, ds:6Ch      ; 0:46Ch = Daily timer counter (4 bytes)
BIOSDATA:1BAF                 mov     si, ds:6Eh
BIOSDATA:1BB3
BIOSDATA:1BB3 wait_for_key:                           ; CODE XREF: BIOSDATA:1BFF↓j
BIOSDATA:1BB3                 push    bx
BIOSDATA:1BB4                 mov     bx, 7
BIOSDATA:1BB7                 mov     ax, 0E08h
BIOSDATA:1BBA                 int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
BIOSDATA:1BBA                                         ; AL = character, BH = display page (alpha modes)
BIOSDATA:1BBA                                         ; BL = foreground color (graphics modes)
BIOSDATA:1BBC                 mov     ax, 0E20h
BIOSDATA:1BBF                 int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
BIOSDATA:1BBF                                         ; AL = character, BH = display page (alpha modes)
BIOSDATA:1BBF                                         ; BL = foreground color (graphics modes)
BIOSDATA:1BC1                 mov     ax, 0E08h
BIOSDATA:1BC4                 int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
BIOSDATA:1BC4                                         ; AL = character, BH = display page (alpha modes)
BIOSDATA:1BC4                                         ; BL = foreground color (graphics modes)
BIOSDATA:1BC6                 pop     bx
BIOSDATA:1BC7                 add     bx, 18          ; 18.2 ticks per second
BIOSDATA:1BCA                 adc     si, 0           ; next second (if carry flag is 1)
BIOSDATA:1BCD
BIOSDATA:1BCD continue_to_wait:                       ; CODE XREF: BIOSDATA:cdb0_6↓j
BIOSDATA:1BCD                 mov     ah, 1
BIOSDATA:1BCF                 int     16h             ; KEYBOARD -
BIOSDATA:1BD1                 jz      short cdbo_5
BIOSDATA:1BD3                 mov     ah, 0
BIOSDATA:1BD5                 int     16h             ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
BIOSDATA:1BD5                                         ; Return: AH = scan code, AL = character
BIOSDATA:1BD7                 cmp     ax, 11Bh
BIOSDATA:1BDA                 jz      short cdb0_7
BIOSDATA:1BDC
BIOSDATA:1BDC cdbo_4:                                 ; CODE XREF: BIOSDATA:cdbo_8↓j
BIOSDATA:1BDC                 mov     bx, 7
BIOSDATA:1BDF                 mov     ax, 0E0Dh
BIOSDATA:1BE2                 int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
BIOSDATA:1BE2                                         ; AL = character, BH = display page (alpha modes)
BIOSDATA:1BE2                                         ; BL = foreground color (graphics modes)
BIOSDATA:1BE4                 mov     ax, 0E0Ah
BIOSDATA:1BE7                 int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
BIOSDATA:1BE7                                         ; AL = character, BH = display page (alpha modes)
BIOSDATA:1BE7                                         ; BL = foreground color (graphics modes)
BIOSDATA:1BE9                 pop     dx
BIOSDATA:1BEA                 pop     es
BIOSDATA:1BEB                 pop     ds
BIOSDATA:1BEC                 assume ds:nothing
BIOSDATA:1BEC                 pop     ax
BIOSDATA:1BED                 retn
BIOSDATA:1BEE ; ---------------------------------------------------------------------------
BIOSDATA:1BEE
BIOSDATA:1BEE cdbo_5:                                 ; CODE XREF: BIOSDATA:1BD1↑j
BIOSDATA:1BEE                 cmp     si, ds:6Eh
BIOSDATA:1BF2                 jnz     short cdb0_6
BIOSDATA:1BF4                 cmp     bx, ds:6Ch
BIOSDATA:1BF8
BIOSDATA:1BF8 cdb0_6:                                 ; CODE XREF: BIOSDATA:1BF2↑j
BIOSDATA:1BF8                 jnb     short continue_to_wait
BIOSDATA:1BFA                 dec     cs:time_counter
BIOSDATA:1BFF                 jnz     short wait_for_key
BIOSDATA:1C01
BIOSDATA:1C01 cdb0_7:                                 ; CODE XREF: BIOSDATA:1BDA↑j
BIOSDATA:1C01                 mov     bx, 7
BIOSDATA:1C04                 mov     ax, 0E0Dh
BIOSDATA:1C07                 int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
BIOSDATA:1C07                                         ; AL = character, BH = display page (alpha modes)
BIOSDATA:1C07                                         ; BL = foreground color (graphics modes)
BIOSDATA:1C09                 mov     ax, 0E0Ah
BIOSDATA:1C0C                 int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
BIOSDATA:1C0C                                         ; AL = character, BH = display page (alpha modes)
BIOSDATA:1C0C                                         ; BL = foreground color (graphics modes)
BIOSDATA:1C0E                 push    cs
BIOSDATA:1C0F                 pop     ds
BIOSDATA:1C10                 assume ds:BIOSDATA
BIOSDATA:1C10                 mov     ax, 4B00h
BIOSDATA:1C13                 xor     dl, dl          ; disk drive = 0 (fd)
BIOSDATA:1C15                 mov     si, offset empty_dap_buff
BIOSDATA:1C18                 int     13h             ; DISK - Bootable CD-ROM - AL = TERMINATE DISK EMULATION
BIOSDATA:1C1A                 mov     dx, 80h         ; DS:SI = Specification packet filled
BIOSDATA:1C1D                 xor     ax, ax
BIOSDATA:1C1F                 mov     byte ptr [si], 13h
BIOSDATA:1C22                 mov     [si+1], al
BIOSDATA:1C25                 mov     [si+2], dx
BIOSDATA:1C28                 mov     [si+4], ax
BIOSDATA:1C2B                 mov     [si+6], ax
BIOSDATA:1C2E                 mov     [si+8], ax
BIOSDATA:1C31                 mov     [si+0Ah], ax
BIOSDATA:1C34                 mov     [si+0Ch], ax
BIOSDATA:1C37                 mov     [si+0Eh], ax
BIOSDATA:1C3A                 mov     [si+10h], al
BIOSDATA:1C3D                 mov     [si+11h], al
BIOSDATA:1C40                 mov     [si+12h], al
BIOSDATA:1C43                 mov     ax, 4B00h       ; disk drive = 80h (hd)
BIOSDATA:1C46                 int     13h             ; DISK - Bootable CD-ROM - AL = TERMINATE DISK EMULATION
BIOSDATA:1C48                 xor     ax, ax
BIOSDATA:1C4A                 mov     dx, 80h
BIOSDATA:1C4D                 int     13h             ; DISK - RESET DISK SYSTEM
BIOSDATA:1C4D                                         ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
BIOSDATA:1C4F                 push    cs
BIOSDATA:1C50                 pop     es
BIOSDATA:1C51                 assume es:BIOSDATA
BIOSDATA:1C51                 mov     ax, 201h
BIOSDATA:1C54                 mov     bx, offset disksector
BIOSDATA:1C57                 mov     cx, 1
BIOSDATA:1C5A                 mov     dx, 80h
BIOSDATA:1C5D                 int     13h             ; DISK - READ SECTORS INTO MEMORY
BIOSDATA:1C5D                                         ; AL = number of sectors to read, CH = track, CL = sector
BIOSDATA:1C5D                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
BIOSDATA:1C5D                                         ; Return: CF set on error, AH = status, AL = number of sectors read
BIOSDATA:1C5F                 jb      short cdbo_8
BIOSDATA:1C61                 cmp     word ptr es:[bx+1FEh], 0AA55h
BIOSDATA:1C68                 jz      short cdbo_9
BIOSDATA:1C6A
BIOSDATA:1C6A cdbo_8:                                 ; CODE XREF: BIOSDATA:1C5F↑j
BIOSDATA:1C6A                 jmp     cdbo_4
BIOSDATA:1C6D ; ---------------------------------------------------------------------------
BIOSDATA:1C6D
BIOSDATA:1C6D cdbo_9:                                 ; CODE XREF: BIOSDATA:1C68↑j
BIOSDATA:1C6D                 push    cs
BIOSDATA:1C6E                 pop     ds
BIOSDATA:1C6F                 xor     ax, ax
BIOSDATA:1C71                 mov     di, 7C00h
BIOSDATA:1C74                 mov     es, ax
BIOSDATA:1C76                 assume es:nothing
BIOSDATA:1C76                 mov     si, bx
BIOSDATA:1C78                 push    es
BIOSDATA:1C79                 push    di
BIOSDATA:1C7A                 mov     cx, 100h        ; 256
BIOSDATA:1C7D                 cld
BIOSDATA:1C7E                 rep movsw
BIOSDATA:1C80                 mov     ds, ax
BIOSDATA:1C82                 assume ds:nothing
BIOSDATA:1C82                 mov     si, 78h
BIOSDATA:1C85                 mov     ax, cs:Orig_Int1Eh_Table
BIOSDATA:1C89                 mov     [si], ax
BIOSDATA:1C8B                 mov     ax, cs:Orig_Int1Eh_Table+2
BIOSDATA:1C8F                 mov     [si+2], ax
BIOSDATA:1C92                 retf
BIOSDATA:1C92 ; ---------------------------------------------------------------------------
BIOSDATA:1C93 empty_dap_buff  db 19                   ; DATA XREF: BIOSDATA:1C15↑o
BIOSDATA:1C94                 db 18 dup(0)
BIOSDATA:1CA6 time_counter    db 5                    ; DATA XREF: BIOSDATA:1BFA↑w
BIOSDATA:1CA6                                         ; 5 seconds
BIOSDATA:1CA7 cd_boot_msg     db 0Dh,0Ah              ; DATA XREF: BIOSDATA:1B96↑o
BIOSDATA:1CA7                 db 'Press the ENTER key to boot from CD or DVD......',0
BIOSDATA:1CDA ; ---------------------------------------------------------------------------
BIOSDATA:1CDA
BIOSDATA:1CDA init:                                   ; CODE XREF: BIOSDATA:hdrv_pat↑j
BIOSDATA:1CDA                 cli
BIOSDATA:1CDB                 mov     cs:Orig_Int1Eh_Table+2, ds ; DS:SI from MSLOAD (not boot sector)
BIOSDATA:1CE0                 mov     cs:Orig_Int1Eh_Table, si
BIOSDATA:1CE5                 push    ax
BIOSDATA:1CE6                 xor     ax, ax
BIOSDATA:1CE8                 mov     ds, ax
BIOSDATA:1CEA                 pop     ax
BIOSDATA:1CEB                 mov     cs:First_Data_Sector+2, ax ; AX:BX from MSLOAD
BIOSDATA:1CEF                 mov     cs:First_Data_Sector, bx
BIOSDATA:1CF4                 mov     cs:Boot_Drv, dl ; Boot Drive from MSLOAD ;;; [BootDrive]
BIOSDATA:1CF9                 push    cs
BIOSDATA:1CFA                 pop     es
BIOSDATA:1CFB                 assume es:BIOSDATA
BIOSDATA:1CFB                 push    cx
BIOSDATA:1CFC                 push    di
BIOSDATA:1CFD                 cld
BIOSDATA:1CFE                 push    ds
BIOSDATA:1CFF                 mov     ax, 544h        ; SYSINIT segment
BIOSDATA:1CFF                                         ; SYSINITSEG (= IOSYSCODESEG+(SYSINITOFFSET>>4)
BIOSDATA:1D02                 xor     si, si
BIOSDATA:1D04                 mov     ds, si          ; check (1st sector) of the root directory -of BOOT CD-
BIOSDATA:1D04                                         ; for special names (as boot option signature)
BIOSDATA:1D06                 mov     si, 540h        ; ROOT DIRECTORY BUFFER offset 40h
BIOSDATA:1D06                                         ; (BOOT DRV's root directory the 3rd entry)
BIOSDATA:1D09
BIOSDATA:1D09 chk_boot_hdnoz:                         ; CODE XREF: BIOSDATA:1D42↓j
BIOSDATA:1D09                 cmp     byte ptr [si], 0
BIOSDATA:1D0C                 jz      short chk_no_logo_noz
BIOSDATA:1D0E                 cmp     word ptr [si], 425Fh ; '_BOOT_HDNOZ'
BIOSDATA:1D12                 jnz     short chk_next_1
BIOSDATA:1D14                 cmp     word ptr [si+2], 4F4Fh ; 'OO'
BIOSDATA:1D19                 jnz     short chk_next_1
BIOSDATA:1D1B                 cmp     word ptr [si+4], 5F54h
BIOSDATA:1D20                 jnz     short chk_next_1
BIOSDATA:1D22                 cmp     word ptr [si+6], 4448h ; 'HD'
BIOSDATA:1D27                 jnz     short chk_next_1
BIOSDATA:1D29                 cmp     word ptr [si+8], 4F4Eh
BIOSDATA:1D2E                 jnz     short chk_next_1
BIOSDATA:1D30                 cmp     byte ptr [si+0Ah], 5Ah ; 'Z'
BIOSDATA:1D34                 jnz     short chk_next_1
BIOSDATA:1D36                 call    cd_boot_option
BIOSDATA:1D39                 jmp     short chk_no_logo_noz
BIOSDATA:1D3B ; ---------------------------------------------------------------------------
BIOSDATA:1D3B
BIOSDATA:1D3B chk_next_1:                             ; CODE XREF: BIOSDATA:1D12↑j
BIOSDATA:1D3B                                         ; BIOSDATA:1D19↑j ...
BIOSDATA:1D3B                 add     si, 32          ; (next entry)
BIOSDATA:1D3E                 cmp     si, 700h
BIOSDATA:1D42                 jb      short chk_boot_hdnoz
BIOSDATA:1D44
BIOSDATA:1D44 chk_no_logo_noz:                        ; CODE XREF: BIOSDATA:1D0C↑j
BIOSDATA:1D44                                         ; BIOSDATA:1D39↑j
BIOSDATA:1D44                 mov     si, 540h        ; (BOOT DRV's root directory the 3rd entry)
BIOSDATA:1D47
BIOSDATA:1D47 chk_no_logo_noz2_nxt:                   ; CODE XREF: BIOSDATA:1D7B↓j
BIOSDATA:1D47                 cmp     byte ptr [si], 0
BIOSDATA:1D4A                 jz      short write_start_msg
BIOSDATA:1D4C                 cmp     word ptr [si], 4F4Eh ; 'NO_LOGO NOZ'
BIOSDATA:1D50                 jnz     short chk_next_2
BIOSDATA:1D52                 cmp     word ptr [si+2], 4C5Fh
BIOSDATA:1D57                 jnz     short chk_next_2
BIOSDATA:1D59                 cmp     word ptr [si+4], 474Fh
BIOSDATA:1D5E                 jnz     short chk_next_2
BIOSDATA:1D60                 cmp     word ptr [si+6], 204Fh
BIOSDATA:1D65                 jnz     short chk_next_2
BIOSDATA:1D67                 cmp     word ptr [si+8], 4F4Eh
BIOSDATA:1D6C                 jnz     short chk_next_2
BIOSDATA:1D6E                 cmp     byte ptr [si+0Ah], 5Ah
BIOSDATA:1D72                 jz      short startmsg_ok
BIOSDATA:1D74
BIOSDATA:1D74 chk_next_2:                             ; CODE XREF: BIOSDATA:1D50↑j
BIOSDATA:1D74                                         ; BIOSDATA:1D57↑j ...
BIOSDATA:1D74                 add     si, 32          ; (next entry)
BIOSDATA:1D77                 cmp     si, 700h
BIOSDATA:1D7B                 jb      short chk_no_logo_noz2_nxt
BIOSDATA:1D7D
BIOSDATA:1D7D write_start_msg:                        ; CODE XREF: BIOSDATA:1D4A↑j
BIOSDATA:1D7D                 mov     ds, ax          ; SYSINIT segment
BIOSDATA:1D7F                 assume ds:nothing
BIOSDATA:1D7F                 mov     si, offset StartMsg ; "Starting PC DOS...\r\n\n"
BIOSDATA:1D82
BIOSDATA:1D82 startmsg_nxt_chr:                       ; CODE XREF: BIOSDATA:1D8E↓j
BIOSDATA:1D82                 lodsb
BIOSDATA:1D83                 or      al, al
BIOSDATA:1D85                 jz      short startmsg_ok
BIOSDATA:1D87                 mov     ah, 0Eh
BIOSDATA:1D89                 mov     bx, 7
BIOSDATA:1D8C                 int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
BIOSDATA:1D8C                                         ; AL = character, BH = display page (alpha modes)
BIOSDATA:1D8C                                         ; BL = foreground color (graphics modes)
BIOSDATA:1D8E                 jmp     short startmsg_nxt_chr
BIOSDATA:1D90 ; ---------------------------------------------------------------------------
BIOSDATA:1D90
BIOSDATA:1D90 startmsg_ok:                            ; CODE XREF: BIOSDATA:1D72↑j
BIOSDATA:1D90                                         ; BIOSDATA:1D85↑j
BIOSDATA:1D90                 pop     ds
BIOSDATA:1D91                 mov     cx, 5
BIOSDATA:1D94                 mov     si, offset RomVectors
BIOSDATA:1D97
BIOSDATA:1D97 next_int:                               ; CODE XREF: BIOSDATA:1DA8↓j
BIOSDATA:1D97                 lods    byte ptr cs:[si]
BIOSDATA:1D99                 cbw
BIOSDATA:1D9A                 shl     ax, 1
BIOSDATA:1D9C                 shl     ax, 1
BIOSDATA:1D9E                 mov     di, ax
BIOSDATA:1DA0                 xchg    si, di
BIOSDATA:1DA2                 lodsw
BIOSDATA:1DA3                 stosw
BIOSDATA:1DA4                 lodsw
BIOSDATA:1DA5                 stosw
BIOSDATA:1DA6                 xchg    si, di
BIOSDATA:1DA8                 loop    next_int
BIOSDATA:1DAA                 pop     di
BIOSDATA:1DAB                 pop     cx
BIOSDATA:1DAC                 mov     ax, word ptr cs:Old13
BIOSDATA:1DB0                 mov     word ptr cs:Orig13, ax
BIOSDATA:1DB4                 mov     ax, word ptr cs:Old13+2
BIOSDATA:1DB8                 mov     word ptr cs:Orig13+2, ax
BIOSDATA:1DBC                 mov     word ptr ds:4Ch, offset block13
BIOSDATA:1DC2                 mov     word ptr ds:4Eh, cs
BIOSDATA:1DC6                 mov     ax, ds:68h
BIOSDATA:1DC9                 mov     word ptr cs:Orig1A, ax
BIOSDATA:1DCD                 mov     ax, ds:6Ah
BIOSDATA:1DD0                 mov     word ptr cs:Orig1A+2, ax
BIOSDATA:1DD4                 mov     word ptr ds:68h, offset Int1A
BIOSDATA:1DDA                 mov     word ptr ds:6Ah, cs
BIOSDATA:1DDE                 mov     word ptr ds:54h, offset Int15
BIOSDATA:1DE4                 mov     word ptr ds:56h, cs
BIOSDATA:1DE8                 mov     word ptr ds:64h, offset int19
BIOSDATA:1DEE                 mov     word ptr ds:66h, cs ; 19h*4+2
BIOSDATA:1DF2                 sti
BIOSDATA:1DF3                 int     11h             ; EQUIPMENT DETERMINATION
BIOSDATA:1DF3                                         ; Return: AX = equipment flag bits
BIOSDATA:1DF5                 jmp     short chk_fd_count
BIOSDATA:1DF7 ; ---------------------------------------------------------------------------
BIOSDATA:1DF7                 push    dx              ; 52h ; 'R'
BIOSDATA:1DF8                 push    ax              ; 50h ; 'P'
BIOSDATA:1DF9                 push    bx              ; 53h ; 'S'
BIOSDATA:1DFA
BIOSDATA:1DFA chk_fd_count:                           ; CODE XREF: BIOSDATA:1DF5↑j
BIOSDATA:1DFA                 or      ax, 1
BIOSDATA:1DFD                 test    ax, 1
BIOSDATA:1E00                 jnz     short normalfloppydrv
BIOSDATA:1E02                 push    ax
BIOSDATA:1E03                 push    bx
BIOSDATA:1E04                 push    cx
BIOSDATA:1E05                 push    dx
BIOSDATA:1E06                 push    di
BIOSDATA:1E07                 push    es
BIOSDATA:1E08                 mov     ah, 8
BIOSDATA:1E0A                 mov     dl, 0
BIOSDATA:1E0C                 int     13h             ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
BIOSDATA:1E0C                                         ; DL = drive number
BIOSDATA:1E0C                                         ; Return: CF set on error, AH = status code, BL = drive type
BIOSDATA:1E0C                                         ; DL = number of consecutive drives
BIOSDATA:1E0C                                         ; DH = maximum value for head number, ES:DI -> drive parameter
BIOSDATA:1E0E                 jb      short _gdskp_error
BIOSDATA:1E10                 mov     cs:flp_drvs, dl
BIOSDATA:1E15
BIOSDATA:1E15 _gdskp_error:                           ; CODE XREF: BIOSDATA:1E0E↑j
BIOSDATA:1E15                 pop     es
BIOSDATA:1E16                 assume es:nothing
BIOSDATA:1E16                 pop     di
BIOSDATA:1E17                 pop     dx
BIOSDATA:1E18                 pop     cx
BIOSDATA:1E19                 pop     bx
BIOSDATA:1E1A                 pop     ax
BIOSDATA:1E1B                 jb      short normalfloppydrv
BIOSDATA:1E1D                 cmp     cs:flp_drvs, 0
BIOSDATA:1E23                 jz      short _set_fake_flpdrv
BIOSDATA:1E25                 mov     al, cs:flp_drvs
BIOSDATA:1E29                 dec     al
BIOSDATA:1E2B                 jmp     short got_num_flp_drvs
BIOSDATA:1E2D ; ---------------------------------------------------------------------------
BIOSDATA:1E2D
BIOSDATA:1E2D _set_fake_flpdrv:                       ; CODE XREF: BIOSDATA:1E23↑j
BIOSDATA:1E2D                 mov     cs:fakefloppydrv, 1
BIOSDATA:1E33                 mov     ax, 1
BIOSDATA:1E36                 jmp     short settwodrive
BIOSDATA:1E38 ; ---------------------------------------------------------------------------
BIOSDATA:1E38
BIOSDATA:1E38 normalfloppydrv:                        ; CODE XREF: BIOSDATA:1E00↑j
BIOSDATA:1E38                                         ; BIOSDATA:1E1B↑j
BIOSDATA:1E38                 rol     al, 1
BIOSDATA:1E3A                 rol     al, 1
BIOSDATA:1E3C
BIOSDATA:1E3C got_num_flp_drvs:                       ; CODE XREF: BIOSDATA:1E2B↑j
BIOSDATA:1E3C                 and     ax, 3
BIOSDATA:1E3F                 jnz     short notsingle
BIOSDATA:1E41                 inc     ax
BIOSDATA:1E42
BIOSDATA:1E42 settwodrive:                            ; CODE XREF: BIOSDATA:1E36↑j
BIOSDATA:1E42                 inc     cs:single
BIOSDATA:1E47
BIOSDATA:1E47 notsingle:                              ; CODE XREF: BIOSDATA:1E3F↑j
BIOSDATA:1E47                 inc     ax
BIOSDATA:1E48                 mov     cl, al
BIOSDATA:1E4A                 test    dl, 80h
BIOSDATA:1E4D                 jnz     short gothrd
BIOSDATA:1E4F                 xor     ax, ax
BIOSDATA:1E51                 mov     cs:Boot_Drv, al
BIOSDATA:1E55
BIOSDATA:1E55 gothrd:                                 ; CODE XREF: BIOSDATA:1E4D↑j
BIOSDATA:1E55                 xor     dx, dx
BIOSDATA:1E57                 cli
BIOSDATA:1E58                 mov     ss, dx
BIOSDATA:1E5A                 assume ss:nothing
BIOSDATA:1E5A                 mov     sp, 700h
BIOSDATA:1E5D                 sti
BIOSDATA:1E5E                 push    cx
BIOSDATA:1E5F                 mov     ah, ch          ; [MediaByte]
BIOSDATA:1E61                 push    ax
BIOSDATA:1E62                 mov     ah, 0C0h
BIOSDATA:1E64                 int     15h             ; SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
BIOSDATA:1E66                 jb      short no_rom_system_conf
BIOSDATA:1E68                 cmp     ah, 0
BIOSDATA:1E6B                 jnz     short no_rom_system_conf
BIOSDATA:1E6D                 mov     al, es:[bx+2]
BIOSDATA:1E71                 mov     cs:model_byte, al
BIOSDATA:1E75                 mov     al, es:[bx+3]
BIOSDATA:1E79                 mov     cs:secondary_model_byte, al
BIOSDATA:1E7D                 jmp     short turn_timer_on
BIOSDATA:1E7F ; ---------------------------------------------------------------------------
BIOSDATA:1E7F
BIOSDATA:1E7F no_rom_system_conf:                     ; CODE XREF: BIOSDATA:1E66↑j
BIOSDATA:1E7F                                         ; BIOSDATA:1E6B↑j
BIOSDATA:1E7F                 mov     si, 0FFFFh
BIOSDATA:1E82                 mov     es, si
BIOSDATA:1E84                 assume es:nothing
BIOSDATA:1E84                 mov     al, es:0Eh
BIOSDATA:1E88                 mov     cs:model_byte, al
BIOSDATA:1E8C
BIOSDATA:1E8C turn_timer_on:                          ; CODE XREF: BIOSDATA:1E7D↑j
BIOSDATA:1E8C                 mov     al, 20h
BIOSDATA:1E8E                 out     20h, al         ; Interrupt controller, 8259A.
BIOSDATA:1E90                 cmp     cs:model_byte, 0
BIOSDATA:1E96                 jnz     short not_olivetti_m24
BIOSDATA:1E98                 in      al, 66h
BIOSDATA:1E9A                 test    al, 20h
BIOSDATA:1E9C                 jz      short not_olivetti_m24
BIOSDATA:1E9E                 mov     al, 0Fh
BIOSDATA:1EA0                 out     50h, al
BIOSDATA:1EA2                 in      al, 50h
BIOSDATA:1EA4                 test    al, 1
BIOSDATA:1EA6                 jz      short skip_aux_port_init
BIOSDATA:1EA8
BIOSDATA:1EA8 not_olivetti_m24:                       ; CODE XREF: BIOSDATA:1E96↑j
BIOSDATA:1EA8                                         ; BIOSDATA:1E9C↑j
BIOSDATA:1EA8                 mov     al, 3
BIOSDATA:1EAA                 call    aux_init
BIOSDATA:1EAD                 mov     al, 2
BIOSDATA:1EAF                 call    aux_init
BIOSDATA:1EB2                 mov     al, 1
BIOSDATA:1EB4                 call    aux_init
BIOSDATA:1EB7                 xor     al, al
BIOSDATA:1EB9                 call    aux_init
BIOSDATA:1EBC
BIOSDATA:1EBC skip_aux_port_init:                     ; CODE XREF: BIOSDATA:1EA6↑j
BIOSDATA:1EBC                 mov     al, 2
BIOSDATA:1EBE                 call    print_init
BIOSDATA:1EC1                 mov     al, 1
BIOSDATA:1EC3                 call    print_init
BIOSDATA:1EC6                 xor     al, al
BIOSDATA:1EC8                 call    print_init
BIOSDATA:1ECB                 xor     dx, dx
BIOSDATA:1ECD                 mov     ds, dx
BIOSDATA:1ECF                 assume ds:nothing
BIOSDATA:1ECF                 mov     es, dx
BIOSDATA:1ED1                 assume es:nothing
BIOSDATA:1ED1                 mov     ax, word ptr ds:534h ; initspot
BIOSDATA:1ED1                                         ; IBMDOS.COM's first cluster - high word
BIOSDATA:1ED1                                         ; 520h (the 2nd entry of root dir) + 14h
BIOSDATA:1ED4                 mov     cs:firstcluster_hw, ax
BIOSDATA:1ED8                 xor     ax, ax          ; 0
BIOSDATA:1EDA                 mov     di, 534h        ; INITSPOT (0000h:0534h)
BIOSDATA:1EDA                                         ; IBM wants 4 zeros here
BIOSDATA:1EDD                 stosw
BIOSDATA:1EDE                 stosw
BIOSDATA:1EDF                 mov     ax, cs
BIOSDATA:1EE1                 mov     word ptr ds:6Ch, offset cbreak ; INT 1Bh vector
BIOSDATA:1EE7                 mov     word ptr ds:6Eh, ax
BIOSDATA:1EEA                 mov     word ptr ds:0A4h, offset outchr ; INT 29h vector
BIOSDATA:1EF0                 mov     word ptr ds:0A6h, ax
BIOSDATA:1EF3                 mov     di, 4
BIOSDATA:1EF6                 mov     bx, offset intret
BIOSDATA:1EF9                 xchg    ax, bx
BIOSDATA:1EFA                 stosw                   ; int 1
BIOSDATA:1EFB                 xchg    ax, bx
BIOSDATA:1EFC                 stosw
BIOSDATA:1EFD                 add     di, 4           ; skip int 2
BIOSDATA:1F00                 xchg    ax, bx
BIOSDATA:1F01                 stosw                   ; int 3
BIOSDATA:1F02                 xchg    ax, bx
BIOSDATA:1F03                 stosw
BIOSDATA:1F04                 xchg    ax, bx
BIOSDATA:1F05                 stosw                   ; int 4
BIOSDATA:1F06                 xchg    ax, bx
BIOSDATA:1F07                 stosw
BIOSDATA:1F08                 mov     word ptr ds:500h, dx ; set print screen & break = 0
BIOSDATA:1F0C                 mov     word ptr ds:504h, dx ; clean out last drive spec
BIOSDATA:1F10                 mov     al, byte ptr ds:52Ch ; SEC9+DISK_PARMS.DISK_MOTOR_STRT
BIOSDATA:1F10                                         ; motor start time in 1/8 seconds
BIOSDATA:1F13                 mov     cs:motorstartup, al
BIOSDATA:1F17                 cmp     cs:model_byte, 0FDh ; is this an old rom?
BIOSDATA:1F1D                 jb      short no_diddle ; no
BIOSDATA:1F1F                 mov     word ptr ds:52Bh, 20Fh ; [SEC9+DISK_PARMS.DISK_HEAD_STTL]
BIOSDATA:1F1F                                         ; head settle time in milliseconds
BIOSDATA:1F25                 mov     byte ptr ds:522h, 0DFh ; [SEC9+DISK_PARMS.DISK_SPECIFY_1]
BIOSDATA:1F25                                         ; set 1st specify byte on pc-1 pc-2 pc-xt hal0
BIOSDATA:1F2A
BIOSDATA:1F2A no_diddle:                              ; CODE XREF: BIOSDATA:1F1D↑j
BIOSDATA:1F2A                 int     12h             ; MEMORY SIZE -
BIOSDATA:1F2A                                         ; Return: AX = number of contiguous 1K blocks of memory
BIOSDATA:1F2C                 mov     cl, 6
BIOSDATA:1F2E                 shl     ax, cl
BIOSDATA:1F30                 pop     cx
BIOSDATA:1F31                 mov     cs:drvfat, cx
BIOSDATA:1F36                 push    ax
BIOSDATA:1F37                 push    ds
BIOSDATA:1F38                 push    bx
BIOSDATA:1F39                 xor     bx, bx
BIOSDATA:1F3B                 mov     ds, bx
BIOSDATA:1F3D                 mov     bx, word ptr ds:0BCh ; INT 2Fh handler ; [2Fh*4]
BIOSDATA:1F41                 mov     ds, word ptr ds:0BEh ; [2Fh*4+2]
BIOSDATA:1F45                 assume ds:nothing
BIOSDATA:1F45                 cmp     word ptr [bx+3], 5052h ; 'RP' ; 'RPL'
BIOSDATA:1F4A                 jnz     short SkipRPL
BIOSDATA:1F4C                 cmp     byte ptr [bx+5], 4Ch ; 'L'
BIOSDATA:1F50                 jnz     short SkipRPL
BIOSDATA:1F52                 mov     dx, ax          ; get TOM into dx
BIOSDATA:1F54                 mov     ax, 4A06h       ; (multMULT shl 8) + multMULTRPLTOM
BIOSDATA:1F57                 int     2Fh             ; Get new TOM from any RPL
BIOSDATA:1F59                 mov     ax, dx
BIOSDATA:1F5B
BIOSDATA:1F5B SkipRPL:                                ; CODE XREF: BIOSDATA:1F4A↑j
BIOSDATA:1F5B                                         ; BIOSDATA:1F50↑j
BIOSDATA:1F5B                 pop     bx
BIOSDATA:1F5C                 pop     ds
BIOSDATA:1F5D                 sub     ax, 40h
BIOSDATA:1F60                 mov     cs:fatloc, ax   ; location to read fat
BIOSDATA:1F64                 sub     ax, 40h
BIOSDATA:1F67                 mov     cs:init_bootseg, ax
BIOSDATA:1F6B                 pop     ax
BIOSDATA:1F6C                 mov     dx, 544h        ; SYSINITSEG ; SYSINIT segment
BIOSDATA:1F6F                 mov     ds, dx
BIOSDATA:1F71                 assume ds:nothing
BIOSDATA:1F71                 mov     word ptr ds:DEVICE_LIST, offset res_dev_list
BIOSDATA:1F77                 mov     word ptr ds:DEVICE_LIST+2, cs
BIOSDATA:1F7B                 mov     ds:MEMORY_SIZE, ax
BIOSDATA:1F7E                 inc     cl
BIOSDATA:1F80                 mov     ds:DEFAULT_DRIVE, cl
BIOSDATA:1F84                 mov     ds:CURRENTDOSLOCATION, 0AF8h ; DOSLOADSEG
BIOSDATA:1F84                                         ; DOSLOADSEG  = SYSINITSEG+((SYSINITSIZE+15)/16)
BIOSDATA:1F8A                 mov     ax, 544h        ; SYSINITSEG
BIOSDATA:1F8D                 mov     es, ax
BIOSDATA:1F8F                 assume es:nothing
BIOSDATA:1F8F                 xor     ax, ax
BIOSDATA:1F91                 mov     ds, ax
BIOSDATA:1F93                 assume ds:nothing
BIOSDATA:1F93                 mov     ax, word ptr ds:3Eh ; INT 0Fh vector, segment
BIOSDATA:1F96                 cmp     ax, es:MEMORY_SIZE
BIOSDATA:1F9B                 jbe     short resetintf
BIOSDATA:1F9D                 cmp     ax, 0F000h
BIOSDATA:1FA0                 jnz     short keepintf
BIOSDATA:1FA2
BIOSDATA:1FA2 resetintf:                              ; CODE XREF: BIOSDATA:1F9B↑j
BIOSDATA:1FA2                 mov     ds:3Ch, offset intret
BIOSDATA:1FA8                 mov     word ptr ds:3Eh, cs
BIOSDATA:1FAC
BIOSDATA:1FAC keepintf:                               ; CODE XREF: BIOSDATA:1FA0↑j
BIOSDATA:1FAC                 xor     cx, cx
BIOSDATA:1FAE                 mov     ds, cx
BIOSDATA:1FB0                 mov     cl, byte ptr ds:496h ; get keyboard flag
BIOSDATA:1FB4                 test    cl, 10h         ; extended keyboard ?
BIOSDATA:1FB7                 jz      short org_key   ; no
BIOSDATA:1FB9                 mov     cs:keyrd_func, 10h ; extended keyboard function
BIOSDATA:1FBF                 mov     cs:keysts_func, 11h ; extended keyboard function
BIOSDATA:1FC5
BIOSDATA:1FC5 org_key:                                ; CODE XREF: BIOSDATA:1FB7↑j
BIOSDATA:1FC5                 push    cs
BIOSDATA:1FC6                 pop     ds
BIOSDATA:1FC7                 assume ds:BIOSDATA
BIOSDATA:1FC7                 push    cs
BIOSDATA:1FC8                 pop     es
BIOSDATA:1FC9                 assume es:BIOSDATA
BIOSDATA:1FC9                 call    cmos_clock_read ; If cmos clock exists,
BIOSDATA:1FC9                                         ; then set the system time according to that.
BIOSDATA:1FC9                                         ; also, reset the cmos clock rate.
BIOSDATA:1FC9                                         ; ;
BIOSDATA:1FCC                 mov     word ptr hdrv_pat, offset harddrv ; BData_start
BIOSDATA:1FD2                 pop     ax              ; number of floppies and FAT ID
BIOSDATA:1FD3                 xor     ah, ah          ; chuck fat id byte
BIOSDATA:1FD5                 mov     drvmax, al      ; remember which drive is hard disk
BIOSDATA:1FD8                 mov     dsktnum, al     ; and set initial number of drives
BIOSDATA:1FDB                 shl     ax, 1
BIOSDATA:1FDD                 add     last_dskdrv_table, ax
BIOSDATA:1FE1                 push    ds
BIOSDATA:1FE2                 mov     ax, 0F000h
BIOSDATA:1FE5                 mov     ds, ax
BIOSDATA:1FE7                 assume ds:nothing
BIOSDATA:1FE7                 cmp     word ptr ds:0FFEAh, 'OC' ; 'COMPAQ'
BIOSDATA:1FED                 jnz     short skip_mode2
BIOSDATA:1FEF                 cmp     word ptr ds:0FFECh, 'PM'
BIOSDATA:1FF5                 jnz     short skip_mode2
BIOSDATA:1FF7                 cmp     word ptr ds:0FFEEh, 'QA'
BIOSDATA:1FFD                 jnz     short skip_mode2
BIOSDATA:1FFF                 mov     ax, 0E400h
BIOSDATA:2002                 int     15h
BIOSDATA:2004                 jb      short skip_mode2
BIOSDATA:2006                 or      bx, 0           ; or bx,40h ; enable mode 2
BIOSDATA:2006                                         ; (MSDOS 6.0)
BIOSDATA:2009                 mov     ax, 0E480h      ; set advanced system info
BIOSDATA:200C                 int     15h
BIOSDATA:200E
BIOSDATA:200E skip_mode2:                             ; CODE XREF: BIOSDATA:1FED↑j
BIOSDATA:200E                                         ; BIOSDATA:1FF5↑j ...
BIOSDATA:200E                 pop     ds
BIOSDATA:200F                 assume ds:nothing
BIOSDATA:200F                 mov     dl, 80h
BIOSDATA:2011                 mov     ah, 8
BIOSDATA:2013                 int     13h             ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
BIOSDATA:2013                                         ; DL = drive number
BIOSDATA:2013                                         ; Return: CF set on error, AH = status code, BL = drive type
BIOSDATA:2013                                         ; DL = number of consecutive drives
BIOSDATA:2013                                         ; DH = maximum value for head number, ES:DI -> drive parameter
BIOSDATA:2015                 jb      short enddrv
BIOSDATA:2017                 mov     ds:hnum, dl     ; save number of hard drives
BIOSDATA:201B
BIOSDATA:201B enddrv:                                 ; CODE XREF: BIOSDATA:2015↑j
BIOSDATA:201B                 xor     dl, dl          ; drive number = 0
BIOSDATA:201D                 push    cs
BIOSDATA:201E                 pop     ds
BIOSDATA:201F                 assume ds:BIOSDATA
BIOSDATA:201F                 mov     eot, 9
BIOSDATA:2024                 mov     di, offset start_bds
BIOSDATA:2027                 cmp     fakefloppydrv, 1
BIOSDATA:202C                 jnz     short loop_drive
BIOSDATA:202E                 mov     di, [di]        ; [di+BDS.link]
BIOSDATA:2030                 mov     di, [di]        ;  di <- second bds link
BIOSDATA:2032                 mov     word ptr [di], 0FFFFh ; -1 ; set end of link
BIOSDATA:2036                 jmp     dohard          ; allocate/initialise bds for harddrives
BIOSDATA:2039 ; ---------------------------------------------------------------------------
BIOSDATA:2039
BIOSDATA:2039 loop_drive:                             ; CODE XREF: BIOSDATA:202C↑j
BIOSDATA:2039                                         ; BIOSDATA:21E5↓j
BIOSDATA:2039                 cmp     dl, drvmax
BIOSDATA:203D                 jb      short got_more
BIOSDATA:203F                 jmp     done_drives
BIOSDATA:2042 ; ---------------------------------------------------------------------------
BIOSDATA:2042
BIOSDATA:2042 got_more:                               ; CODE XREF: BIOSDATA:203D↑j
BIOSDATA:2042                 xor     cx, cx          ; zero all flags
BIOSDATA:2044                 mov     di, [di]        ; [di+BDS.link] ; get next bds
BIOSDATA:2046                 cmp     di, 0FFFFh      ; end of link ?
BIOSDATA:2049                 jnz     short not_last_bds
BIOSDATA:204B                 mov     al, dl          ; drive number (0 based)
BIOSDATA:204D                 cbw
BIOSDATA:204E                 add     ax, ax
BIOSDATA:2050                 add     ax, offset dskdrvs
BIOSDATA:2053                 mov     last_dskdrv_table, ax
BIOSDATA:2056                 mov     di, end_of_bdss
BIOSDATA:205A                 call    xinstall_bds
BIOSDATA:205D                 dec     drvmax
BIOSDATA:2061
BIOSDATA:2061 not_last_bds:                           ; CODE XREF: BIOSDATA:2049↑j
BIOSDATA:2061                 mov     dh, 0           ; ff48tpi ; set form factor to 48 tpi
BIOSDATA:2063                 mov     num_cyln, 40    ; 40 tracks per side
BIOSDATA:2069                 push    ds
BIOSDATA:206A                 push    di
BIOSDATA:206B                 push    dx
BIOSDATA:206C                 push    cx
BIOSDATA:206D                 push    es
BIOSDATA:206E                 xor     bx, bx
BIOSDATA:2070                 xor     cx, cx
BIOSDATA:2072                 push    dx
BIOSDATA:2073                 mov     ah, 8
BIOSDATA:2075                 int     13h             ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
BIOSDATA:2075                                         ; DL = drive number
BIOSDATA:2075                                         ; Return: CF set on error, AH = status code, BL = drive type
BIOSDATA:2075                                         ; DL = number of consecutive drives
BIOSDATA:2075                                         ; DH = maximum value for head number, ES:DI -> drive parameter
BIOSDATA:2077                 pop     ax
BIOSDATA:2078                 jnb     short chk_drv_type
BIOSDATA:207A                 jmp     noparmsfromrom
BIOSDATA:207D ; ---------------------------------------------------------------------------
BIOSDATA:207D
BIOSDATA:207D chk_drv_type:                           ; CODE XREF: BIOSDATA:2078↑j
BIOSDATA:207D                 cmp     bl, 10h         ; ATAPI Removable Media Device
BIOSDATA:2080                 jnz     short not_atapi_removable
BIOSDATA:2082                 push    ds
BIOSDATA:2083                 push    si
BIOSDATA:2084                 mov     dl, al
BIOSDATA:2086                 sub     sp, 26
BIOSDATA:2089                 xor     ax, ax
BIOSDATA:208B                 push    ax
BIOSDATA:208C                 mov     ax, 30
BIOSDATA:208F                 push    ax
BIOSDATA:2090                 mov     si, sp          ; DS:SI = segment:offset pointer to Result Buffer
BIOSDATA:2092                 push    ss
BIOSDATA:2093                 pop     ds
BIOSDATA:2094                 assume ds:nothing
BIOSDATA:2094                 mov     ah, 48h
BIOSDATA:2096                 int     13h             ; DISK - IBM/MS Extension
BIOSDATA:2096                                         ; GET DRIVE PARAMETERS (DL - drive, DS:SI - buffer)
BIOSDATA:2098                 jb      short ext_gdp_err
BIOSDATA:209A                 mov     ax, [si+8]      ; physical number of heads
BIOSDATA:209D                 mov     ds:num_heads, ax
BIOSDATA:20A0                 mov     ax, [si+4]      ; physical number of cylinders
BIOSDATA:20A3                 mov     ds:num_cyln, ax
BIOSDATA:20A6                 mov     al, [si+0Ch]    ; physical number of sectors per track
BIOSDATA:20A9                 mov     ds:sec_trk, al
BIOSDATA:20AC                 cmp     al, ds:eot
BIOSDATA:20B0                 jbe     short _eotok
BIOSDATA:20B2                 mov     ds:eot, al
BIOSDATA:20B5
BIOSDATA:20B5 _eotok:                                 ; CODE XREF: BIOSDATA:20B0↑j
BIOSDATA:20B5                 xor     al, al
BIOSDATA:20B7                 test    byte ptr [si+2], 10h ; information flags
BIOSDATA:20B7                                         ; bit 4 = Device has change line support
BIOSDATA:20BB                 jz      short not_chgline_sup
BIOSDATA:20BD                 or      al, 2           ; change line support
BIOSDATA:20BF
BIOSDATA:20BF not_chgline_sup:                        ; CODE XREF: BIOSDATA:20BB↑j
BIOSDATA:20BF                 add     sp, 30
BIOSDATA:20C2                 pop     si
BIOSDATA:20C3                 pop     ds
BIOSDATA:20C4                 assume ds:nothing
BIOSDATA:20C4                 pop     es
BIOSDATA:20C5                 assume es:nothing
BIOSDATA:20C5                 pop     cx
BIOSDATA:20C6                 pop     dx
BIOSDATA:20C7                 pop     di
BIOSDATA:20C8                 pop     ds
BIOSDATA:20C9                 test    al, 2
BIOSDATA:20CB                 jz      short gotother_j
BIOSDATA:20CD                 or      cl, al
BIOSDATA:20CF                 mov     ds:fhave96, 1   ; Device has change line support
BIOSDATA:20D4
BIOSDATA:20D4 gotother_j:                             ; CODE XREF: BIOSDATA:20CB↑j
BIOSDATA:20D4                 jmp     short gotother
BIOSDATA:20D6 ; ---------------------------------------------------------------------------
BIOSDATA:20D6
BIOSDATA:20D6 ext_gdp_err:                            ; CODE XREF: BIOSDATA:2098↑j
BIOSDATA:20D6                 add     sp, 30
BIOSDATA:20D9                 pop     si
BIOSDATA:20DA                 pop     ds
BIOSDATA:20DB
BIOSDATA:20DB not_atapi_removable:                    ; CODE XREF: BIOSDATA:2080↑j
BIOSDATA:20DB                 cmp     ch, 0           ; if ch=0, then cl,dh=0 too.
BIOSDATA:20DE                 jnz     short pfr_ok    ;
BIOSDATA:20DE                                         ; rom gave wrong info.
BIOSDATA:20DE                                         ; let's default to 360k.
BIOSDATA:20E0                 mov     ch, 39
BIOSDATA:20E2                 mov     cl, 9
BIOSDATA:20E4                 mov     dh, 1
BIOSDATA:20E6
BIOSDATA:20E6 pfr_ok:                                 ; CODE XREF: BIOSDATA:20DE↑j
BIOSDATA:20E6                 xchg    dl, dh
BIOSDATA:20E8                 xor     dh, dh
BIOSDATA:20EA                 inc     dx              ; make number of heads 1-based
BIOSDATA:20EB                 mov     ds:num_heads, dx
BIOSDATA:20EF                 push    cx
BIOSDATA:20F0                 and     cl, 3Fh
BIOSDATA:20F3                 mov     ds:sec_trk, cl
BIOSDATA:20F7                 pop     cx
BIOSDATA:20F8                 xchg    cl, ch
BIOSDATA:20FA                 rol     ch, 1
BIOSDATA:20FC                 rol     ch, 1
BIOSDATA:20FE                 and     ch, 3
BIOSDATA:2101                 inc     cx              ; make number of cylinders 1-based
BIOSDATA:2102                 mov     ds:num_cyln, cx
BIOSDATA:2106                 mov     cl, ds:sec_trk
BIOSDATA:210A                 cmp     cl, ds:eot
BIOSDATA:210E                 jbe     short eotok
BIOSDATA:2110                 mov     ds:eot, cl
BIOSDATA:2114
BIOSDATA:2114 eotok:                                  ; CODE XREF: BIOSDATA:210E↑j
BIOSDATA:2114                 pop     es
BIOSDATA:2115                 pop     cx
BIOSDATA:2116                 pop     dx
BIOSDATA:2117                 pop     di
BIOSDATA:2118                 pop     ds
BIOSDATA:2119                 push    dx
BIOSDATA:211A                 push    cx
BIOSDATA:211B                 mov     ah, 15h
BIOSDATA:211D                 int     13h             ; DISK - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)
BIOSDATA:211D                                         ; DL = drive ID
BIOSDATA:211D                                         ; Return: CF set on error, AH = disk type (3 = hard drive)
BIOSDATA:211D                                         ; CX:DX = number of sectors on the media
BIOSDATA:211F                 pop     cx
BIOSDATA:2120                 pop     dx
BIOSDATA:2121                 jb      short changeline_done
BIOSDATA:2123                 cmp     ah, 2
BIOSDATA:2126                 jnz     short changeline_done
BIOSDATA:2128                 or      cl, 2           ; fchangeline ; change line support
BIOSDATA:212B                 mov     ds:fhave96, 1   ; remember that we have 96tpi disks
BIOSDATA:2130
BIOSDATA:2130 changeline_done:                        ; CODE XREF: BIOSDATA:2121↑j
BIOSDATA:2130                                         ; BIOSDATA:2126↑j
BIOSDATA:2130                 cmp     ds:num_cyln, 40
BIOSDATA:2135                 jnz     short try_80
BIOSDATA:2137                 cmp     ds:sec_trk, 9
BIOSDATA:213C                 jbe     short nextdrive
BIOSDATA:213E
BIOSDATA:213E gotother:                               ; CODE XREF: BIOSDATA:gotother_j↑j
BIOSDATA:213E                                         ; BIOSDATA:2147↓j ...
BIOSDATA:213E                 mov     dh, 7           ; ffOther ; we have a "strange" medium
BIOSDATA:2140                 jmp     short nextdrive
BIOSDATA:2142 ; ---------------------------------------------------------------------------
BIOSDATA:2142
BIOSDATA:2142 try_80:                                 ; CODE XREF: BIOSDATA:2135↑j
BIOSDATA:2142                 cmp     ds:num_cyln, 80
BIOSDATA:2147                 jnz     short gotother
BIOSDATA:2149                 mov     dh, 9           ; ff288 ; assume 2.88 MB drive
BIOSDATA:214B                 cmp     ds:sec_trk, 36  ; is it ?
BIOSDATA:2150                 jz      short nextdrive ; yes, go update
BIOSDATA:2152                 cmp     ds:sec_trk, 15
BIOSDATA:2157                 jz      short got96
BIOSDATA:2159                 cmp     ds:sec_trk, 9
BIOSDATA:215E                 jnz     short gotother
BIOSDATA:2160                 mov     dh, 2           ; ffSmall
BIOSDATA:2162                 jmp     short nextdrive
BIOSDATA:2164 ; ---------------------------------------------------------------------------
BIOSDATA:2164
BIOSDATA:2164 got96:                                  ; CODE XREF: BIOSDATA:2157↑j
BIOSDATA:2164                 mov     dh, 1           ; ff96tpi
BIOSDATA:2166                 jmp     short nextdrive
BIOSDATA:2168 ; ---------------------------------------------------------------------------
BIOSDATA:2168
BIOSDATA:2168 noparmsfromrom:                         ; CODE XREF: BIOSDATA:207A↑j
BIOSDATA:2168                 pop     es
BIOSDATA:2169                 pop     cx
BIOSDATA:216A                 pop     dx
BIOSDATA:216B                 pop     di
BIOSDATA:216C                 pop     ds
BIOSDATA:216D                 push    dx
BIOSDATA:216E                 push    cx
BIOSDATA:216F                 mov     ah, 15h
BIOSDATA:2171                 int     13h             ; DISK - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)
BIOSDATA:2171                                         ; DL = drive ID
BIOSDATA:2171                                         ; Return: CF set on error, AH = disk type (3 = hard drive)
BIOSDATA:2171                                         ; CX:DX = number of sectors on the media
BIOSDATA:2173                 pop     cx
BIOSDATA:2174                 pop     dx
BIOSDATA:2175                 jb      short nextdrive
BIOSDATA:2177                 cmp     ah, 2           ; is there changeline?
BIOSDATA:217A                 jnz     short nextdrive
BIOSDATA:217C                 or      cl, 2           ; yes, this drive has change line supoort
BIOSDATA:217F                 mov     ds:fhave96, 1   ; remember that we have 96tpi drives
BIOSDATA:217F                                         ; (change line support)
BIOSDATA:2184                 mov     ds:num_cyln, 80
BIOSDATA:218A                 mov     dh, 1           ; ff96tpi
BIOSDATA:218C                 mov     al, 15
BIOSDATA:218E                 cmp     al, ds:eot
BIOSDATA:2192                 jbe     short nextdrive
BIOSDATA:2194                 mov     ds:eot, al
BIOSDATA:2197
BIOSDATA:2197 nextdrive:                              ; CODE XREF: BIOSDATA:213C↑j
BIOSDATA:2197                                         ; BIOSDATA:2140↑j ...
BIOSDATA:2197                 or      cl, 20h         ; fi_own_physical
BIOSDATA:2197                                         ; set this true for all drives
BIOSDATA:219A                 mov     bh, dl          ; save int13 drive number
BIOSDATA:219C                 cmp     ds:single, 2
BIOSDATA:21A1                 jb      short not_special
BIOSDATA:21A3                 dec     bh              ; int13 drive number same for logical drive
BIOSDATA:21A5                 xor     cl, 20h         ; fi_own_physical
BIOSDATA:21A5                                         ; reset ownership flag for logical drive
BIOSDATA:21A8
BIOSDATA:21A8 not_special:                            ; CODE XREF: BIOSDATA:21A1↑j
BIOSDATA:21A8                 mov     ax, ds:num_heads
BIOSDATA:21AB                 mov     [di+52h], ax    ; [di+BDS.rheads]
BIOSDATA:21AE                 xor     ax, ax
BIOSDATA:21B0                 mov     al, ds:sec_trk
BIOSDATA:21B3                 mov     [di+50h], ax    ; [di+BDS.rsecpertrack]
BIOSDATA:21B6                 mov     [di+3Fh], cx    ; [di+BDS.flags]
BIOSDATA:21B9                 mov     [di+3Eh], dh    ; [di+BDS.formfactor]
BIOSDATA:21BC                 mov     [di+5], dl      ; [di+BDS.drivelet]
BIOSDATA:21BF                 mov     [di+4], bh      ; [di+BDS.drivenum]
BIOSDATA:21C2                 push    bx
BIOSDATA:21C3                 mov     bx, ds:num_cyln
BIOSDATA:21C7                 mov     [di+41h], bx    ; [di+BDS.cylinders]
BIOSDATA:21CA                 pop     bx
BIOSDATA:21CB                 cmp     ds:single, 1    ; Special case for single drive system
BIOSDATA:21D0                 jnz     short no_single
BIOSDATA:21D2                 mov     ds:single, 2    ; Don't forget we have single drive system
BIOSDATA:21D7                 or      cx, 10h         ; fi_am_mult
BIOSDATA:21D7                                         ; set that this is one of several drives
BIOSDATA:21DA                 or      [di+3Fh], cx    ; [di+BDS.flags] ; save flags
BIOSDATA:21DD                 mov     di, [di]        ; [di+BDS.link] ; move to next BDS in list
BIOSDATA:21DF                 inc     dl              ; add a number
BIOSDATA:21E1                 jmp     short nextdrive ; Use same info for BDS as previous
BIOSDATA:21E3 ; ---------------------------------------------------------------------------
BIOSDATA:21E3
BIOSDATA:21E3 no_single:                              ; CODE XREF: BIOSDATA:21D0↑j
BIOSDATA:21E3                 inc     dl
BIOSDATA:21E5                 jmp     loop_drive
BIOSDATA:21E8 ; ---------------------------------------------------------------------------
BIOSDATA:21E8
BIOSDATA:21E8 done_drives:                            ; CODE XREF: BIOSDATA:203F↑j
BIOSDATA:21E8                 mov     word ptr [di], 0FFFFh ; -1
BIOSDATA:21EC
BIOSDATA:21EC dohard:                                 ; CODE XREF: BIOSDATA:2036↑j
BIOSDATA:21EC                 mov     dh, ds:hnum
BIOSDATA:21F0                 or      dh, dh
BIOSDATA:21F2                 jz      short static_configure
BIOSDATA:21F4                 mov     dl, 80h
BIOSDATA:21F6
BIOSDATA:21F6 dohard1:                                ; CODE XREF: BIOSDATA:2213↓j
BIOSDATA:21F6                 push    dx
BIOSDATA:21F7                 mov     di, ds:end_of_bdss
BIOSDATA:21FB                 mov     bl, ds:drvmax
BIOSDATA:21FF                 mov     bh, 0
BIOSDATA:2201                 call    sethard
BIOSDATA:2204                 jb      short hardfile_err
BIOSDATA:2206                 call    dmax_check
BIOSDATA:2209                 jnb     short hardfile_err
BIOSDATA:220B                 call    xinstall_bds
BIOSDATA:220E
BIOSDATA:220E hardfile_err:                           ; CODE XREF: BIOSDATA:2204↑j
BIOSDATA:220E                                         ; BIOSDATA:2209↑j
BIOSDATA:220E                 pop     dx
BIOSDATA:220F                 inc     dl
BIOSDATA:2211                 dec     dh
BIOSDATA:2213                 jnz     short dohard1
BIOSDATA:2215                 call    domini
BIOSDATA:2218                 mov     dh, ds:hnum
BIOSDATA:221C                 mov     dl, 80h
BIOSDATA:221E
BIOSDATA:221E dohardx1:                               ; CODE XREF: BIOSDATA:2243↓j
BIOSDATA:221E                 mov     bh, 1
BIOSDATA:2220
BIOSDATA:2220 dohardx2:                               ; CODE XREF: BIOSDATA:223B↓j
BIOSDATA:2220                 push    dx
BIOSDATA:2221                 push    bx
BIOSDATA:2222                 mov     di, ds:end_of_bdss
BIOSDATA:2226                 mov     bl, ds:drvmax
BIOSDATA:222A                 call    sethard
BIOSDATA:222D                 jb      short dohardx4
BIOSDATA:222F                 call    dmax_check
BIOSDATA:2232                 jnb     short dohardx4
BIOSDATA:2234                 call    xinstall_bds
BIOSDATA:2237                 pop     bx
BIOSDATA:2238                 pop     dx
BIOSDATA:2239                 inc     bh
BIOSDATA:223B                 jmp     short dohardx2
BIOSDATA:223D ; ---------------------------------------------------------------------------
BIOSDATA:223D
BIOSDATA:223D dohardx4:                               ; CODE XREF: BIOSDATA:222D↑j
BIOSDATA:223D                                         ; BIOSDATA:2232↑j
BIOSDATA:223D                 pop     bx
BIOSDATA:223E                 pop     dx
BIOSDATA:223F                 inc     dl
BIOSDATA:2241                 dec     dh
BIOSDATA:2243                 jnz     short dohardx1
BIOSDATA:2245                 cmp     ds:dsktnum, 2
BIOSDATA:224A                 jbe     short static_configure
BIOSDATA:224C                 call    remap
BIOSDATA:224F
BIOSDATA:224F static_configure:                       ; CODE XREF: BIOSDATA:21F2↑j
BIOSDATA:224F                                         ; BIOSDATA:224A↑j
BIOSDATA:224F                 mov     di, ds:end_of_bdss
BIOSDATA:2253                 cmp     di, offset bdss
BIOSDATA:2257                 jnz     short dynamic_configure
BIOSDATA:2259                 mov     di, offset harddrv ; offset end96tpi
BIOSDATA:225C                 cmp     ds:fhave96, 0
BIOSDATA:2261                 jnz     short dynamic_configure
BIOSDATA:2263                 mov     di, offset endfloppy
BIOSDATA:2266
BIOSDATA:2266 dynamic_configure:                      ; CODE XREF: BIOSDATA:2257↑j
BIOSDATA:2266                                         ; BIOSDATA:2261↑j
BIOSDATA:2266                 push    cs
BIOSDATA:2267                 pop     es
BIOSDATA:2268                 assume es:BIOSDATA
BIOSDATA:2268                 cld
BIOSDATA:2269                 cmp     ds:model_byte, 0FCh ; AT?
BIOSDATA:226E                 jnz     short checkcompaqbug ; no
BIOSDATA:2270                 cmp     ds:hnum, 0      ; No hard file?
BIOSDATA:2275                 jz      short checkcompaqbug
BIOSDATA:2277                 xchg    ax, di          ; save allocation pointer in ax
BIOSDATA:2278                 mov     si, 0F000h
BIOSDATA:227B                 mov     es, si
BIOSDATA:227D                 assume es:nothing
BIOSDATA:227D                 mov     si, offset bios_date ; "01/10/84"
BIOSDATA:2280                 mov     di, 0FFF5h      ; ROM BIOS string is at F000:FFF5
BIOSDATA:2283                 mov     cx, 9           ; Only patch ROM for bios 01/10/84
BIOSDATA:2286                 repe cmpsb              ; check for date + zero on end
BIOSDATA:2288                 xchg    ax, di          ; restore allocation pointer
BIOSDATA:2289                 jnz     short checkcompaqbug
BIOSDATA:228B                 mov     cx, offset endatrom
BIOSDATA:228E                 mov     si, offset ibm_disk_io
BIOSDATA:2291                 jmp     short install_int13_patch
BIOSDATA:2293 ; ---------------------------------------------------------------------------
BIOSDATA:2293
BIOSDATA:2293 checkcompaqbug:                         ; CODE XREF: BIOSDATA:226E↑j
BIOSDATA:2293                                         ; BIOSDATA:2275↑j ...
BIOSDATA:2293                 mov     ax, 0F000h
BIOSDATA:2296                 mov     es, ax
BIOSDATA:2298                 cmp     word ptr es:0FFEAh, 4F43h ; 'CO'
BIOSDATA:229F                 jnz     short checkcmosclock
BIOSDATA:22A1                 cmp     word ptr es:0FFECh, 504Dh ; 'MP'
BIOSDATA:22A8                 jnz     short checkcmosclock
BIOSDATA:22AA                 cmp     word ptr es:0FFEEh, 5141h ; 'AQ'
BIOSDATA:22B1                 jnz     short checkcmosclock
BIOSDATA:22B3                 mov     ax, es:0FFFBh
BIOSDATA:22B7                 xchg    ah, al
BIOSDATA:22B9                 cmp     ax, 3836h       ; '68' (NASM syntax) (('86' in MASM syntax))
BIOSDATA:22BC                 ja      short checkcmosclock
BIOSDATA:22BE                 jz      short chkcompaqbug1
BIOSDATA:22C0                 cmp     ax, 3739h       ; '97'
BIOSDATA:22C3                 jbe     short checkcmosclock
BIOSDATA:22C5                 stc
BIOSDATA:22C6
BIOSDATA:22C6 chkcompaqbug1:                          ; CODE XREF: BIOSDATA:22BE↑j
BIOSDATA:22C6                 jb      short do_compaq_patch
BIOSDATA:22C8                 mov     ax, es:0FFF5h
BIOSDATA:22CC                 xchg    ah, al
BIOSDATA:22CE                 cmp     ax, 3038h       ; '80'
BIOSDATA:22D1                 ja      short checkcmosclock
BIOSDATA:22D3                 jb      short do_compaq_patch
BIOSDATA:22D5                 mov     ax, es:0FFF8h
BIOSDATA:22D9                 xchg    ah, al
BIOSDATA:22DB                 cmp     ax, 3034h       ; '40'
BIOSDATA:22DE                 jnb     short checkcmosclock
BIOSDATA:22E0
BIOSDATA:22E0 do_compaq_patch:                        ; CODE XREF: BIOSDATA:chkcompaqbug1↑j
BIOSDATA:22E0                                         ; BIOSDATA:22D3↑j
BIOSDATA:22E0                 mov     cx, offset end_compaq_i13hook
BIOSDATA:22E3                 mov     si, offset endatrom
BIOSDATA:22E6
BIOSDATA:22E6 install_int13_patch:                    ; CODE XREF: BIOSDATA:2291↑j
BIOSDATA:22E6                 push    cs
BIOSDATA:22E7                 pop     es
BIOSDATA:22E8                 assume es:BIOSDATA
BIOSDATA:22E8                 mov     word ptr ds:Orig13, di
BIOSDATA:22EC                 mov     word ptr ds:Orig13+2, cs
BIOSDATA:22F0                 sub     cx, si
BIOSDATA:22F2                 rep movsb
BIOSDATA:22F4
BIOSDATA:22F4 checkcmosclock:                         ; CODE XREF: BIOSDATA:229F↑j
BIOSDATA:22F4                                         ; BIOSDATA:22A8↑j ...
BIOSDATA:22F4                 push    cs
BIOSDATA:22F5                 pop     es
BIOSDATA:22F6
BIOSDATA:22F6 checkk09:
BIOSDATA:22F6                 push    di
BIOSDATA:22F7                 mov     ax, 4100h       ; wait for any external event (al=0)
BIOSDATA:22FA                 mov     bl, 4           ; wait for 4 clock ticks
BIOSDATA:22FC                 stc
BIOSDATA:22FD                 int     15h             ; SYSTEM - WAIT ON EXTERNAL EVENT (CONVERTIBLE)
BIOSDATA:22FD                                         ; AL = condition type, BH = condition compare or mask value
BIOSDATA:22FD                                         ; BL = timeout value times 55 milliseconds, 00h means no timeout
BIOSDATA:22FD                                         ; DX = I/O port address if AL bit 4 set
BIOSDATA:22FF                 pop     di
BIOSDATA:2300                 jb      short configdone
BIOSDATA:2302                 mov     ds:fhavek09, 1  ; remember we have a k09 type
BIOSDATA:2307                 push    ds
BIOSDATA:2308                 xor     ax, ax
BIOSDATA:230A                 mov     ds, ax
BIOSDATA:230C                 assume ds:nothing
BIOSDATA:230C                 mov     word ptr ds:1B0h, di ; [6Ch*4]
BIOSDATA:230C                                         ; new int 6ch handler
BIOSDATA:2310                 mov     word ptr ds:1B2h, cs
BIOSDATA:2314                 pop     ds
BIOSDATA:2315                 assume ds:nothing
BIOSDATA:2315                 mov     si, offset int_6Ch
BIOSDATA:2318                 mov     cx, 461         ; endk09-int_6Ch (size of k09 routine)
BIOSDATA:231B                 rep movsb
BIOSDATA:231D
BIOSDATA:231D configdone:                             ; CODE XREF: BIOSDATA:2300↑j
BIOSDATA:231D                 push    cs
BIOSDATA:231E                 pop     ds              ; di is final ending address of msbio.
BIOSDATA:231F                 assume ds:BIOSDATA
BIOSDATA:231F                 add     di, 15          ; round (up) to paragraph
BIOSDATA:2322                 shr     di, 1
BIOSDATA:2324                 shr     di, 1
BIOSDATA:2326                 shr     di, 1
BIOSDATA:2328                 shr     di, 1
BIOSDATA:232A                 add     di, 70h
BIOSDATA:232E                 mov     DosDataSg, di   ; where the dos data segment will be
BIOSDATA:2332                 mov     ax, drvfat
BIOSDATA:2335                 mov     bp, offset SetDrive
BIOSDATA:2338                 push    cs
BIOSDATA:2339                 call    call_bios_code
BIOSDATA:233C                 mov     bp, offset GetBp
BIOSDATA:233F                 push    cs
BIOSDATA:2340                 call    call_bios_code
BIOSDATA:2343                 push    es
BIOSDATA:2344                 pop     ds
BIOSDATA:2345                 xor     di, di
BIOSDATA:2347                 mov     al, es:[di]
BIOSDATA:234A                 mov     byte ptr es:drvfat+1, al
BIOSDATA:234E                 mov     ax, es:drvfat
BIOSDATA:2352                 push    es
BIOSDATA:2353                 push    ds
BIOSDATA:2354                 pop     es
BIOSDATA:2355                 push    cs
BIOSDATA:2356                 pop     ds
BIOSDATA:2357                 mov     bp, offset SetDrive
BIOSDATA:235A                 push    cs
BIOSDATA:235B                 call    call_bios_code
BIOSDATA:235E                 push    es
BIOSDATA:235F                 pop     ds
BIOSDATA:2360                 pop     es
BIOSDATA:2361                 assume es:nothing
BIOSDATA:2361                 mov     bx, [di+6]
BIOSDATA:2364                 mov     cs:md_sectorsize, bx
BIOSDATA:2369                 mov     bl, [di+3Bh]
BIOSDATA:236C                 mov     es:fbigfat, bl
BIOSDATA:2371                 mov     cl, [di+8]
BIOSDATA:2374                 mov     ax, [di+17h]
BIOSDATA:2377                 sub     es:First_Data_Sector, ax
BIOSDATA:237C                 mov     ax, [di+19h]
BIOSDATA:237F                 sbb     es:First_Data_Sector+2, ax
BIOSDATA:2384                 xor     ch, ch
BIOSDATA:2386                 push    di
BIOSDATA:2387                 push    ds
BIOSDATA:2388                 xor     di, di
BIOSDATA:238A                 mov     ds, di
BIOSDATA:238C                 assume ds:nothing
BIOSDATA:238C                 mov     bx, word ptr ds:53Ah ; clus=*53Ah
BIOSDATA:238C                                         ; (First cluster field of 2nd dir entry
BIOSDATA:238C                                         ; of root directory in the buffer at 500h)
BIOSDATA:2390                 mov     si, cs:firstcluster_hw
BIOSDATA:2395                 pop     ds
BIOSDATA:2396                 assume ds:nothing
BIOSDATA:2396                 pop     di
BIOSDATA:2397                 mov     al, es:fbigfat
BIOSDATA:239B                 push    ax              ; (*) save fbigfat flags
BIOSDATA:239C                 mov     al, byte ptr es:drvfat
BIOSDATA:23A0                 or      al, es:Boot_Drv
BIOSDATA:23A5                 jnz     short boot_drv_fixed ; hard disk
BIOSDATA:23A7
BIOSDATA:23A7 boot_drv_removable:                     ; calculate cluster count and set fbig or fbigbig flag
BIOSDATA:23A7                 push    bx              ; for removable drives
BIOSDATA:23A8                 push    cx
BIOSDATA:23A9                 push    dx
BIOSDATA:23AA                 mov     ax, [di+0Eh]    ; [di+BDS.totalsecs16]
BIOSDATA:23AD                 xor     dx, dx
BIOSDATA:23AF                 or      ax, ax
BIOSDATA:23B1                 jnz     short prep_totalsecs_ok
BIOSDATA:23B3                 mov     ax, [di+1Bh]    ; [di+BDS.totalsecs32]
BIOSDATA:23B6                 mov     dx, [di+1Dh]
BIOSDATA:23B9
BIOSDATA:23B9 prep_totalsecs_ok:                      ; CODE XREF: BIOSDATA:23B1↑j
BIOSDATA:23B9                 sub     ax, [di+9]      ; [di+BDS.resectors]
BIOSDATA:23BC                 sbb     dx, 0
BIOSDATA:23BF                 push    ax
BIOSDATA:23C0                 push    dx
BIOSDATA:23C1                 mov     bx, [di+11h]    ; [di+BDS.fatsecs16]
BIOSDATA:23C4                 xor     ax, ax
BIOSDATA:23C6                 or      bx, bx
BIOSDATA:23C8                 jnz     short prep_fatsecs_ok
BIOSDATA:23CA                 mov     bx, [di+1Fh]    ; [di+BDS.fatsecs32]
BIOSDATA:23CD                 mov     ax, [di+21h]
BIOSDATA:23D0
BIOSDATA:23D0 prep_fatsecs_ok:                        ; CODE XREF: BIOSDATA:23C8↑j
BIOSDATA:23D0                 mov     cl, [di+0Bh]    ; ax:bx = 32 bit count of FAT sectors
BIOSDATA:23D0                                         ; [di+BDS.fats]
BIOSDATA:23D3                 xor     ch, ch
BIOSDATA:23D5                 mul     cx
BIOSDATA:23D7                 xchg    ax, cx
BIOSDATA:23D8                 mul     bx
BIOSDATA:23DA                 add     cx, dx
BIOSDATA:23DC                 mov     bx, ax          ; cx:bx = total (2*) fat sectors
BIOSDATA:23DE                 pop     dx
BIOSDATA:23DF                 pop     ax              ; dx:ax = totals sectors - reserved sectors
BIOSDATA:23E0                 sub     ax, bx
BIOSDATA:23E2                 sbb     dx, cx          ; dx:ax = data sectors (includes root dir sectors)
BIOSDATA:23E4                 mov     bx, [di+0Ch]    ; [di+BDS.direntries]
BIOSDATA:23E7                 add     bx, 15          ; 16 directory entries per sector
BIOSDATA:23E7                                         ; (round up sector count by adding 15)
BIOSDATA:23EA                 mov     cl, 4           ; (rounded) dir entries / 16
BIOSDATA:23EC                 shr     bx, cl
BIOSDATA:23EE                 xor     cx, cx
BIOSDATA:23F0                 sub     ax, bx
BIOSDATA:23F2                 sbb     dx, cx          ; dx:ax = data sectors (except root directory sectors)
BIOSDATA:23F2                                         ; (will be used for cluster count calculation)
BIOSDATA:23F4                 mov     cl, [di+8]      ; [di+BDS.secperclus]
BIOSDATA:23F7                 push    ax              ; 32 bit division (data sectors / sector per cluster)
BIOSDATA:23F8                 mov     ax, dx
BIOSDATA:23FA                 xor     dx, dx
BIOSDATA:23FC                 div     cx
BIOSDATA:23FE                 mov     bx, ax
BIOSDATA:2400                 pop     ax
BIOSDATA:2401                 div     cx
BIOSDATA:2403                 or      bx, bx          ; 32 bit cluster count if bx > 0
BIOSDATA:2405                 jnz     short set_fbigbig_flag ; too big cluster number
BIOSDATA:2407                 cmp     ax, 0FFF6h
BIOSDATA:240A                 jb      short set_fbig_flag
BIOSDATA:240C
BIOSDATA:240C set_fbigbig_flag:                       ; CODE XREF: BIOSDATA:2405↑j
BIOSDATA:240C                 or      es:fbigfat, 20h ; FAT32  ; fbigbig
BIOSDATA:2412                 jmp     short set_fbig_flag_ok
BIOSDATA:2414 ; ---------------------------------------------------------------------------
BIOSDATA:2414
BIOSDATA:2414 set_fbig_flag:                          ; CODE XREF: BIOSDATA:240A↑j
BIOSDATA:2414                 cmp     ax, 0FF6h       ; 4096-10
BIOSDATA:2414                                         ; is this 16-bit fat?
BIOSDATA:2417                 jb      short set_fbig_flag_ok ; no, small fat
BIOSDATA:2419                 or      es:fbigfat, 40h ; FAT16 ; fbig
BIOSDATA:241F
BIOSDATA:241F set_fbig_flag_ok:                       ; CODE XREF: BIOSDATA:2412↑j
BIOSDATA:241F                                         ; BIOSDATA:2417↑j
BIOSDATA:241F                 pop     dx
BIOSDATA:2420                 pop     cx
BIOSDATA:2421                 pop     bx
BIOSDATA:2422
BIOSDATA:2422 boot_drv_fixed:                         ; CODE XREF: BIOSDATA:23A5↑j
BIOSDATA:2422                 xor     di, di
BIOSDATA:2424
BIOSDATA:2424 loadit:                                 ; CODE XREF: BIOSDATA:iseofx↓j
BIOSDATA:2424                 mov     ax, 544h        ; Load DOS kernel (IBMDOS.COM)
BIOSDATA:2424                                         ; SYSINIT segment = 544h
BIOSDATA:2427                 mov     es, ax
BIOSDATA:2429                 assume es:nothing
BIOSDATA:2429                 mov     es, es:CURRENTDOSLOCATION
BIOSDATA:242E                 assume es:nothing
BIOSDATA:242E                 call    getclus
BIOSDATA:2431                 test    cs:fbigfat, 20h ; fbigbig ; FAT32 fs flag
BIOSDATA:2437                 jz      short iseof
BIOSDATA:2439
BIOSDATA:2439 eofbigbig:                              ; si:bx = 32 bit cluster number
BIOSDATA:2439                 cmp     si, 0FFFh
BIOSDATA:243D                 jnz     short iseofx
BIOSDATA:243F                 cmp     bx, 0FFF7h
BIOSDATA:2442                 jmp     short iseofx
BIOSDATA:2444 ; ---------------------------------------------------------------------------
BIOSDATA:2444
BIOSDATA:2444 iseof:                                  ; CODE XREF: BIOSDATA:2437↑j
BIOSDATA:2444                 test    cs:fbigfat, 40h ; fbig ; FAT16 fs flag
BIOSDATA:244A                 jnz     short eofbig
BIOSDATA:244C                 cmp     bx, 0FF7h
BIOSDATA:2450                 jmp     short iseofx
BIOSDATA:2452 ; ---------------------------------------------------------------------------
BIOSDATA:2452
BIOSDATA:2452 eofbig:                                 ; CODE XREF: BIOSDATA:244A↑j
BIOSDATA:2452                 cmp     bx, 0FFF7h
BIOSDATA:2455
BIOSDATA:2455 iseofx:                                 ; CODE XREF: BIOSDATA:243D↑j
BIOSDATA:2455                                         ; BIOSDATA:2442↑j ...
BIOSDATA:2455                 jb      short loadit
BIOSDATA:2457                 pop     ax              ; (*) restore fbigfat flags
BIOSDATA:2457                                         ; (after loading DOS kernel)
BIOSDATA:2458                 mov     cs:fbigfat, al
BIOSDATA:245C                 call    setdrvparms
BIOSDATA:245F                 jmp     far ptr 544h:269h ; SYSNIT:_SYSINIT
BIOSDATA:2464
BIOSDATA:2464 ; =============== S U B R O U T I N E =======================================
BIOSDATA:2464
BIOSDATA:2464
BIOSDATA:2464 remap           proc near               ; CODE XREF: BIOSDATA:224C↑p
BIOSDATA:2464                 mov     di, cs:start_bds ; get first bds
BIOSDATA:2469
BIOSDATA:2469 drive_loop:                             ; CODE XREF: remap+10↓j
BIOSDATA:2469                 cmp     byte ptr [di+4], 80h ; [di+BDS.drivenum] ; first hard disk??
BIOSDATA:246D                 jz      short fdrv_found ; yes, continue
BIOSDATA:246F                 mov     di, [di]        ; [di+BDS.link] ; get next bds, assume segment
BIOSDATA:2471                 cmp     di, 0FFFFh      ; last bds?
BIOSDATA:2474                 jnz     short drive_loop
BIOSDATA:2476                 jmp     short rmap_exit ; yes, no hard drive on system
BIOSDATA:2478 ; ---------------------------------------------------------------------------
BIOSDATA:2478
BIOSDATA:2478 fdrv_found:                             ; CODE XREF: remap+9↑j
BIOSDATA:2478                 mov     al, 2           ; start with logical drv num=2
BIOSDATA:247A
BIOSDATA:247A fdrv_loop:                              ; CODE XREF: remap+20↓j
BIOSDATA:247A                 mov     [di+5], al      ; [di+BDS.drivelet]
BIOSDATA:247D                 mov     di, [di]        ; [di+BDS.link] ; ds:di--> next bds
BIOSDATA:247F                 inc     al              ; set num for next drive
BIOSDATA:2481                 cmp     di, 0FFFFh      ; last hard drive ?
BIOSDATA:2484                 jnz     short fdrv_loop ; no - assign more disk drives
BIOSDATA:2486                 mov     di, cs:start_bds
BIOSDATA:248B                 mov     di, [di]        ; [di+BDS.link] ; ds:di-->bds2
BIOSDATA:248D                 mov     ah, cs:dsktnum  ; get number of floppies to remap
BIOSDATA:2492                 sub     ah, 2           ; adjust for a: & b:
BIOSDATA:2495
BIOSDATA:2495 remap_loop1:                            ; CODE XREF: remap+3A↓j
BIOSDATA:2495                 mov     di, [di]        ; [di+BDS.link] ; set new num to next floppy
BIOSDATA:2497                 mov     [di+5], al      ; [di+BDS.drivelet]
BIOSDATA:249A                 inc     al              ; new number for next floppy
BIOSDATA:249C                 dec     ah              ; count down extra floppies
BIOSDATA:249E                 jnz     short remap_loop1
BIOSDATA:24A0                 mov     al, byte ptr cs:drvfat ; boot drive
BIOSDATA:24A4                 cmp     al, 2           ; is it a: or b: ?
BIOSDATA:24A6                 jb      short rmap_exit
BIOSDATA:24A8                 sub     al, cs:dsktnum  ; is it one of the other floppies?
BIOSDATA:24AD                 jb      short remap_boot_flop ; brif so
BIOSDATA:24AF                 add     al, 2           ; bootdrv -= (dsktnum-2)
BIOSDATA:24B1                 jmp     short remap_change_boot_drv
BIOSDATA:24B3 ; ---------------------------------------------------------------------------
BIOSDATA:24B3
BIOSDATA:24B3 remap_boot_flop:                        ; CODE XREF: remap+49↑j
BIOSDATA:24B3                 add     al, cs:drvmax   ; bootdrv += (drvmax-dsktnum)
BIOSDATA:24B8
BIOSDATA:24B8 remap_change_boot_drv:                  ; CODE XREF: remap+4D↑j
BIOSDATA:24B8                 mov     byte ptr cs:drvfat, al
BIOSDATA:24BC                 inc     al
BIOSDATA:24BE                 push    ds
BIOSDATA:24BF                 mov     di, 544h        ; SYSINIT segment
BIOSDATA:24C2                 mov     ds, di
BIOSDATA:24C4                 assume ds:nothing
BIOSDATA:24C4                 mov     ds:DEFAULT_DRIVE, al
BIOSDATA:24C7                 pop     ds
BIOSDATA:24C8                 assume ds:nothing
BIOSDATA:24C8
BIOSDATA:24C8 rmap_exit:                              ; CODE XREF: remap+12↑j
BIOSDATA:24C8                                         ; remap+42↑j
BIOSDATA:24C8                 retn
BIOSDATA:24C8 remap           endp
BIOSDATA:24C8
BIOSDATA:24C9
BIOSDATA:24C9 ; =============== S U B R O U T I N E =======================================
BIOSDATA:24C9
BIOSDATA:24C9
BIOSDATA:24C9 getboot         proc near               ; CODE XREF: sethard+30↓p
BIOSDATA:24C9                                         ; domini+3B↓p
BIOSDATA:24C9                 mov     ax, cs:init_bootseg
BIOSDATA:24CD                 mov     es, ax
BIOSDATA:24CF                 mov     bx, 200h        ; bootbias
BIOSDATA:24D2                 mov     ax, 201h
BIOSDATA:24D5                 xor     dh, dh
BIOSDATA:24D7                 mov     cx, 1
BIOSDATA:24DA                 int     13h             ; DISK - READ SECTORS INTO MEMORY
BIOSDATA:24DA                                         ; AL = number of sectors to read, CH = track, CL = sector
BIOSDATA:24DA                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
BIOSDATA:24DA                                         ; Return: CF set on error, AH = status, AL = number of sectors read
BIOSDATA:24DC                 jb      short erret
BIOSDATA:24DE                 cmp     word ptr es:3FEh, 0AA55h ; [es:bootbias+1FEh]
BIOSDATA:24DE                                         ; Dave Litton magic word?
BIOSDATA:24E5                 jz      short norm_ret  ; yes
BIOSDATA:24E7
BIOSDATA:24E7 erret:                                  ; CODE XREF: getboot+13↑j
BIOSDATA:24E7                 stc
BIOSDATA:24E8
BIOSDATA:24E8 norm_ret:                               ; CODE XREF: getboot+1C↑j
BIOSDATA:24E8                 retn
BIOSDATA:24E8 getboot         endp
BIOSDATA:24E8
BIOSDATA:24E9
BIOSDATA:24E9 ; =============== S U B R O U T I N E =======================================
BIOSDATA:24E9
BIOSDATA:24E9
BIOSDATA:24E9 sethard         proc near               ; CODE XREF: BIOSDATA:2201↑p
BIOSDATA:24E9                                         ; BIOSDATA:222A↑p
BIOSDATA:24E9                 push    di              ; inputs:
BIOSDATA:24E9                                         ;     dl is rom drive number (80h...)
BIOSDATA:24E9                                         ;     bh is partition number (0....)
BIOSDATA:24E9                                         ;     ds:di points to bds
BIOSDATA:24E9                                         ; outputs:
BIOSDATA:24E9                                         ;     carry clear -> bpb is filled in
BIOSDATA:24E9                                         ;     carry set -> bpb is left uninitialized due to error
BIOSDATA:24EA                 push    bx
BIOSDATA:24EB                 push    ds
BIOSDATA:24EC                 push    es
BIOSDATA:24ED                 mov     [di+5], bl      ; [di+BDS.drivelet]
BIOSDATA:24F0                 mov     [di+4], dl      ; [di+BDS.drivenum]
BIOSDATA:24F3                 or      byte ptr [di+3Fh], 1 ; [di+BDS.flags], fnon_removable
BIOSDATA:24F7                 mov     byte ptr [di+3Eh], 5 ; [di+BDS.formfactor], ffHardFile
BIOSDATA:24FB                 mov     ds:fbigfat, 0   ; assume 12 bit FAT
BIOSDATA:2500                 mov     dh, bh
BIOSDATA:2502                 push    dx
BIOSDATA:2503                 mov     ah, 8
BIOSDATA:2505                 int     13h             ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
BIOSDATA:2505                                         ; DL = drive number
BIOSDATA:2505                                         ; Return: CF set on error, AH = status code, BL = drive type
BIOSDATA:2505                                         ; DL = number of consecutive drives
BIOSDATA:2505                                         ; DH = maximum value for head number, ES:DI -> drive parameter
BIOSDATA:2507                 mov     dl, dh
BIOSDATA:2509                 mov     dh, 0
BIOSDATA:250B                 inc     dx
BIOSDATA:250C                 mov     [di+15h], dx    ; [di+BDS.heads]
BIOSDATA:250F                 pop     dx
BIOSDATA:2510                 jb      short setret_j  ; error if no hard disk
BIOSDATA:2512                 and     cx, 3Fh
BIOSDATA:2515                 mov     [di+13h], cx    ; [di+BDS.secpertrack]
BIOSDATA:2518                 push    dx
BIOSDATA:2519                 call    getboot
BIOSDATA:251C                 pop     dx              ; restore partition number
BIOSDATA:251D                 jnb     short chk_act_part
BIOSDATA:251F
BIOSDATA:251F setret_j:                               ; CODE XREF: sethard+27↑j
BIOSDATA:251F                 jmp     setret
BIOSDATA:2522 ; ---------------------------------------------------------------------------
BIOSDATA:2522
BIOSDATA:2522 chk_act_part:                           ; CODE XREF: sethard+34↑j
BIOSDATA:2522                 xor     bx, bx
BIOSDATA:2524                 mov     cs:ep_start_sector, bx
BIOSDATA:2529                 mov     cs:ep_start_sector+2, bx
BIOSDATA:252E                 mov     cs:ep_hidden_secs, bx
BIOSDATA:2533                 mov     cs:ep_hidden_secs+2, bx
BIOSDATA:2538                 mov     bx, 3C2h        ; 1C2h+bootbias
BIOSDATA:253B
BIOSDATA:253B act_part:                               ; CODE XREF: sethard+8A↓j
BIOSDATA:253B                 test    byte ptr es:[bx-4], 80h
BIOSDATA:2540                 jz      short no_act
BIOSDATA:2542                 cmp     byte ptr es:[bx], 1 ; FAT12
BIOSDATA:2546                 jz      short got_good_act
BIOSDATA:2548                 cmp     byte ptr es:[bx], 4 ; FAT16 CHS (<= 32MB)
BIOSDATA:254C                 jz      short got_good_act
BIOSDATA:254E                 cmp     byte ptr es:[bx], 0Bh ; FAT32 CHS
BIOSDATA:2552                 jz      short got_good_act
BIOSDATA:2554                 cmp     byte ptr es:[bx], 0Ch ; FAT32 LBA
BIOSDATA:2558                 jz      short got_good_act
BIOSDATA:255A                 cmp     byte ptr es:[bx], 0Eh ; FAT16 LBA
BIOSDATA:255E                 jz      short got_good_act
BIOSDATA:2560                 cmp     byte ptr es:[bx], 6 ; FAT16 BIG CHS (> 32MB)
BIOSDATA:2564                 jnz     short no_act
BIOSDATA:2566
BIOSDATA:2566 got_good_act:                           ; CODE XREF: sethard+5D↑j
BIOSDATA:2566                                         ; sethard+63↑j ...
BIOSDATA:2566                 or      dh, dh
BIOSDATA:2568                 jz      short set2
BIOSDATA:256A                 dec     dh
BIOSDATA:256C
BIOSDATA:256C no_act:                                 ; CODE XREF: sethard+57↑j
BIOSDATA:256C                                         ; sethard+7B↑j
BIOSDATA:256C                 add     bx, 16
BIOSDATA:256F                 cmp     bx, 402h        ; 202h+bootbias
BIOSDATA:256F                                         ; last entry done?
BIOSDATA:2573                 jnz     short act_part
BIOSDATA:2575                 mov     bx, 3C2h        ; 1C2h+bootbias
BIOSDATA:2575                                         ; restore original value of bx
BIOSDATA:2578
BIOSDATA:2578 get_primary:                            ; CODE XREF: sethard+C7↓j
BIOSDATA:2578                 test    byte ptr es:[bx-4], 80h
BIOSDATA:257D                 jnz     short not_prim  ; we've already scanned
BIOSDATA:257D                                         ; the ACTIVE ones
BIOSDATA:257F                 cmp     byte ptr es:[bx], 1 ; FAT12 fs
BIOSDATA:2583                 jz      short got_prim
BIOSDATA:2585                 cmp     byte ptr es:[bx], 4 ; FAT16 fs
BIOSDATA:2589                 jz      short got_prim
BIOSDATA:258B                 cmp     byte ptr es:[bx], 0Bh ; FAT32 CHS file system
BIOSDATA:258F                 jz      short got_prim
BIOSDATA:2591                 cmp     byte ptr es:[bx], 0Ch ; FAT32 LBA file system
BIOSDATA:2595                 jz      short got_prim
BIOSDATA:2597                 cmp     byte ptr es:[bx], 0Eh ; FAT16 LBA file system
BIOSDATA:259B                 jz      short got_prim
BIOSDATA:259D                 cmp     byte ptr es:[bx], 6 ; FAT16 big fs (> 32 MB)
BIOSDATA:25A1                 jnz     short not_prim
BIOSDATA:25A3
BIOSDATA:25A3 got_prim:                               ; CODE XREF: sethard+9A↑j
BIOSDATA:25A3                                         ; sethard+A0↑j ...
BIOSDATA:25A3                 or      dh, dh
BIOSDATA:25A5                 jz      short set2
BIOSDATA:25A7                 dec     dh
BIOSDATA:25A9
BIOSDATA:25A9 not_prim:                               ; CODE XREF: sethard+94↑j
BIOSDATA:25A9                                         ; sethard+B8↑j
BIOSDATA:25A9                 add     bx, 16
BIOSDATA:25AC                 cmp     bx, 402h        ; 202h+bootbias
BIOSDATA:25B0                 jnz     short get_primary ; loop till we've gone through table
BIOSDATA:25B2
BIOSDATA:25B2 setret:                                 ; CODE XREF: sethard:setret_j↑j
BIOSDATA:25B2                                         ; sethard:set3_err↓j
BIOSDATA:25B2                 stc
BIOSDATA:25B3                 jmp     ret_hard_err
BIOSDATA:25B3 ; ---------------------------------------------------------------------------
BIOSDATA:25B6 ep_start_sector dw 2 dup(0)             ; DATA XREF: sethard+3B↑w
BIOSDATA:25B6                                         ; domini+D↓w ...
BIOSDATA:25BA ep_hidden_secs  dw 2 dup(0)             ; DATA XREF: sethard+45↑w
BIOSDATA:25BA                                         ; sethard:okdrive↓r ...
BIOSDATA:25BE ; ---------------------------------------------------------------------------
BIOSDATA:25BE
BIOSDATA:25BE set2:                                   ; CODE XREF: sethard+7F↑j
BIOSDATA:25BE                                         ; sethard+BC↑j ...
BIOSDATA:25BE                 mov     cs:rom_drv_num, dl
BIOSDATA:25C3                 mov     ax, es:[bx+4]   ; start sector (LBA) of the partition
BIOSDATA:25C7                 mov     dx, es:[bx+6]
BIOSDATA:25CB                 sub     ax, 1
BIOSDATA:25CE                 sbb     dx, 0           ; zero based sector count
BIOSDATA:25D1                 add     ax, es:[bx+8]   ; start LBA + partition size in sectors
BIOSDATA:25D5                 adc     dx, es:[bx+0Ah]
BIOSDATA:25D9                 jnb     short okdrive
BIOSDATA:25DB                 or      ds:fbigfat, 80h ; ftoobig
BIOSDATA:25E0
BIOSDATA:25E0 okdrive:                                ; CODE XREF: sethard+F0↑j
BIOSDATA:25E0                 add     ax, cs:ep_hidden_secs
BIOSDATA:25E5                 adc     dx, cs:ep_hidden_secs+2
BIOSDATA:25EA                 jnb     short okdrive_1
BIOSDATA:25EC                 or      ds:fbigfat, 80h ; ftoobig
BIOSDATA:25F1
BIOSDATA:25F1 okdrive_1:                              ; CODE XREF: sethard+101↑j
BIOSDATA:25F1                 cmp     byte ptr es:[bx], 0Ch ; FAT32 LBA partition ID
BIOSDATA:25F5                 jz      short set_lba_flag
BIOSDATA:25F7                 cmp     byte ptr es:[bx], 0Eh ; FAT16 LBA partition ID
BIOSDATA:25FB                 jz      short set_lba_flag
BIOSDATA:25FD                 cmp     dx, [di+13h]    ; if dx > [di+BDS.secpertrack] then
BIOSDATA:2600                 jnb     short set_lba_flag ; set LBA r/w flag
BIOSDATA:2602                 div     word ptr [di+13h]
BIOSDATA:2605                 xor     dx, dx
BIOSDATA:2607                 div     word ptr [di+15h]
BIOSDATA:260A                 cmp     ax, 400h        ; if ax (cylinder number) >= 1024
BIOSDATA:260A                                         ;  set LBA r/w flag
BIOSDATA:260D                 jb      short set3
BIOSDATA:260F
BIOSDATA:260F set_lba_flag:                           ; CODE XREF: sethard+10C↑j
BIOSDATA:260F                                         ; sethard+112↑j ...
BIOSDATA:260F                 or      byte ptr [di+40h], 4 ; fLBArw ; LBA r/w flag
BIOSDATA:2613
BIOSDATA:2613 set3:                                   ; CODE XREF: sethard+124↑j
BIOSDATA:2613                 mov     ax, es:[bx+4]   ; start sector (LBA) of the partition
BIOSDATA:2617                 mov     dx, es:[bx+6]
BIOSDATA:261B                 add     ax, cs:ep_hidden_secs ; + hidden secs of the extd dos partion
BIOSDATA:2620                 adc     dx, cs:ep_hidden_secs+2
BIOSDATA:2625                 mov     [di+17h], ax    ; [di+BDS.hiddensectors]
BIOSDATA:2628                 mov     [di+19h], dx
BIOSDATA:262B                 xor     ax, ax
BIOSDATA:262D                 mov     [di+7Bh], ax    ; [di+BDS.bdsm_hidden_trks]
BIOSDATA:2630                 mov     [di+0Eh], ax    ; [di+BDS.totalsec16]
BIOSDATA:2633                 mov     dx, es:[bx+10]  ; totals sectors (size) of the partition
BIOSDATA:2637                 mov     ax, es:[bx+8]
BIOSDATA:263B                 mov     [di+1Dh], dx
BIOSDATA:263E                 mov     [di+1Bh], ax    ; [di+BDS.totalsecs32]
BIOSDATA:2641                 cmp     dx, 0
BIOSDATA:2644                 ja      short set3_read
BIOSDATA:2646                 cmp     ax, 64
BIOSDATA:2649                 jb      short set3_err
BIOSDATA:264B
BIOSDATA:264B set3_read:                              ; CODE XREF: sethard+15B↑j
BIOSDATA:264B                 mov     dx, [di+19h]    ; [di+BDS.hiddensectors+2]
BIOSDATA:264E                 mov     ax, [di+17h]    ; [di+BDS.hiddensectors]
BIOSDATA:2651                 xor     bx, bx
BIOSDATA:2653                 mov     bl, [di+13h]    ; [di+BDS.secpertrack]
BIOSDATA:2656                 push    ax
BIOSDATA:2657                 mov     ax, dx
BIOSDATA:2659                 xor     dx, dx
BIOSDATA:265B                 div     bx
BIOSDATA:265D                 mov     cs:saved_word, ax
BIOSDATA:2661                 pop     ax
BIOSDATA:2662                 div     bx
BIOSDATA:2664                 mov     cl, dl
BIOSDATA:2666                 inc     cl
BIOSDATA:2668                 mov     bx, [di+15h]    ; [di+BDS.heads]
BIOSDATA:266B                 push    ax
BIOSDATA:266C                 xor     dx, dx
BIOSDATA:266E                 mov     ax, cs:saved_word
BIOSDATA:2672                 div     bx
BIOSDATA:2674                 mov     cs:saved_word, ax
BIOSDATA:2678                 pop     ax
BIOSDATA:2679                 div     bx
BIOSDATA:267B                 test    byte ptr [di+40h], 4 ; fLBArw ; LBA read/write flag
BIOSDATA:267F                 jz      short set3_chs_read
BIOSDATA:2681
BIOSDATA:2681 set3_lba_read:
BIOSDATA:2681                 push    cs
BIOSDATA:2682                 pop     es
BIOSDATA:2683                 assume es:BIOSDATA
BIOSDATA:2683                 mov     bx, offset disksector
BIOSDATA:2686                 push    ds
BIOSDATA:2687                 push    si
BIOSDATA:2688                 xor     ax, ax          ; 0
BIOSDATA:268A                 push    ax
BIOSDATA:268B                 push    ax
BIOSDATA:268C                 mov     ax, [di+19h]    ; [di+BDS.hiddensectors+2]
BIOSDATA:268F                 push    ax
BIOSDATA:2690                 mov     ax, [di+17h]    ; [di+BDS.hiddensectors]
BIOSDATA:2693                 push    ax
BIOSDATA:2694                 push    es              ; buffer address
BIOSDATA:2695                 push    bx
BIOSDATA:2696                 mov     ax, 1           ; sector (read) count
BIOSDATA:2699                 push    ax
BIOSDATA:269A                 mov     ax, 16          ; DAP size
BIOSDATA:269D                 push    ax
BIOSDATA:269E                 mov     ax, ss
BIOSDATA:26A0                 mov     ds, ax
BIOSDATA:26A2                 assume ds:nothing
BIOSDATA:26A2                 mov     si, sp
BIOSDATA:26A4                 mov     dl, cs:rom_drv_num
BIOSDATA:26A9                 mov     ah, 42h
BIOSDATA:26AB                 int     13h             ; DISK - IBM/MS Extension
BIOSDATA:26AB                                         ; EXTENDED READ (DL - drive, DS:SI - disk address packet)
BIOSDATA:26AD                 jnb     short set3_lba_read_ok
BIOSDATA:26AF                 add     sp, 16
BIOSDATA:26B2                 pop     si
BIOSDATA:26B3                 pop     ds
BIOSDATA:26B4                 assume ds:nothing
BIOSDATA:26B4
BIOSDATA:26B4 set3_err:                               ; CODE XREF: sethard+160↑j
BIOSDATA:26B4                                         ; sethard+1FA↓j
BIOSDATA:26B4                 jmp     setret
BIOSDATA:26B7 ; ---------------------------------------------------------------------------
BIOSDATA:26B7
BIOSDATA:26B7 set3_lba_read_ok:                       ; CODE XREF: sethard+1C4↑j
BIOSDATA:26B7                 add     sp, 16
BIOSDATA:26BA                 pop     si
BIOSDATA:26BB                 pop     ds
BIOSDATA:26BC                 jmp     short set3_read_ok
BIOSDATA:26BE ; ---------------------------------------------------------------------------
BIOSDATA:26BE
BIOSDATA:26BE set3_chs_read:                          ; CODE XREF: sethard+196↑j
BIOSDATA:26BE                 cmp     word ptr [di+79h], 1 ; [di+BDS.bdsm_ismini] ; check for mini disk
BIOSDATA:26C2                 jnz     short oknotmini
BIOSDATA:26C4                 add     ax, [di+7Bh]    ; [di+BDS.bdsm_hidden_trks]
BIOSDATA:26C7
BIOSDATA:26C7 oknotmini:                              ; CODE XREF: sethard+1D9↑j
BIOSDATA:26C7                 ror     ah, 1           ; move high two bits of cyl to high
BIOSDATA:26C9                 ror     ah, 1           ; two bits of upper byte
BIOSDATA:26CB                 and     ah, 0C0h        ; turn off remainder of bits
BIOSDATA:26CE                 or      cl, ah          ; move two bits to correct spot
BIOSDATA:26D0                 mov     ch, al          ; ch is cylinder (low 8 bits)
BIOSDATA:26D0                                         ; cl is sector + 2 high bits of cylinder
BIOSDATA:26D2                 mov     dh, dl          ; dh is head
BIOSDATA:26D4                 mov     dl, cs:rom_drv_num ; dl is drive number
BIOSDATA:26D9                 push    cs
BIOSDATA:26DA                 pop     es
BIOSDATA:26DB                 mov     bx, offset disksector
BIOSDATA:26DE                 mov     ax, 201h
BIOSDATA:26E1                 int     13h             ; DISK - READ SECTORS INTO MEMORY
BIOSDATA:26E1                                         ; AL = number of sectors to read, CH = track, CL = sector
BIOSDATA:26E1                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
BIOSDATA:26E1                                         ; Return: CF set on error, AH = status, AL = number of sectors read
BIOSDATA:26E3                 jb      short set3_err
BIOSDATA:26E5
BIOSDATA:26E5 set3_read_ok:                           ; CODE XREF: sethard+1D3↑j
BIOSDATA:26E5                 mov     bx, offset disksector
BIOSDATA:26E8                 push    bx
BIOSDATA:26E9                 push    ax
BIOSDATA:26EA                 cmp     word ptr es:[bx+1FEh], 0AA55h
BIOSDATA:26F1                 jnz     short invalid_boot_record
BIOSDATA:26F3                 cmp     word ptr es:[bx+16h], 0 ; [bx+BPB_FATSz16] ; 16 bit FAT size is 0 if it is FAT32 bs
BIOSDATA:26F8                 jz      short check_1   ; FAT32
BIOSDATA:26FA                 push    ds
BIOSDATA:26FB                 push    si
BIOSDATA:26FC                 push    di
BIOSDATA:26FD                 push    es
BIOSDATA:26FE                 pop     ds
BIOSDATA:26FF                 assume ds:BIOSDATA
BIOSDATA:26FF                 mov     cx, 28
BIOSDATA:2702                 lea     si, [bx+24h]    ; move offset 36 to 63
BIOSDATA:2702                                         ;      to offset 64 (28 bytes)
BIOSDATA:2705                 lea     di, [bx+40h]    ; boot sector offset 64
BIOSDATA:2708                 cld
BIOSDATA:2709                 rep movsb
BIOSDATA:270B                 pop     di
BIOSDATA:270C                 pop     si
BIOSDATA:270D                 pop     ds
BIOSDATA:270E                 assume ds:nothing
BIOSDATA:270E
BIOSDATA:270E check_1:                                ; CODE XREF: sethard+20F↑j
BIOSDATA:270E                 cmp     byte ptr cs:[bx], 0E9h ; is it a near jump?
BIOSDATA:2712                 jz      short check_2   ; yes
BIOSDATA:2714                 cmp     byte ptr cs:[bx], 0EBh ; is it a short jump?
BIOSDATA:2718                 jnz     short invalid_boot_record ; no
BIOSDATA:271A                 cmp     byte ptr cs:[bx+2], 90h ; yes, is the next one a nop?
BIOSDATA:271F                 jnz     short invalid_boot_record ; no
BIOSDATA:2721
BIOSDATA:2721 check_2:                                ; CODE XREF: sethard+229↑j
BIOSDATA:2721                 mov     bx, (offset disksector+0Bh) ;  disksector+EXT_BOOT.BPB ; disksector+11
BIOSDATA:2724                 mov     al, cs:[bx+10]  ; [bx+EBPB.MEDIADESCRIPTOR]
BIOSDATA:2728                 and     al, 0F0h        ; mask off low nibble
BIOSDATA:272A                 cmp     al, 0F0h        ; is high nibble = 0Fh?
BIOSDATA:272C                 jnz     short invalid_boot_record
BIOSDATA:272E                 cmp     word ptr cs:[bx], 512 ; [bx+EBPB.BYTESPERSECTOR]
BIOSDATA:2733                 jnz     short invalid_boot_record ; invalidate non 512 byte sectors
BIOSDATA:2735                 mov     al, cs:[bx+2]   ; now make sure that
BIOSDATA:2735                                         ; the sectorspercluster is a power of 2
BIOSDATA:2739                 or      al, al          ; is it zero?
BIOSDATA:273B                 jz      short invalid_boot_record ; yes, invalid boot record
BIOSDATA:273D
BIOSDATA:273D ck_power_of_two:                        ; CODE XREF: sethard+256↓j
BIOSDATA:273D                 shr     al, 1           ; shift until first bit emerges
BIOSDATA:273F                 jnb     short ck_power_of_two
BIOSDATA:2741                 jz      short valid_boot_record
BIOSDATA:2743
BIOSDATA:2743 invalid_boot_record:                    ; CODE XREF: sethard+208↑j
BIOSDATA:2743                                         ; sethard+22F↑j ...
BIOSDATA:2743                 pop     ax
BIOSDATA:2744                 pop     bx
BIOSDATA:2745                 jmp     unknown         ; jump to invalid boot record
BIOSDATA:2745                                         ; unformatted or illegal media.
BIOSDATA:2748 ; ---------------------------------------------------------------------------
BIOSDATA:2748
BIOSDATA:2748 valid_boot_record:                      ; CODE XREF: sethard+258↑j
BIOSDATA:2748                 pop     ax
BIOSDATA:2749                 pop     bx              ;
BIOSDATA:2749                                         ; Signature found. Now check version.
BIOSDATA:274A                 cmp     word ptr cs:[bx+8], 2E32h ; '2.' (NASM syntax)
BIOSDATA:2750                 jnz     short try5
BIOSDATA:2752                 cmp     byte ptr cs:[bx+0Ah], 30h ; '0'
BIOSDATA:2757                 jnz     short try5
BIOSDATA:2759                 jmp     short copybpb
BIOSDATA:275B ; ---------------------------------------------------------------------------
BIOSDATA:275B
BIOSDATA:275B unknown3_0_j:                           ; CODE XREF: sethard+293↓j
BIOSDATA:275B                                         ; sethard+29C↓j
BIOSDATA:275B                 jmp     unknown3_0
BIOSDATA:275E ; ---------------------------------------------------------------------------
BIOSDATA:275E
BIOSDATA:275E try5:                                   ; CODE XREF: sethard+267↑j
BIOSDATA:275E                                         ; sethard+26E↑j
BIOSDATA:275E                 call    cover_fdisk_bug
BIOSDATA:2761                 cmp     word ptr cs:[bx+8], 2E30h ; '0.' (NASM syntax)
BIOSDATA:2767                 jnz     short no_os2
BIOSDATA:2769                 mov     al, cs:[bx+7]
BIOSDATA:276D                 sub     al, 31h ; '1'
BIOSDATA:276F                 and     al, 0FEh
BIOSDATA:2771                 jz      short copybpb   ; accept either '1' or '2'
BIOSDATA:2773                 jmp     unknown
BIOSDATA:2776 ; ---------------------------------------------------------------------------
BIOSDATA:2776
BIOSDATA:2776 no_os2:                                 ; CODE XREF: sethard+27E↑j
BIOSDATA:2776                 cmp     word ptr cs:[bx+8], 2E33h ; '3.' (NASM syntax)
BIOSDATA:277C                 jb      short unknown3_0_j
BIOSDATA:277E                 jnz     short copybpb
BIOSDATA:2780                 cmp     byte ptr cs:[bx+0Ah], 31h ; '1'
BIOSDATA:2785                 jb      short unknown3_0_j
BIOSDATA:2787
BIOSDATA:2787 copybpb:                                ; CODE XREF: sethard+270↑j
BIOSDATA:2787                                         ; sethard+288↑j ...
BIOSDATA:2787                 cmp     word ptr cs:disksector+4Dh, 0
BIOSDATA:278D                 jnz     short check_3   ; NOTE: This check is not proper for FAT32 boot sector (standard spec)
BIOSDATA:278D                                         ; (after PCDOS 7.1). So, it is not existing in Windows ME IO.SYS
BIOSDATA:278D                                         ; Erdogan Tan - 01/09/2023
BIOSDATA:278F                 cmp     cs:disksector+42h, 29h ; BS_BootSig (FAT32)
BIOSDATA:2795                 jmp     short check_4
BIOSDATA:2797 ; ---------------------------------------------------------------------------
BIOSDATA:2797
BIOSDATA:2797 check_3:                                ; CODE XREF: sethard+2A4↑j
BIOSDATA:2797                 cmp     cs:disksector+26h, 29h ; BS_BootSig (FAT16/FAT12)
BIOSDATA:279D
BIOSDATA:279D check_4:                                ; CODE XREF: sethard+2AC↑j
BIOSDATA:279D                 jnz     short copybpb_fat
BIOSDATA:279F                 cmp     cs:disksector+10h, 0 ; BPB.fats
BIOSDATA:27A5                 jnz     short copybpb_fat
BIOSDATA:27A7                 push    di
BIOSDATA:27A8                 push    ds
BIOSDATA:27A9                 push    ds
BIOSDATA:27AA                 pop     es
BIOSDATA:27AB                 assume es:nothing
BIOSDATA:27AB                 push    cs
BIOSDATA:27AC                 pop     ds
BIOSDATA:27AD                 assume ds:BIOSDATA
BIOSDATA:27AD                 mov     si, (offset disksector+0Bh) ; BIOSDATA:015Dh
BIOSDATA:27B0                 add     di, 6           ; add di,BDS.BPB
BIOSDATA:27B3                 cmp     word ptr cs:[si+8], 0 ; [BPB.totalsecs16]
BIOSDATA:27B8                 jnz     short already_nonz
BIOSDATA:27BA                 cmp     word ptr cs:[si+15h], 0 ; [BPB.totalsecs32]
BIOSDATA:27BF                 jnz     short already_nonz
BIOSDATA:27C1                 cmp     word ptr cs:[si+17h], 0 ; [BPB.totalsecs32+2]
BIOSDATA:27C6                 jnz     short already_nonz
BIOSDATA:27C8                 mov     ax, [di+8]      ; .. empty BPB (size) fields ..
BIOSDATA:27C8                                         ; fill boot sector's BPB fields
BIOSDATA:27C8                                         ;           with correct values
BIOSDATA:27CB                 mov     cs:[si+8], ax
BIOSDATA:27CF                 mov     ax, [di+15h]
BIOSDATA:27D2                 mov     cs:[si+15h], ax
BIOSDATA:27D6                 mov     ax, [di+17h]
BIOSDATA:27D9                 mov     cs:[si+17h], ax
BIOSDATA:27DD
BIOSDATA:27DD already_nonz:                           ; CODE XREF: sethard+2CF↑j
BIOSDATA:27DD                                         ; sethard+2D6↑j ...
BIOSDATA:27DD                 mov     cx, 53          ; copy contents of the bootsector's BPB
BIOSDATA:27DD                                         ;                      to the BDS's BPB
BIOSDATA:27E0                 rep movsb
BIOSDATA:27E2                 pop     ds
BIOSDATA:27E3                 assume ds:nothing
BIOSDATA:27E3                 pop     di
BIOSDATA:27E4                 push    es
BIOSDATA:27E5                 push    ds
BIOSDATA:27E6                 pop     es
BIOSDATA:27E7                 push    cs
BIOSDATA:27E8                 pop     ds
BIOSDATA:27E9                 assume ds:BIOSDATA
BIOSDATA:27E9                 mov     bp, offset mov_media_ids
BIOSDATA:27EC                 push    cs
BIOSDATA:27ED                 call    call_bios_code
BIOSDATA:27F0                 push    es
BIOSDATA:27F1                 pop     ds
BIOSDATA:27F2                 assume ds:nothing
BIOSDATA:27F2                 pop     es
BIOSDATA:27F3                 jmp     goodret
BIOSDATA:27F3 sethard         endp
BIOSDATA:27F3
BIOSDATA:27F6
BIOSDATA:27F6 ; =============== S U B R O U T I N E =======================================
BIOSDATA:27F6
BIOSDATA:27F6
BIOSDATA:27F6 copybpb_fat     proc near               ; CODE XREF: sethard:check_4↑j
BIOSDATA:27F6                                         ; sethard+2BC↑j
BIOSDATA:27F6                 mov     si, (offset disksector+0Bh) ; BIOSDATA:015Dh
BIOSDATA:27F6                                         ; disksector+11
BIOSDATA:27F6                                         ; disksector+EXT_BOOT.BPB
BIOSDATA:27F9                 xor     dx, dx
BIOSDATA:27FB                 mov     ax, cs:[si+8]   ; BPB.totalsecs16
BIOSDATA:27FF                 or      ax, ax          ; get totsec from boot sec
BIOSDATA:2801                 jnz     short copy_totsec
BIOSDATA:2803                 mov     ax, cs:[si+15h] ; BPB.totalsecs32
BIOSDATA:2807                 mov     dx, cs:[si+17h] ; BPB.totalsecs32+2
BIOSDATA:280B                 mov     cx, dx          ; get the big version
BIOSDATA:280D                 or      cx, ax          ; see if it is a big zero
BIOSDATA:280F                 jz      short fat_big_small ; screw it. it was bogus.
BIOSDATA:2811
BIOSDATA:2811 copy_totsec:                            ; CODE XREF: copybpb_fat+B↑j
BIOSDATA:2811                 mov     [di+1Bh], ax    ; [di+BDS.totalsecs32]
BIOSDATA:2814                 mov     [di+1Dh], dx    ; [di+BDS.totalsecs32+2]
BIOSDATA:2817
BIOSDATA:2817 fat_big_small:                          ; CODE XREF: copybpb_fat+19↑j
BIOSDATA:2817                 mov     ax, [di+1Bh]
BIOSDATA:281A                 mov     dx, [di+1Dh]
BIOSDATA:281D                 mov     bx, cs:[si+3]   ; BPB.resectors
BIOSDATA:2821                 mov     [di+9], bx      ; [di+BDS.resectors]
BIOSDATA:2824                 sub     ax, bx
BIOSDATA:2826                 sbb     dx, 0
BIOSDATA:2829                 mov     bx, cs:[si+0Bh] ; BPB.fatsecs
BIOSDATA:282D                 mov     [di+11h], bx    ; [di+BDS.fatsecs]
BIOSDATA:2830                 push    bx
BIOSDATA:2831                 or      bx, bx
BIOSDATA:2833                 jnz     short fat_16bit
BIOSDATA:2835                 sub     ax, cs:[si+19h] ; FAT32 file system (BUG!)
BIOSDATA:2835                                         ; BPB.FATSz32
BIOSDATA:2839                 sbb     dx, cs:[si+1Bh] ; BPB.FATSz32+2 (BUG!)
BIOSDATA:283D                 mov     bx, cs:[si+19h] ; BPB.FATSz32
BIOSDATA:2841                 mov     [di+1Fh], bx    ; [di+BDS.fatsecs32]
BIOSDATA:2844                 mov     bx, cs:[si+1Bh] ; BPB.FATSz32+2
BIOSDATA:2848                 mov     [di+21h], bx    ; [di+BDS.fatsecs32+2]
BIOSDATA:284B                 mov     bx, cs:[si+1Dh] ; BPB.BPB_ExtFlags
BIOSDATA:284F                 mov     [di+23h], bx    ; [di+BDS.extflags]
BIOSDATA:2852                 mov     bx, cs:[si+1Fh] ; BPB.FSVer
BIOSDATA:2856                 mov     [di+25h], bx    ; [di+BDS.fsver]
BIOSDATA:2859                 mov     bx, cs:[si+21h] ; BPB.RootClus
BIOSDATA:285D                 mov     [di+27h], bx    ; [di+BDS.rootdirclust]
BIOSDATA:2860                 mov     bx, cs:[si+23h] ; BPB.RootClus+2
BIOSDATA:2864                 mov     [di+29h], bx    ; [di+BDS.rootdirclust+2]
BIOSDATA:2867                 mov     bx, cs:[si+25h] ; BPB.FSInfo
BIOSDATA:286B                 mov     [di+2Bh], bx    ; [di+BDS.fsinfo]
BIOSDATA:286E                 mov     bx, cs:[si+27h] ; BPB.FSInfo+2
BIOSDATA:2872                 mov     [di+2Dh], bx    ; [di+BDS.fsinfo+2]
BIOSDATA:2875                 jmp     short fat_32bit ; BUG! Erdogan Tan - 8/8/2023
BIOSDATA:2875                                         ; correct code (would be):
BIOSDATA:2875                                         ;   mov cl, [cs:si+05h] ; BPB_NumFATs
BIOSDATA:2875                                         ; sub_fat32_size:
BIOSDATA:2875                                         ;   sub ax, [cs:si+19h] ; BPB_FATSz32
BIOSDATA:2875                                         ;   sbb dx, [cs:si+1Bh] ; BPB_FATSz32+2
BIOSDATA:2875                                         ;   dec cl
BIOSDATA:2875                                         ;   jg short sub_fat32_size
BIOSDATA:2875                                         ;   jmp short fat_32bit
BIOSDATA:2877 ; ---------------------------------------------------------------------------
BIOSDATA:2877
BIOSDATA:2877 fat_16bit:                              ; CODE XREF: copybpb_fat+3D↑j
BIOSDATA:2877                 shl     bx, 1           ; always 2 fats ! BUG!
BIOSDATA:2879                 sub     ax, bx          ; sub # fat sectors
BIOSDATA:287B                 sbb     dx, 0           ; BUG! Erdogan Tan - 8/8/2023
BIOSDATA:287B                                         ; correct code (would be):
BIOSDATA:287B                                         ;   mov cl, [cs:si+05h] ; BPB_NumFATs
BIOSDATA:287B                                         ; sub_fat_size:
BIOSDATA:287B                                         ;   sub ax, bx ; BPB.fatsecs
BIOSDATA:287B                                         ;   sbb dx, 0
BIOSDATA:287B                                         ;   dec cl
BIOSDATA:287B                                         ;   jg short sub_fat_size
BIOSDATA:287E
BIOSDATA:287E fat_32bit:                              ; CODE XREF: copybpb_fat+7F↑j
BIOSDATA:287E                 mov     bx, cs:[si+6]   ; BPB.direntries
BIOSDATA:2882                 mov     [di+0Ch], bx    ; [di+BDS.direntries]
BIOSDATA:2885                 mov     cl, 4
BIOSDATA:2887                 shr     bx, cl
BIOSDATA:2889                 sub     ax, bx          ; - root dir sectors
BIOSDATA:288B                 sbb     dx, 0           ; dx:ax = # of data sectors
BIOSDATA:288E                 xor     cx, cx
BIOSDATA:2890                 mov     cl, cs:[si+2]   ; BPB.secperclus
BIOSDATA:2894                 mov     [di+8], cl      ; [di+BDS.secperclus]
BIOSDATA:2897                 push    ax
BIOSDATA:2898                 mov     ax, dx
BIOSDATA:289A                 xor     dx, dx
BIOSDATA:289C                 div     cx              ; 32 bit division
BIOSDATA:289E                 mov     cs:saved_word, ax ; hw of cluster number
BIOSDATA:28A2                 pop     ax
BIOSDATA:28A3                 div     cx
BIOSDATA:28A5                 pop     bx
BIOSDATA:28A6                 or      bx, bx
BIOSDATA:28A8                 jnz     short chk_clnum_hw ; 16 bit fat sectors > 0 ; FAT12 or FAT16 fs
BIOSDATA:28AA                 cmp     cs:saved_word, 0FFFh
BIOSDATA:28B1                 jnz     short fat32_clust_limit
BIOSDATA:28B3                 cmp     ax, 0FFF6h      ; FAT32 cluster number limit: 0FFFFFF6h
BIOSDATA:28B6
BIOSDATA:28B6 fat32_clust_limit:                      ; CODE XREF: copybpb_fat+BB↑j
BIOSDATA:28B6                 ja      short toobig_ret
BIOSDATA:28B8                 cmp     cs:saved_word, bx
BIOSDATA:28BD                 jnz     short fat16_clust_limit
BIOSDATA:28BF                 cmp     ax, 0FFF6h      ; FAT16 cluster number limit: 0FFF6h
BIOSDATA:28C2
BIOSDATA:28C2 fat16_clust_limit:                      ; CODE XREF: copybpb_fat+C7↑j
BIOSDATA:28C2                 jbe     short fat12_clust_limit
BIOSDATA:28C4                 or      ds:fbigfat, 20h ; fbigbig ; FAT32 fs
BIOSDATA:28C9                 jmp     short copymediaid
BIOSDATA:28CB ; ---------------------------------------------------------------------------
BIOSDATA:28CB
BIOSDATA:28CB chk_clnum_hw:                           ; CODE XREF: copybpb_fat+B2↑j
BIOSDATA:28CB                 cmp     cs:saved_word, 0
BIOSDATA:28D1                 ja      short toobig_ret
BIOSDATA:28D3
BIOSDATA:28D3 fat12_clust_limit:                      ; CODE XREF: copybpb_fat:fat16_clust_limit↑j
BIOSDATA:28D3                 cmp     ax, 0FF6h       ; FAT12 cluster number limit: 0FF6h
BIOSDATA:28D6                 jb      short copymediaid ; FAT12 fs
BIOSDATA:28D8                 or      ds:fbigfat, 40h ; fbig ; FAT16 fs
BIOSDATA:28DD
BIOSDATA:28DD copymediaid:                            ; CODE XREF: copybpb_fat+D3↑j
BIOSDATA:28DD                                         ; copybpb_fat+E0↑j
BIOSDATA:28DD                 push    es
BIOSDATA:28DE                 push    ds
BIOSDATA:28DF                 pop     es
BIOSDATA:28E0                 push    cs
BIOSDATA:28E1                 pop     ds
BIOSDATA:28E2                 assume ds:BIOSDATA
BIOSDATA:28E2                 mov     bp, offset mov_media_ids ;
BIOSDATA:28E2                                         ; MOVMEDIAIDS equ mov_media_ids - DOSBIOSEG
BIOSDATA:28E5                 push    cs
BIOSDATA:28E6                 call    call_bios_code
BIOSDATA:28E9                 push    es
BIOSDATA:28EA                 pop     ds
BIOSDATA:28EB                 assume ds:nothing
BIOSDATA:28EB                 pop     es
BIOSDATA:28EC                 jmp     massage_bpb
BIOSDATA:28EF ; ---------------------------------------------------------------------------
BIOSDATA:28EF
BIOSDATA:28EF toobig_ret:                             ; CODE XREF: copybpb_fat:fat32_clust_limit↑j
BIOSDATA:28EF                                         ; copybpb_fat+DB↑j
BIOSDATA:28EF                 or      cs:fbigfat, 80h ; ftoobig ; too big (32 bit cluster #) for FAT16
BIOSDATA:28F5                 jmp     goodret         ; still drive letter is assigned
BIOSDATA:28F5                                         ; but useless. to big for
BIOSDATA:28F5                                         ; current pc dos fat file system
BIOSDATA:28F8 ; ---------------------------------------------------------------------------
BIOSDATA:28F8
BIOSDATA:28F8 unknown:                                ; CODE XREF: sethard+25C↑j
BIOSDATA:28F8                                         ; sethard+28A↑j
BIOSDATA:28F8                 or      byte ptr [di+40h], 2 ; [di+BDS.flags+1] ; unformatted_media
BIOSDATA:28F8                                         ; Set unformatted media flag.
BIOSDATA:28FC
BIOSDATA:28FC unknown3_0:                             ; CODE XREF: sethard:unknown3_0_j↑j
BIOSDATA:28FC                 mov     dx, [di+1Dh]    ; skip setting unformatted_media bit
BIOSDATA:28FC                                         ; [di+BDS.totalsecs32+2]
BIOSDATA:28FF                 mov     ax, [di+1Bh]    ; [di+BDS.totalsecs32]
BIOSDATA:2902                 mov     si, offset disktable2
BIOSDATA:2905
BIOSDATA:2905 scan:                                   ; CODE XREF: copybpb_fat+11F↓j
BIOSDATA:2905                 cmp     dx, cs:[si]     ; total sectors hw
BIOSDATA:2908                 jb      short gotparm
BIOSDATA:290A                 ja      short scan_next
BIOSDATA:290C                 cmp     ax, cs:[si+2]   ; total sectors lw
BIOSDATA:2910                 jbe     short gotparm
BIOSDATA:2912
BIOSDATA:2912 scan_next:                              ; CODE XREF: copybpb_fat+114↑j
BIOSDATA:2912                 add     si, 10
BIOSDATA:2915                 jmp     short scan
BIOSDATA:2917 ; ---------------------------------------------------------------------------
BIOSDATA:2917
BIOSDATA:2917 gotparm:                                ; CODE XREF: copybpb_fat+112↑j
BIOSDATA:2917                                         ; copybpb_fat+11A↑j
BIOSDATA:2917                 mov     cl, [si+8]      ; bigfat flags
BIOSDATA:2917                                         ; (FAT16 fbig=40h, FAT32 fbigbig=20h)
BIOSDATA:291A                 or      ds:fbigfat, cl
BIOSDATA:291E                 mov     cx, cs:[si+4]   ; shift count (cl) -log base 2 of ch-
BIOSDATA:291E                                         ; sector per cluster (ch)
BIOSDATA:2922                 mov     dx, cs:[si+6]   ; root directory entries
BIOSDATA:2926                 mov     [di+0Ch], dx    ; [di+BDS.direntries]
BIOSDATA:2929                 mov     dx, [di+1Dh]    ; [di+BDS.totalsecs32]
BIOSDATA:292C                 mov     ax, [di+1Bh]
BIOSDATA:292F                 mov     [di+8], ch      ; [di+BDS.secperclus]
BIOSDATA:2932                 test    ds:fbigfat, 60h ; fbig+fbigbig ; FAT16 or FAT32
BIOSDATA:2937                 jnz     short dobig
BIOSDATA:2939                 xor     bx, bx          ; 12 bit fat (FAT12 fs)
BIOSDATA:293B                 mov     bl, ch
BIOSDATA:293D                 dec     bx
BIOSDATA:293E                 add     bx, ax
BIOSDATA:2940                 shr     bx, cl
BIOSDATA:2942                 inc     bx              ; bx = 1+(bpb->maxsec+BDS.secperclus-1)
BIOSDATA:2942                                         ;      / BDS.secperclus
BIOSDATA:2943                 and     bl, 0FEh        ; bx &= ~1; (=number of clusters)
BIOSDATA:2946                 mov     si, bx
BIOSDATA:2948                 shr     bx, 1
BIOSDATA:294A                 add     bx, si          ; number of FAT bytes
BIOSDATA:294C                 add     bx, 511         ; bx += 511 + bx/2
BIOSDATA:2950                 shr     bh, 1           ; bh >>= 1; (=bx/512)
BIOSDATA:2952                 mov     [di+11h], bh    ; [di+BDS.fatsecs]
BIOSDATA:2952                                         ; save number of fat sectors
BIOSDATA:2955                 jmp     short massage_bpb
BIOSDATA:2957 ; ---------------------------------------------------------------------------
BIOSDATA:2957
BIOSDATA:2957 dobig:                                  ; CODE XREF: copybpb_fat+141↑j
BIOSDATA:2957                 mov     cl, 4           ; 16 (2^4) directory entries per sector
BIOSDATA:2959                 push    dx              ; save total sectors (high)
BIOSDATA:295A                 mov     dx, [di+0Ch]    ; [di+BDS.direntries]
BIOSDATA:295D                 shr     dx, cl          ; root dir sectors = BDS.direntries / 16;
BIOSDATA:295F                 sub     ax, dx
BIOSDATA:2961                 pop     dx              ; restore total sectors (high)
BIOSDATA:2962                 sbb     dx, 0           ; dx:ax = total sectors - root dir sectors
BIOSDATA:2965                 sub     ax, 1           ; - reserved sectors (1 for FAT16 fs)
BIOSDATA:2968                 sbb     dx, 0           ; dx:ax = t - r - d
BIOSDATA:2968                                         ; total secs - reserved secs - root dir secs
BIOSDATA:296B                 mov     bl, 2
BIOSDATA:296D                 mov     bh, [di+8]      ; [di+BDS.secperclus]
BIOSDATA:296D                                         ; bx = 256 * BDS.secperclus + 2
BIOSDATA:296D                                         ;
BIOSDATA:296D                                         ; ; 29/12/2018 - Erdogan Tan (Retro DOS v4.0)
BIOSDATA:296D                                         ; ; 27/09/2022
BIOSDATA:296D                                         ; ; (Microsoft FAT32 File System Specification,
BIOSDATA:296D                                         ; ; December 2000, Page 21)
BIOSDATA:296D                                         ; ; TmpVal1 = DskSize - (BPB_ResvdSecCnt+RootrDirSectors)
BIOSDATA:296D                                         ; ; TmpVal2 = (256*BPB_SecPerClus)+BPB_NumFATs
BIOSDATA:296D                                         ; ; 8/8/2023 (Retro DOS v5.0)
BIOSDATA:296D                                         ; ; If(FATType == FAT32)
BIOSDATA:296D                                         ; ;   TmpVal2 = TmpVal2 / 2;
BIOSDATA:296D                                         ; ; FATsz = (TmpVal1+(TmpVal2-1))/TmpVal2
BIOSDATA:296D                                         ; ; 8/8/2023 (Retro DOS v5.0)
BIOSDATA:296D                                         ; ; If(FATType == FAT32) {
BIOSDATA:296D                                         ; ;   BPB_FATSz16 = 0;
BIOSDATA:296D                                         ; ;   BPB_FATSz32 = FATSz;
BIOSDATA:296D                                         ; ;} else {
BIOSDATA:296D                                         ; ;   BPB_FATSz16 = LOWORD(FATSz);
BIOSDATA:296D                                         ; ;/* there is no BPB_FATSz32 in a FAT16 BPB */
BIOSDATA:296D                                         ; ;}
BIOSDATA:296D                                         ;
BIOSDATA:296D                                         ; dx:ax = TmpVal1, bx = TmpVal2
BIOSDATA:2970                 add     ax, bx
BIOSDATA:2972                 adc     dx, 0           ; dx:ax = TmpVal1+TmpVal2
BIOSDATA:2975                 sub     ax, 1
BIOSDATA:2978                 sbb     dx, 0           ; dx:ax = TmpVal1+TmpVal2-1
BIOSDATA:297B                 test    ds:fbigfat, 20h ; fbigbig (FAT32) flag
BIOSDATA:2980                 jz      short dobig1
BIOSDATA:2982                 shr     bx, 1           ; TmpVal2 = TmpVal2 / 2
BIOSDATA:2982                                         ; dx:ax = TmpVal1+(2*TmpVal2)-1
BIOSDATA:2984                 sub     ax, 31          ; reserved sectors = 32 (for FAT32 fs) /// 1+31 = 32
BIOSDATA:2987                 sbb     dx, 0
BIOSDATA:298A                 sub     ax, bx
BIOSDATA:298C                 sbb     dx, 0           ; dx:ax = TmpVal1+(2*TmpVal2)-TmpVal2-1
BIOSDATA:298C                                         ;       = TmpVal1+(TmpVal2-1)
BIOSDATA:298F
BIOSDATA:298F dobig1:                                 ; CODE XREF: copybpb_fat+18A↑j
BIOSDATA:298F                 push    ax              ; save lw of dividend
BIOSDATA:2990                 mov     ax, dx          ; divide hw of dx:ax at first (as 1st stage)
BIOSDATA:2992                 xor     dx, dx
BIOSDATA:2994                 div     bx              ; 32 bit division, dx:ax/bx
BIOSDATA:2994                                         ; remainder in dx is hw of 2nd stage dividend
BIOSDATA:2996                 mov     bp, ax          ; hw of quotient
BIOSDATA:2998                 pop     ax              ; restore lw of dividend (of 1st stage)
BIOSDATA:2999                 div     bx
BIOSDATA:299B                 mov     [di+11h], ax    ; [di+BDS.fatsecs] ; number of fat sectors
BIOSDATA:299B                                         ; lw of quotient
BIOSDATA:299E                 mov     bl, ds:fbigfat
BIOSDATA:29A2                 mov     [di+3Bh], bl    ; [di+BDS.fatsiz] ; fat size flag
BIOSDATA:29A5                 test    bl, 20h         ; fbigbig (FAT32) flag
BIOSDATA:29A8                 jz      short dobig2    ; not FAT32
BIOSDATA:29AA                 mov     [di+1Fh], ax    ; [di+BDS.fatsecs32]
BIOSDATA:29AD                 mov     [di+21h], bp    ; [di+BDS.fatsecs32+2]
BIOSDATA:29B0                 mov     word ptr [di+11h], 0 ; [di+BDS.fatsecs] = 0
BIOSDATA:29B0                                         ; clear 16 bit FAT size field
BIOSDATA:29B5                 mov     word ptr [di+9], 32 ; [di+BDS.resectors]
BIOSDATA:29B5                                         ; set reserved sectors to 32 (FAT32 de facto)
BIOSDATA:29BA
BIOSDATA:29BA dobig2:                                 ; CODE XREF: copybpb_fat+1B2↑j
BIOSDATA:29BA                 push    ds              ; set the default filesys_id,
BIOSDATA:29BA                                         ;     volume label, serial number
BIOSDATA:29BB                 push    ds
BIOSDATA:29BC                 pop     es
BIOSDATA:29BD                 push    cs
BIOSDATA:29BE                 pop     ds
BIOSDATA:29BF                 assume ds:BIOSDATA
BIOSDATA:29BF                 mov     bp, offset clear_ids
BIOSDATA:29C2                 push    cs
BIOSDATA:29C3                 call    call_bios_code
BIOSDATA:29C6                 pop     ds
BIOSDATA:29C7                 assume ds:nothing
BIOSDATA:29C7
BIOSDATA:29C7 massage_bpb:                            ; CODE XREF: copybpb_fat+F6↑j
BIOSDATA:29C7                                         ; copybpb_fat+15F↑j
BIOSDATA:29C7                 mov     dx, [di+1Dh]    ; [di+BDS.totalsecs32+2]
BIOSDATA:29CA                 mov     ax, [di+1Bh]    ; [di+BDS.totalsecs32]
BIOSDATA:29CD                 cmp     dx, 0
BIOSDATA:29D0                 ja      short goodret
BIOSDATA:29D2                 cmp     word ptr [di+19h], 0 ; [di+BDS.hiddensecs+2]
BIOSDATA:29D6                 ja      short goodret
BIOSDATA:29D8                 add     ax, [di+17h]    ; [di+BDS.hiddensecs]
BIOSDATA:29DB                 jb      short goodret
BIOSDATA:29DD                 mov     ax, [di+1Bh]    ; [di+BDS.totalsecs32]
BIOSDATA:29E0                 mov     [di+0Eh], ax    ; [di+BDS.totalsecs16]
BIOSDATA:29E3                 mov     word ptr [di+1Bh], 0
BIOSDATA:29E8
BIOSDATA:29E8 goodret:                                ; CODE XREF: sethard+30A↑j
BIOSDATA:29E8                                         ; copybpb_fat+FF↑j ...
BIOSDATA:29E8                 mov     bl, ds:fbigfat
BIOSDATA:29EC                 mov     [di+3Bh], bl    ; [di+BDS.fatsiz]
BIOSDATA:29EC                                         ; set size of fat on media
BIOSDATA:29EF                 clc
BIOSDATA:29F0
BIOSDATA:29F0 ret_hard_err:                           ; CODE XREF: sethard+CA↑j
BIOSDATA:29F0                 pop     es
BIOSDATA:29F1                 pop     ds
BIOSDATA:29F2                 pop     bx
BIOSDATA:29F3                 pop     di
BIOSDATA:29F4                 retn
BIOSDATA:29F4 copybpb_fat     endp ; sp-analysis failed
BIOSDATA:29F4
BIOSDATA:29F5
BIOSDATA:29F5 ; =============== S U B R O U T I N E =======================================
BIOSDATA:29F5
BIOSDATA:29F5
BIOSDATA:29F5 cover_fdisk_bug proc near               ; CODE XREF: sethard:try5↑p
BIOSDATA:29F5                 push    ax              ; fdisk of pc dos 3.3 and below, os2 1.0 has a bug.
BIOSDATA:29F5                                         ; the maximum number of sector that can be handled by pc dos 3.3
BIOSDATA:29F5                                         ; ibmbio should be 0ffffh. instead, sometimes fdisk use 10000h to
BIOSDATA:29F5                                         ; calculate the maximum number. so, we are going to check that if
BIOSDATA:29F5                                         ; BPB_TOTALSECTORS + hidden sector = 10000h then subtract 1 from
BIOSDATA:29F5                                         ; BPB_TOTALSECTORS.
BIOSDATA:29F6                 push    dx
BIOSDATA:29F7                 push    si
BIOSDATA:29F8                 cmp     word ptr cs:disksector+16h, 0 ; BPB_FATSz16
BIOSDATA:29FE                 jz      short cfb_retit ; FAT32 boot sector
BIOSDATA:2A00                 cmp     cs:disksector+26h, 29h ; ')' ;
BIOSDATA:2A00                                         ; [disksector+EXT_BOOT.SIG], EXT_BOOT_SIGNATURE
BIOSDATA:2A06                 jz      short cfb_retit ; if extended bpb, then >= pc dos 4.00
BIOSDATA:2A08                 cmp     word ptr cs:[bx+7], 3031h ; '10' ; os2 1.0 = ibm 10.0
BIOSDATA:2A0E                 jnz     short cfb_chk_totalsecs
BIOSDATA:2A10                 cmp     byte ptr cs:[bx+0Ah], 30h ; '0'
BIOSDATA:2A15                 jnz     short cfb_retit
BIOSDATA:2A17
BIOSDATA:2A17 cfb_chk_totalsecs:                      ; CODE XREF: cover_fdisk_bug+19↑j
BIOSDATA:2A17                 mov     si, (offset disksector+0Bh) ; 15Dh
BIOSDATA:2A17                                         ; disksector+EXT_BOOT.BPB
BIOSDATA:2A1A                 cmp     word ptr cs:[si+8], 0 ; [cs:si+EBPB.TOTALSECTORS]
BIOSDATA:2A1F                 jz      short cfb_retit ; just to make sure.
BIOSDATA:2A21                 mov     ax, cs:[si+8]
BIOSDATA:2A25                 add     ax, cs:[si+11h] ; [cs:si+EBPB.HIDDENSECTORS]
BIOSDATA:2A29                 jnb     short cfb_retit
BIOSDATA:2A2B                 jnz     short cfb_retit ;
BIOSDATA:2A2B                                         ; if carry set and ax=0
BIOSDATA:2A2D                 dec     word ptr cs:[si+8] ; then decrease BPB_TOTALSECTORS by 1
BIOSDATA:2A31                 sub     word ptr [di+1Bh], 1 ; [di+BDS.totalsecs32]
BIOSDATA:2A35                 sbb     word ptr [di+1Dh], 0 ; [di+BDS.totalsecs32+2]
BIOSDATA:2A39
BIOSDATA:2A39 cfb_retit:                              ; CODE XREF: cover_fdisk_bug+9↑j
BIOSDATA:2A39                                         ; cover_fdisk_bug+11↑j ...
BIOSDATA:2A39                 pop     si
BIOSDATA:2A3A                 pop     dx
BIOSDATA:2A3B                 pop     ax
BIOSDATA:2A3C                 retn
BIOSDATA:2A3C cover_fdisk_bug endp
BIOSDATA:2A3C
BIOSDATA:2A3C ; ---------------------------------------------------------------------------
BIOSDATA:2A3D word2           dw 2                    ; DATA XREF: setdrvparms+8C↓r
BIOSDATA:2A3F word3           dw 3                    ; DATA XREF: setdrvparms+87↓r
BIOSDATA:2A41 word512         dw 200h                 ; DATA XREF: setdrvparms+93↓r
BIOSDATA:2A43
BIOSDATA:2A43 ; =============== S U B R O U T I N E =======================================
BIOSDATA:2A43
BIOSDATA:2A43
BIOSDATA:2A43 setdrvparms     proc near               ; CODE XREF: BIOSDATA:245C↑p
BIOSDATA:2A43                 xor     bx, bx          ; setdrvparms sets up the recommended bpb in each bds
BIOSDATA:2A43                                         ; in the system based on the form factor.
BIOSDATA:2A43                                         ; it is assumed that the bpbs for the various form factors
BIOSDATA:2A43                                         ; are present in the bpbtable. for hard files,
BIOSDATA:2A43                                         ; the recommended bpb is the same as the bpb on the drive.
BIOSDATA:2A45                 les     di, dword ptr ds:start_bds ; get first bds in list
BIOSDATA:2A49
BIOSDATA:2A49 _next_bds:                              ; CODE XREF: setdrvparms+B7↓j
BIOSDATA:2A49                 push    es
BIOSDATA:2A4A                 push    di
BIOSDATA:2A4B                 mov     bl, es:[di+3Eh] ; [es:di+BDS.formfactor]
BIOSDATA:2A4F                 cmp     bl, 5           ; ffHardFile
BIOSDATA:2A52                 jnz     short nothardff
BIOSDATA:2A54                 xor     dx, dx
BIOSDATA:2A56                 mov     ax, es:[di+0Eh] ; [es:di+BDS.totalsecs16]
BIOSDATA:2A5A                 or      ax, ax
BIOSDATA:2A5C                 jnz     short get_ccyl
BIOSDATA:2A5E                 mov     dx, es:[di+1Dh] ; [es:di+BDS.totalsecs32+2]
BIOSDATA:2A62                 mov     ax, es:[di+1Bh] ; [es:di+BDS.totalsecs32]
BIOSDATA:2A66
BIOSDATA:2A66 get_ccyl:                               ; CODE XREF: setdrvparms+19↑j
BIOSDATA:2A66                 push    dx
BIOSDATA:2A67                 push    ax
BIOSDATA:2A68                 mov     ax, es:[di+15h] ; [es:di+BDS.heads]
BIOSDATA:2A6C                 mul     word ptr es:[di+13h] ; [es:di+BDS.secpertrack]
BIOSDATA:2A6C                                         ; assume sectors per cyl. < 64k.
BIOSDATA:2A70                 mov     cx, ax          ; cx has # sectors per cylinder
BIOSDATA:2A72                 pop     ax
BIOSDATA:2A73                 pop     dx              ; dx:ax = total sectors
BIOSDATA:2A74                 push    ax
BIOSDATA:2A75                 mov     ax, dx
BIOSDATA:2A77                 xor     dx, dx
BIOSDATA:2A79                 div     cx
BIOSDATA:2A7B                 mov     cs:saved_word, ax
BIOSDATA:2A7F                 pop     ax
BIOSDATA:2A80                 div     cx              ; div #sec by sec/cyl to get # cyl.
BIOSDATA:2A82                 or      dx, dx
BIOSDATA:2A84                 jz      short no_cyl_rnd
BIOSDATA:2A86                 inc     ax              ; round up
BIOSDATA:2A87
BIOSDATA:2A87 no_cyl_rnd:                             ; CODE XREF: setdrvparms+41↑j
BIOSDATA:2A87                 mov     es:[di+41h], ax ; [es:di+BDS.cylinders]
BIOSDATA:2A8B                 push    es
BIOSDATA:2A8C                 pop     ds
BIOSDATA:2A8D                 lea     si, [di+6]      ; [di+BDS.bytespersec]
BIOSDATA:2A8D                                         ; ds:si -> bpb for hard file
BIOSDATA:2A90                 jmp     short set_recbpb
BIOSDATA:2A92 ; ---------------------------------------------------------------------------
BIOSDATA:2A92
BIOSDATA:2A92 nothardff:                              ; CODE XREF: setdrvparms+F↑j
BIOSDATA:2A92                 push    cs
BIOSDATA:2A93                 pop     ds              ; if fake floppy drive variable is set
BIOSDATA:2A93                                         ; then we don't have to handle this bds.
BIOSDATA:2A93                                         ; we can just go and deal with the next bds
BIOSDATA:2A93                                         ; at label go_to_next_bds.
BIOSDATA:2A94                 assume ds:BIOSDATA
BIOSDATA:2A94                 cmp     cs:fakefloppydrv, 1
BIOSDATA:2A9A                 jz      short go_to_next_bds
BIOSDATA:2A9C                 cmp     bl, 7           ; ffother
BIOSDATA:2A9C                                         ; special case "other" type of medium
BIOSDATA:2A9F                 jnz     short not_process_other
BIOSDATA:2AA1                 xor     dx, dx
BIOSDATA:2AA3                 mov     ax, [di+41h]    ; [di+BDS.cylinders]
BIOSDATA:2AA6                 mul     word ptr [di+52h] ; [di+BDS.rheads]
BIOSDATA:2AA9                 mul     word ptr [di+50h] ; [di+BDS.rsecpertrack]
BIOSDATA:2AAC                 mov     [di+4Bh], ax    ; [di+BDS.rtotalsecs16]
BIOSDATA:2AAC                                         ; have the total number of sectors
BIOSDATA:2AAF                 dec     ax
BIOSDATA:2AB0                 mov     dl, 1
BIOSDATA:2AB2
BIOSDATA:2AB2 _again:                                 ; CODE XREF: setdrvparms+78↓j
BIOSDATA:2AB2                 cmp     ax, 0FF6h       ; 4096-10
BIOSDATA:2AB5                 jb      short _@@
BIOSDATA:2AB7                 shr     ax, 1
BIOSDATA:2AB9                 shl     dl, 1
BIOSDATA:2ABB                 jmp     short _again
BIOSDATA:2ABD ; ---------------------------------------------------------------------------
BIOSDATA:2ABD
BIOSDATA:2ABD _@@:                                    ; CODE XREF: setdrvparms+72↑j
BIOSDATA:2ABD                 cmp     dl, 1           ; is it a small disk ?
BIOSDATA:2AC0                 jz      short __@@      ; yes, 224 root entries is enuf
BIOSDATA:2AC2                 mov     word ptr [di+49h], 240 ; [di+BDS.rdirentries]
BIOSDATA:2AC7
BIOSDATA:2AC7 __@@:                                   ; CODE XREF: setdrvparms+7D↑j
BIOSDATA:2AC7                 mov     [di+45h], dl    ; [di+BDS.rsecperclus]
BIOSDATA:2ACA                 mul     cs:word3        ; * 3
BIOSDATA:2ACF                 div     cs:word2        ; / 2
BIOSDATA:2AD4                 xor     dx, dx
BIOSDATA:2AD6                 div     cs:word512      ; / 512
BIOSDATA:2ADB                 inc     ax              ; + 1
BIOSDATA:2ADC                 mov     [di+4Eh], ax    ; [di+BDS.rfatsecs]
BIOSDATA:2ADF                 jmp     short go_to_next_bds
BIOSDATA:2AE1 ; ---------------------------------------------------------------------------
BIOSDATA:2AE1
BIOSDATA:2AE1 not_process_other:                      ; CODE XREF: setdrvparms+5C↑j
BIOSDATA:2AE1                 shl     bx, 1           ; bx is word index into table of bpbs
BIOSDATA:2AE3                 mov     si, offset bpbtable
BIOSDATA:2AE6                 mov     si, [bx+si]     ; get address of bpb
BIOSDATA:2AE8
BIOSDATA:2AE8 set_recbpb:                             ; CODE XREF: setdrvparms+4D↑j
BIOSDATA:2AE8                 lea     di, [di+43h]    ; [di+BDS.R_BPB]
BIOSDATA:2AE8                                         ; es:di -> recbpb
BIOSDATA:2AEB                 mov     cx, 53          ; bpbx.size
BIOSDATA:2AEE                 rep movsb               ; move (size bpbx) bytes
BIOSDATA:2AF0
BIOSDATA:2AF0 go_to_next_bds:                         ; CODE XREF: setdrvparms+57↑j
BIOSDATA:2AF0                                         ; setdrvparms+9C↑j
BIOSDATA:2AF0                 pop     di
BIOSDATA:2AF1                 pop     es              ; restore pointer to bds
BIOSDATA:2AF2                 les     di, es:[di]     ; [es:di+BDS.link]
BIOSDATA:2AF5                 cmp     di, 0FFFFh      ; -1
BIOSDATA:2AF8                 jz      short got_end_of_bds_chain
BIOSDATA:2AFA                 jmp     _next_bds
BIOSDATA:2AFD ; ---------------------------------------------------------------------------
BIOSDATA:2AFD
BIOSDATA:2AFD got_end_of_bds_chain:                   ; CODE XREF: setdrvparms+B5↑j
BIOSDATA:2AFD                 retn
BIOSDATA:2AFD setdrvparms     endp
BIOSDATA:2AFD
BIOSDATA:2AFE
BIOSDATA:2AFE ; =============== S U B R O U T I N E =======================================
BIOSDATA:2AFE
BIOSDATA:2AFE
BIOSDATA:2AFE print_init      proc near               ; CODE XREF: BIOSDATA:1EBE↑p
BIOSDATA:2AFE                                         ; BIOSDATA:1EC3↑p ...
BIOSDATA:2AFE                 cbw
BIOSDATA:2AFF                 mov     dx, ax
BIOSDATA:2B01                 mov     ah, 1
BIOSDATA:2B03                 int     17h             ; PRINTER - INITIALIZE
BIOSDATA:2B03                                         ; DX = printer port (0-3)
BIOSDATA:2B03                                         ; Return: AH = status
BIOSDATA:2B05                 retn
BIOSDATA:2B05 print_init      endp
BIOSDATA:2B05
BIOSDATA:2B06
BIOSDATA:2B06 ; =============== S U B R O U T I N E =======================================
BIOSDATA:2B06
BIOSDATA:2B06
BIOSDATA:2B06 aux_init        proc near               ; CODE XREF: BIOSDATA:1EAA↑p
BIOSDATA:2B06                                         ; BIOSDATA:1EAF↑p ...
BIOSDATA:2B06                 cbw
BIOSDATA:2B07                 mov     dx, ax
BIOSDATA:2B09                 mov     al, 0A3h        ; RSINIT ; 0A3h
BIOSDATA:2B09                                         ; 2400,n,1,8 (msequ.inc)
BIOSDATA:2B0B                 mov     ah, 0
BIOSDATA:2B0D                 int     14h             ; SERIAL I/O - INITIALIZE USART
BIOSDATA:2B0D                                         ; AL = initializing parameters, DX = port number (0-3)
BIOSDATA:2B0D                                         ; Return: AH = RS-232 status code bits, AL = modem status bits
BIOSDATA:2B0F                 retn
BIOSDATA:2B0F aux_init        endp
BIOSDATA:2B0F
BIOSDATA:2B10
BIOSDATA:2B10 ; =============== S U B R O U T I N E =======================================
BIOSDATA:2B10
BIOSDATA:2B10
BIOSDATA:2B10 domini          proc near               ; CODE XREF: BIOSDATA:2215↑p
BIOSDATA:2B10                 mov     dh, hnum        ; mini disk initialization routine
BIOSDATA:2B10                                         ; get number of hardfiles
BIOSDATA:2B14                 cmp     dh, 0
BIOSDATA:2B17                 jz      short dominiret ; no hard file? then exit.
BIOSDATA:2B19                 mov     dl, 80h         ; start with hardfile 80h
BIOSDATA:2B1B
BIOSDATA:2B1B domini_loop:                            ; CODE XREF: domini+49↓j
BIOSDATA:2B1B                 xor     ax, ax
BIOSDATA:2B1D                 mov     cs:ep_start_sector, ax
BIOSDATA:2B21                 mov     cs:ep_start_sector+2, ax
BIOSDATA:2B25                 mov     cs:ep_hidden_secs, ax
BIOSDATA:2B29                 mov     cs:ep_hidden_secs+2, ax
BIOSDATA:2B2D                 push    dx
BIOSDATA:2B2E                 mov     rom_minidisk_num, dl
BIOSDATA:2B32                 mov     ah, 8
BIOSDATA:2B34                 int     13h             ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
BIOSDATA:2B34                                         ; DL = drive number
BIOSDATA:2B34                                         ; Return: CF set on error, AH = status code, BL = drive type
BIOSDATA:2B34                                         ; DL = number of consecutive drives
BIOSDATA:2B34                                         ; DH = maximum value for head number, ES:DI -> drive parameter
BIOSDATA:2B36                 xor     ax, ax
BIOSDATA:2B38                 mov     al, dh          ; <= 255
BIOSDATA:2B3A                 inc     ax              ; (0FFh -> 100h)
BIOSDATA:2B3B                 mov     mini_hdlim, ax  ; # of heads
BIOSDATA:2B3E                 mov     al, cl
BIOSDATA:2B40                 and     ax, 3Fh
BIOSDATA:2B43                 mov     mini_seclim, ax ; # of sectors/track
BIOSDATA:2B46                 push    es
BIOSDATA:2B47                 mov     dl, rom_minidisk_num
BIOSDATA:2B4B                 call    getboot         ; read master boot record into
BIOSDATA:2B4B                                         ; initbootsegment:bootbias
BIOSDATA:2B4E                 jb      short domininext
BIOSDATA:2B50                 call    find_mini_partition
BIOSDATA:2B53
BIOSDATA:2B53 domininext:                             ; CODE XREF: domini+3E↑j
BIOSDATA:2B53                 pop     es
BIOSDATA:2B54                 pop     dx
BIOSDATA:2B55                 inc     dl              ; next hard file
BIOSDATA:2B57                 dec     dh
BIOSDATA:2B59                 jnz     short domini_loop
BIOSDATA:2B5B
BIOSDATA:2B5B dominiret:                              ; CODE XREF: domini+7↑j
BIOSDATA:2B5B                 retn
BIOSDATA:2B5B domini          endp
BIOSDATA:2B5B
BIOSDATA:2B5C
BIOSDATA:2B5C ; =============== S U B R O U T I N E =======================================
BIOSDATA:2B5C
BIOSDATA:2B5C
BIOSDATA:2B5C find_mini_partition proc near           ; CODE XREF: domini+40↑p
BIOSDATA:2B5C                 add     bx, 1C2h        ; tries to find every extended partition on a disk
BIOSDATA:2B5C                                         ; bx -> file system id
BIOSDATA:2B60                 mov     ld_p_number, 26
BIOSDATA:2B66
BIOSDATA:2B66 fmpnext:                                ; CODE XREF: find_mini_partition+2A↓j
BIOSDATA:2B66                                         ; find_mini_partition:fmpnextchain↓j
BIOSDATA:2B66                 add     ld_p_number, 16
BIOSDATA:2B6B                 cmp     ld_p_number, 4122 ; 64 logical disk partitions (64 EBRs)
BIOSDATA:2B6B                                         ; (64*4 = 256 pte's, 256*16 = 4096, + 26 = 4122)
BIOSDATA:2B71                 jg      short fmpnextfound
BIOSDATA:2B73                 cmp     byte ptr es:[bx], 5 ; Extended DOS CHS
BIOSDATA:2B77                 jz      short fmpgot
BIOSDATA:2B79                 cmp     byte ptr es:[bx], 0Fh ; Extended DOS LBA
BIOSDATA:2B7D                 jz      short fmpgot
BIOSDATA:2B7F                 add     bx, 16
BIOSDATA:2B82                 cmp     bx, 402h        ; 202h+bootbias
BIOSDATA:2B86                 jnz     short fmpnext
BIOSDATA:2B88
BIOSDATA:2B88 fmpnextfound:                           ; CODE XREF: find_mini_partition+15↑j
BIOSDATA:2B88                                         ; find_mini_partition+32↓j ...
BIOSDATA:2B88                 jmp     _fmpnextfound   ; extended partition not found
BIOSDATA:2B8B ; ---------------------------------------------------------------------------
BIOSDATA:2B8B
BIOSDATA:2B8B fmpgot:                                 ; CODE XREF: find_mini_partition+1B↑j
BIOSDATA:2B8B                                         ; find_mini_partition+21↑j
BIOSDATA:2B8B                 call    dmax_check      ; check for drvmax already 26
BIOSDATA:2B8E                 jnb     short fmpnextfound ; done if too many
BIOSDATA:2B90                 mov     di, end_of_bdss ; get next free bds
BIOSDATA:2B94                 mov     word ptr [di+79h], 1 ; [di+BDS.bdsm_ismini]
BIOSDATA:2B99                 or      byte ptr [di+3Fh], 1 ; [di+BDS.flags],fNon_Removable
BIOSDATA:2B9D                 mov     byte ptr [di+3Eh], 5 ; [di+BDS.formfactor],ffHardFile
BIOSDATA:2BA1                 mov     fbigfat, 0      ; assume 12 bit fat.
BIOSDATA:2BA6                 mov     ax, mini_hdlim
BIOSDATA:2BA9                 mov     [di+15h], ax    ; [di+BDS.heads]
BIOSDATA:2BAC                 mov     ax, mini_seclim
BIOSDATA:2BAF                 mov     [di+13h], ax    ; [di+BDS.secpertrack]
BIOSDATA:2BB2                 mov     al, rom_minidisk_num
BIOSDATA:2BB5                 mov     [di+4], al      ; [di+BDS.drivenum] ; set physical number
BIOSDATA:2BB8                 mov     al, drvmax
BIOSDATA:2BBB                 mov     [di+5], al      ; [di+BDS.drivelet] ; set logical number
BIOSDATA:2BBE                 cmp     word ptr es:[bx+10], 0
BIOSDATA:2BC3                 ja      short fmpgot1
BIOSDATA:2BC5                 cmp     word ptr es:[bx+8], 64 ; minimum 64 sectors
BIOSDATA:2BCA                 jb      short fmpnextfound
BIOSDATA:2BCC
BIOSDATA:2BCC fmpgot1:                                ; CODE XREF: find_mini_partition+67↑j
BIOSDATA:2BCC                 sub     bx, 4           ; let bx point to the start of the entry
BIOSDATA:2BCF                 mov     dh, es:[bx+2]   ; cylinder
BIOSDATA:2BD3                 and     dh, 0C0h        ; get higher bits of cyl
BIOSDATA:2BD6                 rol     dh, 1
BIOSDATA:2BD8                 rol     dh, 1
BIOSDATA:2BDA                 mov     dl, es:[bx+3]   ; cyl byte
BIOSDATA:2BDE                 mov     [di+7Bh], dx    ; [di+BDS.bdsm_hidden_trks] ; set hidden trks
BIOSDATA:2BE1                 push    bx
BIOSDATA:2BE2                 mov     cx, es:[bx+8]   ; partition size, lw
BIOSDATA:2BE6                 mov     ax, es:[bx+10]  ; partition size, hw
BIOSDATA:2BEA                 add     cx, ep_start_sector
BIOSDATA:2BEE                 adc     ax, ep_start_sector+2
BIOSDATA:2BF2                 cmp     ep_start_sector, 0
BIOSDATA:2BF7                 jnz     short fmpgot2
BIOSDATA:2BF9                 cmp     ep_start_sector+2, 0
BIOSDATA:2BFE                 jnz     short fmpgot2
BIOSDATA:2C00                 mov     ep_start_sector, cx
BIOSDATA:2C04                 mov     ep_start_sector+2, ax
BIOSDATA:2C07
BIOSDATA:2C07 fmpgot2:                                ; CODE XREF: find_mini_partition+9B↑j
BIOSDATA:2C07                                         ; find_mini_partition+A2↑j
BIOSDATA:2C07                 mov     ep_hidden_secs, cx
BIOSDATA:2C0B                 mov     ep_hidden_secs+2, ax ;
BIOSDATA:2C0B                                         ; convert start sector address to CHS
BIOSDATA:2C0E                 mov     bx, [di+13h]    ; [di+BDS.secpertrack]
BIOSDATA:2C11                 xor     dx, dx
BIOSDATA:2C13                 div     bx
BIOSDATA:2C15                 xchg    ax, cx
BIOSDATA:2C16                 div     bx
BIOSDATA:2C18                 mov     bx, [di+15h]    ; [di+BDS.heads]
BIOSDATA:2C1B                 xchg    ax, cx
BIOSDATA:2C1C                 xor     dx, dx
BIOSDATA:2C1E                 div     bx
BIOSDATA:2C20                 xchg    ax, cx
BIOSDATA:2C21                 div     bx
BIOSDATA:2C23                 pop     bx
BIOSDATA:2C24                 or      cx, cx
BIOSDATA:2C26                 jnz     short fmpgot_lba_rd
BIOSDATA:2C28                 cmp     ax, 1024        ; cylinder number < 1024, CHS read is proper
BIOSDATA:2C2B                 jb      short fmpgot_chs_rd
BIOSDATA:2C2D
BIOSDATA:2C2D fmpgot_lba_rd:                          ; CODE XREF: find_mini_partition+CA↑j
BIOSDATA:2C2D                 or      byte ptr [di+40h], 4 ; set fLBArw flag ; LBA read/write ok/ready
BIOSDATA:2C31                 mov     dl, rom_minidisk_num
BIOSDATA:2C35                 push    ds
BIOSDATA:2C36                 push    si
BIOSDATA:2C37                 xor     ax, ax          ; push bp
BIOSDATA:2C37                                         ; mov bp, sp ; (*)
BIOSDATA:2C39                 push    ax              ; 0
BIOSDATA:2C3A                 push    ax              ; 0
BIOSDATA:2C3B                 push    ep_hidden_secs+2
BIOSDATA:2C3F                 push    ep_hidden_secs
BIOSDATA:2C43                 mov     ax, 200h        ; bootbias (buffer offset)
BIOSDATA:2C46                 push    es              ; buffer segment
BIOSDATA:2C47                 push    ax
BIOSDATA:2C48                 mov     ax, 1
BIOSDATA:2C4B                 push    ax              ; read count
BIOSDATA:2C4C                 mov     ax, 10h         ; DAP size = 16
BIOSDATA:2C4F                 push    ax
BIOSDATA:2C50                 mov     ax, ss
BIOSDATA:2C52                 mov     ds, ax
BIOSDATA:2C54                 assume ds:nothing
BIOSDATA:2C54                 mov     si, sp          ; ds:si = Disk Address Packet
BIOSDATA:2C56                 mov     ah, 42h         ; LBA read
BIOSDATA:2C58                 int     13h             ; DISK - IBM/MS Extension
BIOSDATA:2C58                                         ; EXTENDED READ (DL - drive, DS:SI - disk address packet)
BIOSDATA:2C5A                 pushf                   ; BUG! Erdogan Tan - 08/08/2023
BIOSDATA:2C5B                 add     sp, 16
BIOSDATA:2C5E                 popf                    ; BUG!
BIOSDATA:2C5E                                         ; mov sp, bp ; (*)
BIOSDATA:2C5E                                         ; pop bp
BIOSDATA:2C5F                 pop     si
BIOSDATA:2C60                 pop     ds
BIOSDATA:2C61                 assume ds:nothing
BIOSDATA:2C61                 jmp     short fmpgot3
BIOSDATA:2C63 ; ---------------------------------------------------------------------------
BIOSDATA:2C63
BIOSDATA:2C63 fmpgot_chs_rd:                          ; CODE XREF: find_mini_partition+CF↑j
BIOSDATA:2C63                 mov     cx, es:[bx+2]   ; cylinder,cylinder/sector
BIOSDATA:2C67                 mov     dh, es:[bx+1]   ; head
BIOSDATA:2C6B                 mov     dl, ds:rom_minidisk_num
BIOSDATA:2C6F                 mov     bx, 200h        ; bootbias
BIOSDATA:2C72                 mov     ax, 201h
BIOSDATA:2C75                 int     13h             ; DISK - READ SECTORS INTO MEMORY
BIOSDATA:2C75                                         ; AL = number of sectors to read, CH = track, CL = sector
BIOSDATA:2C75                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
BIOSDATA:2C75                                         ; Return: CF set on error, AH = status, AL = number of sectors read
BIOSDATA:2C77
BIOSDATA:2C77 fmpgot3:                                ; CODE XREF: find_mini_partition+105↑j
BIOSDATA:2C77                 jb      short _fmpnextfound
BIOSDATA:2C79                 mov     bx, 3C2h        ; 1C2h+bootbias
BIOSDATA:2C7C                 cmp     word ptr es:[bx+3Ch], 0AA55h ; 03C2h+03Ch = 3FEh
BIOSDATA:2C82                 jnz     short _fmpnextfound ; not a valid boot sector !
BIOSDATA:2C84                 push    es
BIOSDATA:2C85                 call    setmini         ; install a mini disk.
BIOSDATA:2C85                                         ; bx value saved.
BIOSDATA:2C88                 pop     es
BIOSDATA:2C89                 jb      short fmpnextchain
BIOSDATA:2C8B                 call    xinstall_bds    ; -- install the bdsm into table
BIOSDATA:2C8E
BIOSDATA:2C8E fmpnextchain:                           ; CODE XREF: find_mini_partition+12D↑j
BIOSDATA:2C8E                 jmp     fmpnext
BIOSDATA:2C91 ; ---------------------------------------------------------------------------
BIOSDATA:2C91
BIOSDATA:2C91 _fmpnextfound:                          ; CODE XREF: find_mini_partition:fmpnextfound↑j
BIOSDATA:2C91                                         ; find_mini_partition:fmpgot3↑j ...
BIOSDATA:2C91                 retn
BIOSDATA:2C91 find_mini_partition endp
BIOSDATA:2C91
BIOSDATA:2C92
BIOSDATA:2C92 ; =============== S U B R O U T I N E =======================================
BIOSDATA:2C92
BIOSDATA:2C92
BIOSDATA:2C92 setmini         proc near               ; CODE XREF: find_mini_partition+129↑p
BIOSDATA:2C92                 push    di
BIOSDATA:2C93                 push    bx
BIOSDATA:2C94                 push    ds
BIOSDATA:2C95                 push    es
BIOSDATA:2C96
BIOSDATA:2C96 setmini_1:                              ; CODE XREF: setmini+2F↓j
BIOSDATA:2C96                 cmp     byte ptr es:[bx], 1 ; FAT12 partition
BIOSDATA:2C9A                 jz      short setmini_2
BIOSDATA:2C9C                 cmp     byte ptr es:[bx], 4 ; FAT16 (CHS) partition
BIOSDATA:2CA0                 jz      short setmini_2
BIOSDATA:2CA2                 cmp     byte ptr es:[bx], 6 ; FAT16 Big (CHS) partition
BIOSDATA:2CA6                 jz      short setmini_2
BIOSDATA:2CA8                 cmp     byte ptr es:[bx], 0Bh ; FAT32 (CHS) partition
BIOSDATA:2CAC                 jz      short setmini_2
BIOSDATA:2CAE                 cmp     byte ptr es:[bx], 0Ch ; FAT32 (LBA) partition
BIOSDATA:2CB2                 jz      short setmini_2
BIOSDATA:2CB4                 cmp     byte ptr es:[bx], 0Eh ; FAT16 (LBA) partition
BIOSDATA:2CB8                 jz      short setmini_2
BIOSDATA:2CBA                 add     bx, 16
BIOSDATA:2CBD                 cmp     bx, 402h        ; 202h+bootbias
BIOSDATA:2CC1                 jnz     short setmini_1
BIOSDATA:2CC3                 stc
BIOSDATA:2CC4                 pop     es
BIOSDATA:2CC5                 pop     ds
BIOSDATA:2CC6                 pop     bx
BIOSDATA:2CC7                 pop     di
BIOSDATA:2CC8                 retn
BIOSDATA:2CC9 ; ---------------------------------------------------------------------------
BIOSDATA:2CC9
BIOSDATA:2CC9 setmini_2:                              ; CODE XREF: setmini+8↑j
BIOSDATA:2CC9                                         ; setmini+E↑j ...
BIOSDATA:2CC9                 jmp     set2            ; branch into middle of sethard
BIOSDATA:2CC9 setmini         endp
BIOSDATA:2CC9
BIOSDATA:2CCC
BIOSDATA:2CCC ; =============== S U B R O U T I N E =======================================
BIOSDATA:2CCC
BIOSDATA:2CCC
BIOSDATA:2CCC dmax_check      proc near               ; CODE XREF: BIOSDATA:2206↑p
BIOSDATA:2CCC                                         ; BIOSDATA:222F↑p ...
BIOSDATA:2CCC                 cmp     ds:drvmax, 26   ; checks for drvmax < 26
BIOSDATA:2CD1                 jb      short dmax_ok   ; returns with carry if okay
BIOSDATA:2CD3                 push    es
BIOSDATA:2CD4                 mov     ax, 544h        ; SYSINIT segment
BIOSDATA:2CD7                 mov     es, ax
BIOSDATA:2CD9                 assume es:nothing
BIOSDATA:2CD9                 mov     es:toomanydrivesflag, 1
BIOSDATA:2CDF                 pop     es
BIOSDATA:2CE0                 assume es:nothing
BIOSDATA:2CE0
BIOSDATA:2CE0 dmax_ok:                                ; CODE XREF: dmax_check+5↑j
BIOSDATA:2CE0                 retn
BIOSDATA:2CE0 dmax_check      endp
BIOSDATA:2CE0
BIOSDATA:2CE1
BIOSDATA:2CE1 ; =============== S U B R O U T I N E =======================================
BIOSDATA:2CE1
BIOSDATA:2CE1
BIOSDATA:2CE1 xinstall_bds    proc near               ; CODE XREF: BIOSDATA:205A↑p
BIOSDATA:2CE1                                         ; BIOSDATA:220B↑p ...
BIOSDATA:2CE1                 push    si              ; link next bds (at ds:di) into the chain.
BIOSDATA:2CE1                                         ; assume that the chain is entirely within ds == datagrp.
BIOSDATA:2CE1                                         ; also update drvmax, dskdrv_table, and end_of_bdss.
BIOSDATA:2CE2                 push    bx
BIOSDATA:2CE3                 mov     si, ds:start_bds ; get first bds
BIOSDATA:2CE7
BIOSDATA:2CE7 xinstall_bds_1:                         ; CODE XREF: xinstall_bds+D↓j
BIOSDATA:2CE7                 cmp     word ptr [si], 0FFFFh ; is this the last one?
BIOSDATA:2CEA                 jz      short xinstall_bds_2
BIOSDATA:2CEC                 mov     si, [si]        ; [si+BDS.link] ; chain through list
BIOSDATA:2CEE                 jmp     short xinstall_bds_1
BIOSDATA:2CF0 ; ---------------------------------------------------------------------------
BIOSDATA:2CF0
BIOSDATA:2CF0 xinstall_bds_2:                         ; CODE XREF: xinstall_bds+9↑j
BIOSDATA:2CF0                 mov     [si], di        ; [si+BDS.link]
BIOSDATA:2CF2                 mov     word ptr [si+2], ds ; [si+BDS.link+2]
BIOSDATA:2CF5                 mov     word ptr [di], 0FFFFh ; -1 ; make sure it is a null ptr.
BIOSDATA:2CF9                 mov     word ptr [di+2], ds ; might as well plug segment
BIOSDATA:2CFC                 lea     bx, [di+6]      ; [di+BDS.BPB]
BIOSDATA:2CFF                 mov     si, ds:last_dskdrv_table
BIOSDATA:2D03                 mov     [si], bx
BIOSDATA:2D05                 add     ds:last_dskdrv_table, 2
BIOSDATA:2D0A                 inc     ds:drvmax
BIOSDATA:2D0E                 add     ds:end_of_bdss, 150 ; BDS.size = 150
BIOSDATA:2D14                 pop     bx
BIOSDATA:2D15                 pop     si
BIOSDATA:2D16                 retn
BIOSDATA:2D16 xinstall_bds    endp
BIOSDATA:2D16
BIOSDATA:2D17
BIOSDATA:2D17 ; =============== S U B R O U T I N E =======================================
BIOSDATA:2D17
BIOSDATA:2D17
BIOSDATA:2D17 cmos_clock_read proc near               ; CODE XREF: BIOSDATA:1FC9↑p
BIOSDATA:2D17                 push    ax
BIOSDATA:2D18                 push    cx
BIOSDATA:2D19                 push    dx
BIOSDATA:2D1A                 push    bp
BIOSDATA:2D1B                 xor     bp, bp
BIOSDATA:2D1D
BIOSDATA:2D1D loop_clock:                             ; CODE XREF: cmos_clock_read+23↓j
BIOSDATA:2D1D                 xor     cx, cx
BIOSDATA:2D1F                 xor     dx, dx
BIOSDATA:2D21                 mov     ah, 2
BIOSDATA:2D23                 int     1Ah             ; CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)
BIOSDATA:2D23                                         ; Return: CH = hours in BCD
BIOSDATA:2D23                                         ; CL = minutes in BCD
BIOSDATA:2D23                                         ; DH = seconds in BCD
BIOSDATA:2D25                 cmp     cx, 0
BIOSDATA:2D28                 jnz     short clock_present
BIOSDATA:2D2A                 cmp     dx, 0
BIOSDATA:2D2D                 jnz     short clock_present
BIOSDATA:2D2F                 cmp     bp, 1           ; read again after a slight delay, in case clock
BIOSDATA:2D32                 jz      short no_readdate ; was at zero setting.
BIOSDATA:2D34                 inc     bp              ; only perform delay once.
BIOSDATA:2D35                 mov     cx, 4000h       ; 16384
BIOSDATA:2D38
BIOSDATA:2D38 delay:                                  ; CODE XREF: cmos_clock_read:delay↓j
BIOSDATA:2D38                 loop    delay
BIOSDATA:2D3A                 jmp     short loop_clock
BIOSDATA:2D3C ; ---------------------------------------------------------------------------
BIOSDATA:2D3C
BIOSDATA:2D3C clock_present:                          ; CODE XREF: cmos_clock_read+11↑j
BIOSDATA:2D3C                                         ; cmos_clock_read+16↑j
BIOSDATA:2D3C                 mov     cs:havecmoscloc, 1 ; set the flag for cmos clock
BIOSDATA:2D42                 call    cmosck          ; reset cmos clock rate that may be
BIOSDATA:2D42                                         ; possibly destroyed by cp dos and
BIOSDATA:2D42                                         ; post routine did not restore that.
BIOSDATA:2D45                 push    si
BIOSDATA:2D46                 call    read_real_date  ; read real-time clock for date
BIOSDATA:2D49                 cli
BIOSDATA:2D4A                 mov     ds:daycnt, si   ; set system date
BIOSDATA:2D4E                 sti
BIOSDATA:2D4F                 pop     si
BIOSDATA:2D50
BIOSDATA:2D50 no_readdate:                            ; CODE XREF: cmos_clock_read+1B↑j
BIOSDATA:2D50                 pop     bp
BIOSDATA:2D51                 pop     dx
BIOSDATA:2D52                 pop     cx
BIOSDATA:2D53                 pop     ax
BIOSDATA:2D54                 retn
BIOSDATA:2D54 cmos_clock_read endp
BIOSDATA:2D54
BIOSDATA:2D55
BIOSDATA:2D55 ; =============== S U B R O U T I N E =======================================
BIOSDATA:2D55
BIOSDATA:2D55
BIOSDATA:2D55 cmosck          proc near               ; CODE XREF: cmos_clock_read+2B↑p
BIOSDATA:2D55                 push    ax              ; check and reset rtc rate bits
BIOSDATA:2D55                                         ;
BIOSDATA:2D55                                         ; the following code is written by jack gulley in engineering group.
BIOSDATA:2D55                                         ; cp dos (CP/DOS, OS/2) is changing cmos clock rate for its own purposes
BIOSDATA:2D55                                         ; and if the use cold boot the system to use pc dos while running cp dos,
BIOSDATA:2D55                                         ; the cmos clock rate are still slow which slow down disk operations
BIOSDATA:2D55                                         ; of pc dos which uses cmos clock. pc dos is put this code in msinit
BIOSDATA:2D55                                         ; to fix this problem at the request of cp dos.
BIOSDATA:2D56                 cmp     cs:model_byte, 0FCh
BIOSDATA:2D5C                 jnz     short cmosck9   ; Exit if not an AT model
BIOSDATA:2D5E                 cmp     cs:secondary_model_byte, 6 ; Is it 06 for the industral AT ?
BIOSDATA:2D64                 jz      short cmosck4   ; Go reset CMOS periodic rate if 06
BIOSDATA:2D66                 cmp     cs:secondary_model_byte, 4 ; Is it 00, 01, 02, or 03 ?
BIOSDATA:2D6C                 jnb     short cmosck9   ; EXIT if problem fixed by POST
BIOSDATA:2D6C                                         ; Also,Secondary_model_byte = 0
BIOSDATA:2D6C                                         ; when AH=0C0h, int 15h failed.
BIOSDATA:2D6C                                         ; RESET THE CMOS PERIODIC RATE
BIOSDATA:2D6C                                         ; Model=FC submodel=00,01,02,03 or 06
BIOSDATA:2D6E
BIOSDATA:2D6E cmosck4:                                ; CODE XREF: cmosck+F↑j
BIOSDATA:2D6E                 mov     al, 8Ah         ; cmos_reg_a|nmi
BIOSDATA:2D6E                                         ; NMI disabled on return
BIOSDATA:2D70                 mov     ah, 26h         ; 00100110b
BIOSDATA:2D70                                         ; Set divider & rate selection
BIOSDATA:2D72                 call    cmos_write
BIOSDATA:2D75                 mov     al, 8Bh         ; cmos_reg_b|nmi
BIOSDATA:2D75                                         ; NMI disabled on return
BIOSDATA:2D77                 call    cmos_read
BIOSDATA:2D7A                 and     al, 7           ; 00000111b
BIOSDATA:2D7A                                         ; clear SET,PIE,AIE,UIE,SQWE
BIOSDATA:2D7C                 mov     ah, al
BIOSDATA:2D7E                 mov     al, 0Bh         ; cmos_reg_b
BIOSDATA:2D7E                                         ; NMI enabled on return
BIOSDATA:2D80                 call    cmos_write
BIOSDATA:2D83
BIOSDATA:2D83 cmosck9:                                ; CODE XREF: cmosck+7↑j
BIOSDATA:2D83                                         ; cmosck+17↑j
BIOSDATA:2D83                 pop     ax
BIOSDATA:2D84                 retn
BIOSDATA:2D84 cmosck          endp
BIOSDATA:2D84
BIOSDATA:2D85
BIOSDATA:2D85 ; =============== S U B R O U T I N E =======================================
BIOSDATA:2D85
BIOSDATA:2D85
BIOSDATA:2D85 cmos_read       proc near               ; CODE XREF: cmosck+22↑p
BIOSDATA:2D85                 pushf                   ; read location (al) into (al)
BIOSDATA:2D85                                         ; bit 7 = 0 for nmi enabled and 1 for nmi disabled on exit
BIOSDATA:2D86                 cli
BIOSDATA:2D87                 push    bx
BIOSDATA:2D88                 push    ax
BIOSDATA:2D89                 or      al, 80h
BIOSDATA:2D8B                 out     70h, al         ; CMOS Memory/RTC Index Register:
BIOSDATA:2D8B                                         ; RTC Seconds
BIOSDATA:2D8D                 nop
BIOSDATA:2D8E                 in      al, 71h         ; CMOS Memory/RTC Data Register
BIOSDATA:2D90                 mov     bx, ax
BIOSDATA:2D92                 pop     ax
BIOSDATA:2D93                 and     al, 80h
BIOSDATA:2D95                 or      al, 0Fh
BIOSDATA:2D97                 out     70h, al         ; CMOS Memory/RTC Index Register:
BIOSDATA:2D97                                         ; RTC Seconds
BIOSDATA:2D99                 nop
BIOSDATA:2D9A                 in      al, 71h         ; CMOS Memory/RTC Data Register
BIOSDATA:2D9C                 mov     ax, bx
BIOSDATA:2D9E                 pop     bx
BIOSDATA:2D9F                 push    cs
BIOSDATA:2DA0                 call    near ptr cmos_popf
BIOSDATA:2DA3                 retn
BIOSDATA:2DA3 cmos_read       endp
BIOSDATA:2DA3
BIOSDATA:2DA4
BIOSDATA:2DA4 ; =============== S U B R O U T I N E =======================================
BIOSDATA:2DA4
BIOSDATA:2DA4
BIOSDATA:2DA4 cmos_popf       proc far                ; CODE XREF: cmos_read+1B↑p
BIOSDATA:2DA4                                         ; cmos_write+19↓p
BIOSDATA:2DA4                 iret                    ; popf for level b- parts
BIOSDATA:2DA4 cmos_popf       endp                    ; return far and restore flags
BIOSDATA:2DA4
BIOSDATA:2DA5
BIOSDATA:2DA5 ; =============== S U B R O U T I N E =======================================
BIOSDATA:2DA5
BIOSDATA:2DA5
BIOSDATA:2DA5 cmos_write      proc near               ; CODE XREF: cmosck+1D↑p
BIOSDATA:2DA5                                         ; cmosck+2B↑p
BIOSDATA:2DA5                 pushf                   ; write (ah) to location (al)
BIOSDATA:2DA5                                         ; bit 7 = 0 for nmi enabled and 1 for nmi disabled on exit
BIOSDATA:2DA6                 push    ax
BIOSDATA:2DA7                 cli
BIOSDATA:2DA8                 push    ax
BIOSDATA:2DA9                 or      al, 80h
BIOSDATA:2DAB                 out     70h, al         ; CMOS Memory/RTC Index Register:
BIOSDATA:2DAB                                         ; RTC Seconds
BIOSDATA:2DAD                 nop
BIOSDATA:2DAE                 mov     al, ah
BIOSDATA:2DB0                 out     71h, al         ; CMOS Memory/RTC Data Register
BIOSDATA:2DB2                 pop     ax
BIOSDATA:2DB3                 and     al, 80h
BIOSDATA:2DB5                 or      al, 0Fh
BIOSDATA:2DB7                 out     70h, al         ; CMOS Memory/RTC Index Register:
BIOSDATA:2DB7                                         ; RTC Seconds
BIOSDATA:2DB9                 nop
BIOSDATA:2DBA                 in      al, 71h         ; CMOS Memory/RTC Data Register
BIOSDATA:2DBC                 pop     ax
BIOSDATA:2DBD                 push    cs              ; *place code segment in stack and
BIOSDATA:2DBE                 call    near ptr cmos_popf ; *handle popf for b- level 80286
BIOSDATA:2DC1                 retn
BIOSDATA:2DC1 cmos_write      endp
BIOSDATA:2DC1
BIOSDATA:2DC1 ; ---------------------------------------------------------------------------
BIOSDATA:2DC2 ClusterH        dw 0                    ; DATA XREF: getclus+9↓w
BIOSDATA:2DC2                                         ; getclus+11↓w ...
BIOSDATA:2DC4
BIOSDATA:2DC4 ; =============== S U B R O U T I N E =======================================
BIOSDATA:2DC4
BIOSDATA:2DC4
BIOSDATA:2DC4 getclus         proc near               ; CODE XREF: BIOSDATA:242E↑p
BIOSDATA:2DC4                 push    cx              ; 1*
BIOSDATA:2DC4                                         ; si:bx = (32 bit) cluster to read
BIOSDATA:2DC4                                         ; cx = sectors per cluster
BIOSDATA:2DC4                                         ; es:di = load location
BIOSDATA:2DC5                 push    di              ; 2*
BIOSDATA:2DC6                 mov     cs:doscnt, cx
BIOSDATA:2DCB                 mov     ax, bx
BIOSDATA:2DCD                 mov     cs:ClusterH, si ; high word of cluster number
BIOSDATA:2DD2                 sub     ax, 2
BIOSDATA:2DD5                 sbb     cs:ClusterH, 0
BIOSDATA:2DDB                 xchg    ax, cs:ClusterH
BIOSDATA:2DE0                 mul     cx
BIOSDATA:2DE2                 xchg    ax, cs:ClusterH
BIOSDATA:2DE7                 mul     cx
BIOSDATA:2DE9                 add     dx, cs:ClusterH ; convert to logical sector
BIOSDATA:2DE9                                         ; dx:ax = matching logical sector number
BIOSDATA:2DE9                                         ; starting from the data sector
BIOSDATA:2DEE                 add     ax, cs:First_Data_Sector
BIOSDATA:2DF3                 adc     dx, cs:First_Data_Sector+2 ;
BIOSDATA:2DF3                                         ; dx:ax = first logical sector to read
BIOSDATA:2DF8
BIOSDATA:2DF8 unpack:                                 ; CODE XREF: getclus+D7↓j
BIOSDATA:2DF8                 push    ds              ; 3*
BIOSDATA:2DF9                 push    ax              ; 4*
BIOSDATA:2DFA                 push    si              ; 5*
BIOSDATA:2DFB                 push    bx              ; 6*
BIOSDATA:2DFC                 mov     ax, cs:fatloc
BIOSDATA:2E00                 mov     ds, ax
BIOSDATA:2E02                 test    cs:fbigfat, 20h ; fbigbig
BIOSDATA:2E02                                         ; FAT32 ?
BIOSDATA:2E08                 jz      short not_32bit_cluster ; no
BIOSDATA:2E0A
BIOSDATA:2E0A unpack32:                               ; yes
BIOSDATA:2E0A                 push    dx              ; 7*
BIOSDATA:2E0B                 mov     dx, si
BIOSDATA:2E0D                 mov     si, bx
BIOSDATA:2E0F                 add     si, si
BIOSDATA:2E11                 adc     dx, dx
BIOSDATA:2E13                 add     si, si
BIOSDATA:2E15                 adc     dx, dx          ; dx:si = 4*(si:bx)
BIOSDATA:2E17                 call    get_fat_sector
BIOSDATA:2E1A                 mov     si, [bx+2]      ; byte 16-31 of the FAT32 cluster number
BIOSDATA:2E1D                 mov     bx, [bx]        ; byte 0-15 of the FAT32 cluster number
BIOSDATA:2E1F                 pop     dx              ; 7*
BIOSDATA:2E20                 jmp     short getcl1
BIOSDATA:2E22 ; ---------------------------------------------------------------------------
BIOSDATA:2E22
BIOSDATA:2E22 not_32bit_cluster:                      ; CODE XREF: getclus+44↑j
BIOSDATA:2E22                 mov     si, bx          ; next cluster
BIOSDATA:2E24                 test    cs:fbigfat, 40h ; fbig
BIOSDATA:2E24                                         ; FAT16 ?
BIOSDATA:2E2A                 jnz     short unpack16  ; yes
BIOSDATA:2E2C
BIOSDATA:2E2C unpack12:
BIOSDATA:2E2C                 shr     si, 1
BIOSDATA:2E2E                 add     si, bx          ; 12 bit fat. si=si/2
BIOSDATA:2E2E                                         ; si = clus + clus/2
BIOSDATA:2E2E                                         ; (si = byte offset of the cluster in the FAT)
BIOSDATA:2E30                 push    dx
BIOSDATA:2E31                 xor     dx, dx
BIOSDATA:2E33                 call    get_fat_sector
BIOSDATA:2E36                 pop     dx
BIOSDATA:2E37                 mov     ax, [bx]        ; save cluster number into ax
BIOSDATA:2E39                 jnz     short even_odd  ; if not a splitted fat, check even-odd
BIOSDATA:2E3B                 mov     al, [bx]        ; (not needed!) Erdogan Tan - 2023
BIOSDATA:2E3D                 mov     byte ptr cs:temp_cluster, al ; splitted fat
BIOSDATA:2E41                 inc     si              ; (next byte)
BIOSDATA:2E42                 push    dx
BIOSDATA:2E43                 xor     dx, dx
BIOSDATA:2E45                 call    get_fat_sector
BIOSDATA:2E48                 pop     dx
BIOSDATA:2E49                 mov     al, ds:0        ; mov ah,[0]
BIOSDATA:2E4C                 mov     byte ptr cs:temp_cluster+1, al
BIOSDATA:2E50                 mov     ax, cs:temp_cluster ; mov al,[cs:temp_cluster]
BIOSDATA:2E54
BIOSDATA:2E54 even_odd:                               ; CODE XREF: getclus+75↑j
BIOSDATA:2E54                 pop     bx              ; restore old fat entry value
BIOSDATA:2E55                 push    bx              ; 6*
BIOSDATA:2E56                 shr     bx, 1           ; was it even or odd?
BIOSDATA:2E58                 jnb     short havclus   ; it was even
BIOSDATA:2E5A                 shr     ax, 1           ; odd. massage fat value and keep
BIOSDATA:2E5A                                         ; the highest 12 bits.
BIOSDATA:2E5C                 shr     ax, 1
BIOSDATA:2E5E                 shr     ax, 1
BIOSDATA:2E60                 shr     ax, 1
BIOSDATA:2E62
BIOSDATA:2E62 havclus:                                ; CODE XREF: getclus+94↑j
BIOSDATA:2E62                 mov     bx, ax          ; now bx = new fat entry
BIOSDATA:2E64                 and     bx, 0FFFh       ; keep low 12 bits
BIOSDATA:2E68                 jmp     short unpackx
BIOSDATA:2E6A ; ---------------------------------------------------------------------------
BIOSDATA:2E6A
BIOSDATA:2E6A unpack16:                               ; CODE XREF: getclus+66↑j
BIOSDATA:2E6A                 push    dx
BIOSDATA:2E6B                 xor     dx, dx          ; extend to 32 bit offset
BIOSDATA:2E6D                 shl     si, 1           ; cluster number * 2
BIOSDATA:2E6F                 adc     dx, 0
BIOSDATA:2E72                 call    get_fat_sector
BIOSDATA:2E75                 pop     dx
BIOSDATA:2E76                 mov     bx, [bx]        ; bx = new fat entry
BIOSDATA:2E78
BIOSDATA:2E78 unpackx:                                ; CODE XREF: getclus+A4↑j
BIOSDATA:2E78                 xor     si, si          ; high word of cluster number = 0
BIOSDATA:2E78                                         ; (FAT12 or FAT16)
BIOSDATA:2E7A
BIOSDATA:2E7A getcl1:                                 ; CODE XREF: getclus+5C↑j
BIOSDATA:2E7A                 pop     ax              ; 6* - cluster number lw
BIOSDATA:2E7B                 pop     cs:ClusterH     ; 5* - cluster number hw
BIOSDATA:2E80                 sub     ax, bx          ; previous - current (or current - new)
BIOSDATA:2E82                 sbb     cs:ClusterH, si
BIOSDATA:2E87                 cmp     cs:ClusterH, -1 ; one apart? (current = previous+1)
BIOSDATA:2E8D                 jnz     short not_consenquental
BIOSDATA:2E8F                 cmp     ax, -1          ; 0FFFFh ; is [ClusterH]:ax = -1 ?
BIOSDATA:2E92
BIOSDATA:2E92 not_consenquental:                      ; CODE XREF: getclus+C9↑j
BIOSDATA:2E92                 pop     ax              ; 4* - low word of first logical sector
BIOSDATA:2E93                 pop     ds              ; 3*
BIOSDATA:2E94                 jnz     short getcl2
BIOSDATA:2E96                 add     cs:doscnt, cx   ; consequental cluster read, +1 cluster sectors
BIOSDATA:2E96                                         ; (cx = sectors per cluster)
BIOSDATA:2E9B                 jmp     unpack
BIOSDATA:2E9E ; ---------------------------------------------------------------------------
BIOSDATA:2E9E
BIOSDATA:2E9E getcl2:                                 ; CODE XREF: getclus+D0↑j
BIOSDATA:2E9E                 push    bx
BIOSDATA:2E9F                 push    si
BIOSDATA:2EA0                 push    dx              ; sector to read (high)
BIOSDATA:2EA1                 push    ax              ; sector to read (low)
BIOSDATA:2EA2                 mov     ax, cs:drvfat   ; get drive and fat spec
BIOSDATA:2EA6                 mov     cx, di          ; dma and segment (64K boundary) overrun precaution
BIOSDATA:2EA6                                         ; (sector count will be decreased if it is required)
BIOSDATA:2EA8                 not     cx              ; cx = 65535 - cx
BIOSDATA:2EAA                 shr     cx, 1           ; cx = cx/2
BIOSDATA:2EAC                 xor     cl, cl
BIOSDATA:2EAE                 xchg    cl, ch          ; cx = cx/256
BIOSDATA:2EB0                 cmp     cx, cs:doscnt   ; if sector read count > cx, decrease it to cx
BIOSDATA:2EB5                 jbe     short getcl3
BIOSDATA:2EB7                 mov     cx, cs:doscnt
BIOSDATA:2EBC
BIOSDATA:2EBC getcl3:                                 ; CODE XREF: getclus+F1↑j
BIOSDATA:2EBC                 pop     dx              ; sector to read for diskrd (low)
BIOSDATA:2EBD                 pop     cs:start_sec_h  ; sector to read for diskrd (high)
BIOSDATA:2EC2                 push    cx
BIOSDATA:2EC3                 push    ds
BIOSDATA:2EC4                 push    cs
BIOSDATA:2EC5                 pop     ds
BIOSDATA:2EC6                 assume ds:BIOSDATA
BIOSDATA:2EC6                 push    cs              ; simulate far call
BIOSDATA:2EC7                 mov     bp, offset DISKRD ; BIOSCODE:0A2Bh ; 364h:0A2Bh
BIOSDATA:2ECA                 call    call_bios_code
BIOSDATA:2ECD                 pop     ds
BIOSDATA:2ECE                 assume ds:nothing
BIOSDATA:2ECE                 pop     ax              ; sector count
BIOSDATA:2ECF                 pop     si
BIOSDATA:2ED0                 pop     bx
BIOSDATA:2ED1                 pop     di              ; 2* - load location (es:di)
BIOSDATA:2ED2                 xchg    ah, al
BIOSDATA:2ED4                 shl     ax, 1           ; ax = ax * 512 ; byte count
BIOSDATA:2ED6                 add     di, ax          ; update load location
BIOSDATA:2ED8                 pop     cx              ; 1* - restore sectors/cluster
BIOSDATA:2ED9                 retn
BIOSDATA:2ED9 getclus         endp
BIOSDATA:2ED9
BIOSDATA:2EDA
BIOSDATA:2EDA ; =============== S U B R O U T I N E =======================================
BIOSDATA:2EDA
BIOSDATA:2EDA
BIOSDATA:2EDA get_fat_sector  proc near               ; CODE XREF: getclus+53↑p
BIOSDATA:2EDA                                         ; getclus+6F↑p ...
BIOSDATA:2EDA                 push    ax              ; dx:si = offset value (starting from fat entry 0)
BIOSDATA:2EDA                                         ;         of fat entry to find
BIOSDATA:2EDB                 push    cx
BIOSDATA:2EDC                 push    di
BIOSDATA:2EDD                 push    si
BIOSDATA:2EDE                 push    es
BIOSDATA:2EDF                 push    ds
BIOSDATA:2EE0                 mov     ax, si
BIOSDATA:2EE2                 mov     cx, cs:md_sectorsize ; 512
BIOSDATA:2EE7                 div     cx
BIOSDATA:2EE9                 nop                     ; ax = sector number, dx = offset
BIOSDATA:2EEA                 push    es
BIOSDATA:2EEB                 push    ds
BIOSDATA:2EEC                 push    di
BIOSDATA:2EED                 push    ax
BIOSDATA:2EEE                 push    cs
BIOSDATA:2EEF                 pop     ds
BIOSDATA:2EF0                 assume ds:BIOSDATA
BIOSDATA:2EF0                 mov     ax, cs:drvfat   ; get drive # and FAT id
BIOSDATA:2EF4                 mov     bp, offset SetDrive ; BIOSCODE:05AEh
BIOSDATA:2EF7                 push    cs              ; simulate far call
BIOSDATA:2EF8                 call    call_bios_code  ; get bds for drive
BIOSDATA:2EFB                 pop     ax              ; (sector number -without reserved and hidden sectors-)
BIOSDATA:2EFC                 add     ax, es:[di+9]   ; [es:di+BDS.resectors]
BIOSDATA:2EFC                                         ; add #reserved_sectors
BIOSDATA:2F00                 pop     di
BIOSDATA:2F01                 pop     ds
BIOSDATA:2F02                 assume ds:nothing
BIOSDATA:2F02                 pop     es
BIOSDATA:2F03                 cmp     ax, cs:last_fat_sec_num
BIOSDATA:2F08                 jz      short gfs_split_chk ; don't need to read it again
BIOSDATA:2F0A                 mov     cs:last_fat_sec_num, ax ; sector number
BIOSDATA:2F0A                                         ; (in the partition, without hidden sectors)
BIOSDATA:2F0E                 push    dx
BIOSDATA:2F0F                 mov     cs:start_sec_h, 0 ; prepare to read the fat sector
BIOSDATA:2F0F                                         ; start_sec_h is always 0 for fat sector
BIOSDATA:2F16                 mov     dx, ax
BIOSDATA:2F18                 mov     cx, 1           ; 1 sector read
BIOSDATA:2F1B                 mov     ax, cs:drvfat
BIOSDATA:2F1F                 push    ds
BIOSDATA:2F20                 pop     es
BIOSDATA:2F21                 xor     di, di          ; es:di -> fatloc segment:0
BIOSDATA:2F23                 push    ds
BIOSDATA:2F24                 push    cs
BIOSDATA:2F25                 pop     ds
BIOSDATA:2F26                 assume ds:BIOSDATA
BIOSDATA:2F26                 push    cs              ; simulate far call
BIOSDATA:2F27                 mov     bp, offset DISKRD ; BIOSCODE:0A2Bh ; 364h:0A2Bh
BIOSDATA:2F2A                 call    call_bios_code
BIOSDATA:2F2D                 pop     ds
BIOSDATA:2F2E                 assume ds:nothing
BIOSDATA:2F2E                 pop     dx
BIOSDATA:2F2F                 mov     cx, cs:md_sectorsize ; 512
BIOSDATA:2F34
BIOSDATA:2F34 gfs_split_chk:                          ; CODE XREF: get_fat_sector+2E↑j
BIOSDATA:2F34                 dec     cx              ; 511
BIOSDATA:2F35                 cmp     dx, cx          ; if offset points to the last byte of this sector,
BIOSDATA:2F35                                         ; then splitted entry.
BIOSDATA:2F37                 mov     bx, dx          ; offset value from fatloc segment
BIOSDATA:2F39                 pop     ds
BIOSDATA:2F3A                 pop     es
BIOSDATA:2F3B                 pop     si
BIOSDATA:2F3C                 pop     di
BIOSDATA:2F3D                 pop     cx
BIOSDATA:2F3E                 pop     ax
BIOSDATA:2F3F                 retn
BIOSDATA:2F3F get_fat_sector  endp
BIOSDATA:2F3F
BIOSDATA:2F3F BIOSDATA        ends
BIOSDATA:2F3F
BIOSCODE:0000 ; ===========================================================================
BIOSCODE:0000
BIOSCODE:0000 ; Segment type: Regular
BIOSCODE:0000 BIOSCODE        segment byte public 'BIOSCODE' use16
BIOSCODE:0000                 assume cs:BIOSCODE
BIOSCODE:0000                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
BIOSCODE:0000 BCode_start     db 30h dup(0)
BIOSCODE:0030 Bios_Data_Word  dw 70h                  ; DATA XREF: BIOSCODE:_seg_reinit↓r
BIOSCODE:0030                                         ; BIOSCODE:0055↓r ...
BIOSCODE:0030                                         ; BIOSDATA segment
BIOSCODE:0032 ; ---------------------------------------------------------------------------
BIOSCODE:0032
BIOSCODE:0032 _seg_reinit:                            ; DATA XREF: SYSINIT:_seg_reinit_ptr↓o
BIOSCODE:0032                 mov     es, cs:Bios_Data_Word
BIOSCODE:0037                 assume es:nothing
BIOSCODE:0037                 mov     di, offset cdev_2 ; (offset cdev+2)
BIOSCODE:003A                 mov     cx, 3           ; (it was 4 in MSDOS 6.21 IO.SYS)
BIOSCODE:003A                                         ; ('bcode_i2f: dw i2f_handler, IOSYSCODESEG' is removed)
BIOSCODE:003D
BIOSCODE:003D _seg_reinit_1:                          ; CODE XREF: BIOSCODE:0040↓j
BIOSCODE:003D                 stosw                   ; ax = new code (BIOSCODE) segment value
BIOSCODE:003E                 inc     di
BIOSCODE:003F                 inc     di
BIOSCODE:0040                 loop    _seg_reinit_1
BIOSCODE:0042                 mov     es:bios_i2f_seg, ax ; (direct jump to i2f_handler
BIOSCODE:0042                                         ;  from BIOSDATA:bios_i2f)
BIOSCODE:0042                                         ; (instead of 'bcode_i2f: dw i2f_handler, IOSYSCODESEG'
BIOSCODE:0042                                         ;  in MSDOS 6.21 IO.SYS)
BIOSCODE:0046                 retf
BIOSCODE:0047 ; ---------------------------------------------------------------------------
BIOSCODE:0047
BIOSCODE:0047 chardev_entry:                          ; DATA XREF: BIOSDATA:cdev↑o
BIOSCODE:0047                 push    si
BIOSCODE:0048                 push    ax
BIOSCODE:0049                 push    cx
BIOSCODE:004A                 push    dx
BIOSCODE:004B                 push    di
BIOSCODE:004C                 push    bp
BIOSCODE:004D                 push    ds
BIOSCODE:004E                 push    es
BIOSCODE:004F                 push    bx
BIOSCODE:0050                 mov     bp, sp
BIOSCODE:0052                 mov     si, [bp+18]     ; get return address (dispatch table)
BIOSCODE:0055                 mov     ds, cs:Bios_Data_Word ; BIOSDATA segment
BIOSCODE:005A                 assume ds:nothing
BIOSCODE:005A                 les     si, [si]        ; get the device number if present
BIOSCODE:005A                                         ; si points to the device dispatch table
BIOSCODE:005C                 assume es:nothing
BIOSCODE:005C                 mov     ax, es
BIOSCODE:005E                 mov     byte ptr ds:auxnum, al
BIOSCODE:0061                 mov     ds:printdev, ah
BIOSCODE:0065                 les     bx, ds:ptrsav   ; get pointer to i/o packet
BIOSCODE:0069                 mov     al, es:[bx+1]   ; [es:bx+unit] ; al = unit code
BIOSCODE:006D                 mov     ah, es:[bx+13]  ; [es:bx+media] ; ah = media descrip
BIOSCODE:0071                 mov     cx, es:[bx+18]  ; [es:bx+count] ; cx = count
BIOSCODE:0075                 mov     dx, es:[bx+20]  ; [es:bx+start] ; dx = start sector
BIOSCODE:0079                 cmp     si, offset DSKTBL ; BIOSCODE:579h
BIOSCODE:007D                 jnz     short no_sector32_mapping
BIOSCODE:007F                 mov     ds:start_sec_h, 0
BIOSCODE:0085                 cmp     dx, 0FFFFh
BIOSCODE:0088                 jnz     short no_sector32_mapping
BIOSCODE:008A                 mov     dx, es:[bx+28]  ; [es:bx+start_h]
BIOSCODE:008A                                         ; 32 bit dsk req
BIOSCODE:008E                 mov     ds:start_sec_h, dx ; start_sec_h = packet.start_h
BIOSCODE:0092                 mov     dx, es:[bx+26]  ; [es:bx+start_l]
BIOSCODE:0092                                         ; dx = packet.start_l
BIOSCODE:0096
BIOSCODE:0096 no_sector32_mapping:                    ; CODE XREF: BIOSCODE:007D↑j
BIOSCODE:0096                                         ; BIOSCODE:0088↑j
BIOSCODE:0096                 xchg    ax, di
BIOSCODE:0097                 mov     al, es:[bx+2]   ; [es:bx+cmd]
BIOSCODE:009B                 cmp     al, cs:[si]
BIOSCODE:009E                 jnb     short command_error
BIOSCODE:00A0                 cbw
BIOSCODE:00A1                 shl     ax, 1
BIOSCODE:00A3                 add     si, ax
BIOSCODE:00A5                 xchg    ax, di
BIOSCODE:00A6                 les     di, es:[bx+14]  ; [es:bx+trans]
BIOSCODE:00AA                 cld
BIOSCODE:00AB                 call    word ptr cs:[si+1]
BIOSCODE:00AF                 jb      short already_got_ah_status
BIOSCODE:00B1                 mov     ah, 1
BIOSCODE:00B3
BIOSCODE:00B3 already_got_ah_status:                  ; CODE XREF: BIOSCODE:00AF↑j
BIOSCODE:00B3                                         ; BIOSCODE:00CE↓j
BIOSCODE:00B3                 mov     ds, cs:Bios_Data_Word
BIOSCODE:00B8                 lds     bx, ds:ptrsav
BIOSCODE:00BC                 assume ds:nothing
BIOSCODE:00BC                 mov     [bx+3], ax      ; [bx+status]
BIOSCODE:00BC                                         ; mark operation complete
BIOSCODE:00BF                 pop     bx
BIOSCODE:00C0                 pop     es
BIOSCODE:00C1                 pop     ds
BIOSCODE:00C2                 pop     bp
BIOSCODE:00C3                 pop     di
BIOSCODE:00C4                 pop     dx
BIOSCODE:00C5                 pop     cx
BIOSCODE:00C6                 pop     ax
BIOSCODE:00C7                 pop     si
BIOSCODE:00C8                 inc     sp              ; get rid of fake return address
BIOSCODE:00C9                 inc     sp
BIOSCODE:00CA
BIOSCODE:00CA bc_retf:                                ; DATA XREF: BIOSDATA:addr_of_bcretf↑o
BIOSCODE:00CA                 retf
BIOSCODE:00CB ; ---------------------------------------------------------------------------
BIOSCODE:00CB
BIOSCODE:00CB command_error:                          ; CODE XREF: BIOSCODE:009E↑j
BIOSCODE:00CB                 call    bc_cmderr
BIOSCODE:00CE                 jmp     short already_got_ah_status
BIOSCODE:00CE ; ---------------------------------------------------------------------------
BIOSCODE:00D0 _offset_D0h     db 5 dup(0)             ; 5 bytes from 0:C0h will be copied onto here
BIOSCODE:00D0                                         ; which is the CP/M call 5 entry point
BIOSCODE:00D5
BIOSCODE:00D5 ; =============== S U B R O U T I N E =======================================
BIOSCODE:00D5
BIOSCODE:00D5
BIOSCODE:00D5 bc_cmderr       proc near               ; CODE XREF: BIOSCODE:command_error↑p
BIOSCODE:00D5                                         ; BIOSCODE:prnfuncerr↓j ...
BIOSCODE:00D5                 mov     al, 3           ; unknown command error
BIOSCODE:00D7
BIOSCODE:00D7 bc_err_cnt:                             ; CODE XREF: BIOSCODE:prn_input↓p
BIOSCODE:00D7                                         ; BIOSCODE:pmessg↓j ...
BIOSCODE:00D7                 les     bx, ds:ptrsav
BIOSCODE:00DB                 mov     ah, 81h         ; mark error return
BIOSCODE:00DD                 sub     es:[bx+18], cx  ; [es:bx+count]
BIOSCODE:00DD                                         ; # of successful i/o's
BIOSCODE:00E1                 stc                     ; indicate abnormal end
BIOSCODE:00E2                 retn
BIOSCODE:00E2 bc_cmderr       endp
BIOSCODE:00E2
BIOSCODE:00E2 ; ---------------------------------------------------------------------------
BIOSCODE:00E3                 db    0
BIOSCODE:00E4 con_table       db 11                   ; DATA XREF: BIOSDATA:0623↑o
BIOSCODE:00E4                                         ; ((con_table_end - con_table)-1)/2 = 11
BIOSCODE:00E5                 dw offset bc_exvec
BIOSCODE:00E7                 dw offset bc_exvec
BIOSCODE:00E9                 dw offset bc_exvec
BIOSCODE:00EB                 dw offset bc_cmderr
BIOSCODE:00ED                 dw offset con_read
BIOSCODE:00EF                 dw offset con_rdnd
BIOSCODE:00F1                 dw offset bc_exvec
BIOSCODE:00F3                 dw offset con_flush
BIOSCODE:00F5                 dw offset con_writ
BIOSCODE:00F7                 dw offset con_writ
BIOSCODE:00F9                 dw offset bc_exvec
BIOSCODE:00FB prn_table       db 26                   ; DATA XREF: BIOSDATA:0628↑o
BIOSCODE:00FB                                         ; BIOSDATA:062F↑o ...
BIOSCODE:00FB                                         ; ((prn_table_end - prn_table)-1)/2 = 26
BIOSCODE:00FC                 dw offset bc_exvec
BIOSCODE:00FE                 dw offset bc_exvec
BIOSCODE:0100                 dw offset bc_exvec
BIOSCODE:0102                 dw offset bc_cmderr
BIOSCODE:0104                 dw offset prn_input
BIOSCODE:0106                 dw offset z_bus_exit
BIOSCODE:0108                 dw offset bc_exvec
BIOSCODE:010A                 dw offset bc_exvec
BIOSCODE:010C                 dw offset prn_writ
BIOSCODE:010E                 dw offset prn_writ
BIOSCODE:0110                 dw offset prn_stat
BIOSCODE:0112                 dw offset bc_exvec
BIOSCODE:0114                 dw offset bc_exvec
BIOSCODE:0116                 dw offset bc_exvec
BIOSCODE:0118                 dw offset bc_exvec
BIOSCODE:011A                 dw offset bc_exvec
BIOSCODE:011C                 dw offset prn_tilbusy
BIOSCODE:011E                 dw offset bc_exvec
BIOSCODE:0120                 dw offset bc_exvec
BIOSCODE:0122                 dw offset prn_genioctl
BIOSCODE:0124                 dw offset bc_exvec
BIOSCODE:0126                 dw offset bc_exvec
BIOSCODE:0128                 dw offset bc_exvec
BIOSCODE:012A                 dw offset bc_exvec
BIOSCODE:012C                 dw offset bc_exvec
BIOSCODE:012E                 dw offset prn_ioctl_query
BIOSCODE:0130 aux_table       db 11                   ; DATA XREF: BIOSDATA:0644↑o
BIOSCODE:0130                                         ; BIOSDATA:064A↑o ...
BIOSCODE:0130                                         ; ((aux_table_end - aux_table)-1)/2 = 11
BIOSCODE:0131                 dw offset bc_exvec
BIOSCODE:0133                 dw offset bc_exvec
BIOSCODE:0135                 dw offset bc_exvec
BIOSCODE:0137                 dw offset bc_cmderr
BIOSCODE:0139                 dw offset aux_read
BIOSCODE:013B                 dw offset aux_rdnd
BIOSCODE:013D                 dw offset bc_exvec
BIOSCODE:013F                 dw offset aux_flsh
BIOSCODE:0141                 dw offset aux_writ
BIOSCODE:0143                 dw offset aux_writ
BIOSCODE:0145                 dw offset aux_wrst
BIOSCODE:0147 tim_table       db 10                   ; DATA XREF: BIOSDATA:065C↑o
BIOSCODE:0147                                         ; ((tim_table_end - tim_table)-1)/2 = 10
BIOSCODE:0148                 dw offset bc_exvec
BIOSCODE:014A                 dw offset bc_exvec
BIOSCODE:014C                 dw offset bc_exvec
BIOSCODE:014E                 dw offset bc_cmderr
BIOSCODE:0150                 dw offset tim_read
BIOSCODE:0152                 dw offset z_bus_exit
BIOSCODE:0154                 dw offset bc_exvec
BIOSCODE:0156                 dw offset bc_exvec
BIOSCODE:0158                 dw offset tim_writ
BIOSCODE:015A                 dw offset tim_writ
BIOSCODE:015C
BIOSCODE:015C ; =============== S U B R O U T I N E =======================================
BIOSCODE:015C
BIOSCODE:015C
BIOSCODE:015C con_read        proc near               ; DATA XREF: BIOSCODE:00ED↑o
BIOSCODE:015C                 jcxz    short con_exit  ; read cx bytes from keyboard into buffer
BIOSCODE:015E
BIOSCODE:015E con_loop:                               ; CODE XREF: con_read+6↓j
BIOSCODE:015E                 call    chrin           ; get char in al
BIOSCODE:0161                 stosb                   ; store char at es:di
BIOSCODE:0162                 loop    con_loop
BIOSCODE:0164
BIOSCODE:0164 con_exit:                               ; CODE XREF: con_read↑j
BIOSCODE:0164                 clc
BIOSCODE:0165                 retn
BIOSCODE:0165 con_read        endp
BIOSCODE:0165
BIOSCODE:0166
BIOSCODE:0166 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0166
BIOSCODE:0166
BIOSCODE:0166 chrin           proc near               ; CODE XREF: con_read:con_loop↑p
BIOSCODE:0166                                         ; chrin+12↓j
BIOSCODE:0166                 mov     ah, ds:keyrd_func ; set by msinit. 0 or 10h
BIOSCODE:016A                 xor     al, al
BIOSCODE:016C                 xchg    al, ds:altah    ; get character & zero altah
BIOSCODE:0170                 or      al, al
BIOSCODE:0172                 jnz     short keyret
BIOSCODE:0174                 int     16h             ; KEYBOARD -
BIOSCODE:0176                 or      ax, ax
BIOSCODE:0178                 jz      short chrin
BIOSCODE:017A                 cmp     ax, 7200h       ; check for ctrl-prtsc
BIOSCODE:017D                 jnz     short alt_ext_chk
BIOSCODE:017F                 mov     al, 10h
BIOSCODE:0181                 jmp     short keyret
BIOSCODE:0183 ; ---------------------------------------------------------------------------
BIOSCODE:0183
BIOSCODE:0183 alt_ext_chk:                            ; CODE XREF: chrin+17↑j
BIOSCODE:0183                 cmp     ds:keyrd_func, 0
BIOSCODE:0188                 jz      short not_ext
BIOSCODE:018A                 cmp     al, 0E0h
BIOSCODE:018C                 jnz     short not_ext
BIOSCODE:018E                 or      ah, ah
BIOSCODE:0190                 jz      short keyret
BIOSCODE:0192                 xor     al, al
BIOSCODE:0194                 jmp     short alt_save
BIOSCODE:0196 ; ---------------------------------------------------------------------------
BIOSCODE:0196
BIOSCODE:0196 not_ext:                                ; CODE XREF: chrin+22↑j
BIOSCODE:0196                                         ; chrin+26↑j
BIOSCODE:0196                 or      al, al          ; special case?
BIOSCODE:0198                 jnz     short keyret
BIOSCODE:019A
BIOSCODE:019A alt_save:                               ; CODE XREF: chrin+2E↑j
BIOSCODE:019A                 mov     ds:altah, ah    ; store special key
BIOSCODE:019E
BIOSCODE:019E keyret:                                 ; CODE XREF: chrin+C↑j
BIOSCODE:019E                                         ; chrin+1B↑j ...
BIOSCODE:019E                 retn
BIOSCODE:019E chrin           endp
BIOSCODE:019E
BIOSCODE:019F
BIOSCODE:019F ; =============== S U B R O U T I N E =======================================
BIOSCODE:019F
BIOSCODE:019F
BIOSCODE:019F con_rdnd        proc near               ; CODE XREF: con_rdnd+37↓j
BIOSCODE:019F                                         ; DATA XREF: BIOSCODE:00EF↑o
BIOSCODE:019F                 mov     al, ds:altah    ; keyboard non destructive read, no wait
BIOSCODE:01A2                 or      al, al
BIOSCODE:01A4                 jnz     short rdexit
BIOSCODE:01A6                 mov     ah, ds:keysts_func
BIOSCODE:01AA                 int     16h             ; KEYBOARD -
BIOSCODE:01AC                 jnz     short gotchr
BIOSCODE:01AE                 cmp     ds:fhavek09, 0
BIOSCODE:01B3                 jz      short z_bus_exit
BIOSCODE:01B5                 les     bx, ds:ptrsav
BIOSCODE:01B9                 test    word ptr es:[bx+3], 400h ; [es:bx+status]
BIOSCODE:01BF                 jz      short z_bus_exit
BIOSCODE:01C1                 mov     ax, 4100h
BIOSCODE:01C4                 xor     bl, bl
BIOSCODE:01C6                 int     15h             ; SYSTEM - WAIT ON EXTERNAL EVENT (CONVERTIBLE)
BIOSCODE:01C6                                         ; AL = condition type, BH = condition compare or mask value
BIOSCODE:01C6                                         ; BL = timeout value times 55 milliseconds, 00h means no timeout
BIOSCODE:01C6                                         ; DX = I/O port address if AL bit 4 set
BIOSCODE:01C8
BIOSCODE:01C8 z_bus_exit:                             ; CODE XREF: con_rdnd+14↑j
BIOSCODE:01C8                                         ; con_rdnd+20↑j ...
BIOSCODE:01C8                 stc
BIOSCODE:01C9                 mov     ah, 3           ; indicate busy status
BIOSCODE:01CB                 retn
BIOSCODE:01CC ; ---------------------------------------------------------------------------
BIOSCODE:01CC
BIOSCODE:01CC gotchr:                                 ; CODE XREF: con_rdnd+D↑j
BIOSCODE:01CC                 or      ax, ax
BIOSCODE:01CE                 jnz     short notbrk    ; check for null after break
BIOSCODE:01D0                 mov     ah, ds:keyrd_func ; issue keyboard read function
BIOSCODE:01D4                 int     16h             ; KEYBOARD -
BIOSCODE:01D6                 jmp     short con_rdnd  ; get a real status
BIOSCODE:01D8 ; ---------------------------------------------------------------------------
BIOSCODE:01D8
BIOSCODE:01D8 notbrk:                                 ; CODE XREF: con_rdnd+2F↑j
BIOSCODE:01D8                 cmp     ax, 7200h       ; check for ctrl-prtsc
BIOSCODE:01DB                 jnz     short rd_ext_chk
BIOSCODE:01DD                 mov     al, 10h         ; ('P' & 1Fh) ; return control p
BIOSCODE:01DF                 jmp     short rdexit
BIOSCODE:01E1 ; ---------------------------------------------------------------------------
BIOSCODE:01E1
BIOSCODE:01E1 rd_ext_chk:                             ; CODE XREF: con_rdnd+3C↑j
BIOSCODE:01E1                 cmp     ds:keyrd_func, 0 ; extended keyboard function?
BIOSCODE:01E6                 jz      short rdexit
BIOSCODE:01E8                 cmp     al, 0E0h        ; extended key value or greek alpha?
BIOSCODE:01EA                 jnz     short rdexit
BIOSCODE:01EC                 cmp     ah, 0           ; scan code exist?
BIOSCODE:01EF                 jz      short rdexit    ; yes. greek alpha char.
BIOSCODE:01F1                 mov     al, 0           ; no. extended key stroke.
BIOSCODE:01F1                                         ; change it for compatibility
BIOSCODE:01F3
BIOSCODE:01F3 rdexit:                                 ; CODE XREF: con_rdnd+5↑j
BIOSCODE:01F3                                         ; con_rdnd+40↑j ...
BIOSCODE:01F3                 les     bx, ds:ptrsav
BIOSCODE:01F7                 mov     es:[bx+13], al  ; [es:bx+media]
BIOSCODE:01F7                                         ; return keyboard character here
BIOSCODE:01FB
BIOSCODE:01FB bc_exvec:                               ; CODE XREF: con_writ↓j
BIOSCODE:01FB                                         ; DATA XREF: BIOSCODE:00E5↑o ...
BIOSCODE:01FB                 clc                     ; indicate normal termination
BIOSCODE:01FC                 retn
BIOSCODE:01FC con_rdnd        endp
BIOSCODE:01FC
BIOSCODE:01FD
BIOSCODE:01FD ; =============== S U B R O U T I N E =======================================
BIOSCODE:01FD
BIOSCODE:01FD
BIOSCODE:01FD con_writ        proc near               ; DATA XREF: BIOSCODE:00F5↑o
BIOSCODE:01FD                                         ; BIOSCODE:00F7↑o
BIOSCODE:01FD                 jcxz    short bc_exvec  ; console write routine
BIOSCODE:01FF
BIOSCODE:01FF con_lp:                                 ; CODE XREF: con_writ+8↓j
BIOSCODE:01FF                 mov     al, es:[di]
BIOSCODE:0202                 inc     di
BIOSCODE:0203                 int     29h             ; DOS 2+ internal - FAST PUTCHAR
BIOSCODE:0203                                         ; AL = character to display
BIOSCODE:0205                 loop    con_lp
BIOSCODE:0205 con_writ        endp
BIOSCODE:0205
BIOSCODE:0207 ; START OF FUNCTION CHUNK FOR con_flush
BIOSCODE:0207
BIOSCODE:0207 cc_ret:                                 ; CODE XREF: con_flush+9↓j
BIOSCODE:0207                 clc
BIOSCODE:0208                 retn
BIOSCODE:0208 ; END OF FUNCTION CHUNK FOR con_flush
BIOSCODE:0209
BIOSCODE:0209 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0209
BIOSCODE:0209
BIOSCODE:0209 con_flush       proc near               ; CODE XREF: swpdsk+37↓p
BIOSCODE:0209                                         ; DATA XREF: BIOSCODE:00F3↑o
BIOSCODE:0209
BIOSCODE:0209 ; FUNCTION CHUNK AT BIOSCODE:0207 SIZE 00000002 BYTES
BIOSCODE:0209
BIOSCODE:0209                 mov     ds:altah, 0     ; flush out keyboard queue
BIOSCODE:0209                                         ; clear out holding buffer
BIOSCODE:020E
BIOSCODE:020E flloop:                                 ; CODE XREF: con_flush+F↓j
BIOSCODE:020E                 mov     ah, 1           ; while (charavail()) charread();
BIOSCODE:0210                 int     16h             ; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
BIOSCODE:0210                                         ; Return: ZF clear if character in buffer
BIOSCODE:0210                                         ; AH = scan code, AL = character
BIOSCODE:0210                                         ; ZF set if no character in buffer
BIOSCODE:0212                 jz      short cc_ret
BIOSCODE:0214                 xor     ah, ah
BIOSCODE:0216                 int     16h             ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
BIOSCODE:0216                                         ; Return: AH = scan code, AL = character
BIOSCODE:0218                 jmp     short flloop
BIOSCODE:0218 con_flush       endp
BIOSCODE:0218
BIOSCODE:021A ; ---------------------------------------------------------------------------
BIOSCODE:021A
BIOSCODE:021A prn_input:                              ; DATA XREF: BIOSCODE:0104↑o
BIOSCODE:021A                 call    bc_err_cnt      ; reset count to zero
BIOSCODE:021A                                         ; (sub reqpkt.count,cx)
BIOSCODE:021D                 clc                     ; but return with carry   reset for no error
BIOSCODE:021E                 retn
BIOSCODE:021F ; ---------------------------------------------------------------------------
BIOSCODE:021F
BIOSCODE:021F prn_writ:                               ; DATA XREF: BIOSCODE:010C↑o
BIOSCODE:021F                                         ; BIOSCODE:010E↑o
BIOSCODE:021F                 jcxz    short prn_done  ; write cx bytes from es:di to printer device
BIOSCODE:0221
BIOSCODE:0221 prn_loop:                               ; CODE XREF: BIOSCODE:024D↓j
BIOSCODE:0221                 mov     bx, 2           ; retry count
BIOSCODE:0224
BIOSCODE:0224 prn_out:                                ; CODE XREF: BIOSCODE:0247↓j
BIOSCODE:0224                 call    prnstat         ; get status
BIOSCODE:0227                 jnz     short TestPrnError
BIOSCODE:0229                 mov     al, es:[di]     ; get character to print
BIOSCODE:022C                 xor     ah, ah
BIOSCODE:022E                 call    prnop           ; print to printer
BIOSCODE:0231                 jz      short prn_con   ; no error - continue
BIOSCODE:0233                 cmp     ah, 0FFh        ; MODE_CTRLBRK
BIOSCODE:0236                 jnz     short _prnwf
BIOSCODE:0238                 mov     al, 0Ch         ; error_I24_gen_failure
BIOSCODE:023A                 mov     ds:altah, 0
BIOSCODE:023F                 jmp     short pmessg
BIOSCODE:0241 ; ---------------------------------------------------------------------------
BIOSCODE:0241
BIOSCODE:0241 _prnwf:                                 ; CODE XREF: BIOSCODE:0236↑j
BIOSCODE:0241                 test    ah, 1           ; timeoutstatus
BIOSCODE:0244                 jz      short prn_con
BIOSCODE:0246
BIOSCODE:0246 TestPrnError:                           ; CODE XREF: BIOSCODE:0227↑j
BIOSCODE:0246                 dec     bx              ; retry until count is exhausted
BIOSCODE:0247                 jnz     short prn_out
BIOSCODE:0249
BIOSCODE:0249 pmessg:                                 ; CODE XREF: BIOSCODE:023F↑j
BIOSCODE:0249                                         ; BIOSCODE:0254↓j
BIOSCODE:0249                 jmp     bc_err_cnt
BIOSCODE:024C ; ---------------------------------------------------------------------------
BIOSCODE:024C
BIOSCODE:024C prn_con:                                ; CODE XREF: BIOSCODE:0231↑j
BIOSCODE:024C                                         ; BIOSCODE:0244↑j
BIOSCODE:024C                 inc     di              ; point to next char and continue
BIOSCODE:024D                 loop    prn_loop
BIOSCODE:024F
BIOSCODE:024F prn_done:                               ; CODE XREF: BIOSCODE:prn_writ↑j
BIOSCODE:024F                                         ; BIOSCODE:0259↓j
BIOSCODE:024F                 clc
BIOSCODE:0250                 retn
BIOSCODE:0251 ; ---------------------------------------------------------------------------
BIOSCODE:0251
BIOSCODE:0251 prn_stat:                               ; DATA XREF: BIOSCODE:0110↑o
BIOSCODE:0251                 call    prnstat         ; device in dx
BIOSCODE:0254                 jnz     short pmessg
BIOSCODE:0256                 test    ah, 80h         ; notbusystatus
BIOSCODE:0259                 jnz     short prn_done
BIOSCODE:025B                 jmp     z_bus_exit
BIOSCODE:025E
BIOSCODE:025E ; =============== S U B R O U T I N E =======================================
BIOSCODE:025E
BIOSCODE:025E
BIOSCODE:025E prnstat         proc near               ; CODE XREF: BIOSCODE:prn_out↑p
BIOSCODE:025E                                         ; BIOSCODE:prn_stat↑p ...
BIOSCODE:025E                 mov     ah, 2           ; PRINTER - GET STATUS
BIOSCODE:025E prnstat         endp                    ; set command for get status
BIOSCODE:025E                                         ; DX = printer port (0-3)
BIOSCODE:025E                                         ; Return: AH = status
BIOSCODE:0260
BIOSCODE:0260 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0260
BIOSCODE:0260
BIOSCODE:0260 prnop           proc near               ; CODE XREF: BIOSCODE:022E↑p
BIOSCODE:0260                                         ; BIOSCODE:02B9↓p
BIOSCODE:0260                 mov     dx, ds:auxnum   ; get printer number
BIOSCODE:0264                 push    ds
BIOSCODE:0265                 push    di
BIOSCODE:0266                 xor     di, di
BIOSCODE:0268                 mov     ds, di
BIOSCODE:026A                 assume ds:nothing
BIOSCODE:026A                 pop     di
BIOSCODE:026B                 pushf                   ; simulate int 17h
BIOSCODE:026C                 cli
BIOSCODE:026D                 call    dword ptr ds:5Ch ; 0:5Ch = INT 17h vector
BIOSCODE:0271                 pop     ds
BIOSCODE:0272                 assume ds:nothing
BIOSCODE:0272                 push    ax
BIOSCODE:0273                 and     ah, 30h
BIOSCODE:0276                 cmp     ah, 30h         ; noprinter error
BIOSCODE:0279                 pop     ax
BIOSCODE:027A                 jnz     short NextTest
BIOSCODE:027C                 and     ah, 0DFh        ; ~nopaperstatus
BIOSCODE:027F                 or      ah, 8           ; ioerrstatus
BIOSCODE:0282
BIOSCODE:0282 NextTest:                               ; CODE XREF: prnop+1A↑j
BIOSCODE:0282                 test    ah, 28h         ; (ioerrstatus+nopaperstatus)
BIOSCODE:0282                                         ; i/o error?
BIOSCODE:0285                 jz      short checknotready ; no, try not ready
BIOSCODE:0287                 mov     al, 9           ; error_I24_out_of_paper
BIOSCODE:0287                                         ;  first, assume out of paper
BIOSCODE:0289                 test    ah, 20h         ; out of paper set?
BIOSCODE:028C                 jnz     short ret1      ; yes, error is set
BIOSCODE:028E                 inc     al              ; return al=10 (i/o error)
BIOSCODE:0290
BIOSCODE:0290 ret1:                                   ; CODE XREF: prnop+2C↑j
BIOSCODE:0290                 retn
BIOSCODE:0291 ; ---------------------------------------------------------------------------
BIOSCODE:0291
BIOSCODE:0291 checknotready:                          ; CODE XREF: prnop+25↑j
BIOSCODE:0291                 mov     al, 2           ; assume not-ready
BIOSCODE:0293                 test    ah, 1
BIOSCODE:0296                 retn
BIOSCODE:0296 prnop           endp
BIOSCODE:0296
BIOSCODE:0297 ; ---------------------------------------------------------------------------
BIOSCODE:0297
BIOSCODE:0297 prn_tilbusy:                            ; DATA XREF: BIOSCODE:011C↑o
BIOSCODE:0297                 mov     si, di
BIOSCODE:0299
BIOSCODE:0299 prn_tilbloop:                           ; CODE XREF: BIOSCODE:02BE↓j
BIOSCODE:0299                 push    cx
BIOSCODE:029A                 push    bx
BIOSCODE:029B                 xor     bh, bh
BIOSCODE:029D                 mov     bl, ds:printdev
BIOSCODE:02A1                 shl     bx, 1
BIOSCODE:02A3                 mov     cx, ds:wait_count[bx] ; wait count times to come ready
BIOSCODE:02A7                 pop     bx
BIOSCODE:02A8
BIOSCODE:02A8 prn_getstat:                            ; CODE XREF: BIOSCODE:02B0↓j
BIOSCODE:02A8                 call    prnstat         ; get status
BIOSCODE:02AB                 jnz     short prn_bperr ; error
BIOSCODE:02AD                 test    ah, 80h         ; ready yet?
BIOSCODE:02B0                 loope   prn_getstat     ; no, go for more
BIOSCODE:02B2                 pop     cx              ; get original count
BIOSCODE:02B3                 jz      short prn_berr  ; still not ready => done
BIOSCODE:02B5                 lods    byte ptr es:[si]
BIOSCODE:02B7                 xor     ah, ah
BIOSCODE:02B9                 call    prnop
BIOSCODE:02BC                 jnz     short prn_berr
BIOSCODE:02BE                 loop    prn_tilbloop
BIOSCODE:02C0                 clc                     ; normal no-error return
BIOSCODE:02C1                 retn
BIOSCODE:02C2 ; ---------------------------------------------------------------------------
BIOSCODE:02C2
BIOSCODE:02C2 prn_bperr:                              ; CODE XREF: BIOSCODE:02AB↑j
BIOSCODE:02C2                 pop     cx
BIOSCODE:02C3
BIOSCODE:02C3 prn_berr:                               ; CODE XREF: BIOSCODE:02B3↑j
BIOSCODE:02C3                                         ; BIOSCODE:02BC↑j
BIOSCODE:02C3                 jmp     bc_err_cnt
BIOSCODE:02C6 ; ---------------------------------------------------------------------------
BIOSCODE:02C6
BIOSCODE:02C6 prn_genioctl:                           ; DATA XREF: BIOSCODE:0122↑o
BIOSCODE:02C6                 les     di, ds:ptrsav
BIOSCODE:02CA                 cmp     byte ptr es:[di+13], 5 ; [es:di+IOCTL_REQ.MAJORFUNCTION]
BIOSCODE:02CA                                         ; ioc_pc
BIOSCODE:02CF                 jnz     short prnfuncerr
BIOSCODE:02D1                 mov     al, es:[di+14]  ; [es:di+IOCTL_REQ.MINORFUNCTION]
BIOSCODE:02D5                 les     di, es:[di+19]  ; [es:di+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:02D9                 xor     bh, bh
BIOSCODE:02DB                 mov     bl, ds:printdev
BIOSCODE:02DF                 shl     bx, 1
BIOSCODE:02E1                 mov     cx, ds:wait_count[bx] ; pull out retry count for device
BIOSCODE:02E5                 cmp     al, 65h         ; get_retry_count
BIOSCODE:02E7                 jz      short prngetcount
BIOSCODE:02E9                 cmp     al, 45h         ; set_retry_count
BIOSCODE:02EB                 jnz     short prnfuncerr
BIOSCODE:02ED                 mov     cx, es:[di]
BIOSCODE:02F0
BIOSCODE:02F0 prngetcount:                            ; CODE XREF: BIOSCODE:02E7↑j
BIOSCODE:02F0                 mov     ds:wait_count[bx], cx
BIOSCODE:02F4                 mov     es:[di], cx     ; [es:di+A_RETRYCOUNT.RC_COUNT]
BIOSCODE:02F4                                         ; return current retry count
BIOSCODE:02F7
BIOSCODE:02F7 IOCtlSupported:                         ; CODE XREF: BIOSCODE:030A↓j
BIOSCODE:02F7                                         ; BIOSCODE:030E↓j
BIOSCODE:02F7                 clc
BIOSCODE:02F8                 retn
BIOSCODE:02F9 ; ---------------------------------------------------------------------------
BIOSCODE:02F9
BIOSCODE:02F9 prn_ioctl_query:                        ; DATA XREF: BIOSCODE:012E↑o
BIOSCODE:02F9                 les     di, ds:ptrsav
BIOSCODE:02FD                 cmp     byte ptr es:[di+13], 5 ; [es:di+IOCTL_REQ.MAJORFUNCTION]
BIOSCODE:02FD                                         ; ioc_pc
BIOSCODE:0302                 jnz     short prn_query_err
BIOSCODE:0304                 mov     al, es:[di+14]  ; [es:di+IOCTL_REQ.MINORFUNCTION]
BIOSCODE:0308                 cmp     al, 65h         ; GET_RETRY_COUNT
BIOSCODE:030A                 jz      short IOCtlSupported
BIOSCODE:030C                 cmp     al, 45h         ; SET_RETRY_COUNT
BIOSCODE:030E                 jz      short IOCtlSupported
BIOSCODE:0310
BIOSCODE:0310 prn_query_err:                          ; CODE XREF: BIOSCODE:0302↑j
BIOSCODE:0310                 stc
BIOSCODE:0311
BIOSCODE:0311 prnfuncerr:                             ; CODE XREF: BIOSCODE:02CF↑j
BIOSCODE:0311                                         ; BIOSCODE:02EB↑j
BIOSCODE:0311                 jmp     bc_cmderr
BIOSCODE:0314 ; ---------------------------------------------------------------------------
BIOSCODE:0314
BIOSCODE:0314 aux_read:                               ; DATA XREF: BIOSCODE:0139↑o
BIOSCODE:0314                 jcxz    short exvec2
BIOSCODE:0316                 call    getbx           ; put address of auxbuf   in bx
BIOSCODE:0319                 xor     al, al
BIOSCODE:031B                 xchg    al, [bx]
BIOSCODE:031D                 or      al, al
BIOSCODE:031F                 jnz     short aux2
BIOSCODE:0321
BIOSCODE:0321 aux1:                                   ; CODE XREF: BIOSCODE:0325↓j
BIOSCODE:0321                 call    auxin           ; get character from port
BIOSCODE:0321                                         ; won't return if error
BIOSCODE:0324
BIOSCODE:0324 aux2:                                   ; CODE XREF: BIOSCODE:031F↑j
BIOSCODE:0324                 stosb
BIOSCODE:0325                 loop    aux1            ; if more characters, go around again
BIOSCODE:0327
BIOSCODE:0327 exvec2:                                 ; CODE XREF: BIOSCODE:aux_read↑j
BIOSCODE:0327                                         ; BIOSCODE:aux_writ↓j
BIOSCODE:0327                 clc                     ; all done, successful exit
BIOSCODE:0328
BIOSCODE:0328 auxin_retn:                             ; CODE XREF: BIOSCODE:0331↓j
BIOSCODE:0328                 retn
BIOSCODE:0329 ; ---------------------------------------------------------------------------
BIOSCODE:0329
BIOSCODE:0329 auxin:                                  ; CODE XREF: BIOSCODE:aux1↑p
BIOSCODE:0329                                         ; BIOSCODE:034D↓p
BIOSCODE:0329                 mov     ah, 2
BIOSCODE:032B                 call    auxop
BIOSCODE:032E                 test    ah, 0Eh         ; flag_frame|flag_parity|flag_overrun
BIOSCODE:0331                 jz      short auxin_retn
BIOSCODE:0333
BIOSCODE:0333 arbad:
BIOSCODE:0333                 pop     ax
BIOSCODE:0334                 mov     al, 0B0h        ; flag_rec_sig|flag_dsr|flag_cts
BIOSCODE:0336                 jmp     short bc_err_cnt_j
BIOSCODE:0338 ; ---------------------------------------------------------------------------
BIOSCODE:0338
BIOSCODE:0338 aux_rdnd:                               ; DATA XREF: BIOSCODE:013B↑o
BIOSCODE:0338                 call    getbx           ; non-destructive aux port read
BIOSCODE:033B                 mov     al, [bx]
BIOSCODE:033D                 or      al, al
BIOSCODE:033F                 jnz     short auxrdx    ; if al is non-zero (char in buffer)
BIOSCODE:033F                                         ; then return character
BIOSCODE:0341                 call    auxstat         ; if not, get status of   aux device
BIOSCODE:0344                 test    ah, 1           ; flag_data_ready - test data ready
BIOSCODE:0347                 jz      short auxbus    ; then device is busy (not ready)
BIOSCODE:0349                 test    al, 20h         ; flag_dsr - test data set ready
BIOSCODE:034B                 jz      short auxbus    ; then device is busy (not ready)
BIOSCODE:034D                 call    auxin           ; else aux is ready, get character
BIOSCODE:0350                 mov     [bx], al
BIOSCODE:0352
BIOSCODE:0352 auxrdx:                                 ; CODE XREF: BIOSCODE:033F↑j
BIOSCODE:0352                 jmp     rdexit          ; return busy status
BIOSCODE:0355 ; ---------------------------------------------------------------------------
BIOSCODE:0355
BIOSCODE:0355 auxbus:                                 ; CODE XREF: BIOSCODE:0347↑j
BIOSCODE:0355                                         ; BIOSCODE:034B↑j ...
BIOSCODE:0355                 jmp     z_bus_exit
BIOSCODE:0358 ; ---------------------------------------------------------------------------
BIOSCODE:0358
BIOSCODE:0358 aux_wrst:                               ; DATA XREF: BIOSCODE:0145↑o
BIOSCODE:0358                 call    auxstat         ; return aux port write status
BIOSCODE:035B                 test    al, 20h         ; test data set ready
BIOSCODE:035D                 jz      short auxbus    ; then device is busy (not ready)
BIOSCODE:035F                 test    ah, 20h         ; flag_tranhol_emp - test transmit hold reg
BIOSCODE:0362                 jz      short auxbus    ; then device is busy (not ready)
BIOSCODE:0364                 clc
BIOSCODE:0365                 retn
BIOSCODE:0366
BIOSCODE:0366 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0366
BIOSCODE:0366
BIOSCODE:0366 auxstat         proc near               ; CODE XREF: BIOSCODE:0341↑p
BIOSCODE:0366                                         ; BIOSCODE:aux_wrst↑p
BIOSCODE:0366                 mov     ah, 3           ; auxfunc_status
BIOSCODE:0366 auxstat         endp
BIOSCODE:0366
BIOSCODE:0368
BIOSCODE:0368 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0368
BIOSCODE:0368
BIOSCODE:0368 auxop           proc near               ; CODE XREF: BIOSCODE:032B↑p
BIOSCODE:0368                                         ; BIOSCODE:038B↓p
BIOSCODE:0368                 mov     dx, ds:auxnum   ; ah=function code
BIOSCODE:0368                                         ; 0=init, 1=send, 2=receive, 3=status
BIOSCODE:0368                                         ; get port number
BIOSCODE:036C                 push    ds
BIOSCODE:036D                 push    di
BIOSCODE:036E                 xor     di, di
BIOSCODE:0370                 mov     ds, di
BIOSCODE:0372                 assume ds:nothing
BIOSCODE:0372                 pop     di
BIOSCODE:0373                 pushf                   ; simulate INT 14h
BIOSCODE:0374                 cli
BIOSCODE:0375                 call    dword ptr ds:50h ; INT 14h vector (14h*4 = 50h)
BIOSCODE:0375                                         ; SERIAL I/O - GET USART STATUS
BIOSCODE:0375                                         ; DX = port number (0-3)
BIOSCODE:0375                                         ; Return: AX = port status code
BIOSCODE:0379                 pop     ds
BIOSCODE:037A                 assume ds:nothing
BIOSCODE:037A                 retn
BIOSCODE:037A auxop           endp
BIOSCODE:037A
BIOSCODE:037B ; ---------------------------------------------------------------------------
BIOSCODE:037B
BIOSCODE:037B aux_flsh:                               ; DATA XREF: BIOSCODE:013F↑o
BIOSCODE:037B                 call    getbx           ; flush aux input buffer
BIOSCODE:037B                                         ; get bx to point to auxbuf
BIOSCODE:037B                                         ; zero out buffer
BIOSCODE:037B                                         ; all done, successful return
BIOSCODE:037E                 mov     byte ptr [bx], 0
BIOSCODE:0381                 clc
BIOSCODE:0382                 retn
BIOSCODE:0383 ; ---------------------------------------------------------------------------
BIOSCODE:0383
BIOSCODE:0383 aux_writ:                               ; DATA XREF: BIOSCODE:0141↑o
BIOSCODE:0383                                         ; BIOSCODE:0143↑o
BIOSCODE:0383                 jcxz    short exvec2    ; write to aux device (if cx > 0)
BIOSCODE:0385
BIOSCODE:0385 aux_loop:                               ; CODE XREF: BIOSCODE:awok↓j
BIOSCODE:0385                 mov     al, es:[di]     ; get character to be written
BIOSCODE:0388                 inc     di              ; move di pointer to next character
BIOSCODE:0389                 mov     ah, 1           ; auxfunc_send - indicates a write
BIOSCODE:038B                 call    auxop           ; send character over aux port
BIOSCODE:038E                 test    ah, 80h         ; check for error
BIOSCODE:0391                 jz      short awok      ; then no error
BIOSCODE:0393                 mov     al, 10          ; else indicate write fault
BIOSCODE:0395
BIOSCODE:0395 bc_err_cnt_j:                           ; CODE XREF: BIOSCODE:0336↑j
BIOSCODE:0395                 jmp     bc_err_cnt      ; call error routines
BIOSCODE:0398 ; ---------------------------------------------------------------------------
BIOSCODE:0398
BIOSCODE:0398 awok:                                   ; CODE XREF: BIOSCODE:0391↑j
BIOSCODE:0398                 loop    aux_loop        ; move di pointer to next character
BIOSCODE:039A                 clc
BIOSCODE:039B                 retn
BIOSCODE:039C
BIOSCODE:039C ; =============== S U B R O U T I N E =======================================
BIOSCODE:039C
BIOSCODE:039C
BIOSCODE:039C getbx           proc near               ; CODE XREF: BIOSCODE:0316↑p
BIOSCODE:039C                                         ; BIOSCODE:aux_rdnd↑p ...
BIOSCODE:039C                 mov     bx, ds:auxnum   ; return bx -> single byte input buffer
BIOSCODE:039C                                         ; for selected aux port ([auxnum])
BIOSCODE:03A0                 add     bx, offset auxbuf
BIOSCODE:03A4                 retn
BIOSCODE:03A4 getbx           endp
BIOSCODE:03A4
BIOSCODE:03A5 ; ---------------------------------------------------------------------------
BIOSCODE:03A5
BIOSCODE:03A5 time_to_ticks:                          ; DATA XREF: BIOSDATA:ttticks↑o
BIOSCODE:03A5                 mov     al, 60          ; convert time to ticks
BIOSCODE:03A5                                         ; input : time in cx and dx
BIOSCODE:03A5                                         ; output: ticks returned in cx:dx
BIOSCODE:03A5                                         ;
BIOSCODE:03A5                                         ; the clock ticks at the rate of:
BIOSCODE:03A5                                         ; 1193180/65536 ticks/second
BIOSCODE:03A5                                         ; (about 18.2 ticks per second)
BIOSCODE:03A7                 mul     ch              ; hours to minutes ///
BIOSCODE:03A7                                         ; first convert from hour,min,sec,hund. to
BIOSCODE:03A7                                         ; total number of 100th of seconds
BIOSCODE:03A9                 mov     ch, 0
BIOSCODE:03AB                 add     ax, cx          ; total minutes
BIOSCODE:03AD                 mov     cx, 6000        ; 60*100
BIOSCODE:03B0                 mov     bx, dx
BIOSCODE:03B2                 mul     cx              ; convert to 1/100 sec
BIOSCODE:03B4                 mov     cx, ax
BIOSCODE:03B6                 mov     al, 100
BIOSCODE:03B8                 mul     bh              ; convert seconds to 1/100 sec
BIOSCODE:03BA                 add     cx, ax          ; combine seconds with hours and min
BIOSCODE:03BC                 adc     dx, 0
BIOSCODE:03BF                 mov     bh, 0
BIOSCODE:03C1                 add     cx, bx          ; combine 1/100 sec
BIOSCODE:03C3                 adc     dx, 0           ; dx:cx is time in 1/100 sec
BIOSCODE:03C6                 xchg    ax, dx
BIOSCODE:03C7                 xchg    ax, cx          ; now time is in cx:ax
BIOSCODE:03C8                 mov     bx, 59659
BIOSCODE:03CB                 mul     bx              ; multiply low half
BIOSCODE:03CD                 xchg    dx, cx
BIOSCODE:03CF                 xchg    ax, dx          ; cx->ax, ax->dx, dx->cx
BIOSCODE:03D0                 mul     bx              ; multiply high half
BIOSCODE:03D2                 add     ax, cx          ; combine overlapping products
BIOSCODE:03D4                 adc     dx, 0
BIOSCODE:03D7                 xchg    ax, dx          ; ax:dx=time*59659
BIOSCODE:03D8                 mov     bx, 5
BIOSCODE:03DB                 div     bl              ; divide high half by 5
BIOSCODE:03DD                 mov     cl, al
BIOSCODE:03DF                 mov     ch, 0
BIOSCODE:03E1                 mov     al, ah          ; remainder of divide-by-5
BIOSCODE:03E3                 cbw
BIOSCODE:03E4                 xchg    ax, dx          ; use it to extend low half
BIOSCODE:03E5                 div     bx              ; divide low half by 5
BIOSCODE:03E7                 mov     dx, ax          ; cx:dx is now number of ticks in time
BIOSCODE:03E9                 retf
BIOSCODE:03EA ; ---------------------------------------------------------------------------
BIOSCODE:03EA
BIOSCODE:03EA tim_writ:                               ; DATA XREF: BIOSCODE:0158↑o
BIOSCODE:03EA                                         ; BIOSCODE:015A↑o
BIOSCODE:03EA                 mov     ax, es:[di]     ; sets the current time
BIOSCODE:03ED                 push    ax              ; daycnt. we need to set this at the very
BIOSCODE:03ED                                         ; end to avoid tick windows
BIOSCODE:03EE                 cmp     ds:havecmoscloc, 0
BIOSCODE:03F3                 jz      short no_cmos_1
BIOSCODE:03F5                 mov     al, es:[di+3]   ; get binary hours
BIOSCODE:03F5                                         ; convert to bcd
BIOSCODE:03F9                 call    bintobcd
BIOSCODE:03FC                 mov     ch, al          ; ch = bcd hours
BIOSCODE:03FE                 mov     al, es:[di+2]   ; get binary minutes
BIOSCODE:0402                 call    bintobcd
BIOSCODE:0405                 mov     cl, al          ; cl = bcd minutes
BIOSCODE:0407                 mov     al, es:[di+5]   ; get binary seconds
BIOSCODE:040B                 call    bintobcd
BIOSCODE:040E                 mov     dh, al          ; dh = bcd seconds
BIOSCODE:0410                 mov     dl, 0           ; dl = 0 (st) or 1 (dst)
BIOSCODE:0412                 cli
BIOSCODE:0413                 mov     ah, 3
BIOSCODE:0415                 int     1Ah             ; CLOCK - SET REAL TIME CLOCK (AT,XT286,CONV,PS)
BIOSCODE:0415                                         ; CH = hours in BCD, CL = minutes in BCD
BIOSCODE:0415                                         ;  DH = seconds in BCD,DL = 01h if daylight savings, 00h if standard time
BIOSCODE:0415                                         ; Return: CMOS clock set
BIOSCODE:0417                 sti
BIOSCODE:0418
BIOSCODE:0418 no_cmos_1:                              ; CODE XREF: BIOSCODE:03F3↑j
BIOSCODE:0418                 push    ds
BIOSCODE:0419                 lds     cx, es:[di+2]
BIOSCODE:041D                 mov     dx, ds
BIOSCODE:041F                 pop     ds
BIOSCODE:0420                 call    dword ptr ds:ttticks ; convert time to ticks
BIOSCODE:0420                                         ; cx:dx now has time in ticks
BIOSCODE:0424                 cli                     ; turn off timer
BIOSCODE:0425                 mov     ah, 1
BIOSCODE:0427                 int     1Ah             ; CLOCK - SET TIME OF DAY
BIOSCODE:0427                                         ; CX:DX = clock count
BIOSCODE:0427                                         ; Return: time of day set
BIOSCODE:0429                 pop     ds:daycnt
BIOSCODE:042D                 sti
BIOSCODE:042E                 cmp     ds:havecmoscloc, 0
BIOSCODE:0433                 jz      short no_cmos_2
BIOSCODE:0435                 call    daycnttoday
BIOSCODE:0438                 cli
BIOSCODE:0439                 mov     ah, 5
BIOSCODE:043B                 int     1Ah             ; CLOCK - SET DATE IN REAL TIME CLOCK (AT,XT286,CONV,PS)
BIOSCODE:043B                                         ; DL = day in BCD, DH = month in BCD, CL = year in BCD
BIOSCODE:043B                                         ; CH = century (19h or 20h)
BIOSCODE:043B                                         ; Return: CMOS clock set
BIOSCODE:043D                 sti
BIOSCODE:043E
BIOSCODE:043E no_cmos_2:                              ; CODE XREF: BIOSCODE:0433↑j
BIOSCODE:043E                 clc
BIOSCODE:043F                 retn
BIOSCODE:0440
BIOSCODE:0440 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0440
BIOSCODE:0440
BIOSCODE:0440 daycnttoday     proc near               ; CODE XREF: BIOSCODE:0435↑p
BIOSCODE:0440                 push    ds:daycnt       ; entry: [daycnt] = number of days since 1-1-80
BIOSCODE:0440                                         ; return: ch - century in bcd
BIOSCODE:0440                                         ;         cl - year in bcd
BIOSCODE:0440                                         ;         dh - month in bcd
BIOSCODE:0440                                         ;         dl - day in bcd
BIOSCODE:0444                 cmp     ds:daycnt, 7305 ; (365*20+(20/4))
BIOSCODE:0444                                         ; # days from 1-1-1980 to 1-1-2000
BIOSCODE:044A                 jnb     short century20
BIOSCODE:044C                 mov     word ptr ds:base_century, 5013h ; base century = 19
BIOSCODE:044C                                         ; base year = 80
BIOSCODE:0452                 jmp     short years
BIOSCODE:0454 ; ---------------------------------------------------------------------------
BIOSCODE:0454
BIOSCODE:0454 century20:                              ; CODE XREF: daycnttoday+A↑j
BIOSCODE:0454                 mov     word ptr ds:base_century, 20 ; base century = 20
BIOSCODE:0454                                         ; base year = 0
BIOSCODE:045A                 sub     ds:daycnt, 7305 ; 365*20+(20/4))
BIOSCODE:045A                                         ; adjust daycnt
BIOSCODE:0460
BIOSCODE:0460 years:                                  ; CODE XREF: daycnttoday+12↑j
BIOSCODE:0460                 xor     dx, dx
BIOSCODE:0462                 mov     ax, ds:daycnt
BIOSCODE:0465                 mov     bx, 1461        ; 366+365*3)
BIOSCODE:0465                                         ; # of days in a Leap year block
BIOSCODE:0468                 div     bx              ; ax = # of leap block, dx = daycnt
BIOSCODE:046A                 mov     ds:daycnt, dx   ; save daycnt left
BIOSCODE:046E                 mov     bl, 4
BIOSCODE:0470                 mul     bl
BIOSCODE:0472                 add     ds:base_year, al ; ax = # of years. Less than 100
BIOSCODE:0476                 inc     ds:daycnt
BIOSCODE:047A                 cmp     ds:daycnt, 366  ; daycnt = remainder of leap year block
BIOSCODE:047A                                         ; within 366+355+355+355 days
BIOSCODE:0480                 jbe     short leapyear
BIOSCODE:0482                 inc     ds:base_year    ; if daycnt <= 366, then leap year
BIOSCODE:0482                                         ; else daycnt -= 366, base_year++
BIOSCODE:0486                 sub     ds:daycnt, 366
BIOSCODE:048C                 mov     cx, 3           ; And next three years are normal
BIOSCODE:048F
BIOSCODE:048F regularyear:                            ; CODE XREF: daycnttoday+61↓j
BIOSCODE:048F                 cmp     ds:daycnt, 365  ; for(i=1; i>3 or daycnt <=365; i++)
BIOSCODE:0495                 jbe     short yeardone  ; {if (daycnt > 365)
BIOSCODE:0497                 inc     ds:base_year    ; { daycnt -= 365
BIOSCODE:049B                 sub     ds:daycnt, 365  ; }
BIOSCODE:04A1                 loop    regularyear     ; }
BIOSCODE:04A1                                         ; should never fall through loop
BIOSCODE:04A3
BIOSCODE:04A3 leapyear:                               ; CODE XREF: daycnttoday+40↑j
BIOSCODE:04A3                 mov     ds:february, 29 ; leap year.
BIOSCODE:04A3                                         ; change month table.
BIOSCODE:04A8
BIOSCODE:04A8 yeardone:                               ; CODE XREF: daycnttoday+55↑j
BIOSCODE:04A8                 xor     bx, bx
BIOSCODE:04AA                 xor     dx, dx
BIOSCODE:04AC                 mov     ax, ds:daycnt
BIOSCODE:04AF                 mov     si, offset month_table
BIOSCODE:04B2                 mov     cx, 12
BIOSCODE:04B5
BIOSCODE:04B5 months:                                 ; CODE XREF: daycnttoday+80↓j
BIOSCODE:04B5                 inc     bl
BIOSCODE:04B7                 mov     dl, [si]
BIOSCODE:04B9                 cmp     ax, dx          ; cmp daycnt for each month till fit
BIOSCODE:04B9                                         ; dh=0
BIOSCODE:04BB                 jbe     short month_done
BIOSCODE:04BD                 inc     si              ; next month
BIOSCODE:04BE                 sub     ax, dx          ; adjust daycnt
BIOSCODE:04C0                 loop    months          ;
BIOSCODE:04C0                                         ; should never fall through loop
BIOSCODE:04C2
BIOSCODE:04C2 month_done:                             ; CODE XREF: daycnttoday+7B↑j
BIOSCODE:04C2                 mov     ds:february, 28 ; restore month table value
BIOSCODE:04C7                 mov     dl, bl
BIOSCODE:04C9                 mov     dh, ds:base_year
BIOSCODE:04CD                 mov     cl, ds:base_century ; al=day,dl=month,dh=year,cl=cntry
BIOSCODE:04D1                 call    bintobcd        ; convert "day" to bcd
BIOSCODE:04D1                                         ; dl = bcd day, al = month
BIOSCODE:04D4                 xchg    dl, al
BIOSCODE:04D6                 call    bintobcd        ; dh = bcd month, al = year
BIOSCODE:04D9                 xchg    dh, al
BIOSCODE:04DB                 call    bintobcd        ; cl = bcd year, al = century
BIOSCODE:04DE                 xchg    cl, al
BIOSCODE:04E0                 call    bintobcd        ; ch = bcd century
BIOSCODE:04E3                 mov     ch, al
BIOSCODE:04E5                 pop     ds:daycnt       ; restore original value
BIOSCODE:04E9                 retn
BIOSCODE:04E9 daycnttoday     endp
BIOSCODE:04E9
BIOSCODE:04EA
BIOSCODE:04EA ; =============== S U B R O U T I N E =======================================
BIOSCODE:04EA
BIOSCODE:04EA
BIOSCODE:04EA bintobcd        proc near               ; CODE XREF: BIOSCODE:03F9↑p
BIOSCODE:04EA                                         ; BIOSCODE:0402↑p ...
BIOSCODE:04EA                 aam                     ; convert a binary input in al
BIOSCODE:04EA                                         ; (less than 63h or 99 decimal)
BIOSCODE:04EA                                         ; into a bcd value in al. ah destroyed
BIOSCODE:04EA                                         ;
BIOSCODE:04EA                                         ; AH = AL/10, AL = AL MOD 10
BIOSCODE:04EC                 aad     10h             ; db 0D5h,10h
BIOSCODE:04EC                                         ; AL = (AH*10H)+AL, AH = 0
BIOSCODE:04EE                 retn
BIOSCODE:04EE bintobcd        endp
BIOSCODE:04EE
BIOSCODE:04EF ; ---------------------------------------------------------------------------
BIOSCODE:04EF
BIOSCODE:04EF tim_read:                               ; DATA XREF: BIOSCODE:0150↑o
BIOSCODE:04EF                 call    GetTickCnt      ; gettime reads date and time
BIOSCODE:04EF                                         ;
BIOSCODE:04EF                                         ; 65,536 seconds = 1,193,180 ticks
BIOSCODE:04EF                                         ;
BIOSCODE:04EF                                         ; time in 100th of seconds
BIOSCODE:04EF                                         ;    = ticks from clock  * 65,536 * 100 / 1,193,180
BIOSCODE:04EF                                         ;    = ticks from clock * 5 * 65,536 / 59,659
BIOSCODE:04F2                 mov     si, ds:daycnt
BIOSCODE:04F6                 mov     ax, cx
BIOSCODE:04F8                 mov     bx, dx          ; start with ticks in cx:dx
BIOSCODE:04F8                                         ; multiply by 5
BIOSCODE:04FA                 shl     dx, 1
BIOSCODE:04FC                 rcl     cx, 1
BIOSCODE:04FE                 shl     dx, 1
BIOSCODE:0500                 rcl     cx, 1
BIOSCODE:0502                 add     dx, bx
BIOSCODE:0504                 adc     ax, cx
BIOSCODE:0506                 xchg    ax, dx
BIOSCODE:0507                 mov     cx, 59659       ; multiply by 65536 and divide by 59659
BIOSCODE:050A                 div     cx              ; dx has remainder
BIOSCODE:050A                                         ; ax has high word of final quotient
BIOSCODE:050C                 xchg    ax, bx          ; put high word in safe place
BIOSCODE:050D                 xor     ax, ax          ; multiply by 65536
BIOSCODE:050F                 div     cx              ; bx:ax has time in 100th of seconds
BIOSCODE:0511                 mov     dx, bx
BIOSCODE:0513                 mov     cx, 200         ; division by 200 is necessary
BIOSCODE:0513                                         ; to ensure no overflow--max result
BIOSCODE:0513                                         ; is number of seconds in a day/2 = 43200.
BIOSCODE:0516                 div     cx
BIOSCODE:0518                 cmp     dl, 100         ; remainder over 100?
BIOSCODE:051B                 jb      short noadj
BIOSCODE:051D                 sub     dl, 100         ; keep 1/100's less than 100
BIOSCODE:0520
BIOSCODE:0520 noadj:                                  ; CODE XREF: BIOSCODE:051B↑j
BIOSCODE:0520                 cmc                     ; if we subtracted 100, carry is now set
BIOSCODE:0521                 mov     bl, dl          ; save 1/100's
BIOSCODE:0523                 rcl     ax, 1           ; multiply by two
BIOSCODE:0525                 mov     dl, 0
BIOSCODE:0527                 rcl     dx, 1
BIOSCODE:0529                 mov     cl, 60          ; divide out seconds
BIOSCODE:052B                 div     cx
BIOSCODE:052D                 mov     bh, dl          ; save the seconds
BIOSCODE:052F                 div     cl              ; break into hours and minutes
BIOSCODE:0531                 xchg    al, ah          ; time is now in ax:bx
BIOSCODE:0531                                         ; (hours, minutes, seconds, 1/100 sec)
BIOSCODE:0533                 xchg    ax, si          ; daycnt
BIOSCODE:0534                 stosw
BIOSCODE:0535                 xchg    ax, si          ; al = hours, ah = minutes
BIOSCODE:0536                 stosw
BIOSCODE:0537                 mov     ax, bx
BIOSCODE:0539                 stosw
BIOSCODE:053A                 clc                     ; [es:di] = count of days since 1-1-80
BIOSCODE:053A                                         ;    [es:di+2] = hours
BIOSCODE:053A                                         ;    [es:di+3] = minutes
BIOSCODE:053A                                         ;    [es:di+4] = seconds
BIOSCODE:053A                                         ;    [es:di+5] = hundredths of seconds
BIOSCODE:053B                 retn
BIOSCODE:053C
BIOSCODE:053C ; =============== S U B R O U T I N E =======================================
BIOSCODE:053C
BIOSCODE:053C
BIOSCODE:053C GetTickCnt      proc near               ; CODE XREF: BIOSCODE:tim_read↑p
BIOSCODE:053C                                         ; Check_Time_Of_Access+3↓p ...
BIOSCODE:053C                 xor     ah, ah          ; Returns the tick count in cx:dx
BIOSCODE:053C                                         ; Takes care of DayCnt in case of rollover
BIOSCODE:053C                                         ; if ( rollover ) {
BIOSCODE:053C                                         ;     if ( t_switch )
BIOSCODE:053C                                         ;            daycnt++ ;
BIOSCODE:053C                                         ;     else
BIOSCODE:053C                                         ;            daycnt += rollover ;
BIOSCODE:053C                                         ;     }
BIOSCODE:053E                 int     1Ah             ; CLOCK - GET TIME OF DAY
BIOSCODE:053E                                         ; Return: CX:DX = clock count
BIOSCODE:053E                                         ; AL = 00h if clock was read or written (via AH=0,1) since the previous
BIOSCODE:053E                                         ; midnight
BIOSCODE:053E                                         ; Otherwise, AL > 0
BIOSCODE:0540                 xor     ah, ah
BIOSCODE:0542                 cmp     ds:t_switch, ah ; use old method ? (>0 is yes)
BIOSCODE:0546                 jnz     short inc_case  ; old method assumes that Int 1Ah returns rollover flag
BIOSCODE:0548                 add     ds:daycnt, ax   ; new method assumes that Int 1Ah returns roll over count
BIOSCODE:0548                                         ; and not flag
BIOSCODE:054C                 retn
BIOSCODE:054D ; ---------------------------------------------------------------------------
BIOSCODE:054D
BIOSCODE:054D inc_case:                               ; CODE XREF: GetTickCnt+A↑j
BIOSCODE:054D                 or      al, al
BIOSCODE:054F                 jz      short no_rollover
BIOSCODE:0551                 inc     ds:daycnt
BIOSCODE:0555
BIOSCODE:0555 no_rollover:                            ; CODE XREF: GetTickCnt+13↑j
BIOSCODE:0555                 retn
BIOSCODE:0555 GetTickCnt      endp
BIOSCODE:0555
BIOSCODE:0555 ; ---------------------------------------------------------------------------
BIOSCODE:0556 fat_12_id       db 'FAT12   '           ; DATA XREF: clear_ids+2C↓o
BIOSCODE:055E fat_16_id       db 'FAT16   '           ; DATA XREF: clear_ids+27↓o
BIOSCODE:0566 fat_32_id       db 'FAT32   '           ; DATA XREF: clear_ids+1D↓o
BIOSCODE:056E nul_vid         db 'NO NAME    '        ; DATA XREF: clear_ids+F↓o
BIOSCODE:056E                                         ; read_volume_id+B↓o
BIOSCODE:0579 DSKTBL          db 26                   ; DATA XREF: BIOSDATA:0661↑o
BIOSCODE:0579                                         ; BIOSCODE:0079↑o
BIOSCODE:057A                 dw offset dsk_init
BIOSCODE:057C                 dw offset media_chk
BIOSCODE:057E                 dw offset get_bpb
BIOSCODE:0580                 dw offset ioctl_input   ; PCDOS 7
BIOSCODE:0582                 dw offset dsk_read
BIOSCODE:0584                 dw offset x_bus_exit
BIOSCODE:0586                 dw offset ret_carry_clear
BIOSCODE:0588                 dw offset ret_carry_clear
BIOSCODE:058A                 dw offset dsk_writ
BIOSCODE:058C                 dw offset dsk_writv
BIOSCODE:058E                 dw offset ret_carry_clear
BIOSCODE:0590                 dw offset ret_carry_clear
BIOSCODE:0592                 dw offset ioctl_output  ; PCDOS 7
BIOSCODE:0594                 dw offset dsk_open
BIOSCODE:0596                 dw offset dsk_close
BIOSCODE:0598                 dw offset dsk_rem
BIOSCODE:059A                 dw offset ret_carry_clear
BIOSCODE:059C                 dw offset ret_carry_clear
BIOSCODE:059E                 dw offset ret_carry_clear
BIOSCODE:05A0                 dw offset do_generic_ioctl
BIOSCODE:05A2                 dw offset ret_carry_clear
BIOSCODE:05A4                 dw offset ret_carry_clear
BIOSCODE:05A6                 dw offset ret_carry_clear
BIOSCODE:05A8                 dw offset ioctl_getown
BIOSCODE:05AA                 dw offset ioctl_setown
BIOSCODE:05AC                 dw offset ioctl_support_query
BIOSCODE:05AE
BIOSCODE:05AE ; =============== S U B R O U T I N E =======================================
BIOSCODE:05AE
BIOSCODE:05AE
BIOSCODE:05AE SetDrive        proc near               ; CODE XREF: BIOSCODE:media_chk↓p
BIOSCODE:05AE                                         ; get_bpb+3↓p ...
BIOSCODE:05AE                 les     di, dword ptr ds:start_bds ; Point es:di to first bds
BIOSCODE:05B2
BIOSCODE:05B2 X_Scan_Loop:                            ; CODE XREF: SetDrive+10↓j
BIOSCODE:05B2                 cmp     es:[di+5], al   ; logical drive number (BDS.drivelet)
BIOSCODE:05B6                 jz      short X_SetDrv
BIOSCODE:05B8                 les     di, es:[di]     ; [es:di+BDS.link] ; Go to next bds
BIOSCODE:05BB                 cmp     di, 0FFFFh
BIOSCODE:05BE                 jnz     short X_Scan_Loop
BIOSCODE:05C0                 stc
BIOSCODE:05C1
BIOSCODE:05C1 X_SetDrv:                               ; CODE XREF: SetDrive+8↑j
BIOSCODE:05C1                 retn
BIOSCODE:05C1 SetDrive        endp
BIOSCODE:05C1
BIOSCODE:05C2 ; ---------------------------------------------------------------------------
BIOSCODE:05C2
BIOSCODE:05C2 media_chk:                              ; DATA XREF: BIOSCODE:057C↑o
BIOSCODE:05C2                 call    SetDrive
BIOSCODE:05C5                 mov     si, 1
BIOSCODE:05C8                 test    byte ptr es:[di+40h], 1 ; [es:di+BDS.flags+1], fchanged_by_format
BIOSCODE:05CD                 jz      short WeAreNotFakingIt
BIOSCODE:05CF                 and     byte ptr es:[di+40h], 0FEh ; [es:di+BDS.flags+1],
BIOSCODE:05CF                                         ; ~fchanged_by_format ; reset flag
BIOSCODE:05D4                 mov     ds:tim_drv, 0FFh ; -1
BIOSCODE:05D4                                         ; Ensure that we ask the rom if media has changed
BIOSCODE:05D9                 test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
BIOSCODE:05DE                 jz      short wehaveafloppy
BIOSCODE:05E0                 neg     si
BIOSCODE:05E2                 jmp     short Media_Done
BIOSCODE:05E4 ; ---------------------------------------------------------------------------
BIOSCODE:05E4
BIOSCODE:05E4 WeAreNotFakingIt:                       ; CODE XREF: BIOSCODE:05CD↑j
BIOSCODE:05E4                 test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
BIOSCODE:05E9                 jnz     short Media_Done
BIOSCODE:05EB
BIOSCODE:05EB wehaveafloppy:                          ; CODE XREF: BIOSCODE:05DE↑j
BIOSCODE:05EB                 dec     si              ; 0 ; Presume "I don't know"
BIOSCODE:05EC                 cmp     ds:fhave96, 0   ; Do we have changeline support?
BIOSCODE:05F1                 jz      short mChk_NoChangeLine ; Brif not
BIOSCODE:05F3                 call    mediacheck      ; Call into removable routine
BIOSCODE:05F6                 jb      short err_exitj
BIOSCODE:05F8                 call    haschange
BIOSCODE:05FB                 jnz     short Media_Done
BIOSCODE:05FD
BIOSCODE:05FD mChk_NoChangeLine:                      ; CODE XREF: BIOSCODE:05F1↑j
BIOSCODE:05FD                 mov     si, 1           ; Presume no change
BIOSCODE:0600                 mov     al, ds:tim_drv  ; Last drive accessed
BIOSCODE:0603                 cmp     al, es:[di+4]   ; [es:di+BDS.drivenum]
BIOSCODE:0603                                         ; Is drive of last access the same?
BIOSCODE:0607                 jnz     short Media_Unk ; No, then "i don't know"
BIOSCODE:0609                 call    Check_Time_Of_Access
BIOSCODE:060C                 jmp     short Media_Done
BIOSCODE:060E ; ---------------------------------------------------------------------------
BIOSCODE:060E
BIOSCODE:060E Media_Unk:                              ; CODE XREF: BIOSCODE:0607↑j
BIOSCODE:060E                 dec     si              ; 0 ; Return "I don't know"
BIOSCODE:060F
BIOSCODE:060F Media_Done:                             ; CODE XREF: BIOSCODE:05E2↑j
BIOSCODE:060F                                         ; BIOSCODE:05E9↑j ...
BIOSCODE:060F                 push    es
BIOSCODE:0610                 les     bx, ds:ptrsav
BIOSCODE:0614                 mov     es:[bx+14], si  ; [es:bx+trans]
BIOSCODE:0618                 pop     es
BIOSCODE:0619                 or      si, si
BIOSCODE:061B                 jns     short ret_carry_clear ; volidok
BIOSCODE:061D                 cmp     ds:fhave96, 0
BIOSCODE:0622                 jz      short mChk1_NoChangeLine
BIOSCODE:0624                 call    media_set_vid
BIOSCODE:0627
BIOSCODE:0627 mChk1_NoChangeLine:                     ; CODE XREF: BIOSCODE:0622↑j
BIOSCODE:0627                 mov     ds:tim_drv, 0FFh ; -1
BIOSCODE:0627                                         ; Make sure we ask rom for media check
BIOSCODE:062C
BIOSCODE:062C ret_carry_clear:                        ; CODE XREF: BIOSCODE:061B↑j
BIOSCODE:062C                                         ; DATA XREF: BIOSCODE:0586↑o ...
BIOSCODE:062C                 clc                     ; volidok
BIOSCODE:062D                 retn
BIOSCODE:062E ; ---------------------------------------------------------------------------
BIOSCODE:062E
BIOSCODE:062E err_exitj:                              ; CODE XREF: BIOSCODE:05F6↑j
BIOSCODE:062E                                         ; BIOSCODE:0663↓j ...
BIOSCODE:062E                 call    maperror        ; guaranteed to set carry
BIOSCODE:0631 ; START OF FUNCTION CHUNK FOR get_bpb
BIOSCODE:0631
BIOSCODE:0631 ret81:                                  ; CODE XREF: get_bpb+18↓j
BIOSCODE:0631                 mov     ah, 81h         ; return error status
BIOSCODE:0633                 retn                    ; return with carry set
BIOSCODE:0633 ; END OF FUNCTION CHUNK FOR get_bpb
BIOSCODE:0634
BIOSCODE:0634 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0634
BIOSCODE:0634
BIOSCODE:0634 Check_Time_Of_Access proc near          ; CODE XREF: BIOSCODE:0609↑p
BIOSCODE:0634                                         ; mediacheck+30↓p
BIOSCODE:0634                 mov     si, 1           ; presume no change
BIOSCODE:0637                 call    GetTickCnt      ; cx:dx is the elapsed time
BIOSCODE:063A                 mov     ax, es:[di+79h] ; [es:di+BDS.tim_lo]
BIOSCODE:063A                                         ; get stored time
BIOSCODE:063E                 sub     dx, ax
BIOSCODE:0640                 mov     ax, es:[di+7Bh] ; [es:di+BDS.tim_hi]
BIOSCODE:0644                 sbb     cx, ax
BIOSCODE:0646                 mov     al, ds:accesscount
BIOSCODE:0649                 jnz     short timecheck_unk ; cx<>0 => >1 hour
BIOSCODE:064B                 or      dx, dx          ; time must pass
BIOSCODE:064D                 jnz     short timepassed ; yes, examine max value
BIOSCODE:064F                 inc     al
BIOSCODE:0651                 cmp     al, 5
BIOSCODE:0653                 jb      short timecheck_ret ; if count is less than threshold, ok
BIOSCODE:0655                 dec     al
BIOSCODE:0657                 jmp     short timecheck_unk
BIOSCODE:0659 ; ---------------------------------------------------------------------------
BIOSCODE:0659
BIOSCODE:0659 timepassed:                             ; CODE XREF: Check_Time_Of_Access+19↑j
BIOSCODE:0659                 cmp     dx, 36          ; 18*2 ; 18.2 tics per second.
BIOSCODE:0659                                         ; min elapsed time? (2 seconds)
BIOSCODE:065C                 jbe     short timecheck_ret
BIOSCODE:065E
BIOSCODE:065E timecheck_unk:                          ; CODE XREF: Check_Time_Of_Access+15↑j
BIOSCODE:065E                                         ; Check_Time_Of_Access+23↑j
BIOSCODE:065E                 dec     si              ; presume i don't know
BIOSCODE:065F
BIOSCODE:065F timecheck_ret:                          ; CODE XREF: Check_Time_Of_Access+1F↑j
BIOSCODE:065F                                         ; Check_Time_Of_Access+28↑j
BIOSCODE:065F                 mov     ds:accesscount, al
BIOSCODE:0662                 retn
BIOSCODE:0662 Check_Time_Of_Access endp
BIOSCODE:0662
BIOSCODE:0663 ; ---------------------------------------------------------------------------
BIOSCODE:0663                 jmp     short err_exitj
BIOSCODE:0665
BIOSCODE:0665 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0665
BIOSCODE:0665
BIOSCODE:0665 get_bpb         proc near               ; DATA XREF: BIOSCODE:057E↑o
BIOSCODE:0665
BIOSCODE:0665 ; FUNCTION CHUNK AT BIOSCODE:0631 SIZE 00000003 BYTES
BIOSCODE:0665
BIOSCODE:0665                 mov     ah, es:[di]     ; Build a valid bpb for the disk in the drive.
BIOSCODE:0665                                         ; get fat id byte read by dos
BIOSCODE:0668                 call    SetDrive        ; get the correct bds for the drive
BIOSCODE:066B                 test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
BIOSCODE:0670                 jnz     short already_gotbpb ; no need to build for fixed disks
BIOSCODE:0672                 call    clear_ids
BIOSCODE:0675                 mov     ds:set_id_flag, 1 ; indicate to set system id in bds
BIOSCODE:067A                 call    GetBp           ; build a bpb if necessary
BIOSCODE:067D                 jb      short ret81
BIOSCODE:067F                 cmp     ds:set_id_flag, 2 ; already, volume_label set from boot
BIOSCODE:0684                 mov     ds:set_id_flag, 0 ; record to bds table?
BIOSCODE:0689                 jz      short already_gotbpb ; do not set it again from root dir
BIOSCODE:0689                                         ; otherwise, conventional boot record
BIOSCODE:068B                 cmp     ds:fhave96, 0   ; do we have changeline support?
BIOSCODE:0690                 jz      short already_gotbpb ; brif not
BIOSCODE:0692                 call    set_volume_id
BIOSCODE:0695
BIOSCODE:0695 already_gotbpb:                         ; CODE XREF: get_bpb+B↑j
BIOSCODE:0695                                         ; get_bpb+24↑j ...
BIOSCODE:0695                 add     di, 6           ; BDS.BPB (BDS offset 6)
BIOSCODE:0698
BIOSCODE:0698 SetPtrSav:                              ; CODE XREF: dsk_init+9↓j
BIOSCODE:0698                 push    ds              ; return point for dsk_init
BIOSCODE:0699                 lds     bx, ds:ptrsav
BIOSCODE:069D                 mov     [bx+0Dh], ah    ; [bx+media]
BIOSCODE:06A0                 mov     [bx+12h], di    ; [bx+count]
BIOSCODE:06A3                 mov     word ptr [bx+14h], es ; [bx+count+2]
BIOSCODE:06A6                 push    ds
BIOSCODE:06A7                 pop     es
BIOSCODE:06A8                 pop     ds
BIOSCODE:06A9                 clc
BIOSCODE:06AA                 retn
BIOSCODE:06AA get_bpb         endp
BIOSCODE:06AA
BIOSCODE:06AB
BIOSCODE:06AB ; =============== S U B R O U T I N E =======================================
BIOSCODE:06AB
BIOSCODE:06AB
BIOSCODE:06AB clear_ids       proc near               ; CODE XREF: get_bpb+D↑p
BIOSCODE:06AB                                         ; DATA XREF: copybpb_fat+1C9↑o
BIOSCODE:06AB                 push    di
BIOSCODE:06AC                 xor     cx, cx          ; 0
BIOSCODE:06AE                 mov     es:[di+89h], cx ; [es:di+BDS.vol_serial]
BIOSCODE:06B3                 mov     es:[di+8Bh], cx ; [es:di+BDS.vol_serial+2]
BIOSCODE:06B8                 mov     cl, 11
BIOSCODE:06BA                 mov     si, offset nul_vid ; "NO NAME    "
BIOSCODE:06BD                 add     di, 125         ; BDS.volid
BIOSCODE:06C0                 rep movs byte ptr es:[di], byte ptr cs:[si] ; cs rep movsb
BIOSCODE:06C3                 test    byte ptr es:[di+59], 20h ; (here, es:di points to the BDS offset +136)
BIOSCODE:06C3                                         ; [es:di+BDS.fatsiz], fbigbig
BIOSCODE:06C3                                         ;
BIOSCODE:06C3                                         ; ! NOTE - 26/06/2023 - Erdogan Tan
BIOSCODE:06C3                                         ; Microsoft/IBM code has a bug here because the BDS's
BIOSCODE:06C3                                         ; .volid and .filesys_id fields will be reset
BIOSCODE:06C3                                         ; (to their default text) according to 'BDS.fatsiz' flags
BIOSCODE:06C3                                         ; at the BDS offset 59 but current (this) code checks flags
BIOSCODE:06C3                                         ; at ES:DI+59 while DI points the BDS offset 136!?
BIOSCODE:06C3                                         ;
BIOSCODE:06C3                                         ; Correct Code:
BIOSCODE:06C3                                         ; test byte [ES:DI+59-136],20h or
BIOSCODE:06C3                                         ; DI_POSITION equ BDS.volid + size_of_EXT_BOOT_VOL_LABEL
BIOSCODE:06C3                                         ; test byte [ES:DI:BDS.fatsiz-DI_POSITION],20h ; fbigbig
BIOSCODE:06C3                                         ;
BIOSCODE:06C3                                         ; (Why this bug did not affect MSDOS and PCDOS 7.x applications:
BIOSCODE:06C3                                         ; 'clear_ids' is used for floppy disks only and the default
BIOSCODE:06C3                                         ; option of 'clear_ids' is FAT12 volid and filesys_id text
BIOSCODE:06C3                                         ; when the flag bit has wrong value for FAT16/40h or FAT32/20h.)
BIOSCODE:06C8                 mov     si, offset fat_32_id ; "FAT32   "
BIOSCODE:06CB                 jnz     short ci_bigfat
BIOSCODE:06CD                 test    byte ptr es:[di+59], 40h ; [es:di+BDS.fatsiz], fbig
BIOSCODE:06D2                 mov     si, offset fat_16_id ; "FAT16   "
BIOSCODE:06D5                 jnz     short ci_bigfat
BIOSCODE:06D7                 mov     si, offset fat_12_id ; "FAT12   "
BIOSCODE:06DA
BIOSCODE:06DA ci_bigfat:                              ; CODE XREF: clear_ids+20↑j
BIOSCODE:06DA                                         ; clear_ids+2A↑j
BIOSCODE:06DA                 mov     cl, 8           ; size_of_EXT_SYSTEM_ID
BIOSCODE:06DC                 add     di, 5           ; (BDS.filesys_id-BDS.volid)-size_of_EXT_BOOT_VOL_LABEL
BIOSCODE:06DC                                         ; BDS.filesys_id (BDS offset 141)
BIOSCODE:06DF                 rep movs byte ptr es:[di], byte ptr cs:[si] ; 0F3h,2Eh,0A4h
BIOSCODE:06DF                                         ; cs rep movsb
BIOSCODE:06E2                 pop     di              ; restore bds pointer
BIOSCODE:06E3
BIOSCODE:06E3 getret_exit:                            ; CODE XREF: GetBp+5↓j
BIOSCODE:06E3                 retn
BIOSCODE:06E3 clear_ids       endp
BIOSCODE:06E3
BIOSCODE:06E4
BIOSCODE:06E4 ; =============== S U B R O U T I N E =======================================
BIOSCODE:06E4
BIOSCODE:06E4
BIOSCODE:06E4 GetBp           proc near               ; CODE XREF: get_bpb+15↑p
BIOSCODE:06E4                                         ; BIOSCODE:0F92↓p ...
BIOSCODE:06E4                 test    byte ptr es:[di+3Fh], 5 ; [es:di+BDS.flags],
BIOSCODE:06E4                                         ; return_fake_bpb|fnon_removable
BIOSCODE:06E9                 jnz     short getret_exit
BIOSCODE:06EB                 push    cx
BIOSCODE:06EC                 push    dx
BIOSCODE:06ED                 push    bx
BIOSCODE:06EE                 call    readbootsec
BIOSCODE:06F1                 jb      short getbp_err_ret_brdg
BIOSCODE:06F3                 or      bx, bx          ; bx is 0 if boot sector is valid
BIOSCODE:06F5                 jnz     short dofatbpb
BIOSCODE:06F7                 call    movbpb          ; move bpb into registers
BIOSCODE:06FA                 jmp     getret
BIOSCODE:06FD ; ---------------------------------------------------------------------------
BIOSCODE:06FD
BIOSCODE:06FD getbp_err_ret_brdg:                     ; CODE XREF: GetBp+D↑j
BIOSCODE:06FD                                         ; GetBp+1F↓j
BIOSCODE:06FD                 jmp     getbp_err_ret
BIOSCODE:0700 ; ---------------------------------------------------------------------------
BIOSCODE:0700
BIOSCODE:0700 dofatbpb:                               ; CODE XREF: GetBp+11↑j
BIOSCODE:0700                 call    readfat         ; puts media descriptor byte in ah
BIOSCODE:0703                 jb      short getbp_err_ret_brdg
BIOSCODE:0705                 cmp     ds:fhave96, 0   ; changeline support available?
BIOSCODE:070A                 jz      short bpb_nochangeline ; brif not
BIOSCODE:070C                 call    hidensity
BIOSCODE:070F
BIOSCODE:070F bpb_nochangeline:                       ; CODE XREF: GetBp+26↑j
BIOSCODE:070F                 cmp     byte ptr es:[di+3Eh], 2 ; [es:di+BDS.formfactor], ffSmall
BIOSCODE:0714                 jnz     short is_floppy
BIOSCODE:0716                 cmp     ah, 0F9h        ; is it a valid fat id byte for 3.5" ?
BIOSCODE:0719                 jz      short Has720K   ; yes
BIOSCODE:071B                 jmp     got_unknown_medium
BIOSCODE:071E ; ---------------------------------------------------------------------------
BIOSCODE:071E
BIOSCODE:071E Has720K:                                ; CODE XREF: GetBp+35↑j
BIOSCODE:071E                                         ; hidensity+30↓j
BIOSCODE:071E                 mov     al, 3           ; bpbtype.sbf = 3
BIOSCODE:0720                 mov     cx, 1440        ; bpbtype.csec = 1440
BIOSCODE:0723                 mov     dx, 202h        ; dl = bpbtype.spau = 2
BIOSCODE:0723                                         ; dh = bpbtype.chead = 2
BIOSCODE:0726                 mov     bx, 7009h       ; bl = bpbtype.spt = 9
BIOSCODE:0726                                         ; bh = bpbtype.dire = 112
BIOSCODE:0729                 jmp     short Has1
BIOSCODE:072B ; ---------------------------------------------------------------------------
BIOSCODE:072B
BIOSCODE:072B is_floppy:                              ; CODE XREF: GetBp+30↑j
BIOSCODE:072B                 cmp     ah, 0F8h
BIOSCODE:072E                 jnb     short chk_160K
BIOSCODE:0730                 jmp     got_unknown_medium
BIOSCODE:0733 ; ---------------------------------------------------------------------------
BIOSCODE:0733
BIOSCODE:0733 chk_160K:                               ; CODE XREF: GetBp+4A↑j
BIOSCODE:0733                 mov     al, 1           ; bpbtype.sbf = 1
BIOSCODE:0735                 mov     bx, 4008h       ; bl = bpbtype.spt = 8
BIOSCODE:0735                                         ; bh = bpbtype.dire = 64
BIOSCODE:0738                 mov     cx, 320         ; bpbtype.csec = 320
BIOSCODE:073B                 mov     dx, 101h        ; dl = bpbtype.spau = 1
BIOSCODE:073B                                         ; dh = bpbtype.chead = 1
BIOSCODE:073E                 test    ah, 2
BIOSCODE:0741                 jnz     short has8
BIOSCODE:0743                 inc     ax              ; bpbtype.sbf = 2
BIOSCODE:0744                 inc     bx              ; bpbtype.spt = 9
BIOSCODE:0745                 add     cx, 40          ; 180K (360 sectors)
BIOSCODE:0748
BIOSCODE:0748 has8:                                   ; CODE XREF: GetBp+5D↑j
BIOSCODE:0748                 test    ah, 1           ; bpbtype.sbf = 1
BIOSCODE:074B                 jz      short Has1
BIOSCODE:074D                 add     cx, cx
BIOSCODE:074F                 mov     bh, 112         ; bh = bpbtype.dire = 112
BIOSCODE:0751                 inc     dh              ; bpbtype.chead = 2
BIOSCODE:0753                 inc     dx              ; bpbtype.spau = 2
BIOSCODE:0754
BIOSCODE:0754 Has1:                                   ; CODE XREF: GetBp+45↑j
BIOSCODE:0754                                         ; GetBp+67↑j ...
BIOSCODE:0754                 push    ds
BIOSCODE:0755                 push    es
BIOSCODE:0756                 pop     ds
BIOSCODE:0757                 mov     [di+8], dh      ; [di+BDS.secperclus]
BIOSCODE:075A                 xor     dh, dh          ; 0
BIOSCODE:075C                 mov     [di+15h], dx    ; [di+BDS.heads]
BIOSCODE:075F                 mov     dl, bh
BIOSCODE:0761                 mov     [di+0Ch], dx    ; [di+BDS.direntries]
BIOSCODE:0764                 mov     [di+0Eh], cx    ; [di+BDS.totalsecs16]
BIOSCODE:0767                 mov     [di+1Bh], cx    ; [di+BDS.totalsecs32]
BIOSCODE:076A                 mov     [di+10h], ah    ; [di+BDS.media]
BIOSCODE:076D                 mov     dl, al
BIOSCODE:076F                 mov     [di+11h], dx    ; [di+BDS.fatsecs]
BIOSCODE:0772                 mov     dl, bl
BIOSCODE:0774                 mov     [di+13h], dx    ; [di+BDS.secpertrack]
BIOSCODE:0777                 xor     bx, bx          ; 0
BIOSCODE:0779                 mov     [di+19h], bx    ; [di+BDS.hiddensecs+2]
BIOSCODE:077C                 mov     [di+17h], bx    ; [di+BDS.hiddensecs]
BIOSCODE:077F                 mov     [di+1Dh], bx    ; [di+BDS.totalsecs32+2]
BIOSCODE:0782                 mov     [di+1Fh], bx    ; [di+BDS.fatsecs32] ; BPB_FATSz32
BIOSCODE:0785                 mov     [di+21h], bx    ; [di+BDS.fatsecs32+2]
BIOSCODE:0788                 mov     [di+27h], bx    ; [di+BDS.rootdirclust]
BIOSCODE:078B                 mov     [di+29h], bx    ; [di+BDS.rootdirclust+2]
BIOSCODE:078E                 mov     [di+2Fh], bx    ; [di+BDS.reserved]
BIOSCODE:078E                                         ;     BPB_Reserved (12 zero bytes)
BIOSCODE:0791                 mov     [di+31h], bx
BIOSCODE:0794                 mov     [di+33h], bx
BIOSCODE:0797                 mov     [di+35h], bx
BIOSCODE:079A                 mov     [di+37h], bx
BIOSCODE:079D                 mov     [di+39h], bx
BIOSCODE:07A0                 mov     [di+23h], bx    ; [di+BDS.extflags] ; BPB_ExtFlags
BIOSCODE:07A3                 mov     [di+25h], bx    ; [di+BDS.fsver] ; BPB_FSVer
BIOSCODE:07A6                 dec     bx              ; -1 ; 0FFFFFFFFh
BIOSCODE:07A7                 mov     [di+2Bh], bx    ; [di+BDS.fsinfo] ; BPB_FSInfo
BIOSCODE:07AA                 mov     [di+2Dh], bx    ; [di+BDS.bkbootsec] ; BPB_BkBootSec
BIOSCODE:07AD                 pop     ds
BIOSCODE:07AE
BIOSCODE:07AE getret:                                 ; CODE XREF: GetBp+16↑j
BIOSCODE:07AE                                         ; GetBp+D6↓j ...
BIOSCODE:07AE                 pop     bx
BIOSCODE:07AF                 pop     dx
BIOSCODE:07B0                 pop     cx
BIOSCODE:07B1                 retn
BIOSCODE:07B2 ; ---------------------------------------------------------------------------
BIOSCODE:07B2
BIOSCODE:07B2 getbp_err_ret:                          ; CODE XREF: GetBp:getbp_err_ret_brdg↑j
BIOSCODE:07B2                 mov     ds:set_id_flag, 0
BIOSCODE:07B7                 call    maperror
BIOSCODE:07BA                 jmp     short getret
BIOSCODE:07BC ; ---------------------------------------------------------------------------
BIOSCODE:07BC
BIOSCODE:07BC got_unknown_medium:                     ; CODE XREF: GetBp+37↑j
BIOSCODE:07BC                                         ; GetBp+4C↑j
BIOSCODE:07BC                 mov     ds:set_id_flag, 0
BIOSCODE:07C1                 mov     al, 7
BIOSCODE:07C3                 stc
BIOSCODE:07C4                 jmp     short getret
BIOSCODE:07C4 GetBp           endp
BIOSCODE:07C4
BIOSCODE:07C6
BIOSCODE:07C6 ; =============== S U B R O U T I N E =======================================
BIOSCODE:07C6
BIOSCODE:07C6
BIOSCODE:07C6 readbootsec     proc near               ; CODE XREF: GetBp+A↑p
BIOSCODE:07C6                 mov     dh, 0           ; head 0
BIOSCODE:07C8                 mov     cx, 1           ; cylinder 0, sector 1
BIOSCODE:07CB                 call    read_sector
BIOSCODE:07CE                 jb      short err_ret
BIOSCODE:07D0                 xor     bx, bx          ; bx = 0
BIOSCODE:07D2                 mov     al, ds:disksector
BIOSCODE:07D5                 cmp     al, 69h         ; is it a direct jump?
BIOSCODE:07D7                 jz      short check_bpb_mediabyte ; don't need to find a nop
BIOSCODE:07D9                 cmp     al, 0E9h        ; dos 2.0 jump?
BIOSCODE:07DB                 jz      short check_bpb_mediabyte ; no need for nop
BIOSCODE:07DD                 cmp     al, 0EBh        ; how about a short jump?
BIOSCODE:07DF                 jnz     short invalidbootsec
BIOSCODE:07E1                 cmp     ds:disksector+2, 90h ; is next one a nop?
BIOSCODE:07E6                 jnz     short invalidbootsec
BIOSCODE:07E8
BIOSCODE:07E8 check_bpb_mediabyte:                    ; CODE XREF: readbootsec+11↑j
BIOSCODE:07E8                                         ; readbootsec+15↑j
BIOSCODE:07E8                 mov     al, ds:disksector+15h ;
BIOSCODE:07E8                                         ; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
BIOSCODE:07EB                 push    ax
BIOSCODE:07EC                 and     al, 0F0h
BIOSCODE:07EE                 cmp     al, 0F0h        ; allow for strange media
BIOSCODE:07F0                 pop     ax
BIOSCODE:07F1                 jnz     short invalidbootsec
BIOSCODE:07F3                 cmp     al, 0F0h
BIOSCODE:07F5                 jz      short gooddsk
BIOSCODE:07F7                 test    al, 1
BIOSCODE:07F9                 jnz     short gooddsk
BIOSCODE:07FB                 cmp     word ptr ds:disksector+8, 2E33h ; '3.'
BIOSCODE:0801                 jnz     short mustbeearlier
BIOSCODE:0803                 cmp     ds:disksector+0Ah, 32h ; '2' ; 2
BIOSCODE:0808                 jnb     short gooddsk
BIOSCODE:080A
BIOSCODE:080A mustbeearlier:                          ; CODE XREF: readbootsec+3B↑j
BIOSCODE:080A                 mov     ds:disksector+0Dh, 1 ; we must have a pre-3.20 diskette.
BIOSCODE:080A                                         ; set the sec/clus field to 1
BIOSCODE:080A                                         ; [disksector+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER]
BIOSCODE:080F                 jmp     short gooddsk
BIOSCODE:0811 ; ---------------------------------------------------------------------------
BIOSCODE:0811
BIOSCODE:0811 invalidbootsec:                         ; CODE XREF: readbootsec+19↑j
BIOSCODE:0811                                         ; readbootsec+20↑j ...
BIOSCODE:0811                 inc     bx              ; indicate that boot sector invalid (bx = 1)
BIOSCODE:0812
BIOSCODE:0812 gooddsk:                                ; CODE XREF: readbootsec+2F↑j
BIOSCODE:0812                                         ; readbootsec+33↑j ...
BIOSCODE:0812                 clc
BIOSCODE:0813
BIOSCODE:0813 err_ret:                                ; CODE XREF: readbootsec+8↑j
BIOSCODE:0813                 retn
BIOSCODE:0813 readbootsec     endp
BIOSCODE:0813
BIOSCODE:0814
BIOSCODE:0814 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0814
BIOSCODE:0814
BIOSCODE:0814 movbpb          proc near               ; CODE XREF: GetBp+13↑p
BIOSCODE:0814                 push    di
BIOSCODE:0815                 add     di, 6           ; BDS+6 = BDS.BPB
BIOSCODE:0818                 lea     si, disksector+0Bh
BIOSCODE:081C                 mov     cx, 53          ; copy bios parameters block
BIOSCODE:081C                                         ; from BPB_BytsPerSec to (FAT32) BS_DrvNum (excluded)
BIOSCODE:081F                 cld
BIOSCODE:0820                 rep movsb
BIOSCODE:0822                 mov     cx, [si-45]     ; si = disksector+64 -> 64-45 = 19
BIOSCODE:0822                                         ; disksektor+19 = BPB_TotSec16
BIOSCODE:0825                 xor     ax, ax
BIOSCODE:0827                 jcxz    short movbpb_bigdisk
BIOSCODE:0829                 mov     es:[di-32], cx  ; write 16 bit total sectors
BIOSCODE:0829                                         ; to 32 bit total sectors field
BIOSCODE:082D                 mov     es:[di-30], ax  ; BPB_TotalSec32+2 (BDS offset 29, BPB offset 23)
BIOSCODE:0831
BIOSCODE:0831 movbpb_bigdisk:                         ; CODE XREF: movbpb+13↑j
BIOSCODE:0831                 cmp     [si-42], ax     ; BPB_FATSz16 = disksector+22
BIOSCODE:0834                 jz      short movbpb_fat32
BIOSCODE:0836
BIOSCODE:0836 movbpb_fat:                             ;
BIOSCODE:0836                 sub     di, 28          ; di = BDS offset 31 (BPB offset 25)
BIOSCODE:0839                 mov     cx, 12          ; clear 12 byte extended BDS (FAT32) fields
BIOSCODE:0839                                         ; (which are used only for FAT32 disks)
BIOSCODE:083C                 rep stosb
BIOSCODE:083E                 dec     ax              ; -1 ; 0FFFFh
BIOSCODE:083F                 stosw                   ; set BDS offset 43 (dword) to -1
BIOSCODE:083F                                         ; dword [BDS.BPB_FSInfo] = 0FFFFFFFFh
BIOSCODE:0840                 stosw
BIOSCODE:0841                 inc     ax              ; ax = 0
BIOSCODE:0842                 mov     cx, 12          ; clear BDS offset 47 to 59
BIOSCODE:0842                                         ; (BPB offset 41 to 53) (disksector offset 52 to 64)
BIOSCODE:0845                 rep stosb
BIOSCODE:0847
BIOSCODE:0847 movbpb_fat32:                           ; CODE XREF: movbpb+20↑j
BIOSCODE:0847                 pop     di
BIOSCODE:0848                 cmp     ds:set_id_flag, 1 ; called by get_bpb?
BIOSCODE:084D                 jnz     short movbpb_ret
BIOSCODE:084F                 call    mov_media_ids
BIOSCODE:0852                 jb      short movbpb_conv ; conventional boot record?
BIOSCODE:0854                 mov     ds:set_id_flag, 2 ; signals that volume id is set
BIOSCODE:0859
BIOSCODE:0859 movbpb_conv:                            ; CODE XREF: movbpb+3E↑j
BIOSCODE:0859                 cmp     ds:fhave96, 1
BIOSCODE:085E                 jnz     short movbpb_ret
BIOSCODE:0860                 call    resetchanged    ; reset flags in bds to not fchanged
BIOSCODE:0863
BIOSCODE:0863 movbpb_ret:                             ; CODE XREF: movbpb+39↑j
BIOSCODE:0863                                         ; movbpb+4A↑j
BIOSCODE:0863                 clc
BIOSCODE:0864                 retn
BIOSCODE:0864 movbpb          endp
BIOSCODE:0864
BIOSCODE:0865
BIOSCODE:0865 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0865
BIOSCODE:0865
BIOSCODE:0865 mov_media_ids   proc near               ; CODE XREF: movbpb+3B↑p
BIOSCODE:0865                                         ; BIOSCODE:1501↓p
BIOSCODE:0865                                         ; DATA XREF: ...
BIOSCODE:0865                 cmp     word ptr ds:disksector+16h, 0 ; BPB.FATSz16
BIOSCODE:086A                 jnz     short mmi_chk_fat
BIOSCODE:086C                 cmp     ds:disksector+42h, 29h ; [disksector+FAT32_EXT_BOOT.SIG],
BIOSCODE:086C                                         ;                     EXT_BOOT_SIGNATURE
BIOSCODE:0871                 jmp     short mmi_chk_fat32
BIOSCODE:0873 ; ---------------------------------------------------------------------------
BIOSCODE:0873
BIOSCODE:0873 mmi_chk_fat:                            ; CODE XREF: mov_media_ids+5↑j
BIOSCODE:0873                 cmp     ds:disksector+26h, 29h ; [disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE
BIOSCODE:0878
BIOSCODE:0878 mmi_chk_fat32:                          ; CODE XREF: mov_media_ids+C↑j
BIOSCODE:0878                 jnz     short mmi_not_ext
BIOSCODE:087A                 push    cx
BIOSCODE:087B                 push    ax
BIOSCODE:087C                 push    di
BIOSCODE:087D                 push    si
BIOSCODE:087E                 push    ds
BIOSCODE:087F                 cmp     word ptr ds:disksector+16h, 0 ; BPB.FATSz16
BIOSCODE:0884                 jnz     short mmi_fat
BIOSCODE:0886
BIOSCODE:0886 mmi_fat32:                              ; FAT32 file system
BIOSCODE:0886                 lds     cx, dword ptr ds:disksector+43h ; BS_FAT32_VolID
BIOSCODE:088A                 mov     si, (offset disksector+47h) ; BS_FAT32_VolLab
BIOSCODE:088D                 mov     ax, (offset disksector+52h) ; BS_FAT32_FilSysType
BIOSCODE:0890                 jmp     short mmi_do
BIOSCODE:0892 ; ---------------------------------------------------------------------------
BIOSCODE:0892
BIOSCODE:0892 mmi_fat:                                ; CODE XREF: mov_media_ids+1F↑j
BIOSCODE:0892                 lds     cx, dword ptr ds:disksector+27h ; BS_VolID
BIOSCODE:0896                 mov     si, (offset disksector+2Bh) ; BS_VolLab
BIOSCODE:0899                 mov     ax, (offset disksector+36h) ; BS_FilSysType
BIOSCODE:089C
BIOSCODE:089C mmi_do:                                 ; CODE XREF: mov_media_ids+2B↑j
BIOSCODE:089C                 mov     es:[di+89h], cx ; [es:di+BDS.vol_serial]
BIOSCODE:089C                                         ; (BDS offset 137)
BIOSCODE:08A1                 mov     word ptr es:[di+8Bh], ds ; [es:di+BDS.vol_serial+2]
BIOSCODE:08A6                 pop     ds
BIOSCODE:08A7                 mov     cx, 11
BIOSCODE:08AA                 add     di, 125         ; di = di+125 = BDS.volid
BIOSCODE:08AD                 rep movsb
BIOSCODE:08AF                 mov     cl, 8           ; di = di+136
BIOSCODE:08B1                 mov     si, ax          ; BS_FilSysType or BS_FAT32_FilSysType
BIOSCODE:08B3                 add     di, 5           ; di = di+141 = BDS.filesys_id
BIOSCODE:08B6                 rep movsb
BIOSCODE:08B8                 pop     si
BIOSCODE:08B9                 pop     di
BIOSCODE:08BA                 pop     ax
BIOSCODE:08BB                 pop     cx
BIOSCODE:08BC                 clc                     ; this clc is not required (16/06/2019 - Erdogan Tan)
BIOSCODE:08BC                                         ; (20/09/2022 - 27/06/2023) MSDOS 6.21 .. PCDOS 7.1
BIOSCODE:08BD                 retn
BIOSCODE:08BE ; ---------------------------------------------------------------------------
BIOSCODE:08BE
BIOSCODE:08BE mmi_not_ext:                            ; CODE XREF: mov_media_ids:mmi_chk_fat32↑j
BIOSCODE:08BE                 stc
BIOSCODE:08BF                 retn
BIOSCODE:08BF mov_media_ids   endp
BIOSCODE:08BF
BIOSCODE:08C0
BIOSCODE:08C0 ; =============== S U B R O U T I N E =======================================
BIOSCODE:08C0
BIOSCODE:08C0
BIOSCODE:08C0 readfat         proc near               ; CODE XREF: GetBp:dofatbpb↑p
BIOSCODE:08C0                 mov     dh, 0           ; head 0
BIOSCODE:08C2                 mov     cx, 2           ; cylinder 0, sector 2
BIOSCODE:08C5                 call    read_sector
BIOSCODE:08C8                 jb      short bad_fat_ret
BIOSCODE:08CA                 mov     ah, [bx]        ; media byte
BIOSCODE:08CC
BIOSCODE:08CC bad_fat_ret:                            ; CODE XREF: readfat+8↑j
BIOSCODE:08CC                 retn
BIOSCODE:08CC readfat         endp
BIOSCODE:08CC
BIOSCODE:08CD
BIOSCODE:08CD ; =============== S U B R O U T I N E =======================================
BIOSCODE:08CD
BIOSCODE:08CD
BIOSCODE:08CD read_sector     proc near               ; CODE XREF: readbootsec+5↑p
BIOSCODE:08CD                                         ; readfat+5↑p ...
BIOSCODE:08CD                 push    bp
BIOSCODE:08CE                 mov     bp, 3           ; make 3 attempts
BIOSCODE:08D1                 mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
BIOSCODE:08D5                 mov     bx, offset disksector ; BIOSDATA:0152h
BIOSCODE:08D8
BIOSCODE:08D8 rd_ret:                                 ; CODE XREF: read_sector+20↓j
BIOSCODE:08D8                 push    es
BIOSCODE:08D9                 push    ds
BIOSCODE:08DA                 pop     es
BIOSCODE:08DB                 mov     ax, 201h
BIOSCODE:08DE                 int     13h             ; DISK - READ SECTORS INTO MEMORY
BIOSCODE:08DE                                         ; AL = number of sectors to read, CH = track, CL = sector
BIOSCODE:08DE                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
BIOSCODE:08DE                                         ; Return: CF set on error, AH = status, AL = number of sectors read
BIOSCODE:08E0                 pop     es
BIOSCODE:08E1                 jnb     short okret2
BIOSCODE:08E3
BIOSCODE:08E3 rd_rty:                                 ; CODE XREF: read_sector+5D↓j
BIOSCODE:08E3                 call    again           ; reset disk, decrement bp
BIOSCODE:08E6                 jz      short err_rd_ret
BIOSCODE:08E8                 test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
BIOSCODE:08E8                                         ; (BDS offset 63)
BIOSCODE:08ED                 jnz     short rd_ret
BIOSCODE:08EF                 cmp     ds:media_set_for_format, 0
BIOSCODE:08F4                 jnz     short rd_skip1_dpt
BIOSCODE:08F6                 push    ax
BIOSCODE:08F7                 push    ds              ; for retry, set the head settle time to 0Fh
BIOSCODE:08F8                 lds     si, ds:dpt
BIOSCODE:08FC                 mov     al, [si+9]      ; [si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:08FF                 mov     byte ptr [si+9], 15 ; NORMSETTLE
BIOSCODE:0903                 pop     ds
BIOSCODE:0904                 mov     ds:save_head_sttl, al
BIOSCODE:0907                 pop     ax
BIOSCODE:0908
BIOSCODE:0908 rd_skip1_dpt:                           ; CODE XREF: read_sector+27↑j
BIOSCODE:0908                 push    es
BIOSCODE:0909                 push    ds
BIOSCODE:090A                 pop     es
BIOSCODE:090B                 mov     ax, 201h
BIOSCODE:090E                 int     13h             ; DISK - READ SECTORS INTO MEMORY
BIOSCODE:090E                                         ; AL = number of sectors to read, CH = track, CL = sector
BIOSCODE:090E                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
BIOSCODE:090E                                         ; Return: CF set on error, AH = status, AL = number of sectors read
BIOSCODE:0910                 pop     es
BIOSCODE:0911                 pushf
BIOSCODE:0912                 cmp     ds:media_set_for_format, 0
BIOSCODE:0917                 jnz     short rd_skip2_dpt
BIOSCODE:0919                 push    ax
BIOSCODE:091A                 mov     al, ds:save_head_sttl
BIOSCODE:091D                 push    ds
BIOSCODE:091E                 lds     si, ds:dpt
BIOSCODE:0922                 mov     [si+9], al      ; [si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:0925                 pop     ds
BIOSCODE:0926                 pop     ax
BIOSCODE:0927
BIOSCODE:0927 rd_skip2_dpt:                           ; CODE XREF: read_sector+4A↑j
BIOSCODE:0927                 popf
BIOSCODE:0928                 jnb     short okret2
BIOSCODE:092A                 jmp     short rd_rty
BIOSCODE:092C ; ---------------------------------------------------------------------------
BIOSCODE:092C
BIOSCODE:092C err_rd_ret:                             ; CODE XREF: read_sector+19↑j
BIOSCODE:092C                 mov     dl, 0FFh        ; make sure we ask rom if media has changed
BIOSCODE:092E                 stc                     ; return error
BIOSCODE:092F
BIOSCODE:092F okret2:                                 ; CODE XREF: read_sector+14↑j
BIOSCODE:092F                                         ; read_sector+5B↑j
BIOSCODE:092F                 mov     ds:step_drv, dl
BIOSCODE:0933                 mov     ds:tim_drv, dl
BIOSCODE:0937                 mov     es:[di+78h], ch ; [es:di+BDS.track]
BIOSCODE:0937                                         ; (BDS offset 120)
BIOSCODE:0937                                         ; save last track accessed on this drive
BIOSCODE:093B                 pushf
BIOSCODE:093C                 call    set_tim
BIOSCODE:093F                 popf                    ; restore flags
BIOSCODE:0940                 pop     bp
BIOSCODE:0941                 retn
BIOSCODE:0941 read_sector     endp
BIOSCODE:0941
BIOSCODE:0942
BIOSCODE:0942 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0942
BIOSCODE:0942
BIOSCODE:0942 dsk_open        proc near               ; DATA XREF: BIOSCODE:0594↑o
BIOSCODE:0942                 cmp     ds:fhave96, 0
BIOSCODE:0947                 jz      short dsk_open_exit ; done if no changeline support
BIOSCODE:0949                 call    SetDrive        ; get bds for drive
BIOSCODE:094C                 inc     word ptr es:[di+3Ch] ; [es:di+BDS.opcnt]
BIOSCODE:094C                                         ; (BDS offset 60)
BIOSCODE:0950
BIOSCODE:0950 dsk_open_exit:                          ; CODE XREF: dsk_open+5↑j
BIOSCODE:0950                 clc                     ; CF is already ZERO here - Erdogan Tan
BIOSCODE:0951                 retn
BIOSCODE:0951 dsk_open        endp
BIOSCODE:0951
BIOSCODE:0952
BIOSCODE:0952 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0952
BIOSCODE:0952
BIOSCODE:0952 dsk_close       proc near               ; DATA XREF: BIOSCODE:0596↑o
BIOSCODE:0952                 cmp     ds:fhave96, 0
BIOSCODE:0957                 jz      short exitjx    ; done if no changeline support
BIOSCODE:0959                 call    SetDrive        ; get bds for drive
BIOSCODE:095C                 cmp     word ptr es:[di+3Ch], 0 ; [es:di+BDS.opcnt]
BIOSCODE:0961                 jz      short exitjx    ; watch out for wrap
BIOSCODE:0963                 dec     word ptr es:[di+3Ch]
BIOSCODE:0967
BIOSCODE:0967 exitjx:                                 ; CODE XREF: dsk_close+5↑j
BIOSCODE:0967                                         ; dsk_close+F↑j ...
BIOSCODE:0967                 clc                     ; CF is already ZERO here - Erdogan Tan
BIOSCODE:0968                 retn
BIOSCODE:0968 dsk_close       endp
BIOSCODE:0968
BIOSCODE:0969
BIOSCODE:0969 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0969
BIOSCODE:0969
BIOSCODE:0969 dsk_rem         proc near               ; DATA XREF: BIOSCODE:0598↑o
BIOSCODE:0969                 call    SetDrive
BIOSCODE:096C                 test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
BIOSCODE:0971                 jz      short exitjx
BIOSCODE:0973
BIOSCODE:0973 x_bus_exit:                             ; DATA XREF: BIOSCODE:0584↑o
BIOSCODE:0973                 mov     ah, 3           ; non_rem
BIOSCODE:0973                                         ; return busy status
BIOSCODE:0975                 stc
BIOSCODE:0976
BIOSCODE:0976 dsk_ret:                                ; CODE XREF: BIOSCODE:dsk_io↓j
BIOSCODE:0976                 retn
BIOSCODE:0976 dsk_rem         endp
BIOSCODE:0976
BIOSCODE:0977 ; ---------------------------------------------------------------------------
BIOSCODE:0977
BIOSCODE:0977 dsk_writv:                              ; DATA XREF: BIOSCODE:058C↑o
BIOSCODE:0977                 mov     word ptr ds:rflag, 103h ; write and verify
BIOSCODE:097D                 jmp     short dsk_cl
BIOSCODE:097F ; ---------------------------------------------------------------------------
BIOSCODE:097F
BIOSCODE:097F dsk_writ:                               ; DATA XREF: BIOSCODE:058A↑o
BIOSCODE:097F                 mov     word ptr ds:rflag, 3 ; romwrite
BIOSCODE:0985
BIOSCODE:0985 dsk_cl:                                 ; CODE XREF: BIOSCODE:097D↑j
BIOSCODE:0985                 call    diskio          ; prepare for rombios read/write
BIOSCODE:0988
BIOSCODE:0988 dsk_io:                                 ; CODE XREF: BIOSCODE:0990↓j
BIOSCODE:0988                 jnb     short dsk_ret
BIOSCODE:098A                 jmp     bc_err_cnt
BIOSCODE:098D ; ---------------------------------------------------------------------------
BIOSCODE:098D
BIOSCODE:098D dsk_read:                               ; DATA XREF: BIOSCODE:0582↑o
BIOSCODE:098D                 call    DISKRD
BIOSCODE:0990                 jmp     short dsk_io
BIOSCODE:0992
BIOSCODE:0992 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0992
BIOSCODE:0992
BIOSCODE:0992 checksingle     proc near               ; CODE XREF: diskio+77↓p
BIOSCODE:0992                                         ; BIOSCODE:0F8F↓p ...
BIOSCODE:0992                 push    ax
BIOSCODE:0993                 push    bx
BIOSCODE:0994                 mov     bx, es:[di+3Fh] ; [es:di+BDS.flags]
BIOSCODE:0998                 test    bl, 21h         ; fnon_removable|fi_own_physical
BIOSCODE:099B                 jnz     short singleret
BIOSCODE:099D                 test    bl, 10h         ; fi_am_mult
BIOSCODE:099D                                         ; is there a drive sharing this physical drive?
BIOSCODE:09A0                 jz      short singleret
BIOSCODE:09A2                 mov     al, es:[di+4]   ; [es:di+BDS.drivenum]
BIOSCODE:09A2                                         ; get physical drive number
BIOSCODE:09A6                 push    es              ; preserve pointer to current bds
BIOSCODE:09A7                 push    di
BIOSCODE:09A8                 les     di, dword ptr ds:start_bds ; get first bds
BIOSCODE:09AC
BIOSCODE:09AC scan_list:                              ; CODE XREF: checksingle+79↓j
BIOSCODE:09AC                 cmp     es:[di+4], al
BIOSCODE:09B0                 jnz     short scan_skip ; Not our drive. Try next bds.
BIOSCODE:09B2                 mov     bl, 20h         ; fi_own_physical ; test ownership flag
BIOSCODE:09B4                 test    es:[di+3Fh], bl
BIOSCODE:09B8                 jz      short scan_skip ; he doesn't own it either. continue
BIOSCODE:09BA                 xor     es:[di+3Fh], bl ; reset ownership flag
BIOSCODE:09BE                 pop     di
BIOSCODE:09BF                 pop     es
BIOSCODE:09C0                 or      es:[di+3Fh], bl
BIOSCODE:09C4                 cmp     ds:fsetowner, 1
BIOSCODE:09C9                 jnz     short not_fsetowner
BIOSCODE:09CB                 cmp     byte ptr es:[di+4], 0 ; are we handling drive number 0 ?
BIOSCODE:09D0                 jnz     short singleret
BIOSCODE:09D2                 mov     al, es:[di+5]   ; [es:di+BDS.drivelet]
BIOSCODE:09D2                                         ; get the DOS drive letter
BIOSCODE:09D6                 push    es
BIOSCODE:09D7                 mov     es, ds:zeroseg
BIOSCODE:09DB                 assume es:nothing
BIOSCODE:09DB                 mov     byte ptr es:504h, al ; [es:LSTDRV]
BIOSCODE:09DB                                         ; set up sdsb
BIOSCODE:09DF                 pop     es              ; restore bds pointer
BIOSCODE:09E0                 assume es:nothing
BIOSCODE:09E0                 jmp     short singleret
BIOSCODE:09E2 ; ---------------------------------------------------------------------------
BIOSCODE:09E2
BIOSCODE:09E2 not_fsetowner:                          ; CODE XREF: checksingle+37↑j
BIOSCODE:09E2                 cmp     ds:single, 2    ; if (single_drive_system)
BIOSCODE:09E7                 jnz     short ignore_sdsb
BIOSCODE:09E9                 push    ax
BIOSCODE:09EA                 mov     al, es:[di+5]   ; if (curr_drv == req_drv)
BIOSCODE:09EE                 mov     ah, al
BIOSCODE:09F0                 push    es
BIOSCODE:09F1                 mov     es, ds:zeroseg
BIOSCODE:09F5                 assume es:nothing
BIOSCODE:09F5                 xchg    al, byte ptr es:504h ; [es:LSTDRV]
BIOSCODE:09F5                                         ; then swap(curr_drv,req_drv)
BIOSCODE:09FA                 pop     es
BIOSCODE:09FB                 assume es:nothing
BIOSCODE:09FB                 cmp     ah, al          ; else
BIOSCODE:09FD                 pop     ax              ; swap(curr_drv,req_drv)
BIOSCODE:09FE                 jz      short singleret ; issue swap_dsk_msg
BIOSCODE:0A00
BIOSCODE:0A00 ignore_sdsb:                            ; CODE XREF: checksingle+55↑j
BIOSCODE:0A00                 call    swpdsk
BIOSCODE:0A03                 jmp     short singleret
BIOSCODE:0A05 ; ---------------------------------------------------------------------------
BIOSCODE:0A05
BIOSCODE:0A05 scan_skip:                              ; CODE XREF: checksingle+1E↑j
BIOSCODE:0A05                                         ; checksingle+26↑j
BIOSCODE:0A05                 les     di, es:[di]
BIOSCODE:0A08                 cmp     di, 0FFFFh      ; -1  ; end of list?
BIOSCODE:0A0B                 jnz     short scan_list ; continue until hit end of list
BIOSCODE:0A0D                 stc
BIOSCODE:0A0E                 pop     di              ; restore current bds
BIOSCODE:0A0F                 pop     es
BIOSCODE:0A10
BIOSCODE:0A10 singleret:                              ; CODE XREF: checksingle+9↑j
BIOSCODE:0A10                                         ; checksingle+E↑j ...
BIOSCODE:0A10                 pop     bx
BIOSCODE:0A11                 pop     ax
BIOSCODE:0A12                 retn
BIOSCODE:0A12 checksingle     endp
BIOSCODE:0A12
BIOSCODE:0A13 ; ---------------------------------------------------------------------------
BIOSCODE:0A13 ; START OF FUNCTION CHUNK FOR diskio
BIOSCODE:0A13
BIOSCODE:0A13 baddrive:                               ; CODE XREF: diskio+32↓j
BIOSCODE:0A13                                         ; diskio+38↓j ...
BIOSCODE:0A13                 mov     al, 8           ; sector not found
BIOSCODE:0A15                 jmp     short baddrive_ret
BIOSCODE:0A17 ; ---------------------------------------------------------------------------
BIOSCODE:0A17
BIOSCODE:0A17 unformatteddrive:                       ; CODE XREF: diskio+17↓j
BIOSCODE:0A17                 mov     al, 7           ; unknown media
BIOSCODE:0A19
BIOSCODE:0A19 baddrive_ret:                           ; CODE XREF: diskio-1B↑j
BIOSCODE:0A19                 stc
BIOSCODE:0A19 ; END OF FUNCTION CHUNK FOR diskio
BIOSCODE:0A1A
BIOSCODE:0A1A ioret:                                  ; CODE XREF: diskio+10↓j
BIOSCODE:0A1A                 retn
BIOSCODE:0A1A ; ---------------------------------------------------------------------------
BIOSCODE:0A1B LBA_Packet      db 16                   ; DATA XREF: diskio+E1↓o
BIOSCODE:0A1B                                         ; DAP buffer
BIOSCODE:0A1C                 db 0
BIOSCODE:0A1D dap_block_cnt   dw 0                    ; DATA XREF: diskio+C2↓w
BIOSCODE:0A1F dap_trans_buf   dw 2 dup(0)             ; DATA XREF: diskio+B3↓w
BIOSCODE:0A1F                                         ; diskio+BB↓w
BIOSCODE:0A23 dap_lba_value   dw 2 dup(0)             ; DATA XREF: diskio:set_lbarw_2↓w
BIOSCODE:0A23                                         ; diskio+AE↓w
BIOSCODE:0A27                 db 4 dup(0)
BIOSCODE:0A2B
BIOSCODE:0A2B ; =============== S U B R O U T I N E =======================================
BIOSCODE:0A2B
BIOSCODE:0A2B
BIOSCODE:0A2B DISKRD          proc near               ; CODE XREF: BIOSCODE:dsk_read↑p
BIOSCODE:0A2B                                         ; DATA XREF: getclus+103↑o ...
BIOSCODE:0A2B                 mov     ds:rflag, 2     ; romread
BIOSCODE:0A2B DISKRD          endp
BIOSCODE:0A2B
BIOSCODE:0A30
BIOSCODE:0A30 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0A30
BIOSCODE:0A30
BIOSCODE:0A30 diskio          proc near               ; CODE XREF: BIOSCODE:dsk_cl↑p
BIOSCODE:0A30                                         ; BootIo+11↓p
BIOSCODE:0A30
BIOSCODE:0A30 ; FUNCTION CHUNK AT BIOSCODE:0A13 SIZE 00000007 BYTES
BIOSCODE:0A30
BIOSCODE:0A30                 mov     bx, di          ; al = drive number
BIOSCODE:0A30                                         ; cx = sector count
BIOSCODE:0A30                                         ; dx = first sector (low)
BIOSCODE:0A30                                         ; [start_sec_h] = first sector (high)
BIOSCODE:0A30                                         ;
BIOSCODE:0A30                                         ; es:bx = transfer address
BIOSCODE:0A32                 mov     ds:xfer_seg, es ; save transfer segment
BIOSCODE:0A36                 call    SetDrive
BIOSCODE:0A39                 mov     al, es:[di+10h] ; [es:di+BDS.media]
BIOSCODE:0A3D                 mov     ds:medbyt, al
BIOSCODE:0A40                 jcxz    short ioret
BIOSCODE:0A42                 test    byte ptr es:[di+40h], 2 ; [es:di+BDS.flags+1]
BIOSCODE:0A42                                         ; unformatted_media
BIOSCODE:0A47                 jnz     short unformatteddrive
BIOSCODE:0A49                 mov     ds:seccnt, cx   ; save sector count
BIOSCODE:0A4D                 mov     ds:spsav, sp    ; save sp
BIOSCODE:0A51                 mov     ax, dx
BIOSCODE:0A53                 xor     si, si
BIOSCODE:0A55                 add     dx, cx
BIOSCODE:0A57                 rcl     si, 1
BIOSCODE:0A59                 cmp     word ptr es:[di+0Eh], 0 ; [es:di+BDS.totalsecs16]
BIOSCODE:0A59                                         ; > 32 bit sector ?
BIOSCODE:0A5E                 jz      short sanity32
BIOSCODE:0A60                 or      si, si
BIOSCODE:0A62                 jnz     short baddrive
BIOSCODE:0A64                 cmp     dx, es:[di+0Eh] ; [es:di+BDS.totalsecs16]
BIOSCODE:0A68                 ja      short baddrive
BIOSCODE:0A6A                 jmp     short sanityok
BIOSCODE:0A6C ; ---------------------------------------------------------------------------
BIOSCODE:0A6C
BIOSCODE:0A6C sanity32:                               ; CODE XREF: diskio+2E↑j
BIOSCODE:0A6C                 add     si, ds:start_sec_h
BIOSCODE:0A70                 cmp     si, es:[di+1Dh] ; [es:di+BDS.totalsecs32+2]
BIOSCODE:0A74                 jb      short sanityok
BIOSCODE:0A76                 ja      short baddrive
BIOSCODE:0A78                 cmp     dx, es:[di+1Bh] ; [es:di+BDS.totalsecs32]
BIOSCODE:0A7C                 ja      short baddrive
BIOSCODE:0A7E
BIOSCODE:0A7E sanityok:                               ; CODE XREF: diskio+3A↑j
BIOSCODE:0A7E                                         ; diskio+44↑j
BIOSCODE:0A7E                 mov     dx, ds:start_sec_h
BIOSCODE:0A82                 add     ax, es:[di+17h] ; [es:di+BDS.hiddensecs]
BIOSCODE:0A86                 adc     dx, es:[di+19h] ; [es:di+BDS.hiddensecs+2]
BIOSCODE:0A8A                 mov     ds:saved_word, ax ; save the sector number (low)
BIOSCODE:0A8D                 push    es
BIOSCODE:0A8E                 xor     si, si          ; 0
BIOSCODE:0A90                 mov     es, si
BIOSCODE:0A92                 assume es:nothing
BIOSCODE:0A92                 les     si, dword ptr es:78h ; INT 1Eh vector address
BIOSCODE:0A92                                         ; [es:DSKADR] - current disk parm table
BIOSCODE:0A97                 assume es:nothing
BIOSCODE:0A97                 mov     word ptr ds:dpt, si
BIOSCODE:0A9B                 mov     word ptr ds:dpt+2, es
BIOSCODE:0A9F                 pop     es
BIOSCODE:0AA0                 test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
BIOSCODE:0AA5                 jnz     short chk_13h_ext_flag
BIOSCODE:0AA7                 call    checksingle
BIOSCODE:0AAA                 cmp     ds:fhave96, 0   ; do we have changeline support?
BIOSCODE:0AAF                 jz      short diskio_nochangeline ; brif not
BIOSCODE:0AB1                 call    checklatchio    ; will do a sneaky pop stack return
BIOSCODE:0AB1                                         ; if a disk error occurs
BIOSCODE:0AB4
BIOSCODE:0AB4 diskio_nochangeline:                    ; CODE XREF: diskio+7F↑j
BIOSCODE:0AB4                 call    iosetup         ; set up tables and variables for i/o
BIOSCODE:0AB7
BIOSCODE:0AB7 chk_13h_ext_flag:                       ; CODE XREF: diskio+75↑j
BIOSCODE:0AB7                 test    byte ptr es:[di+40h], 4 ; [es:di+BDS.flags+1], fLBArw
BIOSCODE:0AB7                                         ; LBA read/write flag
BIOSCODE:0ABC                 jnz     short set_lbarw_1
BIOSCODE:0ABE                 jmp     skip_setup
BIOSCODE:0AC1 ; ---------------------------------------------------------------------------
BIOSCODE:0AC1
BIOSCODE:0AC1 set_lbarw_1:                            ; CODE XREF: diskio+8C↑j
BIOSCODE:0AC1                 mov     ax, ds:saved_word ; check for mini disk (logical dos drive/partition)
BIOSCODE:0AC4                 cmp     word ptr es:[di+79h], 1 ; [di+BDS.bdsm_ismini] ; logical dos partition
BIOSCODE:0AC9                 jnz     short set_lbarw_2 ; not a logical dos partition/drive
BIOSCODE:0ACB                 cmp     word ptr es:[di+7Bh], 0 ; [di+BDS.bdsm_hidden_trks] (> 0)
BIOSCODE:0AD0                 jz      short set_lbarw_2
BIOSCODE:0AD2                 add     ax, es:[di+17h] ; [es:di+BDS.hiddensecs]
BIOSCODE:0AD6                 adc     dx, es:[di+19h] ; [es:di+BDS.hiddensecs+2]
BIOSCODE:0ADA
BIOSCODE:0ADA set_lbarw_2:                            ; CODE XREF: diskio+99↑j
BIOSCODE:0ADA                                         ; diskio+A0↑j
BIOSCODE:0ADA                 mov     cs:dap_lba_value, ax
BIOSCODE:0ADE                 mov     cs:dap_lba_value+2, dx
BIOSCODE:0AE3                 mov     cs:dap_trans_buf, bx
BIOSCODE:0AE8                 mov     ax, ds:xfer_seg
BIOSCODE:0AEB                 mov     cs:dap_trans_buf+2, ax
BIOSCODE:0AEF                 mov     ax, ds:seccnt
BIOSCODE:0AF2                 mov     cs:dap_block_cnt, ax
BIOSCODE:0AF6                 mov     bp, 5
BIOSCODE:0AF9                 mov     ds:vretry_cnt, bp ; verify op. retry cnt for write-verify
BIOSCODE:0AFD                 mov     ds:soft_ecc_cnt, bp ; soft ecc error retry count
BIOSCODE:0B01
BIOSCODE:0B01 set_lbarw_3:                            ; CODE XREF: diskio:set_lbarw_6↓j
BIOSCODE:0B01                                         ; diskio:set_lbarw_11↓j
BIOSCODE:0B01                 mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
BIOSCODE:0B05                 mov     ah, ds:rflag    ; get read/write indicator
BIOSCODE:0B09                 add     ah, 40h
BIOSCODE:0B0C                 xor     al, al
BIOSCODE:0B0E                 push    ds
BIOSCODE:0B0F                 push    cs
BIOSCODE:0B10                 pop     ds
BIOSCODE:0B11                 assume ds:BIOSCODE
BIOSCODE:0B11                 mov     si, offset LBA_Packet
BIOSCODE:0B14                 int     13h             ; DISK -
BIOSCODE:0B16                 pop     ds
BIOSCODE:0B17                 assume ds:nothing
BIOSCODE:0B17                 jnb     short set_lbarw_7
BIOSCODE:0B19                 call    again
BIOSCODE:0B1C                 jnz     short set_lbarw_4
BIOSCODE:0B1E                 jmp     harderr
BIOSCODE:0B21 ; ---------------------------------------------------------------------------
BIOSCODE:0B21
BIOSCODE:0B21 set_lbarw_4:                            ; CODE XREF: diskio+EC↑j
BIOSCODE:0B21                 cmp     ah, 0CCh        ; Write fault (hard disk)
BIOSCODE:0B24                 jnz     short set_lbarw_5
BIOSCODE:0B26                 mov     bp, 1
BIOSCODE:0B29                 jmp     short set_lbarw_6
BIOSCODE:0B2B ; ---------------------------------------------------------------------------
BIOSCODE:0B2B
BIOSCODE:0B2B set_lbarw_5:                            ; CODE XREF: diskio+F4↑j
BIOSCODE:0B2B                 mov     ds:soft_ecc_cnt, 5
BIOSCODE:0B31
BIOSCODE:0B31 set_lbarw_6:                            ; CODE XREF: diskio+F9↑j
BIOSCODE:0B31                 jmp     short set_lbarw_3
BIOSCODE:0B33 ; ---------------------------------------------------------------------------
BIOSCODE:0B33
BIOSCODE:0B33 set_lbarw_7:                            ; CODE XREF: diskio+E7↑j
BIOSCODE:0B33                 cmp     word ptr ds:rflag, 103h
BIOSCODE:0B39                 jnz     short set_lbarw_12
BIOSCODE:0B3B                 mov     ah, 44h
BIOSCODE:0B3D                 push    ds
BIOSCODE:0B3E                 push    cs
BIOSCODE:0B3F                 pop     ds
BIOSCODE:0B40                 assume ds:BIOSCODE
BIOSCODE:0B40                 int     13h             ; DISK - IBM/MS Extension - VERIFY SECTORS
BIOSCODE:0B40                                         ;  (DL - drive, DS:SI - disk address packet)
BIOSCODE:0B42                 pop     ds
BIOSCODE:0B43                 assume ds:nothing
BIOSCODE:0B43                 jnb     short set_lbarw_12
BIOSCODE:0B45                 cmp     ah, 11h         ; ECC corrected data error (soft error - retried OK )
BIOSCODE:0B48                 jnz     short set_lbarw_8
BIOSCODE:0B4A                 dec     ds:soft_ecc_cnt
BIOSCODE:0B4E
BIOSCODE:0B4E set_lbarw_8:                            ; CODE XREF: diskio+118↑j
BIOSCODE:0B4E                 jz      short set_lbarw_12
BIOSCODE:0B50                 call    ResetDisk
BIOSCODE:0B53                 cmp     ah, 11h
BIOSCODE:0B56                 jz      short set_lbarw_11
BIOSCODE:0B58                 dec     ds:vretry_cnt
BIOSCODE:0B5C                 jnz     short set_lbarw_9
BIOSCODE:0B5E                 jmp     harderr
BIOSCODE:0B61 ; ---------------------------------------------------------------------------
BIOSCODE:0B61
BIOSCODE:0B61 set_lbarw_9:                            ; CODE XREF: diskio+12C↑j
BIOSCODE:0B61                 cmp     ah, 0CCh
BIOSCODE:0B64                 jnz     short set_lbarw_10
BIOSCODE:0B66                 mov     bp, 1
BIOSCODE:0B69                 jmp     short set_lbarw_11
BIOSCODE:0B6B ; ---------------------------------------------------------------------------
BIOSCODE:0B6B
BIOSCODE:0B6B set_lbarw_10:                           ; CODE XREF: diskio+134↑j
BIOSCODE:0B6B                 mov     ds:soft_ecc_cnt, 5 ; soft ecc error retry count
BIOSCODE:0B71
BIOSCODE:0B71 set_lbarw_11:                           ; CODE XREF: diskio+126↑j
BIOSCODE:0B71                                         ; diskio+139↑j
BIOSCODE:0B71                 jmp     short set_lbarw_3
BIOSCODE:0B73 ; ---------------------------------------------------------------------------
BIOSCODE:0B73
BIOSCODE:0B73 set_lbarw_12:                           ; CODE XREF: diskio+109↑j
BIOSCODE:0B73                                         ; diskio+113↑j ...
BIOSCODE:0B73                 xor     ax, ax
BIOSCODE:0B75                 retn
BIOSCODE:0B76 ; ---------------------------------------------------------------------------
BIOSCODE:0B76
BIOSCODE:0B76 skip_setup:                             ; CODE XREF: diskio+8E↑j
BIOSCODE:0B76                 push    bp
BIOSCODE:0B77                 xchg    ax, dx
BIOSCODE:0B78                 xor     dx, dx
BIOSCODE:0B7A                 mov     cx, es:[di+13h] ; [es:di+BDS.secpertrack]
BIOSCODE:0B7A                                         ; divide by sec per track
BIOSCODE:0B7E                 div     cx
BIOSCODE:0B80                 xchg    ax, bp
BIOSCODE:0B81                 mov     ax, ds:saved_word
BIOSCODE:0B84                 div     cx              ; [es:di+BDS.secpertrack]
BIOSCODE:0B84                                         ; now, bp:ax = track #, dx = sector
BIOSCODE:0B84                                         ; sector number is 1 based.
BIOSCODE:0B86                 inc     dx
BIOSCODE:0B87                 mov     ds:cursec, dl   ; save current sector
BIOSCODE:0B8B                 mov     cx, es:[di+15h] ; [es:di+BDS.heads]
BIOSCODE:0B8B                                         ; get number of heads
BIOSCODE:0B8F                 push    ax
BIOSCODE:0B90                 xor     dx, dx
BIOSCODE:0B92                 xchg    ax, bp          ; divide tracks by heads per cylinder
BIOSCODE:0B93                 div     cx
BIOSCODE:0B95                 xchg    ax, bp
BIOSCODE:0B96                 pop     ax
BIOSCODE:0B97                 div     cx              ; now, bp:ax = cylinder #, dx = head
BIOSCODE:0B99                 or      bp, bp
BIOSCODE:0B9B                 pop     bp
BIOSCODE:0B9C                 jnz     short baddrive_brdg
BIOSCODE:0B9E                 cmp     ax, 1024        ; 2^10 currently maximum for track #.
BIOSCODE:0BA1                 jnb     short baddrive_brdg
BIOSCODE:0BA3                 mov     ds:curhd, dl    ; save current head
BIOSCODE:0BA7                 mov     ds:curtrk, ax   ; save current track
BIOSCODE:0BAA                 mov     ax, ds:seccnt
BIOSCODE:0BAD                 call    block
BIOSCODE:0BB0                 call    done
BIOSCODE:0BB3                 retn
BIOSCODE:0BB4 ; ---------------------------------------------------------------------------
BIOSCODE:0BB4
BIOSCODE:0BB4 baddrive_brdg:                          ; CODE XREF: diskio+16C↑j
BIOSCODE:0BB4                                         ; diskio+171↑j
BIOSCODE:0BB4                 jmp     baddrive
BIOSCODE:0BB4 diskio          endp
BIOSCODE:0BB4
BIOSCODE:0BB7
BIOSCODE:0BB7 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0BB7
BIOSCODE:0BB7
BIOSCODE:0BB7 iosetup         proc near               ; CODE XREF: diskio:diskio_nochangeline↑p
BIOSCODE:0BB7                                         ; TrackIo+10↓p
BIOSCODE:0BB7                 mov     al, es:[di+4]   ; [es:di+BDS.drivenum]
BIOSCODE:0BBB                 mov     ds:tim_drv, al  ; save drive letter
BIOSCODE:0BBE                 cmp     ds:media_set_for_format, 0
BIOSCODE:0BC3                 jnz     short skip_dpt_setting
BIOSCODE:0BC5                 mov     al, ds:eot      ; fetch up eot before changing ds
BIOSCODE:0BC8                 push    ds
BIOSCODE:0BC9                 lds     si, ds:dpt      ; get pointer to disk base table
BIOSCODE:0BCD                 mov     [si+4], al
BIOSCODE:0BD0                 mov     al, [si+10]     ; [si+DISK_PARMS.DISK_MOTOR_STRT]
BIOSCODE:0BD3                 mov     ah, [si+4]      ; [si+DISK_PARMS.DISK_EOT]
BIOSCODE:0BD6                 pop     ds
BIOSCODE:0BD7                 mov     ds:motorstartup, al
BIOSCODE:0BDA                 mov     ds:save_eot, ah
BIOSCODE:0BDE                 push    ds
BIOSCODE:0BDF                 lds     si, ds:dpt      ; get pointer to disk base table
BIOSCODE:0BE3                 cmp     byte ptr es:[di+3Eh], 2 ; [es:di+BDS.formfactor], ffSmall
BIOSCODE:0BE8                 jnz     short motor_start_ok
BIOSCODE:0BEA                 mov     al, 4
BIOSCODE:0BEC                 xchg    al, [si+10]     ; [si+DISK_PARMS.DISK_MOTOR_STRT]
BIOSCODE:0BEF
BIOSCODE:0BEF motor_start_ok:                         ; CODE XREF: iosetup+31↑j
BIOSCODE:0BEF                 xor     al, al
BIOSCODE:0BF1                 inc     al              ; ibm wants fast settle to be 1
BIOSCODE:0BF3                 xchg    al, [si+9]      ; [si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:0BF3                                         ; get settle and set up for fast
BIOSCODE:0BF6                 pop     ds
BIOSCODE:0BF7                 mov     ds:settlecurrent, al
BIOSCODE:0BFA                 mov     al, 15          ; NORMSETTLE
BIOSCODE:0BFA                                         ; someone has diddled the settle
BIOSCODE:0BFC                 mov     ds:settleslow, al
BIOSCODE:0BFF
BIOSCODE:0BFF skip_dpt_setting:                       ; CODE XREF: iosetup+C↑j
BIOSCODE:0BFF                 retn
BIOSCODE:0BFF iosetup         endp
BIOSCODE:0BFF
BIOSCODE:0C00
BIOSCODE:0C00 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0C00
BIOSCODE:0C00
BIOSCODE:0C00 done            proc near               ; CODE XREF: diskio+180↑p
BIOSCODE:0C00                                         ; TrackIo+83↓p
BIOSCODE:0C00                 test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
BIOSCODE:0C05                 jnz     short ddbx      ; do not set for non-removable media
BIOSCODE:0C07                 call    set_tim
BIOSCODE:0C0A
BIOSCODE:0C0A diddle_back:                            ; CODE XREF: Disk+142↓j
BIOSCODE:0C0A                 pushf
BIOSCODE:0C0B                 cmp     ds:media_set_for_format, 0
BIOSCODE:0C10                 jnz     short nodiddleback
BIOSCODE:0C12                 push    ax
BIOSCODE:0C13                 push    es
BIOSCODE:0C14                 les     si, ds:dpt
BIOSCODE:0C18                 mov     al, ds:save_eot
BIOSCODE:0C1B                 mov     es:[si+4], al   ; [es:si+DISK_PARMS.DISK_EOT]
BIOSCODE:0C1F                 mov     al, ds:settlecurrent
BIOSCODE:0C22                 mov     ah, ds:motorstartup
BIOSCODE:0C26                 mov     es:[si+9], al   ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:0C2A                 mov     byte ptr es:[si+3], 2 ; [es:si+DISK_PARMS.DISK_SECTOR_SIZ]
BIOSCODE:0C2F                 mov     es:[si+0Ah], ah ; [es:si+DISK_PARMS.DISK_MOTOR_STRT]
BIOSCODE:0C33                 pop     es
BIOSCODE:0C34                 pop     ax
BIOSCODE:0C35
BIOSCODE:0C35 nodiddleback:                           ; CODE XREF: done+10↑j
BIOSCODE:0C35                 popf
BIOSCODE:0C36
BIOSCODE:0C36 ddbx:                                   ; CODE XREF: done+5↑j
BIOSCODE:0C36                                         ; block+2↓j
BIOSCODE:0C36                 retn
BIOSCODE:0C36 done            endp
BIOSCODE:0C36
BIOSCODE:0C37
BIOSCODE:0C37 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0C37
BIOSCODE:0C37
BIOSCODE:0C37 block           proc near               ; CODE XREF: diskio+17D↑p
BIOSCODE:0C37                                         ; block+38↓j
BIOSCODE:0C37                 or      ax, ax
BIOSCODE:0C39                 jz      short ddbx
BIOSCODE:0C3B                 test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
BIOSCODE:0C40                 jz      short block_floppy
BIOSCODE:0C42                 test    byte ptr ds:multrk_flag, 80h ; multrk_on
BIOSCODE:0C47                 jz      short block_floppy
BIOSCODE:0C49                 call    Disk
BIOSCODE:0C4C                 xor     ax, ax
BIOSCODE:0C4E                 retn
BIOSCODE:0C4F ; ---------------------------------------------------------------------------
BIOSCODE:0C4F
BIOSCODE:0C4F block_floppy:                           ; CODE XREF: block+9↑j
BIOSCODE:0C4F                                         ; block+10↑j
BIOSCODE:0C4F                 mov     cl, es:[di+19]  ; [es:di+BDS.secpertrack]
BIOSCODE:0C53                 inc     cx
BIOSCODE:0C54                 sub     cl, ds:cursec
BIOSCODE:0C58                 xor     ch, ch
BIOSCODE:0C5A                 cmp     ax, cx
BIOSCODE:0C5C                 jnb     short gotmin
BIOSCODE:0C5E                 mov     cx, ax
BIOSCODE:0C60
BIOSCODE:0C60 gotmin:                                 ; CODE XREF: block+25↑j
BIOSCODE:0C60                 push    ax
BIOSCODE:0C61                 push    cx
BIOSCODE:0C62                 mov     ax, cx
BIOSCODE:0C64                 call    Disk
BIOSCODE:0C67                 pop     cx
BIOSCODE:0C68                 pop     ax
BIOSCODE:0C69                 sub     ax, cx          ; reduce sectors-remaining by last i/o
BIOSCODE:0C6B                 add     cl, cl
BIOSCODE:0C6D                 add     bh, cl          ; adjust transfer address
BIOSCODE:0C6F                 jmp     short block
BIOSCODE:0C6F block           endp
BIOSCODE:0C6F
BIOSCODE:0C71 ; ---------------------------------------------------------------------------
BIOSCODE:0C71 ; START OF FUNCTION CHUNK FOR Disk
BIOSCODE:0C71
BIOSCODE:0C71 dskerr_brdg:                            ; CODE XREF: Disk:testerr↓j
BIOSCODE:0C71                                         ; Disk+6E↓j
BIOSCODE:0C71                 jmp     dskerr
BIOSCODE:0C71 ; END OF FUNCTION CHUNK FOR Disk
BIOSCODE:0C74
BIOSCODE:0C74 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0C74
BIOSCODE:0C74
BIOSCODE:0C74 Disk            proc near               ; CODE XREF: block+12↑p
BIOSCODE:0C74                                         ; block+2D↑p ...
BIOSCODE:0C74
BIOSCODE:0C74 ; FUNCTION CHUNK AT BIOSCODE:0C71 SIZE 00000003 BYTES
BIOSCODE:0C74
BIOSCODE:0C74                 mov     bp, 5           ; al = number of sectors (1-8, all on one track)
BIOSCODE:0C74                                         ; es:di point to drive parameters
BIOSCODE:0C74                                         ; xfer_seg:bx = transfer address
BIOSCODE:0C74                                         ;      (must not cross a 64k physical boundary)
BIOSCODE:0C74                                         ; [rflag] = 2 if read, 3 if write
BIOSCODE:0C74                                         ; [verify] = 0 for normal, 1 for verify after write
BIOSCODE:0C74                                         ;
BIOSCODE:0C74                                         ; bp = MAXERR
BIOSCODE:0C74                                         ;      retry_count
BIOSCODE:0C77                 test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
BIOSCODE:0C7C                 jz      short GetRdWrInd
BIOSCODE:0C7E                 cmp     ah, 4           ; romverify ; Is this a track verify?
BIOSCODE:0C81                 jz      short GetRdWrInd
BIOSCODE:0C83                 mov     bp, 2           ; This is not verify so only 1 retry
BIOSCODE:0C86
BIOSCODE:0C86 GetRdWrInd:                             ; CODE XREF: Disk+8↑j
BIOSCODE:0C86                                         ; Disk+D↑j
BIOSCODE:0C86                 mov     ds:vretry_cnt, bp ; verify op. retry cnt for write-verify
BIOSCODE:0C8A                 mov     ds:soft_ecc_cnt, bp ; soft ecc error retry count
BIOSCODE:0C8E                 mov     ah, ds:rflag    ; get read/write indicator
BIOSCODE:0C92
BIOSCODE:0C92 _retry:                                 ; CODE XREF: Disk+12A↓j
BIOSCODE:0C92                 push    ax
BIOSCODE:0C93                 mov     dx, ds:curtrk
BIOSCODE:0C97                 test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.bdsm_ismini]
BIOSCODE:0C97                                         ; is this a mini disk? ((logical dos partition))
BIOSCODE:0C9C                 jz      short disk_not_mini ; no. continue to next
BIOSCODE:0C9E                 cmp     word ptr es:[di+79h], 1
BIOSCODE:0CA3                 jnz     short disk_not_mini
BIOSCODE:0CA5                 add     dx, es:[di+7Bh] ; [es:di+BDS.bdsm_hidden_trks]
BIOSCODE:0CA5                                         ; add hidden tracks
BIOSCODE:0CA9
BIOSCODE:0CA9 disk_not_mini:                          ; CODE XREF: Disk+28↑j
BIOSCODE:0CA9                                         ; Disk+2F↑j
BIOSCODE:0CA9                 ror     dh, 1
BIOSCODE:0CAB                 ror     dh, 1
BIOSCODE:0CAD                 or      dh, ds:cursec
BIOSCODE:0CB1                 mov     cl, dh
BIOSCODE:0CB3                 mov     ch, dl          ; cl = sector, ch = cylinder
BIOSCODE:0CB5                 mov     dh, ds:curhd    ; load current head number and
BIOSCODE:0CB9                 mov     dl, es:[di+4]   ; physical drive number
BIOSCODE:0CB9                                         ; [es:di+BDS.drivenum]
BIOSCODE:0CBD                 cmp     byte ptr es:[di+3Eh], 5 ; [es:di+BDS.formfactor], ffHardFile
BIOSCODE:0CC2                 jz      short do_fast   ; hard files use fast speed
BIOSCODE:0CC4                 cmp     ds:step_drv, 0FFh ; -1
BIOSCODE:0CC9                 jz      short do_write
BIOSCODE:0CCB                 cmp     ah, 2           ; romread
BIOSCODE:0CCE                 jz      short do_fast
BIOSCODE:0CD0                 cmp     ah, 4           ; romverify
BIOSCODE:0CD3                 jnz     short do_write
BIOSCODE:0CD5
BIOSCODE:0CD5 do_fast:                                ; CODE XREF: Disk+4E↑j
BIOSCODE:0CD5                                         ; Disk+5A↑j ...
BIOSCODE:0CD5                 call    fastspeed
BIOSCODE:0CD8
BIOSCODE:0CD8 testerr:                                ; CODE XREF: Disk+D0↓j
BIOSCODE:0CD8                 jb      short dskerr_brdg
BIOSCODE:0CDA                 cmp     bp, 5           ; is there retry ?
BIOSCODE:0CDD                 jnz     short testerror ; yes
BIOSCODE:0CDF                 cmp     ah, 0BBh        ; Undefined error (hard disk)
BIOSCODE:0CE2                 jz      short dskerr_brdg
BIOSCODE:0CE4
BIOSCODE:0CE4 testerror:                              ; CODE XREF: Disk+69↑j
BIOSCODE:0CE4                 mov     ds:step_drv, dl
BIOSCODE:0CE8                 mov     es:[di+78h], ch ; [es:di+BDS.track]
BIOSCODE:0CEC                 cmp     word ptr ds:rflag, 103h ; check for write and verify
BIOSCODE:0CF2                 jz      short doverify
BIOSCODE:0CF4
BIOSCODE:0CF4 noverify:                               ; CODE XREF: Disk+D9↓j
BIOSCODE:0CF4                                         ; Disk+E4↓j
BIOSCODE:0CF4                 pop     ax
BIOSCODE:0CF5                 test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
BIOSCODE:0CFA                 jz      short its_removable
BIOSCODE:0CFC                 test    byte ptr ds:multrk_flag, 80h ; multrk_on
BIOSCODE:0D01                 jnz     short disk_ret
BIOSCODE:0D03
BIOSCODE:0D03 its_removable:                          ; CODE XREF: Disk+86↑j
BIOSCODE:0D03                 and     cl, 3Fh         ; eliminate cylinder bits from sector
BIOSCODE:0D06                 xor     ah, ah
BIOSCODE:0D08                 sub     ds:seccnt, ax   ; reduce count of sectors to go next sector
BIOSCODE:0D0C                 add     cl, al
BIOSCODE:0D0E                 mov     ds:cursec, cl
BIOSCODE:0D12                 cmp     cl, es:[di+13h] ; [es:di+BDS.secpertrack]
BIOSCODE:0D12                                         ; see if sector/track limit reached
BIOSCODE:0D16                 jbe     short disk_ret
BIOSCODE:0D18                 mov     ds:cursec, 1
BIOSCODE:0D1D                 mov     dh, ds:curhd
BIOSCODE:0D21                 inc     dh
BIOSCODE:0D23                 cmp     dh, es:[di+15h] ; [es:di+BDS.heads]
BIOSCODE:0D23                                         ; see if head limit reached
BIOSCODE:0D27                 jb      short noxor
BIOSCODE:0D29                 xor     dh, dh          ; head 0
BIOSCODE:0D2B                 inc     ds:curtrk       ; next track
BIOSCODE:0D2F
BIOSCODE:0D2F noxor:                                  ; CODE XREF: Disk+B3↑j
BIOSCODE:0D2F                 mov     ds:curhd, dh
BIOSCODE:0D33
BIOSCODE:0D33 disk_ret:                               ; CODE XREF: Disk+8D↑j
BIOSCODE:0D33                                         ; Disk+A2↑j
BIOSCODE:0D33                 clc
BIOSCODE:0D34                 retn
BIOSCODE:0D35 ; ---------------------------------------------------------------------------
BIOSCODE:0D35
BIOSCODE:0D35 do_write:                               ; CODE XREF: Disk+55↑j
BIOSCODE:0D35                                         ; Disk+5F↑j
BIOSCODE:0D35                 cmp     dl, ds:step_drv
BIOSCODE:0D39                 jnz     short do_norm   ; we have changed drives
BIOSCODE:0D3B                 cmp     ch, es:[di+78h] ; [es:di+BDS.track]
BIOSCODE:0D3F                 jz      short do_fast   ; we are still on the same track
BIOSCODE:0D41
BIOSCODE:0D41 do_norm:                                ; CODE XREF: Disk+C5↑j
BIOSCODE:0D41                 call    normspeed
BIOSCODE:0D44                 jmp     short testerr
BIOSCODE:0D46 ; ---------------------------------------------------------------------------
BIOSCODE:0D46
BIOSCODE:0D46 doverify:                               ; CODE XREF: Disk+7E↑j
BIOSCODE:0D46                 pop     ax
BIOSCODE:0D47                 push    ax
BIOSCODE:0D48                 mov     ah, 4
BIOSCODE:0D4A                 call    fastspeed
BIOSCODE:0D4D                 jnb     short noverify
BIOSCODE:0D4F                 cmp     ah, 11h         ; soft ecc error ?
BIOSCODE:0D52                 jnz     short not_softecc_err
BIOSCODE:0D54                 dec     ds:soft_ecc_cnt
BIOSCODE:0D58                 jz      short noverify  ; no more retry
BIOSCODE:0D5A                 call    ResetDisk
BIOSCODE:0D5D                 jmp     short diskerr1  ; retry
BIOSCODE:0D5F ; ---------------------------------------------------------------------------
BIOSCODE:0D5F
BIOSCODE:0D5F not_softecc_err:                        ; CODE XREF: Disk+DE↑j
BIOSCODE:0D5F                 call    ResetDisk
BIOSCODE:0D62                 dec     ds:vretry_cnt
BIOSCODE:0D66                 jmp     short dskerr0
BIOSCODE:0D68 ; ---------------------------------------------------------------------------
BIOSCODE:0D68
BIOSCODE:0D68 dskerr:                                 ; CODE XREF: Disk:dskerr_brdg↑j
BIOSCODE:0D68                 cmp     ds:fhave96, 0   ; do we have changeline support?
BIOSCODE:0D6D                 jz      short dskerr_nochangeline ; brif not
BIOSCODE:0D6F                 call    checkio
BIOSCODE:0D72
BIOSCODE:0D72 dskerr_nochangeline:                    ; CODE XREF: Disk+F9↑j
BIOSCODE:0D72                 cmp     ds:multitrk_format_flag, 1 ; multi trk format request?
BIOSCODE:0D77                 jnz     short dochkagain ; no more retry
BIOSCODE:0D79                 mov     bp, 1
BIOSCODE:0D7C                 mov     ds:multitrk_format_flag, 0 ; clear the flag
BIOSCODE:0D81
BIOSCODE:0D81 dochkagain:                             ; CODE XREF: Disk+103↑j
BIOSCODE:0D81                 call    again
BIOSCODE:0D84
BIOSCODE:0D84 dskerr0:                                ; CODE XREF: Disk+F2↑j
BIOSCODE:0D84                 jz      short harderr
BIOSCODE:0D86                 test    byte ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
BIOSCODE:0D8B                 jnz     short skip_timeout_chk
BIOSCODE:0D8D                 cmp     ah, 80h         ; timeout?
BIOSCODE:0D90                 jz      short harderr
BIOSCODE:0D92
BIOSCODE:0D92 skip_timeout_chk:                       ; CODE XREF: Disk+117↑j
BIOSCODE:0D92                 cmp     ah, 0CCh        ; write fault error?
BIOSCODE:0D95                 jz      short write_fault_err ; then, don't retry.
BIOSCODE:0D97                 mov     ds:soft_ecc_cnt, 5 ; MAXERR
BIOSCODE:0D97                                         ; set soft_ecc_cnt back   to maxerr
BIOSCODE:0D9D
BIOSCODE:0D9D diskerr1:                               ; CODE XREF: Disk+E9↑j
BIOSCODE:0D9D                                         ; Disk+130↓j
BIOSCODE:0D9D                 pop     ax              ; restore sector count
BIOSCODE:0D9E                 jmp     _retry
BIOSCODE:0DA1 ; ---------------------------------------------------------------------------
BIOSCODE:0DA1
BIOSCODE:0DA1 write_fault_err:                        ; CODE XREF: Disk+121↑j
BIOSCODE:0DA1                 mov     bp, 1           ; just retry only once
BIOSCODE:0DA1                                         ; for write fault error
BIOSCODE:0DA4                 jmp     short diskerr1
BIOSCODE:0DA6 ; ---------------------------------------------------------------------------
BIOSCODE:0DA6
BIOSCODE:0DA6 harderr:                                ; CODE XREF: diskio+EE↑j
BIOSCODE:0DA6                                         ; diskio+12E↑j ...
BIOSCODE:0DA6                 call    maperror
BIOSCODE:0DA9
BIOSCODE:0DA9 harderr2:                               ; CODE XREF: checkio:no_error_map↓j
BIOSCODE:0DA9                 mov     ds:tim_drv, 0FFh ; force a media check through rom
BIOSCODE:0DAE                 mov     cx, ds:seccnt   ; get count of sectors to go
BIOSCODE:0DB2                 mov     sp, ds:spsav    ; recover entry stack pointer
BIOSCODE:0DB6                 jmp     diddle_back
BIOSCODE:0DB6 Disk            endp
BIOSCODE:0DB6
BIOSCODE:0DB9
BIOSCODE:0DB9 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0DB9
BIOSCODE:0DB9
BIOSCODE:0DB9 normspeed       proc near               ; CODE XREF: Disk:do_norm↑p
BIOSCODE:0DB9                 cmp     ds:media_set_for_format, 0
BIOSCODE:0DBE                 jnz     short fastspeed
BIOSCODE:0DC0                 push    es
BIOSCODE:0DC1                 push    ax
BIOSCODE:0DC2                 mov     al, ds:settleslow
BIOSCODE:0DC5                 les     si, ds:dpt      ; current disk parm table
BIOSCODE:0DC9                 mov     es:[si+9], al   ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:0DCD                 pop     ax
BIOSCODE:0DCE                 pop     es
BIOSCODE:0DCF                 call    fastspeed
BIOSCODE:0DD2                 push    ds
BIOSCODE:0DD3                 lds     si, ds:dpt
BIOSCODE:0DD7                 mov     byte ptr [si+9], 1 ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:0DD7                                         ; 1 is fast settle value
BIOSCODE:0DDB                 pop     ds
BIOSCODE:0DDC                 retn
BIOSCODE:0DDC normspeed       endp
BIOSCODE:0DDC
BIOSCODE:0DDD
BIOSCODE:0DDD ; =============== S U B R O U T I N E =======================================
BIOSCODE:0DDD
BIOSCODE:0DDD
BIOSCODE:0DDD fastspeed       proc near               ; CODE XREF: Disk:do_fast↑p
BIOSCODE:0DDD                                         ; Disk+D6↑p ...
BIOSCODE:0DDD                 push    es
BIOSCODE:0DDE                 mov     es, ds:xfer_seg
BIOSCODE:0DE2                 int     13h             ; DISK -
BIOSCODE:0DE4                 mov     ds:xfer_seg, es
BIOSCODE:0DE8                 pop     es
BIOSCODE:0DE9                 retn
BIOSCODE:0DE9 fastspeed       endp
BIOSCODE:0DE9
BIOSCODE:0DEA
BIOSCODE:0DEA ; =============== S U B R O U T I N E =======================================
BIOSCODE:0DEA
BIOSCODE:0DEA
BIOSCODE:0DEA maperror        proc near               ; CODE XREF: BIOSCODE:err_exitj↑p
BIOSCODE:0DEA                                         ; GetBp+D3↑p ...
BIOSCODE:0DEA                 push    cx
BIOSCODE:0DEB                 push    es
BIOSCODE:0DEC                 push    ds
BIOSCODE:0DED                 pop     es              ; set es=Bios_Data
BIOSCODE:0DEE                 mov     al, ah
BIOSCODE:0DF0                 mov     ds:lsterr, al   ; terminate list with error code
BIOSCODE:0DF3                 mov     cx, 11          ; numerr (= errout-errin)
BIOSCODE:0DF3                                         ; number of possible error conditions
BIOSCODE:0DF6                 mov     di, offset errin
BIOSCODE:0DF9                 repne scasb
BIOSCODE:0DFB                 mov     al, [di+10]     ; [di+numerr-1]
BIOSCODE:0DFB                                         ; get translation
BIOSCODE:0DFF                 pop     es
BIOSCODE:0E00                 pop     cx
BIOSCODE:0E01                 stc                     ; flag error condition
BIOSCODE:0E02                 retn
BIOSCODE:0E02 maperror        endp
BIOSCODE:0E02
BIOSCODE:0E03
BIOSCODE:0E03 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0E03
BIOSCODE:0E03
BIOSCODE:0E03 set_tim         proc near               ; CODE XREF: read_sector+6F↑p
BIOSCODE:0E03                                         ; done+7↑p
BIOSCODE:0E03                 push    ax              ; set the time of last access for this drive.
BIOSCODE:0E03                                         ; this is done only for removable media.
BIOSCODE:0E03                                         ; es:di -> bds
BIOSCODE:0E04                 call    GetTickCnt      ; Does INT 1A ah=0 & updates daycnt
BIOSCODE:0E07                 cmp     dx, es:[di+79h] ; [es:di+BDS.tim_lo]
BIOSCODE:0E0B                 jnz     short setaccess
BIOSCODE:0E0D                 cmp     cx, es:[di+7Bh] ; [es:di+BDS.tim_hi]
BIOSCODE:0E11                 jz      short done_set
BIOSCODE:0E13
BIOSCODE:0E13 setaccess:                              ; CODE XREF: set_tim+8↑j
BIOSCODE:0E13                 mov     ds:accesscount, 0 ; the time has passed
BIOSCODE:0E13                                         ; reset the threshold counter
BIOSCODE:0E18                 mov     es:[di+79h], dx
BIOSCODE:0E1C                 mov     es:[di+7Bh], cx
BIOSCODE:0E20
BIOSCODE:0E20 done_set:                               ; CODE XREF: set_tim+E↑j
BIOSCODE:0E20                 clc
BIOSCODE:0E21                 pop     ax
BIOSCODE:0E22                 retn
BIOSCODE:0E22 set_tim         endp
BIOSCODE:0E22
BIOSCODE:0E23
BIOSCODE:0E23 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0E23
BIOSCODE:0E23
BIOSCODE:0E23 again           proc near               ; CODE XREF: read_sector:rd_rty↑p
BIOSCODE:0E23                                         ; diskio+E9↑p ...
BIOSCODE:0E23                 call    ResetDisk
BIOSCODE:0E26                 cmp     ah, 6           ; If it is a media change error
BIOSCODE:0E26                                         ; do not decrement retry count
BIOSCODE:0E29                 jz      short dont_dec_retry_count
BIOSCODE:0E2B                 dec     bp              ; decrement retry count
BIOSCODE:0E2C                 retn
BIOSCODE:0E2D ; ---------------------------------------------------------------------------
BIOSCODE:0E2D
BIOSCODE:0E2D dont_dec_retry_count:                   ; CODE XREF: again+6↑j
BIOSCODE:0E2D                 or      ah, ah
BIOSCODE:0E2F                 retn
BIOSCODE:0E2F again           endp
BIOSCODE:0E2F
BIOSCODE:0E2F ; ---------------------------------------------------------------------------
BIOSCODE:0E30 ioctl_drvnum    db 0                    ; DATA XREF: BIOSCODE:0E3C↓w
BIOSCODE:0E30                                         ; BIOSCODE:ioctl_output_1↓r
BIOSCODE:0E31
BIOSCODE:0E31 ; =============== S U B R O U T I N E =======================================
BIOSCODE:0E31
BIOSCODE:0E31
BIOSCODE:0E31 get_phy_drv_num proc near               ; CODE XREF: BIOSCODE:ioctl_output↓p
BIOSCODE:0E31                                         ; BIOSCODE:ioctl_input↓p
BIOSCODE:0E31                 call    SetDrive        ; get physical drive number
BIOSCODE:0E31                                         ; INPUT: al = logical drive number (BDS.drivelet)
BIOSCODE:0E31                                         ; OUTPUT: physical drive number (BDS.drivenum)
BIOSCODE:0E34                 mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
BIOSCODE:0E38                 retn
BIOSCODE:0E38 get_phy_drv_num endp
BIOSCODE:0E38
BIOSCODE:0E39 ; ---------------------------------------------------------------------------
BIOSCODE:0E39
BIOSCODE:0E39 ioctl_output:                           ; DATA XREF: BIOSCODE:0592↑o
BIOSCODE:0E39                 call    get_phy_drv_num
BIOSCODE:0E3C                 mov     cs:ioctl_drvnum, dl
BIOSCODE:0E41                 mov     ah, 41h
BIOSCODE:0E43                 mov     bx, 55AAh
BIOSCODE:0E46                 int     13h             ; DISK - Check for INT 13h Extensions
BIOSCODE:0E46                                         ; BX = 55AAh, DL = drive number
BIOSCODE:0E46                                         ; Return: CF set if not supported
BIOSCODE:0E46                                         ; AH = extensions version
BIOSCODE:0E46                                         ; BX = AA55h
BIOSCODE:0E46                                         ; CX = Interface support bit map
BIOSCODE:0E48                 jb      short int13h_exts_err
BIOSCODE:0E4A
BIOSCODE:0E4A ioctl_input_1:                          ; CODE XREF: BIOSCODE:0E91↓j
BIOSCODE:0E4A                 les     di, ds:ptrsav
BIOSCODE:0E4E                 les     di, es:[di+14]  ; [es:di+IOCTL_REQ.MINORFUNCTION]
BIOSCODE:0E52                 jb      short ioctl_input_2
BIOSCODE:0E54                 mov     ax, 4600h       ; Eject removable media
BIOSCODE:0E57                 cmp     es:[di], al     ; al = 0 ; disk ioctl function = 0
BIOSCODE:0E5A                 jz      short ioctl_output_1
BIOSCODE:0E5C                 cmp     byte ptr es:[di], 1 ; al = 1 ; disk ioctl function = 1
BIOSCODE:0E60                 jnz     short ioctl_output_2
BIOSCODE:0E62                 mov     ax, 4501h       ; Lock/unlock media
BIOSCODE:0E62                                         ; (al, 0 = lock, 1 = unlock)
BIOSCODE:0E65                 cmp     byte ptr es:[di+1], 0 ; unlock (reverse of INT 13h ah=45h)
BIOSCODE:0E6A                 jz      short ioctl_output_1
BIOSCODE:0E6C                 cmp     es:[di+1], al   ; lock (reverse of INT 13h ah=45h)
BIOSCODE:0E70                 jnz     short ioctl_output_2
BIOSCODE:0E72                 dec     ax
BIOSCODE:0E73
BIOSCODE:0E73 ioctl_output_1:                         ; CODE XREF: BIOSCODE:0E5A↑j
BIOSCODE:0E73                                         ; BIOSCODE:0E6A↑j
BIOSCODE:0E73                 mov     dl, cs:ioctl_drvnum
BIOSCODE:0E78                 int     13h             ; DISK - IBM/MS Extension - LOCK/UNLOCK DRIVE (DL - drive, DS:SI - disk address packet)
BIOSCODE:0E7A                 jb      short int13h_exts_err
BIOSCODE:0E7C
BIOSCODE:0E7C ioctl_output_ret:                       ; CODE XREF: BIOSCODE:0E83↓j
BIOSCODE:0E7C                                         ; BIOSCODE:0E88↓j ...
BIOSCODE:0E7C                 clc
BIOSCODE:0E7D                 retn
BIOSCODE:0E7E ; ---------------------------------------------------------------------------
BIOSCODE:0E7E
BIOSCODE:0E7E ioctl_output_2:                         ; CODE XREF: BIOSCODE:0E60↑j
BIOSCODE:0E7E                                         ; BIOSCODE:0E70↑j ...
BIOSCODE:0E7E                 mov     ah, 1
BIOSCODE:0E80
BIOSCODE:0E80 int13h_exts_err:                        ; CODE XREF: BIOSCODE:0E48↑j
BIOSCODE:0E80                                         ; BIOSCODE:0E7A↑j ...
BIOSCODE:0E80                 cmp     ah, 0B0h        ; volume not locked in drive
BIOSCODE:0E83                 jz      short ioctl_output_ret
BIOSCODE:0E85                 cmp     ah, 0B4h        ; lock count exceeded
BIOSCODE:0E88                 jz      short ioctl_output_ret
BIOSCODE:0E8A                 jmp     err_exitj
BIOSCODE:0E8D ; ---------------------------------------------------------------------------
BIOSCODE:0E8D
BIOSCODE:0E8D ioctl_input:                            ; DATA XREF: BIOSCODE:0580↑o
BIOSCODE:0E8D                 call    get_phy_drv_num
BIOSCODE:0E90                 stc
BIOSCODE:0E91                 jmp     short ioctl_input_1
BIOSCODE:0E93 ; ---------------------------------------------------------------------------
BIOSCODE:0E93
BIOSCODE:0E93 ioctl_input_2:                          ; CODE XREF: BIOSCODE:0E52↑j
BIOSCODE:0E93                 cmp     byte ptr es:[di], 6 ; disk ioctl function = 6
BIOSCODE:0E97                 jnz     short ioctl_output_2
BIOSCODE:0E99                 mov     ax, 4502h       ; get lock status
BIOSCODE:0E9C                 int     13h             ; DISK - IBM/MS Extension - LOCK/UNLOCK DRIVE (DL - drive, DS:SI - disk address packet)
BIOSCODE:0E9E                 jb      short int13h_exts_err
BIOSCODE:0EA0                 mov     bx, 0Ch         ; bit 1 lock bit
BIOSCODE:0EA3                 cmp     al, 0           ; not locked
BIOSCODE:0EA5                 jz      short ioctl_input_3
BIOSCODE:0EA7                 mov     bl, 0Eh
BIOSCODE:0EA9
BIOSCODE:0EA9 ioctl_input_3:                          ; CODE XREF: BIOSCODE:0EA5↑j
BIOSCODE:0EA9                 push    bx
BIOSCODE:0EAA                 mov     ah, 4
BIOSCODE:0EAC                 mov     cx, 101h
BIOSCODE:0EAF                 mov     dh, 1
BIOSCODE:0EB1                 int     13h             ; DISK - VERIFY SECTORS
BIOSCODE:0EB1                                         ; AL = number of sectors to verify, CH = track, CL = sector
BIOSCODE:0EB1                                         ; DH = head, DL = drive
BIOSCODE:0EB1                                         ; Return: CF set on error, AH = status
BIOSCODE:0EB1                                         ; AL = number of sectors verified
BIOSCODE:0EB3                 pop     bx
BIOSCODE:0EB4                 cmp     ah, 31h         ; no media in drive (IBM/MS INT 13 extensions)
BIOSCODE:0EB7                 jz      short ioctl_input_5
BIOSCODE:0EB9                 cmp     ah, 80h         ; timeout (not ready)
BIOSCODE:0EBC                 jz      short ioctl_input_5
BIOSCODE:0EBE
BIOSCODE:0EBE ioctl_input_4:                          ; CODE XREF: BIOSCODE:0EC8↓j
BIOSCODE:0EBE                 mov     es:[di+1], bx
BIOSCODE:0EC2                 jmp     short ioctl_output_ret
BIOSCODE:0EC4 ; ---------------------------------------------------------------------------
BIOSCODE:0EC4
BIOSCODE:0EC4 ioctl_input_5:                          ; CODE XREF: BIOSCODE:0EB7↑j
BIOSCODE:0EC4                                         ; BIOSCODE:0EBC↑j
BIOSCODE:0EC4                 or      bx, 801h        ; bit 0 error bit (1 = error, 31h or 80h)
BIOSCODE:0EC4                                         ; bit 11 (not ready -removable media error- bit)
BIOSCODE:0EC4                                         ; if bit 11 = 0, another error (except 31h and 80h)
BIOSCODE:0EC8                 jmp     short ioctl_input_4
BIOSCODE:0EC8 ; ---------------------------------------------------------------------------
BIOSCODE:0ECA IoReadJumpTable db 15                   ; DATA XREF: BIOSCODE:0F35↓o
BIOSCODE:0ECB                 dw offset GetDeviceParameters ; 60h
BIOSCODE:0ECD                 dw offset ReadTrack     ; 61h
BIOSCODE:0ECF                 dw offset VerifyTrack   ; 62h
BIOSCODE:0ED1                 dw offset Cmd_Error_Proc ; 63h
BIOSCODE:0ED3                 dw offset Cmd_Error_Proc ; 64h
BIOSCODE:0ED5                 dw offset Cmd_Error_Proc ; 65h
BIOSCODE:0ED7                 dw offset GetMediaId    ; 66h
BIOSCODE:0ED9                 dw offset GetAccessFlag ; 67h
BIOSCODE:0EDB                 dw offset SenseMediaType ; 68h
BIOSCODE:0EDD                 dw offset Cmd_Error_Proc ; 69h
BIOSCODE:0EDF                 dw offset Cmd_Error_Proc ; 6Ah
BIOSCODE:0EE1                 dw offset Cmd_Error_Proc ; 6Bh
BIOSCODE:0EE3                 dw offset Cmd_Error_Proc ; 6Ch
BIOSCODE:0EE5                 dw offset Cmd_Error_Proc ; 6Dh
BIOSCODE:0EE7                 dw offset Cmd_Error_Proc ; 6Eh
BIOSCODE:0EE9                 dw offset GetDrvMapInfo ; 6Fh
BIOSCODE:0EEB IoWriteJumpTable db 9                   ; DATA XREF: BIOSCODE:0F3C↓o
BIOSCODE:0EEC                 dw offset SetDeviceParameters ; 40h
BIOSCODE:0EEE                 dw offset WriteTrack    ; 41h
BIOSCODE:0EF0                 dw offset FormatTrack   ; 42h
BIOSCODE:0EF2                 dw offset Cmd_Error_Proc ; 43h
BIOSCODE:0EF4                 dw offset Cmd_Error_Proc ; 44h
BIOSCODE:0EF6                 dw offset Cmd_Error_Proc ; 45h
BIOSCODE:0EF8                 dw offset SetMediaId    ; 46h
BIOSCODE:0EFA                 dw offset SetAccessFlag ; 47h
BIOSCODE:0EFC                 dw offset SetLockState  ; 48h
BIOSCODE:0EFE                 dw offset EjectMedia    ; 49h
BIOSCODE:0F00 IOC_DC_Table    db 60h, 40h, 61h, 41h, 62h, 42h, 66h, 46h, 67h, 47h, 68h
BIOSCODE:0F00                                         ; DATA XREF: ioctl_support_query+16↓o
BIOSCODE:0F00                 db 48h, 49h, 6Fh
BIOSCODE:0F0E new_genioctl    db 0                    ; DATA XREF: BIOSCODE:0F12↓w
BIOSCODE:0F0E                                         ; BIOSCODE:0F24↓w ...
BIOSCODE:0F0F ; ---------------------------------------------------------------------------
BIOSCODE:0F0F
BIOSCODE:0F0F do_generic_ioctl:                       ; DATA XREF: BIOSCODE:05A0↑o
BIOSCODE:0F0F                 call    SetDrive        ; es:di points to bds for drive
BIOSCODE:0F12                 mov     cs:new_genioctl, 0 ; 0, old generic ioctl function
BIOSCODE:0F18                 push    es
BIOSCODE:0F19                 les     bx, ds:ptrsav   ; es:bx points to request header
BIOSCODE:0F1D                 cmp     byte ptr es:[bx+0Dh], 8 ; [es:bx+IOCTL_REQ.MAJORFUNCTION],
BIOSCODE:0F1D                                         ; RAWIO
BIOSCODE:0F22                 jz      short chk_genioctl_minor
BIOSCODE:0F24                 inc     cs:new_genioctl ; 1, new generic ioctl function (FAT32)
BIOSCODE:0F29                 cmp     byte ptr es:[bx+0Dh], 48h ; Generic IOCtl Request support
BIOSCODE:0F29                                         ; (called only if bit 6 of attribute is set to 1)
BIOSCODE:0F2E
BIOSCODE:0F2E chk_genioctl_minor:                     ; CODE XREF: BIOSCODE:0F22↑j
BIOSCODE:0F2E                 mov     al, es:[bx+0Eh] ; [es:bx+IOCTL_REQ.MINORFUNCTION]
BIOSCODE:0F32                 pop     es
BIOSCODE:0F33                 jnz     short IoctlFuncErr
BIOSCODE:0F35                 mov     si, offset IoReadJumpTable
BIOSCODE:0F38                 test    al, 20h         ; GEN_IOCTL_FN_TST ; test of req. function
BIOSCODE:0F3A                 jnz     short NotGenericWrite
BIOSCODE:0F3C                 mov     si, offset IoWriteJumpTable
BIOSCODE:0F3F
BIOSCODE:0F3F NotGenericWrite:                        ; CODE XREF: BIOSCODE:0F3A↑j
BIOSCODE:0F3F                 and     al, 0DFh        ; ~GEN_IOCTL_FN_TST ; get rid of read/write
BIOSCODE:0F41                 sub     al, 40h         ; offset for base function
BIOSCODE:0F43                 cmp     al, cs:[si]
BIOSCODE:0F46                 ja      short IoctlFuncErr
BIOSCODE:0F48                 cbw
BIOSCODE:0F49                 add     ax, ax
BIOSCODE:0F4B                 inc     si
BIOSCODE:0F4C                 add     si, ax
BIOSCODE:0F4E                 call    word ptr cs:[si]
BIOSCODE:0F51                 mov     ds, cs:Bios_Data_Word
BIOSCODE:0F56                 assume ds:nothing
BIOSCODE:0F56                 mov     ah, 81h         ; Return this status in case of carry
BIOSCODE:0F58                 retn
BIOSCODE:0F59 ; ---------------------------------------------------------------------------
BIOSCODE:0F59
BIOSCODE:0F59 Cmd_Error_Proc:                         ; DATA XREF: BIOSCODE:0ED1↑o
BIOSCODE:0F59                                         ; BIOSCODE:0ED3↑o ...
BIOSCODE:0F59                 pop     dx
BIOSCODE:0F5A
BIOSCODE:0F5A IoctlFuncErr:                           ; CODE XREF: BIOSCODE:0F33↑j
BIOSCODE:0F5A                                         ; BIOSCODE:0F46↑j
BIOSCODE:0F5A                 jmp     bc_cmderr
BIOSCODE:0F5D ; ---------------------------------------------------------------------------
BIOSCODE:0F5D
BIOSCODE:0F5D GetDeviceParameters:                    ; DATA XREF: BIOSCODE:0ECB↑o
BIOSCODE:0F5D                 lds     bx, ds:ptrsav   ; ds:bx points to request header
BIOSCODE:0F61                 assume ds:nothing
BIOSCODE:0F61                 lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:0F61                                         ; (ds:bx) = return buffer
BIOSCODE:0F64                 mov     al, es:[di+3Eh] ; [es:di+BDS.formfactor]
BIOSCODE:0F68                 mov     [bx+1], al      ; [bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
BIOSCODE:0F6B                 mov     ax, es:[di+3Fh] ; [es:di+BDS.flags]
BIOSCODE:0F6F                 and     ax, 3           ; fnon_removable+fchangeline
BIOSCODE:0F6F                                         ; Mask off other bits
BIOSCODE:0F72                 mov     [bx+2], ax      ; [bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
BIOSCODE:0F75                 mov     ax, es:[di+41h] ; [es:di+BDS.cylinders]
BIOSCODE:0F79                 mov     [bx+4], ax      ; [bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
BIOSCODE:0F7C                 xor     al, al          ; Set media type to default
BIOSCODE:0F7E                 mov     [bx+6], al      ; [bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
BIOSCODE:0F81                 lea     si, [di+43h]    ; [di+BDS.rbytespersec] = [di+BDS.R_BPB]
BIOSCODE:0F81                                         ; (copy recommended bpb)
BIOSCODE:0F84                 test    byte ptr [bx], 1 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
BIOSCODE:0F84                                         ; BUILD_DEVICE_BPB
BIOSCODE:0F87                 jz      short UseBpbPresent
BIOSCODE:0F89                 push    ds
BIOSCODE:0F8A                 mov     ds, cs:Bios_Data_Word ; Point back to BIOSDATA
BIOSCODE:0F8F                 assume ds:nothing
BIOSCODE:0F8F                 call    checksingle
BIOSCODE:0F92                 call    GetBp           ; Build the bpb from scratch
BIOSCODE:0F95                 pop     ds
BIOSCODE:0F96                 assume ds:nothing
BIOSCODE:0F96                 jb      short GetParmRet
BIOSCODE:0F98                 lea     si, [di+6]      ; [di+BDS.bytespersec] = [di+BSD.DP_BPB]
BIOSCODE:0F98                                         ; Use this subfield of bds instead
BIOSCODE:0F9B
BIOSCODE:0F9B UseBpbPresent:                          ; CODE XREF: BIOSCODE:0F87↑j
BIOSCODE:0F9B                 lea     di, [bx+7]      ; [bx+A_DEVICEPARAMETERS.DP_BPB]
BIOSCODE:0F9B                                         ; This is where the result goes
BIOSCODE:0F9E                 xor     dx, dx
BIOSCODE:0FA0                 mov     cx, 31          ; A_BPB.size = 31
BIOSCODE:0FA3                 cmp     cs:new_genioctl, dl
BIOSCODE:0FA8                 jz      short gdp_1     ; old type (FAT12 & FAT16) structure
BIOSCODE:0FAA                 mov     cx, 53          ; FAT32 BPB size
BIOSCODE:0FAD                 mov     dx, 32          ; 53+32 = 85 bytes (A_BPB_FAT32.size)
BIOSCODE:0FB0
BIOSCODE:0FB0 gdp_1:                                  ; CODE XREF: BIOSCODE:0FA8↑j
BIOSCODE:0FB0                 push    ds              ; reverse segments for copy
BIOSCODE:0FB1                 push    es
BIOSCODE:0FB2                 pop     ds
BIOSCODE:0FB3                 pop     es
BIOSCODE:0FB4                 rep movsb
BIOSCODE:0FB6                 mov     cx, dx          ; 0 or 32
BIOSCODE:0FB8                 jcxz    short gdp_2
BIOSCODE:0FBA                 xor     al, al          ; 32 zeros
BIOSCODE:0FBC                 rep stosb
BIOSCODE:0FBE
BIOSCODE:0FBE gdp_2:                                  ; CODE XREF: BIOSCODE:0FB8↑j
BIOSCODE:0FBE                 clc
BIOSCODE:0FBF
BIOSCODE:0FBF GetParmRet:                             ; CODE XREF: BIOSCODE:0F96↑j
BIOSCODE:0FBF                 retn
BIOSCODE:0FC0 ; ---------------------------------------------------------------------------
BIOSCODE:0FC0
BIOSCODE:0FC0 SetDeviceParameters:                    ; DATA XREF: BIOSCODE:0EEC↑o
BIOSCODE:0FC0                 lds     bx, ds:ptrsav   ; ds:bx points to request header
BIOSCODE:0FC4                 lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:0FC7                 or      word ptr es:[di+3Fh], 140h ; [es:di+BDS.flags],
BIOSCODE:0FC7                                         ;  fchanged_by_format|fchanged
BIOSCODE:0FCD                 test    byte ptr [bx], 2 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
BIOSCODE:0FCD                                         ;  ONLY_SET_TRACKLAYOUT
BIOSCODE:0FD0                 jz      short sdp_1
BIOSCODE:0FD2                 jmp     setTrackTable
BIOSCODE:0FD5 ; ---------------------------------------------------------------------------
BIOSCODE:0FD5
BIOSCODE:0FD5 sdp_1:                                  ; CODE XREF: BIOSCODE:0FD0↑j
BIOSCODE:0FD5                 mov     al, [bx+1]      ; [bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
BIOSCODE:0FD8                 mov     es:[di+3Eh], al ; [es:di+BDS.formfactor]
BIOSCODE:0FDC                 mov     ax, [bx+4]      ; [bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
BIOSCODE:0FDF                 mov     es:[di+41h], ax ; [es:di+BDS.cylinders]
BIOSCODE:0FE3                 mov     ax, [bx+2]      ; [bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
BIOSCODE:0FE6                 push    ds
BIOSCODE:0FE7                 mov     ds, cs:Bios_Data_Word ; BIOSDATA segment
BIOSCODE:0FEC                 assume ds:nothing
BIOSCODE:0FEC                 cmp     ds:fhave96, 0
BIOSCODE:0FF1                 pop     ds
BIOSCODE:0FF2                 assume ds:nothing
BIOSCODE:0FF2                 jnz     short HaveChange ; we have changeline support
BIOSCODE:0FF4                 and     ax, 0FFFDh
BIOSCODE:0FF7
BIOSCODE:0FF7 HaveChange:                             ; CODE XREF: BIOSCODE:0FF2↑j
BIOSCODE:0FF7                 and     ax, 3           ; Ignore all bits except non_removable and changeline
BIOSCODE:0FF7                                         ; fnon_removable|fchangeline
BIOSCODE:0FFA                 mov     cx, es:[di+3Fh] ; [es:di+BDS.flags]
BIOSCODE:0FFE                 and     cx, 0FDF4h      ; ~(fnon_removable|fchangeline|good_tracklayout|unformatted_media)
BIOSCODE:1002                 or      ax, cx
BIOSCODE:1004                 mov     es:[di+3Fh], ax ; [es:di+BDS.flags]
BIOSCODE:1008                 mov     al, [bx+6]      ; [bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
BIOSCODE:1008                                         ; Set media type
BIOSCODE:100B                 push    ds
BIOSCODE:100C                 mov     ds, cs:Bios_Data_Word
BIOSCODE:1011                 assume ds:nothing
BIOSCODE:1011                 mov     ds:mediatype, al
BIOSCODE:1014                 mov     cx, 53          ; FAT32 BPB size
BIOSCODE:1017                 cmp     cs:new_genioctl, 0
BIOSCODE:101D                 jnz     short sdp_2     ; new type (FAT32) structure
BIOSCODE:101F                 mov     cx, 31          ; A_BPB.size = 31
BIOSCODE:1022
BIOSCODE:1022 sdp_2:                                  ; CODE XREF: BIOSCODE:101D↑j
BIOSCODE:1022                 pop     ds
BIOSCODE:1023                 assume ds:nothing
BIOSCODE:1023                 or      word ptr es:[di+3Fh], 80h ; [es:di+BDS.flags],
BIOSCODE:1023                                         ; set_dasd_true (the next time we format a track)
BIOSCODE:1029                 push    di
BIOSCODE:102A                 test    byte ptr [bx], 1 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
BIOSCODE:102A                                         ;  INSTALL_FAKE_BPB
BIOSCODE:102D                 jnz     short InstallFakeBpb
BIOSCODE:102F                 test    word ptr es:[di+3Fh], 4 ; [es:di+BDS.flags], return_fake_bpb
BIOSCODE:102F                                         ; were we returning a fake bpb when asked to build a bpb?
BIOSCODE:1035                 jz      short InstallRecommendedBpb
BIOSCODE:1037                 and     word ptr es:[di+3Fh], 0FFFBh ; [es:di+BDS.flags], ~return_fake_bpb
BIOSCODE:1037                                         ; we were returning a fake bpb but we can stop now
BIOSCODE:103C
BIOSCODE:103C InstallRecommendedBpb:                  ; CODE XREF: BIOSCODE:1035↑j
BIOSCODE:103C                 lea     di, [di+43h]    ; [di+BDS.R_BPB] = [di+BDS.rbytespersec]
BIOSCODE:103F                 jmp     short CopyTheBpb
BIOSCODE:1041 ; ---------------------------------------------------------------------------
BIOSCODE:1041
BIOSCODE:1041 InstallFakeBpb:                         ; CODE XREF: BIOSCODE:102D↑j
BIOSCODE:1041                 or      word ptr es:[di+3Fh], 4 ; byte [es:di+BDS.flags], return_fake_bpb
BIOSCODE:1046                 lea     di, [di+6]      ; [es:di+BDS.BPB] = [es:di+BDS.bytespersec]
BIOSCODE:1049
BIOSCODE:1049 CopyTheBpb:                             ; CODE XREF: BIOSCODE:103F↑j
BIOSCODE:1049                 lea     si, [bx+7]      ; [bx+A_DEVICEPARAMETERS.DP_BPB]
BIOSCODE:104C                 rep movsb
BIOSCODE:104E                 push    ds              ; Save packet segment
BIOSCODE:104F                 mov     ds, cs:Bios_Data_Word ; BIOSDATA segment
BIOSCODE:1054                 assume ds:nothing
BIOSCODE:1054                 call    RestoreOldDpt
BIOSCODE:1057                 pop     ds
BIOSCODE:1058                 assume ds:nothing
BIOSCODE:1058                 pop     di
BIOSCODE:1059
BIOSCODE:1059 setTrackTable:                          ; CODE XREF: BIOSCODE:0FD2↑j
BIOSCODE:1059                 mov     cx, [bx+5Ch]    ; [bx+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]
BIOSCODE:1059                                         ; offset 85+7 (A_BPB.size+7) (FAT32)
BIOSCODE:105C                 cmp     cs:new_genioctl, 0
BIOSCODE:1062                 jnz     short sdp_3     ; new type (FAT32) structure
BIOSCODE:1064                 mov     cx, [bx+26h]    ; [bx+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]
BIOSCODE:1064                                         ; offset 31+7 (A_BPB.size+7)
BIOSCODE:1067
BIOSCODE:1067 sdp_3:                                  ; CODE XREF: BIOSCODE:1062↑j
BIOSCODE:1067                 push    ds
BIOSCODE:1068                 mov     ds, cs:Bios_Data_Word
BIOSCODE:106D                 assume ds:nothing
BIOSCODE:106D                 mov     ds:sectorspertrack, cx
BIOSCODE:1071                 pop     ds
BIOSCODE:1072                 assume ds:nothing
BIOSCODE:1072                 and     word ptr es:[di+3Fh], 0FFF7h ; [es:di+BDS.flags], ~good_tracklayout
BIOSCODE:1077                 test    byte ptr [bx], 4 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
BIOSCODE:1077                                         ;  TRACKLAYOUT_IS_GOOD
BIOSCODE:107A                 jz      short UglyTrackLayOut
BIOSCODE:107C                 or      word ptr es:[di+3Fh], 8 ; [es:di+BDS.flags], good_tracklayout
BIOSCODE:1081
BIOSCODE:1081 UglyTrackLayOut:                        ; CODE XREF: BIOSCODE:107A↑j
BIOSCODE:1081                 cmp     cx, 63          ; MAX_SECTORS_IN_TRACK
BIOSCODE:1084                 ja      short TooManyPerTrack
BIOSCODE:1086                 jcxz    short SectorInfoSaved
BIOSCODE:1088                 mov     di, offset tracktable
BIOSCODE:108B                 lea     si, [bx+5Eh]    ; [bx+A_DEVICEPARAMETERS.DP_SECTORTABLE]
BIOSCODE:108B                                         ; offset 85+9 (A_BPB.size+9) (FAT32)
BIOSCODE:108E                 cmp     cs:new_genioctl, 0
BIOSCODE:1094                 jnz     short sdp_4     ; new type (FAT32) structure
BIOSCODE:1096                 lea     si, [bx+28h]    ; [bx+A_DEVICEPARAMETERS.DP_SECTORTABLE]
BIOSCODE:1096                                         ; offset 31+9 (A_BPB.size+9)
BIOSCODE:1099
BIOSCODE:1099 sdp_4:                                  ; CODE XREF: BIOSCODE:1094↑j
BIOSCODE:1099                 mov     es, cs:Bios_Data_Word ; BIOSDATA segment
BIOSCODE:1099                                         ; Trash our bds pointer
BIOSCODE:109E                 assume es:nothing
BIOSCODE:109E
BIOSCODE:109E StoreSectorInfo:                        ; CODE XREF: BIOSCODE:10AF↓j
BIOSCODE:109E                 inc     di
BIOSCODE:109F                 inc     di              ; Skip over cylinder and head
BIOSCODE:10A0                 lodsw                   ; Get sector id
BIOSCODE:10A1                 stosb                   ; Copy it
BIOSCODE:10A2                 lodsw                   ; Get sector size
BIOSCODE:10A2                                         ;
BIOSCODE:10A2                                         ; SectSizeToSectIndex:
BIOSCODE:10A2                                         ;     Input:  ax contains sector size in bytes
BIOSCODE:10A2                                         ;     Output: al contains index
BIOSCODE:10A3                 cmp     ah, 2           ; > 512 bytes per sector ?
BIOSCODE:10A6                 ja      short OneK      ; yes
BIOSCODE:10A8                 mov     al, ah          ; set index to 2 or 1 (256 bps) or 0 (128 bps)
BIOSCODE:10AA                 jmp     short sdp_5
BIOSCODE:10AC ; ---------------------------------------------------------------------------
BIOSCODE:10AC
BIOSCODE:10AC OneK:                                   ; CODE XREF: BIOSCODE:10A6↑j
BIOSCODE:10AC                 mov     al, 3           ; 1024 bytes per sector
BIOSCODE:10AC                                         ; set index to 3
BIOSCODE:10AE
BIOSCODE:10AE sdp_5:                                  ; CODE XREF: BIOSCODE:10AA↑j
BIOSCODE:10AE                 stosb
BIOSCODE:10AF                 loop    StoreSectorInfo
BIOSCODE:10B1
BIOSCODE:10B1 SectorInfoSaved:                        ; CODE XREF: BIOSCODE:1086↑j
BIOSCODE:10B1                 clc
BIOSCODE:10B2                 retn
BIOSCODE:10B3 ; ---------------------------------------------------------------------------
BIOSCODE:10B3
BIOSCODE:10B3 TooManyPerTrack:                        ; CODE XREF: BIOSCODE:1084↑j
BIOSCODE:10B3                 mov     al, 0Ch
BIOSCODE:10B5                 stc
BIOSCODE:10B6                 retn
BIOSCODE:10B7 ; ---------------------------------------------------------------------------
BIOSCODE:10B7
BIOSCODE:10B7 FormatTrack:                            ; DATA XREF: BIOSCODE:0EF0↑o
BIOSCODE:10B7                 lds     bx, ds:ptrsav
BIOSCODE:10BB                 lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:10BE                 test    byte ptr [bx], 1 ; bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],
BIOSCODE:10BE                                         ;  STATUS_FOR_FORMAT
BIOSCODE:10C1                 jz      short DoFormatTrack
BIOSCODE:10C3                 push    ds
BIOSCODE:10C4                 mov     ds, cs:Bios_Data_Word
BIOSCODE:10C9                 assume ds:nothing
BIOSCODE:10C9                 call    SetMediaForFormat ; Also moves current Dpt to TempDpt
BIOSCODE:10CC                 pop     ds
BIOSCODE:10CD                 assume ds:nothing
BIOSCODE:10CD                 mov     [bx], al        ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
BIOSCODE:10CF                 clc
BIOSCODE:10D0                 retn
BIOSCODE:10D1 ; ---------------------------------------------------------------------------
BIOSCODE:10D1
BIOSCODE:10D1 DoFormatTrack:                          ; CODE XREF: BIOSCODE:10C1↑j
BIOSCODE:10D1                 cmp     byte ptr es:[di+3Eh], 5 ; [es:di+BDS.formfactor], DEV_HARDDISK
BIOSCODE:10D6                 jnz     short DoFormatDiskette
BIOSCODE:10D8                 mov     ds, cs:Bios_Data_Word
BIOSCODE:10DD                 assume ds:nothing
BIOSCODE:10DD                 jmp     VerifyTrack
BIOSCODE:10E0 ; ---------------------------------------------------------------------------
BIOSCODE:10E0
BIOSCODE:10E0 DoFormatDiskette:                       ; CODE XREF: BIOSCODE:10D6↑j
BIOSCODE:10E0                 mov     cx, [bx+1]      ; [bx+A_FORMATPACKET.FP_HEAD]
BIOSCODE:10E3                 mov     dx, [bx+3]      ; [bx+A_FORMATPACKET.FP_CYLINDER]
BIOSCODE:10E6                 test    byte ptr [bx], 2 ; [bx+A_FORMATPACKET.FP_SPECIALFUNCTIONS]
BIOSCODE:10E6                                         ;     FP_TRACKCOUNT is only meaningful
BIOSCODE:10E6                                         ;     when FP_SPECIALFUNCTIONS bit 1 = 1
BIOSCODE:10E9                 mov     ds, cs:Bios_Data_Word
BIOSCODE:10EE                 jz      short DoFormatDiskette_1
BIOSCODE:10F0                 jmp     VerifyTrack_Err
BIOSCODE:10F3 ; ---------------------------------------------------------------------------
BIOSCODE:10F3
BIOSCODE:10F3 DoFormatDiskette_1:                     ; CODE XREF: BIOSCODE:10EE↑j
BIOSCODE:10F3                 call    SetMediaForFormat ; Also moves current Dpt to TempDpt
BIOSCODE:10F6                 cmp     al, 1
BIOSCODE:10F8                 jz      short NeedToSetDasd ; Old rom
BIOSCODE:10FA                 cmp     al, 3           ; Time out error?
BIOSCODE:10FC                 jnz     short NoSetDasd ; No,fine. (at this point, don't care
BIOSCODE:10FC                                         ; about the illegal combination)
BIOSCODE:10FE                 jmp     short FormatFailed
BIOSCODE:1100 ; ---------------------------------------------------------------------------
BIOSCODE:1100
BIOSCODE:1100 NeedToSetDasd:                          ; CODE XREF: BIOSCODE:10F8↑j
BIOSCODE:1100                 push    dx
BIOSCODE:1101                 call    SetDasd         ; INT 13h, ah=17h
BIOSCODE:1104                 pop     dx
BIOSCODE:1105
BIOSCODE:1105 NoSetDasd:                              ; CODE XREF: BIOSCODE:10FC↑j
BIOSCODE:1105                 call    checksingle     ; Do any needed diskette swapping
BIOSCODE:1108                 mov     ax, dx          ; Get track from packet
BIOSCODE:110A                 mov     ds:trknum, ax
BIOSCODE:110D                 mov     ds:hdnum, cl
BIOSCODE:1111                 mov     ah, cl
BIOSCODE:1113                 mov     bx, offset tracktable
BIOSCODE:1116                 mov     cx, ds:sectorspertrack
BIOSCODE:111A                 jcxz    short set_fmt_retry_count
BIOSCODE:111C
BIOSCODE:111C StoreCylinderHead:                      ; CODE XREF: BIOSCODE:1121↓j
BIOSCODE:111C                 mov     [bx], ax        ; Store into TrackTable
BIOSCODE:111E                 add     bx, 4           ; Skip to next sector field
BIOSCODE:1121                 loop    StoreCylinderHead
BIOSCODE:1123
BIOSCODE:1123 set_fmt_retry_count:                    ; CODE XREF: BIOSCODE:111A↑j
BIOSCODE:1123                 mov     cl, 5           ; MAXERR - Set up retry count
BIOSCODE:1125
BIOSCODE:1125 FormatRetry:                            ; CODE XREF: BIOSCODE:1166↓j
BIOSCODE:1125                 push    cx              ; Now verify the sectors just formatted.
BIOSCODE:1125                                         ; NOTE: because of bug in some BIOSes
BIOSCODE:1125                                         ;       we have to set ES:BX to 00:00
BIOSCODE:1126                 mov     bx, offset tracktable
BIOSCODE:1129                 mov     al, byte ptr ds:sectorspertrack
BIOSCODE:112C                 mov     ah, 5           ; romformat
BIOSCODE:112E                 mov     ds:xfer_seg, ds
BIOSCODE:1132                 call    ToRom
BIOSCODE:1135                 pop     cx
BIOSCODE:1136                 jb      short FormatError
BIOSCODE:1138                 push    cx
BIOSCODE:1139                 push    bx
BIOSCODE:113A                 xor     bx, bx
BIOSCODE:113C                 mov     ds:xfer_seg, bx
BIOSCODE:1140                 mov     al, byte ptr ds:sectorspertrack
BIOSCODE:1143                 mov     ah, 4           ; romverify
BIOSCODE:1145                 mov     cl, 1
BIOSCODE:1147                 call    ToRom
BIOSCODE:114A                 pop     bx
BIOSCODE:114B                 pop     cx
BIOSCODE:114C                 jnb     short FormatOk
BIOSCODE:114E
BIOSCODE:114E FormatError:                            ; CODE XREF: BIOSCODE:1136↑j
BIOSCODE:114E                 call    ResetDisk
BIOSCODE:1151                 mov     ds:had_format_error, 1
BIOSCODE:1156                 push    ax
BIOSCODE:1157                 push    cx
BIOSCODE:1158                 push    dx
BIOSCODE:1159                 call    SetMediaForFormat
BIOSCODE:115C                 cmp     al, 1
BIOSCODE:115E                 jnz     short WhileErr
BIOSCODE:1160                 call    SetDasd
BIOSCODE:1163
BIOSCODE:1163 WhileErr:                               ; CODE XREF: BIOSCODE:115E↑j
BIOSCODE:1163                 pop     dx
BIOSCODE:1164                 pop     cx
BIOSCODE:1165                 pop     ax
BIOSCODE:1166                 loop    FormatRetry
BIOSCODE:1168
BIOSCODE:1168 FormatFailed:                           ; CODE XREF: BIOSCODE:10FE↑j
BIOSCODE:1168                 mov     ds:had_format_error, 1 ; Set the format error flag
BIOSCODE:116D                 cmp     ah, 6           ; DSK_CHANGELINE_ERR
BIOSCODE:116D                                         ; convert change line error to time out error
BIOSCODE:1170                 jnz     short DoMapIt
BIOSCODE:1172                 mov     ah, 80h         ; DSK_TIMEOUT_ERR
BIOSCODE:1174
BIOSCODE:1174 DoMapIt:                                ; CODE XREF: BIOSCODE:1170↑j
BIOSCODE:1174                 jmp     maperror
BIOSCODE:1177 ; ---------------------------------------------------------------------------
BIOSCODE:1177
BIOSCODE:1177 FormatOk:                               ; CODE XREF: BIOSCODE:114C↑j
BIOSCODE:1177                 mov     ds:had_format_error, 0 ; reset the format error flag
BIOSCODE:117C                 retn
BIOSCODE:117D ; ---------------------------------------------------------------------------
BIOSCODE:117D
BIOSCODE:117D VerifyTrack:                            ; CODE XREF: BIOSCODE:10DD↑j
BIOSCODE:117D                                         ; DATA XREF: BIOSCODE:0ECF↑o
BIOSCODE:117D                 push    ds
BIOSCODE:117E                 lds     bx, ds:ptrsav   ; ds:bx points to request header.
BIOSCODE:1182                 assume ds:nothing
BIOSCODE:1182                 lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:1185                 mov     cx, [bx+3]      ; [bx+A_VERIFYPACKET.VP_CYLINDER]
BIOSCODE:1188                 mov     ax, [bx+1]      ; [bx+A_VERIFYPACKET.VP_HEAD]
BIOSCODE:118B                 mov     dx, [bx+5]      ; [bx+A_FORMATPACKET.FP_TRACKCOUNT]
BIOSCODE:118E                 mov     bl, [bx]        ; [bx+A_FORMATPACKET.FP_SPECIALFUNCTIONS]
BIOSCODE:1190                 pop     ds
BIOSCODE:1191                 mov     ds:rflag, 4     ; romverify
BIOSCODE:1196                 mov     ds:curtrk, cx
BIOSCODE:119A                 mov     ds:curhd, al    ; assume heads < 256
BIOSCODE:119D                 mov     cx, ds:sectorspertrack
BIOSCODE:11A1                 test    bl, 2           ; DO_FAST_FORMAT
BIOSCODE:11A4                 jz      short NormVerifyTrack
BIOSCODE:11A6                 mov     ax, dx          ; Get ax = number of trks to verify
BIOSCODE:11A8                 or      ah, ah
BIOSCODE:11AA                 jnz     short VerifyTrack_Err ; #tracks > 255
BIOSCODE:11AC                 mul     cl
BIOSCODE:11AE                 or      ah, ah
BIOSCODE:11B0                 jnz     short VerifyTrack_Err
BIOSCODE:11B2                 mov     cx, ax
BIOSCODE:11B4                 test    word ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
BIOSCODE:11BA                 jz      short NormVerifyTrack
BIOSCODE:11BC                 test    ds:multrk_flag, 80h ; MULTI_TRK_ON
BIOSCODE:11C2                 jz      short NormVerifyTrack
BIOSCODE:11C4                 mov     ds:multitrk_format_flag, 1
BIOSCODE:11C9
BIOSCODE:11C9 NormVerifyTrack:                        ; CODE XREF: BIOSCODE:11A4↑j
BIOSCODE:11C9                                         ; BIOSCODE:11BA↑j ...
BIOSCODE:11C9                 xor     ax, ax          ; 1st sector
BIOSCODE:11CB                 xor     bx, bx
BIOSCODE:11CD                 mov     ds:xfer_seg, bx ; Use 0:0 as the transfer address for verify
BIOSCODE:11D1                 call    TrackIo
BIOSCODE:11D4                 mov     ds:multitrk_format_flag, 0
BIOSCODE:11D9                 retn
BIOSCODE:11DA ; ---------------------------------------------------------------------------
BIOSCODE:11DA
BIOSCODE:11DA VerifyTrack_Err:                        ; CODE XREF: BIOSCODE:10F0↑j
BIOSCODE:11DA                                         ; BIOSCODE:11AA↑j ...
BIOSCODE:11DA                 mov     ah, 1
BIOSCODE:11DC                 jmp     maperror
BIOSCODE:11DF ; ---------------------------------------------------------------------------
BIOSCODE:11DF
BIOSCODE:11DF ReadTrack:                              ; DATA XREF: BIOSCODE:0ECD↑o
BIOSCODE:11DF                 mov     ds:rflag, 2     ; romread
BIOSCODE:11E4                 jmp     short ReadWriteTrack
BIOSCODE:11E6 ; ---------------------------------------------------------------------------
BIOSCODE:11E6
BIOSCODE:11E6 WriteTrack:                             ; DATA XREF: BIOSCODE:0EEE↑o
BIOSCODE:11E6                 mov     ds:rflag, 3
BIOSCODE:11EB
BIOSCODE:11EB ReadWriteTrack:                         ; CODE XREF: BIOSCODE:11E4↑j
BIOSCODE:11EB                 push    es
BIOSCODE:11EC                 les     bx, ds:ptrsav   ; es:bx -> to request header
BIOSCODE:11F0                 assume es:nothing
BIOSCODE:11F0                 les     bx, es:[bx+13h] ; [es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:11F4                 mov     ax, es:[bx+3]   ; [es:bx+A_TRACKREADWRITEPACKET.TRWP_CYLINDER]
BIOSCODE:11F8                 mov     ds:curtrk, ax
BIOSCODE:11FB                 mov     ax, es:[bx+1]   ; [es:bx+A_TRACKREADWRITEPACKET.TRWP_HEAD]
BIOSCODE:11FF                 mov     ds:curhd, al    ; Assume heads < 256 !
BIOSCODE:1202                 mov     ax, es:[bx+5]   ; [es:bx+A_TRACKREADWRITEPACKET.TRWP_FIRSTSECTOR]
BIOSCODE:1206                 mov     cx, es:[bx+7]   ; [es:bx+A_TRACKREADWRITEPACKET.TRWP_SECTORSTOREADWRITE]
BIOSCODE:120A                 les     bx, es:[bx+9]   ; [es:bx+A_TRACKREADWRITEPACKET.TRWP_TRANSFERADDRESS]
BIOSCODE:120A                                         ; Get transfer address
BIOSCODE:120E                 mov     ds:xfer_seg, es ; Pass transfer segment
BIOSCODE:1212                 pop     es
BIOSCODE:1213
BIOSCODE:1213 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1213
BIOSCODE:1213
BIOSCODE:1213 TrackIo         proc near               ; CODE XREF: BIOSCODE:11D1↑p
BIOSCODE:1213                 mov     ds:spsav, sp    ; performs track read/write/verify
BIOSCODE:1213                                         ;
BIOSCODE:1213                                         ;  input:
BIOSCODE:1213                                         ;   rFlag - 2 = read
BIOSCODE:1213                                         ;           3 = write
BIOSCODE:1213                                         ;           4 = verify
BIOSCODE:1213                                         ;   ax - Index into track table of first sector to io
BIOSCODE:1213                                         ;   cx - Number of sectors to io
BIOSCODE:1213                                         ;   Xfer_Seg:bx - Transfer address
BIOSCODE:1213                                         ;   es:di - Pointer to bds
BIOSCODE:1213                                         ;   CurTrk - Current cylinder
BIOSCODE:1213                                         ;   CurHd - Current head
BIOSCODE:1217                 call    checksingle
BIOSCODE:121A                 cmp     ds:media_set_for_format, 1 ; See if we have already set disk
BIOSCODE:121F                 jz      short Dptalreadyset
BIOSCODE:1221                 push    ax              ; set up tables and variables for i/o
BIOSCODE:1222                 push    cx
BIOSCODE:1223                 call    iosetup
BIOSCODE:1226                 pop     cx
BIOSCODE:1227                 pop     ax
BIOSCODE:1228
BIOSCODE:1228 Dptalreadyset:                          ; CODE XREF: TrackIo+C↑j
BIOSCODE:1228                 mov     si, offset tracktable ; Point si at the table entry of the
BIOSCODE:1228                                         ; first sector to be io'd
BIOSCODE:122B                 add     ax, ax
BIOSCODE:122D                 add     ax, ax
BIOSCODE:122F                 add     si, ax
BIOSCODE:1231                 mov     dx, 1
BIOSCODE:1234                 test    word ptr es:[di+3Fh], 8 ; [es:di+BDS.flags], good_tracklayout
BIOSCODE:123A                 jz      short ionextsector
BIOSCODE:123C                 xchg    dx, cx          ; We can read all secs in one blow
BIOSCODE:123E
BIOSCODE:123E ionextsector:                           ; CODE XREF: TrackIo+27↑j
BIOSCODE:123E                                         ; TrackIo+7A↓j
BIOSCODE:123E                 push    cx
BIOSCODE:123F                 push    dx
BIOSCODE:1240                 inc     si
BIOSCODE:1241                 inc     si              ; Skip over the cylinder and head in
BIOSCODE:1241                                         ; the track table
BIOSCODE:1242                 lodsb                   ; Get sector ID from track table
BIOSCODE:1243                 mov     ds:cursec, al
BIOSCODE:1246                 test    word ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
BIOSCODE:1246                                         ; Fixed disk?
BIOSCODE:124C                 jz      short IoRemovable ; No
BIOSCODE:124E                 test    ds:multrk_flag, 80h ; MULTI_TRK_ON
BIOSCODE:1254                 jz      short IoRemovable ; No,don't do that.
BIOSCODE:1256                 mov     ds:seccnt, dx
BIOSCODE:125A                 mov     ax, dx
BIOSCODE:125C                 call    Disk
BIOSCODE:125F                 pop     dx
BIOSCODE:1260                 pop     cx
BIOSCODE:1261                 clc
BIOSCODE:1262                 retn
BIOSCODE:1263 ; ---------------------------------------------------------------------------
BIOSCODE:1263
BIOSCODE:1263 IoRemovable:                            ; CODE XREF: TrackIo+39↑j
BIOSCODE:1263                                         ; TrackIo+41↑j
BIOSCODE:1263                 lodsb                   ; Get sector size index from track
BIOSCODE:1263                                         ; table and save it
BIOSCODE:1264                 push    ax
BIOSCODE:1265                 push    si
BIOSCODE:1266                 push    ds              ; Save BIOSDATA
BIOSCODE:1267                 push    ax
BIOSCODE:1268                 mov     ah, ds:eot      ; Preserve whatever might be in ah
BIOSCODE:1268                                         ; Fetch EOT while ds-> BIOSDATA
BIOSCODE:126C                 lds     si, ds:dpt
BIOSCODE:1270                 mov     [si+3], al      ; [si+DISK_PARMS.DISK_SECTOR_SIZ]
BIOSCODE:1273                 mov     [si+4], ah      ; [si+DISK_PARMS.DISK_EOT]
BIOSCODE:1276                 pop     ax
BIOSCODE:1277                 pop     ds
BIOSCODE:1278                 mov     al, dl
BIOSCODE:127A                 mov     ds:seccnt, ax
BIOSCODE:127D                 call    Disk
BIOSCODE:1280                 pop     si              ; Advance buffer pointer by adding
BIOSCODE:1280                                         ; sector size
BIOSCODE:1281                 pop     ax
BIOSCODE:1282                 mov     cl, al          ; SectorSizeIndexToSectorSize
BIOSCODE:1284                 mov     ax, 128
BIOSCODE:1287                 shl     ax, cl
BIOSCODE:1289                 add     bx, ax
BIOSCODE:128B                 pop     dx
BIOSCODE:128C                 pop     cx
BIOSCODE:128D                 loop    ionextsector
BIOSCODE:128F                 cmp     ds:media_set_for_format, 1
BIOSCODE:1294                 jz      short NoNeedDone
BIOSCODE:1296                 call    done            ; set time of last access, and reset
BIOSCODE:1296                                         ; entries in Dpt.
BIOSCODE:1299
BIOSCODE:1299 NoNeedDone:                             ; CODE XREF: TrackIo+81↑j
BIOSCODE:1299                 clc
BIOSCODE:129A                 retn
BIOSCODE:129A TrackIo         endp
BIOSCODE:129A
BIOSCODE:129B
BIOSCODE:129B ; =============== S U B R O U T I N E =======================================
BIOSCODE:129B
BIOSCODE:129B
BIOSCODE:129B SetDasd         proc near               ; CODE XREF: BIOSCODE:1101↑p
BIOSCODE:129B                                         ; BIOSCODE:1160↑p
BIOSCODE:129B                 cmp     ds:had_format_error, 1 ; See if we've previously set dasd type
BIOSCODE:12A0                 jz      short DoSetDasd
BIOSCODE:12A2                 test    word ptr es:[di+3Fh], 80h ; [es:di+BDS.flags], set_dasd_true
BIOSCODE:12A8                 jz      short DasdHasBeenSet
BIOSCODE:12AA                 and     word ptr es:[di+3Fh], 0FF7Fh ; [es:di+BDS.flags], ~set_dasd_true
BIOSCODE:12B0
BIOSCODE:12B0 DoSetDasd:                              ; CODE XREF: SetDasd+5↑j
BIOSCODE:12B0                 mov     ds:had_format_error, 0 ; Reset it
BIOSCODE:12B5                 mov     ds:gap_patch, 50h ; Format gap for 48tpi disks
BIOSCODE:12BA                 mov     al, 4
BIOSCODE:12BC                 mov     ah, es:[di+3Eh] ; [es:di+BDS.formfactor]
BIOSCODE:12C0                 cmp     ah, 2           ; DEV_3INCH720KB
BIOSCODE:12C3                 jz      short DoSet
BIOSCODE:12C5                 cmp     ah, 1           ; DEV_5INCH96TPI
BIOSCODE:12C8                 mov     al, 1
BIOSCODE:12CA                 jnz     short DoSet
BIOSCODE:12CC                 inc     ax              ; mov al, 2
BIOSCODE:12CC                                         ; 160/320k in a 1.2 meg drive
BIOSCODE:12CD                 cmp     ds:mediatype, 0
BIOSCODE:12D2                 jnz     short DoSet
BIOSCODE:12D4                 inc     ax              ; mov al, 3
BIOSCODE:12D4                                         ; 1.2meg in a 1.2meg drive
BIOSCODE:12D5                 mov     ds:gap_patch, 54h ; Format gap for 96 tpi, 1.2MB diskette
BIOSCODE:12DA
BIOSCODE:12DA DoSet:                                  ; CODE XREF: SetDasd+28↑j
BIOSCODE:12DA                                         ; SetDasd+2F↑j ...
BIOSCODE:12DA                 push    ds
BIOSCODE:12DB                 push    si
BIOSCODE:12DC                 xor     si, si
BIOSCODE:12DE                 mov     ds, si          ; 0
BIOSCODE:12E0                 assume ds:nothing
BIOSCODE:12E0                 lds     si, dword ptr ds:78h ; [DSKADR] (Int 1Eh)
BIOSCODE:12E4                 assume ds:nothing
BIOSCODE:12E4                 mov     byte ptr [si+9], 0Fh ; [si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:12E8                 pop     si
BIOSCODE:12E9                 pop     ds
BIOSCODE:12EA                 mov     ah, 17h
BIOSCODE:12EC                 mov     dl, es:[di+4]
BIOSCODE:12F0                 int     13h             ; DISK - SET TYPE (AT,XT2,XT286,CONV,PS
BIOSCODE:12F0                                         ; AL = disk type
BIOSCODE:12F2
BIOSCODE:12F2 DasdHasBeenSet:                         ; CODE XREF: SetDasd+D↑j
BIOSCODE:12F2                 mov     ah, es:[di+13h] ; [es:di+BDS.secpertrack]
BIOSCODE:12F6                 mov     ds:formt_eot, ah
BIOSCODE:12FA                 retn
BIOSCODE:12FA SetDasd         endp
BIOSCODE:12FA
BIOSCODE:12FB
BIOSCODE:12FB ; =============== S U B R O U T I N E =======================================
BIOSCODE:12FB
BIOSCODE:12FB
BIOSCODE:12FB SetMediaForFormat proc near             ; CODE XREF: BIOSCODE:10C9↑p
BIOSCODE:12FB                                         ; BIOSCODE:DoFormatDiskette_1↑p ...
BIOSCODE:12FB                 push    cx
BIOSCODE:12FC                 push    dx
BIOSCODE:12FD                 cmp     ds:had_format_error, 1
BIOSCODE:1302                 jz      short SkipSaveDskAdr
BIOSCODE:1304                 xor     al, al          ; If already done return 0
BIOSCODE:1306                 cmp     ds:media_set_for_format, 1
BIOSCODE:130B                 jnz     short DoSetMediaForFormat
BIOSCODE:130D                 jmp     SetMediaRet     ; Media already set
BIOSCODE:1310 ; ---------------------------------------------------------------------------
BIOSCODE:1310
BIOSCODE:1310 DoSetMediaForFormat:                    ; CODE XREF: SetMediaForFormat+10↑j
BIOSCODE:1310                 push    es
BIOSCODE:1311                 push    si
BIOSCODE:1312                 xor     si, si
BIOSCODE:1314                 mov     es, si          ; 0 ; Point to interrupt vectors
BIOSCODE:1316                 assume es:nothing
BIOSCODE:1316                 les     si, dword ptr es:78h ; [es:DSKADR]
BIOSCODE:1316                                         ; Get pointer to disk base table
BIOSCODE:131B                 assume es:nothing
BIOSCODE:131B                 mov     word ptr ds:dpt, si
BIOSCODE:131F                 mov     word ptr ds:dpt+2, es
BIOSCODE:1323                 mov     byte ptr es:[si+9], 0Fh ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:1328                 pop     si
BIOSCODE:1329                 pop     es
BIOSCODE:132A
BIOSCODE:132A SkipSaveDskAdr:                         ; CODE XREF: SetMediaForFormat+7↑j
BIOSCODE:132A                 mov     cx, es:[di+41h] ; [es:di+BDS.cylinders]
BIOSCODE:132E                 dec     cx
BIOSCODE:132F                 and     ch, 3
BIOSCODE:1332                 ror     ch, 1
BIOSCODE:1334                 ror     ch, 1
BIOSCODE:1336                 xchg    ch, cl
BIOSCODE:1338                 or      cl, es:[di+13h] ; [es:di+BDS.secpertrack]
BIOSCODE:133C                 mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
BIOSCODE:1340                 push    es
BIOSCODE:1341                 push    ds
BIOSCODE:1342                 push    si
BIOSCODE:1343                 push    di
BIOSCODE:1344                 mov     ah, 18h
BIOSCODE:1346                 int     13h             ; DISK - SET MEDIA TYPE FOR FORMAT (AT model 3x9,XT2,XT286,PS)
BIOSCODE:1346                                         ; DL = drive number, CH = lower 8 bits of number of tracks,
BIOSCODE:1346                                         ; CL = sectors per track
BIOSCODE:1348                 jb      short FormaStatErr
BIOSCODE:134A                 cmp     ds:had_format_error, 1
BIOSCODE:134F                 jz      short skip_disk_base_setting
BIOSCODE:1351                 push    es
BIOSCODE:1352                 xor     si, si
BIOSCODE:1354                 mov     es, si
BIOSCODE:1356                 assume es:nothing
BIOSCODE:1356                 les     si, dword ptr es:78h ; [es:DSKADR] (Int 1Eh)
BIOSCODE:1356                                         ; Get current disk base table
BIOSCODE:135B                 assume es:nothing
BIOSCODE:135B                 mov     word ptr ds:tempdpt, si
BIOSCODE:135F                 mov     word ptr ds:tempdpt+2, es ; Save it
BIOSCODE:1363                 xor     si, si
BIOSCODE:1365                 mov     es, si          ; 0
BIOSCODE:1367                 assume es:nothing
BIOSCODE:1367                 mov     word ptr es:78h, di ; replace with one returned by rom
BIOSCODE:136C                 pop     word ptr es:78h+2
BIOSCODE:1371                 mov     ds:media_set_for_format, 1
BIOSCODE:1376
BIOSCODE:1376 skip_disk_base_setting:                 ; CODE XREF: SetMediaForFormat+54↑j
BIOSCODE:1376                 xor     al, al          ; Legal combination + rom support code
BIOSCODE:1378                 mov     ds:had_format_error, al ; Reset the flag
BIOSCODE:137B                 jmp     short PopStatRet
BIOSCODE:137D ; ---------------------------------------------------------------------------
BIOSCODE:137D
BIOSCODE:137D FormaStatErr:                           ; CODE XREF: SetMediaForFormat+4D↑j
BIOSCODE:137D                 cmp     ah, 0Ch         ; DSK_ILLEGAL_COMBINATION
BIOSCODE:137D                                         ; Illegal combination = 0Ch
BIOSCODE:1380                 jz      short FormatStatIllegalComb
BIOSCODE:1382                 cmp     ah, 80h         ; DSK_TIMEOUT_ERR
BIOSCODE:1385                 jz      short FormatStatTimeOut
BIOSCODE:1387                 mov     al, 1           ; Function not supported.
BIOSCODE:1389                 jmp     short PopStatRet
BIOSCODE:138B ; ---------------------------------------------------------------------------
BIOSCODE:138B
BIOSCODE:138B FormatStatIllegalComb:                  ; CODE XREF: SetMediaForFormat+85↑j
BIOSCODE:138B                 mov     al, 2           ; Function supported, but
BIOSCODE:138B                                         ; Illegal sect/trk,trk combination.
BIOSCODE:138D                 jmp     short PopStatRet
BIOSCODE:138F ; ---------------------------------------------------------------------------
BIOSCODE:138F
BIOSCODE:138F FormatStatTimeOut:                      ; CODE XREF: SetMediaForFormat+8A↑j
BIOSCODE:138F                 mov     al, 3           ; Function supported, but
BIOSCODE:138F                                         ; Media not present
BIOSCODE:1391
BIOSCODE:1391 PopStatRet:                             ; CODE XREF: SetMediaForFormat+80↑j
BIOSCODE:1391                                         ; SetMediaForFormat+8E↑j ...
BIOSCODE:1391                 pop     di
BIOSCODE:1392                 pop     si
BIOSCODE:1393                 pop     ds
BIOSCODE:1394                 pop     es
BIOSCODE:1395                 assume es:nothing
BIOSCODE:1395
BIOSCODE:1395 SetMediaRet:                            ; CODE XREF: SetMediaForFormat+12↑j
BIOSCODE:1395                 pop     dx
BIOSCODE:1396                 pop     cx
BIOSCODE:1397                 retn
BIOSCODE:1397 SetMediaForFormat endp
BIOSCODE:1397
BIOSCODE:1398
BIOSCODE:1398 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1398
BIOSCODE:1398
BIOSCODE:1398 ResetDisk       proc near               ; CODE XREF: diskio+120↑p
BIOSCODE:1398                                         ; Disk+E6↑p ...
BIOSCODE:1398                 push    ax
BIOSCODE:1399                 mov     ax, 1           ; Reset while formatting?
BIOSCODE:139C                 cmp     ds:media_set_for_format, al
BIOSCODE:13A0                 jnz     short ResetDisk_cont
BIOSCODE:13A2                 mov     ds:had_format_error, al ; Then verify operation in "fmt & vrfy"
BIOSCODE:13A2                                         ; Might have failed.
BIOSCODE:13A2                                         ; So signals that we had a format error.
BIOSCODE:13A5
BIOSCODE:13A5 ResetDisk_cont:                         ; CODE XREF: ResetDisk+8↑j
BIOSCODE:13A5                 int     13h             ; DISK - RESET DISK SYSTEM
BIOSCODE:13A5                                         ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
BIOSCODE:13A7                 mov     ds:step_drv, 0FFh ; -1
BIOSCODE:13A7                                         ; Zap up the speed
BIOSCODE:13AC                 pop     ax
BIOSCODE:13AD                 retn
BIOSCODE:13AD ResetDisk       endp
BIOSCODE:13AD
BIOSCODE:13AE
BIOSCODE:13AE ; =============== S U B R O U T I N E =======================================
BIOSCODE:13AE
BIOSCODE:13AE
BIOSCODE:13AE ToRom           proc near               ; CODE XREF: BIOSCODE:1132↑p
BIOSCODE:13AE                                         ; BIOSCODE:1147↑p
BIOSCODE:13AE                 push    bx
BIOSCODE:13AF                 push    si
BIOSCODE:13B0                 test    ds:media_set_for_format, 1
BIOSCODE:13B5                 jnz     short GotValidDpt
BIOSCODE:13B7                 push    ax
BIOSCODE:13B8                 push    es              ; Save bds segment
BIOSCODE:13B9                 cmp     byte ptr es:[di+3Eh], 2 ; [es:di+BDS.formfactor], ffSmall
BIOSCODE:13B9                                         ; is it a 3.5" drive?
BIOSCODE:13BE                 mov     es, ds:zeroseg  ; 0
BIOSCODE:13C2                 assume es:nothing
BIOSCODE:13C2                 les     si, dword ptr es:78h ; Get pointer to disk base table
BIOSCODE:13C7                 assume es:nothing
BIOSCODE:13C7                 mov     word ptr ds:dpt, si ; Save pointer to table
BIOSCODE:13CB                 mov     word ptr ds:dpt+2, es
BIOSCODE:13CF                 mov     al, ds:formt_eot
BIOSCODE:13D2                 mov     es:[si+4], al   ; [es:si+DISK_PARMS.DISK_EOT]
BIOSCODE:13D6                 mov     al, ds:gap_patch
BIOSCODE:13D9                 mov     es:[si+7], al   ; [es:si+DISK_PARMS.DISK_FORMT_GAP]
BIOSCODE:13D9                                         ; Important for format
BIOSCODE:13DD                 mov     byte ptr es:[si+9], 0Fh ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
BIOSCODE:13DD                                         ; Assume we are doing a seek operation
BIOSCODE:13DD                                         ; Setup motor start correctly for 3.5" drives
BIOSCODE:13E2                 jnz     short MotorStrtOK
BIOSCODE:13E4                 mov     byte ptr es:[si+0Ah], 4 ; [es:si+DISK_PARMS.DISK_MOTOR_STRT]
BIOSCODE:13E9
BIOSCODE:13E9 MotorStrtOK:                            ; CODE XREF: ToRom+34↑j
BIOSCODE:13E9                 pop     es              ; Restore bds segment
BIOSCODE:13EA                 pop     ax
BIOSCODE:13EB
BIOSCODE:13EB GotValidDpt:                            ; CODE XREF: ToRom+7↑j
BIOSCODE:13EB                 mov     dx, ds:trknum   ; Set track number
BIOSCODE:13EF                 mov     ch, dl          ; Set low 8 bits in ch
BIOSCODE:13F1                 mov     dl, es:[di+4]   ; Set drive number
BIOSCODE:13F5                 mov     dh, ds:hdnum    ; Set head number
BIOSCODE:13F9                 push    es              ; Save bds segment
BIOSCODE:13FA                 mov     es, ds:xfer_seg
BIOSCODE:13FE                 int     13h             ; DISK -
BIOSCODE:1400                 pop     es              ; Restore bds segment
BIOSCODE:1401                 pop     si
BIOSCODE:1402                 pop     bx
BIOSCODE:1403                 retn
BIOSCODE:1403 ToRom           endp
BIOSCODE:1403
BIOSCODE:1404
BIOSCODE:1404 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1404
BIOSCODE:1404
BIOSCODE:1404 ioctl_getown    proc near               ; DATA XREF: BIOSCODE:05A8↑o
BIOSCODE:1404                 call    SetDrive
BIOSCODE:1407                 mov     al, es:[di+4]   ; [es:di+BDS.drivenum]
BIOSCODE:1407                                         ; Get physical drive number
BIOSCODE:140B                 les     di, dword ptr ds:start_bds ; Get start of bds chain
BIOSCODE:140F
BIOSCODE:140F ownloop:                                ; CODE XREF: ioctl_getown+1C↓j
BIOSCODE:140F                 cmp     es:[di+4], al   ; [es:di+BDS.drivenum]
BIOSCODE:1413                 jnz     short getnextBDS
BIOSCODE:1415                 test    word ptr es:[di+3Fh], 20h ; [es:di+BDS.flags], fi_own_physical
BIOSCODE:141B                 jnz     short exitown
BIOSCODE:141D
BIOSCODE:141D getnextBDS:                             ; CODE XREF: ioctl_getown+F↑j
BIOSCODE:141D                 les     di, es:[di]     ; [es:di+BDS.link]
BIOSCODE:1420                 jmp     short ownloop
BIOSCODE:1422 ; ---------------------------------------------------------------------------
BIOSCODE:1422
BIOSCODE:1422 ioctl_setown:                           ; DATA XREF: BIOSCODE:05AA↑o
BIOSCODE:1422                 call    SetDrive
BIOSCODE:1425                 mov     ds:fsetowner, 1 ; set flag for CheckSingle to look at.
BIOSCODE:142A                 call    checksingle
BIOSCODE:142D                 dec     ds:fsetowner    ; 0 ; set ownership of drive reset flag
BIOSCODE:1431
BIOSCODE:1431 exitown:                                ; CODE XREF: ioctl_getown+17↑j
BIOSCODE:1431                 xor     cl, cl
BIOSCODE:1433                 test    word ptr es:[di+3Fh], 10h ; [es:di+BDS.flags], fi_am_mult
BIOSCODE:1439                 jz      short ExitNoMult
BIOSCODE:143B                 mov     cl, es:[di+5]   ; [es:di+BDS.drivelet]
BIOSCODE:143B                                         ; Get logical drive number
BIOSCODE:143F                 inc     cx              ; Get it 1-based
BIOSCODE:1440
BIOSCODE:1440 ExitNoMult:                             ; CODE XREF: ioctl_getown+35↑j
BIOSCODE:1440                 lds     bx, ds:ptrsav
BIOSCODE:1444                 mov     [bx+1], cl      ; [bx+unit]
BIOSCODE:1444                                         ; Exit normal termination
BIOSCODE:1447                 clc
BIOSCODE:1448                 retn
BIOSCODE:1448 ioctl_getown    endp
BIOSCODE:1448
BIOSCODE:1449
BIOSCODE:1449 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1449
BIOSCODE:1449
BIOSCODE:1449 RestoreOldDpt   proc near               ; CODE XREF: BIOSCODE:1054↑p
BIOSCODE:1449                 push    ax
BIOSCODE:144A                 xor     al, al
BIOSCODE:144C                 mov     ds:had_format_error, al ; Reset flag and
BIOSCODE:144F                 xchg    al, ds:media_set_for_format ; get current flag setting
BIOSCODE:1453                 or      al, al
BIOSCODE:1455                 jz      short DontRestore
BIOSCODE:1457                 push    si
BIOSCODE:1458                 push    ds
BIOSCODE:1459                 push    es
BIOSCODE:145A                 lds     si, ds:tempdpt
BIOSCODE:145E                 mov     es, cs:Bios_Data_Word
BIOSCODE:1463                 assume es:nothing
BIOSCODE:1463                 mov     es, es:zeroseg  ; es = 0
BIOSCODE:1468                 assume es:nothing
BIOSCODE:1468                 mov     word ptr es:78h, si ; [es:DSKADR] (Int 1Eh)
BIOSCODE:146D                 mov     word ptr es:78h+2, ds ; [es:DSKADR+2]
BIOSCODE:1472                 pop     es
BIOSCODE:1473                 assume es:nothing
BIOSCODE:1473                 pop     ds
BIOSCODE:1474                 pop     si
BIOSCODE:1475
BIOSCODE:1475 DontRestore:                            ; CODE XREF: RestoreOldDpt+C↑j
BIOSCODE:1475                 pop     ax
BIOSCODE:1476                 clc
BIOSCODE:1477                 retn
BIOSCODE:1477 RestoreOldDpt   endp
BIOSCODE:1477
BIOSCODE:1478
BIOSCODE:1478 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1478
BIOSCODE:1478
BIOSCODE:1478 GetMediaId      proc near               ; DATA XREF: BIOSCODE:0ED7↑o
BIOSCODE:1478                 call    ChangeLineChk   ; get volume serial number
BIOSCODE:147B                 mov     al, es:[di+5]   ; [es:di+BDS.drivelet] ; Logical drive number
BIOSCODE:147F                 mov     ds:rflag, 2     ; Read operation
BIOSCODE:1484                 call    BootIo          ; Read boot sector into DiskSector
BIOSCODE:1487                 jb      short IOCtl_If1
BIOSCODE:1489                 cmp     ds:disksector+15h, 0F0h ; Valid? (0F0h-0FFh?)
BIOSCODE:148E                 jb      short IOCtl_If2 ; brif not valid (0F0h - 0FFh)
BIOSCODE:1490                 mov     si, (offset disksector+43h) ; BS_FAT32_VolID
BIOSCODE:1493                 cmp     word ptr ds:disksector+16h, 0 ; BPB.FATSz16
BIOSCODE:1498                 jz      short IOCtl_If3 ; FAT32 fs
BIOSCODE:149A                 sub     si, 1Ch         ; FAT (12-16) fs ; 43h-1Ch = 27h ; BS_VolID
BIOSCODE:149D
BIOSCODE:149D IOCtl_If3:                              ; CODE XREF: GetMediaId+20↑j
BIOSCODE:149D                 cmp     byte ptr [si-1], 29h ; si-1 = offset disksector+26h (FAT)
BIOSCODE:149D                                         ;       or  = offset disksector+42h (FAT32)
BIOSCODE:149D                                         ;             disksector+EXT_BOOT.SIG
BIOSCODE:149D                                         ; BS_BootSig
BIOSCODE:14A1                 jnz     short IOCtl_If2
BIOSCODE:14A3                 les     di, ds:ptrsav
BIOSCODE:14A7                 les     di, es:[bx+19]  ; [es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:14AB                 add     di, 2           ; A_MEDIA_ID_INFO.MI_SERIAL
BIOSCODE:14AE
BIOSCODE:14AE IOCtl_If4:                              ; CODE XREF: BIOSCODE:14FA↓p
BIOSCODE:14AE                 mov     cx, 23          ; size_of_EXT_BOOT_SERIAL
BIOSCODE:14AE                                         ; + size_of_EXT_BOOT_VOL_LABEL
BIOSCODE:14AE                                         ; + size_of_EXT_SYSTEM_ID
BIOSCODE:14B1                 rep movsb
BIOSCODE:14B3                 clc
BIOSCODE:14B4                 retn
BIOSCODE:14B5 ; ---------------------------------------------------------------------------
BIOSCODE:14B5
BIOSCODE:14B5 IOCtl_If2:                              ; CODE XREF: GetMediaId+16↑j
BIOSCODE:14B5                                         ; GetMediaId+29↑j
BIOSCODE:14B5                 mov     al, 7
BIOSCODE:14B7                 stc
BIOSCODE:14B8
BIOSCODE:14B8 IOCtl_If1:                              ; CODE XREF: GetMediaId+F↑j
BIOSCODE:14B8                 retn
BIOSCODE:14B8 GetMediaId      endp
BIOSCODE:14B8
BIOSCODE:14B9 ; ---------------------------------------------------------------------------
BIOSCODE:14B9
BIOSCODE:14B9 SetMediaId:                             ; DATA XREF: BIOSCODE:0EF8↑o
BIOSCODE:14B9                 call    ChangeLineChk
BIOSCODE:14BC                 mov     al, es:[di+5]   ; [es:di+BDS.drivelet]
BIOSCODE:14BC                                         ; Logical drive number
BIOSCODE:14C0                 mov     dl, al
BIOSCODE:14C2                 mov     ds:rflag, 2     ; romread
BIOSCODE:14C7                 push    dx
BIOSCODE:14C8                 call    BootIo          ; Read boot sector to BIOSDATA:DiskSector
BIOSCODE:14CB                 pop     dx
BIOSCODE:14CC                 jb      short IOCtl_If6
BIOSCODE:14CE                 cmp     ds:disksector+15h, 0F0h ; Valid? (0F0h-0FFh?)
BIOSCODE:14CE                                         ; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
BIOSCODE:14D3                 jb      short IOCtl_If7 ; Brif not
BIOSCODE:14D5                 push    es
BIOSCODE:14D6                 push    di
BIOSCODE:14D7                 push    ds
BIOSCODE:14D8                 pop     es
BIOSCODE:14D9                 mov     di, (offset disksector+43h) ; disksector+EXT_BOOT.SERIAL
BIOSCODE:14DC                 cmp     word ptr ds:disksector+16h, 0 ; BPB.FATSz16
BIOSCODE:14E1                 jz      short IOCtl_If5 ; FAT32 fs
BIOSCODE:14E3                 sub     di, 1Ch         ; 67-28 ; offset disksektor+27h
BIOSCODE:14E6
BIOSCODE:14E6 IOCtl_If5:                              ; CODE XREF: BIOSCODE:14E1↑j
BIOSCODE:14E6                 cmp     byte ptr [di-1], 29h ; [disksector+EXT_BOOT.SIG], EXT_BOOT_SIGNATURE
BIOSCODE:14EA                 jz      short IOCtl_If8
BIOSCODE:14EC                 pop     di              ; not extended boot record
BIOSCODE:14ED                 pop     es
BIOSCODE:14EE                 jmp     short IOCtl_If7
BIOSCODE:14F0 ; ---------------------------------------------------------------------------
BIOSCODE:14F0
BIOSCODE:14F0 IOCtl_If8:                              ; CODE XREF: BIOSCODE:14EA↑j
BIOSCODE:14F0                 lds     si, ds:ptrsav
BIOSCODE:14F4                 lds     si, [si+13h]    ; [si+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:14F7                 add     si, 2           ; A_MEDIA_ID_INFO.MI_SERIAL
BIOSCODE:14FA                 call    IOCtl_If4       ; copy volume serial, label and system id
BIOSCODE:14FD                 push    es              ; point ds back to BIOSDATA
BIOSCODE:14FE                 pop     ds
BIOSCODE:14FF                 pop     di              ; restore bds pointer
BIOSCODE:1500                 pop     es
BIOSCODE:1501                 call    mov_media_ids   ; update the bds media id info.
BIOSCODE:1504                 mov     al, dl
BIOSCODE:1506                 mov     ds:rflag, 3     ; romwrite
BIOSCODE:150B                 call    BootIo          ; write it back
BIOSCODE:150E                 mov     ds:tim_drv, 0FFh ; make sure chk_media check the driver
BIOSCODE:150E                                         ; return with error code from BootIo
BIOSCODE:1513                 retn
BIOSCODE:1514 ; ---------------------------------------------------------------------------
BIOSCODE:1514
BIOSCODE:1514 IOCtl_If7:                              ; CODE XREF: BIOSCODE:14D3↑j
BIOSCODE:1514                                         ; BIOSCODE:14EE↑j
BIOSCODE:1514                 mov     al, 7           ; error_unknown_media
BIOSCODE:1516                 stc
BIOSCODE:1517
BIOSCODE:1517 IOCtl_If6:                              ; CODE XREF: BIOSCODE:14CC↑j
BIOSCODE:1517                 retn
BIOSCODE:1518
BIOSCODE:1518 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1518
BIOSCODE:1518
BIOSCODE:1518 BootIo          proc near               ; CODE XREF: GetMediaId+C↑p
BIOSCODE:1518                                         ; BIOSCODE:14C8↑p ...
BIOSCODE:1518                 push    es
BIOSCODE:1519                 push    di
BIOSCODE:151A                 push    bx
BIOSCODE:151B                 push    ds
BIOSCODE:151C                 pop     es
BIOSCODE:151D                 mov     di, offset disksector ; es:di -> transfer address
BIOSCODE:1520                 xor     dx, dx          ; First sector (h) -> 0
BIOSCODE:1522                 mov     ds:start_sec_h, dx ; Start sector (h) -> 0
BIOSCODE:1526                 mov     cx, 1
BIOSCODE:1529                 call    diskio
BIOSCODE:152C                 pop     bx
BIOSCODE:152D                 pop     di
BIOSCODE:152E                 pop     es
BIOSCODE:152F                 retn
BIOSCODE:152F BootIo          endp
BIOSCODE:152F
BIOSCODE:1530
BIOSCODE:1530 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1530
BIOSCODE:1530
BIOSCODE:1530 ChangeLineChk   proc near               ; CODE XREF: GetMediaId↑p
BIOSCODE:1530                                         ; BIOSCODE:SetMediaId↑p
BIOSCODE:1530                 mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
BIOSCODE:1534                 or      dl, dl          ; Fixed disk?
BIOSCODE:1536                 js      short ChangeLnChkRet
BIOSCODE:1538                 test    word ptr es:[di+3Fh], 4 ; [es:di+BDS.flags], return_fake_bpb
BIOSCODE:153E                 jnz     short ChangeLnChkRet
BIOSCODE:1540                 cmp     ds:fhave96, 1   ; This rom support change line?
BIOSCODE:1545                 jnz     short ChangeLnChkRet ; no
BIOSCODE:1547                 call    haschange
BIOSCODE:154A                 jz      short ChangeLnChkRet ; Do nothing
BIOSCODE:154C                 mov     ah, 16h
BIOSCODE:154E                 int     13h             ; DISK - FLOPPY DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
BIOSCODE:154E                                         ; DL = drive to check
BIOSCODE:154E                                         ; Return: AH = disk change status
BIOSCODE:1550                 jnb     short ChangeLnChkRet
BIOSCODE:1552                 push    bx
BIOSCODE:1553                 mov     bx, 40h         ; fchanged
BIOSCODE:1553                                         ; Update flag in BDS for this physical drive
BIOSCODE:1556                 call    set_changed_dl
BIOSCODE:1559                 pop     bx
BIOSCODE:155A
BIOSCODE:155A ChangeLnChkRet:                         ; CODE XREF: ChangeLineChk+6↑j
BIOSCODE:155A                                         ; ChangeLineChk+E↑j ...
BIOSCODE:155A                 retn
BIOSCODE:155A ChangeLineChk   endp
BIOSCODE:155A
BIOSCODE:155B
BIOSCODE:155B ; =============== S U B R O U T I N E =======================================
BIOSCODE:155B
BIOSCODE:155B
BIOSCODE:155B GetAccessFlag   proc near               ; DATA XREF: BIOSCODE:0ED9↑o
BIOSCODE:155B                 lds     bx, ds:ptrsav   ; ds:bx points to request header
BIOSCODE:155F                 lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:1562                 mov     al, 0           ; Assume result is unformatted
BIOSCODE:1564                 test    word ptr es:[di+3Fh], 200h ; [es:di+BDS.flags], unformatted_media
BIOSCODE:156A                 jnz     short GafDone   ; Done if unformatted
BIOSCODE:156C                 inc     ax              ; Return true for formatted
BIOSCODE:156D
BIOSCODE:156D GafDone:                                ; CODE XREF: GetAccessFlag+F↑j
BIOSCODE:156D                 mov     [bx+1], al      ; [bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]
BIOSCODE:1570                 retn
BIOSCODE:1570 GetAccessFlag   endp
BIOSCODE:1570
BIOSCODE:1571
BIOSCODE:1571 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1571
BIOSCODE:1571
BIOSCODE:1571 SetAccessFlag   proc near               ; DATA XREF: BIOSCODE:0EFA↑o
BIOSCODE:1571                 lds     bx, ds:ptrsav   ; ds:bx points to request header
BIOSCODE:1575                 lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:1578                 and     word ptr es:[di+3Fh], 0FDFFh ; [es:di+BDS.flags], ~unformatted_media
BIOSCODE:157E                 cmp     byte ptr [bx+1], 0 ; [bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]
BIOSCODE:1582                 jnz     short saf_Done
BIOSCODE:1584                 or      word ptr es:[di+3Fh], 200h ; [es:di+BDS.flags], unformatted_media
BIOSCODE:158A
BIOSCODE:158A saf_Done:                               ; CODE XREF: SetAccessFlag+11↑j
BIOSCODE:158A                 retn
BIOSCODE:158A SetAccessFlag   endp
BIOSCODE:158A
BIOSCODE:158B
BIOSCODE:158B ; =============== S U B R O U T I N E =======================================
BIOSCODE:158B
BIOSCODE:158B
BIOSCODE:158B ioctl_support_query proc near           ; DATA XREF: BIOSCODE:05AC↑o
BIOSCODE:158B                 push    es
BIOSCODE:158C                 les     bx, ds:ptrsav   ; es:bx points to request header.
BIOSCODE:1590                 mov     ax, es:[bx+0Dh] ; [es:bx+IOCTL_REQ.MAJORFUNCTION]
BIOSCODE:1590                                         ; al == Major, ah == Minor
BIOSCODE:1594                 cmp     al, 48h         ; IOC_NEW_DC
BIOSCODE:1594                                         ; new generic ioctl function (FAT32)
BIOSCODE:1596                 jz      short ioctl_support
BIOSCODE:1598                 cmp     al, 8           ; IOC_DC
BIOSCODE:1598                                         ; (old) generic ioctl function (FAT12-FAT16)
BIOSCODE:159A                 jnz     short nosupport
BIOSCODE:159C
BIOSCODE:159C ioctl_support:                          ; CODE XREF: ioctl_support_query+B↑j
BIOSCODE:159C                 push    cs
BIOSCODE:159D                 pop     es
BIOSCODE:159E                 assume es:BIOSCODE
BIOSCODE:159E                 mov     cx, 14          ; IOC_DC_TABLE_LEN
BIOSCODE:15A1                 mov     di, offset IOC_DC_Table
BIOSCODE:15A4                 xchg    al, ah
BIOSCODE:15A6                 repne scasb
BIOSCODE:15A8                 jnz     short nosupport
BIOSCODE:15AA                 mov     ax, 100h
BIOSCODE:15AD                 pop     es
BIOSCODE:15AE                 assume es:nothing
BIOSCODE:15AE                 clc
BIOSCODE:15AF                 retn
BIOSCODE:15B0 ; ---------------------------------------------------------------------------
BIOSCODE:15B0
BIOSCODE:15B0 nosupport:                              ; CODE XREF: ioctl_support_query+F↑j
BIOSCODE:15B0                                         ; ioctl_support_query+1D↑j
BIOSCODE:15B0                 pop     es
BIOSCODE:15B1                 jmp     bc_cmderr
BIOSCODE:15B1 ioctl_support_query endp
BIOSCODE:15B1
BIOSCODE:15B4 ; ---------------------------------------------------------------------------
BIOSCODE:15B4
BIOSCODE:15B4 SenseMediaType:                         ; DATA XREF: BIOSCODE:0EDB↑o
BIOSCODE:15B4                 lds     bx, ds:ptrsav   ; ds:bx points to request header.
BIOSCODE:15B8                 lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:15BB                 xor     dx, dx          ; 0 ; Initialize the 2 packet bytes
BIOSCODE:15BD                 mov     [bx], dx        ; invalidate drive type (byte 1)
BIOSCODE:15BD                                         ; and default type flag (byte 0)
BIOSCODE:15BF                 mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
BIOSCODE:15C3                 mov     ah, 20h
BIOSCODE:15C5                 int     13h             ; Compaq, ATAPI Removable Media Device
BIOSCODE:15C5                                         ; GET CURRENT MEDIA FORMAT
BIOSCODE:15C5                                         ;   AH = 20h
BIOSCODE:15C5                                         ;   DL = drive number (00h,01h)
BIOSCODE:15C5                                         ; Return: CF clear if successful
BIOSCODE:15C5                                         ;   AL = media type
BIOSCODE:15C5                                         ;   AH = 00h
BIOSCODE:15C5                                         ;   CF set on error
BIOSCODE:15C5                                         ;      AH = error code
BIOSCODE:15C5                                         ;
BIOSCODE:15C5                                         ; (Ref: Ralf Brown's Interrupt List, INTERRUP.B)
BIOSCODE:15C7                 jb      short MediaSenseErr
BIOSCODE:15C9                 inc     byte ptr [bx]   ; [bx+A_MEDIA_SENSE.MS_ISDEFAULT]
BIOSCODE:15C9                                         ; 1 = default media type
BIOSCODE:15CB
BIOSCODE:15CB DetermineMediaType:                     ; CODE XREF: BIOSCODE:15E3↓j
BIOSCODE:15CB                 dec     al              ; 3 -> 2, 4 -> 3, 6 -> 5
BIOSCODE:15CD                 cmp     al, 2           ; 3.5 inch, 720 KB
BIOSCODE:15CF                 jz      short GotMediaType
BIOSCODE:15D1                 add     al, 4           ; 3 -> 6, 4 -> 7, 6 -> 9
BIOSCODE:15D3                 cmp     al, 7           ; 3.5 inch, 1.44 MB
BIOSCODE:15D5                 jz      short GotMediaType
BIOSCODE:15D7                 cmp     al, 9           ; 3.5 inch, 2.88 MB
BIOSCODE:15D9                 jnz     short UnknownMediaType ; Just didn't recognize media type
BIOSCODE:15DB
BIOSCODE:15DB GotMediaType:                           ; CODE XREF: BIOSCODE:15CF↑j
BIOSCODE:15DB                                         ; BIOSCODE:15D5↑j
BIOSCODE:15DB                 mov     [bx+1], al      ; [bx+A_MEDIA_SENSE.MS_DEVICETYPE]
BIOSCODE:15DE                 clc
BIOSCODE:15DF                 retn
BIOSCODE:15E0 ; ---------------------------------------------------------------------------
BIOSCODE:15E0
BIOSCODE:15E0 MediaSenseErr:                          ; CODE XREF: BIOSCODE:15C7↑j
BIOSCODE:15E0                 cmp     ah, 32h         ; non-default media /
BIOSCODE:15E0                                         ; drive does not support media type
BIOSCODE:15E3                 jz      short DetermineMediaType
BIOSCODE:15E5                 mov     al, 2           ; function supported but, drive not ready
BIOSCODE:15E7                 cmp     ah, 31h         ; no such drive / media not present
BIOSCODE:15EA                 jz      short SenseErrExit
BIOSCODE:15EC
BIOSCODE:15EC UnknownMediaType:                       ; CODE XREF: BIOSCODE:15D9↑j
BIOSCODE:15EC                 mov     al, 7           ; error_unknown_media
BIOSCODE:15EE
BIOSCODE:15EE SenseErrExit:                           ; CODE XREF: BIOSCODE:15EA↑j
BIOSCODE:15EE                 mov     ah, 81h         ; Return this status in case of carry
BIOSCODE:15F0                 stc
BIOSCODE:15F1                 retn
BIOSCODE:15F2
BIOSCODE:15F2 ; =============== S U B R O U T I N E =======================================
BIOSCODE:15F2
BIOSCODE:15F2
BIOSCODE:15F2 SetLockState    proc near               ; DATA XREF: BIOSCODE:0EFC↑o
BIOSCODE:15F2                 lds     bx, ds:ptrsav   ; set media lock state
BIOSCODE:15F6                 lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:15F9                 mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
BIOSCODE:15FD                 call    check_int13h_exts_present
BIOSCODE:1600                 mov     al, 3           ; unknown command error
BIOSCODE:1602                 jb      short setlockst_ret
BIOSCODE:1604                 mov     al, [bx]        ; [bx+A_LOCKSTATE_CONTROL.LOCKSTATE_FUNCTIONS]
BIOSCODE:1606                 mov     ah, 45h
BIOSCODE:1608                 int     13h             ; DISK - IBM/MS Extension - LOCK/UNLOCK DRIVE
BIOSCODE:1608                                         ; (DL - drive, DS:SI - disk address packet)
BIOSCODE:160A                 mov     [bx+1], al      ; 1 = locked, 0 = not locked
BIOSCODE:160A                                         ; [bx+A_LOCKSTATE_CONTROL.LOCKSTATE_FLAG]
BIOSCODE:160D                 jnb     short setlockst_ret
BIOSCODE:160F                 mov     al, ah
BIOSCODE:1611                 call    maperror
BIOSCODE:1614
BIOSCODE:1614 setlockst_ret:                          ; CODE XREF: SetLockState+10↑j
BIOSCODE:1614                                         ; SetLockState+1B↑j
BIOSCODE:1614                 mov     ah, 81h         ; Return this status in case of carry
BIOSCODE:1616                 retn
BIOSCODE:1616 SetLockState    endp
BIOSCODE:1616
BIOSCODE:1617
BIOSCODE:1617 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1617
BIOSCODE:1617
BIOSCODE:1617 EjectMedia      proc near               ; DATA XREF: BIOSCODE:0EFE↑o
BIOSCODE:1617                 mov     dl, es:[di+4]   ; eject media in drive
BIOSCODE:1617                                         ; [es:di+BDS.drivenum]
BIOSCODE:161B                 call    check_int13h_exts_present
BIOSCODE:161E                 mov     al, 3           ; unknown command error
BIOSCODE:1620                 jb      short ejectm_ret
BIOSCODE:1622                 mov     ax, 4600h
BIOSCODE:1625                 int     13h             ; DISK - IBM/MS Extension - EJECT MEDIA
BIOSCODE:1625                                         ; (DL - drive)
BIOSCODE:1627                 jnb     short ejectm_ret
BIOSCODE:1629                 mov     al, ah
BIOSCODE:162B                 call    maperror
BIOSCODE:162E
BIOSCODE:162E ejectm_ret:                             ; CODE XREF: EjectMedia+9↑j
BIOSCODE:162E                                         ; EjectMedia+10↑j
BIOSCODE:162E                 mov     ah, 81h         ; Return this status in case of carry
BIOSCODE:1630                 retn
BIOSCODE:1630 EjectMedia      endp
BIOSCODE:1630
BIOSCODE:1631
BIOSCODE:1631 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1631
BIOSCODE:1631
BIOSCODE:1631 check_int13h_exts_present proc near     ; CODE XREF: SetLockState+B↑p
BIOSCODE:1631                                         ; EjectMedia+4↑p
BIOSCODE:1631                 mov     ah, 41h
BIOSCODE:1633                 push    bx
BIOSCODE:1634                 mov     bx, 55AAh
BIOSCODE:1637                 int     13h             ; DISK - Check for INT 13h Extensions
BIOSCODE:1637                                         ; BX = 55AAh, DL = drive number
BIOSCODE:1637                                         ; Return: CF set if not supported
BIOSCODE:1637                                         ; AH = extensions version
BIOSCODE:1637                                         ; BX = AA55h
BIOSCODE:1637                                         ; CX = Interface support bit map
BIOSCODE:1639                 cmp     bx, 0AA55h
BIOSCODE:163D                 pop     bx
BIOSCODE:163E                 jnz     short exts_notsupported
BIOSCODE:1640                 test    cl, 2           ; bit 1 - drive locking and ejecting subset
BIOSCODE:1643                 jnz     short exts_supported
BIOSCODE:1645
BIOSCODE:1645 exts_notsupported:                      ; CODE XREF: check_int13h_exts_present+D↑j
BIOSCODE:1645                 stc
BIOSCODE:1646
BIOSCODE:1646 exts_supported:                         ; CODE XREF: check_int13h_exts_present+12↑j
BIOSCODE:1646                 retn
BIOSCODE:1646 check_int13h_exts_present endp
BIOSCODE:1646
BIOSCODE:1647 ; ---------------------------------------------------------------------------
BIOSCODE:1647
BIOSCODE:1647 GetDrvMapInfo:                          ; DATA XREF: BIOSCODE:0EE9↑o
BIOSCODE:1647                 mov     cx, ds          ; get drive map information
BIOSCODE:1647                                         ;
BIOSCODE:1647                                         ; es:di points to BDS which belongs to
BIOSCODE:1647                                         ;       the requested logical/dos drive number
BIOSCODE:1647                                         ;
BIOSCODE:1647                                         ; Format of parameter block:
BIOSCODE:1647                                         ; Offset  Description (Table 01570)
BIOSCODE:1647                                         ;  00h    (call) length of this buffer (in bytes)
BIOSCODE:1647                                         ;  01h    (ret) number of bytes in parameter block
BIOSCODE:1647                                         ;         actually used
BIOSCODE:1647                                         ;  02h    (ret) drive flags
BIOSCODE:1647                                         ;  03h    (ret) physical drive number
BIOSCODE:1647                                         ;         00h-7Fh floppy
BIOSCODE:1647                                         ;         80h-FEh hard
BIOSCODE:1647                                         ;         FFh no physical drive
BIOSCODE:1647                                         ;  04h    (ret) bitmap of logical drives associated with
BIOSCODE:1647                                         ;         physical drive
BIOSCODE:1647                                         ;         bit 0 = drive A:, etc.
BIOSCODE:1647                                         ;  08h    (ret) relative block address of partition start
BIOSCODE:1647                                         ;         qword
BIOSCODE:1647                                         ;
BIOSCODE:1647                                         ; Ref: Ralf Brown's Interrupt List, INTERRUP.G
BIOSCODE:1649                 lds     bx, ds:ptrsav
BIOSCODE:164D                 lds     bx, [bx+13h]    ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
BIOSCODE:1650                 mov     ax, 8103h       ; ah = generic ioctl error code (81h)
BIOSCODE:1650                                         ; al = unknown command error (03h)
BIOSCODE:1653                 cmp     byte ptr [bx], 10h ; parameter buffer length = 16 bytes
BIOSCODE:1656                 jb      short gdmi_4
BIOSCODE:1658                 mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
BIOSCODE:165C                 mov     [bx+3], dl      ; parameter block - offset 3 - physical drive number
BIOSCODE:165F                 mov     byte ptr [bx+1], 10h ; parameter block - actually used length
BIOSCODE:1663                 mov     ax, es:[di+17h] ; [es:di+BDS.hiddensectors]
BIOSCODE:1667                 mov     [bx+8], ax      ; parameter block - offset 8 - partition start LBA
BIOSCODE:166A                 mov     ax, es:[di+19h] ; [es:di+BDS.hiddensectors+2]
BIOSCODE:166E                 mov     [bx+0Ah], ax    ; parameter block - offset 10
BIOSCODE:1671                 xor     ax, ax
BIOSCODE:1673                 mov     [bx+2], al      ; drive flags = 0 (protected mode flags etc.)
BIOSCODE:1676                 mov     [bx+0Ch], ax    ; high dword of partition start address (LBA) is 0
BIOSCODE:1679                 mov     [bx+0Eh], ax
BIOSCODE:167C                 mov     [bx+4], ax      ; logical drive bitmap of same physical drive
BIOSCODE:167C                                         ; initialized as 0
BIOSCODE:167F                 mov     [bx+6], ax
BIOSCODE:1682                 mov     es, cx
BIOSCODE:1684                 les     di, dword ptr es:start_bds ; 1st BDS
BIOSCODE:1689                 mov     cx, 1           ; bit 0 (drive A:)
BIOSCODE:168C
BIOSCODE:168C gdmi_1:                                 ; CODE XREF: BIOSCODE:16A4↓j
BIOSCODE:168C                 cmp     di, 0FFFFh      ; last BDS ?
BIOSCODE:168F                 jz      short gdmi_3    ; yes
BIOSCODE:1691                 cmp     es:[di+4], dl   ; [es:di+BDS.drivenum], dl
BIOSCODE:1691                                         ; is it same physical drive ?
BIOSCODE:1695                 jnz     short gdmi_2    ; no
BIOSCODE:1697                 or      [bx+4], cx      ; set bit for logical drive index of this BDS
BIOSCODE:1697                                         ; (previously) shifted bit (which is 1/ON) is in ax:cx
BIOSCODE:169A                 or      [bx+6], ax
BIOSCODE:169D
BIOSCODE:169D gdmi_2:                                 ; CODE XREF: BIOSCODE:1695↑j
BIOSCODE:169D                 shl     cx, 1           ; shift one left for setting the next drive's bit
BIOSCODE:169F                 rcl     ax, 1           ; set high word of the bit select (set) value
BIOSCODE:16A1                 les     di, es:[di]     ; next BDS
BIOSCODE:16A4                 jmp     short gdmi_1    ; loop until di = -1 (last BDS sign)
BIOSCODE:16A6 ; ---------------------------------------------------------------------------
BIOSCODE:16A6
BIOSCODE:16A6 gdmi_3:                                 ; CODE XREF: BIOSCODE:168F↑j
BIOSCODE:16A6                 mov     ax, 100h        ; success
BIOSCODE:16A9
BIOSCODE:16A9 gdmi_4:                                 ; CODE XREF: BIOSCODE:1656↑j
BIOSCODE:16A9                 retn
BIOSCODE:16AA ; ---------------------------------------------------------------------------
BIOSCODE:16AA
BIOSCODE:16AA i2f_handler:                            ; DATA XREF: BIOSDATA:0006↑o
BIOSCODE:16AA                 cmp     ah, 13h
BIOSCODE:16AD                 jz      short int2f_replace_int13
BIOSCODE:16AF                 cmp     ah, 8
BIOSCODE:16B2                 jz      short mine
BIOSCODE:16B4                 cmp     ah, 16h         ; MultWin386
BIOSCODE:16B7                 jz      short win386call
BIOSCODE:16B9                 cmp     ah, 4Ah         ; multMULT
BIOSCODE:16BC                 jnz     short i2f_handler_iret
BIOSCODE:16BE                 jmp     handle_multmult
BIOSCODE:16C1 ; ---------------------------------------------------------------------------
BIOSCODE:16C1
BIOSCODE:16C1 i2f_handler_iret:                       ; CODE XREF: BIOSCODE:16BC↑j
BIOSCODE:16C1                 iret
BIOSCODE:16C2 ; ---------------------------------------------------------------------------
BIOSCODE:16C2
BIOSCODE:16C2 int2f_replace_int13:                    ; CODE XREF: BIOSCODE:16AD↑j
BIOSCODE:16C2                 cli
BIOSCODE:16C3                 push    ax
BIOSCODE:16C4                 mov     ax, ds
BIOSCODE:16C6                 mov     ds, cs:Bios_Data_Word
BIOSCODE:16CB                 assume ds:nothing
BIOSCODE:16CB                 push    word ptr ds:Orig13+2
BIOSCODE:16CF                 push    word ptr ds:Old13+2
BIOSCODE:16D3                 xchg    dx, word ptr ds:Orig13
BIOSCODE:16D7                 mov     word ptr ds:Orig13+2, ax
BIOSCODE:16DA                 xchg    bx, word ptr ds:Old13
BIOSCODE:16DE                 mov     word ptr ds:Old13+2, es
BIOSCODE:16E2                 pop     es
BIOSCODE:16E3                 pop     ds
BIOSCODE:16E4                 assume ds:nothing
BIOSCODE:16E4                 pop     ax
BIOSCODE:16E5
BIOSCODE:16E5 i2f_iret:                               ; CODE XREF: BIOSCODE:16E8↓j
BIOSCODE:16E5                 iret
BIOSCODE:16E6 ; ---------------------------------------------------------------------------
BIOSCODE:16E6
BIOSCODE:16E6 mine:                                   ; CODE XREF: BIOSCODE:16B2↑j
BIOSCODE:16E6                 cmp     al, 0F8h        ; iret on reserved functions
BIOSCODE:16E8                 jnb     short i2f_iret
BIOSCODE:16EA                 or      al, al          ; a get installed state request?
BIOSCODE:16EC                 jnz     short disp_func
BIOSCODE:16EE                 mov     al, 0FFh
BIOSCODE:16F0                 iret
BIOSCODE:16F1 ; ---------------------------------------------------------------------------
BIOSCODE:16F1
BIOSCODE:16F1 disp_func:                              ; CODE XREF: BIOSCODE:16EC↑j
BIOSCODE:16F1                 cmp     al, 1           ; request for installing bds?
BIOSCODE:16F3                 jz      short do_subfun_01
BIOSCODE:16F5                 cmp     al, 3           ; get bds vector?
BIOSCODE:16F7                 jz      short do_get_bds_vector
BIOSCODE:16F9                 push    ds
BIOSCODE:16FA                 mov     ds, cs:Bios_Data_Word
BIOSCODE:16FF                 assume ds:nothing
BIOSCODE:16FF                 mov     word ptr ds:ptrsav, bx
BIOSCODE:1703                 mov     word ptr ds:ptrsav+2, es
BIOSCODE:1707                 pop     ds
BIOSCODE:1708                 assume ds:nothing
BIOSCODE:1708                 jmp     far ptr 70h:65Eh ; BIOSDATA:dsk_entry
BIOSCODE:1708                                         ;
BIOSCODE:1708                                         ; NOTE: jump to a FAR function, not an
BIOSCODE:1708                                         ; IRET type function. Callers of
BIOSCODE:1708                                         ; this int2f subfunction will have
BIOSCODE:1708                                         ; to be careful to do a popf
BIOSCODE:170D ; ---------------------------------------------------------------------------
BIOSCODE:170D
BIOSCODE:170D do_subfun_01:                           ; CODE XREF: BIOSCODE:16F3↑j
BIOSCODE:170D                 push    es
BIOSCODE:170E                 push    ds
BIOSCODE:170F                 push    ds
BIOSCODE:1710                 pop     es
BIOSCODE:1711                 mov     ds, cs:Bios_Data_Word ; BIOSDATA segment
BIOSCODE:1716                 assume ds:nothing
BIOSCODE:1716                 call    install_bds
BIOSCODE:1719                 pop     ds
BIOSCODE:171A                 assume ds:nothing
BIOSCODE:171A                 pop     es
BIOSCODE:171B                 iret
BIOSCODE:171C ; ---------------------------------------------------------------------------
BIOSCODE:171C
BIOSCODE:171C do_get_bds_vector:                      ; CODE XREF: BIOSCODE:16F7↑j
BIOSCODE:171C                 mov     ds, cs:Bios_Data_Word
BIOSCODE:1721                 assume ds:nothing
BIOSCODE:1721                 lds     di, dword ptr ds:start_bds
BIOSCODE:1725                 assume ds:nothing
BIOSCODE:1725                 iret
BIOSCODE:1726 ; ---------------------------------------------------------------------------
BIOSCODE:1726
BIOSCODE:1726 win386call:                             ; CODE XREF: BIOSCODE:16B7↑j
BIOSCODE:1726                 push    ds
BIOSCODE:1727                 mov     ds, cs:Bios_Data_Word ; BIOSDATA segment
BIOSCODE:172C                 assume ds:nothing
BIOSCODE:172C                 cmp     al, 5           ; Win386_Init
BIOSCODE:172C                                         ; is it win386 initializing?
BIOSCODE:172E                 jz      short Win386Init
BIOSCODE:1730                 cmp     al, 6           ; Win386_Exit
BIOSCODE:1730                                         ; is it win386 exiting?
BIOSCODE:1732                 jnz     short win_iret
BIOSCODE:1734                 test    dx, 1           ; is it win386 or win286 dos extender?
BIOSCODE:1738                 jnz     short win_iret  ; if not win386, then continue
BIOSCODE:173A                 and     ds:IsWin386, 0  ; indicate that win386 is not present
BIOSCODE:173F                 jmp     short win_iret
BIOSCODE:1741 ; ---------------------------------------------------------------------------
BIOSCODE:1741
BIOSCODE:1741 Win386Init:                             ; CODE XREF: BIOSCODE:172E↑j
BIOSCODE:1741                 test    dx, 1           ; is it win386 or win286 dos extender?
BIOSCODE:1745                 jnz     short win_iret  ; if not win386, then continue
BIOSCODE:1747                 or      ds:IsWin386, 1
BIOSCODE:174C                 mov     word ptr ds:SI_Next, bx
BIOSCODE:1750                 mov     word ptr ds:SI_Next+2, es ; Hook our structure into chain
BIOSCODE:1754                 mov     bx, offset Win386_SI ; point es:bx to Win386_SI
BIOSCODE:1757                 push    ds
BIOSCODE:1758                 pop     es
BIOSCODE:1759                 assume es:nothing
BIOSCODE:1759
BIOSCODE:1759 win_iret:                               ; CODE XREF: BIOSCODE:1732↑j
BIOSCODE:1759                                         ; BIOSCODE:1738↑j ...
BIOSCODE:1759                 pop     ds
BIOSCODE:175A                 assume ds:nothing
BIOSCODE:175A                 iret                    ; return back up the chain
BIOSCODE:175B ; ---------------------------------------------------------------------------
BIOSCODE:175B
BIOSCODE:175B handle_multmult:                        ; CODE XREF: BIOSCODE:16BE↑j
BIOSCODE:175B                 cmp     al, 1
BIOSCODE:175D                 jnz     short try_2
BIOSCODE:175F                 push    ds
BIOSCODE:1760                 call    HMAptr          ; get offset of free HMA
BIOSCODE:1763                 mov     bx, 0FFFFh
BIOSCODE:1766                 mov     es, bx          ; seg of HMA
BIOSCODE:1768                 assume es:nothing
BIOSCODE:1768                 mov     bx, di
BIOSCODE:176A                 not     bx
BIOSCODE:176C                 or      bx, bx
BIOSCODE:176E                 jz      short try_1
BIOSCODE:1770                 inc     bx
BIOSCODE:1771
BIOSCODE:1771 try_1:                                  ; CODE XREF: BIOSCODE:176E↑j
BIOSCODE:1771                 pop     ds
BIOSCODE:1772                 iret
BIOSCODE:1773 ; ---------------------------------------------------------------------------
BIOSCODE:1773
BIOSCODE:1773 try_2:                                  ; CODE XREF: BIOSCODE:175D↑j
BIOSCODE:1773                 cmp     al, 2           ; multMULTALLOCHMA
BIOSCODE:1775                 jnz     short try_3
BIOSCODE:1777                 push    ds
BIOSCODE:1778                 mov     di, 0FFFFh      ; assume not enough space
BIOSCODE:177B                 mov     es, di
BIOSCODE:177D                 call    HMAptr          ; get offset of free HMA
BIOSCODE:1780                 cmp     di, 0FFFFh
BIOSCODE:1783                 jz      short InsuffHMA
BIOSCODE:1785                 neg     di              ; free space in HMA
BIOSCODE:1787                 cmp     bx, di
BIOSCODE:1789                 jbe     short try_4
BIOSCODE:178B                 mov     di, 0FFFFh
BIOSCODE:178E                 pop     ds
BIOSCODE:178F                 iret
BIOSCODE:1790 ; ---------------------------------------------------------------------------
BIOSCODE:1790
BIOSCODE:1790 try_4:                                  ; CODE XREF: BIOSCODE:1789↑j
BIOSCODE:1790                 call    get_FreeHMAPtr
BIOSCODE:1793                 add     bx, 15
BIOSCODE:1796                 and     bl, 0F0h
BIOSCODE:1799                 add     ds:FreeHMAPtr, bx ; update the free pointer
BIOSCODE:179D                 jnz     short InsuffHMA
BIOSCODE:179F                 mov     ds:FreeHMAPtr, 0FFFFh ; -1
BIOSCODE:179F                                         ; no more HMA if we have wrapped
BIOSCODE:17A5
BIOSCODE:17A5 InsuffHMA:                              ; CODE XREF: BIOSCODE:1783↑j
BIOSCODE:17A5                                         ; BIOSCODE:179D↑j
BIOSCODE:17A5                 pop     ds
BIOSCODE:17A6
BIOSCODE:17A6 try_3:                                  ; CODE XREF: BIOSCODE:1775↑j
BIOSCODE:17A6                 iret
BIOSCODE:17A7
BIOSCODE:17A7 ; =============== S U B R O U T I N E =======================================
BIOSCODE:17A7
BIOSCODE:17A7
BIOSCODE:17A7 HMAptr          proc near               ; CODE XREF: BIOSCODE:1760↑p
BIOSCODE:17A7                                         ; BIOSCODE:177D↑p
BIOSCODE:17A7                 mov     ds, cs:Bios_Data_Word
BIOSCODE:17AC                 assume ds:nothing
BIOSCODE:17AC                 mov     di, ds:FreeHMAPtr
BIOSCODE:17B0                 cmp     di, 0FFFFh
BIOSCODE:17B3                 jnz     short HMAPtr_retn
BIOSCODE:17B5                 cmp     ds:SysinitPresent, 0
BIOSCODE:17BA                 jz      short HMAPtr_retn
BIOSCODE:17BC                 call    dword ptr ds:MoveDOSIntoHMA ; call far [MoveDOSIntoHMA]
BIOSCODE:17BC HMAptr          endp
BIOSCODE:17BC
BIOSCODE:17C0
BIOSCODE:17C0 ; =============== S U B R O U T I N E =======================================
BIOSCODE:17C0
BIOSCODE:17C0
BIOSCODE:17C0 get_FreeHMAPtr  proc near               ; CODE XREF: BIOSCODE:try_4↑p
BIOSCODE:17C0                 mov     di, ds:FreeHMAPtr
BIOSCODE:17C4
BIOSCODE:17C4 HMAPtr_retn:                            ; CODE XREF: HMAptr+C↑j
BIOSCODE:17C4                                         ; HMAptr+13↑j
BIOSCODE:17C4                 retn
BIOSCODE:17C4 get_FreeHMAPtr  endp
BIOSCODE:17C4
BIOSCODE:17C5
BIOSCODE:17C5 ; =============== S U B R O U T I N E =======================================
BIOSCODE:17C5
BIOSCODE:17C5
BIOSCODE:17C5 move_sector     proc near               ; CODE XREF: BIOSCODE:199F↓p
BIOSCODE:17C5                                         ; BIOSCODE:1A0F↓p ...
BIOSCODE:17C5                 cld
BIOSCODE:17C6                 push    cx
BIOSCODE:17C7                 mov     cx, 256
BIOSCODE:17CA                 cmp     si, 0FE00h
BIOSCODE:17CE                 ja      short movsec_bytes
BIOSCODE:17D0                 cmp     di, 0FE00h
BIOSCODE:17D4                 ja      short movsec_bytes
BIOSCODE:17D6                 rep movsw
BIOSCODE:17D8                 pop     cx
BIOSCODE:17D9                 retn
BIOSCODE:17DA ; ---------------------------------------------------------------------------
BIOSCODE:17DA
BIOSCODE:17DA movsec_bytes:                           ; CODE XREF: move_sector+9↑j
BIOSCODE:17DA                                         ; move_sector+F↑j
BIOSCODE:17DA                 shl     cx, 1
BIOSCODE:17DC                 rep movsb
BIOSCODE:17DE                 pop     cx
BIOSCODE:17DF                 retn
BIOSCODE:17DF move_sector     endp
BIOSCODE:17DF
BIOSCODE:17E0
BIOSCODE:17E0 ; =============== S U B R O U T I N E =======================================
BIOSCODE:17E0
BIOSCODE:17E0
BIOSCODE:17E0 check_wrap      proc near               ; CODE XREF: BIOSCODE:1956↓p
BIOSCODE:17E0                                         ; BIOSCODE:1A56↓p ...
BIOSCODE:17E0                 push    ax
BIOSCODE:17E1                 push    bx
BIOSCODE:17E2                 push    es
BIOSCODE:17E3                 push    di
BIOSCODE:17E4                 call    find_bds        ; get pointer to bds for drive in dl
BIOSCODE:17E7                 jb      short no_wrap
BIOSCODE:17E9                 test    word ptr es:[di+3Fh], 1 ; [es:di+BDS.flags],fnon_removable
BIOSCODE:17EF                 jz      short no_wrap   ; no wrapping for removable media
BIOSCODE:17F1                 mov     bx, es:[di+13h] ; [es:di+BDS.secpertrack]
BIOSCODE:17F5                 mov     ax, cx
BIOSCODE:17F7                 and     ax, 3Fh         ; extract sector number
BIOSCODE:17FA                 cmp     ax, bx          ; are we going to wrap?
BIOSCODE:17FC                 jbe     short no_wrap
BIOSCODE:17FE                 div     bl              ; ah=new sector #, al=# of head wraps
BIOSCODE:1800                 or      ah, ah
BIOSCODE:1802                 jnz     short not_on_bound
BIOSCODE:1804                 mov     ah, bl          ; set sector=BDS_BPB.BPB_SECTORSPERTRACK
BIOSCODE:1806                 dec     al              ; if on boundary
BIOSCODE:1806                                         ; also decrement # of head wrap
BIOSCODE:1808
BIOSCODE:1808 not_on_bound:                           ; CODE XREF: check_wrap+22↑j
BIOSCODE:1808                 and     cl, 0C0h        ; zero out sector #
BIOSCODE:180B                 or      cl, ah          ; or in new sector #
BIOSCODE:180D                 xor     ah, ah          ; ax = # of head wraps
BIOSCODE:180F                 inc     ax
BIOSCODE:1810                 add     al, dh          ; add in starting head #
BIOSCODE:1812                 adc     ah, 0           ; catch any carry
BIOSCODE:1815                 cmp     ax, es:[di+15h] ; [es:di+BDS.heads]
BIOSCODE:1815                                         ; are we going to wrap around a head?
BIOSCODE:1819                 jbe     short no_wrap_head
BIOSCODE:181B                 push    dx              ; preserve drive number and head number
BIOSCODE:181C                 xor     dx, dx
BIOSCODE:181E                 mov     bx, es:[di+15h] ; [es:di+BDS.heads]
BIOSCODE:181E                                         ; dx = new head #, ax = # of cylinder wraps
BIOSCODE:1822                 div     bx
BIOSCODE:1824                 or      dx, dx          ; if new head # is 0, then we are on the last head
BIOSCODE:1826                 jnz     short no_head_bound
BIOSCODE:1828                 mov     dx, bx          ; on boundary. set to BDS_BPB.BPB_HEADS
BIOSCODE:182A                 or      ax, ax          ; if we had some cylinder wraps,
BIOSCODE:182A                                         ; we need to reduce them by on
BIOSCODE:182C                 jz      short no_head_bound
BIOSCODE:182E                 dec     ax              ; reduce number of cylinder wraps
BIOSCODE:182F
BIOSCODE:182F no_head_bound:                          ; CODE XREF: check_wrap+46↑j
BIOSCODE:182F                                         ; check_wrap+4C↑j
BIOSCODE:182F                 mov     bh, dl          ; bh has new head number
BIOSCODE:1831                 pop     dx              ; restore drive number and head number
BIOSCODE:1832                 dec     bh
BIOSCODE:1834                 mov     dh, bh
BIOSCODE:1836                 mov     bh, cl
BIOSCODE:1838                 and     bh, 3Fh         ; preserve sector number
BIOSCODE:183B                 mov     bl, 6
BIOSCODE:183D                 xchg    cl, bl
BIOSCODE:183F                 shr     bl, cl          ; get ms cylinder bits to ls end
BIOSCODE:1841                 add     ch, al          ; add in cylinder wrap
BIOSCODE:1843                 adc     bl, ah          ; add in high byte
BIOSCODE:1845                 shl     bl, cl          ; move up to ms end
BIOSCODE:1847                 xchg    bl, cl          ; restore cylinder bits into cl
BIOSCODE:1849                 or      cl, bh          ; or in sector number
BIOSCODE:184B
BIOSCODE:184B no_wrap:                                ; CODE XREF: check_wrap+7↑j
BIOSCODE:184B                                         ; check_wrap+F↑j ...
BIOSCODE:184B                 clc
BIOSCODE:184C                 pop     di
BIOSCODE:184D                 pop     es
BIOSCODE:184E                 assume es:nothing
BIOSCODE:184E                 pop     bx
BIOSCODE:184F                 pop     ax
BIOSCODE:1850                 retn
BIOSCODE:1851 ; ---------------------------------------------------------------------------
BIOSCODE:1851
BIOSCODE:1851 no_wrap_head:                           ; CODE XREF: check_wrap+39↑j
BIOSCODE:1851                 mov     dh, al          ; do not lose new head number
BIOSCODE:1853                 dec     dh              ; get it 0-based
BIOSCODE:1855                 jmp     short no_wrap
BIOSCODE:1855 check_wrap      endp
BIOSCODE:1855
BIOSCODE:1857
BIOSCODE:1857 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1857
BIOSCODE:1857
BIOSCODE:1857 find_bds        proc near               ; CODE XREF: check_wrap+4↑p
BIOSCODE:1857                                         ; BIOSCODE:1A1D↓p
BIOSCODE:1857                 les     di, dword ptr ds:start_bds ; point es:di to first bds
BIOSCODE:185B
BIOSCODE:185B fbds_1:                                 ; CODE XREF: find_bds+10↓j
BIOSCODE:185B                 cmp     es:[di+4], dl   ; [es:di+BDS.drivenum]
BIOSCODE:185F                 jz      short fdbs_2
BIOSCODE:1861                 les     di, es:[di]     ; [es:di+BDS.link]
BIOSCODE:1861                                         ; go to next bds
BIOSCODE:1864                 cmp     di, 0FFFFh
BIOSCODE:1867                 jnz     short fbds_1
BIOSCODE:1869                 stc
BIOSCODE:186A
BIOSCODE:186A fdbs_2:                                 ; CODE XREF: find_bds+8↑j
BIOSCODE:186A                 retn
BIOSCODE:186A find_bds        endp
BIOSCODE:186A
BIOSCODE:186B
BIOSCODE:186B ; =============== S U B R O U T I N E =======================================
BIOSCODE:186B
BIOSCODE:186B
BIOSCODE:186B doint           proc near               ; CODE XREF: BIOSCODE:19E4↓p
BIOSCODE:186B                                         ; BIOSCODE:doblockdoint↓p ...
BIOSCODE:186B                 mov     dl, [bp+8]      ; [bp+INT13FRAME.olddx]
BIOSCODE:186B                                         ; get physical drive number
BIOSCODE:186F                 xor     ah, ah
BIOSCODE:1871                 or      al, al
BIOSCODE:1873                 jz      short dointdone ; if zero sectors, return ax=0
BIOSCODE:1875                 mov     ah, [bp+3]      ; [bp+INT13FRAME.oldax+1]
BIOSCODE:1875                                         ; get request code
BIOSCODE:1879                 push    word ptr [bp+10h] ; [bp+INT13FRAME.oldf]
BIOSCODE:187D                 popf
BIOSCODE:187E                 call    70h:70Bh        ; call BIOSDATA:call_orig13
BIOSCODE:187E                                         ; call DOSBIOSSEG:call_orig13
BIOSCODE:1883                 pushf
BIOSCODE:1884                 pop     word ptr [bp+10h] ; [bp+INT13FRAME.oldf]
BIOSCODE:1888
BIOSCODE:1888 dointdone:                              ; CODE XREF: doint+8↑j
BIOSCODE:1888                 retn
BIOSCODE:1888 doint           endp
BIOSCODE:1888
BIOSCODE:1888 ; ---------------------------------------------------------------------------
BIOSCODE:1889 dtype_array     dd 400090h              ; DATA XREF: BIOSCODE:18B4↓r
BIOSCODE:1889                                         ; 40h:90h is drive type array addr
BIOSCODE:188D ; ---------------------------------------------------------------------------
BIOSCODE:188D
BIOSCODE:188D format_special_stuff:                   ; CODE XREF: BIOSCODE:18EB↓j
BIOSCODE:188D                 cmp     ds:fhave96, 0   ; do we have changeline support?
BIOSCODE:1892                 jz      short format_special_stuff_done ; brif not
BIOSCODE:1894                 push    bx
BIOSCODE:1895                 mov     bx, 140h        ; fchanged_by_format+fchanged
BIOSCODE:1898                 call    set_changed_dl  ; indicate that media changed by format
BIOSCODE:189B                 pop     bx
BIOSCODE:189C                 jmp     short format_special_stuff_done
BIOSCODE:189E ; ---------------------------------------------------------------------------
BIOSCODE:189E
BIOSCODE:189E ec35_special_stuff:                     ; CODE XREF: BIOSCODE:18F2↓j
BIOSCODE:189E                 test    dl, dl          ; floppy or hard disk?
BIOSCODE:18A0                 js      short ec35_special_stuff_done ; if hard drive, we're done
BIOSCODE:18A2                 push    ax              ; see if this PARTICULAR drive is ec35
BIOSCODE:18A3                 push    cx
BIOSCODE:18A4                 mov     cl, dl          ; turn drive number into bit map
BIOSCODE:18A6                 mov     al, 1           ; assume drive 0
BIOSCODE:18A8                 shl     al, cl          ; shift over correct number of times
BIOSCODE:18AA                 test    ds:ec35_flag, al ; electrically compatible 3.5 incher?
BIOSCODE:18AE                 pop     cx
BIOSCODE:18AF                 pop     ax
BIOSCODE:18B0                 jz      short ec35_special_stuff_done ; done if this floppy is not an ec35
BIOSCODE:18B2                 push    bx              ; free up a far pointer (es:bx)
BIOSCODE:18B3                 push    es
BIOSCODE:18B4                 les     bx, cs:dtype_array
BIOSCODE:18B9                 add     bl, dl
BIOSCODE:18BB                 adc     bh, 0           ; find entry for this drive
BIOSCODE:18BE                 mov     byte ptr es:[bx], 93h ; establish drive type as:
BIOSCODE:18BE                                         ; (360k disk in 360k drive,
BIOSCODE:18BE                                         ; no double-stepping, 250 kbs transfer rate)
BIOSCODE:18C2                 pop     es
BIOSCODE:18C3                 pop     bx
BIOSCODE:18C4                 jmp     short ec35_special_stuff_done
BIOSCODE:18C6 ; ---------------------------------------------------------------------------
BIOSCODE:18C6
BIOSCODE:18C6 ps2_special_stuff:                      ; CODE XREF: BIOSCODE:18FF↓j
BIOSCODE:18C6                 cmp     ds:prevoper, 8  ; (ps2_30)
BIOSCODE:18C6                                         ; read driver parm?
BIOSCODE:18CB                 jz      short ps2_30_problem
BIOSCODE:18CD                 cmp     ds:prevoper, 15h ; apparently function 15h fails, too
BIOSCODE:18D2                 jnz     short ps2_special_stuff_done
BIOSCODE:18D4
BIOSCODE:18D4 ps2_30_problem:                         ; CODE XREF: BIOSCODE:18CB↑j
BIOSCODE:18D4                 push    ax
BIOSCODE:18D5                 mov     ah, 1
BIOSCODE:18D7                 call    70h:70Bh        ; call BIOSDATA:call_orig13
BIOSCODE:18DC                 pop     ax
BIOSCODE:18DD                 jmp     short ps2_special_stuff_done
BIOSCODE:18DF ; ---------------------------------------------------------------------------
BIOSCODE:18DF
BIOSCODE:18DF i13z:                                   ; DATA XREF: BIOSDATA:i13x↑o
BIOSCODE:18DF                 push    ds
BIOSCODE:18E0                 mov     ds, cs:Bios_Data_Word
BIOSCODE:18E5                 mov     ds:prevoper, ax ; save request
BIOSCODE:18E8                 cmp     ah, 5           ; romformat
BIOSCODE:18EB                 jz      short format_special_stuff
BIOSCODE:18ED
BIOSCODE:18ED format_special_stuff_done:              ; CODE XREF: BIOSCODE:1892↑j
BIOSCODE:18ED                                         ; BIOSCODE:189C↑j
BIOSCODE:18ED                 cmp     ds:ec35_flag, 0 ; any electrically compat 3.5 inchers?
BIOSCODE:18F2                 jnz     short ec35_special_stuff ; go handle it out of line if so
BIOSCODE:18F4
BIOSCODE:18F4 ec35_special_stuff_done:                ; CODE XREF: BIOSCODE:18A0↑j
BIOSCODE:18F4                                         ; BIOSCODE:18B0↑j ...
BIOSCODE:18F4                 call    70h:70Bh        ; call BIOSDATA:call_orig13
BIOSCODE:18F9                 pushf
BIOSCODE:18FA                 cmp     ds:model_byte, 0FAh ; is this a ps2/30?
BIOSCODE:18FA                                         ; mdl_ps2_30
BIOSCODE:18FF                 jz      short ps2_special_stuff ; exit mainline to address special
BIOSCODE:1901
BIOSCODE:1901 ps2_special_stuff_done:                 ; CODE XREF: BIOSCODE:18D2↑j
BIOSCODE:1901                                         ; BIOSCODE:18DD↑j
BIOSCODE:1901                 popf
BIOSCODE:1902                 jb      short goterr13  ; error on original orig13 call-thru?
BIOSCODE:1904
BIOSCODE:1904 ret_from_i13:                           ; CODE XREF: BIOSCODE:i13ret_ck_chglinerr↓j
BIOSCODE:1904                                         ; BIOSCODE:1923↓j ...
BIOSCODE:1904                 pop     ds
BIOSCODE:1905                 assume ds:nothing
BIOSCODE:1905                 retf    2               ; restore ds & iret w/flags
BIOSCODE:1908 ; ---------------------------------------------------------------------------
BIOSCODE:1908
BIOSCODE:1908 i13ret_ck_chglinerr:                    ; CODE XREF: BIOSCODE:197E↓j
BIOSCODE:1908                                         ; BIOSCODE:19FE↓j
BIOSCODE:1908                 jnb     short ret_from_i13 ; done if not an error termination
BIOSCODE:190A
BIOSCODE:190A i13_ret_error:                          ; CODE XREF: BIOSCODE:192D↓j
BIOSCODE:190A                                         ; BIOSCODE:1934↓j ...
BIOSCODE:190A                 cmp     ah, 6           ; did i see a change event?
BIOSCODE:190D                 jnz     short int13b    ; skip if wrong error
BIOSCODE:190F                 or      dl, dl          ; is this for the hard disk?
BIOSCODE:1911                 js      short int13b    ; yes, ignore
BIOSCODE:1913                 cmp     ds:fhave96, 0
BIOSCODE:1918                 jz      short int13b    ; just in case ROM returned this
BIOSCODE:1918                                         ; error even though it told us it
BIOSCODE:1918                                         ; never would
BIOSCODE:191A                 push    bx
BIOSCODE:191B                 mov     bx, 40h         ; fchanged
BIOSCODE:191E                 call    set_changed_dl
BIOSCODE:1921                 pop     bx
BIOSCODE:1922
BIOSCODE:1922 int13b:                                 ; CODE XREF: BIOSCODE:190D↑j
BIOSCODE:1922                                         ; BIOSCODE:1911↑j ...
BIOSCODE:1922                 stc                     ; now return the error
BIOSCODE:1923                 jmp     short ret_from_i13
BIOSCODE:1925 ; ---------------------------------------------------------------------------
BIOSCODE:1925
BIOSCODE:1925 goterr13:                               ; CODE XREF: BIOSCODE:1902↑j
BIOSCODE:1925                 cmp     ah, 9           ; dma error?
BIOSCODE:1928                 jz      short gotdmaerr
BIOSCODE:192A
BIOSCODE:192A goterr13_xxxx:                          ; CODE XREF: BIOSCODE:xgoterr13_xxxx↓j
BIOSCODE:192A                 cmp     ah, 11h         ; ecc error?
BIOSCODE:192D                 jnz     short i13_ret_error ; other error. just return back.
BIOSCODE:192F                 cmp     ds:media_set_for_format, 1 ; formatting?
BIOSCODE:1934                 jz      short i13_ret_error
BIOSCODE:1936                 cmp     byte ptr ds:prevoper+1, 2 ; ecc-corrected error
BIOSCODE:1936                                         ; (2 = romread)
BIOSCODE:1936                                         ; ECC correction only applies to reads
BIOSCODE:193B                 jnz     short i13_ret_error
BIOSCODE:193D                 xor     ah, ah
BIOSCODE:193F                 call    70h:70Bh        ; call BIOSDATA:call_orig13
BIOSCODE:193F                                         ; call DOSBIOSSEG:call_orig13
BIOSCODE:1944                 mov     ax, ds:prevoper
BIOSCODE:1947                 xor     ah, ah          ; return code = no error
BIOSCODE:1949                 cmp     al, 1           ; if request for one sector, assume ok
BIOSCODE:194B                 jz      short ret_from_i13 ; return with carry clear
BIOSCODE:194D                 push    bx
BIOSCODE:194E                 push    cx
BIOSCODE:194F                 push    dx
BIOSCODE:1950                 mov     ds:number_of_sec, al
BIOSCODE:1953
BIOSCODE:1953 loop_ecc:                               ; CODE XREF: BIOSCODE:1978↓j
BIOSCODE:1953                 mov     ax, 201h        ; read one sector
BIOSCODE:1956                 call    check_wrap      ; get correct parameters for int 13
BIOSCODE:1959                 call    70h:70Bh        ; call BIOSDATA:call_orig13
BIOSCODE:1959                                         ; call DOSBIOSSEG:call_orig13
BIOSCODE:195E                 jnb     short ok11_op
BIOSCODE:1960                 cmp     ah, 9           ; DMA error during ECC read?
BIOSCODE:1963                 jz      short handle_dma_during_ecc
BIOSCODE:1965                 cmp     ah, 11h         ; only allow ecc errors
BIOSCODE:1968                 jnz     short ok11_exit_err
BIOSCODE:196A                 xor     ax, ax          ; ecc error. reset the system again.
BIOSCODE:196A                                         ; clear the error code so that if this
BIOSCODE:196A                                         ; was the last sector, no error code
BIOSCODE:196A                                         ; will be returned for the corrected read.
BIOSCODE:196A                                         ; (clear carry too.)
BIOSCODE:196C
BIOSCODE:196C ok11_op:                                ; CODE XREF: BIOSCODE:195E↑j
BIOSCODE:196C                                         ; BIOSCODE:19A4↓j
BIOSCODE:196C                 dec     ds:number_of_sec
BIOSCODE:1970                 jz      short ok11_exit ; all done?
BIOSCODE:1972                 inc     cl              ; advance sector number
BIOSCODE:1972                                         ; add 200h to address
BIOSCODE:1974                 inc     bh
BIOSCODE:1976                 inc     bh
BIOSCODE:1978                 jmp     short loop_ecc
BIOSCODE:197A ; ---------------------------------------------------------------------------
BIOSCODE:197A
BIOSCODE:197A ok11_exit_err:                          ; CODE XREF: BIOSCODE:1968↑j
BIOSCODE:197A                                         ; BIOSCODE:1996↓j
BIOSCODE:197A                 stc                     ; set carry bit again.
BIOSCODE:197B
BIOSCODE:197B ok11_exit:                              ; CODE XREF: BIOSCODE:1970↑j
BIOSCODE:197B                 pop     dx
BIOSCODE:197C                 pop     cx
BIOSCODE:197D                 pop     bx
BIOSCODE:197E                 jmp     short i13ret_ck_chglinerr
BIOSCODE:1980 ; ---------------------------------------------------------------------------
BIOSCODE:1980
BIOSCODE:1980 handle_dma_during_ecc:                  ; CODE XREF: BIOSCODE:1963↑j
BIOSCODE:1980                 push    es
BIOSCODE:1981                 push    bx
BIOSCODE:1982                 mov     bx, offset disksector ; BIOSDATA:0152h
BIOSCODE:1985                 push    ds
BIOSCODE:1986                 pop     es              ; point es:bx to buffer
BIOSCODE:1987                 mov     ax, 201h        ; read one sector
BIOSCODE:198A                 call    70h:70Bh        ; call BIOSDATA:call_orig13
BIOSCODE:198F                 pop     bx
BIOSCODE:1990                 pop     es
BIOSCODE:1991                 jnb     short handle_dma_during_ecc_noerr
BIOSCODE:1993                 cmp     ah, 11h
BIOSCODE:1996                 jnz     short ok11_exit_err
BIOSCODE:1998
BIOSCODE:1998 handle_dma_during_ecc_noerr:            ; CODE XREF: BIOSCODE:1991↑j
BIOSCODE:1998                 push    si
BIOSCODE:1999                 push    di
BIOSCODE:199A                 mov     di, bx
BIOSCODE:199C                 mov     si, offset disksector
BIOSCODE:199F                 call    move_sector
BIOSCODE:19A2                 pop     di
BIOSCODE:19A3                 pop     si
BIOSCODE:19A4                 jmp     short ok11_op
BIOSCODE:19A6 ; ---------------------------------------------------------------------------
BIOSCODE:19A6
BIOSCODE:19A6 gotdmaerr:                              ; CODE XREF: BIOSCODE:1928↑j
BIOSCODE:19A6                 mov     ax, ds:prevoper
BIOSCODE:19A9                 sti
BIOSCODE:19AA                 cmp     ah, 2           ; romread
BIOSCODE:19AD                 jb      short i13_done_dmaerr
BIOSCODE:19AF                 cmp     ah, 4           ; romverify
BIOSCODE:19B2                 jz      short intverify
BIOSCODE:19B4                 cmp     ah, 5           ; romformat
BIOSCODE:19B7                 jz      short intformat
BIOSCODE:19B9                 ja      short i13_done_dmaerr
BIOSCODE:19BB                 push    dx              ; set up stack frame here!
BIOSCODE:19BC                 push    cx
BIOSCODE:19BD                 push    bx
BIOSCODE:19BE                 push    ax
BIOSCODE:19BF                 push    bp
BIOSCODE:19C0                 mov     bp, sp
BIOSCODE:19C2                 mov     dx, es          ; check for 64k boundary error
BIOSCODE:19C4                 add     dx, dx
BIOSCODE:19C6                 add     dx, dx
BIOSCODE:19C8                 add     dx, dx
BIOSCODE:19CA                 add     dx, dx          ; dx = dx*16
BIOSCODE:19CC                 add     dx, bx
BIOSCODE:19CE                 add     dx, 511
BIOSCODE:19D2                 jnb     short no_skip_first
BIOSCODE:19D4                 jmp     bufferx         ; restore dh=head & do buffer
BIOSCODE:19D7 ; ---------------------------------------------------------------------------
BIOSCODE:19D7
BIOSCODE:19D7 no_skip_first:                          ; CODE XREF: BIOSCODE:19D2↑j
BIOSCODE:19D7                 shr     dh, 1           ; dh = number of sectors before address
BIOSCODE:19D9                 mov     ah, 128         ; ah = max number of sectors in segment
BIOSCODE:19DB                 sub     ah, dh
BIOSCODE:19DD                 cmp     ah, al          ; can we fit it in?
BIOSCODE:19DF                 jb      short doblock   ; no, perform blocking.
BIOSCODE:19DF                                         ; yes, the request fits. let it happen
BIOSCODE:19E1                 mov     dh, [bp+9]      ; [bp+INT13FRAME.olddx+1]
BIOSCODE:19E1                                         ; set up head number
BIOSCODE:19E4                 call    doint
BIOSCODE:19E7                 jmp     bad13           ; and return from this place
BIOSCODE:19EA ; ---------------------------------------------------------------------------
BIOSCODE:19EA
BIOSCODE:19EA i13_done_dmaerr:                        ; CODE XREF: BIOSCODE:19AD↑j
BIOSCODE:19EA                                         ; BIOSCODE:19B9↑j
BIOSCODE:19EA                 mov     ah, 9           ; pass dma error thru to caller
BIOSCODE:19EC                 stc
BIOSCODE:19ED                 jmp     ret_from_i13    ; return with error,
BIOSCODE:19ED                                         ; we know it's not a changeline error
BIOSCODE:19F0 ; ---------------------------------------------------------------------------
BIOSCODE:19F0
BIOSCODE:19F0 intverify:                              ; CODE XREF: BIOSCODE:19B2↑j
BIOSCODE:19F0                 push    es              ; save caller's dma address
BIOSCODE:19F1                 push    bx
BIOSCODE:19F2                 push    ds
BIOSCODE:19F3                 pop     es              ; es:bx -> BIOSDATA:disksector
BIOSCODE:19F4
BIOSCODE:19F4 dosimple:                               ; CODE XREF: BIOSCODE:1A15↓j
BIOSCODE:19F4                 mov     bx, offset disksector
BIOSCODE:19F7                 call    70h:70Bh        ; call DOSBIOSSEG:call_orig13
BIOSCODE:19F7                                         ; call BIOSDATA:call_orig13
BIOSCODE:19FC                 pop     bx
BIOSCODE:19FD                 pop     es
BIOSCODE:19FE                 jmp     i13ret_ck_chglinerr
BIOSCODE:1A01 ; ---------------------------------------------------------------------------
BIOSCODE:1A01
BIOSCODE:1A01 intformat:                              ; CODE XREF: BIOSCODE:19B7↑j
BIOSCODE:1A01                 push    es
BIOSCODE:1A02                 push    bx
BIOSCODE:1A03                 push    si
BIOSCODE:1A04                 push    di
BIOSCODE:1A05                 push    ds
BIOSCODE:1A06                 push    es
BIOSCODE:1A07                 push    ds
BIOSCODE:1A08                 pop     es
BIOSCODE:1A09                 pop     ds
BIOSCODE:1A0A                 mov     si, bx
BIOSCODE:1A0C                 mov     di, offset disksector
BIOSCODE:1A0F                 call    move_sector     ; user's data into BIOSDATA:disksector
BIOSCODE:1A12                 pop     ds
BIOSCODE:1A13                 pop     di
BIOSCODE:1A14                 pop     si              ; do the i/o from
BIOSCODE:1A15                 jmp     short dosimple  ; BIOSDATA:disksector
BIOSCODE:1A17 ; ---------------------------------------------------------------------------
BIOSCODE:1A17
BIOSCODE:1A17 doblock:                                ; CODE XREF: BIOSCODE:19DF↑j
BIOSCODE:1A17                 mov     dx, [bp+8]      ; [bp+INT13FRAME.olddx]
BIOSCODE:1A17                                         ; get head #, drive #
BIOSCODE:1A1A                 push    cx
BIOSCODE:1A1B                 push    es
BIOSCODE:1A1C                 push    di              ; ah - # of sectors before dma boundary
BIOSCODE:1A1C                                         ; al - requested # of sectors for i/o.
BIOSCODE:1A1D                 call    find_bds
BIOSCODE:1A20                 mov     cx, es:[di+13h] ; [es:di+BDS.secpertrack]
BIOSCODE:1A24                 test    word ptr es:[di+3Fh], 1 ; [es:di+BDS.flags], fnon_removable
BIOSCODE:1A2A                 pop     di
BIOSCODE:1A2B                 pop     es
BIOSCODE:1A2C                 mov     al, ah          ; set al=ah for floppies
BIOSCODE:1A2E                 jz      short doblockflop ; they are track by track operation
BIOSCODE:1A30                 mov     ah, 63          ; ah = 63-secpt (# safe sectors??)
BIOSCODE:1A32                 sub     ah, cl          ; al - # of sectors before dma boundary
BIOSCODE:1A34
BIOSCODE:1A34 doblockflop:                            ; CODE XREF: BIOSCODE:1A2E↑j
BIOSCODE:1A34                 pop     cx
BIOSCODE:1A35
BIOSCODE:1A35 doblockcontinue:                        ; CODE XREF: BIOSCODE:1A59↓j
BIOSCODE:1A35                 cmp     ah, al          ; if safe_# >= #_of_sectors_to_go_before dma,
BIOSCODE:1A37                 jnb     short doblocklast ; then #_of_sectors_to_go as it is for doint.
BIOSCODE:1A39                 push    ax
BIOSCODE:1A3A                 mov     al, ah          ; otherwise, set al to ah to operate.
BIOSCODE:1A3C                 jmp     short doblockdoint
BIOSCODE:1A3E ; ---------------------------------------------------------------------------
BIOSCODE:1A3E
BIOSCODE:1A3E doblocklast:                            ; CODE XREF: BIOSCODE:1A37↑j
BIOSCODE:1A3E                 mov     ah, al
BIOSCODE:1A40                 push    ax
BIOSCODE:1A41
BIOSCODE:1A41 doblockdoint:                           ; CODE XREF: BIOSCODE:1A3C↑j
BIOSCODE:1A41                 call    doint           ; let ah = al = # of sectors for this shot
BIOSCODE:1A44                 jb      short bad13     ; something happened, bye!
BIOSCODE:1A46                 pop     ax
BIOSCODE:1A47                 sub     [bp+2], ah      ; sub [bp+INT13FRAME.oldax], ah
BIOSCODE:1A47                                         ; decrement by the successful operation
BIOSCODE:1A4A                 add     cl, ah          ; advance sector #. safety gauranteed.
BIOSCODE:1A4C                 add     bh, ah          ; advance dma address
BIOSCODE:1A4E                 add     bh, ah          ; twice for 512 byte sectors
BIOSCODE:1A50                 cmp     ah, al          ; check the previous value
BIOSCODE:1A52                 jz      short buffer    ; if #_of_sectors_to_go < safe_#,
BIOSCODE:1A52                                         ; then we are done already.
BIOSCODE:1A54                 sub     al, ah          ; otherwise,
BIOSCODE:1A54                                         ; #_sector_to_go = #_of_sector_to_go - safe_#
BIOSCODE:1A56                 call    check_wrap      ; get new cx, dh for the next operation.
BIOSCODE:1A59                 jmp     short doblockcontinue ; handles next sectors left.
BIOSCODE:1A5B ; ---------------------------------------------------------------------------
BIOSCODE:1A5B
BIOSCODE:1A5B bufferx:                                ; CODE XREF: BIOSCODE:19D4↑j
BIOSCODE:1A5B                 mov     dh, [bp+9]      ; [bp+INT13FRAME.olddx+1]
BIOSCODE:1A5B                                         ; set up head number
BIOSCODE:1A5E
BIOSCODE:1A5E buffer:                                 ; CODE XREF: BIOSCODE:1A52↑j
BIOSCODE:1A5E                 push    bx
BIOSCODE:1A5F                 mov     ah, [bp+3]      ; [bp+INT13FRAME.oldax+1]
BIOSCODE:1A62                 cmp     ah, 3           ; romwrite
BIOSCODE:1A65                 jnz     short doread
BIOSCODE:1A67                 push    es
BIOSCODE:1A68                 push    ds
BIOSCODE:1A69                 push    si
BIOSCODE:1A6A                 push    di
BIOSCODE:1A6B                 push    ds              ; exchange segment registers
BIOSCODE:1A6C                 push    es
BIOSCODE:1A6D                 pop     ds
BIOSCODE:1A6E                 pop     es
BIOSCODE:1A6F                 mov     di, offset disksector ; where to move
BIOSCODE:1A72                 push    di              ; save it
BIOSCODE:1A73                 mov     si, bx          ; source
BIOSCODE:1A75                 call    move_sector     ; move sector into local buffer
BIOSCODE:1A78                 pop     bx              ; new transfer address
BIOSCODE:1A78                                         ; (es:bx = BIOSDATA:disksector)
BIOSCODE:1A79                 pop     di              ; restore caller's di & si
BIOSCODE:1A7A                 pop     si
BIOSCODE:1A7B                 pop     ds              ; restore BIOSDATA
BIOSCODE:1A7C                 mov     al, 1
BIOSCODE:1A7E                 mov     dl, [bp+8]      ; [bp+INT13FRAME.olddx]
BIOSCODE:1A7E                                         ; get drive number
BIOSCODE:1A81                 call    check_wrap      ; sets up registers if wrap-around
BIOSCODE:1A81                                         ;
BIOSCODE:1A81                                         ; ah is function
BIOSCODE:1A81                                         ; al is 1 for single sector transfer
BIOSCODE:1A81                                         ; es:bx is local transfer addres
BIOSCODE:1A81                                         ; cx is track/sector number
BIOSCODE:1A81                                         ; dx is head/drive number
BIOSCODE:1A81                                         ; si, di unchanged
BIOSCODE:1A84                 call    doint
BIOSCODE:1A87                 pop     es              ; restore caller's dma segment
BIOSCODE:1A88                 jb      short bad13     ; go clean up
BIOSCODE:1A8A                 jmp     short dotail
BIOSCODE:1A8C ; ---------------------------------------------------------------------------
BIOSCODE:1A8C
BIOSCODE:1A8C doread:                                 ; CODE XREF: BIOSCODE:1A65↑j
BIOSCODE:1A8C                 push    es
BIOSCODE:1A8D                 push    bx
BIOSCODE:1A8E                 push    ds
BIOSCODE:1A8F                 pop     es              ; es = BIOSCODE segment
BIOSCODE:1A90                 mov     bx, offset disksector
BIOSCODE:1A93                 mov     al, 1
BIOSCODE:1A95                 mov     dl, [bp+8]      ; [bp+INT13FRAME.olddx]
BIOSCODE:1A95                                         ; get drive number
BIOSCODE:1A98                 call    check_wrap      ; ah = function
BIOSCODE:1A98                                         ; al = 1 for single sector
BIOSCODE:1A98                                         ; es:bx points to local   buffer
BIOSCODE:1A98                                         ; cx, dx are track/sector, head/drive
BIOSCODE:1A9B                 call    doint
BIOSCODE:1A9E                 pop     bx
BIOSCODE:1A9F                 pop     es
BIOSCODE:1AA0                 jb      short bad13
BIOSCODE:1AA2                 push    si
BIOSCODE:1AA3                 push    di
BIOSCODE:1AA4                 mov     di, bx
BIOSCODE:1AA6                 mov     si, offset disksector
BIOSCODE:1AA9                 call    move_sector
BIOSCODE:1AAC                 pop     di
BIOSCODE:1AAD                 pop     si
BIOSCODE:1AAE
BIOSCODE:1AAE dotail:                                 ; CODE XREF: BIOSCODE:1A8A↑j
BIOSCODE:1AAE                 pop     bx              ; retrieve new dma area
BIOSCODE:1AAF                 add     bh, 2           ; advance over sector
BIOSCODE:1AB2                 inc     cx
BIOSCODE:1AB3                 mov     al, [bp+2]      ; [bp+INT13FRAME.oldax]
BIOSCODE:1AB6                 clc
BIOSCODE:1AB7                 dec     al
BIOSCODE:1AB9                 jz      short bad13     ; no more i/o
BIOSCODE:1ABB                 mov     dl, [bp+8]      ; [bp+INT13FRAME.olddx]
BIOSCODE:1ABE                 call    check_wrap
BIOSCODE:1AC1                 call    doint
BIOSCODE:1AC4
BIOSCODE:1AC4 bad13:                                  ; CODE XREF: BIOSCODE:19E7↑j
BIOSCODE:1AC4                                         ; BIOSCODE:1A44↑j ...
BIOSCODE:1AC4                 mov     sp, bp
BIOSCODE:1AC6                 pop     bp
BIOSCODE:1AC7                 pop     bx
BIOSCODE:1AC8                 pop     bx
BIOSCODE:1AC9                 pop     cx
BIOSCODE:1ACA                 pop     dx
BIOSCODE:1ACB                 jb      short xgoterr13_xxxx ; go handle ECC errors
BIOSCODE:1ACD                 jmp     ret_from_i13    ; non-error exit
BIOSCODE:1AD0 ; ---------------------------------------------------------------------------
BIOSCODE:1AD0
BIOSCODE:1AD0 xgoterr13_xxxx:                         ; CODE XREF: BIOSCODE:1ACB↑j
BIOSCODE:1AD0                 jmp     goterr13_xxxx
BIOSCODE:1AD0 ; ---------------------------------------------------------------------------
BIOSCODE:1AD3                 db    0
BIOSCODE:1AD4
BIOSCODE:1AD4 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1AD4
BIOSCODE:1AD4
BIOSCODE:1AD4 dsk_init        proc near               ; DATA XREF: BIOSCODE:057A↑o
BIOSCODE:1AD4                 mov     ah, ds:drvmax
BIOSCODE:1AD8                 mov     di, offset dskdrvs ; pass result in es:di
BIOSCODE:1ADB                 push    ds
BIOSCODE:1ADC                 pop     es
BIOSCODE:1ADD                 jmp     SetPtrSav
BIOSCODE:1ADD dsk_init        endp
BIOSCODE:1ADD
BIOSCODE:1AE0
BIOSCODE:1AE0 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1AE0
BIOSCODE:1AE0
BIOSCODE:1AE0 install_bds     proc near               ; CODE XREF: BIOSCODE:1716↑p
BIOSCODE:1AE0                 push    ds              ; save Bios_Data (BIOSDATA) segment
BIOSCODE:1AE1                 mov     si, offset start_bds ; beginning of chain
BIOSCODE:1AE4
BIOSCODE:1AE4 loop_next_bds:                          ; CODE XREF: install_bds+2C↓j
BIOSCODE:1AE4                 lds     si, [si]        ; [si+BDS.link]
BIOSCODE:1AE4                                         ; fetch next bds
BIOSCODE:1AE6                 mov     al, es:[di+4]   ; [es:di+BDS.drivenum]
BIOSCODE:1AEA                 cmp     [si+4], al      ; does this one share a physical
BIOSCODE:1AEA                                         ; drive with new one?
BIOSCODE:1AED                 jnz     short next_bds
BIOSCODE:1AEF                 mov     bl, 10h         ; fi_am_mult
BIOSCODE:1AF1                 or      es:[di+3Fh], bl ; [es:di+BDS.flags]
BIOSCODE:1AF1                                         ; set both of them to i_am_mult if so
BIOSCODE:1AF5                 or      [si+3Fh], bl    ; [si+BDS.flags]
BIOSCODE:1AF8                 and     byte ptr es:[di+3Fh], 0DFh ; [es:di+BDS.flags],~fi_own_physical
BIOSCODE:1AF8                                         ; we don't own it
BIOSCODE:1AFD                 mov     bl, [si+3Fh]    ; [si+BDS.flags]
BIOSCODE:1AFD                                         ; determine if changeline available
BIOSCODE:1B00                 and     bl, 2           ; fchangeline
BIOSCODE:1B03                 or      es:[di+3Fh], bl ; [es:di+BDS.flags]
BIOSCODE:1B07
BIOSCODE:1B07 next_bds:                               ; CODE XREF: install_bds+D↑j
BIOSCODE:1B07                 mov     ax, 0FFFFh
BIOSCODE:1B0A                 cmp     [si], ax        ; [si+BDS.link],-1
BIOSCODE:1B0A                                         ; are we at end of list?
BIOSCODE:1B0C                 jnz     short loop_next_bds
BIOSCODE:1B0E                 mov     word ptr [si+2], es ; [si+BDS.link+2], es
BIOSCODE:1B0E                                         ; install bds
BIOSCODE:1B11                 mov     [si], di
BIOSCODE:1B13                 mov     es:[di], ax     ; [es:di+BDS.link],-1
BIOSCODE:1B13                                         ; set next pointer to null
BIOSCODE:1B16                 pop     ds
BIOSCODE:1B17                 mov     al, es:[di+50h] ; [es:di+BDS.rsecpertrack]
BIOSCODE:1B1B                 cmp     al, ds:eot
BIOSCODE:1B1F                 jbe     short _eot_ok
BIOSCODE:1B21                 mov     ds:eot, al
BIOSCODE:1B24
BIOSCODE:1B24 _eot_ok:                                ; CODE XREF: install_bds+3F↑j
BIOSCODE:1B24                 retn
BIOSCODE:1B24 install_bds     endp
BIOSCODE:1B24
BIOSCODE:1B25
BIOSCODE:1B25 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1B25
BIOSCODE:1B25
BIOSCODE:1B25 swpdsk          proc near               ; CODE XREF: checksingle:ignore_sdsb↑p
BIOSCODE:1B25                 test    ds:IsWin386, 1  ; Is win386 present?
BIOSCODE:1B2A                 jz      short no_win386 ; no, skip SetFocus
BIOSCODE:1B2C                 call    far ptr 70h:813h ; call DOSBIOSSEG:V86_Crit_SetFocus
BIOSCODE:1B2C                                         ; call BIOSDATA:V86_Crit_SetFocus
BIOSCODE:1B31
BIOSCODE:1B31 no_win386:                              ; CODE XREF: swpdsk+5↑j
BIOSCODE:1B31                 push    cx
BIOSCODE:1B32                 push    dx
BIOSCODE:1B33                 mov     dl, es:[di+5]   ; [es:di+BDS.drivelet]
BIOSCODE:1B33                                         ; get the drive letter
BIOSCODE:1B37                 mov     dh, dl
BIOSCODE:1B39                 xor     dh, 1
BIOSCODE:1B3C                 sub     cx, cx          ; nobody has handled swap disk
BIOSCODE:1B3E                 mov     ax, 4A00h       ; multMULT<<8)|multMULTSWPDSK
BIOSCODE:1B3E                                         ; broadcast code for swap disk
BIOSCODE:1B3E                                         ; Broadcast it
BIOSCODE:1B41                 int     2Fh
BIOSCODE:1B43                 inc     cx
BIOSCODE:1B44                 jz      short swpdsk9
BIOSCODE:1B46                 add     dl, 'A'
BIOSCODE:1B49                 mov     byte ptr cs:drvlet, dl ; "A: and press any key when ready\r\n\n"
BIOSCODE:1B4E                 mov     si, offset sngmsg ; "\r\nInsert diskette for drive "
BIOSCODE:1B51                 push    bx
BIOSCODE:1B52                 lods    byte ptr cs:[si] ; get the next character of the message
BIOSCODE:1B54
BIOSCODE:1B54 wrmsg_loop:                             ; CODE XREF: swpdsk+35↓j
BIOSCODE:1B54                 int     29h             ; DOS 2+ internal - FAST PUTCHAR
BIOSCODE:1B54                                         ; AL = character to display
BIOSCODE:1B56                 lods    byte ptr cs:[si] ; cs lodsb
BIOSCODE:1B56                                         ; get the next character of the message
BIOSCODE:1B58                 or      al, al
BIOSCODE:1B5A                 jnz     short wrmsg_loop
BIOSCODE:1B5C                 call    con_flush       ; flush out keyboard queue
BIOSCODE:1B5C                                         ; call rom-bios
BIOSCODE:1B5F                 xor     ah, ah
BIOSCODE:1B61                 int     16h             ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
BIOSCODE:1B61                                         ; Return: AH = scan code, AL = character
BIOSCODE:1B63                 pop     bx
BIOSCODE:1B64
BIOSCODE:1B64 swpdsk9:                                ; CODE XREF: swpdsk+1F↑j
BIOSCODE:1B64                 pop     dx
BIOSCODE:1B65                 pop     cx
BIOSCODE:1B66                 retn
BIOSCODE:1B66 swpdsk          endp
BIOSCODE:1B66
BIOSCODE:1B66 ; ---------------------------------------------------------------------------
BIOSCODE:1B67 sngmsg          db 0Dh,0Ah              ; DATA XREF: swpdsk+29↑o
BIOSCODE:1B67                 db 'Insert diskette for drive '
BIOSCODE:1B83 drvlet          db 'A: and press any key when ready',0Dh,0Ah
BIOSCODE:1B83                                         ; DATA XREF: swpdsk+24↑w
BIOSCODE:1B83                 db 0Ah,0
BIOSCODE:1BA6
BIOSCODE:1BA6 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1BA6
BIOSCODE:1BA6
BIOSCODE:1BA6 mediacheck      proc near               ; CODE XREF: BIOSCODE:05F3↑p
BIOSCODE:1BA6                 call    checksingle     ; make sure correct disk is in place
BIOSCODE:1BA9                 xor     si, si
BIOSCODE:1BAB                 call    haschange
BIOSCODE:1BAE                 jz      short mediaret
BIOSCODE:1BB0                 test    word ptr es:[di+3Fh], 40h ; [es:di+BDS.flags], fchanged ; 40h
BIOSCODE:1BB0                                         ; (BDS offset 63)
BIOSCODE:1BB6                 jnz     short mediadovolid ; media changed
BIOSCODE:1BB8                 push    ax
BIOSCODE:1BB9                 push    dx
BIOSCODE:1BBA                 mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
BIOSCODE:1BBE                 mov     ah, 16h
BIOSCODE:1BC0                 int     13h             ; DISK - FLOPPY DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
BIOSCODE:1BC0                                         ; DL = drive to check
BIOSCODE:1BC0                                         ; Return: AH = disk change status
BIOSCODE:1BC2                 pop     dx
BIOSCODE:1BC3                 pop     ax
BIOSCODE:1BC4                 jb      short mediadovolid
BIOSCODE:1BC6                 mov     si, 1
BIOSCODE:1BC9                 mov     bl, ds:tim_drv  ; get last drive accessed
BIOSCODE:1BCD                 cmp     es:[di+4], bl   ; [es:di+BDS.drivenum]
BIOSCODE:1BCD                                         ; (If the last drive accessed is not current drive
BIOSCODE:1BCD                                         ; media change status may be incorrect. So,
BIOSCODE:1BCD                                         ; "I don't now" will be returned even if it is indicated
BIOSCODE:1BCD                                         ; as media is not changed.)
BIOSCODE:1BD1                 jz      short mediaret  ; (same drive, media changeline indication is reliable)
BIOSCODE:1BD3                 push    ax
BIOSCODE:1BD4                 push    cx
BIOSCODE:1BD5                 push    dx
BIOSCODE:1BD6                 call    Check_Time_Of_Access
BIOSCODE:1BD9                 pop     dx
BIOSCODE:1BDA                 pop     cx
BIOSCODE:1BDB                 pop     ax
BIOSCODE:1BDC                 or      si, si
BIOSCODE:1BDE                 jz      short mediadovolid ; check_time says ">= 2 secs passed"
BIOSCODE:1BDE                                         ; (volume id will be checked)
BIOSCODE:1BE0                 xor     si, si          ; return "i don't know"
BIOSCODE:1BE2
BIOSCODE:1BE2 mediaret:                               ; CODE XREF: mediacheck+8↑j
BIOSCODE:1BE2                                         ; mediacheck+2B↑j ...
BIOSCODE:1BE2                 retn
BIOSCODE:1BE3 ; ---------------------------------------------------------------------------
BIOSCODE:1BE3
BIOSCODE:1BE3 mediadovolid:                           ; CODE XREF: mediacheck+10↑j
BIOSCODE:1BE3                                         ; mediacheck+1E↑j ...
BIOSCODE:1BE3                 call    GetBp           ; build a new bpb in current bds
BIOSCODE:1BE6                 jb      short mediaret
BIOSCODE:1BE8                 call    check_vid
BIOSCODE:1BEB                 jnb     short mediaret
BIOSCODE:1BED                 jmp     maperror        ; fix up al for return to dos
BIOSCODE:1BED mediacheck      endp
BIOSCODE:1BED
BIOSCODE:1BF0
BIOSCODE:1BF0 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1BF0
BIOSCODE:1BF0
BIOSCODE:1BF0 checklatchio    proc near               ; CODE XREF: diskio+81↑p
BIOSCODE:1BF0                 cmp     word ptr es:[di+3Ch], 0 ; [es:di+BDS.opcnt]
BIOSCODE:1BF5                 jz      short checkret  ; done if zero
BIOSCODE:1BF7                 test    word ptr es:[di+3Fh], 40h ; test [es:di+BDS.flags], fchanged ; 40h
BIOSCODE:1BFD                 jz      short checkret  ; not changed
BIOSCODE:1BFF                 call    GetBp           ; build bpb in current bds
BIOSCODE:1C02                 jb      short ret_no_error_map ; disk error trying to read in
BIOSCODE:1C04                 call    check_vid
BIOSCODE:1C07                 jb      short checklatchret ; disk error trying to read in
BIOSCODE:1C09                 or      si, si          ; is changed for sure?
BIOSCODE:1C0B                 jns     short checkret  ; no
BIOSCODE:1C0D                 call    returnvid       ; yes
BIOSCODE:1C10
BIOSCODE:1C10 checklatchret:                          ; CODE XREF: checklatchio+17↑j
BIOSCODE:1C10                 call    maperror        ; fix up al for return to dos
BIOSCODE:1C13
BIOSCODE:1C13 ret_no_error_map:                       ; CODE XREF: checklatchio+12↑j
BIOSCODE:1C13                 stc
BIOSCODE:1C14                 pop     si              ; pop off return address
BIOSCODE:1C15
BIOSCODE:1C15 checkret:                               ; CODE XREF: checklatchio+5↑j
BIOSCODE:1C15                                         ; checklatchio+D↑j ...
BIOSCODE:1C15                 retn
BIOSCODE:1C15 checklatchio    endp ; sp-analysis failed
BIOSCODE:1C15
BIOSCODE:1C16
BIOSCODE:1C16 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1C16
BIOSCODE:1C16
BIOSCODE:1C16 checkfatvid     proc near               ; CODE XREF: checkio+11↓p
BIOSCODE:1C16                 call    fat_check       ; check the fat and the vid
BIOSCODE:1C19                 or      si, si
BIOSCODE:1C1B                 js      short changed_drv ;
BIOSCODE:1C1B checkfatvid     endp                    ; fall into check_vid
BIOSCODE:1C1B
BIOSCODE:1C1D
BIOSCODE:1C1D ; =============== S U B R O U T I N E =======================================
BIOSCODE:1C1D
BIOSCODE:1C1D
BIOSCODE:1C1D check_vid       proc near               ; CODE XREF: mediacheck+42↑p
BIOSCODE:1C1D                                         ; checklatchio+14↑p
BIOSCODE:1C1D                 cmp     word ptr ds:disksector+16h, 0 ; BPB_FATSz16
BIOSCODE:1C22                 jnz     short chk_vid_1
BIOSCODE:1C24                 cmp     ds:disksector+42h, 29h ; BS_FAT32_BootSig
BIOSCODE:1C24                                         ; [disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE
BIOSCODE:1C29                 jmp     short chk_vid_2
BIOSCODE:1C2B ; ---------------------------------------------------------------------------
BIOSCODE:1C2B
BIOSCODE:1C2B chk_vid_1:                              ; CODE XREF: check_vid+5↑j
BIOSCODE:1C2B                 cmp     ds:disksector+26h, 29h ; BS_FAT_BootSig ; BS_BootSig
BIOSCODE:1C2B                                         ; [disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE
BIOSCODE:1C30
BIOSCODE:1C30 chk_vid_2:                              ; CODE XREF: check_vid+C↑j
BIOSCODE:1C30                 jz      short do_ext_check_id
BIOSCODE:1C32                 call    haschange
BIOSCODE:1C35                 jz      short checkret
BIOSCODE:1C37                 xor     si, si
BIOSCODE:1C39                 cmp     ds:disksector+10h, 0 ; BPB_NumFATs
BIOSCODE:1C39                                         ; [disksector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS]
BIOSCODE:1C3E                 jz      short checkfatret ; don't read vol id if not fat system
BIOSCODE:1C40                 call    read_volume_id
BIOSCODE:1C43                 jb      short checkfatret
BIOSCODE:1C45                 call    check_volume_id
BIOSCODE:1C48                 mov     si, 0FFFFh      ; -1
BIOSCODE:1C48                                         ; definitely changed
BIOSCODE:1C4B                 jnz     short changed_drv
BIOSCODE:1C4D                 inc     si              ; not changed
BIOSCODE:1C4E
BIOSCODE:1C4E vid_no_changed:                         ; CODE XREF: check_vid+5A↓j
BIOSCODE:1C4E                 call    resetchanged
BIOSCODE:1C51                 clc
BIOSCODE:1C52
BIOSCODE:1C52 checkfatret:                            ; CODE XREF: check_vid+21↑j
BIOSCODE:1C52                                         ; check_vid+26↑j ...
BIOSCODE:1C52                 retn
BIOSCODE:1C53 ; ---------------------------------------------------------------------------
BIOSCODE:1C53
BIOSCODE:1C53 changed_drv:                            ; CODE XREF: checkfatvid+5↑j
BIOSCODE:1C53                                         ; check_vid+2E↑j ...
BIOSCODE:1C53                 clc                     ; cas -- return no error
BIOSCODE:1C54                 mov     ds:tim_drv, 0FFh ; ensure that we ask rom for media
BIOSCODE:1C54                                         ;   check next time round
BIOSCODE:1C59                 retn
BIOSCODE:1C5A ; ---------------------------------------------------------------------------
BIOSCODE:1C5A
BIOSCODE:1C5A do_ext_check_id:                        ; CODE XREF: check_vid:chk_vid_2↑j
BIOSCODE:1C5A                 push    ax
BIOSCODE:1C5B                 push    di
BIOSCODE:1C5C                 mov     si, (offset disksector+43h) ; BS_FAT32_VolID
BIOSCODE:1C5C                                         ; [DiskSector+EXT_BOOT.SERIAL]
BIOSCODE:1C5F                 cmp     word ptr ds:disksector+16h, 0 ; BPB_FATSz16
BIOSCODE:1C64                 jz      short chk_vid_3
BIOSCODE:1C66                 sub     si, 28          ; offset disksector+27h ; BS_VolID
BIOSCODE:1C69
BIOSCODE:1C69 chk_vid_3:                              ; CODE XREF: check_vid+47↑j
BIOSCODE:1C69                 add     di, 137         ; BDS.vol_serial
BIOSCODE:1C6D                 cmpsw                   ; [DiskSector+EXT_BOOT.SERIAL] = [di+BDS.vol_serial] ?
BIOSCODE:1C6E                 jnz     short chk_vid_4
BIOSCODE:1C70                 cmpsw                   ; [DiskSector+EXT_BOOT.SERIAL+2] =
BIOSCODE:1C70                                         ;          [di+BDS.vol_serial+2] ?
BIOSCODE:1C71
BIOSCODE:1C71 chk_vid_4:                              ; CODE XREF: check_vid+51↑j
BIOSCODE:1C71                 pop     di
BIOSCODE:1C72                 pop     ax
BIOSCODE:1C73                 jnz     short ext_changed ; not equal/same
BIOSCODE:1C75                 xor     si, si          ; 0 ; don't know
BIOSCODE:1C77                 jmp     short vid_no_changed ; reset the flag
BIOSCODE:1C79 ; ---------------------------------------------------------------------------
BIOSCODE:1C79
BIOSCODE:1C79 ext_changed:                            ; CODE XREF: check_vid+56↑j
BIOSCODE:1C79                 mov     si, 0FFFFh      ; -1
BIOSCODE:1C79                                         ; disk changed!
BIOSCODE:1C7C                 clc
BIOSCODE:1C7D                 jmp     short changed_drv
BIOSCODE:1C7D check_vid       endp
BIOSCODE:1C7D
BIOSCODE:1C7F
BIOSCODE:1C7F ; =============== S U B R O U T I N E =======================================
BIOSCODE:1C7F
BIOSCODE:1C7F
BIOSCODE:1C7F checkio         proc near               ; CODE XREF: Disk+FB↑p
BIOSCODE:1C7F                 cmp     ah, 6
BIOSCODE:1C82                 jnz     short checkfatret
BIOSCODE:1C84                 cmp     word ptr es:[di+3Ch], 0 ; [es:di+BDS.opcnt]
BIOSCODE:1C89                 jz      short checkfatret
BIOSCODE:1C8B                 call    GetBp
BIOSCODE:1C8E                 jb      short no_error_map
BIOSCODE:1C90                 call    checkfatvid
BIOSCODE:1C93                 jb      short checkioret ; disk error trying to read in.
BIOSCODE:1C95                 or      si, si          ; is changed for sure?
BIOSCODE:1C97                 js      short checkioerr ; yes changed
BIOSCODE:1C99                 inc     bp              ; allow a retry
BIOSCODE:1C9A                 retn
BIOSCODE:1C9B ; ---------------------------------------------------------------------------
BIOSCODE:1C9B
BIOSCODE:1C9B checkioerr:                             ; CODE XREF: checkio+18↑j
BIOSCODE:1C9B                 call    returnvid
BIOSCODE:1C9E
BIOSCODE:1C9E checkioret:                             ; CODE XREF: checkio+14↑j
BIOSCODE:1C9E                 stc                     ; make sure carry gets passed through
BIOSCODE:1C9F                 jmp     harderr
BIOSCODE:1CA2 ; ---------------------------------------------------------------------------
BIOSCODE:1CA2
BIOSCODE:1CA2 no_error_map:                           ; CODE XREF: checkio+F↑j
BIOSCODE:1CA2                 jmp     harderr2
BIOSCODE:1CA2 checkio         endp
BIOSCODE:1CA2
BIOSCODE:1CA5
BIOSCODE:1CA5 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1CA5
BIOSCODE:1CA5
BIOSCODE:1CA5 returnvid       proc near               ; CODE XREF: checklatchio+1D↑p
BIOSCODE:1CA5                                         ; checkio:checkioerr↑p
BIOSCODE:1CA5                 mov     si, 22          ; trans+8
BIOSCODE:1CA5                                         ; offset into pointer to return value
BIOSCODE:1CA8                 call    vid_into_packet
BIOSCODE:1CAB                 mov     ah, 6
BIOSCODE:1CAD                 stc
BIOSCODE:1CAE                 retn
BIOSCODE:1CAE returnvid       endp
BIOSCODE:1CAE
BIOSCODE:1CAF
BIOSCODE:1CAF ; =============== S U B R O U T I N E =======================================
BIOSCODE:1CAF
BIOSCODE:1CAF
BIOSCODE:1CAF media_set_vid   proc near               ; CODE XREF: BIOSCODE:0624↑p
BIOSCODE:1CAF                 mov     si, 15          ; trans+1
BIOSCODE:1CB2
BIOSCODE:1CB2 vid_into_packet:                        ; CODE XREF: returnvid+3↑p
BIOSCODE:1CB2                 push    ds
BIOSCODE:1CB3                 lds     bx, ds:ptrsav
BIOSCODE:1CB7                 add     di, 125         ; BDS.volid (BDS offset 125)
BIOSCODE:1CBA                 mov     [bx+si], di
BIOSCODE:1CBC                 sub     di, 125         ; BDS start (BDS offset 0)
BIOSCODE:1CBF                 mov     word ptr [bx+si+2], es
BIOSCODE:1CC2                 pop     ds
BIOSCODE:1CC3
BIOSCODE:1CC3 dofloppy:                               ; CODE XREF: hidensity+6↓j
BIOSCODE:1CC3                                         ; hidensity+D↓j ...
BIOSCODE:1CC3                 retn
BIOSCODE:1CC3 media_set_vid   endp
BIOSCODE:1CC3
BIOSCODE:1CC4
BIOSCODE:1CC4 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1CC4
BIOSCODE:1CC4
BIOSCODE:1CC4 hidensity       proc near               ; CODE XREF: GetBp+28↑p
BIOSCODE:1CC4                 test    word ptr es:[di+3Fh], 2 ; check for correct drive
BIOSCODE:1CC4                                         ; is it special?
BIOSCODE:1CC4                                         ; [es:di+BDS.flags], fchangeline
BIOSCODE:1CCA                 jz      short dofloppy  ; no, do normal floppy test
BIOSCODE:1CCC                 cmp     byte ptr es:[di+3Eh], 2 ; is it single-media?
BIOSCODE:1CD1                 jz      short dofloppy  ; [es:di+BDS.formfactor], ffSmall
BIOSCODE:1CD1                                         ; yes, use fatid.
BIOSCODE:1CD3                 cmp     ah, 0F9h
BIOSCODE:1CD6                 jnz     short dofloppy
BIOSCODE:1CD8                 mov     al, es:[di+3Eh] ; [es:di+BDS.formfactor]
BIOSCODE:1CDC                 cmp     al, 7           ; ffOther ?
BIOSCODE:1CDE                 jz      short Is720K
BIOSCODE:1CE0                 cmp     al, 9
BIOSCODE:1CE2                 jz      short Is720K
BIOSCODE:1CE4                 mov     al, 7           ; seven sectors / fat
BIOSCODE:1CE6                 mov     bx, 0E00Fh      ; 224*256+0Fh (57359)
BIOSCODE:1CE6                                         ; 224 root dir entries & 0Fh sector max
BIOSCODE:1CE9                 mov     cx, 2400        ; 80*15*2
BIOSCODE:1CE9                                         ; 80 tracks, 15 sectors/track, 2 sides
BIOSCODE:1CEC                 pop     dx              ; pop off return address
BIOSCODE:1CED                 mov     dx, 258         ; 1*256+2
BIOSCODE:1CED                                         ; sectors/allocation unit & head max
BIOSCODE:1CF0                 jmp     Has1            ; return to tail of getbp
BIOSCODE:1CF3 ; ---------------------------------------------------------------------------
BIOSCODE:1CF3
BIOSCODE:1CF3 Is720K:                                 ; CODE XREF: hidensity+1A↑j
BIOSCODE:1CF3                                         ; hidensity+1E↑j
BIOSCODE:1CF3                 pop     bx              ; pop off return address
BIOSCODE:1CF4                 jmp     Has720K         ; return to 720K code
BIOSCODE:1CF4 hidensity       endp ; sp-analysis failed
BIOSCODE:1CF4
BIOSCODE:1CF7
BIOSCODE:1CF7 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1CF7
BIOSCODE:1CF7
BIOSCODE:1CF7 set_changed_dl  proc near               ; CODE XREF: ChangeLineChk+26↑p
BIOSCODE:1CF7                                         ; BIOSCODE:1898↑p ...
BIOSCODE:1CF7                 push    es
BIOSCODE:1CF8                 push    di
BIOSCODE:1CF9                 les     di, dword ptr ds:start_bds
BIOSCODE:1CFD
BIOSCODE:1CFD scan_bds:                               ; CODE XREF: set_changed_dl+16↓j
BIOSCODE:1CFD                 cmp     es:[di+4], dl   ; [es:di+BDS.drivenum]
BIOSCODE:1D01                 jnz     short get_next_bds
BIOSCODE:1D03                 or      es:[di+3Fh], bx ; [es:di+BDS.flags]
BIOSCODE:1D03                                         ; signal change on other drive
BIOSCODE:1D07
BIOSCODE:1D07 get_next_bds:                           ; CODE XREF: set_changed_dl+A↑j
BIOSCODE:1D07                 les     di, es:[di]     ; [es:di+BDS.link]
BIOSCODE:1D07                                         ; go to next bds
BIOSCODE:1D0A                 cmp     di, 0FFFFh
BIOSCODE:1D0D                 jnz     short scan_bds  ; loop unless end of chain
BIOSCODE:1D0F                 pop     di
BIOSCODE:1D10                 pop     es
BIOSCODE:1D11                 retn
BIOSCODE:1D11 set_changed_dl  endp
BIOSCODE:1D11
BIOSCODE:1D12
BIOSCODE:1D12 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1D12
BIOSCODE:1D12
BIOSCODE:1D12 resetchanged    proc near               ; CODE XREF: movbpb+4C↑p
BIOSCODE:1D12                                         ; check_vid:vid_no_changed↑p ...
BIOSCODE:1D12                 and     word ptr es:[di+3Fh], 0FFBFh ; [es:di+BDS.flags], ~fchanged
BIOSCODE:1D17                 retn
BIOSCODE:1D17 resetchanged    endp
BIOSCODE:1D17
BIOSCODE:1D18
BIOSCODE:1D18 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1D18
BIOSCODE:1D18
BIOSCODE:1D18 haschange       proc near               ; CODE XREF: BIOSCODE:05F8↑p
BIOSCODE:1D18                                         ; ChangeLineChk+17↑p ...
BIOSCODE:1D18                 test    word ptr es:[di+3Fh], 2 ; [es:di+BDS.flags], fchangeline
BIOSCODE:1D1E                 retn
BIOSCODE:1D1E haschange       endp
BIOSCODE:1D1E
BIOSCODE:1D1F
BIOSCODE:1D1F ; =============== S U B R O U T I N E =======================================
BIOSCODE:1D1F
BIOSCODE:1D1F
BIOSCODE:1D1F set_volume_id   proc near               ; CODE XREF: get_bpb+2D↑p
BIOSCODE:1D1F                 push    dx
BIOSCODE:1D20                 push    ax
BIOSCODE:1D21                 call    haschange       ; does drive have changeline support?
BIOSCODE:1D24                 jz      short setvret   ; no, get out
BIOSCODE:1D26                 call    read_volume_id
BIOSCODE:1D29                 jb      short seterr
BIOSCODE:1D2B                 call    transfer_volume_id ; copy the volume id to special drive
BIOSCODE:1D2E                 call    resetchanged    ; restore value of change line
BIOSCODE:1D31
BIOSCODE:1D31 setvret:                                ; CODE XREF: set_volume_id+5↑j
BIOSCODE:1D31                 clc
BIOSCODE:1D32                 pop     ax
BIOSCODE:1D33                 pop     dx
BIOSCODE:1D34                 retn
BIOSCODE:1D35 ; ---------------------------------------------------------------------------
BIOSCODE:1D35
BIOSCODE:1D35 seterr:                                 ; CODE XREF: set_volume_id+A↑j
BIOSCODE:1D35                 pop     dx              ; pop stack but don't overwrite ax
BIOSCODE:1D36                 pop     dx
BIOSCODE:1D37                 retn
BIOSCODE:1D37 set_volume_id   endp
BIOSCODE:1D37
BIOSCODE:1D37 ; ---------------------------------------------------------------------------
BIOSCODE:1D38 root_sec        dw 0                    ; DATA XREF: read_volume_id+24↓w
BIOSCODE:1D38                                         ; read_volume_id+32↓r ...
BIOSCODE:1D38                                         ; root sector #
BIOSCODE:1D3A
BIOSCODE:1D3A ; =============== S U B R O U T I N E =======================================
BIOSCODE:1D3A
BIOSCODE:1D3A
BIOSCODE:1D3A read_volume_id  proc near               ; CODE XREF: check_vid+23↑p
BIOSCODE:1D3A                                         ; set_volume_id+7↑p
BIOSCODE:1D3A                 push    dx
BIOSCODE:1D3B                 push    cx
BIOSCODE:1D3C                 push    bx
BIOSCODE:1D3D                 push    ax
BIOSCODE:1D3E                 push    es              ; stack the bds last
BIOSCODE:1D3F                 push    di
BIOSCODE:1D40                 push    ds              ; point es to Bios_Data (BIOSDATA)
BIOSCODE:1D41                 pop     es
BIOSCODE:1D42                 mov     di, offset tmp_vid ; "NO NAME    "
BIOSCODE:1D45                 mov     si, offset nul_vid ; "NO NAME    "
BIOSCODE:1D48                 mov     cx, 11          ; (cx = 12 in MSDOS 6 IO:SYS)
BIOSCODE:1D48                                         ; initialize tmp_vid to null vi_id
BIOSCODE:1D4B                 rep movs byte ptr es:[di], byte ptr cs:[si]
BIOSCODE:1D4E                 pop     di
BIOSCODE:1D4F                 pop     es
BIOSCODE:1D50                 mov     al, es:[di+0Bh] ; [es:di+BDS.fats]
BIOSCODE:1D50                                         ; # of fats
BIOSCODE:1D54                 mov     cx, es:[di+11h] ; [es:di+BDS.fatsecs]
BIOSCODE:1D54                                         ; sectors / fat
BIOSCODE:1D58                 mul     cl
BIOSCODE:1D5A                 add     ax, es:[di+9]   ; [es:di+BDS.resectors]
BIOSCODE:1D5A                                         ; add on reserved sectors
BIOSCODE:1D5A                                         ; now, ax is sector # (0 based)
BIOSCODE:1D5E                 mov     cs:root_sec, ax
BIOSCODE:1D62                 mov     ax, es:[di+0Ch] ; [es:di+BDS.direntries]
BIOSCODE:1D62                                         ; # root dir entries
BIOSCODE:1D66                 mov     cl, 4           ; 16 entries/sector
BIOSCODE:1D68                 shr     ax, cl          ; divide by 16
BIOSCODE:1D6A                 xchg    ax, cx          ; cx is # of sectors to scan
BIOSCODE:1D6B
BIOSCODE:1D6B next_sec:                               ; CODE XREF: read_volume_id+6E↓j
BIOSCODE:1D6B                 push    cx
BIOSCODE:1D6C                 mov     ax, cs:root_sec ; get sector #
BIOSCODE:1D70                 mov     cx, es:[di+13h] ; [es:di+BDS.secpertrack]
BIOSCODE:1D70                                         ; sectors / track
BIOSCODE:1D74                 xor     dx, dx
BIOSCODE:1D76                 div     cx
BIOSCODE:1D78                 inc     dx              ; dx = sectors into track
BIOSCODE:1D78                                         ; ax = track count from 0
BIOSCODE:1D79                 mov     cl, dl          ; sector to read
BIOSCODE:1D7B                 xor     dx, dx
BIOSCODE:1D7D                 div     word ptr es:[di+15h] ; [es:di+BDS.heads]
BIOSCODE:1D7D                                         ; # heads on this disc
BIOSCODE:1D81                 mov     dh, dl          ; head number
BIOSCODE:1D83                 mov     ch, al          ; track #
BIOSCODE:1D85                 call    read_sector     ; get first sector of the root directory,
BIOSCODE:1D85                                         ; ds:bx -> directory sector
BIOSCODE:1D88                 jb      short readviderr
BIOSCODE:1D8A                 mov     cx, 16          ; # of dir entries in a block of root
BIOSCODE:1D8D                 mov     al, 8           ; volume label bit
BIOSCODE:1D8F
BIOSCODE:1D8F fvid_loop:                              ; CODE XREF: read_volume_id+66↓j
BIOSCODE:1D8F                 cmp     [bx], ch        ; 0 ; end of dir?
BIOSCODE:1D91                 jz      short no_vid    ; yes, no vol id
BIOSCODE:1D93                 cmp     byte ptr [bx], 0E5h ; empty entry?
BIOSCODE:1D96                 jz      short ent_loop  ; yes, skip
BIOSCODE:1D98                 test    [bx+0Bh], al    ; is volume label bit set in fcb?
BIOSCODE:1D9B                 jnz     short found_vid ; yes
BIOSCODE:1D9D
BIOSCODE:1D9D ent_loop:                               ; CODE XREF: read_volume_id+5C↑j
BIOSCODE:1D9D                 add     bx, 32          ; add length of directory entry
BIOSCODE:1DA0                 loop    fvid_loop
BIOSCODE:1DA2                 pop     cx              ; outer loop
BIOSCODE:1DA3                 inc     cs:root_sec     ; inc word [root_sec]
BIOSCODE:1DA3                                         ; next sector
BIOSCODE:1DA8                 loop    next_sec        ; continue
BIOSCODE:1DAA
BIOSCODE:1DAA notfound:                               ; CODE XREF: read_volume_id+8F↓j
BIOSCODE:1DAA                 xor     si, si
BIOSCODE:1DAC                 jmp     short fvid_ret
BIOSCODE:1DAE ; ---------------------------------------------------------------------------
BIOSCODE:1DAE
BIOSCODE:1DAE found_vid:                              ; CODE XREF: read_volume_id+61↑j
BIOSCODE:1DAE                 pop     cx              ; clean stack of outer loop counter
BIOSCODE:1DAF                 mov     si, bx          ; point to volume_id
BIOSCODE:1DB1                 push    es              ; preserve current bds
BIOSCODE:1DB2                 push    di
BIOSCODE:1DB3                 push    ds              ; point es to Bios_Data (BIOSDATA)
BIOSCODE:1DB4                 pop     es
BIOSCODE:1DB5                 mov     di, offset tmp_vid ; "NO NAME    "
BIOSCODE:1DB8                 mov     cx, 11          ; VOLID_SIZ-1
BIOSCODE:1DB8                                         ; length of string minus nul
BIOSCODE:1DBB                 rep movsb
BIOSCODE:1DBD                 xchg    ax, cx
BIOSCODE:1DBE                 stosb                   ; null terminate
BIOSCODE:1DBF                 xchg    ax, si
BIOSCODE:1DC0                 pop     di              ; restore current bds
BIOSCODE:1DC1                 pop     es
BIOSCODE:1DC2
BIOSCODE:1DC2 fvid_ret:                               ; CODE XREF: read_volume_id+72↑j
BIOSCODE:1DC2                 pop     ax
BIOSCODE:1DC3                 clc
BIOSCODE:1DC4
BIOSCODE:1DC4 rvidret:                                ; CODE XREF: read_volume_id+93↓j
BIOSCODE:1DC4                 pop     bx
BIOSCODE:1DC5                 pop     cx
BIOSCODE:1DC6                 pop     dx
BIOSCODE:1DC7                 retn
BIOSCODE:1DC8 ; ---------------------------------------------------------------------------
BIOSCODE:1DC8
BIOSCODE:1DC8 no_vid:                                 ; CODE XREF: read_volume_id+57↑j
BIOSCODE:1DC8                 pop     cx              ; clean stack of outer loop counter
BIOSCODE:1DC9                 jmp     short notfound
BIOSCODE:1DCB ; ---------------------------------------------------------------------------
BIOSCODE:1DCB
BIOSCODE:1DCB readviderr:                             ; CODE XREF: read_volume_id+4E↑j
BIOSCODE:1DCB                 pop     si              ; trash the outer loop counter
BIOSCODE:1DCC                 pop     si              ; caller's ax, return error code instead
BIOSCODE:1DCD                 jmp     short rvidret
BIOSCODE:1DCD read_volume_id  endp
BIOSCODE:1DCD
BIOSCODE:1DCF
BIOSCODE:1DCF ; =============== S U B R O U T I N E =======================================
BIOSCODE:1DCF
BIOSCODE:1DCF
BIOSCODE:1DCF preset_volid_addr proc near             ; CODE XREF: BIOSCODE:1DDD↓p
BIOSCODE:1DCF                                         ; check_volume_id+2↓p
BIOSCODE:1DCF                 mov     si, offset tmp_vid ; "NO NAME    "
BIOSCODE:1DD2                 add     di, 125         ; BDS.volid
BIOSCODE:1DD5                 mov     cx, 11          ; VOLID_SIZ (12 for MSDOS 5.0-6.22 versions)
BIOSCODE:1DD8                 cld
BIOSCODE:1DD9                 retn
BIOSCODE:1DD9 preset_volid_addr endp
BIOSCODE:1DD9
BIOSCODE:1DDA ; ---------------------------------------------------------------------------
BIOSCODE:1DDA
BIOSCODE:1DDA transfer_volume_id:                     ; CODE XREF: set_volume_id+C↑p
BIOSCODE:1DDA                 push    di
BIOSCODE:1DDB                 push    cx
BIOSCODE:1DDC                 push    si
BIOSCODE:1DDD                 call    preset_volid_addr
BIOSCODE:1DE0                 rep movsb
BIOSCODE:1DE2                 pop     si
BIOSCODE:1DE3 ; START OF FUNCTION CHUNK FOR check_volume_id
BIOSCODE:1DE3
BIOSCODE:1DE3 chk_volid_ok:                           ; CODE XREF: check_volume_id+7↓j
BIOSCODE:1DE3                 pop     cx
BIOSCODE:1DE4                 pop     di
BIOSCODE:1DE5                 retn
BIOSCODE:1DE5 ; END OF FUNCTION CHUNK FOR check_volume_id
BIOSCODE:1DE6
BIOSCODE:1DE6 ; =============== S U B R O U T I N E =======================================
BIOSCODE:1DE6
BIOSCODE:1DE6
BIOSCODE:1DE6 check_volume_id proc near               ; CODE XREF: check_vid+28↑p
BIOSCODE:1DE6
BIOSCODE:1DE6 ; FUNCTION CHUNK AT BIOSCODE:1DE3 SIZE 00000003 BYTES
BIOSCODE:1DE6
BIOSCODE:1DE6                 push    di
BIOSCODE:1DE7                 push    cx
BIOSCODE:1DE8                 call    preset_volid_addr
BIOSCODE:1DEB                 repe cmpsb
BIOSCODE:1DED                 jmp     short chk_volid_ok
BIOSCODE:1DED check_volume_id endp
BIOSCODE:1DED
BIOSCODE:1DEF
BIOSCODE:1DEF ; =============== S U B R O U T I N E =======================================
BIOSCODE:1DEF
BIOSCODE:1DEF
BIOSCODE:1DEF fat_check       proc near               ; CODE XREF: checkfatvid↑p
BIOSCODE:1DEF                 push    ax
BIOSCODE:1DF0                 xor     si, si          ; say fat id's are same.
BIOSCODE:1DF2                 mov     al, ds:medbyt
BIOSCODE:1DF5                 cmp     al, es:[di+10h] ; [es:di+BDS.media]
BIOSCODE:1DF5                                         ; compare it with the bds medbyte
BIOSCODE:1DF9                 jz      short okret1
BIOSCODE:1DFB                 dec     si
BIOSCODE:1DFC
BIOSCODE:1DFC okret1:                                 ; CODE XREF: fat_check+A↑j
BIOSCODE:1DFC                 pop     ax
BIOSCODE:1DFD                 retn
BIOSCODE:1DFD fat_check       endp
BIOSCODE:1DFD
BIOSCODE:1DFD ; ---------------------------------------------------------------------------
BIOSCODE:1DFE                 db 2 dup(0)
BIOSCODE:1DFE BIOSCODE        ends
BIOSCODE:1DFE
SYSINIT:0000 ; ===========================================================================
SYSINIT:0000
SYSINIT:0000 ; Segment type: Regular
SYSINIT:0000 SYSINIT         segment byte public 'SYSINIT' use16
SYSINIT:0000                 assume cs:SYSINIT
SYSINIT:0000                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
SYSINIT:0000 SYSINIT$        dw 0
SYSINIT:0002 stackcount      dw 0                    ; DATA XREF: stackinit+D↓w
SYSINIT:0002                                         ; stackinit+35↓r ...
SYSINIT:0004 stackat         dw 0                    ; DATA XREF: stackinit+3E↓w
SYSINIT:0004                                         ; stackinit+47↓r
SYSINIT:0006 stacksize       dw 0                    ; DATA XREF: stackinit+14↓w
SYSINIT:0006                                         ; stackinit+4C↓r ...
SYSINIT:0008 stacks          dw 2 dup(0)             ; DATA XREF: SYSINIT:firstentry↓o
SYSINIT:0008                                         ; stackinit+1C↓w ...
SYSINIT:000C firstentry      dw offset stacks        ; DATA XREF: do_int_stacks:foundbad02↓r
SYSINIT:000C                                         ; longpath:inuse↓r ...
SYSINIT:000E lastentry       dw 48h                  ; DATA XREF: longpath↓r
SYSINIT:000E                                         ; stackinit+87↓w
SYSINIT:000E                                         ; stacks+(defaultcount*entrysize)-entrysize
SYSINIT:0010 nextentry       dw 48h                  ; DATA XREF: do_int_stacks+8↓r
SYSINIT:0010                                         ; do_int_stacks+17↓w ...
SYSINIT:0010                                         ; stacks+(defaultcount*entrysize)-entrysize
SYSINIT:0012 old02           dd 0                    ; DATA XREF: SYSINIT:002D↓r
SYSINIT:0012                                         ; SYSINIT:0036↓o ...
SYSINIT:0016 ; ---------------------------------------------------------------------------
SYSINIT:0016
SYSINIT:0016 int02:                                  ; DATA XREF: stackinit+AF↓o
SYSINIT:0016                 push    ax
SYSINIT:0017                 push    es
SYSINIT:0018                 mov     ax, 0F000h
SYSINIT:001B                 mov     es, ax
SYSINIT:001D                 assume es:nothing
SYSINIT:001D                 cmp     byte ptr es:0FFFEh, 0F9h ; mdl_convert ; check if convertible
SYSINIT:0023                 pop     es
SYSINIT:0024                 assume es:nothing
SYSINIT:0024                 jnz     short normal02
SYSINIT:0026                 in      al, 62h         ; PC/XT PPI port C. Bits:
SYSINIT:0026                                         ; 0-3: values of DIP switches
SYSINIT:0026                                         ; 5: 1=Timer 2 channel out
SYSINIT:0026                                         ; 6: 1=I/O channel check
SYSINIT:0026                                         ; 7: 1=RAM parity check error occurred.
SYSINIT:0028                 test    al, 80h
SYSINIT:002A                 jz      short normal02
SYSINIT:002C                 pop     ax
SYSINIT:002D                 jmp     cs:old02
SYSINIT:0032 ; ---------------------------------------------------------------------------
SYSINIT:0032
SYSINIT:0032 normal02:                               ; CODE XREF: SYSINIT:0024↑j
SYSINIT:0032                                         ; SYSINIT:002A↑j
SYSINIT:0032                 pop     ax
SYSINIT:0033                 call    near ptr do_int_stacks
SYSINIT:0033 ; ---------------------------------------------------------------------------
SYSINIT:0036                 dw offset old02
SYSINIT:0038 old08           dd 0                    ; DATA XREF: SYSINIT:003F↓o
SYSINIT:0038                                         ; stackinit+BB↓o
SYSINIT:003C ; ---------------------------------------------------------------------------
SYSINIT:003C
SYSINIT:003C int08:                                  ; DATA XREF: stackinit+BE↓o
SYSINIT:003C                 call    near ptr do_int_stacks
SYSINIT:003C ; ---------------------------------------------------------------------------
SYSINIT:003F                 dw offset old08
SYSINIT:0041 old09           dd 0                    ; DATA XREF: SYSINIT:004C↓o
SYSINIT:0041                                         ; stackinit+CA↓o
SYSINIT:0045 ; ---------------------------------------------------------------------------
SYSINIT:0045
SYSINIT:0045 int09:                                  ; DATA XREF: stackinit+CD↓o
SYSINIT:0045                 jmp     short keyboard_lbl
SYSINIT:0047 ; ---------------------------------------------------------------------------
SYSINIT:0047                 nop
SYSINIT:0047 ; ---------------------------------------------------------------------------
SYSINIT:0048                 db 0
SYSINIT:0049 ; ---------------------------------------------------------------------------
SYSINIT:0049
SYSINIT:0049 keyboard_lbl:                           ; CODE XREF: SYSINIT:int09↑j
SYSINIT:0049                 call    near ptr do_int_stacks
SYSINIT:0049 ; ---------------------------------------------------------------------------
SYSINIT:004C                 dw offset old09
SYSINIT:004E old70           dd 0                    ; DATA XREF: SYSINIT:0055↓o
SYSINIT:004E                                         ; stackinit+D9↓o
SYSINIT:0052 ; ---------------------------------------------------------------------------
SYSINIT:0052
SYSINIT:0052 int70:                                  ; DATA XREF: stackinit+DC↓o
SYSINIT:0052                 call    near ptr do_int_stacks
SYSINIT:0052 ; ---------------------------------------------------------------------------
SYSINIT:0055                 dw offset old70
SYSINIT:0057 ; ---------------------------------------------------------------------------
SYSINIT:0057
SYSINIT:0057 int0A:                                  ; DATA XREF: stackinit+119↓o
SYSINIT:0057                 jmp     short entry_int0A_stk
SYSINIT:0057 ; ---------------------------------------------------------------------------
SYSINIT:0059 old0A           dd 0                    ; DATA XREF: SYSINIT:006C↓o
SYSINIT:0059                                         ; stackinit+116↓o
SYSINIT:005D                 dw 424Bh
SYSINIT:005F firstflag0A     db 0
SYSINIT:0060 ; ---------------------------------------------------------------------------
SYSINIT:0060                 jmp     short intret_0A
SYSINIT:0060 ; ---------------------------------------------------------------------------
SYSINIT:0062                 db 7 dup(0)
SYSINIT:0069 ; ---------------------------------------------------------------------------
SYSINIT:0069
SYSINIT:0069 entry_int0A_stk:                        ; CODE XREF: SYSINIT:int0A↑j
SYSINIT:0069                 call    near ptr do_int_stacks
SYSINIT:0069 ; ---------------------------------------------------------------------------
SYSINIT:006C                 dw offset old0A
SYSINIT:006E ; ---------------------------------------------------------------------------
SYSINIT:006E
SYSINIT:006E intret_0A:                              ; CODE XREF: SYSINIT:0060↑j
SYSINIT:006E                 iret
SYSINIT:006F ; ---------------------------------------------------------------------------
SYSINIT:006F
SYSINIT:006F int0B:                                  ; DATA XREF: stackinit+159↓o
SYSINIT:006F                 jmp     short entry_int0B_stk
SYSINIT:006F ; ---------------------------------------------------------------------------
SYSINIT:0071 old0B           dd 0                    ; DATA XREF: SYSINIT:0084↓o
SYSINIT:0071                                         ; stackinit+156↓o
SYSINIT:0075                 dw 424Bh
SYSINIT:0077 firstflag0B     db 0
SYSINIT:0078 ; ---------------------------------------------------------------------------
SYSINIT:0078                 jmp     short intret_0B
SYSINIT:0078 ; ---------------------------------------------------------------------------
SYSINIT:007A                 db 7 dup(0)
SYSINIT:0081 ; ---------------------------------------------------------------------------
SYSINIT:0081
SYSINIT:0081 entry_int0B_stk:                        ; CODE XREF: SYSINIT:int0B↑j
SYSINIT:0081                 call    near ptr do_int_stacks
SYSINIT:0081 ; ---------------------------------------------------------------------------
SYSINIT:0084                 dw offset old0B
SYSINIT:0086 ; ---------------------------------------------------------------------------
SYSINIT:0086
SYSINIT:0086 intret_0B:                              ; CODE XREF: SYSINIT:0078↑j
SYSINIT:0086                 iret
SYSINIT:0087 ; ---------------------------------------------------------------------------
SYSINIT:0087
SYSINIT:0087 int0C:                                  ; DATA XREF: stackinit+199↓o
SYSINIT:0087                 jmp     short entry_int0C_stk
SYSINIT:0087 ; ---------------------------------------------------------------------------
SYSINIT:0089 old0C           dd 0                    ; DATA XREF: SYSINIT:009C↓o
SYSINIT:0089                                         ; stackinit+196↓o
SYSINIT:008D                 dw 424Bh
SYSINIT:008F firstflag0C     db 0
SYSINIT:0090 ; ---------------------------------------------------------------------------
SYSINIT:0090                 jmp     short intret_0C
SYSINIT:0090 ; ---------------------------------------------------------------------------
SYSINIT:0092                 db 7 dup(0)
SYSINIT:0099 ; ---------------------------------------------------------------------------
SYSINIT:0099
SYSINIT:0099 entry_int0C_stk:                        ; CODE XREF: SYSINIT:int0C↑j
SYSINIT:0099                 call    near ptr do_int_stacks
SYSINIT:0099 ; ---------------------------------------------------------------------------
SYSINIT:009C                 dw offset old0C
SYSINIT:009E ; ---------------------------------------------------------------------------
SYSINIT:009E
SYSINIT:009E intret_0C:                              ; CODE XREF: SYSINIT:0090↑j
SYSINIT:009E                 iret
SYSINIT:009F ; ---------------------------------------------------------------------------
SYSINIT:009F
SYSINIT:009F int0D:                                  ; DATA XREF: stackinit+1D9↓o
SYSINIT:009F                 jmp     short int0D_stk
SYSINIT:009F ; ---------------------------------------------------------------------------
SYSINIT:00A1 old0D           dd 0                    ; DATA XREF: SYSINIT:00B4↓o
SYSINIT:00A1                                         ; stackinit+1D6↓o
SYSINIT:00A5                 dw 424Bh
SYSINIT:00A7 firstflag0D     db 0
SYSINIT:00A8 ; ---------------------------------------------------------------------------
SYSINIT:00A8                 jmp     short intret_0D
SYSINIT:00A8 ; ---------------------------------------------------------------------------
SYSINIT:00AA                 db 7 dup(0)
SYSINIT:00B1 ; ---------------------------------------------------------------------------
SYSINIT:00B1
SYSINIT:00B1 int0D_stk:                              ; CODE XREF: SYSINIT:int0D↑j
SYSINIT:00B1                 call    near ptr do_int_stacks
SYSINIT:00B1 ; ---------------------------------------------------------------------------
SYSINIT:00B4                 dw offset old0D
SYSINIT:00B6 ; ---------------------------------------------------------------------------
SYSINIT:00B6
SYSINIT:00B6 intret_0D:                              ; CODE XREF: SYSINIT:00A8↑j
SYSINIT:00B6                 iret
SYSINIT:00B7 ; ---------------------------------------------------------------------------
SYSINIT:00B7
SYSINIT:00B7 int0E:                                  ; DATA XREF: stackinit+219↓o
SYSINIT:00B7                 jmp     short entry_int0E_stk
SYSINIT:00B7 ; ---------------------------------------------------------------------------
SYSINIT:00B9 old0E           dd 0                    ; DATA XREF: SYSINIT:00CC↓o
SYSINIT:00B9                                         ; stackinit+216↓o
SYSINIT:00BD                 dw 424Bh
SYSINIT:00BF firstflag0E     db 0
SYSINIT:00C0 ; ---------------------------------------------------------------------------
SYSINIT:00C0                 jmp     short intret_0E
SYSINIT:00C0 ; ---------------------------------------------------------------------------
SYSINIT:00C2                 db 7 dup(0)
SYSINIT:00C9 ; ---------------------------------------------------------------------------
SYSINIT:00C9
SYSINIT:00C9 entry_int0E_stk:                        ; CODE XREF: SYSINIT:int0E↑j
SYSINIT:00C9                 call    near ptr do_int_stacks
SYSINIT:00C9 ; ---------------------------------------------------------------------------
SYSINIT:00CC                 dw offset old0E
SYSINIT:00CE ; ---------------------------------------------------------------------------
SYSINIT:00CE
SYSINIT:00CE intret_0E:                              ; CODE XREF: SYSINIT:00C0↑j
SYSINIT:00CE                 iret
SYSINIT:00CF ; ---------------------------------------------------------------------------
SYSINIT:00CF
SYSINIT:00CF int72:                                  ; DATA XREF: stackinit+259↓o
SYSINIT:00CF                 jmp     short entry_int72_stk
SYSINIT:00CF ; ---------------------------------------------------------------------------
SYSINIT:00D1 old72           dd 0                    ; DATA XREF: SYSINIT:00E4↓o
SYSINIT:00D1                                         ; stackinit+256↓o
SYSINIT:00D5                 dw 424Bh
SYSINIT:00D7 firstflag72     db 0
SYSINIT:00D8 ; ---------------------------------------------------------------------------
SYSINIT:00D8                 jmp     short intret_72
SYSINIT:00D8 ; ---------------------------------------------------------------------------
SYSINIT:00DA                 db 7 dup(0)
SYSINIT:00E1 ; ---------------------------------------------------------------------------
SYSINIT:00E1
SYSINIT:00E1 entry_int72_stk:                        ; CODE XREF: SYSINIT:int72↑j
SYSINIT:00E1                 call    near ptr do_int_stacks
SYSINIT:00E1 ; ---------------------------------------------------------------------------
SYSINIT:00E4                 dw offset old72
SYSINIT:00E6 ; ---------------------------------------------------------------------------
SYSINIT:00E6
SYSINIT:00E6 intret_72:                              ; CODE XREF: SYSINIT:00D8↑j
SYSINIT:00E6                 iret
SYSINIT:00E7 ; ---------------------------------------------------------------------------
SYSINIT:00E7
SYSINIT:00E7 int73:                                  ; DATA XREF: stackinit+299↓o
SYSINIT:00E7                 jmp     short entry_int73_stk
SYSINIT:00E7 ; ---------------------------------------------------------------------------
SYSINIT:00E9 old73           dd 0                    ; DATA XREF: SYSINIT:00FC↓o
SYSINIT:00E9                                         ; stackinit+296↓o
SYSINIT:00ED                 dw 424Bh
SYSINIT:00EF firstflag73     db 0
SYSINIT:00F0 ; ---------------------------------------------------------------------------
SYSINIT:00F0                 jmp     short intret_73
SYSINIT:00F0 ; ---------------------------------------------------------------------------
SYSINIT:00F2                 db 7 dup(0)
SYSINIT:00F9 ; ---------------------------------------------------------------------------
SYSINIT:00F9
SYSINIT:00F9 entry_int73_stk:                        ; CODE XREF: SYSINIT:int73↑j
SYSINIT:00F9                 call    near ptr do_int_stacks
SYSINIT:00F9 ; ---------------------------------------------------------------------------
SYSINIT:00FC                 dw offset old73
SYSINIT:00FE ; ---------------------------------------------------------------------------
SYSINIT:00FE
SYSINIT:00FE intret_73:                              ; CODE XREF: SYSINIT:00F0↑j
SYSINIT:00FE                 iret
SYSINIT:00FF ; ---------------------------------------------------------------------------
SYSINIT:00FF
SYSINIT:00FF int74:                                  ; DATA XREF: stackinit+2D9↓o
SYSINIT:00FF                 jmp     short entry_int74_stk
SYSINIT:00FF ; ---------------------------------------------------------------------------
SYSINIT:0101 old74           dd 0                    ; DATA XREF: SYSINIT:0114↓o
SYSINIT:0101                                         ; stackinit+2D6↓o
SYSINIT:0105                 dw 424Bh
SYSINIT:0107 firstflag74     db 0
SYSINIT:0108 ; ---------------------------------------------------------------------------
SYSINIT:0108                 jmp     short intret_74
SYSINIT:0108 ; ---------------------------------------------------------------------------
SYSINIT:010A                 db 7 dup(0)
SYSINIT:0111 ; ---------------------------------------------------------------------------
SYSINIT:0111
SYSINIT:0111 entry_int74_stk:                        ; CODE XREF: SYSINIT:int74↑j
SYSINIT:0111                 call    near ptr do_int_stacks
SYSINIT:0111 ; ---------------------------------------------------------------------------
SYSINIT:0114                 dw offset old74
SYSINIT:0116 ; ---------------------------------------------------------------------------
SYSINIT:0116
SYSINIT:0116 intret_74:                              ; CODE XREF: SYSINIT:0108↑j
SYSINIT:0116                 iret
SYSINIT:0117 ; ---------------------------------------------------------------------------
SYSINIT:0117
SYSINIT:0117 int76:                                  ; DATA XREF: stackinit+319↓o
SYSINIT:0117                 jmp     short entry_int76_stk
SYSINIT:0117 ; ---------------------------------------------------------------------------
SYSINIT:0119 old76           dd 0                    ; DATA XREF: SYSINIT:012C↓o
SYSINIT:0119                                         ; stackinit+316↓o
SYSINIT:011D                 dw 424Bh
SYSINIT:011F firstflag76     db 0
SYSINIT:0120 ; ---------------------------------------------------------------------------
SYSINIT:0120                 jmp     short intret_76
SYSINIT:0120 ; ---------------------------------------------------------------------------
SYSINIT:0122                 db 7 dup(0)
SYSINIT:0129 ; ---------------------------------------------------------------------------
SYSINIT:0129
SYSINIT:0129 entry_int76_stk:                        ; CODE XREF: SYSINIT:int76↑j
SYSINIT:0129                 call    near ptr do_int_stacks
SYSINIT:0129 ; ---------------------------------------------------------------------------
SYSINIT:012C                 dw offset old76
SYSINIT:012E ; ---------------------------------------------------------------------------
SYSINIT:012E
SYSINIT:012E intret_76:                              ; CODE XREF: SYSINIT:0120↑j
SYSINIT:012E                 iret
SYSINIT:012F ; ---------------------------------------------------------------------------
SYSINIT:012F
SYSINIT:012F int77:                                  ; DATA XREF: stackinit+359↓o
SYSINIT:012F                 jmp     short entry_int77_stk
SYSINIT:012F ; ---------------------------------------------------------------------------
SYSINIT:0131 old77           dd 0                    ; DATA XREF: SYSINIT:0144↓o
SYSINIT:0131                                         ; stackinit+356↓o
SYSINIT:0135                 dw 424Bh
SYSINIT:0137 firstflag77     db 0
SYSINIT:0138 ; ---------------------------------------------------------------------------
SYSINIT:0138                 jmp     short intret_77
SYSINIT:0138 ; ---------------------------------------------------------------------------
SYSINIT:013A                 db 7 dup(0)
SYSINIT:0141 ; ---------------------------------------------------------------------------
SYSINIT:0141
SYSINIT:0141 entry_int77_stk:                        ; CODE XREF: SYSINIT:int77↑j
SYSINIT:0141                 call    near ptr do_int_stacks
SYSINIT:0141 ; ---------------------------------------------------------------------------
SYSINIT:0144                 dw offset old77
SYSINIT:0146 ; ---------------------------------------------------------------------------
SYSINIT:0146
SYSINIT:0146 intret_77:                              ; CODE XREF: SYSINIT:0138↑j
SYSINIT:0146                 iret
SYSINIT:0147
SYSINIT:0147 ; =============== S U B R O U T I N E =======================================
SYSINIT:0147
SYSINIT:0147
SYSINIT:0147 do_int_stacks   proc far                ; CODE XREF: SYSINIT:0033↑p
SYSINIT:0147                                         ; SYSINIT:int08↑p ...
SYSINIT:0147                 push    ax
SYSINIT:0148                 push    bp
SYSINIT:0149                 push    es
SYSINIT:014A                 mov     es, cs:stacks+2 ; Get segment of stacks
SYSINIT:014F                 assume es:nothing
SYSINIT:014F                 mov     bp, cs:nextentry ; get most likely candidate
SYSINIT:0154                 mov     al, 1           ; allocated
SYSINIT:0156                 xchg    al, es:[bp+0]   ; grab the entry
SYSINIT:015A                 cmp     al, 0           ; free ; still avail?
SYSINIT:015C                 jnz     short notfree02
SYSINIT:015E                 sub     cs:nextentry, 8 ; entrysize ; set for next interrupt
SYSINIT:0164
SYSINIT:0164 found02:                                ; CODE XREF: do_int_stacks+73↓j
SYSINIT:0164                 mov     es:[bp+2], sp   ; [es:bp+savedsp],sp ; save sp value
SYSINIT:0168                 mov     word ptr es:[bp+4], ss ; [es:bp+savedss],ss ; save ss also
SYSINIT:016C                 mov     ax, bp          ; temp save of table offset
SYSINIT:016E                 mov     bp, es:[bp+6]   ; [es:bp+newsp] ; get new SP value
SYSINIT:0172                 cmp     es:[bp+0], ax   ; check for offset into table
SYSINIT:0176                 jnz     short foundbad02
SYSINIT:0178                 mov     ax, es          ; point ss,sp to the new stack
SYSINIT:017A                 mov     es, bp
SYSINIT:017C                 assume es:nothing
SYSINIT:017C                 mov     bp, sp
SYSINIT:017E                 mov     bp, [bp+6]
SYSINIT:0181                 mov     ss, ax
SYSINIT:0183                 assume ss:nothing
SYSINIT:0183                 mov     sp, es
SYSINIT:0185                 mov     es, ax
SYSINIT:0187                 assume es:nothing
SYSINIT:0187                 mov     bp, cs:[bp+0]
SYSINIT:018B                 pushf                   ; go execute the real interrupt handler
SYSINIT:018C                 call    dword ptr cs:[bp+0] ; which will iret back to here
SYSINIT:018C                                         ; call far [cs:bp]
SYSINIT:0190                 mov     bp, sp          ; retrieve the table offset for us
SYSINIT:0192                 mov     bp, es:[bp+0]   ; but leave it on the stack
SYSINIT:0196                 mov     ss, word ptr es:[bp+4] ; [es:bp+savedss] ; get old stack back
SYSINIT:019A                 assume ss:nothing
SYSINIT:019A                 mov     sp, es:[bp+2]   ; [es:bp+savedsp]
SYSINIT:019E                 mov     byte ptr es:[bp+0], 0 ; [es:bp+allocbyte],free ; free the entry
SYSINIT:01A3                 mov     cs:nextentry, bp ; setup to use next time
SYSINIT:01A8                 pop     es              ; saved on entry
SYSINIT:01A9                 assume es:nothing
SYSINIT:01A9                 pop     bp              ; saved on entry
SYSINIT:01AA                 pop     ax              ; saved on entry
SYSINIT:01AB                 add     sp, 2           ; (skip near call return addr)
SYSINIT:01AE                 iret                    ; done with this interrupt
SYSINIT:01AF ; ---------------------------------------------------------------------------
SYSINIT:01AF
SYSINIT:01AF notfree02:                              ; CODE XREF: do_int_stacks+15↑j
SYSINIT:01AF                 cmp     al, 1           ; allocated ; error flag
SYSINIT:01B1                 jz      short findnext02 ; no, continue
SYSINIT:01B3                 xchg    al, es:[bp+0]   ; [es:bp+allocbyte] ; yes, restore error value
SYSINIT:01B7
SYSINIT:01B7 findnext02:                             ; CODE XREF: do_int_stacks+6A↑j
SYSINIT:01B7                                         ; do_int_stacks+7A↓j ...
SYSINIT:01B7                 call    longpath
SYSINIT:01BA                 jmp     short found02
SYSINIT:01BC ; ---------------------------------------------------------------------------
SYSINIT:01BC
SYSINIT:01BC foundbad02:                             ; CODE XREF: do_int_stacks+2F↑j
SYSINIT:01BC                 cmp     bp, cs:firstentry
SYSINIT:01C1                 jb      short findnext02
SYSINIT:01C3                 mov     bp, ax          ; flag this entry
SYSINIT:01C5                 mov     byte ptr es:[bp+0], 3 ; clobbered
SYSINIT:01CA                 jmp     short findnext02 ; keep looking
SYSINIT:01CA do_int_stacks   endp
SYSINIT:01CA
SYSINIT:01CC
SYSINIT:01CC ; =============== S U B R O U T I N E =======================================
SYSINIT:01CC
SYSINIT:01CC
SYSINIT:01CC longpath        proc near               ; CODE XREF: do_int_stacks:findnext02↑p
SYSINIT:01CC                 mov     bp, cs:lastentry ; start with last entry in table
SYSINIT:01D1
SYSINIT:01D1 lploopp:                                ; CODE XREF: longpath+28↓j
SYSINIT:01D1                 cmp     byte ptr es:[bp+0], 0 ; free ?
SYSINIT:01D6                 jnz     short inuse     ; no, try next one
SYSINIT:01D8                 mov     al, 1
SYSINIT:01DA                 xchg    al, es:[bp+0]   ; [es:bp+allocbyte] ; allocate entry
SYSINIT:01DE                 cmp     al, 0           ; is it still free?
SYSINIT:01E0                 jz      short found     ; yes, go use it
SYSINIT:01E2                 cmp     al, 1           ; allocated ?
SYSINIT:01E2                                         ; is it other than Allocated or Free?
SYSINIT:01E4                 jz      short inuse     ; no, check the next one
SYSINIT:01E6                 mov     es:[bp+0], al   ; yes, put back the error state
SYSINIT:01EA
SYSINIT:01EA inuse:                                  ; CODE XREF: longpath+A↑j
SYSINIT:01EA                                         ; longpath+18↑j
SYSINIT:01EA                 cmp     bp, cs:firstentry
SYSINIT:01EF                 jz      short fatal
SYSINIT:01F1                 sub     bp, 8
SYSINIT:01F4                 jmp     short lploopp
SYSINIT:01F6 ; ---------------------------------------------------------------------------
SYSINIT:01F6
SYSINIT:01F6 found:                                  ; CODE XREF: longpath+14↑j
SYSINIT:01F6                 retn
SYSINIT:01F7 ; ---------------------------------------------------------------------------
SYSINIT:01F7
SYSINIT:01F7 fatal:                                  ; CODE XREF: longpath+23↑j
SYSINIT:01F7                 push    ds
SYSINIT:01F8                 mov     ax, 0F000h      ; look at the model byte
SYSINIT:01FB                 mov     ds, ax
SYSINIT:01FD                 assume ds:nothing
SYSINIT:01FD                 cmp     byte ptr ds:0FFFEh, 0F9h ; mdl_convert ; convertible?
SYSINIT:0202                 pop     ds
SYSINIT:0203                 assume ds:nothing
SYSINIT:0203                 jnz     short skip_nmis
SYSINIT:0205                 mov     al, 7           ; disable pc convertible nmis
SYSINIT:0207                 out     72h, al         ; CMOS Memory/RTC Index Register (Extended RAM)
SYSINIT:0209
SYSINIT:0209 skip_nmis:                              ; CODE XREF: longpath+37↑j
SYSINIT:0209                 cli                     ; disable and mask
SYSINIT:020A                 mov     al, 0FFh        ; all other ints
SYSINIT:020C                 out     21h, al         ; Interrupt controller, 8259A.
SYSINIT:020E                 out     0A1h, al        ; Interrupt Controller #2, 8259A
SYSINIT:0210                 mov     si, cs
SYSINIT:0212                 mov     ds, si
SYSINIT:0214                 assume ds:SYSINIT
SYSINIT:0214                 mov     si, offset fatal_msg ; "\r\n\a\r\nInternal stack overflow\r\nSy"...
SYSINIT:0217                 push    ax
SYSINIT:0218                 push    ds
SYSINIT:0219                 mov     ax, 70h         ; DOSBIODATASEG (BIOSDATA segment)
SYSINIT:021C                 mov     ds, ax
SYSINIT:021E                 assume ds:nothing
SYSINIT:021E                 test    ds:IsWin386, 1  ; BIOSDATA:0812h
SYSINIT:0223                 pop     ds
SYSINIT:0224                 assume ds:nothing
SYSINIT:0224                 pop     ax
SYSINIT:0225                 jz      short fatal_loop
SYSINIT:0227                 call    far ptr 70h:813h ; call DOSBIODATASEG:V86_Crit_SetFocus
SYSINIT:022C
SYSINIT:022C fatal_loop:                             ; CODE XREF: longpath+59↑j
SYSINIT:022C                                         ; longpath+6B↓j
SYSINIT:022C                 lodsb
SYSINIT:022D                 cmp     al, 24h ; '$'
SYSINIT:022F                 jz      short fatal_done
SYSINIT:0231                 mov     bl, 7
SYSINIT:0233                 mov     ah, 0Eh
SYSINIT:0235                 int     10h             ; (whoops, this enables ints)
SYSINIT:0235                                         ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
SYSINIT:0235                                         ; AL = character, BH = display page (alpha modes)
SYSINIT:0235                                         ; BL = foreground color (graphics modes)
SYSINIT:0237                 jmp     short fatal_loop
SYSINIT:0239 ; ---------------------------------------------------------------------------
SYSINIT:0239
SYSINIT:0239 fatal_done:                             ; CODE XREF: longpath+63↑j
SYSINIT:0239                                         ; longpath:fatal_done↓j
SYSINIT:0239                 jmp     short fatal_done
SYSINIT:0239 longpath        endp
SYSINIT:0239
SYSINIT:0239 ; ---------------------------------------------------------------------------
SYSINIT:023B fatal_msg       db 0Dh,0Ah              ; DATA XREF: longpath+48↑o
SYSINIT:023B                 db 7,0Dh,0Ah
SYSINIT:023B                 db 'Internal stack overflow',0Dh,0Ah
SYSINIT:023B                 db 'System halted',0Dh,0Ah,'$'
SYSINIT:0269 ; ---------------------------------------------------------------------------
SYSINIT:0269
SYSINIT:0269 _SYSINIT:                               ; DATA XREF: endfile+285↓o
SYSINIT:0269                 jmp     goinit
SYSINIT:0269 ; ---------------------------------------------------------------------------
SYSINIT:026C runhigh         db 0                    ; DATA XREF: SYSINIT:0823↓r
SYSINIT:026C                                         ; SYSINIT:dolast↓r ...
SYSINIT:026D DOSINFO         dd 0                    ; DATA XREF: SYSINIT:05A5↓w
SYSINIT:026D                                         ; SYSINIT:NoRPLArena↓r ...
SYSINIT:026D                                         ; address of the DOS Sysini Variables
SYSINIT:0271 dosinit         dw 0                    ; DATA XREF: SYSINIT:0543↓w
SYSINIT:0271                                         ; SYSINIT:058A↓r ...
SYSINIT:0273 CURRENTDOSLOCATION dw 0                 ; DATA XREF: BIOSDATA:1F84↑w
SYSINIT:0273                                         ; BIOSDATA:2429↑r ...
SYSINIT:0275 DEVICE_LIST     dd 0                    ; DATA XREF: BIOSDATA:1F71↑w
SYSINIT:0275                                         ; SYSINIT:0577↓r ...
SYSINIT:0279 sysi_country    dd 0                    ; DATA XREF: SYSINIT:05B5↓w
SYSINIT:0279                                         ; doconf:tryq_set_for_dos↓r ...
SYSINIT:0279                                         ; pointer to country table in dos
SYSINIT:027D dos_segreinit   dd 0                    ; DATA XREF: SYSINIT:059D↓w
SYSINIT:027D                                         ; SYSINIT:0832↓r ...
SYSINIT:027D                                         ; room for dword
SYSINIT:0281 lo_doscod_size  dw 0                    ; DATA XREF: SYSINIT:0598↓w
SYSINIT:0281                                         ; MovDOSLo+8↓r ...
SYSINIT:0281                                         ; dos code size when in low mem
SYSINIT:0283 hi_doscod_size  dw 0                    ; DATA XREF: SYSINIT:0594↓w
SYSINIT:0283                                         ; MovDOSHi+D↓r
SYSINIT:0283                                         ; dos code size when in HMA
SYSINIT:0285 def_php         dw 0                    ; DATA XREF: SYSINIT:058F↓w
SYSINIT:0285                                         ; SYSINIT:06E6↓r
SYSINIT:0287 _seg_reinit_ptr dw offset _seg_reinit   ; DATA XREF: SYSINIT:056D↓r
SYSINIT:0287                                         ; MovBIOS+1B↓r
SYSINIT:0287                                         ; BIOSCODE:0032h
SYSINIT:0289 temp_bcode_seg  dw 364h                 ; DATA XREF: SYSINIT:0556↓w
SYSINIT:0289                                         ; MovBIOS↓r
SYSINIT:0289                                         ; DOSBIOCODESEG (BIOSCODE)
SYSINIT:028B fake_floppy_drv db 0                    ; DATA XREF: SYSINIT:0466↓w
SYSINIT:028B                                         ; fooset+1F↓r
SYSINIT:028B                                         ; set to 1 if this machine
SYSINIT:028B                                         ; does not have any floppies!!!
SYSINIT:028C stack_count     dw 9                    ; DATA XREF: endfile:doinstallstack↓r
SYSINIT:028C                                         ; endfile+2BF↓r ...
SYSINIT:028C                                         ; defaultcount ; 9
SYSINIT:028E stack_size      dw 128                  ; DATA XREF: endfile+2BA↓r
SYSINIT:028E                                         ; stackinit+11↓r ...
SYSINIT:028E                                         ; defaultsize  ; 128
SYSINIT:0290 stack_addr      dw 2 dup(0)             ; DATA XREF: endfile+256↓r
SYSINIT:0290                                         ; endfile+2A5↓w ...
SYSINIT:0294 MEMORY_SIZE     dw 1                    ; DATA XREF: BIOSDATA:1F7B↑w
SYSINIT:0294                                         ; BIOSDATA:1F96↑r ...
SYSINIT:0296 RPLMemTop       dw 0                    ; DATA XREF: SYSINIT:04A5↓w
SYSINIT:0296                                         ; SYSINIT:05CB↓r ...
SYSINIT:0298 DEFAULT_DRIVE   db 0                    ; DATA XREF: BIOSDATA:1F80↑w
SYSINIT:0298                                         ; remap+60↑w ...
SYSINIT:0298                                         ; initialized by ibminit
SYSINIT:0299 buffers         dw 0FFFFh               ; DATA XREF: endfile+102↓r
SYSINIT:0299                                         ; endfile+112↓w ...
SYSINIT:0299                                         ; initialized during buffer allocation
SYSINIT:029B h_buffers       dw 0                    ; DATA XREF: endfile:dodefaultbuff↓w
SYSINIT:029B                                         ; endfile+1AF↓r ...
SYSINIT:029B                                         ; # of the heuristic buffers. initially 0.
SYSINIT:029D singlebuffersize dw 0                   ; DATA XREF: SYSINIT:0643↓w
SYSINIT:029D                                         ; SYSINIT:068A↓r ...
SYSINIT:029D                                         ; maximum sector size + buffer head
SYSINIT:029F FILES           db 8                    ; DATA XREF: endfile+31↓r
SYSINIT:029F                                         ; endfile:dosdata_noumb↓r ...
SYSINIT:029F                                         ; enough files for pipe
SYSINIT:02A0 FCBS            db 4                    ; DATA XREF: endfile+95↓r
SYSINIT:02A0                                         ; doconf+9B5↓w
SYSINIT:02A0                                         ; performance for recycling
SYSINIT:02A1 KEEP            db 0                    ; DATA XREF: endfile+B0↓r
SYSINIT:02A1                                         ; doconf+9B9↓w
SYSINIT:02A1                                         ; keep original set
SYSINIT:02A2 NUM_CDS         db 5                    ; DATA XREF: endfile+211↓r
SYSINIT:02A2                                         ; endfile+218↓r ...
SYSINIT:02A2                                         ; 5 net drives
SYSINIT:02A3 CONFBOT         dw 0                    ; DATA XREF: SYSINIT:06A9↓w
SYSINIT:02A3                                         ; endfile+14↓r ...
SYSINIT:02A5 ALLOCLIM        dw 0                    ; DATA XREF: SYSINIT:06A5↓w
SYSINIT:02A5                                         ; endfile+18↓w ...
SYSINIT:02A7 top_of_cdss     dw 0                    ; DATA XREF: SYSINIT:069A↓w
SYSINIT:02A7                                         ; TempCDS+17↓r
SYSINIT:02A9 DirStrng        db 'A:\',0              ; DATA XREF: fooset↓r
SYSINIT:02A9                                         ; fooset+D↓w ...
SYSINIT:02A9                                         ; string for the root directory of a drive
SYSINIT:02AD ZERO            db 0                    ; DATA XREF: SYSINIT:EXEC0_6C_FCB↓o
SYSINIT:02AE sepchr          db 0                    ; DATA XREF: check_switch+3F↓w
SYSINIT:02AE                                         ; check_switch+48↓w ...
SYSINIT:02AF linecount       dw 0                    ; DATA XREF: multi_pass+1C↓w
SYSINIT:02AF                                         ; doconf+CB↓w ...
SYSINIT:02AF                                         ; line count in config.sys
SYSINIT:02B1 showcount       db '     ',0Dh,0Ah,'$'  ; DATA XREF: showlinenum+7↓o
SYSINIT:02B1                                         ; used to convert linecount to ascii.
SYSINIT:02B9 buffer_linenum  dw 0                    ; DATA XREF: doconf+22D↓w
SYSINIT:02B9                                         ; line count for "buffers=" command if entered.
SYSINIT:02BB sys_model_byte  db 0FFh                 ; DATA XREF: SYSINIT:0428↓w
SYSINIT:02BB                                         ; SYSINIT:043E↓w ...
SYSINIT:02BB                                         ; model byte used in sysinit
SYSINIT:02BC sys_scnd_model_byte db 0                ; DATA XREF: SYSINIT:0430↓w
SYSINIT:02BC                                         ; endfile+25D↓r
SYSINIT:02BC                                         ; secondary model byte used in sysinit
SYSINIT:02BD buf_prev_off    dw 0                    ; DATA XREF: set_buffer_info↓r
SYSINIT:02BD                                         ; set_buffer_info+9↓w
SYSINIT:02BF EXEC0_ENVIRON   dw 0                    ; DATA XREF: SYSINIT:09D6↓o
SYSINIT:02BF                                         ; COMEXE  ; seg addr of environment
SYSINIT:02C1 EXEC0_COM_LINE  dw offset command_line  ; pointer to asciz command line
SYSINIT:02C3                 dw 544h                 ; SYSINIT segment
SYSINIT:02C5 EXEC0_5C_FCB    dw offset DEFAULT_DRIVE
SYSINIT:02C7                 dw 544h                 ; SYSINIT segment
SYSINIT:02C9 EXEC0_6C_FCB    dw offset ZERO
SYSINIT:02CB                 dw 544h                 ; SYSINIT segment
SYSINIT:02CD multi_pass_id   db 0                    ; DATA XREF: SYSINIT:skip_magicbackdoor↓w
SYSINIT:02CD                                         ; SYSINIT:0873↓w ...
SYSINIT:02CD                                         ; parameter passed to multi_pass
SYSINIT:02CD                                         ; indicating the pass number
SYSINIT:02CD                                         ;  0 - do scan for DOS=HIGH/LOW
SYSINIT:02CD                                         ;  1 - load device drivers
SYSINIT:02CD                                         ;  2 - was to load IFS
SYSINIT:02CD                                         ;      now it is unused
SYSINIT:02CD                                         ;  3 - do install=
SYSINIT:02CD                                         ; >3 - nop
SYSINIT:02CE install_flag    dw 0                    ; DATA XREF: SYSINIT:08A4↓r
SYSINIT:02CE                                         ; SYSINIT:08DA↓r ...
SYSINIT:02CE                                         ; bit 0 - config.sys has install= commands
SYSINIT:02CE                                         ; bit 1 - sysinit_base installed
SYSINIT:02D0 config_size     dw 0                    ; DATA XREF: sum_up+B↓r
SYSINIT:02D0                                         ; doconf+3F↓w
SYSINIT:02D0                                         ; size of config.sys file
SYSINIT:02D2 sysinit_base_ptr dd 0                   ; DATA XREF: endfile+40E↓w
SYSINIT:02D2                                         ; do_install_exec+70↓r ...
SYSINIT:02D2                                         ; pointer to sysinit_base
SYSINIT:02D6 sysinit_ptr     dw 2 dup(0)             ; DATA XREF: endfile+427↓w
SYSINIT:02D6                                         ; SYSINIT:sysinit_base_end↓r ...
SYSINIT:02D6                                         ; returning address from sysinit_base
SYSINIT:02DA checksum        dw 0                    ; DATA XREF: do_install_exec+63↓w
SYSINIT:02DA                                         ; SYSINIT:1458↓r
SYSINIT:02DA                                         ; used by sum_up
SYSINIT:02DC ldexec_fcb      db 14h dup(20h)         ; DATA XREF: SYSINIT:iexec_ldexec_5c_fcb↓o
SYSINIT:02DC                                         ; SYSINIT:iexec_ldexec_6c_fcb↓o
SYSINIT:02DC                                         ; db 20 dup (' ') ; big enough
SYSINIT:02F0 ldexec_line     db 0                    ; DATA XREF: SYSINIT:iexec_ldexec_line↓o
SYSINIT:02F0                                         ; do_install_exec:done_installparm↓w
SYSINIT:02F0                                         ; # of parm characters
SYSINIT:02F1 ldexec_start    db ' '                  ; DATA XREF: do_install_exec+A↓w
SYSINIT:02F1                                         ; do_install_exec+31↓w
SYSINIT:02F2 ldexec_parm     db 80 dup(  0)          ; DATA XREF: do_install_exec+10↓o
SYSINIT:02F2                                         ; times 80 db 0
SYSINIT:0342 iexec_environ   dw 0                    ; DATA XREF: do_install_exec:no_envdata2↓w
SYSINIT:0342                                         ; do_install_exec+6B↓o
SYSINIT:0342                                         ; instexe ; seg addr of environment
SYSINIT:0344 iexec_ldexec_line dw offset ldexec_line ; pointer to asciiz command line
SYSINIT:0346 iexec_ldexec_line_seg dw 544h           ; DATA XREF: do_install_exec+54↓w
SYSINIT:0348 iexec_ldexec_5c_fcb dw offset ldexec_fcb ; default fcb at 5Ch
SYSINIT:034A iexec_ldexec_5c_fcb_seg dw 544h         ; DATA XREF: do_install_exec+58↓w
SYSINIT:034C iexec_ldexec_6c_fcb dw offset ldexec_fcb ; default fcb at 6Ch
SYSINIT:034E iexec_ldexec_6c_fcb_seg dw 544h         ; DATA XREF: do_install_exec+5C↓w
SYSINIT:0350 com_level       db 0                    ; DATA XREF: organize+D↓w
SYSINIT:0350                                         ; organize+26↓w ...
SYSINIT:0350                                         ; level of " " in command line
SYSINIT:0351 cmmt            db 0                    ; DATA XREF: organize+151↓w
SYSINIT:0351                                         ; organize+16E↓w ...
SYSINIT:0351                                         ; length of comment string token
SYSINIT:0352 cmmt1           db 0                    ; DATA XREF: organize+14D↓w
SYSINIT:0352                                         ; skip_comment+15↓r
SYSINIT:0352                                         ; token
SYSINIT:0353 cmmt2           db 0                    ; DATA XREF: organize+16A↓w
SYSINIT:0353                                         ; skip_comment+28↓r
SYSINIT:0353                                         ; token
SYSINIT:0354 cmd_indicator   db 0                    ; DATA XREF: organize+99↓w
SYSINIT:0354                                         ; organize:org3↓r ...
SYSINIT:0355 donotshownum    db 0                    ; DATA XREF: SYSINIT:ConfigDone↓w
SYSINIT:0355                                         ; badfil+22↓r
SYSINIT:0356 count           dw 0                    ; DATA XREF: doconf+2E↓w
SYSINIT:0356                                         ; doconf+3C↓r ...
SYSINIT:0358 org_count       dw 0                    ; DATA XREF: multi_pass+E↓r
SYSINIT:0358                                         ; SYSINIT:44BD↓w ...
SYSINIT:035A chrptr          dw 0                    ; DATA XREF: multi_pass+18↓w
SYSINIT:035A                                         ; doconf:multi_pass_adjust↓w ...
SYSINIT:035C cntryfilehandle dw 0                    ; DATA XREF: doconf+748↓w
SYSINIT:035C                                         ; doconf:coffj4↓r
SYSINIT:035E old_area        dw 0                    ; DATA XREF: SYSINIT:08E5↓r
SYSINIT:035E                                         ; endfile+440↓w
SYSINIT:0360 impossible_owner_size dw 0              ; DATA XREF: SYSINIT:08EA↓r
SYSINIT:0360                                         ; endfile+3F9↓w
SYSINIT:0360                                         ; paragraph
SYSINIT:0362 memlo           dw 0                    ; DATA XREF: endfile+42↓r
SYSINIT:0362                                         ; endfile+5B↓r ...
SYSINIT:0362                                         ; bufptr, bucketptr (dword)
SYSINIT:0364 memhi           dw 0                    ; DATA XREF: SYSINIT:wfk2s_8↓r
SYSINIT:0364                                         ; AllocFreeMem+F↓w ...
SYSINIT:0364                                         ; prmblk (word)
SYSINIT:0366 ldoff           dw 0
SYSINIT:0368 area            dw 0                    ; DATA XREF: SYSINIT:07E3↓r
SYSINIT:0368                                         ; SYSINIT:07F1↓r ...
SYSINIT:036A prev_memhi      dw 0                    ; DATA XREF: endfile+22↓w
SYSINIT:036A                                         ; endfile+313↓r ...
SYSINIT:036C prev_alloclim   dw 0                    ; DATA XREF: endfile+2A↓w
SYSINIT:036C                                         ; endfile+35F↓r
SYSINIT:036E dosdata_umb     db 0                    ; DATA XREF: endfile+2DE↓r
SYSINIT:036E                                         ; endfile+352↓w ...
SYSINIT:036F packet          db 25                   ; DATA XREF: MagicPreload+4D↓o
SYSINIT:036F                                         ; calldev+15↓o
SYSINIT:036F                                         ; was 24 (in MSDOS 6.21)
SYSINIT:0370                 db 0
SYSINIT:0371                 db 0                    ; initialize code
SYSINIT:0372                 dw 0
SYSINIT:0374                 db 8 dup(0)
SYSINIT:037C unitcount       db 0                    ; DATA XREF: MagicPreload:_isblock↓r
SYSINIT:037C                                         ; doconf:isblock↓r
SYSINIT:037D break_addr      dw 2 dup(0)             ; DATA XREF: MagicPreload+50↓w
SYSINIT:037D                                         ; MagicPreload:magic_is_resident↓r ...
SYSINIT:0381 bpb_addr        dd 0                    ; DATA XREF: MagicPreload+11D↓r
SYSINIT:0381                                         ; MagicPostload+24↓w ...
SYSINIT:0385 devdrivenum     db 0                    ; DATA XREF: MagicPreload+63↓w
SYSINIT:0385                                         ; doconf+476↓w
SYSINIT:0386 configmsgflag   db 0                    ; DATA XREF: doconf+481↓w
SYSINIT:0386                                         ; doconf+4E0↓r ...
SYSINIT:0386                                         ; used to control "error in config.sys line #" message
SYSINIT:0386                                         ; (configmsgflag is the last word of the 25 byte packet)
SYSINIT:0386                                         ; ((default value is 0, device driver init may change? it))
SYSINIT:0387                 db 0
SYSINIT:0388 drivenumber     db 0                    ; DATA XREF: SYSINIT:0681↓w
SYSINIT:0388                                         ; MagicPreload+5F↓r ...
SYSINIT:0389 toomanydrivesflag db 0                  ; DATA XREF: dmax_check+D↑w
SYSINIT:0389                                         ; SYSINIT:0716↓r
SYSINIT:0389                                         ; >24 fixed disk partitions flag
SYSINIT:038A BCodeSeg        dw 364h                 ; DATA XREF: MovBIOS+17↓w
SYSINIT:038A                                         ; DOSBIOCODESEG (BIOSCODE segment)
SYSINIT:038C _timer_lw_      dw 0                    ; DATA XREF: SYSINIT:073C↓w
SYSINIT:038C                                         ; kbd_read+1D↓r
SYSINIT:038E F5_key          db 0                    ; DATA XREF: SYSINIT:07C7↓w
SYSINIT:038E                                         ; SYSINIT:084E↓r ...
SYSINIT:038F F8_key          db 0                    ; DATA XREF: SYSINIT:wfk2s_5↓w
SYSINIT:038F                                         ; SYSINIT:0856↓r ...
SYSINIT:0390 MagicBackdoor   dd 0                    ; DATA XREF: SYSINIT:0747↓w
SYSINIT:0390                                         ; SYSINIT:0860↓r ...
SYSINIT:0394 ; ---------------------------------------------------------------------------
SYSINIT:0394
SYSINIT:0394 NullBackdoor:                           ; DATA XREF: SYSINIT:0747↓o
SYSINIT:0394                                         ; MagicPreload+88↓o
SYSINIT:0394                 retf
SYSINIT:0394 ; ---------------------------------------------------------------------------
SYSINIT:0395 BiosComBlock    dw offset SysinitPresent
SYSINIT:0395                                         ; DATA XREF: SYSINIT:0572↓r
SYSINIT:0395                                         ; BIOSDATA:07DDh
SYSINIT:0397                 dw 70h                  ; BIOSDATA segment
SYSINIT:0399 tempstack       db 128 dup(0)
SYSINIT:0419 ; ---------------------------------------------------------------------------
SYSINIT:0419
SYSINIT:0419 goinit:                                 ; CODE XREF: SYSINIT:_SYSINIT↑j
SYSINIT:0419                 mov     ah, 0C0h
SYSINIT:041B                 int     15h             ; SYSTEM - GET CONFIGURATION
SYSINIT:041B                                         ; (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
SYSINIT:041D                 jb      short no_rom_config
SYSINIT:041F                 cmp     ah, 0
SYSINIT:0422                 jnz     short no_rom_config
SYSINIT:0424                 mov     al, es:[bx+2]   ; [es:bx+ROMBIOS_DESC.bios_sd_modelbyte]
SYSINIT:0428                 mov     cs:sys_model_byte, al
SYSINIT:042C                 mov     al, es:[bx+3]   ; [es:bx+ROMBIOS_DESC.bios_sd_scnd_modelbyte]
SYSINIT:0430                 mov     cs:sys_scnd_model_byte, al
SYSINIT:0434                 jmp     short move_myself
SYSINIT:0436 ; ---------------------------------------------------------------------------
SYSINIT:0436
SYSINIT:0436 no_rom_config:                          ; CODE XREF: SYSINIT:041D↑j
SYSINIT:0436                                         ; SYSINIT:0422↑j
SYSINIT:0436                 mov     ax, 0F000h
SYSINIT:0439                 mov     ds, ax
SYSINIT:043B                 assume ds:nothing
SYSINIT:043B                 mov     al, ds:0FFFEh
SYSINIT:043E                 mov     cs:sys_model_byte, al
SYSINIT:0442                 int     11h             ; EQUIPMENT DETERMINATION
SYSINIT:0442                                         ; Return: AX = equipment flag bits
SYSINIT:0444                 jmp     short check_for_fake_floppy
SYSINIT:0444 ; ---------------------------------------------------------------------------
SYSINIT:0446                 db  52h ; R             ; 'RPS' sign
SYSINIT:0447                 db  50h ; P
SYSINIT:0448                 db  53h ; S
SYSINIT:0449 ; ---------------------------------------------------------------------------
SYSINIT:0449
SYSINIT:0449 check_for_fake_floppy:                  ; CODE XREF: SYSINIT:0444↑j
SYSINIT:0449                 or      ax, 1           ; (nonsense! this may be overwritten/disabled
SYSINIT:0449                                         ; by using 'RPS' sign position) 03/07/2023 - Erdogan Tan
SYSINIT:044C                 test    ax, 1           ; have any floppies?
SYSINIT:044F                 jnz     short move_myself ; yes,normal system
SYSINIT:0451                 push    es
SYSINIT:0452                 xor     cl, cl
SYSINIT:0454                 mov     ah, 8           ; get disk parameters
SYSINIT:0456                 mov     dl, 0
SYSINIT:0458                 int     13h             ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
SYSINIT:0458                                         ; DL = drive number
SYSINIT:0458                                         ; Return: CF set on error, AH = status code, BL = drive type
SYSINIT:0458                                         ; DL = number of consecutive drives
SYSINIT:0458                                         ; DH = maximum value for head number, ES:DI -> drive parameter
SYSINIT:045A                 pop     es
SYSINIT:045B                 jb      short move_myself ; if error lets assume that the ROM BIOS lied
SYSINIT:045D                 cmp     cl, 0           ; double check (max sec no cannot be 0)
SYSINIT:0460                 jz      short move_myself
SYSINIT:0462                 or      dl, dl          ; number of flp drvs == 0?
SYSINIT:0464                 jnz     short move_myself
SYSINIT:0466                 mov     cs:fake_floppy_drv, 1 ; set fake flag
SYSINIT:046C
SYSINIT:046C move_myself:                            ; CODE XREF: SYSINIT:0434↑j
SYSINIT:046C                                         ; SYSINIT:044F↑j ...
SYSINIT:046C                 cld                     ; set up move
SYSINIT:046D                 xor     si, si
SYSINIT:046F                 mov     di, si
SYSINIT:0471                 mov     cx, cs:MEMORY_SIZE
SYSINIT:0476                 push    cs
SYSINIT:0477                 pop     ds
SYSINIT:0478                 assume ds:SYSINIT
SYSINIT:0478                 dec     cx
SYSINIT:0479                 xor     bx, bx
SYSINIT:047B                 mov     es, bx          ; 0
SYSINIT:047D                 assume es:nothing
SYSINIT:047D                 mov     bx, word ptr es:0BCh ; Int 2Fh vector (4*2Fh)
SYSINIT:0482                 mov     es, word ptr es:0BEh
SYSINIT:0487                 assume es:nothing
SYSINIT:0487                 cmp     word ptr es:[bx+3], 5052h ; 'RP'
SYSINIT:048D                 jnz     short NoRPL
SYSINIT:048F                 cmp     byte ptr es:[bx+5], 4Ch ; 'L'
SYSINIT:0494                 jnz     short NoRPL
SYSINIT:0496                 mov     dx, cx          ; get TOM into DX
SYSINIT:0498                 push    dx
SYSINIT:0499                 mov     ax, 4A06h       ; (multMULT<<8)+multMULTRPLTOM
SYSINIT:049C                 int     2Fh             ; Get new TOM from any RPL
SYSINIT:049E                 pop     ax
SYSINIT:049F                 mov     cx, dx
SYSINIT:04A1                 cmp     dx, ax
SYSINIT:04A3                 jz      short NoRPL
SYSINIT:04A5                 mov     cs:RPLMemTop, dx
SYSINIT:04AA                 dec     cx
SYSINIT:04AB
SYSINIT:04AB NoRPL:                                  ; CODE XREF: SYSINIT:048D↑j
SYSINIT:04AB                                         ; SYSINIT:0494↑j ...
SYSINIT:04AB                 mov     ax, 5B40h       ; SI_end ; need this much room for sysinit
SYSINIT:04AB                                         ; (SI_end == sysinit code size)
SYSINIT:04AE                 call    _off_to_para
SYSINIT:04B1                 sub     cx, ax
SYSINIT:04B3                 sub     cx, 0B00h       ; DOSSIZE/16 (2816)
SYSINIT:04B3                                         ; leave this much room for DOS
SYSINIT:04B7                 mov     ax, 1E00h       ; BCODE_END
SYSINIT:04BA                 call    _off_to_para    ; leave this much room for BIOS code
SYSINIT:04BD                 sub     cx, ax
SYSINIT:04BF                 mov     es, cx          ; offset where sysinit will be located
SYSINIT:04C1                 mov     cx, 5B40h       ; SI_end ; (sysinit code size)
SYSINIT:04C4                 shr     cx, 1           ; divide by 2 to get words
SYSINIT:04C6                 rep movsw               ; relocate sysinit
SYSINIT:04C8                 push    es              ; push relocated segment
SYSINIT:04C9                 mov     ax, offset SYSIN ; SYSINIT:04F3h
SYSINIT:04CC                 push    ax              ; push relocated entry point
SYSINIT:04CD                 retf                    ; far jump to relocated sysinit
SYSINIT:04CE
SYSINIT:04CE ; =============== S U B R O U T I N E =======================================
SYSINIT:04CE
SYSINIT:04CE
SYSINIT:04CE get_cpu_type    proc near               ; CODE XREF: SYSINIT:04FB↓p
SYSINIT:04CE                 pushf
SYSINIT:04CF                 push    bx
SYSINIT:04D0                 xor     bx, bx
SYSINIT:04D2                 xor     ax, ax
SYSINIT:04D4                 push    ax
SYSINIT:04D5                 popf
SYSINIT:04D6                 pushf
SYSINIT:04D7                 pop     ax
SYSINIT:04D8                 and     ax, 0F000h
SYSINIT:04DB                 cmp     ax, 0F000h
SYSINIT:04DE                 jz      short cpu_8086
SYSINIT:04E0                 mov     ax, 0F000h
SYSINIT:04E3                 push    ax
SYSINIT:04E4                 popf
SYSINIT:04E5                 pushf
SYSINIT:04E6                 pop     ax
SYSINIT:04E7                 and     ax, 0F000h
SYSINIT:04EA                 jz      short cpu_286
SYSINIT:04EC
SYSINIT:04EC cpu_386:
SYSINIT:04EC                 inc     bx
SYSINIT:04ED
SYSINIT:04ED cpu_286:                                ; CODE XREF: get_cpu_type+1C↑j
SYSINIT:04ED                 inc     bx
SYSINIT:04EE
SYSINIT:04EE cpu_8086:                               ; CODE XREF: get_cpu_type+10↑j
SYSINIT:04EE                 mov     ax, bx
SYSINIT:04F0                 pop     bx
SYSINIT:04F1                 popf
SYSINIT:04F2                 retn
SYSINIT:04F2 get_cpu_type    endp
SYSINIT:04F2
SYSINIT:04F3 ; ---------------------------------------------------------------------------
SYSINIT:04F3
SYSINIT:04F3 SYSIN:                                  ; DATA XREF: SYSINIT:04C9↑o
SYSINIT:04F3                 mov     ax, 70h
SYSINIT:04F6                 mov     ds, ax          ; DOSBIODATASEG
SYSINIT:04F8                 assume ds:nothing
SYSINIT:04F8                 push    es
SYSINIT:04F9                 push    ax              ; not needed (*) E.TAN - 03/07/2023
SYSINIT:04FA                 push    di
SYSINIT:04FB                 call    get_cpu_type    ; determine if 386 system
SYSINIT:04FE                 cmp     ax, 2           ; 0 = 8086, 1 = 286, 2 = 386
SYSINIT:0501                 jnz     short not_386_system
SYSINIT:0503                 cld                     ; 80386
SYSINIT:0504                 push    ds
SYSINIT:0505                 pop     es              ; change A20 line on/off check code
SYSINIT:0506                 assume es:nothing
SYSINIT:0506                 mov     di, offset cpu386_cmpsd
SYSINIT:0509                 mov     ax, 4B9h        ; mov cx,4 ; B90400
SYSINIT:050C                 stosw
SYSINIT:050D                 mov     ax, 0F300h      ; repz  ; F3
SYSINIT:0510                 stosw
SYSINIT:0511                 mov     ax, 0A766h      ; cmpsd ; 66A7
SYSINIT:0514                 stosw
SYSINIT:0515
SYSINIT:0515 not_386_system:                         ; CODE XREF: SYSINIT:0501↑j
SYSINIT:0515                 pop     di
SYSINIT:0516                 pop     ax              ; not needed (*) E.TAN - 03/07/2023
SYSINIT:0517                 pop     es
SYSINIT:0518                 assume es:nothing
SYSINIT:0518                 mov     ds:MoveDOSIntoHMA_2, cs ; set seg of routine to move DOS
SYSINIT:0518                                         ; update SYSINITSEG field
SYSINIT:0518                                         ; MoveDOSIntoHMA+2
SYSINIT:051C                 mov     ds:SysinitPresent, 1 ; flag that MoveDOSIntoHMA can be called
SYSINIT:0521                 mov     ax, 5B40h       ; SI_end ; how big is sysinitseg?
SYSINIT:0524                 call    _off_to_para
SYSINIT:0527                 mov     cx, cs          ; pick a buffer for msdos above us
SYSINIT:0529                 add     ax, cx
SYSINIT:052B                 mov     es, ax
SYSINIT:052D                 xor     si, si
SYSINIT:052F                 mov     di, si
SYSINIT:0531                 mov     ds, cs:CURRENTDOSLOCATION ; where it is (set by msinit)
SYSINIT:0536                 assume ds:nothing
SYSINIT:0536                 mov     cx, 5800h       ; DOSSIZE/2 (22528)
SYSINIT:0539                 rep movsw
SYSINIT:053B                 mov     cs:CURRENTDOSLOCATION, es
SYSINIT:0540                 mov     ax, ds:3        ; get offset of dos
SYSINIT:0540                                         ; ax = 3F10h for IBMDOS 7.1 kernel
SYSINIT:0540                                         ;  (IBMDOS.SYS, offset 3)
SYSINIT:0543                 mov     cs:dosinit, ax
SYSINIT:0547                 call    _off_to_para    ; subtract this much from segment
SYSINIT:054A                 sub     cs:CURRENTDOSLOCATION, ax ; FINAL_DOS_LOCATION
SYSINIT:054F                 mov     ax, es
SYSINIT:0551                 add     ax, 0B00h       ; DOSSIZE/16 ; DOSSIZE = 0B000h = 45056
SYSINIT:0554                 mov     es, ax
SYSINIT:0556                 assume es:nothing
SYSINIT:0556                 xchg    ax, cs:temp_bcode_seg ; swap with original home of Bios_Code
SYSINIT:055B                 mov     ds, ax          ; point to loaded image of Bios_Code
SYSINIT:055D                 assume ds:nothing
SYSINIT:055D                 mov     si, offset Bios_Data_Word ; BCODESTART (= BiosDataWord)
SYSINIT:055D                                         ; BIOSCODE:BCODESTART (BIOSCODE:0030h)
SYSINIT:0560                 mov     di, si
SYSINIT:0562                 mov     cx, 1E00h       ; BCODE_END = (SYSINITSEG-DOSBIOCODESEG)*16
SYSINIT:0562                                         ; (544h-364h)*10h = 1E00h (for PCDOS 7.1 IBMBIO.COM)
SYSINIT:0565                 sub     cx, si
SYSINIT:0567                 shr     cx, 1
SYSINIT:0569                 rep movsw               ; move Bios_Code into place
SYSINIT:056B                 mov     ax, es          ; tell it what segment it's in
SYSINIT:056D                 call    dword ptr cs:_seg_reinit_ptr
SYSINIT:0572                 les     di, dword ptr cs:BiosComBlock
SYSINIT:0577                 assume es:nothing
SYSINIT:0577                 lds     si, cs:DEVICE_LIST
SYSINIT:057C                 assume ds:nothing
SYSINIT:057C                 mov     dx, cs:MEMORY_SIZE
SYSINIT:0581                 cli
SYSINIT:0582                 mov     ax, cs
SYSINIT:0584                 mov     ss, ax
SYSINIT:0586                 assume ss:SYSINIT
SYSINIT:0586
SYSINIT:0586 locstack:                               ; DATA XREF: SYSINIT:locstack↓o
SYSINIT:0586                                         ; sum_up:sum_sys_code↓o
SYSINIT:0586                 mov     sp, offset locstack ; set stack
SYSINIT:0586                                         ; mov sp, 586h ; mov sp, locstack
SYSINIT:0586                                         ; %define locstack ($ - SYSINIT$) & 0FFFEh
SYSINIT:0586                                         ; locstack = $ & 0FFFEh (SYSINIT:SYSINIT$=544h:0)
SYSINIT:0589                 sti
SYSINIT:058A                 call    dword ptr cs:dosinit ; call dosinit
SYSINIT:058A                                         ; es:di -> sysinitvars_ext
SYSINIT:058F                 mov     cs:def_php, ds  ; save pointer to PSP
SYSINIT:0594                 mov     cs:hi_doscod_size, ax ; size of doscode (including exepatch)
SYSINIT:0598                 mov     cs:lo_doscod_size, cx ; (as exepatch excluded)
SYSINIT:059D                 mov     word ptr cs:dos_segreinit, dx ; save offset of segreinit
SYSINIT:05A2                 mov     ax, es:[di]     ; [es:di+SysInitVars_Ext.SYSI_InitVars]
SYSINIT:05A5                 mov     word ptr cs:DOSINFO, ax
SYSINIT:05A9                 mov     ax, es:[di+2]
SYSINIT:05AD                 mov     word ptr cs:DOSINFO+2, ax
SYSINIT:05B1                 mov     ax, es:[di+4]   ; [es:di+SysInitVars_Ext.SYSI_Country_Tab]
SYSINIT:05B5                 mov     word ptr cs:sysi_country, ax
SYSINIT:05B9                 mov     ax, es:[di+6]   ; [es:di+SysInitVars_Ext.SYSI_Country_Tab+2]
SYSINIT:05BD                 mov     word ptr cs:sysi_country+2, ax
SYSINIT:05C1                 mov     es, cs:CURRENTDOSLOCATION ; = [FINAL_DOS_LOCATION]
SYSINIT:05C6                 mov     word ptr cs:dos_segreinit+2, es
SYSINIT:05CB                 cmp     cs:RPLMemTop, 0
SYSINIT:05D1                 jz      short NoRPLArena
SYSINIT:05D3                 mov     bx, 0FFFFh
SYSINIT:05D6                 mov     ah, 48h
SYSINIT:05D8                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:05D8                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:05DA                 mov     ah, 48h
SYSINIT:05DC                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:05DC                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:05DE                 mov     es, ax
SYSINIT:05E0                 push    es              ; resize upto RPL mem
SYSINIT:05E1                 sub     ax, cs:RPLMemTop
SYSINIT:05E6                 neg     ax
SYSINIT:05E8                 dec     ax
SYSINIT:05E9                 mov     bx, ax
SYSINIT:05EB                 mov     ah, 4Ah
SYSINIT:05ED                 int     21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
SYSINIT:05ED                                         ; ES = segment address of block to change
SYSINIT:05ED                                         ; BX = new size in paragraphs
SYSINIT:05EF                 mov     bx, 0FFFFh
SYSINIT:05F2                 mov     ah, 48h
SYSINIT:05F4                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:05F4                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:05F6                 mov     ah, 48h
SYSINIT:05F8                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:05F8                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:05FA                 dec     ax
SYSINIT:05FB                 mov     es, ax
SYSINIT:05FD                 mov     word ptr es:1, 8 ; [es:arena_owner]
SYSINIT:0604                 mov     word ptr es:8, 5052h ; [es:arena_name],'RP'
SYSINIT:060B                 mov     word ptr es:10, 4Ch ; 'L' ; [es:arena_name+2],'L'
SYSINIT:0612                 mov     word ptr es:12, 0 ; [es:arena_name+4]
SYSINIT:0619                 mov     word ptr es:14, 0 ; [es:arena_name+6]
SYSINIT:0620                 pop     es
SYSINIT:0621                 mov     ah, 49h         ; Dealloc
SYSINIT:0623                 int     21h             ; DOS - 2+ - FREE MEMORY
SYSINIT:0623                                         ; ES = segment address of area to be freed
SYSINIT:0625
SYSINIT:0625 NoRPLArena:                             ; CODE XREF: SYSINIT:05D1↑j
SYSINIT:0625                 les     di, cs:DOSINFO
SYSINIT:062A                 clc
SYSINIT:062B                 mov     ah, 88h
SYSINIT:062D                 int     15h             ; Get Extended Memory Size
SYSINIT:062D                                         ; Return: CF clear on success
SYSINIT:062D                                         ; AX = size of memory above 1M in K
SYSINIT:062F                 jb      short no_ext_memory
SYSINIT:0631                 mov     es:[di+45h], ax ; [es:di+SYSI_EXT_MEM]
SYSINIT:0635                 or      ax, ax
SYSINIT:0637                 jz      short no_ext_memory
SYSINIT:0639                 call    ClrVDISKHeader
SYSINIT:063C
SYSINIT:063C no_ext_memory:                          ; CODE XREF: SYSINIT:062F↑j
SYSINIT:063C                                         ; SYSINIT:0637↑j
SYSINIT:063C                 mov     ax, es:[di+10h] ; [es:di+SYSI_MAXSEC]
SYSINIT:0640                 add     ax, 24          ; bufinsiz
SYSINIT:0640                                         ; size of buffer header = 24 (PCDOS v7.1 IBMBIO.COM)
SYSINIT:0640                                         ; (it was 20 in MSDOS 6.22 IO.SYS)
SYSINIT:0643                 mov     cs:singlebuffersize, ax ; total size for a buffer
SYSINIT:0647                 mov     al, cs:DEFAULT_DRIVE
SYSINIT:064B                 mov     es:[di+43h], al ; [es:di+SYSI_BOOT_DRIVE]
SYSINIT:064F
SYSINIT:064F _get_cpu_type:
SYSINIT:064F                 pushf
SYSINIT:0650                 push    bx
SYSINIT:0651                 xor     bx, bx
SYSINIT:0653                 xor     ax, ax
SYSINIT:0655                 push    ax
SYSINIT:0656                 popf
SYSINIT:0657                 pushf
SYSINIT:0658                 pop     ax
SYSINIT:0659                 and     ax, 0F000h
SYSINIT:065C                 cmp     ax, 0F000h
SYSINIT:065F                 jz      short _cpu_8086
SYSINIT:0661                 mov     ax, 0F000h
SYSINIT:0664                 push    ax
SYSINIT:0665                 popf
SYSINIT:0666                 pushf
SYSINIT:0667                 pop     ax
SYSINIT:0668                 and     ax, 0F000h
SYSINIT:066B                 jz      short _cpu_286
SYSINIT:066D
SYSINIT:066D _cpu_386:
SYSINIT:066D                 inc     bx
SYSINIT:066E
SYSINIT:066E _cpu_286:                               ; CODE XREF: SYSINIT:066B↑j
SYSINIT:066E                 inc     bx
SYSINIT:066F
SYSINIT:066F _cpu_8086:                              ; CODE XREF: SYSINIT:065F↑j
SYSINIT:066F                 mov     ax, bx
SYSINIT:0671                 pop     bx
SYSINIT:0672                 popf
SYSINIT:0673                 cmp     ax, 2
SYSINIT:0676                 jnz     short _not_386_cpu
SYSINIT:0678                 mov     byte ptr es:[di+44h], 1 ; [es:di+SYSI_DWMOVE],1
SYSINIT:0678                                         ; set doubleword moving flag
SYSINIT:067D
SYSINIT:067D _not_386_cpu:                           ; CODE XREF: SYSINIT:0676↑j
SYSINIT:067D                 mov     al, es:[di+20h] ; [es:di+SYSI_NUMIO]
SYSINIT:0681                 mov     cs:drivenumber, al ; save start of installable block drvs
SYSINIT:0685                 mov     ax, cs
SYSINIT:0687                 sub     ax, 11h         ; room for PSP we will copy shortly
SYSINIT:068A                 mov     cx, cs:singlebuffersize ; temporary single buffer area
SYSINIT:068F                 shr     cx, 1
SYSINIT:0691                 shr     cx, 1
SYSINIT:0693                 shr     cx, 1
SYSINIT:0695                 shr     cx, 1           ; divide size by 16..
SYSINIT:0695                                         ; ...to get paragraphs...
SYSINIT:0697                 inc     cx              ; ... and round up
SYSINIT:0698                 sub     ax, cx
SYSINIT:069A                 mov     cs:top_of_cdss, ax ; temp "unsafe" location
SYSINIT:069E                 push    es
SYSINIT:069F                 push    di
SYSINIT:06A0                 mov     cx, ax          ; save pointer for buffer
SYSINIT:06A2                 sub     ax, 143         ; sub ax,((26 *(curdirlen))+15)/16
SYSINIT:06A2                                         ; (curdirlen=88)
SYSINIT:06A5                 mov     cs:ALLOCLIM, ax
SYSINIT:06A9                 mov     cs:CONFBOT, ax
SYSINIT:06AD                 les     di, es:[di+12h] ; [es:di+SYSI_BUF]
SYSINIT:06B1                 mov     word ptr es:[di+4], 0 ; [es:di+BUFFINF.Dirty_Buff_Count]
SYSINIT:06B7                 mov     word ptr es:[di], 0 ; [es:di+BUFFINF.Buff_Queue]
SYSINIT:06BC                 mov     es:[di+2], cx   ; [es:di+BUFFINF.Buff_Queue+2]
SYSINIT:06BC                                         ; cx = [top_of_cdss]
SYSINIT:06C0                 mov     es, cx
SYSINIT:06C2                 xor     ax, ax
SYSINIT:06C4                 mov     di, ax
SYSINIT:06C6                 mov     es:[di], ax     ; [es:di+buffinfo.buf_next],0
SYSINIT:06C9                 mov     es:[di+2], ax   ; [es:di+buffinfo.buf_prev],0
SYSINIT:06CD                 mov     word ptr es:[di+4], 0FFh ; [es:di+buffinfo.buf_ID],00FFh
SYSINIT:06CD                                         ; free buffer,clear flag
SYSINIT:06D3                 mov     word ptr es:[di+6], 0 ; [es:di+buffinfo.buf_sector]
SYSINIT:06D9                 mov     word ptr es:[di+8], 0 ; [es:di+buffinfo.buf_sector+2]
SYSINIT:06DF                 pop     di
SYSINIT:06E0                 pop     es
SYSINIT:06E1                 push    cs
SYSINIT:06E2                 pop     ds
SYSINIT:06E3                 assume ds:SYSINIT
SYSINIT:06E3                 call    TempCDS         ; set up cdss so re_init and sysinit
SYSINIT:06E3                                         ; can make disk system calls
SYSINIT:06E3                                         ; tempcds trashes ds
SYSINIT:06E6                 mov     ds, cs:def_php  ; retrieve pointer to PSP returned by DOSINIT
SYSINIT:06EB                 assume ds:nothing
SYSINIT:06EB                 call    far ptr 70h:729h ; call DOSBIODATASEG:re_init
SYSINIT:06F0                 sti
SYSINIT:06F1                 cld
SYSINIT:06F2                 mov     bx, cs
SYSINIT:06F4                 sub     bx, 10h
SYSINIT:06F7                 mov     es, bx
SYSINIT:06F9                 assume es:nothing
SYSINIT:06F9                 xor     si, si
SYSINIT:06FB                 mov     di, si
SYSINIT:06FD                 mov     cx, 128
SYSINIT:0700                 rep movsw
SYSINIT:0702                 mov     word ptr es:36h, es ; [es:PDB.JFN_POINTER+2],es ; Relocate
SYSINIT:0707                 mov     ah, 50h
SYSINIT:0709                 int     21h             ; DOS - 2+ internal - SET PSP SEGMENT
SYSINIT:0709                                         ; BX = segment address of new PSP
SYSINIT:070B                 push    ds
SYSINIT:070C                 push    cs
SYSINIT:070D                 pop     ds
SYSINIT:070E                 assume ds:SYSINIT
SYSINIT:070E                 mov     dx, offset int24 ; set up int 24h handler
SYSINIT:0711                 mov     ax, 2524h
SYSINIT:0714                 int     21h             ; DOS - SET INTERRUPT VECTOR
SYSINIT:0714                                         ; AL = interrupt number
SYSINIT:0714                                         ; DS:DX = new vector to be used for specified interrupt
SYSINIT:0716                 cmp     toomanydrivesflag, 0
SYSINIT:071B                 jz      short no_err
SYSINIT:071D                 mov     dx, offset TooManyDrivesMsg ; "WARNING! Logical drives past Z: exist a"...
SYSINIT:0720                 call    print
SYSINIT:0723
SYSINIT:0723 no_err:                                 ; CODE XREF: SYSINIT:071B↑j
SYSINIT:0723                 pop     ds
SYSINIT:0724                 assume ds:nothing
SYSINIT:0724                 mov     dl, cs:DEFAULT_DRIVE
SYSINIT:0729                 or      dl, dl
SYSINIT:072B                 jz      short nodrvset
SYSINIT:072D                 dec     dl
SYSINIT:072F                 mov     ah, 0Eh
SYSINIT:0731                 int     21h             ; DOS - SELECT DISK
SYSINIT:0731                                         ; DL = new default drive number (0 = A, 1 = B, etc.)
SYSINIT:0731                                         ; Return: AL = number of logical drives
SYSINIT:0733
SYSINIT:0733 nodrvset:                               ; CODE XREF: SYSINIT:072B↑j
SYSINIT:0733                 push    ds
SYSINIT:0734                 sub     ax, ax
SYSINIT:0736                 mov     ds, ax          ; 0  ; ROMBIOS data area
SYSINIT:0738                 assume ds:nothing
SYSINIT:0738                 mov     ax, word ptr ds:46Ch ; Counter for Interrupt 1Ah
SYSINIT:0738                                         ; timer tick count (18.2 ticks per second)
SYSINIT:073B                 pop     ds
SYSINIT:073C                 assume ds:nothing
SYSINIT:073C                 mov     cs:_timer_lw_, ax
SYSINIT:0740                 push    cs
SYSINIT:0741                 pop     es
SYSINIT:0742                 assume es:SYSINIT
SYSINIT:0742                 mov     word ptr cs:MagicBackdoor+2, cs
SYSINIT:0747                 mov     word ptr cs:MagicBackdoor, offset NullBackdoor
SYSINIT:074E
SYSINIT:074E set_drvspc_size:                        ; CODE XREF: SYSINIT:0778↓j
SYSINIT:074E                 mov     si, offset MagicDDName ; "\\DBLSPACE.BIN"
SYSINIT:0751
SYSINIT:0751 set_dblspc_size:                        ; CODE XREF: SYSINIT:0767↓j
SYSINIT:0751                                         ; SYSINIT:0783↓j
SYSINIT:0751                 call    SizeDevice
SYSINIT:0754                 jnb     short wait_for_key_2s
SYSINIT:0756                 cmp     byte ptr cs:[si], 'C'
SYSINIT:075A                 jz      short set_drvspc_name
SYSINIT:075C                 cmp     cs:DEFAULT_DRIVE, 3
SYSINIT:0762                 jz      short set_drvspc_name
SYSINIT:0764                 sub     si, 2
SYSINIT:0767                 jmp     short set_dblspc_size
SYSINIT:0769 ; ---------------------------------------------------------------------------
SYSINIT:0769
SYSINIT:0769 set_drvspc_name:                        ; CODE XREF: SYSINIT:075A↑j
SYSINIT:0769                                         ; SYSINIT:0762↑j
SYSINIT:0769                 cmp     byte ptr cs:MagicDDName+2, 'R' ; "BLSPACE.BIN"
SYSINIT:076F                 jz      short set_stacker_name
SYSINIT:0771                 mov     word ptr cs:MagicDDName+2, 'VR' ; 'RV' ; DRVSPACE.BIN
SYSINIT:0778                 jmp     short set_drvspc_size
SYSINIT:077A ; ---------------------------------------------------------------------------
SYSINIT:077A
SYSINIT:077A set_stacker_name:                       ; CODE XREF: SYSINIT:076F↑j
SYSINIT:077A                 cmp     si, offset StackerName ; "C:\\STACKER.BIN"
SYSINIT:077E                 jnb     short wfk2s_4
SYSINIT:0780                 mov     si, (offset StackerName+2) ; "\\STACKER.BIN"
SYSINIT:0783                 jmp     short set_dblspc_size
SYSINIT:0785 ; ---------------------------------------------------------------------------
SYSINIT:0785
SYSINIT:0785 wait_for_key_2s:                        ; CODE XREF: SYSINIT:0754↑j
SYSINIT:0785                 mov     cs:MagicDDNamePtr, si
SYSINIT:078A                 push    ds
SYSINIT:078B                 sub     ax, ax
SYSINIT:078D                 mov     ds, ax          ; 0 ; ROMBIOS data area
SYSINIT:078F                 assume ds:nothing
SYSINIT:078F                 mov     dx, word ptr ds:46Ch ; Counter for Interrupt 1Ah
SYSINIT:0793
SYSINIT:0793 wfk2s_1:                                ; CODE XREF: SYSINIT:07A8↓j
SYSINIT:0793                 mov     ah, 1
SYSINIT:0795                 int     16h             ; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
SYSINIT:0795                                         ; Return: ZF clear if character in buffer
SYSINIT:0795                                         ; AH = scan code, AL = character
SYSINIT:0795                                         ; ZF set if no character in buffer
SYSINIT:0797                 jnz     short wfk2s_2
SYSINIT:0799                 mov     ah, 2
SYSINIT:079B                 int     16h             ; KEYBOARD - GET SHIFT STATUS
SYSINIT:079B                                         ; AL = shift status bits
SYSINIT:079D                 test    al, 3
SYSINIT:079F                 jnz     short wfk2s_2
SYSINIT:07A1                 mov     ax, word ptr ds:46Ch ; tick count
SYSINIT:07A4                 sub     ax, dx
SYSINIT:07A6                 cmp     al, 37          ; 2 seconds
SYSINIT:07A8                 jb      short wfk2s_1   ; wait for user's key press
SYSINIT:07AA
SYSINIT:07AA wfk2s_2:                                ; CODE XREF: SYSINIT:0797↑j
SYSINIT:07AA                                         ; SYSINIT:079F↑j
SYSINIT:07AA                 pop     ds              ; read/check the pressed key
SYSINIT:07AB                 assume ds:nothing
SYSINIT:07AB                 sub     bx, bx          ; bx = 0
SYSINIT:07AD                 mov     ah, 2
SYSINIT:07AF                 int     16h             ; KEYBOARD - GET SHIFT STATUS
SYSINIT:07AF                                         ; AL = shift status bits
SYSINIT:07B1                 test    al, 3           ; Left or Right SHIFT key pressed ?
SYSINIT:07B3                 jz      short wfk2s_3   ; no
SYSINIT:07B5                 inc     bx
SYSINIT:07B6                 inc     bx              ; bx = 2
SYSINIT:07B7
SYSINIT:07B7 wfk2s_3:                                ; CODE XREF: SYSINIT:07B3↑j
SYSINIT:07B7                 mov     ah, 1
SYSINIT:07B9                 int     16h             ; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
SYSINIT:07B9                                         ; Return: ZF clear if character in buffer
SYSINIT:07B9                                         ; AH = scan code, AL = character
SYSINIT:07B9                                         ; ZF set if no character in buffer
SYSINIT:07BB                 jz      short wfk2s_6
SYSINIT:07BD                 cmp     ah, 65h         ; F8 key pressed ?
SYSINIT:07C0                 jz      short wfk2s_5
SYSINIT:07C2                 cmp     ah, 62h         ; F5 key pressed ?
SYSINIT:07C5                 jnz     short wfk2s_6
SYSINIT:07C7                 mov     cs:F5_key, 1
SYSINIT:07CD
SYSINIT:07CD wfk2s_4:                                ; CODE XREF: SYSINIT:077E↑j
SYSINIT:07CD                 jmp     short ProcessConfig ; continue (as normal/default state)
SYSINIT:07CF ; ---------------------------------------------------------------------------
SYSINIT:07CF
SYSINIT:07CF wfk2s_5:                                ; CODE XREF: SYSINIT:07C0↑j
SYSINIT:07CF                 mov     cs:F8_key, 1
SYSINIT:07D5                 jmp     short ProcessConfig
SYSINIT:07D7 ; ---------------------------------------------------------------------------
SYSINIT:07D7
SYSINIT:07D7 wfk2s_6:                                ; CODE XREF: SYSINIT:07BB↑j
SYSINIT:07D7                                         ; SYSINIT:07C5↑j
SYSINIT:07D7                 call    AllocFreeMem    ; get the largest free block from DOS
SYSINIT:07DA                 call    MagicPreload    ; **** PRE-LOAD MAGICDRV!!! ****
SYSINIT:07DD
SYSINIT:07DD wfk2s_7:                                ; error?
SYSINIT:07DD                 or      ax, ax
SYSINIT:07DF                 jz      short wfk2s_8
SYSINIT:07E1
SYSINIT:07E1 PreloadFailed:                          ; Dealloc ; free the block if no load
SYSINIT:07E1                 mov     ah, 49h
SYSINIT:07E3                 mov     es, cs:area
SYSINIT:07E8                 assume es:nothing
SYSINIT:07E8                 int     21h             ; DOS - 2+ - FREE MEMORY
SYSINIT:07E8                                         ; ES = segment address of area to be freed
SYSINIT:07EA                 jmp     short ProcessConfig
SYSINIT:07EC ; ---------------------------------------------------------------------------
SYSINIT:07EC
SYSINIT:07EC wfk2s_8:                                ; CODE XREF: SYSINIT:07DF↑j
SYSINIT:07EC                 mov     bx, cs:memhi
SYSINIT:07F1                 mov     es, cs:area
SYSINIT:07F6                 sub     bx, cs:area     ; get desired block size in paras
SYSINIT:07FB                 mov     ah, 4Ah
SYSINIT:07FD                 int     21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
SYSINIT:07FD                                         ; ES = segment address of block to change
SYSINIT:07FD                                         ; BX = new size in paragraphs
SYSINIT:07FF                 mov     ax, es
SYSINIT:0801                 dec     ax
SYSINIT:0802                 mov     es, ax          ; get Magicdrv arena
SYSINIT:0804                 assume es:nothing
SYSINIT:0804                 mov     word ptr es:1, 8 ; [es:arena_owner], 8 ; set impossible owner
SYSINIT:080B                 mov     word ptr es:8, 4453h ; [es:arena_name],'SD' ; System Data
SYSINIT:0812                 add     ax, es:3        ; get MCB length
SYSINIT:0817                 lds     si, cs:DOSINFO  ; get to arena header
SYSINIT:081C                 inc     ax              ; get addr of next MCB
SYSINIT:081D                 mov     [si-2], ax      ; store that
SYSINIT:0820
SYSINIT:0820 ProcessConfig:                          ; CODE XREF: SYSINIT:wfk2s_4↑j
SYSINIT:0820                                         ; SYSINIT:07D5↑j ...
SYSINIT:0820                 call    doconf
SYSINIT:0823                 cmp     cs:runhigh, 0   ; Did user choose to run low ?
SYSINIT:0829                 jz      short dont_install_stub ; yes, don't install dos low mem stub
SYSINIT:082B                 mov     es, cs:CURRENTDOSLOCATION
SYSINIT:0830                 assume es:nothing
SYSINIT:0830                 xor     ax, ax          ; ax = 0 --> install stub
SYSINIT:0832                 call    cs:dos_segreinit ; call far [dos_segreinit]
SYSINIT:0837                 jmp     short do_multi_pass
SYSINIT:0839 ; ---------------------------------------------------------------------------
SYSINIT:0839
SYSINIT:0839 dont_install_stub:                      ; CODE XREF: SYSINIT:0829↑j
SYSINIT:0839                 xor     bx, bx
SYSINIT:083B                 call    MovDOSLo
SYSINIT:083E                 mov     ax, 1
SYSINIT:0841                 mov     es, cs:CURRENTDOSLOCATION
SYSINIT:0846                 call    cs:dos_segreinit ; call far [cs:dos_segreinit]
SYSINIT:0846                                         ; inform dos about new seg
SYSINIT:084B
SYSINIT:084B do_multi_pass:                          ; CODE XREF: SYSINIT:0837↑j
SYSINIT:084B                 call    AllocFreeMem    ; allocate all the free mem & update [memhi]
SYSINIT:084B                                         ; & [area] start of free memory.
SYSINIT:084E                 cmp     cs:F5_key, 1
SYSINIT:0854                 jz      short skip_magicbackdoor
SYSINIT:0856                 cmp     cs:F8_key, 1
SYSINIT:085C                 jz      short skip_magicbackdoor
SYSINIT:085E                 xor     bx, bx          ; bx=0 ; magic backdoor to place int hooks
SYSINIT:0860                 call    cs:MagicBackdoor
SYSINIT:0865
SYSINIT:0865 skip_magicbackdoor:                     ; CODE XREF: SYSINIT:0854↑j
SYSINIT:0865                                         ; SYSINIT:085C↑j
SYSINIT:0865                 inc     cs:multi_pass_id ; multi_pass_id = 1
SYSINIT:086A                 call    multi_pass      ; load device drivers
SYSINIT:086D                 call    ShrinkUMB
SYSINIT:0870                 call    UnlinkUMB       ; unlink all UMBs
SYSINIT:0873                 inc     cs:multi_pass_id ; multi_pass_id = 2
SYSINIT:0878                 call    multi_pass
SYSINIT:087B                 cmp     cs:F5_key, 1
SYSINIT:0881                 jz      short skip_magicpostload
SYSINIT:0883                 cmp     cs:F8_key, 1
SYSINIT:0889                 jz      short skip_magicpostload
SYSINIT:088B                 call    MagicPostload   ; make sure Magicdrv is final placed
SYSINIT:088E                 call    endfile         ; setup fcbs, files, buffers etc
SYSINIT:0891                 call    MagicSetCdss    ; disable CDSs of reserved drives
SYSINIT:0894                 jmp     short _@_
SYSINIT:0896 ; ---------------------------------------------------------------------------
SYSINIT:0896
SYSINIT:0896 skip_magicpostload:                     ; CODE XREF: SYSINIT:0881↑j
SYSINIT:0896                                         ; SYSINIT:0889↑j
SYSINIT:0896                 call    endfile
SYSINIT:0899
SYSINIT:0899 _@_:                                    ; CODE XREF: SYSINIT:0894↑j
SYSINIT:0899                 mov     ax, 70h         ; DOSBIODATASEG
SYSINIT:089C                 mov     es, ax          ; BIOSDATA segment
SYSINIT:089E                 assume es:nothing
SYSINIT:089E                 mov     es:SysinitPresent, 0 ; clear SysinitPresent flag
SYSINIT:08A4                 test    cs:install_flag, 1 ; have_install_cmd
SYSINIT:08A4                                         ; are there install commands?
SYSINIT:08AB                 jz      short dolast
SYSINIT:08AD                 inc     cs:multi_pass_id
SYSINIT:08B2                 call    multi_pass
SYSINIT:08B5
SYSINIT:08B5 dolast:                                 ; CODE XREF: SYSINIT:08AB↑j
SYSINIT:08B5                 cmp     cs:runhigh, 0FFh ; are we still waiting to be moved?
SYSINIT:08BB                 jnz     short _@@_      ; no, our job is over
SYSINIT:08BD                 call    LoadDOSHiOrLo
SYSINIT:08C0
SYSINIT:08C0 _@@_:                                   ; CODE XREF: SYSINIT:08BB↑j
SYSINIT:08C0                 cmp     cs:runhigh, 0   ; are we running low
SYSINIT:08C6                 jz      short ConfigDone ; yes, no CPM hack needed
SYSINIT:08C8                 call    CPMHack         ; make ffff:d0 same as 0:c0
SYSINIT:08CB
SYSINIT:08CB ConfigDone:                             ; CODE XREF: SYSINIT:08C6↑j
SYSINIT:08CB                 mov     cs:donotshownum, 1
SYSINIT:08D1                 mov     es, cs:area
SYSINIT:08D6                 assume es:nothing
SYSINIT:08D6                 mov     ah, 49h         ; DEALLOC ; free allocated memory for command.com
SYSINIT:08D8                 int     21h             ; DOS - 2+ - FREE MEMORY
SYSINIT:08D8                                         ; ES = segment address of area to be freed
SYSINIT:08DA                 test    cs:install_flag, 2 ; has_installed
SYSINIT:08E1                 jz      short skip_free_sysinitbase ; no
SYSINIT:08E3                 push    es
SYSINIT:08E4                 push    bx
SYSINIT:08E5                 mov     es, cs:old_area
SYSINIT:08EA                 mov     bx, cs:impossible_owner_size
SYSINIT:08EF                 mov     ah, 4Ah
SYSINIT:08F1                 int     21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
SYSINIT:08F1                                         ; ES = segment address of block to change
SYSINIT:08F1                                         ; BX = new size in paragraphs
SYSINIT:08F3                 mov     ax, es
SYSINIT:08F5                 dec     ax
SYSINIT:08F6                 mov     es, ax          ; point to arena
SYSINIT:08F8                 assume es:nothing
SYSINIT:08F8                 mov     word ptr es:1, 8 ; [es:ARENA.OWNER],8 ; set impossible owner
SYSINIT:08FF                 mov     word ptr es:8, 4453h ; [es:ARENA.NAME],'SD' ; System Data
SYSINIT:0906                 pop     bx
SYSINIT:0907                 pop     es
SYSINIT:0908                 assume es:nothing
SYSINIT:0908
SYSINIT:0908 skip_free_sysinitbase:                  ; CODE XREF: SYSINIT:08E1↑j
SYSINIT:0908                 cmp     cs:runhigh, 0
SYSINIT:090E                 jz      short _@@@_
SYSINIT:0910                 call    InstVDiskHeader ; Install VDISK header (allocates some mem from DOS)
SYSINIT:0913
SYSINIT:0913 _@@@_:                                  ; CODE XREF: SYSINIT:090E↑j
SYSINIT:0913                 push    cs
SYSINIT:0914                 pop     ds
SYSINIT:0915                 assume ds:SYSINIT
SYSINIT:0915                 mov     config_cmd, 0   ; set special code for query_user
SYSINIT:091A                 call    query_user      ; to issue the AUTOEXEC prompt
SYSINIT:091D                 pushf
SYSINIT:091E                 test    bDisableUI, 1   ; Note: This flag is useless because it is not set before
SYSINIT:091E                                         ; E.TAN 04/07/2023
SYSINIT:0923                 jnz     short _@@@@_    ; F5 clean/interactive boot option (has been) disabled
SYSINIT:0925                 cmp     F5_key, 1
SYSINIT:092A                 jz      short _@@@@@_   ; F5 key pressed, bypass AUTOEXEC.BAT (clean boot)
SYSINIT:092C
SYSINIT:092C _@@@@_:                                 ; CODE XREF: SYSINIT:0923↑j
SYSINIT:092C                 popf
SYSINIT:092D                 jnb     short process_autoexec ; we should process autoexec normally
SYSINIT:092F                 jmp     short bypass_autoexec
SYSINIT:0931 ; ---------------------------------------------------------------------------
SYSINIT:0931
SYSINIT:0931 _@@@@@_:                                ; CODE XREF: SYSINIT:092A↑j
SYSINIT:0931                 popf                    ; cf status at the return from 'query_user' call
SYSINIT:0932
SYSINIT:0932 bypass_autoexec:                        ; CODE XREF: SYSINIT:092F↑j
SYSINIT:0932                 or      bQueryOpt, 4    ; set "skip all" flag
SYSINIT:0937                 call    disable_autoexec ; no, we should disable it
SYSINIT:093A
SYSINIT:093A process_autoexec:                       ; CODE XREF: SYSINIT:092D↑j
SYSINIT:093A                 call    CheckQueryOpt
SYSINIT:093D                 mov     cl, byte ptr command_line ; "\x02/P"
SYSINIT:0941                 mov     ch, 0
SYSINIT:0943                 inc     cx
SYSINIT:0944                 mov     si, offset command_line ; "\x02/P"
SYSINIT:0947                 add     si, cx          ; retry-4
SYSINIT:0949                 mov     byte ptr [si], 0Dh ; cr-terminate command line
SYSINIT:094C
SYSINIT:094C retry:                                  ; CODE XREF: SYSINIT:do_exec↓j
SYSINIT:094C                                         ; DATA XREF: SYSINIT:098E↓t ...
SYSINIT:094C                 mov     dx, offset commnd ; "\\COMMAND.COM"
SYSINIT:094F                 push    dx              ; save pointer to file name
SYSINIT:0950                 mov     bx, 0FFFFh      ; get biggest piece (second time gets it)
SYSINIT:0953                 mov     ah, 48h
SYSINIT:0955                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:0955                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:0957                 mov     ah, 48h
SYSINIT:0959                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:0959                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:095B                 jb      short memerrjx  ; oooops!
SYSINIT:095D                 mov     es, ax
SYSINIT:095F                 mov     ah, 49h
SYSINIT:0961                 int     21h             ; DOS - 2+ - FREE MEMORY
SYSINIT:0961                                         ; ES = segment address of area to be freed
SYSINIT:0963                 mov     bp, bx
SYSINIT:0965                 mov     bx, MEMORY_SIZE ; get location of end of memory
SYSINIT:0969                 mov     ax, cs          ; get location of beginning of sysinit
SYSINIT:096B                 mov     cx, config_envlen
SYSINIT:096F                 jcxz    short no_env    ; use config_wrkseg only if there's env data
SYSINIT:0971                 mov     ax, config_wrkseg
SYSINIT:0974
SYSINIT:0974 no_env:                                 ; CODE XREF: SYSINIT:096F↑j
SYSINIT:0974                 sub     bx, ax
SYSINIT:0976                 add     bx, 11h         ; add the sysinit php
SYSINIT:0979                 sub     bp, bx          ; sub sysinit size from amount of free memory
SYSINIT:097B                 jb      short memerrjx  ; if there isn't even this much memory, give up
SYSINIT:097D                 mov     ax, 3D00h
SYSINIT:0980                 stc
SYSINIT:0981                 int     21h             ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
SYSINIT:0981                                         ; DS:DX -> ASCIZ filename
SYSINIT:0981                                         ; AL = access mode
SYSINIT:0981                                         ; 0 - read
SYSINIT:0983                 jb      short comerr
SYSINIT:0985                 mov     bx, ax
SYSINIT:0987                 cmp     newcmd, 0       ; was a new shell selected?
SYSINIT:098C                 jnz     short skip_validation ; yes
SYSINIT:098E                 mov     dx, offset retry-4 ; SYSINIT:0948h
SYSINIT:0991                 mov     cx, 4
SYSINIT:0994                 mov     ah, 3Fh
SYSINIT:0996                 int     21h             ; DOS - 2+ - READ FROM FILE WITH HANDLE
SYSINIT:0996                                         ; BX = file handle, CX = number of bytes to read
SYSINIT:0996                                         ; DS:DX -> buffer
SYSINIT:0998                 cmp     byte ptr retry-4, 0E9h
SYSINIT:099D                 jnz     short comerr
SYSINIT:099F                 cmp     byte ptr retry-1, 7Ah ; COMMAND.COM Version 7.10
SYSINIT:099F                                         ; ((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
SYSINIT:09A4                 jnz     short comerr
SYSINIT:09A6
SYSINIT:09A6 skip_validation:                        ; CODE XREF: SYSINIT:098C↑j
SYSINIT:09A6                 xor     cx, cx
SYSINIT:09A8                 xor     dx, dx
SYSINIT:09AA                 mov     ax, 4202h
SYSINIT:09AD                 stc
SYSINIT:09AE                 int     21h             ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
SYSINIT:09AE                                         ; AL = method: offset from end of file
SYSINIT:09B0                 jb      short comerr
SYSINIT:09B2                 add     ax, 0Fh         ; convert size in dx:ax to para in ax
SYSINIT:09B5                 adc     dx, 0           ; round up size for conversion to para
SYSINIT:09B8                 call    _off_to_para
SYSINIT:09BB                 mov     cl, 12
SYSINIT:09BD                 shl     dx, cl          ; low nibble of dx to high nibble
SYSINIT:09BF                 or      ax, dx          ; ax is now # of para for file
SYSINIT:09C1                 add     ax, 10h         ; 100h byte php
SYSINIT:09C4                 cmp     ax, bp          ; will command fit in available mem?
SYSINIT:09C6                 jb      short okld      ; jump if yes.
SYSINIT:09C8
SYSINIT:09C8 memerrjx:                               ; CODE XREF: SYSINIT:095B↑j
SYSINIT:09C8                                         ; SYSINIT:097B↑j
SYSINIT:09C8                 mov     dx, offset badmem ; "\r\nConfiguration too large for memory"...
SYSINIT:09CB                 call    print
SYSINIT:09CE                 jmp     short continue
SYSINIT:09D0 ; ---------------------------------------------------------------------------
SYSINIT:09D0
SYSINIT:09D0 okld:                                   ; CODE XREF: SYSINIT:09C6↑j
SYSINIT:09D0                 mov     ah, 3Eh
SYSINIT:09D2                 int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
SYSINIT:09D2                                         ; BX = file handle
SYSINIT:09D4                 push    cs
SYSINIT:09D5                 pop     es
SYSINIT:09D6                 assume es:SYSINIT
SYSINIT:09D6                 mov     bx, offset EXEC0_ENVIRON ; offset COMEXE
SYSINIT:09D6                                         ; point to exec block
SYSINIT:09D9                 pop     dx
SYSINIT:09DA                 mov     cx, config_envlen
SYSINIT:09DE                 jcxz    short no_envdata
SYSINIT:09E0                 mov     cx, config_wrkseg
SYSINIT:09E4
SYSINIT:09E4 no_envdata:                             ; CODE XREF: SYSINIT:09DE↑j
SYSINIT:09E4                 mov     [bx], cx        ; set segments
SYSINIT:09E4                                         ; [bx+EXEC0.ENVIRON],cx
SYSINIT:09E6                 mov     word ptr [bx+4], cs ; [bx+EXEC0.COM_LINE+2],cs
SYSINIT:09E9                 mov     word ptr [bx+8], cs ; [bx+EXEC0.5C_FCB+2],cs
SYSINIT:09EC                 mov     word ptr [bx+0Ch], cs ; [bx+EXEC0.6C_FCB+2],cs
SYSINIT:09EF                 mov     ax, 4B00h       ; (EXEC<<8)
SYSINIT:09F2                 stc
SYSINIT:09F3                 int     21h             ; DOS - 2+ - LOAD OR EXECUTE (EXEC)
SYSINIT:09F3                                         ; DS:DX -> ASCIZ filename
SYSINIT:09F3                                         ; ES:BX -> parameter block
SYSINIT:09F3                                         ; AL = subfunc: load & execute program
SYSINIT:09F5                 push    cs
SYSINIT:09F6                 pop     ds
SYSINIT:09F7                 push    dx
SYSINIT:09F8
SYSINIT:09F8 comerr:                                 ; CODE XREF: SYSINIT:0983↑j
SYSINIT:09F8                                         ; SYSINIT:099D↑j ...
SYSINIT:09F8                 cmp     byte ptr commnd4, 0 ; "\\DOS\\COMMAND.COM"
SYSINIT:09FD                 jz      short comerr2   ; all defaults exhausted, print err msg
SYSINIT:09FF                 cmp     newcmd, 0
SYSINIT:0A04                 jz      short continue  ; don't print err msg for defaults just yet
SYSINIT:0A06
SYSINIT:0A06 comerr2:                                ; CODE XREF: SYSINIT:09FD↑j
SYSINIT:0A06                 mov     dx, offset badcom ; "Command Interpreter"
SYSINIT:0A09                 call    badfil
SYSINIT:0A0C
SYSINIT:0A0C continue:                               ; CODE XREF: SYSINIT:09CE↑j
SYSINIT:0A0C                                         ; SYSINIT:0A04↑j
SYSINIT:0A0C                 pop     dx
SYSINIT:0A0D                 mov     ah, 19h
SYSINIT:0A0F                 int     21h             ; DOS - GET DEFAULT DISK NUMBER
SYSINIT:0A11                 add     al, 'A'
SYSINIT:0A13                 mov     dl, al          ; dl == default drive letter
SYSINIT:0A15                 mov     si, offset commnd2 ; "\\COMMAND.COM"
SYSINIT:0A18                 cmp     newcmd, 0       ; if a SHELL= was given
SYSINIT:0A1D                 jnz     short do_def2   ; then try the 2nd alternate;
SYSINIT:0A1F                 mov     byte ptr [si], 0 ; otherwise, the default SHELL= was tried,
SYSINIT:0A22                 jmp     short do_def3   ; which is the same as our 2nd alt, so skip it
SYSINIT:0A24 ; ---------------------------------------------------------------------------
SYSINIT:0A24
SYSINIT:0A24 do_def2:                                ; CODE XREF: SYSINIT:0A1D↑j
SYSINIT:0A24                 cmp     byte ptr [si], 0 ; has 2nd alternate been tried?
SYSINIT:0A27                 jnz     short do_alt    ; no
SYSINIT:0A29
SYSINIT:0A29 do_def3:                                ; CODE XREF: SYSINIT:0A22↑j
SYSINIT:0A29                 mov     si, offset commnd3 ; "\\MSDOS\\COMMAND.COM"
SYSINIT:0A2C                 cmp     byte ptr [si], 0 ; has 3rd alternate been tried?
SYSINIT:0A2F                 jnz     short do_alt    ; no
SYSINIT:0A31                 mov     si, offset commnd4 ; "\\DOS\\COMMAND.COM"
SYSINIT:0A34                 cmp     byte ptr [si], 0 ; has 4th alternate been tried?
SYSINIT:0A37                 jnz     short do_alt    ; no
SYSINIT:0A39                 push    dx
SYSINIT:0A3A                 mov     dx, offset badcomprmpt ; "Enter correct name of Command Interpret"...
SYSINIT:0A3D                 call    print
SYSINIT:0A40                 pop     dx              ; recover default drive letter in dl
SYSINIT:0A41
SYSINIT:0A41 request_input:                          ; CODE XREF: SYSINIT:0A69↓j
SYSINIT:0A41                 mov     ah, 2           ; STD_CON_OUTPUT
SYSINIT:0A43                 int     21h             ; DOS - DISPLAY OUTPUT
SYSINIT:0A43                                         ; DL = character to send to standard output
SYSINIT:0A45                 push    dx
SYSINIT:0A46                 mov     dl, '>'         ; 3Eh
SYSINIT:0A48                 int     21h             ; DOS -
SYSINIT:0A4A                 mov     bl, tmplate+1   ; [tmplate] = max. chars buffer can hold = 64
SYSINIT:0A4E                 mov     bh, 0
SYSINIT:0A50                 mov     byte ptr commnd[bx], 0Dh ; "\\COMMAND.COM"
SYSINIT:0A55                 mov     dx, offset tmplate
SYSINIT:0A58                 mov     ah, 0Ah         ; STD_CON_STRING_INPUT
SYSINIT:0A5A                 int     21h             ; DOS - BUFFERED KEYBOARD INPUT
SYSINIT:0A5A                                         ; DS:DX -> buffer
SYSINIT:0A5C                 mov     dx, offset crlfm ; "\r\n$"
SYSINIT:0A5F                 call    print
SYSINIT:0A62                 pop     dx
SYSINIT:0A63                 mov     bl, tmplate+1
SYSINIT:0A67                 or      bl, bl          ; was anything typed?
SYSINIT:0A69                 jz      short request_input
SYSINIT:0A6B                 mov     newcmd, 1       ; disable validation for user-specified binaries
SYSINIT:0A70                 mov     byte ptr commnd[bx], 0 ; NULL-terminate it before execing it
SYSINIT:0A75                 mov     word ptr command_line, 0D00h ; "\x02/P"
SYSINIT:0A7B                 jmp     short do_exec
SYSINIT:0A7D ; ---------------------------------------------------------------------------
SYSINIT:0A7D
SYSINIT:0A7D do_alt:                                 ; CODE XREF: SYSINIT:0A27↑j
SYSINIT:0A7D                                         ; SYSINIT:0A2F↑j ...
SYSINIT:0A7D                 push    ds
SYSINIT:0A7E                 pop     es
SYSINIT:0A7F                 mov     newcmd, 0       ; force validation for alternate binaries
SYSINIT:0A84                 mov     di, offset commnd ; "\\COMMAND.COM"
SYSINIT:0A87
SYSINIT:0A87 do_alt1:                                ; CODE XREF: SYSINIT:0A8F↓j
SYSINIT:0A87                 lodsb                   ; copy the alternate, zapping it as we go
SYSINIT:0A88                 mov     byte ptr [si-1], 0 ; so that we know it's been tried
SYSINIT:0A8C                 stosb
SYSINIT:0A8D                 or      al, al
SYSINIT:0A8F                 jnz     short do_alt1
SYSINIT:0A91                 mov     di, offset command_line ; "\x02/P"
SYSINIT:0A94                 cmp     byte ptr [si+2], ':'
SYSINIT:0A98                 jnz     short do_alt2
SYSINIT:0A9A                 mov     [si+1], dl      ; stuff default drive into alt. command line
SYSINIT:0A9D
SYSINIT:0A9D do_alt2:                                ; CODE XREF: SYSINIT:0A98↑j
SYSINIT:0A9D                                         ; SYSINIT:0AA1↓j
SYSINIT:0A9D                 lodsb
SYSINIT:0A9E                 stosb
SYSINIT:0A9F                 or      al, al
SYSINIT:0AA1                 jnz     short do_alt2
SYSINIT:0AA3                 mov     byte ptr [di-1], 0Dh ; cr
SYSINIT:0AA7                 mov     dae_flag, 0
SYSINIT:0AAC                 call    disable_autoexec
SYSINIT:0AAF                 call    CheckQueryOpt
SYSINIT:0AB2
SYSINIT:0AB2 do_exec:                                ; CODE XREF: SYSINIT:0A7B↑j
SYSINIT:0AB2                 jmp     retry
SYSINIT:0AB5
SYSINIT:0AB5 ; =============== S U B R O U T I N E =======================================
SYSINIT:0AB5
SYSINIT:0AB5
SYSINIT:0AB5 AllocFreeMem    proc near               ; CODE XREF: SYSINIT:wfk2s_6↑p
SYSINIT:0AB5                                         ; SYSINIT:do_multi_pass↑p
SYSINIT:0AB5                 mov     bx, 0FFFFh
SYSINIT:0AB8                 mov     ah, 48h
SYSINIT:0ABA                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:0ABA                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:0ABC                 mov     ah, 48h
SYSINIT:0ABE                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:0ABE                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:0AC0                 mov     cs:area, ax
SYSINIT:0AC4                 mov     cs:memhi, ax
SYSINIT:0AC8                 retn
SYSINIT:0AC8 AllocFreeMem    endp
SYSINIT:0AC8
SYSINIT:0AC8 ; ---------------------------------------------------------------------------
SYSINIT:0AC9 DOSLOMSG        db 'HMA not available: Loading DOS low',0Dh,0Ah,'$'
SYSINIT:0AC9                                         ; DATA XREF: SYSINIT:0B26↓o
SYSINIT:0AEE FEmsg           db 'Fatal Error: Cannot allocate Memory for DOS',0Dh,0Ah,'$'
SYSINIT:0AEE                                         ; DATA XREF: AllocMemForDOS+70↓o
SYSINIT:0B1C ; ---------------------------------------------------------------------------
SYSINIT:0B1C
SYSINIT:0B1C LoadDOSHiOrLo:                          ; CODE XREF: SYSINIT:08BD↑p
SYSINIT:0B1C                 call    TryToMovDOSHi   ; Try moving it into HMA
SYSINIT:0B1F                 jb      short LdngLo    ; If that don't work...
SYSINIT:0B21                 retn
SYSINIT:0B22 ; ---------------------------------------------------------------------------
SYSINIT:0B22
SYSINIT:0B22 LdngLo:                                 ; CODE XREF: SYSINIT:0B1F↑j
SYSINIT:0B22                 push    cs
SYSINIT:0B23                 pop     ds
SYSINIT:0B24                 mov     ah, 9
SYSINIT:0B26                 mov     dx, offset DOSLOMSG ; "HMA not available: Loading DOS low\r\n$"
SYSINIT:0B29                 int     21h             ; DOS - PRINT STRING
SYSINIT:0B29                                         ; DS:DX -> string terminated by "$"
SYSINIT:0B2B                 mov     bx, 1           ; use int 21 alloc for mem
SYSINIT:0B2E                 call    MovDOSLo
SYSINIT:0B31                 mov     es, cs:CURRENTDOSLOCATION ; give dos its temporary loc.
SYSINIT:0B36                 assume es:nothing
SYSINIT:0B36                 xor     ax, ax
SYSINIT:0B38                 call    cs:dos_segreinit
SYSINIT:0B3D                 mov     cs:runhigh, 0   ; mark that we are running lo
SYSINIT:0B43                 retn
SYSINIT:0B44
SYSINIT:0B44 ; =============== S U B R O U T I N E =======================================
SYSINIT:0B44
SYSINIT:0B44
SYSINIT:0B44 TryToMovDOSHi   proc near               ; CODE XREF: SYSINIT:LoadDOSHiOrLo↑p
SYSINIT:0B44                                         ; SYSINIT:0CAF↓p ...
SYSINIT:0B44                 call    MovDOSHi
SYSINIT:0B47                 jb      short ttldhx
SYSINIT:0B49                 mov     es, cs:CURRENTDOSLOCATION ; give dos its temporary loc.
SYSINIT:0B4E                 xor     ax, ax          ; ax = 0 --> install stub
SYSINIT:0B50                 call    cs:dos_segreinit
SYSINIT:0B55                 mov     cs:runhigh, 1
SYSINIT:0B5B                 clc
SYSINIT:0B5C
SYSINIT:0B5C ttldhx:                                 ; CODE XREF: TryToMovDOSHi+3↑j
SYSINIT:0B5C                 retn
SYSINIT:0B5C TryToMovDOSHi   endp
SYSINIT:0B5C
SYSINIT:0B5D
SYSINIT:0B5D ; =============== S U B R O U T I N E =======================================
SYSINIT:0B5D
SYSINIT:0B5D
SYSINIT:0B5D MovDOSHi        proc near               ; CODE XREF: TryToMovDOSHi↑p
SYSINIT:0B5D
SYSINIT:0B5D arg_B86         = word ptr  0B88h
SYSINIT:0B5D
SYSINIT:0B5D                 call    AllocHMA        ; did we get HMA?
SYSINIT:0B60                 jb      short mdhx      ; no
SYSINIT:0B62                 mov     ax, 0FFFFh      ; yes, HMA seg = 0ffffh
SYSINIT:0B65                 mov     es, ax
SYSINIT:0B67                 assume es:nothing
SYSINIT:0B67                 call    MovBIOS         ; First move BIOS into HMA
SYSINIT:0B6A                 mov     cx, cs:hi_doscod_size ; when it is in HMA
SYSINIT:0B6F                 call    MovDOS          ; and move it
SYSINIT:0B72                 call    SaveFreeHMAPtr
SYSINIT:0B75                 clc
SYSINIT:0B76
SYSINIT:0B76 mdhx:                                   ; CODE XREF: MovDOSHi+3↑j
SYSINIT:0B76                 retn
SYSINIT:0B76 MovDOSHi        endp
SYSINIT:0B76
SYSINIT:0B77
SYSINIT:0B77 ; =============== S U B R O U T I N E =======================================
SYSINIT:0B77
SYSINIT:0B77
SYSINIT:0B77 MovDOSLo        proc near               ; CODE XREF: SYSINIT:083B↑p
SYSINIT:0B77                                         ; SYSINIT:0B2E↑p
SYSINIT:0B77                 call    AllocMemForDOS  ; incestuosly!
SYSINIT:0B7A                 mov     es, ax          ; pass the segment to MovBIOS
SYSINIT:0B7C                 assume es:nothing
SYSINIT:0B7C                 call    MovBIOS
SYSINIT:0B7F                 mov     cx, cs:lo_doscod_size ; DOS code size when loaded
SYSINIT:0B84                 call    MovDOS
SYSINIT:0B87                 retn
SYSINIT:0B87 MovDOSLo        endp
SYSINIT:0B87
SYSINIT:0B88
SYSINIT:0B88 ; =============== S U B R O U T I N E =======================================
SYSINIT:0B88
SYSINIT:0B88
SYSINIT:0B88 MovBIOS         proc near               ; CODE XREF: MovDOSHi+A↑p
SYSINIT:0B88                                         ; MovDOSLo+5↑p
SYSINIT:0B88                 mov     ds, cs:temp_bcode_seg
SYSINIT:0B8D                 assume ds:nothing
SYSINIT:0B8D                 mov     si, 30h         ; BCODE_START
SYSINIT:0B90                 mov     di, si
SYSINIT:0B92                 mov     cx, 1E00h       ; BCODE_END
SYSINIT:0B95                 sub     cx, si          ; size of BIOS
SYSINIT:0B97                 shr     cx, 1           ; Both the labels are para aligned
SYSINIT:0B99                 rep movsw
SYSINIT:0B9B                 push    es
SYSINIT:0B9C                 push    di              ; save end of BIOS
SYSINIT:0B9D                 mov     ax, es
SYSINIT:0B9F                 mov     cs:BCodeSeg, ax ; save it for later use
SYSINIT:0BA3                 call    dword ptr cs:_seg_reinit_ptr ; far call to seg_reinit
SYSINIT:0BA3                                         ; call far [cs:seg_reinit_ptr]
SYSINIT:0BA8                 pop     di              ; get back end of BIOS
SYSINIT:0BA9                 pop     es
SYSINIT:0BAA                 retn
SYSINIT:0BAA MovBIOS         endp
SYSINIT:0BAA
SYSINIT:0BAB
SYSINIT:0BAB ; =============== S U B R O U T I N E =======================================
SYSINIT:0BAB
SYSINIT:0BAB
SYSINIT:0BAB MovDOS          proc near               ; CODE XREF: MovDOSHi+12↑p
SYSINIT:0BAB                                         ; MovDOSLo+D↑p
SYSINIT:0BAB                 push    es
SYSINIT:0BAC                 push    di
SYSINIT:0BAD                 lds     si, dword ptr cs:dosinit
SYSINIT:0BB2                 rep movsb
SYSINIT:0BB4                 pop     bx              ; get back offset into which DOS was moved
SYSINIT:0BB5                 mov     ax, cs:dosinit  ; get the offset at which DOS wants to run
SYSINIT:0BB9                 sub     ax, bx
SYSINIT:0BBB                 call    _off_to_para
SYSINIT:0BBE                 pop     bx              ; get the segment at which we moved DOS into
SYSINIT:0BBF                 sub     bx, ax          ; Adjust segment
SYSINIT:0BC1                 mov     cs:CURRENTDOSLOCATION, bx ; and save it
SYSINIT:0BC6                 retn
SYSINIT:0BC6 MovDOS          endp
SYSINIT:0BC6
SYSINIT:0BC7
SYSINIT:0BC7 ; =============== S U B R O U T I N E =======================================
SYSINIT:0BC7
SYSINIT:0BC7
SYSINIT:0BC7 AllocMemForDOS  proc near               ; CODE XREF: MovDOSLo↑p
SYSINIT:0BC7
SYSINIT:0BC7 ; FUNCTION CHUNK AT SYSINIT:1468 SIZE 00000001 BYTES
SYSINIT:0BC7
SYSINIT:0BC7                 mov     ax, 1E00h       ; BCODE_END
SYSINIT:0BCA                 sub     ax, 30h         ; BCODE_START
SYSINIT:0BCA                                         ; BCODE_END-BCODE_START = BIOS code size
SYSINIT:0BCD                 add     ax, cs:lo_doscod_size
SYSINIT:0BD2                 add     ax, 15
SYSINIT:0BD5                 call    _off_to_para    ; convert to para
SYSINIT:0BD8                 or      bx, bx          ; can we use int 21h for alloc ?
SYSINIT:0BDA                 mov     bx, ax
SYSINIT:0BDC                 jz      short update_arena ; no
SYSINIT:0BDE                 mov     ah, 48h
SYSINIT:0BE0                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:0BE0                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:0BE2                 jb      short FatalErr
SYSINIT:0BE4                 sub     ax, 3           ; Take care ORG 30h of BIOS code
SYSINIT:0BE7                 mov     es, ax
SYSINIT:0BE9                 mov     word ptr es:21h, 8 ; [es:20h+ARENA.OWNER],08h
SYSINIT:0BF0                 mov     word ptr es:28h, 4353h ; 'SC' ; mark it as system code area
SYSINIT:0BF7                 retn
SYSINIT:0BF8 ; ---------------------------------------------------------------------------
SYSINIT:0BF8
SYSINIT:0BF8 update_arena:                           ; CODE XREF: AllocMemForDOS+15↑j
SYSINIT:0BF8                 push    ds
SYSINIT:0BF9                 push    di
SYSINIT:0BFA                 push    cx
SYSINIT:0BFB                 push    dx
SYSINIT:0BFC                 lds     di, cs:DOSINFO  ; get ptr to DOS var
SYSINIT:0C01                 dec     di
SYSINIT:0C02                 dec     di              ; Arena head is immediately before sysvar
SYSINIT:0C03                 mov     es, word ptr [di] ; es = arena head
SYSINIT:0C05                 mov     cx, es:3        ; [es:ARENA.SIZE] ; total low mem size
SYSINIT:0C0A                 cmp     cx, bx          ; is it sufficient ?
SYSINIT:0C0C                 jb      short FatalErr  ; no, fatal error
SYSINIT:0C0E                 mov     dl, es:0        ; [es:ARENA.SIGNATURE]
SYSINIT:0C13                 mov     ax, es
SYSINIT:0C15                 add     ax, bx          ; ax = new arena head
SYSINIT:0C17                 mov     [di], ax        ; store it in DOS data area
SYSINIT:0C19                 mov     ds, ax
SYSINIT:0C1B                 mov     ds:0, dl        ; [ARENA.SIGNATURE] ; type of arena
SYSINIT:0C1F                 mov     word ptr ds:1, 0 ; [ARENA.OWNER],0 ; free
SYSINIT:0C25                 sub     cx, bx          ; size of the new block
SYSINIT:0C27                 mov     ds:3, cx        ; [ARENA.SIZE],cx ; store it in the arena
SYSINIT:0C2B                 mov     ax, es          ; return seg to the caller
SYSINIT:0C2D                 sub     ax, 3           ; Take care ORG 30h of BIOS code
SYSINIT:0C30                 pop     dx
SYSINIT:0C31                 pop     cx
SYSINIT:0C32                 pop     di
SYSINIT:0C33                 pop     ds
SYSINIT:0C34                 retn
SYSINIT:0C35 ; ---------------------------------------------------------------------------
SYSINIT:0C35
SYSINIT:0C35 FatalErr:                               ; CODE XREF: AllocMemForDOS+1B↑j
SYSINIT:0C35                                         ; AllocMemForDOS+45↑j
SYSINIT:0C35                 push    cs
SYSINIT:0C36                 pop     ds
SYSINIT:0C37                 assume ds:SYSINIT
SYSINIT:0C37                 mov     dx, offset FEmsg ; "Fatal Error: Cannot allocate Memory for"...
SYSINIT:0C3A                 mov     ah, 9
SYSINIT:0C3C                 int     21h             ; DOS - PRINT STRING
SYSINIT:0C3C                                         ; DS:DX -> string terminated by "$"
SYSINIT:0C3E                 jmp     stall
SYSINIT:0C3E AllocMemForDOS  endp ; sp-analysis failed
SYSINIT:0C3E
SYSINIT:0C41
SYSINIT:0C41 ; =============== S U B R O U T I N E =======================================
SYSINIT:0C41
SYSINIT:0C41
SYSINIT:0C41 AllocHMA        proc near               ; CODE XREF: MovDOSHi↑p
SYSINIT:0C41                 push    ds
SYSINIT:0C42                 mov     ax, 70h         ; DOSBIODATASEG ; BIOSDATA segment
SYSINIT:0C45                 mov     ds, ax
SYSINIT:0C47                 assume ds:nothing
SYSINIT:0C47                 call    IsXMSLoaded
SYSINIT:0C4A                 jnz     short grabhma_error
SYSINIT:0C4C                 mov     ax, 4310h
SYSINIT:0C4F                 int     2Fh             ; - Multiplex - XMS - GET DRIVER ADDRESS
SYSINIT:0C4F                                         ; Return: ES:BX -> driver entry point
SYSINIT:0C51                 mov     word ptr ds:xms, bx
SYSINIT:0C55                 mov     word ptr ds:xms+2, es
SYSINIT:0C59                 mov     ah, 1           ; request HMA
SYSINIT:0C5B                 mov     dx, 0FFFFh
SYSINIT:0C5E                 call    ds:xms          ; call far [xms]
SYSINIT:0C62                 dec     ax
SYSINIT:0C63                 jz      short allocHMA_1 ; error if not able to allocate HMA
SYSINIT:0C65                 mov     ah, 88h
SYSINIT:0C67                 int     15h             ; Get Extended Memory Size
SYSINIT:0C67                                         ; Return: CF clear on success
SYSINIT:0C67                                         ; AX = size of memory above 1M in K
SYSINIT:0C69                 cmp     ax, 64          ; less than 64 K of hma ?
SYSINIT:0C6C                 jb      short grabhma_error
SYSINIT:0C6E
SYSINIT:0C6E allocHMA_1:                             ; CODE XREF: AllocHMA+22↑j
SYSINIT:0C6E                 mov     ah, 5           ; localenableA20
SYSINIT:0C70                 call    ds:xms
SYSINIT:0C74                 dec     ax
SYSINIT:0C75                 jnz     short grabhma_error ; error if couldn't enable A20
SYSINIT:0C77                 call    IsVDiskInstalled
SYSINIT:0C7A                 jz      short grabhma_error ; yes, we cant use HMA
SYSINIT:0C7C                 mov     ax, 0FFFFh
SYSINIT:0C7F                 mov     es, ax
SYSINIT:0C81                 assume es:nothing
SYSINIT:0C81                 mov     word ptr es:10h, 1234h ; see if we can really read/write there
SYSINIT:0C88                 cmp     word ptr es:10h, 1234h
SYSINIT:0C8F                 jnz     short grabhma_error ; don't try to load there if XMS lied
SYSINIT:0C91                 clc
SYSINIT:0C92                 pop     ds
SYSINIT:0C93                 assume ds:nothing
SYSINIT:0C93                 retn
SYSINIT:0C94 ; ---------------------------------------------------------------------------
SYSINIT:0C94
SYSINIT:0C94 grabhma_error:                          ; CODE XREF: AllocHMA+9↑j
SYSINIT:0C94                                         ; AllocHMA+2B↑j ...
SYSINIT:0C94                 stc
SYSINIT:0C95                 pop     ds
SYSINIT:0C96                 retn
SYSINIT:0C96 AllocHMA        endp
SYSINIT:0C96
SYSINIT:0C97
SYSINIT:0C97 ; =============== S U B R O U T I N E =======================================
SYSINIT:0C97
SYSINIT:0C97
SYSINIT:0C97 IsXMSLoaded     proc near               ; CODE XREF: AllocHMA+6↑p
SYSINIT:0C97                                         ; InitAllocUMB↓p
SYSINIT:0C97                 mov     ax, 4300h
SYSINIT:0C9A                 int     2Fh             ; - Multiplex - XMS - INSTALLATION CHECK
SYSINIT:0C9A                                         ; Return: AL = 80h XMS driver installed
SYSINIT:0C9A                                         ; AL <> 80h no driver
SYSINIT:0C9C                 cmp     al, 80h         ; XMS installed?
SYSINIT:0C9E                 retn
SYSINIT:0C9E IsXMSLoaded     endp
SYSINIT:0C9E
SYSINIT:0C9F ; ---------------------------------------------------------------------------
SYSINIT:0C9F
SYSINIT:0C9F FTRYTOMOVDOSHI:                         ; DATA XREF: BIOSDATA:MoveDOSIntoHMA↑o
SYSINIT:0C9F                 push    ax
SYSINIT:0CA0                 push    bx
SYSINIT:0CA1                 push    cx
SYSINIT:0CA2                 push    dx
SYSINIT:0CA3                 push    si
SYSINIT:0CA4                 push    di
SYSINIT:0CA5                 push    ds
SYSINIT:0CA6                 push    es
SYSINIT:0CA7                 cmp     cs:runhigh, 0FFh
SYSINIT:0CAD                 jnz     short _ftymdh_1
SYSINIT:0CAF                 call    TryToMovDOSHi
SYSINIT:0CB2
SYSINIT:0CB2 _ftymdh_1:                              ; CODE XREF: SYSINIT:0CAD↑j
SYSINIT:0CB2                 pop     es
SYSINIT:0CB3                 assume es:nothing
SYSINIT:0CB3                 pop     ds
SYSINIT:0CB4                 pop     di
SYSINIT:0CB5                 pop     si
SYSINIT:0CB6                 pop     dx
SYSINIT:0CB7                 pop     cx
SYSINIT:0CB8                 pop     bx
SYSINIT:0CB9                 pop     ax
SYSINIT:0CBA                 retf
SYSINIT:0CBA ; ---------------------------------------------------------------------------
SYSINIT:0CBB                 db 0
SYSINIT:0CBC StartVDHead     dd 0                    ; DATA XREF: InstVDiskHeader+3A↓o
SYSINIT:0CBC                                         ; link to next device driver
SYSINIT:0CC0                 dw 8000h                ; device attribute
SYSINIT:0CC2                 dw 0                    ; strategy routine offset
SYSINIT:0CC4                 dw 0                    ; interrupt routine offset
SYSINIT:0CC6                 db 1
SYSINIT:0CC7                 db 7 dup(0)             ; reserved area
SYSINIT:0CCE VDiskSig1       db 'VDISK'              ; DATA XREF: IsVDiskInstalled+10↓o
SYSINIT:0CD3                 db '  V3.3'             ; vdisk label ; VLEN1 equ ($-VDiskSig1)
SYSINIT:0CD9                 db 15 dup(0)            ; pad
SYSINIT:0CE8                 dw 0                    ; bits 0-15 of free HMA
SYSINIT:0CEA                 db 11h                  ; bits 16-23 of free HMA (1M + 64K)
SYSINIT:0CEB VDInt19         db 0EAh                 ; jmp to old vector
SYSINIT:0CEC OldVDInt19      dw 2 dup(0)             ; DATA XREF: InstVDiskHeader+7↓w
SYSINIT:0CEC                                         ; InstVDiskHeader+E↓w
SYSINIT:0CF0 VDiskHMAHead    db 0, 0, 0              ; DATA XREF: InstVDiskHeader+52↓o
SYSINIT:0CF0                                         ; EndVDHead
SYSINIT:0CF0                                         ; non-bootable disk
SYSINIT:0CF3 VDiskSig2       db 'VDISK'              ; DATA XREF: IsVDiskInstalled+1F↓o
SYSINIT:0CF8                 db '3.3'                ; VLEN2 equ ($-VDiskSig2)
SYSINIT:0CF8                                         ; OEM - signature
SYSINIT:0CFB                 dw 128                  ; number of bytes/sector
SYSINIT:0CFD                 db 1                    ; sectors/cluster
SYSINIT:0CFE                 dw 1                    ; reserved sectors
SYSINIT:0D00                 db 1                    ; number of FAT copies
SYSINIT:0D01                 dw 64                   ; number of root dir entries
SYSINIT:0D03                 dw 512                  ; number of sectors
SYSINIT:0D05                 db 0FEh                 ; media descriptor
SYSINIT:0D06                 dw 6                    ; number of sectors/FAT
SYSINIT:0D08                 dw 8                    ; sectors per track
SYSINIT:0D0A                 dw 1                    ; number of heads
SYSINIT:0D0C                 dw 0                    ; number of hidden sectors
SYSINIT:0D0E                 dw 440h                 ; Start of free HMA in K (1M+64K)
SYSINIT:0D10
SYSINIT:0D10 ; =============== S U B R O U T I N E =======================================
SYSINIT:0D10
SYSINIT:0D10
SYSINIT:0D10 InstVDiskHeader proc near               ; CODE XREF: SYSINIT:0910↑p
SYSINIT:0D10                 xor     ax, ax          ; EndVDiskHMAHead (SYSINIT:0D10h)
SYSINIT:0D12                 mov     ds, ax          ; seg of int vect table
SYSINIT:0D12                                         ; save old int 19 vector
SYSINIT:0D14                 assume ds:nothing
SYSINIT:0D14                 mov     ax, word ptr ds:64h ; [19h*4]
SYSINIT:0D17                 mov     cs:OldVDInt19, ax
SYSINIT:0D1B                 mov     ax, word ptr ds:66h ; [19h*4+2]
SYSINIT:0D1E                 mov     cs:OldVDInt19+2, ax
SYSINIT:0D22                 mov     ah, 48h
SYSINIT:0D24                 mov     bx, 4
SYSINIT:0D27                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:0D27                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:0D29                 dec     ax
SYSINIT:0D2A                 mov     es, ax
SYSINIT:0D2C                 mov     word ptr es:1, 8 ; [es:ARENA.OWNER],8 ; owner = System
SYSINIT:0D33                 mov     word ptr es:8, 4353h ; [es:ARENA.NAME],'SC' ; System Code
SYSINIT:0D3A                 inc     ax
SYSINIT:0D3B                 mov     es, ax          ; get back to allocated memory
SYSINIT:0D3D                 cli                     ; no reboots at this time
SYSINIT:0D3D                                         ; install new int 19 vector
SYSINIT:0D3E                 mov     word ptr ds:64h, 47 ; (VDInt19-StartVDHead)
SYSINIT:0D3E                                         ; 0CEBh-0CBCh = 2Fh = 47
SYSINIT:0D44                 mov     word ptr ds:66h, ax
SYSINIT:0D47                 mov     cx, 52          ; (EndVDHead-StartVDHead)
SYSINIT:0D4A                 mov     si, offset StartVDHead ; SYSINIT:0CBCh
SYSINIT:0D4D                 xor     di, di
SYSINIT:0D4F                 push    cs
SYSINIT:0D50                 pop     ds
SYSINIT:0D51                 assume ds:SYSINIT
SYSINIT:0D51                 cld
SYSINIT:0D52                 rep movsb
SYSINIT:0D54                 sti                     ; mov the HMA VDisk head into HMA
SYSINIT:0D55                 push    di
SYSINIT:0D56                 push    es
SYSINIT:0D57                 mov     ax, 0FFFFh
SYSINIT:0D5A                 mov     es, ax
SYSINIT:0D5C                 assume es:nothing
SYSINIT:0D5C                 mov     di, 10h
SYSINIT:0D5F                 mov     cx, 32          ; (EndVDiskHMAHead-VDiskHMAHead)
SYSINIT:0D62                 mov     si, offset VDiskHMAHead ; SYSINIT:0CF0h
SYSINIT:0D65                 rep movsb
SYSINIT:0D67                 pop     di
SYSINIT:0D68                 pop     es
SYSINIT:0D69                 assume es:nothing
SYSINIT:0D69                 retn
SYSINIT:0D69 InstVDiskHeader endp
SYSINIT:0D69
SYSINIT:0D69 ; ---------------------------------------------------------------------------
SYSINIT:0D6A dummy           db 8 dup(0)             ; DATA XREF: ClrVDISKHeader+3A↓o
SYSINIT:0D6A                                         ; bmove
SYSINIT:0D72 gdt             db 8 dup(0)             ; times desc.size db 0
SYSINIT:0D7A src_desc        dw 0FFFFh               ; des <0ffffh,0,0,93h,0>
SYSINIT:0D7C desc_lo_word    dw 0                    ; DATA XREF: ClrVDISKHeader+2C↓w
SYSINIT:0D7E desc_hi_byte    db 0                    ; DATA XREF: ClrVDISKHeader+30↓w
SYSINIT:0D7F                 db 93h
SYSINIT:0D80                 dw 0
SYSINIT:0D82 tgt_desc        dw 0FFFFh               ; desc <0ffffh,0,10h,93h,0>  ; 1MB
SYSINIT:0D82                                         ; desc.seg_lim
SYSINIT:0D84                 dw 0                    ; desc.lo_word
SYSINIT:0D86                 db 10h                  ; desc.hi_byte
SYSINIT:0D87                 db 93h                  ; desc.acc_rights
SYSINIT:0D88                 dw 0                    ; desc.reserved
SYSINIT:0D8A rombios_code    db 8 dup(0)             ; times desc.size db 0
SYSINIT:0D92 temp_stack      db 8 dup(0)
SYSINIT:0D9A ClrdVDISKHead   db 32 dup(0)            ; DATA XREF: ClrVDISKHeader+26↓o
SYSINIT:0DBA
SYSINIT:0DBA ; =============== S U B R O U T I N E =======================================
SYSINIT:0DBA
SYSINIT:0DBA
SYSINIT:0DBA ClrVDISKHeader  proc near               ; CODE XREF: SYSINIT:0639↑p
SYSINIT:0DBA                 in      al, 64h         ; 8042 keyboard controller status register
SYSINIT:0DBA                                         ; 7:  PERR    1=parity error in data received from keyboard
SYSINIT:0DBA                                         ;    +----------- AT Mode ----------+------------ PS/2 Mode ------------+
SYSINIT:0DBA                                         ; 6: |RxTO    receive (Rx) timeout  | TO      general timeout (Rx or Tx)|
SYSINIT:0DBA                                         ; 5: |TxTO    transmit (Tx) timeout | MOBF    mouse output buffer full  |
SYSINIT:0DBA                                         ;    +------------------------------+-----------------------------------+
SYSINIT:0DBA                                         ; 4:  INH     0=keyboard communications inhibited
SYSINIT:0DBA                                         ; 3:  A2      0=60h was the port last written to, 1=64h was last
SYSINIT:0DBA                                         ; 2:  SYS     distinguishes reset types: 0=cold reboot, 1=warm reboot
SYSINIT:0DBA                                         ; 1:  IBF     1=input buffer full (keyboard can't accept data)
SYSINIT:0DBA                                         ; 0:  OBF     1=output buffer full (data from keyboard is available)
SYSINIT:0DBC                 test    al, 10h         ; test bit 4 - Is keyboard inhibited?
SYSINIT:0DBE                 jnz     short ClrVDISKok ; No, go do block move
SYSINIT:0DC0                 cmp     word ptr cs:sys_model_byte, 19F8h ; check for TORTUGA models
SYSINIT:0DC7                 jz      short ClrVDISKno ; do not use INT 15h block move code
SYSINIT:0DC7                                         ; (while 8042 is disabled)
SYSINIT:0DC9                 cmp     word ptr cs:sys_model_byte, 9FCh ; Check for PS/2 30-286 model
SYSINIT:0DD0                 jnz     short ClrVDISKok
SYSINIT:0DD2
SYSINIT:0DD2 ClrVDISKno:                             ; CODE XREF: ClrVDISKHeader+D↑j
SYSINIT:0DD2                 retn
SYSINIT:0DD3 ; ---------------------------------------------------------------------------
SYSINIT:0DD3
SYSINIT:0DD3 ClrVDISKok:                             ; CODE XREF: ClrVDISKHeader+4↑j
SYSINIT:0DD3                                         ; ClrVDISKHeader+16↑j
SYSINIT:0DD3                 push    es
SYSINIT:0DD4                 mov     ax, cs
SYSINIT:0DD6                 mov     dx, ax
SYSINIT:0DD8                 mov     cl, 12
SYSINIT:0DDA                 shr     dx, cl          ; dx = higher 4 bits of the segment number
SYSINIT:0DDA                                         ;    = segment number / 4096 (= byte address / 65536)
SYSINIT:0DDC                 mov     cl, 4
SYSINIT:0DDE                 shl     ax, cl          ; ax = (lower 12 bits of the segment number)*16
SYSINIT:0DE0                 add     ax, offset ClrdVDISKHead
SYSINIT:0DE3                 adc     dl, 0           ; dl:ax = 24 bit linear address
SYSINIT:0DE6                 mov     cs:desc_lo_word, ax
SYSINIT:0DEA                 mov     cs:desc_hi_byte, dl
SYSINIT:0DEF                 mov     cx, 16          ; 16 words
SYSINIT:0DF2                 push    cs
SYSINIT:0DF3                 pop     es
SYSINIT:0DF4                 assume es:SYSINIT
SYSINIT:0DF4                 mov     si, offset dummy ; offset bmove
SYSINIT:0DF7                 mov     ah, 87h
SYSINIT:0DF9                 int     15h             ; EXTENDED MEMORY - BLOCK MOVE (AT,XT286,PS)
SYSINIT:0DF9                                         ; CX = number of words to move, ES:SI -> global descriptor table
SYSINIT:0DF9                                         ; Return: CF set on error, AH = status
SYSINIT:0DFB                 pop     es
SYSINIT:0DFC                 assume es:nothing
SYSINIT:0DFC                 retn
SYSINIT:0DFC ClrVDISKHeader  endp
SYSINIT:0DFC
SYSINIT:0DFD
SYSINIT:0DFD ; =============== S U B R O U T I N E =======================================
SYSINIT:0DFD
SYSINIT:0DFD
SYSINIT:0DFD SaveFreeHMAPtr  proc near               ; CODE XREF: MovDOSHi+15↑p
SYSINIT:0DFD                 mov     bx, es
SYSINIT:0DFF                 mov     ax, 0FFFFh      ; HMA segment
SYSINIT:0E02                 sub     ax, bx
SYSINIT:0E04                 add     di, 15          ; para round
SYSINIT:0E07                 and     di, 0FFF0h
SYSINIT:0E0A                 mov     cl, 4
SYSINIT:0E0C                 shl     ax, cl
SYSINIT:0E0E                 sub     di, ax
SYSINIT:0E10                 push    ds
SYSINIT:0E11                 mov     ax, 70h         ; DOSBIODATASEG ; BIOSDATA segment
SYSINIT:0E14                 mov     ds, ax
SYSINIT:0E16                 assume ds:nothing
SYSINIT:0E16                 mov     ds:FreeHMAPtr, di ; BIOSDATA:07D7h
SYSINIT:0E1A                 mov     ds:inHMA, 0FFh  ; BIOSDATA:000Dh
SYSINIT:0E1F                 pop     ds
SYSINIT:0E20                 assume ds:nothing
SYSINIT:0E20                 retn
SYSINIT:0E20 SaveFreeHMAPtr  endp
SYSINIT:0E20
SYSINIT:0E21
SYSINIT:0E21 ; =============== S U B R O U T I N E =======================================
SYSINIT:0E21
SYSINIT:0E21
SYSINIT:0E21 IsVDiskInstalled proc near              ; CODE XREF: AllocHMA+36↑p
SYSINIT:0E21                 xor     ax, ax
SYSINIT:0E23                 mov     ds, ax
SYSINIT:0E25                 assume ds:nothing
SYSINIT:0E25                 mov     ds, word ptr ds:4Eh ; [13h*4+2]
SYSINIT:0E29                 assume ds:nothing
SYSINIT:0E29                 mov     si, 12h         ; VDiskSig1-StartVDHead
SYSINIT:0E2C                 mov     cx, 5           ; VLEN1
SYSINIT:0E2F                 push    cs
SYSINIT:0E30                 pop     es
SYSINIT:0E31                 assume es:SYSINIT
SYSINIT:0E31                 mov     di, offset VDiskSig1 ; "VDISK"
SYSINIT:0E34                 repe cmpsb
SYSINIT:0E36                 jz      short ivdins_retn
SYSINIT:0E38                 mov     ax, 0FFFFh
SYSINIT:0E3B                 mov     ds, ax
SYSINIT:0E3D                 assume ds:nothing
SYSINIT:0E3D                 mov     si, 13h         ; 10h+(VDiskSig2-VDiskHMAHead)
SYSINIT:0E40                 mov     di, offset VDiskSig2 ; "VDISK"
SYSINIT:0E43                 mov     cx, 5
SYSINIT:0E46                 repe cmpsb
SYSINIT:0E48
SYSINIT:0E48 ivdins_retn:                            ; CODE XREF: IsVDiskInstalled+15↑j
SYSINIT:0E48                 retn
SYSINIT:0E48 IsVDiskInstalled endp
SYSINIT:0E48
SYSINIT:0E49
SYSINIT:0E49 ; =============== S U B R O U T I N E =======================================
SYSINIT:0E49
SYSINIT:0E49
SYSINIT:0E49 CPMHack         proc near               ; CODE XREF: SYSINIT:08C8↑p
SYSINIT:0E49                 push    ds
SYSINIT:0E4A                 mov     cx, 0FFFFh
SYSINIT:0E4D                 mov     es, cx
SYSINIT:0E4F                 assume es:nothing
SYSINIT:0E4F                 xor     cx, cx
SYSINIT:0E51                 mov     ds, cx          ; 0
SYSINIT:0E53                 assume ds:nothing
SYSINIT:0E53                 mov     si, 0C0h
SYSINIT:0E56                 mov     di, 0D0h
SYSINIT:0E59                 mov     cx, 5
SYSINIT:0E5C                 cld
SYSINIT:0E5D                 rep movsb               ; move 5 bytes from 0:C0h to FFFFh:D0h
SYSINIT:0E5F                 pop     ds
SYSINIT:0E60                 assume ds:nothing
SYSINIT:0E60                 retn
SYSINIT:0E60 CPMHack         endp
SYSINIT:0E60
SYSINIT:0E61
SYSINIT:0E61 ; =============== S U B R O U T I N E =======================================
SYSINIT:0E61
SYSINIT:0E61
SYSINIT:0E61 _off_to_para    proc near               ; CODE XREF: SYSINIT:04AE↑p
SYSINIT:0E61                                         ; SYSINIT:04BA↑p ...
SYSINIT:0E61                 shr     ax, 1
SYSINIT:0E63                 shr     ax, 1
SYSINIT:0E65                 shr     ax, 1
SYSINIT:0E67                 shr     ax, 1
SYSINIT:0E69                 retn
SYSINIT:0E69 _off_to_para    endp
SYSINIT:0E69
SYSINIT:0E6A
SYSINIT:0E6A ; =============== S U B R O U T I N E =======================================
SYSINIT:0E6A
SYSINIT:0E6A
SYSINIT:0E6A TempCDS         proc near               ; CODE XREF: SYSINIT:06E3↑p
SYSINIT:0E6A                                         ; MagicPreload+1C9↓p ...
SYSINIT:0E6A                 les     di, ds:DOSINFO
SYSINIT:0E6E                 assume es:nothing
SYSINIT:0E6E                 mov     cl, es:[di+20h] ; [es:di+SYSI_NUMIO]
SYSINIT:0E72                 xor     ch, ch          ; (cx) = # of block devices
SYSINIT:0E74                 mov     es:[di+21h], cl ; [es:di+SYSI_NCDS] ; one CDS per device
SYSINIT:0E78                 mov     al, cl
SYSINIT:0E7A                 mov     ah, 88          ; curdirlen ; curdir_list.size
SYSINIT:0E7C                 mul     ah
SYSINIT:0E7E                 call    ParaRound
SYSINIT:0E81                 mov     si, ds:top_of_cdss
SYSINIT:0E85                 sub     si, ax
SYSINIT:0E87                 mov     es:[di+18h], si ; [es:di+SYSI_CDS+2]
SYSINIT:0E8B                 mov     ax, si
SYSINIT:0E8D                 mov     word ptr es:[di+16h], 0 ; [es:di+SYSI_CDS]
SYSINIT:0E8D                                         ; set address of CDS list
SYSINIT:0E93                 lds     si, es:[di]     ; lds si,[es:di+SYSI_DPB]
SYSINIT:0E93                                         ; (ds:si) = address of first DPB
SYSINIT:0E96                 mov     es, ax
SYSINIT:0E98                 xor     di, di          ; (es:di) = address of 1st CDS
SYSINIT:0E98 TempCDS         endp
SYSINIT:0E98
SYSINIT:0E9A
SYSINIT:0E9A ; =============== S U B R O U T I N E =======================================
SYSINIT:0E9A
SYSINIT:0E9A
SYSINIT:0E9A fooset          proc near               ; CODE XREF: fooset+5B↓j
SYSINIT:0E9A                                         ; endfile+251↓p
SYSINIT:0E9A                 mov     ax, word ptr cs:DirStrng ; "A:\"
SYSINIT:0E9E                 stosw                   ; setup the root as the curdir
SYSINIT:0E9F                 call    get_dpb_for_drive_al ; get dpb for drive in dpb
SYSINIT:0E9F                                         ; (ds:si) = address of DPB
SYSINIT:0E9F                                         ;    (si) = -1 if no drive
SYSINIT:0EA2                 mov     ax, word ptr cs:DirStrng+2 ; "\",0
SYSINIT:0EA6                 stosw
SYSINIT:0EA7                 inc     byte ptr cs:DirStrng ; "A:\"
SYSINIT:0EAC                 xor     ax, ax          ; 0
SYSINIT:0EAE                 push    cx
SYSINIT:0EAF                 mov     cx, 63          ; curdir_list.cdir_flags - 4
SYSINIT:0EB2                 rep stosb               ; zero out rest of CURDIR_TEXTs
SYSINIT:0EB2                                         ; (ax) = 0
SYSINIT:0EB2                                         ; (es:di) = CURDIR_FLAGS in the CDS records
SYSINIT:0EB2                                         ; (ds:si) = Next DPB (-1 if none)
SYSINIT:0EB4                 cmp     si, 0FFFFh      ; -1
SYSINIT:0EB7                 jz      short fooset_zero
SYSINIT:0EB9                 cmp     cs:fake_floppy_drv, 1
SYSINIT:0EBF                 jnz     short normcds   ; machine has floppy drives
SYSINIT:0EC1                 cmp     byte ptr [si], 1 ; cmp [si+DPB.drive],1
SYSINIT:0EC1                                         ; if dpb_drive = 0 (A) or 1 (B).
SYSINIT:0EC4                 ja      short normcds
SYSINIT:0EC6                 mov     cl, 3           ; the next dbp pointer
SYSINIT:0EC8                 rep stosw               ; ax should be zero here
SYSINIT:0ECA                 pop     cx
SYSINIT:0ECB                 jmp     short get_next_dpb
SYSINIT:0ECD ; ---------------------------------------------------------------------------
SYSINIT:0ECD
SYSINIT:0ECD fooset_zero:                            ; CODE XREF: fooset+1D↑j
SYSINIT:0ECD                 mov     cl, 3
SYSINIT:0ECF                 rep stosw
SYSINIT:0ED1                 pop     cx
SYSINIT:0ED2                 jmp     short get_next_dpb ; jmp short fincds
SYSINIT:0ED4 ; ---------------------------------------------------------------------------
SYSINIT:0ED4
SYSINIT:0ED4 normcds:                                ; CODE XREF: fooset+25↑j
SYSINIT:0ED4                                         ; fooset+2A↑j
SYSINIT:0ED4                 pop     cx
SYSINIT:0ED5                 cmp     byte ptr [si+8], 0 ; [si+DPB.FAT_COUNT] ; non fat system?
SYSINIT:0ED9                 jz      short setnormcds ; yes. set curdir_flags to 0. ax = 0 now.
SYSINIT:0EDB                 mov     ax, 4000h       ; curdir_inuse ; else,fat system.
SYSINIT:0EDB                                         ; set the flag to curdir_inuse.
SYSINIT:0EDE
SYSINIT:0EDE setnormcds:                             ; CODE XREF: fooset+3F↑j
SYSINIT:0EDE                 stosw                   ; curdir_flags
SYSINIT:0EDF                 mov     ax, si
SYSINIT:0EE1                 stosw                   ; curdir_devptr
SYSINIT:0EE2                 mov     ax, ds
SYSINIT:0EE4                 stosw
SYSINIT:0EE5
SYSINIT:0EE5 get_next_dpb:                           ; CODE XREF: fooset+31↑j
SYSINIT:0EE5                                         ; fooset+38↑j
SYSINIT:0EE5                 mov     ax, 0FFFFh      ; entry point for fake_fooset_zero
SYSINIT:0EE5                                         ; mov ax,-1
SYSINIT:0EE8                 stosw                   ; curdir_id
SYSINIT:0EE9                 stosw                   ; curdir_id
SYSINIT:0EEA                 stosw                   ; curdir_user_word
SYSINIT:0EEB                 mov     ax, 2           ; curdir_end
SYSINIT:0EEE                 stosw
SYSINIT:0EEF                 mov     al, 0           ; clear out 7 bytes (curdir_type,
SYSINIT:0EF1                 stosb
SYSINIT:0EF2                 stosw                   ; curdir_ifs_hdr,curdir_fsda)
SYSINIT:0EF3                 stosw
SYSINIT:0EF4                 stosw
SYSINIT:0EF5                 loop    fooset
SYSINIT:0EF7                 mov     byte ptr cs:DirStrng, 'A' ; "A:\",0
SYSINIT:0EFD                 retn
SYSINIT:0EFD fooset          endp
SYSINIT:0EFD
SYSINIT:0EFE
SYSINIT:0EFE ; =============== S U B R O U T I N E =======================================
SYSINIT:0EFE
SYSINIT:0EFE
SYSINIT:0EFE get_dpb_for_drive_al proc near          ; CODE XREF: fooset+5↑p
SYSINIT:0EFE                 lds     si, cs:DOSINFO  ; point to first DPB
SYSINIT:0F03                 lds     si, [si]        ; (ds:si) = address of first DPB
SYSINIT:0F05                 sub     al, 'A'
SYSINIT:0F07
SYSINIT:0F07 get_dpb_for_drive_1:                    ; CODE XREF: get_dpb_for_drive_al+13↓j
SYSINIT:0F07                 cmp     al, [si]        ; cmp al,[si+DPB.DRIVE] ; match?
SYSINIT:0F09                 jz      short got_dpb_for_drive
SYSINIT:0F0B                 lds     si, [si+19h]    ; lds si,[si+DPB.NEXT_DPB]
SYSINIT:0F0E                 cmp     si, 0FFFFh
SYSINIT:0F11                 jnz     short get_dpb_for_drive_1 ; loop until hit end of DPBs
SYSINIT:0F13
SYSINIT:0F13 got_dpb_for_drive:                      ; CODE XREF: get_dpb_for_drive_al+B↑j
SYSINIT:0F13                 retn
SYSINIT:0F13 get_dpb_for_drive_al endp
SYSINIT:0F13
SYSINIT:0F14
SYSINIT:0F14 ; =============== S U B R O U T I N E =======================================
SYSINIT:0F14
SYSINIT:0F14
SYSINIT:0F14 endfile         proc near               ; CODE XREF: SYSINIT:088E↑p
SYSINIT:0F14                                         ; SYSINIT:skip_magicpostload↑p
SYSINIT:0F14                 push    ds              ; Build DOS structures
SYSINIT:0F15                 mov     ax, 70h         ; DOSBIODATASEG
SYSINIT:0F18                 mov     ds, ax
SYSINIT:0F1A                 assume ds:nothing
SYSINIT:0F1A                 cmp     ds:multrk_flag, 0 ; multrk_off1
SYSINIT:0F1A                                         ; multrack= command entered?
SYSINIT:0F1F                 jnz     short multrk_flag_done
SYSINIT:0F21                 or      ds:multrk_flag, 80h ; or [multrk_flag],multrk_on
SYSINIT:0F27
SYSINIT:0F27 multrk_flag_done:                       ; CODE XREF: endfile+B↑j
SYSINIT:0F27                 pop     ds
SYSINIT:0F28                 assume ds:nothing
SYSINIT:0F28                 mov     ax, cs:CONFBOT
SYSINIT:0F2C                 mov     cs:ALLOCLIM, ax
SYSINIT:0F30                 push    cs
SYSINIT:0F31                 pop     ds
SYSINIT:0F32                 assume ds:SYSINIT
SYSINIT:0F32                 mov     ax, cs:memhi
SYSINIT:0F36                 mov     cs:prev_memhi, ax
SYSINIT:0F3A                 mov     ax, cs:ALLOCLIM
SYSINIT:0F3E                 mov     cs:prev_alloclim, ax
SYSINIT:0F42
SYSINIT:0F42 dosfts:                                 ; CODE XREF: endfile+356↓j
SYSINIT:0F42                 call    round
SYSINIT:0F45                 mov     al, cs:FILES
SYSINIT:0F49                 sub     al, 5
SYSINIT:0F4B                 jbe     short dofcbs
SYSINIT:0F4D                 push    ax
SYSINIT:0F4E                 mov     al, 'F'         ; devmark_files
SYSINIT:0F50                 call    setdevmark      ; set devmark for sfts (files)
SYSINIT:0F53                 pop     ax
SYSINIT:0F54                 xor     ah, ah          ; do not use cbw instruction!
SYSINIT:0F54                                         ; it does sign extend.
SYSINIT:0F56                 mov     bx, cs:memlo
SYSINIT:0F5B                 mov     dx, cs:memhi
SYSINIT:0F60                 lds     di, cs:DOSINFO  ; get pointer to dos data
SYSINIT:0F65                 assume ds:nothing
SYSINIT:0F65                 lds     di, [di+4]      ; lds di,[di+SYSI_SFT] ; ds:di points to sft
SYSINIT:0F68                 mov     [di], bx        ; [di+SF.SFLink],bx
SYSINIT:0F6A                 mov     [di+2], dx      ; [di+SF.SFLink+2],dx ; set pointer to new sft
SYSINIT:0F6D                 push    cs
SYSINIT:0F6E                 pop     ds
SYSINIT:0F6F                 assume ds:SYSINIT
SYSINIT:0F6F                 les     di, dword ptr cs:memlo ; point to new sft
SYSINIT:0F74                 mov     word ptr es:[di], 0FFFFh ; mov word [es:di+SF.SFLink],-1
SYSINIT:0F79                 mov     es:[di+4], ax   ; mov [es:di+SF.SFCount],ax
SYSINIT:0F7D                 mov     bl, 59          ; SF_ENTRY.size
SYSINIT:0F7F                 mul     bl
SYSINIT:0F81                 mov     cx, ax          ; ax = number of bytes to clear
SYSINIT:0F83                 add     cs:memlo, ax    ; allocate memory
SYSINIT:0F88                 mov     ax, 6
SYSINIT:0F8B                 add     cs:memlo, ax    ; remember the header too
SYSINIT:0F90                 or      cs:setdevmarkflag, 2 ; for_devmark
SYSINIT:0F96                 call    round           ; check for mem error before the stosb
SYSINIT:0F99                 add     di, ax          ; ax = 6
SYSINIT:0F9B                 xor     ax, ax
SYSINIT:0F9D                 rep stosb               ; clean out the stuff
SYSINIT:0F9F
SYSINIT:0F9F dofcbs:                                 ; CODE XREF: endfile+37↑j
SYSINIT:0F9F                 push    cs
SYSINIT:0FA0                 pop     ds
SYSINIT:0FA1                 call    round
SYSINIT:0FA4                 mov     al, 'X'         ; devmark_fcbs
SYSINIT:0FA6                 call    setdevmark
SYSINIT:0FA9                 mov     al, cs:FCBS
SYSINIT:0FAD                 xor     ah, ah          ; do not use cbw instruction!
SYSINIT:0FAD                                         ; it does sign extend.
SYSINIT:0FAF                 mov     bx, cs:memlo
SYSINIT:0FB4                 mov     dx, cs:memhi
SYSINIT:0FB9                 lds     di, cs:DOSINFO  ; get pointer to dos data
SYSINIT:0FBE                 assume ds:nothing
SYSINIT:0FBE                 mov     [di+1Ah], bx    ; [di+SYSI_FCB]
SYSINIT:0FC1                 mov     [di+1Ch], dx    ; [di+SYSI_FCB+2] ; set pointer to new table
SYSINIT:0FC4                 mov     bl, cs:KEEP
SYSINIT:0FC9                 xor     bh, bh
SYSINIT:0FCB                 mov     [di+1Eh], bx    ; [di+SYSI_KEEP]
SYSINIT:0FCE                 push    cs
SYSINIT:0FCF                 pop     ds
SYSINIT:0FD0                 assume ds:SYSINIT
SYSINIT:0FD0                 les     di, dword ptr memlo ; point to new table
SYSINIT:0FD4                 mov     word ptr es:[di], 0FFFFh ; [es:di+SF.SFLink],-1
SYSINIT:0FD9                 mov     es:[di+4], ax   ; [es:di+SF.SFCount]
SYSINIT:0FDD                 mov     bl, 59          ; SF_ENTRY.size
SYSINIT:0FDF                 mov     cx, ax
SYSINIT:0FE1                 mul     bl
SYSINIT:0FE3                 add     memlo, ax       ; ax = number of bytes to clear
SYSINIT:0FE7                 mov     ax, 6           ; SF.size-2
SYSINIT:0FEA                 add     memlo, ax       ; remember the header too
SYSINIT:0FEE                 or      setdevmarkflag, 2 ; for_devmark
SYSINIT:0FF3                 call    round           ; check for mem error before the stosb
SYSINIT:0FF6                 add     di, ax          ; skip over header
SYSINIT:0FF8                 mov     al, 'A'
SYSINIT:0FFA
SYSINIT:0FFA fillloop:                               ; CODE XREF: endfile+100↓j
SYSINIT:0FFA                 push    cx              ; save count
SYSINIT:0FFB                 mov     cx, 59          ; number of bytes to fill
SYSINIT:0FFE                 cld
SYSINIT:0FFF                 rep stosb               ; filled
SYSINIT:1001                 mov     word ptr es:[di-3Bh], 0 ; [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_ref_count]
SYSINIT:1007                 mov     word ptr es:[di-26h], 0 ; [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position]
SYSINIT:100D                 mov     word ptr es:[di-24h], 0 ; [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position+2]
SYSINIT:1013                 pop     cx
SYSINIT:1014                 loop    fillloop
SYSINIT:1016                 cmp     buffers, 0FFFFh ; -1 ; has buffers been already set?
SYSINIT:101B                 jz      short dodefaultbuff
SYSINIT:101D                 jmp     dobuff          ; the user entered the buffers=.
SYSINIT:1020 ; ---------------------------------------------------------------------------
SYSINIT:1020
SYSINIT:1020 dodefaultbuff:                          ; CODE XREF: endfile+107↑j
SYSINIT:1020                 mov     h_buffers, 0    ; default is no heuristic (secondary) buffers.
SYSINIT:1026                 mov     buffers, 2      ; default to 2 buffers
SYSINIT:102C                 push    ax
SYSINIT:102D                 push    ds
SYSINIT:102E                 les     bp, cs:DOSINFO  ; search through the dpb's
SYSINIT:1033                 les     bp, es:[bp+0]   ; [es:bp+SYSI_DPB] ; get first dpb
SYSINIT:1037                 push    cs
SYSINIT:1038                 pop     ds
SYSINIT:1039
SYSINIT:1039 nextdpb:                                ; CODE XREF: endfile+175↓j
SYSINIT:1039                 mov     bl, es:[bp+0]   ; [es:bp+DPB.drive]
SYSINIT:103D                 inc     bl
SYSINIT:103F                 mov     ax, 4408h
SYSINIT:1042                 int     21h             ; DOS - 2+ - IOCTL -
SYSINIT:1044                 or      ax, ax          ; 0 = removable disk, 1 = fixed disk
SYSINIT:1046                 jnz     short nosetbuf  ; ax is nonzero if disk is nonremoveable
SYSINIT:1048                 xor     bx, bx          ; get parameters of (removable) drive
SYSINIT:104A                 mov     bl, es:[bp+0]   ; [es:bp+DPB.drive]
SYSINIT:104E                 inc     bl
SYSINIT:1050                 mov     dx, offset devp_specialfunc
SYSINIT:1053                 mov     ax, 440Dh       ; (IOCTL<<8)|GENERIC_IOCTL
SYSINIT:1056                 mov     cx, 860h        ; (RAWIO<<8)|GET_DEVICE_PARAMETERS
SYSINIT:1059                 int     21h             ; DOS - 2+ - IOCTL -
SYSINIT:105B                 jb      short nosetbuf  ; get next dpb if driver doesn't support
SYSINIT:105B                                         ; generic ioctl
SYSINIT:105D                 mov     bx, devp_totalsecs ; [deviceparameters+15]
SYSINIT:105D                                         ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
SYSINIT:1061                 mov     ax, devp_bps    ; [deviceparameters+7]
SYSINIT:1061                                         ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_BYTESPERSECTOR]
SYSINIT:1064                 xor     dx, dx
SYSINIT:1066                 mov     cx, 512         ; scale sector size in factor of 512 bytes
SYSINIT:1069                 div     cx
SYSINIT:106B                 mul     bx              ; ax = #sectors * size factor
SYSINIT:106D                 or      dx, dx          ; just in case of large floppies
SYSINIT:106F                 jnz     short setbuf
SYSINIT:1071                 cmp     ax, 720         ; 720 sectors * size factor of 1
SYSINIT:1074                 jbe     short nosetbuf
SYSINIT:1076
SYSINIT:1076 setbuf:                                 ; CODE XREF: endfile+15B↑j
SYSINIT:1076                 mov     buffers, 3
SYSINIT:107C                 jmp     short chk_memsize_for_buffers ; now check the memory size
SYSINIT:107C                                         ; for default buffer count
SYSINIT:107E ; ---------------------------------------------------------------------------
SYSINIT:107E
SYSINIT:107E nosetbuf:                               ; CODE XREF: endfile+132↑j
SYSINIT:107E                                         ; endfile+147↑j ...
SYSINIT:107E                 cmp     word ptr es:[bp+19h], 0FFFFh ; [es:bp+DPB.NEXT_DPB],-1
SYSINIT:1083                 jz      short chk_memsize_for_buffers
SYSINIT:1085                 les     bp, es:[bp+19h] ; les bp,[es:bp+DPB.NEXT_DPB]
SYSINIT:1089                 jmp     short nextdpb
SYSINIT:108B ; ---------------------------------------------------------------------------
SYSINIT:108B
SYSINIT:108B chk_memsize_for_buffers:                ; CODE XREF: endfile+168↑j
SYSINIT:108B                                         ; endfile+16F↑j
SYSINIT:108B                 cmp     MEMORY_SIZE, 2000h ; 128kb
SYSINIT:1091                 jbe     short bufset
SYSINIT:1093                 mov     buffers, 5
SYSINIT:1099                 cmp     MEMORY_SIZE, 4000h ; 256kb
SYSINIT:109F                 jbe     short bufset
SYSINIT:10A1                 mov     buffers, 10
SYSINIT:10A7                 cmp     MEMORY_SIZE, 8000h ; 512kb
SYSINIT:10AD                 jbe     short bufset
SYSINIT:10AF                 mov     buffers, 15
SYSINIT:10B5
SYSINIT:10B5 bufset:                                 ; CODE XREF: endfile+17D↑j
SYSINIT:10B5                                         ; endfile+18B↑j ...
SYSINIT:10B5                 pop     ds
SYSINIT:10B6                 assume ds:nothing
SYSINIT:10B6                 pop     ax
SYSINIT:10B7
SYSINIT:10B7 dobuff:                                 ; CODE XREF: endfile+109↑j
SYSINIT:10B7                 lds     bx, cs:DOSINFO  ; ds:bx -> sysinitvar
SYSINIT:10BC                 mov     ax, cs:buffers
SYSINIT:10C0                 mov     [bx+3Fh], ax    ; [bx+SYSI_BUFFERS] ; set sysi_buffers
SYSINIT:10C3                 mov     ax, cs:h_buffers
SYSINIT:10C7                 mov     [bx+41h], ax    ; [bx+SYSI_BUFFERS+2]
SYSINIT:10CA                 lds     bx, [bx+12h]    ; [bx+SYSI_BUF] ; now, ds:bx -> buffinfo
SYSINIT:10CD                 call    round           ; get [memhi]:[memlo]
SYSINIT:10D0                 mov     al, 'B'         ; devmark_buf
SYSINIT:10D2                 call    setdevmark
SYSINIT:10D5                 push    ds              ; save buffer info. ptr.
SYSINIT:10D6                 push    bx
SYSINIT:10D7                 call    set_buffer
SYSINIT:10DA                 pop     bx              ; restore buffer info. ptr.
SYSINIT:10DB                 pop     ds
SYSINIT:10DC                 cmp     cs:h_buffers, 0 ; set the secondary buffer if specified
SYSINIT:10E2                 jz      short xif16
SYSINIT:10E4                 call    round
SYSINIT:10E7                 mov     cx, cs:memlo
SYSINIT:10EC                 mov     [bx+6], cx      ; [bx+BUFFINF.Cache_ptr]
SYSINIT:10EF                 mov     cx, cs:memhi
SYSINIT:10F4                 mov     [bx+8], cx      ; [bx+BUFFINF.Cache_ptr+2]
SYSINIT:10F7                 mov     cx, cs:h_buffers
SYSINIT:10FC                 mov     [bx+0Ah], cx    ; [bx+BUFFINF.Cache_count]
SYSINIT:10FF                 mov     ax, 512         ; 512 bytes
SYSINIT:1102                 mul     cx
SYSINIT:1104                 mov     cs:memlo, ax
SYSINIT:1108                 or      cs:setdevmarkflag, 2 ; for_devmark
SYSINIT:110E                 call    round
SYSINIT:1111
SYSINIT:1111 xif16:                                  ; CODE XREF: endfile+1CE↑j
SYSINIT:1111                 call    round           ; buf1
SYSINIT:1114                 push    ax
SYSINIT:1115                 mov     ax, 'L'         ; devmark_cds
SYSINIT:1118                 call    setdevmark
SYSINIT:111B                 pop     ax
SYSINIT:111C                 les     di, cs:DOSINFO
SYSINIT:1121                 mov     cl, es:[di+20h] ; [es:di+SYSI_NUMIO]
SYSINIT:1125                 cmp     cl, cs:NUM_CDS
SYSINIT:112A                 jnb     short gotncds   ; user setting must be at least numio
SYSINIT:112C                 mov     cl, cs:NUM_CDS
SYSINIT:1131
SYSINIT:1131 gotncds:                                ; CODE XREF: endfile+216↑j
SYSINIT:1131                 xor     ch, ch
SYSINIT:1133                 mov     es:[di+21h], cl ; [es:di+SYSI_NCDS]
SYSINIT:1137                 mov     ax, cs:memhi
SYSINIT:113B                 mov     es:[di+18h], ax ; [es:di+SYSI_CDS+2]
SYSINIT:113F                 mov     ax, cs:memlo
SYSINIT:1143                 mov     es:[di+16h], ax ; [es:di+SYSI_CDS]
SYSINIT:1147                 mov     al, cl
SYSINIT:1149                 mov     ah, 88          ; curdirlen ; curdir_list.size
SYSINIT:114B                 mul     ah
SYSINIT:114D                 call    ParaRound
SYSINIT:1150                 add     cs:memhi, ax
SYSINIT:1155                 or      cs:setdevmarkflag, 2 ; for_devmark
SYSINIT:115B                 call    round           ; check for mem error before initializing
SYSINIT:115E                 lds     si, es:[di]     ; lds si,[es:di+SYSI_DPB] ; [es:di+0]
SYSINIT:1161                 les     di, es:[di+16h] ; les di,[es:di+SYSI_CDS] ; [es:di+22]
SYSINIT:1165                 call    fooset          ; Initialize temporary CDSs.
SYSINIT:1168                 push    cs
SYSINIT:1169                 pop     ds
SYSINIT:116A                 assume ds:SYSINIT
SYSINIT:116A                 cmp     stack_addr, 0FFFFh ; -1 ; has the user entered "stacks=" command?
SYSINIT:116F                 jz      short doinstallstack ; then install as specified by the user
SYSINIT:1171                 cmp     sys_scnd_model_byte, 0 ; pc1,xt has the secondary model byte = 0
SYSINIT:1176                 jnz     short doinstallstack ; other model should have default stack of 9,128
SYSINIT:1178                 cmp     sys_model_byte, 0FEh ; pc1, pc/xt or pc portable ?
SYSINIT:117D                 jnb     short skipstack
SYSINIT:117F
SYSINIT:117F doinstallstack:                         ; CODE XREF: endfile+25B↑j
SYSINIT:117F                                         ; endfile+262↑j
SYSINIT:117F                 mov     ax, stack_count ; stack_count = 0?
SYSINIT:1182                 or      ax, ax          ; then, stack size must be 0 too.
SYSINIT:1184                 jz      short skipstack ; don't install stack.
SYSINIT:1186                 call    round           ; dynamic relocation of stack code.
SYSINIT:1189                 mov     al, 'S'         ; devmark_stk
SYSINIT:118B                 call    setdevmark
SYSINIT:118E                 mov     ax, memhi
SYSINIT:1191                 mov     es, ax          ; es -> seg. the stack code is going to move.
SYSINIT:1193                 push    cs
SYSINIT:1194                 pop     ds
SYSINIT:1195                 xor     si, si          ; ! we know that stack code is at the beginning of sysinit.
SYSINIT:1197                 xor     di, di
SYSINIT:1199                 mov     cx, offset _SYSINIT ; offset endstackcode = offset _SYSINIT
SYSINIT:1199                                         ; SYSINIT:0269h
SYSINIT:119C                 mov     memlo, cx
SYSINIT:11A0                 call    round           ; have enough space for relocation?
SYSINIT:11A3                 rep movsb
SYSINIT:11A5                 push    ds
SYSINIT:11A6                 mov     ax, 70h         ; DOSBIODATASEG
SYSINIT:11A9                 mov     ds, ax
SYSINIT:11AB                 assume ds:nothing
SYSINIT:11AB                 mov     ds:NextStack, offset nextentry ; [BIOSDATA:NextStack],
SYSINIT:11AB                                         ;  offset SYSINIT:nextentry (SYSINIT:0010h)
SYSINIT:11B1                 mov     ds:NextStack+2, es
SYSINIT:11B5                 mov     ax, cs:memlo
SYSINIT:11B9                 mov     cs:stack_addr, ax ; set for stack area initialization
SYSINIT:11BD                 mov     word ptr ds:IT_StackLoc, ax ; pass it as Instance Data, too
SYSINIT:11C0                 mov     ax, cs:memhi    ; this will be used by stack_init routine.
SYSINIT:11C4                 mov     cs:stack_addr+2, ax
SYSINIT:11C8                 mov     word ptr ds:IT_StackLoc+2, ax
SYSINIT:11CB                 mov     ax, 8           ; entrysize
SYSINIT:11CE                 add     ax, cs:stack_size
SYSINIT:11D3                 mul     cs:stack_count
SYSINIT:11D8                 mov     ds:IT_StackSize, ax ; pass through to Instance Table
SYSINIT:11DB                 pop     ds
SYSINIT:11DC                 assume ds:nothing
SYSINIT:11DC                 call    ParaRound
SYSINIT:11DF                 add     cs:memhi, ax
SYSINIT:11E4                 or      cs:setdevmarkflag, 2 ; for_devmark
SYSINIT:11E4                                         ; to set the devmark_size for stack by round routine.
SYSINIT:11EA                 call    round           ; check for memory error before continuing
SYSINIT:11ED                 call    stackinit       ; initialize hardware stack.
SYSINIT:11ED                                         ; cs=ds=sysinitseg,es=relocated stack code & data
SYSINIT:11F0
SYSINIT:11F0 skipstack:                              ; CODE XREF: endfile+269↑j
SYSINIT:11F0                                         ; endfile+270↑j
SYSINIT:11F0                 push    cs
SYSINIT:11F1                 pop     ds
SYSINIT:11F2                 assume ds:SYSINIT
SYSINIT:11F2                 cmp     dosdata_umb, 1  ; PCDOS 7 feature - DOSDATA=UMB/NOUMB configuration
SYSINIT:11F2                                         ; 1 = DOSDATA=UMB, 2 = (UMB) done, 0 = NOUMB
SYSINIT:11F7                 ja      short dosdata_umb_done ; 2 - done
SYSINIT:11F9                 jb      short dosdata_noumb ; 0 - DOSDATA=NOUMB
SYSINIT:11FB                 cmp     byte ptr setdevmark, 0EAh
SYSINIT:1200                 jz      short dosdata_noumb
SYSINIT:1202                 mov     ax, 5802h
SYSINIT:1205                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:1205                                         ; AL = function code: (DOS 5beta) get UMB link state
SYSINIT:1207                 cbw
SYSINIT:1208                 mov     di, ax          ; al = 01h -> UMBs in DOS memory chain
SYSINIT:1208                                         ; save current (previous) UMB link state
SYSINIT:120A                 mov     bx, 1           ; bx = 01h -> add UMBs to DOS memory chain
SYSINIT:120D                 mov     ax, 5803h
SYSINIT:1210                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:1210                                         ; AL = function code: (DOS 5beta) set UMB link state
SYSINIT:1212                 jb      short dosdata_noumb
SYSINIT:1214                 mov     ax, 5800h
SYSINIT:1217                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:1217                                         ; AL = function code: get allocation strategy
SYSINIT:1219                 mov     si, ax          ; ax = current strategy
SYSINIT:1219                                         ; save current (previous) allocation strategy
SYSINIT:121B                 mov     bx, 40h         ; bl = new strategy = 40h - high memory first fit
SYSINIT:121E                 mov     ax, 5801h
SYSINIT:1221                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:1221                                         ; AL = function code: set allocation strategy
SYSINIT:1223                 mov     bx, memhi
SYSINIT:1227                 sub     bx, prev_memhi
SYSINIT:122B                 mov     ah, 48h
SYSINIT:122D                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:122D                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:122F                 mov     cx, ax          ; ax = segment of allocated block
SYSINIT:1231                 mov     bx, di          ; restore previous UMB link state
SYSINIT:1233                 mov     ax, 5803h
SYSINIT:1236                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:1236                                         ; AL = function code: (DOS 5beta) set UMB link state
SYSINIT:1238                 mov     bx, si          ; restore previous allocation strategy
SYSINIT:123A                 mov     ax, 5801h
SYSINIT:123D                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:123D                                         ; AL = function code: set allocation strategy
SYSINIT:123F                 cmp     cx, 0A000h      ; Is the allocated memory block (segment) a UMB?
SYSINIT:1243                 jb      short dosdata_noumb ; no
SYSINIT:1245                 mov     ALLOCLIM, 0FFFFh
SYSINIT:124B                 mov     memlo, 0
SYSINIT:1251                 mov     memhi, cx
SYSINIT:1255                 dec     cx
SYSINIT:1256                 mov     es, cx          ; point to arena/mcb
SYSINIT:1258                 mov     word ptr es:1, 8 ; [es:arena_owner], 8 ; set impossible owner
SYSINIT:125F                 mov     word ptr es:8, 4453h ; [es:arena_name],'SD' ; System Data
SYSINIT:1266                 inc     dosdata_umb     ; 1 -> 2 ; DOSDATA=UMB done.
SYSINIT:126A                 jmp     dosfts
SYSINIT:126D ; ---------------------------------------------------------------------------
SYSINIT:126D
SYSINIT:126D dosdata_umb_done:                       ; CODE XREF: endfile+2E3↑j
SYSINIT:126D                 mov     ax, prev_memhi  ; (recent memory block/segment before UMBs)
SYSINIT:1270                 mov     memhi, ax
SYSINIT:1273                 mov     ax, prev_alloclim
SYSINIT:1276                 mov     ALLOCLIM, ax
SYSINIT:1279
SYSINIT:1279 dosdata_noumb:                          ; CODE XREF: endfile+2E5↑j
SYSINIT:1279                                         ; endfile+2EC↑j ...
SYSINIT:1279                 mov     al, FILES
SYSINIT:127C                 xor     ah, ah          ; do not use cbw instruction!
SYSINIT:127C                                         ; it does sign extend.
SYSINIT:127E                 mov     cx, ax
SYSINIT:1280                 xor     bx, bx          ; close standard input
SYSINIT:1282                 mov     ah, 3Eh
SYSINIT:1284                 int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
SYSINIT:1284                                         ; BX = file handle
SYSINIT:1286                 mov     bx, 2           ; close everybody but standard output
SYSINIT:1286                                         ; need output so we can print message
SYSINIT:1286                                         ;  in case we can't get new one open.
SYSINIT:1289
SYSINIT:1289 rcclloop:                               ; CODE XREF: endfile+37A↓j
SYSINIT:1289                 mov     ah, 3Eh
SYSINIT:128B                 int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
SYSINIT:128B                                         ; BX = file handle
SYSINIT:128D                 inc     bx
SYSINIT:128E                 loop    rcclloop
SYSINIT:1290                 mov     dx, offset condev ; "CON"
SYSINIT:1293                 mov     al, 2
SYSINIT:1295                 mov     ah, 3Dh         ; open con for read/write
SYSINIT:1297                 stc                     ; set for possible int 24
SYSINIT:1298                 int     21h             ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
SYSINIT:1298                                         ; DS:DX -> ASCIZ filename
SYSINIT:1298                                         ; AL = access mode
SYSINIT:1298                                         ; 2 - read & write
SYSINIT:129A                 jnb     short goaux
SYSINIT:129C                 call    badfil
SYSINIT:129F                 jmp     short goaux2
SYSINIT:12A1 ; ---------------------------------------------------------------------------
SYSINIT:12A1
SYSINIT:12A1 goaux:                                  ; CODE XREF: endfile+386↑j
SYSINIT:12A1                 push    ax
SYSINIT:12A2                 mov     bx, 1           ; close standard output
SYSINIT:12A5                 mov     ah, 3Eh
SYSINIT:12A7                 int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
SYSINIT:12A7                                         ; BX = file handle
SYSINIT:12A9                 pop     ax
SYSINIT:12AA                 mov     bx, ax          ; new device handle
SYSINIT:12AC                 mov     ah, 45h         ; XDUP ; dup to 1, stdout
SYSINIT:12AE                 int     21h             ; DOS - 2+ - CREATE DUPLICATE HANDLE (DUP)
SYSINIT:12AE                                         ; BX = file handle to duplicate
SYSINIT:12B0                 mov     ah, 45h         ; XDUP ; dup to 2, stderr
SYSINIT:12B2                 int     21h             ; DOS - 2+ - CREATE DUPLICATE HANDLE (DUP)
SYSINIT:12B2                                         ; BX = file handle to duplicate
SYSINIT:12B4
SYSINIT:12B4 goaux2:                                 ; CODE XREF: endfile+38B↑j
SYSINIT:12B4                 mov     dx, offset auxdev ; "AUX"
SYSINIT:12B7                 mov     al, 2           ; read/write access
SYSINIT:12B9                 call    open_dev
SYSINIT:12BC                 mov     dx, offset prndev ; "PRN"
SYSINIT:12BF                 mov     al, 1           ; write only
SYSINIT:12C1                 call    open_dev
SYSINIT:12C4                 push    ax
SYSINIT:12C5                 push    bx
SYSINIT:12C6                 push    dx
SYSINIT:12C7                 push    es
SYSINIT:12C8                 mov     al, 0FFh        ; reset h/w by writing to port
SYSINIT:12CA                 mov     dx, 2F2h        ; get starting address
SYSINIT:12CD                 out     dx, al          ; out 02f2h,0ffh
SYSINIT:12CE                 inc     dx
SYSINIT:12CF                 out     dx, al
SYSINIT:12D0                 inc     dx
SYSINIT:12D1                 out     dx, al
SYSINIT:12D2                 inc     dx
SYSINIT:12D3                 out     dx, al
SYSINIT:12D4                 inc     dx
SYSINIT:12D5                 out     dx, al
SYSINIT:12D6                 inc     dx
SYSINIT:12D7                 out     dx, al          ; out 02f7h,0ffh
SYSINIT:12D8                 mov     ax, 0F000h      ; get machine type
SYSINIT:12DB                 mov     es, ax
SYSINIT:12DD                 assume es:nothing
SYSINIT:12DD                 cmp     byte ptr es:0FFFEh, 0FCh ; is it a AT type machine
SYSINIT:12E3                 jz      short startrearm ; *if AT no need to check
SYSINIT:12E5                 mov     ah, 0C0h
SYSINIT:12E7                 int     15h             ; SYSTEM - GET CONFIGURATION
SYSINIT:12E7                                         ; (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
SYSINIT:12E9                 jb      short finishrearm ; *jmp if old rom
SYSINIT:12EB                 test    byte ptr es:[bx+5], 40h ; [es:bx+ROMBIOS_DESC.bios_sd_featurebyte1],
SYSINIT:12EB                                         ; ScndIntController
SYSINIT:12F0                 jz      short finishrearm
SYSINIT:12F2
SYSINIT:12F2 startrearm:                             ; CODE XREF: endfile+3CF↑j
SYSINIT:12F2                 mov     al, 0FFh        ; write any pattern to port
SYSINIT:12F4                 mov     dx, 6F2h        ; get starting address
SYSINIT:12F7                 out     dx, al
SYSINIT:12F8                 inc     dx
SYSINIT:12F9                 out     dx, al          ; out 06f3h,0ffh
SYSINIT:12FA                 inc     dx
SYSINIT:12FB                 out     dx, al          ; out 06f4h,0ffh
SYSINIT:12FC                 inc     dx
SYSINIT:12FD                 inc     dx
SYSINIT:12FE                 out     dx, al          ; out 06f6h,0ffh
SYSINIT:12FF                 inc     dx
SYSINIT:1300                 out     dx, al          ; out 06f7h,0ffh
SYSINIT:1301
SYSINIT:1301 finishrearm:                            ; CODE XREF: endfile+3D5↑j
SYSINIT:1301                                         ; endfile+3DC↑j
SYSINIT:1301                 pop     es
SYSINIT:1302                 assume es:nothing
SYSINIT:1302                 pop     dx
SYSINIT:1303                 pop     bx
SYSINIT:1304                 pop     ax
SYSINIT:1305
SYSINIT:1305 set_sysinit_base:                       ; sysinit_base will be established
SYSINIT:1305                 push    ax              ; in the secure area of lower memory
SYSINIT:1305                                         ; when it handles the first install= command.
SYSINIT:1305                                         ; if sysinit module (in high memory) has been broken,
SYSINIT:1305                                         ; then "memory error..." message is displayed
SYSINIT:1305                                         ; by sysinit_base
SYSINIT:1306                 mov     ax, memhi
SYSINIT:1309                 sub     ax, area
SYSINIT:130D                 mov     impossible_owner_size, ax ; remember the size in case.
SYSINIT:1310                 mov     al, 'T'         ; devmark_inst
SYSINIT:1312                 call    setdevmark
SYSINIT:1315                 pop     ax
SYSINIT:1316                 mov     di, memhi
SYSINIT:131A                 mov     es, di
SYSINIT:131C                 mov     word ptr sysinit_base_ptr+2, di ; save this entry for the next use.
SYSINIT:1320                 xor     di, di
SYSINIT:1322                 mov     word ptr sysinit_base_ptr, di ; es:di -> destination.
SYSINIT:1326                 mov     si, offset sysinit_base ; ds:si -> source code to be relocated.
SYSINIT:1329                 mov     cx, 129         ; end_sysinit_base-sysinit_base ; 129
SYSINIT:132C                 add     memlo, cx
SYSINIT:1330                 or      cs:setdevmarkflag, 2 ; for_devmark
SYSINIT:1336                 call    round
SYSINIT:1339                 rep movsb
SYSINIT:133B                 mov     sysinit_ptr, offset sysinitptr ; returning address from
SYSINIT:133B                                         ; sysinit_base back to sysinit
SYSINIT:1341                 mov     sysinit_ptr+2, cs
SYSINIT:1345                 or      install_flag, 2 ; for_devmark
SYSINIT:134A                 call    round
SYSINIT:134D                 mov     bx, memhi
SYSINIT:1351                 mov     ax, area
SYSINIT:1354                 mov     old_area, ax    ; save [area]
SYSINIT:1357                 mov     es, ax          ; calc what we needed
SYSINIT:1359                 sub     bx, ax
SYSINIT:135B                 mov     ah, 4Ah         ; SETBLOCK
SYSINIT:135D                 int     21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
SYSINIT:135D                                         ; ES = segment address of block to change
SYSINIT:135D                                         ; BX = new size in paragraphs
SYSINIT:135F                 push    es
SYSINIT:1360                 mov     ax, es
SYSINIT:1362                 dec     ax
SYSINIT:1363                 mov     es, ax          ; point to arena
SYSINIT:1365                 assume es:nothing
SYSINIT:1365                 mov     word ptr es:1, 8 ; [es:ARENA.OWNER],8 ; set impossible owner
SYSINIT:136C                 mov     word ptr es:8, 4453h ; [es:ARENA.NAME],'SD' ; System Data
SYSINIT:1373                 pop     es
SYSINIT:1374                 assume es:nothing
SYSINIT:1374                 mov     bx, 0FFFFh
SYSINIT:1377                 mov     ah, 48h
SYSINIT:1379                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:1379                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:137B                 mov     ah, 48h         ; allocate the rest of the memory
SYSINIT:137D                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:137D                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:137F                 mov     memhi, ax       ; start of the allocated memory
SYSINIT:1382                 mov     memlo, 0        ; to be used next.
SYSINIT:1388                 mov     es, ax
SYSINIT:138A                 mov     bx, CONFBOT
SYSINIT:138E                 sub     bx, ax          ; confbot - memhi
SYSINIT:1390                 dec     bx              ; make a room for the memory block id.
SYSINIT:1391                 dec     bx              ; make sure!
SYSINIT:1392                 mov     ah, 4Ah         ; this will free (confbot to top of memory)
SYSINIT:1394                 int     21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
SYSINIT:1394                                         ; ES = segment address of block to change
SYSINIT:1394                                         ; BX = new size in paragraphs
SYSINIT:1396                 mov     bx, 0FFFFh
SYSINIT:1399                 mov     ah, 48h
SYSINIT:139B                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:139B                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:139D                 mov     ah, 48h         ; allocate (confbot to top of memory)
SYSINIT:139F                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:139F                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:13A1                 mov     area, ax        ; save allocated memory segment.
SYSINIT:13A1                                         ; need this to free this area for command.com.
SYSINIT:13A4                 mov     es, memhi
SYSINIT:13A8                 mov     ah, 49h         ; free allocated memory
SYSINIT:13A8                                         ; free (memhi to confbot(=area))
SYSINIT:13AA                 int     21h             ; DOS - 2+ - FREE MEMORY
SYSINIT:13AA                                         ; ES = segment address of area to be freed
SYSINIT:13AC                 retn
SYSINIT:13AC endfile         endp
SYSINIT:13AC
SYSINIT:13AD
SYSINIT:13AD ; =============== S U B R O U T I N E =======================================
SYSINIT:13AD
SYSINIT:13AD
SYSINIT:13AD do_install_exec proc near               ; CODE XREF: doconf+16F↓p
SYSINIT:13AD                                         ; doconf+19F↓p
SYSINIT:13AD                 push    si              ; EXEC a program being loaded via the
SYSINIT:13AD                                         ; "install=" mechanism in config.sys
SYSINIT:13AE                 push    es
SYSINIT:13AF                 push    ds
SYSINIT:13B0                 pop     es
SYSINIT:13B1                 assume es:SYSINIT
SYSINIT:13B1                 pop     ds              ; es->sysinitseg,ds->confbot seg
SYSINIT:13B2                 assume ds:nothing
SYSINIT:13B2                 mov     dx, si          ; ds:dx->file name,0 in config.sys image.
SYSINIT:13B4                 xor     cx, cx
SYSINIT:13B6                 cld
SYSINIT:13B7                 mov     cs:ldexec_start, 20h ; ' ' ; clear out the parm area
SYSINIT:13BD                 mov     di, offset ldexec_parm
SYSINIT:13C0
SYSINIT:13C0 installfilename:                        ; CODE XREF: do_install_exec+18↓j
SYSINIT:13C0                 lodsb                   ; skip the file name
SYSINIT:13C0                                         ; al = ds:si; si++
SYSINIT:13C1                 cmp     al, 0
SYSINIT:13C3                 jz      short got_installparm
SYSINIT:13C5                 jmp     short installfilename
SYSINIT:13C7 ; ---------------------------------------------------------------------------
SYSINIT:13C7
SYSINIT:13C7 got_installparm:                        ; CODE XREF: do_install_exec+16↑j
SYSINIT:13C7                                         ; do_install_exec+25↓j
SYSINIT:13C7                 lodsb                   ; copy the parameters to ldexec_parm
SYSINIT:13C8                 mov     es:[di], al
SYSINIT:13CB                 cmp     al, 0Ah         ; lf ; line feed?
SYSINIT:13CD                 jz      short done_installparm
SYSINIT:13CF                 inc     cl              ; # of char. in the parm.
SYSINIT:13D1                 inc     di
SYSINIT:13D2                 jmp     short got_installparm
SYSINIT:13D4 ; ---------------------------------------------------------------------------
SYSINIT:13D4
SYSINIT:13D4 done_installparm:                       ; CODE XREF: do_install_exec+20↑j
SYSINIT:13D4                 mov     cs:ldexec_line, cl ; length of the parm.
SYSINIT:13D9                 cmp     cl, 0           ; if no parm,then
SYSINIT:13DC                 jnz     short install_seg_set ; let the parm area
SYSINIT:13DE                 mov     cs:ldexec_start, 0Dh ; cr ; starts with cr.
SYSINIT:13E4
SYSINIT:13E4 install_seg_set:                        ; CODE XREF: do_install_exec+2F↑j
SYSINIT:13E4                 mov     cs:0, 0         ; make a null environment segment
SYSINIT:13EB                 mov     ax, cs          ; by overlap jmp instruction of sysinitseg.
SYSINIT:13ED                 mov     cx, ax
SYSINIT:13EF                 cmp     cs:config_envlen, 0
SYSINIT:13F5                 jz      short no_envdata2
SYSINIT:13F7                 mov     cx, cs:config_wrkseg
SYSINIT:13FC
SYSINIT:13FC no_envdata2:                            ; CODE XREF: do_install_exec+48↑j
SYSINIT:13FC                 mov     cs:iexec_environ, cx ; [cs:instexe.exec0_environ]
SYSINIT:13FC                                         ; set the environment seg.
SYSINIT:1401                 mov     cs:iexec_ldexec_line_seg, ax ; [cs:instexe.exec0_com_line+2]
SYSINIT:1401                                         ; set the seg.
SYSINIT:1405                 mov     cs:iexec_ldexec_5c_fcb_seg, ax ; [cs:instexe.exec0_5c_fcb+2
SYSINIT:1409                 mov     cs:iexec_ldexec_6c_fcb_seg, ax ; [cs:instexe.exec0_6c_fcb+2]]
SYSINIT:140D                 call    sum_up
SYSINIT:1410                 mov     es:checksum, ax ; save the value of the sum
SYSINIT:1414                 xor     ax, ax
SYSINIT:1416                 mov     ah, 4Bh         ; EXEC ; load/exec
SYSINIT:1418                 mov     bx, offset iexec_environ ; instexe ; es:bx -> parm block.
SYSINIT:141B                 push    es              ; save es,ds for load/exec
SYSINIT:141C                 push    ds              ; these registers will be restored in sysinit_base.
SYSINIT:141D                 jmp     cs:sysinit_base_ptr ; jmp to sysinit_base to execute
SYSINIT:141D do_install_exec endp                    ; load/exec function and check sum.
SYSINIT:141D
SYSINIT:1422 ; ---------------------------------------------------------------------------
SYSINIT:1422
SYSINIT:1422 sysinitptr:                             ; DATA XREF: endfile+427↑o
SYSINIT:1422                 pop     si              ; returning far address from sysinit_base
SYSINIT:1422                                         ; restore si for config.sys file.
SYSINIT:1423                 push    es
SYSINIT:1424                 push    ds
SYSINIT:1425                 pop     es
SYSINIT:1426                 assume es:nothing
SYSINIT:1426                 pop     ds              ; now ds - sysinitseg, es - confbot
SYSINIT:1427                 jnb     short install_exit_ret
SYSINIT:1429                 push    si              ; error in loading the file for install=.
SYSINIT:142A                 call    badload         ; es:si-> path,filename,0.
SYSINIT:142D                 pop     si
SYSINIT:142E
SYSINIT:142E install_exit_ret:                       ; CODE XREF: SYSINIT:1427↑j
SYSINIT:142E                 retn
SYSINIT:142F
SYSINIT:142F ; =============== S U B R O U T I N E =======================================
SYSINIT:142F
SYSINIT:142F
SYSINIT:142F ParaRound       proc near               ; CODE XREF: TempCDS+14↑p
SYSINIT:142F                                         ; endfile+239↑p ...
SYSINIT:142F                 add     ax, 15          ; round up length in paragraphs
SYSINIT:142F                                         ; 0Fh
SYSINIT:1432                 rcr     ax, 1
SYSINIT:1434                 shr     ax, 1
SYSINIT:1436                 shr     ax, 1
SYSINIT:1438                 shr     ax, 1
SYSINIT:143A                 retn
SYSINIT:143A ParaRound       endp
SYSINIT:143A
SYSINIT:143B ; ---------------------------------------------------------------------------
SYSINIT:143B
SYSINIT:143B sysinit_base:                           ; DATA XREF: endfile+412↑o
SYSINIT:143B                 mov     word ptr cs:sysinit_base_ss, ss ; sysinit_base module
SYSINIT:1440                 mov     word ptr cs:sysinit_base_sp, sp
SYSINIT:1445                 int     21h             ; load/exec dos call.
SYSINIT:1447                 mov     ss, word ptr cs:sysinit_base_ss ; restore stack
SYSINIT:144C                 assume ss:nothing
SYSINIT:144C                 mov     sp, word ptr cs:sysinit_base_sp
SYSINIT:1451                 pop     ds
SYSINIT:1452                 pop     es
SYSINIT:1453                 jb      short sysinit_base_end
SYSINIT:1455                 call    sum_up
SYSINIT:1458                 cmp     es:checksum, ax
SYSINIT:145D                 jz      short sysinit_base_end
SYSINIT:145F                 mov     ah, 9           ; memory broken.
SYSINIT:145F                                         ; show "memory allocation error" message and stall.
SYSINIT:1461                 push    cs
SYSINIT:1462                 pop     ds
SYSINIT:1463                 assume ds:SYSINIT
SYSINIT:1463                 mov     dx, 102         ; mem_alloc_err_msgx-sysinit_base ; 66h
SYSINIT:1466                 int     21h             ; DOS - PRINT STRING
SYSINIT:1466                                         ; DS:DX -> string terminated by "$"
SYSINIT:1468 ; START OF FUNCTION CHUNK FOR AllocMemForDOS
SYSINIT:1468 ;   ADDITIONAL PARENT FUNCTION round
SYSINIT:1468
SYSINIT:1468 stall:                                  ; CODE XREF: AllocMemForDOS+77↑j
SYSINIT:1468                                         ; SYSINIT:1469↓j ...
SYSINIT:1468                 hlt                     ; use HLT to minimize energy consumption
SYSINIT:1468 ; END OF FUNCTION CHUNK FOR AllocMemForDOS
SYSINIT:1469 ; ---------------------------------------------------------------------------
SYSINIT:1469                 jmp     short stall
SYSINIT:146B ; ---------------------------------------------------------------------------
SYSINIT:146B
SYSINIT:146B sysinit_base_end:                       ; CODE XREF: SYSINIT:1453↑j
SYSINIT:146B                                         ; SYSINIT:145D↑j
SYSINIT:146B                 jmp     dword ptr es:sysinit_ptr ; return back to sysinit module
SYSINIT:1470
SYSINIT:1470 ; =============== S U B R O U T I N E =======================================
SYSINIT:1470
SYSINIT:1470
SYSINIT:1470 sum_up          proc near               ; CODE XREF: do_install_exec+60↑p
SYSINIT:1470                                         ; SYSINIT:1455↑p
SYSINIT:1470                 push    ds
SYSINIT:1471                 mov     ax, es:CONFBOT
SYSINIT:1475                 mov     ds, ax
SYSINIT:1477                 assume ds:nothing
SYSINIT:1477                 xor     si, si
SYSINIT:1479                 xor     ax, ax
SYSINIT:147B                 mov     cx, es:config_size ; if config_size has been broken, then this
SYSINIT:147B                                         ; whole test better fail.
SYSINIT:1480                 shr     cx, 1
SYSINIT:1482                 jz      short sum_sys_code ; when config.sys file not exist.
SYSINIT:1484
SYSINIT:1484 sum1:                                   ; CODE XREF: sum_up+18↓j
SYSINIT:1484                 add     ax, [si]
SYSINIT:1486                 inc     si
SYSINIT:1487                 inc     si
SYSINIT:1488                 loop    sum1
SYSINIT:148A
SYSINIT:148A sum_sys_code:                           ; CODE XREF: sum_up+12↑j
SYSINIT:148A                 mov     si, offset locstack ; 586h
SYSINIT:148A                                         ; starting after the stack.
SYSINIT:148A                                         ; this does not cover the possible stack code!
SYSINIT:148D                 mov     cx, 5B40h       ; SI_end (23360)
SYSINIT:148D                                         ; SI_end is the label at the end of sysinit
SYSINIT:148D                                         ; from after_checksum to SI_end
SYSINIT:1490                 sub     cx, si
SYSINIT:1492                 shr     cx, 1
SYSINIT:1494
SYSINIT:1494 sum2:                                   ; CODE XREF: sum_up+29↓j
SYSINIT:1494                 add     ax, es:[si]
SYSINIT:1497                 inc     si
SYSINIT:1498                 inc     si
SYSINIT:1499                 loop    sum2
SYSINIT:149B                 pop     ds
SYSINIT:149C                 retn
SYSINIT:149C sum_up          endp
SYSINIT:149C
SYSINIT:149C ; ---------------------------------------------------------------------------
SYSINIT:149D sysinit_base_ssx dw 0                   ; sysinit_base_ss equ $-sysinit_base ; 62
SYSINIT:149F sysinit_base_spx dw 0                   ; sysinit_base_sp equ $-sysinit_base ; 64
SYSINIT:14A1 mem_alloc_err_msgx db 0Dh,0Ah
SYSINIT:14A1                 db 'Memory allocation error $'
SYSINIT:14BC
SYSINIT:14BC ; =============== S U B R O U T I N E =======================================
SYSINIT:14BC
SYSINIT:14BC
SYSINIT:14BC set_buffer      proc near               ; CODE XREF: endfile+1C3↑p
SYSINIT:14BC                 xor     dl, dl          ; input:
SYSINIT:14BC                                         ;   ds:bx -> buffinfo.
SYSINIT:14BC                                         ;   [memhi]:[memlo=0] = available space for the hash bucket.
SYSINIT:14BC                                         ;   singlebuffersize = buff header size + sector size
SYSINIT:14BC                                         ; output:
SYSINIT:14BC                                         ;   buffers Queue established.
SYSINIT:14BC                                         ;   [memhi]:[memlo] = addr of the next available free space.
SYSINIT:14BC                                         ;
SYSINIT:14BC                                         ; assume buffers not in HMA
SYSINIT:14BE                 call    GetBufferAddr
SYSINIT:14C1                 jz      short set_buff_1
SYSINIT:14C3                 mov     dl, 1           ; buffers in HMA
SYSINIT:14C5
SYSINIT:14C5 set_buff_1:                             ; CODE XREF: set_buffer+5↑j
SYSINIT:14C5                 mov     [bx], di        ; [bx+BUFFINF.Buff_Queue] ; head of Buff Q
SYSINIT:14C7                 mov     word ptr [bx+2], es ; [bx+BUFFINF.Buff_Queue+2]
SYSINIT:14CA                 mov     word ptr [bx+4], 0 ; [bx+BUFFINF.Dirty_Buff_Count] ; set dirty_count to 0.
SYSINIT:14CF                 mov     ax, di
SYSINIT:14D1                 mov     cx, cs:buffers
SYSINIT:14D6                 push    di              ; remember first buffer
SYSINIT:14D7
SYSINIT:14D7 nxt_buff:                               ; CODE XREF: set_buffer+20↓j
SYSINIT:14D7                 call    set_buffer_info ; set buf_link,buf_id...
SYSINIT:14DA                 mov     di, ax
SYSINIT:14DC                 loop    nxt_buff
SYSINIT:14DE                 sub     di, cs:singlebuffersize ; point to last buffer
SYSINIT:14E3                 pop     cx              ; get first buffer
SYSINIT:14E4                 mov     es:[di], cx     ; [es:di+buffinfo.buf_next] ; last->next = first
SYSINIT:14E7                 xchg    cx, di
SYSINIT:14E9                 mov     es:[di+2], cx   ; [es:di+buffinfo.buf_prev] ; first->prev = last
SYSINIT:14ED                 or      dl, dl          ; In HMa ?
SYSINIT:14EF                 jz      short set_buff_2 ; no
SYSINIT:14F1                 mov     byte ptr [bx+0Ch], 1 ; mov byte [bx+BUFFINF.Buff_In_HMA],1
SYSINIT:14F5                 mov     ax, cs:memhi    ; seg of scratch buff
SYSINIT:14F9                 mov     word ptr [bx+0Dh], 0 ; [bx+BUFFINF.Lo_Mem_Buff] ; offset of scratch buff is 0
SYSINIT:14FE                 mov     [bx+0Fh], ax    ; mov [bx+BUFFINF.Lo_Mem_Buff+2],ax
SYSINIT:1501                 mov     ax, cs:singlebuffersize ; size of scratch buff
SYSINIT:1505                 sub     ax, 24          ; bufinsiz ; 24 ; buffer head not required
SYSINIT:1505                                         ; (bufinsiz is 20 in MSDOS 6.21 IO.SYS)
SYSINIT:1508
SYSINIT:1508 set_buff_2:                             ; CODE XREF: set_buffer+33↑j
SYSINIT:1508                 add     cs:memlo, ax
SYSINIT:150D                 or      cs:setdevmarkflag, 2 ; for_devmark = 2
SYSINIT:1513                 call    round
SYSINIT:1516                 retn
SYSINIT:1516 set_buffer      endp
SYSINIT:1516
SYSINIT:1517
SYSINIT:1517 ; =============== S U B R O U T I N E =======================================
SYSINIT:1517
SYSINIT:1517
SYSINIT:1517 GetBufferAddr   proc near               ; CODE XREF: set_buffer+2↑p
SYSINIT:1517                 push    bx
SYSINIT:1518                 push    dx
SYSINIT:1519                 cmp     cs:dosdata_umb, 2 ; is dosdata moved to UMB ? (DOSDATA=UMB done)
SYSINIT:151F                 jnz     short gba_1     ; no
SYSINIT:1521                 cmp     word ptr [bx+2], 0FFFFh ; is the buffer (already) in HMA ?
SYSINIT:1525                 jz      short gba_2     ; yes
SYSINIT:1527
SYSINIT:1527 gba_1:                                  ; CODE XREF: GetBufferAddr+8↑j
SYSINIT:1527                 mov     ax, cs:singlebuffersize
SYSINIT:152B                 mul     cs:buffers
SYSINIT:1530                 add     ax, 0Fh         ; 15
SYSINIT:1533                 and     ax, 0FFF0h      ; ~15 ; not 0Fh
SYSINIT:1536                 mov     bx, ax
SYSINIT:1538                 mov     ax, 4A02h       ; ((multMULT<<8)+multMULTALLOCHMA)
SYSINIT:153B                 int     2Fh             ; DOS 5+ - ALLOCATE HMA SPACE
SYSINIT:153B                                         ;     AX = 4A02h
SYSINIT:153B                                         ;     BX = number of bytes
SYSINIT:153B                                         ; Return:
SYSINIT:153B                                         ;     ES:DI -> start of allocated HMA block or FFFFh:FFFFh
SYSINIT:153B                                         ;     BX = number of bytes actually allocated (rounded up to next
SYSINIT:153B                                         ;          paragraph for DOS 5.0 and 6.0)
SYSINIT:153B                                         ; Notes:
SYSINIT:153B                                         ;     this call is not valid unless DOS is loaded in the HMA (DOS=HIGH)
SYSINIT:153B                                         ;
SYSINIT:153B                                         ;     called by Windows 3.1 DOSX.EXE
SYSINIT:153B                                         ;     supported by Novell DOS 7
SYSINIT:153D                 cmp     di, 0FFFFh
SYSINIT:1540                 jnz     short got_hma
SYSINIT:1542                 mov     di, 0           ; dont xor di,di Z flag needed
SYSINIT:1542                                         ;
SYSINIT:1542                                         ; 05/09/2023 - Erdogan Tan
SYSINIT:1542                                         ; (above msdos source code comment is wrong
SYSINIT:1542                                         ; because ZF is already 1 here and
SYSINIT:1542                                         ; 'xor di,di' sets ZF to 1 again;
SYSINIT:1542                                         ; 'inc di' would be most proper instruction here)
SYSINIT:1545                 mov     es, cs:memhi
SYSINIT:154A
SYSINIT:154A got_hma:                                ; CODE XREF: GetBufferAddr+29↑j
SYSINIT:154A                 pop     dx
SYSINIT:154B                 pop     bx
SYSINIT:154C                 retn
SYSINIT:154D ; ---------------------------------------------------------------------------
SYSINIT:154D
SYSINIT:154D gba_2:                                  ; CODE XREF: GetBufferAddr+E↑j
SYSINIT:154D                 les     di, [bx]
SYSINIT:154F                 or      di, di
SYSINIT:1551                 pop     dx
SYSINIT:1552                 pop     bx
SYSINIT:1553                 retn
SYSINIT:1553 GetBufferAddr   endp
SYSINIT:1553
SYSINIT:1554
SYSINIT:1554 ; =============== S U B R O U T I N E =======================================
SYSINIT:1554
SYSINIT:1554
SYSINIT:1554 set_buffer_info proc near               ; CODE XREF: set_buffer:nxt_buff↑p
SYSINIT:1554                 push    cs:buf_prev_off ; es:di -> buffer header to be set.
SYSINIT:1554                                         ; ax = di
SYSINIT:1559                 pop     word ptr es:[di+2] ; [es:di+buffinfo.buf_prev]
SYSINIT:155D                 mov     cs:buf_prev_off, ax
SYSINIT:1561                 add     ax, cs:singlebuffersize ; adjust ax
SYSINIT:1566                 mov     es:[di], ax     ; [es:di+buffinfo.buf_next]
SYSINIT:1569                 mov     word ptr es:[di+4], 0FFh ; [es:di+buffinfo.buf_ID]
SYSINIT:1569                                         ; new buffer free
SYSINIT:156F                 mov     word ptr es:[di+6], 0 ; [es:di+buffinfo.buf_sector]
SYSINIT:1575                 mov     word ptr es:[di+8], 0 ; [es:di+buffinfo.buf_sector+2]
SYSINIT:157B                 retn
SYSINIT:157B set_buffer_info endp
SYSINIT:157B
SYSINIT:157C
SYSINIT:157C ; =============== S U B R O U T I N E =======================================
SYSINIT:157C
SYSINIT:157C
SYSINIT:157C stackinit       proc near               ; CODE XREF: endfile+2D9↑p
SYSINIT:157C                 push    ax              ; ibmstack initialization routine
SYSINIT:157C                                         ; in - cs, ds -> sysinitseg,
SYSINIT:157C                                         ;      es -> relocated stack code & data.
SYSINIT:157D                 push    ds
SYSINIT:157E                 push    es
SYSINIT:157F                 push    bx
SYSINIT:1580                 push    cx
SYSINIT:1581                 push    dx
SYSINIT:1582                 push    di
SYSINIT:1583                 push    si
SYSINIT:1584                 push    bp
SYSINIT:1585                 mov     ax, cs:stack_count
SYSINIT:1589                 mov     es:stackcount, ax
SYSINIT:158D                 mov     ax, ds:stack_size
SYSINIT:1590                 mov     es:stacksize, ax
SYSINIT:1594                 mov     ax, cs:stack_addr ; offset
SYSINIT:1598                 mov     es:stacks, ax
SYSINIT:159C                 mov     ax, cs:stack_addr+2 ; segment
SYSINIT:15A0                 mov     es:stacks+2, ax
SYSINIT:15A4                 mov     bp, es:stacks   ; "firstentry" will always be at stacks
SYSINIT:15A4                                         ; the stacks will always immediately follow the table entries
SYSINIT:15A9                 mov     es:firstentry, bp
SYSINIT:15AE                 mov     ax, 8           ; entrysize
SYSINIT:15B1                 mov     cx, es:stackcount
SYSINIT:15B6                 mul     cx
SYSINIT:15B8                 add     ax, bp
SYSINIT:15BA                 mov     es:stackat, ax
SYSINIT:15BE                 mov     bx, ax
SYSINIT:15C0                 sub     bx, 2
SYSINIT:15C3                 mov     di, es:stackat  ; zero the entire stack area to start with
SYSINIT:15C8                 mov     ax, es:stacksize
SYSINIT:15CC                 mul     cx
SYSINIT:15CE                 mov     cx, ax
SYSINIT:15D0                 xor     ax, ax
SYSINIT:15D2                 push    es
SYSINIT:15D3                 pop     ds              ; ds = relocated stack code seg.
SYSINIT:15D4                 mov     es, ds:stacks+2 ; get segment of stack area.
SYSINIT:15D8                 cld
SYSINIT:15D9                 rep stosb               ; 0
SYSINIT:15DB                 mov     cx, ds:stackcount ; loop for "count" times, building a table entry
SYSINIT:15DB                                         ; cs = sysinitseg, ds = relocated stack code seg,
SYSINIT:15DB                                         ; es = segment of stack space
SYSINIT:15DB                                         ; cx = number of entries
SYSINIT:15DB                                         ; es:bp => base of stacks - 2
SYSINIT:15DB                                         ; es:bx => first table entry
SYSINIT:15DF
SYSINIT:15DF buildloop:                              ; CODE XREF: stackinit+82↓j
SYSINIT:15DF                 mov     byte ptr es:[bp+0], 0 ; [es:bp+allocbyte],free
SYSINIT:15E4                 mov     es:[bp+1], al   ; [es:bp+intlevel]
SYSINIT:15E4                                         ; ax = 0
SYSINIT:15E8                 mov     es:[bp+2], ax   ; [es:bp+savedsp]
SYSINIT:15EC                 mov     es:[bp+4], ax   ; [es:bp+savedss]
SYSINIT:15F0                 add     bx, ds:stacksize
SYSINIT:15F4                 mov     es:[bp+6], bx   ; [es:bp+newsp]
SYSINIT:15F8                 mov     es:[bx], bp
SYSINIT:15FB                 add     bp, 8           ; entrysize
SYSINIT:15FE                 loop    buildloop
SYSINIT:1600                 sub     bp, 8           ; entrysize
SYSINIT:1603                 mov     ds:lastentry, bp
SYSINIT:1607                 mov     ds:nextentry, bp
SYSINIT:160B                 push    ds
SYSINIT:160C                 mov     ax, 0F000h      ; look at the model byte
SYSINIT:160F                 mov     ds, ax
SYSINIT:1611                 assume ds:nothing
SYSINIT:1611                 cmp     byte ptr ds:0FFFEh, 0F9h ; mdl_convert ; convertible?
SYSINIT:1616                 pop     ds
SYSINIT:1617                 assume ds:nothing
SYSINIT:1617                 jnz     short skip_disablenmis
SYSINIT:1619                 mov     al, 7           ; disable convertible nmis
SYSINIT:161B                 out     72h, al         ; CMOS Memory/RTC Index Register (Extended RAM)
SYSINIT:161D
SYSINIT:161D skip_disablenmis:                       ; CODE XREF: stackinit+9B↑j
SYSINIT:161D                 xor     ax, ax
SYSINIT:161F                 mov     es, ax
SYSINIT:1621                 assume es:nothing
SYSINIT:1621                 cli
SYSINIT:1622
SYSINIT:1622 stkinit_02:                             ; Int 02h vector table offset
SYSINIT:1622                 mov     si, 8
SYSINIT:1625                 mov     di, offset int19old02
SYSINIT:1628                 mov     bx, offset old02
SYSINIT:162B                 mov     dx, offset int02
SYSINIT:162E                 call    new_init_loop
SYSINIT:1631
SYSINIT:1631 stkinit_08:                             ; Int 08h vector table offset
SYSINIT:1631                 mov     si, 32
SYSINIT:1634                 mov     di, offset int19old08
SYSINIT:1637                 mov     bx, offset old08
SYSINIT:163A                 mov     dx, offset int08
SYSINIT:163D                 call    new_init_loop
SYSINIT:1640
SYSINIT:1640 stkinit_09:                             ; Int 09h vector table offset
SYSINIT:1640                 mov     si, 36
SYSINIT:1643                 mov     di, offset int19old09
SYSINIT:1646                 mov     bx, offset old09
SYSINIT:1649                 mov     dx, offset int09
SYSINIT:164C                 call    new_init_loop
SYSINIT:164F
SYSINIT:164F stkinit_70:                             ; Int 70h vector table offset
SYSINIT:164F                 mov     si, 448
SYSINIT:1652                 mov     di, offset int19old70
SYSINIT:1655                 mov     bx, offset old70
SYSINIT:1658                 mov     dx, offset int70
SYSINIT:165B                 call    new_init_loop
SYSINIT:165E
SYSINIT:165E stkinit_0A:                             ; 0Ah*4 ; 40
SYSINIT:165E                 mov     si, 28h         ; Int 0Ah vector table offset
SYSINIT:1661                 push    ds              ; save relocated stack code segment
SYSINIT:1662                 lds     bx, es:[si]     ; ds:bx -> original interrupt handler
SYSINIT:1665                 push    ds
SYSINIT:1666                 pop     dx              ; dx = segment value
SYSINIT:1667                 cmp     dx, 0
SYSINIT:166A                 jz      short int_0A_first
SYSINIT:166C                 cmp     byte ptr [bx], 0CFh ; does vector point to an iret?
SYSINIT:166F                 jz      short int_0A_first
SYSINIT:1671                 cmp     word ptr [bx+6], 424Bh ; magic offset (see int&aa, msstack.inc)
SYSINIT:1676                 jz      short int_0A_not_first
SYSINIT:1678                 cmp     dx, 0F000h      ; rom bios segment
SYSINIT:167C                 jnz     short int_0A_not_first
SYSINIT:167E                 push    es
SYSINIT:167F                 push    dx
SYSINIT:1680                 mov     dx, 0F000h
SYSINIT:1683                 mov     es, dx
SYSINIT:1685                 assume es:nothing
SYSINIT:1685                 cmp     bx, es:0FF01h
SYSINIT:168A                 pop     dx
SYSINIT:168B                 pop     es
SYSINIT:168C                 assume es:nothing
SYSINIT:168C                 jz      short int_0A_first
SYSINIT:168E
SYSINIT:168E int_0A_not_first:                       ; CODE XREF: stackinit+FA↑j
SYSINIT:168E                                         ; stackinit+100↑j
SYSINIT:168E                 pop     ds              ; not the first. we are going to hook vector.
SYSINIT:168F                 mov     di, offset int19old0A ; we have to set old&aa for int19 handler too.
SYSINIT:1692                 mov     bx, offset old0A ; pass where to save original owner pointer
SYSINIT:1695                 mov     dx, offset int0A ; pass where new handler is
SYSINIT:1698                 call    new_init_loop   ; adjust the vector to new handler,
SYSINIT:1698                                         ; saving pointer to original owner.
SYSINIT:169B                 jmp     short stkinit_0B
SYSINIT:169D ; ---------------------------------------------------------------------------
SYSINIT:169D
SYSINIT:169D int_0A_first:                           ; CODE XREF: stackinit+EE↑j
SYSINIT:169D                                         ; stackinit+F3↑j ...
SYSINIT:169D                 pop     ds              ; the first. don't have to hook stack code.
SYSINIT:169E
SYSINIT:169E stkinit_0B:                             ; CODE XREF: stackinit+11F↑j
SYSINIT:169E                 mov     si, 2Ch         ; Int 0Bh vector table offset
SYSINIT:16A1                 push    ds
SYSINIT:16A2                 lds     bx, es:[si]
SYSINIT:16A5                 push    ds
SYSINIT:16A6                 pop     dx
SYSINIT:16A7                 cmp     dx, 0
SYSINIT:16AA                 jz      short int_0B_first
SYSINIT:16AC                 cmp     byte ptr [bx], 0CFh
SYSINIT:16AF                 jz      short int_0B_first
SYSINIT:16B1                 cmp     word ptr [bx+6], 424Bh
SYSINIT:16B6                 jz      short int_0B_not_first
SYSINIT:16B8                 cmp     dx, 0F000h
SYSINIT:16BC                 jnz     short int_0B_not_first
SYSINIT:16BE                 push    es
SYSINIT:16BF                 push    dx
SYSINIT:16C0                 mov     dx, 0F000h
SYSINIT:16C3                 mov     es, dx
SYSINIT:16C5                 assume es:nothing
SYSINIT:16C5                 cmp     bx, es:0FF01h
SYSINIT:16CA                 pop     dx
SYSINIT:16CB                 pop     es
SYSINIT:16CC                 assume es:nothing
SYSINIT:16CC                 jz      short int_0B_first
SYSINIT:16CE
SYSINIT:16CE int_0B_not_first:                       ; CODE XREF: stackinit+13A↑j
SYSINIT:16CE                                         ; stackinit+140↑j
SYSINIT:16CE                 pop     ds
SYSINIT:16CF                 mov     di, offset int19old0B
SYSINIT:16D2                 mov     bx, offset old0B
SYSINIT:16D5                 mov     dx, offset int0B
SYSINIT:16D8                 call    new_init_loop
SYSINIT:16DB                 jmp     short stkinit_0C
SYSINIT:16DD ; ---------------------------------------------------------------------------
SYSINIT:16DD
SYSINIT:16DD int_0B_first:                           ; CODE XREF: stackinit+12E↑j
SYSINIT:16DD                                         ; stackinit+133↑j ...
SYSINIT:16DD                 pop     ds
SYSINIT:16DE
SYSINIT:16DE stkinit_0C:                             ; CODE XREF: stackinit+15F↑j
SYSINIT:16DE                 mov     si, 30h         ; Int 0Ch vector table offset
SYSINIT:16E1                 push    ds
SYSINIT:16E2                 lds     bx, es:[si]
SYSINIT:16E5                 push    ds
SYSINIT:16E6                 pop     dx
SYSINIT:16E7                 cmp     dx, 0
SYSINIT:16EA                 jz      short int_0C_first
SYSINIT:16EC                 cmp     byte ptr [bx], 0CFh
SYSINIT:16EF                 jz      short int_0C_first
SYSINIT:16F1                 cmp     word ptr [bx+6], 424Bh
SYSINIT:16F6                 jz      short int_0C_not_first
SYSINIT:16F8                 cmp     dx, 0F000h
SYSINIT:16FC                 jnz     short int_0C_not_first
SYSINIT:16FE                 push    es
SYSINIT:16FF                 push    dx
SYSINIT:1700                 mov     dx, 0F000h
SYSINIT:1703                 mov     es, dx
SYSINIT:1705                 assume es:nothing
SYSINIT:1705                 cmp     bx, es:0FF01h
SYSINIT:170A                 pop     dx
SYSINIT:170B                 pop     es
SYSINIT:170C                 assume es:nothing
SYSINIT:170C                 jz      short int_0C_first
SYSINIT:170E
SYSINIT:170E int_0C_not_first:                       ; CODE XREF: stackinit+17A↑j
SYSINIT:170E                                         ; stackinit+180↑j
SYSINIT:170E                 pop     ds
SYSINIT:170F                 mov     di, offset int19old0C
SYSINIT:1712                 mov     bx, offset old0C
SYSINIT:1715                 mov     dx, offset int0C
SYSINIT:1718                 call    new_init_loop
SYSINIT:171B                 jmp     short stkinit_0D
SYSINIT:171D ; ---------------------------------------------------------------------------
SYSINIT:171D
SYSINIT:171D int_0C_first:                           ; CODE XREF: stackinit+16E↑j
SYSINIT:171D                                         ; stackinit+173↑j ...
SYSINIT:171D                 pop     ds
SYSINIT:171E
SYSINIT:171E stkinit_0D:                             ; CODE XREF: stackinit+19F↑j
SYSINIT:171E                 mov     si, 34h         ; Int 0Dh vector table offset
SYSINIT:1721                 push    ds
SYSINIT:1722                 lds     bx, es:[si]
SYSINIT:1725                 push    ds
SYSINIT:1726                 pop     dx
SYSINIT:1727                 cmp     dx, 0
SYSINIT:172A                 jz      short int_0D_first
SYSINIT:172C                 cmp     byte ptr [bx], 0CFh
SYSINIT:172F                 jz      short int_0D_first
SYSINIT:1731                 cmp     word ptr [bx+6], 424Bh
SYSINIT:1736                 jz      short int_0D_not_first
SYSINIT:1738                 cmp     dx, 0F000h
SYSINIT:173C                 jnz     short int_0D_not_first
SYSINIT:173E                 push    es
SYSINIT:173F                 push    dx
SYSINIT:1740                 mov     dx, 0F000h
SYSINIT:1743                 mov     es, dx
SYSINIT:1745                 assume es:nothing
SYSINIT:1745                 cmp     bx, es:0FF01h
SYSINIT:174A                 pop     dx
SYSINIT:174B                 pop     es
SYSINIT:174C                 assume es:nothing
SYSINIT:174C                 jz      short int_0D_first
SYSINIT:174E
SYSINIT:174E int_0D_not_first:                       ; CODE XREF: stackinit+1BA↑j
SYSINIT:174E                                         ; stackinit+1C0↑j
SYSINIT:174E                 pop     ds
SYSINIT:174F                 mov     di, offset int19old0D
SYSINIT:1752                 mov     bx, offset old0D
SYSINIT:1755                 mov     dx, offset int0D
SYSINIT:1758                 call    new_init_loop
SYSINIT:175B                 jmp     short stkinit_0E
SYSINIT:175D ; ---------------------------------------------------------------------------
SYSINIT:175D
SYSINIT:175D int_0D_first:                           ; CODE XREF: stackinit+1AE↑j
SYSINIT:175D                                         ; stackinit+1B3↑j ...
SYSINIT:175D                 pop     ds
SYSINIT:175E
SYSINIT:175E stkinit_0E:                             ; CODE XREF: stackinit+1DF↑j
SYSINIT:175E                 mov     si, 38h         ; 0Eh*4 ; Int 0Eh vector table offset
SYSINIT:1761                 push    ds
SYSINIT:1762                 lds     bx, es:[si]
SYSINIT:1765                 push    ds
SYSINIT:1766                 pop     dx
SYSINIT:1767                 cmp     dx, 0
SYSINIT:176A                 jz      short int_0E_first
SYSINIT:176C                 cmp     byte ptr [bx], 0CFh
SYSINIT:176F                 jz      short int_0E_first
SYSINIT:1771                 cmp     word ptr [bx+6], 424Bh
SYSINIT:1776                 jz      short int_0E_not_first
SYSINIT:1778                 cmp     dx, 0F000h
SYSINIT:177C                 jnz     short int_0E_not_first
SYSINIT:177E                 push    es
SYSINIT:177F                 push    dx
SYSINIT:1780                 mov     dx, 0F000h
SYSINIT:1783                 mov     es, dx
SYSINIT:1785                 assume es:nothing
SYSINIT:1785                 cmp     bx, es:0FF01h
SYSINIT:178A                 pop     dx
SYSINIT:178B                 pop     es
SYSINIT:178C                 assume es:nothing
SYSINIT:178C                 jz      short int_0E_first
SYSINIT:178E
SYSINIT:178E int_0E_not_first:                       ; CODE XREF: stackinit+1FA↑j
SYSINIT:178E                                         ; stackinit+200↑j
SYSINIT:178E                 pop     ds
SYSINIT:178F                 mov     di, offset int19old0E
SYSINIT:1792                 mov     bx, offset old0E
SYSINIT:1795                 mov     dx, offset int0E
SYSINIT:1798                 call    new_init_loop
SYSINIT:179B                 jmp     short stkinit_72
SYSINIT:179D ; ---------------------------------------------------------------------------
SYSINIT:179D
SYSINIT:179D int_0E_first:                           ; CODE XREF: stackinit+1EE↑j
SYSINIT:179D                                         ; stackinit+1F3↑j ...
SYSINIT:179D                 pop     ds
SYSINIT:179E
SYSINIT:179E stkinit_72:                             ; CODE XREF: stackinit+21F↑j
SYSINIT:179E                 mov     si, 1C8h        ; 72h*4 ; 456
SYSINIT:179E                                         ; Int 72h vector table offset
SYSINIT:17A1                 push    ds
SYSINIT:17A2                 lds     bx, es:[si]
SYSINIT:17A5                 push    ds
SYSINIT:17A6                 pop     dx
SYSINIT:17A7                 cmp     dx, 0
SYSINIT:17AA                 jz      short int_72_first
SYSINIT:17AC                 cmp     byte ptr [bx], 0CFh
SYSINIT:17AF                 jz      short int_72_first
SYSINIT:17B1                 cmp     word ptr [bx+6], 424Bh
SYSINIT:17B6                 jz      short int_72_not_first
SYSINIT:17B8                 cmp     dx, 0F000h
SYSINIT:17BC                 jnz     short int_72_not_first
SYSINIT:17BE                 push    es
SYSINIT:17BF                 push    dx
SYSINIT:17C0                 mov     dx, 0F000h
SYSINIT:17C3                 mov     es, dx
SYSINIT:17C5                 assume es:nothing
SYSINIT:17C5                 cmp     bx, es:0FF01h
SYSINIT:17CA                 pop     dx
SYSINIT:17CB                 pop     es
SYSINIT:17CC                 assume es:nothing
SYSINIT:17CC                 jz      short int_72_first
SYSINIT:17CE
SYSINIT:17CE int_72_not_first:                       ; CODE XREF: stackinit+23A↑j
SYSINIT:17CE                                         ; stackinit+240↑j
SYSINIT:17CE                 pop     ds
SYSINIT:17CF                 mov     di, offset int19old72
SYSINIT:17D2                 mov     bx, offset old72
SYSINIT:17D5                 mov     dx, offset int72
SYSINIT:17D8                 call    new_init_loop
SYSINIT:17DB                 jmp     short stkinit_73
SYSINIT:17DD ; ---------------------------------------------------------------------------
SYSINIT:17DD
SYSINIT:17DD int_72_first:                           ; CODE XREF: stackinit+22E↑j
SYSINIT:17DD                                         ; stackinit+233↑j ...
SYSINIT:17DD                 pop     ds
SYSINIT:17DE
SYSINIT:17DE stkinit_73:                             ; CODE XREF: stackinit+25F↑j
SYSINIT:17DE                 mov     si, 1CCh        ; 73h*4 ; 460
SYSINIT:17E1                 push    ds
SYSINIT:17E2                 lds     bx, es:[si]
SYSINIT:17E5                 push    ds
SYSINIT:17E6                 pop     dx
SYSINIT:17E7                 cmp     dx, 0
SYSINIT:17EA                 jz      short int_73_first
SYSINIT:17EC                 cmp     byte ptr [bx], 0CFh
SYSINIT:17EF                 jz      short int_73_first
SYSINIT:17F1                 cmp     word ptr [bx+6], 424Bh
SYSINIT:17F6                 jz      short int_73_not_first
SYSINIT:17F8                 cmp     dx, 0F000h
SYSINIT:17FC                 jnz     short int_73_not_first
SYSINIT:17FE                 push    es
SYSINIT:17FF                 push    dx
SYSINIT:1800                 mov     dx, 0F000h
SYSINIT:1803                 mov     es, dx
SYSINIT:1805                 assume es:nothing
SYSINIT:1805                 cmp     bx, es:0FF01h
SYSINIT:180A                 pop     dx
SYSINIT:180B                 pop     es
SYSINIT:180C                 assume es:nothing
SYSINIT:180C                 jz      short int_73_first
SYSINIT:180E
SYSINIT:180E int_73_not_first:                       ; CODE XREF: stackinit+27A↑j
SYSINIT:180E                                         ; stackinit+280↑j
SYSINIT:180E                 pop     ds
SYSINIT:180F                 mov     di, offset int19old73
SYSINIT:1812                 mov     bx, offset old73
SYSINIT:1815                 mov     dx, offset int73
SYSINIT:1818                 call    new_init_loop
SYSINIT:181B                 jmp     short stkinit_74
SYSINIT:181D ; ---------------------------------------------------------------------------
SYSINIT:181D
SYSINIT:181D int_73_first:                           ; CODE XREF: stackinit+26E↑j
SYSINIT:181D                                         ; stackinit+273↑j ...
SYSINIT:181D                 pop     ds
SYSINIT:181E
SYSINIT:181E stkinit_74:                             ; CODE XREF: stackinit+29F↑j
SYSINIT:181E                 mov     si, 1D0h
SYSINIT:1821                 push    ds
SYSINIT:1822                 lds     bx, es:[si]
SYSINIT:1825                 push    ds
SYSINIT:1826                 pop     dx
SYSINIT:1827                 cmp     dx, 0
SYSINIT:182A                 jz      short int_74_first
SYSINIT:182C                 cmp     byte ptr [bx], 0CFh
SYSINIT:182F                 jz      short int_74_first
SYSINIT:1831                 cmp     word ptr [bx+6], 424Bh
SYSINIT:1836                 jz      short int_74_not_first
SYSINIT:1838                 cmp     dx, 0F000h
SYSINIT:183C                 jnz     short int_74_not_first
SYSINIT:183E                 push    es
SYSINIT:183F                 push    dx
SYSINIT:1840                 mov     dx, 0F000h
SYSINIT:1843                 mov     es, dx
SYSINIT:1845                 assume es:nothing
SYSINIT:1845                 cmp     bx, es:0FF01h
SYSINIT:184A                 pop     dx
SYSINIT:184B                 pop     es
SYSINIT:184C                 assume es:nothing
SYSINIT:184C                 jz      short int_74_first
SYSINIT:184E
SYSINIT:184E int_74_not_first:                       ; CODE XREF: stackinit+2BA↑j
SYSINIT:184E                                         ; stackinit+2C0↑j
SYSINIT:184E                 pop     ds
SYSINIT:184F                 mov     di, offset int19old74
SYSINIT:1852                 mov     bx, offset old74
SYSINIT:1855                 mov     dx, offset int74
SYSINIT:1858                 call    new_init_loop
SYSINIT:185B                 jmp     short stkinit_76
SYSINIT:185D ; ---------------------------------------------------------------------------
SYSINIT:185D
SYSINIT:185D int_74_first:                           ; CODE XREF: stackinit+2AE↑j
SYSINIT:185D                                         ; stackinit+2B3↑j ...
SYSINIT:185D                 pop     ds
SYSINIT:185E
SYSINIT:185E stkinit_76:                             ; CODE XREF: stackinit+2DF↑j
SYSINIT:185E                 mov     si, 1D8h        ; 76h*4 ; 472
SYSINIT:1861                 push    ds
SYSINIT:1862                 lds     bx, es:[si]
SYSINIT:1865                 push    ds
SYSINIT:1866                 pop     dx
SYSINIT:1867                 cmp     dx, 0
SYSINIT:186A                 jz      short int_76_first
SYSINIT:186C                 cmp     byte ptr [bx], 0CFh
SYSINIT:186F                 jz      short int_76_first
SYSINIT:1871                 cmp     word ptr [bx+6], 424Bh
SYSINIT:1876                 jz      short int_76_not_first
SYSINIT:1878                 cmp     dx, 0F000h
SYSINIT:187C                 jnz     short int_76_not_first
SYSINIT:187E                 push    es
SYSINIT:187F                 push    dx
SYSINIT:1880                 mov     dx, 0F000h
SYSINIT:1883                 mov     es, dx
SYSINIT:1885                 assume es:nothing
SYSINIT:1885                 cmp     bx, es:0FF01h
SYSINIT:188A                 pop     dx
SYSINIT:188B                 pop     es
SYSINIT:188C                 assume es:nothing
SYSINIT:188C                 jz      short int_76_first
SYSINIT:188E
SYSINIT:188E int_76_not_first:                       ; CODE XREF: stackinit+2FA↑j
SYSINIT:188E                                         ; stackinit+300↑j
SYSINIT:188E                 pop     ds
SYSINIT:188F                 mov     di, offset int19old76
SYSINIT:1892                 mov     bx, offset old76
SYSINIT:1895                 mov     dx, offset int76
SYSINIT:1898                 call    new_init_loop
SYSINIT:189B                 jmp     short stkinit_77
SYSINIT:189D ; ---------------------------------------------------------------------------
SYSINIT:189D
SYSINIT:189D int_76_first:                           ; CODE XREF: stackinit+2EE↑j
SYSINIT:189D                                         ; stackinit+2F3↑j ...
SYSINIT:189D                 pop     ds
SYSINIT:189E
SYSINIT:189E stkinit_77:                             ; CODE XREF: stackinit+31F↑j
SYSINIT:189E                 mov     si, 1DCh        ; mov si,77h*4 ; 476
SYSINIT:189E                                         ; Int 77h vector table offset
SYSINIT:18A1                 push    ds              ; save relocated stack code segment
SYSINIT:18A2                 lds     bx, es:[si]     ; ds:bx -> original interrupt handler
SYSINIT:18A5                 push    ds
SYSINIT:18A6                 pop     dx              ; dx = segment value
SYSINIT:18A7                 cmp     dx, 0
SYSINIT:18AA                 jz      short int_77_first
SYSINIT:18AC                 cmp     byte ptr [bx], 0CFh ; does vector point to an iret?
SYSINIT:18AF                 jz      short int_77_first
SYSINIT:18B1                 cmp     word ptr [bx+6], 424Bh ; magic offset (see int&aa, msstack.inc)
SYSINIT:18B6                 jz      short int_77_not_first
SYSINIT:18B8                 cmp     dx, 0F000h      ; rom bios segment
SYSINIT:18BC                 jnz     short int_77_not_first
SYSINIT:18BE                 push    es
SYSINIT:18BF                 push    dx
SYSINIT:18C0                 mov     dx, 0F000h
SYSINIT:18C3                 mov     es, dx
SYSINIT:18C5                 assume es:nothing
SYSINIT:18C5                 cmp     bx, es:0FF01h
SYSINIT:18CA                 pop     dx
SYSINIT:18CB                 pop     es
SYSINIT:18CC                 assume es:nothing
SYSINIT:18CC                 jz      short int_77_first
SYSINIT:18CE
SYSINIT:18CE int_77_not_first:                       ; CODE XREF: stackinit+33A↑j
SYSINIT:18CE                                         ; stackinit+340↑j
SYSINIT:18CE                 pop     ds              ; not the first. we are going to hook vector.
SYSINIT:18CF                 mov     di, offset int19old77 ; we have to set old&aa for int19 handler too.
SYSINIT:18D2                 mov     bx, offset old77 ; pass where to save original owner pointer
SYSINIT:18D5                 mov     dx, offset int77 ; pass where new handler is
SYSINIT:18D8                 call    new_init_loop   ; adjust the vector to new handler,
SYSINIT:18D8                                         ; saving pointer to original owner.
SYSINIT:18DB                 jmp     short int_77_end
SYSINIT:18DD ; ---------------------------------------------------------------------------
SYSINIT:18DD
SYSINIT:18DD int_77_first:                           ; CODE XREF: stackinit+32E↑j
SYSINIT:18DD                                         ; stackinit+333↑j ...
SYSINIT:18DD                 pop     ds              ; the first. don't have to hook stack code.
SYSINIT:18DE
SYSINIT:18DE int_77_end:                             ; CODE XREF: stackinit+35F↑j
SYSINIT:18DE                 push    ds
SYSINIT:18DF                 mov     ax, 0F000h
SYSINIT:18E2                 mov     ds, ax
SYSINIT:18E4                 assume ds:nothing
SYSINIT:18E4                 cmp     byte ptr ds:0FFFEh, 0F9h ; mdl_convert ; pc convertible?
SYSINIT:18E9                 pop     ds
SYSINIT:18EA                 assume ds:nothing
SYSINIT:18EA                 jnz     short skip_enablenmis
SYSINIT:18EC                 mov     al, 27h         ; enable convertible nmis
SYSINIT:18EE                 out     72h, al         ; CMOS Memory/RTC Index Register (Extended RAM)
SYSINIT:18F0
SYSINIT:18F0 skip_enablenmis:                        ; CODE XREF: stackinit+36E↑j
SYSINIT:18F0                 sti
SYSINIT:18F1                 mov     ax, 70h         ; DOSBIODATASEG
SYSINIT:18F4                 mov     ds, ax
SYSINIT:18F6                 assume ds:nothing
SYSINIT:18F6                 mov     ds:int19sem, 1  ; indicate that int 19h
SYSINIT:18F6                                         ; initialization is complete
SYSINIT:18FB                 pop     bp
SYSINIT:18FC                 pop     si
SYSINIT:18FD                 pop     di
SYSINIT:18FE                 pop     dx
SYSINIT:18FF                 pop     cx
SYSINIT:1900                 pop     bx
SYSINIT:1901                 pop     es
SYSINIT:1902                 pop     ds
SYSINIT:1903                 assume ds:nothing
SYSINIT:1903                 pop     ax
SYSINIT:1904                 retn
SYSINIT:1904 stackinit       endp
SYSINIT:1904
SYSINIT:1905
SYSINIT:1905 ; =============== S U B R O U T I N E =======================================
SYSINIT:1905
SYSINIT:1905
SYSINIT:1905 new_init_loop   proc near               ; CODE XREF: stackinit+B2↑p
SYSINIT:1905                                         ; stackinit+C1↑p ...
SYSINIT:1905                 cmp     cs:dosdata_umb, 2 ; is DOSDATA=UMB done ? (DOSDATA is in UMB)
SYSINIT:190B                 jnz     short new_init_loop_1st
SYSINIT:190D                 push    ds              ; restore original/previous interrupt handler
SYSINIT:190D                                         ; (from int19old?? field in BIOSDATA)
SYSINIT:190E                 mov     ax, 70h
SYSINIT:1911                 mov     ds, ax
SYSINIT:1913                 assume ds:nothing
SYSINIT:1913                 lds     ax, [di]        ; restore original Int ?? handler addr from int19old?? field
SYSINIT:1915                 assume ds:nothing
SYSINIT:1915                 mov     es:[si], ax     ; copy the original int handler addr to its int vector addr
SYSINIT:1918                 mov     word ptr es:[si+2], ds
SYSINIT:191C                 pop     ds
SYSINIT:191D
SYSINIT:191D new_init_loop_1st:                      ; CODE XREF: new_init_loop+6↑j
SYSINIT:191D                 mov     ax, es:[si]     ; new stack initialization
SYSINIT:191D                                         ; (dx = new handler offset,
SYSINIT:191D                                         ;  bx = original handler saving addr,
SYSINIT:191D                                         ;  si = int vector table offset
SYSINIT:191D                                         ;  di = int19old?? field offset -in DOSBIOSDATASEG-
SYSINIT:191D                                         ;  es = zero, segid of vector table
SYSINIT:191D                                         ;  ds = relocated stack code segment)
SYSINIT:1920                 mov     [bx], ax
SYSINIT:1922                 mov     ax, es:[si+2]
SYSINIT:1926                 mov     [bx+2], ax
SYSINIT:1929                 push    ds
SYSINIT:192A                 mov     ax, 70h         ; DOSBIODATASEG
SYSINIT:192D                 mov     ds, ax
SYSINIT:192F                 assume ds:nothing
SYSINIT:192F                 mov     ax, es:[si]
SYSINIT:1932                 mov     [di], ax
SYSINIT:1934                 mov     ax, es:[si+2]
SYSINIT:1938                 mov     [di+2], ax
SYSINIT:193B                 pop     ds
SYSINIT:193C                 assume ds:nothing
SYSINIT:193C                 mov     es:[si], dx
SYSINIT:193F                 mov     word ptr es:[si+2], ds
SYSINIT:1943                 retn
SYSINIT:1943 new_init_loop   endp
SYSINIT:1943
SYSINIT:1944
SYSINIT:1944 ; =============== S U B R O U T I N E =======================================
SYSINIT:1944
SYSINIT:1944
SYSINIT:1944 setdevmark      proc near               ; CODE XREF: endfile+3C↑p
SYSINIT:1944                                         ; endfile+92↑p ...
SYSINIT:1944                 push    es              ; set the devmark for mem command.
SYSINIT:1944                                         ; in:
SYSINIT:1944                                         ;   [memhi] - the address to place devmark
SYSINIT:1944                                         ;   [memlo] = 0
SYSINIT:1944                                         ;   al = id for devmark_id
SYSINIT:1944                                         ; out:
SYSINIT:1944                                         ;   devmark established.
SYSINIT:1944                                         ;   the address saved in cs:[devmark_addr]
SYSINIT:1944                                         ;   [memhi] increase by 1.
SYSINIT:1945                 push    cx
SYSINIT:1946                 mov     cx, cs:memhi
SYSINIT:194B                 mov     cs:devmark_addr, cx
SYSINIT:1950                 mov     es, cx
SYSINIT:1952                 mov     es:0, al        ; [es:devmark.id]
SYSINIT:1956                 inc     cx
SYSINIT:1957                 mov     es:1, cx        ; [es:devmark.seg]
SYSINIT:195C                 pop     cx
SYSINIT:195D                 pop     es
SYSINIT:195E                 inc     cs:memhi
SYSINIT:1963                 retn
SYSINIT:1963 setdevmark      endp
SYSINIT:1963
SYSINIT:1963 ; ---------------------------------------------------------------------------
SYSINIT:1964 MagicDDNamePtr  dw offset MagicDDName   ; DATA XREF: SYSINIT:wait_for_key_2s↑w
SYSINIT:1964                                         ; MagicPreload+28↓r
SYSINIT:1964                                         ; "\\DBLSPACE.BIN"
SYSINIT:1966                 db 'C:'
SYSINIT:1968 MagicDDName     db '\DBLSPACE.BIN',0    ; DATA XREF: SYSINIT:set_drvspc_size↑o
SYSINIT:1968                                         ; SYSINIT:MagicDDNamePtr↑o ...
SYSINIT:1976 StackerName     db 'C:\STACKER.BIN',0   ; DATA XREF: SYSINIT:set_stacker_name↑o
SYSINIT:1976                                         ; SYSINIT:0780↑o
SYSINIT:1985 tiny_stub_start dw 0FFFFh               ; DATA XREF: MagicPostload+38↓o
SYSINIT:1985                                         ; phony device driver link
SYSINIT:1987                 dw 0FFFFh               ; dw -1, -1
SYSINIT:1989                 dw 8000h                ; mark as character device for MEM display
SYSINIT:198B                 dw 2 dup(0)             ; strat and irpt
SYSINIT:198F                 db 'DBLSBIN$'           ; magic default load
SYSINIT:198F                                         ; (tiny_stub_end-tiny_stub_start = 18)
SYSINIT:1997
SYSINIT:1997 ; =============== S U B R O U T I N E =======================================
SYSINIT:1997
SYSINIT:1997
SYSINIT:1997 MagicPreload    proc near               ; CODE XREF: SYSINIT:07DA↑p
SYSINIT:1997                 mov     cs:setdevmarkflag, 0 ; not for devmark
SYSINIT:199D                 call    round
SYSINIT:19A0                 push    cs
SYSINIT:19A1                 pop     es
SYSINIT:19A2                 assume es:SYSINIT
SYSINIT:19A2                 mov     cs:DeviceHi, 0  ; not to be loaded in UMB
SYSINIT:19A8                 call    InitDevLoad
SYSINIT:19AB                 mov     ax, cs:DevLoadAddr
SYSINIT:19AF                 add     ax, cs:DevSize  ; calculate seg after DD load
SYSINIT:19B4                 jb      short pre_exit_err ; choke if overflows address space
SYSINIT:19B6                 cmp     ax, cs:DevLoadEnd ; does it overflow available space?
SYSINIT:19BB                 ja      short pre_exit_err
SYSINIT:19BD
SYSINIT:19BD _LoadDev:                               ; we're golden if not
SYSINIT:19BD                 push    cs
SYSINIT:19BE                 pop     ds
SYSINIT:19BF                 assume ds:SYSINIT
SYSINIT:19BF                 mov     dx, cs:MagicDDNamePtr
SYSINIT:19C4                 call    ExecDev         ; load device driver using exec call
SYSINIT:19C7                 jb      short pre_exit_err
SYSINIT:19C9                 les     bx, cs:DevEntry ; point to the Magic DD header
SYSINIT:19CE                 assume es:nothing
SYSINIT:19CE                 cmp     word ptr es:[bx+12h], 2E2Ch ; is it our stamp? ; ',.'
SYSINIT:19D4                 jnz     short pre_exit_err
SYSINIT:19D6                 mov     word ptr cs:MagicBackdoor, 14h ; save the backdoor entry.
SYSINIT:19D6                                         ; (initial IP -EXE header offset 20-)
SYSINIT:19DD                 mov     word ptr cs:MagicBackdoor+2, es
SYSINIT:19E2                 push    cs
SYSINIT:19E3                 pop     es
SYSINIT:19E4                 assume es:SYSINIT
SYSINIT:19E4                 mov     bx, offset packet
SYSINIT:19E7                 mov     cs:break_addr, 0
SYSINIT:19EE                 mov     ax, cs:DevLoadEnd
SYSINIT:19F2                 mov     cs:break_addr+2, ax
SYSINIT:19F6                 mov     al, cs:drivenumber ; pass drive number to DBLSPACE as if
SYSINIT:19FA                 mov     cs:devdrivenum, al ; it is a normal block device driver
SYSINIT:19FE                 mov     ax, 10          ; DS_INTERNAL_REVISION
SYSINIT:19FE                                         ; tell it what revision we expect
SYSINIT:1A01                 call    cs:MagicBackdoor ; first time call is init entry point
SYSINIT:1A01                                         ; with a standard device driver
SYSINIT:1A01                                         ; init packet at es:bx
SYSINIT:1A06                 jnb     short no_driver_version_fail ; skip if not a version failure
SYSINIT:1A08                 mov     ax, 6           ; DS_INTERNAL_REVISION_6 ; (Stacker ?)
SYSINIT:1A08                                         ; tell it what revision we expect
SYSINIT:1A0B                 call    cs:MagicBackdoor
SYSINIT:1A10                 jnb     short no_driver_version_fail
SYSINIT:1A12                 push    cs
SYSINIT:1A13                 pop     ds
SYSINIT:1A14                 mov     dx, offset baddblspace ; "Required system component is not instal"...
SYSINIT:1A17                 call    print           ; display the message
SYSINIT:1A1A
SYSINIT:1A1A fail_driver_load:                       ; CODE XREF: MagicPreload+95↓j
SYSINIT:1A1A                 mov     word ptr cs:MagicBackdoor+2, cs
SYSINIT:1A1F                 mov     word ptr cs:MagicBackdoor, offset NullBackdoor
SYSINIT:1A26
SYSINIT:1A26 pre_exit_err:                           ; CODE XREF: MagicPreload+1D↑j
SYSINIT:1A26                                         ; MagicPreload+24↑j ...
SYSINIT:1A26                 mov     ax, 40h         ; SYSPRE_BADFILE_ERROR
SYSINIT:1A26                                         ; (problem loading dblspace.bin)
SYSINIT:1A29                 retn
SYSINIT:1A2A ; ---------------------------------------------------------------------------
SYSINIT:1A2A
SYSINIT:1A2A no_driver_version_fail:                 ; CODE XREF: MagicPreload+6F↑j
SYSINIT:1A2A                                         ; MagicPreload+79↑j
SYSINIT:1A2A                 or      ax, ax          ; error code returned?
SYSINIT:1A2C                 jnz     short fail_driver_load
SYSINIT:1A2E
SYSINIT:1A2E magic_is_resident:
SYSINIT:1A2E                 mov     ax, cs:break_addr
SYSINIT:1A32                 call    ParaRound       ; convert to paragraphs
SYSINIT:1A35                 add     ax, cs:break_addr+2
SYSINIT:1A3A                 mov     word ptr cs:DevBrkAddr+2, ax
SYSINIT:1A3E                 mov     word ptr cs:DevBrkAddr, 0 ; store normalized end here
SYSINIT:1A45                 mov     bx, 4           ; inquire how many paragraphs it wants
SYSINIT:1A48                 call    cs:MagicBackdoor
SYSINIT:1A4D                 mov     bx, cs:ALLOCLIM ; get top of free memory
SYSINIT:1A52                 sub     bx, ax          ; see how much we'll lower it
SYSINIT:1A54                 cmp     bx, word ptr cs:DevBrkAddr+2 ; is there that much room free?
SYSINIT:1A59                 jb      short cant_move_driver
SYSINIT:1A5B                 sub     cs:ALLOCLIM, ax ; (mov [cs:ALLOCLIM],bx)
SYSINIT:1A60                 mov     es, cs:ALLOCLIM
SYSINIT:1A65                 assume es:nothing
SYSINIT:1A65                 mov     bx, 6           ; tell the driver to move itself
SYSINIT:1A68                 call    cs:MagicBackdoor
SYSINIT:1A6D                 mov     word ptr cs:DevBrkAddr+2, ax ; save end of low stub
SYSINIT:1A71
SYSINIT:1A71 cant_move_driver:                       ; CODE XREF: MagicPreload+C2↑j
SYSINIT:1A71                 mov     ax, word ptr cs:DevBrkAddr+2 ; get terminate segment
SYSINIT:1A75                 cmp     ax, cs:DevLoadEnd ; terminate size TOO big?
SYSINIT:1A7A                 ja      short pre_exit_err ; error out if so
SYSINIT:1A7C
SYSINIT:1A7C _isblock:                               ; if no units found, erase the device
SYSINIT:1A7C                 mov     al, cs:unitcount
SYSINIT:1A80                 or      al, al
SYSINIT:1A82                 jz      short pre_exit_err
SYSINIT:1A84                 xor     ah, ah
SYSINIT:1A86                 lds     si, cs:DevEntry ; set ds:si to header
SYSINIT:1A8B                 assume ds:nothing
SYSINIT:1A8B                 mov     [si+10], al     ; mov [si+SYSDEV.NAME],al
SYSINIT:1A8B                                         ; number of units in name field
SYSINIT:1A8B                                         ; device drivers are *supposed*
SYSINIT:1A8B                                         ; to do this for themselves.
SYSINIT:1A8E                 mov     cx, ax
SYSINIT:1A90                 les     di, cs:DOSINFO  ; es:di point to dos info
SYSINIT:1A95                 mov     ah, es:[di+20h] ; [es:di+SYSI_NUMIO]
SYSINIT:1A95                                         ; get number of devices
SYSINIT:1A99                 mov     dl, ah
SYSINIT:1A9B                 add     ah, al          ; check for too many devices
SYSINIT:1A9D                 cmp     ah, 26          ; 'A' - 'Z' is 26 devices
SYSINIT:1AA0                 ja      short pre_exit_err
SYSINIT:1AA2                 or      cs:setdevmarkflag, 2
SYSINIT:1AA8                 call    DevSetBreak
SYSINIT:1AAB                 jnb     short _ok_block
SYSINIT:1AAD                 jmp     pre_exit_err
SYSINIT:1AB0 ; ---------------------------------------------------------------------------
SYSINIT:1AB0
SYSINIT:1AB0 _ok_block:                              ; CODE XREF: MagicPreload+114↑j
SYSINIT:1AB0                 mov     es:[di+20h], ah ; [es:di+SYSI_NUMIO] ; update the amount
SYSINIT:1AB4                 lds     bx, cs:bpb_addr ; point to bpb array (*)
SYSINIT:1AB9                 xor     dh, dh
SYSINIT:1ABB
SYSINIT:1ABB _perunit:
SYSINIT:1ABB                 les     bp, cs:DOSINFO
SYSINIT:1AC0                 les     bp, es:[bp+0]   ; es:[bp.sysi_dpb]
SYSINIT:1AC0                                         ; get first dpb
SYSINIT:1AC0                                         ; [es:bp+SysInitvars.SYSI_DPB] ; [es:bp+0]
SYSINIT:1AC4
SYSINIT:1AC4 _scandpb:                               ; CODE XREF: MagicPreload+138↓j
SYSINIT:1AC4                 cmp     word ptr es:[bp+19h], 0FFFFh ; -1 ; es:[bp.dpb_next_dpb]
SYSINIT:1AC9                 jz      short _foundpb
SYSINIT:1ACB                 les     bp, es:[bp+19h] ; les bp,es:[bp.dpb_next_dpb]
SYSINIT:1ACB                                         ; [es:bp+DPB.NEXT_DPB]
SYSINIT:1ACF                 jmp     short _scandpb
SYSINIT:1AD1 ; ---------------------------------------------------------------------------
SYSINIT:1AD1
SYSINIT:1AD1 _foundpb:                               ; CODE XREF: MagicPreload+132↑j
SYSINIT:1AD1                                         ; MagicPreload+1C4↓j
SYSINIT:1AD1                 mov     ax, word ptr cs:DevBrkAddr
SYSINIT:1AD5                 mov     es:[bp+19h], ax ; es:[bp.dpb_next_dpb] ; DPB.NEXT_DPB
SYSINIT:1AD9                 mov     ax, word ptr cs:DevBrkAddr+2
SYSINIT:1ADD                 mov     es:[bp+1Bh], ax ; es:[bp.dpb_next_dpb+2] ; DPB.NEXT_DPB+2
SYSINIT:1AE1                 les     bp, cs:DevBrkAddr
SYSINIT:1AE6                 mov     word ptr es:[bp+19h], 0FFFFh ; -1
SYSINIT:1AEC                 mov     byte ptr es:[bp+18h], 0FFh ; es:[bp.dpb_first_access],-1
SYSINIT:1AEC                                         ; DPB.FIRST_ACCESS
SYSINIT:1AF1                 add     word ptr cs:DevBrkAddr, 61 ; DPBSIZ ; 3Dh
SYSINIT:1AF7                 call    RoundBreakAddr
SYSINIT:1AFA                 mov     si, [bx]        ; ds:si points to bpb (*)
SYSINIT:1AFA                                         ; (mov si,[bx] ..and then.. add bx,2)
SYSINIT:1AFA                                         ; Note: If unit count > 1, bx points to a BPB in the BPB array,
SYSINIT:1AFA                                         ; the array address is in [bpb_addr] (*)
SYSINIT:1AFA                                         ; Erdogan Tan - 07/07/2023
SYSINIT:1AFC                 mov     es:[bp+0], dl   ; mov word ptr es:[bp.dpb_drive],dx
SYSINIT:1AFC                                         ; [es:bp+DPB.DRIVE],dl
SYSINIT:1B00                 mov     es:[bp+1], dh   ; [es:bp+DPB.UNIT],dh
SYSINIT:1B04                 push    dx
SYSINIT:1B05                 push    cx
SYSINIT:1B06                 mov     dx, 4152h       ; DX = signature 4152h ('AR') for FAT32 extended BPB/DPB
SYSINIT:1B09                 xor     cx, cx          ; 0
SYSINIT:1B0B                 mov     es:[bp+1Dh], cx ; DPB.NEXT_FREE ; last allocated cluster #
SYSINIT:1B0F                 cmp     [si+0Bh], cx    ; BPB.fatsecs16 ; [si+A_BPB.BPB_SECTORSPERFAT]
SYSINIT:1B12                 jnz     short _setdpb   ; FAT DPB (33 bytes)
SYSINIT:1B12                                         ; FAT32 DPB (61 bytes)
SYSINIT:1B14                 mov     es:[bp+39h], cx ; DPB.RESERVED = 0
SYSINIT:1B18                 mov     es:[bp+3Bh], cx ; DPB.RESERVED+2 = 0
SYSINIT:1B1C                 dec     cx              ; 0FFFFh ; -1
SYSINIT:1B1D                 mov     es:[bp+1Fh], cx ; DPB.FREE_CNT (-1 = unknown)
SYSINIT:1B21                 mov     es:[bp+21h], cx ; DPB.FREE_CNT+2 (-1 = unknown)
SYSINIT:1B25                 mov     cx, 4558h       ; CX = signature 4558h ('EX') for FAT32 extended BPB/DPB
SYSINIT:1B28
SYSINIT:1B28 _setdpb:                                ; CODE XREF: MagicPreload+17B↑j
SYSINIT:1B28                 mov     ah, 53h         ; SETDPB ; hidden system call
SYSINIT:1B2A                 int     21h             ; DOS - 2+ internal - TRANSLATE BIOS PARAMETER BLOCK
SYSINIT:1B2A                                         ; DS:SI -> BPB (BIOS Parameter Block)
SYSINIT:1B2A                                         ; ES:BP -> buffer for DOS Drive Parameter Block
SYSINIT:1B2A                                         ; (if CX=4558h & DX=4152h, FAT32 Extended DPB will be set)
SYSINIT:1B2C                 pop     cx
SYSINIT:1B2D                 pop     dx
SYSINIT:1B2E                 mov     ax, es:[bp+2]   ; es:[bp.dpb_sector_size]  ; [es:bp+DPB.SECTOR_SIZE]
SYSINIT:1B32                 push    es
SYSINIT:1B33                 les     di, cs:DOSINFO
SYSINIT:1B38                 cmp     ax, es:[di+10h] ; es:[di.sysi_maxsec] ; [es:di+SysInitvars.SYSI_MAXSEC]
SYSINIT:1B3C                 pop     es
SYSINIT:1B3D                 jbe     short _iblk_1
SYSINIT:1B3F                 mov     ax, 40h         ; SYSPRE_BADFILE_ERROR ; (pre_exit_err)
SYSINIT:1B3F                                         ; (problem loading dblspace.bin)
SYSINIT:1B42                 retn
SYSINIT:1B43 ; ---------------------------------------------------------------------------
SYSINIT:1B43
SYSINIT:1B43 _iblk_1:                                ; CODE XREF: MagicPreload+1A6↑j
SYSINIT:1B43                 push    ds
SYSINIT:1B44                 lds     ax, cs:DevEntry
SYSINIT:1B49                 mov     es:[bp+13h], ax ; [es:bp+DPB.DRIVER_ADDR]
SYSINIT:1B4D                 mov     word ptr es:[bp+15h], ds ; [es:bp+DPB.DRIVER_ADDR+2]
SYSINIT:1B51                 pop     ds
SYSINIT:1B52                 inc     dl              ; increment drive number
SYSINIT:1B54                 inc     dh              ; increment unit number
SYSINIT:1B56                 inc     bx
SYSINIT:1B57                 inc     bx              ; point to next BPB
SYSINIT:1B57                                         ; (in the BPB array) (*) -add bx,2-
SYSINIT:1B58                 dec     cx              ; loop _foundpb
SYSINIT:1B59                 jz      short _linkit
SYSINIT:1B5B                 jmp     _foundpb
SYSINIT:1B5E ; ---------------------------------------------------------------------------
SYSINIT:1B5E
SYSINIT:1B5E _linkit:                                ; CODE XREF: MagicPreload+1C2↑j
SYSINIT:1B5E                 push    cs
SYSINIT:1B5F                 pop     ds
SYSINIT:1B60                 assume ds:SYSINIT
SYSINIT:1B60                 call    TempCDS         ; set cds for new drives
SYSINIT:1B63                 les     di, cs:DOSINFO  ; es:di = dos table (SysInitVars)
SYSINIT:1B68                 mov     ax, es:[di+22h] ; [es:di+SYSI_DEV] ; dx:cx = head of list
SYSINIT:1B6C                 mov     bx, es:[di+24h] ; [es:di+SYSI_DEV+2]
SYSINIT:1B70                 lds     si, cs:DevEntry ; ds:si = device location
SYSINIT:1B75                 assume ds:nothing
SYSINIT:1B75                 mov     [si], ax        ; link in the driver
SYSINIT:1B77                 mov     [si+2], bx
SYSINIT:1B7A                 mov     es:[di+22h], si ; [es:di+SYSI_DEV] ; set head of list in dos
SYSINIT:1B7E                 mov     word ptr es:[di+24h], ds ; [es:di+SYSI_DEV+2]
SYSINIT:1B82                 call    DevBreak        ; mark successful install
SYSINIT:1B85                 mov     cx, word ptr cs:DevBrkAddr+2 ; pass it a work buffer
SYSINIT:1B8A                 mov     dx, cs:ALLOCLIM ; address in cx (segment)
SYSINIT:1B8F                 sub     dx, cx          ; for len dx (paragraphs)
SYSINIT:1B91                 mov     ax, 5500h       ; we're shuffle aware, but don't move
SYSINIT:1B91                                         ; any drives at this point.
SYSINIT:1B94                 mov     bx, 2           ; switch what we can now
SYSINIT:1B97                 call    cs:MagicBackdoor
SYSINIT:1B9C
SYSINIT:1B9C pre_exit:                               ; no errors!
SYSINIT:1B9C                 xor     ax, ax          ; zf=1
SYSINIT:1B9E                 retn
SYSINIT:1B9E MagicPreload    endp
SYSINIT:1B9E
SYSINIT:1B9F
SYSINIT:1B9F ; =============== S U B R O U T I N E =======================================
SYSINIT:1B9F
SYSINIT:1B9F
SYSINIT:1B9F MagicPostload   proc near               ; CODE XREF: SYSINIT:088B↑p
SYSINIT:1B9F                 call    get_dblspace_version ; is it there?
SYSINIT:1BA2                 jnz     short no_magic  ; done if not
SYSINIT:1BA4                 test    dx, 8000h       ; is it already permanent?
SYSINIT:1BA8                 jz      short no_magic  ; no, done if so (not in final position)
SYSINIT:1BAA                 mov     bx, 0FFFFh      ; -1 ; how much space does it want?
SYSINIT:1BAD                 mov     ax, 4A11h       ; multMagicdrv
SYSINIT:1BAD                                         ; DBLSPACE.BIN - GET RELOCATION SIZE
SYSINIT:1BB0                 int     2Fh             ; get paragraphs into ax
SYSINIT:1BB2                 inc     ax              ; extra 2 paragraphs for the stub
SYSINIT:1BB3                 inc     ax              ; ((tiny_stub_end-tiny_stub_start)+15)/16
SYSINIT:1BB3                                         ; (18+15)/16 = 2
SYSINIT:1BB4                 mov     cs:DevSize, ax  ; store that (**)
SYSINIT:1BB8                 mov     cs:DeviceHi, 0  ; not to be loaded in UMB
SYSINIT:1BBE                 mov     word ptr cs:bpb_addr+2, cs ; pass name so that
SYSINIT:1BBE                                         ; arena header can be set
SYSINIT:1BC3                 mov     word ptr cs:bpb_addr, offset MagicDDName ; "\\DBLSPACE.BIN"
SYSINIT:1BCA                 call    round           ; normalize memhi:memlo
SYSINIT:1BCD                 call    InitDevLoad     ; set up sub-arena, DevLoadAddr,
SYSINIT:1BCD                                         ; DevLoadEnd, and DevEntry
SYSINIT:1BCD                                         ; gets arena name from bpb_addr
SYSINIT:1BD0                 mov     es, cs:DevLoadAddr ; (**) (InitDevload sets this)
SYSINIT:1BD5                 xor     di, di          ; move a little header in place
SYSINIT:1BD5                                         ; so that this looks to the mem command
SYSINIT:1BD5                                         ; like a legitimate driver load
SYSINIT:1BD7                 mov     si, offset tiny_stub_start
SYSINIT:1BDA                 mov     cx, 18          ; (tiny_stub_end-tiny_stub_start)
SYSINIT:1BDD                 rep movsb               ; move it!
SYSINIT:1BDF                 mov     ax, es          ; advance es appropriately
SYSINIT:1BE1                 inc     ax              ; add ax,((tiny_stub_end-tiny_stub_start)+15)/16
SYSINIT:1BE2                 inc     ax
SYSINIT:1BE3                 mov     es, ax
SYSINIT:1BE5                 assume es:MSLOAD
SYSINIT:1BE5                 mov     bx, 0FFFEh      ; -2 ; final placement!
SYSINIT:1BE8                 mov     ax, 4A11h       ; multMagicdrv
SYSINIT:1BEB                 int     2Fh             ; DBLSPACE.BIN - RELOCATE
SYSINIT:1BEB                                         ; es = segment to which to relocate DBLSPACE.BIN
SYSINIT:1BED                 mov     ax, cs:DevLoadAddr ; (**)
SYSINIT:1BF1                 add     ax, cs:DevSize  ; calculate seg after DD load
SYSINIT:1BF6                 mov     word ptr cs:DevBrkAddr+2, ax ; save as ending address!
SYSINIT:1BFA                 mov     word ptr cs:DevBrkAddr, 0
SYSINIT:1C01                 call    DevSetBreak     ; go ahead and alloc mem for device
SYSINIT:1C04                 call    DevBreak
SYSINIT:1C07
SYSINIT:1C07 no_magic:                               ; CODE XREF: MagicPostload+3↑j
SYSINIT:1C07                                         ; MagicPostload+9↑j
SYSINIT:1C07                 retn
SYSINIT:1C07 MagicPostload   endp
SYSINIT:1C07
SYSINIT:1C08
SYSINIT:1C08 ; =============== S U B R O U T I N E =======================================
SYSINIT:1C08
SYSINIT:1C08
SYSINIT:1C08 MagicSetCdss    proc near               ; CODE XREF: SYSINIT:0891↑p
SYSINIT:1C08                 call    get_dblspace_version ; is it there?
SYSINIT:1C0B                 jnz     short magic_set_exit ; done if not
SYSINIT:1C0B                                         ; ...
SYSINIT:1C0B                                         ; cl = first DblSpace drive in ASCII
SYSINIT:1C0B                                         ; ch = number of DblSpace drive letters
SYSINIT:1C0D                 lds     si, cs:DOSINFO  ; point to DOS data area (SysInitVars)
SYSINIT:1C12                 lds     si, [si+16h]    ; lds si,[si+SYSI_CDS] ; fetch CDSs
SYSINIT:1C15                 mov     ah, 88          ; curdirLen
SYSINIT:1C17                 sub     cl, 'A'         ; make it zero based.
SYSINIT:1C1A                 mov     al, cl          ; get first DblSpace drive letter
SYSINIT:1C1C                 mul     ah              ; find first DblSpace CDS
SYSINIT:1C1E                 add     si, ax          ; cds pointer
SYSINIT:1C20                 mov     dl, cl          ; save for drive testing loop
SYSINIT:1C22                 mov     cl, ch          ; get DblSpace drive count into cx
SYSINIT:1C24                 xor     ch, ch
SYSINIT:1C26
SYSINIT:1C26 magic_set_cdss_1:                       ; CODE XREF: MagicSetCdss+3C↓j
SYSINIT:1C26                 push    cx
SYSINIT:1C27                 push    dx
SYSINIT:1C28                 push    ds
SYSINIT:1C29                 push    si
SYSINIT:1C2A                 mov     ax, 4A11h       ; multMagicdrv
SYSINIT:1C2D                 mov     bx, 1           ; MD_DRIVE_MAP ; inquire drive map
SYSINIT:1C30                 int     2Fh             ; DBLSPACE.BIN - "GetDriveMapping"
SYSINIT:1C30                                         ; see if this is an unused DblSpace drive
SYSINIT:1C32                 pop     si
SYSINIT:1C33                 pop     ds
SYSINIT:1C34                 pop     dx
SYSINIT:1C35                 pop     cx
SYSINIT:1C36                 cmp     dl, bl          ; if mapped to itself, it is vacant
SYSINIT:1C38                 jnz     short magic_set_cdss_2 ; skip if used
SYSINIT:1C3A                 and     word ptr [si+43h], 0BFFFh ; reset the bit in flags (curdir_inuse bit)
SYSINIT:1C3A                                         ; [si+curdir_list.cdir_flags],~curdir_inuse ; word
SYSINIT:1C3A                                         ; (.. [si+1+curdir_list.cdir_flags],0BFh ; byte)
SYSINIT:1C3F
SYSINIT:1C3F magic_set_cdss_2:                       ; CODE XREF: MagicSetCdss+30↑j
SYSINIT:1C3F                 add     si, 88          ; curdirLen
SYSINIT:1C42                 inc     dl              ; next drive
SYSINIT:1C44                 loop    magic_set_cdss_1
SYSINIT:1C46
SYSINIT:1C46 magic_set_exit:                         ; CODE XREF: MagicSetCdss+3↑j
SYSINIT:1C46                 retn
SYSINIT:1C46 MagicSetCdss    endp
SYSINIT:1C46
SYSINIT:1C47
SYSINIT:1C47 ; =============== S U B R O U T I N E =======================================
SYSINIT:1C47
SYSINIT:1C47
SYSINIT:1C47 get_dblspace_version proc near          ; CODE XREF: MagicPostload↑p
SYSINIT:1C47                                         ; MagicSetCdss↑p ...
SYSINIT:1C47                 mov     ax, 4A11h       ; multMagicdrv
SYSINIT:1C47                                         ; DBLSPACE.BIN - "GetVersion" - INSTALLATION CHECK
SYSINIT:1C47                                         ; (BX = 0)
SYSINIT:1C4A                 xor     bx, bx          ; MD_VERSION = 0
SYSINIT:1C4C                 int     2Fh             ; Return:
SYSINIT:1C4C                                         ;  AX = 0000h (successful)
SYSINIT:1C4C                                         ;  BX = 444Dh ("DM")
SYSINIT:1C4C                                         ;  CL = first drive letter used by DBLSPACE (41h = A:)
SYSINIT:1C4C                                         ;  CH = number of drive letters used by DBLSPACE
SYSINIT:1C4C                                         ;  DX = internal DBLSPACE.BIN version number (bits 14-0)
SYSINIT:1C4C                                         ;  bit 15 set if DBLSPACE.BIN has not yet been relocated
SYSINIT:1C4C                                         ;  to final position in memory (i.e. DBLSPACE.SYS /MOVE)
SYSINIT:1C4E                 or      ax, ax          ; ax = 0 (successful, zf=1)
SYSINIT:1C50                 retn
SYSINIT:1C50 get_dblspace_version endp
SYSINIT:1C50
SYSINIT:1C50 ; ---------------------------------------------------------------------------
SYSINIT:1C51                 db 0
SYSINIT:1C52 config_envlen   dw 0                    ; DATA XREF: SYSINIT:096B↑r
SYSINIT:1C52                                         ; SYSINIT:09DA↑r ...
SYSINIT:1C52                                         ; when config_wrkseg is being used as
SYSINIT:1C52                                         ; a scratch env, this is its length
SYSINIT:1C54 config_wrkseg   dw 0                    ; DATA XREF: SYSINIT:0971↑r
SYSINIT:1C54                                         ; SYSINIT:09E0↑r ...
SYSINIT:1C54                                         ; config work area (above confbot)
SYSINIT:1C54                                         ; segment of work area
SYSINIT:1C56 config_cmd      db 0                    ; DATA XREF: SYSINIT:0915↑w
SYSINIT:1C56                                         ; doconf+DD↓w ...
SYSINIT:1C56                                         ; current config cmd
SYSINIT:1C56                                         ; (with CONFIG_OPTION_QUERY bit intact)
SYSINIT:1C57 config_multi    db 0                    ; DATA XREF: doconf+E2↓r
SYSINIT:1C57                                         ; copy_block+52↓r ...
SYSINIT:1C57                                         ; non-zero if multi-config config.sys
SYSINIT:1C58 multdeviceflag  db 0                    ; DATA XREF: doconf+CF↓w
SYSINIT:1C58                                         ; doconf+453↓r ...
SYSINIT:1C59 devmark_addr    dw 0                    ; DATA XREF: setdevmark+7↑w
SYSINIT:1C59                                         ; round+29↓r
SYSINIT:1C59                                         ; segment address for devmark.
SYSINIT:1C5B setdevmarkflag  db 0                    ; DATA XREF: endfile+7C↑w
SYSINIT:1C5B                                         ; endfile+DA↑w ...
SYSINIT:1C5B                                         ; flag used for devmark
SYSINIT:1C5C drivers_units   db 0                    ; DATA XREF: doconf+3B1↓w
SYSINIT:1C5C                                         ; doconf+54C↓w ...
SYSINIT:1C5C                                         ; total unitcount for driver
SYSINIT:1C5D ems_stub_installed db 0                 ; (not used)
SYSINIT:1C5E badparm_ptr     dd 0                    ; DATA XREF: doconf+30A↓w
SYSINIT:1C5E                                         ; doconf+327↓w ...
SYSINIT:1C5E                                         ; badparm_off equ badparm_ptr
SYSINIT:1C5E                                         ; badparm_seg equ badparm_ptr+2
SYSINIT:1C62 _$P_ORDINAL     dw 0                    ; DATA XREF: SysParse+8↓w
SYSINIT:1C62                                         ; SysParse+DC↓r ...
SYSINIT:1C62                                         ; Operand ordinal save area
SYSINIT:1C64 _$P_RC          dw 0                    ; DATA XREF: SysParse+D↓w
SYSINIT:1C64                                         ; SysParse:_$P_Too_Many_Error↓w ...
SYSINIT:1C64                                         ; Return code from parser
SYSINIT:1C66 _$P_SI_Save     dw 0                    ; DATA XREF: SysParse:_$P_Pack_End↓w
SYSINIT:1C66                                         ; SysParse+162↓r ...
SYSINIT:1C66                                         ; Pointer of command buffer
SYSINIT:1C68 _$P_DX          dw 0                    ; DATA XREF: SysParse+1B↓w
SYSINIT:1C68                                         ; SysParse+167↓r ...
SYSINIT:1C68                                         ; Return result buffer address
SYSINIT:1C6A _$P_Terminator  db 0                    ; DATA XREF: SysParse+16C↓r
SYSINIT:1C6A                                         ; _$P_File_Format:_$P_FileF00↓w ...
SYSINIT:1C6A                                         ; Terminator code (ASCII)
SYSINIT:1C6B _$P_DBCSEV_OFF  dw 0                    ; DATA XREF: _$P_Chk_DBCS+28↓w
SYSINIT:1C6B                                         ; _$P_Chk_DBCS:_$P_DBCS00↓r
SYSINIT:1C6B                                         ; Offset of DBCS EV
SYSINIT:1C6D _$P_DBCSEV_SEG  dw 0                    ; DATA XREF: _$P_Chk_DBCS+3↓r
SYSINIT:1C6D                                         ; _$P_Chk_DBCS+2D↓w
SYSINIT:1C6D                                         ; Segment of DBCS EV
SYSINIT:1C6F _$P_Flags       db 0                    ; DATA XREF: SysParse↓w
SYSINIT:1C6F                                         ; Parser internal flags
SYSINIT:1C6F                                         ; %define _$P_Flags1 _$P_Flags
SYSINIT:1C6F                                         ;         to reference 1st byte flags
SYSINIT:1C6F                                         ; %define _$P_Flags2 _$P_Flags+1
SYSINIT:1C6F                                         ;         to reference 2nd byte flags only
SYSINIT:1C70 _$P_Flags2      db 0                    ; DATA XREF: SysParse+62↓r
SYSINIT:1C70                                         ; SysParse+7A↓r ...
SYSINIT:1C71 _$P_SaveSI_Cmpx dw 0                    ; DATA XREF: SysParse:_$P_Start↓w
SYSINIT:1C71                                         ; _$P_Chk_SW_Control+18↓w ...
SYSINIT:1C71                                         ; save si for later use by complex
SYSINIT:1C73 _$P_KEYorSW_Ptr dw 0                    ; DATA XREF: _$P_Chk_SW_Control+12↓r
SYSINIT:1C73                                         ; _$P_Chk_SW_Control+1E↓r ...
SYSINIT:1C73                                         ; points next to "=" or ":" code
SYSINIT:1C75 _$P_Save_EOB    dw 0                    ; DATA XREF: SysParse+B6↓w
SYSINIT:1C75                                         ; save pointer to EOB
SYSINIT:1C77 _$P_Found_SYNONYM dw 0                  ; DATA XREF: SysParse+14↓w
SYSINIT:1C77                                         ; _$P_Search_KEYorSW:_$P_KEYorSW_Found↓w ...
SYSINIT:1C77                                         ; es:@ points to found synonym
SYSINIT:1C79 _$P_STRING_BUF  db 128 dup(0)           ; DATA XREF: SysParse+5E↓o
SYSINIT:1C79                                         ; SysParse+BE↓o ...
SYSINIT:1C79                                         ; Pick a operand from command line
SYSINIT:1CF9 _$P_Char_CAP_Ptr db 0FFh                ; DATA XREF: _$P_Do_CAPS_Char+12↓o
SYSINIT:1CF9                                         ; info id
SYSINIT:1CFA                 dw 0                    ; offset of char case map table
SYSINIT:1CFC                 dw 0                    ; segment of char case map table
SYSINIT:1CFE _$P_FileSp_Char db '[]|<>+=;"'          ; DATA XREF: SysParse+22↓w
SYSINIT:1CFE                                         ; _$P_FileSp_Chk+2↓o ...
SYSINIT:1CFE                                         ; delimitters of file spec
SYSINIT:1CFE                                         ; _$P_FileSp_Len equ $-_$P_FileSp_Char
SYSINIT:1D07 _$P_err_flag    db 0                    ; DATA XREF: _$P_Check_Match_Flags↓w
SYSINIT:1D07                                         ; _$P_Check_Match_Flags:_$P_Match_Exit↓r ...
SYSINIT:1D07                                         ; flag set if filespec parsing error
SYSINIT:1D07                                         ; was detected.
SYSINIT:1D08
SYSINIT:1D08 ; =============== S U B R O U T I N E =======================================
SYSINIT:1D08
SYSINIT:1D08
SYSINIT:1D08 SysParse        proc near               ; CODE XREF: sysinit_parse+13↓p
SYSINIT:1D08
SYSINIT:1D08 ; FUNCTION CHUNK AT SYSINIT:1E12 SIZE 00000069 BYTES
SYSINIT:1D08
SYSINIT:1D08                 mov     word ptr cs:_$P_Flags, 0 ; Clear all internal flags
SYSINIT:1D0F                 cld                     ; confirm forward direction
SYSINIT:1D10                 mov     cs:_$P_ORDINAL, cx ; save operand ordinal
SYSINIT:1D15                 mov     cs:_$P_RC, 0    ; _$P_No_Error ; assume no error
SYSINIT:1D1C                 mov     cs:_$P_Found_SYNONYM, 0 ; initalize synonym pointer
SYSINIT:1D23                 mov     cs:_$P_DX, 0    ; The table of special chars _$P_FileSp_Char
SYSINIT:1D23                                         ; should be initialized on every entry to SysParse
SYSINIT:1D2A                 mov     word ptr cs:_$P_FileSp_Char, 5D5Bh ; "[]|<>+=;\""
SYSINIT:1D31                 mov     word ptr cs:_$P_FileSp_Char+2, 3C7Ch ; "|<>+=;\""
SYSINIT:1D38                 mov     word ptr cs:_$P_FileSp_Char+4, 2B3Eh ; ">+=;\""
SYSINIT:1D3F                 mov     word ptr cs:_$P_FileSp_Char+6, 3B3Dh ; "=;\""
SYSINIT:1D46                 call    _$P_Skip_Delim  ; Move si to 1st non white space
SYSINIT:1D49                 jnb     short _$P_Start ; If EOL is not encountered, do parse
SYSINIT:1D4B                 mov     ax, 0FFFFh      ; _$P_RC_EOL  ; set exit code to -1
SYSINIT:1D4E                 push    bx
SYSINIT:1D4F                 mov     bx, es:[di]     ; [es:di+_$P_PARMS_Blk.PARMSX_Address]
SYSINIT:1D4F                                         ; Get the PARMSX address to
SYSINIT:1D52                 cmp     cl, es:[bx]     ; [es:bx+_$P_PARMSX_Blk.MinP]
SYSINIT:1D52                                         ; check ORDINAL to see if the minimum
SYSINIT:1D55                 jnb     short _$P_Fin   ; positional found.
SYSINIT:1D57                 mov     ax, 2           ; $P_Op_Missing ; If no, set exit code to missing operand
SYSINIT:1D5A
SYSINIT:1D5A _$P_Fin:                                ; CODE XREF: SysParse+4D↑j
SYSINIT:1D5A                 pop     bx
SYSINIT:1D5B                 jmp     _$P_Single_Exit ; return to the caller
SYSINIT:1D5E ; ---------------------------------------------------------------------------
SYSINIT:1D5E
SYSINIT:1D5E _$P_Start:                              ; CODE XREF: SysParse+41↑j
SYSINIT:1D5E                 mov     cs:_$P_SaveSI_Cmpx, si ; save ptr to command line for later use
SYSINIT:1D5E                                         ; by complex quoted string or file spec.
SYSINIT:1D63                 push    bx
SYSINIT:1D64                 push    di
SYSINIT:1D65                 push    bp
SYSINIT:1D66                 lea     bx, _$P_STRING_BUF ; set buffer to copy from command string
SYSINIT:1D6A                 test    cs:_$P_Flags2, 20h ; _$P_Extra ; 3/9 extra delimiter encountered ?
SYSINIT:1D70                 jnz     short _$P_Pack_End ; 3/9 if yes, no need to copy
SYSINIT:1D72
SYSINIT:1D72 _$P_Pack_Loop:                          ; CODE XREF: SysParse+A3↓j
SYSINIT:1D72                                         ; SysParse+AA↓j
SYSINIT:1D72                 lodsb                   ; Pick a operand from buffer
SYSINIT:1D73                 call    _$P_Chk_Switch  ; Check switch character
SYSINIT:1D76                 jb      short _$P_Pack_End_BY_EOL ; if carry set found delimiter type slash,
SYSINIT:1D76                                         ; need backup si, else continue
SYSINIT:1D78                 call    _$P_Chk_EOL     ; Check EOL character
SYSINIT:1D7B                 jz      short _$P_Pack_End_BY_EOL ; need backup si
SYSINIT:1D7D                 call    _$P_Chk_Delim   ; Check delimiter
SYSINIT:1D80                 jnz     short _$P_PL01  ; If no, process next byte
SYSINIT:1D82                 test    cs:_$P_Flags2, 20h ; _$P_Extra ; 3/9 If yes and white spec,
SYSINIT:1D88                 jnz     short _$P_Pack_End_backup_si ; 3/9 then
SYSINIT:1D8A                 call    _$P_Skip_Delim  ; skip subsequent white space,too
SYSINIT:1D8D                 jmp     short _$P_Pack_End ; finish copy by placing NUL at end
SYSINIT:1D8F ; ---------------------------------------------------------------------------
SYSINIT:1D8F
SYSINIT:1D8F _$P_Pack_End_backup_si:                 ; CODE XREF: SysParse+80↑j
SYSINIT:1D8F                 test    cs:_$P_Flags2, 41h ; _$P_SW+_$P_equ
SYSINIT:1D95                 jz      short _$P_Pack_End
SYSINIT:1D97                 dec     si
SYSINIT:1D98                 jmp     short _$P_Pack_End
SYSINIT:1D9A ; ---------------------------------------------------------------------------
SYSINIT:1D9A
SYSINIT:1D9A _$P_PL01:                               ; CODE XREF: SysParse+78↑j
SYSINIT:1D9A                 mov     cs:[bx], al     ; move byte to STRING_BUF
SYSINIT:1D9D                 cmp     al, 3Dh ; '='   ; _$P_Keyword ; if it is equal character,
SYSINIT:1D9F                 jnz     short _$P_PL00  ; then
SYSINIT:1DA1                 or      cs:_$P_Flags2, 1 ; _$P_equ ; remember it in flag
SYSINIT:1DA7
SYSINIT:1DA7 _$P_PL00:                               ; CODE XREF: SysParse+97↑j
SYSINIT:1DA7                 inc     bx              ; ready to see next byte
SYSINIT:1DA8                 call    _$P_Chk_DBCS    ; was it 1st byte of DBCS ?
SYSINIT:1DAB                 jnb     short _$P_Pack_Loop ; if no, process to next byte
SYSINIT:1DAD                 lodsb
SYSINIT:1DAE                 mov     cs:[bx], al     ; if yes, store 2nd byte of DBCS
SYSINIT:1DB1                 inc     bx              ; update pointer
SYSINIT:1DB2                 jmp     short _$P_Pack_Loop ; process to next byte
SYSINIT:1DB4 ; ---------------------------------------------------------------------------
SYSINIT:1DB4
SYSINIT:1DB4 _$P_Pack_End_BY_EOL:                    ; CODE XREF: SysParse+6E↑j
SYSINIT:1DB4                                         ; SysParse+73↑j
SYSINIT:1DB4                 dec     si              ; backup si pointer
SYSINIT:1DB5
SYSINIT:1DB5 _$P_Pack_End:                           ; CODE XREF: SysParse+68↑j
SYSINIT:1DB5                                         ; SysParse+85↑j ...
SYSINIT:1DB5                 mov     cs:_$P_SI_Save, si ; save next pointer, SI
SYSINIT:1DBA                 mov     byte ptr cs:[bx], 0 ; _$P_NULL ; put NULL at the end
SYSINIT:1DBE                 mov     cs:_$P_Save_EOB, bx ; keep the address for later use of complex
SYSINIT:1DC3                 mov     bx, es:[di]     ; [es:di+_$P_PARMS_Blk.PARMSX_Address]
SYSINIT:1DC3                                         ; get PARMSX address
SYSINIT:1DC6                 lea     si, _$P_STRING_BUF
SYSINIT:1DCA                 cmp     byte ptr cs:[si], 2Fh ; '/' ; the operand begins w/ switch char ?
SYSINIT:1DCA                                         ; _$P_Switch
SYSINIT:1DCE                 jz      short _$P_SW_Manager ; if yes, process as switch
SYSINIT:1DD0                 cmp     byte ptr cs:[si], 22h ; '"' ; _$P_DQuote  ; is it a string?
SYSINIT:1DD4                 jz      short _$P_Positional_Manager ; if so, process as one!
SYSINIT:1DD6                 test    cs:_$P_Flags2, 1 ; $P_equ ; the operand includes equal
SYSINIT:1DDC                 jnz     short _$P_Key_Manager ; if yes, process as keyword
SYSINIT:1DDE
SYSINIT:1DDE _$P_Positional_Manager:                 ; CODE XREF: SysParse+CC↑j
SYSINIT:1DDE                 mov     al, es:[bx+1]   ; else process as positional
SYSINIT:1DDE                                         ; get maxp
SYSINIT:1DE2                 xor     ah, ah          ; ax = maxp
SYSINIT:1DE4                 cmp     cs:_$P_ORDINAL, ax ; too many positional ?
SYSINIT:1DE9                 jnb     short _$P_Too_Many_Error ; if yes, set exit code to too many
SYSINIT:1DEB                 mov     ax, cs:_$P_ORDINAL ; see what the current ordinal
SYSINIT:1DEF                 shl     ax, 1           ; ax = ax*2
SYSINIT:1DF1                 inc     bx
SYSINIT:1DF2                 inc     bx              ; add '2' to bx reg
SYSINIT:1DF2                                         ; now bx points to 1st CONTROL
SYSINIT:1DF3                 add     bx, ax          ; now bx points to specified CONTROL address
SYSINIT:1DF5                 mov     bx, es:[bx]     ; now bx points to specified CONTROL itself
SYSINIT:1DF8                 call    _$P_Chk_Pos_Control ; Do process for positional
SYSINIT:1DFB                 jmp     short _$P_Return_to_Caller ; and return to the caller
SYSINIT:1DFD ; ---------------------------------------------------------------------------
SYSINIT:1DFD
SYSINIT:1DFD _$P_Too_Many_Error:                     ; CODE XREF: SysParse+E1↑j
SYSINIT:1DFD                 mov     cs:_$P_RC, 1    ; set exit code
SYSINIT:1E04                 jmp     short _$P_Return_to_Caller ; and return to the caller
SYSINIT:1E04 SysParse        endp
SYSINIT:1E04
SYSINIT:1E06
SYSINIT:1E06 ; =============== S U B R O U T I N E =======================================
SYSINIT:1E06
SYSINIT:1E06
SYSINIT:1E06 get_maxp        proc near               ; CODE XREF: SysParse:_$P_SW_Manager↓p
SYSINIT:1E06                                         ; SysParse:_$P_Key_Manager↓p
SYSINIT:1E06                 mov     al, es:[bx+1]   ; [es:bx+_$P_PARMSX_Blk.MaxP] ; get maxp
SYSINIT:1E0A                 xor     ah, ah
SYSINIT:1E0C                 inc     ax
SYSINIT:1E0D                 shl     ax, 1
SYSINIT:1E0F                 add     bx, ax          ; now bx points to maxs
SYSINIT:1E11                 retn
SYSINIT:1E11 get_maxp        endp
SYSINIT:1E11
SYSINIT:1E12 ; ---------------------------------------------------------------------------
SYSINIT:1E12 ; START OF FUNCTION CHUNK FOR SysParse
SYSINIT:1E12
SYSINIT:1E12 _$P_SW_Manager:                         ; CODE XREF: SysParse+C6↑j
SYSINIT:1E12                 call    get_maxp
SYSINIT:1E15                 mov     cl, es:[bx]
SYSINIT:1E18                 xor     ch, ch          ; cx = maxs
SYSINIT:1E18                                         ; at least one switch ?
SYSINIT:1E1A                 jcxz    short _$P_SW_Not_Found ; no
SYSINIT:1E1C                 inc     bx              ; now bx points to 1st CONTROL address
SYSINIT:1E1D
SYSINIT:1E1D _$P_SW_Mgr_Loop:                        ; CODE XREF: SysParse+121↓j
SYSINIT:1E1D                 push    bx
SYSINIT:1E1E                 mov     bx, es:[bx]     ; bx points to Switch CONTROL itself
SYSINIT:1E21                 call    _$P_Chk_SW_Control
SYSINIT:1E24                 pop     bx
SYSINIT:1E25                 jnb     short _$P_Return_to_Caller ;
SYSINIT:1E25                                         ; if the CONTROL is for the switch, exit
SYSINIT:1E27                 inc     bx
SYSINIT:1E28                 inc     bx              ;    add '2' to bx reg
SYSINIT:1E28                                         ; else bx points to the next CONTROL
SYSINIT:1E29                 loop    _$P_SW_Mgr_Loop ; and loop
SYSINIT:1E2B
SYSINIT:1E2B _$P_SW_Not_Found:                       ; CODE XREF: SysParse+112↑j
SYSINIT:1E2B                 mov     cs:_$P_RC, 3    ; _$P_Not_In_SW
SYSINIT:1E2B                                         ; here no CONTROL for the switch has
SYSINIT:1E32                 jmp     short _$P_Return_to_Caller
SYSINIT:1E34 ; ---------------------------------------------------------------------------
SYSINIT:1E34
SYSINIT:1E34 _$P_Key_Manager:                        ; CODE XREF: SysParse+D4↑j
SYSINIT:1E34                 call    get_maxp
SYSINIT:1E37                 mov     al, es:[bx]
SYSINIT:1E3A                 xor     ah, ah          ; ax = maxs
SYSINIT:1E3C                 shl     ax, 1
SYSINIT:1E3E                 inc     ax              ; ax = ax*2+1
SYSINIT:1E3F                 add     bx, ax          ; now bx points to maxk
SYSINIT:1E41                 mov     cl, es:[bx]     ; cx = maxk
SYSINIT:1E44                 xor     ch, ch          ; at least one keyword ?
SYSINIT:1E46                 jcxz    short _$P_Key_Not_Found ; no
SYSINIT:1E48                 inc     bx              ; now bx points to 1st CONTROL
SYSINIT:1E49
SYSINIT:1E49 _$P_Key_Mgr_Loop:                       ; CODE XREF: SysParse+14D↓j
SYSINIT:1E49                 push    bx
SYSINIT:1E4A                 mov     bx, es:[bx]     ; bx points to keyword CONTROL itself
SYSINIT:1E4D                 call    _$P_Chk_Key_Control ; do process for keyword
SYSINIT:1E50                 pop     bx
SYSINIT:1E51                 jnb     short _$P_Return_to_Caller ;
SYSINIT:1E51                                         ; if the CONTROL is for the keyword, exit
SYSINIT:1E53                 inc     bx
SYSINIT:1E54                 inc     bx              ;    add '2' to bx reg
SYSINIT:1E54                                         ; else bx points to the next CONTROL
SYSINIT:1E55                 loop    _$P_Key_Mgr_Loop ; and loop
SYSINIT:1E57
SYSINIT:1E57 _$P_Key_Not_Found:                      ; CODE XREF: SysParse+13E↑j
SYSINIT:1E57                 mov     cs:_$P_RC, 4    ; _$P_Not_In_Key
SYSINIT:1E57                                         ; here no CONTROL for the keyword has
SYSINIT:1E5E
SYSINIT:1E5E _$P_Return_to_Caller:                   ; CODE XREF: SysParse+F3↑j
SYSINIT:1E5E                                         ; SysParse+FC↑j ...
SYSINIT:1E5E                 pop     bp
SYSINIT:1E5F                 pop     di
SYSINIT:1E60                 pop     bx
SYSINIT:1E61                 mov     cx, cs:_$P_ORDINAL ; return next ordinal
SYSINIT:1E66                 mov     ax, cs:_$P_RC   ; return exit code
SYSINIT:1E6A                 mov     si, cs:_$P_SI_Save ; return next operand pointer
SYSINIT:1E6F                 mov     dx, cs:_$P_DX   ; return result buffer address
SYSINIT:1E74                 mov     bl, cs:_$P_Terminator ; return delimiter code found
SYSINIT:1E79
SYSINIT:1E79 _$P_Single_Exit:                        ; CODE XREF: SysParse+53↑j
SYSINIT:1E79                 clc
SYSINIT:1E7A                 retn
SYSINIT:1E7A ; END OF FUNCTION CHUNK FOR SysParse
SYSINIT:1E7B
SYSINIT:1E7B ; =============== S U B R O U T I N E =======================================
SYSINIT:1E7B
SYSINIT:1E7B
SYSINIT:1E7B _$P_Chk_Pos_Control proc near           ; CODE XREF: SysParse+F0↑p
SYSINIT:1E7B                 push    ax
SYSINIT:1E7C                 mov     ax, es:[bx]     ; [es:bx+_$P_Control_Blk.Match_Flag]
SYSINIT:1E7F                 test    ax, 2           ; $P_Repeat ; repeat allowed ?
SYSINIT:1E82                 jnz     short _$P_CPC00 ; then do not increment ORDINAL
SYSINIT:1E84                 inc     cs:_$P_ORDINAL  ; update the ordinal
SYSINIT:1E89
SYSINIT:1E89 _$P_CPC00:                              ; CODE XREF: _$P_Chk_Pos_Control+7↑j
SYSINIT:1E89                 cmp     byte ptr cs:[si], 0 ; _$P_NULL ; no data ?
SYSINIT:1E8D                 jnz     short _$P_CPC01
SYSINIT:1E8F                 test    ax, 1           ; _$P_Optional ; yes, then is it optional ?
SYSINIT:1E92                 jnz     short _$P_CPC02
SYSINIT:1E94                 mov     cs:_$P_RC, 2    ; _$P_Op_Missing ; no, then error
SYSINIT:1E9B                 jmp     short _$P_CPC_Exit
SYSINIT:1E9D ; ---------------------------------------------------------------------------
SYSINIT:1E9D
SYSINIT:1E9D _$P_CPC02:                              ; CODE XREF: _$P_Chk_Pos_Control+17↑j
SYSINIT:1E9D                 push    ax
SYSINIT:1E9E                 mov     ax, 0FF03h      ; (_$P_No_Tag<<8)|_$P_String
SYSINIT:1E9E                                         ; if it is optional return NULL
SYSINIT:1E9E                                         ; no item tag indication
SYSINIT:1EA1                 call    _$P_Fill_Result
SYSINIT:1EA4                 pop     ax
SYSINIT:1EA5                 jmp     short _$P_CPC_Exit
SYSINIT:1EA7 ; ---------------------------------------------------------------------------
SYSINIT:1EA7
SYSINIT:1EA7 _$P_CPC01:                              ; CODE XREF: _$P_Chk_Pos_Control+12↑j
SYSINIT:1EA7                 call    _$P_Check_Match_Flags
SYSINIT:1EAA
SYSINIT:1EAA _$P_CPC_Exit:                           ; CODE XREF: _$P_Chk_Pos_Control+20↑j
SYSINIT:1EAA                                         ; _$P_Chk_Pos_Control+2A↑j
SYSINIT:1EAA                 pop     ax
SYSINIT:1EAB                 retn
SYSINIT:1EAB _$P_Chk_Pos_Control endp
SYSINIT:1EAB
SYSINIT:1EAC
SYSINIT:1EAC ; =============== S U B R O U T I N E =======================================
SYSINIT:1EAC
SYSINIT:1EAC
SYSINIT:1EAC _$P_Chk_Key_Control proc near           ; CODE XREF: SysParse+145↑p
SYSINIT:1EAC                 stc                     ; this logic works
SYSINIT:1EAC                                         ; when the KeySW is reset.
SYSINIT:1EAD                 retn
SYSINIT:1EAD _$P_Chk_Key_Control endp
SYSINIT:1EAD
SYSINIT:1EAE
SYSINIT:1EAE ; =============== S U B R O U T I N E =======================================
SYSINIT:1EAE
SYSINIT:1EAE
SYSINIT:1EAE _$P_Search_KEYorSW proc near            ; CODE XREF: _$P_Chk_SW_Control+6↓p
SYSINIT:1EAE                 push    bp
SYSINIT:1EAF                 push    cx
SYSINIT:1EB0                 mov     cl, es:[bx+8]   ; [es:bx+_$P_Control_Blk.nid] ; Get synonym count
SYSINIT:1EB4                 xor     ch, ch          ; and set it to cx
SYSINIT:1EB6                 jcxz    short _$P_KEYorSW_Not_Found ; No synonyms specified ?
SYSINIT:1EB6                                         ; then indicate not found by CY
SYSINIT:1EB8                 lea     bp, [bx+9]      ; [bx+_$P_Control_Blk.KEYorSW]
SYSINIT:1EBB
SYSINIT:1EBB _$P_KEYorSW_Loop:                       ; CODE XREF: _$P_Search_KEYorSW+15↓j
SYSINIT:1EBB                 call    _$P_String_Comp ; compare string in buffer w/ the synonym
SYSINIT:1EBE                 jnb     short _$P_KEYorSW_Found ; If match, set it to synonym pointer
SYSINIT:1EC0                 call    _$P_MoveBP_NUL  ; else, bp points to the next string
SYSINIT:1EC3                 loop    _$P_KEYorSW_Loop ; loop nid times
SYSINIT:1EC5
SYSINIT:1EC5 _$P_KEYorSW_Not_Found:                  ; CODE XREF: _$P_Search_KEYorSW+8↑j
SYSINIT:1EC5                 stc                     ; indicate not found in synonym list
SYSINIT:1EC6                 jmp     short _$P_KEYorSW_Exit ; and exit
SYSINIT:1EC8 ; ---------------------------------------------------------------------------
SYSINIT:1EC8
SYSINIT:1EC8 _$P_KEYorSW_Found:                      ; CODE XREF: _$P_Search_KEYorSW+10↑j
SYSINIT:1EC8                 mov     cs:_$P_Found_SYNONYM, bp ; set synonym pointer
SYSINIT:1ECD                 clc                     ; indicate found
SYSINIT:1ECE
SYSINIT:1ECE _$P_KEYorSW_Exit:                       ; CODE XREF: _$P_Search_KEYorSW+18↑j
SYSINIT:1ECE                 pop     cx
SYSINIT:1ECF                 pop     bp
SYSINIT:1ED0                 retn
SYSINIT:1ED0 _$P_Search_KEYorSW endp
SYSINIT:1ED0
SYSINIT:1ED1
SYSINIT:1ED1 ; =============== S U B R O U T I N E =======================================
SYSINIT:1ED1
SYSINIT:1ED1
SYSINIT:1ED1 _$P_MoveBP_NUL  proc near               ; CODE XREF: _$P_Search_KEYorSW+12↑p
SYSINIT:1ED1                                         ; _$P_MoveBP_NUL+8↓j
SYSINIT:1ED1                 cmp     byte ptr es:[bp+0], 0 ; _$P_NULL
SYSINIT:1ED1                                         ; Increment BP that points
SYSINIT:1ED6                 jz      short _$P_MBP_Exit ; to the synomym list
SYSINIT:1ED8                 inc     bp              ; until
SYSINIT:1ED9                 jmp     short _$P_MoveBP_NUL ; NULL encountered.
SYSINIT:1ED9                                         ; _$P_MBP_Loop
SYSINIT:1EDB ; ---------------------------------------------------------------------------
SYSINIT:1EDB
SYSINIT:1EDB _$P_MBP_Exit:                           ; CODE XREF: _$P_MoveBP_NUL+5↑j
SYSINIT:1EDB                 inc     bp              ; bp points to next to NULL
SYSINIT:1EDC                 retn
SYSINIT:1EDC _$P_MoveBP_NUL  endp
SYSINIT:1EDC
SYSINIT:1EDD
SYSINIT:1EDD ; =============== S U B R O U T I N E =======================================
SYSINIT:1EDD
SYSINIT:1EDD
SYSINIT:1EDD _$P_Chk_SW_Control proc near            ; CODE XREF: SysParse+119↑p
SYSINIT:1EDD                 or      cs:_$P_Flags2, 10h ; (Check if switch is supported)
SYSINIT:1EDD                                         ; _$P_SW_Cmp
SYSINIT:1EDD                                         ; Indicate switch for later string comparison
SYSINIT:1EE3                 call    _$P_Search_KEYorSW ; Search the switch in the CONTROL block
SYSINIT:1EE6                 jb      short _$P_Chk_SW_Err0 ; not found, then try next CONTROL
SYSINIT:1EE8                 and     cs:_$P_Flags2, 0EFh ; and byte [cs:_$P_Flags2],0FFh-_$P_SW_Cmp
SYSINIT:1EE8                                         ; reset the indicator previously set /switch
SYSINIT:1EEE                 push    ax
SYSINIT:1EEF                 mov     ax, cs:_$P_KEYorSW_Ptr
SYSINIT:1EF3                 sub     ax, si          ; [si] = KEY or SW
SYSINIT:1EF5                 add     cs:_$P_SaveSI_Cmpx, ax ; update for complex list
SYSINIT:1EFA                 pop     ax
SYSINIT:1EFB                 mov     si, cs:_$P_KEYorSW_Ptr ; set si at the end or colon
SYSINIT:1F00                 cmp     byte ptr cs:[si], 0 ; _$P_NULL ; any data after colon ?
SYSINIT:1F04                 jnz     short _$P_CSW00 ; if yes, process match flags
SYSINIT:1F06                 cmp     byte ptr cs:[si-1], ':' ; _$P_Colon
SYSINIT:1F06                                         ; if no, the switch terminated by colon ?
SYSINIT:1F0B                 jnz     short _$P_Chk_if_data_required ;
SYSINIT:1F0B                                         ; if yes,
SYSINIT:1F0D                 mov     cs:_$P_RC, 9    ; _$P_Syntax ; return syntax error
SYSINIT:1F14                 jmp     short _$P_Chk_SW_Exit
SYSINIT:1F16 ; ---------------------------------------------------------------------------
SYSINIT:1F16
SYSINIT:1F16 _$P_Chk_if_data_required:               ; CODE XREF: _$P_Chk_SW_Control+2E↑j
SYSINIT:1F16                 cmp     word ptr es:[bx], 0 ; [es:bx+_$P_Control_Blk.Match_Flag]
SYSINIT:1F16                                         ; should have data?
SYSINIT:1F16                                         ; zero match flag means switch followed by nothing is OK
SYSINIT:1F1A                 jz      short _$P_Chk_SW_Exit ; match flags not zero so
SYSINIT:1F1A                                         ; should have something if optional bit is not on
SYSINIT:1F1C                 test    word ptr es:[bx], 1 ; _$P_Optional ; see if no value is valid
SYSINIT:1F21                 jnz     short _$P_Chk_SW_Exit ; if so, then leave, else yell
SYSINIT:1F23                 mov     cs:_$P_RC, 2    ; _$P_Op_Missing
SYSINIT:1F23                                         ; return required operand missing
SYSINIT:1F2A                 jmp     short _$P_Chk_SW_Exit
SYSINIT:1F2C ; ---------------------------------------------------------------------------
SYSINIT:1F2C
SYSINIT:1F2C _$P_CSW00:                              ; CODE XREF: _$P_Chk_SW_Control+27↑j
SYSINIT:1F2C                 call    _$P_Check_Match_Flags ; process match flag
SYSINIT:1F2F                 clc                     ; indicate match
SYSINIT:1F30                 jmp     short _$P_Chk_SW_Single_Exit
SYSINIT:1F32 ; ---------------------------------------------------------------------------
SYSINIT:1F32
SYSINIT:1F32 _$P_Chk_SW_Err0:                        ; CODE XREF: _$P_Chk_SW_Control+9↑j
SYSINIT:1F32                 stc                     ; not found in switch synonym list
SYSINIT:1F33                 retn
SYSINIT:1F34 ; ---------------------------------------------------------------------------
SYSINIT:1F34
SYSINIT:1F34 _$P_Chk_SW_Exit:                        ; CODE XREF: _$P_Chk_SW_Control+37↑j
SYSINIT:1F34                                         ; _$P_Chk_SW_Control+3D↑j ...
SYSINIT:1F34                 push    ax
SYSINIT:1F35                 mov     ax, 0FF03h      ; (_$P_No_Tag<<8)|_$P_String
SYSINIT:1F38                 call    _$P_Fill_Result ; set result buffer
SYSINIT:1F3B                 pop     ax
SYSINIT:1F3C                 clc
SYSINIT:1F3D
SYSINIT:1F3D _$P_Chk_SW_Single_Exit:                 ; CODE XREF: _$P_Chk_SW_Control+53↑j
SYSINIT:1F3D                 retn
SYSINIT:1F3D _$P_Chk_SW_Control endp
SYSINIT:1F3D
SYSINIT:1F3E
SYSINIT:1F3E ; =============== S U B R O U T I N E =======================================
SYSINIT:1F3E
SYSINIT:1F3E
SYSINIT:1F3E _$P_Fill_Result proc near               ; CODE XREF: _$P_Chk_Pos_Control+26↑p
SYSINIT:1F3E                                         ; _$P_Chk_SW_Control+5B↑p ...
SYSINIT:1F3E                 push    di
SYSINIT:1F3F                 mov     di, es:[bx+4]   ; [es:bx+_$P_Control_Blk.Result_Buf]
SYSINIT:1F3F                                         ; di points to result buffer
SYSINIT:1F43                 mov     cs:_$P_DX, di   ; set returned result address
SYSINIT:1F48                 mov     es:[di], al     ; [es:di+_$P_Result_Blk.Type] ; store type
SYSINIT:1F4B                 mov     es:[di+1], ah   ; [es:di+_$P_Result_Blk.Item_Tag] ; store item tag
SYSINIT:1F4F                 push    ax
SYSINIT:1F50                 mov     ax, cs:_$P_Found_SYNONYM
SYSINIT:1F54                 mov     es:[di+2], ax   ; [es:di+_$P_Result_Blk.SYNONYM_Ptr]
SYSINIT:1F58                 pop     ax
SYSINIT:1F59
SYSINIT:1F59 _$P_RLT04:                              ;
SYSINIT:1F59                 cmp     al, 1           ; _$P_Number ; if number
SYSINIT:1F5B                 jnz     short _$P_RLT00 ;
SYSINIT:1F5B                                         ; then store 32 bit
SYSINIT:1F5D
SYSINIT:1F5D _$P_RLT02:                              ; CODE XREF: _$P_Fill_Result+35↓j
SYSINIT:1F5D                                         ; _$P_Fill_Result+39↓j
SYSINIT:1F5D                 mov     es:[di+4], dx   ; [es:di+_$P_Result_Blk.Picked_Val]
SYSINIT:1F61                 mov     es:[di+6], cx   ; [es:di+_$P_Result_Blk.Picked_Val+2]
SYSINIT:1F65                 jmp     short _$P_RLT_Exit
SYSINIT:1F67 ; ---------------------------------------------------------------------------
SYSINIT:1F67
SYSINIT:1F67 _$P_RLT00:                              ; CODE XREF: _$P_Fill_Result+1D↑j
SYSINIT:1F67                 cmp     al, 2           ; _$P_List_Idx ; if list index
SYSINIT:1F69                 jnz     short _$P_RLT01 ;
SYSINIT:1F69                                         ; then store list index
SYSINIT:1F6B                 mov     es:[di+4], dx   ; [es:di+_$P_Result_Blk.Picked_Val]
SYSINIT:1F6F                 jmp     short _$P_RLT_Exit
SYSINIT:1F71 ; ---------------------------------------------------------------------------
SYSINIT:1F71
SYSINIT:1F71 _$P_RLT01:                              ; CODE XREF: _$P_Fill_Result+2B↑j
SYSINIT:1F71                 cmp     al, 7           ; _$P_Date_F ; Date format ?
SYSINIT:1F73                 jz      short _$P_RLT02
SYSINIT:1F75                 cmp     al, 8           ; _$P_Time_F ; Time format ?
SYSINIT:1F77                 jz      short _$P_RLT02
SYSINIT:1F79                 cmp     al, 6           ; _$P_Drive ; drive format ?
SYSINIT:1F7B                 jnz     short _$P_RLT03
SYSINIT:1F7D                 mov     es:[di+4], dl   ; [es:di+_$P_Result_Blk.Picked_Val]
SYSINIT:1F7D                                         ; store drive number
SYSINIT:1F81                 jmp     short _$P_RLT_Exit
SYSINIT:1F83 ; ---------------------------------------------------------------------------
SYSINIT:1F83
SYSINIT:1F83 _$P_RLT03:                              ; CODE XREF: _$P_Fill_Result+3D↑j
SYSINIT:1F83                 cmp     al, 4           ; _$P_Complex ; complex format ?
SYSINIT:1F85                 jnz     short _$P_RLT05
SYSINIT:1F87                 mov     ax, cs:_$P_SaveSI_Cmpx ;
SYSINIT:1F87                                         ; then get pointer in command buffer
SYSINIT:1F8B                 inc     ax              ; skip left Parentheses
SYSINIT:1F8C                 mov     es:[di+4], ax   ; [es:di+_$P_Result_Blk.Picked_Val]
SYSINIT:1F8C                                         ; store offset
SYSINIT:1F90                 mov     word ptr es:[di+6], ds ; [es:di+_$P_Result_Blk.Picked_Val+2]
SYSINIT:1F90                                         ; store segment
SYSINIT:1F94                 jmp     short _$P_RLT_Exit
SYSINIT:1F96 ; ---------------------------------------------------------------------------
SYSINIT:1F96
SYSINIT:1F96 _$P_RLT05:                              ; CODE XREF: _$P_Fill_Result+47↑j
SYSINIT:1F96                 mov     es:[di+4], si   ; AL = 3, 5, or 9
SYSINIT:1F96                                         ; [es:di+_$P_Result_Blk.Picked_Val]
SYSINIT:1F96                                         ; store offset of STRING_BUF
SYSINIT:1F9A                 mov     word ptr es:[di+6], cs ; [es:di+_$P_Result_Blk.Picked_Val+2]
SYSINIT:1F9A                                         ; store segment of STRING_BUF
SYSINIT:1F9E                 push    ax
SYSINIT:1F9F                 test    byte ptr es:[bx+2], 1 ; [es:bx+_$P_Control_Blk.Function_Flag],
SYSINIT:1F9F                                         ; _$P_CAP_File
SYSINIT:1F9F                                         ; need CAPS by file table?
SYSINIT:1FA4                 jz      short _$P_RLT_CAP00
SYSINIT:1FA6                 mov     al, 4           ; _$P_DOSTBL_File ; use file upper case table
SYSINIT:1FA8                 jmp     short _$P_RLT_CAP02
SYSINIT:1FAA ; ---------------------------------------------------------------------------
SYSINIT:1FAA
SYSINIT:1FAA _$P_RLT_CAP00:                          ; CODE XREF: _$P_Fill_Result+66↑j
SYSINIT:1FAA                 test    byte ptr es:[bx+2], 2 ; [es:bx+_$P_Control_Blk.Function_Flag],
SYSINIT:1FAA                                         ; _$P_CAP_Char
SYSINIT:1FAA                                         ; need CAPS by char table
SYSINIT:1FAF                 jz      short _$P_RLT_CAP01
SYSINIT:1FB1                 mov     al, 2           ; _$P_DOSTBL_Char
SYSINIT:1FB1                                         ; use character upper case table
SYSINIT:1FB3
SYSINIT:1FB3 _$P_RLT_CAP02:                          ; CODE XREF: _$P_Fill_Result+6A↑j
SYSINIT:1FB3                 call    _$P_Do_CAPS_String ; process CAPS along the table
SYSINIT:1FB6
SYSINIT:1FB6 _$P_RLT_CAP01:                          ; CODE XREF: _$P_Fill_Result+71↑j
SYSINIT:1FB6                 pop     ax
SYSINIT:1FB7                 test    byte ptr es:[bx+2], 10h ; [es:bx+_$P_Control_Blk.Function_Flag],
SYSINIT:1FB7                                         ; _$P_Rm_Colon
SYSINIT:1FB7                                         ; removing colon at end ?
SYSINIT:1FBC                 jz      short _$P_RLT_Exit
SYSINIT:1FBE                 call    _$P_Remove_Colon ; then process it.
SYSINIT:1FC1
SYSINIT:1FC1 _$P_RLT_Exit:                           ; CODE XREF: _$P_Fill_Result+27↑j
SYSINIT:1FC1                                         ; _$P_Fill_Result+31↑j ...
SYSINIT:1FC1                 pop     di
SYSINIT:1FC2                 retn
SYSINIT:1FC2 _$P_Fill_Result endp
SYSINIT:1FC2
SYSINIT:1FC3
SYSINIT:1FC3 ; =============== S U B R O U T I N E =======================================
SYSINIT:1FC3
SYSINIT:1FC3
SYSINIT:1FC3 _$P_Check_Match_Flags proc near         ; CODE XREF: _$P_Chk_Pos_Control:_$P_CPC01↑p
SYSINIT:1FC3                                         ; _$P_Chk_SW_Control:_$P_CSW00↑p
SYSINIT:1FC3                 mov     cs:_$P_err_flag, 0 ; _$P_NULL ; clear filespec error flag.
SYSINIT:1FC9                 push    ax
SYSINIT:1FCA                 mov     ax, es:[bx]     ; [es:bx+_$P_Control_Blk.Match_Flag]
SYSINIT:1FCA                                         ; load match flag (16bit) to ax
SYSINIT:1FCD                 or      ax, ax          ; test ax for zero
SYSINIT:1FCF                 jnz     short _$P_Mat
SYSINIT:1FD1                 push    ax
SYSINIT:1FD2                 push    bx
SYSINIT:1FD3                 push    dx
SYSINIT:1FD4                 push    di
SYSINIT:1FD5                 mov     cs:_$P_RC, 9    ; _$P_Syntax
SYSINIT:1FDC                 mov     ax, 0FF03h
SYSINIT:1FDF                 call    _$P_Fill_Result
SYSINIT:1FE2                 pop     di
SYSINIT:1FE3                 pop     dx
SYSINIT:1FE4                 pop     bx
SYSINIT:1FE5                 pop     ax
SYSINIT:1FE6                 jmp     short _$P_Bridge
SYSINIT:1FE8 ; ---------------------------------------------------------------------------
SYSINIT:1FE8
SYSINIT:1FE8 _$P_Mat:                                ; CODE XREF: _$P_Check_Match_Flags+C↑j
SYSINIT:1FE8                 jmp     short _$P_Match03
SYSINIT:1FEA ; ---------------------------------------------------------------------------
SYSINIT:1FEA
SYSINIT:1FEA _$P_Bridge:                             ; CODE XREF: _$P_Check_Match_Flags+23↑j
SYSINIT:1FEA                 jmp     short _$P_Match_Exit
SYSINIT:1FEC ; ---------------------------------------------------------------------------
SYSINIT:1FEC                 nop                     ; 90h
SYSINIT:1FED
SYSINIT:1FED _$P_Match03:                            ; CODE XREF: _$P_Check_Match_Flags:_$P_Mat↑j
SYSINIT:1FED                 test    ax, 8000h       ; _$P_Num_Val ; Numeric value
SYSINIT:1FF0                 jz      short _$P_Match04
SYSINIT:1FF2                 mov     cs:_$P_RC, 0    ; _$P_No_Error ; assume no error
SYSINIT:1FF9                 call    _$P_Value       ; do process
SYSINIT:1FFC                 cmp     cs:_$P_RC, 9    ; _$P_Syntax ; if error, examine the next type
SYSINIT:2002                 jnz     short _$P_Match_Exit
SYSINIT:2004
SYSINIT:2004 _$P_Match04:                            ; CODE XREF: _$P_Check_Match_Flags+2D↑j
SYSINIT:2004                 test    ax, 4000h       ; _$P_SNum_Val ; Signed numeric value
SYSINIT:2007                 jz      short _$P_Match05
SYSINIT:2009                 mov     cs:_$P_RC, 0    ; _$P_No_Error ; assume no error
SYSINIT:2010                 call    _$P_SValue      ; do process
SYSINIT:2013                 cmp     cs:_$P_RC, 9    ; _$P_Syntax ; if error, examine the next type
SYSINIT:2019                 jnz     short _$P_Match_Exit
SYSINIT:201B
SYSINIT:201B _$P_Match05:                            ; CODE XREF: _$P_Check_Match_Flags+44↑j
SYSINIT:201B                 test    ax, 100h        ; _$P_Drv_Only ; Drive only
SYSINIT:201E                 jz      short _$P_Match06
SYSINIT:2020                 mov     cs:_$P_RC, 0    ; _$P_No_Error ; assume no error
SYSINIT:2027                 call    _$P_File_Format ; 1st, call file format
SYSINIT:202A                 call    _$P_Drive_Format ; check drive format, next
SYSINIT:202D                 cmp     cs:_$P_RC, 9    ; _$P_Syntax ; if error, examine the next type
SYSINIT:2033                 jnz     short _$P_Match_Exit
SYSINIT:2035
SYSINIT:2035 _$P_Match06:                            ; CODE XREF: _$P_Check_Match_Flags+5B↑j
SYSINIT:2035                 test    ax, 200h        ; _$P_File_Spc ; File spec
SYSINIT:2038                 jz      short _$P_Match07
SYSINIT:203A                 mov     cs:_$P_RC, 0    ; _$P_No_Error ; assume no error
SYSINIT:2041                 call    _$P_File_Format ; do process
SYSINIT:2044                 cmp     cs:_$P_RC, 9    ; _$P_Syntax ; if error, examine the next type
SYSINIT:204A                 jnz     short _$P_Match_Exit
SYSINIT:204C
SYSINIT:204C _$P_Match07:                            ; CODE XREF: _$P_Check_Match_Flags+75↑j
SYSINIT:204C                 test    ax, 2000h       ; _$P_Simple_S ; Simple string
SYSINIT:204F                 jz      short _$P_Match_Exit
SYSINIT:2051                 mov     cs:_$P_RC, 0    ; _$P_No_Error ; assume no error
SYSINIT:2058                 call    _$P_Simple_String ; do process
SYSINIT:205B
SYSINIT:205B _$P_Match_Exit:                         ; CODE XREF: _$P_Check_Match_Flags:_$P_Bridge↑j
SYSINIT:205B                                         ; _$P_Check_Match_Flags+3F↑j ...
SYSINIT:205B                 cmp     cs:_$P_err_flag, 1 ; _$P_error_filespec ; bad filespec ?
SYSINIT:2061                 jnz     short _$P_Match2_Exit ; no, continue
SYSINIT:2063                 cmp     cs:_$P_RC, 0    ; _$P_No_Error ; check for other errors ?
SYSINIT:2069                 jnz     short _$P_Match2_Exit ; no, continue
SYSINIT:206B                 mov     cs:_$P_RC, 9    ; _$P_Syntax ; set error flag
SYSINIT:2072
SYSINIT:2072 _$P_Match2_Exit:                        ; CODE XREF: _$P_Check_Match_Flags+9E↑j
SYSINIT:2072                                         ; _$P_Check_Match_Flags+A6↑j
SYSINIT:2072                 pop     ax
SYSINIT:2073                 retn
SYSINIT:2073 _$P_Check_Match_Flags endp
SYSINIT:2073
SYSINIT:2074
SYSINIT:2074 ; =============== S U B R O U T I N E =======================================
SYSINIT:2074
SYSINIT:2074
SYSINIT:2074 _$P_Remove_Colon proc near              ; CODE XREF: _$P_Fill_Result+80↑p
SYSINIT:2074                 push    ax
SYSINIT:2075                 push    si
SYSINIT:2076
SYSINIT:2076 _$P_RCOL_Loop:                          ; CODE XREF: _$P_Remove_Colon+21↓j
SYSINIT:2076                 mov     al, cs:[si]     ; get character
SYSINIT:2079                 or      al, al          ; end of string ?
SYSINIT:207B                 jz      short _$P_RCOL_Exit ; if yes, just exit
SYSINIT:207D                 cmp     al, ':'         ; _$P_Colon ; is it colon ?
SYSINIT:207F                 jnz     short _$P_RCOL00
SYSINIT:2081                 cmp     byte ptr cs:[si+1], 0 ; _$P_NULL
SYSINIT:2081                                         ; if so, next is NULL ?
SYSINIT:2086                 jnz     short _$P_RCOL00 ; no, then next char
SYSINIT:2088                 mov     byte ptr cs:[si], 0 ; _$P_NULL ; yes, remove colon
SYSINIT:208C                 jmp     short _$P_RCOL_Exit ; and exit.
SYSINIT:208E ; ---------------------------------------------------------------------------
SYSINIT:208E
SYSINIT:208E _$P_RCOL00:                             ; CODE XREF: _$P_Remove_Colon+B↑j
SYSINIT:208E                                         ; _$P_Remove_Colon+12↑j
SYSINIT:208E                 call    _$P_Chk_DBCS    ; if not colon, then check if
SYSINIT:208E                                         ; DBCS leading byte.
SYSINIT:2091                 jnb     short _$P_RCOL01
SYSINIT:2093                 inc     si              ; if yes, skip trailing byte
SYSINIT:2094
SYSINIT:2094 _$P_RCOL01:                             ; CODE XREF: _$P_Remove_Colon+1D↑j
SYSINIT:2094                 inc     si              ; si points to next byte
SYSINIT:2095                 jmp     short _$P_RCOL_Loop ; loop until NULL encountered
SYSINIT:2097 ; ---------------------------------------------------------------------------
SYSINIT:2097
SYSINIT:2097 _$P_RCOL_Exit:                          ; CODE XREF: _$P_Remove_Colon+7↑j
SYSINIT:2097                                         ; _$P_Remove_Colon+18↑j
SYSINIT:2097                 pop     si
SYSINIT:2098                 pop     ax
SYSINIT:2099                 retn
SYSINIT:2099 _$P_Remove_Colon endp
SYSINIT:2099
SYSINIT:209A
SYSINIT:209A ; =============== S U B R O U T I N E =======================================
SYSINIT:209A
SYSINIT:209A
SYSINIT:209A _$P_Do_CAPS_String proc near            ; CODE XREF: _$P_Fill_Result:_$P_RLT_CAP02↑p
SYSINIT:209A                 push    si
SYSINIT:209B                 push    dx
SYSINIT:209C                 mov     dl, al          ; save info id
SYSINIT:209E
SYSINIT:209E _$P_DCS_Loop:                           ; CODE XREF: _$P_Do_CAPS_String+1A↓j
SYSINIT:209E                 mov     al, cs:[si]     ; load charater and
SYSINIT:20A1                 call    _$P_Chk_DBCS    ; check if DBCS leading byte
SYSINIT:20A4                 jb      short _$P_DCS00 ; if yes, do not need CAPS
SYSINIT:20A6                 or      al, al          ; end of string ?
SYSINIT:20A8                 jz      short _$P_DCS_Exit ; then exit.
SYSINIT:20AA                 call    _$P_Do_CAPS_Char ; Here a SBCS char need to be CAPS
SYSINIT:20AD                 mov     cs:[si], al     ; stored upper case char to buffer
SYSINIT:20B0                 jmp     short _$P_DCS01 ; process next
SYSINIT:20B2 ; ---------------------------------------------------------------------------
SYSINIT:20B2
SYSINIT:20B2 _$P_DCS00:                              ; CODE XREF: _$P_Do_CAPS_String+A↑j
SYSINIT:20B2                 inc     si              ; skip DBCS leading and trailing byte
SYSINIT:20B3
SYSINIT:20B3 _$P_DCS01:                              ; CODE XREF: _$P_Do_CAPS_String+16↑j
SYSINIT:20B3                 inc     si              ; si points to next byte
SYSINIT:20B4                 jmp     short _$P_DCS_Loop ; loop until NULL encountered
SYSINIT:20B6 ; ---------------------------------------------------------------------------
SYSINIT:20B6
SYSINIT:20B6 _$P_DCS_Exit:                           ; CODE XREF: _$P_Do_CAPS_String+E↑j
SYSINIT:20B6                 pop     dx
SYSINIT:20B7                 pop     si
SYSINIT:20B8                 retn
SYSINIT:20B8 _$P_Do_CAPS_String endp
SYSINIT:20B8
SYSINIT:20B9
SYSINIT:20B9 ; =============== S U B R O U T I N E =======================================
SYSINIT:20B9
SYSINIT:20B9
SYSINIT:20B9 _$P_Do_CAPS_Char proc near              ; CODE XREF: _$P_Do_CAPS_String+10↑p
SYSINIT:20B9                                         ; _$P_String_Comp+E↓p
SYSINIT:20B9                 cmp     al, 80h         ; _$P_ASCII80 ; need upper case table ?
SYSINIT:20BB                 jnb     short _$P_DCC_Go ; no
SYSINIT:20BD                 cmp     al, 'a'         ; check if  "a" <= AL <= "z"
SYSINIT:20BF                 jb      short _$P_CAPS_Ret
SYSINIT:20C1                 cmp     al, 'z'
SYSINIT:20C3                 ja      short _$P_CAPS_Ret
SYSINIT:20C5                 and     al, 0DFh        ; _$P_Make_Upper ; make CAPS
SYSINIT:20C7                 retn
SYSINIT:20C8 ; ---------------------------------------------------------------------------
SYSINIT:20C8
SYSINIT:20C8 _$P_DCC_Go:                             ; CODE XREF: _$P_Do_CAPS_Char+2↑j
SYSINIT:20C8                 push    bx
SYSINIT:20C9                 push    es
SYSINIT:20CA                 push    di
SYSINIT:20CB                 lea     di, _$P_Char_CAP_Ptr ; or use char CAPS table ?
SYSINIT:20CF                 cmp     cs:[di], dl     ; already got table address ?
SYSINIT:20D2                 jz      short _$P_DCC01 ; no
SYSINIT:20D4                 push    ax
SYSINIT:20D5                 push    cx
SYSINIT:20D6                 push    dx
SYSINIT:20D7                 push    cs
SYSINIT:20D8                 pop     es
SYSINIT:20D9                 assume es:SYSINIT
SYSINIT:20D9                 xchg    ax, dx
SYSINIT:20DA                 mov     ah, 65h         ; _$P_DOS_Get_TBL
SYSINIT:20DC                 mov     bx, 0FFFFh      ; _$P_DOSTBL_Def = -1
SYSINIT:20DF                 mov     cx, 5           ; _$P_DOSTBL_BL
SYSINIT:20E2                 mov     dx, bx          ; _$P_DOSTBL_Def
SYSINIT:20E4                 int     21h             ; DOS - 4.x internal
SYSINIT:20E4                                         ; COUNTRY-DEPENDENT FILENAME CAPITALIZATION
SYSINIT:20E4                                         ; AL = function -
SYSINIT:20E4                                         ;
SYSINIT:20E4                                         ; DI already set to point to buffer
SYSINIT:20E6                 pop     dx
SYSINIT:20E7                 pop     cx
SYSINIT:20E8                 pop     ax
SYSINIT:20E9
SYSINIT:20E9 _$P_DCC01:                              ; CODE XREF: _$P_Do_CAPS_Char+19↑j
SYSINIT:20E9                 les     bx, cs:[di+1]   ; bx = [cs:di+_$P_DOS_TBL.Off] ; [cs:di+1]
SYSINIT:20E9                                         ; es = [cs:di+_$P_DOS_TBL.Seg] ; [cs:di+3]
SYSINIT:20ED                 assume es:nothing
SYSINIT:20ED                 inc     bx
SYSINIT:20EE                 inc     bx              ; add 2 to bx reg
SYSINIT:20EF                 sub     al, 80h         ; _$P_ASCII80 ; make char to index
SYSINIT:20F1                 xlat    byte ptr es:[bx] ; perform case map
SYSINIT:20F3                 pop     di
SYSINIT:20F4                 pop     es
SYSINIT:20F5                 pop     bx
SYSINIT:20F6
SYSINIT:20F6 _$P_CAPS_Ret:                           ; CODE XREF: _$P_Do_CAPS_Char+6↑j
SYSINIT:20F6                                         ; _$P_Do_CAPS_Char+A↑j
SYSINIT:20F6                 retn
SYSINIT:20F6 _$P_Do_CAPS_Char endp
SYSINIT:20F6
SYSINIT:20F7
SYSINIT:20F7 ; =============== S U B R O U T I N E =======================================
SYSINIT:20F7
SYSINIT:20F7
SYSINIT:20F7 _$P_SValue      proc near               ; CODE XREF: _$P_Check_Match_Flags+4D↑p
SYSINIT:20F7                 push    ax
SYSINIT:20F8                 or      cs:_$P_Flags2, 80h ; _$P_Signed ; indicate a signed numeric
SYSINIT:20FE                 and     cs:_$P_Flags2, 0FDh ; 0FFh-_$P_Neg ; assume positive value
SYSINIT:20FE                                         ; and byte [cs:$_Flags2],~_$P_Neg ; ~2
SYSINIT:2104                 mov     al, cs:[si]     ; get sign
SYSINIT:2107                 cmp     al, '+'         ; _$P_Plus
SYSINIT:2109                 jz      short _$P_SVal00
SYSINIT:210B                 cmp     al, '-'         ; _$P_Minus
SYSINIT:210D                 jnz     short _$P_Sval01
SYSINIT:210F                 or      cs:_$P_Flags2, 2 ; _$P_Neg
SYSINIT:210F                                         ; set this is negative value
SYSINIT:2115
SYSINIT:2115 _$P_SVal00:                             ; CODE XREF: _$P_SValue+12↑j
SYSINIT:2115                 inc     si              ; skip sign char
SYSINIT:2116
SYSINIT:2116 _$P_Sval01:                             ; CODE XREF: _$P_SValue+16↑j
SYSINIT:2116                 call    _$P_Value       ; and process value
SYSINIT:2119                 pop     ax
SYSINIT:211A                 retn
SYSINIT:211A _$P_SValue      endp
SYSINIT:211A
SYSINIT:211B
SYSINIT:211B ; =============== S U B R O U T I N E =======================================
SYSINIT:211B
SYSINIT:211B
SYSINIT:211B _$P_Value       proc near               ; CODE XREF: _$P_Check_Match_Flags+36↑p
SYSINIT:211B                                         ; _$P_SValue:_$P_Sval01↑p
SYSINIT:211B                 push    ax
SYSINIT:211C                 push    cx
SYSINIT:211D                 push    dx
SYSINIT:211E                 push    si
SYSINIT:211F                 xor     cx, cx          ; cx = higher 16 bits
SYSINIT:2121                 xor     dx, dx          ; dx = lower 16 bits
SYSINIT:2123                 push    bx
SYSINIT:2124
SYSINIT:2124 _$P_Value_Loop:                         ; CODE XREF: _$P_Value+36↓j
SYSINIT:2124                 mov     al, cs:[si]     ; get character
SYSINIT:2127                 or      al, al          ; end of line ?
SYSINIT:2129                 jz      short _$P_Value00
SYSINIT:212B                 call    _$P_0099        ; make asc(0..9) to bin(0..9)
SYSINIT:212E                 jb      short _$P_Value_Err0
SYSINIT:2130                 xor     ah, ah
SYSINIT:2132                 mov     bp, ax          ; save binary number
SYSINIT:2134                 call    _$P_Value_2x_OVF ; multiply cx:dx by 2 and then check overflow
SYSINIT:2137                 mov     bx, dx          ; ax:bx = 2*(cx:dx)
SYSINIT:2139                 mov     ax, cx
SYSINIT:213B                 call    _$P_Value_2x_OVF ; multiply cx:dx by 2 and then check overflow
SYSINIT:213E                 call    _$P_Value_2x_OVF ; multiply cx:dx by 2 and then check overflow
SYSINIT:2141                 add     dx, bx          ; 8*(cx:dx)+2*(cx:dx) = 10*(cx:dx)
SYSINIT:2143                 adc     cx, ax
SYSINIT:2145                 call    _$P_Value_Chk_Add_OVF
SYSINIT:2148                 add     dx, bp          ; Add the current one degree decimal
SYSINIT:2148                                         ; if carry, add 1 to high 16bit
SYSINIT:214A                 adc     cx, 0
SYSINIT:214D                 call    _$P_Value_Chk_Add_OVF ; Overflow occurred ?
SYSINIT:214D                                         ; then error, exit (without return here)
SYSINIT:2150                 inc     si              ; update pointer
SYSINIT:2151                 jmp     short _$P_Value_Loop
SYSINIT:2153 ; ---------------------------------------------------------------------------
SYSINIT:2153
SYSINIT:2153 _$P_Value_2x_OVF:                       ; CODE XREF: _$P_Value+19↑p
SYSINIT:2153                                         ; _$P_Value+20↑p ...
SYSINIT:2153                 shl     dx, 1           ; to have 2*x
SYSINIT:2155                 rcl     cx, 1           ; shift left w/ carry
SYSINIT:2157
SYSINIT:2157 _$P_Value_Chk_Add_OVF:                  ; CODE XREF: _$P_Value+2A↑p
SYSINIT:2157                                         ; _$P_Value+32↑p
SYSINIT:2157                 call    _$P_Check_OVF   ; check overflow (for the last shift or add)
SYSINIT:215A                 jb      short _$P_Value_OVF
SYSINIT:215C                 retn
SYSINIT:215D ; ---------------------------------------------------------------------------
SYSINIT:215D
SYSINIT:215D _$P_Value_OVF:                          ; CODE XREF: _$P_Value+3F↑j
SYSINIT:215D                 inc     sp              ; skip "call" return address to the caller
SYSINIT:215E                 inc     sp
SYSINIT:215F
SYSINIT:215F _$P_Value_Err0:                         ; CODE XREF: _$P_Value+13↑j
SYSINIT:215F                 pop     bx
SYSINIT:2160                 jmp     _$P_Value_Err   ; bridge
SYSINIT:2163 ; ---------------------------------------------------------------------------
SYSINIT:2163
SYSINIT:2163 _$P_Value00:                            ; CODE XREF: _$P_Value+E↑j
SYSINIT:2163                 pop     bx              ; restore control pointer
SYSINIT:2163                                         ; here cx,dx = 32bit value
SYSINIT:2164                 test    cs:_$P_Flags2, 2 ; _$P_Neg ; was it negative ?
SYSINIT:216A                 jz      short _$P_Value01
SYSINIT:216C                 not     cx              ; | Make 2's complement
SYSINIT:216E                 not     dx              ; |
SYSINIT:2170                 add     dx, 1           ; |
SYSINIT:2173                 adc     cx, 0           ; |
SYSINIT:2176
SYSINIT:2176 _$P_Value01:                            ; CODE XREF: _$P_Value+4F↑j
SYSINIT:2176                 mov     si, es:[bx+6]   ; [es:bx+_$P_Control_Blk.Value_List]
SYSINIT:2176                                         ; si points to value list
SYSINIT:217A                 mov     al, es:[si]     ; get nval
SYSINIT:217D                 cmp     al, 0           ; _$P_nval_None ; no value list ?
SYSINIT:217F                 jnz     short _$P_Value02
SYSINIT:2181                 mov     ax, 0FF01h      ; (_$P_No_Tag<<8)|_$P_Number
SYSINIT:2181                                         ; No ITEM_TAG set
SYSINIT:2184                 jmp     short _$P_Value_Exit
SYSINIT:2186 ; ---------------------------------------------------------------------------
SYSINIT:2186                 nop
SYSINIT:2187
SYSINIT:2187 _$P_Value02:                            ; CODE XREF: _$P_Value+64↑j
SYSINIT:2187                 inc     si
SYSINIT:2188                 mov     al, es:[si]     ; al = number of range
SYSINIT:218B                 cmp     al, 0           ; _$P_No_nrng
SYSINIT:218D                 jz      short _$P_Value_Err ; _$P_Value03
SYSINIT:218F                 inc     si              ; si points to 1st item_tag
SYSINIT:2190
SYSINIT:2190 _$P_Val02_Loop:                         ; CODE XREF: _$P_Value+BE↓j
SYSINIT:2190                 test    cs:_$P_Flags2, 80h ; _$P_Signed
SYSINIT:2196                 jnz     short _$P_Val02_Sign
SYSINIT:2198                 cmp     cx, es:[si+3]   ; [es:si+_$P_Val_List.Val_XH]
SYSINIT:2198                                         ; comp cx with XH
SYSINIT:219C                 jb      short _$P_Val02_Next
SYSINIT:219E                 ja      short _$P_Val_In
SYSINIT:21A0                 cmp     dx, es:[si+1]   ; [es:si+_$P_Val_List.Val_XL]
SYSINIT:21A0                                         ; comp dx with XL
SYSINIT:21A4                 jb      short _$P_Val02_Next
SYSINIT:21A6
SYSINIT:21A6 _$P_Val_In:                             ; CODE XREF: _$P_Value+83↑j
SYSINIT:21A6                 cmp     cx, es:[si+7]   ; [es:si+_$P_Val_List.Val_YH]
SYSINIT:21A6                                         ; comp cx with YH
SYSINIT:21AA                 ja      short _$P_Val02_Next
SYSINIT:21AC                 jb      short _$P_Val_Found
SYSINIT:21AE                 cmp     dx, es:[si+5]   ; [es:si+_$P_Val_List.Val_YL]
SYSINIT:21AE                                         ; comp dx with YL
SYSINIT:21B2                 ja      short _$P_Val02_Next
SYSINIT:21B4                 jmp     short _$P_Val_Found
SYSINIT:21B6 ; ---------------------------------------------------------------------------
SYSINIT:21B6
SYSINIT:21B6 _$P_Val02_Sign:                         ; CODE XREF: _$P_Value+7B↑j
SYSINIT:21B6                 cmp     cx, es:[si+3]   ; [es:si+_$P_Val_List.Val_XH]
SYSINIT:21B6                                         ; comp cx with XH
SYSINIT:21BA                 jl      short _$P_Val02_Next
SYSINIT:21BC                 jg      short _$P_SVal_In
SYSINIT:21BE                 cmp     dx, es:[si+1]   ; [es:si+_$P_Val_List.Val_XL]
SYSINIT:21BE                                         ; comp dx with XL
SYSINIT:21C2                 jl      short _$P_Val02_Next
SYSINIT:21C4
SYSINIT:21C4 _$P_SVal_In:                            ; CODE XREF: _$P_Value+A1↑j
SYSINIT:21C4                 cmp     cx, es:[si+7]   ; [es:si+_$P_Val_List.Val_YH]
SYSINIT:21C4                                         ; comp cx with YH
SYSINIT:21C8                 jg      short _$P_Val02_Next
SYSINIT:21CA                 jl      short _$P_Val_Found
SYSINIT:21CC                 cmp     dx, es:[si+5]   ; [es:si+_$P_Val_List.Val_YL]
SYSINIT:21CC                                         ; comp dx with YL
SYSINIT:21D0                 jg      short _$P_Val02_Next
SYSINIT:21D2                 jmp     short _$P_Val_Found
SYSINIT:21D4 ; ---------------------------------------------------------------------------
SYSINIT:21D4
SYSINIT:21D4 _$P_Val02_Next:                         ; CODE XREF: _$P_Value+81↑j
SYSINIT:21D4                                         ; _$P_Value+89↑j ...
SYSINIT:21D4                 add     si, 9           ; _$P_Len_Range
SYSINIT:21D7                 dec     al              ; loop nrng times in AL
SYSINIT:21D9                 jnz     short _$P_Val02_Loop
SYSINIT:21DB                 mov     cs:_$P_RC, 6    ; _$P_Out_Of_Range
SYSINIT:21E2                 mov     ax, 0FF01h      ; (_$P_No_Tag<<8)|_$P_Number
SYSINIT:21E5                 jmp     short _$P_Value_Exit
SYSINIT:21E7 ; ---------------------------------------------------------------------------
SYSINIT:21E7
SYSINIT:21E7 _$P_Val_Found:                          ; CODE XREF: _$P_Value+91↑j
SYSINIT:21E7                                         ; _$P_Value+99↑j ...
SYSINIT:21E7                 mov     al, 1           ; _$P_Number
SYSINIT:21E9                 mov     ah, es:[si]     ; found ITEM_TAG set
SYSINIT:21EC                 jmp     short _$P_Value_Exit
SYSINIT:21EE ; ---------------------------------------------------------------------------
SYSINIT:21EE
SYSINIT:21EE _$P_Value_Err:                          ; CODE XREF: _$P_Value+45↑j
SYSINIT:21EE                                         ; _$P_Value+72↑j
SYSINIT:21EE                 mov     cs:_$P_RC, 9    ; _$P_Syntax
SYSINIT:21F5                 mov     ax, 0FF03h      ; (_$P_No_Tag<<8)|_$P_String
SYSINIT:21F5                                         ; No ITEM_TAG set
SYSINIT:21F8
SYSINIT:21F8 _$P_Value_Exit:                         ; CODE XREF: _$P_Value+69↑j
SYSINIT:21F8                                         ; _$P_Value+CA↑j ...
SYSINIT:21F8                 call    _$P_Fill_Result
SYSINIT:21FB                 pop     si
SYSINIT:21FC                 pop     dx
SYSINIT:21FD                 pop     cx
SYSINIT:21FE                 pop     ax
SYSINIT:21FF                 retn
SYSINIT:21FF _$P_Value       endp
SYSINIT:21FF
SYSINIT:2200
SYSINIT:2200 ; =============== S U B R O U T I N E =======================================
SYSINIT:2200
SYSINIT:2200
SYSINIT:2200 _$P_Check_OVF   proc near               ; CODE XREF: _$P_Value:_$P_Value_Chk_Add_OVF↑p
SYSINIT:2200                 pushf
SYSINIT:2201                 test    cs:_$P_Flags2, 2 ; _$P_Neg ; is it negative value ?
SYSINIT:2207                 jnz     short _$P_COVF
SYSINIT:2209                 popf                    ; if no, check overflow by the CY bit
SYSINIT:220A                 retn
SYSINIT:220B ; ---------------------------------------------------------------------------
SYSINIT:220B
SYSINIT:220B _$P_COVF:                               ; CODE XREF: _$P_Check_OVF+7↑j
SYSINIT:220B                 popf                    ; else, check overflow by the OF
SYSINIT:220C                 jo      short _$P_COVF00
SYSINIT:220E                 clc                     ; indicate it with CY bit
SYSINIT:220E                                         ; CY=0 means no overflow
SYSINIT:220F                 retn
SYSINIT:2210 ; ---------------------------------------------------------------------------
SYSINIT:2210
SYSINIT:2210 _$P_COVF00:                             ; CODE XREF: _$P_Check_OVF+C↑j
SYSINIT:2210                 stc                     ; and CY=1 means overflow
SYSINIT:2211                 retn
SYSINIT:2211 _$P_Check_OVF   endp
SYSINIT:2211
SYSINIT:2212
SYSINIT:2212 ; =============== S U B R O U T I N E =======================================
SYSINIT:2212
SYSINIT:2212
SYSINIT:2212 _$P_0099        proc near               ; CODE XREF: _$P_Value+10↑p
SYSINIT:2212                 cmp     al, '0'         ; must be 0 =< al =< 9
SYSINIT:2214                 jb      short _$P_0099Err
SYSINIT:2216                 cmp     al, '9'
SYSINIT:2218                 ja      short _$P_0099Err
SYSINIT:221A                 sub     al, '0'         ; sub al,30h ; make char -> bin
SYSINIT:221C                 clc                     ; indicate no error
SYSINIT:221C                                         ; (clc is not required here, cf=0)
SYSINIT:221D                 retn
SYSINIT:221E ; ---------------------------------------------------------------------------
SYSINIT:221E
SYSINIT:221E _$P_0099Err:                            ; CODE XREF: _$P_0099+2↑j
SYSINIT:221E                                         ; _$P_0099+6↑j
SYSINIT:221E                 stc                     ; indicate error (cf=1)
SYSINIT:221F                 retn
SYSINIT:221F _$P_0099        endp
SYSINIT:221F
SYSINIT:2220
SYSINIT:2220 ; =============== S U B R O U T I N E =======================================
SYSINIT:2220
SYSINIT:2220
SYSINIT:2220 _$P_Simple_String proc near             ; CODE XREF: _$P_Check_Match_Flags+95↑p
SYSINIT:2220                 push    ax
SYSINIT:2221                 push    bx
SYSINIT:2222                 push    dx
SYSINIT:2223                 push    di
SYSINIT:2224                 mov     di, es:[bx+6]   ; [es:bx+_$P_Control_Blk.Value_List]
SYSINIT:2224                                         ; di points to value list
SYSINIT:2228                 mov     al, es:[di]     ; get nval
SYSINIT:222B                 or      al, al          ; no value list ?
SYSINIT:222D                 jnz     short _$P_Sim00
SYSINIT:222F                 mov     ah, 0FFh        ; _$P_No_Tag ; then, No ITEM_TAG set
SYSINIT:2231                 jmp     short _$P_Sim_Exit ; and set result buffer
SYSINIT:2233 ; ---------------------------------------------------------------------------
SYSINIT:2233
SYSINIT:2233 _$P_Sim00:                              ; CODE XREF: _$P_Simple_String+D↑j
SYSINIT:2233                 cmp     al, 3           ; Check if keyword or value list id #3 is supported
SYSINIT:2233                                         ; _$P_nval_String ; String choice list provided ?
SYSINIT:2235                 jnz     short _$P_Sim01 ; if no, syntax error
SYSINIT:2237                 inc     di
SYSINIT:2238                 mov     al, es:[di]     ; al = nrng
SYSINIT:223B                 mov     ah, 9           ; _$P_Len_Range
SYSINIT:223D                 mul     ah              ; Skip nrng field
SYSINIT:223F                 inc     ax              ; ax = (nrng*9)+1
SYSINIT:2240                 add     di, ax          ; di points to nnval
SYSINIT:2242                 mov     al, es:[di]     ; get nnval
SYSINIT:2245                 mov     ah, 5           ; _$P_Len_Value
SYSINIT:2247                 mul     ah              ; skip nnval field
SYSINIT:2249                 inc     ax              ; ax = (nnval*5)+1
SYSINIT:224A                 add     di, ax          ; di points to nstrval
SYSINIT:224C                 mov     al, es:[di]     ; get nstrval c
SYSINIT:224F                 inc     di
SYSINIT:2250                 inc     di              ; add '2' to di reg
SYSINIT:2250                                         ; di points to 1st string in list
SYSINIT:2251
SYSINIT:2251 _$P_Sim_Loop:                           ; CODE XREF: _$P_Simple_String+3E↓j
SYSINIT:2251                 mov     bp, es:[di]     ; get string pointer
SYSINIT:2254                 call    _$P_String_Comp ; compare it with operand
SYSINIT:2257                 jnb     short _$P_Sim_Found ; found on list
SYSINIT:2259                 add     di, 3           ; _$P_Len_String ; if no, point to next choice
SYSINIT:225C                 dec     al              ; loop nstval times in AL
SYSINIT:225E                 jnz     short _$P_Sim_Loop
SYSINIT:2260                 mov     cs:_$P_RC, 8    ; / Not found ; _$P_Not_In_Str
SYSINIT:2267                 mov     ah, 0FFh        ; _$P_No_Tag  ; No ITEM_TAG set
SYSINIT:2269                 jmp     short _$P_Sim_Exit
SYSINIT:226B ; ---------------------------------------------------------------------------
SYSINIT:226B
SYSINIT:226B _$P_Sim_Found:                          ; CODE XREF: _$P_Simple_String+37↑j
SYSINIT:226B                 mov     ah, es:[di-1]   ; set item_tag
SYSINIT:226F                 mov     al, 2           ; _$P_List_Idx
SYSINIT:2271                 mov     dx, es:[di]     ; get address of STRING
SYSINIT:2274                 jmp     short _$P_Sim_Exit0
SYSINIT:2276 ; ---------------------------------------------------------------------------
SYSINIT:2276
SYSINIT:2276 _$P_Sim01:                              ; CODE XREF: _$P_Simple_String+15↑j
SYSINIT:2276                 mov     cs:_$P_RC, 9    ; _$P_Syntax
SYSINIT:227D                 mov     ah, 0FFh        ; _$P_No_Tag
SYSINIT:227F
SYSINIT:227F _$P_Sim_Exit:                           ; CODE XREF: _$P_Simple_String+11↑j
SYSINIT:227F                                         ; _$P_Simple_String+49↑j
SYSINIT:227F                 mov     al, 3           ; _$P_String ; Set type
SYSINIT:2281
SYSINIT:2281 _$P_Sim_Exit0:                          ; CODE XREF: _$P_Simple_String+54↑j
SYSINIT:2281                 call    _$P_Fill_Result
SYSINIT:2284                 pop     di
SYSINIT:2285                 pop     dx
SYSINIT:2286                 pop     bx
SYSINIT:2287                 pop     ax
SYSINIT:2288                 retn
SYSINIT:2288 _$P_Simple_String endp
SYSINIT:2288
SYSINIT:2289
SYSINIT:2289 ; =============== S U B R O U T I N E =======================================
SYSINIT:2289
SYSINIT:2289
SYSINIT:2289 _$P_String_Comp proc near               ; CODE XREF: _$P_Search_KEYorSW:_$P_KEYorSW_Loop↑p
SYSINIT:2289                                         ; _$P_Simple_String+34↑p
SYSINIT:2289                 push    ax
SYSINIT:228A                 push    bp
SYSINIT:228B                 push    dx
SYSINIT:228C                 push    si
SYSINIT:228D                 mov     dl, 2           ; _$P_DOSTBL_Char ; use character case map table
SYSINIT:228F
SYSINIT:228F _$P_SCOM_Loop:                          ; CODE XREF: _$P_String_Comp:_$P_SCOM01↓j
SYSINIT:228F                 mov     al, cs:[si]     ; get command character
SYSINIT:2292                 call    _$P_Chk_DBCS    ; DBCS ?
SYSINIT:2295                 jb      short _$P_SCOM00 ; yes
SYSINIT:2297                 call    _$P_Do_CAPS_Char ; else, upper case map before comparison
SYSINIT:229A                 test    cs:_$P_Flags2, 8 ; Check if keyword or switch is supported
SYSINIT:229A                                         ; _$P_Key_Cmp ; keyword search ?
SYSINIT:22A0                 jz      short _$P_SCOM04
SYSINIT:22A2                 cmp     al, '='         ; _$P_Keyword  ; "=" is delimiter
SYSINIT:22A4                 jnz     short _$P_SCOM03 ; IF "=" on command line AND
SYSINIT:22A4                                         ; (bp+1=> char after the "=" in synonym list)
SYSINIT:22A6                 cmp     byte ptr es:[bp+1], 0 ; _$P_NULL ; at end of keyword string
SYSINIT:22A6                                         ;                  in the control block THEN
SYSINIT:22AB                 jnz     short _$P_SCOM_Differ
SYSINIT:22AD                 jmp     short _$P_SCOM05 ; keyword found in synonym list
SYSINIT:22AF ; ---------------------------------------------------------------------------
SYSINIT:22AF
SYSINIT:22AF _$P_SCOM04:                             ; CODE XREF: _$P_String_Comp+17↑j
SYSINIT:22AF                 test    cs:_$P_Flags2, 10h ; _$P_SW_Cmp ; switch search ?
SYSINIT:22B5                 jz      short _$P_SCOM03
SYSINIT:22B7                 cmp     al, ':'         ; _$P_Colon ; ":" is delimiter,
SYSINIT:22B7                                         ;            at end of switch on command line
SYSINIT:22B9                 jnz     short _$P_SCOM03
SYSINIT:22BB                 cmp     byte ptr es:[bp+0], 0 ; _$P_NULL
SYSINIT:22BB                                         ; IF at end of switch on command AND
SYSINIT:22C0                 jnz     short _$P_SCOM_Differ ;
SYSINIT:22C0                                         ; at end of switch string
SYSINIT:22C0                                         ; in the control block THEN
SYSINIT:22C2
SYSINIT:22C2 _$P_SCOM05:                             ; CODE XREF: _$P_String_Comp+24↑j
SYSINIT:22C2                 inc     si              ; found a match
SYSINIT:22C2                                         ; si points to just after "=" or ":"
SYSINIT:22C3                 jmp     short _$P_SCOM_Same ; exit
SYSINIT:22C5 ; ---------------------------------------------------------------------------
SYSINIT:22C5
SYSINIT:22C5 _$P_SCOM03:                             ; CODE XREF: _$P_String_Comp+1B↑j
SYSINIT:22C5                                         ; _$P_String_Comp+2C↑j ...
SYSINIT:22C5                 cmp     al, es:[bp+0]   ; compare operand w/ a synonym
SYSINIT:22C9                 jnz     short _$P_SCOM_Differ0 ; if different,
SYSINIT:22C9                                         ; check ignore colon option
SYSINIT:22CB                 or      al, al          ; end of line ?
SYSINIT:22CD                 jz      short _$P_SCOM_Same ; if so, exit
SYSINIT:22CF                 inc     si              ; update operand pointer
SYSINIT:22D0                 inc     bp              ; and synonym pointer
SYSINIT:22D1                 jmp     short _$P_SCOM01 ; loop until NULL or "=" or ":"
SYSINIT:22D1                                         ;  found in case
SYSINIT:22D3 ; ---------------------------------------------------------------------------
SYSINIT:22D3
SYSINIT:22D3 _$P_SCOM00:                             ; CODE XREF: _$P_String_Comp+C↑j
SYSINIT:22D3                 cmp     al, es:[bp+0]   ; Here al is DBCS leading byte
SYSINIT:22D3                                         ; compare leading byte
SYSINIT:22D7                 jnz     short _$P_SCOM_Differ ; if not match, say different
SYSINIT:22D9                 inc     si              ; else, load next byte
SYSINIT:22DA                 mov     al, cs:[si]
SYSINIT:22DD                 inc     bp
SYSINIT:22DE                 cmp     al, es:[bp+0]   ; and compare 2nd byte
SYSINIT:22E2                 jnz     short _$P_SCOM_Differ ; if not match, say different, too
SYSINIT:22E4                 inc     si              ; else update operand pointer
SYSINIT:22E5                 inc     bp              ; and synonym pointer
SYSINIT:22E6
SYSINIT:22E6 _$P_SCOM01:                             ; CODE XREF: _$P_String_Comp+48↑j
SYSINIT:22E6                 jmp     short _$P_SCOM_Loop ; loop until NULL or "="
SYSINIT:22E6                                         ; or "/" found in case
SYSINIT:22E8 ; ---------------------------------------------------------------------------
SYSINIT:22E8
SYSINIT:22E8 _$P_SCOM_Differ0:                       ; CODE XREF: _$P_String_Comp+40↑j
SYSINIT:22E8                 test    cs:_$P_Flags2, 40h ; _$P_SW
SYSINIT:22EE                 jz      short _$P_not_applicable
SYSINIT:22F0                 test    word ptr es:[bx+2], 20h ; [es:bx+_$P_Control_Blk.Function_Flag],
SYSINIT:22F0                                         ; _$P_colon_is_not_necessary
SYSINIT:22F6                 jz      short _$P_not_applicable
SYSINIT:22F8                 cmp     byte ptr es:[bp+0], 0 ; _$P_NULL
SYSINIT:22FD                 jz      short _$P_SCOM_Same
SYSINIT:22FF
SYSINIT:22FF _$P_not_applicable:                     ; CODE XREF: _$P_String_Comp+65↑j
SYSINIT:22FF                                         ; _$P_String_Comp+6D↑j
SYSINIT:22FF                 test    word ptr es:[bx], 10h ; [es:bx+_$P_Control_Blk.Match_Flag],
SYSINIT:22FF                                         ; _$P_Ig_Colon
SYSINIT:22FF                                         ; ignore colon option specified ?
SYSINIT:2304                 jz      short _$P_SCOM_Differ
SYSINIT:2306                 cmp     al, ':'         ; _$P_Colon ; End up with ":" and subseqently
SYSINIT:2308                 jnz     short _$P_SCOM02
SYSINIT:230A                 cmp     byte ptr es:[bp+0], 0 ; _$P_NULL ; null ?
SYSINIT:230F                 jnz     short _$P_SCOM_Differ ; if no, say different
SYSINIT:2311                 jmp     short _$P_SCOM_Same ; else, say same
SYSINIT:2313 ; ---------------------------------------------------------------------------
SYSINIT:2313
SYSINIT:2313 _$P_SCOM02:                             ; CODE XREF: _$P_String_Comp+7F↑j
SYSINIT:2313                 cmp     al, 0           ; _$P_NULL ; end up NULL and :
SYSINIT:2315                 jnz     short _$P_SCOM_Differ
SYSINIT:2317                 cmp     byte ptr es:[bp+0], ':' ; _$P_Colon ; if no, say different
SYSINIT:231C                 jz      short _$P_SCOM_Same ; else, say same
SYSINIT:231E
SYSINIT:231E _$P_SCOM_Differ:                        ; CODE XREF: _$P_String_Comp+22↑j
SYSINIT:231E                                         ; _$P_String_Comp+37↑j ...
SYSINIT:231E                 stc                     ; indicate not found
SYSINIT:231F                 jmp     short _$P_SCOM_Exit
SYSINIT:2321 ; ---------------------------------------------------------------------------
SYSINIT:2321
SYSINIT:2321 _$P_SCOM_Same:                          ; CODE XREF: _$P_String_Comp+3A↑j
SYSINIT:2321                                         ; _$P_String_Comp+44↑j ...
SYSINIT:2321                 mov     cs:_$P_KEYorSW_Ptr, si ; for later use by keyword or switch
SYSINIT:2326                 clc                     ; indicate found
SYSINIT:2326                                         ; (cf is already 0 here.. clc is not needed)
SYSINIT:2327
SYSINIT:2327 _$P_SCOM_Exit:                          ; CODE XREF: _$P_String_Comp+96↑j
SYSINIT:2327                 pop     si
SYSINIT:2328                 pop     dx
SYSINIT:2329                 pop     bp
SYSINIT:232A                 pop     ax
SYSINIT:232B                 retn
SYSINIT:232B _$P_String_Comp endp
SYSINIT:232B
SYSINIT:232C
SYSINIT:232C ; =============== S U B R O U T I N E =======================================
SYSINIT:232C
SYSINIT:232C
SYSINIT:232C _$P_File_Format proc near               ; CODE XREF: _$P_Check_Match_Flags+64↑p
SYSINIT:232C                                         ; _$P_Check_Match_Flags+7E↑p
SYSINIT:232C                 push    ax
SYSINIT:232D                 push    di
SYSINIT:232E                 push    si
SYSINIT:232F                 mov     di, cs:_$P_SaveSI_Cmpx ; get user buffer address
SYSINIT:2334
SYSINIT:2334 _$P_FileF_Loop0:                        ; / skip special characters
SYSINIT:2334                 mov     al, cs:[si]     ; load character
SYSINIT:2337                 or      al, al          ; end of line ?
SYSINIT:2339                 jz      short _$P_FileF_Err ; if yes, error exit
SYSINIT:233B                 call    _$P_FileSp_Chk  ; else, check if file special character
SYSINIT:233E                 jnz     short _$P_FileF03
SYSINIT:2340                 mov     cs:_$P_err_flag, 1 ; $P_error_filespec
SYSINIT:2340                                         ; set error flag - bad char.
SYSINIT:2346                 pop     si
SYSINIT:2347                 mov     byte ptr cs:[si], 0 ; _$P_NULL
SYSINIT:234B                 pop     di
SYSINIT:234C                 jmp     short _$P_FileF02
SYSINIT:234E ; ---------------------------------------------------------------------------
SYSINIT:234E
SYSINIT:234E _$P_FileF_Err:                          ; CODE XREF: _$P_File_Format+D↑j
SYSINIT:234E                 pop     si
SYSINIT:234F                 mov     byte ptr cs:[si], 0 ; _$P_NULL
SYSINIT:2353                 pop     di
SYSINIT:2354                 test    word ptr es:[bx], 1 ; [es:bx+_$P_Control_Blk.Match_Flag],
SYSINIT:2354                                         ; _$P_Optional
SYSINIT:2359                 jnz     short _$P_FileF02
SYSINIT:235B                 mov     cs:_$P_RC, 2    ; _$P_Op_Missing
SYSINIT:2362                 jmp     short _$P_FileF02
SYSINIT:2364 ; ---------------------------------------------------------------------------
SYSINIT:2364
SYSINIT:2364 _$P_FileF03:                            ; CODE XREF: _$P_File_Format+12↑j
SYSINIT:2364                 pop     ax              ; discard si on top of stack
SYSINIT:2365                 push    si              ; save new si
SYSINIT:2366
SYSINIT:2366 _$P_FileF_Loop1:                        ; CODE XREF: _$P_File_Format+4F↓j
SYSINIT:2366                 mov     al, cs:[si]     ; load character (not special char)
SYSINIT:2369                 or      al, al          ; end of line ?
SYSINIT:236B                 jz      short _$P_FileF_RLT
SYSINIT:236D                 call    _$P_FileSp_Chk  ; File special character ?
SYSINIT:2370                 jz      short _$P_FileF00
SYSINIT:2372                 call    _$P_Chk_DBCS    ; no, then DBCS ?
SYSINIT:2375                 jnb     short _$P_FileF01
SYSINIT:2377                 inc     di              ; if yes, skip next byte
SYSINIT:2378                 inc     si
SYSINIT:2379
SYSINIT:2379 _$P_FileF01:                            ; CODE XREF: _$P_File_Format+49↑j
SYSINIT:2379                 inc     di
SYSINIT:237A                 inc     si
SYSINIT:237B                 jmp     short _$P_FileF_Loop1
SYSINIT:237D ; ---------------------------------------------------------------------------
SYSINIT:237D
SYSINIT:237D _$P_FileF00:                            ; CODE XREF: _$P_File_Format+44↑j
SYSINIT:237D                 mov     cs:_$P_Terminator, al
SYSINIT:2381                 mov     byte ptr cs:[si], 0 ; _$P_NULL ; update end of string
SYSINIT:2385                 inc     di
SYSINIT:2386                 mov     cs:_$P_SI_Save, di ; update next pointer in command line
SYSINIT:238B
SYSINIT:238B _$P_FileF_RLT:                          ; CODE XREF: _$P_File_Format+3F↑j
SYSINIT:238B                 pop     si
SYSINIT:238C                 pop     di
SYSINIT:238D
SYSINIT:238D _$P_FileF02:                            ; CODE XREF: _$P_File_Format+20↑j
SYSINIT:238D                                         ; _$P_File_Format+2D↑j ...
SYSINIT:238D                 pop     ax
SYSINIT:238E                 test    ax, 200h        ; _$P_File_Spc
SYSINIT:2391                 jz      short _$P_Drv_Only_Exit
SYSINIT:2393                 push    ax
SYSINIT:2394                 mov     ax, 0FF05h      ; (_$P_No_Tag<<8)|_$P_File_Spec
SYSINIT:2394                                         ; set result buffer to file spec
SYSINIT:2397                 call    _$P_Fill_Result
SYSINIT:239A                 pop     ax
SYSINIT:239B
SYSINIT:239B _$P_Drv_Only_Exit:                      ; CODE XREF: _$P_File_Format+65↑j
SYSINIT:239B                 retn
SYSINIT:239B _$P_File_Format endp
SYSINIT:239B
SYSINIT:239C
SYSINIT:239C ; =============== S U B R O U T I N E =======================================
SYSINIT:239C
SYSINIT:239C
SYSINIT:239C _$P_FileSp_Chk  proc near               ; CODE XREF: _$P_File_Format+F↑p
SYSINIT:239C                                         ; _$P_File_Format+41↑p
SYSINIT:239C                 push    bx
SYSINIT:239D                 push    cx
SYSINIT:239E                 lea     bx, _$P_FileSp_Char ; "[]|<>+=;\""
SYSINIT:23A2                 mov     cx, 9           ; _$P_FileSp_Len
SYSINIT:23A2                                         ; load length of special character table
SYSINIT:23A2                                         ; at SYSINIT:1CFEh (for PCDOS 7.1 IBMBIO.COM)
SYSINIT:23A5
SYSINIT:23A5 _$P_FileSp_Loop:                        ; CODE XREF: _$P_FileSp_Chk+F↓j
SYSINIT:23A5                 cmp     al, cs:[bx]     ; is it one of special character ?
SYSINIT:23A8                 jz      short _$P_FileSp_Exit
SYSINIT:23AA                 inc     bx
SYSINIT:23AB                 loop    _$P_FileSp_Loop
SYSINIT:23AD                 inc     cx              ; reset ZF
SYSINIT:23AE
SYSINIT:23AE _$P_FileSp_Exit:                        ; CODE XREF: _$P_FileSp_Chk+C↑j
SYSINIT:23AE                 pop     cx
SYSINIT:23AF                 pop     bx
SYSINIT:23B0                 retn
SYSINIT:23B0 _$P_FileSp_Chk  endp
SYSINIT:23B0
SYSINIT:23B1
SYSINIT:23B1 ; =============== S U B R O U T I N E =======================================
SYSINIT:23B1
SYSINIT:23B1
SYSINIT:23B1 _$P_Drive_Format proc near              ; CODE XREF: _$P_Check_Match_Flags+67↑p
SYSINIT:23B1                 push    ax
SYSINIT:23B2                 push    dx
SYSINIT:23B3                 mov     al, cs:[si]
SYSINIT:23B6                 or      al, al          ; if null string
SYSINIT:23B8                 jz      short _$P_Drv_Exit ; do nothing
SYSINIT:23BA                 call    _$P_Chk_DBCS    ; is it leading byte ?
SYSINIT:23BD                 jb      short _$P_Drv_Err ; yes, error
SYSINIT:23BF                 cmp     word ptr cs:[si+1], 3Ah ; ':' ; _$P_Colon
SYSINIT:23BF                                         ; "d", ":", 0 ?
SYSINIT:23C4                 jz      short _$P_DrvF00
SYSINIT:23C6                 test    word ptr es:[bx], 10h ; [es:bx+_$P_Control_Blk.Match_Flag],
SYSINIT:23C6                                         ; _$P_Ig_Colon
SYSINIT:23C6                                         ; colon can be ignored?
SYSINIT:23CB                 jz      short _$P_Drv_Err
SYSINIT:23CD                 cmp     byte ptr cs:[si+1], 0 ; _$P_NULL ; "d", 0 ?
SYSINIT:23D2                 jnz     short _$P_Drv_Err
SYSINIT:23D4
SYSINIT:23D4 _$P_DrvF00:                             ; CODE XREF: _$P_Drive_Format+13↑j
SYSINIT:23D4                 or      al, 20h         ; _$P_Make_Lower ; lower case
SYSINIT:23D6                 cmp     al, 61h ; 'a'   ; drive letter must
SYSINIT:23D8                 jb      short _$P_Drv_Err ; in range of
SYSINIT:23DA                 cmp     al, 7Ah ; 'z'   ; "a"-"z"
SYSINIT:23DC                 ja      short _$P_Drv_Err ; if no, error
SYSINIT:23DE                 sub     al, 60h         ; "a"-1 ; make text drive to binary drive
SYSINIT:23E0                 mov     dl, al
SYSINIT:23E2                 mov     ah, 0FFh        ; _$P_No_Tag
SYSINIT:23E4                 mov     al, 6           ; _$P_Drive
SYSINIT:23E4                                         ; mov ax,(_$P_No_Tag<<8)|_$P_Drive ; 0FF06h
SYSINIT:23E6                 call    _$P_Fill_Result ; set result buffer to drive
SYSINIT:23E9                 jmp     short _$P_Drv_Exit
SYSINIT:23EB ; ---------------------------------------------------------------------------
SYSINIT:23EB
SYSINIT:23EB _$P_Drv_Err:                            ; CODE XREF: _$P_Drive_Format+C↑j
SYSINIT:23EB                                         ; _$P_Drive_Format+1A↑j ...
SYSINIT:23EB                 mov     cs:_$P_RC, 9    ; _$P_Syntax
SYSINIT:23F2
SYSINIT:23F2 _$P_Drv_Exit:                           ; CODE XREF: _$P_Drive_Format+7↑j
SYSINIT:23F2                                         ; _$P_Drive_Format+38↑j
SYSINIT:23F2                 pop     dx
SYSINIT:23F3                 pop     ax
SYSINIT:23F4                 retn
SYSINIT:23F4 _$P_Drive_Format endp
SYSINIT:23F4
SYSINIT:23F5
SYSINIT:23F5 ; =============== S U B R O U T I N E =======================================
SYSINIT:23F5
SYSINIT:23F5
SYSINIT:23F5 _$P_Skip_Delim  proc near               ; CODE XREF: SysParse+3E↑p
SYSINIT:23F5                                         ; SysParse+82↑p ...
SYSINIT:23F5                 lodsb
SYSINIT:23F6                 call    _$P_Chk_EOL     ; is it EOL character ?
SYSINIT:23F9                 jz      short _$P_Skip_Delim_CY ; if yes, exit w/ CY on
SYSINIT:23FB                 call    _$P_Chk_Delim   ; is it one of delimiters ?
SYSINIT:23FE                 jnz     short _$P_Skip_Delim_NCY ; if no, exit w/ CY off
SYSINIT:2400                 test    cs:_$P_Flags2, 20h ; _$P_Extra ; extra delim or comma found
SYSINIT:2406                 jz      short _$P_Skip_Delim ; _$P_Skip_Delim_Loop
SYSINIT:2406                                         ; if no, loop
SYSINIT:2408                 test    cs:_$P_Flags2, 41h ; _$P_SW+_$P_equ ; /x , or xxx=zzz ,
SYSINIT:240E                 jz      short _$P_Exit_At_Extra ; no switch, no keyword
SYSINIT:2410                 dec     si
SYSINIT:2411                 jmp     short _$P_Exit_At_Extra
SYSINIT:2413 ; ---------------------------------------------------------------------------
SYSINIT:2413
SYSINIT:2413 _$P_Skip_Delim_CY:                      ; CODE XREF: _$P_Skip_Delim+4↑j
SYSINIT:2413                 stc                     ; indicate EOL
SYSINIT:2414                 jmp     short _$P_Skip_Delim_Exit
SYSINIT:2416 ; ---------------------------------------------------------------------------
SYSINIT:2416
SYSINIT:2416 _$P_Skip_Delim_NCY:                     ; CODE XREF: _$P_Skip_Delim+9↑j
SYSINIT:2416                 clc                     ; indicate non delim
SYSINIT:2417
SYSINIT:2417 _$P_Skip_Delim_Exit:                    ; CODE XREF: _$P_Skip_Delim+1F↑j
SYSINIT:2417                 dec     si              ; in this case, need backup index pointer
SYSINIT:2418                 retn
SYSINIT:2419 ; ---------------------------------------------------------------------------
SYSINIT:2419
SYSINIT:2419 _$P_Exit_At_Extra:                      ; CODE XREF: _$P_Skip_Delim+19↑j
SYSINIT:2419                                         ; _$P_Skip_Delim+1C↑j
SYSINIT:2419                 clc                     ; indicate extra delim
SYSINIT:241A                 retn
SYSINIT:241A _$P_Skip_Delim  endp
SYSINIT:241A
SYSINIT:241B
SYSINIT:241B ; =============== S U B R O U T I N E =======================================
SYSINIT:241B
SYSINIT:241B
SYSINIT:241B _$P_Chk_EOL     proc near               ; CODE XREF: SysParse+70↑p
SYSINIT:241B                                         ; _$P_Skip_Delim+1↑p
SYSINIT:241B                 push    bx
SYSINIT:241C                 push    cx
SYSINIT:241D                 cmp     al, 0Dh         ; _$P_CR ; Carriage return ?
SYSINIT:241F                 jz      short _$P_Chk_EOL_Exit
SYSINIT:2421                 cmp     al, 0           ; _$P_NULL ; zero ?
SYSINIT:2423                 jz      short _$P_Chk_EOL_Exit
SYSINIT:2425                 cmp     al, 0Ah         ; _$P_LF ; Line feed ?
SYSINIT:2427                 jz      short _$P_Chk_EOL_Exit
SYSINIT:2429                 cmp     byte ptr es:[di+2], 2 ; [es:di+_$P_PARMS_Blk.Num_Extra],
SYSINIT:2429                                         ; _$P_I_Have_EOL
SYSINIT:242E                 jb      short _$P_Chk_EOL_Exit
SYSINIT:2430                 xor     bx, bx
SYSINIT:2432                 mov     bl, es:[di+3]   ; [es:di+_$P_PARMS_Blk.Len_Extra_Delim]
SYSINIT:2432                                         ; get length of delimiter list
SYSINIT:2436                 add     bx, 4           ; _$P_Len_PARMS ; skip it
SYSINIT:2439                 cmp     byte ptr es:[bx+di], 0 ; _$P_I_Use_Default
SYSINIT:2439                                         ; No extra EOL character ?
SYSINIT:243D                 jz      short _$P_Chk_EOL_NZ
SYSINIT:243F                 xor     cx, cx          ; Get number of extra character
SYSINIT:2441                 mov     cl, es:[bx+di]
SYSINIT:2444
SYSINIT:2444 _$P_Chk_EOL_Loop:                       ; CODE XREF: _$P_Chk_EOL+2F↓j
SYSINIT:2444                 inc     bx
SYSINIT:2445                 cmp     al, es:[bx+di]  ; Check extra EOL character
SYSINIT:2448                 jz      short _$P_Chk_EOL_Exit
SYSINIT:244A                 loop    _$P_Chk_EOL_Loop
SYSINIT:244C
SYSINIT:244C _$P_Chk_EOL_NZ:                         ; CODE XREF: _$P_Chk_EOL+22↑j
SYSINIT:244C                 cmp     al, 0Dh         ; _$P_CR ; reset ZF
SYSINIT:244E
SYSINIT:244E _$P_Chk_EOL_Exit:                       ; CODE XREF: _$P_Chk_EOL+4↑j
SYSINIT:244E                                         ; _$P_Chk_EOL+8↑j ...
SYSINIT:244E                 pop     cx
SYSINIT:244F                 pop     bx
SYSINIT:2450                 retn
SYSINIT:2450 _$P_Chk_EOL     endp
SYSINIT:2450
SYSINIT:2451
SYSINIT:2451 ; =============== S U B R O U T I N E =======================================
SYSINIT:2451
SYSINIT:2451
SYSINIT:2451 _$P_Chk_Delim   proc near               ; CODE XREF: SysParse+75↑p
SYSINIT:2451                                         ; _$P_Skip_Delim+6↑p
SYSINIT:2451                 push    bx
SYSINIT:2452                 push    cx
SYSINIT:2453                 mov     cs:_$P_Terminator, 20h ; ' ' ; _$P_Space
SYSINIT:2453                                         ; assume terminated by space
SYSINIT:2459                 and     cs:_$P_Flags2, 0DFh ; 0FFh-_$P_Extra ; ~$P_Extra ; ~20h
SYSINIT:245F                 cmp     al, 20h ; ' '   ; _$P_Space ; Space ?
SYSINIT:2461                 jz      short _$P_Chk_Delim_Exit
SYSINIT:2463                 cmp     al, 9           ; _$P_TAB ; TAB ?
SYSINIT:2465                 jz      short _$P_Chk_Delim_Exit
SYSINIT:2467                 cmp     al, 2Ch ; ','   ; _$P_Comma ; Comma ?
SYSINIT:2469                 jz      short _$P_Chk_Delim_Exit0
SYSINIT:246B
SYSINIT:246B _$P_Chk_Delim00:                        ; Note: _$P_Chk_Delim00 part of code is nonsense
SYSINIT:246B                 cmp     al, 20h ; ' '   ;       here because _$P_Space = _$P_DBSP1 = 20h
SYSINIT:246B                                         ;       Erdogan Tan - 08/07/2023
SYSINIT:246B                                         ;
SYSINIT:246B                                         ; _$P_DBSP1 ; 1st byte of DBCS Space ?
SYSINIT:246D                 jnz     short _$P_Chk_Delim01
SYSINIT:246F                 cmp     byte ptr [si], 20h ; ' ' ; _$P_DBSP2 ; 2nd byte of DBCS Space ?
SYSINIT:2472                 jnz     short _$P_Chk_Delim01
SYSINIT:2474                 mov     al, 20h ; ' '   ; _$P_Space
SYSINIT:2476                 inc     si              ; make si point to next character
SYSINIT:2477                 cmp     al, al          ; Set ZF
SYSINIT:2479                 jmp     short _$P_Chk_Delim_Exit
SYSINIT:247B ; ---------------------------------------------------------------------------
SYSINIT:247B
SYSINIT:247B _$P_Chk_Delim01:                        ; CODE XREF: _$P_Chk_Delim+1C↑j
SYSINIT:247B                                         ; _$P_Chk_Delim+21↑j
SYSINIT:247B                 cmp     byte ptr es:[di+2], 1 ; [es:di-_$P_PARMS_Blk.Num_Extra],
SYSINIT:247B                                         ; _$P_I_Have_Delim
SYSINIT:247B                                         ; delimiter character specified ?
SYSINIT:2480                 jb      short _$P_Chk_Delim_Exit ; no
SYSINIT:2482                 xor     cx, cx
SYSINIT:2484                 mov     cl, es:[di+3]   ; [es:di+_$P_PARMS_Blk.Len_Extra_Delim]
SYSINIT:2484                                         ; get length of delimiter list
SYSINIT:2488                 jcxz    short _$P_Chk_Delim_NZ ; no extra delim character
SYSINIT:248A                 mov     bx, 3           ; _$P_Len_PARMS-1
SYSINIT:248A                                         ; set bx to 1st extra delimiter
SYSINIT:248D
SYSINIT:248D _$P_Chk_Delim_Loop:                     ; CODE XREF: _$P_Chk_Delim+42↓j
SYSINIT:248D                 inc     bx
SYSINIT:248E                 cmp     al, es:[bx+di]  ; check extra delim character
SYSINIT:2491                 jz      short _$P_Chk_Delim_Exit0
SYSINIT:2493                 loop    _$P_Chk_Delim_Loop ; examine all extra delimiter
SYSINIT:2495
SYSINIT:2495 _$P_Chk_Delim_NZ:                       ; CODE XREF: _$P_Chk_Delim+37↑j
SYSINIT:2495                 cmp     al, 20h ; ' '   ; _$P_Space ; reset ZF
SYSINIT:2497
SYSINIT:2497 _$P_Chk_Delim_Exit:                     ; CODE XREF: _$P_Chk_Delim+10↑j
SYSINIT:2497                                         ; _$P_Chk_Delim+14↑j ...
SYSINIT:2497                 pop     cx
SYSINIT:2498                 pop     bx
SYSINIT:2499                 retn
SYSINIT:249A ; ---------------------------------------------------------------------------
SYSINIT:249A
SYSINIT:249A _$P_Chk_Delim_Exit0:                    ; CODE XREF: _$P_Chk_Delim+18↑j
SYSINIT:249A                                         ; _$P_Chk_Delim+40↑j
SYSINIT:249A                 mov     cs:_$P_Terminator, al ; keep terminated delimiter
SYSINIT:249E                 test    cs:_$P_Flags2, 1 ; _$P_equ ; if terminating a key=
SYSINIT:24A4                 jnz     short _$P_No_Set_Extra ; then do not set the EXTRA bit
SYSINIT:24A6                 or      cs:_$P_Flags2, 20h ; _$P_Extra
SYSINIT:24A6                                         ; flag terminated extra delim or comma
SYSINIT:24AC
SYSINIT:24AC _$P_No_Set_Extra:                       ; CODE XREF: _$P_Chk_Delim+53↑j
SYSINIT:24AC                 cmp     al, al          ; set ZF
SYSINIT:24AE                 jmp     short _$P_Chk_Delim_Exit
SYSINIT:24AE _$P_Chk_Delim   endp
SYSINIT:24AE
SYSINIT:24B0
SYSINIT:24B0 ; =============== S U B R O U T I N E =======================================
SYSINIT:24B0
SYSINIT:24B0
SYSINIT:24B0 _$P_Chk_Switch  proc near               ; CODE XREF: SysParse+6B↑p
SYSINIT:24B0                 lea     bp, _$P_STRING_BUF ; BP = Offset of _$P_String_Buf
SYSINIT:24B0                                         ; (mov bp, offset _$P_STRING_BUF)
SYSINIT:24B4                 cmp     bx, bp          ; IF not first char THEN
SYSINIT:24B6                 jz      short _$P_STRUC_L2
SYSINIT:24B8                 cmp     al, 2Fh ; '/'   ; _$P_Switch ; see if a slash
SYSINIT:24BA                 jnz     short _$P_STRUC_L5
SYSINIT:24BC                 stc                     ; not in first position and is slash
SYSINIT:24BD                 retn
SYSINIT:24BE ; ---------------------------------------------------------------------------
SYSINIT:24BE
SYSINIT:24BE _$P_STRUC_L5:                           ; CODE XREF: _$P_Chk_Switch+A↑j
SYSINIT:24BE                 clc                     ; not a slash
SYSINIT:24BF                 retn
SYSINIT:24C0 ; ---------------------------------------------------------------------------
SYSINIT:24C0
SYSINIT:24C0 _$P_STRUC_L2:                           ; CODE XREF: _$P_Chk_Switch+6↑j
SYSINIT:24C0                 cmp     al, 2Fh ; '/'   ; _$P_Switch
SYSINIT:24C2                 jnz     short _$P_STRUC_L12 ; not a slash
SYSINIT:24C4                 or      cs:_$P_Flags2, 40h ; _$P_SW
SYSINIT:24C4                                         ; could be valid switch,
SYSINIT:24C4                                         ; first char and is slash
SYSINIT:24CA
SYSINIT:24CA _$P_STRUC_L12:                          ; CODE XREF: _$P_Chk_Switch+12↑j
SYSINIT:24CA                 clc                     ; is first char in the buffer, ZF=0
SYSINIT:24CA                                         ; (CF=0 indicating first char)
SYSINIT:24CB                 retn
SYSINIT:24CB _$P_Chk_Switch  endp
SYSINIT:24CB
SYSINIT:24CC
SYSINIT:24CC ; =============== S U B R O U T I N E =======================================
SYSINIT:24CC
SYSINIT:24CC
SYSINIT:24CC _$P_Chk_DBCS    proc near               ; CODE XREF: SysParse+A0↑p
SYSINIT:24CC                                         ; _$P_Remove_Colon:_$P_RCOL00↑p ...
SYSINIT:24CC                 push    ds
SYSINIT:24CD                 push    si
SYSINIT:24CE                 push    bx
SYSINIT:24CF                 cmp     cs:_$P_DBCSEV_SEG, 0 ; already set ?
SYSINIT:24D5                 jnz     short _$P_DBCS00 ; yes
SYSINIT:24D7                 push    ax
SYSINIT:24D8                 push    ds
SYSINIT:24D9                 push    cx
SYSINIT:24DA                 push    dx
SYSINIT:24DB                 push    di
SYSINIT:24DC                 push    bp
SYSINIT:24DD                 push    es
SYSINIT:24DE                 xor     si, si
SYSINIT:24E0                 mov     ds, si
SYSINIT:24E2                 assume ds:nothing
SYSINIT:24E2                 mov     ax, 6300h       ; _$P_DOS_GetEV ; GET DBCS EV CALL
SYSINIT:24E5                 int     21h             ; DOS - 3.2+ only
SYSINIT:24E5                                         ; GET DOUBLE BYTE CHARACTER SET LEAD TABLE
SYSINIT:24E7                 mov     bx, ds
SYSINIT:24E9                 or      bx, bx
SYSINIT:24EB                 pop     es
SYSINIT:24EC                 pop     bp
SYSINIT:24ED                 pop     di
SYSINIT:24EE                 pop     dx
SYSINIT:24EF                 pop     cx
SYSINIT:24F0                 pop     ds
SYSINIT:24F1                 assume ds:nothing
SYSINIT:24F1                 pop     ax
SYSINIT:24F2                 jz      short _$P_NON_DBCS
SYSINIT:24F4                 mov     cs:_$P_DBCSEV_OFF, si ; save EV offset
SYSINIT:24F9                 mov     cs:_$P_DBCSEV_SEG, bx ; save EV segment
SYSINIT:24FE
SYSINIT:24FE _$P_DBCS00:                             ; CODE XREF: _$P_Chk_DBCS+9↑j
SYSINIT:24FE                 lds     si, dword ptr cs:_$P_DBCSEV_OFF ; load EV offset and segment
SYSINIT:2503
SYSINIT:2503 _$P_DBCS_LOOP:                          ; CODE XREF: _$P_Chk_DBCS+4A↓j
SYSINIT:2503                 cmp     word ptr [si], 0 ; zero vector ?
SYSINIT:2506                 jz      short _$P_NON_DBCS ; then exit
SYSINIT:2508                 cmp     al, [si]        ; Check if AL is in range of the vector
SYSINIT:250A                 jb      short _$P_DBCS01
SYSINIT:250C                 cmp     al, [si+1]
SYSINIT:250F                 ja      short _$P_DBCS01
SYSINIT:2511                 stc                     ; if yes, indicate DBCS and exit
SYSINIT:2512                 jmp     short _$P_DBCS_EXIT
SYSINIT:2514 ; ---------------------------------------------------------------------------
SYSINIT:2514
SYSINIT:2514 _$P_DBCS01:                             ; CODE XREF: _$P_Chk_DBCS+3E↑j
SYSINIT:2514                                         ; _$P_Chk_DBCS+43↑j
SYSINIT:2514                 inc     si              ; add 2 to si reg
SYSINIT:2515                 inc     si              ; get next vector
SYSINIT:2516                 jmp     short _$P_DBCS_LOOP ; loop until zero vector found
SYSINIT:2518 ; ---------------------------------------------------------------------------
SYSINIT:2518
SYSINIT:2518 _$P_NON_DBCS:                           ; CODE XREF: _$P_Chk_DBCS+26↑j
SYSINIT:2518                                         ; _$P_Chk_DBCS+3A↑j
SYSINIT:2518                 clc                     ; indicate SBCS
SYSINIT:2518                                         ; (note: cf is already 0 here)
SYSINIT:2519
SYSINIT:2519 _$P_DBCS_EXIT:                          ; CODE XREF: _$P_Chk_DBCS+46↑j
SYSINIT:2519                 pop     bx
SYSINIT:251A                 pop     si
SYSINIT:251B                 pop     ds
SYSINIT:251C                 retn
SYSINIT:251C _$P_Chk_DBCS    endp
SYSINIT:251C
SYSINIT:251C ; ---------------------------------------------------------------------------
SYSINIT:251D buf_parms       dw offset buf_parmsx    ; DATA XREF: doconf+1DA↓o
SYSINIT:251D                                         ; buffer = [n | n,m] {/e}
SYSINIT:251F                 db 1                    ; an extra delimiter list
SYSINIT:2520                 db 1                    ; length is 1
SYSINIT:2521                 db ';'                  ; delimiter
SYSINIT:2522 buf_parmsx      db 1                    ; DATA XREF: SYSINIT:buf_parms↑o
SYSINIT:2523                 db 2                    ; min 1, max 2 positionals
SYSINIT:2524                 dw offset buf_pos1
SYSINIT:2526                 dw offset buf_pos2
SYSINIT:2528                 db 1                    ; one switch
SYSINIT:2529                 dw offset sw_x_ctrl
SYSINIT:252B                 db 0                    ; no keywords
SYSINIT:252B                                         ;
SYSINIT:252B                                         ; buf_pos1 p_pos <8000h,0,result_val,buf_range_1>
SYSINIT:252B                                         ; numeric
SYSINIT:252C buf_pos1        dw 8000h                ; DATA XREF: SYSINIT:2524↑o
SYSINIT:252C                                         ; match_flags - numeric value
SYSINIT:252E                 dw 0                    ; function flags
SYSINIT:2530                 dw offset result_val    ; result value buffer
SYSINIT:2532                 dw offset buf_range_1   ; value list
SYSINIT:2534                 db 0                    ; no switches/keywords
SYSINIT:2535 buf_range_1     db 1                    ; DATA XREF: SYSINIT:2532↑o
SYSINIT:2535                                         ; range definition
SYSINIT:2536                 db 1                    ; 1 definition of range
SYSINIT:2537                 db 1                    ; item tag for this range
SYSINIT:2538                 dd 1                    ; numeric min
SYSINIT:253C                 dd 99                   ; numeric max
SYSINIT:253C                                         ;
SYSINIT:253C                                         ; buf_pos2 p_pos <8001h,0,result_val,buf_range_2>
SYSINIT:253C                                         ; optional num.
SYSINIT:2540 buf_pos2        dw 8001h                ; DATA XREF: SYSINIT:2526↑o
SYSINIT:2542                 dw 0
SYSINIT:2544                 dw offset result_val
SYSINIT:2546                 dw offset buf_range_2
SYSINIT:2548                 db 0                    ;
SYSINIT:2548                                         ; buf_range_2 p_range <,,,0,8>
SYSINIT:2549 buf_range_2     db 1                    ; DATA XREF: SYSINIT:2546↑o
SYSINIT:254A                 db 1
SYSINIT:254B                 db 1
SYSINIT:254C                 dd 0
SYSINIT:2550                 dd 8                    ;
SYSINIT:2550                                         ; sw_x_ctrl p_pos <0,0,result_val,noval,1>
SYSINIT:2550                                         ; followed by one switch
SYSINIT:2554 sw_x_ctrl       dw 0                    ; DATA XREF: SYSINIT:2529↑o
SYSINIT:2556                 dw 0
SYSINIT:2558                 dw offset result_val
SYSINIT:255A                 dw offset noval
SYSINIT:255C                 db 1                    ; 1 switch
SYSINIT:255D switch_x        db '/X',0               ; DATA XREF: doconf+1F0↓o
SYSINIT:2560 p_buffers       dw 0                    ; DATA XREF: doconf+202↓w
SYSINIT:2560                                         ; doconf:en7↓r ...
SYSINIT:2562 p_h_buffers     dw 0                    ; DATA XREF: doconf:if13↓w
SYSINIT:2562                                         ; doconf+216↓w ...
SYSINIT:2564 p_buffer_slash_x db 0                   ; DATA XREF: doconf+1D5↓w
SYSINIT:2564                                         ;
SYSINIT:2564                                         ; common definitions
SYSINIT:2565 noval           db 0                    ; DATA XREF: SYSINIT:255A↑o
SYSINIT:2565                                         ; SYSINIT:25C6↓o ...
SYSINIT:2566 result_val      db 0                    ; DATA XREF: SYSINIT:2530↑o
SYSINIT:2566                                         ; SYSINIT:2544↑o ...
SYSINIT:2566                                         ; type returned
SYSINIT:2567 result_val_itag db 0                    ; DATA XREF: doconf+253↓r
SYSINIT:2567                                         ; doconf+295↓r ...
SYSINIT:2567                                         ; item tag returned
SYSINIT:2568 result_val_swoff dw 0                   ; DATA XREF: doconf+1F0↓r
SYSINIT:2568                                         ; doconf+9E6↓r ...
SYSINIT:2568                                         ; es:offset of the switch defined
SYSINIT:256A rv_dword        dd 0                    ; DATA XREF: doconf:if11↓r
SYSINIT:256A                                         ; doconf+6F2↓r ...
SYSINIT:256A                                         ; rv_byte
SYSINIT:256A                                         ; value if number, or seg:offset to string.
SYSINIT:256A                                         ; ;;
SYSINIT:256E brk_parms       dw offset brk_parmsx    ; DATA XREF: doconf+23D↓o
SYSINIT:256E                                         ; break = [ on | off ]
SYSINIT:2570                 db 1                    ; an extra delimiter list
SYSINIT:2571                 db 1                    ; length is 1
SYSINIT:2572                 db ';'                  ; delimiter
SYSINIT:2573 brk_parmsx      db 1                    ; DATA XREF: SYSINIT:brk_parms↑o
SYSINIT:2573                                         ; min,max = 1 positional
SYSINIT:2574                 db 1
SYSINIT:2575                 dw offset brk_pos
SYSINIT:2577                 db 0                    ; no switches
SYSINIT:2578                 db 0                    ; no keywords
SYSINIT:2579 brk_pos         dw 2000h                ; DATA XREF: SYSINIT:2575↑o
SYSINIT:257B                 dw 0
SYSINIT:257D                 dw offset result_val
SYSINIT:257F                 dw offset on_off_string
SYSINIT:2581                 db 0
SYSINIT:2582 on_off_string   db 3                    ; DATA XREF: SYSINIT:257F↑o
SYSINIT:2582                                         ; SYSINIT:2683↓o
SYSINIT:2582                                         ; signals that there is a string choice
SYSINIT:2583                 db 0                    ; no range definition
SYSINIT:2584                 db 0                    ; no numeric values choice
SYSINIT:2585                 db 2                    ; 2 strings for choice
SYSINIT:2586                 db 1                    ; the 1st string tag
SYSINIT:2587                 dw offset _on_string    ; "ON"
SYSINIT:2589                 db 2                    ; the 2nd string tag
SYSINIT:258A                 dw offset _off_string   ; "OFF"
SYSINIT:258C _on_string      db 'ON',0               ; DATA XREF: SYSINIT:2587↑o
SYSINIT:258F _off_string     db 'OFF',0              ; DATA XREF: SYSINIT:258A↑o
SYSINIT:2593 p_ctrl_break    db 0                    ; DATA XREF: doconf+25A↓w
SYSINIT:2593                                         ; doconf:if26↓w ...
SYSINIT:2593                                         ; local variable
SYSINIT:2593                                         ; ;;
SYSINIT:2594 cntry_parms     dw offset cntry_parmsx  ; DATA XREF: doconf+6CD↓o
SYSINIT:2594                                         ; country = n {m {path}}
SYSINIT:2594                                         ; or country = n,,path
SYSINIT:2596                 db 1
SYSINIT:2597                 db 1
SYSINIT:2598                 db ';'
SYSINIT:2599 cntry_parmsx    db 1                    ; DATA XREF: SYSINIT:cntry_parms↑o
SYSINIT:2599                                         ; min 1, max 3 pos.
SYSINIT:259A                 db 3
SYSINIT:259B                 dw offset cntry_pos1
SYSINIT:259D                 dw offset cntry_pos2
SYSINIT:259F                 dw offset cntry_pos3
SYSINIT:25A1                 db 0                    ; no switches
SYSINIT:25A2                 db 0                    ; no keywords
SYSINIT:25A3 cntry_pos1      dw 8000h                ; DATA XREF: SYSINIT:259B↑o
SYSINIT:25A3                                         ; cntry_pos1 p_pos <8000h,0,result_val,cc_range>
SYSINIT:25A3                                         ; numeric value
SYSINIT:25A5                 dw 0
SYSINIT:25A7                 dw offset result_val
SYSINIT:25A9                 dw offset cc_range
SYSINIT:25AB                 db 0
SYSINIT:25AC cc_range        db 1                    ; DATA XREF: SYSINIT:25A9↑o
SYSINIT:25AC                                         ; SYSINIT:25BD↓o
SYSINIT:25AC                                         ; cc_range p_range <,,,1,999>
SYSINIT:25AD                 db 1
SYSINIT:25AE                 db 1
SYSINIT:25AF                 dd 1
SYSINIT:25B3                 dd 999
SYSINIT:25B7 cntry_pos2      dw 8001h                ; DATA XREF: SYSINIT:259D↑o
SYSINIT:25B7                                         ; cntry_pos2 p_pos <8001h,0,result_val,cc_range>
SYSINIT:25B7                                         ; optional num.
SYSINIT:25B9                 dw 0
SYSINIT:25BB                 dw offset result_val
SYSINIT:25BD                 dw offset cc_range
SYSINIT:25BF                 db 0
SYSINIT:25C0 cntry_pos3      dw 201h                 ; DATA XREF: SYSINIT:259F↑o
SYSINIT:25C0                                         ; cntry_pos3 p_pos <201h,0,result_val,noval>
SYSINIT:25C0                                         ; optional filespec
SYSINIT:25C2                 dw 0
SYSINIT:25C4                 dw offset result_val
SYSINIT:25C6                 dw offset noval
SYSINIT:25C8                 db 0
SYSINIT:25C9 p_cntry_code    dw 0                    ; DATA XREF: doconf+6DC↓w
SYSINIT:25C9                                         ; doconf+6FB↓w ...
SYSINIT:25C9                                         ; local variable
SYSINIT:25CB p_code_page     dw 0                    ; DATA XREF: doconf+6C6↓w
SYSINIT:25CB                                         ; doconf:if57↓w ...
SYSINIT:25CB                                         ; local variable
SYSINIT:25CB                                         ; ;;
SYSINIT:25CD files_parms     dw offset files_parmsx  ; DATA XREF: doconf+7ED↓o
SYSINIT:25CD                                         ; files = n
SYSINIT:25CF                 db 1
SYSINIT:25D0                 db 1
SYSINIT:25D1                 db ';'
SYSINIT:25D2 files_parmsx    db 1                    ; DATA XREF: SYSINIT:files_parms↑o
SYSINIT:25D3                 db 1                    ; min,max 1 positional
SYSINIT:25D4                 dw offset files_pos
SYSINIT:25D6                 db 0                    ; no switches
SYSINIT:25D7                 db 0                    ; no keywords
SYSINIT:25D8 files_pos       dw 8000h                ; DATA XREF: SYSINIT:25D4↑o
SYSINIT:25D8                                         ; files_pos p_pos <8000h,0,result_val,files_range,0>
SYSINIT:25D8                                         ; numeric value
SYSINIT:25DA                 dw 0
SYSINIT:25DC                 dw offset result_val
SYSINIT:25DE                 dw offset files_range
SYSINIT:25E0                 db 0
SYSINIT:25E1 files_range     db 1                    ; DATA XREF: SYSINIT:25DE↑o
SYSINIT:25E1                                         ; files_range p_range <,,,8,255>
SYSINIT:25E2                 db 1
SYSINIT:25E3                 db 1
SYSINIT:25E4                 dd 8
SYSINIT:25E8                 dd 255
SYSINIT:25EC p_files         db 0                    ; DATA XREF: doconf+807↓w
SYSINIT:25EC                                         ; doconf:en67↓r
SYSINIT:25EC                                         ; local variable
SYSINIT:25EC                                         ; ;;
SYSINIT:25ED fcbs_parms      dw offset fcbs_parmsx   ; DATA XREF: doconf+986↓o
SYSINIT:25ED                                         ; fcbs = n,m
SYSINIT:25EF                 db 1
SYSINIT:25F0                 db 1
SYSINIT:25F1                 db ';'
SYSINIT:25F2 fcbs_parmsx     db 1                    ; DATA XREF: SYSINIT:fcbs_parms↑o
SYSINIT:25F3                 db 2
SYSINIT:25F4                 dw offset fcbs_pos_1
SYSINIT:25F6                 dw offset fcbs_pos_2
SYSINIT:25F8                 db 0                    ; no switches
SYSINIT:25F9                 db 0                    ; no keywords
SYSINIT:25FA fcbs_pos_1      dw 8000h                ; DATA XREF: SYSINIT:25F4↑o
SYSINIT:25FA                                         ; fcbs_pos_1 p_pos <8000h,0,result_val,fcbs_range>
SYSINIT:25FA                                         ; numeric value
SYSINIT:25FC                 dw 0
SYSINIT:25FE                 dw offset result_val
SYSINIT:2600                 dw offset fcbs_range
SYSINIT:2602                 db 0
SYSINIT:2603 fcbs_range      db 1                    ; DATA XREF: SYSINIT:2600↑o
SYSINIT:2603                                         ; fcbs_range p_range <,,,1,255>
SYSINIT:2604                 db 1
SYSINIT:2605                 db 1
SYSINIT:2606                 dd 1
SYSINIT:260A                 dd 255
SYSINIT:260E fcbs_pos_2      dw 8000h                ; DATA XREF: SYSINIT:25F6↑o
SYSINIT:260E                                         ; fcbs_pos_2 p_pos <8000h,0,result_val,fcbs_keep_range>
SYSINIT:260E                                         ; numeric value
SYSINIT:2610                 dw 0
SYSINIT:2612                 dw offset result_val
SYSINIT:2614                 dw offset fcbs_keep_range
SYSINIT:2616                 db 0
SYSINIT:2617 fcbs_keep_range db 1                    ; DATA XREF: SYSINIT:2614↑o
SYSINIT:2617                                         ; fcbs_keep_range p_range <,,,0,255>
SYSINIT:2618                 db 1
SYSINIT:2619                 db 1
SYSINIT:261A                 dd 0
SYSINIT:261E                 dd 255
SYSINIT:2622 p_fcbs          db 0                    ; DATA XREF: doconf+9A5↓w
SYSINIT:2622                                         ; doconf:en98↓r
SYSINIT:2622                                         ; local variable
SYSINIT:2623 p_keep          db 0                    ; DATA XREF: doconf:if102↓w
SYSINIT:2623                                         ; local variable
SYSINIT:2623                                         ; ;;
SYSINIT:2624 ldrv_parms      dw offset ldrv_parmsx   ; DATA XREF: doconf+822↓o
SYSINIT:2624                                         ; lastdrive = x
SYSINIT:2626                 db 1
SYSINIT:2627                 db 1
SYSINIT:2628                 db ';'
SYSINIT:2629 ldrv_parmsx     db 1                    ; DATA XREF: SYSINIT:ldrv_parms↑o
SYSINIT:262A                 db 1                    ; min,max = 1 positional
SYSINIT:262B                 dw offset ldrv_pos
SYSINIT:262D                 db 0                    ; no switches
SYSINIT:262E                 db 0                    ; no keywords
SYSINIT:262F ldrv_pos        dw 110h                 ; DATA XREF: SYSINIT:262B↑o
SYSINIT:262F                                         ; ldrv_pos p_pos <110h,10h,result_val,noval>
SYSINIT:262F                                         ; drive only, ignore colon at end
SYSINIT:2631                 dw 10h
SYSINIT:2633                 dw offset result_val
SYSINIT:2635                 dw offset noval
SYSINIT:2637                 db 0
SYSINIT:2638 p_ldrv          db 0                    ; DATA XREF: doconf+83C↓w
SYSINIT:2638                                         ; doconf:en73↓r
SYSINIT:2638                                         ; local variable
SYSINIT:2638                                         ; ;;
SYSINIT:2639 stks_parms      dw offset stks_parmsx   ; DATA XREF: doconf+875↓o
SYSINIT:2639                                         ; stacks = n,m
SYSINIT:263B                 db 1
SYSINIT:263C                 db 1
SYSINIT:263D                 db ';'
SYSINIT:263E stks_parmsx     db 2                    ; DATA XREF: SYSINIT:stks_parms↑o
SYSINIT:263F                 db 2                    ; min,max = 2 positionals
SYSINIT:2640                 dw offset stks_pos_1
SYSINIT:2642                 dw offset stks_pos_2
SYSINIT:2644                 db 0                    ; no switches
SYSINIT:2645                 db 0                    ; no keywords
SYSINIT:2646 stks_pos_1      dw 8000h                ; DATA XREF: SYSINIT:2640↑o
SYSINIT:2646                                         ; stks_pos_1 p_pos <8000h,0,result_val,stks_range>
SYSINIT:2646                                         ; numeric value
SYSINIT:2648                 dw 0
SYSINIT:264A                 dw offset result_val
SYSINIT:264C                 dw offset stks_range
SYSINIT:264E                 db 0
SYSINIT:264F stks_range      db 1                    ; DATA XREF: SYSINIT:264C↑o
SYSINIT:264F                                         ; stks_range p_range <,,,0,64>
SYSINIT:2650                 db 1
SYSINIT:2651                 db 1
SYSINIT:2652                 dd 0
SYSINIT:2656                 dd 64
SYSINIT:265A stks_pos_2      dw 8000h                ; DATA XREF: SYSINIT:2642↑o
SYSINIT:265A                                         ; stks_pos_2 p_pos <8000h,0,result_val,stk_size_range>
SYSINIT:265A                                         ; numeric value
SYSINIT:265C                 dw 0
SYSINIT:265E                 dw offset result_val
SYSINIT:2660                 dw offset stk_size_range
SYSINIT:2662                 db 0
SYSINIT:2663 stk_size_range  db 1                    ; DATA XREF: SYSINIT:2660↑o
SYSINIT:2663                                         ; stk_size_range p_range <,,,0,512>
SYSINIT:2664                 db 1
SYSINIT:2665                 db 1
SYSINIT:2666                 dd 0
SYSINIT:266A                 dd 512
SYSINIT:266E p_stack_count   dw 0                    ; DATA XREF: doconf+89B↓w
SYSINIT:266E                                         ; doconf:en79↓r ...
SYSINIT:266E                                         ; local variable
SYSINIT:2670 p_stack_size    dw 0                    ; DATA XREF: doconf:if83↓w
SYSINIT:2670                                         ; doconf+8B7↓r ...
SYSINIT:2670                                         ; local variable
SYSINIT:2670                                         ; ;;
SYSINIT:2672 mtrk_parms      dw offset mtrk_parmsx   ; DATA XREF: doconf+27F↓o
SYSINIT:2672                                         ; multitrack = [ on | off ]
SYSINIT:2674                 db 1
SYSINIT:2675                 db 1
SYSINIT:2676                 db ';'
SYSINIT:2677 mtrk_parmsx     db 1                    ; DATA XREF: SYSINIT:mtrk_parms↑o
SYSINIT:2677                                         ; min,max = 1 positional
SYSINIT:2678                 db 1
SYSINIT:2679                 dw offset mtrk_pos
SYSINIT:267B                 db 0                    ; no switches
SYSINIT:267C                 db 0                    ; no keywords
SYSINIT:267D mtrk_pos        dw 2000h                ; DATA XREF: SYSINIT:2679↑o
SYSINIT:267D                                         ; mtrk_pos p_pos <2000h,0,result_val,on_off_string>
SYSINIT:267D                                         ; simple string
SYSINIT:267F                 dw 0
SYSINIT:2681                 dw offset result_val
SYSINIT:2683                 dw offset on_off_string
SYSINIT:2685                 db 0
SYSINIT:2686 p_mtrk          db 0                    ; DATA XREF: doconf+29C↓w
SYSINIT:2686                                         ; doconf:if35↓w ...
SYSINIT:2686                                         ; local variable
SYSINIT:2686                                         ; ;;
SYSINIT:2687 swit_parms      dw offset swit_parmsx   ; DATA XREF: doconf+9CF↓o
SYSINIT:2687                                         ; switches=/k
SYSINIT:2689                 db 1
SYSINIT:268A                 db 1
SYSINIT:268B                 db ';'
SYSINIT:268C swit_parmsx     dw 0                    ; DATA XREF: SYSINIT:swit_parms↑o
SYSINIT:268C                                         ; no positionals
SYSINIT:268E                 db 6                    ; # of switches (6 for PCDOS 7.1 IBMBIO.COM)
SYSINIT:268E                                         ;  (5 for MSDOS 6.21 IO.SYS)
SYSINIT:268F                 dw offset swit_k_ctrl   ; /k control
SYSINIT:2691                 dw offset swit_n_ctrl   ; /n control (for MULTI_CONFIG only)
SYSINIT:2693                 dw offset swit_f_ctrl   ; /f control (for MULTI_CONFIG only)
SYSINIT:2695                 dw offset swit_t_ctrl   ; /t control
SYSINIT:2697                 dw offset swit_w_ctrl   ; /w control
SYSINIT:2699                 dw offset swit_i_ctrl   ; /i control
SYSINIT:2699                                         ; (6th switch for PCDOS 7.1 IBMBIO.COM)
SYSINIT:269B                 db 0                    ; no keywords
SYSINIT:269C swit_k_ctrl     dw 0                    ; DATA XREF: SYSINIT:268F↑o
SYSINIT:269C                                         ; swit_k_ctrl p_pos <0,0,result_val,noval,1>
SYSINIT:269C                                         ; switch string follows
SYSINIT:269E                 dw 0
SYSINIT:26A0                 dw offset result_val
SYSINIT:26A2                 dw offset noval
SYSINIT:26A4                 db 1
SYSINIT:26A5 swit_k          db '/K',0               ; DATA XREF: doconf+9E6↓o
SYSINIT:26A8 swit_n_ctrl     dw 0                    ; DATA XREF: SYSINIT:2691↑o
SYSINIT:26A8                                         ; swit_n_ctrl p_pos <0,0,result_val,noval,1>
SYSINIT:26A8                                         ; switch string follows
SYSINIT:26AA                 dw 0
SYSINIT:26AC                 dw offset result_val
SYSINIT:26AE                 dw offset noval
SYSINIT:26B0                 db 1
SYSINIT:26B1 swit_n          db '/N',0               ; DATA XREF: menu_check+36↓r
SYSINIT:26B4 swit_f_ctrl     dw 0                    ; DATA XREF: SYSINIT:2693↑o
SYSINIT:26B4                                         ; swit_f_ctrl p_pos <0,0,result_val,noval,1>
SYSINIT:26B4                                         ; switch string follows
SYSINIT:26B6                 dw 0
SYSINIT:26B8                 dw offset result_val
SYSINIT:26BA                 dw offset noval
SYSINIT:26BC                 db 1
SYSINIT:26BD swit_f          db '/F',0               ; DATA XREF: menu_check:swchk_scan2↓r
SYSINIT:26C0 swit_t_ctrl     dw 0                    ; DATA XREF: SYSINIT:2695↑o
SYSINIT:26C0                                         ; swit_t_ctrl p_pos <0,0,result_val,noval,1>
SYSINIT:26C0                                         ; switch string follows
SYSINIT:26C2                 dw 0
SYSINIT:26C4                 dw offset result_val
SYSINIT:26C6                 dw offset noval
SYSINIT:26C8                 db 1
SYSINIT:26C9 swit_t          db '/T',0               ; DATA XREF: doconf:if115↓o
SYSINIT:26CC swit_w_ctrl     dw 0                    ; DATA XREF: SYSINIT:2697↑o
SYSINIT:26CC                                         ; swit_w_ctrl p_pos <0,0,result_val,noval,1>
SYSINIT:26CC                                         ; switch string follows
SYSINIT:26CE                 dw 0
SYSINIT:26D0                 dw offset result_val
SYSINIT:26D2                 dw offset noval
SYSINIT:26D4                 db 1
SYSINIT:26D5 swit_w          db '/W',0               ; DATA XREF: doconf:if116↓o
SYSINIT:26D8 swit_i_ctrl     dw 0                    ; DATA XREF: SYSINIT:2699↑o
SYSINIT:26D8                                         ; swit_i_ctrl p_pos <0,0,result_val,noval,1>
SYSINIT:26D8                                         ; switch string follows
SYSINIT:26DA                 dw 0
SYSINIT:26DC                 dw offset result_val
SYSINIT:26DE                 dw offset noval
SYSINIT:26E0                 db 1
SYSINIT:26E1 swit_i          db '/I',0               ; DATA XREF: doconf:if118↓o
SYSINIT:26E4 swit_c_ctrl     dw 0                    ; ! (/C, /D, /E switches are not used) !
SYSINIT:26E4                                         ; Erdogan Tan - 09/07/2023
SYSINIT:26E6                 dw 0
SYSINIT:26E8                 dw offset result_val
SYSINIT:26EA                 dw offset noval
SYSINIT:26EC                 db 1
SYSINIT:26ED swit_c          db '/C',0
SYSINIT:26F0 swit_d_ctrl     dw 0
SYSINIT:26F2                 dw 0
SYSINIT:26F4                 dw offset result_val
SYSINIT:26F6                 dw offset noval
SYSINIT:26F8                 db 1
SYSINIT:26F9 swit_d          db '/D',0
SYSINIT:26FC swit_e_ctrl     dw 0
SYSINIT:26FE                 dw 0
SYSINIT:2700                 dw offset result_val
SYSINIT:2702                 dw offset noval
SYSINIT:2704                 db 1
SYSINIT:2705 swit_e          db '/E',0
SYSINIT:2708                 db 0
SYSINIT:2709                 db 0
SYSINIT:270A                 db 0
SYSINIT:270B p_swit_k        db 0                    ; DATA XREF: doconf+9EF↓w
SYSINIT:270B                                         ; doconf:en110↓r
SYSINIT:270B                                         ; local variable
SYSINIT:270C p_swit_t        db 0                    ; DATA XREF: doconf+A00↓w
SYSINIT:270C                                         ; doconf:if117↓r
SYSINIT:270C                                         ; local variable
SYSINIT:270D p_swit_w        db 0                    ; DATA XREF: doconf+A22↓w
SYSINIT:270D                                         ; doconf+A49↓r
SYSINIT:270D                                         ; local variable
SYSINIT:270E p_swit_i        db 0                    ; DATA XREF: doconf+A11↓w
SYSINIT:270E                                         ; doconf:if119↓r
SYSINIT:270E                                         ; local variable
SYSINIT:270E                                         ; ;;
SYSINIT:270F dos_parms       dw offset dos_parmsx    ; DATA XREF: doconf+2D7↓o
SYSINIT:270F                                         ; DOS = [ high | low ]
SYSINIT:270F                                         ; DOS = HIGH|LOW[,UMB|,NOUMB]
SYSINIT:2711                 db 1
SYSINIT:2712                 db 1
SYSINIT:2713                 db ';'
SYSINIT:2714 dos_parmsx      db 1                    ; DATA XREF: SYSINIT:dos_parms↑o
SYSINIT:2714                                         ; min parameters
SYSINIT:2715                 db 2                    ; max parameters
SYSINIT:2716                 dw offset dos_pos
SYSINIT:2718                 dw offset dos_pos
SYSINIT:271A                 db 0                    ; no switches
SYSINIT:271B                 db 0                    ; no keywords
SYSINIT:271C dos_pos         dw 2000h                ; DATA XREF: SYSINIT:2716↑o
SYSINIT:271C                                         ; SYSINIT:2718↑o
SYSINIT:271E                 dw 0
SYSINIT:2720                 dw offset result_val
SYSINIT:2722                 dw offset dos_strings
SYSINIT:2724                 db 0
SYSINIT:2725 dos_pos2        dw 2000h                ; dos_pos p_pos <2000h,0,result_val,dos_strings>
SYSINIT:2725                                         ; simple string
SYSINIT:2725                                         ; (this is not needed) - E.TAN - 08/07/2023
SYSINIT:2727                 dw 0
SYSINIT:2729                 dw offset result_val
SYSINIT:272B                 dw offset dos_strings
SYSINIT:272D                 db 0
SYSINIT:272E dos_strings     db 3                    ; DATA XREF: SYSINIT:2722↑o
SYSINIT:272E                                         ; SYSINIT:272B↑o
SYSINIT:272E                                         ; signals that there is a string choice
SYSINIT:272F                 db 0                    ; no range definition
SYSINIT:2730                 db 0                    ; no numeric values choice
SYSINIT:2731                 db 4                    ; 4 strings for choice
SYSINIT:2732                 db 1                    ; the 1st string tag
SYSINIT:2733                 dw offset hi_string     ; "HIGH"
SYSINIT:2735                 db 2                    ; the 2nd string tag
SYSINIT:2736                 dw offset lo_string     ; "LOW"
SYSINIT:2738                 db 3
SYSINIT:2739                 dw offset umb_string    ; "UMB"
SYSINIT:273B                 db 4
SYSINIT:273C                 dw offset noumb_string  ; "NOUMB"
SYSINIT:273E dosdata_parms   dw offset dosdata_parmsx
SYSINIT:273E                                         ; DATA XREF: doconf+AA8↓o
SYSINIT:273E                                         ; DOSDATA = UMB|NOUMB
SYSINIT:2740                 db 1
SYSINIT:2741                 db 1
SYSINIT:2742                 db ';'
SYSINIT:2743 dosdata_parmsx  db 1                    ; DATA XREF: SYSINIT:dosdata_parms↑o
SYSINIT:2744                 db 1                    ; min,max = 1 positional
SYSINIT:2745                 dw offset dosdata_pos
SYSINIT:2747                 db 0                    ; no switches
SYSINIT:2748                 db 0                    ; no keywords
SYSINIT:2749 dosdata_pos     dw 2000h                ; DATA XREF: SYSINIT:2745↑o
SYSINIT:2749                                         ; dosdata_pos p_pos <2000h,0,result_val,dosdata_strings>
SYSINIT:2749                                         ; simple string
SYSINIT:274B                 dw 0
SYSINIT:274D                 dw offset result_val
SYSINIT:274F                 dw offset dosdata_strings
SYSINIT:2751                 db 0
SYSINIT:2752 dosdata_strings db 3                    ; DATA XREF: SYSINIT:274F↑o
SYSINIT:2752                                         ; signals that there is a string choice
SYSINIT:2753                 db 0                    ; no range definition
SYSINIT:2754                 db 0                    ; no numeric values choice
SYSINIT:2755                 db 2                    ; 4 strings for choice
SYSINIT:2756                 db 1                    ; the 1st string tag
SYSINIT:2757                 dw offset umb_string    ; "UMB"
SYSINIT:2759                 db 2                    ; the 2nd string tag
SYSINIT:275A                 dw offset noumb_string  ; "NOUMB"
SYSINIT:275C hi_string       db 'HIGH',0             ; DATA XREF: SYSINIT:2733↑o
SYSINIT:2761 lo_string       db 'LOW',0              ; DATA XREF: SYSINIT:2736↑o
SYSINIT:2765 umb_string      db 'UMB',0              ; DATA XREF: SYSINIT:2739↑o
SYSINIT:2765                                         ; SYSINIT:2757↑o
SYSINIT:2769 noumb_string    db 'NOUMB',0            ; DATA XREF: SYSINIT:273C↑o
SYSINIT:2769                                         ; SYSINIT:275A↑o
SYSINIT:276F p_dos_hi        db 0                    ; local variable (parser does not use this)
SYSINIT:2770                 db 0                    ;
SYSINIT:2770                                         ; for LoadHigh and DeviceHigh:
SYSINIT:2770                                         ;    fInHigh  - Is set to 1 during HideUMBs(), and back to zero in
SYSINIT:2770                                         ;               UnHideUMBs().
SYSINIT:2770                                         ;    fUmbTiny - Is set to 1 iff the user has specified /S on the
SYSINIT:2770                                         ;               command line.
SYSINIT:2770                                         ;    SegLoad  - Segment address for first UMB specified; set
SYSINIT:2770                                         ;               automatically.
SYSINIT:2770                                         ;    UmbLoad  - The load UMB number; for example, this is 3 if the
SYSINIT:2770                                         ;               user has given a command-line like "/L:3,500;4"
SYSINIT:2770                                         ;    fm_umb   - Set to the old UMB link-state (0x80 or 0x00)
SYSINIT:2770                                         ;    fm_strat - Set to the old memory-allocation strategy (0$00000???)
SYSINIT:2770                                         ;    fm_argc  - Number of arguments received by ParseVar()
SYSINIT:2771 fInHigh         db 0                    ; DATA XREF: InitVar+C↓w
SYSINIT:2771                                         ; HideUMBs+12↓w ...
SYSINIT:2772 fUmbTiny        db 0                    ; DATA XREF: InitVar+8↓w
SYSINIT:2772                                         ; ParseVar+21↓w ...
SYSINIT:2773 SegLoad         dw 0                    ; DATA XREF: InitVar+10↓w
SYSINIT:2775 UmbLoad         db 0                    ; DATA XREF: InitVar+14↓w
SYSINIT:2775                                         ; unMarkUMB+10↓r ...
SYSINIT:2775                                         ; UmbUsed - An array of characters, each of which is 1 if the UMB
SYSINIT:2775                                         ;           matching its index number was specified on the
SYSINIT:2775                                         ;           command line;
SYSINIT:2775                                         ;        for example, after "/L:3,500;4;7", UmbUsed[3],[4] & [7]
SYSINIT:2775                                         ;        will be set to 1. All others will be set to 0.
SYSINIT:2775                                         ; UmbSize - An array of words, each of which is interpereted as a
SYSINIT:2775                                         ;           size specified by the user for a UMB (in the above
SYSINIT:2775                                         ;           example, all elements would be zero save UmbSize[3],
SYSINIT:2775                                         ;           which would be 500.
SYSINIT:2776 UmbUsed         db 16 dup(0)            ; DATA XREF: InitVar+22↓o
SYSINIT:2776                                         ; unMarkUMB+A↓w ...
SYSINIT:2776                                         ; times MAXUMB db 0
SYSINIT:2786 UmbSize         dw 16 dup(0)            ; DATA XREF: InitVar+2A↓o
SYSINIT:2786                                         ; stowSiz+B↓w ...
SYSINIT:2786                                         ; times MAXUMB dw 0
SYSINIT:27A6 fm_umb          db 0                    ; DATA XREF: fm_link+8↓w
SYSINIT:27A6                                         ; fm_unlink+5↓r ...
SYSINIT:27A7 fm_strat        db 0
SYSINIT:27A8 fm_argc         db 0                    ; DATA XREF: InitVar+1A↓w
SYSINIT:27A8                                         ; incArgc+4↓r ...
SYSINIT:27A9 DevSize         dw 0                    ; DATA XREF: MagicPreload+18↑r
SYSINIT:27A9                                         ; MagicPostload+15↑w ...
SYSINIT:27A9                                         ; size of the device driver being loaded (paras)
SYSINIT:27AB DevLoadAddr     dw 0                    ; DATA XREF: MagicPreload+14↑r
SYSINIT:27AB                                         ; MagicPostload+31↑r ...
SYSINIT:27AB                                         ; Mem addr where the device driver is 2 b loaded
SYSINIT:27AD DevLoadEnd      dw 0                    ; DATA XREF: MagicPreload+1F↑r
SYSINIT:27AD                                         ; MagicPreload+57↑r ...
SYSINIT:27AD                                         ; MaxAddr to which device can be loaded
SYSINIT:27AF DevEntry        dd 0                    ; DATA XREF: MagicPreload+32↑r
SYSINIT:27AF                                         ; MagicPreload+EF↑r ...
SYSINIT:27AF                                         ; Entry point to the device driver
SYSINIT:27B3 DevBrkAddr      dd 0                    ; DATA XREF: MagicPreload+A7↑w
SYSINIT:27B3                                         ; MagicPreload:_foundpb↑r ...
SYSINIT:27B3                                         ; Break address of the device driver
SYSINIT:27B7 ConvLoad        db 0                    ; DATA XREF: doconf+3BE↓w
SYSINIT:27B7                                         ; doconf+3D4↓w ...
SYSINIT:27B7                                         ; Use conventional (dos 5 style) InitDevLoad?
SYSINIT:27B8 DevUMB          db 0                    ; DATA XREF: doconf+36F↓r
SYSINIT:27B8                                         ; doconf+4B5↓r ...
SYSINIT:27B8                                         ; byte indicating whether to load DDs in UMBs
SYSINIT:27B9 DevUMBAddr      dw 0                    ; DATA XREF: InitDevLoad+36↓r
SYSINIT:27B9                                         ; SpaceInUMB+4↓r ...
SYSINIT:27B9                                         ; current UMB used for loading devices (paras)
SYSINIT:27BB DevUMBSize      dw 0                    ; DATA XREF: InitDevLoad+3B↓r
SYSINIT:27BB                                         ; SpaceInUMB↓r ...
SYSINIT:27BB                                         ; Size of the current UMB being used (paras)
SYSINIT:27BD DevUMBFree      dw 0                    ; DATA XREF: InitDevLoad:InitForHi↓r
SYSINIT:27BD                                         ; SpaceInUMB+9↓r ...
SYSINIT:27BD                                         ; Start of free mem blk in the current UMB (paras)
SYSINIT:27BF DevXMSAddr      dd 0                    ; DATA XREF: InitAllocUMB+13↓w
SYSINIT:27BF                                         ; umb_allocate+6↓r ...
SYSINIT:27C3 DevExecAddr     dw 0                    ; DATA XREF: ExecDev+5↓w
SYSINIT:27C3                                         ; ExecDev+13↓o
SYSINIT:27C3                                         ; Device load address parameter to Exec call
SYSINIT:27C5 DevExecReloc    dw 0                    ; DATA XREF: ExecDev+A↓w
SYSINIT:27C5                                         ; Device load relocation factor
SYSINIT:27C7 DeviceHi        db 0                    ; DATA XREF: MagicPreload+B↑w
SYSINIT:27C7                                         ; MagicPostload+19↑w ...
SYSINIT:27C7                                         ; Flag indicating whether the current device
SYSINIT:27C7                                         ; is being loaded into UMB
SYSINIT:27C8 DevSizeOption   dw 0                    ; DATA XREF: doconf:tryu_1↓r
SYSINIT:27C8                                         ; doconf+392↓w ...
SYSINIT:27C8                                         ; SIZE= option
SYSINIT:27CA Int12Lied       db 0                    ; DATA XREF: SetInt12Mem+16↓w
SYSINIT:27CA                                         ; TrueInt12Mem↓r ...
SYSINIT:27CA                                         ; did we trap int 12h ?
SYSINIT:27CB OldInt12Mem     dw 0                    ; DATA XREF: SetInt12Mem+A↓w
SYSINIT:27CB                                         ; TrueInt12Mem+14↓r
SYSINIT:27CB                                         ; value in 40:13h (int 12h ram)
SYSINIT:27CD ThreeComName    db 'PROTMAN$'           ; DATA XREF: IsIt3Com+D↓o
SYSINIT:27CD                                         ; 3Com Device name
SYSINIT:27D5 FirstUMBLinked  db 0                    ; DATA XREF: InitAllocUMB+1D↓r
SYSINIT:27D5                                         ; InitAllocUMB+2A↓w ...
SYSINIT:27D6 DevDOSData      dw 0                    ; DATA XREF: InitAllocUMB+9↓w
SYSINIT:27D6                                         ; umb_insert+1↓r ...
SYSINIT:27D6                                         ; segment of DOS Data
SYSINIT:27D8 DevCmdLine      dw 2 dup(0)             ; DATA XREF: doconf+3A9↓w
SYSINIT:27D8                                         ; ParseSize+A↓w ...
SYSINIT:27D8                                         ; Current Command line
SYSINIT:27DC DevSavedDelim   db 0                    ; DATA XREF: doconf:tryu_5↓w
SYSINIT:27DC                                         ; doconf+399↓w ...
SYSINIT:27DC                                         ; The delimiter which was replaced with null
SYSINIT:27DC                                         ; to use the file name in the command line
SYSINIT:27DD MagicHomeFlag   db 0                    ; DATA XREF: doconf:CheckDoubleSpace↓r
SYSINIT:27DD                                         ; doconf:set_magichomeflag↓w
SYSINIT:27DD                                         ; set non-zero when MagicDrv is final placed
SYSINIT:27DE
SYSINIT:27DE ; =============== S U B R O U T I N E =======================================
SYSINIT:27DE
SYSINIT:27DE
SYSINIT:27DE doconf          proc near               ; CODE XREF: SYSINIT:ProcessConfig↑p
SYSINIT:27DE
SYSINIT:27DE ; FUNCTION CHUNK AT SYSINIT:28A1 SIZE 0000003A BYTES
SYSINIT:27DE ; FUNCTION CHUNK AT SYSINIT:28EF SIZE 0000001D BYTES
SYSINIT:27DE ; FUNCTION CHUNK AT SYSINIT:290E SIZE 0000069F BYTES
SYSINIT:27DE ; FUNCTION CHUNK AT SYSINIT:2FC1 SIZE 00000317 BYTES
SYSINIT:27DE ; FUNCTION CHUNK AT SYSINIT:3326 SIZE 0000000C BYTES
SYSINIT:27DE
SYSINIT:27DE                 push    cs
SYSINIT:27DF                 pop     ds
SYSINIT:27E0                 assume ds:SYSINIT
SYSINIT:27E0                 mov     ax, 3700h       ; (CHAR_OPER<<8)
SYSINIT:27E3                 int     21h             ; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
SYSINIT:27E3                                         ; Return: AL = FFh unsupported subfunction
SYSINIT:27E3                                         ; DL = current switch character
SYSINIT:27E5                 mov     byte ptr command_line+1, dl ; "/P"
SYSINIT:27E9                 mov     def_swchr, dl   ; save default switchchar
SYSINIT:27ED                 mov     dx, offset config ; "\\CONFIG.SYS"
SYSINIT:27F0                 mov     ax, 3D00h       ; OPEN<<8
SYSINIT:27F3                 stc                     ; (in case of int 24h)
SYSINIT:27F4                 int     21h             ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
SYSINIT:27F4                                         ; DS:DX -> ASCIZ filename
SYSINIT:27F4                                         ; AL = access mode
SYSINIT:27F4                                         ; 0 - read
SYSINIT:27F6                 jnb     short noprob    ; brif opened okay
SYSINIT:27F6                                         ;
SYSINIT:27F6                                         ; config.sys file open error
SYSINIT:27F8                 call    kbd_read        ; we still want to give the guy
SYSINIT:27F8                                         ; a chance to select clean boot!
SYSINIT:27F8                                         ; (ie, no autoexec.bat processing)
SYSINIT:27FB                 mov     multi_pass_id, 11 ; set it to unreasonable number
SYSINIT:2800                 retn
SYSINIT:2801 ; ---------------------------------------------------------------------------
SYSINIT:2801
SYSINIT:2801 noprob:                                 ; CODE XREF: doconf+18↑j
SYSINIT:2801                 mov     bx, ax          ; get file size (note < 64k!!)
SYSINIT:2801                                         ; File handle
SYSINIT:2803                 xor     cx, cx
SYSINIT:2805                 xor     dx, dx
SYSINIT:2807                 mov     ax, 4202h       ; (LSEEK<<8)|2
SYSINIT:280A                 int     21h             ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
SYSINIT:280A                                         ; AL = method: offset from end of file
SYSINIT:280C                 mov     count, ax
SYSINIT:280F                 xor     dx, dx          ; reset pointer to beginning of file
SYSINIT:2811                 mov     ax, 4200h
SYSINIT:2814                 int     21h             ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
SYSINIT:2814                                         ; AL = method: offset from beginning of file
SYSINIT:2816                 mov     dx, ALLOCLIM    ; use current alloclim value
SYSINIT:281A                 mov     ax, count
SYSINIT:281D                 mov     config_size, ax ; save the size of config.sys file.
SYSINIT:2820                 call    ParaRound
SYSINIT:2823                 sub     dx, ax
SYSINIT:2825                 dec     dx              ; reserve 1 additional paragraph
SYSINIT:2826                 mov     config_wrkseg, dx ; this is the segment to be used for
SYSINIT:282A                 sub     dx, ax          ; rebuilding the config.sys memory image
SYSINIT:282C                 sub     dx, 11h         ; room for header
SYSINIT:282F                 mov     ALLOCLIM, dx    ; config starts here. new alloclim value.
SYSINIT:2833                 mov     CONFBOT, dx
SYSINIT:2837                 mov     ds, dx
SYSINIT:2839                 assume ds:nothing
SYSINIT:2839                 mov     es, dx
SYSINIT:283B                 xor     dx, dx
SYSINIT:283D                 mov     cx, cs:count
SYSINIT:2842                 mov     ah, 3Fh
SYSINIT:2844                 stc                     ; (in case of int 24h)
SYSINIT:2845                 int     21h             ; DOS - 2+ - READ FROM FILE WITH HANDLE
SYSINIT:2845                                         ; BX = file handle, CX = number of bytes to read
SYSINIT:2845                                         ; DS:DX -> buffer
SYSINIT:2847                 pushf
SYSINIT:2848                 push    ax              ; find the eof mark in the file.
SYSINIT:2848                                         ; if present,then trim length.
SYSINIT:2849                 push    di
SYSINIT:284A                 push    cx
SYSINIT:284B                 mov     al, 1Ah         ; eof mark
SYSINIT:284D                 mov     di, dx          ; point to buffer
SYSINIT:284F                 jcxz    short puteol    ; no chars
SYSINIT:2851                 repne scasb             ; find end
SYSINIT:2853                 jnz     short puteol    ; none found and count exhausted
SYSINIT:2855                 dec     di              ; backup past 1Ah
SYSINIT:2856
SYSINIT:2856 puteol:                                 ; CODE XREF: doconf+71↑j
SYSINIT:2856                                         ; doconf+75↑j
SYSINIT:2856                 mov     al, 0Dh         ; cr,lf
SYSINIT:2858                 stosb
SYSINIT:2859                 mov     al, 0Ah
SYSINIT:285B                 stosb
SYSINIT:285C                 sub     di, dx          ; difference moved
SYSINIT:285E                 mov     cs:count, di    ; new count
SYSINIT:2863                 pop     cx
SYSINIT:2864                 pop     di
SYSINIT:2865                 pop     ax
SYSINIT:2866                 push    cs
SYSINIT:2867                 pop     ds
SYSINIT:2868                 assume ds:SYSINIT
SYSINIT:2868                 push    ax
SYSINIT:2869                 mov     ah, 3Eh
SYSINIT:286B                 int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
SYSINIT:286B                                         ; BX = file handle
SYSINIT:286D                 pop     ax
SYSINIT:286E                 popf
SYSINIT:286F                 jb      short conferr   ; we've got a problem
SYSINIT:2871                 cmp     cx, ax
SYSINIT:2873                 jz      short getcom    ; if ax <(>) cx
SYSINIT:2873                                         ; couldn't read the file
SYSINIT:2875
SYSINIT:2875 conferr:                                ; CODE XREF: doconf+91↑j
SYSINIT:2875                 mov     dx, offset config ; "\\CONFIG.SYS"
SYSINIT:2878                 call    badfil          ; print config error
SYSINIT:287B
SYSINIT:287B endconv:                                ; CODE XREF: multi_pass:jae_endconv↓j
SYSINIT:287B                                         ; doconf:conflp↓j
SYSINIT:287B                 retn
SYSINIT:287B doconf          endp
SYSINIT:287B
SYSINIT:287C
SYSINIT:287C ; =============== S U B R O U T I N E =======================================
SYSINIT:287C
SYSINIT:287C
SYSINIT:287C multi_pass      proc near               ; CODE XREF: SYSINIT:086A↑p
SYSINIT:287C                                         ; SYSINIT:0878↑p ...
SYSINIT:287C                 push    cs
SYSINIT:287D                 pop     ds
SYSINIT:287E                 cmp     multi_pass_id, 10 ; do nothing. just return.
SYSINIT:2883
SYSINIT:2883 jae_endconv:                            ; CODE XREF: doconf+11D↓j
SYSINIT:2883                 jnb     short endconv
SYSINIT:2885                 push    CONFBOT
SYSINIT:2889                 pop     es              ; es = [confbot] (CONFIG.SYS image seg)
SYSINIT:288A                 mov     si, org_count
SYSINIT:288E                 mov     count, si       ; set count
SYSINIT:2892                 xor     si, si          ; 0
SYSINIT:2894                 mov     chrptr, si      ; reset chrptr
SYSINIT:2898                 mov     linecount, si   ; reset linecount
SYSINIT:289C                 call    getchr
SYSINIT:289F                 jmp     short conflp
SYSINIT:289F multi_pass      endp
SYSINIT:289F
SYSINIT:28A1 ; ---------------------------------------------------------------------------
SYSINIT:28A1 ; START OF FUNCTION CHUNK FOR doconf
SYSINIT:28A1
SYSINIT:28A1 getcom:                                 ; CODE XREF: doconf+95↑j
SYSINIT:28A1                 call    organize        ; organize the file
SYSINIT:28A4                 call    getchr
SYSINIT:28A7
SYSINIT:28A7 conflp:                                 ; CODE XREF: multi_pass+23↑j
SYSINIT:28A7                                         ; doconf+127↓j ...
SYSINIT:28A7                 jb      short endconv
SYSINIT:28A9                 inc     linecount       ; increase linecount
SYSINIT:28AD                 mov     multdeviceflag, 0 ; reset multdeviceflag.
SYSINIT:28B2                 mov     setdevmarkflag, 0 ; reset setdevmarkflag.
SYSINIT:28B7                 cmp     al, 0Ah         ; lf ; linefeed?
SYSINIT:28B9                 jz      short blank_line ; then ignore this line.
SYSINIT:28B9                                         ;
SYSINIT:28B9                                         ; If this is a genuine CONFIG.SYS command,
SYSINIT:28B9                                         ; then there should be a line number
SYSINIT:28B9                                         ; immediately following it
SYSINIT:28BB                 mov     config_cmd, al  ; save original command code
SYSINIT:28BE                 and     al, 7Fh         ; ~CONFIG_OPTION_QUERY
SYSINIT:28C0                 cmp     config_multi, 0 ; is this a multi-config config.sys?
SYSINIT:28C5                 jz      short not_final ; no, line number is not embedded
SYSINIT:28C7                 push    ax
SYSINIT:28C8                 call    getchr          ; ignore end-of-image errors
SYSINIT:28CB                 mov     ah, al          ; because if there's an error
SYSINIT:28CD                 call    getchr          ; fetching the line number that's
SYSINIT:28D0                 xchg    al, ah          ; supposed to be there, the next
SYSINIT:28D2                 mov     linecount, ax   ; getchr call will get the same error
SYSINIT:28D5                 pop     ax
SYSINIT:28D6                 cmp     multi_pass_id, 2 ; final pass?
SYSINIT:28D6 ; END OF FUNCTION CHUNK FOR doconf
SYSINIT:28DB                 jb      short not_final ; no
SYSINIT:28DD                 test    install_flag, 1 ; DATA XREF: MSLOAD:00E7↑r
SYSINIT:28DD                                         ; MSLOAD:not_fat32↑r ...
SYSINIT:28DD                                         ; have_install_cmd
SYSINIT:28DD                                         ; are there install commands?
SYSINIT:28E3                 jz      short final     ; no install cmds, yes it is
SYSINIT:28E5                 cmp     multi_pass_id, 3
SYSINIT:28E5                                         ; DATA XREF: MSLOAD:00C0↑r
SYSINIT:28E5                                         ; MSLOAD:00AE↑r
SYSINIT:28E5                                         ; final pass?
SYSINIT:28EA                 jb      short not_final ; no
SYSINIT:28EC
SYSINIT:28EC final:                                  ; CODE XREF: SYSINIT:28E3↑j
SYSINIT:28EC                                         ; DATA XREF: MSLOAD:00F0↑r ...
SYSINIT:28EC                 mov     es:[si], al     ; save backward-compatible command code
SYSINIT:28EF ; START OF FUNCTION CHUNK FOR doconf
SYSINIT:28EF
SYSINIT:28EF not_final:                              ; CODE XREF: doconf+E7↑j
SYSINIT:28EF                                         ; SYSINIT:28DB↑j ...
SYSINIT:28EF                 mov     ah, al
SYSINIT:28F1                 call    getchr          ; DATA XREF: MSLOAD:011E↑r
SYSINIT:28F4                 jnb     short tryi
SYSINIT:28F6                 cmp     multi_pass_id, 2
SYSINIT:28FB                 jnb     short jae_endconv ; it would be 'jnb short endconv'
SYSINIT:28FB                                         ; (E.TAN - 09/07/2023)
SYSINIT:28FB                                         ; do not show badop again for multi_pass.
SYSINIT:28FD                 jmp     badop
SYSINIT:2900 ; ---------------------------------------------------------------------------
SYSINIT:2900
SYSINIT:2900 coff:                                   ; CODE XREF: doconf:multi_pass_coff2↓j
SYSINIT:2900                                         ; doconf+163↓j ...
SYSINIT:2900                 push    cs
SYSINIT:2901                 pop     ds
SYSINIT:2902                 call    newline
SYSINIT:2905                 jmp     short conflp
SYSINIT:2907 ; ---------------------------------------------------------------------------
SYSINIT:2907
SYSINIT:2907 blank_line:                             ; CODE XREF: doconf+DB↑j
SYSINIT:2907                 call    getchr
SYSINIT:290A                 jmp     short conflp
SYSINIT:290A ; END OF FUNCTION CHUNK FOR doconf
SYSINIT:290C ; ---------------------------------------------------------------------------
SYSINIT:290C                 push    cs
SYSINIT:290D                 pop     ds
SYSINIT:290E ; START OF FUNCTION CHUNK FOR doconf
SYSINIT:290E
SYSINIT:290E tryi:                                   ; CODE XREF: doconf+116↑j
SYSINIT:290E                                         ; DATA XREF: MSLOAD:00D1↑r
SYSINIT:290E                 cmp     multi_pass_id, 0 ; the initial pass for DOS=HI
SYSINIT:2913                 jnz     short not_init_pass
SYSINIT:2915                 jmp     multi_try_doshi
SYSINIT:2918 ; ---------------------------------------------------------------------------
SYSINIT:2918
SYSINIT:2918 not_init_pass:                          ; CODE XREF: doconf+135↑j
SYSINIT:2918                 cmp     multi_pass_id, 2 ; the second pass was for ifs=
SYSINIT:291D                 jz      short multi_pass_coff2 ; now it is NOPs
SYSINIT:291D                                         ;
SYSINIT:291D                                         ; This pass can be made use of if
SYSINIT:291D                                         ; we want do some config.sys process
SYSINIT:291D                                         ; after device drivers are loaded and
SYSINIT:291D                                         ; before install= commands are processed
SYSINIT:291F                 cmp     multi_pass_id, 3 ; the third pass for install= ?
SYSINIT:2924                 jz      short multi_try_i
SYSINIT:2926                 cmp     ah, 48h ; 'H'   ; CONFIG_DOS
SYSINIT:2929                 jz      short multi_pass_coff2
SYSINIT:292B                 cmp     ah, 49h ; 'I'   ; CONFIG_INSTALL ; install= command?
SYSINIT:292E                 jnz     short precheck_installhigh ;
SYSINIT:292E                                         ; the first pass is for normal operation.
SYSINIT:2930                 or      install_flag, 1 ; have_install_cmd ; set the flag
SYSINIT:2935
SYSINIT:2935 multi_pass_coff2:                       ; CODE XREF: doconf+13F↑j
SYSINIT:2935                                         ; doconf+14B↑j
SYSINIT:2935                 jmp     short coff      ; and handles the next command
SYSINIT:2937 ; ---------------------------------------------------------------------------
SYSINIT:2937
SYSINIT:2937 precheck_installhigh:                   ; CODE XREF: doconf+150↑j
SYSINIT:2937                 cmp     ah, 57h ; 'W'   ; CONFIG_INSTALLHIGH ; signifier for INSTALLHIGH
SYSINIT:293A                 jnz     short tryb      ; carry on with normal processing
SYSINIT:293C                 or      install_flag, 1 ; have_install_cmd
SYSINIT:2941                 jmp     short coff
SYSINIT:2943 ; ---------------------------------------------------------------------------
SYSINIT:2943
SYSINIT:2943 multi_try_i:                            ; CODE XREF: doconf+146↑j
SYSINIT:2943                 cmp     ah, 49h ; 'I'   ; CONFIG_INSTALL ; install= command?
SYSINIT:2946                 jnz     short multi_try_n ; no, check for installhigh
SYSINIT:2948                 call    query_user      ; query the user if config_cmd
SYSINIT:294B                 jb      short multi_pass_filter ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:294D                 call    do_install_exec ; install it.
SYSINIT:2950                 jmp     short coff      ; to handle next install= command.
SYSINIT:2952 ; ---------------------------------------------------------------------------
SYSINIT:2952
SYSINIT:2952 multi_try_n:                            ; CODE XREF: doconf+168↑j
SYSINIT:2952                 cmp     ah, 57h ; 'W'   ; CONFIG_INSTALLHIGH ; installhigh= command?
SYSINIT:2955                 jnz     short multi_pass_filter
SYSINIT:2957                 call    query_user      ; query the user if config_cmd
SYSINIT:295A                 jb      short multi_pass_filter ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:295C                 mov     ax, 5800h
SYSINIT:295F                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:295F                                         ; AL = function code: get allocation strategy
SYSINIT:2961                 mov     bx, ax
SYSINIT:2963                 push    bx              ; save for the return
SYSINIT:2964                 or      bx, 80h         ; HIGH_FIRST ; set alloc to HighFirst
SYSINIT:2968                 mov     ax, 5801h       ; (ALLOCOPER<<8)|1
SYSINIT:296B                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:296B                                         ; AL = function code: set allocation strategy
SYSINIT:296D                 mov     ax, 5802h
SYSINIT:2970                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:2970                                         ; AL = function code: (DOS 5beta) get UMB link state
SYSINIT:2972                 xor     ah, ah
SYSINIT:2974                 push    ax              ; save for the return
SYSINIT:2975                 mov     ax, 5803h       ; (ALLOCOPER<<8)|3
SYSINIT:2978                 mov     bx, 1           ; link in UMBs
SYSINIT:297B                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:297B                                         ; AL = function code: (DOS 5beta) set UMB link state
SYSINIT:297D                 call    do_install_exec ; install it.
SYSINIT:2980                 mov     ax, 5803h
SYSINIT:2983                 pop     bx              ; recover original link state
SYSINIT:2984                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:2984                                         ; AL = function code: (DOS 5beta) set UMB link state
SYSINIT:2986                 pop     bx              ; recover original alloc strategy
SYSINIT:2987                 mov     ax, 5801h
SYSINIT:298A                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:298A                                         ; AL = function code: set allocation strategy
SYSINIT:298C                 jmp     coff            ; to handle next install= commands.
SYSINIT:298F ; ---------------------------------------------------------------------------
SYSINIT:298F
SYSINIT:298F multi_pass_filter:                      ; CODE XREF: doconf+16D↑j
SYSINIT:298F                                         ; doconf+177↑j ...
SYSINIT:298F                 cmp     ah, 59h ; 'Y'   ; CONFIG_COMMENT ; comment?
SYSINIT:2992                 jz      short multi_pass_adjust
SYSINIT:2994                 cmp     ah, 5Ah ; 'Z'   ; CONFIG_UNKNOWN ; bad command?
SYSINIT:2997                 jz      short multi_pass_adjust
SYSINIT:2999                 cmp     ah, 30h ; '0'   ; CONFIG_REM ; rem?
SYSINIT:299C                 jnz     short multi_pass_coff ; ignore the rest of the commands.
SYSINIT:299E
SYSINIT:299E multi_pass_adjust:                      ; CODE XREF: doconf+1B4↑j
SYSINIT:299E                                         ; doconf+1B9↑j
SYSINIT:299E                 dec     chrptr          ; these commands need to
SYSINIT:299E                                         ; adjust chrptr,count
SYSINIT:29A2                 inc     count           ; for newline proc.
SYSINIT:29A6
SYSINIT:29A6 multi_pass_coff:                        ; CODE XREF: doconf+1BE↑j
SYSINIT:29A6                 jmp     coff            ; to handle next install= commands.
SYSINIT:29A9 ; ---------------------------------------------------------------------------
SYSINIT:29A9
SYSINIT:29A9 tryb:                                   ; CODE XREF: doconf+15C↑j
SYSINIT:29A9                 cmp     ah, 42h ; 'B'   ; CONFIG_BUFFERS
SYSINIT:29AC                 jnz     short tryc
SYSINIT:29AE                 call    query_user      ; query the user if config_cmd
SYSINIT:29AE                                         ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:29B1                 jb      short tryc
SYSINIT:29B3                 mov     p_buffer_slash_x, 0
SYSINIT:29B8                 mov     di, offset buf_parms
SYSINIT:29BB                 xor     cx, cx
SYSINIT:29BD                 mov     dx, cx
SYSINIT:29BF
SYSINIT:29BF do7:                                    ; CODE XREF: doconf:en11↓j
SYSINIT:29BF                 call    sysinit_parse
SYSINIT:29C2                 jnb     short if7       ;
SYSINIT:29C2                                         ; parse error,
SYSINIT:29C2                                         ; and show messages and end the search
SYSINIT:29C4                 call    badparm_p
SYSINIT:29C7                 jmp     short sr7
SYSINIT:29C9 ; ---------------------------------------------------------------------------
SYSINIT:29C9
SYSINIT:29C9 if7:                                    ; CODE XREF: doconf+1E4↑j
SYSINIT:29C9                 cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
SYSINIT:29CC                 jz      short en7       ; then jmp to $endloop for semantic check
SYSINIT:29CE                 cmp     result_val_swoff, offset switch_x ; (/X switch)
SYSINIT:29CE                                         ; [result_val+_$P_Result_Blk.SYNONYM_Ptr]
SYSINIT:29D4                 jnz     short if11
SYSINIT:29D6                 jmp     short en11
SYSINIT:29D8 ; ---------------------------------------------------------------------------
SYSINIT:29D8
SYSINIT:29D8 if11:                                   ; CODE XREF: doconf+1F6↑j
SYSINIT:29D8                 mov     ax, word ptr rv_dword ; [result_val+_$P_Result_Blk.Picked_Val]
SYSINIT:29DB                 cmp     cx, 1
SYSINIT:29DE                 jnz     short if13
SYSINIT:29E0                 mov     p_buffers, ax
SYSINIT:29E3                 jmp     short en11
SYSINIT:29E5 ; ---------------------------------------------------------------------------
SYSINIT:29E5
SYSINIT:29E5 if13:                                   ; CODE XREF: doconf+200↑j
SYSINIT:29E5                 mov     p_h_buffers, ax
SYSINIT:29E8
SYSINIT:29E8 en11:                                   ; CODE XREF: doconf+1F8↑j
SYSINIT:29E8                                         ; doconf+205↑j
SYSINIT:29E8                 jmp     short do7
SYSINIT:29EA ; ---------------------------------------------------------------------------
SYSINIT:29EA
SYSINIT:29EA en7:                                    ; CODE XREF: doconf+1EE↑j
SYSINIT:29EA                 cmp     p_buffers, 99
SYSINIT:29EF                 jbe     short if18
SYSINIT:29F1                 call    badparm_p
SYSINIT:29F4                 mov     p_h_buffers, 0
SYSINIT:29FA                 jmp     short sr7
SYSINIT:29FC ; ---------------------------------------------------------------------------
SYSINIT:29FC
SYSINIT:29FC if18:                                   ; CODE XREF: doconf+211↑j
SYSINIT:29FC                 mov     ax, p_buffers   ; we don't have any problem.
SYSINIT:29FF                 mov     buffers, ax     ; now,let's set it really.
SYSINIT:2A02                 mov     ax, p_h_buffers
SYSINIT:2A05                 mov     h_buffers, ax
SYSINIT:2A08                 mov     ax, linecount
SYSINIT:2A0B                 mov     buffer_linenum, ax ; save the line number
SYSINIT:2A0B                                         ; for the future use
SYSINIT:2A0E
SYSINIT:2A0E sr7:                                    ; CODE XREF: doconf+1E9↑j
SYSINIT:2A0E                                         ; doconf+21C↑j
SYSINIT:2A0E                 jmp     coff
SYSINIT:2A11 ; ---------------------------------------------------------------------------
SYSINIT:2A11
SYSINIT:2A11 tryc:                                   ; CODE XREF: doconf+1CE↑j
SYSINIT:2A11                                         ; doconf+1D3↑j
SYSINIT:2A11                 cmp     ah, 43h ; 'C'   ; CONFIG_BREAK
SYSINIT:2A14                 jnz     short trym
SYSINIT:2A16                 call    query_user      ; query the user if config_cmd
SYSINIT:2A16                                         ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2A19                 jb      short trym
SYSINIT:2A1B                 mov     di, offset brk_parms
SYSINIT:2A1E                 xor     cx, cx
SYSINIT:2A20                 mov     dx, cx
SYSINIT:2A22
SYSINIT:2A22 do22:                                   ; CODE XREF: doconf:en26↓j
SYSINIT:2A22                 call    sysinit_parse
SYSINIT:2A25                 jnb     short if22      ;
SYSINIT:2A25                                         ; parse error
SYSINIT:2A27                 call    badparm_p
SYSINIT:2A2A                 jmp     short sr22
SYSINIT:2A2C ; ---------------------------------------------------------------------------
SYSINIT:2A2C
SYSINIT:2A2C if22:                                   ; CODE XREF: doconf+247↑j
SYSINIT:2A2C                 cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
SYSINIT:2A2F                 jz      short en22      ; then end the $endloop
SYSINIT:2A31                 cmp     result_val_itag, 1 ; [result_val+_$P_Result_Blk.Item_Tag]
SYSINIT:2A36                 jnz     short if26
SYSINIT:2A38                 mov     p_ctrl_break, 1 ; turn it on
SYSINIT:2A3D                 jmp     short en26
SYSINIT:2A3F ; ---------------------------------------------------------------------------
SYSINIT:2A3F
SYSINIT:2A3F if26:                                   ; CODE XREF: doconf+258↑j
SYSINIT:2A3F                 mov     p_ctrl_break, 0 ; turn it off
SYSINIT:2A44
SYSINIT:2A44 en26:                                   ; CODE XREF: doconf+25F↑j
SYSINIT:2A44                 jmp     short do22      ; we actually set the ctrl break
SYSINIT:2A46 ; ---------------------------------------------------------------------------
SYSINIT:2A46
SYSINIT:2A46 en22:                                   ; CODE XREF: doconf+251↑j
SYSINIT:2A46                 mov     ah, 33h         ; SET_CTRL_C_TRAPPING
SYSINIT:2A46                                         ; if we don't have any parse error.
SYSINIT:2A48                 mov     al, 1
SYSINIT:2A4A                 mov     dl, p_ctrl_break
SYSINIT:2A4E                 int     21h             ; DOS - EXTENDED CONTROL-BREAK CHECKING
SYSINIT:2A4E                                         ; AL = 00h get state / 01h set state / 02h set AND get
SYSINIT:2A4E                                         ; DL = 00h for OFF or 01h for ON
SYSINIT:2A50
SYSINIT:2A50 sr22:                                   ; CODE XREF: doconf+24C↑j
SYSINIT:2A50                 jmp     coff
SYSINIT:2A53 ; ---------------------------------------------------------------------------
SYSINIT:2A53
SYSINIT:2A53 trym:                                   ; CODE XREF: doconf+236↑j
SYSINIT:2A53                                         ; doconf+23B↑j
SYSINIT:2A53                 cmp     ah, 4Dh ; 'M'   ; CONFIG_MULTITRACK
SYSINIT:2A56                 jnz     short tryu
SYSINIT:2A58                 call    query_user      ; query the user if config_cmd
SYSINIT:2A58                                         ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2A5B                 jb      short tryu
SYSINIT:2A5D                 mov     di, offset mtrk_parms
SYSINIT:2A60                 xor     cx, cx
SYSINIT:2A62                 mov     dx, cx
SYSINIT:2A64
SYSINIT:2A64 do31:                                   ; CODE XREF: doconf:en35↓j
SYSINIT:2A64                 call    sysinit_parse
SYSINIT:2A67                 jnb     short if31      ;
SYSINIT:2A67                                         ; parse_error
SYSINIT:2A69                 call    badparm_p       ; show message and end the search loop.
SYSINIT:2A6C                 jmp     short sr31
SYSINIT:2A6E ; ---------------------------------------------------------------------------
SYSINIT:2A6E
SYSINIT:2A6E if31:                                   ; CODE XREF: doconf+289↑j
SYSINIT:2A6E                 cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
SYSINIT:2A71                 jz      short en31
SYSINIT:2A73                 cmp     result_val_itag, 1 ; [result_val+_$P_Result_Blk.Item_Tag]
SYSINIT:2A78                 jnz     short if35
SYSINIT:2A7A                 mov     p_mtrk, 1       ; turn it on temporarily.
SYSINIT:2A7F                 jmp     short en35
SYSINIT:2A81 ; ---------------------------------------------------------------------------
SYSINIT:2A81
SYSINIT:2A81 if35:                                   ; CODE XREF: doconf+29A↑j
SYSINIT:2A81                 mov     p_mtrk, 0       ; turn it off temporarily.
SYSINIT:2A86
SYSINIT:2A86 en35:                                   ; CODE XREF: doconf+2A1↑j
SYSINIT:2A86                 jmp     short do31      ; we actually set the multrk_flag here
SYSINIT:2A88 ; ---------------------------------------------------------------------------
SYSINIT:2A88
SYSINIT:2A88 en31:                                   ; CODE XREF: doconf+293↑j
SYSINIT:2A88                 push    ds
SYSINIT:2A89                 mov     ax, 70h         ; DOSBIODATASEG ; BIOSDATA segment
SYSINIT:2A8C                 mov     ds, ax
SYSINIT:2A8E                 assume ds:nothing
SYSINIT:2A8E                 cmp     cs:p_mtrk, 0
SYSINIT:2A94                 jnz     short if39
SYSINIT:2A96                 mov     ds:multrk_flag, 1 ; multrk_off2
SYSINIT:2A9C                 jmp     short en39
SYSINIT:2A9E ; ---------------------------------------------------------------------------
SYSINIT:2A9E
SYSINIT:2A9E if39:                                   ; CODE XREF: doconf+2B6↑j
SYSINIT:2A9E                 mov     ds:multrk_flag, 80h ; multrk_on
SYSINIT:2AA4
SYSINIT:2AA4 en39:                                   ; CODE XREF: doconf+2BE↑j
SYSINIT:2AA4                 pop     ds
SYSINIT:2AA5                 assume ds:nothing
SYSINIT:2AA5
SYSINIT:2AA5 sr31:                                   ; CODE XREF: doconf+28E↑j
SYSINIT:2AA5                 jmp     coff
SYSINIT:2AA8 ; ---------------------------------------------------------------------------
SYSINIT:2AA8
SYSINIT:2AA8 multi_try_doshi:                        ; CODE XREF: doconf+137↑j
SYSINIT:2AA8                 cmp     ah, 48h ; 'H'   ; CONFIG_DOS
SYSINIT:2AAB                 jz      short it_is_h
SYSINIT:2AAD
SYSINIT:2AAD skip_it:                                ; CODE XREF: doconf+2D5↓j
SYSINIT:2AAD                 jmp     multi_pass_filter
SYSINIT:2AB0 ; ---------------------------------------------------------------------------
SYSINIT:2AB0
SYSINIT:2AB0 it_is_h:                                ; CODE XREF: doconf+2CD↑j
SYSINIT:2AB0                 call    query_user      ; query the user if config_cmd
SYSINIT:2AB0                                         ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2AB3                 jb      short skip_it
SYSINIT:2AB5                 mov     di, offset dos_parms
SYSINIT:2AB8                 xor     cx, cx
SYSINIT:2ABA                 mov     dx, cx
SYSINIT:2ABC
SYSINIT:2ABC h_do_parse:                             ; CODE XREF: doconf+2F0↓j
SYSINIT:2ABC                 call    sysinit_parse
SYSINIT:2ABF                 jnb     short h_parse_ok
SYSINIT:2AC1
SYSINIT:2AC1 h_badparm:                              ; parse error
SYSINIT:2AC1                 call    badparm_p       ; show message and end the search loop.
SYSINIT:2AC4                 jmp     short h_end
SYSINIT:2AC6 ; ---------------------------------------------------------------------------
SYSINIT:2AC6
SYSINIT:2AC6 h_parse_ok:                             ; CODE XREF: doconf+2E1↑j
SYSINIT:2AC6                 cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
SYSINIT:2AC9                 jz      short h_end     ; then end the $endloop
SYSINIT:2ACB                 call    ProcDOS
SYSINIT:2ACE                 jmp     short h_do_parse
SYSINIT:2AD0 ; ---------------------------------------------------------------------------
SYSINIT:2AD0
SYSINIT:2AD0 h_end:                                  ; CODE XREF: doconf+2E6↑j
SYSINIT:2AD0                                         ; doconf+2EB↑j
SYSINIT:2AD0                 jmp     coff
SYSINIT:2AD3 ; ---------------------------------------------------------------------------
SYSINIT:2AD3
SYSINIT:2AD3 tryu:                                   ; CODE XREF: doconf+278↑j
SYSINIT:2AD3                                         ; doconf+27D↑j
SYSINIT:2AD3                 cmp     ah, 'U'         ; CONFIG_DEVICEHIGH
SYSINIT:2AD6                 jz      short tryu_0
SYSINIT:2AD8                 jmp     tryd
SYSINIT:2ADB ; ---------------------------------------------------------------------------
SYSINIT:2ADB
SYSINIT:2ADB tryu_0:                                 ; CODE XREF: doconf+2F8↑j
SYSINIT:2ADB                 call    query_user      ; query the user if config_cmd
SYSINIT:2ADB                                         ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2ADE                 jb      short tryd
SYSINIT:2AE0                 call    InitVar
SYSINIT:2AE3                 call    ParseSize       ; process the size= option
SYSINIT:2AE6                 jnb     short tryu_1    ;
SYSINIT:2AE6                                         ; stash it there in case of an error
SYSINIT:2AE8                 mov     word ptr cs:badparm_ptr, si
SYSINIT:2AED                 mov     word ptr cs:badparm_ptr+2, es
SYSINIT:2AF2                 call    badparm_p
SYSINIT:2AF5                 jmp     coff
SYSINIT:2AF8 ; ---------------------------------------------------------------------------
SYSINIT:2AF8
SYSINIT:2AF8 tryu_1:                                 ; CODE XREF: doconf+308↑j
SYSINIT:2AF8                 mov     ax, cs:DevSizeOption
SYSINIT:2AFC                 or      ax, ax
SYSINIT:2AFE                 jnz     short tryu_2
SYSINIT:2B00                 call    ParseVar
SYSINIT:2B03                 jnb     short tryu_2
SYSINIT:2B05                 mov     word ptr cs:badparm_ptr, si ;
SYSINIT:2B05                                         ; If ParseVar up there failed, then
SYSINIT:2B05                                         ; ES:SI points to its problem area..
SYSINIT:2B0A                 mov     word ptr cs:badparm_ptr+2, es
SYSINIT:2B0F                 call    badparm_p       ; so all we have to do is choke and
SYSINIT:2B0F                                         ; die, rather verbosely.
SYSINIT:2B12                 jmp     coff
SYSINIT:2B15 ; ---------------------------------------------------------------------------
SYSINIT:2B15
SYSINIT:2B15 tryu_2:                                 ; CODE XREF: doconf+320↑j
SYSINIT:2B15                                         ; doconf+325↑j
SYSINIT:2B15                 push    si
SYSINIT:2B16                 push    es
SYSINIT:2B17
SYSINIT:2B17 tryu_3:                                 ; CODE XREF: doconf+34A↓j
SYSINIT:2B17                 mov     al, es:[si]
SYSINIT:2B1A                 cmp     al, 0Dh         ; cr
SYSINIT:2B1C                 jz      short tryu_4    ; (_tryu_4) (*)
SYSINIT:2B1E                 cmp     al, 0Ah         ; lf
SYSINIT:2B20                 jz      short tryu_4    ; (*) this would be 'jz short tryu_5'
SYSINIT:2B20                                         ; Erdogan Tan - 10/07/2023
SYSINIT:2B22                 call    delim
SYSINIT:2B25                 jz      short tryu_4    ; (*) al <> cr
SYSINIT:2B25                                         ;     this would be 'jz short tryu_5'
SYSINIT:2B27                 inc     si
SYSINIT:2B28                 jmp     short tryu_3
SYSINIT:2B2A ; ---------------------------------------------------------------------------
SYSINIT:2B2A
SYSINIT:2B2A tryu_4:                                 ; CODE XREF: doconf+33E↑j
SYSINIT:2B2A                                         ; doconf+342↑j ...
SYSINIT:2B2A                 cmp     al, 0Dh         ; (*) cr ? (this 2nd check woul not be
SYSINIT:2B2A                                         ; needed because al value would be 0Dh here)
SYSINIT:2B2C                 jnz     short tryu_5
SYSINIT:2B2E
SYSINIT:2B2E _tryu_4:                                ;
SYSINIT:2B2E                 mov     al, 20h ; ' '   ; blank instead of cr
SYSINIT:2B30
SYSINIT:2B30 tryu_5:                                 ; CODE XREF: doconf+34E↑j
SYSINIT:2B30                 mov     cs:DevSavedDelim, al ; Save the delimiter
SYSINIT:2B30                                         ; before replacing it with null
SYSINIT:2B34                 mov     byte ptr es:[si], 0
SYSINIT:2B38                 pop     es
SYSINIT:2B39                 pop     si
SYSINIT:2B3A                 call    UmbTest         ; See if UMBs are around...
SYSINIT:2B3D                 jnb     short NrmTst    ; yep. So do that normal thang.
SYSINIT:2B3F                 mov     cs:DeviceHi, 0  ; nope... so load low.
SYSINIT:2B45                 jmp     short LoadDevice
SYSINIT:2B47 ; ---------------------------------------------------------------------------
SYSINIT:2B47
SYSINIT:2B47 NrmTst:                                 ; CODE XREF: doconf+35F↑j
SYSINIT:2B47                 mov     cs:DeviceHi, 0
SYSINIT:2B4D                 cmp     cs:DevUMB, 0    ; do we support UMBs ?
SYSINIT:2B53                 jz      short LoadDevice ; no, we don't
SYSINIT:2B55                 mov     cs:DeviceHi, 1
SYSINIT:2B5B                 jmp     short LoadDevice
SYSINIT:2B5D ; ---------------------------------------------------------------------------
SYSINIT:2B5D
SYSINIT:2B5D tryd:                                   ; CODE XREF: doconf+2FA↑j
SYSINIT:2B5D                                         ; doconf+300↑j
SYSINIT:2B5D                 cmp     ah, 44h ; 'D'   ; CONFIG_DEVICE
SYSINIT:2B60                 jz      short gotd
SYSINIT:2B62
SYSINIT:2B62 skip_it2:                               ; CODE XREF: doconf+38A↓j
SYSINIT:2B62                 jmp     tryq
SYSINIT:2B65 ; ---------------------------------------------------------------------------
SYSINIT:2B65
SYSINIT:2B65 gotd:                                   ; CODE XREF: doconf+382↑j
SYSINIT:2B65                 call    query_user      ; query the user if config_cmd
SYSINIT:2B65                                         ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2B68                 jb      short skip_it2
SYSINIT:2B6A                 mov     cs:DeviceHi, 0  ; not to be loaded in UMB
SYSINIT:2B70                 mov     cs:DevSizeOption, 0
SYSINIT:2B77                 mov     cs:DevSavedDelim, 20h ; ' ' ; In case of DEVICE=
SYSINIT:2B77                                         ; the null has to be replaced with a ' '
SYSINIT:2B7D
SYSINIT:2B7D LoadDevice:                             ; CODE XREF: doconf+367↑j
SYSINIT:2B7D                                         ; doconf+375↑j ...
SYSINIT:2B7D                 push    cs
SYSINIT:2B7E                 pop     ds
SYSINIT:2B7F                 assume ds:SYSINIT
SYSINIT:2B7F                 mov     word ptr bpb_addr, si ;
SYSINIT:2B7F                                         ; pass the command line to the device
SYSINIT:2B83                 mov     word ptr bpb_addr+2, es
SYSINIT:2B87                 mov     DevCmdLine, si  ; save it for ourself
SYSINIT:2B8B                 mov     DevCmdLine+2, es
SYSINIT:2B8F                 mov     drivers_units, 0 ; clear total block units for driver
SYSINIT:2B94                 call    round
SYSINIT:2B97                 call    SizeDevice
SYSINIT:2B9A                 jb      short BadFile
SYSINIT:2B9C                 mov     ConvLoad, 1     ; Doesn't matter if DeviceHi==0
SYSINIT:2BA1                 mov     al, DeviceHi    ; If not using upper memory,
SYSINIT:2BA1                                         ; ('mov al, [DeviceHi]' is not needed here
SYSINIT:2BA1                                         ;  because al value is not used after here)
SYSINIT:2BA4                 or      DeviceHi, 0     ; (or al, al) - Erdogan Tan - 10/07/2023
SYSINIT:2BA9                 jz      short DevConvLoad ; Skip all this and go on
SYSINIT:2BA9                                         ; to the actual load.
SYSINIT:2BAB
SYSINIT:2BAB loc_7EDB:                               ; ('mov al, [UmbLoad]' would be better here)
SYSINIT:2BAB                 call    GetLoadUMB
SYSINIT:2BAE                 cmp     al, 0FFh        ; -1 ; If umb0 not specified, it's old style
SYSINIT:2BB0                 jz      short DevConvLoad ; so load high even if SIZE= is smaller
SYSINIT:2BB2                 dec     ConvLoad        ; 0 ; They specified /L, so use new loader
SYSINIT:2BB6                 call    GetLoadSize     ; Returns size of first UMB specified
SYSINIT:2BB9                 or      ax, ax
SYSINIT:2BBB                 jz      short tryd_1    ; If size is not specified..
SYSINIT:2BBD                 cmp     ax, DevSize     ; /L:...,Size < DevSize?
SYSINIT:2BC1                 jge     short DevConvLoad
SYSINIT:2BC3
SYSINIT:2BC3 tryd_1:                                 ; CODE XREF: doconf+3DD↑j
SYSINIT:2BC3                 mov     ax, DevSize     ; Size < DevSize, so write DevSize as
SYSINIT:2BC6                 call    StoLoadSize     ; minsize for load UMB.
SYSINIT:2BC9
SYSINIT:2BC9 DevConvLoad:                            ; CODE XREF: doconf+3CB↑j
SYSINIT:2BC9                                         ; doconf+3D2↑j ...
SYSINIT:2BC9                 call    InitDevLoad
SYSINIT:2BCC                 mov     ax, DevLoadAddr
SYSINIT:2BCF                 add     ax, DevSize
SYSINIT:2BD3                 jb      short NoMem
SYSINIT:2BD5                 cmp     DevLoadEnd, ax
SYSINIT:2BD9                 jnb     short LoadDev
SYSINIT:2BDB
SYSINIT:2BDB NoMem:                                  ; CODE XREF: doconf+3F5↑j
SYSINIT:2BDB                 jmp     mem_err
SYSINIT:2BDE ; ---------------------------------------------------------------------------
SYSINIT:2BDE
SYSINIT:2BDE BadFile:                                ; CODE XREF: doconf+3BC↑j
SYSINIT:2BDE                                         ; doconf+41D↓j ...
SYSINIT:2BDE                 call    RetFromUM       ; Does nothing if didn't call HideUMBs
SYSINIT:2BE1                 cmp     byte ptr es:[si], 20h ; ' ' ; blank/space
SYSINIT:2BE5                 jnb     short tryd_2
SYSINIT:2BE7                 jmp     badop
SYSINIT:2BEA ; ---------------------------------------------------------------------------
SYSINIT:2BEA
SYSINIT:2BEA tryd_2:                                 ; CODE XREF: doconf+407↑j
SYSINIT:2BEA                 call    badload
SYSINIT:2BED                 jmp     coff
SYSINIT:2BF0 ; ---------------------------------------------------------------------------
SYSINIT:2BF0
SYSINIT:2BF0 LoadDev:                                ; CODE XREF: doconf+3FB↑j
SYSINIT:2BF0                 push    es
SYSINIT:2BF1                 pop     ds
SYSINIT:2BF2                 assume ds:nothing
SYSINIT:2BF2                 mov     dx, si          ; ds:dx points to file name
SYSINIT:2BF4                 call    ExecDev         ; load device driver using exec call
SYSINIT:2BF7                 push    ds
SYSINIT:2BF8                 pop     es              ; es:si back to config.sys
SYSINIT:2BF9                 push    cs
SYSINIT:2BFA                 pop     ds              ; ds back to sysinit
SYSINIT:2BFB                 assume ds:SYSINIT
SYSINIT:2BFB                 jb      short BadFile
SYSINIT:2BFD
SYSINIT:2BFD goodld:                                 ; CODE XREF: doconf+655↓j
SYSINIT:2BFD                 push    es
SYSINIT:2BFE                 push    si
SYSINIT:2BFF                 call    RemoveNull
SYSINIT:2C02                 push    es
SYSINIT:2C03                 push    si
SYSINIT:2C04                 push    cs
SYSINIT:2C05                 pop     es
SYSINIT:2C06                 assume es:SYSINIT
SYSINIT:2C06                 push    ds
SYSINIT:2C07                 push    si
SYSINIT:2C08                 lds     si, cs:DevEntry
SYSINIT:2C0D                 assume ds:nothing
SYSINIT:2C0D                 test    word ptr [si+4], 8000h ; [si+SYSDEV.ATT],DEVTYP
SYSINIT:2C0D                                         ; block device driver?
SYSINIT:2C12                 jnz     short got_device_com_cont ; no.
SYSINIT:2C14                 lds     si, cs:DOSINFO  ; ds:si -> sys_var
SYSINIT:2C19                 cmp     byte ptr [si+20h], 26 ; [si+SYSI_NUMIO]
SYSINIT:2C19                                         ; no more than 26 drive number
SYSINIT:2C1D                 jb      short got_device_com_cont
SYSINIT:2C1F                 pop     si
SYSINIT:2C20                 pop     ds
SYSINIT:2C21                 pop     si              ; clear the stack
SYSINIT:2C22                 pop     es
SYSINIT:2C23                 assume es:nothing
SYSINIT:2C23                 call    RetFromUM       ; Do this before we leave
SYSINIT:2C26                 jmp     badnumblock
SYSINIT:2C29 ; ---------------------------------------------------------------------------
SYSINIT:2C29
SYSINIT:2C29 got_device_com_cont:                    ; CODE XREF: doconf+434↑j
SYSINIT:2C29                                         ; doconf+43F↑j
SYSINIT:2C29                 pop     si
SYSINIT:2C2A                 pop     ds
SYSINIT:2C2B                 call    LieInt12Mem
SYSINIT:2C2E                 call    UpdatePDB       ; update the PSP:2 value
SYSINIT:2C31                 cmp     cs:multdeviceflag, 0 ; Pass limit only for
SYSINIT:2C31                                         ; the 1st device driver in the file
SYSINIT:2C37                 jnz     short skip_pass_limit
SYSINIT:2C39                 mov     cs:break_addr, 0 ; pass the limit to the DD
SYSINIT:2C40                 mov     bx, cs:DevLoadEnd
SYSINIT:2C45                 mov     cs:break_addr+2, bx
SYSINIT:2C4A
SYSINIT:2C4A skip_pass_limit:                        ; CODE XREF: doconf+459↑j
SYSINIT:2C4A                 push    ds
SYSINIT:2C4B                 lds     bx, cs:DOSINFO  ; ds:bx -> sys_var
SYSINIT:2C50                 mov     al, cs:drivenumber ; temporarily use this next drv value
SYSINIT:2C54                 mov     cs:devdrivenum, al ; pass drive number in packet to driver
SYSINIT:2C58                 mov     ah, al
SYSINIT:2C5A                 xchg    ax, [bx+20h]    ; [bx+SYSI_NUMIO]
SYSINIT:2C5A                                         ; swap with existing values
SYSINIT:2C5D                 pop     ds
SYSINIT:2C5E                 push    ax              ; save real sysi_numio/ncds in ax
SYSINIT:2C5F                 mov     word ptr cs:configmsgflag, 0 ; disable (reset msg option)
SYSINIT:2C5F                                         ; "error in config.sys line #" msg
SYSINIT:2C5F                                         ; (before loading -next- device driver)
SYSINIT:2C66                 mov     bx, 6           ; SYSDEV.STRAT
SYSINIT:2C69                 call    calldev         ; calldev (sdevstrat);
SYSINIT:2C6C                 mov     bx, 8           ; SYSDEV.INT
SYSINIT:2C6F                 call    calldev         ; calldev (sdevint);
SYSINIT:2C72                 pop     ax              ; get real sysi_numio value
SYSINIT:2C73                 push    ds
SYSINIT:2C74                 lds     bx, cs:DOSINFO  ; ds:bx -> sys_var
SYSINIT:2C79                 mov     [bx+20h], ax    ; [bx+SYSI_NUMIO]
SYSINIT:2C79                                         ; restore previous/real value
SYSINIT:2C7C                 pop     ds
SYSINIT:2C7D                 call    TrueInt12Mem
SYSINIT:2C80                 mov     ax, cs:break_addr ; move break addr from the req packet
SYSINIT:2C84                 mov     word ptr cs:DevBrkAddr, ax
SYSINIT:2C88                 mov     ax, cs:break_addr+2
SYSINIT:2C8C                 mov     word ptr cs:DevBrkAddr+2, ax
SYSINIT:2C90                 call    RetFromUM       ; There we go... all done.
SYSINIT:2C93                 cmp     cs:DevUMB, 0
SYSINIT:2C99                 jz      short tryd_3
SYSINIT:2C9B                 call    AllocUMB
SYSINIT:2C9E
SYSINIT:2C9E tryd_3:                                 ; CODE XREF: doconf+4BB↑j
SYSINIT:2C9E                 cmp     cs:runhigh, 0FFh
SYSINIT:2CA4                 jnz     short tryd_4
SYSINIT:2CA6                 call    TryToMovDOSHi   ; move DOS into HMA if requsted
SYSINIT:2CA9
SYSINIT:2CA9 tryd_4:                                 ; CODE XREF: doconf+4C6↑j
SYSINIT:2CA9                 pop     si
SYSINIT:2CAA                 pop     ds
SYSINIT:2CAB                 mov     byte ptr [si], 0 ; *p = 0;
SYSINIT:2CAE                 push    cs
SYSINIT:2CAF                 pop     ds
SYSINIT:2CB0                 assume ds:SYSINIT
SYSINIT:2CB0                 jmp     short was_device_com
SYSINIT:2CB2 ; ---------------------------------------------------------------------------
SYSINIT:2CB2
SYSINIT:2CB2 badnumblock:                            ; CODE XREF: doconf+448↑j
SYSINIT:2CB2                                         ; doconf+563↓j
SYSINIT:2CB2                 push    cs
SYSINIT:2CB3                 pop     ds
SYSINIT:2CB4                 mov     dx, offset badblock ; "\r\nToo many block devices\r\n$"
SYSINIT:2CB7                 call    print
SYSINIT:2CBA
SYSINIT:2CBA erase_dev_do:                           ; CODE XREF: doconf:jc_edd↓j
SYSINIT:2CBA                                         ; doconf+547↓j
SYSINIT:2CBA                 pop     si
SYSINIT:2CBB                 pop     es
SYSINIT:2CBC                 push    cs
SYSINIT:2CBD                 pop     ds
SYSINIT:2CBE                 cmp     word ptr cs:configmsgflag, 0 ; is error_line msg disabled ?
SYSINIT:2CC4                 jz      short no_error_line_msg ; yes
SYSINIT:2CC6                 call    error_line      ; show "error in config.sys ..." message.
SYSINIT:2CC9                 mov     word ptr cs:configmsgflag, 0 ; set the default value again.
SYSINIT:2CD0
SYSINIT:2CD0 no_error_line_msg:                      ; CODE XREF: doconf+4E6↑j
SYSINIT:2CD0                 jmp     coff
SYSINIT:2CD3 ; ---------------------------------------------------------------------------
SYSINIT:2CD3
SYSINIT:2CD3 was_device_com:                         ; CODE XREF: doconf+4D2↑j
SYSINIT:2CD3                 mov     ax, word ptr cs:DevBrkAddr+2
SYSINIT:2CD7                 cmp     ax, cs:DevLoadEnd
SYSINIT:2CDC                 jbe     short breakok
SYSINIT:2CDE                 pop     si
SYSINIT:2CDF                 pop     es
SYSINIT:2CE0                 jmp     BadFile
SYSINIT:2CE3 ; ---------------------------------------------------------------------------
SYSINIT:2CE3
SYSINIT:2CE3 breakok:                                ; CODE XREF: doconf+4FE↑j
SYSINIT:2CE3                 lds     dx, cs:DevEntry ; set ds:dx to header
SYSINIT:2CE8                 assume ds:nothing
SYSINIT:2CE8                 mov     si, dx
SYSINIT:2CEA                 les     di, cs:DOSINFO  ; es:di point to dos info
SYSINIT:2CEF                 mov     ax, [si+4]      ; [si+SYSDEV.ATT] ; get attributes
SYSINIT:2CF2                 test    ax, 8000h       ; DEVTYP ; test if block dev
SYSINIT:2CF5                 jz      short isblock
SYSINIT:2CF7                 or      cs:setdevmarkflag, 2 ; for_devmark
SYSINIT:2CFD                 call    DevSetBreak     ; go ahead and alloc mem for device
SYSINIT:2D00
SYSINIT:2D00 jc_edd:                                 ; CODE XREF: doconf+56F↓j
SYSINIT:2D00                 jb      short erase_dev_do ; device driver's init routine failed.
SYSINIT:2D02                 test    ax, 1           ; ISCIN ; is it a console in?
SYSINIT:2D05                 jz      short tryclk
SYSINIT:2D07                 mov     es:[di+0Ch], dx ; [es:di+SYSI_CON]
SYSINIT:2D0B                 mov     word ptr es:[di+0Eh], ds ; [es:di+SYSI_CON+2]
SYSINIT:2D0F
SYSINIT:2D0F tryclk:                                 ; CODE XREF: doconf+527↑j
SYSINIT:2D0F                 test    ax, 8           ; ISCLOCK ; is it a clock device?
SYSINIT:2D12                 jz      short golink
SYSINIT:2D14                 mov     es:[di+8], dx   ; [es:di+SYSI_CLOCK]
SYSINIT:2D18                 mov     word ptr es:[di+0Ah], ds ; [es:di+SYSI_CLOCK+2]
SYSINIT:2D1C
SYSINIT:2D1C golink:                                 ; CODE XREF: doconf+534↑j
SYSINIT:2D1C                 jmp     linkit
SYSINIT:2D1F ; ---------------------------------------------------------------------------
SYSINIT:2D1F
SYSINIT:2D1F isblock:                                ; CODE XREF: doconf+517↑j
SYSINIT:2D1F                 mov     al, cs:unitcount
SYSINIT:2D23                 or      al, al          ; if no units found, erase the device
SYSINIT:2D25                 jz      short erase_dev_do
SYSINIT:2D27                 mov     [si+0Ah], al    ; [si+SYSDEV.NAME]
SYSINIT:2D27                                         ; number of units in name field
SYSINIT:2D2A                 add     cs:drivers_units, al ; keep total for all drivers in file
SYSINIT:2D2F
SYSINIT:2D2F perdrv:                                 ; warning no device > 127 units
SYSINIT:2D2F                 cbw
SYSINIT:2D30                 mov     cx, ax
SYSINIT:2D32                 mov     dh, ah
SYSINIT:2D34                 mov     dl, es:[di+20h] ; [es:di+SYSI_NUMIO]
SYSINIT:2D34                                         ; get number of devices
SYSINIT:2D38                 mov     ah, dl
SYSINIT:2D3A                 add     ah, al          ; check for too many devices
SYSINIT:2D3C                 cmp     ah, 26          ; 'A' - 'Z' is 26 devices
SYSINIT:2D3F                 jbe     short ok_block
SYSINIT:2D41                 jmp     badnumblock
SYSINIT:2D44 ; ---------------------------------------------------------------------------
SYSINIT:2D44
SYSINIT:2D44 ok_block:                               ; CODE XREF: doconf+561↑j
SYSINIT:2D44                 or      cs:setdevmarkflag, 2 ; for_devmark
SYSINIT:2D4A                 call    DevSetBreak     ; alloc the device
SYSINIT:2D4D                 jb      short jc_edd
SYSINIT:2D4F                 add     es:[di+20h], al ; [es:di+SYSI_NUMIO]
SYSINIT:2D4F                                         ; update the amount
SYSINIT:2D53                 add     cs:drivenumber, al ; remember amount for next device
SYSINIT:2D58                 lds     bx, cs:bpb_addr ; point to bpb array
SYSINIT:2D5D
SYSINIT:2D5D perunit:                                ; CODE XREF: doconf+61B↓j
SYSINIT:2D5D                 les     bp, cs:DOSINFO
SYSINIT:2D62                 les     bp, es:[bp+0]   ; [es:bp+SYSI_DPB] ; get first dpb
SYSINIT:2D66
SYSINIT:2D66 scandpb:                                ; CODE XREF: doconf+593↓j
SYSINIT:2D66                 cmp     word ptr es:[bp+19h], 0FFFFh ; [es:bp+DPB.NEXT_DPB],-1
SYSINIT:2D6B                 jz      short foundpb
SYSINIT:2D6D                 les     bp, es:[bp+19h] ; [es:bp+DPB.NEXT_DPB] ; [es:bp+25]
SYSINIT:2D71                 jmp     short scandpb
SYSINIT:2D73 ; ---------------------------------------------------------------------------
SYSINIT:2D73
SYSINIT:2D73 foundpb:                                ; CODE XREF: doconf+58D↑j
SYSINIT:2D73                 mov     ax, word ptr cs:DevBrkAddr
SYSINIT:2D77                 mov     es:[bp+19h], ax ; [es:bp+DPB.NEXT_DPB]
SYSINIT:2D7B                 mov     ax, word ptr cs:DevBrkAddr+2
SYSINIT:2D7F                 mov     es:[bp+1Bh], ax ; [es:bp+DPB.NEXT_DPB+2]
SYSINIT:2D83                 les     bp, cs:DevBrkAddr
SYSINIT:2D88                 add     word ptr cs:DevBrkAddr, 61 ; DPBSIZ = 61
SYSINIT:2D88                                         ; (33 in MSDOS 6.21 IO.SYS)
SYSINIT:2D8E                 call    RoundBreakAddr
SYSINIT:2D91                 mov     word ptr es:[bp+19h], 0FFFFh ; [es:bp+DPB.NEXT_DPB],-1
SYSINIT:2D97                 mov     byte ptr es:[bp+18h], 0FFh ; [es:bp+DPB.FIRST_ACCESS],-1 ; byte
SYSINIT:2D9C                 mov     si, [bx]        ; ds:si points to bpb
SYSINIT:2D9E                 inc     bx
SYSINIT:2D9F                 inc     bx              ; point to next bpb
SYSINIT:2DA0                 mov     es:[bp+0], dx   ; [es:bp+DPB.DRIVE]
SYSINIT:2DA4                 push    dx
SYSINIT:2DA5                 push    cx              ; initialize FAT32 extended DPB parameters/fields
SYSINIT:2DA6                 mov     dx, 4152h       ; 'AR' signature for FAT32 extended DPB
SYSINIT:2DA9                 xor     cx, cx          ; 0
SYSINIT:2DAB                 mov     es:[bp+1Dh], cx ; DPB.NEXT_FREE ; last allocated cluster #
SYSINIT:2DAF                 cmp     [si+0Bh], cx    ; BPB.fatsecs16 ; [si+A_BPB.BPB_SECTORSPERFAT]
SYSINIT:2DB2                 jnz     short setdpb    ; FAT DPB (33 bytes)   -jnz-
SYSINIT:2DB2                                         ; FAT32 DPB (61 bytes) -jz-
SYSINIT:2DB4                 mov     es:[bp+39h], cx ; DPB.RESERVED = 0
SYSINIT:2DB8                 mov     es:[bp+3Bh], cx ; DPB.RESERVED+2 = 0
SYSINIT:2DBC                 dec     cx              ; 0FFFFh ; -1
SYSINIT:2DBD                 mov     es:[bp+1Fh], cx ; DPB.FREE_CNT (-1 = unknown)
SYSINIT:2DC1                 mov     es:[bp+21h], cx ; DPB.FREE_CNT+2 (-1 = unknown)
SYSINIT:2DC5                 mov     cx, 4558h       ; 'EX' signature for FAT32 extended DPB
SYSINIT:2DC8
SYSINIT:2DC8 setdpb:                                 ; CODE XREF: doconf+5D4↑j
SYSINIT:2DC8                 mov     ah, 53h         ; SETDPB ; hidden system call
SYSINIT:2DCA                 int     21h             ; DOS - 2+ internal - TRANSLATE BIOS PARAMETER BLOCK
SYSINIT:2DCA                                         ; DS:SI -> BPB (BIOS Parameter Block)
SYSINIT:2DCA                                         ; ES:BP -> buffer for DOS Drive Parameter Block
SYSINIT:2DCA                                         ; (if CX=4558h & DX=4152h, FAT32 Extd/PCDOS7.1 DPB will be set)
SYSINIT:2DCA                                         ; ((if DX=4152h but CX<>4558h, FAT Extd/PCDOS7.1 DPB will be set))
SYSINIT:2DCC                 pop     cx
SYSINIT:2DCD                 pop     dx
SYSINIT:2DCE                 mov     ax, es:[bp+2]   ; [es:bp+DPB.SECTOR_SIZE]
SYSINIT:2DD2                 push    es
SYSINIT:2DD3                 les     di, cs:DOSINFO  ; es:di point to dos info
SYSINIT:2DD8                 cmp     ax, es:[di+10h] ; [es:di+SYSI_MAXSEC]
SYSINIT:2DDC                 pop     es
SYSINIT:2DDD                 jbe     short iblk_1
SYSINIT:2DDF                 jmp     bad_bpb_size_sector
SYSINIT:2DE2 ; ---------------------------------------------------------------------------
SYSINIT:2DE2
SYSINIT:2DE2 iblk_1:                                 ; CODE XREF: doconf+5FF↑j
SYSINIT:2DE2                 push    ds
SYSINIT:2DE3                 push    dx
SYSINIT:2DE4                 lds     dx, cs:DevEntry
SYSINIT:2DE9                 mov     es:[bp+13h], dx ; [es:bp+DPB.DRIVER_ADDR]
SYSINIT:2DED                 mov     word ptr es:[bp+15h], ds ; [es:bp+DPB.DRIVER_ADDR+2]
SYSINIT:2DF1                 pop     dx
SYSINIT:2DF2                 pop     ds
SYSINIT:2DF3                 inc     dx
SYSINIT:2DF4                 inc     dh
SYSINIT:2DF6                 dec     cx              ; cx = cx - 1
SYSINIT:2DF6                                         ; cx = remain count from [cs:unitcount]
SYSINIT:2DF7                 jz      short iblk_2    ; cx = 0 -> done
SYSINIT:2DF9                 jmp     perunit         ; loop until cx is 0
SYSINIT:2DFC ; ---------------------------------------------------------------------------
SYSINIT:2DFC
SYSINIT:2DFC iblk_2:                                 ; CODE XREF: doconf+619↑j
SYSINIT:2DFC                 push    cs
SYSINIT:2DFD                 pop     ds
SYSINIT:2DFE                 assume ds:SYSINIT
SYSINIT:2DFE                 call    TempCDS         ; set cds for new drives
SYSINIT:2E01
SYSINIT:2E01 linkit:                                 ; CODE XREF: doconf:golink↑j
SYSINIT:2E01                 les     di, cs:DOSINFO  ; es:di = dos table
SYSINIT:2E06                 mov     cx, es:[di+22h] ; [es:di+SYSI_DEV] ; dx:cx = head of list
SYSINIT:2E0A                 mov     dx, es:[di+24h] ; [es:di+SYSI_DEV+2]
SYSINIT:2E0E                 lds     si, cs:DevEntry ; ds:si = device location
SYSINIT:2E13                 assume ds:nothing
SYSINIT:2E13                 mov     es:[di+22h], si ; set head of list in dos
SYSINIT:2E13                                         ; [es:di+SYSI_DEV]
SYSINIT:2E17                 mov     word ptr es:[di+24h], ds ; [es:di+SYSI_DEV+2]
SYSINIT:2E1B                 mov     ax, [si]        ; get pointer to next device
SYSINIT:2E1D                 mov     word ptr cs:DevEntry, ax ; and save it
SYSINIT:2E21                 mov     [si], cx        ; link in the driver
SYSINIT:2E23                 mov     [si+2], dx
SYSINIT:2E26                 pop     si
SYSINIT:2E27                 pop     es
SYSINIT:2E28                 inc     ax              ; ax = 0FFFFh (no more devs if yes)?
SYSINIT:2E29                 jz      short coffj3
SYSINIT:2E2B                 inc     cs:multdeviceflag ; possibly multiple device driver.
SYSINIT:2E30                 call    DevBreak
SYSINIT:2E33                 jmp     goodld          ; otherwise pretend we loaded it in
SYSINIT:2E36 ; ---------------------------------------------------------------------------
SYSINIT:2E36
SYSINIT:2E36 coffj3:                                 ; CODE XREF: doconf+64B↑j
SYSINIT:2E36                 mov     cs:multdeviceflag, 0 ; reset the flag
SYSINIT:2E3C                 call    DevBreak
SYSINIT:2E3F                 call    CheckProtmanArena
SYSINIT:2E42
SYSINIT:2E42 CheckDoubleSpace:                       ; inquire of MagicDrv whether it is present,
SYSINIT:2E42                 test    cs:MagicHomeFlag, 1 ; and final located
SYSINIT:2E48                 jnz     short no_more_magic_calls ; already home?
SYSINIT:2E48                                         ; nothing more to do if so
SYSINIT:2E4A                 call    get_dblspace_version ; is it there?
SYSINIT:2E4D                 jnz     short set_magichomeflag ; done if not
SYSINIT:2E4F                 test    dx, 8000h       ; is it final placed?
SYSINIT:2E53                 jnz     short magic_not_yet_home
SYSINIT:2E55                 add     cs:drivenumber, ch ; add number of MagicDrv volumes to
SYSINIT:2E55                                         ; the drive number we'll pass to the
SYSINIT:2E55                                         ; next loadable block device.
SYSINIT:2E5A
SYSINIT:2E5A set_magichomeflag:                      ; CODE XREF: doconf+66F↑j
SYSINIT:2E5A                 mov     cs:MagicHomeFlag, 1 ; set the flag!
SYSINIT:2E60                 jmp     coff
SYSINIT:2E63 ; ---------------------------------------------------------------------------
SYSINIT:2E63
SYSINIT:2E63 magic_not_yet_home:                     ; CODE XREF: doconf+675↑j
SYSINIT:2E63                 push    es
SYSINIT:2E64                 push    si
SYSINIT:2E65                 mov     ax, cs:memhi    ; pass it a work buffer
SYSINIT:2E69                 mov     dx, cs:ALLOCLIM ; address in cx (segment)
SYSINIT:2E6E                 sub     dx, ax          ; for len dx (paragraphs)
SYSINIT:2E70                 mov     bx, 2
SYSINIT:2E73                 mov     al, cs:drivers_units ; shuffle magicdrives and new drives
SYSINIT:2E73                                         ; by this many units
SYSINIT:2E77                 mov     ah, 55h         ; backdoor won't shuffle unless it
SYSINIT:2E77                                         ; sees this, to prevent bad things
SYSINIT:2E77                                         ; from happening if people run the
SYSINIT:2E77                                         ; new driver with an old (dos) BIOS
SYSINIT:2E79                 call    cs:MagicBackdoor
SYSINIT:2E7E                 pop     si
SYSINIT:2E7F                 pop     es
SYSINIT:2E80
SYSINIT:2E80 no_more_magic_calls:                    ; CODE XREF: doconf+66A↑j
SYSINIT:2E80                 jmp     coff
SYSINIT:2E83 ; ---------------------------------------------------------------------------
SYSINIT:2E83
SYSINIT:2E83 bad_bpb_size_sector:                    ; CODE XREF: doconf+601↑j
SYSINIT:2E83                 pop     si
SYSINIT:2E84                 pop     es
SYSINIT:2E85                 mov     dx, offset badsiz_pre ; "\r\nSector size too large in file $"
SYSINIT:2E88                 mov     bx, offset crlfm ; "\r\n$"
SYSINIT:2E8B                 call    prnerr
SYSINIT:2E8E                 jmp     coff
SYSINIT:2E91 ; ---------------------------------------------------------------------------
SYSINIT:2E91
SYSINIT:2E91 tryq:                                   ; CODE XREF: doconf:skip_it2↑j
SYSINIT:2E91                 cmp     ah, 51h ; 'Q'   ; CONFIG_COUNTRY
SYSINIT:2E94                 jz      short tryq_cont
SYSINIT:2E96
SYSINIT:2E96 skip_it3:                               ; CODE XREF: doconf+6BE↓j
SYSINIT:2E96                 jmp     tryf
SYSINIT:2E99 ; ---------------------------------------------------------------------------
SYSINIT:2E99
SYSINIT:2E99 tryq_cont:                              ; CODE XREF: doconf+6B6↑j
SYSINIT:2E99                 call    query_user      ; query the user if config_cmd
SYSINIT:2E99                                         ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2E9C                 jb      short skip_it3
SYSINIT:2E9E                 mov     byte ptr cs:cntry_drv, 0 ;
SYSINIT:2E9E                                         ; reset the drive,path to default value.
SYSINIT:2EA4                 mov     cs:p_code_page, 0
SYSINIT:2EAB                 mov     di, offset cntry_parms
SYSINIT:2EAE                 xor     cx, cx
SYSINIT:2EB0                 mov     dx, cx
SYSINIT:2EB2
SYSINIT:2EB2 do52:                                   ; CODE XREF: doconf:en56↓j
SYSINIT:2EB2                 call    sysinit_parse
SYSINIT:2EB5                 jnb     short if52      ; parse error,check error code and
SYSINIT:2EB7                 call    cntry_error     ; show message and end the search loop.
SYSINIT:2EBA                 mov     cs:p_cntry_code, 0FFFFh ; -1 ; signals that parse error.
SYSINIT:2EC1                 jmp     short sr52
SYSINIT:2EC3 ; ---------------------------------------------------------------------------
SYSINIT:2EC3
SYSINIT:2EC3 if52:                                   ; CODE XREF: doconf+6D7↑j
SYSINIT:2EC3                 cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
SYSINIT:2EC6                 jz      short sr52
SYSINIT:2EC8                 cmp     cs:result_val, 1 ; _$P_Number
SYSINIT:2ECE                 jnz     short if56
SYSINIT:2ED0                 mov     ax, word ptr cs:rv_dword ;
SYSINIT:2ED0                                         ; [cs:result_val+_$P_Result_Blk.Picked_Val]
SYSINIT:2ED4                 cmp     cx, 1
SYSINIT:2ED7                 jnz     short if57
SYSINIT:2ED9                 mov     cs:p_cntry_code, ax
SYSINIT:2EDD                 jmp     short en57
SYSINIT:2EDF ; ---------------------------------------------------------------------------
SYSINIT:2EDF
SYSINIT:2EDF if57:                                   ; CODE XREF: doconf+6F9↑j
SYSINIT:2EDF                 mov     cs:p_code_page, ax
SYSINIT:2EE3
SYSINIT:2EE3 en57:                                   ; CODE XREF: doconf+6FF↑j
SYSINIT:2EE3                 jmp     short en56      ; path entered
SYSINIT:2EE5 ; ---------------------------------------------------------------------------
SYSINIT:2EE5
SYSINIT:2EE5 if56:                                   ; CODE XREF: doconf+6F0↑j
SYSINIT:2EE5                 push    ds
SYSINIT:2EE6                 push    es
SYSINIT:2EE7                 push    si
SYSINIT:2EE8                 push    di
SYSINIT:2EE9                 push    cs
SYSINIT:2EEA                 pop     es
SYSINIT:2EEB                 assume es:SYSINIT
SYSINIT:2EEB                 lds     si, cs:rv_dword ; move the path to known place.
SYSINIT:2EF0                 mov     di, offset cntry_drv ; "A:"
SYSINIT:2EF3                 call    move_asciiz
SYSINIT:2EF6                 pop     di
SYSINIT:2EF7                 pop     si
SYSINIT:2EF8                 pop     es
SYSINIT:2EF9                 assume es:nothing
SYSINIT:2EF9                 pop     ds
SYSINIT:2EFA
SYSINIT:2EFA en56:                                   ; CODE XREF: doconf:en57↑j
SYSINIT:2EFA                 jmp     short do52
SYSINIT:2EFC ; ---------------------------------------------------------------------------
SYSINIT:2EFC
SYSINIT:2EFC sr52:                                   ; CODE XREF: doconf+6E3↑j
SYSINIT:2EFC                                         ; doconf+6E8↑j
SYSINIT:2EFC                 cmp     cs:p_cntry_code, 0FFFFh ; -1 ; had a parse error?
SYSINIT:2F02                 jnz     short tryq_open
SYSINIT:2F04                 jmp     coff
SYSINIT:2F07 ; ---------------------------------------------------------------------------
SYSINIT:2F07
SYSINIT:2F07 tryqbad:                                ; CODE XREF: doconf+78F↓j
SYSINIT:2F07                 stc
SYSINIT:2F08                 mov     dx, offset badcountry ; "\r\nInvalid country code or code page\r"...
SYSINIT:2F0B                 jmp     tryqchkerr
SYSINIT:2F0E ; ---------------------------------------------------------------------------
SYSINIT:2F0E
SYSINIT:2F0E tryq_open:                              ; CODE XREF: doconf+724↑j
SYSINIT:2F0E                 cmp     byte ptr cs:cntry_drv, 0 ; "A:"
SYSINIT:2F14                 jz      short tryq_def
SYSINIT:2F16                 mov     dx, offset cntry_drv ; "A:"
SYSINIT:2F19                 jmp     short tryq_openit
SYSINIT:2F1B ; ---------------------------------------------------------------------------
SYSINIT:2F1B
SYSINIT:2F1B tryq_def:                               ; CODE XREF: doconf+736↑j
SYSINIT:2F1B                 mov     dx, offset cntry_root
SYSINIT:2F1E
SYSINIT:2F1E tryq_openit:                            ; CODE XREF: doconf+73B↑j
SYSINIT:2F1E                 mov     ax, 3D00h       ; open a file
SYSINIT:2F21                 stc
SYSINIT:2F22                 int     21h             ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
SYSINIT:2F22                                         ; DS:DX -> ASCIZ filename
SYSINIT:2F22                                         ; AL = access mode
SYSINIT:2F22                                         ; 0 - read
SYSINIT:2F24                 jb      short tryqfilebad
SYSINIT:2F26                 mov     cs:cntryfilehandle, ax ; save file handle
SYSINIT:2F2A                 mov     bx, ax
SYSINIT:2F2C                 mov     ax, cs:p_cntry_code
SYSINIT:2F30                 mov     dx, cs:p_code_page ; ax=country id, bx=filehandle
SYSINIT:2F35                 mov     cx, cs:memhi
SYSINIT:2F3A                 add     cx, 384         ; need 6k buffer to handle country.sys
SYSINIT:2F3A                                         ; (384*16 bytes)
SYSINIT:2F3E                 cmp     cx, cs:ALLOCLIM
SYSINIT:2F43                 ja      short tryqmemory ; cannot allocate the buffer for country.sys
SYSINIT:2F45                 mov     si, offset cntry_drv ; "A:"
SYSINIT:2F48                 cmp     byte ptr [si], 0 ; default path?
SYSINIT:2F4B                 jnz     short tryq_set_for_dos ; no
SYSINIT:2F4D                 inc     si
SYSINIT:2F4E                 inc     si              ; ds:si -> cntry_root
SYSINIT:2F4F
SYSINIT:2F4F tryq_set_for_dos:                       ; CODE XREF: doconf+76D↑j
SYSINIT:2F4F                 les     di, cs:sysi_country ; es:di -> country info tab in dos
SYSINIT:2F54                 push    di              ; save di
SYSINIT:2F55                 add     di, 8           ; country_cdpg_info.ccPath_CountrySys
SYSINIT:2F58                 call    move_asciiz     ; set the path to country.sys in dos.
SYSINIT:2F5B                 pop     di              ; es:di -> country info tab again.
SYSINIT:2F5C                 mov     cx, cs:memhi
SYSINIT:2F61                 mov     ds, cx
SYSINIT:2F63                 xor     si, si          ; ds:si -> 2k buffer to be used.
SYSINIT:2F65                 call    setdoscountryinfo ; now do the job!
SYSINIT:2F68                 jnb     short tryqchkerr ; read error or could not find country,
SYSINIT:2F68                                         ; code page combination
SYSINIT:2F6A                 cmp     cx, 0FFFFh      ; -1
SYSINIT:2F6A                                         ; could not find matching country_id, code page?
SYSINIT:2F6D                 jz      short tryqbad   ; then "invalid country code or code page"
SYSINIT:2F6F
SYSINIT:2F6F tryqfilebad:                            ; CODE XREF: doconf+746↑j
SYSINIT:2F6F                 push    cs
SYSINIT:2F70                 pop     es
SYSINIT:2F71                 assume es:SYSINIT
SYSINIT:2F71                 cmp     byte ptr cs:cntry_drv, 0 ; is the default file used?
SYSINIT:2F77                 jz      short tryqdefbad
SYSINIT:2F79                 mov     si, offset cntry_drv ; "A:"
SYSINIT:2F7C                 jmp     short tryqbadload
SYSINIT:2F7E ; ---------------------------------------------------------------------------
SYSINIT:2F7E
SYSINIT:2F7E tryqdefbad:                             ; CODE XREF: doconf+799↑j
SYSINIT:2F7E                 mov     si, offset cntry_root ; default file has been used.
SYSINIT:2F7E                                         ; es:si -> \country.sys in sysinit_seg
SYSINIT:2F81
SYSINIT:2F81 tryqbadload:                            ; CODE XREF: doconf+79E↑j
SYSINIT:2F81                 call    badload
SYSINIT:2F84                 mov     cx, cs:CONFBOT
SYSINIT:2F89                 mov     es, cx          ; restore es -> confbot.
SYSINIT:2F8B                 assume es:nothing
SYSINIT:2F8B                 jmp     short coffj4
SYSINIT:2F8D ; ---------------------------------------------------------------------------
SYSINIT:2F8D
SYSINIT:2F8D tryqmemory:                             ; CODE XREF: doconf+765↑j
SYSINIT:2F8D                 mov     dx, offset insufmemory ; "\r\nInsufficient memory for COUNTRY.SYS"...
SYSINIT:2F90
SYSINIT:2F90 tryqchkerr:                             ; CODE XREF: doconf+72D↑j
SYSINIT:2F90                                         ; doconf+78A↑j
SYSINIT:2F90                 mov     cx, cs:CONFBOT
SYSINIT:2F95                 mov     es, cx          ; restore es -> confbot seg
SYSINIT:2F97                 push    cs
SYSINIT:2F98                 pop     ds              ; restore ds to sysinit_seg
SYSINIT:2F99                 assume ds:SYSINIT
SYSINIT:2F99                 jnb     short coffj4    ; if no error,then exit
SYSINIT:2F9B                 call    print           ; else show error message
SYSINIT:2F9E                 call    error_line
SYSINIT:2FA1
SYSINIT:2FA1 coffj4:                                 ; CODE XREF: doconf+7AD↑j
SYSINIT:2FA1                                         ; doconf+7BB↑j
SYSINIT:2FA1                 mov     bx, cs:cntryfilehandle ; close a file.
SYSINIT:2FA1                                         ; don't care even if it fails.
SYSINIT:2FA6                 mov     ah, 3Eh
SYSINIT:2FA8                 int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
SYSINIT:2FA8                                         ; BX = file handle
SYSINIT:2FAA                 jmp     coff
SYSINIT:2FAA ; END OF FUNCTION CHUNK FOR doconf
SYSINIT:2FAD
SYSINIT:2FAD ; =============== S U B R O U T I N E =======================================
SYSINIT:2FAD
SYSINIT:2FAD
SYSINIT:2FAD cntry_error     proc near               ; CODE XREF: doconf+6D9↑p
SYSINIT:2FAD                 cmp     ax, 6           ; _$P_Out_Of_Range
SYSINIT:2FB0                 jnz     short if64
SYSINIT:2FB2                 mov     dx, offset badcountry ; "\r\nInvalid country code or code page\r"...
SYSINIT:2FB5                 jmp     short en64
SYSINIT:2FB7 ; ---------------------------------------------------------------------------
SYSINIT:2FB7
SYSINIT:2FB7 if64:                                   ; CODE XREF: cntry_error+3↑j
SYSINIT:2FB7                 mov     dx, offset badcountrycom ; "\r\nError in COUNTRY command\r\n$"
SYSINIT:2FBA
SYSINIT:2FBA en64:                                   ; CODE XREF: cntry_error+8↑j
SYSINIT:2FBA                 call    print
SYSINIT:2FBD                 call    error_line
SYSINIT:2FC0                 retn
SYSINIT:2FC0 cntry_error     endp
SYSINIT:2FC0
SYSINIT:2FC1 ; ---------------------------------------------------------------------------
SYSINIT:2FC1 ; START OF FUNCTION CHUNK FOR doconf
SYSINIT:2FC1
SYSINIT:2FC1 tryf:                                   ; CODE XREF: doconf:skip_it3↑j
SYSINIT:2FC1                 cmp     ah, 46h ; 'F'   ; CONFIG_FILES
SYSINIT:2FC4                 jnz     short tryl
SYSINIT:2FC6                 call    query_user      ; query the user if config_cmd
SYSINIT:2FC6                                         ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2FC9                 jb      short tryl
SYSINIT:2FCB                 mov     di, offset files_parms
SYSINIT:2FCE                 xor     cx, cx
SYSINIT:2FD0                 mov     dx, cx
SYSINIT:2FD2
SYSINIT:2FD2 do67:                                   ; CODE XREF: doconf+80B↓j
SYSINIT:2FD2                 call    sysinit_parse
SYSINIT:2FD5                 jnb     short if67      ;
SYSINIT:2FD5                                         ; parse error
SYSINIT:2FD5                                         ; show messages and end the search loop.
SYSINIT:2FD7                 call    badparm_p
SYSINIT:2FDA                 jmp     short sr67
SYSINIT:2FDC ; ---------------------------------------------------------------------------
SYSINIT:2FDC
SYSINIT:2FDC if67:                                   ; CODE XREF: doconf+7F7↑j
SYSINIT:2FDC                 cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
SYSINIT:2FDF                 jz      short en67      ; then end the $endloop
SYSINIT:2FE1                 mov     al, byte ptr cs:rv_dword ;
SYSINIT:2FE1                                         ; [result_val+_$P_Result_Blk.Picked_Val]
SYSINIT:2FE5                 mov     cs:p_files, al  ; save it temporarily
SYSINIT:2FE9                 jmp     short do67
SYSINIT:2FEB ; ---------------------------------------------------------------------------
SYSINIT:2FEB
SYSINIT:2FEB en67:                                   ; CODE XREF: doconf+801↑j
SYSINIT:2FEB                 mov     al, cs:p_files
SYSINIT:2FEF                 mov     cs:FILES, al    ; no error. really set the value now.
SYSINIT:2FF3
SYSINIT:2FF3 sr67:                                   ; CODE XREF: doconf+7FC↑j
SYSINIT:2FF3                 jmp     coff
SYSINIT:2FF6 ; ---------------------------------------------------------------------------
SYSINIT:2FF6
SYSINIT:2FF6 tryl:                                   ; CODE XREF: doconf+7E6↑j
SYSINIT:2FF6                                         ; doconf+7EB↑j
SYSINIT:2FF6                 cmp     ah, 4Ch ; 'L'   ; CONFIG_LASTDRIVE
SYSINIT:2FF9                 jnz     short tryp
SYSINIT:2FFB                 call    query_user      ; query the user if config_cmd
SYSINIT:2FFB                                         ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:2FFE                 jb      short tryp
SYSINIT:3000                 mov     di, offset ldrv_parms
SYSINIT:3003                 xor     cx, cx
SYSINIT:3005                 mov     dx, cx
SYSINIT:3007
SYSINIT:3007 do73:                                   ; CODE XREF: doconf+840↓j
SYSINIT:3007                 call    sysinit_parse
SYSINIT:300A                 jnb     short if73      ;
SYSINIT:300A                                         ; parse error
SYSINIT:300A                                         ; show messages and end the search loop.
SYSINIT:300C                 call    badparm_p
SYSINIT:300F                 jmp     short badparm_p_coff
SYSINIT:3011 ; ---------------------------------------------------------------------------
SYSINIT:3011
SYSINIT:3011 if73:                                   ; CODE XREF: doconf+82C↑j
SYSINIT:3011                 cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
SYSINIT:3014                 jz      short en73      ; then end the $endloop
SYSINIT:3016                 mov     al, byte ptr cs:rv_dword ; [rv_byte]
SYSINIT:3016                                         ; pick up the drive number
SYSINIT:301A                 mov     cs:p_ldrv, al   ; save it temporarily
SYSINIT:301E                 jmp     short do73
SYSINIT:3020 ; ---------------------------------------------------------------------------
SYSINIT:3020
SYSINIT:3020 en73:                                   ; CODE XREF: doconf+836↑j
SYSINIT:3020                 mov     al, cs:p_ldrv
SYSINIT:3024                 mov     cs:NUM_CDS, al  ; no error.
SYSINIT:3024                                         ; really set the value now.
SYSINIT:3028
SYSINIT:3028 badparm_p_coff:                         ; CODE XREF: doconf+831↑j
SYSINIT:3028                 jmp     coff
SYSINIT:302B ; ---------------------------------------------------------------------------
SYSINIT:302B
SYSINIT:302B tryp:                                   ; CODE XREF: doconf+81B↑j
SYSINIT:302B                                         ; doconf+820↑j
SYSINIT:302B                 cmp     ah, 50h ; 'P'   ; CONFIG_DRIVPARM
SYSINIT:302E                 jnz     short tryk
SYSINIT:3030                 call    query_user      ; query the user if config_cmd
SYSINIT:3030                                         ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:3033                 jb      short tryk
SYSINIT:3035                 call    parseline
SYSINIT:3038                 jb      short trypbad
SYSINIT:303A                 call    setparms
SYSINIT:303D                 call    diddleback
SYSINIT:3040                 jmp     coff
SYSINIT:3043 ; ---------------------------------------------------------------------------
SYSINIT:3043
SYSINIT:3043 trypbad:                                ; CODE XREF: doconf+85A↑j
SYSINIT:3043                 jmp     badop
SYSINIT:3046 ; ---------------------------------------------------------------------------
SYSINIT:3046
SYSINIT:3046 tryk:                                   ; CODE XREF: doconf+850↑j
SYSINIT:3046                                         ; doconf+855↑j
SYSINIT:3046                 cmp     ah, 4Bh ; 'K'   ; CONFIG_STACKS
SYSINIT:3049                 jz      short do_tryk
SYSINIT:304B
SYSINIT:304B skip_it4:                               ; CODE XREF: doconf+873↓j
SYSINIT:304B                 jmp     trys
SYSINIT:304E ; ---------------------------------------------------------------------------
SYSINIT:304E
SYSINIT:304E do_tryk:                                ; CODE XREF: doconf+86B↑j
SYSINIT:304E                 call    query_user      ; query the user if config_cmd
SYSINIT:304E                                         ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:3051                 jb      short skip_it4
SYSINIT:3053                 mov     di, offset stks_parms
SYSINIT:3056                 xor     cx, cx
SYSINIT:3058                 mov     dx, cx
SYSINIT:305A
SYSINIT:305A do79:                                   ; CODE XREF: doconf:en83↓j
SYSINIT:305A                 call    sysinit_parse
SYSINIT:305D                 jnb     short if79      ; parse error
SYSINIT:305F                 mov     dx, offset badstack ; "\r\nInvalid STACK parameters\r\n$"
SYSINIT:3062                 call    print           ; show messages and end the search loop.
SYSINIT:3065                 call    error_line
SYSINIT:3068                 jmp     sr79            ; (jmp coff)
SYSINIT:306B ; ---------------------------------------------------------------------------
SYSINIT:306B
SYSINIT:306B if79:                                   ; CODE XREF: doconf+87F↑j
SYSINIT:306B                 cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
SYSINIT:306E                 jz      short en79      ; then end the $endloop
SYSINIT:3070                 mov     ax, word ptr cs:rv_dword ;
SYSINIT:3070                                         ; [cs:result_val+_$P_Result_Blk.Picked_Val]
SYSINIT:3074                 cmp     cx, 1
SYSINIT:3077                 jnz     short if83
SYSINIT:3079                 mov     cs:p_stack_count, ax
SYSINIT:307D                 jmp     short en83
SYSINIT:307F ; ---------------------------------------------------------------------------
SYSINIT:307F
SYSINIT:307F if83:                                   ; CODE XREF: doconf+899↑j
SYSINIT:307F                 mov     cs:p_stack_size, ax
SYSINIT:3083
SYSINIT:3083 en83:                                   ; CODE XREF: doconf+89F↑j
SYSINIT:3083                 jmp     short do79
SYSINIT:3085 ; ---------------------------------------------------------------------------
SYSINIT:3085
SYSINIT:3085 en79:                                   ; CODE XREF: doconf+890↑j
SYSINIT:3085                 cmp     cs:p_stack_count, 0
SYSINIT:308B                 jz      short if87
SYSINIT:308D                 cmp     cs:p_stack_count, 8 ; mincount
SYSINIT:3093                 jb      short ll88
SYSINIT:3095                 cmp     cs:p_stack_size, 32 ; minsize
SYSINIT:309B                 jnb     short if88
SYSINIT:309D
SYSINIT:309D ll88:                                   ; CODE XREF: doconf+8B5↑j
SYSINIT:309D                 mov     cs:p_stack_count, 0FFFFh ; -1 ; invalid
SYSINIT:30A4
SYSINIT:30A4 if88:                                   ; CODE XREF: doconf+8BD↑j
SYSINIT:30A4                 jmp     short en87
SYSINIT:30A6 ; ---------------------------------------------------------------------------
SYSINIT:30A6
SYSINIT:30A6 if87:                                   ; CODE XREF: doconf+8AD↑j
SYSINIT:30A6                 cmp     cs:p_stack_size, 0
SYSINIT:30AC                 jz      short en87
SYSINIT:30AE                 mov     cs:p_stack_count, 0FFFFh ; -1 ; invalid
SYSINIT:30B5
SYSINIT:30B5 en87:                                   ; CODE XREF: doconf:if88↑j
SYSINIT:30B5                                         ; doconf+8CE↑j
SYSINIT:30B5                 cmp     cs:p_stack_count, 0FFFFh ; -1 ; invalid?
SYSINIT:30BB                 jnz     short if94
SYSINIT:30BD                 mov     cs:stack_count, 9 ; defaultcount
SYSINIT:30BD                                         ; reset to default value.
SYSINIT:30C4                 mov     cs:stack_size, 128 ; defaultsize
SYSINIT:30CB                 mov     cs:stack_addr, 0 ; stacks= been accepted.
SYSINIT:30D2                 mov     dx, offset badstack ; "\r\nInvalid STACK parameters\r\n$"
SYSINIT:30D5                 call    print
SYSINIT:30D8                 call    error_line
SYSINIT:30DB                 jmp     short sr79
SYSINIT:30DD ; ---------------------------------------------------------------------------
SYSINIT:30DD
SYSINIT:30DD if94:                                   ; CODE XREF: doconf+8DD↑j
SYSINIT:30DD                 mov     ax, cs:p_stack_count
SYSINIT:30E1                 mov     cs:stack_count, ax
SYSINIT:30E5                 mov     ax, cs:p_stack_size
SYSINIT:30E9                 mov     cs:stack_size, ax
SYSINIT:30ED                 mov     cs:stack_addr, 0FFFFh ; -1 ; stacks= been accepted.
SYSINIT:30F4
SYSINIT:30F4 sr79:                                   ; CODE XREF: doconf+88A↑j
SYSINIT:30F4                                         ; doconf+8FD↑j
SYSINIT:30F4                 jmp     coff
SYSINIT:30F7 ; ---------------------------------------------------------------------------
SYSINIT:30F7
SYSINIT:30F7 trys:                                   ; CODE XREF: doconf:skip_it4↑j
SYSINIT:30F7                 cmp     ah, 53h ; 'S'   ; CONFIG_SHELL
SYSINIT:30FA                 jnz     short tryx
SYSINIT:30FC                 call    query_user      ; query the user if config_cmd
SYSINIT:30FC                                         ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:30FF                 jb      short tryx
SYSINIT:3101                 mov     cs:newcmd, 1
SYSINIT:3107                 mov     word ptr cs:command_line, 0 ;
SYSINIT:3107                                         ; zap length, first byte of command-line
SYSINIT:310E                 mov     di, (offset commnd+1) ; we already have the first char
SYSINIT:3111                 mov     [di-1], al      ; of the new shell in AL, save it now
SYSINIT:3114
SYSINIT:3114 storeshell:                             ; CODE XREF: doconf+948↓j
SYSINIT:3114                 call    getchr
SYSINIT:3117                 or      al, al          ; this is the normal case: "organize"
SYSINIT:3119                 jz      short getshparms ; put a ZERO right after the filename
SYSINIT:311B                 cmp     al, 20h ; ' '   ; this may happen if there are no args
SYSINIT:311D                 jb      short endofshell ; I suppose...
SYSINIT:311F                 mov     [di], al
SYSINIT:3121                 inc     di
SYSINIT:3122                 cmp     di, offset commnd_63 ; commnd+63
SYSINIT:3122                                         ; this makes sure we don't overflow
SYSINIT:3122                                         ; commnd (the filename)
SYSINIT:3126                 jb      short storeshell
SYSINIT:3128                 jmp     short endofshell
SYSINIT:312A ; ---------------------------------------------------------------------------
SYSINIT:312A
SYSINIT:312A getshparms:                             ; CODE XREF: doconf+93B↑j
SYSINIT:312A                 mov     byte ptr [di], 0 ; zero-terminate the filename
SYSINIT:312D                 mov     di, (offset command_line+1) ;
SYSINIT:312D                                         ; prepare to process the command-line
SYSINIT:3130
SYSINIT:3130 parmloop:                               ; CODE XREF: doconf+960↓j
SYSINIT:3130                 call    getchr
SYSINIT:3133                 cmp     al, 20h ; ' '
SYSINIT:3135                 jb      short endofparms
SYSINIT:3137                 mov     [di], al
SYSINIT:3139                 inc     di
SYSINIT:313A                 cmp     di, offset command_line_126 ; command_line+126
SYSINIT:313E                 jb      short parmloop
SYSINIT:3140
SYSINIT:3140 endofparms:                             ; CODE XREF: doconf+957↑j
SYSINIT:3140                 mov     cx, di
SYSINIT:3142                 sub     cx, (offset command_line+1) ; "/P"
SYSINIT:3146                 mov     byte ptr cs:command_line, cl ; "\x02/P"
SYSINIT:314B
SYSINIT:314B endofshell:                             ; CODE XREF: doconf+93F↑j
SYSINIT:314B                                         ; doconf+94A↑j
SYSINIT:314B                 mov     byte ptr [di], 0 ; zero-terminate the filename
SYSINIT:314B                                         ; (or the command-line as the case may be)
SYSINIT:314E
SYSINIT:314E skipline:                               ; CODE XREF: doconf+977↓j
SYSINIT:314E                 cmp     al, 0Ah         ; lf ; the safest way to eat the rest of
SYSINIT:3150                 jz      short endofline ; the line: watch for ever-present LF
SYSINIT:3152                 call    getchr
SYSINIT:3155                 jnb     short skipline
SYSINIT:3157
SYSINIT:3157 endofline:                              ; CODE XREF: doconf+972↑j
SYSINIT:3157                 jmp     conflp
SYSINIT:315A ; ---------------------------------------------------------------------------
SYSINIT:315A
SYSINIT:315A tryx:                                   ; CODE XREF: doconf+91C↑j
SYSINIT:315A                                         ; doconf+921↑j
SYSINIT:315A                 cmp     ah, 58h ; 'X'   ; CONFIG_FCBS
SYSINIT:315D                 jnz     short try1
SYSINIT:315F                 call    query_user      ; query the user if config_cmd
SYSINIT:315F                                         ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:3162                 jb      short try1
SYSINIT:3164                 mov     di, offset fcbs_parms
SYSINIT:3167                 xor     cx, cx
SYSINIT:3169                 mov     dx, cx
SYSINIT:316B
SYSINIT:316B do98:                                   ; CODE XREF: doconf:en102↓j
SYSINIT:316B                 call    sysinit_parse
SYSINIT:316E                 jnb     short if98
SYSINIT:3170                 call    badparm_p       ; parse error
SYSINIT:3170                                         ; show messages and end the search loop.
SYSINIT:3173                 jmp     short sr98
SYSINIT:3175 ; ---------------------------------------------------------------------------
SYSINIT:3175
SYSINIT:3175 if98:                                   ; CODE XREF: doconf+990↑j
SYSINIT:3175                 cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
SYSINIT:3178                 jz      short en98      ; then end the $endloop
SYSINIT:317A                 mov     al, byte ptr cs:rv_dword ;
SYSINIT:317A                                         ; [cs:result_val+_$P_Result_Blk.Picked_Val]
SYSINIT:317E                 cmp     cx, 1           ; the first positional?
SYSINIT:3181                 jnz     short if102
SYSINIT:3183                 mov     cs:p_fcbs, al
SYSINIT:3187                 jmp     short en102
SYSINIT:3189 ; ---------------------------------------------------------------------------
SYSINIT:3189
SYSINIT:3189 if102:                                  ; CODE XREF: doconf+9A3↑j
SYSINIT:3189                 mov     cs:p_keep, al
SYSINIT:318D
SYSINIT:318D en102:                                  ; CODE XREF: doconf+9A9↑j
SYSINIT:318D                 jmp     short do98
SYSINIT:318F ; ---------------------------------------------------------------------------
SYSINIT:318F
SYSINIT:318F en98:                                   ; CODE XREF: doconf+99A↑j
SYSINIT:318F                 mov     al, cs:p_fcbs
SYSINIT:3193                 mov     cs:FCBS, al
SYSINIT:3197                 mov     cs:KEEP, 0
SYSINIT:319D
SYSINIT:319D sr98:                                   ; CODE XREF: doconf+995↑j
SYSINIT:319D                 jmp     coff
SYSINIT:31A0 ; ---------------------------------------------------------------------------
SYSINIT:31A0
SYSINIT:31A0 try1:                                   ; CODE XREF: doconf+97F↑j
SYSINIT:31A0                                         ; doconf+984↑j
SYSINIT:31A0                 cmp     ah, 31h ; '1'   ; CONFIG_SWITCHES
SYSINIT:31A0                                         ; switches= command entered?
SYSINIT:31A3                 jz      short do_try1   ; yes
SYSINIT:31A5
SYSINIT:31A5 skip_it5:                               ; CODE XREF: doconf+9CD↓j
SYSINIT:31A5                 jmp     tryv
SYSINIT:31A8 ; ---------------------------------------------------------------------------
SYSINIT:31A8
SYSINIT:31A8 do_try1:                                ; CODE XREF: doconf+9C5↑j
SYSINIT:31A8                 call    query_user      ; query the user if config_cmd
SYSINIT:31A8                                         ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:31AB                 jb      short skip_it5
SYSINIT:31AD                 mov     di, offset swit_parms
SYSINIT:31B0                 xor     cx, cx
SYSINIT:31B2                 mov     dx, cx
SYSINIT:31B4
SYSINIT:31B4 do110:                                  ; CODE XREF: doconf+9F5↓j
SYSINIT:31B4                                         ; doconf+A06↓j ...
SYSINIT:31B4                 call    sysinit_parse
SYSINIT:31B7                 jnb     short if110     ;
SYSINIT:31B7                                         ; parse error
SYSINIT:31B7                                         ; show messages and end the search loop.
SYSINIT:31B9                 call    badparm_p
SYSINIT:31BC                 jmp     sr110
SYSINIT:31BF ; ---------------------------------------------------------------------------
SYSINIT:31BF
SYSINIT:31BF if110:                                  ; CODE XREF: doconf+9D9↑j
SYSINIT:31BF                 cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
SYSINIT:31C2                 jz      short en110     ; then jmp to $endloop for semantic check
SYSINIT:31C4                 cmp     cs:result_val_swoff, offset swit_k ; offset "/K"
SYSINIT:31C4                                         ; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
SYSINIT:31CB                 jnz     short if115
SYSINIT:31CD                 mov     cs:p_swit_k, 1  ; set the flag
SYSINIT:31D3                 jmp     short do110
SYSINIT:31D5 ; ---------------------------------------------------------------------------
SYSINIT:31D5
SYSINIT:31D5 if115:                                  ; CODE XREF: doconf+9ED↑j
SYSINIT:31D5                 cmp     cs:result_val_swoff, offset swit_t ; offset "/T"
SYSINIT:31D5                                         ; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
SYSINIT:31DC                 jnz     short if118
SYSINIT:31DE                 mov     cs:p_swit_t, 1  ; set the flag
SYSINIT:31E4                 jmp     short do110
SYSINIT:31E6 ; ---------------------------------------------------------------------------
SYSINIT:31E6
SYSINIT:31E6 if118:                                  ; CODE XREF: doconf+9FE↑j
SYSINIT:31E6                 cmp     cs:result_val_swoff, offset swit_i ; offset "/I"
SYSINIT:31E6                                         ; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
SYSINIT:31ED                 jnz     short if116
SYSINIT:31EF                 mov     cs:p_swit_i, 1  ; set the flag
SYSINIT:31F5                 jmp     short do110
SYSINIT:31F7 ; ---------------------------------------------------------------------------
SYSINIT:31F7
SYSINIT:31F7 if116:                                  ; CODE XREF: doconf+A0F↑j
SYSINIT:31F7                 cmp     cs:result_val_swoff, offset swit_w ; offset "/W"
SYSINIT:31F7                                         ; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
SYSINIT:31FE                 jnz     short do110
SYSINIT:3200                 mov     cs:p_swit_w, 1  ; set the flag
SYSINIT:3206                 jmp     short do110
SYSINIT:3208 ; ---------------------------------------------------------------------------
SYSINIT:3208
SYSINIT:3208 en110:                                  ; CODE XREF: doconf+9E4↑j
SYSINIT:3208                 cmp     cs:p_swit_k, 1  ; if /k entered,
SYSINIT:320E                 push    ds
SYSINIT:320F                 mov     ax, 70h         ; DOSBIODATASEG ; BIOSDATA segment
SYSINIT:3212                 mov     ds, ax
SYSINIT:3214                 assume ds:nothing
SYSINIT:3214                 jnz     short if117
SYSINIT:3216                 mov     ds:keyrd_func, 0 ; BIOSDATA:047Eh
SYSINIT:3216                                         ; use the conventional keyboard functions
SYSINIT:321B                 mov     ds:keysts_func, 1 ; BIOSDATA:047Fh
SYSINIT:3220
SYSINIT:3220 if117:                                  ; CODE XREF: doconf+A36↑j
SYSINIT:3220                 mov     al, cs:p_swit_t
SYSINIT:3224                 mov     ds:t_switch, al
SYSINIT:3227                 cmp     cs:p_swit_w, 0
SYSINIT:322D                 jz      short if119
SYSINIT:322F                 push    es
SYSINIT:3230                 push    bx
SYSINIT:3231                 mov     ah, 52h         ; GET_IN_VARS
SYSINIT:3233                 int     21h             ; DOS - 2+ internal - GET LIST OF LISTS
SYSINIT:3233                                         ; Return: ES:BX -> DOS list of lists
SYSINIT:3235                 or      byte ptr es:86h, 2 ; [es:DOS_FLAG_OFFSET], SUPPRESS_WINA20
SYSINIT:323B                 pop     bx
SYSINIT:323C                 pop     es
SYSINIT:323D
SYSINIT:323D if119:                                  ; CODE XREF: doconf+A4F↑j
SYSINIT:323D                 cmp     cs:p_swit_i, 0  ; if /i entered ; new switch for PCDOS 7.1
SYSINIT:3243                 jz      short skip_dos_flag
SYSINIT:3245                 push    es
SYSINIT:3246                 push    bx
SYSINIT:3247                 mov     ah, 52h
SYSINIT:3249                 int     21h             ; DOS - 2+ internal - GET LIST OF LISTS
SYSINIT:3249                                         ; Return: ES:BX -> DOS list of lists
SYSINIT:324B                 or      byte ptr es:86h, 40h ; set DOS_FLAG bit 6
SYSINIT:3251                 pop     bx
SYSINIT:3252                 pop     es
SYSINIT:3253
SYSINIT:3253 skip_dos_flag:                          ; CODE XREF: doconf+A65↑j
SYSINIT:3253                 pop     ds
SYSINIT:3254                 assume ds:nothing
SYSINIT:3254
SYSINIT:3254 sr110:                                  ; CODE XREF: doconf+9DE↑j
SYSINIT:3254                                         ; doconf+A86↓j ...
SYSINIT:3254                 jmp     coff
SYSINIT:3257 ; ---------------------------------------------------------------------------
SYSINIT:3257
SYSINIT:3257 tryv:                                   ; CODE XREF: doconf:skip_it5↑j
SYSINIT:3257                 cmp     ah, 56h ; 'V'   ; CONFIG_SET ; set var=value<cr/lf>
SYSINIT:325A                 jnz     short tryn
SYSINIT:325C                 call    query_user      ; query the user if config_cmd
SYSINIT:325C                                         ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:325F                 jb      short tryn
SYSINIT:3261                 call    copy_envvar     ; copy var at ES:SI to "config_wrkseg"
SYSINIT:3264                 jnb     short sr110     ; no error
SYSINIT:3266
SYSINIT:3266 err:                                    ; CODE XREF: doconf+A9A↓j
SYSINIT:3266                 call    error_line      ; whoops, display error in line XXX
SYSINIT:3269                 jmp     short sr110     ; jump to coff (to skip to next line)
SYSINIT:326B ; ---------------------------------------------------------------------------
SYSINIT:326B
SYSINIT:326B tryn:                                   ; CODE XREF: doconf+A7C↑j
SYSINIT:326B                                         ; doconf+A81↑j
SYSINIT:326B                 cmp     ah, 4Eh ; 'N'   ; CONFIG_NUMLOCK ; numlock=on|off
SYSINIT:326E                 jnz     short tryt
SYSINIT:3270                 call    query_user      ; query the user if config_cmd
SYSINIT:3270                                         ; has the CONFIG_OPTION_QUERY bit set
SYSINIT:3273                 jb      short tryt
SYSINIT:3275                 call    set_numlock
SYSINIT:3278                 jb      short err
SYSINIT:327A                 jmp     short sr110     ; all done
SYSINIT:327C ; ---------------------------------------------------------------------------
SYSINIT:327C
SYSINIT:327C tryt:                                   ; CODE XREF: doconf+A90↑j
SYSINIT:327C                                         ; doconf+A95↑j
SYSINIT:327C                 cmp     ah, 54h ; 'T'   ; CONFIG_DOSDATA ; PCDOS 7 new config cmd
SYSINIT:327F                 jnz     short tryy
SYSINIT:3281                 call    query_user
SYSINIT:3284                 jb      short tryy
SYSINIT:3286                 mov     di, offset dosdata_parms
SYSINIT:3289                 xor     cx, cx
SYSINIT:328B                 mov     dx, cx
SYSINIT:328D
SYSINIT:328D do120:                                  ; CODE XREF: doconf:sr120↓j
SYSINIT:328D                 call    sysinit_parse
SYSINIT:3290                 jnb     short if120
SYSINIT:3292                 call    badparm_p
SYSINIT:3295                 jmp     short en120
SYSINIT:3297 ; ---------------------------------------------------------------------------
SYSINIT:3297
SYSINIT:3297 if120:                                  ; CODE XREF: doconf+AB2↑j
SYSINIT:3297                 cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
SYSINIT:329A                 jz      short en120
SYSINIT:329C                 cmp     ds:result_val_itag, 1 ; tag 1 (UMB)
SYSINIT:329C                                         ; [result_val+_$P_Result_Blk.Item_Tag]
SYSINIT:32A1                 jnz     short if121
SYSINIT:32A3                 mov     ds:dosdata_umb, 1 ; DOSDATA=UMB (1) NOUMB (0)
SYSINIT:32A8                 jmp     short sr120
SYSINIT:32AA ; ---------------------------------------------------------------------------
SYSINIT:32AA
SYSINIT:32AA if121:                                  ; CODE XREF: doconf+AC3↑j
SYSINIT:32AA                 mov     ds:dosdata_umb, 0 ; DOSDATA=UMB (1) NOUMB (0)
SYSINIT:32AF
SYSINIT:32AF sr120:                                  ; CODE XREF: doconf+ACA↑j
SYSINIT:32AF                 jmp     short do120
SYSINIT:32B1 ; ---------------------------------------------------------------------------
SYSINIT:32B1
SYSINIT:32B1 en120:                                  ; CODE XREF: doconf+AB7↑j
SYSINIT:32B1                                         ; doconf+ABC↑j
SYSINIT:32B1                 jmp     coff
SYSINIT:32B4 ; ---------------------------------------------------------------------------
SYSINIT:32B4
SYSINIT:32B4 tryy:                                   ; CODE XREF: doconf+AA1↑j
SYSINIT:32B4                                         ; doconf+AA6↑j
SYSINIT:32B4                 cmp     ah, 59h ; 'Y'   ; CONFIG_COMMENT
SYSINIT:32B4                                         ; (do nothing with this line.)
SYSINIT:32B7                 jnz     short try0
SYSINIT:32B9
SYSINIT:32B9 donothing:                              ; CODE XREF: doconf+AE9↓j
SYSINIT:32B9                                         ; doconf+AEE↓j
SYSINIT:32B9                 dec     ds:chrptr
SYSINIT:32BD                 inc     ds:count
SYSINIT:32C1                 jmp     coff
SYSINIT:32C4 ; ---------------------------------------------------------------------------
SYSINIT:32C4
SYSINIT:32C4 try0:                                   ; CODE XREF: doconf+AD9↑j
SYSINIT:32C4                 cmp     ah, 30h ; '0'   ; CONFIG_REM
SYSINIT:32C4                                         ; (do nothing with this line.)
SYSINIT:32C7                 jz      short donothing
SYSINIT:32C9                 cmp     ah, 0FFh        ; null/bogus command?
SYSINIT:32CC                 jz      short donothing
SYSINIT:32CE                 dec     ds:chrptr
SYSINIT:32D2                 inc     ds:count
SYSINIT:32D6                 jmp     short badop
SYSINIT:32D6 ; END OF FUNCTION CHUNK FOR doconf
SYSINIT:32D8
SYSINIT:32D8 ; =============== S U B R O U T I N E =======================================
SYSINIT:32D8
SYSINIT:32D8
SYSINIT:32D8 CheckProtmanArena proc near             ; CODE XREF: doconf+661↑p
SYSINIT:32D8                 push    es              ; adjusts alloclim if Protman$
SYSINIT:32D8                                         ; reduced our arena through a manual hack
SYSINIT:32D9                 mov     ax, cs:area     ; get our arena header
SYSINIT:32DD                 dec     ax
SYSINIT:32DE                 mov     es, ax
SYSINIT:32E0                 add     ax, es:3        ; [es:ARENA.SIZE] ; find end of arena
SYSINIT:32E5                 inc     ax
SYSINIT:32E6                 cmp     ax, cs:ALLOCLIM
SYSINIT:32EB                 ja      short CheckProtmanDone
SYSINIT:32ED                 mov     cs:ALLOCLIM, ax
SYSINIT:32F1
SYSINIT:32F1 CheckProtmanDone:                       ; CODE XREF: CheckProtmanArena+13↑j
SYSINIT:32F1                 pop     es
SYSINIT:32F2                 retn
SYSINIT:32F2 CheckProtmanArena endp
SYSINIT:32F2
SYSINIT:32F3
SYSINIT:32F3 ; =============== S U B R O U T I N E =======================================
SYSINIT:32F3
SYSINIT:32F3
SYSINIT:32F3 sysinit_parse   proc near               ; CODE XREF: doconf:do7↑p
SYSINIT:32F3                                         ; doconf:do22↑p ...
SYSINIT:32F3                 push    es              ; set up registers for sysparse
SYSINIT:32F3                                         ; in:
SYSINIT:32F3                                         ;    es:si -> command line in confbot
SYSINIT:32F3                                         ;       di -> offset of the parse control definition.
SYSINIT:32F3                                         ; out:
SYSINIT:32F3                                         ;    calls sysparse.
SYSINIT:32F3                                         ;    carry will set if parse error.
SYSINIT:32F3                                         ;    *** the caller should check the eol condition by looking at ax
SYSINIT:32F3                                         ;    *** after each call.
SYSINIT:32F3                                         ;    *** if no parameters are found,then ax will contain a error code.
SYSINIT:32F3                                         ;    *** if the caller needs to look at the synomym@ of the result,
SYSINIT:32F3                                         ;    *** the caller should use cs:@ instead of es:@.
SYSINIT:32F3                                         ;    cx should be set to 0 at the 1st time the caller calls this proc.
SYSINIT:32F3                                         ;    ax - exit code
SYSINIT:32F3                                         ;    bl - terminated delimeter code
SYSINIT:32F3                                         ;    cx - new positional ordinal
SYSINIT:32F3                                         ;    si - set to pase scanned operand
SYSINIT:32F3                                         ;    dx - selected result buffer
SYSINIT:32F4                 push    ds
SYSINIT:32F5                 push    es              ; now ds:si -> command line
SYSINIT:32F6                 pop     ds
SYSINIT:32F7                 push    cs
SYSINIT:32F8                 pop     es              ; now es:di -> control definition
SYSINIT:32F9                 assume es:SYSINIT
SYSINIT:32F9                 mov     word ptr cs:badparm_ptr+2, ds ; save the pointer to the parm
SYSINIT:32FE                 mov     word ptr cs:badparm_ptr, si ; we are about to parse for badparm msg.
SYSINIT:3303                 mov     dx, 0
SYSINIT:3306                 call    SysParse
SYSINIT:3309                 cmp     ax, 0           ; _$P_No_Error ; no error
SYSINIT:330C                 jz      short ll4       ; cf=0
SYSINIT:330E                 cmp     ax, 0FFFFh      ; _$P_RC_EOL ; end of line?
SYSINIT:3311                 jnz     short if4       ; or the end of line?
SYSINIT:3313
SYSINIT:3313 ll4:                                    ; CODE XREF: sysinit_parse+19↑j
SYSINIT:3313                 clc
SYSINIT:3314                 jmp     short en4
SYSINIT:3316 ; ---------------------------------------------------------------------------
SYSINIT:3316
SYSINIT:3316 if4:                                    ; CODE XREF: sysinit_parse+1E↑j
SYSINIT:3316                 stc
SYSINIT:3317
SYSINIT:3317 en4:                                    ; CODE XREF: sysinit_parse+21↑j
SYSINIT:3317                 pop     ds
SYSINIT:3318                 pop     es
SYSINIT:3319                 assume es:nothing
SYSINIT:3319                 retn
SYSINIT:3319 sysinit_parse   endp
SYSINIT:3319
SYSINIT:331A ; ---------------------------------------------------------------------------
SYSINIT:331A
SYSINIT:331A badop_p:                                ; 'badop_p' is not used in
SYSINIT:331A                 push    cs              ; MSDOS 6.21 IO.SYS and PCDOS 7.1 IBMBIO.COM
SYSINIT:331A                                         ; (but it was/is not removed)
SYSINIT:331A                                         ; Erdogan Tan - 11/07/2023
SYSINIT:331B                 pop     ds
SYSINIT:331C                 assume ds:SYSINIT
SYSINIT:331C                 mov     dx, offset badopm ; "\r\nUnrecognized command in CONFIG.SYS"
SYSINIT:331F                 call    print
SYSINIT:3322                 call    error_line
SYSINIT:3325                 retn
SYSINIT:3326 ; ---------------------------------------------------------------------------
SYSINIT:3326 ; START OF FUNCTION CHUNK FOR doconf
SYSINIT:3326
SYSINIT:3326 badop:                                  ; CODE XREF: doconf+11F↑j
SYSINIT:3326                                         ; doconf+409↑j ...
SYSINIT:3326                 mov     dx, offset badopm ; "\r\nUnrecognized command in CONFIG.SYS"
SYSINIT:3329                 call    print
SYSINIT:332C                 call    error_line
SYSINIT:332F                 jmp     coff
SYSINIT:332F ; END OF FUNCTION CHUNK FOR doconf
SYSINIT:3332
SYSINIT:3332 ; =============== S U B R O U T I N E =======================================
SYSINIT:3332
SYSINIT:3332
SYSINIT:3332 badparm_p       proc near               ; CODE XREF: doconf+1E6↑p
SYSINIT:3332                                         ; doconf+213↑p ...
SYSINIT:3332                 push    ds
SYSINIT:3333                 push    dx
SYSINIT:3334                 push    si
SYSINIT:3335                 push    cs
SYSINIT:3336                 pop     ds
SYSINIT:3337                 mov     dx, offset badparm ; "\r\nBad command or parameters - $"
SYSINIT:333A                 call    print
SYSINIT:333D                 lds     si, badparm_ptr
SYSINIT:3341                 assume ds:nothing
SYSINIT:3341
SYSINIT:3341 do1:                                    ; CODE XREF: badparm_p+1B↓j
SYSINIT:3341                 mov     dl, [si]        ; print "xxxx" until cr.
SYSINIT:3343                 cmp     dl, 0Dh         ; cr ?
SYSINIT:3346                 jz      short en1       ; yes
SYSINIT:3348                 mov     ah, 2           ; display character
SYSINIT:334A                 int     21h             ; DOS - DISPLAY OUTPUT
SYSINIT:334A                                         ; DL = character to send to standard output
SYSINIT:334C                 inc     si
SYSINIT:334D                 jmp     short do1
SYSINIT:334F ; ---------------------------------------------------------------------------
SYSINIT:334F
SYSINIT:334F en1:                                    ; CODE XREF: badparm_p+14↑j
SYSINIT:334F                 push    cs
SYSINIT:3350                 pop     ds
SYSINIT:3351                 assume ds:SYSINIT
SYSINIT:3351                 mov     dx, offset crlfm ; "\r\n$"
SYSINIT:3354                 call    print
SYSINIT:3357                 call    error_line
SYSINIT:335A                 pop     si
SYSINIT:335B                 pop     dx
SYSINIT:335C                 pop     ds
SYSINIT:335D                 assume ds:nothing
SYSINIT:335D                 retn
SYSINIT:335D badparm_p       endp
SYSINIT:335D
SYSINIT:335E
SYSINIT:335E ; =============== S U B R O U T I N E =======================================
SYSINIT:335E
SYSINIT:335E
SYSINIT:335E getchr          proc near               ; CODE XREF: multi_pass+20↑p
SYSINIT:335E                                         ; doconf+C6↑p ...
SYSINIT:335E                 push    cx
SYSINIT:335F                 mov     cx, ds:count
SYSINIT:3363                 jcxz    short nochar
SYSINIT:3365                 mov     si, ds:chrptr
SYSINIT:3369                 mov     al, es:[si]
SYSINIT:336C                 dec     ds:count
SYSINIT:3370                 inc     ds:chrptr
SYSINIT:3374                 clc
SYSINIT:3375
SYSINIT:3375 get_ret:                                ; CODE XREF: getchr+1A↓j
SYSINIT:3375                 pop     cx
SYSINIT:3376                 retn
SYSINIT:3377 ; ---------------------------------------------------------------------------
SYSINIT:3377
SYSINIT:3377 nochar:                                 ; CODE XREF: getchr+5↑j
SYSINIT:3377                 stc
SYSINIT:3378                 jmp     short get_ret
SYSINIT:3378 getchr          endp
SYSINIT:3378
SYSINIT:337A ; ---------------------------------------------------------------------------
SYSINIT:337A
SYSINIT:337A incorrect_order:                        ; 'incorrect_order' is not used in
SYSINIT:337A                 mov     dx, offset badorder ; MSDOS 6.21 IO.SYS and PCDOS 7.1 IBMBIO.COM
SYSINIT:337A                                         ; (but it was/is not removed)
SYSINIT:337A                                         ; Erdogan Tan - 11/07/2023
SYSINIT:337D                 call    print
SYSINIT:3380                 call    showlinenum
SYSINIT:3383                 retn
SYSINIT:3384
SYSINIT:3384 ; =============== S U B R O U T I N E =======================================
SYSINIT:3384
SYSINIT:3384
SYSINIT:3384 error_line      proc near               ; CODE XREF: doconf+4E8↑p
SYSINIT:3384                                         ; doconf+7C0↑p ...
SYSINIT:3384                 push    cs
SYSINIT:3385                 pop     ds
SYSINIT:3386                 assume ds:SYSINIT
SYSINIT:3386                 mov     dx, offset errorcmd ; "Error in CONFIG.SYS line $"
SYSINIT:3389                 call    print
SYSINIT:338C                 call    showlinenum
SYSINIT:338F                 retn
SYSINIT:338F error_line      endp
SYSINIT:338F
SYSINIT:3390
SYSINIT:3390 ; =============== S U B R O U T I N E =======================================
SYSINIT:3390
SYSINIT:3390
SYSINIT:3390 showlinenum     proc near               ; CODE XREF: SYSINIT:3380↑p
SYSINIT:3390                                         ; error_line+8↑p
SYSINIT:3390                 push    es
SYSINIT:3391                 push    ds
SYSINIT:3392                 push    di
SYSINIT:3393                 push    cs
SYSINIT:3394                 pop     es
SYSINIT:3395                 assume es:SYSINIT
SYSINIT:3395                 push    cs
SYSINIT:3396                 pop     ds
SYSINIT:3397                 mov     di, (offset showcount+4) ;
SYSINIT:3397                                         ; di -> the least significant decimal field.
SYSINIT:339A                 mov     cx, 10
SYSINIT:339D                 mov     ax, cs:linecount ; (ds = cs !)
SYSINIT:33A1
SYSINIT:33A1 sln_loop:                               ; CODE XREF: showlinenum+20↓j
SYSINIT:33A1                 cmp     ax, 10          ; < 10 ?
SYSINIT:33A4                 jb      short sln_last  ; yes
SYSINIT:33A6                 xor     dx, dx
SYSINIT:33A8                 div     cx              ; cx = 10
SYSINIT:33AA                 or      dl, 30h         ; convert to ascii numeric char ("0" to "9")
SYSINIT:33AD                 mov     [di], dl
SYSINIT:33AF                 dec     di
SYSINIT:33B0                 jmp     short sln_loop
SYSINIT:33B2 ; ---------------------------------------------------------------------------
SYSINIT:33B2
SYSINIT:33B2 sln_last:                               ; CODE XREF: showlinenum+14↑j
SYSINIT:33B2                 or      al, 30h         ; convert to ascii numeric char ("0" to "9")
SYSINIT:33B4                 mov     [di], al
SYSINIT:33B6                 mov     dx, di
SYSINIT:33B8                 call    print           ; show it
SYSINIT:33BB                 pop     di
SYSINIT:33BC                 pop     ds
SYSINIT:33BD                 assume ds:nothing
SYSINIT:33BD                 pop     es
SYSINIT:33BE                 assume es:nothing
SYSINIT:33BE                 retn
SYSINIT:33BE showlinenum     endp
SYSINIT:33BE
SYSINIT:33BF
SYSINIT:33BF ; =============== S U B R O U T I N E =======================================
SYSINIT:33BF
SYSINIT:33BF
SYSINIT:33BF ProcDOS         proc near               ; CODE XREF: doconf+2ED↑p
SYSINIT:33BF                 xor     ah, ah
SYSINIT:33C1                 mov     al, cs:result_val_itag ;
SYSINIT:33C1                                         ; [cs:result_val+_$P_Result_Blk.Item_Tag]
SYSINIT:33C1                                         ;
SYSINIT:33C1                                         ; result_val._$P_item_tag
SYSINIT:33C1                                         ;          = 1 for DOS=HIGH
SYSINIT:33C1                                         ;          = 2 for DOS=LOW
SYSINIT:33C1                                         ;          = 3 for DOS=UMB
SYSINIT:33C1                                         ;          = 4 for DOS=NOUMB
SYSINIT:33C5                 dec     ax
SYSINIT:33C6                 jz      short pd_hi
SYSINIT:33C8                 dec     ax
SYSINIT:33C9                 jz      short pd_lo
SYSINIT:33CB                 dec     ax
SYSINIT:33CC                 jz      short pd_umb
SYSINIT:33CE                 mov     cs:DevUMB, 0
SYSINIT:33D4                 retn
SYSINIT:33D5 ; ---------------------------------------------------------------------------
SYSINIT:33D5
SYSINIT:33D5 pd_umb:                                 ; CODE XREF: ProcDOS+D↑j
SYSINIT:33D5                 mov     cs:DevUMB, 0FFh
SYSINIT:33DB                 retn
SYSINIT:33DC ; ---------------------------------------------------------------------------
SYSINIT:33DC
SYSINIT:33DC pd_lo:                                  ; CODE XREF: ProcDOS+A↑j
SYSINIT:33DC                 mov     cs:runhigh, 0
SYSINIT:33E2                 retn
SYSINIT:33E3 ; ---------------------------------------------------------------------------
SYSINIT:33E3
SYSINIT:33E3 pd_hi:                                  ; CODE XREF: ProcDOS+7↑j
SYSINIT:33E3                 mov     cs:runhigh, 0FFh
SYSINIT:33E9                 retn
SYSINIT:33E9 ProcDOS         endp
SYSINIT:33E9
SYSINIT:33EA
SYSINIT:33EA ; =============== S U B R O U T I N E =======================================
SYSINIT:33EA
SYSINIT:33EA
SYSINIT:33EA LieInt12Mem     proc near               ; CODE XREF: doconf+44D↑p
SYSINIT:33EA                 mov     ax, cs:ALLOCLIM ; lie INT 12h as alloclim
SYSINIT:33EA                                         ; assuming that it is 3Com
SYSINIT:33EE                 call    IsIt3Com        ; Is it 3Com driver?
SYSINIT:33F1                 jz      short lim_set   ; yes, lie to him differently
SYSINIT:33F3                 cmp     cs:DeviceHi, 0  ; Is the DD being loaded in UMB
SYSINIT:33F9                 jz      short limx      ; no, don't lie
SYSINIT:33FB                 mov     ax, cs:DevLoadEnd ; lie INT 12h as end of UMB
SYSINIT:33FF
SYSINIT:33FF lim_set:                                ; CODE XREF: LieInt12Mem+7↑j
SYSINIT:33FF                 call    SetInt12Mem
SYSINIT:3402
SYSINIT:3402 limx:                                   ; CODE XREF: LieInt12Mem+F↑j
SYSINIT:3402                 retn
SYSINIT:3402 LieInt12Mem     endp
SYSINIT:3402
SYSINIT:3403
SYSINIT:3403 ; =============== S U B R O U T I N E =======================================
SYSINIT:3403
SYSINIT:3403
SYSINIT:3403 SetInt12Mem     proc near               ; CODE XREF: LieInt12Mem:lim_set↑p
SYSINIT:3403                 push    ds
SYSINIT:3404                 mov     bx, 40h         ; ROMBIOS data area segment
SYSINIT:3407                 mov     ds, bx
SYSINIT:3409                 assume ds:nothing
SYSINIT:3409                 mov     bx, ds:13h      ; memory size (KB)
SYSINIT:340D                 mov     cs:OldInt12Mem, bx
SYSINIT:3412                 mov     cl, 6           ; 16*64 = 1024
SYSINIT:3414                 shr     ax, cl          ; convert paragraphs to kilobyte
SYSINIT:3416                 mov     ds:13h, ax
SYSINIT:3419                 mov     cs:Int12Lied, 0FFh ; mark that we are lying
SYSINIT:341F                 pop     ds
SYSINIT:3420                 assume ds:nothing
SYSINIT:3420                 retn
SYSINIT:3420 SetInt12Mem     endp
SYSINIT:3420
SYSINIT:3421
SYSINIT:3421 ; =============== S U B R O U T I N E =======================================
SYSINIT:3421
SYSINIT:3421
SYSINIT:3421 TrueInt12Mem    proc near               ; CODE XREF: doconf+49F↑p
SYSINIT:3421                 cmp     cs:Int12Lied, 0 ; were we lying so far?
SYSINIT:3427                 mov     cs:Int12Lied, 0
SYSINIT:342D                 jz      short timx      ; yes
SYSINIT:342D                                         ; no, we weren't
SYSINIT:342F                 push    ds
SYSINIT:3430                 mov     ax, 40h
SYSINIT:3433                 mov     ds, ax
SYSINIT:3435                 assume ds:nothing
SYSINIT:3435                 mov     ax, cs:OldInt12Mem
SYSINIT:3439                 mov     ds:13h, ax      ; restore INT 12h memory
SYSINIT:343C                 pop     ds
SYSINIT:343D                 assume ds:nothing
SYSINIT:343D
SYSINIT:343D timx:                                   ; CODE XREF: TrueInt12Mem+C↑j
SYSINIT:343D                 retn
SYSINIT:343D TrueInt12Mem    endp
SYSINIT:343D
SYSINIT:343E
SYSINIT:343E ; =============== S U B R O U T I N E =======================================
SYSINIT:343E
SYSINIT:343E
SYSINIT:343E IsIt3Com        proc near               ; CODE XREF: LieInt12Mem+4↑p
SYSINIT:343E                 push    ds
SYSINIT:343F                 push    es
SYSINIT:3440                 push    si
SYSINIT:3441                 lds     si, cs:DevEntry ; ptr to device header
SYSINIT:3446                 add     si, 10          ; SYSDEV.NAME ; ptr device name
SYSINIT:3449                 push    cs
SYSINIT:344A                 pop     es
SYSINIT:344B                 assume es:SYSINIT
SYSINIT:344B                 mov     di, offset ThreeComName ; "PROTMAN$"
SYSINIT:344E                 mov     cx, 8           ; name length
SYSINIT:3451                 repe cmpsb
SYSINIT:3453                 pop     si
SYSINIT:3454                 pop     es
SYSINIT:3455                 assume es:nothing
SYSINIT:3455                 pop     ds
SYSINIT:3456                 retn
SYSINIT:3456 IsIt3Com        endp
SYSINIT:3456
SYSINIT:3457
SYSINIT:3457 ; =============== S U B R O U T I N E =======================================
SYSINIT:3457
SYSINIT:3457
SYSINIT:3457 UpdatePDB       proc near               ; CODE XREF: doconf+450↑p
SYSINIT:3457                 push    ds
SYSINIT:3458                 mov     ah, 62h
SYSINIT:345A                 int     21h             ; DOS - 3+ - GET PSP ADDRESS
SYSINIT:345C                 mov     ds, bx
SYSINIT:345E                 mov     bx, cs:ALLOCLIM
SYSINIT:3463                 mov     ds:2, bx        ; [PDB.BLOCK_LEN]
SYSINIT:3467                 pop     ds
SYSINIT:3468                 retn
SYSINIT:3468 UpdatePDB       endp
SYSINIT:3468
SYSINIT:3469
SYSINIT:3469 ; =============== S U B R O U T I N E =======================================
SYSINIT:3469
SYSINIT:3469
SYSINIT:3469 InitVar         proc near               ; CODE XREF: doconf+302↑p
SYSINIT:3469                 push    ax
SYSINIT:346A                 push    cx
SYSINIT:346B                 push    di
SYSINIT:346C                 push    es
SYSINIT:346D                 push    cs
SYSINIT:346E                 pop     es
SYSINIT:346F                 assume es:SYSINIT
SYSINIT:346F                 xor     ax, ax          ; 0
SYSINIT:3471                 mov     es:fUmbTiny, al ; Shrink UMBs? (made 1 if /S given)
SYSINIT:3475                 mov     es:fInHigh, al  ; Set to 1 when DH/LH has been called
SYSINIT:3479                 mov     es:SegLoad, ax  ; Load Address (seg), used for DH only
SYSINIT:347D                 mov     es:UmbLoad, 0FFh ; UNSPECIFIED
SYSINIT:347D                                         ; Later is the # of the 1st spec'd UMB
SYSINIT:3483                 mov     es:fm_argc, al  ; Start with zero args having been read
SYSINIT:3487                 cld
SYSINIT:3488                 mov     cx, 16          ; MAXUMB
SYSINIT:348B                 mov     di, offset UmbUsed ;
SYSINIT:348B                                         ; For each entry on the UmbUsed array,
SYSINIT:348E                 rep stosb               ; Store 0
SYSINIT:3490                 mov     cx, 16          ; MAXUMB
SYSINIT:3493                 mov     di, offset UmbSize ; Okay...
SYSINIT:3493                                         ; for each entry on the UmbSize array,
SYSINIT:3496                 rep stosw               ; Store 0
SYSINIT:3498                 pop     es
SYSINIT:3499                 assume es:nothing
SYSINIT:3499                 pop     di
SYSINIT:349A                 pop     cx
SYSINIT:349B                 pop     ax
SYSINIT:349C                 retn
SYSINIT:349C InitVar         endp
SYSINIT:349C
SYSINIT:349D
SYSINIT:349D ; =============== S U B R O U T I N E =======================================
SYSINIT:349D
SYSINIT:349D
SYSINIT:349D FixMem          proc near               ; CODE XREF: HideUMBs+9↓p
SYSINIT:349D                 push    ax              ; scans the upper memory chain
SYSINIT:349D                                         ; and concatenates adjacent free MCBs
SYSINIT:349E                 push    bx
SYSINIT:349F                 push    cx
SYSINIT:34A0                 push    dx
SYSINIT:34A1                 push    es
SYSINIT:34A2                 call    fm_link         ; Link in UMBs
SYSINIT:34A5                 call    UmbHead         ; Get first upper-memory MCB address (0x9FFF)
SYSINIT:34A8                 jb      short fmX       ; (if couldn't get it, leave now).
SYSINIT:34AA                 mov     es, ax          ; It returns in AX, so move it to ES.
SYSINIT:34AC                 xor     dx, dx          ; We're keeping the address of the last MCB
SYSINIT:34AE                 mov     cx, dx          ; in CX... and the last owner
SYSINIT:34B0                 inc     dx              ; in dx as we go through the loop
SYSINIT:34B1
SYSINIT:34B1 fm10:                                   ; CODE XREF: FixMem+4C↓j
SYSINIT:34B1                 mov     al, es:0        ; [es:ARENA.SIGNATURE]
SYSINIT:34B1                                         ; if 'Z', don't repeat loop
SYSINIT:34B5                 mov     bx, es:1        ; [es:ARENA.OWNER] ; if not zero, do nothing
SYSINIT:34BA                 or      bx, dx          ; dx was owner of previous MCB
SYSINIT:34BC                 jnz     short fm30      ; If not both zero, don't cat.
SYSINIT:34BE
SYSINIT:34BE fm20:                                   ; [es:ARENA.SIZE]
SYSINIT:34BE                 mov     bx, es:3        ; Grab this block's Size,
SYSINIT:34C3                 mov     es, cx          ; Go back to prev MCB's address
SYSINIT:34C5                 assume es:nothing
SYSINIT:34C5                 mov     byte ptr es:0, al ; [es:ARENA.SIGNATURE]
SYSINIT:34C5                                         ; & move the SECOND sig here
SYSINIT:34C9                 add     bx, word ptr es:3 ; [es:ARENA.SIZE]
SYSINIT:34C9                                         ; Size += first MCB's size
SYSINIT:34CE                 add     bx, 1           ; And add one for the header
SYSINIT:34D1                 mov     word ptr es:3, bx ; [es:ARENA.SIZE] ; Write the size
SYSINIT:34D6
SYSINIT:34D6 fm30:                                   ; CODE XREF: FixMem+1F↑j
SYSINIT:34D6                 mov     cx, es          ; Save MCB address
SYSINIT:34D8                 mov     dx, word ptr es:1 ; [es:ARENA.OWNER] ; And remember its owner
SYSINIT:34DD                 mov     bx, es          ; Move to the next MCB
SYSINIT:34DF                 add     bx, word ptr es:3 ; [es:ARENA.SIZE]
SYSINIT:34E4                 inc     bx
SYSINIT:34E5                 mov     es, bx
SYSINIT:34E7                 assume es:nothing
SYSINIT:34E7                 cmp     al, 5Ah ; 'Z'   ; arena_signature_end
SYSINIT:34E9                 jnz     short fm10      ; If signature != 'Z', there are more.
SYSINIT:34EB
SYSINIT:34EB fmX:                                    ; CODE XREF: FixMem+B↑j
SYSINIT:34EB                 call    fm_unlink       ; Unlink UMBs
SYSINIT:34EE                 pop     es
SYSINIT:34EF                 pop     dx
SYSINIT:34F0                 pop     cx
SYSINIT:34F1                 pop     bx
SYSINIT:34F2                 pop     ax
SYSINIT:34F3                 retn
SYSINIT:34F3 FixMem          endp
SYSINIT:34F3
SYSINIT:34F4
SYSINIT:34F4 ; =============== S U B R O U T I N E =======================================
SYSINIT:34F4
SYSINIT:34F4
SYSINIT:34F4 fm_link         proc near               ; CODE XREF: FixMem+5↑p
SYSINIT:34F4                                         ; SYSINIT:378C↓p ...
SYSINIT:34F4                 mov     ax, 5802h       ; DOS_CHECK_UMBLINK
SYSINIT:34F7                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:34F7                                         ; AL = function code: (DOS 5beta) get UMB link state
SYSINIT:34F9                 push    es
SYSINIT:34FA                 push    cs
SYSINIT:34FB                 pop     es
SYSINIT:34FC                 assume es:SYSINIT
SYSINIT:34FC                 mov     es:fm_umb, al   ; store current link-state (to use/set later)
SYSINIT:3500                 pop     es
SYSINIT:3501                 assume es:nothing
SYSINIT:3501                 mov     ax, 5803h       ; DOS_SET_UMBLINK
SYSINIT:3504                 mov     bx, 1
SYSINIT:3507                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:3507                                         ; AL = function code: (DOS 5beta) set UMB link state
SYSINIT:3509                 retn
SYSINIT:3509 fm_link         endp
SYSINIT:3509
SYSINIT:350A
SYSINIT:350A ; =============== S U B R O U T I N E =======================================
SYSINIT:350A
SYSINIT:350A
SYSINIT:350A fm_unlink       proc near               ; CODE XREF: FixMem:fmX↑p
SYSINIT:350A                                         ; UmbTest+B↓p
SYSINIT:350A                 xor     bx, bx
SYSINIT:350C                 push    ds
SYSINIT:350D                 push    cs
SYSINIT:350E                 pop     ds
SYSINIT:350F                 assume ds:SYSINIT
SYSINIT:350F                 mov     bl, fm_umb      ; old link-state (to set again)
SYSINIT:3513                 pop     ds
SYSINIT:3514                 assume ds:nothing
SYSINIT:3514                 mov     ax, 5803h       ; DOS_SET_UMBLINK
SYSINIT:3517                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:3517                                         ; AL = function code: (DOS 5beta) set UMB link state
SYSINIT:3519                 retn
SYSINIT:3519 fm_unlink       endp
SYSINIT:3519
SYSINIT:351A
SYSINIT:351A ; =============== S U B R O U T I N E =======================================
SYSINIT:351A
SYSINIT:351A
SYSINIT:351A ParseVar        proc near               ; CODE XREF: doconf+322↑p
SYSINIT:351A                 push    di              ; parses [/S][/L:umb[,size][;umb[,size]]*]
SYSINIT:351A                                         ;   and builds the table laid out in highvar.inc
SYSINIT:351A                                         ; ENTRY:
SYSINIT:351A                                         ;   ES:SI points to command tail of LoadHigh/DeviceHigh
SYSINIT:351A                                         ;       (whitespace ok)
SYSINIT:351A                                         ; EXIT:
SYSINIT:351A                                         ;   ES:SI points to first character in child program name
SYSINIT:351B                 push    ds
SYSINIT:351C                 push    es
SYSINIT:351D                 push    es              ; Make DS:SI point to it, as well as ES:SI
SYSINIT:351E                 pop     ds              ; (regardless if we're in devhigh or loadhigh)
SYSINIT:351F                 cld
SYSINIT:3520
SYSINIT:3520 pv10:                                   ; CODE XREF: ParseVar+A↓j
SYSINIT:3520                                         ; ParseVar+28↓j ...
SYSINIT:3520                 lodsb                   ; here, ES:SI=="  /L..."--must eat whitespace
SYSINIT:3521                 call    isWhite
SYSINIT:3524                 jz      short pv10      ; ES:SI==" /L..."--keep eating.
SYSINIT:3526                 cmp     al, 2Fh ; '/'   ; SWTCH ; ES:SI=="/L..."--go process a switch
SYSINIT:3528                 jz      short pv20
SYSINIT:352A                 dec     si              ; Backup--it's now "odule options", and we need
SYSINIT:352B                 clc                     ; that "m" we just read (or whatever it is).
SYSINIT:352C                 jmp     short pvX       ; Then return with carry clear == we're done.
SYSINIT:352E ; ---------------------------------------------------------------------------
SYSINIT:352E
SYSINIT:352E pv20:                                   ; CODE XREF: ParseVar+E↑j
SYSINIT:352E                 lodsb                   ; Just read 'S' or 'L', hopefully
SYSINIT:352F                 and     al, 0DFh        ; So we make it upper-case, and...
SYSINIT:3531                 cmp     al, 53h ; 'S'   ; just read 'S'?
SYSINIT:3533                 jnz     short pv30
SYSINIT:3535                 call    incArgc         ; If it's /S, it's another arg for LH to skip.
SYSINIT:3535                                         ;
SYSINIT:3535                                         ; Note: 'inc byte [cs:fm_argc]' would be enough here
SYSINIT:3535                                         ; Erdogan Tan - 19/04/2019 (Retro DOS v4) - 11/07/2023
SYSINIT:3538                 push    es
SYSINIT:3539                 push    cs
SYSINIT:353A                 pop     es
SYSINIT:353B                 assume es:SYSINIT
SYSINIT:353B                 mov     es:fUmbTiny, 1  ; /S, so ES:SI=="  /L..." or " module opts", or
SYSINIT:3541                 pop     es
SYSINIT:3542                 assume es:nothing
SYSINIT:3542                 jmp     short pv10      ; possibly even "/L...".
SYSINIT:3544 ; ---------------------------------------------------------------------------
SYSINIT:3544
SYSINIT:3544 pv30:                                   ; CODE XREF: ParseVar+19↑j
SYSINIT:3544                 cmp     al, 4Ch ; 'L'   ; If it's not 'L' either, then it's a bad switch!
SYSINIT:3546                 jnz     short pvE1
SYSINIT:3548                 call    incArgc
SYSINIT:354B                 call    parseL
SYSINIT:354E                 jnb     short pv10      ; If no carry, go back and look for more
SYSINIT:3550                 dec     si              ; Else, back up and exit.
SYSINIT:3551                 jmp     short pvErr
SYSINIT:3553 ; ---------------------------------------------------------------------------
SYSINIT:3553
SYSINIT:3553 pvE1:                                   ; CODE XREF: ParseVar+2C↑j
SYSINIT:3553                 mov     ax, 3           ; PV_InvSwt ; Unrecognized switch passed
SYSINIT:3556
SYSINIT:3556 pvErr:                                  ; CODE XREF: ParseVar+37↑j
SYSINIT:3556                 dec     si
SYSINIT:3557                 dec     si
SYSINIT:3558                 stc
SYSINIT:3559
SYSINIT:3559 pvX:                                    ; CODE XREF: ParseVar+12↑j
SYSINIT:3559                 pop     es
SYSINIT:355A                 pop     ds
SYSINIT:355B                 pop     di
SYSINIT:355C                 retn
SYSINIT:355C ParseVar        endp
SYSINIT:355C
SYSINIT:355D
SYSINIT:355D ; =============== S U B R O U T I N E =======================================
SYSINIT:355D
SYSINIT:355D
SYSINIT:355D parseL          proc near               ; CODE XREF: ParseVar+31↑p
SYSINIT:355D                 lodsb
SYSINIT:355E                 cmp     al, 3Ah ; ':'   ; Make sure they did /L:
SYSINIT:3560                 jnz     short plE1      ; If they didn't, return with carry set.
SYSINIT:3562
SYSINIT:3562 pl10:                                   ; CODE XREF: parseL+1A↓j
SYSINIT:3562                                         ; parseL+3F↓j
SYSINIT:3562                 call    GetXNum         ; After this, it's ",size" or ";umb" or " mod"
SYSINIT:3565                 jb      short plE2      ; And error if it's a bad number.
SYSINIT:3567                 call    convUMB         ; Convert any address to a UMB number
SYSINIT:356A                 mov     cl, al          ; Remember the UMB number
SYSINIT:356C                 call    stowUMB         ; Mark this UMB # as used;
SYSINIT:356F                 jb      short plE2      ; If it was already marked, it'll error
SYSINIT:3571                 call    incArgc         ; Each UMB number is another arg for LH to skip
SYSINIT:3571                                         ; ('inc byte [cs:fm_argc]' would be enough)
SYSINIT:3571                                         ; Erdogan Tan - 08/04/2019 (Retro DOS v4) - 11/07/2023
SYSINIT:3574                 lodsb
SYSINIT:3575                 cmp     al, 3Bh ; ';'   ; Did "umb;" ?
SYSINIT:3577                 jz      short pl10      ; Yep: go back and get another UMB.
SYSINIT:3579                 call    isWhite         ; Did "umb " ?
SYSINIT:357C                 jz      short plX       ; Yep: return (it'll go back to whitespace)
SYSINIT:357E                 call    isEOL           ; Did "umb" ?
SYSINIT:3581                 jz      short plSwX     ; If so, backup and exit like everything's ok
SYSINIT:3583                 cmp     al, 2Fh ; '/'   ; Did "umb/" ? (as in, "/L:1,100;2/S")
SYSINIT:3585                 jz      short plSwX     ; If so, back up ES:SI one character and return
SYSINIT:3587                 cmp     al, 2Ch ; ','   ; Did "umb," ?
SYSINIT:3589                 jnz     short plE1      ; Just what the heck DID they do? Return error.
SYSINIT:358B                 call    GetXNum         ; Stop on "size;" or "size " or anything else
SYSINIT:358E                 jb      short plE1      ; And error if it's a bad size.
SYSINIT:3590                 call    toPara          ; Convert from bytes to paragraphs
SYSINIT:3593                 call    stowSiz         ; CL still has the UMB number for this routine
SYSINIT:3596                 call    incArgc         ; Each UMB size is another arg for LH to skip
SYSINIT:3596                                         ; ('inc byte [cs:fm_argc]')
SYSINIT:3599                 lodsb
SYSINIT:359A                 cmp     al, 3Bh ; ';'   ; They did "umb,size;", so get another UMB.
SYSINIT:359C                 jz      short pl10
SYSINIT:359E                 call    isWhite         ; Did it end with whitespace?
SYSINIT:35A1                 jz      short plX       ; If so, we're done here--go back.
SYSINIT:35A3                 call    isEOL           ; Did they do "umb,size" and end??? (stupid)
SYSINIT:35A6                 jz      short plSwX     ; If so, backup and exit like everything's ok
SYSINIT:35A8                 cmp     al, 2Fh ; '/'   ; SWTCH ; Did they do "umb,size/" ?
SYSINIT:35AA                 jz      short plSwX     ; If so, again, we're done here.
SYSINIT:35AC
SYSINIT:35AC plE1:                                   ; CODE XREF: parseL+3↑j
SYSINIT:35AC                                         ; parseL+2C↑j ...
SYSINIT:35AC                 mov     ax, 1           ; PV_InvArg ; If not, we don't know WHAT they did.
SYSINIT:35AF                 dec     si
SYSINIT:35B0                 stc
SYSINIT:35B1                 retn
SYSINIT:35B2 ; ---------------------------------------------------------------------------
SYSINIT:35B2
SYSINIT:35B2 plE2:                                   ; CODE XREF: parseL+8↑j
SYSINIT:35B2                                         ; parseL+12↑j
SYSINIT:35B2                 mov     ax, 2           ; In this case, they've specified a UMB twice
SYSINIT:35B5                 stc
SYSINIT:35B6                 retn
SYSINIT:35B7 ; ---------------------------------------------------------------------------
SYSINIT:35B7
SYSINIT:35B7 plSwX:                                  ; CODE XREF: parseL+24↑j
SYSINIT:35B7                                         ; parseL+28↑j ...
SYSINIT:35B7                 dec     si              ; If we hit a '/' character, back up one char
SYSINIT:35B7                                         ; so the whitespace checker will see it too.
SYSINIT:35B8
SYSINIT:35B8 plX:                                    ; CODE XREF: parseL+1F↑j
SYSINIT:35B8                                         ; parseL+44↑j
SYSINIT:35B8                 clc                     ; Then just return with carry clear, so
SYSINIT:35B8                                         ; ParseVar will go about its business.
SYSINIT:35B9                 retn
SYSINIT:35B9 parseL          endp
SYSINIT:35B9
SYSINIT:35BA
SYSINIT:35BA ; =============== S U B R O U T I N E =======================================
SYSINIT:35BA
SYSINIT:35BA
SYSINIT:35BA incArgc         proc near               ; CODE XREF: ParseVar+1B↑p
SYSINIT:35BA                                         ; ParseVar+2E↑p ...
SYSINIT:35BA                 push    ax              ; increments fm_argc,
SYSINIT:35BA                                         ; for use with LoadHigh command-line parsing
SYSINIT:35BA                                         ; ***
SYSINIT:35BA                                         ; ('inc byte [cs:fm_argc]' would be enough)
SYSINIT:35BA                                         ; Erdogan Tan - 11/07/2023
SYSINIT:35BB                 push    ds
SYSINIT:35BC                 push    cs
SYSINIT:35BD                 pop     ds
SYSINIT:35BE                 assume ds:SYSINIT
SYSINIT:35BE                 mov     al, fm_argc     ; Obtain previous value of fm_argc,
SYSINIT:35C1                 pop     ds
SYSINIT:35C2                 assume ds:nothing
SYSINIT:35C2                 inc     al              ; Increment it,
SYSINIT:35C4                 push    es
SYSINIT:35C5                 push    cs
SYSINIT:35C6                 pop     es
SYSINIT:35C7                 assume es:SYSINIT
SYSINIT:35C7                 mov     es:fm_argc, al  ; And store it right back.
SYSINIT:35CB                 pop     es
SYSINIT:35CC                 assume es:nothing
SYSINIT:35CC                 pop     ax
SYSINIT:35CD                 retn
SYSINIT:35CD incArgc         endp
SYSINIT:35CD
SYSINIT:35CE
SYSINIT:35CE ; =============== S U B R O U T I N E =======================================
SYSINIT:35CE
SYSINIT:35CE
SYSINIT:35CE isEOL           proc near               ; CODE XREF: parseL+21↑p
SYSINIT:35CE                                         ; parseL+46↑p
SYSINIT:35CE                 cmp     al, 0           ; Null-terminator
SYSINIT:35D0                 jz      short ieX
SYSINIT:35D2                 cmp     al, 0Dh         ; CR ; Carriage Return
SYSINIT:35D4                 jz      short ieX
SYSINIT:35D6                 cmp     al, 0Ah         ; LF ; LineFeed
SYSINIT:35D8
SYSINIT:35D8 ieX:                                    ; CODE XREF: isEOL+2↑j
SYSINIT:35D8                                         ; isEOL+6↑j
SYSINIT:35D8                 retn                    ; zf=1 if AL contains EOL character
SYSINIT:35D8 isEOL           endp
SYSINIT:35D8
SYSINIT:35D9
SYSINIT:35D9 ; =============== S U B R O U T I N E =======================================
SYSINIT:35D9
SYSINIT:35D9
SYSINIT:35D9 isWhite         proc near               ; CODE XREF: ParseVar+7↑p
SYSINIT:35D9                                         ; parseL+1C↑p ...
SYSINIT:35D9                 cmp     al, 20h ; ' '   ; Space
SYSINIT:35DB                 jz      short iwX
SYSINIT:35DD                 cmp     al, 3Dh ; '='   ; Equals (treat as whitespace)
SYSINIT:35DF                 jz      short iwX
SYSINIT:35E1                 cmp     al, 9           ; Tab
SYSINIT:35E3
SYSINIT:35E3 iwX:                                    ; CODE XREF: isWhite+2↑j
SYSINIT:35E3                                         ; isWhite+6↑j
SYSINIT:35E3                 retn                    ; zf=1 if AL contains space,
SYSINIT:35E3 isWhite         endp                    ;         tab or equals character
SYSINIT:35E3
SYSINIT:35E4
SYSINIT:35E4 ; =============== S U B R O U T I N E =======================================
SYSINIT:35E4
SYSINIT:35E4
SYSINIT:35E4 unMarkUMB       proc near               ; CODE XREF: _hideUMB_+22↓p
SYSINIT:35E4                 push    ax              ; marks a given UMB as unused
SYSINIT:35E4                                         ; AL contains UMB number
SYSINIT:35E5                 push    bx
SYSINIT:35E6                 push    di
SYSINIT:35E7                 push    es
SYSINIT:35E8                 push    cs
SYSINIT:35E9                 pop     es
SYSINIT:35EA                 assume es:SYSINIT
SYSINIT:35EA                 xor     ah, ah
SYSINIT:35EC                 mov     bx, ax
SYSINIT:35EE                 mov     es:UmbUsed[bx], 0
SYSINIT:35F4                 cmp     es:UmbLoad, al
SYSINIT:35F9                 jnz     short umu10     ; If unmarked the load UMB,
SYSINIT:35F9                                         ; load into convent.
SYSINIT:35FB                 mov     es:UmbLoad, 0
SYSINIT:3601
SYSINIT:3601 umu10:                                  ; CODE XREF: unMarkUMB+15↑j
SYSINIT:3601                 pop     es
SYSINIT:3602                 assume es:nothing
SYSINIT:3602                 pop     di
SYSINIT:3603                 pop     bx
SYSINIT:3604                 pop     ax
SYSINIT:3605                 retn
SYSINIT:3605 unMarkUMB       endp
SYSINIT:3605
SYSINIT:3606
SYSINIT:3606 ; =============== S U B R O U T I N E =======================================
SYSINIT:3606
SYSINIT:3606
SYSINIT:3606 stowUMB         proc near               ; CODE XREF: parseL+F↑p
SYSINIT:3606                 cmp     al, 16          ; MAXUMB
SYSINIT:3608                 jb      short su10
SYSINIT:360A                 stc                     ; Ooops-- UMB # >= MAXUMB
SYSINIT:360B                 retn
SYSINIT:360C ; ---------------------------------------------------------------------------
SYSINIT:360C
SYSINIT:360C su10:                                   ; CODE XREF: stowUMB+2↑j
SYSINIT:360C                 push    bx
SYSINIT:360D                 push    di
SYSINIT:360E                 push    si
SYSINIT:360F                 push    ds
SYSINIT:3610                 push    es
SYSINIT:3611                 push    cs
SYSINIT:3612                 pop     es
SYSINIT:3613                 assume es:SYSINIT
SYSINIT:3613                 push    cs
SYSINIT:3614                 pop     ds
SYSINIT:3615                 assume ds:SYSINIT
SYSINIT:3615                 cmp     UmbLoad, 0FFh   ; UNSPECIFIED
SYSINIT:3615                                         ; If this, we haven't been here before
SYSINIT:361A                 jnz     short su20
SYSINIT:361C                 mov     UmbLoad, al     ; So remember this UMB as the load UMB slot.
SYSINIT:361F
SYSINIT:361F su20:                                   ; CODE XREF: stowUMB+14↑j
SYSINIT:361F                 or      al, al          ; If they gave UMB 0, there's really nothing
SYSINIT:3621                 jz      short su30      ; that we should do here.
SYSINIT:3623                 mov     bl, al
SYSINIT:3625                 xor     bh, bh
SYSINIT:3627                 mov     ax, 1           ; Now, AX = 1, and BX = UMB Number
SYSINIT:362A                 xchg    al, es:UmbUsed[bx]
SYSINIT:362F                 or      al, al          ; If it was already 1,
SYSINIT:362F                                         ; then al==1... and that means an error.
SYSINIT:3631                 jz      short su30
SYSINIT:3633                 stc                     ; OOOPS! This one's been used before. :(
SYSINIT:3634
SYSINIT:3634 su30:                                   ; CODE XREF: stowUMB+1B↑j
SYSINIT:3634                                         ; stowUMB+2B↑j
SYSINIT:3634                 pop     es
SYSINIT:3635                 assume es:nothing
SYSINIT:3635                 pop     ds
SYSINIT:3636                 assume ds:nothing
SYSINIT:3636                 pop     si
SYSINIT:3637                 pop     di
SYSINIT:3638                 pop     bx
SYSINIT:3639                 retn
SYSINIT:3639 stowUMB         endp
SYSINIT:3639
SYSINIT:363A
SYSINIT:363A ; =============== S U B R O U T I N E =======================================
SYSINIT:363A
SYSINIT:363A
SYSINIT:363A stowSiz         proc near               ; CODE XREF: parseL+36↑p
SYSINIT:363A                                         ; StoLoadSize+E↓p
SYSINIT:363A                 push    bx
SYSINIT:363B                 push    di
SYSINIT:363C                 push    es
SYSINIT:363D                 push    cs
SYSINIT:363E                 pop     es              ; mov [cs:bx+UmbSize],ax !!! ; 08/09/2023
SYSINIT:363F                 assume es:SYSINIT
SYSINIT:363F                 mov     bl, cl          ; Now bl==UMB number, AX==size
SYSINIT:3641                 mov     bh, 0           ; bx==UMB number, AX==size
SYSINIT:3643                 shl     bl, 1           ; bx==offset into array
SYSINIT:3645                 mov     es:UmbSize[bx], ax ; Store the size
SYSINIT:364A                 pop     es
SYSINIT:364B                 assume es:nothing
SYSINIT:364B                 pop     di
SYSINIT:364C                 pop     bx
SYSINIT:364D                 retn
SYSINIT:364D stowSiz         endp
SYSINIT:364D
SYSINIT:364D ; ---------------------------------------------------------------------------
SYSINIT:364E gnradix         dw 0                    ; DATA XREF: toDigit↓r
SYSINIT:364E                                         ; GetXNum+C↓w ...
SYSINIT:364E                                         ; Must be a word--16x16 multiplication
SYSINIT:3650
SYSINIT:3650 ; =============== S U B R O U T I N E =======================================
SYSINIT:3650
SYSINIT:3650
SYSINIT:3650 toDigit         proc near               ; CODE XREF: GetXNum+16↓p
SYSINIT:3650                                         ; GetXNum+3A↓p
SYSINIT:3650                 cmp     cs:gnradix, 10h
SYSINIT:3656                 jnz     short td10      ; Don't check hex digits if radix isn't 16
SYSINIT:3658                 cmp     cl, 61h ; 'a'
SYSINIT:365B                 jb      short td20
SYSINIT:365D                 cmp     cl, 66h ; 'f'
SYSINIT:3660                 ja      short tdE       ; Nothing valid above 'f' at all...
SYSINIT:3662                 sub     cl, 57h         ; 'a'-10 ; 87 ; Make 'a'==10 and return.
SYSINIT:3665                 retn
SYSINIT:3666 ; ---------------------------------------------------------------------------
SYSINIT:3666
SYSINIT:3666 td20:                                   ; CODE XREF: toDigit+B↑j
SYSINIT:3666                 cmp     cl, 41h ; 'A'   ; Below 'A'? Not a letter...
SYSINIT:3669                 jb      short td10
SYSINIT:366B                 cmp     cl, 46h ; 'F'   ; Above 'F'? Not a digit.
SYSINIT:366E                 ja      short tdE
SYSINIT:3670                 sub     cl, 37h         ; 'A'-10 ; 55 ; Make 'A'==10 and return.
SYSINIT:3673                 retn
SYSINIT:3674 ; ---------------------------------------------------------------------------
SYSINIT:3674
SYSINIT:3674 td10:                                   ; CODE XREF: toDigit+6↑j
SYSINIT:3674                                         ; toDigit+19↑j
SYSINIT:3674                 cmp     cl, 30h ; '0'   ; If less than zero,
SYSINIT:3677                 jb      short tdE       ; Done.
SYSINIT:3679                 cmp     cl, 39h ; '9'   ; Or, if greater than nine,
SYSINIT:367C                 ja      short tdE       ; Done.
SYSINIT:367E                 sub     cl, 30h ; '0'   ; Okay--make '0'==0 and return.
SYSINIT:3681                 retn
SYSINIT:3682 ; ---------------------------------------------------------------------------
SYSINIT:3682
SYSINIT:3682 tdE:                                    ; CODE XREF: toDigit+10↑j
SYSINIT:3682                                         ; toDigit+1E↑j ...
SYSINIT:3682                 stc
SYSINIT:3683                 retn
SYSINIT:3683 toDigit         endp
SYSINIT:3683
SYSINIT:3684
SYSINIT:3684 ; =============== S U B R O U T I N E =======================================
SYSINIT:3684
SYSINIT:3684
SYSINIT:3684 GetXNum         proc near               ; CODE XREF: parseL:pl10↑p
SYSINIT:3684                                         ; parseL+2E↑p
SYSINIT:3684                 push    bx              ; reads a 32-bit ASCII number at ES:SI
SYSINIT:3684                                         ; and returns it in DX:AX
SYSINIT:3685                 push    cx
SYSINIT:3686                 push    ds
SYSINIT:3687                 cld
SYSINIT:3688                 xor     ax, ax
SYSINIT:368A                 xor     bx, bx
SYSINIT:368C                 xor     cx, cx
SYSINIT:368E                 xor     dx, dx          ; Start with 0 (makes sense)
SYSINIT:3690                 mov     cs:gnradix, 10  ; And default to a radix of 10 (dec)
SYSINIT:3697                 mov     cl, es:[si]
SYSINIT:369A                 call    toDigit
SYSINIT:369D                 jb      short gxnE      ; If it's not a digit, leave now.
SYSINIT:369F                 or      cl, cl
SYSINIT:36A1                 jnz     short gxn20     ; Doesn't have '0x'
SYSINIT:36A3                 mov     cl, es:[si+1]
SYSINIT:36A7                 cmp     cl, 'x'         ; Either 'x'...
SYSINIT:36AA                 jz      short gxn10
SYSINIT:36AC                 cmp     cl, 'X'
SYSINIT:36AF                 jnz     short gxn20
SYSINIT:36B1
SYSINIT:36B1 gxn10:                                  ; CODE XREF: GetXNum+26↑j
SYSINIT:36B1                 mov     cs:gnradix, 16
SYSINIT:36B8                 inc     si              ; Since we read "0x", march over it.
SYSINIT:36B9                 inc     si
SYSINIT:36BA
SYSINIT:36BA gxn20:                                  ; CODE XREF: GetXNum+1D↑j
SYSINIT:36BA                                         ; GetXNum+2B↑j ...
SYSINIT:36BA                 mov     cl, es:[si]     ; Now DX:AX=current total, CH=0/CL=char
SYSINIT:36BD                 inc     si
SYSINIT:36BE                 call    toDigit         ; Accepts only valid digits, A-F -> 10-16
SYSINIT:36C1                 jb      short gxnQ      ; <- Ah... wasn't a digit. Stop.
SYSINIT:36C3                 call    mul32
SYSINIT:36C6                 jb      short gxnX
SYSINIT:36C8                 add     ax, cx
SYSINIT:36CA                 adc     dx, bx
SYSINIT:36CC                 jb      short gxnX
SYSINIT:36CE                 jmp     short gxn20
SYSINIT:36D0 ; ---------------------------------------------------------------------------
SYSINIT:36D0
SYSINIT:36D0 gxnE:                                   ; CODE XREF: GetXNum+19↑j
SYSINIT:36D0                 stc
SYSINIT:36D1                 jmp     short gxnX
SYSINIT:36D3 ; ---------------------------------------------------------------------------
SYSINIT:36D3
SYSINIT:36D3 gxnQ:                                   ; CODE XREF: GetXNum+3D↑j
SYSINIT:36D3                 dec     si
SYSINIT:36D4                 clc
SYSINIT:36D5
SYSINIT:36D5 gxnX:                                   ; CODE XREF: GetXNum+42↑j
SYSINIT:36D5                                         ; GetXNum+48↑j ...
SYSINIT:36D5                 pop     ds
SYSINIT:36D6                 pop     cx
SYSINIT:36D7                 pop     bx
SYSINIT:36D8                 retn
SYSINIT:36D8 GetXNum         endp
SYSINIT:36D8
SYSINIT:36D9
SYSINIT:36D9 ; =============== S U B R O U T I N E =======================================
SYSINIT:36D9
SYSINIT:36D9
SYSINIT:36D9 mul32           proc near               ; CODE XREF: GetXNum+3F↑p
SYSINIT:36D9                 push    ax              ; multiplies the number in DX:AX by gnradix
SYSINIT:36D9                                         ; DX=old:hi, AX=old:lo, TOS=old:lo, BX=0
SYSINIT:36DA                 mov     ax, dx
SYSINIT:36DC                 mul     cs:gnradix      ; DX=?, AX=new:hi, TOS=old:lo, BX=0
SYSINIT:36E1                 jb      short m32E      ; Too big?
SYSINIT:36E3                 mov     dx, ax          ; DX=new:hi, AX=new:hi, TOS=old:lo, BX=0
SYSINIT:36E5                 pop     ax              ; DX=new:hi, AX=old:lo, TOS=orig, BX=0
SYSINIT:36E6                 xchg    dx, bx          ; DX=0, AX=old:lo, TOS=orig, BX=new:hi
SYSINIT:36E8                 mul     cs:gnradix      ; DX=carry, AX=new:lo, TOS=orig, BX=new:hi
SYSINIT:36ED                 xchg    dx, bx
SYSINIT:36EF                 add     dx, bx          ; DX=new:hi, AX=new:lo, TOS=orig, BX=carry
SYSINIT:36F1                 xor     bx, bx          ; BX=0
SYSINIT:36F3                 retn
SYSINIT:36F4 ; ---------------------------------------------------------------------------
SYSINIT:36F4
SYSINIT:36F4 m32E:                                   ; CODE XREF: mul32+8↑j
SYSINIT:36F4                 pop     ax
SYSINIT:36F5                 retn
SYSINIT:36F5 mul32           endp
SYSINIT:36F5
SYSINIT:36F6
SYSINIT:36F6 ; =============== S U B R O U T I N E =======================================
SYSINIT:36F6
SYSINIT:36F6
SYSINIT:36F6 toPara          proc near               ; CODE XREF: parseL+33↑p
SYSINIT:36F6                 push    cx              ; divides DX:AX by 16; result in AX only
SYSINIT:36F7                 mov     cl, 4           ; DX:AX=HHHH hhhh hhhh hhhh:LLLL llll llll llll
SYSINIT:36F9                 shr     ax, cl          ; DX:AX=HHHH hhhh hhhh hhhh:0000 LLLL llll llll
SYSINIT:36FB                 xchg    ax, dx          ; DX:AX=0000 LLLL llll llll:HHHH hhhh hhhh hhhh
SYSINIT:36FC                 mov     cl, 12
SYSINIT:36FE                 shl     ax, cl          ; DX:AX=0000 LLLL llll llll:hhhh 0000 0000 0000
SYSINIT:3700                 or      ax, dx          ; AX=hhhh LLLL llll llll
SYSINIT:3702                 pop     cx
SYSINIT:3703                 retn
SYSINIT:3703 toPara          endp
SYSINIT:3703
SYSINIT:3704
SYSINIT:3704 ; =============== S U B R O U T I N E =======================================
SYSINIT:3704
SYSINIT:3704
SYSINIT:3704 UmbHead         proc near               ; CODE XREF: FixMem+8↑p
SYSINIT:3704                                         ; AddrToUmb+5↓p ...
SYSINIT:3704                 push    si
SYSINIT:3705                 push    ds
SYSINIT:3706                 push    es
SYSINIT:3707                 mov     ah, 52h         ; GET_IN_VARS
SYSINIT:3709                 int     21h             ; DOS - 2+ internal - GET LIST OF LISTS
SYSINIT:3709                                         ; Return: ES:BX -> DOS list of lists
SYSINIT:370B                 mov     ax, es:8Ch      ; [es:DOS_UMB_HEAD]
SYSINIT:370F                 cmp     ax, 0FFFFh
SYSINIT:3712                 jz      short uhE
SYSINIT:3714                 clc
SYSINIT:3715                 jmp     short uhX
SYSINIT:3717 ; ---------------------------------------------------------------------------
SYSINIT:3717
SYSINIT:3717 uhE:                                    ; CODE XREF: UmbHead+E↑j
SYSINIT:3717                 stc
SYSINIT:3718
SYSINIT:3718 uhX:                                    ; CODE XREF: UmbHead+11↑j
SYSINIT:3718                 pop     es
SYSINIT:3719                 pop     ds
SYSINIT:371A                 pop     si
SYSINIT:371B                 retn
SYSINIT:371B UmbHead         endp
SYSINIT:371B
SYSINIT:371C
SYSINIT:371C ; =============== S U B R O U T I N E =======================================
SYSINIT:371C
SYSINIT:371C
SYSINIT:371C isSysMCB        proc near               ; CODE XREF: AddrToUmb+14↓p
SYSINIT:371C                                         ; hideUMB:hu10↓p ...
SYSINIT:371C                 push    ax              ; sets ZF if ES points to an MCB owned by "SC"
SYSINIT:371D                 mov     ax, es:1        ; [es:ARENA.OWNER]
SYSINIT:3721                 cmp     ax, 8           ; SystemPSPOwner ; 8 (for US or Japan) is valid
SYSINIT:3724                 jz      short ism10
SYSINIT:3726                 cmp     ax, 9           ; JapanPSPOwner ; 9 (for Japan) is valid
SYSINIT:3729                 jz      short ism10
SYSINIT:372B                 jmp     short ismX
SYSINIT:372D ; ---------------------------------------------------------------------------
SYSINIT:372D
SYSINIT:372D ism10:                                  ; CODE XREF: isSysMCB+8↑j
SYSINIT:372D                                         ; isSysMCB+D↑j
SYSINIT:372D                 mov     ax, es:8        ; [es:ARENA.NAME]
SYSINIT:3731                 cmp     ax, 4353h       ; 'SC'
SYSINIT:3734
SYSINIT:3734 ismX:                                   ; CODE XREF: isSysMCB+F↑j
SYSINIT:3734                 pop     ax
SYSINIT:3735                 retn
SYSINIT:3735 isSysMCB        endp
SYSINIT:3735
SYSINIT:3736
SYSINIT:3736 ; =============== S U B R O U T I N E =======================================
SYSINIT:3736
SYSINIT:3736
SYSINIT:3736 AddrToUmb       proc near               ; CODE XREF: convUMB+8↓p
SYSINIT:3736                 push    cx              ; converts a segment address in AX
SYSINIT:3736                                         ; to its appropriate UMB number
SYSINIT:3737                 push    dx
SYSINIT:3738                 push    es
SYSINIT:3739                 mov     dx, ax          ; DX = address to search for
SYSINIT:373B                 call    UmbHead         ; AX = first segment
SYSINIT:373E                 jb      short atuE      ; If it couldn't get it, error out
SYSINIT:3740                 mov     es, ax
SYSINIT:3742                 xor     cx, cx          ; 0
SYSINIT:3744
SYSINIT:3744 atu10:                                  ; CODE XREF: AddrToUmb+2C↓j
SYSINIT:3744                 mov     ax, es
SYSINIT:3746                 cmp     ax, dx          ; Present segment >= given segment?
SYSINIT:3748                 jnb     short atuX      ; yes, done.
SYSINIT:374A                 call    isSysMCB        ; Returns with ZF set if this is a system MCB
SYSINIT:374D                 jnz     short atu20
SYSINIT:374F                 inc     cx              ; If it _was_ a system MCB, we're in a new UMB.
SYSINIT:3750
SYSINIT:3750 atu20:                                  ; CODE XREF: AddrToUmb+17↑j
SYSINIT:3750                 mov     al, es:0        ; [es:ARENA.SIGNATURE]
SYSINIT:3754                 cmp     al, 5Ah ; 'Z'
SYSINIT:3756                 jz      short atu30     ; 'Z' means this was the last MCB... that's it.
SYSINIT:3758                 mov     ax, es
SYSINIT:375A                 add     ax, es:3        ; [es:ARENA.SIZE]
SYSINIT:375F                 inc     ax
SYSINIT:3760                 mov     es, ax
SYSINIT:3762                 jmp     short atu10
SYSINIT:3764 ; ---------------------------------------------------------------------------
SYSINIT:3764
SYSINIT:3764 atu30:                                  ; CODE XREF: AddrToUmb+20↑j
SYSINIT:3764                 mov     ax, es
SYSINIT:3766                 add     ax, es:3        ; [es:ARENA.SIZE]
SYSINIT:376B                 cmp     ax, dx          ; Present >= given?
SYSINIT:376D                 jnb     short atuX      ; Yep! It _was_ inside.
SYSINIT:376F
SYSINIT:376F atuE:                                   ; CODE XREF: AddrToUmb+8↑j
SYSINIT:376F                 xor     cx, cx
SYSINIT:3771                 dec     cx              ; Address is above UM Range,
SYSINIT:3771                                         ; AX will return as 0FFFFh.
SYSINIT:3772
SYSINIT:3772 atuX:                                   ; CODE XREF: AddrToUmb+12↑j
SYSINIT:3772                                         ; AddrToUmb+37↑j
SYSINIT:3772                 mov     ax, cx          ; Return the UMB number in AX (0==conv)
SYSINIT:3774                 pop     es
SYSINIT:3775                 pop     dx
SYSINIT:3776                 pop     cx
SYSINIT:3777                 retn
SYSINIT:3777 AddrToUmb       endp
SYSINIT:3777
SYSINIT:3778
SYSINIT:3778 ; =============== S U B R O U T I N E =======================================
SYSINIT:3778
SYSINIT:3778
SYSINIT:3778 convUMB         proc near               ; CODE XREF: parseL+A↑p
SYSINIT:3778                 cmp     cs:gnradix, 10h ; convert address to UMB number after GetXNum
SYSINIT:3778                                         ; (GetXNum has read a hex number)
SYSINIT:377E                 jnz     short cu10      ; GetXNum didn't read in hex, it is not an addr
SYSINIT:3780                 call    AddrToUmb       ; convert the address to a UMB number
SYSINIT:3783                 cmp     ax, 0FFFFh
SYSINIT:3786                 jnz     short cu10
SYSINIT:3788                 inc     ax              ; If too high, ignore it (make it conventional)
SYSINIT:3789
SYSINIT:3789 cu10:                                   ; CODE XREF: convUMB+6↑j
SYSINIT:3789                                         ; convUMB+E↑j
SYSINIT:3789                 retn
SYSINIT:3789 convUMB         endp
SYSINIT:3789
SYSINIT:378A ; ---------------------------------------------------------------------------
SYSINIT:378A
SYSINIT:378A setUMBs:                                ; CODE XREF: HideUMBs+C↓p
SYSINIT:378A                 push    ax
SYSINIT:378B                 push    bx
SYSINIT:378C                 call    fm_link
SYSINIT:378F                 pop     bx
SYSINIT:3790                 pop     ax
SYSINIT:3791                 retn
SYSINIT:3792 ; ---------------------------------------------------------------------------
SYSINIT:3792
SYSINIT:3792 loadLow:                                ; loadLow subroutine is not used anywhere
SYSINIT:3792                 push    ds              ; of PCDOS 7.1 IBMBIO.COM (& MSDOS 6.21 IO.SYS)
SYSINIT:3792                                         ; Erdogan Tan - 18/07/2023
SYSINIT:3793                 push    cs
SYSINIT:3794                 pop     ds
SYSINIT:3795                 assume ds:SYSINIT
SYSINIT:3795                 mov     al, UmbLoad
SYSINIT:3798                 cmp     al, 0FFh        ; UNSPECIFIED ; -1
SYSINIT:379A                 jnz     short ll10
SYSINIT:379C                 mov     al, 1
SYSINIT:379E                 stc
SYSINIT:379F                 jmp     short llx
SYSINIT:37A1 ; ---------------------------------------------------------------------------
SYSINIT:37A1
SYSINIT:37A1 ll10:                                   ; CODE XREF: SYSINIT:379A↑j
SYSINIT:37A1                 or      al, al
SYSINIT:37A3                 jz      short llx
SYSINIT:37A5                 mov     al, 1
SYSINIT:37A7                 clc
SYSINIT:37A8
SYSINIT:37A8 llx:                                    ; CODE XREF: SYSINIT:379F↑j
SYSINIT:37A8                                         ; SYSINIT:37A3↑j
SYSINIT:37A8                 pop     ds
SYSINIT:37A9                 assume ds:nothing
SYSINIT:37A9                 retn
SYSINIT:37AA
SYSINIT:37AA ; =============== S U B R O U T I N E =======================================
SYSINIT:37AA
SYSINIT:37AA
SYSINIT:37AA HideUMBs        proc near               ; CODE XREF: InitDevLoad+13↓p
SYSINIT:37AA                 push    ax              ; links UMBs and hides upper-memory as appropriate
SYSINIT:37AB                 push    cx
SYSINIT:37AC                 push    ds
SYSINIT:37AD                 push    es
SYSINIT:37AE                 call    UmbTest         ; cf=0 if UMBs are available
SYSINIT:37B1                 jb      short husX      ; there is nothing to do.
SYSINIT:37B3                 call    FixMem          ; Concatenate adjacent free MCBs in upper mem
SYSINIT:37B6                 call    setUMBs         ; Link UMBs and set memory-allocation strategy
SYSINIT:37B9                 push    es
SYSINIT:37BA                 push    cs
SYSINIT:37BB                 pop     es
SYSINIT:37BC                 assume es:SYSINIT
SYSINIT:37BC                 mov     es:fInHigh, 1   ; Remember that we're now running high
SYSINIT:37C2                 pop     es
SYSINIT:37C3                 assume es:nothing
SYSINIT:37C3                 call    GetLoadUMB      ; See if they gave us a list to leave free
SYSINIT:37C6                 cmp     al, 0FFh        ; UNSPECIFIED ; If they didn't,
SYSINIT:37C8                 jz      short husX      ; then we shouldn't do this loop:
SYSINIT:37CA                 xor     cx, cx          ; 0
SYSINIT:37CC
SYSINIT:37CC hus10:                                  ; CODE XREF: HideUMBs+34↓j
SYSINIT:37CC                 inc     cx              ; +1 for each UMB
SYSINIT:37CD                 cmp     cx, 16          ; MAXUMB
SYSINIT:37D0                 jnb     short hus20
SYSINIT:37D2                 mov     al, cl
SYSINIT:37D4                 push    es
SYSINIT:37D5                 call    findUMB         ; ES:0 points to first MCB in UMB
SYSINIT:37D5                                         ; Carry set if couldn't reach UMB
SYSINIT:37D8                 pop     es
SYSINIT:37D9                 jb      short hus20     ; outside of the valid range of UMBs
SYSINIT:37DB                 call    _hideUMB_       ; hide what we need to hide.
SYSINIT:37DE                 jmp     short hus10
SYSINIT:37E0 ; ---------------------------------------------------------------------------
SYSINIT:37E0
SYSINIT:37E0 hus20:                                  ; CODE XREF: HideUMBs+26↑j
SYSINIT:37E0                                         ; HideUMBs+2F↑j
SYSINIT:37E0                 call    GetLoadUMB      ; mov al,[cs:UmbLoad]
SYSINIT:37E3                 or      al, al          ; or byte [cs:UmbLoad],0
SYSINIT:37E3                                         ; Is the load UMB 0? (-1==unspecified)
SYSINIT:37E5                 jnz     short husX      ; no, done.
SYSINIT:37E7                 call    hl_unlink       ; fix UMBs and strategy.
SYSINIT:37EA
SYSINIT:37EA husX:                                   ; CODE XREF: HideUMBs+7↑j
SYSINIT:37EA                                         ; HideUMBs+1E↑j ...
SYSINIT:37EA                 pop     es
SYSINIT:37EB                 pop     ds
SYSINIT:37EC                 pop     cx
SYSINIT:37ED                 pop     ax
SYSINIT:37EE                 retn
SYSINIT:37EE HideUMBs        endp
SYSINIT:37EE
SYSINIT:37EF
SYSINIT:37EF ; =============== S U B R O U T I N E =======================================
SYSINIT:37EF
SYSINIT:37EF
SYSINIT:37EF GetLoadUMB      proc near               ; CODE XREF: doconf:loc_7EDB↑p
SYSINIT:37EF                                         ; HideUMBs+19↑p ...
SYSINIT:37EF                 push    ds              ; Returns the load UMB number in AL
SYSINIT:37EF                                         ;  (-1 if not specified)
SYSINIT:37EF                                         ;
SYSINIT:37EF                                         ; Instead of calling this subroutine
SYSINIT:37EF                                         ; "or byte [cs:UmbLoad],0" then "jz/jnz .."
SYSINIT:37EF                                         ; would be enough. Erdogan Tan - 18/07/2023
SYSINIT:37F0                 push    cs
SYSINIT:37F1                 pop     ds
SYSINIT:37F2                 assume ds:SYSINIT
SYSINIT:37F2                 mov     al, UmbLoad
SYSINIT:37F5                 pop     ds
SYSINIT:37F6                 assume ds:nothing
SYSINIT:37F6                 retn
SYSINIT:37F6 GetLoadUMB      endp
SYSINIT:37F6
SYSINIT:37F7
SYSINIT:37F7 ; =============== S U B R O U T I N E =======================================
SYSINIT:37F7
SYSINIT:37F7
SYSINIT:37F7 GetLoadSize     proc near               ; CODE XREF: doconf+3D8↑p
SYSINIT:37F7                 push    bx              ; Returns the load UMB minimum size
SYSINIT:37F7                                         ;  (0 if not specified)
SYSINIT:37F8                 push    si
SYSINIT:37F9                 push    ds
SYSINIT:37FA                 push    cs
SYSINIT:37FB                 pop     ds
SYSINIT:37FC                 assume ds:SYSINIT
SYSINIT:37FC                 mov     al, UmbLoad
SYSINIT:37FF                 xor     ah, ah
SYSINIT:3801                 mov     bx, offset UmbSize ; array
SYSINIT:3804                 shl     al, 1
SYSINIT:3806                 add     ax, bx
SYSINIT:3808                 mov     si, ax
SYSINIT:380A                 lodsw                   ; ax==size
SYSINIT:380B                 pop     ds
SYSINIT:380C                 assume ds:nothing
SYSINIT:380C                 pop     si
SYSINIT:380D                 pop     bx
SYSINIT:380E                 retn
SYSINIT:380E GetLoadSize     endp
SYSINIT:380E
SYSINIT:380F
SYSINIT:380F ; =============== S U B R O U T I N E =======================================
SYSINIT:380F
SYSINIT:380F
SYSINIT:380F GetSize         proc near               ; CODE XREF: _hideUMB_+14↓p
SYSINIT:380F                 push    bx              ; Returns the UMB in AL's minimum size
SYSINIT:380F                                         ;  (0 if not specified)
SYSINIT:3810                 push    si
SYSINIT:3811                 push    ds
SYSINIT:3812                 push    cs
SYSINIT:3813                 pop     ds
SYSINIT:3814                 assume ds:SYSINIT
SYSINIT:3814                 xor     ah, ah
SYSINIT:3816                 mov     bx, offset UmbSize ; array
SYSINIT:3819                 shl     al, 1
SYSINIT:381B                 add     ax, bx
SYSINIT:381D                 mov     si, ax
SYSINIT:381F                 lodsw                   ; ax==size
SYSINIT:3820                 pop     ds
SYSINIT:3821                 assume ds:nothing
SYSINIT:3821                 pop     si
SYSINIT:3822                 pop     bx
SYSINIT:3823                 retn
SYSINIT:3823 GetSize         endp
SYSINIT:3823
SYSINIT:3824 ; ---------------------------------------------------------------------------
SYSINIT:3824
SYSINIT:3824 StoLoadUMB:                             ; StoLoadUMB subroutine is not used anywhere
SYSINIT:3824                 push    es              ; of PCDOS 7.1 IBMBIO.COM (& MSDOS 6.21 IO.SYS)
SYSINIT:3824                                         ; Erdogan Tan - 18/07/2023
SYSINIT:3825                 push    cs
SYSINIT:3826                 pop     es              ; mov [cs:UmbLoad], al !!!! ; 08/09/2023
SYSINIT:3827                 assume es:SYSINIT
SYSINIT:3827                 mov     es:UmbLoad, al  ; Overrides the load UMB number with what's in AL
SYSINIT:382B                 pop     es
SYSINIT:382C                 assume es:nothing
SYSINIT:382C                 retn
SYSINIT:382D
SYSINIT:382D ; =============== S U B R O U T I N E =======================================
SYSINIT:382D
SYSINIT:382D
SYSINIT:382D StoLoadSize     proc near               ; CODE XREF: doconf+3E8↑p
SYSINIT:382D                 push    dx              ; Overrides the load UMB min. size with what's in AX
SYSINIT:382E                 push    ds
SYSINIT:382F                 push    cs
SYSINIT:3830                 pop     ds
SYSINIT:3831                 assume ds:SYSINIT
SYSINIT:3831                 mov     dl, UmbLoad     ; Put UMB# in DL
SYSINIT:3831                                         ;
SYSINIT:3831                                         ; BUG ! CL would/must be used here instead of DL (*)
SYSINIT:3831                                         ; 18/07/2023
SYSINIT:3835                 pop     ds
SYSINIT:3836                 assume ds:nothing
SYSINIT:3836                 cmp     dl, 0FFh        ; UNSPECIFIED ?
SYSINIT:3839                 jz      short sls10
SYSINIT:383B                 call    stowSiz         ; We've got a function to do just this
SYSINIT:383B                                         ;
SYSINIT:383B                                         ; BUG ! stowSiz uses CL instead of DL !
SYSINIT:383B                                         ; (CL is set in ParseL which calls stowSiz)
SYSINIT:383B                                         ; (This BUG existing in MSDOS 6.21 IO.SYS also)
SYSINIT:383B                                         ; Erdogan Tan - 18/07/2023
SYSINIT:383E
SYSINIT:383E sls10:                                  ; CODE XREF: StoLoadSize+C↑j
SYSINIT:383E                 pop     dx
SYSINIT:383F                 retn
SYSINIT:383F StoLoadSize     endp
SYSINIT:383F
SYSINIT:3840
SYSINIT:3840 ; =============== S U B R O U T I N E =======================================
SYSINIT:3840
SYSINIT:3840
SYSINIT:3840 hideUMB         proc near               ; CODE XREF: _hideUMB_+40↓p
SYSINIT:3840                 push    ax              ; marks as HIDDEN all FREE elements in UMB passed as AL
SYSINIT:3841                 push    es
SYSINIT:3842                 call    findUMB         ; Returns with carry if err, else ES == MCB
SYSINIT:3845                 jb      short huX
SYSINIT:3847
SYSINIT:3847 hu10:                                   ; CODE XREF: hideUMB+26↓j
SYSINIT:3847                 call    isSysMCB        ; Returns with ZF set if owner is SYSTEM
SYSINIT:384A                 jz      short huX
SYSINIT:384C                 call    isFreeMCB       ; or word [es:ARENA.OWNER],0
SYSINIT:384F                 jnz     short hu20
SYSINIT:3851                 call    hideMCB
SYSINIT:3854
SYSINIT:3854 hu20:                                   ; CODE XREF: hideUMB+F↑j
SYSINIT:3854                 mov     al, es:0        ; [es:ARENA.SIGNATURE]
SYSINIT:3858                 cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:385A                 jz      short huX
SYSINIT:385C                 mov     ax, es          ; Go on forward.
SYSINIT:385E                 add     ax, es:3        ; [es:ARENA.SIZE]
SYSINIT:3863                 inc     ax
SYSINIT:3864                 mov     es, ax
SYSINIT:3866                 jmp     short hu10
SYSINIT:3868 ; ---------------------------------------------------------------------------
SYSINIT:3868
SYSINIT:3868 huX:                                    ; CODE XREF: hideUMB+5↑j
SYSINIT:3868                                         ; hideUMB+A↑j ...
SYSINIT:3868                 pop     es
SYSINIT:3869                 pop     ax
SYSINIT:386A                 retn
SYSINIT:386A hideUMB         endp
SYSINIT:386A
SYSINIT:386B
SYSINIT:386B ; =============== S U B R O U T I N E =======================================
SYSINIT:386B
SYSINIT:386B
SYSINIT:386B isTiny          proc near               ; CODE XREF: _hideUMB_:hu_10↓p
SYSINIT:386B                 push    ax              ; returns with ZF set if user didn't specify /S
SYSINIT:386C                 push    ds
SYSINIT:386D                 push    cs
SYSINIT:386E                 pop     ds
SYSINIT:386F                 assume ds:SYSINIT
SYSINIT:386F                 mov     al, fUmbTiny
SYSINIT:3872                 pop     ds
SYSINIT:3873                 assume ds:nothing
SYSINIT:3873                 or      al, al
SYSINIT:3875                 pop     ax
SYSINIT:3876                 retn
SYSINIT:3876 isTiny          endp
SYSINIT:3876
SYSINIT:3877
SYSINIT:3877 ; =============== S U B R O U T I N E =======================================
SYSINIT:3877
SYSINIT:3877
SYSINIT:3877 isFreeMCB       proc near               ; CODE XREF: hideUMB+C↑p
SYSINIT:3877                                         ; BigFree+10↓p ...
SYSINIT:3877                 or      word ptr es:1, 0 ; or word [es:ARENA.OWNER],0
SYSINIT:387D                 retn
SYSINIT:387D isFreeMCB       endp
SYSINIT:387D
SYSINIT:387E
SYSINIT:387E ; =============== S U B R O U T I N E =======================================
SYSINIT:387E
SYSINIT:387E
SYSINIT:387E hideMCB         proc near               ; CODE XREF: hideUMB+11↑p
SYSINIT:387E                 mov     word ptr es:1, 8 ; marks as HIDDEN the MCB at ES:0
SYSINIT:3885                 mov     word ptr es:8, 4948h ; 'HI'
SYSINIT:388C                 mov     word ptr es:0Ah, 4444h ; 'DD'
SYSINIT:3893                 mov     word ptr es:0Ch, 4E45h ; 'EN'
SYSINIT:389A                 mov     word ptr es:0Eh, 2020h ; '  '
SYSINIT:38A1                 retn
SYSINIT:38A1 hideMCB         endp
SYSINIT:38A1
SYSINIT:38A2
SYSINIT:38A2 ; =============== S U B R O U T I N E =======================================
SYSINIT:38A2
SYSINIT:38A2
SYSINIT:38A2 unHideMCB       proc near               ; CODE XREF: _hideUMB_+49↓p
SYSINIT:38A2                                         ; UnFreeze+E↓p
SYSINIT:38A2                 push    ax              ; marks as FREE the MCB at ES:0
SYSINIT:38A3                 mov     word ptr es:1, 0 ; [es:ARENA.OWNER],FreePSPOwner
SYSINIT:38AA                 mov     ax, 2020h       ; '  '
SYSINIT:38AD                 mov     es:8, ax        ; [es:ARENA.NAME+0]
SYSINIT:38B1                 mov     es:0Ah, ax      ; [es:ARENA.NAME+2]
SYSINIT:38B5                 mov     es:0Ch, ax      ; [es:ARENA.NAME+4]
SYSINIT:38B9                 mov     es:0Eh, ax      ; [es:ARENA.NAME+6]
SYSINIT:38BD                 pop     ax
SYSINIT:38BE                 retn
SYSINIT:38BE unHideMCB       endp
SYSINIT:38BE
SYSINIT:38BF
SYSINIT:38BF ; =============== S U B R O U T I N E =======================================
SYSINIT:38BF
SYSINIT:38BF
SYSINIT:38BF findUMB         proc near               ; CODE XREF: HideUMBs+2B↑p
SYSINIT:38BF                                         ; hideUMB+2↑p ...
SYSINIT:38BF                 push    ax              ; makes ES:0 point to the first MCB in UMB given as AL
SYSINIT:38C0                 push    cx
SYSINIT:38C1                 push    dx
SYSINIT:38C2                 xor     ah, ah
SYSINIT:38C4                 mov     dx, ax          ; Store the to-be-found UMB number in DX
SYSINIT:38C6                 call    UmbHead         ; Returns first UMB segment in AX
SYSINIT:38C9                 mov     es, ax
SYSINIT:38CB                 xor     cx, cx          ; Pretend we're on UMB 0 for now...
SYSINIT:38CD
SYSINIT:38CD fu10:                                   ; CODE XREF: findUMB+2A↓j
SYSINIT:38CD                 cmp     cx, dx          ; If CX==DX, the UMB is found
SYSINIT:38CF                 jz      short fuX
SYSINIT:38D1                 call    isSysMCB        ; Returns with ZF set if owner is SYSTEM
SYSINIT:38D4                 jnz     short fu20
SYSINIT:38D6                 inc     cx
SYSINIT:38D7
SYSINIT:38D7 fu20:                                   ; CODE XREF: findUMB+15↑j
SYSINIT:38D7                 mov     al, es:0
SYSINIT:38DB                 cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:38DD                 jz      short fuE       ; 'Z' means this was the last MCB
SYSINIT:38DF                 mov     ax, es          ; Go on forward.
SYSINIT:38E1                 add     ax, es:3        ; [es:ARENA.SIZE]
SYSINIT:38E6                 inc     ax
SYSINIT:38E7                 mov     es, ax
SYSINIT:38E9                 jmp     short fu10
SYSINIT:38EB ; ---------------------------------------------------------------------------
SYSINIT:38EB
SYSINIT:38EB fuE:                                    ; CODE XREF: findUMB+1E↑j
SYSINIT:38EB                 stc
SYSINIT:38EC
SYSINIT:38EC fuX:                                    ; CODE XREF: findUMB+10↑j
SYSINIT:38EC                 pop     dx
SYSINIT:38ED                 pop     cx
SYSINIT:38EE                 pop     ax              ; The address is already in ES.
SYSINIT:38EF                 retn
SYSINIT:38EF findUMB         endp
SYSINIT:38EF
SYSINIT:38F0
SYSINIT:38F0 ; =============== S U B R O U T I N E =======================================
SYSINIT:38F0
SYSINIT:38F0
SYSINIT:38F0 BigFree         proc near               ; CODE XREF: _hideUMB_+C↓p
SYSINIT:38F0                 push    bx              ; makes ES:0 point to the largest free MCB
SYSINIT:38F0                                         ; in UMB given as AL
SYSINIT:38F1                 push    cx
SYSINIT:38F2                 call    findUMB         ; Returns with CF if err, else ES==MCB
SYSINIT:38F5                 jb      short bfX
SYSINIT:38F7                 xor     bx, bx          ; Segment address of largest free MCB
SYSINIT:38F9                 xor     cx, cx          ; Size of largest free MCB
SYSINIT:38FB
SYSINIT:38FB bf10:                                   ; CODE XREF: BigFree+35↓j
SYSINIT:38FB                 call    isSysMCB        ; If we've left the MCB, we're done.
SYSINIT:38FE                 jz      short bf30
SYSINIT:3900                 call    isFreeMCB       ; or word [es:ARENA.OWNER],0
SYSINIT:3903                 jnz     short bf20
SYSINIT:3905                 cmp     cx, es:3        ; [es:ARENA.SIZE] ; Compare sizes..
SYSINIT:390A                 jg      short bf20
SYSINIT:390C                 mov     bx, es          ; Unless we're bigger,
SYSINIT:390E                 mov     cx, es:3        ; Store this new element's addr and size.
SYSINIT:3913
SYSINIT:3913 bf20:                                   ; CODE XREF: BigFree+13↑j
SYSINIT:3913                                         ; BigFree+1A↑j
SYSINIT:3913                 mov     al, es:0
SYSINIT:3917                 cmp     al, 5Ah ; 'Z'   ; [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:3919                 jz      short bf30
SYSINIT:391B                 mov     ax, es          ; NextMCB es,ax ; (macro) ; Go on forward.
SYSINIT:391D                 add     ax, es:3        ; es:ARENA.SIZE]
SYSINIT:3922                 inc     ax
SYSINIT:3923                 mov     es, ax
SYSINIT:3925                 jmp     short bf10
SYSINIT:3927 ; ---------------------------------------------------------------------------
SYSINIT:3927
SYSINIT:3927 bf30:                                   ; CODE XREF: BigFree+E↑j
SYSINIT:3927                                         ; BigFree+29↑j
SYSINIT:3927                 mov     es, bx          ; Return the address
SYSINIT:3929                 mov     ax, cx          ; Return the size
SYSINIT:392B                 or      bx, bx
SYSINIT:392D                 jnz     short bfX
SYSINIT:392F                 stc                     ; (if size==0, there's nothing free)
SYSINIT:3930
SYSINIT:3930 bfX:                                    ; CODE XREF: BigFree+5↑j
SYSINIT:3930                                         ; BigFree+3D↑j
SYSINIT:3930                 pop     cx
SYSINIT:3931                 pop     bx
SYSINIT:3932                 retn
SYSINIT:3932 BigFree         endp
SYSINIT:3932
SYSINIT:3933
SYSINIT:3933 ; =============== S U B R O U T I N E =======================================
SYSINIT:3933
SYSINIT:3933
SYSINIT:3933 isSpecified     proc near               ; CODE XREF: _hideUMB_+5↓p
SYSINIT:3933                                         ; _hideUMB_+37↓p
SYSINIT:3933                 push    ax              ; sets ZF if UMB in AL wasn't specified in DH/LH line.
SYSINIT:3934                 xor     bh, bh
SYSINIT:3936                 mov     bl, al
SYSINIT:3938                 push    ds
SYSINIT:3939                 push    cs
SYSINIT:393A                 pop     ds
SYSINIT:393B                 assume ds:SYSINIT
SYSINIT:393B                 mov     al, UmbUsed[bx]
SYSINIT:393F                 pop     ds
SYSINIT:3940                 assume ds:nothing
SYSINIT:3940                 or      al, al          ; ets ZF if al==0 (ie, if unspecified)
SYSINIT:3942                 pop     ax
SYSINIT:3943                 retn
SYSINIT:3943 isSpecified     endp
SYSINIT:3943
SYSINIT:3944
SYSINIT:3944 ; =============== S U B R O U T I N E =======================================
SYSINIT:3944
SYSINIT:3944
SYSINIT:3944 shrinkMCB       proc near               ; CODE XREF: _hideUMB_+2C↓p
SYSINIT:3944                 push    bx              ; breaks an MCB into two pieces, the lowest one's size==AX
SYSINIT:3944                                         ; AX == new size, ES:0 == current MCB
SYSINIT:3945                 push    cx
SYSINIT:3946                 push    es
SYSINIT:3947                 mov     bx, ax          ; requested size (lowest one)
SYSINIT:3949                 mov     ax, es
SYSINIT:394B                 mov     cx, es:3        ; [es:ARENA.SIZE]
SYSINIT:3950                 sub     cx, 32          ; MIN_SPLIT_SIZE = 32
SYSINIT:3953                 cmp     bx, cx          ; {New size} vs {Current Size-20h}
SYSINIT:3955                 ja      short smE       ; if wanted_size > cur-20h, abort.
SYSINIT:3957                 mov     dl, es:0        ; [es:ARENA.SIGNATURE]
SYSINIT:395C                 mov     cx, es:3
SYSINIT:3961                 mov     es:3, bx        ; [es:ARENA.SIZE]
SYSINIT:3966                 mov     byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],'M'
SYSINIT:396C                 add     ax, bx
SYSINIT:396E                 inc     ax
SYSINIT:396F                 mov     es, ax          ; Move to new arena area
SYSINIT:3971                 mov     ax, cx
SYSINIT:3973                 sub     ax, bx
SYSINIT:3975                 dec     ax              ; And prepare the new size
SYSINIT:3976                 mov     es:0, dl        ; [es:ARENA.SIGNATURE],dl
SYSINIT:397B                 mov     word ptr es:1, 0 ; [es:ARENA.OWNER]
SYSINIT:3982                 mov     es:3, ax        ; [es:ARENA.SIZE]
SYSINIT:3986                 mov     ax, 2020h       ; '  '
SYSINIT:3989                 mov     es:8, ax        ; [es:ARENA.NAME+0]
SYSINIT:398D                 mov     es:0Ah, ax      ; [es:ARENA.NAME+2]
SYSINIT:3991                 mov     es:0Ch, ax      ; [es:ARENA.NAME+4]
SYSINIT:3995                 mov     es:0Eh, ax      ; [es:ARENA.NAME+6]
SYSINIT:3999                 clc
SYSINIT:399A                 jmp     short smX
SYSINIT:399C ; ---------------------------------------------------------------------------
SYSINIT:399C
SYSINIT:399C smE:                                    ; CODE XREF: shrinkMCB+11↑j
SYSINIT:399C                 stc
SYSINIT:399D
SYSINIT:399D smX:                                    ; CODE XREF: shrinkMCB+56↑j
SYSINIT:399D                 pop     es
SYSINIT:399E                 pop     cx
SYSINIT:399F                 pop     bx
SYSINIT:39A0                 retn
SYSINIT:39A0 shrinkMCB       endp
SYSINIT:39A0
SYSINIT:39A1
SYSINIT:39A1 ; =============== S U B R O U T I N E =======================================
SYSINIT:39A1
SYSINIT:39A1
SYSINIT:39A1 _hideUMB_       proc near               ; CODE XREF: HideUMBs+31↑p
SYSINIT:39A1                 push    bx              ; hides as appropriate the UMB in CL
SYSINIT:39A2                 push    dx
SYSINIT:39A3                 push    es
SYSINIT:39A4                 mov     al, cl
SYSINIT:39A6                 call    isSpecified     ; Returns ZF set if al's umb was NOT specified
SYSINIT:39A9                 jz      short hu_20
SYSINIT:39AB                 mov     al, cl
SYSINIT:39AD                 call    BigFree         ; Retrieve the size of the largest free element
SYSINIT:39AD                                         ; in AX, put its address in ES.
SYSINIT:39B0                 jb      short hu_20
SYSINIT:39B2                 push    ax              ; TOS==size of BigFree in UMB
SYSINIT:39B3                 mov     al, cl          ; Retrieve the user's specified
SYSINIT:39B5                 call    GetSize         ; minimum size for this umb (into AX)
SYSINIT:39B8                 pop     bx              ; BX==BigFree, AX==Specified Size
SYSINIT:39B9                 or      ax, ax          ; If they didn't specify one,
SYSINIT:39B9                                         ; skip over all this.
SYSINIT:39BB                 jz      short hu_20
SYSINIT:39BD                 cmp     ax, bx          ; if (specified > max free)
SYSINIT:39BF                 jbe     short hu_10
SYSINIT:39C1                 mov     al, cl          ; then mark that UMB as unused.
SYSINIT:39C3                 call    unMarkUMB
SYSINIT:39C6                 jmp     short hu_20
SYSINIT:39C8 ; ---------------------------------------------------------------------------
SYSINIT:39C8
SYSINIT:39C8 hu_10:                                  ; CODE XREF: _hideUMB_+1E↑j
SYSINIT:39C8                 call    isTiny          ; or byte [cs:fUmbTiny],0
SYSINIT:39CB                 jz      short hu_20
SYSINIT:39CD                 call    shrinkMCB       ; They specified /S, so shrink the MCB to AX
SYSINIT:39D0                 jb      short hu_20
SYSINIT:39D2                 mov     dx, es
SYSINIT:39D4                 jmp     short hu_30     ; Skip the spec check.. we wanna hide this one.
SYSINIT:39D6 ; ---------------------------------------------------------------------------
SYSINIT:39D6
SYSINIT:39D6 hu_20:                                  ; CODE XREF: _hideUMB_+8↑j
SYSINIT:39D6                                         ; _hideUMB_+F↑j ...
SYSINIT:39D6                 mov     ax, cx
SYSINIT:39D8                 call    isSpecified     ; If they specified this UMB, we're done.
SYSINIT:39DB                 jnz     short hu_X      ; so leave.
SYSINIT:39DD                 xor     dx, dx          ; 0
SYSINIT:39DF
SYSINIT:39DF hu_30:                                  ; CODE XREF: _hideUMB_+33↑j
SYSINIT:39DF                 mov     al, cl
SYSINIT:39E1                 call    hideUMB         ; Hides everything in UMB #al
SYSINIT:39E4                 or      dx, dx          ; Did we shrink a UMB? If not, DX==0,
SYSINIT:39E6                 jz      short hu_X      ; So we should leave.
SYSINIT:39E8                 mov     es, dx          ; Ah, but if it isn't, DX==the MCB's address;
SYSINIT:39EA                 call    unHideMCB       ; Un-hides the lower portion of that MCB.
SYSINIT:39ED
SYSINIT:39ED hu_X:                                   ; CODE XREF: _hideUMB_+3A↑j
SYSINIT:39ED                                         ; _hideUMB_+45↑j
SYSINIT:39ED                 pop     es
SYSINIT:39EE                 pop     dx
SYSINIT:39EF                 pop     bx
SYSINIT:39F0                 retn
SYSINIT:39F0 _hideUMB_       endp
SYSINIT:39F0
SYSINIT:39F1
SYSINIT:39F1 ; =============== S U B R O U T I N E =======================================
SYSINIT:39F1
SYSINIT:39F1
SYSINIT:39F1 UnFreeze        proc near               ; CODE XREF: InitDevLoad+1D↓p
SYSINIT:39F1                 push    ax              ; Marks FROZEN elements as FREE
SYSINIT:39F2                 push    es
SYSINIT:39F3                 call    UmbHead         ; Returns with carry if err, else ES == MCB
SYSINIT:39F6                 jb      short ufX
SYSINIT:39F8                 mov     es, ax
SYSINIT:39FA
SYSINIT:39FA uf10:                                   ; CODE XREF: UnFreeze+23↓j
SYSINIT:39FA                 call    isFrozMCB       ; Returns with ZF set if MCB is FROZEN
SYSINIT:39FD                 jnz     short uf20
SYSINIT:39FF                 call    unHideMCB
SYSINIT:3A02
SYSINIT:3A02 uf20:                                   ; CODE XREF: UnFreeze+C↑j
SYSINIT:3A02                 mov     al, es:0
SYSINIT:3A06                 cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:3A08                 jz      short ufX
SYSINIT:3A0A                 mov     ax, es
SYSINIT:3A0C                 add     ax, es:3        ; [es:ARENA.SIZE]
SYSINIT:3A11                 inc     ax
SYSINIT:3A12                 mov     es, ax
SYSINIT:3A14                 jmp     short uf10
SYSINIT:3A16 ; ---------------------------------------------------------------------------
SYSINIT:3A16
SYSINIT:3A16 ufX:                                    ; CODE XREF: UnFreeze+5↑j
SYSINIT:3A16                                         ; UnFreeze+17↑j
SYSINIT:3A16                 pop     es
SYSINIT:3A17                 pop     ax
SYSINIT:3A18                 retn
SYSINIT:3A18 UnFreeze        endp
SYSINIT:3A18
SYSINIT:3A19
SYSINIT:3A19 ; =============== S U B R O U T I N E =======================================
SYSINIT:3A19
SYSINIT:3A19
SYSINIT:3A19 isFrozMCB       proc near               ; CODE XREF: UnFreeze:uf10↑p
SYSINIT:3A19                 push    ax
SYSINIT:3A1A                 mov     ax, es:1        ; [es:ARENA.OWNER] ; Check the owner..
SYSINIT:3A1E                 cmp     ax, 8           ; 8 (for US OR Japan) is valid
SYSINIT:3A21                 jnz     short ifmX
SYSINIT:3A23                 mov     ax, es:8        ; [es:ARENA.NAME+0]
SYSINIT:3A27                 cmp     ax, 5246h       ; 'FR'
SYSINIT:3A2A                 jnz     short ifmX
SYSINIT:3A2C                 mov     ax, es:0Ah      ; [es:ARENA.NAME+2]
SYSINIT:3A30                 cmp     ax, 5A4Fh       ; 'OZ'
SYSINIT:3A33                 jnz     short ifmX
SYSINIT:3A35                 mov     ax, es:0Ch      ; [es:ARENA.NAME+4]
SYSINIT:3A39                 cmp     ax, 4E45h       ; 'EN'
SYSINIT:3A3C                 jnz     short ifmX
SYSINIT:3A3E                 mov     ax, es:0Eh      ; [es:ARENA.NAME+6]
SYSINIT:3A42                 cmp     ax, 2020h       ; '  '
SYSINIT:3A45
SYSINIT:3A45 ifmX:                                   ; CODE XREF: isFrozMCB+8↑j
SYSINIT:3A45                                         ; isFrozMCB+11↑j ...
SYSINIT:3A45                 pop     ax
SYSINIT:3A46                 retn
SYSINIT:3A46 isFrozMCB       endp
SYSINIT:3A46
SYSINIT:3A47
SYSINIT:3A47 ; =============== S U B R O U T I N E =======================================
SYSINIT:3A47
SYSINIT:3A47
SYSINIT:3A47 frezMCB         proc near               ; CODE XREF: FreezeUM+21↓p
SYSINIT:3A47                 mov     word ptr es:1, 8 ; marks as 8+FROZEN the MCB at ES:0
SYSINIT:3A47                                         ; mov word [es:ARENA.OWNER],SystemPSPOwner
SYSINIT:3A4E                 mov     word ptr es:8, 5246h ; [es:ARENA.NAME+0],'FR'
SYSINIT:3A55                 mov     word ptr es:0Ah, 5A4Fh ; [es:ARENA.NAME+2],'OZ'
SYSINIT:3A5C                 mov     word ptr es:0Ch, 4E45h ; [es:ARENA.NAME+4],'EN'
SYSINIT:3A63                 mov     word ptr es:0Eh, 2020h ; [es:ARENA.NAME+6],'  '
SYSINIT:3A6A                 retn
SYSINIT:3A6A frezMCB         endp
SYSINIT:3A6A
SYSINIT:3A6B
SYSINIT:3A6B ; =============== S U B R O U T I N E =======================================
SYSINIT:3A6B
SYSINIT:3A6B
SYSINIT:3A6B FreezeUM        proc near               ; CODE XREF: InitDevLoad+16↓p
SYSINIT:3A6B                 push    ax              ; Marks FROZEN all UM elements now FREE,
SYSINIT:3A6B                                         ; save those in load UMB
SYSINIT:3A6C                 push    cx
SYSINIT:3A6D                 push    dx
SYSINIT:3A6E                 push    es
SYSINIT:3A6F                 call    GetLoadUMB      ; mov al,[cs:UmbLoad]
SYSINIT:3A72                 xor     ah, ah          ; 0
SYSINIT:3A74                 mov     dx, ax          ; Store the load UMB in DX, so we can skip it
SYSINIT:3A76                 call    UmbHead         ; Returns first UMB segment in AX
SYSINIT:3A79                 mov     es, ax
SYSINIT:3A7B                 xor     cx, cx          ; Pretend we're on UMB 0 for now..
SYSINIT:3A7D
SYSINIT:3A7D fum10:                                  ; CODE XREF: FreezeUM+36↓j
SYSINIT:3A7D                 call    isSysMCB        ; Returns with ZF set if owner is SYSTEM
SYSINIT:3A80                 jnz     short fum20
SYSINIT:3A82                 inc     cx              ; If it _was_ SYSTEM, we're in a new UMB.
SYSINIT:3A83
SYSINIT:3A83 fum20:                                  ; CODE XREF: FreezeUM+15↑j
SYSINIT:3A83                 cmp     cx, dx          ; DX - UMB number to skip (load UMB)
SYSINIT:3A83                                         ;
SYSINIT:3A83                                         ; If this is the load UMB, we don't want to
SYSINIT:3A83                                         ; freeze anything.. so skip that section.
SYSINIT:3A85                 jz      short fum30
SYSINIT:3A87                 call    isFreeMCB       ; or word [es:ARENA.OWNER],0
SYSINIT:3A87                                         ; If it's not free, we can't freeze it
SYSINIT:3A8A                 jnz     short fum30
SYSINIT:3A8C                 call    frezMCB
SYSINIT:3A8F
SYSINIT:3A8F fum30:                                  ; CODE XREF: FreezeUM+1A↑j
SYSINIT:3A8F                                         ; FreezeUM+1F↑j
SYSINIT:3A8F                 mov     al, es:0
SYSINIT:3A93                 cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:3A95                 jz      short fumX
SYSINIT:3A97                 mov     ax, es          ; NextMCB es, ax (macro) ; Go on forward.
SYSINIT:3A99                 add     ax, es:3        ; [es:ARENA.SIZE]
SYSINIT:3A9E                 inc     ax
SYSINIT:3A9F                 mov     es, ax
SYSINIT:3AA1                 jmp     short fum10
SYSINIT:3AA3 ; ---------------------------------------------------------------------------
SYSINIT:3AA3
SYSINIT:3AA3 fumX:                                   ; CODE XREF: FreezeUM+2A↑j
SYSINIT:3AA3                 pop     es
SYSINIT:3AA4                 pop     dx
SYSINIT:3AA5                 pop     cx
SYSINIT:3AA6                 pop     ax
SYSINIT:3AA7                 retn
SYSINIT:3AA7 FreezeUM        endp
SYSINIT:3AA7
SYSINIT:3AA8
SYSINIT:3AA8 ; =============== S U B R O U T I N E =======================================
SYSINIT:3AA8
SYSINIT:3AA8
SYSINIT:3AA8 UmbTest         proc near               ; CODE XREF: doconf+35C↑p
SYSINIT:3AA8                                         ; HideUMBs+4↑p
SYSINIT:3AA8                 push    ax              ; returns with carry set if UMBs are not available,
SYSINIT:3AA8                                         ;  else CF==false
SYSINIT:3AA9                 push    bx
SYSINIT:3AAA                 push    ds
SYSINIT:3AAB                 push    es
SYSINIT:3AAC                 call    fm_link         ; Link in UMBs (if not already linked)
SYSINIT:3AAF                 call    WalkMem         ; Check to see if they're really linked
SYSINIT:3AB2                 pushf                   ; And remember what we found out
SYSINIT:3AB3                 call    fm_unlink       ; Unlink UMBs (if we have linked 'em)
SYSINIT:3AB6                 popf                    ; And restore what we found out.
SYSINIT:3AB7                 pop     es
SYSINIT:3AB8                 pop     ds
SYSINIT:3AB9                 pop     bx
SYSINIT:3ABA                 pop     ax
SYSINIT:3ABB                 retn
SYSINIT:3ABB UmbTest         endp
SYSINIT:3ABB
SYSINIT:3ABC
SYSINIT:3ABC ; =============== S U B R O U T I N E =======================================
SYSINIT:3ABC
SYSINIT:3ABC
SYSINIT:3ABC WalkMem         proc near               ; CODE XREF: UmbTest+7↑p
SYSINIT:3ABC                 push    ax              ; WalkMem - travels memory chain and
SYSINIT:3ABC                                         ; returns carry clear if UMBs are linked
SYSINIT:3ABD                 push    bx
SYSINIT:3ABE                 push    es
SYSINIT:3ABF                 mov     ah, 52h
SYSINIT:3AC1                 int     21h             ; DOS - 2+ internal - GET LIST OF LISTS
SYSINIT:3AC1                                         ; Return: ES:BX -> DOS list of lists
SYSINIT:3AC3                 mov     ax, es:[bx-2]
SYSINIT:3AC7                 mov     es, ax          ; ES = Current MCB pointer
SYSINIT:3AC9
SYSINIT:3AC9 um10:                                   ; CODE XREF: WalkMem+1F↓j
SYSINIT:3AC9                 mov     al, es:0
SYSINIT:3ACD                 cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:3ACF                 jz      short um20
SYSINIT:3AD1                 mov     bx, es          ; Move to the next MCB
SYSINIT:3AD3                 add     bx, es:3        ; [es:ARENA.SIZE]
SYSINIT:3AD8                 inc     bx
SYSINIT:3AD9                 mov     es, bx
SYSINIT:3ADB                 jmp     short um10
SYSINIT:3ADD ; ---------------------------------------------------------------------------
SYSINIT:3ADD
SYSINIT:3ADD um20:                                   ; CODE XREF: WalkMem+13↑j
SYSINIT:3ADD                 mov     ax, es
SYSINIT:3ADF                 cmp     ax, 9FFFh       ; This sets CF if ax < 9FFFh.
SYSINIT:3AE2                 pop     es
SYSINIT:3AE3                 pop     bx
SYSINIT:3AE4                 pop     ax
SYSINIT:3AE5                 retn
SYSINIT:3AE5 WalkMem         endp
SYSINIT:3AE5
SYSINIT:3AE6
SYSINIT:3AE6 ; =============== S U B R O U T I N E =======================================
SYSINIT:3AE6
SYSINIT:3AE6
SYSINIT:3AE6 hl_unlink       proc near               ; CODE XREF: HideUMBs+3D↑p
SYSINIT:3AE6                 xor     bh, bh          ; unlinks UMBs if fm_umb is set to 0;
SYSINIT:3AE6                                         ;  restores strategy too
SYSINIT:3AE8                 push    ds
SYSINIT:3AE9                 push    cs
SYSINIT:3AEA                 pop     ds
SYSINIT:3AEB                 assume ds:SYSINIT
SYSINIT:3AEB                 mov     bl, fm_umb
SYSINIT:3AEF                 pop     ds
SYSINIT:3AF0                 assume ds:nothing
SYSINIT:3AF0                 mov     ax, 5803h       ; DOS_SET_UMBLINK
SYSINIT:3AF3                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:3AF3                                         ; AL = function code: (DOS 5beta) set UMB link state
SYSINIT:3AF5                 retn
SYSINIT:3AF5 hl_unlink       endp
SYSINIT:3AF5
SYSINIT:3AF6
SYSINIT:3AF6 ; =============== S U B R O U T I N E =======================================
SYSINIT:3AF6
SYSINIT:3AF6
SYSINIT:3AF6 UnHideUMBs      proc near               ; CODE XREF: RetFromUM+7↓p
SYSINIT:3AF6                 push    ax              ; Marks HIDDEN elements as FREE
SYSINIT:3AF7                 push    ds
SYSINIT:3AF8                 push    cs
SYSINIT:3AF9                 pop     ds
SYSINIT:3AFA                 assume ds:SYSINIT
SYSINIT:3AFA                 mov     al, fInHigh     ; mov al,[cs:fInHigh]
SYSINIT:3AFD                 pop     ds
SYSINIT:3AFE                 assume ds:nothing
SYSINIT:3AFE                 or      al, al
SYSINIT:3B00                 jnz     short uhu10     ; If didn't call loadhigh/devicehigh earlier,
SYSINIT:3B02                 pop     ax              ; then there's nothing to do here.
SYSINIT:3B03                 stc
SYSINIT:3B04                 retn
SYSINIT:3B05 ; ---------------------------------------------------------------------------
SYSINIT:3B05
SYSINIT:3B05 uhu10:                                  ; CODE XREF: UnHideUMBs+A↑j
SYSINIT:3B05                 call    linkumb         ; Make sure UMBs are linked in.
SYSINIT:3B08                 call    FreeUMBs
SYSINIT:3B0B                 push    es
SYSINIT:3B0C                 push    cs
SYSINIT:3B0D                 pop     es
SYSINIT:3B0E                 assume es:SYSINIT
SYSINIT:3B0E                 mov     es:fInHigh, 0   ; We're leaving, so update fInHigh.
SYSINIT:3B14                 pop     es
SYSINIT:3B15                 assume es:nothing
SYSINIT:3B15                 call    he_unlink       ; Unlink UMBs
SYSINIT:3B18                 pop     ax
SYSINIT:3B19                 clc
SYSINIT:3B1A                 retn
SYSINIT:3B1A UnHideUMBs      endp
SYSINIT:3B1A
SYSINIT:3B1B
SYSINIT:3B1B ; =============== S U B R O U T I N E =======================================
SYSINIT:3B1B
SYSINIT:3B1B
SYSINIT:3B1B he_unlink       proc near               ; CODE XREF: UnHideUMBs+1F↑p
SYSINIT:3B1B                 xor     bh, bh          ; unlinks UMBs if fm_umb is set to 0
SYSINIT:3B1D                 push    ds
SYSINIT:3B1E                 push    cs
SYSINIT:3B1F                 pop     ds
SYSINIT:3B20                 assume ds:SYSINIT
SYSINIT:3B20                 mov     bl, fm_umb
SYSINIT:3B24                 pop     ds
SYSINIT:3B25                 assume ds:nothing
SYSINIT:3B25                 mov     ax, 5803h
SYSINIT:3B28                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:3B28                                         ; AL = function code: (DOS 5beta) set UMB link state
SYSINIT:3B2A                 retn
SYSINIT:3B2A he_unlink       endp
SYSINIT:3B2A
SYSINIT:3B2B
SYSINIT:3B2B ; =============== S U B R O U T I N E =======================================
SYSINIT:3B2B
SYSINIT:3B2B
SYSINIT:3B2B FreeUMBs        proc near               ; CODE XREF: UnHideUMBs+12↑p
SYSINIT:3B2B                 push    ax              ; frees all HIDDEN memory elements in upper-memory
SYSINIT:3B2C                 push    es
SYSINIT:3B2D                 call    HeadUmb         ; Returns with carry if err, else ES == MCB
SYSINIT:3B30                 jb      short fusX
SYSINIT:3B32
SYSINIT:3B32 fus10:                                  ; CODE XREF: FreeUMBs+21↓j
SYSINIT:3B32                 mov     es, ax          ; Prepare for the loop; ES = current MCB addr.
SYSINIT:3B34                 call    isHideMCB       ; Returns with ZF set if owner is 0
SYSINIT:3B37                 jnz     short fus20
SYSINIT:3B39                 call    freeMCB
SYSINIT:3B3C
SYSINIT:3B3C fus20:                                  ; CODE XREF: FreeUMBs+C↑j
SYSINIT:3B3C                 mov     al, es:0
SYSINIT:3B40                 cmp     al, 5Ah ; 'Z'   ; cmp byte [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:3B42                 jz      short fusX
SYSINIT:3B44                 mov     ax, es
SYSINIT:3B46                 add     ax, es:3        ; [es:ARENA.SIZE]
SYSINIT:3B4B                 inc     ax
SYSINIT:3B4C                 jmp     short fus10     ; Go on forward.
SYSINIT:3B4E ; ---------------------------------------------------------------------------
SYSINIT:3B4E
SYSINIT:3B4E fusX:                                   ; CODE XREF: FreeUMBs+5↑j
SYSINIT:3B4E                                         ; FreeUMBs+17↑j
SYSINIT:3B4E                 pop     es
SYSINIT:3B4F                 pop     ax
SYSINIT:3B50                 retn
SYSINIT:3B50 FreeUMBs        endp
SYSINIT:3B50
SYSINIT:3B51
SYSINIT:3B51 ; =============== S U B R O U T I N E =======================================
SYSINIT:3B51
SYSINIT:3B51
SYSINIT:3B51 isHideMCB       proc near               ; CODE XREF: FreeUMBs+9↑p
SYSINIT:3B51                 push    ax              ; returns with ZF set if current MCB (ES:0) is HIDDEN
SYSINIT:3B52                 cmp     word ptr es:1, 8 ; [es:ARENA.OWNER],SystemPSPOwner
SYSINIT:3B52                                         ; If the owner's SYSTEM then check for HIDDEN
SYSINIT:3B58                 jnz     short ihm_x
SYSINIT:3B5A                 mov     ax, es:8
SYSINIT:3B5E                 cmp     ax, 4948h       ; cmp word [es:ARENA.NAME+0],'HI'
SYSINIT:3B61                 jnz     short ihm_x
SYSINIT:3B63                 mov     ax, es:0Ah
SYSINIT:3B67                 cmp     ax, 4444h       ; cmp word [es:ARENA.NAME+2],'DD'
SYSINIT:3B6A                 jnz     short ihm_x
SYSINIT:3B6C                 mov     ax, es:0Ch
SYSINIT:3B70                 cmp     ax, 4E45h       ; cmp word [es:ARENA.NAME+4],'EN'
SYSINIT:3B73                 jnz     short ihm_x
SYSINIT:3B75                 mov     ax, es:0Eh
SYSINIT:3B79                 cmp     ax, 2020h       ; [es:ARENA.NAME+6],'  '
SYSINIT:3B7C
SYSINIT:3B7C ihm_x:                                  ; CODE XREF: isHideMCB+7↑j
SYSINIT:3B7C                                         ; isHideMCB+10↑j ...
SYSINIT:3B7C                 pop     ax
SYSINIT:3B7D                 retn
SYSINIT:3B7D isHideMCB       endp
SYSINIT:3B7D
SYSINIT:3B7E
SYSINIT:3B7E ; =============== S U B R O U T I N E =======================================
SYSINIT:3B7E
SYSINIT:3B7E
SYSINIT:3B7E freeMCB         proc near               ; CODE XREF: FreeUMBs+E↑p
SYSINIT:3B7E                 mov     word ptr es:1, 0 ; marks as free the MCB at ES:0
SYSINIT:3B85                 mov     ax, 2020h       ; '  '
SYSINIT:3B88                 mov     es:8, ax        ; mov word [es:ARENA.NAME+0],'  '
SYSINIT:3B8C                 mov     es:0Ah, ax
SYSINIT:3B90                 mov     es:0Ch, ax
SYSINIT:3B94                 mov     es:0Eh, ax      ; [es:ARENA.NAME+6]
SYSINIT:3B98                 retn
SYSINIT:3B98 freeMCB         endp
SYSINIT:3B98
SYSINIT:3B99
SYSINIT:3B99 ; =============== S U B R O U T I N E =======================================
SYSINIT:3B99
SYSINIT:3B99
SYSINIT:3B99 HeadUmb         proc near               ; CODE XREF: FreeUMBs+2↑p
SYSINIT:3B99                 push    es              ; returns in AX the addr of the 1st UMB block (0x9FFF)
SYSINIT:3B9A                 mov     ah, 52h
SYSINIT:3B9C                 int     21h             ; DOS - 2+ internal - GET LIST OF LISTS
SYSINIT:3B9C                                         ; Return: ES:BX -> DOS list of lists
SYSINIT:3B9E                 mov     ax, es:8Ch      ; [es:UMB_HeadIdx]
SYSINIT:3BA2                 cmp     ax, 0FFFFh
SYSINIT:3BA5                 jz      short xhu_e     ; If it's 0xFFFF, it's an error...
SYSINIT:3BA7                 clc                     ; AX contains 0x9FFF for most systems
SYSINIT:3BA8                 jmp     short xhu_x
SYSINIT:3BAA ; ---------------------------------------------------------------------------
SYSINIT:3BAA
SYSINIT:3BAA xhu_e:                                  ; CODE XREF: HeadUmb+C↑j
SYSINIT:3BAA                 stc                     ; error
SYSINIT:3BAB
SYSINIT:3BAB xhu_x:                                  ; CODE XREF: HeadUmb+F↑j
SYSINIT:3BAB                 pop     es
SYSINIT:3BAC                 retn
SYSINIT:3BAC HeadUmb         endp
SYSINIT:3BAC
SYSINIT:3BAD
SYSINIT:3BAD ; =============== S U B R O U T I N E =======================================
SYSINIT:3BAD
SYSINIT:3BAD
SYSINIT:3BAD linkumb         proc near               ; CODE XREF: UnHideUMBs:uhu10↑p
SYSINIT:3BAD                 mov     ax, 5802h       ; DOS_GET_UMBLINK
SYSINIT:3BB0                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:3BB0                                         ; AL = function code: (DOS 5beta) get UMB link state
SYSINIT:3BB2                 or      al, al          ; Current link-state is now in al
SYSINIT:3BB2                                         ; al = 01h -> UMBs in DOS memory chain
SYSINIT:3BB4                 jnz     short lumbX     ; Jumps if UMBs already linked in
SYSINIT:3BB6                 mov     ax, 5803h       ; DOS_SET_UMBLINK
SYSINIT:3BB9                 mov     bx, 1           ; bx = 01h -> add UMBs to DOS memory chain
SYSINIT:3BBC                 int     21h             ; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
SYSINIT:3BBC                                         ; AL = function code: (DOS 5beta) set UMB link state
SYSINIT:3BBE
SYSINIT:3BBE lumbX:                                  ; CODE XREF: linkumb+7↑j
SYSINIT:3BBE                 retn
SYSINIT:3BBE linkumb         endp
SYSINIT:3BBE
SYSINIT:3BBF
SYSINIT:3BBF ; =============== S U B R O U T I N E =======================================
SYSINIT:3BBF
SYSINIT:3BBF
SYSINIT:3BBF InitDevLoad     proc near               ; CODE XREF: MagicPreload+11↑p
SYSINIT:3BBF                                         ; MagicPostload+2E↑p ...
SYSINIT:3BBF                 cmp     cs:DeviceHi, 0  ; Are we loading in UMB ?
SYSINIT:3BC5                 jz      short InitForLo ; no, init for lo mem
SYSINIT:3BC7                 cmp     cs:ConvLoad, 1  ; Are we loading as per Dos 5?
SYSINIT:3BCD                 jz      short InitForConv
SYSINIT:3BCF                 call    ShrinkUMB       ; Stop using the old device arena
SYSINIT:3BD2                 call    HideUMBs        ; Mark up the UM area as we see fit
SYSINIT:3BD5                 call    FreezeUM        ; Hide everything BUT the load area
SYSINIT:3BD8                 call    GetUMBForDev    ; And grab that load area as needed
SYSINIT:3BDB                 pushf
SYSINIT:3BDC                 call    UnFreeze        ; Then unhide everything frozen
SYSINIT:3BDF                 popf
SYSINIT:3BE0                 jb      short InitForLo ;  (if carry, it's loading low)
SYSINIT:3BE2                 jmp     short InitForHi
SYSINIT:3BE4 ; ---------------------------------------------------------------------------
SYSINIT:3BE4
SYSINIT:3BE4 InitForConv:                            ; CODE XREF: InitDevLoad+E↑j
SYSINIT:3BE4                 call    SpaceInUMB      ; Do we have space left in the current UMB ?
SYSINIT:3BE7                 jnb     short InitForHi ; yes, we have
SYSINIT:3BE9                 call    ShrinkUMB       ; shrink the current UMB in use
SYSINIT:3BEC                 call    GetUMBForDev    ; else try to allocate new UMB
SYSINIT:3BEF                 jb      short InitForLo ; we didn't succeed, so load in low memory
SYSINIT:3BF1
SYSINIT:3BF1 InitForHi:                              ; CODE XREF: InitDevLoad+23↑j
SYSINIT:3BF1                                         ; InitDevLoad+28↑j
SYSINIT:3BF1                 mov     ax, cs:DevUMBFree ; get Para addr of free mem
SYSINIT:3BF5                 mov     dx, cs:DevUMBAddr ; UMB start addr
SYSINIT:3BFA                 add     dx, cs:DevUMBSize ; dx = UMB End addr
SYSINIT:3BFF                 jmp     short idl1
SYSINIT:3C01 ; ---------------------------------------------------------------------------
SYSINIT:3C01
SYSINIT:3C01 InitForLo:                              ; CODE XREF: InitDevLoad+6↑j
SYSINIT:3C01                                         ; InitDevLoad+21↑j ...
SYSINIT:3C01                 mov     cs:DeviceHi, 0  ; in case we failed to load into UMB
SYSINIT:3C01                                         ; indicate that we are loading low
SYSINIT:3C07                 mov     ax, cs:memhi    ; start of Low memory
SYSINIT:3C0B                 mov     dx, cs:ALLOCLIM ; end of Low memory
SYSINIT:3C10
SYSINIT:3C10 idl1:                                   ; CODE XREF: InitDevLoad+40↑j
SYSINIT:3C10                 call    DevSetMark      ; setup a sub-arena for DD
SYSINIT:3C13                 mov     cs:DevLoadAddr, ax ; init the Device load address
SYSINIT:3C17                 mov     cs:DevLoadEnd, dx ; init the limit of the block
SYSINIT:3C1C                 mov     word ptr cs:DevEntry, 0 ; init Entry point to DD
SYSINIT:3C23                 mov     word ptr cs:DevEntry+2, ax
SYSINIT:3C27                 retn
SYSINIT:3C27 InitDevLoad     endp
SYSINIT:3C27
SYSINIT:3C28
SYSINIT:3C28 ; =============== S U B R O U T I N E =======================================
SYSINIT:3C28
SYSINIT:3C28
SYSINIT:3C28 SpaceInUMB      proc near               ; CODE XREF: InitDevLoad:InitForConv↑p
SYSINIT:3C28                 mov     ax, cs:DevUMBSize
SYSINIT:3C2C                 add     ax, cs:DevUMBAddr ; End of UMB
SYSINIT:3C31                 sub     ax, cs:DevUMBFree ; - Free = Remaining space
SYSINIT:3C36                 or      ax, ax          ; Nospace ?
SYSINIT:3C38                 jnz     short spcinumb1
SYSINIT:3C3A                 stc
SYSINIT:3C3B                 retn
SYSINIT:3C3C ; ---------------------------------------------------------------------------
SYSINIT:3C3C
SYSINIT:3C3C spcinumb1:                              ; CODE XREF: SpaceInUMB+10↑j
SYSINIT:3C3C                 dec     ax              ; space for sub-arena
SYSINIT:3C3D                 cmp     ax, cs:DevSize  ; do we have space ?
SYSINIT:3C42                 retn
SYSINIT:3C42 SpaceInUMB      endp
SYSINIT:3C42
SYSINIT:3C43
SYSINIT:3C43 ; =============== S U B R O U T I N E =======================================
SYSINIT:3C43
SYSINIT:3C43
SYSINIT:3C43 PrepareMark     proc near               ; CODE XREF: GetUMBForDev+1D↓p
SYSINIT:3C43                 push    ds
SYSINIT:3C44                 mov     ds, ax
SYSINIT:3C46                 mov     word ptr ds:1, 8 ; [ARENA.OWNER]
SYSINIT:3C4C                 mov     word ptr ds:8, 4453h ; [ARENA.NAME],'SD'
SYSINIT:3C52                 pop     ds
SYSINIT:3C53                 inc     ax
SYSINIT:3C54                 mov     cs:DevUMBAddr, ax
SYSINIT:3C58                 mov     cs:DevUMBFree, ax
SYSINIT:3C5C                 mov     cs:DevUMBSize, bx ; update the UMB Variables
SYSINIT:3C61                 retn
SYSINIT:3C61 PrepareMark     endp
SYSINIT:3C61
SYSINIT:3C62
SYSINIT:3C62 ; =============== S U B R O U T I N E =======================================
SYSINIT:3C62
SYSINIT:3C62
SYSINIT:3C62 GetUMBForDev    proc near               ; CODE XREF: InitDevLoad+19↑p
SYSINIT:3C62                                         ; InitDevLoad+2D↑p
SYSINIT:3C62                 mov     bx, 0FFFFh
SYSINIT:3C65                 mov     ax, 4800h
SYSINIT:3C68                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:3C68                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:3C6A                 or      bx, bx
SYSINIT:3C6C                 jz      short gufd_err
SYSINIT:3C6E                 dec     bx
SYSINIT:3C6F                 cmp     cs:DevSize, bx
SYSINIT:3C74                 ja      short gufd_err
SYSINIT:3C76                 inc     bx
SYSINIT:3C77                 mov     ax, 4800h
SYSINIT:3C7A                 int     21h             ; DOS - 2+ - ALLOCATE MEMORY
SYSINIT:3C7A                                         ; BX = number of 16-byte paragraphs desired
SYSINIT:3C7C                 jb      short gufd_err
SYSINIT:3C7E                 dec     ax
SYSINIT:3C7F                 call    PrepareMark
SYSINIT:3C82                 clc
SYSINIT:3C83                 retn
SYSINIT:3C84 ; ---------------------------------------------------------------------------
SYSINIT:3C84
SYSINIT:3C84 gufd_err:                               ; CODE XREF: GetUMBForDev+A↑j
SYSINIT:3C84                                         ; GetUMBForDev+12↑j ...
SYSINIT:3C84                 xor     ax, ax          ; 0
SYSINIT:3C86                 mov     cs:DevUMBSize, ax ; erase the previous values
SYSINIT:3C8A                 mov     cs:DevUMBAddr, ax
SYSINIT:3C8E                 mov     cs:DevUMBFree, ax
SYSINIT:3C92                 stc
SYSINIT:3C93                 retn
SYSINIT:3C93 GetUMBForDev    endp
SYSINIT:3C93
SYSINIT:3C94
SYSINIT:3C94 ; =============== S U B R O U T I N E =======================================
SYSINIT:3C94
SYSINIT:3C94
SYSINIT:3C94 DevSetMark      proc near               ; CODE XREF: InitDevLoad:idl1↑p
SYSINIT:3C94                 push    es              ; Input :
SYSINIT:3C94                                         ; AX - Free segment were device is going to be loaded
SYSINIT:3C94                                         ; Output :
SYSINIT:3C94                                         ; AX - Segment at which device can be loaded (AX=AX+1)
SYSINIT:3C94                                         ;
SYSINIT:3C94                                         ; Creates a sub-arena for the device driver
SYSINIT:3C94                                         ; puts 'D' marker in the sub-arena
SYSINIT:3C95                 push    di
SYSINIT:3C96                 push    ds
SYSINIT:3C97                 push    si
SYSINIT:3C98                 mov     es, ax
SYSINIT:3C9A                 mov     byte ptr es:0, 44h ; 'D' ; [es:devmark.id],devmark_device ; 'D'
SYSINIT:3CA0                 inc     ax
SYSINIT:3CA1                 mov     es:1, ax        ; [es:devmark.seg]
SYSINIT:3CA5                 push    ax              ; save load address
SYSINIT:3CA6                 lds     si, cs:bpb_addr ; command line is still there
SYSINIT:3CAB                 mov     di, si
SYSINIT:3CAD                 cld
SYSINIT:3CAE
SYSINIT:3CAE dsm_again:                              ; CODE XREF: DevSetMark+21↓j
SYSINIT:3CAE                                         ; DevSetMark+29↓j ...
SYSINIT:3CAE                 lodsb
SYSINIT:3CAF                 cmp     al, 3Ah ; ':'
SYSINIT:3CB1                 jnz     short isit_slash
SYSINIT:3CB3                 mov     di, si
SYSINIT:3CB5                 jmp     short dsm_again
SYSINIT:3CB7 ; ---------------------------------------------------------------------------
SYSINIT:3CB7
SYSINIT:3CB7 isit_slash:                             ; CODE XREF: DevSetMark+1D↑j
SYSINIT:3CB7                 cmp     al, 5Ch ; '\'
SYSINIT:3CB9                 jnz     short isit_null
SYSINIT:3CBB                 mov     di, si
SYSINIT:3CBD                 jmp     short dsm_again
SYSINIT:3CBF ; ---------------------------------------------------------------------------
SYSINIT:3CBF
SYSINIT:3CBF isit_null:                              ; CODE XREF: DevSetMark+25↑j
SYSINIT:3CBF                 or      al, al
SYSINIT:3CC1                 jnz     short dsm_again
SYSINIT:3CC3                 mov     si, di
SYSINIT:3CC5                 mov     di, 8           ; devmark.filename ; 8
SYSINIT:3CC8                 mov     cx, 8           ; maximum 8 characters
SYSINIT:3CCB
SYSINIT:3CCB dsm_next_char:                          ; CODE XREF: DevSetMark+41↓j
SYSINIT:3CCB                 lodsb
SYSINIT:3CCC                 or      al, al
SYSINIT:3CCE                 jz      short blankout
SYSINIT:3CD0                 cmp     al, 2Eh ; '.'
SYSINIT:3CD2                 jz      short blankout
SYSINIT:3CD4                 stosb
SYSINIT:3CD5                 loop    dsm_next_char
SYSINIT:3CD7
SYSINIT:3CD7 blankout:                               ; CODE XREF: DevSetMark+3A↑j
SYSINIT:3CD7                                         ; DevSetMark+3E↑j
SYSINIT:3CD7                 jcxz    short dsm_exit
SYSINIT:3CD9                 mov     al, 20h ; ' '
SYSINIT:3CDB                 rep stosb               ; blank out the rest
SYSINIT:3CDD
SYSINIT:3CDD dsm_exit:                               ; CODE XREF: DevSetMark:blankout↑j
SYSINIT:3CDD                 pop     ax              ; restore load address
SYSINIT:3CDE                 pop     si
SYSINIT:3CDF                 pop     ds
SYSINIT:3CE0                 pop     di
SYSINIT:3CE1                 pop     es
SYSINIT:3CE2                 retn
SYSINIT:3CE2 DevSetMark      endp
SYSINIT:3CE2
SYSINIT:3CE3
SYSINIT:3CE3 ; =============== S U B R O U T I N E =======================================
SYSINIT:3CE3
SYSINIT:3CE3
SYSINIT:3CE3 SizeDevice      proc near               ; CODE XREF: SYSINIT:set_dblspc_size↑p
SYSINIT:3CE3                                         ; doconf+3B9↑p
SYSINIT:3CE3                 push    ds              ; Calculates the size of the device file in paras
SYSINIT:3CE3                                         ; and stores it in DevSize
SYSINIT:3CE4                 push    es
SYSINIT:3CE5                 pop     ds
SYSINIT:3CE6                 mov     dx, si
SYSINIT:3CE8                 mov     ax, 3D00h
SYSINIT:3CEB                 int     21h             ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
SYSINIT:3CEB                                         ; DS:DX -> ASCIZ filename
SYSINIT:3CEB                                         ; AL = access mode
SYSINIT:3CEB                                         ; 0 - read
SYSINIT:3CED                 jb      short sd_err
SYSINIT:3CEF                 mov     bx, ax          ; BX - file handle
SYSINIT:3CF1                 mov     ax, 4202h
SYSINIT:3CF4                 xor     cx, cx
SYSINIT:3CF6                 mov     dx, cx
SYSINIT:3CF8                 int     21h             ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
SYSINIT:3CF8                                         ; AL = method: offset from end of file
SYSINIT:3CFA                 jb      short sd_close
SYSINIT:3CFC                 add     ax, 15
SYSINIT:3CFF                 adc     dx, 0
SYSINIT:3D02                 test    dx, 0FFF0h      ; size > 0ffffh paras ?
SYSINIT:3D06                 jz      short sd_ctp    ; no
SYSINIT:3D08                 mov     cs:DevSize, 0FFFFh ; invalid device size
SYSINIT:3D08                                         ; assuming that we fail later
SYSINIT:3D0F                 jmp     short sd_close
SYSINIT:3D11 ; ---------------------------------------------------------------------------
SYSINIT:3D11
SYSINIT:3D11 sd_ctp:                                 ; CODE XREF: SizeDevice+23↑j
SYSINIT:3D11                 mov     cl, 4           ; convert it to paras
SYSINIT:3D13                 shr     ax, cl
SYSINIT:3D15                 mov     cl, 12
SYSINIT:3D17                 shl     dx, cl
SYSINIT:3D19                 or      ax, dx
SYSINIT:3D1B                 mov     cs:DevSize, ax  ; save file size (in paragraphs)
SYSINIT:3D1F                 clc                     ; CLC is not needed here
SYSINIT:3D1F                                         ; (OR instruction clears CF) - E.TAN 22/07/2023
SYSINIT:3D20
SYSINIT:3D20 sd_close:                               ; CODE XREF: SizeDevice+17↑j
SYSINIT:3D20                                         ; SizeDevice+2C↑j
SYSINIT:3D20                 pushf                   ; save carry flag
SYSINIT:3D21                 mov     ax, 3E00h
SYSINIT:3D24                 int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
SYSINIT:3D24                                         ; BX = file handle
SYSINIT:3D26                 popf                    ; restore carry flag
SYSINIT:3D26                                         ; (we are not checking for 'close file' err)
SYSINIT:3D27
SYSINIT:3D27 sd_err:                                 ; CODE XREF: SizeDevice+A↑j
SYSINIT:3D27                 pop     ds
SYSINIT:3D28                 retn
SYSINIT:3D28 SizeDevice      endp
SYSINIT:3D28
SYSINIT:3D29
SYSINIT:3D29 ; =============== S U B R O U T I N E =======================================
SYSINIT:3D29
SYSINIT:3D29
SYSINIT:3D29 ExecDev         proc near               ; CODE XREF: MagicPreload+2D↑p
SYSINIT:3D29                                         ; doconf+416↑p
SYSINIT:3D29                 mov     bx, cs:DevLoadAddr
SYSINIT:3D2E                 mov     cs:DevExecAddr, bx ; Load the parameter block
SYSINIT:3D33                 mov     cs:DevExecReloc, bx ; block for exec with Load address
SYSINIT:3D38                 mov     bx, cs
SYSINIT:3D3A                 mov     es, bx
SYSINIT:3D3C                 assume es:SYSINIT
SYSINIT:3D3C                 mov     bx, offset DevExecAddr ; es:bx points to parameters
SYSINIT:3D3F                 mov     al, 3           ; (load program only)
SYSINIT:3D41                 mov     ah, 4Bh         ; load in the device driver
SYSINIT:3D43                 int     21h             ; DOS - 2+ - LOAD OR EXECUTE (EXEC)
SYSINIT:3D43                                         ; DS:DX -> ASCIZ filename
SYSINIT:3D43                                         ; ES:BX -> parameter block
SYSINIT:3D43                                         ; AL = type of load
SYSINIT:3D45                 retn
SYSINIT:3D45 ExecDev         endp
SYSINIT:3D45
SYSINIT:3D46
SYSINIT:3D46 ; =============== S U B R O U T I N E =======================================
SYSINIT:3D46
SYSINIT:3D46
SYSINIT:3D46 RetFromUM       proc near               ; CODE XREF: doconf:BadFile↑p
SYSINIT:3D46                                         ; doconf+445↑p ...
SYSINIT:3D46                 pushf
SYSINIT:3D47                 mov     cs:ConvLoad, 1  ; ConvLoad set if didn't previously call HideUMBs
SYSINIT:3D4D                 call    UnHideUMBs
SYSINIT:3D50                 jb      short rfUM1
SYSINIT:3D52                 mov     cs:ConvLoad, 0  ; ConvLoad clear if did.
SYSINIT:3D58
SYSINIT:3D58 rfUM1:                                  ; CODE XREF: RetFromUM+A↑j
SYSINIT:3D58                 popf
SYSINIT:3D59                 retn
SYSINIT:3D59 RetFromUM       endp
SYSINIT:3D59
SYSINIT:3D5A
SYSINIT:3D5A ; =============== S U B R O U T I N E =======================================
SYSINIT:3D5A
SYSINIT:3D5A
SYSINIT:3D5A RemoveNull      proc near               ; CODE XREF: doconf+421↑p
SYSINIT:3D5A                                         ; RemoveNull+8↓j
SYSINIT:3D5A                 mov     bl, es:[si]
SYSINIT:3D5D                 or      bl, bl          ; null ?
SYSINIT:3D5F                 jz      short rn_gotnull
SYSINIT:3D61                 inc     si              ; advance the pointer
SYSINIT:3D62                 jmp     short RemoveNull
SYSINIT:3D64 ; ---------------------------------------------------------------------------
SYSINIT:3D64
SYSINIT:3D64 rn_gotnull:                             ; CODE XREF: RemoveNull+5↑j
SYSINIT:3D64                 mov     bl, cs:DevSavedDelim
SYSINIT:3D69                 mov     es:[si], bl     ; replace null with blank
SYSINIT:3D6C                 retn
SYSINIT:3D6C RemoveNull      endp
SYSINIT:3D6C
SYSINIT:3D6D
SYSINIT:3D6D ; =============== S U B R O U T I N E =======================================
SYSINIT:3D6D
SYSINIT:3D6D
SYSINIT:3D6D RoundBreakAddr  proc near               ; CODE XREF: MagicPreload+160↑p
SYSINIT:3D6D                                         ; doconf+5B0↑p ...
SYSINIT:3D6D                 mov     ax, word ptr cs:DevBrkAddr ; Rounds DevBrkAddr to a para addr
SYSINIT:3D6D                                         ; so that it is of the form xxxx:0
SYSINIT:3D71                 call    ParaRound
SYSINIT:3D74                 add     word ptr cs:DevBrkAddr+2, ax
SYSINIT:3D79                 mov     word ptr cs:DevBrkAddr, 0
SYSINIT:3D80                 mov     ax, cs:DevLoadEnd
SYSINIT:3D84                 cmp     word ptr cs:DevBrkAddr+2, ax
SYSINIT:3D89                 jbe     short rba_ok
SYSINIT:3D8B                 jmp     mem_err
SYSINIT:3D8E ; ---------------------------------------------------------------------------
SYSINIT:3D8E
SYSINIT:3D8E rba_ok:                                 ; CODE XREF: RoundBreakAddr+1C↑j
SYSINIT:3D8E                 retn
SYSINIT:3D8E RoundBreakAddr  endp
SYSINIT:3D8E
SYSINIT:3D8F
SYSINIT:3D8F ; =============== S U B R O U T I N E =======================================
SYSINIT:3D8F
SYSINIT:3D8F
SYSINIT:3D8F DevSetBreak     proc near               ; CODE XREF: MagicPreload+111↑p
SYSINIT:3D8F                                         ; MagicPostload+62↑p ...
SYSINIT:3D8F                 push    ax
SYSINIT:3D90                 mov     ax, word ptr cs:DevBrkAddr+2 ; remove the init code
SYSINIT:3D94                 cmp     cs:multdeviceflag, 0
SYSINIT:3D9A                 jnz     short set_break_continue ; do not check it.
SYSINIT:3D9C                 cmp     ax, cs:DevLoadAddr
SYSINIT:3DA1                 jnz     short set_break_continue ; if not same, then o.k.
SYSINIT:3DA3                 cmp     word ptr cs:DevBrkAddr, 0
SYSINIT:3DA9                 jz      short break_failed ; [DevBrkAddr+2]=[memhi] & [DevBrkAddr]=0
SYSINIT:3DAB
SYSINIT:3DAB set_break_continue:                     ; CODE XREF: DevSetBreak+B↑j
SYSINIT:3DAB                                         ; DevSetBreak+12↑j
SYSINIT:3DAB                 call    RoundBreakAddr
SYSINIT:3DAE                 pop     ax
SYSINIT:3DAF                 clc
SYSINIT:3DB0                 retn
SYSINIT:3DB1 ; ---------------------------------------------------------------------------
SYSINIT:3DB1
SYSINIT:3DB1 break_failed:                           ; CODE XREF: DevSetBreak+1A↑j
SYSINIT:3DB1                 pop     ax
SYSINIT:3DB2                 stc
SYSINIT:3DB3                 retn
SYSINIT:3DB3 DevSetBreak     endp
SYSINIT:3DB3
SYSINIT:3DB4
SYSINIT:3DB4 ; =============== S U B R O U T I N E =======================================
SYSINIT:3DB4
SYSINIT:3DB4
SYSINIT:3DB4 DevBreak        proc near               ; CODE XREF: MagicPreload+1EB↑p
SYSINIT:3DB4                                         ; MagicPostload+65↑p ...
SYSINIT:3DB4                 push    ds              ; Marks a succesful install of a device driver
SYSINIT:3DB4                                         ; Sets device size field in sub-arena &
SYSINIT:3DB4                                         ; Updates Free ptr in UMB or adjusts memhi
SYSINIT:3DB5                 mov     ax, cs:DevLoadAddr
SYSINIT:3DB9                 mov     bx, word ptr cs:DevBrkAddr+2
SYSINIT:3DBE                 dec     ax              ; seg of sub-arena
SYSINIT:3DBF                 mov     ds, ax
SYSINIT:3DC1                 inc     ax              ; Back to Device segment
SYSINIT:3DC2                 sub     ax, bx
SYSINIT:3DC4                 neg     ax              ; size of device in paras
SYSINIT:3DC6                 mov     ds:3, ax        ; [devmark.size]
SYSINIT:3DC6                                         ; store it in sub-arena
SYSINIT:3DC9                 cmp     cs:DeviceHi, 0
SYSINIT:3DCF                 jz      short db_lo
SYSINIT:3DD1                 mov     cs:DevUMBFree, bx ; update Free ptr in UMB
SYSINIT:3DD6                 jmp     short db_exit
SYSINIT:3DD8 ; ---------------------------------------------------------------------------
SYSINIT:3DD8
SYSINIT:3DD8 db_lo:                                  ; CODE XREF: DevBreak+1B↑j
SYSINIT:3DD8                 mov     cs:memhi, bx
SYSINIT:3DDD                 mov     cs:memlo, 0
SYSINIT:3DE4
SYSINIT:3DE4 db_exit:                                ; CODE XREF: DevBreak+22↑j
SYSINIT:3DE4                 pop     ds
SYSINIT:3DE5                 retn
SYSINIT:3DE5 DevBreak        endp
SYSINIT:3DE5
SYSINIT:3DE6
SYSINIT:3DE6 ; =============== S U B R O U T I N E =======================================
SYSINIT:3DE6
SYSINIT:3DE6
SYSINIT:3DE6 ParseSize       proc near               ; CODE XREF: doconf+305↑p
SYSINIT:3DE6                 push    bx              ; Parses the command line for SIZE= command
SYSINIT:3DE7                 mov     bx, si
SYSINIT:3DE9                 mov     cs:DevSizeOption, 0 ; init the value
SYSINIT:3DF0                 mov     cs:DevCmdLine, si
SYSINIT:3DF5                 mov     cs:DevCmdLine+2, es
SYSINIT:3DFA                 call    SkipDelim
SYSINIT:3DFD                 cmp     word ptr es:[si], 4953h ; 'SI'
SYSINIT:3E02                 jnz     short ps_no_size
SYSINIT:3E04                 cmp     word ptr es:[si+2], 455Ah ; 'ZE'
SYSINIT:3E0A                 jnz     short ps_no_size
SYSINIT:3E0C                 mov     al, es:[si+4]
SYSINIT:3E10                 call    delim
SYSINIT:3E13                 jnz     short ps_no_size ; cf=0 here
SYSINIT:3E15                 add     si, 5
SYSINIT:3E18                 call    GetHexNum
SYSINIT:3E1B                 jb      short ps_err
SYSINIT:3E1D                 mov     cs:DevSizeOption, ax
SYSINIT:3E21                 call    SkipDelim
SYSINIT:3E24                 mov     bx, si          ; cf=0 here
SYSINIT:3E26
SYSINIT:3E26 ps_no_size:                             ; CODE XREF: ParseSize+1C↑j
SYSINIT:3E26                                         ; ParseSize+24↑j ...
SYSINIT:3E26                 mov     si, bx
SYSINIT:3E28                 pop     bx
SYSINIT:3E29                 clc                     ; cf=0 here (clc is not needed)
SYSINIT:3E29                                         ; 22/07/2023 - Erdogan Tan
SYSINIT:3E2A                 retn
SYSINIT:3E2B ; ---------------------------------------------------------------------------
SYSINIT:3E2B
SYSINIT:3E2B ps_err:                                 ; CODE XREF: ParseSize+35↑j
SYSINIT:3E2B                 pop     bx
SYSINIT:3E2C                 stc
SYSINIT:3E2D                 retn
SYSINIT:3E2D ParseSize       endp
SYSINIT:3E2D
SYSINIT:3E2E
SYSINIT:3E2E ; =============== S U B R O U T I N E =======================================
SYSINIT:3E2E
SYSINIT:3E2E
SYSINIT:3E2E SkipDelim       proc near               ; CODE XREF: ParseSize+14↑p
SYSINIT:3E2E                                         ; ParseSize+3B↑p ...
SYSINIT:3E2E                 mov     al, es:[si]     ; Skips delimiters in the string pointed to by ES:SI
SYSINIT:3E2E                                         ; Returns ptr to first non-delimiter character in ES:SI
SYSINIT:3E31                 call    delim
SYSINIT:3E34                 jnz     short sd_ret
SYSINIT:3E36                 inc     si
SYSINIT:3E37                 jmp     short SkipDelim
SYSINIT:3E39 ; ---------------------------------------------------------------------------
SYSINIT:3E39
SYSINIT:3E39 sd_ret:                                 ; CODE XREF: SkipDelim+6↑j
SYSINIT:3E39                 retn
SYSINIT:3E39 SkipDelim       endp
SYSINIT:3E39
SYSINIT:3E3A
SYSINIT:3E3A ; =============== S U B R O U T I N E =======================================
SYSINIT:3E3A
SYSINIT:3E3A
SYSINIT:3E3A GetHexNum       proc near               ; CODE XREF: ParseSize+32↑p
SYSINIT:3E3A                 xor     ax, ax          ; Converts an ascii string
SYSINIT:3E3A                                         ; terminated by a delimiter into binary.
SYSINIT:3E3A                                         ; Assumes that the ES:SI
SYSINIT:3E3A                                         ; points to a Hexadecimal string
SYSINIT:3E3C                 xor     dx, dx
SYSINIT:3E3E
SYSINIT:3E3E ghn_next:                               ; CODE XREF: GetHexNum+2B↓j
SYSINIT:3E3E                 mov     bl, es:[si]
SYSINIT:3E41                 cmp     bl, 0Dh         ; cr
SYSINIT:3E44                 jz      short ghn_err
SYSINIT:3E46                 cmp     bl, 0Ah         ; lf
SYSINIT:3E49                 jz      short ghn_err
SYSINIT:3E4B                 push    ax
SYSINIT:3E4C                 mov     al, bl
SYSINIT:3E4E                 call    delim
SYSINIT:3E51                 pop     ax
SYSINIT:3E52                 jz      short ghn_into_paras
SYSINIT:3E54                 call    GetNibble
SYSINIT:3E57                 jb      short ghn_err
SYSINIT:3E59                 mov     cx, 4
SYSINIT:3E5C
SYSINIT:3E5C ghn_shift1:                             ; CODE XREF: GetHexNum+26↓j
SYSINIT:3E5C                 shl     ax, 1
SYSINIT:3E5E                 rcl     dx, 1
SYSINIT:3E60                 loop    ghn_shift1
SYSINIT:3E62                 or      al, bl
SYSINIT:3E64                 inc     si
SYSINIT:3E65                 jmp     short ghn_next
SYSINIT:3E67 ; ---------------------------------------------------------------------------
SYSINIT:3E67
SYSINIT:3E67 ghn_into_paras:                         ; CODE XREF: GetHexNum+18↑j
SYSINIT:3E67                 add     ax, 15
SYSINIT:3E6A                 adc     dx, 0
SYSINIT:3E6D                 test    dx, 0FFF0h
SYSINIT:3E71                 jnz     short ghn_err
SYSINIT:3E73                 mov     cx, 4
SYSINIT:3E76
SYSINIT:3E76 ghn_shift2:                             ; CODE XREF: GetHexNum+41↓j
SYSINIT:3E76                 clc
SYSINIT:3E77                 rcr     dx, 1
SYSINIT:3E79                 rcr     ax, 1
SYSINIT:3E7B                 loop    ghn_shift2
SYSINIT:3E7D                 clc                     ; AX = number of paras equivalent to the
SYSINIT:3E7D                                         ; hex number of bytes specified
SYSINIT:3E7D                                         ; by the hexadecimal string.
SYSINIT:3E7E                 retn
SYSINIT:3E7F ; ---------------------------------------------------------------------------
SYSINIT:3E7F
SYSINIT:3E7F ghn_err:                                ; CODE XREF: GetHexNum+A↑j
SYSINIT:3E7F                                         ; GetHexNum+F↑j ...
SYSINIT:3E7F                 stc                     ; encountered a non-hex character or crlf
SYSINIT:3E80                 retn
SYSINIT:3E80 GetHexNum       endp
SYSINIT:3E80
SYSINIT:3E81
SYSINIT:3E81 ; =============== S U B R O U T I N E =======================================
SYSINIT:3E81
SYSINIT:3E81
SYSINIT:3E81 GetNibble       proc near               ; CODE XREF: GetHexNum+1A↑p
SYSINIT:3E81                 cmp     bl, 30h ; '0'   ; Convert one nibble (hex digit) in BL into binary
SYSINIT:3E84                 jb      short gnib_err
SYSINIT:3E86                 cmp     bl, 39h ; '9'
SYSINIT:3E89                 ja      short is_it_hex
SYSINIT:3E8B                 sub     bl, 30h ; '0'
SYSINIT:3E8E                 retn
SYSINIT:3E8F ; ---------------------------------------------------------------------------
SYSINIT:3E8F
SYSINIT:3E8F is_it_hex:                              ; CODE XREF: GetNibble+8↑j
SYSINIT:3E8F                 cmp     bl, 41h ; 'A'
SYSINIT:3E92                 jb      short gnib_err
SYSINIT:3E94                 cmp     bl, 46h ; 'F'
SYSINIT:3E97                 ja      short gnib_err
SYSINIT:3E99                 sub     bl, 37h ; '7'   ; 'A'- 10
SYSINIT:3E9C                 retn
SYSINIT:3E9D ; ---------------------------------------------------------------------------
SYSINIT:3E9D
SYSINIT:3E9D gnib_err:                               ; CODE XREF: GetNibble+3↑j
SYSINIT:3E9D                                         ; GetNibble+11↑j ...
SYSINIT:3E9D                 stc
SYSINIT:3E9E                 retn
SYSINIT:3E9E GetNibble       endp
SYSINIT:3E9E
SYSINIT:3E9F
SYSINIT:3E9F ; =============== S U B R O U T I N E =======================================
SYSINIT:3E9F
SYSINIT:3E9F
SYSINIT:3E9F AllocUMB        proc near               ; CODE XREF: doconf+4BD↑p
SYSINIT:3E9F                 call    InitAllocUMB    ; Allocate all UMBs and link it to DOS arena chain
SYSINIT:3E9F                                         ; link in the first UMB
SYSINIT:3EA2                 jb      short au_exit   ; quit on error
SYSINIT:3EA4
SYSINIT:3EA4 au_next:                                ; CODE XREF: AllocUMB+D↓j
SYSINIT:3EA4                 call    umb_allocate    ; allocate
SYSINIT:3EA7                 jb      short au_coalesce
SYSINIT:3EA9                 call    umb_insert      ; & insert till no UMBs
SYSINIT:3EAC                 jmp     short au_next
SYSINIT:3EAE ; ---------------------------------------------------------------------------
SYSINIT:3EAE
SYSINIT:3EAE au_coalesce:                            ; CODE XREF: AllocUMB+8↑j
SYSINIT:3EAE                 call    umb_coalesce    ; coalesce all UMBs
SYSINIT:3EB1
SYSINIT:3EB1 au_exit:                                ; CODE XREF: AllocUMB+3↑j
SYSINIT:3EB1                 retn
SYSINIT:3EB1 AllocUMB        endp
SYSINIT:3EB1
SYSINIT:3EB2
SYSINIT:3EB2 ; =============== S U B R O U T I N E =======================================
SYSINIT:3EB2
SYSINIT:3EB2
SYSINIT:3EB2 InitAllocUMB    proc near               ; CODE XREF: AllocUMB↑p
SYSINIT:3EB2                 call    IsXMSLoaded
SYSINIT:3EB5                 jnz     short iau_err   ; quit on no XMS driver
SYSINIT:3EB7                 mov     ah, 52h
SYSINIT:3EB9                 int     21h             ; DOS - 2+ internal - GET LIST OF LISTS
SYSINIT:3EB9                                         ; Return: ES:BX -> DOS list of lists
SYSINIT:3EBB                 mov     cs:DevDOSData, es ; save dos data segment
SYSINIT:3EC0                 mov     ax, 4310h
SYSINIT:3EC3                 int     2Fh             ; - Multiplex - XMS - GET DRIVER ADDRESS
SYSINIT:3EC3                                         ; Return: ES:BX -> driver entry point
SYSINIT:3EC5                 mov     word ptr cs:DevXMSAddr, bx ; get XMS driver address
SYSINIT:3ECA                 mov     word ptr cs:DevXMSAddr+2, es
SYSINIT:3ECF                 cmp     cs:FirstUMBLinked, 0 ; have we already linked a UMB?
SYSINIT:3ED5                 jnz     short ia_1      ; quit if we already did it
SYSINIT:3ED7                 call    LinkFirstUMB    ; else link the first UMB
SYSINIT:3EDA                 jb      short iau_err
SYSINIT:3EDC                 mov     cs:FirstUMBLinked, 0FFh ; mark that 1st UMB linked
SYSINIT:3EE2
SYSINIT:3EE2 ia_1:                                   ; CODE XREF: InitAllocUMB+23↑j
SYSINIT:3EE2                 clc                     ; (cf is already zero here)
SYSINIT:3EE2                                         ; Erdogan tan - 27/07/2023
SYSINIT:3EE3                 retn
SYSINIT:3EE4 ; ---------------------------------------------------------------------------
SYSINIT:3EE4
SYSINIT:3EE4 iau_err:                                ; CODE XREF: InitAllocUMB+3↑j
SYSINIT:3EE4                                         ; InitAllocUMB+28↑j
SYSINIT:3EE4                 stc
SYSINIT:3EE5                 retn
SYSINIT:3EE5 InitAllocUMB    endp
SYSINIT:3EE5
SYSINIT:3EE6
SYSINIT:3EE6 ; =============== S U B R O U T I N E =======================================
SYSINIT:3EE6
SYSINIT:3EE6
SYSINIT:3EE6 umb_allocate    proc near               ; CODE XREF: AllocUMB:au_next↑p
SYSINIT:3EE6                                         ; LinkFirstUMB↓p
SYSINIT:3EE6                 push    ax
SYSINIT:3EE7                 mov     ah, 16          ; XMM_REQUEST_UMB
SYSINIT:3EE9                 mov     dx, 0FFFFh      ; try to allocate largest possible
SYSINIT:3EEC                 call    cs:DevXMSAddr
SYSINIT:3EF1                 or      dx, dx
SYSINIT:3EF3                 jz      short ua_err
SYSINIT:3EF5                 mov     ah, 16
SYSINIT:3EF7                 call    cs:DevXMSAddr
SYSINIT:3EFC                 cmp     ax, 1           ; Q: was the reqst successful
SYSINIT:3EFF                 jnz     short ua_err    ; N: error
SYSINIT:3F01                 clc
SYSINIT:3F02
SYSINIT:3F02 ua_done:                                ; CODE XREF: umb_allocate+1F↓j
SYSINIT:3F02                 pop     ax
SYSINIT:3F03                 retn
SYSINIT:3F04 ; ---------------------------------------------------------------------------
SYSINIT:3F04
SYSINIT:3F04 ua_err:                                 ; CODE XREF: umb_allocate+D↑j
SYSINIT:3F04                                         ; umb_allocate+19↑j
SYSINIT:3F04                 stc
SYSINIT:3F05                 jmp     short ua_done
SYSINIT:3F05 umb_allocate    endp
SYSINIT:3F05
SYSINIT:3F07
SYSINIT:3F07 ; =============== S U B R O U T I N E =======================================
SYSINIT:3F07
SYSINIT:3F07
SYSINIT:3F07 umb_insert      proc near               ; CODE XREF: AllocUMB+A↑p
SYSINIT:3F07                 push    ds              ; links the UMB into the arena chain
SYSINIT:3F08                 mov     ds, cs:DevDOSData
SYSINIT:3F0D                 mov     ds, word ptr ds:8Ch ; [UMB_ARENA]  ; ds = UMB_HEAD
SYSINIT:3F11                 mov     ax, ds
SYSINIT:3F13                 mov     es, ax
SYSINIT:3F15                 assume es:nothing
SYSINIT:3F15
SYSINIT:3F15 ui_next:                                ; CODE XREF: umb_insert+1F↓j
SYSINIT:3F15                 cmp     ax, bx          ; BX = seg address of UMB to be linked in
SYSINIT:3F17                 ja      short ui_insert ; current block above new block, insert it
SYSINIT:3F19                 cmp     byte ptr es:0, 5Ah ; 'Z' ; [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:3F1F                 jz      short ui_append ; if current block is the last,
SYSINIT:3F1F                                         ; append new block to chain
SYSINIT:3F21                 mov     ds, ax
SYSINIT:3F23                 call    get_next
SYSINIT:3F26                 jmp     short ui_next   ; ax = es = next block
SYSINIT:3F28 ; ---------------------------------------------------------------------------
SYSINIT:3F28
SYSINIT:3F28 ui_insert:                              ; CODE XREF: umb_insert+10↑j
SYSINIT:3F28                 mov     cx, ds          ; ds = previous arena
SYSINIT:3F2A                 inc     cx              ; top of previous block
SYSINIT:3F2B                 sub     cx, bx
SYSINIT:3F2D                 neg     cx              ; cx = size of used block
SYSINIT:3F2F                 mov     byte ptr ds:0, 4Dh ; 'M' ; [ARENA.SIGNATURE],arena_signature_normal
SYSINIT:3F34                 mov     word ptr ds:1, 8 ; [ARENA.OWNER],8 ; mark as system owned
SYSINIT:3F3A                 mov     ds:3, cx        ; [ARENA.SIZE],cx
SYSINIT:3F3E                 mov     word ptr ds:8, 4353h ; [ARENA.NAME],'SC'
SYSINIT:3F44                 mov     es, bx          ; prepare the arena at start of new block
SYSINIT:3F46                 mov     byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
SYSINIT:3F4C                 mov     word ptr es:1, 0 ; [es:ARENA.OWNER],arena_owner_system ; mark as free
SYSINIT:3F53                 sub     dx, 2           ; DX = size of UMB to be linked in paras
SYSINIT:3F53                                         ; make room for arena at start & end of new block
SYSINIT:3F56                 mov     es:3, dx        ; [es:ARENA.SIZE],dx
SYSINIT:3F5B                 add     bx, dx          ; prepare arena at end of new block
SYSINIT:3F5D                 inc     bx
SYSINIT:3F5E                 mov     es, bx          ; es = arena at top of new block
SYSINIT:3F60                 inc     bx              ; bx = top of new block
SYSINIT:3F61                 sub     ax, bx          ; ax contains arena just above this block
SYSINIT:3F61                                         ; result: ax = size of used block
SYSINIT:3F63                 mov     byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
SYSINIT:3F69                 mov     word ptr es:1, 8 ; [es:ARENA.OWNER],8 ; mark as system owned
SYSINIT:3F70                 mov     es:3, ax        ; [es:ARENA.SIZE],ax
SYSINIT:3F74                 mov     word ptr es:8, 4353h ; [es:ARENA.NAME],'SC'
SYSINIT:3F7B                 jmp     short ui_done
SYSINIT:3F7D ; ---------------------------------------------------------------------------
SYSINIT:3F7D
SYSINIT:3F7D ui_append:                              ; CODE XREF: umb_insert+18↑j
SYSINIT:3F7D                 add     ax, es:3        ; es = arena of last block
SYSINIT:3F7D                                         ; [es:ARENA.SIZE] ; ax=top of last block-1 para
SYSINIT:3F82                 sub     word ptr es:3, 1 ; reserve space on top of this
SYSINIT:3F82                                         ; block for the next arena.
SYSINIT:3F88                 mov     byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
SYSINIT:3F8E                 mov     cx, ax          ; cx = top of prev block-1
SYSINIT:3F90                 inc     ax
SYSINIT:3F91                 sub     ax, bx          ; ax = top of prev block - seg. addr of new block
SYSINIT:3F93                 neg     ax
SYSINIT:3F95                 mov     es, cx          ; es = arena of unused block
SYSINIT:3F97                 mov     byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
SYSINIT:3F9D                 mov     word ptr es:1, 8 ; [es:ARENA.OWNER],8 ; mark as system owned
SYSINIT:3FA4                 mov     es:3, ax        ; mov [es:ARENA.SIZE],ax
SYSINIT:3FA8                 mov     word ptr es:8, 4353h ; mov word [es:ARENA.NAME],'SC'
SYSINIT:3FAF                 mov     es, bx          ; prepare the arena at start of new block
SYSINIT:3FB1                 mov     byte ptr es:0, 5Ah ; 'Z' ; [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:3FB7                 mov     word ptr es:1, 0 ; [es:ARENA.OWNER],arena_owner_system
SYSINIT:3FB7                                         ; mark as free
SYSINIT:3FBE                 dec     dx              ; make room for arena
SYSINIT:3FBF                 mov     es:3, dx        ; mov [es:ARENA.SIZE],dx
SYSINIT:3FC4
SYSINIT:3FC4 ui_done:                                ; CODE XREF: umb_insert+74↑j
SYSINIT:3FC4                 pop     ds
SYSINIT:3FC5                 retn
SYSINIT:3FC5 umb_insert      endp
SYSINIT:3FC5
SYSINIT:3FC6
SYSINIT:3FC6 ; =============== S U B R O U T I N E =======================================
SYSINIT:3FC6
SYSINIT:3FC6
SYSINIT:3FC6 umb_coalesce    proc near               ; CODE XREF: AllocUMB:au_coalesce↑p
SYSINIT:3FC6                 xor     di, di          ; Combine free blocks ahead with current block
SYSINIT:3FC8                 mov     es, cs:DevDOSData
SYSINIT:3FCD                 mov     es, word ptr es:8Ch ; [es:UMB_ARENA] ; es = UMB_HEAD
SYSINIT:3FD2
SYSINIT:3FD2 uc_nextfree:                            ; CODE XREF: umb_coalesce+1C↓j
SYSINIT:3FD2                                         ; umb_coalesce+28↓j
SYSINIT:3FD2                 mov     ax, es
SYSINIT:3FD4                 mov     ds, ax
SYSINIT:3FD6                 cmp     es:1, di        ; [es:ARENA.OWNER],di
SYSINIT:3FD6                                         ; Q: is current arena free
SYSINIT:3FDB                 jz      short uc_again  ; Y: try to coalesce with next block
SYSINIT:3FDB                                         ; N: get next arena
SYSINIT:3FDD                 call    get_next        ; es, ax = next arena
SYSINIT:3FE0                 jb      short uc_done
SYSINIT:3FE2                 jmp     short uc_nextfree
SYSINIT:3FE4 ; ---------------------------------------------------------------------------
SYSINIT:3FE4
SYSINIT:3FE4 uc_again:                               ; CODE XREF: umb_coalesce+15↑j
SYSINIT:3FE4                                         ; umb_coalesce+39↓j
SYSINIT:3FE4                 call    get_next        ; es, ax = next arena
SYSINIT:3FE7                 jb      short uc_done
SYSINIT:3FE9                 cmp     es:1, di        ; [es:ARENA.OWNER],di
SYSINIT:3FE9                                         ; Q: is arena free
SYSINIT:3FEE                 jnz     short uc_nextfree ; N: get next free arena
SYSINIT:3FEE                                         ; Y: coalesce
SYSINIT:3FF0                 mov     cx, es:3        ; [es:ARENA.SIZE]
SYSINIT:3FF0                                         ; cx = next block size
SYSINIT:3FF5                 inc     cx              ; cx = cx + 1 (for header size)
SYSINIT:3FF6                 add     ds:3, cx        ; [ARENA.SIZE],cx
SYSINIT:3FF6                                         ; current size = current size + cx
SYSINIT:3FFA                 mov     cl, es:[di]     ; move up signature
SYSINIT:3FFD                 mov     [di], cl
SYSINIT:3FFF                 jmp     short uc_again  ; try again
SYSINIT:4001 ; ---------------------------------------------------------------------------
SYSINIT:4001
SYSINIT:4001 uc_done:                                ; CODE XREF: umb_coalesce+1A↑j
SYSINIT:4001                                         ; umb_coalesce+21↑j
SYSINIT:4001                 retn
SYSINIT:4001 umb_coalesce    endp
SYSINIT:4001
SYSINIT:4002
SYSINIT:4002 ; =============== S U B R O U T I N E =======================================
SYSINIT:4002
SYSINIT:4002
SYSINIT:4002 get_next        proc near               ; CODE XREF: umb_insert+1C↑p
SYSINIT:4002                                         ; umb_coalesce+17↑p ...
SYSINIT:4002                 cmp     byte ptr ds:0, 5Ah ; 'Z' ; Find Next item in Arena
SYSINIT:4002                                         ; cmp byte [ARENA.SIGNATURE],arena_signature_end
SYSINIT:4007                 jz      short gn_err
SYSINIT:4009                 mov     ax, ds          ; ax = current block
SYSINIT:400B                 add     ax, ds:3        ; add ax,[ARENA.SIZE]
SYSINIT:400B                                         ; ax = ax + current block length
SYSINIT:400F                 inc     ax              ; remember that header!
SYSINIT:4010                 mov     es, ax
SYSINIT:4012                 clc
SYSINIT:4013                 retn
SYSINIT:4014 ; ---------------------------------------------------------------------------
SYSINIT:4014
SYSINIT:4014 gn_err:                                 ; CODE XREF: get_next+5↑j
SYSINIT:4014                 stc
SYSINIT:4015                 retn
SYSINIT:4015 get_next        endp
SYSINIT:4015
SYSINIT:4016
SYSINIT:4016 ; =============== S U B R O U T I N E =======================================
SYSINIT:4016
SYSINIT:4016
SYSINIT:4016 LinkFirstUMB    proc near               ; CODE XREF: InitAllocUMB+25↑p
SYSINIT:4016                 call    umb_allocate
SYSINIT:4019                 jb      short lfu_er
SYSINIT:401B                 int     12h             ; MEMORY SIZE -
SYSINIT:401B                                         ; Return: AX = number of contiguous 1K blocks of memory
SYSINIT:401D                 mov     cl, 6
SYSINIT:401F                 shl     ax, cl          ; ax = size in paragraphs
SYSINIT:4021                 mov     cx, ax
SYSINIT:4023                 sub     ax, bx          ; bx = segment of allocated UMB
SYSINIT:4023                                         ; ax = - size of unused block
SYSINIT:4025                 neg     ax
SYSINIT:4027                 sub     cx, 1           ; cx = first umb_arena
SYSINIT:402A                 mov     es, cx          ; es = first umb_arena
SYSINIT:402C                 mov     byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
SYSINIT:4032                 mov     word ptr es:1, 8 ; [es:ARENA.OWNER],8 ; mark as system owned
SYSINIT:4039                 mov     es:3, ax        ; mov [es:ARENA.SIZE],ax
SYSINIT:403D                 mov     word ptr es:8, 4353h ; [es:ARENA.NAME],'SC'
SYSINIT:4044                 mov     es, bx          ; put in the arena for the first UMB
SYSINIT:4044                                         ; es has first free umb seg
SYSINIT:4046                 mov     byte ptr es:0, 5Ah ; 'Z' ; [es:ARENA.SIGNATURE],arena_signature_end
SYSINIT:404C                 mov     word ptr es:1, 0 ; es:ARENA.OWNER],arena_owner_system
SYSINIT:404C                                         ; mark as free
SYSINIT:4053                 dec     dx              ; dx = size of UMB
SYSINIT:4053                                         ; make room for arena
SYSINIT:4054                 mov     es:3, dx        ; [es:ARENA.SIZE],dx
SYSINIT:4059                 mov     es, cs:DevDOSData
SYSINIT:405E                 mov     di, 8Ch         ; UMB_ARENA
SYSINIT:4061                 mov     es:[di], cx     ; initialize umb_head in DOS data segment
SYSINIT:4061                                         ; with the arena just below Top of Memory
SYSINIT:4061                                         ;
SYSINIT:4061                                         ; we must now scan the arena chain and
SYSINIT:4061                                         ; update the size of the last arena
SYSINIT:4064                 mov     di, 24h         ; DOS_ARENA
SYSINIT:4067                 mov     es, word ptr es:[di] ; es = start arena
SYSINIT:406A                 xor     di, di
SYSINIT:406C
SYSINIT:406C scannext:                               ; CODE XREF: LinkFirstUMB+66↓j
SYSINIT:406C                 cmp     byte ptr es:[di], 5Ah ; 'Z' ; arena_signature_end
SYSINIT:4070                 jz      short got_last
SYSINIT:4072                 mov     ax, es
SYSINIT:4074                 add     ax, es:3        ; [es:ARENA.SIZE]
SYSINIT:4079                 inc     ax
SYSINIT:407A                 mov     es, ax
SYSINIT:407C                 jmp     short scannext
SYSINIT:407E ; ---------------------------------------------------------------------------
SYSINIT:407E
SYSINIT:407E got_last:                               ; CODE XREF: LinkFirstUMB+5A↑j
SYSINIT:407E                 sub     word ptr es:3, 1 ; sub word [es:ARENA.SIZE],1
SYSINIT:4084                 mov     byte ptr es:0, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],arena_signature_normal
SYSINIT:408A                 clc
SYSINIT:408B                 retn
SYSINIT:408C ; ---------------------------------------------------------------------------
SYSINIT:408C
SYSINIT:408C lfu_er:                                 ; CODE XREF: LinkFirstUMB+3↑j
SYSINIT:408C                 stc
SYSINIT:408D                 retn
SYSINIT:408D LinkFirstUMB    endp
SYSINIT:408D
SYSINIT:408E
SYSINIT:408E ; =============== S U B R O U T I N E =======================================
SYSINIT:408E
SYSINIT:408E
SYSINIT:408E ShrinkUMB       proc near               ; CODE XREF: SYSINIT:086D↑p
SYSINIT:408E                                         ; InitDevLoad+10↑p ...
SYSINIT:408E                 cmp     cs:DevUMBAddr, 0 ; Shrinks the current UMB in use,
SYSINIT:408E                                         ; so that the unused portions of the UMB
SYSINIT:408E                                         ; is given back to the DOS free mem pool
SYSINIT:4094                 jz      short su_exit
SYSINIT:4096                 push    es
SYSINIT:4097                 push    bx
SYSINIT:4098                 mov     bx, cs:DevUMBFree
SYSINIT:409D                 sub     bx, cs:DevUMBAddr
SYSINIT:40A2                 mov     es, cs:DevUMBAddr
SYSINIT:40A7                 mov     ax, 4A00h
SYSINIT:40AA                 int     21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
SYSINIT:40AA                                         ; ES = segment address of block to change
SYSINIT:40AA                                         ; BX = new size in paragraphs
SYSINIT:40AC                 mov     ax, es
SYSINIT:40AE                 dec     ax
SYSINIT:40AF                 mov     es, ax
SYSINIT:40B1                 assume es:nothing
SYSINIT:40B1                 mov     word ptr es:1, 8 ; [es:ARENA.OWNER]
SYSINIT:40B8                 pop     bx
SYSINIT:40B9                 pop     es
SYSINIT:40BA                 assume es:nothing
SYSINIT:40BA
SYSINIT:40BA su_exit:                                ; CODE XREF: ShrinkUMB+6↑j
SYSINIT:40BA                 retn
SYSINIT:40BA ShrinkUMB       endp
SYSINIT:40BA
SYSINIT:40BB
SYSINIT:40BB ; =============== S U B R O U T I N E =======================================
SYSINIT:40BB
SYSINIT:40BB
SYSINIT:40BB UnlinkUMB       proc near               ; CODE XREF: SYSINIT:0870↑p
SYSINIT:40BB                 push    ds              ; Unlinks the UMBs from the DOS arena chain
SYSINIT:40BC                 push    es
SYSINIT:40BD                 cmp     cs:FirstUMBLinked, 0
SYSINIT:40C3                 jz      short ulu_x     ; nothing to unlink
SYSINIT:40C5                 mov     es, cs:DevDOSData ; get DOS data seg
SYSINIT:40CA                 mov     ds, word ptr es:24h ; [es:DOS_ARENA]
SYSINIT:40CF                 mov     di, es:8Ch      ; [es:UMB_ARENA]
SYSINIT:40D4
SYSINIT:40D4 ulu_next:                               ; CODE XREF: UnlinkUMB+24↓j
SYSINIT:40D4                 call    get_next
SYSINIT:40D7                 jb      short ulu_x
SYSINIT:40D9                 cmp     di, ax          ; is the next one UMB ?
SYSINIT:40DB                 jz      short ulu_found
SYSINIT:40DD                 mov     ds, ax
SYSINIT:40DF                 jmp     short ulu_next
SYSINIT:40E1 ; ---------------------------------------------------------------------------
SYSINIT:40E1
SYSINIT:40E1 ulu_found:                              ; CODE XREF: UnlinkUMB+20↑j
SYSINIT:40E1                 mov     byte ptr ds:0, 5Ah ; 'Z' ; [ARENA.SIGNATURE],arena_signature_end
SYSINIT:40E6
SYSINIT:40E6 ulu_x:                                  ; CODE XREF: UnlinkUMB+8↑j
SYSINIT:40E6                                         ; UnlinkUMB+1C↑j
SYSINIT:40E6                 pop     es
SYSINIT:40E7                 pop     ds
SYSINIT:40E8                 retn
SYSINIT:40E8 UnlinkUMB       endp
SYSINIT:40E8
SYSINIT:40E8 ; ---------------------------------------------------------------------------
SYSINIT:40E9                 db 2 dup(0)
SYSINIT:40EB
SYSINIT:40EB ; =============== S U B R O U T I N E =======================================
SYSINIT:40EB
SYSINIT:40EB
SYSINIT:40EB setparms        proc near               ; CODE XREF: doconf+85C↑p
SYSINIT:40EB                 push    ds
SYSINIT:40EC                 push    ax
SYSINIT:40ED                 push    bx
SYSINIT:40EE                 push    cx
SYSINIT:40EF                 push    dx
SYSINIT:40F0                 push    cs
SYSINIT:40F1                 pop     ds
SYSINIT:40F2                 assume ds:SYSINIT
SYSINIT:40F2                 xor     bx, bx
SYSINIT:40F4                 mov     bl, drive
SYSINIT:40F8                 inc     bl              ; get it correct for ioctl call
SYSINIT:40F8                                         ; (1=A,2=A...)
SYSINIT:40FA                 mov     dx, offset devp_specialfunc ; offset deviceparameters
SYSINIT:40FD                 mov     ah, 44h         ; IOCTL
SYSINIT:40FF                 mov     al, 0Dh         ; GENERIC_IOCTL
SYSINIT:4101                 mov     ch, 8           ; RAWIO
SYSINIT:4103                 mov     cl, 40h         ; SET_DEVICE_PARAMETERS
SYSINIT:4105                 int     21h             ; DOS - 2+ - IOCTL -
SYSINIT:4107                 mov     ax, 70h         ; DOSBIODATASEG ; BIOSDATA segment
SYSINIT:410A                 mov     ds, ax
SYSINIT:410C                 assume ds:nothing
SYSINIT:410C                 test    cs:switches, 4  ; flagec35
SYSINIT:4113                 jz      short not_ec35
SYSINIT:4115                 mov     cl, cs:drive    ; which drive was this for?
SYSINIT:411A                 mov     al, 1           ; assume drive 0
SYSINIT:411C                 shl     al, cl          ; set proper bit depending on drive
SYSINIT:411E                 or      ds:ec35_flag, al ; set the bit in the permanent flags
SYSINIT:4122
SYSINIT:4122 not_ec35:                               ; CODE XREF: setparms+28↑j
SYSINIT:4122                 mov     al, byte ptr cs:devp_spt ; mov al,[cs:deviceparameters+20]
SYSINIT:4122                                         ; [cs:deviceparameters+A_DEVICEPARAMETERS.DP_BPB
SYSINIT:4122                                         ; +A_BPB.BPB_SECTORSPERTRACK]
SYSINIT:4126                 cmp     al, ds:eot
SYSINIT:412A                 jbe     short eot_ok
SYSINIT:412C                 mov     ds:eot, al
SYSINIT:412F
SYSINIT:412F eot_ok:                                 ; CODE XREF: setparms+3F↑j
SYSINIT:412F                 pop     dx
SYSINIT:4130                 pop     cx
SYSINIT:4131                 pop     bx
SYSINIT:4132                 pop     ax
SYSINIT:4133                 pop     ds
SYSINIT:4134                 assume ds:nothing
SYSINIT:4134                 retn
SYSINIT:4134 setparms        endp
SYSINIT:4134
SYSINIT:4135
SYSINIT:4135 ; =============== S U B R O U T I N E =======================================
SYSINIT:4135
SYSINIT:4135
SYSINIT:4135 diddleback      proc near               ; CODE XREF: doconf+85F↑p
SYSINIT:4135                 push    ds              ; replace default values for further drivparm commands
SYSINIT:4136                 push    cs
SYSINIT:4137                 pop     ds
SYSINIT:4138                 assume ds:SYSINIT
SYSINIT:4138                 mov     devp_cylinders, 80 ; [deviceparameters+4],80
SYSINIT:4138                                         ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],80
SYSINIT:413E                 mov     devp_devtype, 2 ; [deviceparameters+1],2
SYSINIT:413E                                         ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_3INCH720KB
SYSINIT:4143                 mov     devp_devattr, 0 ; [deviceparameters+2],0
SYSINIT:4143                                         ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],0
SYSINIT:4149                 mov     switches, 0     ; zero all switches
SYSINIT:414F                 pop     ds
SYSINIT:4150                 assume ds:nothing
SYSINIT:4150                 retn
SYSINIT:4150 diddleback      endp
SYSINIT:4150
SYSINIT:4151
SYSINIT:4151 ; =============== S U B R O U T I N E =======================================
SYSINIT:4151
SYSINIT:4151
SYSINIT:4151 parseline       proc near               ; CODE XREF: doconf+857↑p
SYSINIT:4151                 push    ds
SYSINIT:4152                 push    cs
SYSINIT:4153                 pop     ds
SYSINIT:4154                 assume ds:SYSINIT
SYSINIT:4154
SYSINIT:4154 nextswtch:                              ; CODE XREF: parseline+24↓j
SYSINIT:4154                 cmp     al, 0Dh         ; al contains the first character in command line.
SYSINIT:4156                 jz      short done_line ; cr
SYSINIT:4158                 cmp     al, 0Ah
SYSINIT:415A                 jz      short put_back  ; lf ; put it back and done
SYSINIT:415C                 cmp     al, 20h ; ' '
SYSINIT:415E                 jbe     short getnext   ; skip over space
SYSINIT:4160                 cmp     al, 2Fh ; '/'
SYSINIT:4162                 jz      short getparm
SYSINIT:4164                 stc                     ; mark error invalid-character-in-input
SYSINIT:4165                 jmp     short exitpl
SYSINIT:4167 ; ---------------------------------------------------------------------------
SYSINIT:4167
SYSINIT:4167 getparm:                                ; CODE XREF: parseline+11↑j
SYSINIT:4167                 call    check_switch
SYSINIT:416A                 mov     switches, bx    ; save switches read so far
SYSINIT:416E                 jb      short swterr
SYSINIT:4170
SYSINIT:4170 getnext:                                ; CODE XREF: parseline+D↑j
SYSINIT:4170                 call    getchr
SYSINIT:4173                 jb      short done_line
SYSINIT:4175                 jmp     short nextswtch
SYSINIT:4177 ; ---------------------------------------------------------------------------
SYSINIT:4177
SYSINIT:4177 swterr:                                 ; CODE XREF: parseline+1D↑j
SYSINIT:4177                 jmp     short exitpl    ; exit if error
SYSINIT:4179 ; ---------------------------------------------------------------------------
SYSINIT:4179
SYSINIT:4179 done_line:                              ; CODE XREF: parseline+5↑j
SYSINIT:4179                                         ; parseline+22↑j ...
SYSINIT:4179                 test    switches, 8     ; flagdrive ; see if drive specified
SYSINIT:417F                 jnz     short okay
SYSINIT:4181                 stc                     ; mark error no-drive-specified
SYSINIT:4182                 jmp     short exitpl
SYSINIT:4184 ; ---------------------------------------------------------------------------
SYSINIT:4184
SYSINIT:4184 okay:                                   ; CODE XREF: parseline+2E↑j
SYSINIT:4184                 mov     ax, switches
SYSINIT:4187                 and     ax, 3           ; get flag bits for changeline and non-rem
SYSINIT:418A                 mov     devp_devattr, ax ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
SYSINIT:418D                 mov     devp_trktblents, 0 ; [deviceparameters+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]
SYSINIT:4193                 clc                     ; everything is fine
SYSINIT:4194                 call    setdeviceparameters
SYSINIT:4197
SYSINIT:4197 exitpl:                                 ; CODE XREF: parseline+14↑j
SYSINIT:4197                                         ; parseline:swterr↑j ...
SYSINIT:4197                 pop     ds
SYSINIT:4198                 assume ds:nothing
SYSINIT:4198                 retn
SYSINIT:4199 ; ---------------------------------------------------------------------------
SYSINIT:4199
SYSINIT:4199 put_back:                               ; CODE XREF: parseline+9↑j
SYSINIT:4199                 inc     ds:count        ; one more char to scan
SYSINIT:419D                 dec     ds:chrptr       ; back up over linefeed
SYSINIT:41A1                 jmp     short done_line
SYSINIT:41A1 parseline       endp
SYSINIT:41A1
SYSINIT:41A3
SYSINIT:41A3 ; =============== S U B R O U T I N E =======================================
SYSINIT:41A3
SYSINIT:41A3
SYSINIT:41A3 check_switch    proc near               ; CODE XREF: parseline:getparm↑p
SYSINIT:41A3                 call    getchr
SYSINIT:41A6                 jb      short err_chk
SYSINIT:41A8                 and     al, 0DFh        ; convert it to upper case
SYSINIT:41AA                 cmp     al, 41h ; 'A'
SYSINIT:41AC                 jb      short err_chk
SYSINIT:41AE                 cmp     al, 5Ah ; 'Z'
SYSINIT:41B0                 ja      short err_chk
SYSINIT:41B2                 push    es
SYSINIT:41B3                 push    cs
SYSINIT:41B4                 pop     es
SYSINIT:41B5                 assume es:SYSINIT
SYSINIT:41B5                 mov     cl, byte ptr ds:switchlist ; get number of valid switches
SYSINIT:41B9                 mov     ch, 0           ; point to string of valid switches
SYSINIT:41BB                 mov     di, (offset switchlist+1) ; "FHSTDICN"
SYSINIT:41BE                 repne scasb
SYSINIT:41C0                 pop     es
SYSINIT:41C1                 assume es:nothing
SYSINIT:41C1                 jnz     short err_chk
SYSINIT:41C3                 mov     ax, 1
SYSINIT:41C6                 shl     ax, cl          ; set bit to indicate switch
SYSINIT:41C8                 mov     bx, ds:switches ; get switches so far
SYSINIT:41CC                 or      bx, ax          ; save this with other switches
SYSINIT:41CE                 mov     cx, ax
SYSINIT:41D0                 test    ax, 0F8h        ; switchnum ; 0F8h
SYSINIT:41D0                                         ; test against switches that require number to follow
SYSINIT:41D3                 jz      short done_swtch
SYSINIT:41D5                 call    getchr
SYSINIT:41D8                 jb      short err_swtch
SYSINIT:41DA                 cmp     al, ':'
SYSINIT:41DC                 jnz     short err_swtch
SYSINIT:41DE                 call    getchr
SYSINIT:41E1                 push    bx              ; preserve switches
SYSINIT:41E2                 mov     cs:sepchr, 20h ; ' ' ; allow space separators
SYSINIT:41E8                 call    getnum
SYSINIT:41EB                 mov     cs:sepchr, 0
SYSINIT:41F1                 pop     bx              ; restore switches
SYSINIT:41F2                 call    process_num
SYSINIT:41F5
SYSINIT:41F5 done_swtch:                             ; CODE XREF: check_switch+30↑j
SYSINIT:41F5                 clc
SYSINIT:41F6                 retn
SYSINIT:41F7 ; ---------------------------------------------------------------------------
SYSINIT:41F7
SYSINIT:41F7 err_swtch:                              ; CODE XREF: check_switch+35↑j
SYSINIT:41F7                                         ; check_switch+39↑j
SYSINIT:41F7                 xor     bx, cx          ; remove this switch from the records
SYSINIT:41F9
SYSINIT:41F9 err_chk:                                ; CODE XREF: check_switch+3↑j
SYSINIT:41F9                                         ; check_switch+9↑j ...
SYSINIT:41F9                 stc
SYSINIT:41FA                 retn
SYSINIT:41FA check_switch    endp
SYSINIT:41FA
SYSINIT:41FB
SYSINIT:41FB ; =============== S U B R O U T I N E =======================================
SYSINIT:41FB
SYSINIT:41FB
SYSINIT:41FB process_num     proc near               ; CODE XREF: check_switch+4F↑p
SYSINIT:41FB                 test    ds:switches, cx ; if this switch has been done before,
SYSINIT:41FF                 jnz     short done_ret  ; ignore this one.
SYSINIT:4201                 test    cx, 8           ; flagdrive
SYSINIT:4205                 jz      short try_f
SYSINIT:4207                 mov     ds:drive, al
SYSINIT:420A                 jmp     short done_ret
SYSINIT:420C ; ---------------------------------------------------------------------------
SYSINIT:420C
SYSINIT:420C try_f:                                  ; CODE XREF: process_num+A↑j
SYSINIT:420C                 test    cx, 80h         ; flagff
SYSINIT:4210                 jz      short try_t
SYSINIT:4212                 mov     ds:devp_devtype, al
SYSINIT:4215                 jmp     short done_ret
SYSINIT:4217 ; ---------------------------------------------------------------------------
SYSINIT:4217
SYSINIT:4217 try_t:                                  ; CODE XREF: process_num+15↑j
SYSINIT:4217                 or      ax, ax          ; if number entered was 0, assume default value
SYSINIT:4219                 jz      short done_ret
SYSINIT:421B                 test    cx, 10h         ; flagcyln
SYSINIT:421F                 jz      short try_s
SYSINIT:4221                 mov     ds:devp_cylinders, ax ; [deviceparameters+4],ax
SYSINIT:4221                                         ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
SYSINIT:4224                 jmp     short done_ret
SYSINIT:4226 ; ---------------------------------------------------------------------------
SYSINIT:4226
SYSINIT:4226 try_s:                                  ; CODE XREF: process_num+24↑j
SYSINIT:4226                 test    cx, 20h         ; flagseclim
SYSINIT:422A                 jz      short try_h     ; must be for number of heads
SYSINIT:422C                 mov     ds:slim, ax
SYSINIT:422F                 jmp     short done_ret
SYSINIT:4231 ; ---------------------------------------------------------------------------
SYSINIT:4231
SYSINIT:4231 try_h:                                  ; CODE XREF: process_num+2F↑j
SYSINIT:4231                 mov     ds:hlim, ax
SYSINIT:4234
SYSINIT:4234 done_ret:                               ; CODE XREF: process_num+4↑j
SYSINIT:4234                                         ; process_num+F↑j ...
SYSINIT:4234                 clc                     ; (test instruction resets cf)
SYSINIT:4235                 retn
SYSINIT:4235 process_num     endp
SYSINIT:4235
SYSINIT:4236
SYSINIT:4236 ; =============== S U B R O U T I N E =======================================
SYSINIT:4236
SYSINIT:4236
SYSINIT:4236 setdeviceparameters proc near           ; CODE XREF: parseline+43↑p
SYSINIT:4236                 push    es
SYSINIT:4237                 push    cs
SYSINIT:4238                 pop     es
SYSINIT:4239                 assume es:SYSINIT
SYSINIT:4239                 xor     bx, bx
SYSINIT:423B                 mov     bl, ds:devp_devtype ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE]
SYSINIT:423F                 cmp     bl, 0           ; DEV_5INCH
SYSINIT:4242                 jnz     short got_80
SYSINIT:4244                 mov     ds:devp_cylinders, 40 ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
SYSINIT:4244                                         ; 48 tpi = 40 cyl
SYSINIT:424A
SYSINIT:424A got_80:                                 ; CODE XREF: setdeviceparameters+C↑j
SYSINIT:424A                 shl     bx, 1           ; get index into bpb table
SYSINIT:424C                 mov     si, ds:_bpbtable[bx] ; get address of bpb
SYSINIT:4250                 mov     di, offset devp_bps ; deviceparameters+7
SYSINIT:4250                                         ; deviceparameters+A_DEVICEPARAMETERS.DP_BPB
SYSINIT:4250                                         ; es:di -> bpb
SYSINIT:4253                 mov     cx, 59          ; A_BPB.size
SYSINIT:4256                 cld
SYSINIT:4257                 rep movsb
SYSINIT:4259                 pop     es
SYSINIT:425A                 assume es:nothing
SYSINIT:425A                 test    ds:switches, 20h ; flagseclim
SYSINIT:4260                 jz      short see_heads
SYSINIT:4262                 mov     ax, ds:slim
SYSINIT:4265                 mov     ds:devp_spt, ax ; [deviceparameters+20]
SYSINIT:4265                                         ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
SYSINIT:4265                                         ;  +A_BPB.BPB_SECTORSPERTRACK]
SYSINIT:4268
SYSINIT:4268 see_heads:                              ; CODE XREF: setdeviceparameters+2A↑j
SYSINIT:4268                 test    ds:switches, 40h ; flagheads
SYSINIT:426E                 jz      short heads_not_altered
SYSINIT:4270                 mov     ax, ds:hlim
SYSINIT:4273                 mov     ds:devp_heads, ax ; [deviceparameters+22]
SYSINIT:4273                                         ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]
SYSINIT:4276
SYSINIT:4276 heads_not_altered:                      ; CODE XREF: setdeviceparameters+38↑j
SYSINIT:4276                 mov     ds:devp_secperclus, 2 ; [deviceparameters+9],2
SYSINIT:4276                                         ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
SYSINIT:4276                                         ;  +A_BPB.BPB_SECTORSPERCLUSTER]
SYSINIT:427B                 mov     bl, 0F0h        ; get default mediabyte
SYSINIT:427D                 mov     bh, ds:devp_mediaid ; [deviceparameters+17]
SYSINIT:427D                                         ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR]
SYSINIT:4281                 cmp     ds:devp_heads, 2
SYSINIT:4286                 ja      short got_correct_mediaid ; just use default if heads>2
SYSINIT:4288                 jnz     short only_one_head ; one head, do one head stuff
SYSINIT:428A                 mov     bl, bh
SYSINIT:428C                 cmp     ds:devp_spt, 18 ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
SYSINIT:428C                                         ;  +A_BPB.BPB_SECTORSPERTRACK]
SYSINIT:4291                 jnz     short not_144m
SYSINIT:4293                 cmp     ds:devp_cylinders, 80 ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
SYSINIT:4298                 jnz     short not_144m
SYSINIT:429A                 jmp     short got_one_secperclus_drive ; cyl=80, heads=2, secpertrack=18.
SYSINIT:429A                                         ;  Set cluster size to 1.
SYSINIT:429C ; ---------------------------------------------------------------------------
SYSINIT:429C
SYSINIT:429C not_144m:                               ; CODE XREF: setdeviceparameters+5B↑j
SYSINIT:429C                                         ; setdeviceparameters+62↑j
SYSINIT:429C                 cmp     ds:devp_cylinders, 40 ; check for 320K
SYSINIT:42A1                 jnz     short got_correct_mediaid
SYSINIT:42A3                 cmp     ds:devp_spt, 8
SYSINIT:42A8                 jnz     short got_correct_mediaid
SYSINIT:42AA                 mov     bl, 0FCh
SYSINIT:42AC                 jmp     short got_correct_mediaid
SYSINIT:42AE ; ---------------------------------------------------------------------------
SYSINIT:42AE
SYSINIT:42AE only_one_head:                          ; CODE XREF: setdeviceparameters+52↑j
SYSINIT:42AE                 cmp     ds:devp_devtype, 0 ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_5INCH
SYSINIT:42B3                 jnz     short got_one_secperclus_drive
SYSINIT:42B5                 mov     bl, 0FCh        ; single sided 9 sector media id
SYSINIT:42B7                 cmp     ds:devp_spt, 8  ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
SYSINIT:42B7                                         ; +A_BPB.BPB_SECTORSPERTRACK],8
SYSINIT:42BC                 jnz     short got_one_secperclus_drive ; okay if anything besides 8
SYSINIT:42BE                 mov     bl, 0FEh        ; 160K mediaid
SYSINIT:42C0
SYSINIT:42C0 got_one_secperclus_drive:               ; CODE XREF: setdeviceparameters+64↑j
SYSINIT:42C0                                         ; setdeviceparameters+7D↑j ...
SYSINIT:42C0                 mov     ds:devp_secperclus, 1 ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
SYSINIT:42C0                                         ;  +A_BPB.BPB_SECTORSPERCLUSTER],1
SYSINIT:42C5
SYSINIT:42C5 got_correct_mediaid:                    ; CODE XREF: setdeviceparameters+50↑j
SYSINIT:42C5                                         ; setdeviceparameters+6B↑j ...
SYSINIT:42C5                 mov     ds:devp_mediaid, bl ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB
SYSINIT:42C5                                         ;  +A_BPB.BPB_MEDIADESCRIPTOR],bl
SYSINIT:42C9                 mov     ax, ds:devp_cylinders ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
SYSINIT:42CC                 mul     ds:devp_heads   ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]
SYSINIT:42D0                 mul     ds:devp_spt     ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
SYSINIT:42D4                 mov     ds:devp_totalsecs, ax ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
SYSINIT:42D7                 clc
SYSINIT:42D8                 retn
SYSINIT:42D8 setdeviceparameters endp
SYSINIT:42D8
SYSINIT:42D9
SYSINIT:42D9 ; =============== S U B R O U T I N E =======================================
SYSINIT:42D9
SYSINIT:42D9
SYSINIT:42D9 organize        proc near               ; CODE XREF: doconf:getcom↑p
SYSINIT:42D9                 mov     cx, cs:count
SYSINIT:42DE                 jcxz    short nochar1
SYSINIT:42E0                 xor     si, si
SYSINIT:42E2                 mov     di, si
SYSINIT:42E4                 xor     ax, ax
SYSINIT:42E6                 mov     cs:com_level, 0
SYSINIT:42EC
SYSINIT:42EC org1:                                   ; CODE XREF: organize+21↓j
SYSINIT:42EC                                         ; organize+2C↓j ...
SYSINIT:42EC                 call    skip_comment
SYSINIT:42EF                 jz      short end_commd_line ; found a comment string and skipped.
SYSINIT:42F1                 call    get2            ; not a comment string. then get a char.
SYSINIT:42F4                 cmp     al, 0Ah         ; lf
SYSINIT:42F6                 jz      short end_commd_line ; starts with a blank line.
SYSINIT:42F8                 cmp     al, 20h ; ' '
SYSINIT:42FA                 jbe     short org1      ; skip leading control characters
SYSINIT:42FC                 jmp     short findit
SYSINIT:42FE ; ---------------------------------------------------------------------------
SYSINIT:42FE
SYSINIT:42FE end_commd_line:                         ; CODE XREF: organize+16↑j
SYSINIT:42FE                                         ; organize+1D↑j ...
SYSINIT:42FE                 stosb                   ; store line feed char in buffer for the linecount.
SYSINIT:42FF                 mov     cs:com_level, 0 ; reset the command level.
SYSINIT:4305                 jmp     short org1
SYSINIT:4307 ; ---------------------------------------------------------------------------
SYSINIT:4307
SYSINIT:4307 nochar1:                                ; CODE XREF: organize+5↑j
SYSINIT:4307                 stc
SYSINIT:4308                 retn
SYSINIT:4309 ; ---------------------------------------------------------------------------
SYSINIT:4309
SYSINIT:4309 findit:                                 ; CODE XREF: organize+23↑j
SYSINIT:4309                 push    cx              ; prepare to search command table
SYSINIT:430A                 push    si
SYSINIT:430B                 push    di
SYSINIT:430C                 mov     bp, si
SYSINIT:430E                 dec     bp
SYSINIT:430F                 mov     si, offset comtab ; "\x01[["
SYSINIT:4312                 mov     ch, 0
SYSINIT:4314
SYSINIT:4314 findcom:                                ; CODE XREF: organize+59↓j
SYSINIT:4314                                         ; organize+80↓j
SYSINIT:4314                 mov     di, bp
SYSINIT:4316                 mov     cl, [si]
SYSINIT:4318                 inc     si
SYSINIT:4319                 jcxz    short nocom
SYSINIT:431B                 cmp     byte ptr es:[di], 3Bh ; ';' ; CONFIG_SEMICOLON
SYSINIT:431F                 jz      short semicolon
SYSINIT:4321
SYSINIT:4321 loopcom:                                ; CODE XREF: organize+52↓j
SYSINIT:4321                 mov     al, es:[di]
SYSINIT:4324                 inc     di
SYSINIT:4325                 and     al, 0DFh        ; ~20h ; force upper case
SYSINIT:4327                 inc     si
SYSINIT:4328                 cmp     al, [si-1]      ; compare to byte @es:di
SYSINIT:432B                 loope   loopcom
SYSINIT:432D                 lahf
SYSINIT:432E                 add     si, cx          ; bump to next position without affecting flags
SYSINIT:4330                 sahf
SYSINIT:4331                 lodsb
SYSINIT:4332                 jnz     short findcom
SYSINIT:4334                 cmp     byte ptr es:[di], 0Dh ; the next char might be cr,lf
SYSINIT:4338                 jz      short gotcom0
SYSINIT:433A                 cmp     byte ptr es:[di], 0Ah ; such as in "rem",cr,lf case.
SYSINIT:433E                 jz      short gotcom0
SYSINIT:4340                 cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
SYSINIT:4342                 jz      short gotcom0
SYSINIT:4344                 push    ax
SYSINIT:4345                 mov     al, es:[di]     ; now the next char. should be a delim.
SYSINIT:4348                 cmp     al, 3Fh ; '?'   ; explicit interactive command?
SYSINIT:434A                 jnz     short no_query  ; no
SYSINIT:434C                 pop     ax              ; yes, so retrieve the original code
SYSINIT:434D                 or      al, 80h         ; CONFIG_OPTION_QUERY ; and set the QUERY bit
SYSINIT:434F                 jmp     short gotcom0
SYSINIT:4351 ; ---------------------------------------------------------------------------
SYSINIT:4351
SYSINIT:4351 semicolon:                              ; CODE XREF: organize+46↑j
SYSINIT:4351                 mov     al, 30h ; '0'   ; CONFIG_REM
SYSINIT:4353                 jmp     short gotcom0
SYSINIT:4355 ; ---------------------------------------------------------------------------
SYSINIT:4355
SYSINIT:4355 no_query:                               ; CODE XREF: organize+71↑j
SYSINIT:4355                 call    delim
SYSINIT:4358                 pop     ax
SYSINIT:4359                 jnz     short findcom
SYSINIT:435B
SYSINIT:435B gotcom0:                                ; CODE XREF: organize+5F↑j
SYSINIT:435B                                         ; organize+65↑j ...
SYSINIT:435B                 pop     di
SYSINIT:435C                 pop     si
SYSINIT:435D                 pop     cx
SYSINIT:435E                 jmp     short gotcom
SYSINIT:4360 ; ---------------------------------------------------------------------------
SYSINIT:4360
SYSINIT:4360 nocom:                                  ; CODE XREF: organize+40↑j
SYSINIT:4360                 pop     di
SYSINIT:4361                 pop     si
SYSINIT:4362                 pop     cx
SYSINIT:4363                 mov     al, 5Ah ; 'Z'   ; CONFIG_UNKNOWN
SYSINIT:4365                 stosb                   ; save indicator char.
SYSINIT:4366
SYSINIT:4366 _skipline:                              ; CODE XREF: organize+92↓j
SYSINIT:4366                 call    get2
SYSINIT:4369                 cmp     al, 0Ah         ; lf ; skip this bad command line
SYSINIT:436B                 jnz     short _skipline
SYSINIT:436D                 jmp     short end_commd_line
SYSINIT:436F ; ---------------------------------------------------------------------------
SYSINIT:436F
SYSINIT:436F gotcom:                                 ; CODE XREF: organize+85↑j
SYSINIT:436F                 stosb                   ; save indicator char in buffer
SYSINIT:4370                 and     al, 7Fh         ; ~CONFIG_OPTION_QUERY
SYSINIT:4372                 mov     cs:cmd_indicator, al ; save it for the future use.
SYSINIT:4376                 cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
SYSINIT:4378                 jz      short org31
SYSINIT:437A                 cmp     al, 4Fh ; 'O'   ; CONFIG_SUBMENU
SYSINIT:437C                 jz      short org2
SYSINIT:437E                 cmp     al, 45h ; 'E'   ; CONFIG_MENUITEM
SYSINIT:4380                 jz      short org2
SYSINIT:4382                 cmp     al, 41h ; 'A'   ; CONFIG_MENUDEFAULT
SYSINIT:4384                 jz      short org2
SYSINIT:4386                 cmp     al, 4Ah ; 'J'   ; CONFIG_INCLUDE
SYSINIT:4388                 jz      short org2
SYSINIT:438A                 call    mapcase         ; map case of rest of line to UPPER
SYSINIT:438D
SYSINIT:438D org2:                                   ; CODE XREF: organize+A3↑j
SYSINIT:438D                                         ; organize+A7↑j ...
SYSINIT:438D                 call    get2            ; skip the command name until delimiter
SYSINIT:4390                 cmp     al, 0Ah         ; lf
SYSINIT:4392                 jz      short org21
SYSINIT:4394                 cmp     al, 0Dh         ; cr
SYSINIT:4396                 jz      short org21
SYSINIT:4398                 cmp     al, 2Fh ; '/'   ; Added to allow DEVHIGH/L:...
SYSINIT:439A                 jz      short org21     ; to be parsed properly
SYSINIT:439C                 call    delim
SYSINIT:439F                 jnz     short org2
SYSINIT:43A1                 jmp     short org3
SYSINIT:43A3 ; ---------------------------------------------------------------------------
SYSINIT:43A3
SYSINIT:43A3 org21:                                  ; CODE XREF: organize+B9↑j
SYSINIT:43A3                                         ; organize+BD↑j ...
SYSINIT:43A3                 dec     si              ; if cr or lf then
SYSINIT:43A4                 inc     cx              ; undo si, cx register and continue
SYSINIT:43A5
SYSINIT:43A5 org3:                                   ; CODE XREF: organize+C8↑j
SYSINIT:43A5                 cmp     cs:cmd_indicator, 59h ; 'Y' ; CONFIG_COMMENT
SYSINIT:43AB                 jz      short get_cmt_token
SYSINIT:43AD                 cmp     cs:cmd_indicator, 44h ; 'D' ; CONFIG_DEVICE
SYSINIT:43B3                 jz      short org_file
SYSINIT:43B5                 cmp     cs:cmd_indicator, 49h ; 'I' ; CONFIG_INSTALL
SYSINIT:43BB                 jz      short org_file
SYSINIT:43BD                 cmp     cs:cmd_indicator, 57h ; 'W' ; CONFIG_INSTALLHIGH
SYSINIT:43C3                 jz      short org_file
SYSINIT:43C5                 cmp     cs:cmd_indicator, 53h ; 'S' ; CONFIG_SHELL
SYSINIT:43CB                 jz      short org_file
SYSINIT:43CD                 cmp     cs:cmd_indicator, 31h ; '1' ; CONFIG_SWITCHES
SYSINIT:43D3                 jz      short org_switch
SYSINIT:43D5
SYSINIT:43D5 org31:                                  ; CODE XREF: organize+9F↑j
SYSINIT:43D5                 jmp     org4
SYSINIT:43D8 ; ---------------------------------------------------------------------------
SYSINIT:43D8
SYSINIT:43D8 org_switch:                             ; CODE XREF: organize+FA↑j
SYSINIT:43D8                                         ; organize+10A↓j
SYSINIT:43D8                 call    skip_comment
SYSINIT:43DB                 jz      short end_commd_line_brdg
SYSINIT:43DD                 call    get2
SYSINIT:43E0                 call    org_delim
SYSINIT:43E3                 jz      short org_switch
SYSINIT:43E5                 stosb
SYSINIT:43E6                 jmp     org5
SYSINIT:43E9 ; ---------------------------------------------------------------------------
SYSINIT:43E9
SYSINIT:43E9 org_file:                               ; CODE XREF: organize+DA↑j
SYSINIT:43E9                                         ; organize+E2↑j ...
SYSINIT:43E9                 call    skip_comment    ; get the filename and put 0 at end
SYSINIT:43EC                 jz      short org_put_zero
SYSINIT:43EE                 call    get2            ; not a comment
SYSINIT:43F1                 call    delim
SYSINIT:43F4                 jz      short org_file  ; skip the possible delimiters
SYSINIT:43F6                 stosb                   ; copy the first non delim char found in buffer
SYSINIT:43F7
SYSINIT:43F7 org_copy_file:                          ; CODE XREF: organize+132↓j
SYSINIT:43F7                 call    skip_comment    ; comment char in the filename?
SYSINIT:43FA                 jz      short org_put_zero ; then stop copying filename at that point
SYSINIT:43FC                 call    get2
SYSINIT:43FF                 cmp     al, 2Fh ; '/'   ; a switch char? (device=filename/xxx)
SYSINIT:4401                 jz      short end_file_slash ; this will be the special case.
SYSINIT:4403                 stosb                   ; save the char. in buffer
SYSINIT:4404                 call    delim
SYSINIT:4407                 jz      short end_copy_file
SYSINIT:4409                 cmp     al, 20h ; ' '
SYSINIT:440B                 ja      short org_copy_file ; keep copying
SYSINIT:440D                 jmp     short end_copy_file ; otherwise, assume end of the filename.
SYSINIT:440F ; ---------------------------------------------------------------------------
SYSINIT:440F
SYSINIT:440F get_cmt_token:                          ; CODE XREF: organize+D2↑j
SYSINIT:440F                                         ; organize+13B↓j ...
SYSINIT:440F                 call    get2            ; get the token. just max. 2 char.
SYSINIT:4412                 cmp     al, 20h ; ' '   ; skip white spaces or "=" char.
SYSINIT:4414                 jz      short get_cmt_token ; (we are allowing the other special
SYSINIT:4416                 cmp     al, 9           ; characters can used for comment id.
SYSINIT:4418                 jz      short get_cmt_token ; character.)
SYSINIT:441A                 cmp     al, 3Dh ; '='   ; = is special in this case.
SYSINIT:441C                 jz      short get_cmt_token
SYSINIT:441E                 cmp     al, 0Dh
SYSINIT:4420                 jz      short get_cmt_end ; cannot accept the carriage return
SYSINIT:4422                 cmp     al, 0Ah
SYSINIT:4424                 jz      short get_cmt_end
SYSINIT:4426                 mov     cs:cmmt1, al    ; store it
SYSINIT:442A                 mov     cs:cmmt, 1      ; 1 char. so far.
SYSINIT:4430                 call    get2
SYSINIT:4433                 cmp     al, 20h ; ' '   ; space
SYSINIT:4435                 jz      short get_cmt_end
SYSINIT:4437                 cmp     al, 9           ; tab
SYSINIT:4439                 jz      short get_cmt_end
SYSINIT:443B                 cmp     al, 0Dh         ; cr
SYSINIT:443D                 jz      short get_cmt_end
SYSINIT:443F                 cmp     al, 0Ah         ; lf
SYSINIT:4441                 jz      short end_commd_line_brdg
SYSINIT:4443                 mov     cs:cmmt2, al
SYSINIT:4447                 inc     cs:cmmt
SYSINIT:444C
SYSINIT:444C get_cmt_end:                            ; CODE XREF: organize+147↑j
SYSINIT:444C                                         ; organize+14B↑j ...
SYSINIT:444C                 call    get2
SYSINIT:444F                 cmp     al, 0Ah         ; lf
SYSINIT:4451                 jnz     short get_cmt_end ; skip it.
SYSINIT:4453
SYSINIT:4453 end_commd_line_brdg:                    ; CODE XREF: organize+102↑j
SYSINIT:4453                                         ; organize+168↑j ...
SYSINIT:4453                 jmp     end_commd_line  ; else jmp to end_commd_line
SYSINIT:4456 ; ---------------------------------------------------------------------------
SYSINIT:4456
SYSINIT:4456 org_put_zero:                           ; CODE XREF: organize+113↑j
SYSINIT:4456                                         ; organize+121↑j
SYSINIT:4456                 mov     byte ptr es:[di], 0 ; make the filename in front of
SYSINIT:4456                                         ; the comment string to be an asciiz.
SYSINIT:445A                 inc     di
SYSINIT:445B                 jmp     end_commd_line  ; (maybe null if device=/*)
SYSINIT:445E ; ---------------------------------------------------------------------------
SYSINIT:445E
SYSINIT:445E end_file_slash:                         ; CODE XREF: organize+128↑j
SYSINIT:445E                 mov     byte ptr es:[di], 0 ; al = "/" option char.
SYSINIT:445E                                         ; make a filename an asciiz
SYSINIT:4462                 inc     di              ; and
SYSINIT:4463                 stosb                   ; store "/" after that.
SYSINIT:4464                 jmp     short org5      ; continue with the rest of the line
SYSINIT:4466 ; ---------------------------------------------------------------------------
SYSINIT:4466
SYSINIT:4466 end_copy_file:                          ; CODE XREF: organize+12E↑j
SYSINIT:4466                                         ; organize+134↑j
SYSINIT:4466                 mov     byte ptr es:[di-1], 0 ; make it an asciiz and handle the next char.
SYSINIT:446B                 cmp     al, 0Ah         ; lf
SYSINIT:446D                 jz      short end_commd_line_brdg
SYSINIT:446F                 jmp     short org5
SYSINIT:4471 ; ---------------------------------------------------------------------------
SYSINIT:4471
SYSINIT:4471 org4:                                   ; CODE XREF: organize:org31↑j
SYSINIT:4471                                         ; organize+1A3↓j
SYSINIT:4471                 call    skip_comment    ; org4 skips all delimiters
SYSINIT:4471                                         ; after the command name except for '/'
SYSINIT:4474                 jz      short end_commd_line_brdg
SYSINIT:4476                 call    get2
SYSINIT:4479                 call    org_delim       ; skip delimiters except '/'
SYSINIT:447C                 jz      short org4
SYSINIT:447E                 jmp     short org51
SYSINIT:4480 ; ---------------------------------------------------------------------------
SYSINIT:4480
SYSINIT:4480 org5:                                   ; CODE XREF: organize+10D↑j
SYSINIT:4480                                         ; organize+18B↑j ...
SYSINIT:4480                 call    skip_comment    ; rest of the line is
SYSINIT:4483                 jz      short end_commd_line_brdg ; comment.
SYSINIT:4485                 call    get2            ; not a comment.
SYSINIT:4488
SYSINIT:4488 org51:                                  ; CODE XREF: organize+1A5↑j
SYSINIT:4488                 stosb                   ; copy the character
SYSINIT:4489                 cmp     al, 22h ; '"'   ; a quote ?
SYSINIT:448B                 jz      short at_quote
SYSINIT:448D                 cmp     al, 20h ; ' '   ; cmp al,0Ah
SYSINIT:448D                                         ; jne short org5
SYSINIT:448D                                         ; jmp org1 (Erdogan Tan - 28/07/2023)
SYSINIT:448F                 ja      short org5
SYSINIT:4491                 cmp     al, 0Ah         ; cmp al,lf
SYSINIT:4493                 jz      short org1_brdg
SYSINIT:4495                 jmp     short org5
SYSINIT:4497 ; ---------------------------------------------------------------------------
SYSINIT:4497
SYSINIT:4497 org1_brdg:                              ; CODE XREF: organize+1BA↑j
SYSINIT:4497                 jmp     org1
SYSINIT:449A ; ---------------------------------------------------------------------------
SYSINIT:449A
SYSINIT:449A at_quote:                               ; CODE XREF: organize+1B2↑j
SYSINIT:449A                 cmp     cs:com_level, 0
SYSINIT:44A0                 jz      short up_level
SYSINIT:44A2                 mov     cs:com_level, 0 ; reset it
SYSINIT:44A8                 jmp     short org5
SYSINIT:44AA ; ---------------------------------------------------------------------------
SYSINIT:44AA
SYSINIT:44AA up_level:                               ; CODE XREF: organize+1C7↑j
SYSINIT:44AA                 inc     cs:com_level    ; set it
SYSINIT:44AF                 jmp     short org5
SYSINIT:44AF organize        endp
SYSINIT:44AF
SYSINIT:44B1 ; ---------------------------------------------------------------------------
SYSINIT:44B1
SYSINIT:44B1 get2:                                   ; CODE XREF: organize+18↑p
SYSINIT:44B1                                         ; organize:_skipline↑p ...
SYSINIT:44B1                 jcxz    short noget
SYSINIT:44B3                 lods    byte ptr es:[si]
SYSINIT:44B5                 dec     cx
SYSINIT:44B6                 retn
SYSINIT:44B7 ; ---------------------------------------------------------------------------
SYSINIT:44B7
SYSINIT:44B7 noget:                                  ; CODE XREF: SYSINIT:get2↑j
SYSINIT:44B7                                         ; skip_comment↓j ...
SYSINIT:44B7                 pop     cx              ; This was the rather kludgy way
SYSINIT:44B7                                         ; out of procedure "organize",
SYSINIT:44B7                                         ; but instead of returning to doconf,
SYSINIT:44B7                                         ; we now want to check config.sys BEGIN/END blocks
SYSINIT:44B7                                         ; and the new boot menu stuff
SYSINIT:44B8                 mov     cs:count, di
SYSINIT:44BD                 mov     cs:org_count, di
SYSINIT:44C2                 xor     si, si
SYSINIT:44C4                 mov     cs:chrptr, si
SYSINIT:44C9                 mov     cx, di
SYSINIT:44CB                 jmp     menu_check
SYSINIT:44CE
SYSINIT:44CE ; =============== S U B R O U T I N E =======================================
SYSINIT:44CE
SYSINIT:44CE
SYSINIT:44CE skip_comment    proc near               ; CODE XREF: organize:org1↑p
SYSINIT:44CE                                         ; organize:org_switch↑p ...
SYSINIT:44CE                 jcxz    short noget     ; get out of the organize routine.
SYSINIT:44CE                                         ; ...
SYSINIT:44CE                                         ; skip the commented string until lf,
SYSINIT:44CE                                         ; if current es:si-> a comment string.
SYSINIT:44CE                                         ; ...
SYSINIT:44D0                 cmp     cs:com_level, 0 ; only check it if parameter level is 0.
SYSINIT:44D6                 jnz     short no_commt  ; (not inside quotations)
SYSINIT:44D8                 cmp     cs:cmmt, 1
SYSINIT:44DE                 jb      short no_commt
SYSINIT:44E0                 mov     al, es:[si]
SYSINIT:44E3                 cmp     cs:cmmt1, al
SYSINIT:44E8                 jnz     short no_commt
SYSINIT:44EA                 cmp     cs:cmmt, 2
SYSINIT:44F0                 jnz     short skip_cmmt
SYSINIT:44F2                 mov     al, es:[si+1]
SYSINIT:44F6                 cmp     cs:cmmt2, al
SYSINIT:44FB                 jnz     short no_commt
SYSINIT:44FD
SYSINIT:44FD skip_cmmt:                              ; CODE XREF: skip_comment+22↑j
SYSINIT:44FD                                         ; skip_comment+38↓j
SYSINIT:44FD                 jcxz    short noget     ; get out of organize routine.
SYSINIT:44FF                 mov     al, es:[si]
SYSINIT:4502                 inc     si
SYSINIT:4503                 dec     cx
SYSINIT:4504                 cmp     al, 0Ah         ; lf ; line feed ?
SYSINIT:4506                 jnz     short skip_cmmt
SYSINIT:4508
SYSINIT:4508 no_commt:                               ; CODE XREF: skip_comment+8↑j
SYSINIT:4508                                         ; skip_comment+10↑j ...
SYSINIT:4508                 retn
SYSINIT:4508 skip_comment    endp
SYSINIT:4508
SYSINIT:4509
SYSINIT:4509 ; =============== S U B R O U T I N E =======================================
SYSINIT:4509
SYSINIT:4509
SYSINIT:4509 kbd_read        proc near               ; CODE XREF: doconf+1A↑p
SYSINIT:4509                                         ; menu_check+5E↓p
SYSINIT:4509                 test    ds:bDisableUI, 2 ; wait for keystroke
SYSINIT:450E                 jnz     short kbd_nodelay ;
SYSINIT:450E                                         ; the bios timer tick count is incremented
SYSINIT:450E                                         ; 18.2 times per second;
SYSINIT:450E                                         ; watch the timer tick count for 37 transitions
SYSINIT:450E                                         ; get initial value
SYSINIT:4510                 push    ds
SYSINIT:4511                 sub     ax, ax
SYSINIT:4513                 mov     ds, ax
SYSINIT:4515                 assume ds:nothing
SYSINIT:4515
SYSINIT:4515 kbd_loop:                               ; CODE XREF: kbd_read+25↓j
SYSINIT:4515                 mov     ah, 1           ; peek the keyboard
SYSINIT:4517                 int     16h             ; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
SYSINIT:4517                                         ; Return: ZF clear if character in buffer
SYSINIT:4517                                         ; AH = scan code, AL = character
SYSINIT:4517                                         ; ZF set if no character in buffer
SYSINIT:4519                 jnz     short kbd_loopdone
SYSINIT:451B                 mov     ah, 2
SYSINIT:451D                 int     16h             ; KEYBOARD - GET SHIFT STATUS
SYSINIT:451D                                         ; AL = shift status bits
SYSINIT:451F                 test    al, 3           ; either right or left shift key bits set?
SYSINIT:4521                 jnz     short kbd_loopdone ; yes
SYSINIT:4523                 mov     ax, ds:046Ch    ; system timer, lw
SYSINIT:4526                 sub     ax, cs:_timer_lw_ ; get difference
SYSINIT:452B                 cmp     ax, 37          ; reached limit? ; (2 seconds)
SYSINIT:452E                 jb      short kbd_loop
SYSINIT:4530
SYSINIT:4530 kbd_loopdone:                           ; CODE XREF: kbd_read+10↑j
SYSINIT:4530                                         ; kbd_read+18↑j
SYSINIT:4530                 pop     ds              ; delay complete!
SYSINIT:4531                 assume ds:nothing
SYSINIT:4531
SYSINIT:4531 kbd_nodelay:                            ; CODE XREF: kbd_read+5↑j
SYSINIT:4531                 sub     bx, bx          ; assume clean boot
SYSINIT:4533                 mov     ah, 2           ; peek the shift states
SYSINIT:4535                 int     16h             ; KEYBOARD - GET SHIFT STATUS
SYSINIT:4535                                         ; AL = shift status bits
SYSINIT:4537                 test    al, 3           ; either right or left shift key bits set?
SYSINIT:4539                 jz      short kbd_notshift ; no
SYSINIT:453B                 inc     bx              ; yes
SYSINIT:453C                 inc     bx
SYSINIT:453D                 or      ds:bQueryOpt, 4
SYSINIT:4542
SYSINIT:4542 kbd_notshift:                           ; CODE XREF: kbd_read+30↑j
SYSINIT:4542                 mov     ah, 1           ; peek the keyboard
SYSINIT:4544                 int     16h             ; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
SYSINIT:4544                                         ; Return: ZF clear if character in buffer
SYSINIT:4544                                         ; AH = scan code, AL = character
SYSINIT:4544                                         ; ZF set if no character in buffer
SYSINIT:4546                 jz      short kbd_test  ; no key present
SYSINIT:4548                 or      al, al          ; is it a function key?
SYSINIT:454A                 jnz     short kbd_test  ; no
SYSINIT:454C                 cmp     ah, 62h         ; CTRL F5
SYSINIT:454F                 jz      short kbd_cfg_bypass
SYSINIT:4551                 cmp     ah, 3Fh         ; F5 function key?
SYSINIT:4554                 jnz     short kbd_notf5 ; no
SYSINIT:4556
SYSINIT:4556 kbd_cfg_bypass:                         ; CODE XREF: kbd_read+46↑j
SYSINIT:4556                 mov     dx, offset _$CleanMsg ; "PC DOS is bypassing your CONFIG.SYS and"...
SYSINIT:4559                 call    print
SYSINIT:455C                 or      ds:bQueryOpt, 4
SYSINIT:4561                 jmp     short kbd_eat   ; yes, clean boot selected
SYSINIT:4563 ; ---------------------------------------------------------------------------
SYSINIT:4563
SYSINIT:4563 kbd_notf5:                              ; CODE XREF: kbd_read+4B↑j
SYSINIT:4563                 cmp     ah, 65h         ; CTRL F8
SYSINIT:4566                 jz      short kbd_cfg_confirm
SYSINIT:4568                 cmp     ah, 42h         ; F8
SYSINIT:456B                 jnz     short kbd_exit
SYSINIT:456D
SYSINIT:456D kbd_cfg_confirm:                        ; CODE XREF: kbd_read+5D↑j
SYSINIT:456D                 mov     dx, offset _$InterMsg ; "PC DOS will prompt you to confirm each "...
SYSINIT:4570                 call    print
SYSINIT:4573                 mov     bl, 1           ; yes, interactive-boot option enabled
SYSINIT:4575                 mov     ds:bQueryOpt, bl ; change default setting
SYSINIT:4579
SYSINIT:4579 kbd_eat:                                ; CODE XREF: kbd_read+58↑j
SYSINIT:4579                 mov     ah, 0           ; eat the key we assumed was a signal
SYSINIT:457B                 int     16h             ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
SYSINIT:457B                                         ; Return: AH = scan code, AL = character
SYSINIT:457D                 mov     ds:secElapsed, 0FFh ; -1
SYSINIT:4582                 or      bx, bx
SYSINIT:4584                 jz      short kbd_clean
SYSINIT:4586
SYSINIT:4586 kbd_test:                               ; CODE XREF: kbd_read+3D↑j
SYSINIT:4586                                         ; kbd_read+41↑j
SYSINIT:4586                 cmp     bl, 2
SYSINIT:4589                 jb      short kbd_exit
SYSINIT:458B
SYSINIT:458B kbd_clean:                              ; CODE XREF: kbd_read+7B↑j
SYSINIT:458B                 call    disable_autoexec ; yes, tell COMMAND to skip autoexec.bat
SYSINIT:458E                 stc                     ; set carry to indicate abort
SYSINIT:458F                 retn
SYSINIT:4590 ; ---------------------------------------------------------------------------
SYSINIT:4590
SYSINIT:4590 kbd_exit:                               ; CODE XREF: kbd_read+62↑j
SYSINIT:4590                                         ; kbd_read+80↑j
SYSINIT:4590                 clc                     ; clear carry to indicate success
SYSINIT:4591                 retn
SYSINIT:4591 kbd_read        endp
SYSINIT:4591
SYSINIT:4592
SYSINIT:4592 ; =============== S U B R O U T I N E =======================================
SYSINIT:4592
SYSINIT:4592
SYSINIT:4592 set_numlock     proc near               ; CODE XREF: doconf+A97↑p
SYSINIT:4592                                         ; menu_check+18↓p ...
SYSINIT:4592                 push    ax              ; set numlock LED
SYSINIT:4593                 push    ds
SYSINIT:4594                 in      al, 64h         ; 8042 keyboard controller status register
SYSINIT:4594                                         ; 7:  PERR    1=parity error in data received from keyboard
SYSINIT:4594                                         ;    +----------- AT Mode ----------+------------ PS/2 Mode ------------+
SYSINIT:4594                                         ; 6: |RxTO    receive (Rx) timeout  | TO      general timeout (Rx or Tx)|
SYSINIT:4594                                         ; 5: |TxTO    transmit (Tx) timeout | MOBF    mouse output buffer full  |
SYSINIT:4594                                         ;    +------------------------------+-----------------------------------+
SYSINIT:4594                                         ; 4:  INH     0=keyboard communications inhibited
SYSINIT:4594                                         ; 3:  A2      0=60h was the port last written to, 1=64h was last
SYSINIT:4594                                         ; 2:  SYS     distinguishes reset types: 0=cold reboot, 1=warm reboot
SYSINIT:4594                                         ; 1:  IBF     1=input buffer full (keyboard can't accept data)
SYSINIT:4594                                         ; 0:  OBF     1=output buffer full (data from keyboard is available)
SYSINIT:4596                 test    al, 10h
SYSINIT:4598                 jz      short set_done  ; keyboard communications inhibited
SYSINIT:459A                 sub     ax, ax
SYSINIT:459C                 mov     ds, ax
SYSINIT:459E                 assume ds:nothing
SYSINIT:459E                 mov     ax, es:[si]     ; get 1st 2 bytes of value (ON or OF)
SYSINIT:45A1                 cmp     ax, word ptr cs:OnOff2 ; "OFF"
SYSINIT:45A6                 jnz     short not_off
SYSINIT:45A8                 and     byte ptr ds:0417h, 0DFh ; ~20h ; turn it off
SYSINIT:45AD                 jmp     short set_done
SYSINIT:45AF ; ---------------------------------------------------------------------------
SYSINIT:45AF
SYSINIT:45AF not_off:                                ; CODE XREF: set_numlock+14↑j
SYSINIT:45AF                 cmp     ax, word ptr cs:OnOff ; "ON"
SYSINIT:45B4                 stc
SYSINIT:45B5                 jnz     short set_done
SYSINIT:45B7                 or      byte ptr ds:0417h, 20h ; turn it on
SYSINIT:45BC
SYSINIT:45BC set_done:                               ; CODE XREF: set_numlock+6↑j
SYSINIT:45BC                                         ; set_numlock+1B↑j ...
SYSINIT:45BC                 pop     ds
SYSINIT:45BD                 assume ds:nothing
SYSINIT:45BD                 pop     ax
SYSINIT:45BE                 retn
SYSINIT:45BE set_numlock     endp
SYSINIT:45BE
SYSINIT:45BF
SYSINIT:45BF ; =============== S U B R O U T I N E =======================================
SYSINIT:45BF
SYSINIT:45BF
SYSINIT:45BF menu_check      proc near               ; CODE XREF: SYSINIT:44CB↑j
SYSINIT:45BF                 push    cx              ; Search for SWITCHES,
SYSINIT:45BF                                         ; determine if /N or /F are present;
SYSINIT:45BF                                         ; if so, then disable clean/interactive boot options
SYSINIT:45C0                 push    si
SYSINIT:45C1                 sub     bx, bx          ; remains ZERO until first block
SYSINIT:45C3
SYSINIT:45C3 swchk_loop:                             ; CODE XREF: menu_check+53↓j
SYSINIT:45C3                 call    get_char        ; get first char of current line
SYSINIT:45C6                 jb      short swchk_end ; hit eof
SYSINIT:45C8                 cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
SYSINIT:45CA                 jnz     short swchk_next1
SYSINIT:45CC                 inc     bx              ; remember that we've seen a block
SYSINIT:45CD                 jmp     short swchk_nextline
SYSINIT:45CF ; ---------------------------------------------------------------------------
SYSINIT:45CF
SYSINIT:45CF swchk_next1:                            ; CODE XREF: menu_check+B↑j
SYSINIT:45CF                 cmp     al, 4Eh ; 'N'   ; CONFIG_NUMLOCK
SYSINIT:45D1                 jnz     short swchk_next2
SYSINIT:45D3                 or      bx, bx          ; only do NUMLOCK commands that exist
SYSINIT:45D5                 jnz     short swchk_nextline ; before the first block
SYSINIT:45D7                 call    set_numlock     ; REM it out so we don't act on it later, too
SYSINIT:45DA                 mov     byte ptr es:[si-1], 30h ; '0' ; CONFIG_REM
SYSINIT:45DF                 jmp     short swchk_nextline
SYSINIT:45E1 ; ---------------------------------------------------------------------------
SYSINIT:45E1
SYSINIT:45E1 swchk_next2:                            ; CODE XREF: menu_check+12↑j
SYSINIT:45E1                 cmp     al, 31h ; '1'   ; CONFIG_SWITCHES
SYSINIT:45E3                 jnz     short swchk_nextline ; this line ain't it
SYSINIT:45E5
SYSINIT:45E5 swchk_scan:                             ; CODE XREF: menu_check+2F↓j
SYSINIT:45E5                                         ; menu_check+41↓j ...
SYSINIT:45E5                 call    get_char        ; look for /N or /F
SYSINIT:45E8
SYSINIT:45E8 swchk_scan1:                            ; CODE XREF: menu_check+47↓j
SYSINIT:45E8                 cmp     al, 0Ah         ; LF ; end of line ?
SYSINIT:45EA                 jz      short swchk_nextline
SYSINIT:45EC                 cmp     al, 2Fh ; '/'   ; switch-char?
SYSINIT:45EE                 jnz     short swchk_scan ; no
SYSINIT:45F0                 call    get_char
SYSINIT:45F3                 and     al, 0DFh        ; ~20h ; convert to upper case
SYSINIT:45F5                 cmp     al, byte ptr ds:swit_n+1 ; "N"
SYSINIT:45F9                 jnz     short swchk_scan2 ; no
SYSINIT:45FB                 or      ds:bDisableUI, 1
SYSINIT:4600                 jmp     short swchk_scan ; continue looking for switches of interest
SYSINIT:4602 ; ---------------------------------------------------------------------------
SYSINIT:4602
SYSINIT:4602 swchk_scan2:                            ; CODE XREF: menu_check+3A↑j
SYSINIT:4602                 cmp     al, byte ptr ds:swit_f+1 ; "F"
SYSINIT:4606                 jnz     short swchk_scan1 ; no
SYSINIT:4608                 or      ds:bDisableUI, 2
SYSINIT:460D                 jmp     short swchk_scan ; continue looking for switches of interest
SYSINIT:460F ; ---------------------------------------------------------------------------
SYSINIT:460F
SYSINIT:460F swchk_nextline:                         ; CODE XREF: menu_check+E↑j
SYSINIT:460F                                         ; menu_check+16↑j ...
SYSINIT:460F                 call    skip_opt_line
SYSINIT:4612                 jmp     short swchk_loop
SYSINIT:4614 ; ---------------------------------------------------------------------------
SYSINIT:4614
SYSINIT:4614 swchk_end:                              ; CODE XREF: menu_check+7↑j
SYSINIT:4614                 pop     si
SYSINIT:4615                 pop     cx              ;
SYSINIT:4615                                         ; Do the keyboard tests for clean/interactive boot now,
SYSINIT:4615                                         ; but only if the DisableUI flag is still clear
SYSINIT:4616                 test    ds:bDisableUI, 1
SYSINIT:461B                 jnz     short menu_search ;
SYSINIT:461B                                         ; Wait for 2 seconds first,
SYSINIT:461B                                         ; UNLESS the /F bit was set in bDisableUI, or
SYSINIT:461B                                         ; there is anything at all in the keyboard buffer
SYSINIT:461D                 call    kbd_read
SYSINIT:4620                 jnb     short menu_search
SYSINIT:4622                 jmp     menu_abort
SYSINIT:4625 ; ---------------------------------------------------------------------------
SYSINIT:4625
SYSINIT:4625 menu_search:                            ; CODE XREF: menu_check+5C↑j
SYSINIT:4625                                         ; menu_check+61↑j ...
SYSINIT:4625                 sub     bx, bx          ; Search for MENU block;
SYSINIT:4625                                         ; it is allowed to be anywhere in config.sys
SYSINIT:4627                 mov     di, offset szMenu ; "MENU"
SYSINIT:462A                 call    find_block      ; find the MENU block
SYSINIT:462A                                         ; if no MENU, default to zero for no_selection
SYSINIT:462D                 jnb     short menu_found
SYSINIT:462F                 mov     byte ptr ds:szBoot, 0 ; "CONFIG="
SYSINIT:4634                 jmp     no_selection    ; not found
SYSINIT:4637 ; ---------------------------------------------------------------------------
SYSINIT:4637
SYSINIT:4637 menu_color:                             ; CODE XREF: menu_check+E3↓j
SYSINIT:4637                 push    cx              ; Process the requested menu color(s)
SYSINIT:4638                 push    dx
SYSINIT:4639                 mov     dx, 7           ; default color setting
SYSINIT:463C                 call    get_number      ; get first number
SYSINIT:463F                 and     bl, 0Fh         ; first # is foreground color (for low nibble)
SYSINIT:4642                 mov     ch, bl          ; save it in CH
SYSINIT:4644                 and     dl, 0F0h
SYSINIT:4647                 or      dl, bl
SYSINIT:4649                 call    delim           ; did we hit a delimiter
SYSINIT:464C                 jnz     short check_color ; no, all done
SYSINIT:464E                 call    get_number      ; get next number
SYSINIT:4651                 and     bl, 0Fh         ; second # is background color (for high nibble)
SYSINIT:4654                 mov     dh, bl          ; save it in DH
SYSINIT:4656                 and     dl, 0Fh
SYSINIT:4659                 mov     cl, 4
SYSINIT:465B                 shl     bl, cl
SYSINIT:465D                 or      dl, bl
SYSINIT:465F
SYSINIT:465F check_color:                            ; CODE XREF: menu_check+8D↑j
SYSINIT:465F                 cmp     ch, dh          ; are foreground/background the same?
SYSINIT:4661                 jnz     short set_color ; no
SYSINIT:4663                 xor     dl, 8           ; yes, so modify the fgnd intensity
SYSINIT:4666
SYSINIT:4666 set_color:                              ; CODE XREF: menu_check+A2↑j
SYSINIT:4666                 mov     ds:bMenuColor, dl
SYSINIT:466A                 pop     dx
SYSINIT:466B                 pop     cx
SYSINIT:466C                 jmp     menu_nextitem
SYSINIT:466F ; ---------------------------------------------------------------------------
SYSINIT:466F
SYSINIT:466F menu_found:                             ; CODE XREF: menu_check+6E↑j
SYSINIT:466F                                         ; menu_check+286↓j
SYSINIT:466F                 mov     ds:bDefBlock, 1
SYSINIT:4674                 mov     ds:offDefBlock, 0
SYSINIT:467A                 mov     ds:secTimeOut, 0FFh ; -1
SYSINIT:467F                 and     ds:bQueryOpt, 0FDh ; ~2
SYSINIT:4684                 call    skip_opt_line   ; skip to next line
SYSINIT:4687                 sub     dx, dx          ; initialize total block count (0 => none yet)
SYSINIT:4689
SYSINIT:4689 menu_process:                           ; CODE XREF: menu_check+15E↓j
SYSINIT:4689                 call    get_char        ; get first char of current line
SYSINIT:468C                 jb      short to_menu_getdefault ; could happen if menu block at end (rare)
SYSINIT:468E                 and     al, 7Fh         ; ~CONFIG_OPTION_QUERY
SYSINIT:4690                 cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
SYSINIT:4692                 jz      short to_menu_getdefault ; BEGIN implies END
SYSINIT:4694                 cmp     al, 4Fh ; 'O'   ; CONFIG_SUBMENU
SYSINIT:4696                 jz      short menu_item ; go process sub-menu
SYSINIT:4698                 cmp     al, 45h ; 'E'   ; CONFIG_MENUITEM
SYSINIT:469A                 jz      short menu_item ; go process menu item
SYSINIT:469C                 cmp     al, 41h ; 'A'   ; CONFIG_MENUDEFAULT
SYSINIT:469E                 jz      short menu_default ; go process menu default
SYSINIT:46A0                 cmp     al, 52h ; 'R'   ; CONFIG_MENUCOLOR
SYSINIT:46A2                 jz      short menu_color ; go process menu color
SYSINIT:46A4                 cmp     al, 4Eh ; 'N'   ; CONFIG_NUMLOCK
SYSINIT:46A6                 jz      short menu_numlock
SYSINIT:46A8                 cmp     al, 30h ; '0'   ; CONFIG_REM
SYSINIT:46AA                 jz      short menu_nextitem ; allow remarks in menu block
SYSINIT:46AC                 call    any_delim       ; allow blank lines and such
SYSINIT:46AF                 jz      short menu_nextitem
SYSINIT:46B1                 stc
SYSINIT:46B2                 call    print_error     ; non-MENU command!
SYSINIT:46B5                 jmp     short menu_nextitem
SYSINIT:46B7 ; ---------------------------------------------------------------------------
SYSINIT:46B7
SYSINIT:46B7 menu_numlock:                           ; CODE XREF: menu_check+E7↑j
SYSINIT:46B7                 call    set_numlock
SYSINIT:46BA                 jmp     short menu_nextitem
SYSINIT:46BC ; ---------------------------------------------------------------------------
SYSINIT:46BC
SYSINIT:46BC to_menu_getdefault:                     ; CODE XREF: menu_check+CD↑j
SYSINIT:46BC                                         ; menu_check+D3↑j
SYSINIT:46BC                 jmp     short menu_getdefault
SYSINIT:46BE ; ---------------------------------------------------------------------------
SYSINIT:46BE
SYSINIT:46BE menu_default:                           ; CODE XREF: menu_check+DF↑j
SYSINIT:46BE                 mov     ds:offDefBlock, si ; save address of default block name
SYSINIT:46C2                 cmp     ds:secElapsed, 0
SYSINIT:46C7                 jnz     short timeout_skip ; secElapsed is only zero for the FIRST menu,
SYSINIT:46C9                 call    skip_token      ; and for subsequent menus IF nothing was typed;
SYSINIT:46CC                 jb      short menu_nextitem ; secElapsed becomes -1 forever as soon as
SYSINIT:46CE                 call    skip_delim      ; something is typed
SYSINIT:46D1                 jb      short menu_nextitem
SYSINIT:46D3                 mov     si, bx
SYSINIT:46D5                 call    get_number      ; get number (of seconds for timeout)
SYSINIT:46D8                 cmp     bl, 90          ; limit it to a reasonable number
SYSINIT:46DB                 jb      short timeout_ok ; (besides, 99 is the largest # my simple
SYSINIT:46DD                 mov     bl, 90
SYSINIT:46DF
SYSINIT:46DF timeout_ok:                             ; CODE XREF: menu_check+11C↑j
SYSINIT:46DF                 mov     ds:secTimeOut, bl
SYSINIT:46E3
SYSINIT:46E3 timeout_skip:                           ; CODE XREF: menu_check+108↑j
SYSINIT:46E3                 jmp     short menu_nextitem
SYSINIT:46E5 ; ---------------------------------------------------------------------------
SYSINIT:46E5
SYSINIT:46E5 menu_item:                              ; CODE XREF: menu_check+D7↑j
SYSINIT:46E5                                         ; menu_check+DB↑j
SYSINIT:46E5                 cmp     dl, 9           ; MAX_MULTI_CONFIG
SYSINIT:46E5                                         ; have we reached the max # of items yet?
SYSINIT:46E8                 jnb     short menu_nextitem
SYSINIT:46EA                 mov     di, si          ; DS:DI -> block name to search for
SYSINIT:46EC                 call    srch_block
SYSINIT:46EF                 jz      short menu_itemfound ; srch_block, having succeeded,
SYSINIT:46EF                                         ; returns DI -> past the token that it just matched,
SYSINIT:46EF                                         ; which in this case should be a descriptive string;
SYSINIT:46EF                                         ; ES:SI and CX are unmodified
SYSINIT:46F1                 stc
SYSINIT:46F2                 call    print_error     ; print error and pause
SYSINIT:46F5                 jmp     short menu_nextitem ; if not found, ignore this menu item
SYSINIT:46F7 ; ---------------------------------------------------------------------------
SYSINIT:46F7
SYSINIT:46F7 menu_itemfound:                         ; CODE XREF: menu_check+130↑j
SYSINIT:46F7                 inc     dx              ; otherwise, increment total block count
SYSINIT:46F8                 mov     bx, dx          ; and use it to index the arrays of offsets
SYSINIT:46FA                 mov     ds:abBlockType[bx], al
SYSINIT:46FE                 add     bx, bx          ; of recorded block names and descriptions
SYSINIT:4700                 mov     ds:aoffBlockName[bx], si ;
SYSINIT:4700                                         ; There should be a description immediately following
SYSINIT:4700                                         ; the block name on MENUITEM line; failing that,
SYSINIT:4700                                         ; we'll just use the block name as the description...
SYSINIT:4704                 mov     ds:aoffBlockDesc[bx], si
SYSINIT:4708                 mov     di, bx          ; skip_delim modifies BX, so stash it in DI
SYSINIT:470A                 call    skip_token
SYSINIT:470D                 jb      short menu_nextitem ; hit eol/eof
SYSINIT:470F                 call    skip_delim
SYSINIT:4712                 jb      short menu_nextitem ; hit eol/eof
SYSINIT:4714                 xchg    bx, di
SYSINIT:4716                 mov     ds:aoffBlockDesc[bx], di
SYSINIT:471A
SYSINIT:471A menu_nextitem:                          ; CODE XREF: menu_check+AD↑j
SYSINIT:471A                                         ; menu_check+EB↑j ...
SYSINIT:471A                 call    skip_opt_line
SYSINIT:471D                 jmp     menu_process    ; go back for more lines
SYSINIT:4720 ; ---------------------------------------------------------------------------
SYSINIT:4720
SYSINIT:4720 menu_getdefault:                        ; CODE XREF: menu_check:to_menu_getdefault↑j
SYSINIT:4720                 or      dl, dl          ; Display menu items now,
SYSINIT:4720                                         ; after determining which one is default
SYSINIT:4720                                         ;
SYSINIT:4720                                         ; where there any valid blocks at all?
SYSINIT:4722                 jnz     short menu_valid ; yes
SYSINIT:4724                 sub     bx, bx          ; no, so force autoselect of 0
SYSINIT:4726                 jmp     menu_autoselect ; (meaning: process common blocks only)
SYSINIT:4729 ; ---------------------------------------------------------------------------
SYSINIT:4729
SYSINIT:4729 menu_valid:                             ; CODE XREF: menu_check+163↑j
SYSINIT:4729                 sub     bx, bx
SYSINIT:472B                 mov     ds:bMaxBlock, dl ; first, record how many blocks we found
SYSINIT:472F                 mov     di, ds:offDefBlock
SYSINIT:4733                 or      di, di          ; does a default block exist?
SYSINIT:4735                 jz      short menu_nodefault ; no
SYSINIT:4737                 inc     bx              ; yes, walk name table, looking for default
SYSINIT:4738
SYSINIT:4738 menu_chkdefault:                        ; CODE XREF: menu_check+192↓j
SYSINIT:4738                 push    bx
SYSINIT:4739                 add     bx, bx
SYSINIT:473B                 mov     si, ds:aoffBlockName[bx]
SYSINIT:473F                 mov     cx, 128         ; arbitrary maximum length of a name
SYSINIT:4742                 push    ds
SYSINIT:4743                 push    es
SYSINIT:4744                 pop     ds
SYSINIT:4745                 call    comp_names      ; is this block the same as the default?
SYSINIT:4748                 pop     ds
SYSINIT:4749                 pop     bx
SYSINIT:474A                 jz      short menu_setdefault ; yes
SYSINIT:474C                 inc     bx
SYSINIT:474D                 cmp     bl, ds:bMaxBlock ; all done searching?
SYSINIT:4751                 jbe     short menu_chkdefault ; not yet
SYSINIT:4753
SYSINIT:4753 menu_nodefault:                         ; CODE XREF: menu_check+176↑j
SYSINIT:4753                 mov     bl, 1           ; if no default, force default to #1
SYSINIT:4755
SYSINIT:4755 menu_setdefault:                        ; CODE XREF: menu_check+18B↑j
SYSINIT:4755                 mov     ds:bDefBlock, bl ; yes, this will be the initial current block
SYSINIT:4755                                         ;
SYSINIT:4755                                         ; If the timeout was explicitly set to 0 (or technically,
SYSINIT:4755                                         ; anything that failed to resolve to a number, like "NONE"
SYSINIT:4755                                         ; or "EAT POTATOES"), then we're supposed to skip menu display
SYSINIT:4755                                         ; and run with the specified default block; however,
SYSINIT:4755                                         ; if the user hit Enter prior to boot, thereby requesting fully
SYSINIT:4755                                         ; INTERACTIVE boot, then we shall display the menu block anyway
SYSINIT:4755                                         ; (though still with no timeout)
SYSINIT:4759                 cmp     ds:secTimeOut, 0 ; is timeout zero? (ie, assume default)
SYSINIT:475E                 jnz     short menu_display ; no
SYSINIT:4760                 test    ds:bQueryOpt, 1 ; yes, but was INTERACTIVE requested?
SYSINIT:4765                 jnz     short menu_display ; yes, so *don't* assume default after all
SYSINIT:4767                 jmp     not_topmenu
SYSINIT:476A ; ---------------------------------------------------------------------------
SYSINIT:476A
SYSINIT:476A menu_display:                           ; CODE XREF: menu_check+19F↑j
SYSINIT:476A                                         ; menu_check+1A6↑j
SYSINIT:476A                 mov     ah, 0Fh         ; Reset the mode,
SYSINIT:476A                                         ; so that we know screen is clean and cursor is home
SYSINIT:476A                                         ; ;
SYSINIT:476C                 int     10h             ; - VIDEO - GET CURRENT VIDEO MODE
SYSINIT:476C                                         ; Return: AH = number of columns on screen
SYSINIT:476C                                         ; AL = current video mode
SYSINIT:476C                                         ; BH = current active display page
SYSINIT:476E                 mov     ah, 0
SYSINIT:4770                 int     10h             ; - VIDEO - SET VIDEO MODE
SYSINIT:4770                                         ; AL = mode
SYSINIT:4772                 push    es
SYSINIT:4773                 mov     ax, 40h         ; reach down into the ROM BIOS data area
SYSINIT:4776                 mov     es, ax          ; and save the current (default) video page
SYSINIT:4778                 assume es:nothing
SYSINIT:4778                 mov     ax, es:4Eh      ; start address and page #, in case the
SYSINIT:477C                 mov     ds:wCRTStart, ax ; undocumented QUIET option was enabled
SYSINIT:477F                 mov     al, es:62h
SYSINIT:4783                 mov     ds:bCRTPage, al
SYSINIT:4786                 mov     ax, word ptr ds:bMenuPage ; select new page for menu
SYSINIT:4789                 int     10h             ; - VIDEO -
SYSINIT:478B                 mov     ax, 600h        ; clear entire screen
SYSINIT:478E                 mov     bh, ds:bMenuColor ; using this color
SYSINIT:4792                 sub     cx, cx          ; upper left row/col
SYSINIT:4794                 mov     dl, es:4Ah      ; [es:CRT_Cols]
SYSINIT:4799                 dec     dl
SYSINIT:479B                 mov     dh, es:84h      ; [es:CRT_Rows]
SYSINIT:47A0                 or      dh, dh          ; # of rows valid?
SYSINIT:47A2                 jnz     short menu_clear ; hopefully
SYSINIT:47A4                 mov     dh, ds:bLastRow ; no, use a default
SYSINIT:47A8
SYSINIT:47A8 menu_clear:                             ; CODE XREF: menu_check+1E3↑j
SYSINIT:47A8                 int     10h             ; clear the screen using the req. attribute
SYSINIT:47A8                                         ;
SYSINIT:47A8                                         ; - VIDEO - SCROLL PAGE UP
SYSINIT:47A8                                         ; AL = number of lines to scroll window (0 = blank whole window)
SYSINIT:47A8                                         ; BH = attributes to be used on blanked lines
SYSINIT:47A8                                         ; CH,CL = row,column of upper left corner of window to scroll
SYSINIT:47A8                                         ; DH,DL = row,column of lower right corner of window
SYSINIT:47AA                 pop     es
SYSINIT:47AB                 assume es:nothing
SYSINIT:47AB                 mov     ds:bLastRow, dh ; save DH
SYSINIT:47AF                 mov     dx, offset _$MenuHeader ; "\r\n  PC DOS 7.1 Startup Menu\r\n  "
SYSINIT:47B2                 call    print           ; cursor now on row 3 (numbered from 0)
SYSINIT:47B5                 test    ds:bDisableUI, 1
SYSINIT:47BA                 jnz     short menu_nostatus
SYSINIT:47BC                 mov     bh, ds:bMenuPage
SYSINIT:47C0                 mov     dh, ds:bLastRow ; restore DH
SYSINIT:47C4                 mov     dl, 0           ; print the status line on row DH, col 0,
SYSINIT:47C6                 mov     ah, 2           ; now that we can trash the cursor position
SYSINIT:47C8                 int     10h             ; - VIDEO - SET CURSOR POSITION
SYSINIT:47C8                                         ; DH,DL = row, column (0,0 = upper left)
SYSINIT:47C8                                         ; BH = page number
SYSINIT:47CA                 mov     dx, offset _$StatusLine ; "F5=Bypass startup files F8=Confirm each"...
SYSINIT:47CD                 call    print
SYSINIT:47D0                 mov     ah, 3           ; get cursor position
SYSINIT:47D2                 int     10h             ; - VIDEO - READ CURSOR POSITION
SYSINIT:47D2                                         ; BH = page number
SYSINIT:47D2                                         ; Return: DH,DL = row,column, CH = cursor start line, CL = cursor end line
SYSINIT:47D4                 sub     dl, 2
SYSINIT:47D7                 mov     ds:bLastCol, dl ; save column where status char will go
SYSINIT:47DB
SYSINIT:47DB menu_nostatus:                          ; CODE XREF: menu_check+1FB↑j
SYSINIT:47DB                 mov     bx, 1           ; now prepare to display all the menu items
SYSINIT:47DE
SYSINIT:47DE menu_disploop:                          ; CODE XREF: menu_check+227↓j
SYSINIT:47DE                 call    print_item      ; print item #BL
SYSINIT:47E1                 inc     bx              ; why "inc bx"? because it's a 1-byte opcode
SYSINIT:47E2                 cmp     bl, ds:bMaxBlock ; all done?
SYSINIT:47E6                 jbe     short menu_disploop ; not yet
SYSINIT:47E8                 mov     dl, 0           ; Set cursor position to just below the menu items
SYSINIT:47E8                                         ; column 0
SYSINIT:47EA                 mov     dh, bl
SYSINIT:47EC                 add     dh, 4           ; select row below menu
SYSINIT:47EF                 mov     bh, ds:bMenuPage
SYSINIT:47F3                 mov     ah, 2           ; set cursor position beneath the block list
SYSINIT:47F5                 int     10h             ; - VIDEO - SET CURSOR POSITION
SYSINIT:47F5                                         ; DH,DL = row, column (0,0 = upper left)
SYSINIT:47F5                                         ; BH = page number
SYSINIT:47F7                 mov     dx, offset _$MenuPrmpt ; "  Enter a choice: $"
SYSINIT:47FA                 call    print
SYSINIT:47FD                 call    select_item     ; make a selection, return # in BX
SYSINIT:4800                 mov     dx, offset crlfm ; "\r\n$"
SYSINIT:4803                 call    print
SYSINIT:4806                 push    word ptr ds:bDisableUI
SYSINIT:480A                 or      ds:bDisableUI, 1
SYSINIT:480F                 call    show_status     ; clear the status line now
SYSINIT:4812                 pop     word ptr ds:bDisableUI ;
SYSINIT:4812                                         ; Now begins the "re-organization" process...
SYSINIT:4816
SYSINIT:4816 menu_autoselect:                        ; CODE XREF: menu_check+167↑j
SYSINIT:4816                 cmp     bx, 0FFFFh      ; -1 ; clean boot requested?
SYSINIT:4819                 jnz     short normal_boot
SYSINIT:481B                 call    disable_autoexec
SYSINIT:481E
SYSINIT:481E menu_abort:                             ; CODE XREF: menu_check+63↑j
SYSINIT:481E                 sub     cx, cx
SYSINIT:4820                 jmp     menu_exit
SYSINIT:4823 ; ---------------------------------------------------------------------------
SYSINIT:4823
SYSINIT:4823 normal_boot:                            ; CODE XREF: menu_check+25A↑j
SYSINIT:4823                 cmp     bx, 0FFFEh      ; -2 ; back to top-level menu?
SYSINIT:4826                 jnz     short not_topmenu ; no
SYSINIT:4828                 mov     cx, ds:count    ; yes, start all over
SYSINIT:482C                 sub     si, si
SYSINIT:482E                 jmp     menu_search
SYSINIT:4831 ; ---------------------------------------------------------------------------
SYSINIT:4831
SYSINIT:4831 not_topmenu:                            ; CODE XREF: menu_check+1A8↑j
SYSINIT:4831                                         ; menu_check+267↑j
SYSINIT:4831                 cmp     ds:abBlockType[bx], 4Fh ; CONFIG_SUBMENU
SYSINIT:4836                 jnz     short not_submenu
SYSINIT:4838                 add     bx, bx
SYSINIT:483A                 mov     di, ds:aoffBlockName[bx]
SYSINIT:483E                 call    srch_block      ; THIS CANNOT FAIL!
SYSINIT:4841                 mov     si, di
SYSINIT:4843                 mov     cx, bx          ; ES:SI and CX are ready for another round
SYSINIT:4845                 jmp     menu_found
SYSINIT:4848 ; ---------------------------------------------------------------------------
SYSINIT:4848
SYSINIT:4848 not_submenu:                            ; CODE XREF: menu_check+277↑j
SYSINIT:4848                 add     bx, bx          ; get BX -> name of selected block
SYSINIT:484A                 mov     bx, ds:aoffBlockName[bx] ;
SYSINIT:484A                                         ; BX should now either be ZERO
SYSINIT:484A                                         ; (meaning no block has been selected) or the offset
SYSINIT:484A                                         ; relative to ES of the block name to be processed
SYSINIT:484A                                         ; (along with all the "common" lines of course)
SYSINIT:484E
SYSINIT:484E no_selection:                           ; CODE XREF: menu_check+75↑j
SYSINIT:484E                 mov     ds:offDefBlock, bx ; save selection
SYSINIT:4852                 mov     cx, ds:count    ; reset ES:SI and CX for reprocessing
SYSINIT:4856                 sub     si, si
SYSINIT:4858                 push    ds
SYSINIT:4859                 mov     ds, ds:config_wrkseg ; this is where we'll store new config.sys image
SYSINIT:485D                 sub     di, di          ;
SYSINIT:485D                                         ; ES:SI-> config.sys, DS:DI -> new config.sys workspace
SYSINIT:485D                                         ;
SYSINIT:485D                                         ; Work our way through the config.sys image again, this time copying
SYSINIT:485D                                         ; all lines that are (A) "common" lines outside any block or (B) lines
SYSINIT:485D                                         ; within the requested block. Lines inside INCLUDEd blocks are
SYSINIT:485D                                         ; transparently copied by copy_block in a recursive fashion;
SYSINIT:485D                                         ; the amount of recursion is limited by the fact INCLUDE statements are
SYSINIT:485D                                         ; REMed by copy_block as they are processed and by the number of unique
SYSINIT:485D                                         ; INCLUDE stmts in config.sys...
SYSINIT:485F
SYSINIT:485F copyblock_loop:                         ; CODE XREF: menu_check+2D1↓j
SYSINIT:485F                 push    bx              ; save selected block name
SYSINIT:4860                 call    copy_block      ; process (named or common) block
SYSINIT:4863                 pop     bx
SYSINIT:4864                 jb      short move_config ; hit eof
SYSINIT:4866
SYSINIT:4866 copyblock_begin:                        ; CODE XREF: menu_check+2DF↓j
SYSINIT:4866                 push    ax              ; copy_block can only return for two reasons:
SYSINIT:4866                                         ;  it hit eof or a new block
SYSINIT:4867                 push    cx
SYSINIT:4868                 push    si
SYSINIT:4869                 push    di              ; always do "common" blocks
SYSINIT:486A                 mov     di, offset szCommon ; "COMMON"
SYSINIT:486D                 push    ds
SYSINIT:486E                 push    cs
SYSINIT:486F                 pop     ds
SYSINIT:4870                 assume ds:SYSINIT
SYSINIT:4870                 call    comp_names
SYSINIT:4873                 pop     ds
SYSINIT:4874                 assume ds:nothing
SYSINIT:4874                 pop     di
SYSINIT:4875                 pop     si
SYSINIT:4876                 pop     cx
SYSINIT:4877                 pop     ax
SYSINIT:4878                 jz      short copyblock_check
SYSINIT:487A                 or      bx, bx          ; is there a block name to check?
SYSINIT:487C                 jz      short copyblock_skip ; no
SYSINIT:487E                 push    di
SYSINIT:487F                 mov     di, bx          ; check block against given block name
SYSINIT:4881                 push    ds
SYSINIT:4882                 push    es
SYSINIT:4883                 pop     ds
SYSINIT:4884                 call    comp_names      ; is this the block we really want to do?
SYSINIT:4887                 pop     ds
SYSINIT:4888                 pop     di
SYSINIT:4889
SYSINIT:4889 copyblock_check:                        ; CODE XREF: menu_check+2B9↑j
SYSINIT:4889                 jb      short move_config ; hit eof
SYSINIT:488B                 jnz     short copyblock_skip
SYSINIT:488D                 call    skip_opt_line
SYSINIT:4890                 jmp     short copyblock_loop
SYSINIT:4892 ; ---------------------------------------------------------------------------
SYSINIT:4892
SYSINIT:4892 copyblock_skip:                         ; CODE XREF: menu_check+2BD↑j
SYSINIT:4892                                         ; menu_check+2CC↑j ...
SYSINIT:4892                 call    skip_opt_line   ; this ain't the block we wanted, so skip it
SYSINIT:4895                 call    get_char
SYSINIT:4898                 jb      short move_config ; hit eof
SYSINIT:489A                 and     al, 7Fh         ; ~CONFIG_OPTION_QUERY
SYSINIT:489C                 cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
SYSINIT:489E                 jz      short copyblock_begin
SYSINIT:48A0                 jmp     short copyblock_skip ; anything else is just skipped
SYSINIT:48A2 ; ---------------------------------------------------------------------------
SYSINIT:48A2
SYSINIT:48A2 move_config:                            ; CODE XREF: menu_check+2A5↑j
SYSINIT:48A2                                         ; menu_check:copyblock_check↑j ...
SYSINIT:48A2                 mov     cx, di          ; To create as little risk to the rest of SysInit
SYSINIT:48A2                                         ; as little as possible, and to free the workspace
SYSINIT:48A2                                         ; at "config_wrkseg" for creating an environment,
SYSINIT:48A2                                         ; copy the new config.sys image to "confbot".
SYSINIT:48A2                                         ;
SYSINIT:48A2                                         ; now copy workspace at DS:DI to "confbot"
SYSINIT:48A4                 push    cx              ;
SYSINIT:48A4                                         ; But first, copy the CONFIG=<configuration><0> string
SYSINIT:48A4                                         ; to the workspace, since the configuration name only
SYSINIT:48A4                                         ; currently exists in the "confbot" area.
SYSINIT:48A4                                         ; ;
SYSINIT:48A5                 mov     cx, 7           ; szMenu-szBoot-1
SYSINIT:48A5                                         ; first copy the CONFIG= part
SYSINIT:48A8                 mov     si, offset szBoot ; "CONFIG="
SYSINIT:48AB                 inc     di              ; skip a byte, in case absolutely nothing
SYSINIT:48AB                                         ; was copied to the workspace, because we always
SYSINIT:48AB                                         ; zero the first byte of the workspace (below)
SYSINIT:48AC
SYSINIT:48AC copy_boot:                              ; CODE XREF: menu_check+2F2↓j
SYSINIT:48AC                 lods    byte ptr cs:[si]
SYSINIT:48AE                 mov     [di], al
SYSINIT:48B0                 inc     di
SYSINIT:48B1                 loop    copy_boot
SYSINIT:48B3                 push    es              ; then copy the configuration name
SYSINIT:48B4                 mov     cx, 121         ; 128-7 ; put an upper limit on the name, to be safe
SYSINIT:48B7                 mov     si, cs:offDefBlock ; ES:SI -> default block name
SYSINIT:48BC                 or      si, si          ; valid?
SYSINIT:48BE                 jnz     short l1        ; yes
SYSINIT:48C0                 push    cs
SYSINIT:48C1                 pop     es
SYSINIT:48C2                 assume es:SYSINIT
SYSINIT:48C2                 mov     si, offset szCommon ; "COMMON"
SYSINIT:48C5
SYSINIT:48C5 l1:                                     ; CODE XREF: menu_check+2FF↑j
SYSINIT:48C5                                         ; menu_check+312↓j
SYSINIT:48C5                 mov     al, es:[si]
SYSINIT:48C8                 call    any_delim
SYSINIT:48CB                 jz      short l2
SYSINIT:48CD                 mov     [di], al
SYSINIT:48CF                 inc     si
SYSINIT:48D0                 inc     di
SYSINIT:48D1                 loop    l1
SYSINIT:48D3
SYSINIT:48D3 l2:                                     ; CODE XREF: menu_check+30C↑j
SYSINIT:48D3                 mov     byte ptr [di], 0Ah ; terminate the configuration string
SYSINIT:48D6                 pop     es
SYSINIT:48D7                 assume es:nothing
SYSINIT:48D7                 sub     di, di          ; Now we can copy "config_wrkseg" (DS) to "confbot" (ES)
SYSINIT:48D9                 mov     cs:config_envlen, di
SYSINIT:48DE                 sub     si, si
SYSINIT:48E0                 pop     cx              ; recover the size of "config_wrkseg"
SYSINIT:48E1                 push    cx
SYSINIT:48E2                 rep movsb               ; moved!
SYSINIT:48E4                 pop     cx
SYSINIT:48E5                 mov     ax, ds
SYSINIT:48E7                 pop     ds              ; Now that the config_wrkseg is available once again,
SYSINIT:48E7                                         ; we shall use it to create an environment. The first
SYSINIT:48E7                                         ; thing to go in will be the "CONFIG=configuration" thing.
SYSINIT:48E7                                         ; It is also important to zero the first byte of the workspace,
SYSINIT:48E7                                         ; so that copy_envvar knows the buffer is empty.
SYSINIT:48E8                 push    es
SYSINIT:48E9                 mov     es, ax
SYSINIT:48EB                 inc     si              ; ES:SI -> "CONFIG=configuration"
SYSINIT:48EC                 mov     byte ptr es:0, 0 ; empty the environment block
SYSINIT:48F2                 call    copy_envvar     ; copy envvar at ES:SI to "config_wrkseg"
SYSINIT:48F5                 pop     es              ;
SYSINIT:48F5                                         ; Before returning, restore the default video page setting
SYSINIT:48F5                                         ; but do NOT do it using INT 10h's Set Active Page function,
SYSINIT:48F5                                         ; because if the menu was displayed on a different page,
SYSINIT:48F5                                         ; then it's because we don't want to see all the device
SYSINIT:48F5                                         ; driver/TSR goop (which goes to the default page)
SYSINIT:48F6                 cmp     ds:bMenuPage, 0
SYSINIT:48FB                 jz      short menu_exit
SYSINIT:48FD                 push    es
SYSINIT:48FE                 mov     ax, 40h
SYSINIT:4901                 mov     es, ax
SYSINIT:4903                 assume es:nothing
SYSINIT:4903                 mov     ax, ds:wCRTStart
SYSINIT:4906                 mov     es:4Eh, ax
SYSINIT:490A                 mov     al, ds:bCRTPage
SYSINIT:490D                 mov     es:62h, al
SYSINIT:4911                 pop     es
SYSINIT:4912                 assume es:nothing
SYSINIT:4912
SYSINIT:4912 menu_exit:                              ; CODE XREF: menu_check+261↑j
SYSINIT:4912                                         ; menu_check+33C↑j
SYSINIT:4912                 mov     ds:count, cx
SYSINIT:4916                 mov     ds:org_count, cx
SYSINIT:491A                 retn
SYSINIT:491A menu_check      endp
SYSINIT:491A
SYSINIT:491B
SYSINIT:491B ; =============== S U B R O U T I N E =======================================
SYSINIT:491B
SYSINIT:491B
SYSINIT:491B copy_envvar     proc near               ; CODE XREF: doconf+A83↑p
SYSINIT:491B                                         ; menu_check+333↑p
SYSINIT:491B                 push    cx              ; copy the envvar at ES:SI to "config_wrkseg"
SYSINIT:491B                                         ; ES:SI -> environment variable
SYSINIT:491B                                         ;          (in the form "var=string<cr/lf>")
SYSINIT:491C                 push    si
SYSINIT:491D                 push    ds
SYSINIT:491E                 push    es
SYSINIT:491F                 push    es
SYSINIT:4920                 mov     es, ds:config_wrkseg ; ES:DI to point to next available byte
SYSINIT:4924                 pop     ds              ; DS:SI to point to envvar
SYSINIT:4925                 sub     cx, cx
SYSINIT:4927
SYSINIT:4927 copy_varlen:                            ; CODE XREF: copy_envvar+1F↓j
SYSINIT:4927                 lodsb
SYSINIT:4928                 or      al, al          ; NULL?
SYSINIT:492A                 stc
SYSINIT:492B                 jz      short copy_envexit ; yes, abort
SYSINIT:492D                 cmp     al, 0Dh         ; cr
SYSINIT:492F                 stc
SYSINIT:4930                 jz      short copy_envexit
SYSINIT:4932                 cmp     al, 0Ah         ; lf
SYSINIT:4934                 stc
SYSINIT:4935                 jz      short copy_envexit
SYSINIT:4937                 inc     cx
SYSINIT:4938                 cmp     al, 3Dh ; '='
SYSINIT:493A                 jnz     short copy_varlen
SYSINIT:493C                 mov     al, 0
SYSINIT:493E                 mov     ah, [si]        ; save char after '='
SYSINIT:4940                 sub     si, cx          ; back up to given varname
SYSINIT:4942                 dec     cx              ; CX == # of bytes in varname
SYSINIT:4943                 sub     di, di          ; start looking for DS:SI at ES:0
SYSINIT:4945
SYSINIT:4945 copy_varsrch:                           ; CODE XREF: copy_envvar+67↓j
SYSINIT:4945                 cmp     es:[di], al
SYSINIT:4948                 jz      short copy_envprep ; search failed, just copy var
SYSINIT:494A                 mov     bx, di          ; ES:BX -> start of this varname
SYSINIT:494C                 push    cx
SYSINIT:494D                 push    si
SYSINIT:494E                 repe cmpsb
SYSINIT:4950                 pop     si
SYSINIT:4951                 pop     cx
SYSINIT:4952                 jnz     short copy_varnext ; no match, skip to next varname
SYSINIT:4954                 cmp     byte ptr es:[di], '='
SYSINIT:4958                 jnz     short copy_varnext ; no match, there's more characters
SYSINIT:4958                                         ;
SYSINIT:4958                                         ; Previous occurrence of variable has been found;
SYSINIT:4958                                         ; determine the entire length and then destroy it
SYSINIT:495A                 mov     cx, 0FFFFh      ; -1
SYSINIT:495D                 repne scasb             ; guaranteed to get null (since we put it there)
SYSINIT:495F                 push    si
SYSINIT:4960                 mov     si, di
SYSINIT:4962                 mov     di, bx
SYSINIT:4964                 mov     cx, cs:config_envlen
SYSINIT:4969                 sub     cx, si          ; destroy variable now
SYSINIT:496B                 rep movs byte ptr es:[di], byte ptr es:[si]
SYSINIT:496E                 pop     si
SYSINIT:496F
SYSINIT:496F copy_envprep:                           ; CODE XREF: copy_envvar+2D↑j
SYSINIT:496F                 cmp     ah, 0Dh         ; if there is nothing after the '='
SYSINIT:4972                 jz      short copy_envdel
SYSINIT:4974                 cmp     ah, 0Ah
SYSINIT:4977                 jz      short copy_envdel
SYSINIT:4979                 jmp     short copy_envloop
SYSINIT:497B ; ---------------------------------------------------------------------------
SYSINIT:497B
SYSINIT:497B copy_varnext:                           ; CODE XREF: copy_envvar+37↑j
SYSINIT:497B                                         ; copy_envvar+3D↑j
SYSINIT:497B                 push    cx
SYSINIT:497C                 mov     cx, 0FFFFh      ; -1
SYSINIT:497F                 repne scasb
SYSINIT:4981                 pop     cx
SYSINIT:4982                 jmp     short copy_varsrch
SYSINIT:4984 ; ---------------------------------------------------------------------------
SYSINIT:4984
SYSINIT:4984 copy_envloop:                           ; CODE XREF: copy_envvar+5E↑j
SYSINIT:4984                                         ; copy_envvar+73↓j
SYSINIT:4984                 lodsb
SYSINIT:4985                 cmp     al, 0Dh         ; cr
SYSINIT:4987                 jz      short copy_envdone
SYSINIT:4989                 cmp     al, 0Ah         ; lf
SYSINIT:498B                 jz      short copy_envdone
SYSINIT:498D                 stosb
SYSINIT:498E                 jmp     short copy_envloop
SYSINIT:4990 ; ---------------------------------------------------------------------------
SYSINIT:4990
SYSINIT:4990 copy_envdone:                           ; CODE XREF: copy_envvar+6C↑j
SYSINIT:4990                                         ; copy_envvar+70↑j
SYSINIT:4990                 sub     al, al          ; do SUB to clear carry as well
SYSINIT:4992                 stosb                   ; always null-terminate these puppies
SYSINIT:4993
SYSINIT:4993 copy_envdel:                            ; CODE XREF: copy_envvar+57↑j
SYSINIT:4993                                         ; copy_envvar+5C↑j
SYSINIT:4993                 mov     es:[di], al     ; and stick another null to terminate the env.
SYSINIT:4996                 mov     cs:config_envlen, di
SYSINIT:499B
SYSINIT:499B copy_envexit:                           ; CODE XREF: copy_envvar+10↑j
SYSINIT:499B                                         ; copy_envvar+15↑j ...
SYSINIT:499B                 pop     es
SYSINIT:499C                 pop     ds
SYSINIT:499D                 pop     si
SYSINIT:499E                 pop     cx
SYSINIT:499F                 retn
SYSINIT:499F copy_envvar     endp
SYSINIT:499F
SYSINIT:49A0
SYSINIT:49A0 ; =============== S U B R O U T I N E =======================================
SYSINIT:49A0
SYSINIT:49A0
SYSINIT:49A0 copy_block      proc near               ; CODE XREF: menu_check+2A1↑p
SYSINIT:49A0                                         ; copy_block+3B↓p ...
SYSINIT:49A0                 call    get_char        ; copy the current block to the new config.sys workspace
SYSINIT:49A0                                         ;
SYSINIT:49A0                                         ; CX == remaining bytes in "organized" config.sys memory image
SYSINIT:49A0                                         ; ES:SI -> remaining bytes in "organized" config.sys memory image
SYSINIT:49A0                                         ; DS:DI -> new config.sys workspace (equal in size to the original
SYSINIT:49A0                                         ;        config.sys image) where the current block is to be copied
SYSINIT:49A0                                         ;
SYSINIT:49A0                                         ; check for include
SYSINIT:49A3                 jb      short copy_done
SYSINIT:49A5                 and     al, 7Fh         ; ~CONFIG_OPTION_QUERY
SYSINIT:49A7                 cmp     al, 5Bh ; '['   ; CONFIG_BEGIN
SYSINIT:49A7                                         ; another BEGIN implies END as well
SYSINIT:49A9                 jz      short copy_done
SYSINIT:49AB                 cmp     al, 4Ah ; 'J'   ; CONFIG_INCLUDE ; 'J'
SYSINIT:49AD                 mov     al, ah          ; AL == the original line code
SYSINIT:49AF                 jnz     short copy_line ; not an "include" line
SYSINIT:49AF                                         ;
SYSINIT:49AF                                         ; We have hit an "INCLUDE" line; first, REM out the line
SYSINIT:49AF                                         ; so that we never try to include the block again
SYSINIT:49AF                                         ; (no infinite include loops please), then search for
SYSINIT:49AF                                         ; the named block and call copy_block again.
SYSINIT:49B1                 mov     byte ptr es:[si-1], 30h ; '0' ; CONFIG_REM
SYSINIT:49B6                 push    di
SYSINIT:49B7                 mov     di, offset szMenu ; "MENU"
SYSINIT:49BA                 call    comp_names_safe ; don't allow INCLUDE MENU
SYSINIT:49BD                 jz      short copy_skip
SYSINIT:49BF                 mov     di, offset szCommon ; "COMMON"
SYSINIT:49C2                 call    comp_names_safe ; don't allow INCLUDE COMMON
SYSINIT:49C5                 jz      short copy_skip
SYSINIT:49C7                 mov     di, si          ; try to find the block
SYSINIT:49C9                 call    srch_block
SYSINIT:49CC                 mov     dx, di
SYSINIT:49CE                 pop     di
SYSINIT:49CF                 jnz     short copy_error ; no such block
SYSINIT:49D1                 push    cx
SYSINIT:49D2                 mov     cx, bx
SYSINIT:49D4                 push    si
SYSINIT:49D5                 dec     dx
SYSINIT:49D6                 mov     si, dx
SYSINIT:49D8                 call    skip_line       ; skip the rest of the "block name" line
SYSINIT:49DB                 call    copy_block      ; and copy in the rest of that block
SYSINIT:49DE                 pop     si
SYSINIT:49DF                 pop     cx
SYSINIT:49E0                 sub     al, al          ; force skip_opt_line to skip...
SYSINIT:49E2                 jmp     short copy_nextline
SYSINIT:49E4 ; ---------------------------------------------------------------------------
SYSINIT:49E4
SYSINIT:49E4 copy_skip:                              ; CODE XREF: copy_block+1D↑j
SYSINIT:49E4                                         ; copy_block+25↑j
SYSINIT:49E4                 pop     di
SYSINIT:49E5
SYSINIT:49E5 copy_error:                             ; CODE XREF: copy_block+2F↑j
SYSINIT:49E5                 clc
SYSINIT:49E6                 call    print_error     ; note that carry is clear, no pause
SYSINIT:49E9                 jmp     short copy_nextline
SYSINIT:49EB ; ---------------------------------------------------------------------------
SYSINIT:49EB
SYSINIT:49EB copy_line:                              ; CODE XREF: copy_block+F↑j
SYSINIT:49EB                 mov     [di], al        ; Copy the line at ES:SI
SYSINIT:49EB                                         ;  to the current location at DS:DI
SYSINIT:49ED                 inc     di
SYSINIT:49EE                 cmp     al, 20h ; ' '   ; is this is a "real" line with a "real" code?
SYSINIT:49F0                 jb      short copy_nextline ; no
SYSINIT:49F2                 cmp     cs:config_multi, 0
SYSINIT:49F8                 jz      short copy_loop ; not a multi-config config.sys, don't embed #s
SYSINIT:49FA                 call    get_linenum     ; BX == line # of line @ES:SI
SYSINIT:49FD                 mov     [di], bx        ; stash it immediately following the line code
SYSINIT:49FF                 inc     di
SYSINIT:4A00                 inc     di
SYSINIT:4A01                 jmp     short copy_next
SYSINIT:4A03 ; ---------------------------------------------------------------------------
SYSINIT:4A03
SYSINIT:4A03 copy_loop:                              ; CODE XREF: copy_block+58↑j
SYSINIT:4A03                                         ; copy_block+6D↓j
SYSINIT:4A03                 call    get_char
SYSINIT:4A06                 jb      short copy_done ; end of file
SYSINIT:4A08                 mov     [di], al
SYSINIT:4A0A                 inc     di
SYSINIT:4A0B
SYSINIT:4A0B copy_next:                              ; CODE XREF: copy_block+61↑j
SYSINIT:4A0B                 cmp     al, 0Ah         ; lf ; done with line?
SYSINIT:4A0D                 jnz     short copy_loop ; nope
SYSINIT:4A0F
SYSINIT:4A0F copy_nextline:                          ; CODE XREF: copy_block+42↑j
SYSINIT:4A0F                                         ; copy_block+49↑j ...
SYSINIT:4A0F                 call    skip_opt_line
SYSINIT:4A12                 jmp     short copy_block
SYSINIT:4A14 ; ---------------------------------------------------------------------------
SYSINIT:4A14
SYSINIT:4A14 copy_done:                              ; CODE XREF: copy_block+3↑j
SYSINIT:4A14                                         ; copy_block+9↑j ...
SYSINIT:4A14                 retn
SYSINIT:4A14 copy_block      endp
SYSINIT:4A14
SYSINIT:4A15
SYSINIT:4A15 ; =============== S U B R O U T I N E =======================================
SYSINIT:4A15
SYSINIT:4A15
SYSINIT:4A15 get_linenum     proc near               ; CODE XREF: copy_block+5A↑p
SYSINIT:4A15                                         ; print_error+8↓p
SYSINIT:4A15                 push    ax              ; return line # (in BX) of current line (@ES:SI)
SYSINIT:4A16                 sub     bx, bx          ; BX == line # (to be returned)
SYSINIT:4A18                 push    cx
SYSINIT:4A19                 mov     dx, si          ; DX == the offset we're looking for
SYSINIT:4A1B                 push    si
SYSINIT:4A1C                 mov     cx, cs:count
SYSINIT:4A21                 sub     si, si          ; prepare to scan entire file
SYSINIT:4A23
SYSINIT:4A23 get_linenum_loop:                       ; CODE XREF: get_linenum+16↓j
SYSINIT:4A23                 call    skip_line
SYSINIT:4A26                 jb      short get_linenum_done
SYSINIT:4A28                 inc     bx
SYSINIT:4A29                 cmp     si, dx          ; have we exceeded the desired offset yet?
SYSINIT:4A2B                 jb      short get_linenum_loop ; no
SYSINIT:4A2D
SYSINIT:4A2D get_linenum_done:                       ; CODE XREF: get_linenum+11↑j
SYSINIT:4A2D                 pop     si
SYSINIT:4A2E                 pop     cx
SYSINIT:4A2F                 pop     ax
SYSINIT:4A30                 retn
SYSINIT:4A30 get_linenum     endp
SYSINIT:4A30
SYSINIT:4A31
SYSINIT:4A31 ; =============== S U B R O U T I N E =======================================
SYSINIT:4A31
SYSINIT:4A31
SYSINIT:4A31 srch_block      proc near               ; CODE XREF: menu_check+12D↑p
SYSINIT:4A31                                         ; menu_check+27F↑p ...
SYSINIT:4A31                 push    ax              ; searches entire config.sys
SYSINIT:4A31                                         ; for block name @ES:DI
SYSINIT:4A32                 push    cx
SYSINIT:4A33                 mov     cx, cs:count
SYSINIT:4A38                 push    si
SYSINIT:4A39                 sub     si, si
SYSINIT:4A3B                 push    ds
SYSINIT:4A3C                 push    es
SYSINIT:4A3D                 pop     ds
SYSINIT:4A3E                 call    find_block
SYSINIT:4A41                 mov     di, si          ; ES:DI -> just past the name in the block heading, if found
SYSINIT:4A43                 mov     bx, cx          ; BX == # bytes remaining from that point, if found
SYSINIT:4A45                 pop     ds
SYSINIT:4A46                 pop     si
SYSINIT:4A47                 pop     cx
SYSINIT:4A48                 pop     ax
SYSINIT:4A49                 retn
SYSINIT:4A49 srch_block      endp
SYSINIT:4A49
SYSINIT:4A4A
SYSINIT:4A4A ; =============== S U B R O U T I N E =======================================
SYSINIT:4A4A
SYSINIT:4A4A
SYSINIT:4A4A find_block      proc near               ; CODE XREF: menu_check+6B↑p
SYSINIT:4A4A                                         ; srch_block+D↑p ...
SYSINIT:4A4A                 call    get_char        ; searches rest of config.sys for block name @DS:DI
SYSINIT:4A4A                                         ; get line code
SYSINIT:4A4D                 jb      short find_exit ; end of file
SYSINIT:4A4F                 and     al, 7Fh         ; ~CONFIG_OPTION_QUERY
SYSINIT:4A51                 cmp     al, 5Bh ; '['   ; CONFIG_BEGIN ; beginning of a block?
SYSINIT:4A53                 jz      short check_line ; no
SYSINIT:4A55                 cmp     al, 4Ah ; 'J'   ; CONFIG_INCLUDE
SYSINIT:4A57                 jnz     short next_line
SYSINIT:4A59                 or      cs:config_multi, 1
SYSINIT:4A5F                 jmp     short next_line
SYSINIT:4A61 ; ---------------------------------------------------------------------------
SYSINIT:4A61
SYSINIT:4A61 check_line:                             ; CODE XREF: find_block+9↑j
SYSINIT:4A61                 or      cs:config_multi, 1
SYSINIT:4A67                 call    comp_names      ; compare block names
SYSINIT:4A6A                 jbe     short find_exit ; end of file, or names matched
SYSINIT:4A6C
SYSINIT:4A6C next_line:                              ; CODE XREF: find_block+D↑j
SYSINIT:4A6C                                         ; find_block+15↑j
SYSINIT:4A6C                 call    skip_opt_line   ; no, so skip to next line
SYSINIT:4A6F                 jmp     short find_block
SYSINIT:4A71 ; ---------------------------------------------------------------------------
SYSINIT:4A71
SYSINIT:4A71 find_exit:                              ; CODE XREF: find_block+3↑j
SYSINIT:4A71                                         ; find_block+20↑j
SYSINIT:4A71                 retn
SYSINIT:4A71 find_block      endp
SYSINIT:4A71
SYSINIT:4A72
SYSINIT:4A72 ; =============== S U B R O U T I N E =======================================
SYSINIT:4A72
SYSINIT:4A72
SYSINIT:4A72 comp_names      proc near               ; CODE XREF: menu_check+186↑p
SYSINIT:4A72                                         ; menu_check+2B1↑p ...
SYSINIT:4A72                 push    di              ; compares keyword @DS:DI
SYSINIT:4A72                                         ;  to position in config.sys @ES:SI
SYSINIT:4A73
SYSINIT:4A73 comp_loop:                              ; CODE XREF: comp_names+13↓j
SYSINIT:4A73                 call    get_char
SYSINIT:4A76                 jb      short comp_exit
SYSINIT:4A78                 call    any_delim       ; is next character a delimiter?
SYSINIT:4A7B                 mov     ah, [di]        ; (get next character we're supposed to match)
SYSINIT:4A7D                 jz      short comp_almost ; yes, it *could* be a match
SYSINIT:4A7F                 inc     di
SYSINIT:4A80                 and     ax, 0DFDFh      ; ~2020h
SYSINIT:4A83                 cmp     al, ah          ; match?
SYSINIT:4A85                 jz      short comp_loop ; yes, keep looking at the characters
SYSINIT:4A87                 clc                     ; prevent erroneous eof indication: clear carry
SYSINIT:4A88
SYSINIT:4A88 comp_exit:                              ; CODE XREF: comp_names+4↑j
SYSINIT:4A88                                         ; comp_names+1F↓j
SYSINIT:4A88                 pop     di
SYSINIT:4A89                 retn
SYSINIT:4A8A ; ---------------------------------------------------------------------------
SYSINIT:4A8A
SYSINIT:4A8A comp_almost:                            ; CODE XREF: comp_names+B↑j
SYSINIT:4A8A                 xchg    al, ah          ; we don't know for sure if it's a match
SYSINIT:4A8C                 call    any_delim       ; until we verify that the second string
SYSINIT:4A8F                 xchg    al, ah          ; has been exhausted also...
SYSINIT:4A91                 jmp     short comp_exit ; if we are, this call to any_delim will tell...
SYSINIT:4A91 comp_names      endp
SYSINIT:4A91
SYSINIT:4A93
SYSINIT:4A93 ; =============== S U B R O U T I N E =======================================
SYSINIT:4A93
SYSINIT:4A93
SYSINIT:4A93 comp_names_safe proc near               ; CODE XREF: copy_block+1A↑p
SYSINIT:4A93                                         ; copy_block+22↑p
SYSINIT:4A93                 push    ax
SYSINIT:4A94                 push    cx
SYSINIT:4A95                 push    si
SYSINIT:4A96                 push    ds
SYSINIT:4A97                 push    cs
SYSINIT:4A98                 pop     ds
SYSINIT:4A99                 assume ds:SYSINIT
SYSINIT:4A99                 call    comp_names
SYSINIT:4A9C                 pop     ds
SYSINIT:4A9D                 assume ds:nothing
SYSINIT:4A9D                 pop     si
SYSINIT:4A9E                 pop     cx
SYSINIT:4A9F                 pop     ax
SYSINIT:4AA0                 retn
SYSINIT:4AA0 comp_names_safe endp
SYSINIT:4AA0
SYSINIT:4AA1
SYSINIT:4AA1 ; =============== S U B R O U T I N E =======================================
SYSINIT:4AA1
SYSINIT:4AA1
SYSINIT:4AA1 print_item      proc near               ; CODE XREF: menu_check:menu_disploop↑p
SYSINIT:4AA1                                         ; select_item+BC↓p ...
SYSINIT:4AA1                 push    ax              ; display menu item #BL
SYSINIT:4AA2                 push    bx
SYSINIT:4AA3                 push    cx
SYSINIT:4AA4                 push    dx
SYSINIT:4AA5                 push    si
SYSINIT:4AA6                 mov     ah, 3           ; get cursor position
SYSINIT:4AA8                 mov     bh, ds:bMenuPage ; always page zero
SYSINIT:4AAC                 int     10h             ; - VIDEO - READ CURSOR POSITION
SYSINIT:4AAC                                         ; BH = page number
SYSINIT:4AAC                                         ; Return: DH,DL = row,column, CH = cursor start line, CL = cursor end line
SYSINIT:4AAE                 push    dx
SYSINIT:4AAF                 mov     ah, 2           ; set cursor position for correct row/col
SYSINIT:4AB1                 mov     dh, bl
SYSINIT:4AB3                 add     dh, 3
SYSINIT:4AB6                 mov     dl, 5
SYSINIT:4AB8                 int     10h             ; - VIDEO - SET CURSOR POSITION
SYSINIT:4AB8                                         ; DH,DL = row, column (0,0 = upper left)
SYSINIT:4AB8                                         ; BH = page number
SYSINIT:4ABA                 mov     al, bl
SYSINIT:4ABC                 add     al, 30h ; '0'   ; convert menu item # to ASCII digit
SYSINIT:4ABE                 mov     ah, ds:bMenuColor ; normal attribute
SYSINIT:4AC2                 cmp     bl, ds:bDefBlock ; are we printing the current block?
SYSINIT:4AC6                 jnz     short print_other ; no
SYSINIT:4AC8                 or      ah, 70h         ; yes, set bgnd color to white
SYSINIT:4ACB                 mov     ch, ah
SYSINIT:4ACD                 mov     cl, 4
SYSINIT:4ACF                 rol     ch, cl
SYSINIT:4AD1                 cmp     ch, ah          ; are fgnd/bgnd the same?
SYSINIT:4AD3                 jnz     short print_other ; no
SYSINIT:4AD5                 xor     ah, 8           ; yes, so modify the fgnd intensity
SYSINIT:4AD8
SYSINIT:4AD8 print_other:                            ; CODE XREF: print_item+25↑j
SYSINIT:4AD8                                         ; print_item+32↑j
SYSINIT:4AD8                 mov     bh, 0
SYSINIT:4ADA                 add     bx, bx
SYSINIT:4ADC                 mov     di, ds:aoffBlockDesc[bx]
SYSINIT:4AE0                 mov     bl, ah          ; put the attribute in the correct register now
SYSINIT:4AE2                 mov     bh, ds:bMenuPage ; get correct video page #
SYSINIT:4AE6                 mov     ah, 9           ; write char/attr
SYSINIT:4AE8                 mov     cx, 1
SYSINIT:4AEB                 int     10h             ; - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION
SYSINIT:4AEB                                         ; AL = character, BH = display page
SYSINIT:4AEB                                         ; BL = attributes of character (alpha modes) or color (graphics modes)
SYSINIT:4AEB                                         ; CX = number of times to write character
SYSINIT:4AED                 inc     dl              ; increment column
SYSINIT:4AEF                 mov     ah, 2
SYSINIT:4AF1                 int     10h             ; - VIDEO - SET CURSOR POSITION
SYSINIT:4AF1                                         ; DH,DL = row, column (0,0 = upper left)
SYSINIT:4AF1                                         ; BH = page number
SYSINIT:4AF3                 mov     ax, 92Eh        ; display '.'
SYSINIT:4AF6                 int     10h             ; - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION
SYSINIT:4AF6                                         ; AL = character, BH = display page
SYSINIT:4AF6                                         ; BL = attributes of character (alpha modes) or color (graphics modes)
SYSINIT:4AF6                                         ; CX = number of times to write character
SYSINIT:4AF8                 inc     dl              ; increment column
SYSINIT:4AFA                 mov     ah, 2
SYSINIT:4AFC                 int     10h             ; - VIDEO - SET CURSOR POSITION
SYSINIT:4AFC                                         ; DH,DL = row, column (0,0 = upper left)
SYSINIT:4AFC                                         ; BH = page number
SYSINIT:4AFE                 mov     ax, 920h        ; display ' '
SYSINIT:4B01                 int     10h             ; - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION
SYSINIT:4B01                                         ; AL = character, BH = display page
SYSINIT:4B01                                         ; BL = attributes of character (alpha modes) or color (graphics modes)
SYSINIT:4B01                                         ; CX = number of times to write character
SYSINIT:4B03                 inc     dl              ; increment column
SYSINIT:4B05                 mov     ah, 2
SYSINIT:4B07                 int     10h             ; - VIDEO - SET CURSOR POSITION
SYSINIT:4B07                                         ; DH,DL = row, column (0,0 = upper left)
SYSINIT:4B07                                         ; BH = page number
SYSINIT:4B09                 push    es
SYSINIT:4B0A
SYSINIT:4B0A print_loop:                             ; CODE XREF: print_item+8A↓j
SYSINIT:4B0A                 mov     al, es:[di]     ; get a character of the description
SYSINIT:4B0D                 inc     di
SYSINIT:4B0E                 cmp     al, 9           ; TAB ; substitute spaces for tabs
SYSINIT:4B10                 jnz     short print_nontab
SYSINIT:4B12                 mov     al, 20h ; ' '
SYSINIT:4B14
SYSINIT:4B14 print_nontab:                           ; CODE XREF: print_item+6F↑j
SYSINIT:4B14                 cmp     al, 20h ; ' '
SYSINIT:4B16                 jb      short print_done ; stop at the 1st character < space
SYSINIT:4B18                 cmp     al, 24h ; '$'
SYSINIT:4B1A                 jz      short print_done ; also stop on $
SYSINIT:4B1C                 mov     ah, 9
SYSINIT:4B1E                 int     10h             ; - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION
SYSINIT:4B1E                                         ; AL = character, BH = display page
SYSINIT:4B1E                                         ; BL = attributes of character (alpha modes) or color (graphics modes)
SYSINIT:4B1E                                         ; CX = number of times to write character
SYSINIT:4B20                 inc     dl              ; increment column
SYSINIT:4B22                 cmp     dl, 78          ; far enough?
SYSINIT:4B25                 jnb     short print_done ; yes
SYSINIT:4B27                 mov     ah, 2
SYSINIT:4B29                 int     10h             ; - VIDEO - SET CURSOR POSITION
SYSINIT:4B29                                         ; DH,DL = row, column (0,0 = upper left)
SYSINIT:4B29                                         ; BH = page number
SYSINIT:4B2B                 jmp     short print_loop
SYSINIT:4B2D ; ---------------------------------------------------------------------------
SYSINIT:4B2D
SYSINIT:4B2D print_done:                             ; CODE XREF: print_item+75↑j
SYSINIT:4B2D                                         ; print_item+79↑j ...
SYSINIT:4B2D                 pop     es
SYSINIT:4B2E                 pop     dx
SYSINIT:4B2F                 mov     ah, 2           ; restore previous row/col
SYSINIT:4B31                 int     10h             ; - VIDEO - SET CURSOR POSITION
SYSINIT:4B31                                         ; DH,DL = row, column (0,0 = upper left)
SYSINIT:4B31                                         ; BH = page number
SYSINIT:4B33                 pop     si
SYSINIT:4B34                 pop     dx
SYSINIT:4B35                 pop     cx
SYSINIT:4B36                 pop     bx
SYSINIT:4B37                 pop     ax
SYSINIT:4B38                 retn
SYSINIT:4B38 print_item      endp
SYSINIT:4B38
SYSINIT:4B39
SYSINIT:4B39 ; =============== S U B R O U T I N E =======================================
SYSINIT:4B39
SYSINIT:4B39
SYSINIT:4B39 select_item     proc near               ; CODE XREF: menu_check+23E↑p
SYSINIT:4B39                 mov     bl, ds:bDefBlock ; wait for user to select menu item, with time-out
SYSINIT:4B39                                         ;
SYSINIT:4B39                                         ; returns digit value in BX (trashes AX/CX/DX)
SYSINIT:4B3D                 mov     al, bl          ; BL will be the default block #
SYSINIT:4B3F                 call    disp_num
SYSINIT:4B42                 call    show_status     ; display current interactive status
SYSINIT:4B45                 cmp     ds:secTimeOut, 0FFh ; -1
SYSINIT:4B4A                 jz      short input_key ; no time-out, just go to input
SYSINIT:4B4C                 mov     ah, 2Ch         ; GET_TIME
SYSINIT:4B4E                 int     21h             ; DOS - GET CURRENT TIME
SYSINIT:4B4E                                         ; Return: CH = hours, CL = minutes, DH = seconds
SYSINIT:4B4E                                         ; DL = hundredths of seconds
SYSINIT:4B4E                                         ; ;
SYSINIT:4B50                 mov     bh, dh          ; BH = initial # of seconds
SYSINIT:4B52
SYSINIT:4B52 check_time:                             ; CODE XREF: select_item+8A↓j
SYSINIT:4B52                 mov     al, ds:secTimeOut
SYSINIT:4B55                 sub     al, ds:secElapsed
SYSINIT:4B59                 jnb     short show_time
SYSINIT:4B5B                 or      ds:bQueryOpt, 2 ; disable all further prompting
SYSINIT:4B60                 mov     ds:secElapsed, 0
SYSINIT:4B65                 jmp     select_done     ; time's up!
SYSINIT:4B68 ; ---------------------------------------------------------------------------
SYSINIT:4B68
SYSINIT:4B68 show_time:                              ; CODE XREF: select_item+20↑j
SYSINIT:4B68                 push    bx
SYSINIT:4B69                 mov     bl, al          ; save # in BL
SYSINIT:4B6B                 mov     bh, ds:bMenuPage
SYSINIT:4B6F                 mov     ah, 3
SYSINIT:4B71                 int     10h             ; - VIDEO - READ CURSOR POSITION
SYSINIT:4B71                                         ; BH = page number
SYSINIT:4B71                                         ; Return: DH,DL = row,column, CH = cursor start line, CL = cursor end line
SYSINIT:4B73                 push    dx
SYSINIT:4B74                 add     dl, 8           ; move cursor to the right
SYSINIT:4B77                 mov     ah, 2
SYSINIT:4B79                 int     10h             ; - VIDEO - SET CURSOR POSITION
SYSINIT:4B79                                         ; DH,DL = row, column (0,0 = upper left)
SYSINIT:4B79                                         ; BH = page number
SYSINIT:4B7B                 mov     dx, offset _$TimeOut ; "Time remaining: $"
SYSINIT:4B7E                 call    print           ; print the "Time remaining: " prompt
SYSINIT:4B81                 mov     al, bl          ; recover # from BL
SYSINIT:4B83                 cbw                     ; this works because AL is always <= 90
SYSINIT:4B84                 mov     cl, 10
SYSINIT:4B86                 div     cl              ; AL = tens digit, AH = ones digit
SYSINIT:4B88                 mov     cl, ah
SYSINIT:4B8A                 add     al, '0'         ; write TTY tens digit
SYSINIT:4B8C                 mov     ah, 0Eh
SYSINIT:4B8E                 int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
SYSINIT:4B8E                                         ; AL = character, BH = display page (alpha modes)
SYSINIT:4B8E                                         ; BL = foreground color (graphics modes)
SYSINIT:4B90                 mov     al, cl
SYSINIT:4B92                 add     al, '0'         ; write TTY ones digit
SYSINIT:4B94                 mov     ah, 0Eh
SYSINIT:4B96                 int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
SYSINIT:4B96                                         ; AL = character, BH = display page (alpha modes)
SYSINIT:4B96                                         ; BL = foreground color (graphics modes)
SYSINIT:4B98                 pop     dx
SYSINIT:4B99                 mov     ah, 2           ; set cursor position back to where it was
SYSINIT:4B9B                 int     10h             ; - VIDEO - SET CURSOR POSITION
SYSINIT:4B9B                                         ; DH,DL = row, column (0,0 = upper left)
SYSINIT:4B9B                                         ; BH = page number
SYSINIT:4B9D                 pop     bx
SYSINIT:4B9E
SYSINIT:4B9E input_key:                              ; CODE XREF: select_item+11↑j
SYSINIT:4B9E                                         ; select_item+72↓j ...
SYSINIT:4B9E                 mov     ah, 6           ; RAW_CON_IO
SYSINIT:4BA0                 mov     dl, 0FFh        ; input request
SYSINIT:4BA2                 int     21h             ; DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
SYSINIT:4BA2                                         ; DL = character <> FFh
SYSINIT:4BA2                                         ;  Return: ZF set = no character
SYSINIT:4BA2                                         ;   ZF clear = character recieved, AL = character
SYSINIT:4BA4                 jnz     short got_key
SYSINIT:4BA6                 cmp     ds:secTimeOut, 0FFh ; -1 ; is there a time-out?
SYSINIT:4BAB                 jz      short input_key ; no, just go back to input
SYSINIT:4BAD                 mov     ah, 2Ch         ; GET_TIME
SYSINIT:4BAF                 int     21h             ; DOS - GET CURRENT TIME
SYSINIT:4BAF                                         ; Return: CH = hours, CL = minutes, DH = seconds
SYSINIT:4BAF                                         ; DL = hundredths of seconds
SYSINIT:4BB1                 mov     ah, dh
SYSINIT:4BB3                 sub     dh, bh          ; should generally be zero or one
SYSINIT:4BB5                 mov     bh, ah
SYSINIT:4BB7                 jnb     short got_time
SYSINIT:4BB9                 mov     dh, 1           ; it wrapped back to zero, so assume one
SYSINIT:4BBB
SYSINIT:4BBB got_time:                               ; CODE XREF: select_item+7E↑j
SYSINIT:4BBB                 or      dh, dh          ; any change?
SYSINIT:4BBD                 jz      short input_key ; no
SYSINIT:4BBF                 add     ds:secElapsed, dh
SYSINIT:4BC3                 jmp     short check_time
SYSINIT:4BC5 ; ---------------------------------------------------------------------------
SYSINIT:4BC5
SYSINIT:4BC5 got_key:                                ; CODE XREF: select_item+6B↑j
SYSINIT:4BC5                 push    ax
SYSINIT:4BC6                 mov     ax, 0FFFFh      ; -1 ; zap both secTimeOut and secElapsed
SYSINIT:4BC9                 xchg    ax, word ptr ds:secTimeOut
SYSINIT:4BCD                 cmp     al, 0FFh        ; -1 ; was time-out already disabled?
SYSINIT:4BCF                 jz      short timeout_disabled ; yes
SYSINIT:4BD1                 push    bx              ; let's disable # seconds display
SYSINIT:4BD2                 mov     ax, 0A20h       ; write multiple spaces
SYSINIT:4BD5                 mov     bx, word ptr ds:bMenuColor
SYSINIT:4BD9                 mov     cx, 80          ; 80 of them, to be safe
SYSINIT:4BD9                                         ; to completely obliterate # seconds display
SYSINIT:4BDC                 int     10h             ; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
SYSINIT:4BDC                                         ; AL = character, BH = display page - alpha mode
SYSINIT:4BDC                                         ; BL = color of character (graphics mode, PCjr only)
SYSINIT:4BDC                                         ; CX = number of times to write character
SYSINIT:4BDE                 pop     bx
SYSINIT:4BDF
SYSINIT:4BDF timeout_disabled:                       ; CODE XREF: select_item+96↑j
SYSINIT:4BDF                 pop     ax
SYSINIT:4BE0                 or      al, al          ; extended key pressed?
SYSINIT:4BE2                 jnz     short normal_key ; no
SYSINIT:4BE4                 int     21h             ; get the next part of the key then
SYSINIT:4BE6                 jz      short input_key ; what happened to the second part!?
SYSINIT:4BE8                 cmp     al, 48h         ; up arrow?
SYSINIT:4BEA                 jnz     short not_up    ; no
SYSINIT:4BEC                 cmp     bl, 1           ; are we as up as up can get?
SYSINIT:4BEF                 jbe     short input_key ; yes, ignore it
SYSINIT:4BF1                 dec     ds:bDefBlock
SYSINIT:4BF5                 call    print_item      ; re-print the current item
SYSINIT:4BF8                 dec     bl              ; and then print the new current item
SYSINIT:4BFA                 jmp     short print1
SYSINIT:4BFC ; ---------------------------------------------------------------------------
SYSINIT:4BFC
SYSINIT:4BFC not_up:                                 ; CODE XREF: select_item+B1↑j
SYSINIT:4BFC                 cmp     al, 50h ; 'P'   ; down arrow?
SYSINIT:4BFE                 jnz     short not_down  ; no
SYSINIT:4C00                 cmp     bl, ds:bMaxBlock ; are we as down as down can get?
SYSINIT:4C04                 jnb     short to_input_key ; yes, ignore it
SYSINIT:4C06                 inc     ds:bDefBlock
SYSINIT:4C0A                 call    print_item      ; re-print the current item
SYSINIT:4C0D                 inc     bx              ; and then print the new current item
SYSINIT:4C0E
SYSINIT:4C0E print1:                                 ; CODE XREF: select_item+C1↑j
SYSINIT:4C0E                 mov     al, bl
SYSINIT:4C10
SYSINIT:4C10 print2:                                 ; CODE XREF: select_item+123↓j
SYSINIT:4C10                 call    print_item
SYSINIT:4C13                 call    disp_num
SYSINIT:4C16
SYSINIT:4C16 to_input_key:                           ; CODE XREF: select_item+CB↑j
SYSINIT:4C16                                         ; select_item+E4↓j ...
SYSINIT:4C16                 jmp     short input_key
SYSINIT:4C18 ; ---------------------------------------------------------------------------
SYSINIT:4C18
SYSINIT:4C18 not_down:                               ; CODE XREF: select_item+C5↑j
SYSINIT:4C18                 test    ds:bDisableUI, 1
SYSINIT:4C1D                 jnz     short to_input_key ; don't allow F8 or F5
SYSINIT:4C1F                 cmp     al, 42h         ; F8 function key?
SYSINIT:4C21                 jnz     short not_f8    ; no
SYSINIT:4C23                 xor     ds:bQueryOpt, 1
SYSINIT:4C28                 call    show_status
SYSINIT:4C2B                 jmp     input_key
SYSINIT:4C2E ; ---------------------------------------------------------------------------
SYSINIT:4C2E
SYSINIT:4C2E not_f8:                                 ; CODE XREF: select_item+E8↑j
SYSINIT:4C2E                 cmp     al, 3Fh         ; F5 function key?
SYSINIT:4C30                 jnz     short to_input_key ; no
SYSINIT:4C32                 or      ds:bQueryOpt, 4 ; no more queries
SYSINIT:4C37                 mov     bx, 0FFFFh      ; special return code (-1) indicating clean boot
SYSINIT:4C3A                 mov     al, 20h ; ' '   ; don't want to display anything really;
SYSINIT:4C3C                 jmp     short disp_input
SYSINIT:4C3E ; ---------------------------------------------------------------------------
SYSINIT:4C3E
SYSINIT:4C3E normal_key:                             ; CODE XREF: select_item+A9↑j
SYSINIT:4C3E                 cmp     al, 0Dh         ; Enter?
SYSINIT:4C40                 jz      short select_done ; yes
SYSINIT:4C42                 cmp     al, 8           ; backspace?
SYSINIT:4C44                 jnz     short not_backspace ; no
SYSINIT:4C46                 mov     bx, 0FFFEh      ; -2 ; yes, special return code
SYSINIT:4C49                 retn
SYSINIT:4C4A ; ---------------------------------------------------------------------------
SYSINIT:4C4A
SYSINIT:4C4A not_backspace:                          ; CODE XREF: select_item+10B↑j
SYSINIT:4C4A                 sub     al, 30h ; '0'   ; is greater than '0'?
SYSINIT:4C4C                 jbe     short to_input_key ; no
SYSINIT:4C4E                 cmp     al, ds:bMaxBlock ; is less than or equal to the maximum digit?
SYSINIT:4C52                 ja      short to_input_key ; no
SYSINIT:4C54                 mov     ds:bDefBlock, al
SYSINIT:4C57                 call    print_item      ; redisplay the current selection
SYSINIT:4C5A                 mov     bl, al          ; set new selection
SYSINIT:4C5C                 jmp     short print2
SYSINIT:4C5E ; ---------------------------------------------------------------------------
SYSINIT:4C5E
SYSINIT:4C5E select_done:                            ; CODE XREF: select_item+2C↑j
SYSINIT:4C5E                                         ; select_item+107↑j
SYSINIT:4C5E                 mov     bh, 0           ; return a full 16-bit value (for indexing)
SYSINIT:4C60                 mov     al, bl
SYSINIT:4C62                 add     al, 30h ; '0'   ; convert it into a digit, then display it
SYSINIT:4C62 select_item     endp
SYSINIT:4C62
SYSINIT:4C64
SYSINIT:4C64 ; =============== S U B R O U T I N E =======================================
SYSINIT:4C64
SYSINIT:4C64
SYSINIT:4C64 disp_input      proc near               ; CODE XREF: select_item+103↑j
SYSINIT:4C64                                         ; query_user:legal_char↓p
SYSINIT:4C64                 push    ax
SYSINIT:4C65                 cmp     al, 20h ; ' '
SYSINIT:4C67                 jnb     short disp_ok
SYSINIT:4C69                 mov     al, 20h ; ' '
SYSINIT:4C6B
SYSINIT:4C6B disp_ok:                                ; CODE XREF: disp_input+3↑j
SYSINIT:4C6B                 mov     dl, al
SYSINIT:4C6D                 mov     ah, 2           ; STD_CON_OUTPUT
SYSINIT:4C6F                 int     21h             ; DOS - DISPLAY OUTPUT
SYSINIT:4C6F                                         ; DL = character to send to standard output
SYSINIT:4C71                 mov     dx, offset crlfm ; "\r\n$"
SYSINIT:4C74                 call    print
SYSINIT:4C77                 pop     ax
SYSINIT:4C78                 retn
SYSINIT:4C78 disp_input      endp
SYSINIT:4C78
SYSINIT:4C79
SYSINIT:4C79 ; =============== S U B R O U T I N E =======================================
SYSINIT:4C79
SYSINIT:4C79
SYSINIT:4C79 disp_num        proc near               ; CODE XREF: select_item+6↑p
SYSINIT:4C79                                         ; select_item+DA↑p
SYSINIT:4C79                 push    bx              ; display a single character + cr/lf
SYSINIT:4C7A                 add     al, '0'
SYSINIT:4C7C                 mov     ah, 0Ah
SYSINIT:4C7E                 mov     bx, word ptr ds:bMenuColor
SYSINIT:4C82                 mov     cx, 1
SYSINIT:4C85                 int     10h             ; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
SYSINIT:4C85                                         ; AL = character, BH = display page - alpha mode
SYSINIT:4C85                                         ; BL = color of character (graphics mode, PCjr only)
SYSINIT:4C85                                         ; CX = number of times to write character
SYSINIT:4C87                 pop     bx
SYSINIT:4C88                 retn
SYSINIT:4C88 disp_num        endp
SYSINIT:4C88
SYSINIT:4C89
SYSINIT:4C89 ; =============== S U B R O U T I N E =======================================
SYSINIT:4C89
SYSINIT:4C89
SYSINIT:4C89 show_status     proc near               ; CODE XREF: menu_check+250↑p
SYSINIT:4C89                                         ; select_item+9↑p ...
SYSINIT:4C89                 push    bx              ; display current interactive mode setting (on/off/none)
SYSINIT:4C8A                 mov     bx, word ptr ds:bMenuColor
SYSINIT:4C8E                 mov     ah, 3
SYSINIT:4C90                 int     10h             ; - VIDEO - READ CURSOR POSITION
SYSINIT:4C90                                         ; BH = page number
SYSINIT:4C90                                         ; Return: DH,DL = row,column, CH = cursor start line, CL = cursor end line
SYSINIT:4C92                 push    dx
SYSINIT:4C93                 mov     ah, 2
SYSINIT:4C95                 mov     dx, word ptr ds:bLastCol ; set correct row/col
SYSINIT:4C99                 test    ds:bDisableUI, 1
SYSINIT:4C9E                 jz      short show_onoff ; just show on/off
SYSINIT:4CA0                 mov     dl, 0
SYSINIT:4CA2                 int     10h             ; - VIDEO - SET CURSOR POSITION
SYSINIT:4CA2                                         ; DH,DL = row, column (0,0 = upper left)
SYSINIT:4CA2                                         ; BH = page number
SYSINIT:4CA4                 mov     ax, 0A20h       ; write multiple spaces
SYSINIT:4CA7                 mov     cx, 80          ; 80 of them, to be exact to obliterate the status line
SYSINIT:4CAA                 int     10h             ; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
SYSINIT:4CAA                                         ; AL = character, BH = display page - alpha mode
SYSINIT:4CAA                                         ; BL = color of character (graphics mode, PCjr only)
SYSINIT:4CAA                                         ; CX = number of times to write character
SYSINIT:4CAC                 jmp     short show_done
SYSINIT:4CAE ; ---------------------------------------------------------------------------
SYSINIT:4CAE
SYSINIT:4CAE show_onoff:                             ; CODE XREF: show_status+15↑j
SYSINIT:4CAE                 int     10h             ; - VIDEO -
SYSINIT:4CB0                 mov     al, byte ptr ds:_$NO ; "NO $"
SYSINIT:4CB3                 cmp     ds:bQueryOpt, 1 ; is interactive mode on?
SYSINIT:4CB8                 jnz     short show_noton ; no
SYSINIT:4CBA                 mov     al, byte ptr ds:_$YES ; "YES$"
SYSINIT:4CBD
SYSINIT:4CBD show_noton:                             ; CODE XREF: show_status+2F↑j
SYSINIT:4CBD                 mov     ah, 0Eh
SYSINIT:4CBF                 int     10h             ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
SYSINIT:4CBF                                         ; AL = character, BH = display page (alpha modes)
SYSINIT:4CBF                                         ; BL = foreground color (graphics modes)
SYSINIT:4CC1
SYSINIT:4CC1 show_done:                              ; CODE XREF: show_status+23↑j
SYSINIT:4CC1                 pop     dx              ; restore original cursor position
SYSINIT:4CC2                 mov     ah, 2
SYSINIT:4CC4                 int     10h             ; - VIDEO - SET CURSOR POSITION
SYSINIT:4CC4                                         ; DH,DL = row, column (0,0 = upper left)
SYSINIT:4CC4                                         ; BH = page number
SYSINIT:4CC6                 pop     bx
SYSINIT:4CC7                 retn
SYSINIT:4CC7 show_status     endp
SYSINIT:4CC7
SYSINIT:4CC8
SYSINIT:4CC8 ; =============== S U B R O U T I N E =======================================
SYSINIT:4CC8
SYSINIT:4CC8
SYSINIT:4CC8 skip_token      proc near               ; CODE XREF: menu_check+10A↑p
SYSINIT:4CC8                                         ; menu_check+14B↑p ...
SYSINIT:4CC8                 call    get_char        ; advances ES:SI/CX past the current token
SYSINIT:4CCB                 jb      short skip_token_done
SYSINIT:4CCD                 call    any_delim
SYSINIT:4CD0                 jnz     short skip_token
SYSINIT:4CD2
SYSINIT:4CD2 skip_check_eol:                         ; CODE XREF: skip_delim+D↓j
SYSINIT:4CD2                 cmp     al, 0Dh         ; CR
SYSINIT:4CD4                 jz      short skip_token_eol
SYSINIT:4CD6                 cmp     al, 0Ah         ; LF
SYSINIT:4CD8                 jz      short skip_token_eol
SYSINIT:4CDA                 clc
SYSINIT:4CDB                 jmp     short skip_token_done
SYSINIT:4CDD ; ---------------------------------------------------------------------------
SYSINIT:4CDD
SYSINIT:4CDD skip_token_eol:                         ; CODE XREF: skip_token+C↑j
SYSINIT:4CDD                                         ; skip_token+10↑j
SYSINIT:4CDD                 stc
SYSINIT:4CDE
SYSINIT:4CDE skip_token_done:                        ; CODE XREF: skip_token+3↑j
SYSINIT:4CDE                                         ; skip_token+13↑j ...
SYSINIT:4CDE                 retn
SYSINIT:4CDE skip_token      endp
SYSINIT:4CDE
SYSINIT:4CDF
SYSINIT:4CDF ; =============== S U B R O U T I N E =======================================
SYSINIT:4CDF
SYSINIT:4CDF
SYSINIT:4CDF skip_delim      proc near               ; CODE XREF: menu_check+10F↑p
SYSINIT:4CDF                                         ; menu_check+150↑p ...
SYSINIT:4CDF                 call    get_char        ; advances ES:SI/CX past the current delimiter
SYSINIT:4CE2                 lea     bx, [si-1]
SYSINIT:4CE5                 jb      short skip_token_done
SYSINIT:4CE7                 call    delim
SYSINIT:4CEA                 jz      short skip_delim
SYSINIT:4CEC                 jmp     short skip_check_eol
SYSINIT:4CEC skip_delim      endp
SYSINIT:4CEC
SYSINIT:4CEE
SYSINIT:4CEE ; =============== S U B R O U T I N E =======================================
SYSINIT:4CEE
SYSINIT:4CEE
SYSINIT:4CEE skip_opt_line   proc near               ; CODE XREF: menu_check:swchk_nextline↑p
SYSINIT:4CEE                                         ; menu_check+C5↑p ...
SYSINIT:4CEE                 cmp     al, 0Ah         ; LF
SYSINIT:4CF0                 jz      short skip_line_done
SYSINIT:4CF0 skip_opt_line   endp
SYSINIT:4CF0
SYSINIT:4CF2
SYSINIT:4CF2 ; =============== S U B R O U T I N E =======================================
SYSINIT:4CF2
SYSINIT:4CF2
SYSINIT:4CF2 skip_line       proc near               ; CODE XREF: copy_block+38↑p
SYSINIT:4CF2                                         ; get_linenum:get_linenum_loop↑p ...
SYSINIT:4CF2                 call    get_char
SYSINIT:4CF5                 jb      short skip_line_done
SYSINIT:4CF7
SYSINIT:4CF7 _skip_opt_line_:                        ; skip_opt_line: (Erdogan Tan - 03/08/2023)
SYSINIT:4CF7                 cmp     al, 0Ah         ; LF
SYSINIT:4CF9                 jnz     short skip_line
SYSINIT:4CFB
SYSINIT:4CFB skip_line_done:                         ; CODE XREF: skip_opt_line+2↑j
SYSINIT:4CFB                                         ; skip_line+3↑j
SYSINIT:4CFB                 retn
SYSINIT:4CFB skip_line       endp
SYSINIT:4CFB
SYSINIT:4CFC
SYSINIT:4CFC ; =============== S U B R O U T I N E =======================================
SYSINIT:4CFC
SYSINIT:4CFC
SYSINIT:4CFC get_number      proc near               ; CODE XREF: menu_check+7D↑p
SYSINIT:4CFC                                         ; menu_check+8F↑p ...
SYSINIT:4CFC                 sub     bx, bx          ; return binary equivalent of numeric string
SYSINIT:4CFC                                         ; BX = result
SYSINIT:4CFE
SYSINIT:4CFE num_loop:                               ; CODE XREF: get_number+1F↓j
SYSINIT:4CFE                 call    get_char
SYSINIT:4D01                 jb      short num_done
SYSINIT:4D03                 cmp     al, 30h ; '0'   ; convert to value
SYSINIT:4D05                 jb      short num_done  ; no more number
SYSINIT:4D07                 cmp     al, 39h ; '9'
SYSINIT:4D09                 ja      short num_done
SYSINIT:4D0B                 push    ax
SYSINIT:4D0C                 mov     ax, 10
SYSINIT:4D0F                 push    dx
SYSINIT:4D10                 mul     bx
SYSINIT:4D12                 pop     dx
SYSINIT:4D13                 mov     bx, ax
SYSINIT:4D15                 pop     ax
SYSINIT:4D16                 sub     al, 30h ; '0'
SYSINIT:4D18                 cbw
SYSINIT:4D19                 add     bx, ax
SYSINIT:4D1B                 jmp     short num_loop
SYSINIT:4D1D ; ---------------------------------------------------------------------------
SYSINIT:4D1D
SYSINIT:4D1D num_done:                               ; CODE XREF: get_number+5↑j
SYSINIT:4D1D                                         ; get_number+9↑j ...
SYSINIT:4D1D                 retn
SYSINIT:4D1D get_number      endp
SYSINIT:4D1D
SYSINIT:4D1E
SYSINIT:4D1E ; =============== S U B R O U T I N E =======================================
SYSINIT:4D1E
SYSINIT:4D1E
SYSINIT:4D1E get_char        proc near               ; CODE XREF: menu_check:swchk_loop↑p
SYSINIT:4D1E                                         ; menu_check:swchk_scan↑p ...
SYSINIT:4D1E                 sub     cx, 1           ; return next character,
SYSINIT:4D1E                                         ; advance ES:SI, and decrement CX
SYSINIT:4D1E                                         ; (use SUB to set carry,zero)
SYSINIT:4D21                 jb      short get_fail  ; out of data
SYSINIT:4D23                 lods    byte ptr es:[si] ; es
SYSINIT:4D23                                         ; lodsb
SYSINIT:4D25                 mov     ah, al
SYSINIT:4D27                 retn
SYSINIT:4D28 ; ---------------------------------------------------------------------------
SYSINIT:4D28
SYSINIT:4D28 get_fail:                               ; CODE XREF: get_char+3↑j
SYSINIT:4D28                 mov     cx, 0           ; restore CX to zero
SYSINIT:4D28                                         ; leave carry set, zero not set
SYSINIT:4D2B
SYSINIT:4D2B nearby_ret:                             ; CODE XREF: query_user+F↓j
SYSINIT:4D2B                 retn
SYSINIT:4D2B get_char        endp
SYSINIT:4D2B
SYSINIT:4D2C
SYSINIT:4D2C ; =============== S U B R O U T I N E =======================================
SYSINIT:4D2C
SYSINIT:4D2C
SYSINIT:4D2C query_user      proc near               ; CODE XREF: SYSINIT:091A↑p
SYSINIT:4D2C                                         ; doconf+16A↑p ...
SYSINIT:4D2C                 test    ds:bQueryOpt, 4 ; ask user whether to execute current config.sys command
SYSINIT:4D2C                                         ; answer no to everything?
SYSINIT:4D31                 jz      short qu_1      ; no
SYSINIT:4D33                 jmp     skip_all        ; yes
SYSINIT:4D36 ; ---------------------------------------------------------------------------
SYSINIT:4D36
SYSINIT:4D36 qu_1:                                   ; CODE XREF: query_user+5↑j
SYSINIT:4D36                 test    ds:bQueryOpt, 2 ; answer yes to everything?
SYSINIT:4D3B                 jnz     short nearby_ret ; yes (and return carry clear!)
SYSINIT:4D3D                 push    ax
SYSINIT:4D3E                 mov     al, ds:config_cmd
SYSINIT:4D41                 test    ds:bQueryOpt, 1 ; query every command?
SYSINIT:4D46                 jnz     short query_all ; yes
SYSINIT:4D48                 test    al, 80h         ; CONFIG_OPTION_QUERY
SYSINIT:4D4A                 jnz     short query_all
SYSINIT:4D4C                 jmp     do_cmd
SYSINIT:4D4F ; ---------------------------------------------------------------------------
SYSINIT:4D4F
SYSINIT:4D4F query_all:                              ; CODE XREF: query_user+1A↑j
SYSINIT:4D4F                                         ; query_user+1E↑j
SYSINIT:4D4F                 push    si              ; save pointer to rest of CONFIG.SYS line
SYSINIT:4D50                 mov     dx, offset _$AutoPrmpt ; "Process AUTOEXEC.BAT [Y,N]?$"
SYSINIT:4D53                 and     al, 7Fh         ; ~CONFIG_OPTION_QUERY
SYSINIT:4D55                 jz      short generic_prompt ; config_cmd must have been 0
SYSINIT:4D57                 mov     dh, al          ; save config_cmd in DH
SYSINIT:4D59                 sub     bx, bx          ; 0
SYSINIT:4D5B                 mov     di, offset comtab ; "\x01[["
SYSINIT:4D5E
SYSINIT:4D5E find_match:                             ; CODE XREF: query_user+40↓j
SYSINIT:4D5E                 mov     bl, [di]        ; get size of current keyword
SYSINIT:4D60                 or      bl, bl
SYSINIT:4D62                 jz      short line_print ; end of table
SYSINIT:4D64                 inc     di
SYSINIT:4D65                 cmp     al, [bx+di]     ; match?
SYSINIT:4D67                 jz      short cmd_match ; yes
SYSINIT:4D69                 lea     di, [bx+di+1]   ; otherwise, skip this command code
SYSINIT:4D6C                 jmp     short find_match ; loop
SYSINIT:4D6E ; ---------------------------------------------------------------------------
SYSINIT:4D6E
SYSINIT:4D6E cmd_match:                              ; CODE XREF: query_user+3B↑j
SYSINIT:4D6E                 mov     cl, [di-1]
SYSINIT:4D71                 mov     ch, 0
SYSINIT:4D73                 mov     ah, 2           ; STD_CON_OUTPUT
SYSINIT:4D75
SYSINIT:4D75 cmd_print:                              ; CODE XREF: query_user+50↓j
SYSINIT:4D75                 mov     al, [di]
SYSINIT:4D77                 inc     di
SYSINIT:4D78                 mov     dl, al
SYSINIT:4D7A                 int     21h             ; DOS - DISPLAY OUTPUT
SYSINIT:4D7A                                         ; DL = character to send to standard output
SYSINIT:4D7C                 loop    cmd_print
SYSINIT:4D7E                 mov     dl, '='         ; '=' looks funny on SET commands
SYSINIT:4D80                 cmp     dh, 'V'         ; CONFIG_SET
SYSINIT:4D83                 jnz     short cmd_notset
SYSINIT:4D85                 mov     dl, 20h ; ' '   ; for SET commands, don't display a '='
SYSINIT:4D87
SYSINIT:4D87 cmd_notset:                             ; CODE XREF: query_user+57↑j
SYSINIT:4D87                 int     21h             ; DOS - DISPLAY OUTPUT
SYSINIT:4D87                                         ; DL = character to send to standard output
SYSINIT:4D89
SYSINIT:4D89 line_print:                             ; CODE XREF: query_user+36↑j
SYSINIT:4D89                                         ; query_user+77↓j
SYSINIT:4D89                 lods    byte ptr es:[si]
SYSINIT:4D8B                 or      al, al
SYSINIT:4D8D                 jnz     short non_null
SYSINIT:4D8F                 mov     al, 20h ; ' '
SYSINIT:4D91
SYSINIT:4D91 non_null:                               ; CODE XREF: query_user+61↑j
SYSINIT:4D91                 cmp     al, 20h ; ' '   ; control code?
SYSINIT:4D93                 jb      short prompt_user ; yes, assume end of line
SYSINIT:4D95                 jnz     short non_space
SYSINIT:4D97                 cmp     byte ptr es:[si], 20h ; ' '
SYSINIT:4D9B                 jb      short prompt_user
SYSINIT:4D9D
SYSINIT:4D9D non_space:                              ; CODE XREF: query_user+69↑j
SYSINIT:4D9D                 mov     dl, al
SYSINIT:4D9F                 mov     ah, 2
SYSINIT:4DA1                 int     21h             ; DOS - DISPLAY OUTPUT
SYSINIT:4DA1                                         ; DL = character to send to standard output
SYSINIT:4DA3                 jmp     short line_print
SYSINIT:4DA5 ; ---------------------------------------------------------------------------
SYSINIT:4DA5
SYSINIT:4DA5 prompt_user:                            ; CODE XREF: query_user+67↑j
SYSINIT:4DA5                                         ; query_user+6F↑j
SYSINIT:4DA5                 mov     dx, offset _$InterPrmpt ; " [Y,N,ESC]?$"
SYSINIT:4DA8
SYSINIT:4DA8 generic_prompt:                         ; CODE XREF: query_user+29↑j
SYSINIT:4DA8                 call    print
SYSINIT:4DAB
SYSINIT:4DAB input_loop:                             ; CODE XREF: query_user+8A↓j
SYSINIT:4DAB                                         ; query_user+A9↓j ...
SYSINIT:4DAB                 mov     ah, 0
SYSINIT:4DAD                 int     16h             ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
SYSINIT:4DAD                                         ; Return: AH = scan code, AL = character
SYSINIT:4DAF                 or      al, al          ; is it a function key?
SYSINIT:4DB1                 jnz     short not_func  ; no
SYSINIT:4DB3                 cmp     ah, 3Fh         ; F5 function key?
SYSINIT:4DB6                 jnz     short input_loop ; no
SYSINIT:4DB8                 mov     al, byte ptr ds:_$NO ; "NO $"
SYSINIT:4DBB                 or      ds:bQueryOpt, 4 ; no more queries
SYSINIT:4DC0                 jmp     short legal_char
SYSINIT:4DC2 ; ---------------------------------------------------------------------------
SYSINIT:4DC2
SYSINIT:4DC2 not_func:                               ; CODE XREF: query_user+85↑j
SYSINIT:4DC2                 and     al, 0DFh        ; ~20h ; converting to upper case
SYSINIT:4DC2                                         ; converting to upper case
SYSINIT:4DC2                                         ; verify character is legal
SYSINIT:4DC4                 cmp     al, byte ptr ds:_$NO ; "NO $"
SYSINIT:4DC8                 jz      short legal_char
SYSINIT:4DCA                 cmp     al, byte ptr ds:_$YES ; "YES$"
SYSINIT:4DCE                 jz      short legal_char
SYSINIT:4DD0                 cmp     ds:config_cmd, 0
SYSINIT:4DD5                 jz      short input_loop ; don't allow Esc on this query
SYSINIT:4DD7                 cmp     al, 1Bh         ; Esc?
SYSINIT:4DD9                 jnz     short input_loop
SYSINIT:4DDB                 or      ds:bQueryOpt, 2 ; no more interactive boot prompts
SYSINIT:4DE0                 mov     al, byte ptr ds:_$YES ; "YES$"
SYSINIT:4DE3
SYSINIT:4DE3 legal_char:                             ; CODE XREF: query_user+94↑j
SYSINIT:4DE3                                         ; query_user+9C↑j ...
SYSINIT:4DE3                 call    disp_input
SYSINIT:4DE6                 pop     si              ; restore pointer to rest of CONFIG.SYS line
SYSINIT:4DE6                                         ; process line?
SYSINIT:4DE7                 cmp     al, byte ptr ds:_$NO ; "NO $"
SYSINIT:4DEB                 jz      short skip_cmd  ; no
SYSINIT:4DED
SYSINIT:4DED do_cmd:                                 ; CODE XREF: query_user+20↑j
SYSINIT:4DED                 pop     ax
SYSINIT:4DEE                 clc                     ; just do the command
SYSINIT:4DEF                 retn
SYSINIT:4DF0 ; ---------------------------------------------------------------------------
SYSINIT:4DF0
SYSINIT:4DF0 skip_cmd:                               ; CODE XREF: query_user+BF↑j
SYSINIT:4DF0                 pop     ax
SYSINIT:4DF1
SYSINIT:4DF1 skip_all:                               ; CODE XREF: query_user+7↑j
SYSINIT:4DF1                 mov     ah, 30h ; '0'   ; CONFIG_REM ; fake out the rest of sysinit's processing
SYSINIT:4DF3                 stc
SYSINIT:4DF4                 retn
SYSINIT:4DF4 query_user      endp
SYSINIT:4DF4
SYSINIT:4DF5
SYSINIT:4DF5 ; =============== S U B R O U T I N E =======================================
SYSINIT:4DF5
SYSINIT:4DF5
SYSINIT:4DF5 print_error     proc near               ; CODE XREF: menu_check+F3↑p
SYSINIT:4DF5                                         ; menu_check+133↑p ...
SYSINIT:4DF5                 push    ax              ; displays multi-config error conditions
SYSINIT:4DF6                 push    bx
SYSINIT:4DF7                 push    cx
SYSINIT:4DF8                 push    dx
SYSINIT:4DF9                 push    ds
SYSINIT:4DFA                 push    cs
SYSINIT:4DFB                 pop     ds
SYSINIT:4DFC                 assume ds:SYSINIT
SYSINIT:4DFC                 pushf
SYSINIT:4DFD                 call    get_linenum
SYSINIT:4E00                 mov     linecount, bx
SYSINIT:4E04                 call    error_line
SYSINIT:4E07                 popf
SYSINIT:4E08                 jnb     short pe_ret
SYSINIT:4E0A                 mov     dx, offset _$PauseMsg ; "Press any key to continue...\r\n$"
SYSINIT:4E0D                 call    print
SYSINIT:4E10                 mov     ax, 0C07h       ; flush input buffer, then wait for key
SYSINIT:4E13                 int     21h             ; DOS - CLEAR KEYBOARD BUFFER
SYSINIT:4E13                                         ; AL must be 01h, 06h, 07h, 08h, or 0Ah.
SYSINIT:4E15                 or      al, al          ; extended key?
SYSINIT:4E17                 jnz     short pe_1      ; no
SYSINIT:4E19                 mov     ah, 7           ; yes, eat it too
SYSINIT:4E1B                 int     21h             ; DOS - DIRECT STDIN INPUT, NO ECHO
SYSINIT:4E1D
SYSINIT:4E1D pe_1:                                   ; CODE XREF: print_error+22↑j
SYSINIT:4E1D                 mov     dx, offset crlfm ; "\r\n$"
SYSINIT:4E20                 call    print
SYSINIT:4E23
SYSINIT:4E23 pe_ret:                                 ; CODE XREF: print_error+13↑j
SYSINIT:4E23                 pop     ds
SYSINIT:4E24                 assume ds:nothing
SYSINIT:4E24                 pop     dx
SYSINIT:4E25                 pop     cx
SYSINIT:4E26                 pop     bx
SYSINIT:4E27                 pop     ax
SYSINIT:4E28                 retn
SYSINIT:4E28 print_error     endp
SYSINIT:4E28
SYSINIT:4E29
SYSINIT:4E29 ; =============== S U B R O U T I N E =======================================
SYSINIT:4E29
SYSINIT:4E29
SYSINIT:4E29 disable_autoexec proc near              ; CODE XREF: SYSINIT:0937↑p
SYSINIT:4E29                                         ; SYSINIT:0AAC↑p ...
SYSINIT:4E29                 test    ds:bQueryOpt, 4 ; This function is very simple:
SYSINIT:4E29                                         ; it merely prepends a "/D" to the command-line for the shell;
SYSINIT:4E29                                         ; this (undocumented) switch disables AUTOEXEC.BAT processing
SYSINIT:4E29                                         ; and the date/time prompt that is usually displayed
SYSINIT:4E29                                         ; when there's no AUTOEXEC.BAT.
SYSINIT:4E2E                 jz      short disable_exit
SYSINIT:4E30                 test    ds:dae_flag, 1
SYSINIT:4E35                 jnz     short disable_exit
SYSINIT:4E37                 or      ds:dae_flag, 1
SYSINIT:4E3C                 or      word ptr ds:bQueryOpt, 102h ; [bDefBlock] = 1
SYSINIT:4E42                 mov     dx, ' D'        ; 2044h ; 'D ' (NASM syntax)
SYSINIT:4E45
SYSINIT:4E45 dae_1:                                  ; CODE XREF: CheckQueryOpt+16↓j
SYSINIT:4E45                 mov     al, ds:def_swchr ; get default switchchar
SYSINIT:4E48                 or      al, al
SYSINIT:4E4A                 jz      short disable_exit
SYSINIT:4E4C                 mov     bl, byte ptr ds:command_line ; "\x02/P"
SYSINIT:4E50                 mov     bh, 0           ; BX == command-line length
SYSINIT:4E52                 mov     cx, bx
SYSINIT:4E54                 add     bl, 3
SYSINIT:4E57                 cmp     bl, 126
SYSINIT:4E5A                 ja      short disable_exit ;
SYSINIT:4E5A                                         ; update length
SYSINIT:4E5C                 mov     byte ptr ds:command_line, bl ; "\x02/P"
SYSINIT:4E60                 add     bx, (offset command_line+1) ;
SYSINIT:4E60                                         ; make sure we move the NULL too
SYSINIT:4E64                 inc     cx              ; (just for consistency sake)
SYSINIT:4E65
SYSINIT:4E65 disable_loop:                           ; CODE XREF: disable_autoexec+42↓j
SYSINIT:4E65                 mov     ah, [bx-3]
SYSINIT:4E68                 mov     [bx], ah
SYSINIT:4E6A                 dec     bx
SYSINIT:4E6B                 loop    disable_loop
SYSINIT:4E6D                 mov     [bx-2], al
SYSINIT:4E70                 mov     [bx-1], dx      ; 'D ' ; /D is stuffed into place now
SYSINIT:4E73
SYSINIT:4E73 disable_exit:                           ; CODE XREF: disable_autoexec+5↑j
SYSINIT:4E73                                         ; disable_autoexec+C↑j ...
SYSINIT:4E73                 retn
SYSINIT:4E73 disable_autoexec endp
SYSINIT:4E73
SYSINIT:4E74
SYSINIT:4E74 ; =============== S U B R O U T I N E =======================================
SYSINIT:4E74
SYSINIT:4E74
SYSINIT:4E74 CheckQueryOpt   proc near               ; CODE XREF: SYSINIT:process_autoexec↑p
SYSINIT:4E74                                         ; SYSINIT:0AAF↑p
SYSINIT:4E74                 cmp     ds:bQueryOpt, 1
SYSINIT:4E79                 jnz     short disable_exit
SYSINIT:4E7B                 test    ds:dae_flag, 2
SYSINIT:4E80                 jnz     short disable_exit
SYSINIT:4E82                 or      ds:dae_flag, 2
SYSINIT:4E87                 mov     dx, ' Y'        ; 'Y ' ; 2059h
SYSINIT:4E8A                 jmp     short dae_1
SYSINIT:4E8A CheckQueryOpt   endp
SYSINIT:4E8A
SYSINIT:4E8C
SYSINIT:4E8C ; =============== S U B R O U T I N E =======================================
SYSINIT:4E8C
SYSINIT:4E8C
SYSINIT:4E8C any_delim       proc near               ; CODE XREF: menu_check+ED↑p
SYSINIT:4E8C                                         ; menu_check+309↑p ...
SYSINIT:4E8C                 cmp     al, 0Dh         ; cr
SYSINIT:4E8E                 jz      short delim_ret
SYSINIT:4E90                 cmp     al, 0Ah         ; lf
SYSINIT:4E92                 jz      short delim_ret
SYSINIT:4E94                 cmp     al, '['
SYSINIT:4E96                 jz      short delim_ret
SYSINIT:4E98                 cmp     al, ']'
SYSINIT:4E9A                 jz      short delim_ret
SYSINIT:4E9A any_delim       endp
SYSINIT:4E9A
SYSINIT:4E9C
SYSINIT:4E9C ; =============== S U B R O U T I N E =======================================
SYSINIT:4E9C
SYSINIT:4E9C
SYSINIT:4E9C delim           proc near               ; CODE XREF: doconf+344↑p
SYSINIT:4E9C                                         ; ParseSize+2A↑p ...
SYSINIT:4E9C                 cmp     al, '/'         ; ibm will assume "/" as an delimeter
SYSINIT:4E9E                 jz      short delim_ret
SYSINIT:4EA0                 cmp     al, 0           ; special case for sysinit!
SYSINIT:4EA2                 jz      short delim_ret
SYSINIT:4EA4
SYSINIT:4EA4 org_delim:                              ; CODE XREF: organize+107↑p
SYSINIT:4EA4                                         ; organize+1A0↑p
SYSINIT:4EA4                 cmp     al, 20h ; ' '   ; space
SYSINIT:4EA6                 jz      short delim_ret
SYSINIT:4EA8                 cmp     al, 9           ; tab
SYSINIT:4EAA                 jz      short delim_ret
SYSINIT:4EAC                 cmp     al, '='
SYSINIT:4EAE                 jz      short delim_ret
SYSINIT:4EB0                 cmp     al, ','
SYSINIT:4EB2                 jz      short delim_ret
SYSINIT:4EB4                 cmp     al, ';'
SYSINIT:4EB6                 clc
SYSINIT:4EB7
SYSINIT:4EB7 delim_ret:                              ; CODE XREF: any_delim+2↑j
SYSINIT:4EB7                                         ; any_delim+6↑j ...
SYSINIT:4EB7                 retn
SYSINIT:4EB7 delim           endp
SYSINIT:4EB7
SYSINIT:4EB8
SYSINIT:4EB8 ; =============== S U B R O U T I N E =======================================
SYSINIT:4EB8
SYSINIT:4EB8
SYSINIT:4EB8 newline         proc near               ; CODE XREF: doconf+124↑p
SYSINIT:4EB8                                         ; newline+7↓j
SYSINIT:4EB8                 call    getchr          ; skip non-control characters
SYSINIT:4EBB                 jb      short nl_ret    ; no char
SYSINIT:4EBD                 cmp     al, 0Ah         ; lf
SYSINIT:4EBF                 jnz     short newline
SYSINIT:4EC1                 call    getchr
SYSINIT:4EC4
SYSINIT:4EC4 nl_ret:                                 ; CODE XREF: newline+3↑j
SYSINIT:4EC4                 retn                    ; al = first character of next line (if cf=0)
SYSINIT:4EC4 newline         endp
SYSINIT:4EC4
SYSINIT:4EC5
SYSINIT:4EC5 ; =============== S U B R O U T I N E =======================================
SYSINIT:4EC5
SYSINIT:4EC5
SYSINIT:4EC5 mapcase         proc near               ; CODE XREF: organize+B1↑p
SYSINIT:4EC5                 push    cx
SYSINIT:4EC6                 push    si
SYSINIT:4EC7                 push    ds
SYSINIT:4EC8                 push    es
SYSINIT:4EC9                 pop     ds
SYSINIT:4ECA                 mov     bl, al
SYSINIT:4ECC
SYSINIT:4ECC convloop:                               ; CODE XREF: mapcase+26↓j
SYSINIT:4ECC                 lodsb
SYSINIT:4ECD                 cmp     al, 'a'
SYSINIT:4ECF                 jb      short noconv
SYSINIT:4ED1                 cmp     al, 'z'
SYSINIT:4ED3                 ja      short noconv
SYSINIT:4ED5                 sub     al, 20h         ; convert to upper-case (and al,0DFh)
SYSINIT:4ED7                 mov     [si-1], al
SYSINIT:4EDA
SYSINIT:4EDA noconv:                                 ; CODE XREF: mapcase+A↑j
SYSINIT:4EDA                                         ; mapcase+E↑j
SYSINIT:4EDA                 cmp     bl, 'V'         ; CONFIG_SET ; preserve case for part of the line?
SYSINIT:4EDD                 jnz     short check_eol ; no, just check for end-of-line
SYSINIT:4EDF                 cmp     al, '='         ; separator between SET var and value?
SYSINIT:4EE1                 jz      short convdone  ; yes
SYSINIT:4EE1                                         ; (we don't want to upper-case
SYSINIT:4EE1                                         ; anything after the "=" in a SET)
SYSINIT:4EE3
SYSINIT:4EE3 check_eol:                              ; CODE XREF: mapcase+18↑j
SYSINIT:4EE3                 cmp     al, 0Dh         ; cr
SYSINIT:4EE5                 jz      short convdone
SYSINIT:4EE7                 cmp     al, 0Ah         ; lf
SYSINIT:4EE9                 jz      short convdone
SYSINIT:4EEB                 loop    convloop
SYSINIT:4EED
SYSINIT:4EED convdone:                               ; CODE XREF: mapcase+1C↑j
SYSINIT:4EED                                         ; mapcase+20↑j ...
SYSINIT:4EED                 pop     ds
SYSINIT:4EEE                 pop     si
SYSINIT:4EEF                 pop     cx
SYSINIT:4EF0                 retn
SYSINIT:4EF0 mapcase         endp
SYSINIT:4EF0
SYSINIT:4EF1
SYSINIT:4EF1 ; =============== S U B R O U T I N E =======================================
SYSINIT:4EF1
SYSINIT:4EF1
SYSINIT:4EF1 round           proc near               ; CODE XREF: endfile:dosfts↑p
SYSINIT:4EF1                                         ; endfile+82↑p ...
SYSINIT:4EF1
SYSINIT:4EF1 ; FUNCTION CHUNK AT SYSINIT:1468 SIZE 00000001 BYTES
SYSINIT:4EF1
SYSINIT:4EF1                 push    ax              ; round the values in memlo and memhi
SYSINIT:4EF1                                         ; to paragraph boundary.
SYSINIT:4EF1                                         ; perform bounds check.
SYSINIT:4EF2                 mov     ax, cs:memlo
SYSINIT:4EF6                 call    ParaRound       ; para round up
SYSINIT:4EF9                 add     cs:memhi, ax
SYSINIT:4EFE                 mov     cs:memlo, 0
SYSINIT:4F05                 mov     ax, cs:memhi    ; ax = new memhi
SYSINIT:4F09                 cmp     ax, cs:ALLOCLIM
SYSINIT:4F0E                 jnb     short mem_err
SYSINIT:4F10                 test    cs:setdevmarkflag, 2 ; for_devmark
SYSINIT:4F16                 jz      short skip_set_devmarksize
SYSINIT:4F18                 push    es
SYSINIT:4F19                 push    si
SYSINIT:4F1A                 mov     si, cs:devmark_addr
SYSINIT:4F1F                 mov     es, si
SYSINIT:4F21                 sub     ax, si
SYSINIT:4F23                 dec     ax
SYSINIT:4F24                 mov     es:3, ax        ; mov [es:devmark.size],ax ; paragraph
SYSINIT:4F28                 and     cs:setdevmarkflag, 0FDh ; ~2 ; not 2
SYSINIT:4F28                                         ; not_for_devmark
SYSINIT:4F2E                 pop     si
SYSINIT:4F2F                 pop     es
SYSINIT:4F30
SYSINIT:4F30 skip_set_devmarksize:                   ; CODE XREF: round+25↑j
SYSINIT:4F30                 pop     ax
SYSINIT:4F31                 clc
SYSINIT:4F32                 retn
SYSINIT:4F33 ; ---------------------------------------------------------------------------
SYSINIT:4F33
SYSINIT:4F33 mem_err:                                ; CODE XREF: doconf:NoMem↑j
SYSINIT:4F33                                         ; RoundBreakAddr+1E↑j ...
SYSINIT:4F33                 mov     dx, offset badmem ; "\r\nConfiguration too large for memory"...
SYSINIT:4F36                 push    cs
SYSINIT:4F37                 pop     ds
SYSINIT:4F38                 assume ds:SYSINIT
SYSINIT:4F38                 call    print
SYSINIT:4F3B                 jmp     stall
SYSINIT:4F3B round           endp
SYSINIT:4F3B
SYSINIT:4F3E
SYSINIT:4F3E ; =============== S U B R O U T I N E =======================================
SYSINIT:4F3E
SYSINIT:4F3E
SYSINIT:4F3E calldev         proc near               ; CODE XREF: doconf+48B↑p
SYSINIT:4F3E                                         ; doconf+491↑p
SYSINIT:4F3E                 mov     ds, word ptr cs:DevEntry+2
SYSINIT:4F43                 assume ds:nothing
SYSINIT:4F43                 add     bx, word ptr cs:DevEntry ; do a little relocation
SYSINIT:4F48                 mov     ax, [bx]
SYSINIT:4F4A                 push    word ptr cs:DevEntry
SYSINIT:4F4F                 mov     word ptr cs:DevEntry, ax
SYSINIT:4F53                 mov     bx, offset packet
SYSINIT:4F56                 call    cs:DevEntry
SYSINIT:4F5B                 pop     word ptr cs:DevEntry
SYSINIT:4F60                 retn
SYSINIT:4F60 calldev         endp
SYSINIT:4F60
SYSINIT:4F61
SYSINIT:4F61 ; =============== S U B R O U T I N E =======================================
SYSINIT:4F61
SYSINIT:4F61
SYSINIT:4F61 todigit         proc near               ; CODE XREF: getnum:b2↓p
SYSINIT:4F61                 sub     al, '0'
SYSINIT:4F63                 jb      short notdig
SYSINIT:4F65                 cmp     al, 9
SYSINIT:4F67                 ja      short notdig
SYSINIT:4F69                 clc
SYSINIT:4F6A                 retn
SYSINIT:4F6B ; ---------------------------------------------------------------------------
SYSINIT:4F6B
SYSINIT:4F6B notdig:                                 ; CODE XREF: todigit+2↑j
SYSINIT:4F6B                                         ; todigit+6↑j
SYSINIT:4F6B                 stc
SYSINIT:4F6C                 retn
SYSINIT:4F6C todigit         endp
SYSINIT:4F6C
SYSINIT:4F6D
SYSINIT:4F6D ; =============== S U B R O U T I N E =======================================
SYSINIT:4F6D
SYSINIT:4F6D
SYSINIT:4F6D getnum          proc near               ; CODE XREF: check_switch+45↑p
SYSINIT:4F6D                 push    bx              ; getnum parses a decimal number.
SYSINIT:4F6D                                         ; returns it in ax, sets zero flag if ax = 0
SYSINIT:4F6D                                         ; (may be considered an error),
SYSINIT:4F6D                                         ; if number is bad carry is set, zero is set, ax=0.
SYSINIT:4F6D                                         ; ;;
SYSINIT:4F6E                 xor     bx, bx          ; running count is zero
SYSINIT:4F70
SYSINIT:4F70 b2:                                     ; CODE XREF: getnum+40↓j
SYSINIT:4F70                 call    todigit         ; do we have a digit ?
SYSINIT:4F73                 jb      short badnum    ; no, bomb
SYSINIT:4F75                 xchg    ax, bx          ; put total in ax
SYSINIT:4F76                 push    bx              ; save digit (0 to 9)
SYSINIT:4F77                 mov     bx, 10          ; base of arithmetic
SYSINIT:4F7A                 mul     bx              ; shift by one decimal digit
SYSINIT:4F7C                 pop     bx              ; get back digit (0 to 9)
SYSINIT:4F7D                 add     al, bl          ; get total
SYSINIT:4F7F                 adc     ah, 0           ; make that 16 bits
SYSINIT:4F82                 jb      short badnum    ; too big a number
SYSINIT:4F84                 xchg    ax, bx          ; stash total
SYSINIT:4F85                 call    getchr          ; get next digit
SYSINIT:4F88                 jb      short b1        ; no more characters
SYSINIT:4F8A                 cmp     al, ' '         ; space?
SYSINIT:4F8C                 jz      short b15       ; then end of digits
SYSINIT:4F8E                 cmp     al, ','         ; ',' is a seperator!!!
SYSINIT:4F90                 jz      short b15       ; then end of digits.
SYSINIT:4F92                 cmp     al, 9           ; tab
SYSINIT:4F94                 jz      short b15
SYSINIT:4F96                 cmp     al, cs:sepchr   ; allow 0 or special separators
SYSINIT:4F9B                 jz      short b15
SYSINIT:4F9D                 cmp     al, '/'         ; see if another switch follows
SYSINIT:4F9F                 nop                     ; cas - remnant of old bad code
SYSINIT:4FA0                 nop                     ; (04/08/2023 - Erdogan Tan - 'nop,nop' is not neded)
SYSINIT:4FA1                 jz      short b15
SYSINIT:4FA3                 cmp     al, 0Ah         ; lf ; line-feed?
SYSINIT:4FA5                 jz      short b15
SYSINIT:4FA7                 cmp     al, 0Dh         ; cr ; carriage return?
SYSINIT:4FA9                 jz      short b15
SYSINIT:4FAB                 or      al, al          ; end of line separator?
SYSINIT:4FAD                 jnz     short b2        ; no, try as a valid char...
SYSINIT:4FAF
SYSINIT:4FAF b15:                                    ; CODE XREF: getnum+1F↑j
SYSINIT:4FAF                                         ; getnum+23↑j ...
SYSINIT:4FAF                 inc     cs:count        ; one more character to s...
SYSINIT:4FB4                 dec     cs:chrptr       ; clears carry, sets zero accordingly
SYSINIT:4FB9
SYSINIT:4FB9 b1:                                     ; CODE XREF: getnum+1B↑j
SYSINIT:4FB9                 mov     ax, bx
SYSINIT:4FBB                 or      ax, ax
SYSINIT:4FBD                 pop     bx
SYSINIT:4FBE                 retn
SYSINIT:4FBF ; ---------------------------------------------------------------------------
SYSINIT:4FBF
SYSINIT:4FBF badnum:                                 ; CODE XREF: getnum+6↑j
SYSINIT:4FBF                                         ; getnum+15↑j
SYSINIT:4FBF                 mov     cs:sepchr, 0
SYSINIT:4FC5                 xor     ax, ax          ; set zero flag, and ax = 0
SYSINIT:4FC7                 pop     bx
SYSINIT:4FC8                 stc                     ; and carry set
SYSINIT:4FC9                 retn
SYSINIT:4FC9 getnum          endp
SYSINIT:4FC9
SYSINIT:4FCA
SYSINIT:4FCA ; =============== S U B R O U T I N E =======================================
SYSINIT:4FCA
SYSINIT:4FCA
SYSINIT:4FCA setdoscountryinfo proc near             ; CODE XREF: doconf+787↑p
SYSINIT:4FCA                 push    di              ; input:
SYSINIT:4FCA                                         ;   es:di -> pointer to dos_country_cdpg_info
SYSINIT:4FCA                                         ;   ds:0  -> buffer.
SYSINIT:4FCA                                         ;      si = 0
SYSINIT:4FCA                                         ;      ax = country id
SYSINIT:4FCA                                         ;      dx = code page id. (if 0, then use ccsyscodepage as a default.)
SYSINIT:4FCA                                         ;      bx = file handle
SYSINIT:4FCA                                         ;   this routine can handle maximum 438 country_data entries.
SYSINIT:4FCA                                         ; output:
SYSINIT:4FCA                                         ;   dos_country_cdpg_info set.
SYSINIT:4FCA                                         ;   carry set if any file read failure or wrong information in the file.
SYSINIT:4FCA                                         ;   carry set and cx = -1 if cannot find the matching country_id,
SYSINIT:4FCA                                         ;         codepage_id in the file.
SYSINIT:4FCB                 push    ax
SYSINIT:4FCC                 push    dx
SYSINIT:4FCD                 xor     cx, cx
SYSINIT:4FCF                 xor     dx, dx
SYSINIT:4FD1                 mov     ax, 512         ; read 512 bytes
SYSINIT:4FD4                 call    readincontrolbuffer ; read the file header
SYSINIT:4FD7                 jb      short setdosdata_fail
SYSINIT:4FD9                 push    es
SYSINIT:4FDA                 push    si
SYSINIT:4FDB                 push    cs
SYSINIT:4FDC                 pop     es
SYSINIT:4FDD                 assume es:SYSINIT
SYSINIT:4FDD                 mov     di, offset country_file_signature ; db 0FFh,'COUNTRY'
SYSINIT:4FE0                 mov     cx, 8           ; length of the signature
SYSINIT:4FE3                 repe cmpsb
SYSINIT:4FE5                 pop     si
SYSINIT:4FE6                 pop     es
SYSINIT:4FE7                 assume es:nothing
SYSINIT:4FE7                 jnz     short setdosdata_fail ; signature mismatch
SYSINIT:4FE9                 add     si, 18
SYSINIT:4FEC                 cmp     byte ptr [si], 1 ; si -> county info type
SYSINIT:4FEC                                         ; only accept type 1 (currently only 1 header type)
SYSINIT:4FEF                 jnz     short setdosdata_fail ; cannot proceed. error return
SYSINIT:4FF1                 inc     si              ; si -> file offset
SYSINIT:4FF2                 mov     dx, [si]        ; get the info file offset.
SYSINIT:4FF4                 mov     cx, [si+2]
SYSINIT:4FF7                 mov     ax, 6144        ; read 6144 bytes.
SYSINIT:4FFA                 call    readincontrolbuffer ; read info
SYSINIT:4FFD                 jb      short setdosdata_fail
SYSINIT:4FFF                 mov     cx, [si]        ; get the # of country, codepage combination entries
SYSINIT:5001                 cmp     cx, 438         ; cannot handle more than 438 entries.
SYSINIT:5005                 ja      short setdosdata_fail
SYSINIT:5007                 inc     si
SYSINIT:5008                 inc     si              ; si -> entry information packet
SYSINIT:5009                 pop     dx              ; restore code page id
SYSINIT:500A                 pop     ax              ; restore country id
SYSINIT:500B                 pop     di              ; search for desired country_id,codepage_id.
SYSINIT:500C
SYSINIT:500C setdoscntry_find:                       ; CODE XREF: setdoscountryinfo+55↓j
SYSINIT:500C                 cmp     ax, [si+2]      ; compare country_id
SYSINIT:500F                 jnz     short setdoscntry_next
SYSINIT:5011                 cmp     dx, 0           ; no user specified code page ?
SYSINIT:5014                 jz      short setdoscntry_any_codepage ; then no need to match code page id.
SYSINIT:5016                 cmp     dx, [si+4]      ; compare code page id
SYSINIT:5019                 jz      short setdoscntry_got_it
SYSINIT:501B
SYSINIT:501B setdoscntry_next:                       ; CODE XREF: setdoscountryinfo+45↑j
SYSINIT:501B                 add     si, [si]        ; next entry
SYSINIT:501D                 inc     si
SYSINIT:501E                 inc     si              ; take a word for size of entry itself
SYSINIT:501F                 loop    setdoscntry_find
SYSINIT:5021                 mov     cx, 0FFFFh      ; -1 ; signals that bad country id entered.
SYSINIT:5024
SYSINIT:5024 setdoscntry_fail:                       ; CODE XREF: setdoscountryinfo+5F↓j
SYSINIT:5024                                         ; setdoscountryinfo+75↓j
SYSINIT:5024                 stc
SYSINIT:5025                 retn
SYSINIT:5026 ; ---------------------------------------------------------------------------
SYSINIT:5026
SYSINIT:5026 setdosdata_fail:                        ; CODE XREF: setdoscountryinfo+D↑j
SYSINIT:5026                                         ; setdoscountryinfo+1D↑j ...
SYSINIT:5026                 pop     si
SYSINIT:5027                 pop     cx
SYSINIT:5028                 pop     di
SYSINIT:5029                 jmp     short setdoscntry_fail
SYSINIT:502B ; ---------------------------------------------------------------------------
SYSINIT:502B
SYSINIT:502B setdoscntry_any_codepage:               ; CODE XREF: setdoscountryinfo+4A↑j
SYSINIT:502B                 mov     dx, [si+4]      ; use the code_page_id of the country_id found.
SYSINIT:502E
SYSINIT:502E setdoscntry_got_it:                     ; CODE XREF: setdoscountryinfo+4F↑j
SYSINIT:502E                 mov     cs:cntrycodepage_id, dx ; save code page id for this country.
SYSINIT:5033                 mov     dx, [si+10]     ; get the file offset of country data
SYSINIT:5036                 mov     cx, [si+12]
SYSINIT:5039                 mov     ax, 512         ; read 512 bytes
SYSINIT:503C                 call    readincontrolbuffer
SYSINIT:503F                 jb      short setdoscntry_fail
SYSINIT:5041                 mov     cx, [si]        ; get the number of entries to handle.
SYSINIT:5043                 inc     si
SYSINIT:5044                 inc     si              ; si -> first entry
SYSINIT:5045
SYSINIT:5045 setdoscntry_data:                       ; CODE XREF: setdoscountryinfo+110↓j
SYSINIT:5045                 push    di              ; es:di -> dos_country_cdpg_info
SYSINIT:5046                 push    cx              ; save # of entry left
SYSINIT:5047                 push    si              ; si -> current entry in control buffer
SYSINIT:5048                 mov     al, [si+2]      ; get data entry id
SYSINIT:504B                 call    getcountrydestination ; get the address of destination in es:di
SYSINIT:504E                 jb      short setdoscntry_data_next ; no matching data entry id in dos
SYSINIT:5050                 mov     dx, [si+4]      ; get offset of data
SYSINIT:5053                 mov     cx, [si+6]
SYSINIT:5056                 mov     ax, 4200h
SYSINIT:5059                 stc
SYSINIT:505A                 int     21h             ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
SYSINIT:505A                                         ; AL = method: offset from beginning of file
SYSINIT:505C                 jb      short setdosdata_fail ;
SYSINIT:505C                                         ; read the country.sys data
SYSINIT:505E                 mov     dx, 512         ; start of data buffer
SYSINIT:5061                 mov     cx, 20          ; read 20 bytes only. we only need to
SYSINIT:5064                 mov     ah, 3Fh         ; look at the length of the data in the file.
SYSINIT:5066                 stc
SYSINIT:5067                 int     21h             ; DOS - 2+ - READ FROM FILE WITH HANDLE
SYSINIT:5067                                         ; BX = file handle, CX = number of bytes to read
SYSINIT:5067                                         ; DS:DX -> buffer
SYSINIT:5069                 jb      short setdosdata_fail ; read failure
SYSINIT:506B                 cmp     ax, cx
SYSINIT:506D                 jnz     short setdosdata_fail
SYSINIT:506F                 mov     dx, [si+4]      ; get offset of data again.
SYSINIT:5072                 mov     cx, [si+6]
SYSINIT:5075                 mov     ax, 4200h       ; move pointer back again
SYSINIT:5078                 stc
SYSINIT:5079                 int     21h             ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
SYSINIT:5079                                         ; AL = method: offset from beginning of file
SYSINIT:507B                 jb      short setdosdata_fail
SYSINIT:507D                 push    si
SYSINIT:507E                 mov     si, 520         ; (512+8) ; get length of the data from the file
SYSINIT:5081                 mov     cx, [si]
SYSINIT:5083                 pop     si
SYSINIT:5084                 mov     dx, 512         ; start of data buffer
SYSINIT:5087                 add     cx, 10          ; signature + a word for the length itself
SYSINIT:508A                 mov     ah, 3Fh         ; read the data from the file.
SYSINIT:508C                 stc
SYSINIT:508D                 int     21h             ; DOS - 2+ - READ FROM FILE WITH HANDLE
SYSINIT:508D                                         ; BX = file handle, CX = number of bytes to read
SYSINIT:508D                                         ; DS:DX -> buffer
SYSINIT:508F                 jb      short setdosdata_fail
SYSINIT:5091                 cmp     ax, cx
SYSINIT:5093                 jnz     short setdosdata_fail
SYSINIT:5095                 mov     al, [si+2]      ; save data id for future use.
SYSINIT:5098                 mov     si, 520         ; (512+8) ; si-> data buffer + id tag field
SYSINIT:509B                 mov     cx, [si]        ; get the length of the file
SYSINIT:509D                 inc     cx              ; take care of a word for lenght of tab itself.
SYSINIT:509E                 inc     cx
SYSINIT:509F                 cmp     cx, 1528        ; (2048-512-8) ; fit into the buffer?
SYSINIT:50A3                 ja      short setdosdata_fail
SYSINIT:50A5                 call    setdbcs_before_copy
SYSINIT:50A8                 cmp     al, 1           ; SetCountryInfo ; is the data for setcountryinfo table?
SYSINIT:50AA                 jnz     short setdoscntry_mov ; no, don't worry
SYSINIT:50AC                 push    word ptr es:[di+24] ;
SYSINIT:50AC                                         ; [es:di+country_cdpg_info.ccMono_Ptr
SYSINIT:50AC                                         ;  -country_cdpg_info.ccCountryInfoLen]
SYSINIT:50B0                 push    word ptr es:[di+26] ;
SYSINIT:50B0                                         ; [es:di+country_cdpg_info.ccMono_Ptr
SYSINIT:50B0                                         ;  -country_cdpg_info.ccCountryInfoLen+2]
SYSINIT:50B0                                         ;
SYSINIT:50B0                                         ; at this time di -> cccountryinfolen
SYSINIT:50B4                 push    di
SYSINIT:50B5                 push    ax
SYSINIT:50B6                 mov     ax, cs:cntrycodepage_id ; do not use the code page info in country_info
SYSINIT:50BA                 mov     [si+4], ax      ; use the saved one for this !!!
SYSINIT:50BD                 pop     ax
SYSINIT:50BE
SYSINIT:50BE setdoscntry_mov:                        ; CODE XREF: setdoscountryinfo+E0↑j
SYSINIT:50BE                 rep movsb               ; copy the table into dos
SYSINIT:50C0                 cmp     al, 1           ; SetCountryInfo ; was the ccmono_ptr saved?
SYSINIT:50C2                 jnz     short setdoscntry_data_next
SYSINIT:50C4                 pop     di
SYSINIT:50C5                 pop     word ptr es:[di+26] ;
SYSINIT:50C5                                         ; [es:di+country_cdpg_info.ccMono_Ptr
SYSINIT:50C5                                         ;  -country_cdpg_info.ccCountryInfoLen+2]
SYSINIT:50C9                 pop     word ptr es:[di+24] ;
SYSINIT:50C9                                         ; [es:di+country_cdpg_info.ccMono_Ptr
SYSINIT:50C9                                         ;  -country_cdpg_info.ccCountryInfoLen]
SYSINIT:50CD
SYSINIT:50CD setdoscntry_data_next:                  ; CODE XREF: setdoscountryinfo+84↑j
SYSINIT:50CD                                         ; setdoscountryinfo+F8↑j
SYSINIT:50CD                 pop     si              ; restore control buffer pointer
SYSINIT:50CE                 pop     cx              ; restore # of entries left
SYSINIT:50CF                 pop     di              ; restore pointer to dso_country_cdpg
SYSINIT:50D0                 add     si, [si]        ; try to get the next entry
SYSINIT:50D2                 inc     si
SYSINIT:50D3                 inc     si              ; take a word of entry length itself
SYSINIT:50D4                 dec     cx
SYSINIT:50D5                 cmp     cx, 0
SYSINIT:50D8                 jz      short setdoscntry_ok
SYSINIT:50DA                 jmp     setdoscntry_data
SYSINIT:50DD ; ---------------------------------------------------------------------------
SYSINIT:50DD
SYSINIT:50DD setdoscntry_ok:                         ; CODE XREF: setdoscountryinfo+10E↑j
SYSINIT:50DD                 retn
SYSINIT:50DD setdoscountryinfo endp ; sp-analysis failed
SYSINIT:50DD
SYSINIT:50DE
SYSINIT:50DE ; =============== S U B R O U T I N E =======================================
SYSINIT:50DE
SYSINIT:50DE
SYSINIT:50DE setdbcs_before_copy proc near           ; CODE XREF: setdoscountryinfo+DB↑p
SYSINIT:50DE                 cmp     al, 7           ; SetDBCS ; dbcs vector set?
SYSINIT:50E0                 jnz     short sdbcsbc   ; jump if not
SYSINIT:50E2                 cmp     word ptr es:[di], 0 ; zero byte data block?
SYSINIT:50E6                 jz      short sdbcsbc   ; jump if so
SYSINIT:50E8                 push    di
SYSINIT:50E9                 push    ax
SYSINIT:50EA                 push    cx
SYSINIT:50EB                 mov     cx, es:[di]     ; load block length
SYSINIT:50EE                 add     di, 2           ; points actual data
SYSINIT:50F1                 xor     al, al          ; fill bytes
SYSINIT:50F3                 rep stosb               ; clear data block
SYSINIT:50F5                 pop     cx
SYSINIT:50F6                 pop     ax
SYSINIT:50F7                 pop     di
SYSINIT:50F8
SYSINIT:50F8 sdbcsbc:                                ; CODE XREF: setdbcs_before_copy+2↑j
SYSINIT:50F8                                         ; setdbcs_before_copy+8↑j
SYSINIT:50F8                 retn
SYSINIT:50F8 setdbcs_before_copy endp
SYSINIT:50F8
SYSINIT:50F9
SYSINIT:50F9 ; =============== S U B R O U T I N E =======================================
SYSINIT:50F9
SYSINIT:50F9
SYSINIT:50F9 getcountrydestination proc near         ; CODE XREF: setdoscountryinfo+81↑p
SYSINIT:50F9                 push    cx              ; get the destination address
SYSINIT:50F9                                         ;  in the dos country info table.
SYSINIT:50FA                 add     di, 74          ; country_cdpg_info.ccNumber_of_entries
SYSINIT:50FA                                         ; skip the reserved area, syscodepage etc.
SYSINIT:50FD                 mov     cx, es:[di]     ; get the number of entries
SYSINIT:5100                 inc     di
SYSINIT:5101                 inc     di              ; si -> the first start entry id
SYSINIT:5102
SYSINIT:5102 getcntrydest:                           ; CODE XREF: getcountrydestination:getcntrydest_loop↓j
SYSINIT:5102                 cmp     es:[di], al
SYSINIT:5105                 jz      short getcntrydest_ok
SYSINIT:5107                 cmp     byte ptr es:[di], 1 ; SetCountryInfo ; was it setcountryinfo entry?
SYSINIT:510B                 jz      short getcntrydest_1
SYSINIT:510D                 add     di, 5           ; next data id
SYSINIT:5110                 jmp     short getcntrydest_loop
SYSINIT:5112 ; ---------------------------------------------------------------------------
SYSINIT:5112
SYSINIT:5112 getcntrydest_1:                         ; CODE XREF: getcountrydestination+12↑j
SYSINIT:5112                 add     di, 41          ; NEW_COUNTRY_SIZE+3 ; next data id
SYSINIT:5115
SYSINIT:5115 getcntrydest_loop:                      ; CODE XREF: getcountrydestination+17↑j
SYSINIT:5115                 loop    getcntrydest
SYSINIT:5117                 stc
SYSINIT:5118                 jmp     short getcntrydest_exit
SYSINIT:511A ; ---------------------------------------------------------------------------
SYSINIT:511A
SYSINIT:511A getcntrydest_ok:                        ; CODE XREF: getcountrydestination+C↑j
SYSINIT:511A                 cmp     al, 1           ; SetCountryInfo ; select country info?
SYSINIT:511C                 jnz     short getcntrydest_ok1
SYSINIT:511E                 inc     di              ; now di -> cccountryinfolen
SYSINIT:511F                 jmp     short getcntrydest_exit
SYSINIT:5121 ; ---------------------------------------------------------------------------
SYSINIT:5121
SYSINIT:5121 getcntrydest_ok1:                       ; CODE XREF: getcountrydestination+23↑j
SYSINIT:5121                 les     di, es:[di+1]   ; get the destination in es:di
SYSINIT:5125
SYSINIT:5125 getcntrydest_exit:                      ; CODE XREF: getcountrydestination+1F↑j
SYSINIT:5125                                         ; getcountrydestination+26↑j
SYSINIT:5125                 pop     cx
SYSINIT:5126                 retn
SYSINIT:5126 getcountrydestination endp
SYSINIT:5126
SYSINIT:5127
SYSINIT:5127 ; =============== S U B R O U T I N E =======================================
SYSINIT:5127
SYSINIT:5127
SYSINIT:5127 readincontrolbuffer proc near           ; CODE XREF: setdoscountryinfo+A↑p
SYSINIT:5127                                         ; setdoscountryinfo+30↑p ...
SYSINIT:5127                 push    ax              ; # of bytes to read
SYSINIT:5128                 mov     ax, 4200h
SYSINIT:512B                 stc
SYSINIT:512C                 int     21h             ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
SYSINIT:512C                                         ; AL = method: offset from beginning of file
SYSINIT:512E                 pop     cx              ; # of bytes to read
SYSINIT:512F                 jb      short ricb_exit
SYSINIT:5131                 xor     dx, dx          ; ds:dx -> control buffer
SYSINIT:5133                 xor     si, si
SYSINIT:5135                 mov     ah, 3Fh         ; read into the buffer
SYSINIT:5135                                         ; should be less than 1024 bytes.
SYSINIT:5137                 stc
SYSINIT:5138                 int     21h             ; DOS - 2+ - READ FROM FILE WITH HANDLE
SYSINIT:5138                                         ; BX = file handle, CX = number of bytes to read
SYSINIT:5138                                         ; DS:DX -> buffer
SYSINIT:513A
SYSINIT:513A ricb_exit:                              ; CODE XREF: readincontrolbuffer+8↑j
SYSINIT:513A                 retn
SYSINIT:513A readincontrolbuffer endp
SYSINIT:513A
SYSINIT:513B ; ---------------------------------------------------------------------------
SYSINIT:513B
SYSINIT:513B set_country_path:                       ; ! this procedure is not called from anywhere !
SYSINIT:513B                 push    si              ; Erdogan Tan - 04/08/2023
SYSINIT:513C                 push    ds
SYSINIT:513D                 push    es
SYSINIT:513E                 pop     ds
SYSINIT:513F                 pop     es
SYSINIT:5140                 call    chk_drive_letter
SYSINIT:5143                 jb      short scp_default_drv
SYSINIT:5145                 mov     al, [si]
SYSINIT:5147                 inc     si
SYSINIT:5148                 inc     si
SYSINIT:5149                 jmp     short scp_setdrv
SYSINIT:514B ; ---------------------------------------------------------------------------
SYSINIT:514B
SYSINIT:514B scp_default_drv:                        ; CODE XREF: SYSINIT:5143↑j
SYSINIT:514B                 mov     ah, 19h
SYSINIT:514D                 int     21h             ; DOS - GET DEFAULT DISK NUMBER
SYSINIT:514F                 add     al, 'A'
SYSINIT:5151
SYSINIT:5151 scp_setdrv:                             ; CODE XREF: SYSINIT:5149↑j
SYSINIT:5151                 mov     byte ptr cs:cntry_drv, al ; "A:"
SYSINIT:5155                 mov     di, offset cntry_path ; "COUNTRY.SYS"
SYSINIT:5158                 mov     al, [si]
SYSINIT:515A                 cmp     al, '\'
SYSINIT:515C                 jz      short scp_root_dir
SYSINIT:515E                 cmp     al, '/'
SYSINIT:5160                 jz      short scp_root_dir
SYSINIT:5162                 jmp     short scp_path
SYSINIT:5164 ; ---------------------------------------------------------------------------
SYSINIT:5164
SYSINIT:5164 scp_root_dir:                           ; CODE XREF: SYSINIT:515C↑j
SYSINIT:5164                                         ; SYSINIT:5160↑j
SYSINIT:5164                 dec     di
SYSINIT:5165
SYSINIT:5165 scp_path:                               ; CODE XREF: SYSINIT:5162↑j
SYSINIT:5165                 call    move_asciiz
SYSINIT:5168                 mov     di, offset cntry_drv ; "A:"
SYSINIT:516B                 push    ds
SYSINIT:516C                 push    es
SYSINIT:516D                 pop     ds
SYSINIT:516E                 pop     es
SYSINIT:516F                 pop     si
SYSINIT:5170                 retn
SYSINIT:5171
SYSINIT:5171 ; =============== S U B R O U T I N E =======================================
SYSINIT:5171
SYSINIT:5171
SYSINIT:5171 chk_drive_letter proc near              ; CODE XREF: SYSINIT:5140↑p
SYSINIT:5171                 push    ax
SYSINIT:5172                 cmp     byte ptr [si], 'A'
SYSINIT:5175                 jb      short cdletter_no
SYSINIT:5177                 cmp     byte ptr [si], 'Z'
SYSINIT:517A                 ja      short cdletter_no
SYSINIT:517C                 cmp     byte ptr [si+1], ':'
SYSINIT:5180                 jnz     short cdletter_no
SYSINIT:5182                 jmp     short cdletter_exit
SYSINIT:5184 ; ---------------------------------------------------------------------------
SYSINIT:5184
SYSINIT:5184 cdletter_no:                            ; CODE XREF: chk_drive_letter+4↑j
SYSINIT:5184                                         ; chk_drive_letter+9↑j ...
SYSINIT:5184                 stc
SYSINIT:5185
SYSINIT:5185 cdletter_exit:                          ; CODE XREF: chk_drive_letter+11↑j
SYSINIT:5185                 pop     ax
SYSINIT:5186                 retn
SYSINIT:5186 chk_drive_letter endp
SYSINIT:5186
SYSINIT:5187
SYSINIT:5187 ; =============== S U B R O U T I N E =======================================
SYSINIT:5187
SYSINIT:5187
SYSINIT:5187 move_asciiz     proc near               ; CODE XREF: doconf+715↑p
SYSINIT:5187                                         ; doconf+77A↑p ...
SYSINIT:5187                 movsb
SYSINIT:5188                 cmp     byte ptr [si-1], 0 ; was it 0?
SYSINIT:518C                 jnz     short move_asciiz
SYSINIT:518E                 retn
SYSINIT:518E move_asciiz     endp
SYSINIT:518E
SYSINIT:518F
SYSINIT:518F ; =============== S U B R O U T I N E =======================================
SYSINIT:518F
SYSINIT:518F
SYSINIT:518F badfil          proc near               ; CODE XREF: SYSINIT:0A09↑p
SYSINIT:518F                                         ; endfile+388↑p ...
SYSINIT:518F                 push    cs
SYSINIT:5190                 pop     es
SYSINIT:5191                 assume es:SYSINIT
SYSINIT:5191                 mov     si, dx
SYSINIT:5193
SYSINIT:5193 badload:                                ; CODE XREF: SYSINIT:142A↑p
SYSINIT:5193                                         ; doconf:tryd_2↑p ...
SYSINIT:5193                 mov     dx, offset badld_pre ; "\r\nBad or missing $"
SYSINIT:5196                 mov     bx, offset crlfm ; "\r\n$"
SYSINIT:5199
SYSINIT:5199 prnerr:                                 ; CODE XREF: doconf+6AD↑p
SYSINIT:5199                 push    cs
SYSINIT:519A                 pop     ds
SYSINIT:519B                 assume ds:SYSINIT
SYSINIT:519B                 call    print
SYSINIT:519E
SYSINIT:519E prn1:                                   ; CODE XREF: badfil+1B↓j
SYSINIT:519E                 mov     dl, es:[si]
SYSINIT:51A1                 or      dl, dl
SYSINIT:51A3                 jz      short prn2
SYSINIT:51A5                 mov     ah, 2
SYSINIT:51A7                 int     21h             ; DOS - DISPLAY OUTPUT
SYSINIT:51A7                                         ; DL = character to send to standard output
SYSINIT:51A9                 inc     si
SYSINIT:51AA                 jmp     short prn1
SYSINIT:51AC ; ---------------------------------------------------------------------------
SYSINIT:51AC
SYSINIT:51AC prn2:                                   ; CODE XREF: badfil+14↑j
SYSINIT:51AC                 mov     dx, bx
SYSINIT:51AE                 call    print
SYSINIT:51B1                 cmp     cs:donotshownum, 1 ; suppress line number when handling command.com
SYSINIT:51B7                 jz      short prnexit
SYSINIT:51B9                 call    error_line
SYSINIT:51BC
SYSINIT:51BC prnexit:                                ; CODE XREF: badfil+28↑j
SYSINIT:51BC                 retn
SYSINIT:51BC badfil          endp
SYSINIT:51BC
SYSINIT:51BD
SYSINIT:51BD ; =============== S U B R O U T I N E =======================================
SYSINIT:51BD
SYSINIT:51BD
SYSINIT:51BD print           proc near               ; CODE XREF: SYSINIT:0720↑p
SYSINIT:51BD                                         ; SYSINIT:09CB↑p ...
SYSINIT:51BD                 mov     ah, 9
SYSINIT:51BF                 int     21h             ; DOS - PRINT STRING
SYSINIT:51BF                                         ; DS:DX -> string terminated by "$"
SYSINIT:51C1                 retn
SYSINIT:51C1 print           endp
SYSINIT:51C1
SYSINIT:51C2
SYSINIT:51C2 ; =============== S U B R O U T I N E =======================================
SYSINIT:51C2
SYSINIT:51C2
SYSINIT:51C2 open_dev        proc near               ; CODE XREF: endfile+3A5↑p
SYSINIT:51C2                                         ; endfile+3AD↑p
SYSINIT:51C2                 call    open_file
SYSINIT:51C5                 jnb     short open_dev3
SYSINIT:51C7
SYSINIT:51C7 open_dev1:                              ; CODE XREF: open_dev+1D↓j
SYSINIT:51C7                 mov     dx, offset nuldev ; "NUL"
SYSINIT:51CA                 call    open_file
SYSINIT:51CD
SYSINIT:51CD of_retn:                                ; CODE XREF: open_dev+17↓j
SYSINIT:51CD                 retn
SYSINIT:51CE ; ---------------------------------------------------------------------------
SYSINIT:51CE
SYSINIT:51CE open_dev3:                              ; CODE XREF: open_dev+3↑j
SYSINIT:51CE                 mov     bx, ax          ; handle from open to bx
SYSINIT:51D0                 xor     ax, ax
SYSINIT:51D2                 mov     ah, 44h
SYSINIT:51D4                 int     21h             ; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
SYSINIT:51D4                                         ; BX = file or device handle
SYSINIT:51D6                 test    dl, 80h
SYSINIT:51D9                 jnz     short of_retn
SYSINIT:51DB                 mov     ah, 3Eh
SYSINIT:51DD                 int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
SYSINIT:51DD                                         ; BX = file handle
SYSINIT:51DF                 jmp     short open_dev1
SYSINIT:51DF open_dev        endp
SYSINIT:51DF
SYSINIT:51E1
SYSINIT:51E1 ; =============== S U B R O U T I N E =======================================
SYSINIT:51E1
SYSINIT:51E1
SYSINIT:51E1 open_file       proc near               ; CODE XREF: open_dev↑p
SYSINIT:51E1                                         ; open_dev+8↑p
SYSINIT:51E1                 mov     ah, 3Dh         ; OPEN
SYSINIT:51E3                 stc
SYSINIT:51E4                 int     21h             ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
SYSINIT:51E4                                         ; DS:DX -> ASCIZ filename
SYSINIT:51E4                                         ; AL = access mode
SYSINIT:51E4                                         ; 0 - read, 1 - write, 2 - read & write
SYSINIT:51E6                 retn
SYSINIT:51E6 open_file       endp
SYSINIT:51E6
SYSINIT:51E7 ; ---------------------------------------------------------------------------
SYSINIT:51E7
SYSINIT:51E7 int24:                                  ; DATA XREF: SYSINIT:070E↑o
SYSINIT:51E7                 mov     al, 3           ; fail the system call
SYSINIT:51E9                 iret                    ; return back to dos.
SYSINIT:51E9 ; ---------------------------------------------------------------------------
SYSINIT:51EA IBMDOSV71COPYR  db 'IBM DOS Version 7.1 (C)Copyright 1981-2002 IBM Corporation Licens'
SYSINIT:51EA                 db 'ed Material - Property of IBM All rights reserved '
SYSINIT:525D nuldev          db 'NUL',0              ; DATA XREF: open_dev:open_dev1↑o
SYSINIT:5261 condev          db 'CON',0              ; DATA XREF: endfile+37C↑o
SYSINIT:5265 auxdev          db 'AUX',0              ; DATA XREF: endfile:goaux2↑o
SYSINIT:5269 prndev          db 'PRN',0              ; DATA XREF: endfile+3A8↑o
SYSINIT:526D config          db '\CONFIG.SYS',0      ; DATA XREF: doconf+F↑o
SYSINIT:526D                                         ; doconf:conferr↑o
SYSINIT:5279 cntry_drv       db 'A:'                 ; DATA XREF: doconf+6C0↑w
SYSINIT:5279                                         ; doconf+712↑o ...
SYSINIT:527B cntry_root      db '\'                  ; DATA XREF: doconf:tryq_def↑o
SYSINIT:527B                                         ; doconf:tryqdefbad↑o
SYSINIT:527C cntry_path      db 'COUNTRY.SYS',0      ; DATA XREF: SYSINIT:5155↑o
SYSINIT:5288                 db 52 dup(0)
SYSINIT:52BC country_file_signature db 0FFh,'COUNTRY'
SYSINIT:52BC                                         ; DATA XREF: setdoscountryinfo+13↑o
SYSINIT:52C4 cntrycodepage_id dw 0                   ; DATA XREF: setdoscountryinfo:setdoscntry_got_it↑w
SYSINIT:52C4                                         ; setdoscountryinfo+EC↑r
SYSINIT:52C6 newcmd          db 0                    ; DATA XREF: SYSINIT:0987↑r
SYSINIT:52C6                                         ; SYSINIT:09FF↑r ...
SYSINIT:52C6                                         ; non-zero if non-std shell specified
SYSINIT:52C7 tmplate         db 64, 12               ; DATA XREF: SYSINIT:0A55↑o
SYSINIT:52C7                                         ; SYSINIT:0A4A↑r ...
SYSINIT:52C7                                         ; must precede commnd
SYSINIT:52C7                                         ; size of commnd line (excl. null)
SYSINIT:52C7                                         ; 5309h-52C9h = 40h = 64
SYSINIT:52C9 commnd          db '\COMMAND.COM',0     ; DATA XREF: SYSINIT:retry↑o
SYSINIT:52C9                                         ; SYSINIT:0A50↑w ...
SYSINIT:52D6                 db 50 dup(0)
SYSINIT:5308 commnd_63       db 0                    ; DATA XREF: doconf+944↑o
SYSINIT:5309 commnd2         db '\COMMAND.COM',0     ; DATA XREF: SYSINIT:0A15↑o
SYSINIT:5309                                         ; alternate commands to exec
SYSINIT:5316                 db 2,'/P',0             ; followed by their respective alternate command lines
SYSINIT:531A commnd3         db '\MSDOS\COMMAND.COM',0
SYSINIT:531A                                         ; DATA XREF: SYSINIT:do_def3↑o
SYSINIT:532D                 db 11
SYSINIT:532E                 db 'A:\MSDOS /P',0
SYSINIT:533A commnd4         db '\DOS\COMMAND.COM',0 ; DATA XREF: SYSINIT:comerr↑r
SYSINIT:533A                                         ; SYSINIT:0A31↑o
SYSINIT:534B                 db 9
SYSINIT:534C                 db 'A:\DOS /P',0
SYSINIT:5356 def_swchr       db 0                    ; DATA XREF: doconf+B↑w
SYSINIT:5356                                         ; disable_autoexec:dae_1↑r
SYSINIT:5357 command_line    db 2,'/P'               ; DATA XREF: SYSINIT:EXEC0_COM_LINE↑o
SYSINIT:5357                                         ; SYSINIT:093D↑r ...
SYSINIT:535A                 db 123 dup(0)
SYSINIT:53D5 command_line_126 db 0                   ; DATA XREF: doconf+95C↑o
SYSINIT:53D6                 db 0
SYSINIT:53D7 pathstring      db 64 dup(0)
SYSINIT:5417 dae_flag        db 0                    ; DATA XREF: SYSINIT:0AA7↑w
SYSINIT:5417                                         ; disable_autoexec+7↑r ...
SYSINIT:5418 bMenuColor      db 7                    ; DATA XREF: menu_check:set_color↑w
SYSINIT:5418                                         ; menu_check+1CF↑r ...
SYSINIT:5418                                         ; default fgnd/bgnd color
SYSINIT:5419 bMenuPage       db 0                    ; DATA XREF: menu_check+1C7↑r
SYSINIT:5419                                         ; menu_check+1FD↑r ...
SYSINIT:5419                                         ; menu video page (KEEP AFTER bMenuColor)
SYSINIT:541A                 db 5                    ; video page function # (KEEP AFTER bMenuPage)
SYSINIT:541B bLastCol        db 0                    ; DATA XREF: menu_check+218↑w
SYSINIT:541B                                         ; show_status+C↑r
SYSINIT:541B                                         ; ending column on status line
SYSINIT:541C bLastRow        db 24                   ; DATA XREF: menu_check+1E5↑r
SYSINIT:541C                                         ; menu_check+1EC↑w ...
SYSINIT:541C                                         ; row # of status line (KEEP AFTER bLastCol)
SYSINIT:541D bDisableUI      db 0                    ; DATA XREF: SYSINIT:091E↑r
SYSINIT:541D                                         ; kbd_read↑r ...
SYSINIT:541D                                         ; 1=disable clean/interactive
SYSINIT:541D                                         ; 2=disable default 2-second delay
SYSINIT:541E bCRTPage        db 0                    ; DATA XREF: menu_check+1C4↑w
SYSINIT:541E                                         ; menu_check+34B↑r
SYSINIT:541E                                         ; value saved from BIOS data area
SYSINIT:541F wCRTStart       dw 0                    ; DATA XREF: menu_check+1BD↑w
SYSINIT:541F                                         ; menu_check+344↑r
SYSINIT:541F                                         ; value saved from BIOS data area
SYSINIT:5421 bQueryOpt       db 0                    ; DATA XREF: SYSINIT:bypass_autoexec↑w
SYSINIT:5421                                         ; kbd_read+34↑w ...
SYSINIT:5421                                         ; 0=off, 1=prompt all, 2=prompt none, 4=skip all
SYSINIT:5422 bDefBlock       db 1                    ; DATA XREF: menu_check:menu_found↑w
SYSINIT:5422                                         ; menu_check:menu_setdefault↑w ...
SYSINIT:5422                                         ; default block #
SYSINIT:5423 bMaxBlock       db 0                    ; DATA XREF: menu_check+16C↑w
SYSINIT:5423                                         ; menu_check+18E↑r ...
SYSINIT:5423                                         ; maximum block #
SYSINIT:5424 offDefBlock     dw 0                    ; DATA XREF: menu_check+B5↑w
SYSINIT:5424                                         ; menu_check:menu_default↑w ...
SYSINIT:5424                                         ; offset of name of default block (if any)
SYSINIT:5426 secTimeOut      db 0FFh                 ; DATA XREF: menu_check+BB↑w
SYSINIT:5426                                         ; menu_check:timeout_ok↑w ...
SYSINIT:5426                                         ; # of seconds for timeout (-1 == indefinite)
SYSINIT:5427 secElapsed      db 0                    ; DATA XREF: kbd_read+74↑w
SYSINIT:5427                                         ; menu_check+103↑r ...
SYSINIT:5427                                         ; # of seconds elapsed so far (KEEP AFTER secTimeOut)
SYSINIT:5428 abBlockType     db 10 dup(0)            ; DATA XREF: menu_check+13B↑w
SYSINIT:5428                                         ; menu_check:not_topmenu↑r
SYSINIT:5428                                         ; times MAX_MULTI_CONFIG+1 db 0
SYSINIT:5428                                         ; array of block types
SYSINIT:5432 aoffBlockName   dw 10 dup(0)            ; DATA XREF: menu_check+141↑w
SYSINIT:5432                                         ; menu_check+17C↑r ...
SYSINIT:5432                                         ; times MAX_MULTI_CONFIG+1 dw 0
SYSINIT:5432                                         ; array of offsets of block names
SYSINIT:5446 aoffBlockDesc   dw 10 dup(0)            ; DATA XREF: menu_check+145↑w
SYSINIT:5446                                         ; menu_check+157↑w ...
SYSINIT:5446                                         ; times MAX_MULTI_CONFIG+1 dw 0
SYSINIT:5446                                         ; array of offsets of block descriptions
SYSINIT:545A szBoot          db 'CONFIG=',0          ; DATA XREF: menu_check+70↑w
SYSINIT:545A                                         ; menu_check+2E9↑o
SYSINIT:5462 szMenu          db 'MENU',0             ; DATA XREF: menu_check+68↑o
SYSINIT:5462                                         ; copy_block+17↑o
SYSINIT:5467 szCommon        db 'COMMON',0           ; DATA XREF: menu_check+2AB↑o
SYSINIT:5467                                         ; menu_check+303↑o ...
SYSINIT:546E comtab          db 1,'[['               ; DATA XREF: organize+36↑o
SYSINIT:546E                                         ; query_user+2F↑o
SYSINIT:546E                                         ; CONFIG.SYS Command Table
SYSINIT:546E                                         ; CONFIG_BEGIN
SYSINIT:5471 aBreak          db 5,'BREAKC'           ; CONFIG_BREAK
SYSINIT:5478 aBuffers        db 7,'BUFFERSB'         ; CONFIG_BUFFERS
SYSINIT:5481 aComment        db 7,'COMMENTY'         ; CONFIG_COMMENT
SYSINIT:548A aCountry        db 7,'COUNTRYQ'         ; CONFIG_COUNTRY
SYSINIT:5493 aDevice         db 6,'DEVICED'          ; CONFIG_DEVICE
SYSINIT:549B aDevicehigh     db 0Ah                  ; CONFIG_DEVICEHIGH
SYSINIT:549B                 db 'DEVICEHIGHU'
SYSINIT:54A7 aDos            db 3,'DOSH'             ; CONFIG_DOS
SYSINIT:54AC aDrivparm       db 8,'DRIVPARMP'        ; CONFIG_DRIVPARM
SYSINIT:54B6 aFcbs           db 4,'FCBSX'            ; CONFIG_FCBS
SYSINIT:54BC aFiles          db 5,'FILESF'           ; CONFIG_FILES
SYSINIT:54C3 aInclude        db 7,'INCLUDEJ'         ; CONFIG_INCLUDE
SYSINIT:54CC aInstall        db 7,'INSTALLI'         ; CONFIG_INSTALL
SYSINIT:54D5 aInstallhigh    db 0Bh,'INSTALLHIGHW'   ; CONFIG_INSTALLHIGH
SYSINIT:54E2 aLastdrive      db 9,'LASTDRIVEL'       ; CONFIG_LASTDRIVE
SYSINIT:54ED aSubmenu        db 7,'SUBMENUO'         ; CONFIG_SUBMENU
SYSINIT:54F6 aMenucolor      db 9,'MENUCOLORR'       ; CONFIG_MENUCOLOR
SYSINIT:5501 aMenudefault    db 0Bh,'MENUDEFAULTA'   ; CONFIG_MENUDEFAULT
SYSINIT:550E aMenuitem       db 8,'MENUITEME'        ; CONFIG_MENUITEM
SYSINIT:5518 aMultitrack     db 0Ah                  ; CONFIG_MULTITRACK
SYSINIT:5518                 db 'MULTITRACKM'
SYSINIT:5524 aNumlock        db 7,'NUMLOCKN'         ; CONFIG_NUMLOCK
SYSINIT:552D aRem            db 3,'REM0'             ; CONFIG_REM
SYSINIT:5532 aSet            db 3,'SETV'             ; CONFIG_SET
SYSINIT:5537 aShell          db 5,'SHELLS'           ; CONFIG_SHELL
SYSINIT:553E aStacks         db 6,'STACKSK'          ; CONFIG_STACKS
SYSINIT:5546 aSwitches       db 8,'SWITCHES1'        ; CONFIG_SWITCHES
SYSINIT:5550 aDosdata        db 7,'DOSDATAT'         ; CONFIG_DOSDATA
SYSINIT:5559                 db 0                    ; end of command table
SYSINIT:555A devp_specialfunc db 0                   ; DATA XREF: endfile+13C↑o
SYSINIT:555A                                         ; setparms+F↑o
SYSINIT:555A                                         ; deviceparameters
SYSINIT:555B devp_devtype    db 2                    ; DATA XREF: diddleback+9↑w
SYSINIT:555B                                         ; process_num+17↑w ...
SYSINIT:555C devp_devattr    dw 0                    ; DATA XREF: diddleback+E↑w
SYSINIT:555C                                         ; parseline+39↑w
SYSINIT:555E devp_cylinders  dw 80                   ; DATA XREF: diddleback+3↑w
SYSINIT:555E                                         ; process_num+26↑w ...
SYSINIT:5560                 db 0
SYSINIT:5561 devp_bps        dw 0                    ; DATA XREF: endfile+14D↑r
SYSINIT:5561                                         ; setdeviceparameters+1A↑o
SYSINIT:5561                                         ; A_DEVICEPARAMETERS.DP_BPB
SYSINIT:5561                                         ; bytes per sectors
SYSINIT:5563 devp_secperclus db 0                    ; DATA XREF: setdeviceparameters:heads_not_altered↑w
SYSINIT:5563                                         ; setdeviceparameters:got_one_secperclus_drive↑w
SYSINIT:5564                 dw 0
SYSINIT:5566                 db 0
SYSINIT:5567                 dw 0
SYSINIT:5569 devp_totalsecs  dw 0                    ; DATA XREF: endfile+149↑r
SYSINIT:5569                                         ; setdeviceparameters+9E↑w
SYSINIT:5569                                         ; total sectors
SYSINIT:556B devp_mediaid    db 0                    ; DATA XREF: setdeviceparameters+47↑r
SYSINIT:556B                                         ; setdeviceparameters:got_correct_mediaid↑w
SYSINIT:556C                 dw 0
SYSINIT:556E devp_spt        dw 0                    ; DATA XREF: setparms:not_ec35↑r
SYSINIT:556E                                         ; setdeviceparameters+2F↑w ...
SYSINIT:5570 devp_heads      dw 0                    ; DATA XREF: setdeviceparameters+3D↑w
SYSINIT:5570                                         ; setdeviceparameters+4B↑r ...
SYSINIT:5572                 db 68 dup(0)
SYSINIT:55B6 devp_trktblents dw 0                    ; DATA XREF: parseline+3C↑w
SYSINIT:55B8                 db 252 dup(0)
SYSINIT:56B4 hlim            dw 2                    ; DATA XREF: process_num:try_h↑w
SYSINIT:56B4                                         ; setdeviceparameters+3A↑r
SYSINIT:56B6 slim            dw 9                    ; DATA XREF: process_num+31↑w
SYSINIT:56B6                                         ; setdeviceparameters+2C↑r
SYSINIT:56B8 drive           db 0                    ; DATA XREF: setparms+9↑r
SYSINIT:56B8                                         ; setparms+2A↑r ...
SYSINIT:56B9 switches        dw 0                    ; DATA XREF: setparms+21↑r
SYSINIT:56B9                                         ; diddleback+14↑w ...
SYSINIT:56BB _bpb48t         dw 512                  ; DATA XREF: SYSINIT:_bpbtable↓o
SYSINIT:56BB                                         ; 48 tpi diskettes
SYSINIT:56BD                 db 2
SYSINIT:56BE                 dw 1
SYSINIT:56C0                 db 2
SYSINIT:56C1                 dw 112
SYSINIT:56C3                 dw 720                  ; 2*9*40
SYSINIT:56C5                 db 0FDh
SYSINIT:56C6                 dw 2
SYSINIT:56C8                 dw 9
SYSINIT:56CA                 dw 2
SYSINIT:56CC                 dd 0
SYSINIT:56D0                 dd 0
SYSINIT:56D4 _bpb96t         dw 512                  ; DATA XREF: SYSINIT:573A↓o
SYSINIT:56D4                                         ; 96tpi diskettes
SYSINIT:56D6                 db 1
SYSINIT:56D7                 dw 1
SYSINIT:56D9                 db 2
SYSINIT:56DA                 dw 224
SYSINIT:56DC                 dw 2400                 ; 2*15*80
SYSINIT:56DE                 db 0F9h
SYSINIT:56DF                 dw 7
SYSINIT:56E1                 dw 15
SYSINIT:56E3                 dw 2
SYSINIT:56E5                 dd 0
SYSINIT:56E9                 dd 0
SYSINIT:56ED _bpb35          dw 200h                 ; DATA XREF: SYSINIT:573C↓o
SYSINIT:56ED                                         ; SYSINIT:573E↓o ...
SYSINIT:56ED                                         ; 3 1/2 inch diskette bpb
SYSINIT:56EF                 db 2
SYSINIT:56F0                 dw 1
SYSINIT:56F2                 db 2
SYSINIT:56F3                 dw 112
SYSINIT:56F5                 dw 1440                 ; 2*9*80
SYSINIT:56F7                 db 0F9h
SYSINIT:56F8                 dw 3
SYSINIT:56FA                 dw 9
SYSINIT:56FC                 dw 2
SYSINIT:56FE                 dd 0
SYSINIT:5702                 dd 0
SYSINIT:5706 _bpb35h         dw 512                  ; DATA XREF: SYSINIT:5746↓o
SYSINIT:5708                 db 1
SYSINIT:5709                 dw 1
SYSINIT:570B                 db 2
SYSINIT:570C                 dw 224
SYSINIT:570E                 dw 2880                 ; 2*18*80
SYSINIT:5710                 db 0F0h
SYSINIT:5711                 dw 9
SYSINIT:5713                 dw 18
SYSINIT:5715                 dw 2
SYSINIT:5717                 dd 0
SYSINIT:571B                 dd 0
SYSINIT:571F _bpb288         dw 512                  ; DATA XREF: SYSINIT:574A↓o
SYSINIT:5721                 db 2
SYSINIT:5722                 dw 1
SYSINIT:5724                 db 2
SYSINIT:5725                 dw 240
SYSINIT:5727                 dw 5760                 ; 2*36*80
SYSINIT:5729                 db 0F0h
SYSINIT:572A                 dw 9
SYSINIT:572C                 dw 36
SYSINIT:572E                 dw 2
SYSINIT:5730                 dd 0
SYSINIT:5734                 dd 0
SYSINIT:5738 _bpbtable       dw offset _bpb48t       ; DATA XREF: setdeviceparameters+16↑r
SYSINIT:5738                                         ; 48tpi drives
SYSINIT:573A                 dw offset _bpb96t       ; 96tpi drives
SYSINIT:573C                 dw offset _bpb35        ; 3.5" drives
SYSINIT:573E                 dw offset _bpb35        ; not used - 8" drives - default to 3.5"
SYSINIT:5740                 dw offset _bpb35        ; not used - 8" drives - default to 3.5"
SYSINIT:5742                 dw offset _bpb35        ; not used - hard files - default to 3.5"
SYSINIT:5744                 dw offset _bpb35        ; not used - tape drives - default to 3.5"
SYSINIT:5746                 dw offset _bpb35h       ; 3-1/2" 1.44mb drive
SYSINIT:5748                 dw offset _bpb35        ; ERIMO
SYSINIT:574A                 dw offset _bpb288       ; 2.88 MB diskette drives
SYSINIT:574C switchlist      db 8,'FHSTDICN'         ; DATA XREF: check_switch+12↑r
SYSINIT:574C                                         ; check_switch+18↑o
SYSINIT:574C                                         ; preserve the positions of n and c
SYSINIT:5755                 db 0
SYSINIT:5756 badopm          db 0Dh,0Ah              ; DATA XREF: SYSINIT:331C↑o
SYSINIT:5756                                         ; doconf:badop↑o
SYSINIT:5756                 db 'Unrecognized command in CONFIG.SYS'
SYSINIT:577A crlfm           db 0Dh,0Ah,'$'          ; DATA XREF: SYSINIT:0A5C↑o
SYSINIT:577A                                         ; doconf+6AA↑o ...
SYSINIT:577D badparm         db 0Dh,0Ah              ; DATA XREF: badparm_p+5↑o
SYSINIT:577D                 db 'Bad command or parameters - $'
SYSINIT:579C badsiz_pre      db 0Dh,0Ah              ; DATA XREF: doconf+6A7↑o
SYSINIT:579C                 db 'Sector size too large in file $'
SYSINIT:57BD badld_pre       db 0Dh,0Ah              ; DATA XREF: badfil:badload↑o
SYSINIT:57BD                 db 'Bad or missing $'
SYSINIT:57CF badcom          db 'Command Interpreter',0
SYSINIT:57CF                                         ; DATA XREF: SYSINIT:comerr2↑o
SYSINIT:57E3 badcountry      db 0Dh,0Ah              ; DATA XREF: doconf+72A↑o
SYSINIT:57E3                                         ; cntry_error+5↑o
SYSINIT:57E3                 db 'Invalid country code or code page',0Dh,0Ah,'$'
SYSINIT:5809 badcountrycom   db 0Dh,0Ah              ; DATA XREF: cntry_error:if64↑o
SYSINIT:5809                 db 'Error in COUNTRY command',0Dh,0Ah,'$'
SYSINIT:5826 insufmemory     db 0Dh,0Ah              ; DATA XREF: doconf:tryqmemory↑o
SYSINIT:5826                 db 'Insufficient memory for COUNTRY.SYS file',0Dh,0Ah,'$'
SYSINIT:5853 badmem          db 0Dh,0Ah              ; DATA XREF: SYSINIT:memerrjx↑o
SYSINIT:5853                                         ; round:mem_err↑o
SYSINIT:5853                 db 'Configuration too large for memory',0Dh,0Ah,'$'
SYSINIT:587A badblock        db 0Dh,0Ah              ; DATA XREF: doconf+4D6↑o
SYSINIT:587A                 db 'Too many block devices',0Dh,0Ah,'$'
SYSINIT:5895 badstack        db 0Dh,0Ah              ; DATA XREF: doconf+881↑o
SYSINIT:5895                                         ; doconf+8F4↑o
SYSINIT:5895                 db 'Invalid STACK parameters',0Dh,0Ah,'$'
SYSINIT:58B2 badorder        db 0Dh,0Ah              ; DATA XREF: SYSINIT:incorrect_order↑o
SYSINIT:58B2                 db 'Incorrect order in CONFIG.SYS line $'
SYSINIT:58D8 errorcmd        db 'Error in CONFIG.SYS line $'
SYSINIT:58D8                                         ; DATA XREF: error_line+2↑o
SYSINIT:58F2 OnOff           db 'ON'                 ; DATA XREF: set_numlock:not_off↑r
SYSINIT:58F4 OnOff2          db 'OFF'                ; DATA XREF: set_numlock+F↑r
SYSINIT:58F7 StartMsg        db 'Starting PC DOS...',0Dh,0Ah
SYSINIT:58F7                                         ; DATA XREF: BIOSDATA:1D7F↑o
SYSINIT:58F7                 db 0Ah,0
SYSINIT:590D _$PauseMsg      db 'Press any key to continue...',0Dh,0Ah,'$'
SYSINIT:590D                                         ; DATA XREF: print_error+15↑o
SYSINIT:592C _$CleanMsg      db 'PC DOS is bypassing your CONFIG.SYS and AUTOEXEC.BAT files.',0Dh,0Ah
SYSINIT:592C                                         ; DATA XREF: kbd_read:kbd_cfg_bypass↑o
SYSINIT:592C                 db '$'
SYSINIT:596A _$InterMsg      db 'PC DOS will prompt you to confirm each CONFIG.SYS command.',0Dh,0Ah
SYSINIT:596A                                         ; DATA XREF: kbd_read:kbd_cfg_confirm↑o
SYSINIT:596A                 db '$'
SYSINIT:59A7 _$MenuHeader    db 0Dh,0Ah              ; DATA XREF: menu_check+1F0↑o
SYSINIT:59A7                 db '  PC DOS 7.1 Startup Menu',0Dh,0Ah
SYSINIT:59A7                 db '  '
SYSINIT:59C6                 db 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh ; '═' ; ASCII code 205
SYSINIT:59C6                 db 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh
SYSINIT:59C6                 db 0CDh, 0CDh, 0CDh, 0CDh, 0CDh, 0CDh
SYSINIT:59DE                 db 0Dh,0Ah
SYSINIT:59E0                 db  24h ; $
SYSINIT:59E1 _$MenuPrmpt     db '  Enter a choice: $'
SYSINIT:59E1                                         ; DATA XREF: menu_check+238↑o
SYSINIT:59F4 _$StatusLine    db 'F5=Bypass startup files F8=Confirm each line of CONFIG.SYS and AU'
SYSINIT:59F4                                         ; DATA XREF: menu_check+20B↑o
SYSINIT:59F4                 db 'TOEXEC.BAT [ ]$'
SYSINIT:5A44 _$InterPrmpt    db ' [Y,N,ESC]?$'       ; DATA XREF: query_user:prompt_user↑o
SYSINIT:5A50 _$YES           db 'YES$'               ; DATA XREF: show_status+31↑r
SYSINIT:5A50                                         ; query_user+9E↑r ...
SYSINIT:5A54 _$NO            db 'NO $'               ; DATA XREF: show_status+27↑r
SYSINIT:5A54                                         ; query_user+8C↑r ...
SYSINIT:5A58 _$TimeOut       db 'Time remaining: $'  ; DATA XREF: select_item+42↑o
SYSINIT:5A69 badcomprmpt     db 'Enter correct name of Command Interpreter (for example, C:\COMMAN'
SYSINIT:5A69                                         ; DATA XREF: SYSINIT:0A3A↑o
SYSINIT:5A69                 db 'D.COM)',0Dh,0Ah,'$'
SYSINIT:5AB3 _$AutoPrmpt     db 'Process AUTOEXEC.BAT [Y,N]?$'
SYSINIT:5AB3                                         ; DATA XREF: query_user+24↑o
SYSINIT:5ACF TooManyDrivesMsg db 'WARNING! Logical drives past Z: exist and will be ignored',0Dh,0Ah
SYSINIT:5ACF                                         ; DATA XREF: SYSINIT:071D↑o
SYSINIT:5ACF                 db '$'
SYSINIT:5B0B baddblspace     db 'Required system component is not installed',0Dh,0Ah
SYSINIT:5B0B                                         ; DATA XREF: MagicPreload+7D↑o
SYSINIT:5B0B                 db '$',0
SYSINIT:5B39                 db 7 dup(0)
SYSINIT:5B39 SYSINIT         ends
SYSINIT:5B39
SYSINIT:5B39
SYSINIT:5B39                 end
