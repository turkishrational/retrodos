//
// +-------------------------------------------------------------------------+
// |   This file has been generated by The Interactive Disassembler (IDA)    |
// |           Copyright (c) 2013 Hex-Rays, <support@hex-rays.com>           |
// |                      Licensed to: Freeware version                      |
// +-------------------------------------------------------------------------+
//
//
//      This file should be used in the following way:
//         - reload executable into IDA with using switch -c
//         - use File, Load IDC file and load this file.
//
//      NOTE: This file doesn't contain all information from the database.
//

#define UNLOADED_FILE   1
#include <idc.idc>

static main(void)
{
  // set 'loading idc file' mode
  SetCharPrm(INF_GENFLAGS, INFFL_LOADIDC|GetCharPrm(INF_GENFLAGS));
  GenInfo();            // various settings
  Segments();           // segmentation
  Enums();              // enumerations
  Structures();         // structure types
  Patches();            // manual patches
  SegRegs();            // segment register values
  Bytes();              // individual bytes (code,data)
  Functions();          // function definitions
  // clear 'loading idc file' mode
  SetCharPrm(INF_GENFLAGS, ~INFFL_LOADIDC&GetCharPrm(INF_GENFLAGS));
}

//------------------------------------------------------------------------
// General information

static GenInfo(void) {

        DeleteAll();    // purge database
	SetPrcsr("80386r");
	SetCharPrm(INF_COMPILER, 0);
	StringStp(0xA);
	Tabs(1);
	Comments(0);
	Voids(0);
	XrefShow(2);
	AutoShow(1);
	Indent(16);
	CmtIndent(40);
	TailDepth(0x10);
}

//------------------------------------------------------------------------
// Information about segmentation

static Segments(void) {
	SetSelector(0X1,0);
	;
	SegCreate(0,0X25C0,0X1,0,1,2);
	SegRename(0,"BIOSDATA");
	SegClass (0,"BIOSDATA");
	SegDefReg(0x0,"es",0x70);
	SegDefReg(0x0,"ss",0x0);
	SegDefReg(0x0,"ds",0x0);
	SegDefReg(0x0,"fs",0x0);
	SegDefReg(0x0,"gs",0x0);
	SegCreate(0X25C0,0X4030,0X25C,0,1,2);
	SegRename(0X25C0,"BIOSCODE");
	SegClass (0X25C0,"BIOSCODE");
	SegCreate(0X4030,0X98D0,0X403,0,1,2);
	SegRename(0X4030,"SYSINIT");
	SegClass (0X4030,"SYSINIT");
	LowVoids(0x0);
	HighVoids(0x98D0);
}

//------------------------------------------------------------------------
// Information about enum types

static Enums(void) {
        auto id;
        BeginTypeUpdating(UTP_ENUM);
}

//------------------------------------------------------------------------
// Information about structure types

static Structures(void) {
        auto id;
        BeginTypeUpdating(UTP_STRUCT);
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_0(void) {
        auto x;
#define id x

	ExtLinA		(0,	0,	"; File Name   : C:\\Users\\erdogan.tan\\Desktop\\IO621SYS.BIN");
	ExtLinA		(0,	1,	"; Format      : Binary file");
	ExtLinA		(0,	2,	"; Base Address: 0000h Range: 0000h - 98D0h Loaded length: 98D0h");
	MakeCode	(0);
	MakeName	(0,	"BData_start");
	MakeWord	(0X3);
	MakeName	(0X3,	"DosDataSg");
	MakeComm	(0X5,	"far jump to int_2f (segment may not be at 70h)");
	MakeByte	(0X5);
	MakeName	(0X5,	"bios_i2f");
	MakeWord	(x=0X6);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeWord	(0X8);
	MakeComm	(0XA,	"The start address for the romfind routines");
	MakeWord	(0XA);
	MakeName	(0XA,	"romstartaddr");
	MakeComm	(0XC,	"special key handling");
	MakeByte	(0XC);
	MakeName	(0XC,	"altah");
	MakeComm	(0XD,	"flag indicates we're running from HMA");
	MakeByte	(0XD);
	MakeName	(0XD,	"inHMA");
	MakeComm	(0XE,	"entry point to xms if above is true");
	MakeDword	(0XE);
	MakeName	(0XE,	"xms");
	MakeComm	(0X12,	"pointer save\nThis variable holds the pointer to \nthe Request Header passed by a program wishing\nto use a device driver. When the strategy routine\nis called it puts the address of the Request header\nin this variable and returns.");
	MakeDword	(0X12);
	MakeName	(0X12,	"ptrsav");
	MakeComm	(0X16,	"set of 1 byte buffers for com 1,2,3, and 4");
	MakeByte	(0X16);
	MakeArray	(0X16,	0X4);
	MakeName	(0X16,	"auxbuf");
	MakeComm	(0X1A,	"easy way to load segment registers with zero");
	MakeWord	(0X1A);
	MakeName	(0X1A,	"zeroseg");
	MakeComm	(0X1C,	"ds register for int 13h call through");
	MakeWord	(0X1C);
	MakeName	(0X1C,	"i13_ds");
	MakeComm	(0X1E,	"holds int 13h request (i.e. register ax).");
	MakeWord	(0X1E);
	MakeName	(0X1E,	"prevoper");
	MakeComm	(0X20,	"holds number of secs. to read on an ecc error");
	MakeByte	(0X20);
	MakeName	(0X20,	"number_of_sec");
	MakeComm	(0X21,	"which aux device was requested");
	MakeWord	(0X21);
	MakeName	(0X21,	"auxnum");
	MakeComm	(0X23,	"CONHeader ;  Device Header for the CON Device Driver");
	MakeWord	(x=0X23);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X23,	"res_dev_list");
	MakeWord	(0X25);
	MakeWord	(0X27);
	MakeWord	(x=0X29);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeWord	(x=0X2B);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeStr		(0X2D,	0X35);
	MakeWord	(x=0X35);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X35,	"auxdev2");
	MakeWord	(0X37);
	MakeWord	(0X39);
	MakeWord	(x=0X3B);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeWord	(x=0X3D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeStr		(0X3F,	0X47);
	MakeWord	(x=0X47);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X47,	"prndev2");
	MakeWord	(0X49);
	MakeWord	(0X4B);
	MakeWord	(x=0X4D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeWord	(x=0X4F);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeStr		(0X51,	0X59);
	MakeWord	(x=0X59);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X59,	"timdev");
	MakeWord	(0X5B);
	MakeWord	(0X5D);
	MakeWord	(x=0X5F);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeWord	(x=0X61);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeStr		(0X63,	0X6B);
	MakeWord	(x=0X6B);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X6B,	"dskdev");
	MakeWord	(0X6D);
	MakeWord	(0X6F);
	MakeWord	(x=0X71);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeWord	(x=0X73);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X75,	"maximum number of drives");
	MakeByte	(0X75);
	MakeName	(0X75,	"drvmax");
	MakeComm	(0X76,	"-2 ; last drive accessed");
	MakeByte	(x=0X76);
	OpHex		(x,	0);
	MakeName	(0X76,	"step_drv");
	MakeComm	(0X77,	"flag to indicate presence of 96tpi support");
	MakeByte	(0X77);
	MakeName	(0X77,	"fhave96");
	MakeComm	(0X78,	"used to detect single drive systems");
	MakeByte	(0X78);
	MakeName	(0X78,	"single");
	MakeComm	(0X79,	"indicates if this is a k09 or not\n used by console driver.");
	MakeByte	(0X79);
	MakeName	(0X79,	"fhavek09");
	MakeComm	(0X7A,	"= 1 if we are setting the owner of a drive.\n (examined by checksingle).");
	MakeByte	(0X7A);
	MakeName	(0X7A,	"fsetowner");
	MakeComm	(0X7B,	"Device Header for device \"COM1\"");
	MakeWord	(x=0X7B);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X7B,	"com1dev");
	MakeWord	(0X7D);
	MakeWord	(0X7F);
	MakeWord	(x=0X81);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeWord	(x=0X83);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeStr		(0X85,	0X8D);
	MakeWord	(x=0X8D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X8D,	"lpt1dev");
	MakeWord	(0X8F);
	MakeWord	(0X91);
	MakeWord	(x=0X93);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeWord	(x=0X95);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeStr		(0X97,	0X9F);
	MakeWord	(x=0X9F);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X9F,	"lpt2dev");
	MakeWord	(0XA1);
	MakeWord	(x=0XA3);
	OpHex		(x,	0);
	MakeWord	(x=0XA5);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeWord	(x=0XA7);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeStr		(0XA9,	0XB1);
	MakeByte	(0XB1);
	MakeArray	(0XB1,	0X3);
	MakeComm	(0XB4,	"Orig13 needs to be at offset 0B4h\n for the CMS floppy driver to work.");
	MakeDword	(0XB4);
	MakeName	(0XB4,	"Orig13");
	MakeComm	(0XB8,	"Device Header for device LPT3");
	MakeWord	(x=0XB8);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0XB8,	"lpt3dev");
	MakeWord	(0XBA);
	MakeWord	(0XBC);
	MakeWord	(x=0XBE);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeWord	(x=0XC0);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeStr		(0XC2,	0XCA);
	MakeWord	(x=0XCA);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0XCA,	"com2dev");
	MakeWord	(0XCC);
	MakeWord	(0XCE);
	MakeWord	(x=0XD0);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeWord	(x=0XD2);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeStr		(0XD4,	0XDC);
	MakeWord	(x=0XDC);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0XDC,	"com3dev");
	MakeWord	(0XDE);
	MakeWord	(0XE0);
	MakeWord	(x=0XE2);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeWord	(x=0XE4);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeStr		(0XE6,	0XEE);
	MakeWord	(0XEE);
	MakeName	(0XEE,	"com4dev");
	MakeWord	(0XF0);
	MakeWord	(0XF2);
	MakeWord	(x=0XF4);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeWord	(x=0XF6);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeStr		(0XF8,	0X100);
	MakeByte	(0X100);
	MakeName	(0X100,	"RomVectors");
	MakeDword	(0X101);
	MakeName	(0X101,	"Old10");
	MakeByte	(0X105);
	MakeDword	(0X106);
	MakeName	(0X106,	"Old13");
	MakeByte	(0X10A);
	MakeDword	(0X10B);
	MakeName	(0X10B,	"Old15");
	MakeByte	(0X10F);
	MakeDword	(0X110);
	MakeName	(0X110,	"Old19");
	MakeByte	(0X114);
	MakeDword	(0X115);
	MakeName	(0X115,	"Old1B");
	MakeComm	(0X119,	"Start of linked list of BDS's");
	MakeWord	(x=0X119);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X119,	"start_bds");
	MakeComm	(0X11B,	"KERNEL_SEGMENT (BIOSDATA segment)");
	MakeWord	(0X11B);
	MakeByte	(0X11D);
	MakeName	(0X11D,	"accesscount");
	MakeByte	(0X11E);
	MakeName	(0X11E,	"tim_drv");
	MakeByte	(0X11F);
	MakeName	(0X11F,	"medbyt");
	MakeComm	(0X120,	"2 for read, 3 for write");
	MakeByte	(0X120);
	MakeName	(0X120,	"rflag");
	MakeComm	(0X121,	"1 if verify after write");
	MakeByte	(0X121);
	MakeName	(0X121,	"verify");
	MakeWord	(0X122);
	MakeName	(0X122,	"seccnt");
	MakeComm	(0X124,	"-- pad where hardnum was");
	MakeByte	(0X124);
	MakeComm	(0X125,	"number of diskette drives");
	MakeByte	(0X125);
	MakeName	(0X125,	"dsktnum");
	MakeComm	(0X126,	"value from table");
	MakeByte	(0X126);
	MakeName	(0X126,	"motorstartup");
	MakeComm	(0X127,	"value from table");
	MakeByte	(0X127);
	MakeName	(0X127,	"settlecurrent");
	MakeComm	(0X128,	"slow settle value");
	MakeByte	(0X128);
	MakeName	(0X128,	"settleslow");
	MakeComm	(0X129,	"value of speed to be used");
	MakeByte	(0X129);
	MakeName	(0X129,	"nextspeed");
	MakeComm	(0X12A,	"used by read_sector routine");
	MakeByte	(0X12A);
	MakeName	(0X12A,	"save_head_sttl");
	MakeComm	(0X12B,	"saved eot from the default DPT");
	MakeByte	(0X12B);
	MakeName	(0X12B,	"save_eot");
	MakeByte	(0X12C);
	MakeName	(0X12C,	"eot");
	MakeComm	(0X12D,	"pointer to Disk Parameter Table");
	MakeDword	(0X12D);
	MakeName	(0X12D,	"dpt");
	MakeComm	(0X131,	"current sector");
	MakeByte	(0X131);
	MakeName	(0X131,	"cursec");
	MakeComm	(0X132,	"current head");
	MakeByte	(0X132);
	MakeName	(0X132,	"curhd");
	MakeComm	(0X133,	"current track");
	MakeWord	(0X133);
	MakeName	(0X133,	"curtrk");
	MakeComm	(0X135,	"save the stack pointer");
	MakeWord	(0X135);
	MakeName	(0X135,	"spsav");
	MakeComm	(0X137,	"eot used for format");
	MakeByte	(0X137);
	MakeName	(0X137,	"formt_eot");
	MakeComm	(0X138,	"head number");
	MakeByte	(0X138);
	MakeName	(0X138,	"hdnum");
	MakeComm	(0X139,	"track being manipulated");
	MakeWord	(0X139);
	MakeName	(0X139,	"trknum");
	MakeComm	(0X13B,	"format gap patched into dpt");
	MakeByte	(0X13B);
	MakeName	(0X13B,	"gap_patch");
	MakeComm	(0X13C,	"disk errors returned from the IBM rom\nwrite fault");
	MakeByte	(0X13C);
	MakeName	(0X13C,	"errin");
	MakeComm	(0X13D,	"no response");
	MakeByte	(0X13D);
	MakeComm	(0X13E,	"seek failure");
	MakeByte	(0X13E);
	MakeComm	(0X13F,	"bad crc");
	MakeByte	(0X13F);
	MakeComm	(0X140,	"dma overrun");
	MakeByte	(0X140);
	MakeComm	(0X141,	"media change");
	MakeByte	(0X141);
	MakeComm	(0X142,	"sector not found");
	MakeByte	(0X142);
	MakeComm	(0X143,	"write attempt to write-protect disk");
	MakeByte	(0X143);
	MakeComm	(0X144,	"all other errors");
	MakeByte	(0X144);
	MakeName	(0X144,	"lsterr");
	MakeComm	(0X145,	"returned error codes corresponding to above\n write  fault error");
	MakeByte	(x=0X145);
	OpDecimal	(x,	0);
	MakeName	(0X145,	"errout");
	MakeComm	(0X146,	"no response");
	MakeByte	(0X146);
	MakeComm	(0X147,	"seek failure");
	MakeByte	(0X147);
	MakeComm	(0X148,	"bad crc");
	MakeByte	(0X148);
	MakeComm	(0X149,	"dma overrun");
	MakeByte	(0X149);
	MakeComm	(0X14A,	"invalid media change");
	MakeByte	(x=0X14A);
	OpDecimal	(x,	0);
	MakeComm	(0X14B,	"sector not found");
	MakeByte	(0X14B);
	MakeComm	(0X14C,	"write attempt to write-protect disk");
	MakeByte	(0X14C);
	MakeComm	(0X14D,	"general error");
	MakeByte	(x=0X14D);
	OpDecimal	(x,	0);
	MakeComm	(0X14E,	"read in boot sector here");
	MakeByte	(x=0X14E);
	MakeArray	(x,	0X200);
	OpDecimal	(x,	0);
	MakeName	(0X14E,	"disksector");
	MakeComm	(0X34E,	"dword link to next structure");
	MakeWord	(x=0X34E);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X34E,	"bds1");
	MakeWord	(0X350);
	MakeComm	(0X352,	"int 13h drive number");
	MakeByte	(0X352);
	MakeComm	(0X353,	"logical drive letter");
	MakeByte	(0X353);
	MakeComm	(0X354,	"physical sector size in bytes");
	MakeWord	(x=0X354);
	OpDecimal	(x,	0);
	MakeName	(0X354,	"fdrive1");
	MakeComm	(0X356,	"sectors/allocation unit");
	MakeComm	(0X357,	"reserved sectors for dos");
	MakeWord	(0X357);
	MakeComm	(0X359,	"no of file allocation tables");
	MakeByte	(0X359);
	MakeComm	(0X35A,	"number of root directory entries");
	MakeWord	(x=0X35A);
	OpDecimal	(x,	0);
	MakeComm	(0X35C,	"number of sectors (at 512 bytes each)");
	MakeWord	(x=0X35C);
	OpDecimal	(x,	0);
	MakeComm	(0X35E,	"media descriptor, initially 0");
	MakeByte	(0X35E);
	MakeComm	(0X35F,	"number of fat sectors");
	MakeWord	(0X35F);
	MakeComm	(0X361,	"sector limit (sectors per track)");
	MakeWord	(0X361);
	MakeComm	(0X363,	"head limit (number of heads - 1)");
	MakeWord	(0X363);
	MakeComm	(0X365,	"hidden sector count");
	MakeDword	(0X365);
	MakeComm	(0X369,	"number of sectors (32 bit)");
	MakeDword	(0X369);
	MakeComm	(0X36D,	"true => large fats (BDS.fatsiz)");
	MakeByte	(0X36D);
	MakeName	(0X36D,	"fatsiz");
	MakeComm	(0X36E,	"open ref. count");
	MakeWord	(0X36E);
	MakeName	(0X36E,	"opcnt1");
	MakeComm	(0X370,	"form factor");
	MakeByte	(0X370);
	MakeComm	(0X371,	"various flags");
	MakeWord	(0X371);
	MakeName	(0X371,	"flags1");
	MakeComm	(0X373,	"number of cylinders");
	MakeWord	(x=0X373);
	OpDecimal	(x,	0);
	MakeComm	(0X375,	"recommended bps for this drive");
	MakeWord	(x=0X375);
	OpDecimal	(x,	0);
	MakeName	(0X375,	"recbpb1");
	MakeByte	(0X377);
	MakeWord	(0X378);
	MakeByte	(0X37A);
	MakeComm	(0X37B,	"number of root directory entries");
	MakeWord	(x=0X37B);
	OpDecimal	(x,	0);
	MakeWord	(x=0X37D);
	OpDecimal	(x,	0);
	MakeComm	(0X37F,	"media descriptor, initially 0F0h");
	MakeByte	(0X37F);
	MakeWord	(0X380);
	MakeWord	(0X382);
	MakeWord	(0X384);
	MakeDword	(0X386);
	MakeDword	(0X38A);
	MakeByte	(0X38E);
	MakeArray	(0X38E,	0X6);
	MakeComm	(0X394,	"last track accessed on this drive");
	MakeByte	(0X394);
	MakeComm	(0X395,	"keep these two contiguous (?)");
	MakeWord	(0X395);
	MakeWord	(0X397);
	MakeComm	(0X399,	"volume id for this disk");
	MakeStr		(0X399,	0X3A5);
	MakeComm	(0X3A5,	"current volume serial from boot record");
	MakeDword	(0X3A5);
	MakeComm	(0X3A9,	"current file system id from boot record");
	MakeStr		(0X3A9,	0X3B2);
	MakeWord	(x=0X3B2);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X3B2,	"bds2");
	MakeWord	(0X3B4);
	MakeByte	(0X3B6);
	MakeByte	(0X3B7);
	MakeByte	(0X3B8);
	MakeArray	(0X3B8,	0X5E);
	MakeName	(0X3B8,	"fdrive2");
	MakeWord	(x=0X416);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X416,	"bds3");
	MakeWord	(0X418);
	MakeByte	(0X41A);
	MakeByte	(0X41B);
	MakeByte	(0X41C);
	MakeArray	(0X41C,	0X5E);
	MakeName	(0X41C,	"fdrive3");
	MakeWord	(0X47A);
	MakeName	(0X47A,	"bds4");
	MakeWord	(0X47C);
	MakeByte	(0X47E);
	MakeByte	(0X47F);
	MakeByte	(0X480);
	MakeArray	(0X480,	0X5E);
	MakeName	(0X480,	"fdrive4");
	MakeByte	(x=0X4DE);
	MakeArray	(x,	0X7);
	OpDecimal	(x,	0);
	MakeName	(0X4DE,	"sm92");
	MakeByte	(0X4E5);
	MakeName	(0X4E5,	"keyrd_func");
	MakeByte	(0X4E6);
	MakeName	(0X4E6,	"keysts_func");
	MakeComm	(0X4E7,	"printer device index");
	MakeByte	(0X4E7);
	MakeName	(0X4E7,	"printdev");
	MakeComm	(0X4E8,	"retry counts for printers");
	MakeWord	(0X4E8);
	MakeName	(0X4E8,	"wait_count");
	MakeWord	(0X4EA);
	MakeWord	(0X4EC);
	MakeWord	(0X4EE);
	MakeWord	(0X4F0);
	MakeName	(0X4F0,	"daycnt");
	MakeComm	(0X4F2,	"flag for updating daycnt");
	MakeByte	(0X4F2);
	MakeName	(0X4F2,	"t_switch");
	MakeByte	(0X4F3);
	MakeName	(0X4F3,	"havecmoscloc");
	MakeByte	(x=0X4F4);
	OpDecimal	(x,	0);
	MakeName	(0X4F4,	"base_century");
	MakeByte	(x=0X4F5);
	OpDecimal	(x,	0);
	MakeName	(0X4F5,	"base_year");
	MakeByte	(x=0X4F6);
	MakeArray	(x,	0XC);
	OpDecimal	(x,	0);
	MakeName	(0X4F6,	"month_tab");
	MakeWord	(x=0X502);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X502,	"bintobcd");
	MakeWord	(0X504);
	MakeWord	(x=0X506);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X506,	"daycnttoday");
	MakeWord	(0X508);
	MakeComm	(0X50A,	"flag for getbp routine");
	MakeByte	(0X50A);
	MakeName	(0X50A,	"set_id_flag");
	MakeStr		(0X50B,	0X514);
	MakeName	(0X50B,	"fat_12_id");
	MakeStr		(0X514,	0X51D);
	MakeName	(0X514,	"fat_16_id");
	MakeStr		(0X51D,	0X529);
	MakeName	(0X51D,	"vol_no_name");
	MakeComm	(0X529,	"temporary for 32 bit calculation");
	MakeWord	(0X529);
	MakeName	(0X529,	"temp_h");
	MakeComm	(0X52B,	"starting sector number high word");
	MakeWord	(0X52B);
	MakeName	(0X52B,	"start_sec_h");
	MakeComm	(0X52D,	"tempory saving place for a word");
	MakeWord	(0X52D);
	MakeName	(0X52D,	"saved_word");
	MakeWord	(0X52F);
	MakeName	(0X52F,	"multrk_flag");
	MakeComm	(0X531,	"flags for 3.5 inch disk drives");
	MakeByte	(0X531);
	MakeName	(0X531,	"ec35_flag");
	MakeWord	(0X532);
	MakeName	(0X532,	"vretry_cnt");
	MakeWord	(0X534);
	MakeName	(0X534,	"soft_ecc_cnt");
	MakeComm	(0X536,	"multi track format request flag");
	MakeByte	(0X536);
	MakeName	(0X536,	"multitrk_format_flag");
	MakeComm	(0X537,	"temp for transfer segment");
	MakeWord	(0X537);
	MakeName	(0X537,	"xfer_seg");
	MakeWord	(x=0X539);
	OpDecimal	(x,	0);
	MakeName	(0X539,	"sectorspertrack");
	MakeByte	(x=0X53B);
	MakeArray	(x,	0X90);
	OpDecimal	(x,	0);
	MakeName	(0X53B,	"tracktable");
	MakeByte	(x=0X5CB);
	MakeArray	(x,	0X6C);
	OpDecimal	(x,	0);
	MakeByte	(0X637);
	MakeName	(0X637,	"mediatype");
	MakeComm	(0X638,	"1 if we have done an int 13h\nset media type for format call");
	MakeByte	(0X638);
	MakeName	(0X638,	"media_set_for_format");
	MakeComm	(0X639,	"1 if the previous format operation failed.");
	MakeByte	(0X639);
	MakeName	(0X639,	"had_format_error");
	MakeComm	(0X63A,	"-1 ; temp disk base table");
	MakeDword	(0X63A);
	MakeName	(0X63A,	"tempdpt");
	MakeComm	(0X63E,	"model byte set at init time");
	MakeByte	(0X63E);
	MakeName	(0X63E,	"model_byte");
	MakeByte	(0X63F);
	MakeName	(0X63F,	"secondary_model_byte");
	MakeComm	(0X640,	"indicate that all int 19h\ninitialization is complete");
	MakeByte	(0X640);
	MakeName	(0X640,	"int19sem");
	MakeComm	(0X641,	"original hardware int. vectors for int 19h");
	MakeByte	(0X641);
	MakeName	(0X641,	"i19_lst");
	MakeDword	(0X642);
	MakeName	(0X642,	"int19old02");
	MakeByte	(0X646);
	MakeDword	(0X647);
	MakeName	(0X647,	"int19old08");
	MakeByte	(0X64B);
	MakeDword	(0X64C);
	MakeName	(0X64C,	"int19old09");
	MakeByte	(x=0X650);
	OpHex		(x,	0);
	MakeDword	(0X651);
	MakeName	(0X651,	"int19old0A");
	MakeByte	(0X655);
	MakeDword	(0X656);
	MakeName	(0X656,	"int19old0B");
	MakeByte	(0X65A);
	MakeDword	(0X65B);
	MakeName	(0X65B,	"int19old0C");
	MakeByte	(0X65F);
	MakeDword	(0X660);
	MakeName	(0X660,	"int19old0D");
	MakeByte	(0X664);
	MakeDword	(0X665);
	MakeName	(0X665,	"int19old0E");
	MakeByte	(0X669);
	MakeDword	(0X66A);
	MakeName	(0X66A,	"int19old70");
	MakeByte	(0X66E);
	MakeDword	(0X66F);
	MakeName	(0X66F,	"int19old72");
	MakeByte	(0X673);
	MakeDword	(0X674);
	MakeName	(0X674,	"int19old73");
	MakeByte	(0X678);
	MakeDword	(0X679);
	MakeName	(0X679,	"int19old74");
	MakeByte	(0X67D);
	MakeDword	(0X67E);
	MakeName	(0X67E,	"int19old76");
	MakeByte	(0X682);
	MakeDword	(0X683);
	MakeName	(0X683,	"int19old77");
	MakeWord	(x=0X687);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X687,	"dskdrvs");
	MakeWord	(x=0X689);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeWord	(x=0X68B);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeWord	(x=0X68D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X68F,	"up to 26 drives for mini disks");
	MakeWord	(x=0X68F);
	MakeArray	(x,	0X16);
	OpDecimal	(x,	0);
	MakeDword	(0X6BB);
	MakeName	(0X6BB,	"int6c_ret_addr");
	MakeComm	(0X6BF,	"century, year, month,   day");
	MakeByte	(0X6BF);
	MakeArray	(0X6BF,	0X4);
	MakeName	(0X6BF,	"bin_date_time");
	MakeWord	(x=0X6C3);
	MakeArray	(x,	0XC);
	OpDecimal	(x,	0);
	MakeName	(0X6C3,	"month_table");
	MakeWord	(0X6DB);
	MakeName	(0X6DB,	"daycnt2");
	MakeComm	(0X6DD,	"february 29 in a leap   year flag");
	MakeByte	(0X6DD);
	MakeName	(0X6DD,	"feb29");
	MakeWord	(x=0X6DE);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeName	(0X6DE,	"cdev");
	MakeComm	(0X6E0,	"BIOSCODE segment");
	MakeWord	(0X6E0);
	MakeName	(0X6E0,	"cdev_2");
	MakeWord	(x=0X6E2);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeName	(0X6E2,	"ttticks");
	MakeWord	(0X6E4);
	MakeWord	(x=0X6E6);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeName	(0X6E6,	"bcode_i2f");
	MakeWord	(0X6E8);
	MakeWord	(x=0X6EA);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeName	(0X6EA,	"i13x");
	MakeWord	(0X6EC);
	MakeComm	(0X6EE,	"indicate break key set");
	MakeCode	(0X6EE);
	MakeName	(0X6EE,	"cbreak");
	MakeName	(0X6F4,	"intret");
	MakeComm	(0X6F5,	"store es:bx (device driver request packet)\n     away at [ptrsav] for next driver function call");
	MakeCode	(0X6F5);
	MakeName	(0X6F5,	"strategy");
	MakeCode	(0X700);
	MakeName	(0X700,	"con_entry");
	MakeComm	(0X703,	"2C7h:0E4h = BIOSCODE:0E4h = 70h:2654h");
	MakeCode	(x=0X703);
	OpHex		(x,	1);
	MakeName	(0X705,	"prn0_entry");
	MakeByte	(0X70A);
	MakeArray	(0X70A,	0X2);
	MakeCode	(0X70C);
	MakeName	(0X70C,	"prn1_entry");
	MakeByte	(0X711);
	MakeArray	(0X711,	0X2);
	MakeCode	(0X713);
	MakeName	(0X713,	"prn2_entry");
	MakeComm	(0X716,	" 2C7h:0FBh = BIOSCODE:0FBh = 70h:266Bh");
	MakeCode	(0X71A);
	MakeName	(0X71A,	"prn3_entry");
	MakeCode	(0X721);
	MakeName	(0X721,	"aux0_entry");
	MakeByte	(0X726);
	MakeCode	(0X727);
	MakeName	(0X727,	"aux1_entry");
	MakeComm	(0X72A,	"2C7h:130h = BIOSCODE:130h = 70h:26A0h");
	MakeByte	(0X72C);
	MakeCode	(0X72D);
	MakeName	(0X72D,	"aux2_entry");
	MakeByte	(0X732);
	MakeCode	(0X733);
	MakeName	(0X733,	"aux3_entry");
	MakeByte	(0X738);
	MakeCode	(0X739);
	MakeName	(0X739,	"tim_entry");
	MakeComm	(0X73C,	"2C7h:147h = BIOSCODE:147h = 70h:26B7h");
	MakeCode	(0X73E);
	MakeName	(0X73E,	"dsk_entry");
	MakeComm	(0X741,	"2C7h:4A2h = BIOSCODE:4A2h = 70h:2A12h");
	MakeWord	(x=0X741);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeCode	(0X743);
	MakeName	(0X743,	"cdev_entry");
	MakeComm	(0X74B,	"optimized for DOS in HMA");
	MakeComm	(0X756,	"jump is coded this way to fall thru\nin 99.99% of the cases");
	MakeCode	(0X75D);
	MakeComm	(0X762,	"int 29h handler");
	MakeCode	(0X762);
	MakeName	(0X762,	"outchr");
	MakeComm	(0X76C,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)");
	MakeCode	(x=0X76C);
	OpHex		(x,	0);
	MakeCode	(0X774);
	MakeName	(0X774,	"block13");
	MakeComm	(0X77C,	"A20 Off?");
	MakeComm	(0X781,	"assure a20 enabled");
	MakeComm	(0X784,	"save caller's ds for call-through");
	MakeName	(0X784,	"skipa20");
	MakeComm	(0X789,	"fake interrupt");
	MakeComm	(0X78A,	"call through Bios_Code entry table");
	MakeComm	(0X797,	"get caller's ds register");
	MakeCode	(0X797);
	MakeName	(0X797,	"call_orig13");
	MakeComm	(0X7A7,	"restore ds -> Bios_Data before return");
	MakeWord	(0X7B4);
	MakeWord	(0X7B6);
	MakeCode	(0X7B9);
	MakeDword	(0X7BB);
	MakeName	(0X7BB,	"HiMem");
	MakeDword	(0X7BF);
	MakeName	(0X7BF,	"LoMem");
	MakeCode	(0X7C3);
	MakeName	(0X7C3,	"EnsureA20On");
	MakeCode	(0X7C9);
	MakeName	(0X7C9,	"EnableA20");
	MakeComm	(0X7CB,	"local enable A20");
	MakeCode	(0X7D5);
	MakeName	(0X7D5,	"IsA20off");
	MakeCode	(0X7EF);
	MakeName	(0X7EF,	"DisableA20");
	MakeComm	(0X7F1,	"local disable A20");
	MakeComm	(0X7F3,	"call far [cs:xms]");
	MakeCode	(0X7FB);
	MakeName	(0X7FB,	"int19");
	MakeCode	(x=0X804);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X807,	"get int number");
	MakeName	(0X807,	"_next_int");
	MakeComm	(0X808,	"assume < 128");
	MakeCode	(x=0X809);
	OpHex		(x,	1);
	MakeComm	(0X80B,	"int * 4");
	MakeCode	(x=0X80B);
	OpHex		(x,	1);
	MakeComm	(0X80F,	"install the saved vector");
	MakeComm	(0X81C,	"stacks code has changed these hardware interrupt vectors\nstkinit in sysinit1 will initialize int19oldxx values");
	MakeCode	(x=0X81C);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X81F);
	OpDecimal	(x,	1);
	MakeComm	(0X822,	"get interrupt number");
	MakeName	(0X822,	"i19_restore_loop");
	MakeComm	(0X823,	"assume < 128");
	MakeComm	(0X826,	"get original vector offset");
	MakeComm	(0X827,	"save it");
	MakeComm	(0X82A,	"check for 0ffffh (unlikely segment)");
	MakeComm	(0X82D,	"opt no need to check selector too");
	MakeWord	(0X839);
	MakeCode	(0X83C);
	MakeName	(0X83C,	"i19_restor_1");
	MakeComm	(0X83E,	"Is dos running from HMA ?");
	MakeName	(0X83E,	"doint19");
	MakeComm	(0X843,	"no");
	MakeComm	(0X845,	"Then erase our VDISK header at 1MB boundary\nSome m/c's (AST 386 & HP QS/16 do not clear\nthe memory above 1MB during a warm boot.");
	MakeComm	(0X848,	"DISK BOOT\ncauses reboot of disk system");
	MakeCode	(x=0X848);
	OpHex		(x,	0);
	MakeName	(0X848,	"SkipVDisk");
	MakeComm	(0X84A,	"del keystroke ? (4F00h+DELKEY)");
	MakeName	(0X84A,	"Int15");
	MakeCode	(0X854);
	MakeName	(0X854,	"int15_1");
	MakeComm	(0X856,	"ROMBIOS data segment");
	MakeCode	(x=0X856);
	OpHex		(x,	1);
	MakeComm	(0X85B,	"[KBFLAG]");
	MakeComm	(0X85E,	"(CTRLSTATE | ALTSTATE)");
	MakeCode	(x=0X85E);
	OpHex		(x,	1);
	MakeComm	(0X860,	"(CTRLSTATE | ALTSTATE)");
	MakeComm	(0X866,	"is DOS running from HMA ?");
	MakeComm	(0X86B,	"no");
	MakeName	(0X870,	"int15_2");
	MakeCode	(0X878);
	MakeName	(0X878,	"EraseVDiskHead");
	MakeComm	(0X87F,	"HMA seg");
	MakeComm	(0X884,	"point to VDISK header");
	MakeComm	(0X887,	"size of vdisk header");
	MakeCode	(x=0X887);
	OpDecimal	(x,	1);
	MakeComm	(0X88C,	"clear it");
	MakeCode	(0X893);
	MakeName	(0X893,	"int_2f");
	MakeCode	(0X898);
	MakeCode	(0X89B);
	MakeName	(0X89B,	"re_init");
	MakeByte	(0X89C);
	MakeArray	(0X89C,	0X2);
	MakeName	(0X89C,	"Win386_SI");
	MakeDword	(0X89E);
	MakeName	(0X89E,	"SI_Next");
	MakeDword	(0X8A2);
	MakeDword	(0X8A6);
	MakeWord	(x=0X8AA);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X8AC,	"BIOSDATA segment");
	MakeWord	(0X8AC);
	MakeWord	(0X8AE);
	MakeName	(0X8AE,	"Instance_Table");
	MakeComm	(0X8B0,	"print screen status...");
	MakeWord	(0X8B0);
	MakeComm	(0X8B2,	"2 bytes");
	MakeWord	(0X8B2);
	MakeComm	(0X8B4,	"ROM Basic data");
	MakeWord	(0X8B4);
	MakeWord	(0X8B6);
	MakeWord	(0X8B8);
	MakeComm	(0X8BA,	"a con device buffer");
	MakeWord	(x=0X8BA);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X8BC,	"BIOSDATA segment");
	MakeWord	(0X8BC);
	MakeWord	(0X8BE);
	MakeComm	(0X8C0,	"pointer to next stack to be used");
	MakeWord	(0X8C0);
	MakeArray	(0X8C0,	0X2);
	MakeName	(0X8C0,	"NextStack");
	MakeComm	(0X8C4,	"2 bytes");
	MakeWord	(0X8C4);
	MakeComm	(0X8C6,	"location of hardware stacks");
	MakeDword	(0X8C6);
	MakeName	(0X8C6,	"IT_StackLoc");
	MakeComm	(0X8CA,	"size of hardware stacks");
	MakeWord	(0X8CA);
	MakeName	(0X8CA,	"IT_StackSize");
	MakeComm	(0X8CC,	"terminate the instance table");
	MakeDword	(0X8CC);
	MakeComm	(0X8D0,	"Flag to indicate whether\nWin386 is running or not");
	MakeByte	(0X8D0);
	MakeName	(0X8D0,	"IsWin386");
	MakeCode	(0X8D1);
	MakeName	(0X8D1,	"V86_Crit_SetFocus");
	MakeComm	(0X8DF,	"- Multiplex - MS WINDOWS - GET DEVICE API ENTRY POINT\nBX = virtual device (VxD) ID, ES:DI = 0000h:0000h\nReturn: ES:DI -> VxD API entry point, or 0:0 if the VxD does not support an API");
	MakeCode	(x=0X8DF);
	OpHex		(x,	0);
	MakeCode	(x=0X8E8);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(0X8F2);
	MakeWord	(0X8F7);
	MakeName	(0X8F7,	"FreeHMAPtr");
	MakeWord	(x=0X8F9);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X8F9,	"MoveDOSIntoHMA");
	MakeComm	(0X8FB,	"SYSINIT segment");
	MakeWord	(0X8FB);
	MakeName	(0X8FB,	"MoveDOSIntoHMA_2");
	MakeByte	(0X8FD);
	MakeName	(0X8FD,	"SysinitPresent");
	MakeByte	(0X8FE);
	MakeName	(0X8FE,	"endfloppy");
	MakeByte	(0X8FF);
	MakeStr		(0X900,	0X90C);
	MakeName	(0X900,	"nul_vid");
	MakeStr		(0X90C,	0X918);
	MakeName	(0X90C,	"tmp_vid");
	MakeByte	(0X918);
	MakeName	(0X918,	"harddrv");
	MakeComm	(0X919,	"max_mini_dsk_num equ 23\nBDS_STRUC (2+max_mini_dsk_num) dup (<>)\ncurrently max. 25\n(MSDOS 6 BDS structure size = 100 bytes)");
	MakeWord	(0X919);
	MakeName	(0X919,	"bdss");
	MakeWord	(0X91B);
	MakeByte	(x=0X91D);
	OpDecimal	(x,	0);
	MakeByte	(0X91E);
	MakeWord	(x=0X91F);
	OpDecimal	(x,	0);
	MakeByte	(0X921);
	MakeWord	(0X922);
	MakeByte	(0X924);
	MakeWord	(x=0X925);
	OpDecimal	(x,	0);
	MakeWord	(0X927);
	MakeByte	(0X929);
	MakeWord	(0X92A);
	MakeWord	(0X92C);
	MakeWord	(0X92E);
	MakeDword	(0X930);
	MakeDword	(0X934);
	MakeByte	(0X938);
	MakeWord	(0X939);
	MakeByte	(0X93B);
	MakeWord	(0X93C);
	MakeWord	(x=0X93E);
	OpDecimal	(x,	0);
	MakeByte	(x=0X940);
	MakeArray	(x,	0X1F);
	OpDecimal	(x,	0);
	MakeByte	(x=0X95F);
	OpDecimal	(x,	0);
	MakeWord	(0X960);
	MakeWord	(0X962);
	MakeStr		(0X964,	0X970);
	MakeDword	(0X970);
	MakeStr		(0X974,	0X97D);
	MakeWord	(0X97D);
	MakeName	(0X97D,	"bdss_1");
	MakeByte	(0X97F);
	MakeArray	(0X97F,	0X62);
	MakeWord	(0X9E1);
	MakeName	(0X9E1,	"bdss_2");
	MakeByte	(0X9E3);
	MakeArray	(0X9E3,	0X62);
	MakeWord	(0XA45);
	MakeName	(0XA45,	"bdss_3");
	MakeByte	(0XA47);
	MakeArray	(0XA47,	0X62);
	MakeWord	(0XAA9);
	MakeName	(0XAA9,	"bdss_4");
	MakeByte	(0XAAB);
	MakeArray	(0XAAB,	0X62);
	MakeWord	(0XB0D);
	MakeByte	(0XB0F);
	MakeArray	(0XB0F,	0X62);
	MakeWord	(0XB71);
	MakeByte	(0XB73);
	MakeArray	(0XB73,	0X62);
	MakeWord	(0XBD5);
	MakeByte	(0XBD7);
	MakeArray	(0XBD7,	0X62);
	MakeWord	(0XC39);
	MakeByte	(0XC3B);
	MakeArray	(0XC3B,	0X62);
	MakeWord	(0XC9D);
	MakeByte	(0XC9F);
	MakeArray	(0XC9F,	0X62);
	MakeWord	(0XD01);
	MakeByte	(0XD03);
	MakeArray	(0XD03,	0X62);
	MakeWord	(0XD65);
	MakeByte	(0XD67);
	MakeArray	(0XD67,	0X62);
	MakeWord	(0XDC9);
	MakeByte	(0XDCB);
	MakeArray	(0XDCB,	0X62);
	MakeWord	(0XE2D);
	MakeByte	(0XE2F);
	MakeArray	(0XE2F,	0X62);
	MakeWord	(0XE91);
	MakeByte	(0XE93);
	MakeArray	(0XE93,	0X62);
	MakeWord	(0XEF5);
	MakeByte	(0XEF7);
	MakeArray	(0XEF7,	0X62);
	MakeWord	(0XF59);
	MakeByte	(0XF5B);
	MakeArray	(0XF5B,	0X62);
	MakeWord	(0XFBD);
	MakeByte	(0XFBF);
	MakeArray	(0XFBF,	0X62);
	MakeWord	(0X1021);
	MakeByte	(0X1023);
	MakeArray	(0X1023,	0X62);
	MakeWord	(0X1085);
	MakeByte	(0X1087);
	MakeArray	(0X1087,	0X62);
	MakeWord	(0X10E9);
	MakeByte	(0X10EB);
	MakeArray	(0X10EB,	0X62);
	MakeWord	(0X114D);
	MakeByte	(0X114F);
	MakeArray	(0X114F,	0X62);
	MakeWord	(0X11B1);
	MakeByte	(0X11B3);
	MakeArray	(0X11B3,	0X62);
	MakeWord	(0X1215);
	MakeByte	(0X1217);
	MakeArray	(0X1217,	0X62);
	MakeWord	(0X1279);
	MakeName	(0X1279,	"bdss_24");
	MakeByte	(0X127B);
	MakeArray	(0X127B,	0X62);
	MakeByte	(0X12DD);
	MakeComm	(0X12DE,	"main routine, fixes at rom bug\npass through floppy disk calls");
	MakeCode	(x=0X12DE);
	OpHex		(x,	1);
	MakeName	(0X12DE,	"ibm_disk_io");
	MakeComm	(0X12E6,	"intercept call 02h (read sectors)");
	MakeComm	(0X12E8,	"and call 0Ah (read long)");
	MakeComm	(0X12ED,	"use rom int 13h handler");
	MakeName	(0X12ED,	"atd1");
	MakeCode	(0X12F2);
	MakeName	(0X12F2,	"atd2");
	MakeComm	(0X12F9,	"rombios data segment");
	MakeCode	(x=0X12F9);
	OpHex		(x,	1);
	MakeComm	(0X12FE,	"[disk_status1]\ninitially no error code");
	MakeComm	(0X1303,	"mask to hard disk number");
	MakeCode	(x=0X1303);
	OpHex		(x,	1);
	MakeComm	(0X1306,	"[hf_num] ; 40h:75h");
	MakeComm	(0X130A,	"disk number in ranger");
	MakeComm	(0X130C,	"[disk_status1]");
	MakeComm	(0X1311,	"disk number out of range error, return");
	MakeCode	(0X1313);
	MakeName	(0X1313,	"atd3");
	MakeComm	(0X1316,	"make es:bx to seg:000x form");
	MakeCode	(x=0X1316);
	OpHex		(x,	1);
	MakeCode	(x=0X131E);
	OpHex		(x,	1);
	MakeComm	(0X1325,	"abort if dma across segment boundary");
	MakeComm	(0X1329,	"set up command block for disk op");
	MakeComm	(0X132C,	"hf_reg_port");
	MakeCode	(x=0X132C);
	OpHex		(x,	1);
	MakeComm	(0X132F,	"AT only. Fixed disk register");
	MakeComm	(0X1330,	"carry out command");
	MakeName	(0X1333,	"atd4");
	MakeComm	(0X1334,	"[disk_status1]");
	MakeName	(0X133D,	"atd5");
	MakeComm	(0X1346,	"[cmd_block+sec_cnt]");
	MakeCode	(0X1346);
	MakeName	(0X1346,	"setcmd");
	MakeCode	(x=0X1349);
	OpHex		(x,	1);
	MakeComm	(0X134E,	"cmd_reg = 20h if function 02h (read)");
	MakeComm	(0X1353,	"[cmd_block+cmd_reg]\ncmd_reg = 22h if function 0Ah (read long)");
	MakeCode	(x=0X1353);
	OpHex		(x,	1);
	MakeName	(0X1358,	"setc1");
	MakeComm	(0X135A,	"mask sector number");
	MakeCode	(x=0X135A);
	OpHex		(x,	1);
	MakeComm	(0X135C,	"[cmd_block+sec_num]");
	MakeComm	(0X135F,	"[cmd_block+cyl_low]");
	MakeComm	(0X1365,	"get two high bits of cylinder number");
	MakeCode	(x=0X1365);
	OpHex		(x,	1);
	MakeComm	(0X1368,	"[cmd_block+cyl_high]");
	MakeComm	(0X136D,	"drive number");
	MakeCode	(x=0X136D);
	OpHex		(x,	1);
	MakeCode	(x=0X1370);
	OpHex		(x,	1);
	MakeComm	(0X1373,	"head number");
	MakeComm	(0X1375,	"set ecc and 512 bytes per sector");
	MakeCode	(x=0X1375);
	OpHex		(x,	1);
	MakeComm	(0X1377,	"[cmd_block+drv_head]");
	MakeComm	(0X1380,	"[es:bx+fdp_precomp]\nwrite pre-comp from disk parameters");
	MakeCode	(x=0X1384);
	OpHex		(x,	1);
	MakeComm	(0X1387,	"[cmd_block+pre_comp]");
	MakeComm	(0X138A,	"[es:bx+fdp_control]\ncontrol byte modifier");
	MakeComm	(0X1390,	"[control_byte]");
	MakeComm	(0X1394,	"keep disable retry bits");
	MakeCode	(x=0X1394);
	OpHex		(x,	1);
	MakeCode	(0X139E);
	MakeName	(0X139E,	"docmd");
	MakeComm	(0X13A7,	"wait for controller to complete read");
	MakeCode	(x=0X13AC);
	OpDecimal	(x,	1);
	MakeComm	(0X13AF,	"hf_port");
	MakeCode	(x=0X13AF);
	OpHex		(x,	1);
	MakeComm	(0X13B4,	"read in sector");
	MakeComm	(0X13B8,	"[cmd_block+cmd_reg]");
	MakeCode	(x=0X13B8);
	OpHex		(x,	1);
	MakeComm	(0X13C5,	"4 bytes of ecc");
	MakeCode	(x=0X13C8);
	OpHex		(x,	1);
	MakeComm	(0X13CC,	"read in ecc");
	MakeComm	(0X13D5,	"[cmd_block+sec_cnt]");
	MakeComm	(0X13DC,	"get pointer to hard disk parameters");
	MakeCode	(0X13DC);
	MakeName	(0X13DC,	"get_vec");
	MakeComm	(0X13E4,	"send contents of cmd_block to disk controller");
	MakeCode	(0X13E4);
	MakeName	(0X13E4,	"command");
	MakeComm	(0X13EC,	"wait for disk interrupt");
	MakeCode	(0X13EC);
	MakeName	(0X13EC,	"waitt");
	MakeComm	(0X13F4,	"wait for data request");
	MakeCode	(0X13F4);
	MakeName	(0X13F4,	"wait_drq");
	MakeComm	(0X13FC,	"check hard disk status");
	MakeCode	(0X13FC);
	MakeName	(0X13FC,	"check_status");
	MakeComm	(0X1404,	"check for dma overrun 64k segment");
	MakeCode	(0X1404);
	MakeName	(0X1404,	"check_dma");
	MakeCode	(0X140C);
	MakeName	(0X140C,	"endatrom");
	MakeName	(0X1411,	"no_hookit");
	MakeCode	(x=0X1416);
	OpHex		(x,	1);
	MakeName	(0X1416,	"mebbe_hookit");
	MakeCode	(x=0X141D);
	OpHex		(x,	1);
	MakeByte	(0X142D);
	MakeName	(0X142D,	"end_compaq_i13hook");
	MakeComm	(0X142E,	"entry: [daycnt] = number of days since 1-1-80\nreturn: ch - century in bcd\n        cl - year in bcd\n        dh - month in bcd\n        dl - day in bcd");
	MakeCode	(0X142E);
	MakeName	(0X142E,	"daycnt_to_day");
	MakeComm	(0X1433,	"(365*20+(20/4))\n# days from 1-1-1980 to 1-1-2000");
	MakeCode	(x=0X1433);
	OpDecimal	(x,	1);
	MakeCode	(x=0X143C);
	OpDecimal	(x,	1);
	MakeCode	(x=0X1442);
	OpDecimal	(x,	1);
	MakeCode	(x=0X144A);
	OpDecimal	(x,	1);
	MakeName	(0X144A,	"century20");
	MakeComm	(0X1456,	"365*20+(20/4))\nadjust daycnt");
	MakeCode	(x=0X1456);
	OpDecimal	(x,	1);
	MakeName	(0X145D,	"years");
	MakeComm	(0X1463,	"366+365*3)\n# of days in a Leap year block");
	MakeCode	(x=0X1463);
	OpDecimal	(x,	1);
	MakeComm	(0X1466,	"ax = # of leap block, dx = daycnt");
	MakeComm	(0X1468,	"save daycnt left");
	MakeComm	(0X1471,	"ax = # of years. Less than 100");
	MakeComm	(0X147B,	"daycnt = remainder of leap year block\nwithin 366+355+355+355 days");
	MakeCode	(x=0X147B);
	OpDecimal	(x,	1);
	MakeComm	(0X1484,	"if daycnt <= 366, then leap year\nelse daycnt -= 366, base_year++");
	MakeCode	(x=0X1489);
	OpDecimal	(x,	1);
	MakeComm	(0X1490,	"And next three years are normal");
	MakeComm	(0X1493,	"for(i=1; i>3 or daycnt <=365; i++)");
	MakeCode	(x=0X1493);
	OpDecimal	(x,	1);
	MakeName	(0X1493,	"regularyear");
	MakeComm	(0X149A,	"{if (daycnt > 365)");
	MakeComm	(0X149C,	"{ daycnt -= 365");
	MakeComm	(0X14A1,	"}");
	MakeCode	(x=0X14A1);
	OpDecimal	(x,	1);
	MakeComm	(0X14A8,	"}\nshould never fall through loop");
	MakeComm	(0X14AA,	"leap year.\nchange month table.");
	MakeCode	(x=0X14AA);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpDecimal	(x,	1);
	MakeName	(0X14AA,	"leapyear");
	MakeName	(0X14B0,	"yeardone");
	MakeCode	(x=0X14B8);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X14BB);
	OpDecimal	(x,	1);
	MakeName	(0X14BE,	"months");
	MakeComm	(0X14C2,	"cmp daycnt for each month till fit\ndh=0");
	MakeComm	(0X14C6,	"next month");
	MakeComm	(0X14C7,	"adjust daycnt");
	MakeComm	(0X14C9,	"\nshould never fall through loop");
	MakeComm	(0X14CB,	"restore month table value");
	MakeCode	(x=0X14CB);
	OpDecimal	(x,	1);
	MakeName	(0X14CB,	"month_done");
	MakeComm	(0X14D8,	"al=day,dl=month,dh=year,cl=cntry");
	MakeComm	(0X14DD,	"call far [cs:bintobcd]\nconvert \"day\" to bcd\ndl = bcd day, al = month");
	MakeComm	(0X14E4,	"dh = bcd month, al = year");
	MakeComm	(0X14EB,	"cl = bcd year, al = century");
	MakeComm	(0X14F2,	"ch = bcd century");
	MakeComm	(0X14F9,	"restore original value");
	MakeComm	(0X14FF,	"convert a binary input in al\n(less than 63h or 99 decimal)\ninto a bcd value in al. ah destroyed");
	MakeCode	(0X14FF);
	MakeName	(0X14FF,	"bin_to_bcd");
	MakeComm	(0X1500,	"AH = AL/10, AL = AL MOD 10");
	MakeComm	(0X1506,	"AL = (AH*10h)+AL");
	MakeComm	(0X150A,	"The K09 requires the routines for reading the clock\nbecause of the suspend/resume facility.");
	MakeCode	(0X150A);
	MakeName	(0X150A,	"int6c");
	MakeComm	(0X1515,	"get the date from the clock");
	MakeComm	(0X1519,	"update dos copy of date");
	MakeComm	(0X151E,	"get the time from the   rtc");
	MakeComm	(0X1524,	"CLOCK - SET TIME OF DAY\nCX:DX = clock count\nReturn: time of day set");
	MakeCode	(x=0X1524);
	OpHex		(x,	0);
	MakeComm	(0X1527,	"jmp far [int6c_ret_addr] ; long jump");
	MakeCode	(0X152B);
	MakeName	(0X152B,	"read_real_date");
	MakeComm	(0X152E,	"throw away clock roll over");
	MakeComm	(0X1530,	"CLOCK - GET TIME OF DAY\nReturn: CX:DX = clock count\nAL = 00h if clock was read or written (via AH=0,1) since the previous\nmidnight\nOtherwise, AL > 0");
	MakeCode	(x=0X1530);
	OpHex		(x,	0);
	MakeComm	(0X1542,	"CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)\nReturn: DL = day in BCD\nDH = month in BCD\nCL = year in BCD\nCH = century (19h or 20h)");
	MakeCode	(x=0X1542);
	OpHex		(x,	0);
	MakeCode	(0X1549);
	MakeName	(0X1549,	"read_ok");
	MakeComm	(0X1559,	"READ OF R-T CLOCK SUCCESSFUL");
	MakeComm	(0X1560,	"verify bcd values in range");
	MakeComm	(0X1563,	"some value out of range");
	MakeComm	(0X157F,	"20th century?");
	MakeCode	(x=0X157F);
	OpDecimal	(x,	1);
	MakeComm	(0X1586,	"add in a century");
	MakeCode	(x=0X1586);
	OpDecimal	(x,	1);
	MakeComm	(0X1589,	"subtract off 1-1-80");
	MakeCode	(x=0X1589);
	OpDecimal	(x,	1);
	MakeComm	(0X158C,	"leap year every 4");
	MakeComm	(0X158E,	"al= # leap year blocks, ah= remainder");
	MakeComm	(0X1590,	"save odd years");
	MakeComm	(0X1592,	"zero ah");
	MakeComm	(0X1593,	"366+(3*365)\n# of days in leap year blocks");
	MakeCode	(x=0X1593);
	OpDecimal	(x,	1);
	MakeComm	(0X1598,	"SAVE COUNT OF DAYS");
	MakeComm	(0X159C,	"get odd years count");
	MakeComm	(0X15A3,	"days in year");
	MakeCode	(x=0X15A3);
	OpDecimal	(x,	1);
	MakeComm	(0X15A8,	"ADD ON DAYS IN ODD YEARS");
	MakeComm	(0X15AD,	"account for leap year\npossibly account for a leap day");
	MakeComm	(0X15AF,	"is month february?");
	MakeCode	(0X15AF);
	MakeComm	(0X15B4,	"jan or feb. no leap day yet");
	MakeComm	(0X15B6,	"account for leap day");
	MakeComm	(0X15BB,	"get days of month");
	MakeComm	(0X15C1,	"because of offset from day 1, not day 0");
	MakeComm	(0X15C2,	"GET DAYS IN MONTHS PRECEEDING");
	MakeComm	(0X15C7,	"get month");
	MakeComm	(0X15CD,	"january starts at offset 0");
	MakeComm	(0X15CE,	"word offset");
	MakeCode	(x=0X15CE);
	OpHex		(x,	1);
	MakeCode	(x=0X15D0);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(0X15E6);
	MakeCode	(0X15EC);
	MakeName	(0X15EC,	"read_real_time");
	MakeComm	(0X15EE,	"CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)\nReturn: CH = hours in BCD\nCL = minutes in BCD\nDH = seconds in BCD");
	MakeCode	(x=0X15EE);
	OpHex		(x,	0);
	MakeName	(0X15F2,	"oktime");
	MakeComm	(0X1620,	"call far [ttticks]\nnote: indirect far call\ncx:dx = number of ticks\n(at 18.2 ticks per sec.)");
	MakeName	(0X1624,	"r_t_ret");
	MakeComm	(0X1625,	"century or hours");
	MakeCode	(0X1625);
	MakeName	(0X1625,	"in_bin");
	MakeComm	(0X162E,	"years or minutes");
	MakeComm	(0X1637,	"months or seconds");
	MakeComm	(0X1640,	"days (not used for time)");
	MakeComm	(0X164A,	"bcd_to_bin converts two bcd nibbles in al \n(value <= 99.) to a binary representation in al");
	MakeCode	(0X164A);
	MakeName	(0X164A,	"bcd_to_bin");
	MakeCode	(x=0X164C);
	OpHex		(x,	1);
	MakeComm	(0X1655,	"century check");
	MakeCode	(x=0X1655);
	OpHex		(x,	1);
	MakeName	(0X1655,	"date_verify");
	MakeComm	(0X165C,	"jmp in 21th century");
	MakeComm	(0X165E,	"century check");
	MakeCode	(x=0X165E);
	OpHex		(x,	1);
	MakeComm	(0X1665,	"year check");
	MakeCode	(x=0X1665);
	OpHex		(x,	1);
	MakeComm	(0X166C,	"year check");
	MakeCode	(x=0X166C);
	OpHex		(x,	1);
	MakeComm	(0X1673,	"month check");
	MakeCode	(x=0X1673);
	OpHex		(x,	1);
	MakeComm	(0X1681,	"day check");
	MakeCode	(x=0X1681);
	OpHex		(x,	1);
	MakeCode	(0X1691);
	MakeComm	(0X1693,	"hour check");
	MakeCode	(x=0X1693);
	OpHex		(x,	1);
	MakeName	(0X1693,	"time_verify");
	MakeComm	(0X169A,	"minute check");
	MakeCode	(x=0X169A);
	OpHex		(x,	1);
	MakeComm	(0X16A1,	"second check");
	MakeCode	(x=0X16A1);
	OpHex		(x,	1);
	MakeCode	(0X16AA);
	MakeComm	(0X16AC,	"4 bytes to check");
	MakeCode	(0X16AC);
	MakeName	(0X16AC,	"bcd_verify");
	MakeCode	(x=0X16AF);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X16B2,	"get a bcd number (0..99)");
	MakeComm	(0X16B6,	"10's place in high ah, 1's in al\nis 1's place in range?");
	MakeCode	(x=0X16B6);
	OpHex		(x,	1);
	MakeCode	(x=0X16B9);
	OpDecimal	(x,	1);
	MakeComm	(0X16BB,	"jmp out of range");
	MakeCode	(x=0X16BD);
	OpHex		(x,	1);
	MakeCode	(x=0X16BF);
	OpHex		(x,	1);
	MakeCode	(x=0X16C1);
	OpHex		(x,	1);
	MakeCode	(x=0X16C3);
	OpHex		(x,	1);
	MakeComm	(0X16C5,	"get rid of any erroneous bits");
	MakeCode	(x=0X16C5);
	OpHex		(x,	1);
	MakeComm	(0X16C8,	"is 10's place in range");
	MakeCode	(x=0X16C8);
	OpDecimal	(x,	1);
	MakeComm	(0X16CB,	"jmp out of range");
	MakeComm	(0X16D1,	"set success flag");
	MakeComm	(0X16D3,	"set error flag");
	MakeCode	(0X16D3);
	MakeByte	(0X16D5);
	MakeWord	(0X16D6);
	MakeName	(0X16D6,	"drvfat");
	MakeWord	(0X16D8);
	MakeName	(0X16D8,	"bios_l");
	MakeWord	(0X16DA);
	MakeName	(0X16DA,	"bios_h");
	MakeWord	(0X16DC);
	MakeName	(0X16DC,	"doscnt");
	MakeByte	(0X16DE);
	MakeName	(0X16DE,	"fbigfat");
	MakeWord	(0X16DF);
	MakeName	(0X16DF,	"fatloc");
	MakeWord	(0X16E1);
	MakeName	(0X16E1,	"init_bootseg");
	MakeByte	(0X16E3);
	MakeName	(0X16E3,	"rom_drv_num");
	MakeWord	(x=0X16E4);
	OpDecimal	(x,	0);
	MakeName	(0X16E4,	"md_sectorsize");
	MakeWord	(0X16E6);
	MakeName	(0X16E6,	"temp_cluster");
	MakeWord	(x=0X16E8);
	OpDecimal	(x,	0);
	MakeName	(0X16E8,	"last_fat_secnum");
	MakeByte	(0X16EA);
	MakeName	(0X16EA,	"num_heads");
	MakeByte	(0X16EB);
	MakeName	(0X16EB,	"sec_trk");
	MakeByte	(x=0X16EC);
	OpDecimal	(x,	0);
	MakeName	(0X16EC,	"num_cyln");
	MakeByte	(0X16ED);
	MakeName	(0X16ED,	"fakefloppydrv");
	MakeComm	(0X16EE,	"\nwarning !!! old values\ndefault disktable under\nthe assumption of total fat size <= 128 kb,\nand the maximum size of fat entry = 16 bit.");
	MakeWord	(x=0X16EE);
	MakeArray	(x,	0X14);
	OpDecimal	(x,	0);
	MakeName	(0X16EE,	"disktable");
	MakeComm	(0X1716,	"fbig = 64 ; covers upto 134 mb media.\nupto 268 mb\nupto 536 mb\nupto 1072 mb\nupto 2144 mb\nupto 4288 mb...");
	MakeWord	(x=0X1716);
	MakeArray	(x,	0X23);
	OpDecimal	(x,	0);
	MakeName	(0X1716,	"disktable2");
	MakeComm	(0X175C,	"temp variable for phys unit");
	MakeByte	(0X175C);
	MakeName	(0X175C,	"rom_minidisk_num");
	MakeComm	(0X175D,	"real number of hardfiles");
	MakeByte	(0X175D);
	MakeName	(0X175D,	"hnum");
	MakeComm	(0X175E,	"index into dskdrv table");
	MakeWord	(x=0X175E);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X175E,	"last_dskdrv_table");
	MakeComm	(0X1760,	"offset value of the ending address of bds table.\nneeded to figure out the dosdatasg address.");
	MakeWord	(x=0X1760);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X1760,	"end_of_bdss");
	MakeWord	(0X1762);
	MakeName	(0X1762,	"mini_hdlim");
	MakeWord	(0X1764);
	MakeName	(0X1764,	"mini_seclim");
	MakeComm	(0X1766,	"used for checking at rom bios   date.");
	MakeStr		(0X1766,	0X176F);
	MakeName	(0X1766,	"bios_date");
	MakeComm	(0X176F,	"align 2");
	MakeByte	(0X176F);
	MakeComm	(0X1770,	"48 tpi diskettes ; physical sector size in bytes");
	MakeWord	(x=0X1770);
	OpDecimal	(x,	0);
	MakeName	(0X1770,	"bpb48t");
	MakeByte	(0X1772);
	MakeWord	(0X1773);
	MakeByte	(0X1775);
	MakeWord	(x=0X1776);
	OpDecimal	(x,	0);
	MakeWord	(x=0X1778);
	OpDecimal	(x,	0);
	MakeByte	(0X177A);
	MakeWord	(0X177B);
	MakeWord	(0X177D);
	MakeWord	(0X177F);
	MakeWord	(0X1781);
	MakeWord	(0X1783);
	MakeDword	(0X1785);
	MakeByte	(0X1789);
	MakeComm	(0X178A,	"96 tpi diskettes ; physical sector size in bytes");
	MakeWord	(x=0X178A);
	OpDecimal	(x,	0);
	MakeName	(0X178A,	"bpb96t");
	MakeByte	(0X178C);
	MakeWord	(0X178D);
	MakeByte	(0X178F);
	MakeWord	(x=0X1790);
	OpDecimal	(x,	0);
	MakeWord	(x=0X1792);
	OpDecimal	(x,	0);
	MakeByte	(0X1794);
	MakeWord	(x=0X1795);
	OpDecimal	(x,	0);
	MakeWord	(x=0X1797);
	OpDecimal	(x,	0);
	MakeWord	(x=0X1799);
	OpDecimal	(x,	0);
	MakeWord	(x=0X179B);
	OpDecimal	(x,	0);
	MakeWord	(x=0X179D);
	OpDecimal	(x,	0);
	MakeByte	(0X179F);
	MakeByte	(0X17A0);
	MakeByte	(0X17A1);
	MakeByte	(0X17A2);
	MakeByte	(0X17A3);
	MakeComm	(0X17A4,	"3.5\" diskettes ; physical sector size in bytes");
	MakeWord	(x=0X17A4);
	OpDecimal	(x,	0);
	MakeName	(0X17A4,	"bpb35");
	MakeComm	(0X17A6,	"sectors/allocation unit");
	MakeByte	(0X17A6);
	MakeComm	(0X17A7,	"reserved sectors for dos");
	MakeWord	(0X17A7);
	MakeComm	(0X17A9,	"number of allocation tables");
	MakeByte	(0X17A9);
	MakeComm	(0X17AA,	"number of directory entries");
	MakeWord	(x=0X17AA);
	OpDecimal	(x,	0);
	MakeComm	(0X17AC,	"number of sectors (at 512 bytes each)");
	MakeWord	(x=0X17AC);
	OpDecimal	(x,	0);
	MakeComm	(0X17AE,	"media descriptor");
	MakeByte	(0X17AE);
	MakeComm	(0X17AF,	"number of fat sectors");
	MakeWord	(0X17AF);
	MakeComm	(0X17B1,	"sectors per track");
	MakeWord	(0X17B1);
	MakeComm	(0X17B3,	"heads");
	MakeWord	(0X17B3);
	MakeComm	(0X17B5,	"hidden sector count (low word)");
	MakeWord	(0X17B5);
	MakeComm	(0X17B7,	"hidden sector (high)");
	MakeWord	(0X17B7);
	MakeComm	(0X17B9,	"number of sectors");
	MakeDword	(0X17B9);
	MakeByte	(0X17BD);
	MakeComm	(0X17BE,	"3.5\" diskettes - 2.88 MB ; physical sector size in bytes");
	MakeWord	(x=0X17BE);
	OpDecimal	(x,	0);
	MakeName	(0X17BE,	"bpb288");
	MakeByte	(0X17C0);
	MakeWord	(0X17C1);
	MakeByte	(0X17C3);
	MakeWord	(x=0X17C4);
	OpDecimal	(x,	0);
	MakeWord	(x=0X17C6);
	OpDecimal	(x,	0);
	MakeWord	(0X17C9);
	MakeWord	(x=0X17CB);
	OpDecimal	(x,	0);
	MakeWord	(0X17CD);
	MakeWord	(0X17CF);
	MakeWord	(0X17D1);
	MakeDword	(0X17D3);
	MakeByte	(0X17D7);
	MakeComm	(0X17D8,	"48tpi drives");
	MakeWord	(x=0X17D8);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X17D8,	"bpbtable");
	MakeComm	(0X17DA,	"96tpi drives");
	MakeWord	(x=0X17DA);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X17DC,	"3.5\" drives");
	MakeWord	(x=0X17DC);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X17DE,	"unused 8\" diskette");
	MakeWord	(x=0X17DE);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X17E0,	"unused 8\" diskette");
	MakeWord	(x=0X17E0);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X17E2,	"used for hard disk");
	MakeWord	(x=0X17E2);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X17E4,	"used for tape drive");
	MakeWord	(x=0X17E4);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X17E6,	"FFOTHER");
	MakeWord	(x=0X17E6);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X17E8,	"ERIMO");
	MakeWord	(x=0X17E8);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X17EA,	"2.88MB drive");
	MakeWord	(x=0X17EA);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeWord	(x=0X17EC);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeName	(0X17EC,	"addr_of_bcretf");
	MakeComm	(0X17EE,	"set up near return to far return");
	MakeCode	(0X17EE);
	MakeName	(0X17EE,	"call_bios_code");
	MakeComm	(0X17F3,	"push Bios_Code segment");
	MakeComm	(0X17F8,	"save offset of utility function");
	MakeComm	(0X17F9,	"far jump to (DOS)BIOS code");
	MakeByte	(0X17FA);
	MakeName	(0X17FA,	"flp_drvs");
	MakeComm	(0X17FB,	"entry from boot sector. the register contents are:\n\ndl = int 13 drive number we booted from\nch = media byte\nbx = first data sector on disk.\nax = first data sector (high)\ndi = sectors/fat for the boot media.");
	MakeCode	(0X17FB);
	MakeName	(0X17FB,	"init");
	MakeComm	(0X1810,	"SYSINIT segment");
	MakeCode	(x=0X1810);
	OpHex		(x,	1);
	MakeCode	(x=0X1815);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeName	(0X1818,	"startmsg_nxt_chr");
	MakeComm	(0X1822,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)");
	MakeCode	(x=0X1822);
	OpHex		(x,	0);
	MakeCode	(0X1826);
	MakeName	(0X1826,	"startmsg_ok");
	MakeCode	(x=0X182A);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X182D,	"next_int");
	MakeCode	(x=0X1830);
	OpHex		(x,	1);
	MakeCode	(x=0X1832);
	OpHex		(x,	1);
	MakeComm	(0X1852,	"Int 13h vector");
	MakeCode	(x=0X1852);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X1858);
	MakeComm	(0X185C,	"Int 15h vector");
	MakeCode	(x=0X185C);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X1862);
	MakeComm	(0X1866,	"Int 19h vector");
	MakeCode	(x=0X1866);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X186C);
	MakeComm	(0X1871,	"EQUIPMENT DETERMINATION\nReturn: AX = equipment flag bits");
	MakeCode	(x=0X1871);
	OpHex		(x,	0);
	MakeComm	(0X1873,	"floppy drives present ?");
	MakeCode	(x=0X1873);
	OpHex		(x,	1);
	MakeComm	(0X1876,	"yes");
	MakeComm	(0X1882,	"DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)\nDL = drive number\nReturn: CF set on error, AH = status code, BL = drive type\nDL = number of consecutive drives\nDH = maximum value for head number, ES:DI -> drive parameter");
	MakeCode	(x=0X1882);
	OpHex		(x,	0);
	MakeName	(0X188B,	"_gdskp_error");
	MakeComm	(0X1891,	"if error it is an old ROM BIOS\nso, lets assume that ROM BIOS lied");
	MakeComm	(0X18A3,	"we don't have any floppy drives.");
	MakeCode	(0X18A3);
	MakeName	(0X18A3,	"_set_fake_flpdrv");
	MakeComm	(0X18AC,	"well then set it for two drives!");
	MakeComm	(0X18AE,	"there exist floppy drives.\nput bits 6 & 7 into bits 0 & 1");
	MakeCode	(x=0X18AE);
	OpHex		(x,	1);
	MakeName	(0X18AE,	"normalfloppydrv");
	MakeCode	(x=0X18B0);
	OpHex		(x,	1);
	MakeComm	(0X18B2,	"only look at bits 0 & 1");
	MakeCode	(x=0X18B2);
	OpHex		(x,	1);
	MakeName	(0X18B2,	"got_num_flp_drvs");
	MakeComm	(0X18B5,	"zero means single drive system");
	MakeComm	(0X18B7,	"pretend it's a two drive system\nset this to two fakedrives");
	MakeName	(0X18B8,	"settwodrive");
	MakeComm	(0X18BD,	"ax has number of drives");
	MakeName	(0X18BD,	"notsingle");
	MakeComm	(0X18C0,	"determine whether we booted from floppy or hard disk..");
	MakeCode	(x=0X18C0);
	OpHex		(x,	1);
	MakeComm	(0X18C3,	"hard disk");
	MakeComm	(0X18C5,	"indicate boot from drive A");
	MakeComm	(0X18C7,	"ax = 0-based drive we booted from\nbios_l, bios_h set.\ncl = number of floppies including fake one\nch = media byte");
	MakeName	(0X18C7,	"gothrd");
	MakeCode	(x=0X18CC);
	OpHex		(x,	1);
	MakeComm	(0X18D3,	"save boot drive number and media byte");
	MakeCode	(x=0X18D4);
	OpHex		(x,	1);
	MakeComm	(0X18D6,	"SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)");
	MakeCode	(x=0X18D6);
	OpHex		(x,	0);
	MakeComm	(0X18DF,	"[es:bx+ROMBIOS_DESC.bios_sd_modelbyte]");
	MakeComm	(0X18E7,	"[es:bx+ROMBIOS_DESC.bios_sd_scnd_modelbyte]");
	MakeCode	(0X18F1);
	MakeName	(0X18F1,	"no_rom_system_conf");
	MakeComm	(0X18F6,	"get model byte (from 0FFFFh:0Eh)");
	MakeComm	(0X18FE,	"turn on the timer");
	MakeCode	(x=0X18FE);
	OpHex		(x,	1);
	MakeName	(0X18FE,	"turn_timer_on");
	MakeComm	(0X1900,	"Interrupt controller, 8259A.");
	MakeCode	(x=0X1900);
	OpHex		(x,	0);
	MakeComm	(0X1902,	"Olivetti m24 check");
	MakeComm	(0X190A,	"inhibit the normal aux port initialization");
	MakeCode	(x=0X190A);
	OpHex		(x,	1);
	MakeCode	(x=0X190C);
	OpHex		(x,	1);
	MakeComm	(0X1910,	"double check");
	MakeCode	(x=0X1912);
	OpHex		(x,	0);
	MakeCode	(x=0X1914);
	OpHex		(x,	1);
	MakeComm	(0X1916,	"this test was copied from olivetti");
	MakeCode	(x=0X1916);
	OpHex		(x,	1);
	MakeComm	(0X1918,	"take this branch if 8530 installed");
	MakeComm	(0X191A,	"init com4");
	MakeName	(0X191A,	"not_olivetti_m24");
	MakeComm	(0X191F,	"init com3");
	MakeComm	(0X1924,	"init com2");
	MakeComm	(0X1929,	"init com1");
	MakeComm	(0X192E,	"init lpt3");
	MakeName	(0X192E,	"skip_aux_port_init");
	MakeComm	(0X1933,	"init lpt2");
	MakeComm	(0X1938,	"init lpt1");
	MakeComm	(0X193F,	"to initialize print screen vector");
	MakeComm	(0X1943,	"0");
	MakeComm	(0X1945,	"INITSPOT");
	MakeCode	(x=0X1945);
	OpHex		(x,	1);
	MakeComm	(0X1948,	"IBM wants 4 zeros here");
	MakeComm	(0X194A,	"fetch segment");
	MakeCode	(x=0X194C);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X1952,	"[BRKADR]");
	MakeCode	(x=0X1952);
	MakeComm	(0X1955,	"[CHROUT*4]");
	MakeCode	(x=0X1955);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X195B);
	MakeCode	(x=0X1961);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X1965,	"location 4");
	MakeComm	(0X1967,	"cs:");
	MakeComm	(0X196C,	"location 12");
	MakeComm	(0X196E,	"cs:");
	MakeComm	(0X1970,	"location 16");
	MakeComm	(0X1972,	"cs:");
	MakeComm	(0X1973,	"0  ; Print screen status byte (not active)");
	MakeCode	(x=0X1973);
	MakeComm	(0X1977,	"0 ; DOS single diskette mode flag, 0=A:, 1=B:");
	MakeCode	(x=0X1977);
	MakeComm	(0X197B,	"[SEC9+DISK_PARMS.DISK_MOTOR_STRT]");
	MakeCode	(x=0X197B);
	MakeComm	(0X1982,	"is this an old rom?");
	MakeCode	(x=0X1982);
	OpHex		(x,	1);
	MakeComm	(0X1988,	"no");
	MakeComm	(0X198A,	"[SEC9+DISK_PARMS.DISK_HEAD_STTL], 0200h+NORMSETTLE");
	MakeCode	(x=0X198A);
	OpHex		(x,	1);
	MakeComm	(0X1990,	"[SEC9+DISK_PARMS.DISK_SPECIFY_1]\nset 1st specify byte on pc-1 pc-2 pc-xt hal0");
	MakeCode	(x=0X1990);
	OpHex		(x,	1);
	MakeComm	(0X1995,	"MEMORY SIZE - \nReturn: AX = number of contiguous 1K blocks of memory");
	MakeCode	(x=0X1995);
	OpHex		(x,	0);
	MakeName	(0X1995,	"no_diddle");
	MakeComm	(0X1999,	"convert memory size to 16-byte blocks (segment no.)");
	MakeComm	(0X19A1,	"save real top of memory");
	MakeComm	(0X19A8,	"[2Fh*4]");
	MakeCode	(x=0X19A8);
	MakeCode	(x=0X19AC);
	MakeComm	(0X19B0,	"'RPL'");
	MakeComm	(0X19BD,	"get TOM into DX");
	MakeComm	(0X19BF,	"(multMULT shl 8) + multMULTRPLTOM");
	MakeComm	(0X19C2,	"Get new TOM from any RPL");
	MakeCode	(x=0X19C2);
	OpHex		(x,	0);
	MakeName	(0X19C6,	"SkipRPL");
	MakeComm	(0X19C8,	"room for fatloc segment. (1 kb buffer)");
	MakeCode	(x=0X19C8);
	OpHex		(x,	1);
	MakeComm	(0X19CB,	"location to read fat");
	MakeCode	(x=0X19CF);
	OpHex		(x,	1);
	MakeComm	(0X19D7,	"SYSINIT segment");
	MakeCode	(x=0X19DC);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X19E2);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X19E6);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X19EB);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X19EF,	"DOSLOADSEG");
	MakeCode	(x=0X19EF);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X19F5,	"SYSINIT segment");
	MakeComm	(0X19FA,	"some old ibm hardware generates spurious int 0F's\ndue to bogus printer cards.\nwe initialize this value to point to an iret\nonly if\n   1) the original segment points to \n      storage inside valid ram.\n   2) the original segment is 0F000:xxxx");
	MakeComm	(0X19FC,	"0");
	MakeComm	(0X19FE,	"segment for INT 0Fh");
	MakeCode	(x=0X19FE);
	MakeComm	(0X1A01,	"es:294h\n(condition 1)");
	MakeCode	(x=0X1A01);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X1A08,	"(condition 2)");
	MakeComm	(0X1A0D,	"[0Fh*4]");
	MakeCode	(x=0X1A0D);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X1A0D,	"resetintf");
	MakeCode	(x=0X1A13);
	MakeName	(0X1A17,	"keepintf");
	MakeComm	(0X1A1B,	"get keyboard flag");
	MakeCode	(x=0X1A1B);
	MakeComm	(0X1A1F,	"extended keyboard ?");
	MakeCode	(x=0X1A1F);
	OpHex		(x,	1);
	MakeComm	(0X1A22,	"no, original keyboard\nchange for extended keyboard functions");
	MakeName	(0X1A30,	"org_key");
	MakeComm	(0X1A34,	"If cmos clock exists,\nthen set the system time according to that.\nalso, reset the cmos clock rate.");
	MakeComm	(0X1A37,	"hdrv_pat\nset up pointer to hdrive");
	MakeCode	(x=0X1A37);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X1A3D,	"number of floppies and FAT ID");
	MakeComm	(0X1A3E,	"chuck fat id byte");
	MakeComm	(0X1A40,	"remember which drive is hard disk");
	MakeComm	(0X1A43,	"and set initial number of drives");
	MakeCode	(x=0X1A46);
	OpHex		(x,	1);
	MakeComm	(0X1A4D,	"point to ROM BIOS");
	MakeComm	(0X1A52,	"'OC' ; look for COMPAQ");
	MakeComm	(0X1A5A,	"'PM'");
	MakeComm	(0X1A62,	"'QA'");
	MakeComm	(0X1A6D,	"OS HOOK - DEVICE OPEN (AT,XT2,XT286,PS)\nBX = device ID, CX = process type\nReturn: CF set on error, AH = status\nCF clear if successful, AH = 00h");
	MakeCode	(x=0X1A6D);
	OpHex		(x,	0);
	MakeComm	(0X1A71,	"enable mode 2\n(dual hard disk controllers on Compaq systems)");
	MakeCode	(x=0X1A71);
	OpHex		(x,	1);
	MakeComm	(0X1A77,	"OS HOOK - DEVICE OPEN (AT,XT2,XT286,PS)\nBX = device ID, CX = process type\nReturn: CF set on error, AH = status\nCF clear if successful, AH = 00h");
	MakeCode	(x=0X1A77);
	OpHex		(x,	0);
	MakeName	(0X1A79,	"skip_mode2");
	MakeCode	(x=0X1A7A);
	OpHex		(x,	1);
	MakeComm	(0X1A7E,	"DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)\nDL = drive number\nReturn: CF set on error, AH = status code, BL = drive type\nDL = number of consecutive drives\nDH = maximum value for head number, ES:DI -> drive parameter");
	MakeCode	(x=0X1A7E);
	OpHex		(x,	0);
	MakeComm	(0X1A86,	"scan the list of drives to determine their type.\nwe have three flavors of diskette drives:\n\n48tpi drives  we do nothing special for them\n96tpi drives  mark the fact that they have changeline support.\n3.5\"  drives  mark changeline support and small.\n\nthe following code uses registers for certain values:\n\n   dl - physical drive\n   ds:di - points to current bds\n   cx - flag bits for bds\n   dh - form factor for the drive\n       (1 - 48tpi, 2 - 96tpi, 3 - 3.5\" medium)");
	MakeName	(0X1A86,	"enddrv");
	MakeCode	(x=0X1A8F);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X1A99,	"[di+BDS.link] ; di <- first bds link");
	MakeComm	(0X1A9B,	"[di+BDS.link] ; di <- second bds link");
	MakeComm	(0X1A9D,	"-1 ; set end of link");
	MakeComm	(0X1AA1,	"allocate/initialise bds for harddrives");
	MakeCode	(0X1AA4);
	MakeName	(0X1AA4,	"loop_drive");
	MakeComm	(0X1AAD,	"zero all flags");
	MakeCode	(0X1AAD);
	MakeName	(0X1AAD,	"got_more");
	MakeComm	(0X1AAF,	"mov di,[di+BDS.link] ; get next bds");
	MakeComm	(0X1AB1,	"ff48tpi ; set form factor to 48 tpi");
	MakeCode	(x=0X1AB3);
	OpDecimal	(x,	1);
	MakeComm	(0X1ABF,	"DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)\nDL = drive number\nReturn: CF set on error, AH = status code, BL = drive type\nDL = number of consecutive drives\nDH = maximum value for head number, ES:DI -> drive parameter");
	MakeCode	(x=0X1ABF);
	OpHex		(x,	0);
	MakeComm	(0X1AC3,	"if ch=0, then cl,dh=0 too.");
	MakeComm	(0X1AC8,	"rom gave wrong info.");
	MakeCode	(x=0X1AC8);
	OpDecimal	(x,	1);
	MakeComm	(0X1ACA,	"let's default to 360k.");
	MakeComm	(0X1ACE,	"make number of heads 1-based");
	MakeName	(0X1ACE,	"pfr_ok");
	MakeComm	(0X1AD0,	"make number of cylinders 1-based");
	MakeComm	(0X1AD2,	"save parms returned by rom");
	MakeComm	(0X1AD6,	"extract sectors/track");
	MakeCode	(x=0X1AD6);
	OpHex		(x,	1);
	MakeComm	(0X1ADD,	"assume less than 256 cylinders!!");
	MakeComm	(0X1AE1,	"make sure that eot contains the max number of sec/trk\n in system of floppies");
	MakeName	(0X1AEB,	"eot_ok");
	MakeComm	(0X1AF0,	"set command to get dasd type");
	MakeComm	(0X1AF2,	"DISK - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)\nDL = drive ID\nReturn: CF set on error, AH = disk type (3 = hard drive)\nCX:DX = number of sectors on the media");
	MakeCode	(x=0X1AF2);
	OpHex		(x,	0);
	MakeComm	(0X1AF6,	"check for presence of changeline");
	MakeComm	(0X1AFB,	"fchangeline ; signal type");
	MakeCode	(x=0X1AFB);
	OpHex		(x,	1);
	MakeComm	(0X1AFE,	"remember that we have 96tpi disks");
	MakeComm	(0X1B03,	"we have a \"strange\" medium");
	MakeCode	(x=0X1B03);
	OpDecimal	(x,	1);
	MakeName	(0X1B03,	"changeline_done");
	MakeName	(0X1B11,	"gotother");
	MakeComm	(0X1B13,	"\n80 cylinders and 9 sectors/track => 720 kb device\n80 cylinders and 15 sec/trk => 96 tpi medium");
	MakeCode	(x=0X1B15);
	OpDecimal	(x,	1);
	MakeName	(0X1B15,	"try_80");
	MakeComm	(0X1B1C,	"ff288 ; assume 2.88 MB drive");
	MakeComm	(0X1B1E,	"is it ?");
	MakeCode	(x=0X1B1E);
	OpDecimal	(x,	1);
	MakeComm	(0X1B23,	"yes, go update");
	MakeCode	(x=0X1B25);
	OpDecimal	(x,	1);
	MakeComm	(0X1B33,	"ffsmall");
	MakeComm	(0X1B37,	"ff96tpi");
	MakeCode	(0X1B37);
	MakeName	(0X1B37,	"got96");
	MakeCode	(0X1B3B);
	MakeName	(0X1B3B,	"noparmsfromrom");
	MakeComm	(0X1B40,	"set command to get dasd type");
	MakeComm	(0X1B42,	"DISK - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)\nDL = drive ID\nReturn: CF set on error, AH = disk type (3 = hard drive)\nCX:DX = number of sectors on the media");
	MakeCode	(x=0X1B42);
	OpHex		(x,	0);
	MakeComm	(0X1B46,	"is there changeline?");
	MakeCode	(x=0X1B4B);
	OpHex		(x,	1);
	MakeComm	(0X1B4E,	"remember that we have 96tpi drives");
	MakeCode	(x=0X1B53);
	OpDecimal	(x,	1);
	MakeComm	(0X1B5A,	"set eot if necessary");
	MakeCode	(x=0X1B5A);
	OpDecimal	(x,	1);
	MakeComm	(0X1B65,	"fi_own_physical ; set this true for all drives");
	MakeCode	(x=0X1B65);
	OpHex		(x,	1);
	MakeName	(0X1B65,	"nextdrive");
	MakeComm	(0X1B68,	"save int 13h drive number");
	MakeComm	(0X1B71,	"int 13h drive number same for logical drive");
	MakeComm	(0X1B73,	"fi_own_physical ; reset ownership flag for logical drive");
	MakeCode	(x=0X1B73);
	OpHex		(x,	1);
	MakeComm	(0X1B76,	"fill BDS for drive");
	MakeName	(0X1B76,	"not_special");
	MakeComm	(0X1B7B,	"[di+BDS.rheads]");
	MakeCode	(x=0X1B7B);
	OpDecimal	(x,	0);
	MakeComm	(0X1B81,	"[di+BDS.rsecpertrack]");
	MakeCode	(x=0X1B81);
	OpDecimal	(x,	0);
	MakeComm	(0X1B84,	"[di+BDS.flags]");
	MakeCode	(x=0X1B84);
	OpDecimal	(x,	0);
	MakeComm	(0X1B87,	"[di+BDS.formfactor]");
	MakeCode	(x=0X1B87);
	OpDecimal	(x,	0);
	MakeComm	(0X1B8A,	"[di+BDS.drivelet]");
	MakeComm	(0X1B8D,	"[di+BDS.drivenum]");
	MakeComm	(0X1B94,	"[di+BDS.cylinders]");
	MakeCode	(x=0X1B94);
	OpDecimal	(x,	0);
	MakeComm	(0X1B97,	"Special case for single drive system");
	MakeComm	(0X1B9E,	"Don't forget we have single drive system");
	MakeComm	(0X1BA3,	"fi_am_mult\nset that this is one of several drives");
	MakeCode	(x=0X1BA3);
	OpHex		(x,	1);
	MakeComm	(0X1BA6,	"[di+BDS.flags] ; save flags");
	MakeCode	(x=0X1BA6);
	OpDecimal	(x,	0);
	MakeComm	(0X1BA9,	"[di+BDS.link] ; move to next BDS in list");
	MakeComm	(0X1BAB,	"add a number");
	MakeComm	(0X1BAD,	"Use same info for BDS as previous");
	MakeCode	(0X1BAF);
	MakeName	(0X1BAF,	"no_single");
	MakeComm	(0X1BB4,	"[di+BDS.link],-1 ; set link to null");
	MakeCode	(0X1BB4);
	MakeName	(0X1BB4,	"done_drives");
	MakeName	(0X1BB8,	"dohard");
	MakeComm	(0X1BBC,	"done if no hardfiles");
	MakeCode	(x=0X1BC0);
	OpHex		(x,	1);
	MakeName	(0X1BC2,	"dohard1");
	MakeComm	(0X1BCB,	"first primary partition (or active)");
	MakeComm	(0X1BD2,	"error if already 26 drives");
	MakeComm	(0X1BD7,	"insert new bds into linked list");
	MakeName	(0X1BDA,	"hardfile_err");
	MakeComm	(0X1BDB,	"next hard drive");
	MakeComm	(0X1BDF,	"\nend of physical drive   initialization\n\n*** do not change the position of the following statement.\n*** domini routine will use [drvmax] value for the start of the logical\n*** drive number of mini disk(s).");
	MakeComm	(0X1BE1,	"for setting up mini disks, if found");
	MakeComm	(0X1BE4,	"we already know this is >0");
	MakeCode	(x=0X1BE8);
	OpHex		(x,	1);
	MakeComm	(0X1BEA,	"do all subsequent primary partitions");
	MakeName	(0X1BEA,	"dohardx1");
	MakeName	(0X1BEC,	"dohardx2");
	MakeComm	(0X1BF9,	"move to next hardfile if error");
	MakeComm	(0X1BFB,	"make sure <=26 drives");
	MakeComm	(0X1BFE,	"skip if error");
	MakeComm	(0X1C00,	"insert new bds into linked list");
	MakeComm	(0X1C03,	"get partition number");
	MakeComm	(0X1C04,	"restore physical drive counts");
	MakeComm	(0X1C07,	"keep looping until we fail");
	MakeComm	(0X1C09,	"unjunk partition number from stack");
	MakeCode	(0X1C09);
	MakeName	(0X1C09,	"dohardx4");
	MakeComm	(0X1C0A,	"restore physical drive counts");
	MakeComm	(0X1C0B,	"next hard drive");
	MakeComm	(0X1C11,	">2 diskette drives");
	MakeComm	(0X1C16,	"no - no need for remapping");
	MakeComm	(0X1C18,	"remap bds chain to adjust driver letters\n...\nEnd of drive initialization.");
	MakeName	(0X1C1B,	"static_configure");
	MakeComm	(0X1C1F,	"did we allocate any hard drive bdss?");
	MakeCode	(x=0X1C1F);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X1C23,	"that's the end, then");
	MakeComm	(0X1C25,	"end96tpi\nkeep everything up to end96tpi");
	MakeCode	(x=0X1C25);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X1C2F);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X1C32,	"dynamic_configure");
	MakeComm	(0X1C34,	"clear direction");
	MakeComm	(0X1C35,	"AT ?");
	MakeCode	(x=0X1C35);
	OpHex		(x,	1);
	MakeComm	(0X1C3C,	"No hard file?");
	MakeComm	(0X1C43,	"save allocation pointer in ax");
	MakeComm	(0X1C47,	"ES -> ROM BIOS segment");
	MakeCode	(x=0X1C49);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X1C4C,	"ROM BIOS string is at   F000:FFF5");
	MakeComm	(0X1C4F,	"bdate_l ; Only patch ROM for bios 01/10/84");
	MakeComm	(0X1C52,	"check for date + zero on end");
	MakeComm	(0X1C54,	"restore allocation pointer");
	MakeCode	(x=0X1C57);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X1C5A);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(0X1C5F);
	MakeName	(0X1C5F,	"checkcompaqbug");
	MakeComm	(0X1C64,	"look for COMPAQ");
	MakeCode	(x=0X1C64);
	OpChr		(x,	1);
	MakeCode	(x=0X1C6D);
	OpChr		(x,	1);
	MakeCode	(x=0X1C76);
	OpChr		(x,	1);
	MakeComm	(0X1C7F,	"get year");
	MakeComm	(0X1C85,	"3836h ; is it 86?");
	MakeCode	(x=0X1C85);
	OpChr		(x,	1);
	MakeComm	(0X1C8C,	"get month");
	MakeComm	(0X1C92,	"3038h ; is it 08?");
	MakeCode	(x=0X1C92);
	OpChr		(x,	1);
	MakeComm	(0X1C99,	"get day");
	MakeComm	(0X1C9F,	"3034h ; is it 04?");
	MakeCode	(x=0X1C9F);
	OpChr		(x,	1);
	MakeCode	(x=0X1CA4);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X1CA4,	"do_compaq_patch");
	MakeCode	(x=0X1CA7);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X1CAA,	"install_int13_patch");
	MakeComm	(0X1CAC,	"set new rom bios int 13 vector");
	MakeComm	(0X1CB4,	"size of rom fix module");
	MakeComm	(0X1CB6,	"relocate it");
	MakeName	(0X1CB8,	"not_compaq_patch");
	MakeComm	(0X1CBA,	"cmos clock exists?");
	MakeComm	(0X1CBF,	"no");
	MakeComm	(0X1CC1,	"set the address for mschar");
	MakeComm	(0X1CC5,	"enddaycnttoday - daycnt_to_day");
	MakeCode	(x=0X1CC5);
	OpDecimal	(x,	1);
	MakeCode	(x=0X1CC8);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X1CCD,	"set the address for msclock\nlet original segment stay");
	MakeComm	(0X1CD1,	"endcmosclockset - bin_to_bcd");
	MakeCode	(x=0X1CD1);
	OpDecimal	(x,	1);
	MakeCode	(x=0X1CD4);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X1CD9,	"checkk09");
	MakeComm	(0X1CDA,	"wait for bh=es:[di]");
	MakeCode	(x=0X1CDA);
	OpHex		(x,	1);
	MakeComm	(0X1CDD,	"wait for 1 clock tick");
	MakeComm	(0X1CE3,	"SYSTEM - WAIT ON EXTERNAL EVENT (CONVERTIBLE)\nAL = condition type, BH = condition compare or mask value\nBL = timeout value times 55 milliseconds, 00h means no timeout\nDX = I/O port address if AL bit 4 set");
	MakeCode	(x=0X1CE3);
	OpHex		(x,	0);
	MakeComm	(0X1CE8,	"remember we have a k09 type");
	MakeComm	(0X1CF2,	"[6Ch*4]\nnew int 6ch handler");
	MakeCode	(x=0X1CFB);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X1CFE,	"endk09-int6c (size of k09 routine)");
	MakeCode	(x=0X1CFE);
	OpDecimal	(x,	1);
	MakeComm	(0X1D03,	"di is final ending address of msbio.");
	MakeName	(0X1D03,	"configdone");
	MakeComm	(0X1D05,	"round (up) to paragraph");
	MakeCode	(x=0X1D05);
	OpDecimal	(x,	1);
	MakeCode	(x=0X1D08);
	OpHex		(x,	1);
	MakeCode	(x=0X1D0A);
	OpHex		(x,	1);
	MakeCode	(x=0X1D0C);
	OpHex		(x,	1);
	MakeCode	(x=0X1D0E);
	OpHex		(x,	1);
	MakeCode	(x=0X1D10);
	OpHex		(x,	1);
	MakeComm	(0X1D14,	"where the dos data segment will be");
	MakeComm	(0X1D18,	"get drive and fat id");
	MakeComm	(0X1D1B,	"Note: SETDRIVES uses AL (drive number) only");
	MakeCode	(x=0X1D1B);
	OpOff		(x,	1,	0X25C0);
	OpOff		(x,	129,	0X25C0);
	MakeComm	(0X1D1E,	"simulate far call");
	MakeComm	(0X1D1F,	"get bds for drive");
	MakeComm	(0X1D22,	"ensure valid bpb is present");
	MakeCode	(x=0X1D22);
	OpOff		(x,	1,	0X25C0);
	OpOff		(x,	129,	0X25C0);
	MakeComm	(0X1D29,	"copy bds to ds:di");
	MakeComm	(0X1D2D,	"get fat id byte");
	MakeComm	(0X1D30,	"save fat byte");
	MakeComm	(0X1D39,	"copy bds to es:di");
	MakeComm	(0X1D3B,	"copy Bios_Data to ds");
	MakeCode	(x=0X1D3D);
	OpOff		(x,	1,	0X25C0);
	OpOff		(x,	129,	0X25C0);
	MakeComm	(0X1D40,	"simulate far call");
	MakeComm	(0X1D41,	"get correct bds for this drive");
	MakeComm	(0X1D47,	"[di+BDS.BDS_BPB.BPB_BYTESPERSECTOR]");
	MakeComm	(0X1D4A,	"used by get_fat_sector proc.");
	MakeComm	(0X1D4F,	"[di+BDS.fatsiz]\nget size of fat on media");
	MakeCode	(x=0X1D4F);
	OpDecimal	(x,	1);
	MakeCode	(x=0X1D52);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X1D5A,	"[di+BDS.BDS_BPB.BPB_HIDDENSECTORS]");
	MakeCode	(x=0X1D5A);
	OpDecimal	(x,	1);
	MakeComm	(0X1D5D,	"subtract hidden sectors since we\nneed a logical sector number that will\nbe used by getclus(diskrd procedure)");
	MakeCode	(x=0X1D5D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X1D62,	"[di+BDS.BDS_BPB.BPB_HIDDENSECTORS+2]");
	MakeCode	(x=0X1D62);
	OpDecimal	(x,	1);
	MakeComm	(0X1D65,	"subtract upper 16 bits of sector num");
	MakeCode	(x=0X1D65);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X1D6A,	"cx = sectors/cluster");
	MakeComm	(0X1D6D,	"0");
	MakeComm	(0X1D71,	"clus=*53Ah\n(First cluster field of 2nd dir entry\nof root directory in the buffer at 500h)");
	MakeCode	(x=0X1D71);
	MakeComm	(0X1D76,	"SYSINIT segment (SYSINITSEG)");
	MakeCode	(x=0X1D76);
	OpHex		(x,	1);
	MakeName	(0X1D76,	"loadit");
	MakeCode	(x=0X1D7B);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X1D80,	"read cluster at ES:DI (DI is updated)");
	MakeComm	(0X1D83,	"fbig");
	MakeCode	(x=0X1D83);
	OpHex		(x,	1);
	MakeCode	(x=0X1D8B);
	OpHex		(x,	1);
	MakeCode	(0X1D91);
	MakeName	(0X1D91,	"eofbig");
	MakeComm	(0X1D94,	"keep loading until cluster = eof");
	MakeName	(0X1D94,	"iseofx");
	MakeComm	(0X1D99,	"SYSINIT:_SYSINIT");
	MakeCode	(x=0X1D99);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X1D9E,	"get first bds");
	MakeCode	(0X1D9E);
	MakeName	(0X1D9E,	"remap");
	MakeComm	(0X1DA3,	"[di+BDS.drivenum] ; first hard disk??");
	MakeCode	(x=0X1DA3);
	OpHex		(x,	1);
	MakeComm	(0X1DA7,	"yes, continue");
	MakeComm	(0X1DA9,	"[di+BDS.link] ; get next bds, assume segment");
	MakeComm	(0X1DAB,	"last bds?");
	MakeCode	(x=0X1DAB);
	OpSign		(x,	1);
	OpDecimal	(x,	1);
	MakeComm	(0X1DAE,	"loop if not");
	MakeComm	(0X1DB0,	"yes, no hard drive on   system");
	MakeComm	(0X1DB2,	"start with logical drv num=2");
	MakeCode	(0X1DB2);
	MakeComm	(0X1DB4,	"[di+BDS.drivelet] ; found ??");
	MakeComm	(0X1DB7,	"[di+BDS.link] ; ds:di--> next bds");
	MakeComm	(0X1DB9,	"set num for next drive");
	MakeComm	(0X1DBB,	"last hard drive ??");
	MakeCode	(x=0X1DBB);
	OpSign		(x,	1);
	OpDecimal	(x,	1);
	MakeComm	(0X1DBE,	"no - assign more disk   drives");
	MakeComm	(0X1DC0,	"get first bds");
	MakeComm	(0X1DC5,	"[di+BDS.link] ; ds:di-->bds2");
	MakeComm	(0X1DC7,	"get number of floppies to remap");
	MakeComm	(0X1DCC,	"adjust for a: & b:");
	MakeComm	(0X1DCF,	"[di+BDS.link] ; set new num to next floppy");
	MakeComm	(0X1DD1,	"[di+BDS.drivelet]");
	MakeComm	(0X1DD4,	"new number for next floppy");
	MakeComm	(0X1DD6,	"count down extra floppies");
	MakeComm	(0X1DD8,	"\nnow we've got to adjust the boot drive \nif we reassigned it");
	MakeComm	(0X1DDE,	"is it a: or b: ?");
	MakeComm	(0X1DE2,	"is it one of the other floppies?");
	MakeComm	(0X1DE7,	"brif so");
	MakeComm	(0X1DE9,	"bootdrv -= (dsktnum-2)");
	MakeComm	(0X1DED,	"bootdrv += (drvmax-dsktnum)");
	MakeCode	(0X1DED);
	MakeComm	(0X1DF2,	"alter msdos.sys load drive");
	MakeComm	(0X1DF9,	"SYSINIT segment");
	MakeCode	(x=0X1DF9);
	OpHex		(x,	1);
	MakeComm	(0X1DFE,	"[SYSINIT+DEFAULT_DRIVE]\npass it to sysinit as well");
	MakeCode	(x=0X1DFE);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X1E03);
	MakeName	(0X1E03,	"getboot");
	MakeComm	(0X1E09,	"bootbias\nload BX, ES:BX is where sector goes");
	MakeCode	(x=0X1E09);
	OpHex		(x,	1);
	MakeCode	(x=0X1E0C);
	OpHex		(x,	1);
	MakeComm	(0X1E14,	"DISK - READ SECTORS INTO MEMORY\nAL = number of sectors to read, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer to fill\nReturn: CF set on error, AH = status, AL = number of sectors read");
	MakeCode	(x=0X1E14);
	OpHex		(x,	0);
	MakeComm	(0X1E18,	"[es:bootbias+1FEh]\nDave Litton magic word?");
	MakeComm	(0X1E1F,	"yes");
	MakeComm	(0X1E23,	"generate bpb for a variable sized hard file");
	MakeCode	(0X1E23);
	MakeName	(0X1E23,	"sethard");
	MakeComm	(0X1E27,	"[di+BDS.drivelet]");
	MakeComm	(0X1E2A,	"[di+BDS.drivenum]");
	MakeComm	(0X1E2D,	"[di+BDS.flags] ; fnon_removable");
	MakeCode	(x=0X1E2D);
	OpDecimal	(x,	0);
	OpHex		(x,	1);
	MakeComm	(0X1E31,	"[di+BDS.formfactor] ; ffHardFile");
	MakeCode	(x=0X1E31);
	OpDecimal	(x,	0);
	MakeComm	(0X1E35,	"assume 12 bit FAT");
	MakeComm	(0X1E3A,	"partition number");
	MakeComm	(0X1E3F,	"DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)\nDL = drive number\nReturn: CF set on error, AH = status code, BL = drive type\nDL = number of consecutive drives\nDH = maximum value for head number, ES:DI -> drive parameter");
	MakeCode	(x=0X1E3F);
	OpHex		(x,	0);
	MakeComm	(0X1E43,	"[di+BDS.heads] ; get number of heads");
	MakeComm	(0X1E47,	"error   if no hard disk");
	MakeCode	(x=0X1E49);
	OpHex		(x,	1);
	MakeComm	(0X1E4C,	"[di+BDS.secpertrack]");
	MakeComm	(0X1E4F,	"save partition number");
	MakeComm	(0X1E53,	"restore partition number");
	MakeComm	(0X1E56,	"1C2h+bootbias");
	MakeComm	(0X1E59,	"is the partition active?");
	MakeCode	(x=0X1E59);
	OpHex		(x,	1);
	MakeComm	(0X1E5E,	"no");
	MakeComm	(0X1E60,	"reject if partitiontype != 1, 4 or 6");
	MakeComm	(0X1E72,	"is this our target partition #?");
	MakeComm	(0X1E74,	"WE GOT THE ONE WANTED!");
	MakeComm	(0X1E76,	"count down");
	MakeCode	(x=0X1E78);
	OpDecimal	(x,	1);
	MakeComm	(0X1E7B,	"202h+bootbias\nlast entry done?");
	MakeCode	(x=0X1E7B);
	OpHex		(x,	1);
	MakeComm	(0X1E7F,	"no, process next entry");
	MakeComm	(0X1E81,	"1C2h+bootbias\nrestore original value of bx");
	MakeCode	(x=0X1E81);
	OpHex		(x,	1);
	MakeComm	(0X1E84,	"Now scan the non-active partitions");
	MakeCode	(x=0X1E84);
	OpHex		(x,	1);
	MakeComm	(0X1E89,	"we've already scanned the ACTIVE ones");
	MakeComm	(0X1E8B,	"see if partitiontype == 1, 4 or 6");
	MakeComm	(0X1E9D,	"is this our target partition?");
	MakeCode	(x=0X1EA3);
	OpDecimal	(x,	1);
	MakeComm	(0X1EA6,	"202h+bootbias");
	MakeCode	(x=0X1EA6);
	OpHex		(x,	1);
	MakeComm	(0X1EAA,	"loop till we've gone through table");
	MakeComm	(0X1EAC,	"error return");
	MakeComm	(0X1EB0,	"save the rom bios drive number");
	MakeCode	(0X1EB0);
	MakeName	(0X1EB0,	"set2");
	MakeComm	(0X1EB5,	"hidden sectors (start sector)");
	MakeComm	(0X1EBD,	"decrement the sector count by 1 to make it zero based.\nexactly 64k sectors should be allowed");
	MakeComm	(0X1EC3,	"sectors in partition");
	MakeCode	(x=0X1EC7);
	OpDecimal	(x,	1);
	MakeComm	(0X1ECD,	"ftoobig");
	MakeCode	(x=0X1ECD);
	OpHex		(x,	1);
	MakeComm	(0X1ED6,	"[di+BDS.hiddensecs]\nBPB_HIDDENSECTORS = p->partitionbegin");
	MakeCode	(x=0X1ED6);
	OpDecimal	(x,	0);
	MakeComm	(0X1EDD,	"[di+BDS.hiddensecs+2]");
	MakeCode	(x=0X1EDD);
	OpDecimal	(x,	0);
	MakeComm	(0X1EE0,	"# of sectors (high)");
	MakeCode	(x=0X1EE0);
	OpDecimal	(x,	1);
	MakeComm	(0X1EE4,	"# of sectors (low)");
	MakeComm	(0X1EE8,	"[di+BDS.totalsecs32+2]");
	MakeCode	(x=0X1EE8);
	OpDecimal	(x,	0);
	MakeComm	(0X1EEB,	"[di+BDS.totalsecs32]\nbpb->maxsec = p->partitionlength");
	MakeCode	(x=0X1EEB);
	OpDecimal	(x,	0);
	MakeComm	(0X1EF3,	"if (p->partitionlength < 64)");
	MakeCode	(x=0X1EF3);
	OpDecimal	(x,	1);
	MakeComm	(0X1EF6,	"return -1;");
	MakeComm	(0X1EF8,	"[di+BDS.hiddensecs+2]");
	MakeCode	(x=0X1EF8);
	OpDecimal	(x,	1);
	MakeComm	(0X1EFB,	"[di+BDS.hiddensecs]");
	MakeCode	(x=0X1EFB);
	OpDecimal	(x,	1);
	MakeComm	(0X1EFE,	"boot sector number - for mini disk\nusually equal to the # of sec/trk.");
	MakeComm	(0X1F00,	"[di+BDS.secpertrack]");
	MakeCode	(x=0X1F00);
	OpDecimal	(x,	1);
	MakeComm	(0X1F0F,	"(sectors)dx:ax / (BDS.secpertrack)bx =\n(track)temp_h:ax + (sector)dx");
	MakeComm	(0X1F17,	"[di+BDS.heads]");
	MakeCode	(x=0X1F17);
	OpDecimal	(x,	1);
	MakeComm	(0X1F21,	"dl is head, ax is cylinder");
	MakeComm	(0X1F30,	"exceeds the limit of int 13h");
	MakeCode	(x=0X1F32);
	OpDecimal	(x,	1);
	MakeComm	(0X1F35,	"exceeds the limit of int 13h\nRetro DOS v3.2 note by Erdogan Tan - 28/07/2019\n**MSDOS code accepts if ax = 1024 but it is nonsense here\n('ja' must be 'jnb')");
	MakeComm	(0X1F37,	"[di+BDS.bdsm_ismini]\ncheck for mini disk");
	MakeCode	(x=0X1F37);
	OpDecimal	(x,	0);
	MakeComm	(0X1F3B,	"not mini disk.");
	MakeComm	(0X1F3D,	"[di+BDS.bdsm_hidden_trks]\nset the physical track number");
	MakeCode	(x=0X1F3D);
	OpDecimal	(x,	1);
	MakeComm	(0X1F40,	"move high two bits of cyl to high");
	MakeCode	(x=0X1F40);
	OpHex		(x,	1);
	MakeComm	(0X1F42,	"two bits of upper byte");
	MakeCode	(x=0X1F42);
	OpHex		(x,	1);
	MakeComm	(0X1F44,	"turn off remainder of bits");
	MakeCode	(x=0X1F44);
	OpHex		(x,	1);
	MakeComm	(0X1F47,	"move two bits to correct spot");
	MakeComm	(0X1F49,	"ch is cylinder (low 8 bits)\ncl is sector + 2 high bits of cylinder");
	MakeComm	(0X1F4B,	"dh is head");
	MakeComm	(0X1F4D,	"dl is drive number");
	MakeCode	(x=0X1F54);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X1F57);
	OpHex		(x,	1);
	MakeComm	(0X1F5A,	"DISK - READ SECTORS INTO MEMORY\nAL = number of sectors to read, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer to fill\nReturn: CF set on error, AH = status, AL = number of sectors read");
	MakeCode	(x=0X1F5A);
	OpHex		(x,	0);
	MakeCode	(x=0X1F5C);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X1F61,	"is it a near jump?");
	MakeCode	(x=0X1F61);
	OpHex		(x,	1);
	MakeComm	(0X1F65,	"yes");
	MakeComm	(0X1F67,	"is it a short jump?");
	MakeCode	(x=0X1F67);
	OpHex		(x,	1);
	MakeComm	(0X1F6B,	"no");
	MakeComm	(0X1F6D,	"yes, is the next one a nop?");
	MakeCode	(x=0X1F6D);
	OpHex		(x,	1);
	MakeComm	(0X1F74,	"disksector+EXT_BOOT.BPB\npoint to the bpb in the boot record");
	MakeComm	(0X1F77,	"[bx+EBPB.MEDIADESCRIPTOR]\nget the mediadescriptor byte");
	MakeCode	(x=0X1F77);
	OpDecimal	(x,	1);
	MakeComm	(0X1F7B,	"mask off low nibble");
	MakeCode	(x=0X1F7B);
	OpHex		(x,	1);
	MakeComm	(0X1F7D,	"is high nibble = 0Fh?");
	MakeComm	(0X1F7F,	"no, invalid boot record");
	MakeComm	(0X1F81,	"[bx+EBPB.BYTESPERSECTOR]");
	MakeCode	(x=0X1F81);
	OpDecimal	(x,	1);
	MakeComm	(0X1F86,	"invalidate non 512 byte sectors");
	MakeComm	(0X1F88,	"yes, mediadescriptor ok.\nnow make sure that the sectorspercluster is a power of 2\n[bx+EBPB.SECTORSPERCLUSTER]\nget the sectorspercluster");
	MakeName	(0X1F88,	"check_2_ok");
	MakeComm	(0X1F8C,	"is it zero?");
	MakeComm	(0X1F8E,	"yes, invalid boot record");
	MakeComm	(0X1F90,	"shift until first bit emerges");
	MakeCode	(x=0X1F90);
	OpHex		(x,	1);
	MakeComm	(0X1F98,	"jump to invalid boot record\nunformatted or illegal media.");
	MakeCode	(0X1F9B);
	MakeComm	(0X1F9C,	"Signature found. Now check version.");
	MakeComm	(0X1F9D,	"'2.' (NASM syntax)");
	MakeCode	(x=0X1F9D);
	OpChr		(x,	1);
	MakeCode	(x=0X1FA5);
	OpDecimal	(x,	0);
	OpChr		(x,	1);
	MakeCode	(0X1FAE);
	MakeComm	(0X1FB1,	"legally formatted media,\nalthough, content might be bad.");
	MakeCode	(0X1FB1);
	MakeCode	(0X1FB4);
	MakeComm	(0X1FB7,	"'0.' (NASM syntax)");
	MakeCode	(x=0X1FB7);
	OpChr		(x,	1);
	MakeCode	(x=0X1FC3);
	OpChr		(x,	1);
	MakeCode	(x=0X1FC5);
	OpHex		(x,	1);
	MakeComm	(0X1FC7,	"accept either '1' or '2'");
	MakeComm	(0X1FCC,	"'3.' (NASM syntax)");
	MakeCode	(x=0X1FCC);
	OpChr		(x,	1);
	MakeComm	(0X1FD2,	"must be 2.1 boot record.\ndo not trust it, but still legal.");
	MakeComm	(0X1FD4,	"honor os2 boot record or dos 4.0 version");
	MakeComm	(0X1FD6,	"if version >= 3.1, then o.k.");
	MakeCode	(x=0X1FD6);
	OpDecimal	(x,	0);
	OpChr		(x,	1);
	MakeComm	(0X1FDD,	"[disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE");
	MakeCode	(x=0X1FDD);
	OpHex		(x,	1);
	MakeComm	(0X1FE3,	"conventional fat system");
	MakeComm	(0X1FEB,	"a fat system.");
	MakeComm	(0X1FED,	"non fat based media.");
	MakeComm	(0X1FF3,	"disksector+EXT_BOOT.BPB");
	MakeCode	(x=0X1FF3);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X1FF6,	"add di,BDS.BPB");
	MakeComm	(0X1FF9,	"[cs:si+EBPB.TOTALSECTORS]");
	MakeComm	(0X2000,	"[cs:si+EBPB.BIGTOTALSECTORS]");
	MakeCode	(x=0X2000);
	OpDecimal	(x,	0);
	MakeComm	(0X2007,	"[cs:si+EBPB.BIGTOTALSECTORS+2]");
	MakeCode	(x=0X2007);
	OpDecimal	(x,	0);
	MakeComm	(0X200E,	"[di+BDS.totalsecs16]");
	MakeComm	(0X2011,	"[cs:si+EBPB.TOTALSECTORS]");
	MakeComm	(0X2015,	"[di+BDS.totalsecs32]");
	MakeCode	(x=0X2015);
	OpDecimal	(x,	1);
	MakeComm	(0X2018,	"[cs:si+EBPB.BIGTOTALSECTORS]");
	MakeCode	(x=0X2018);
	OpDecimal	(x,	0);
	MakeComm	(0X201C,	"[di+BDS.totalsecs32+2]");
	MakeCode	(x=0X201C);
	OpDecimal	(x,	1);
	MakeComm	(0X201F,	"[cs:si+EBPB.BIGTOTALSECTORS+2]");
	MakeCode	(x=0X201F);
	OpDecimal	(x,	0);
	MakeComm	(0X2023,	"A_BPB.size - 6 ; Use SMALL version!");
	MakeCode	(x=0X2023);
	OpDecimal	(x,	1);
	MakeCode	(x=0X202F);
	OpOff		(x,	1,	0X25C0);
	OpOff		(x,	129,	0X25C0);
	MakeComm	(0X2032,	"simulate far call");
	MakeComm	(0X203C,	"disksector+EXT_BOOT.BPB\ncs:si -> bpb in boot");
	MakeCode	(x=0X203C);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2041,	"[cs:si+EBPB.TOTALSECTORS]\nget totsec from boot sec");
	MakeComm	(0X2047,	"if non zero, use that");
	MakeComm	(0X2049,	"[cs:si+EBPB.BIGTOTALSECTORS]\nget the big version (32 bit total sectors)");
	MakeCode	(x=0X2049);
	OpDecimal	(x,	1);
	MakeComm	(0X204D,	"[cs:si+EBPB.BIGTOTALSECTORS+2]");
	MakeCode	(x=0X204D);
	OpDecimal	(x,	1);
	MakeComm	(0X2051,	"see if it is a big zero\n10/12/2022\nmov bx,ax\nor bx,ax");
	MakeComm	(0X2057,	"[di+BDS.totalsecs32]\nmake DPB match boot sec");
	MakeCode	(x=0X2057);
	OpDecimal	(x,	0);
	MakeComm	(0X205A,	"[di+BDS.totalsecs32+2]");
	MakeCode	(x=0X205A);
	OpDecimal	(x,	0);
	MakeComm	(0X205D,	"[di+BDS.totalsecs32]");
	MakeCode	(x=0X205D);
	OpDecimal	(x,	1);
	MakeComm	(0X2060,	"[di+BDS.totalsecs32+2]");
	MakeCode	(x=0X2060);
	OpDecimal	(x,	1);
	MakeComm	(0X2063,	"[cs:si+EBPB.RESERVEDSECTORS]\nget #reserved_sectors from BPB");
	MakeComm	(0X2067,	"[di+BDS.resectors] ; update BDS field");
	MakeComm	(0X206C,	"update the count");
	MakeComm	(0X206F,	"[cs:si+EBPB.SECTORSPERFAT] ; bx = sectors/fat");
	MakeCode	(x=0X206F);
	OpDecimal	(x,	1);
	MakeComm	(0X2073,	"[di+BDS.fatsecs] ; set in bds bpb");
	MakeCode	(x=0X2073);
	OpDecimal	(x,	0);
	MakeComm	(0X2076,	"always 2 fats (may be 1 fat!?)\n10/12/2022\n(number of FATs optimization)\nCL = number of FATs (2 or 1) \ndec cx\nshl bx, cl");
	MakeCode	(x=0X2076);
	OpHex		(x,	1);
	MakeComm	(0X2078,	"sub # fat sectors");
	MakeComm	(0X207D,	"[cs:si+EBPB.ROOTENTRIES]\n# root entries");
	MakeComm	(0X2081,	"[di+BDS.direntries]\nset in bds bpb");
	MakeCode	(x=0X2081);
	OpDecimal	(x,	0);
	MakeComm	(0X2086,	"div by 16 ents/sector");
	MakeComm	(0X2088,	"sub # dir sectors");
	MakeComm	(0X208A,	"dx:ax now contains the # of data sectors");
	MakeComm	(0X208F,	"[cs:si+EBPB.SECTORSPERCLUSTER]\nsectors per cluster");
	MakeComm	(0X2093,	"[di+BDS.secperclus]\nset in bios bpb");
	MakeComm	(0X209B,	"cx = sectors per cluster");
	MakeComm	(0X209D,	"[temp_h]:ax now contains the # clusters.");
	MakeComm	(0X20AA,	"too big cluster number");
	MakeComm	(0X20AC,	"4096-10\nis this 16-bit fat?");
	MakeCode	(x=0X20AC);
	OpHex		(x,	1);
	MakeComm	(0X20AF,	"no, small fat");
	MakeComm	(0X20B1,	"fbig ; 16 bit fat");
	MakeCode	(x=0X20B1);
	OpHex		(x,	1);
	MakeCode	(x=0X20BB);
	OpOff		(x,	1,	0X25C0);
	OpOff		(x,	129,	0X25C0);
	MakeComm	(0X20BE,	"simulate far call");
	MakeComm	(0X20C5,	"now final check for bpb info and return.");
	MakeCode	(x=0X20C8);
	OpHex		(x,	1);
	MakeName	(0X20C8,	"toobig_ret");
	MakeComm	(0X20CE,	"still drive letter is   assigned but useless.\nto big for current pc dos fat file system");
	MakeComm	(0X20D1,	"unformatted_media\nSet unformatted media flag.");
	MakeCode	(x=0X20D1);
	OpDecimal	(x,	0);
	OpHex		(x,	1);
	MakeComm	(0X20D6,	"skip setting unformatted_media bit\n[di+BDS.totalsecs32+2]");
	MakeCode	(x=0X20D6);
	OpDecimal	(x,	1);
	MakeComm	(0X20D9,	"[di+BDS.totalsecs32]");
	MakeCode	(x=0X20D9);
	OpDecimal	(x,	1);
	MakeCode	(x=0X20DC);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X20DF,	"scan");
	MakeComm	(0X20EC,	"5*2");
	MakeCode	(x=0X20EC);
	OpDecimal	(x,	1);
	MakeComm	(0X20EF,	"covers upto 512 mb media");
	MakeComm	(0X20F1,	"fat size for fbigfat flag");
	MakeCode	(0X20F1);
	MakeName	(0X20F1,	"gotparm");
	MakeComm	(0X20F8,	"ch = number of sectors per cluster\ncl = log base 2 of ch");
	MakeComm	(0X20FC,	"dx = number of root dir entries");
	MakeComm	(0X2100,	"[di+BDS.direntries]\nsave number of (root) dir entries");
	MakeCode	(x=0X2100);
	OpDecimal	(x,	0);
	MakeComm	(0X2103,	"[di+BDS.totalsecs32+2]");
	MakeCode	(x=0X2103);
	OpDecimal	(x,	1);
	MakeComm	(0X2106,	"[di+BDS.totalsecs32]");
	MakeCode	(x=0X2106);
	OpDecimal	(x,	1);
	MakeComm	(0X2109,	"[di+BDS.secperclus]\nsave sectors per cluster");
	MakeComm	(0X210C,	"fbig\nif (fbigfat)");
	MakeCode	(x=0X210C);
	OpHex		(x,	1);
	MakeComm	(0X2111,	"go to dobig (16 bit fat)");
	MakeComm	(0X2113,	"(12 bit fat)");
	MakeComm	(0X2118,	"dx=0");
	MakeComm	(0X211A,	"bx = 1+(bpb->maxsec+BDS.secperclus-1)/");
	MakeComm	(0X211C,	"BDS.secperclus");
	MakeComm	(0X211D,	"bx &= ~1; (=number of clusters)");
	MakeCode	(x=0X211D);
	OpHex		(x,	1);
	MakeCode	(x=0X2122);
	OpHex		(x,	1);
	MakeComm	(0X2126,	"bx += 511 + bx/2");
	MakeCode	(x=0X2126);
	OpDecimal	(x,	1);
	MakeComm	(0X212A,	"bh >>= 1; (=bx/512)");
	MakeCode	(x=0X212A);
	OpHex		(x,	1);
	MakeComm	(0X212C,	"[di+BDS.fatsecs]\nsave number of fat sectors");
	MakeCode	(x=0X212C);
	OpDecimal	(x,	0);
	MakeComm	(0X2131,	"16 (2^4) directory entries per sector");
	MakeCode	(0X2131);
	MakeName	(0X2131,	"dobig");
	MakeComm	(0X2133,	"save total sectors (high)");
	MakeComm	(0X2134,	"[di+BDS.direntries]");
	MakeCode	(x=0X2134);
	OpDecimal	(x,	1);
	MakeComm	(0X2137,	"root dir sectors = BDS.direntries / 16;");
	MakeComm	(0X213C,	"dx:ax = total sectors - root dir sectors");
	MakeComm	(0X2142,	"dx:ax = t - r - d\ntotal secs - reserved secs - root dir secs");
	MakeComm	(0X2147,	"[di+BDS.secperclus]\nbx = 256 * BDS.secperclus + 2");
	MakeComm	(0X214A,	"ax = t-r-d+256*spc+2");
	MakeComm	(0X214F,	"ax = t-r-d+256*spc+1");
	MakeComm	(0X2155,	"BDS.fatsecs =\nceil((total-dir-res)/(256*BDS.secperclus+2))");
	MakeComm	(0X2157,	"[di+BDS.fatsecs]\nnumber of fat sectors");
	MakeCode	(x=0X2157);
	OpDecimal	(x,	0);
	MakeComm	(0X215E,	"[di+BDS.fatsiz] ; fat size flag");
	MakeCode	(x=0X215E);
	OpDecimal	(x,	0);
	MakeCode	(x=0X2166);
	OpOff		(x,	1,	0X25C0);
	OpOff		(x,	129,	0X25C0);
	MakeComm	(0X216E,	"[di+BDS.totalsecs32+2]");
	MakeCode	(x=0X216E);
	OpDecimal	(x,	1);
	MakeComm	(0X2171,	"[di+BDS.totalsecs32]");
	MakeCode	(x=0X2171);
	OpDecimal	(x,	1);
	MakeComm	(0X2174,	"double word total sectors?");
	MakeComm	(0X2177,	"don't have to change it.");
	MakeComm	(0X2179,	"[di+BDS.hiddensecs+2]");
	MakeCode	(x=0X2179);
	OpDecimal	(x,	0);
	MakeComm	(0X217D,	"don't have to change it.");
	MakeComm	(0X217F,	"[di+BDS.hiddensecs]");
	MakeCode	(x=0X217F);
	OpDecimal	(x,	1);
	MakeComm	(0X2184,	"[di+BDS.totalsecs32]");
	MakeCode	(x=0X2184);
	OpDecimal	(x,	1);
	MakeComm	(0X2187,	"[di+BDS.totalsecs16]");
	MakeCode	(x=0X2187);
	OpDecimal	(x,	0);
	MakeComm	(0X218A,	"[di+BDS.totalsecs32]");
	MakeCode	(x=0X218A);
	OpDecimal	(x,	0);
	MakeName	(0X218F,	"goodret");
	MakeComm	(0X2193,	"[di+BDS.fatsiz]\nset size of fat on media");
	MakeCode	(x=0X2193);
	OpDecimal	(x,	0);
	MakeCode	(0X219C);
	MakeName	(0X219C,	"cover_fdisk_bug");
	MakeComm	(0X219F,	"disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE");
	MakeCode	(x=0X219F);
	OpHex		(x,	1);
	MakeComm	(0X21A5,	"if extended bpb, then >= pc dos 4.00");
	MakeComm	(0X21A7,	"'10' (NASM syntax) ; os2 1.0 = ibm 10.0");
	MakeCode	(x=0X21A7);
	OpChr		(x,	1);
	MakeCode	(x=0X21AF);
	OpChr		(x,	1);
	MakeComm	(0X21B6,	"disksector+EXT_BOOT.BPB");
	MakeCode	(x=0X21B6);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X21B9,	"[cs:si+EBPB.TOTALSECTORS]\njust to make sure.");
	MakeComm	(0X21C0,	"[cs:si+EBPB.TOTALSECTORS]");
	MakeComm	(0X21C4,	"[cs:si+EBPB.HIDDENSECTORS]");
	MakeComm	(0X21CA,	"\nif carry set and ax=0");
	MakeComm	(0X21CC,	"0 -> 0FFFFh\ndecrease BPB_TOTALSECTORS by 1");
	MakeComm	(0X21D0,	"[di+BDS.totalsecs32]");
	MakeComm	(0X21D4,	"[di+BDS.totalsecs32+2]");
	MakeWord	(0X21DC);
	MakeName	(0X21DC,	"word2");
	MakeWord	(0X21DE);
	MakeName	(0X21DE,	"word3");
	MakeWord	(x=0X21E0);
	OpDecimal	(x,	0);
	MakeName	(0X21E0,	"word512");
	MakeCode	(0X21E2);
	MakeName	(0X21E2,	"setdrvparms");
	MakeComm	(0X21E4,	"get first bds in list");
	MakeComm	(0X21EA,	"[es:di+BDS.formfactor]");
	MakeCode	(x=0X21EA);
	OpDecimal	(x,	1);
	MakeComm	(0X21EE,	"ffHardFile");
	MakeComm	(0X21F5,	"[es:di+BDS.totalsecs16]");
	MakeCode	(x=0X21F5);
	OpDecimal	(x,	1);
	MakeComm	(0X21FD,	"[es:di+BDS.totalsecs32+2]");
	MakeCode	(x=0X21FD);
	OpDecimal	(x,	1);
	MakeComm	(0X2201,	"[es:di+BDS.totalsecs32]");
	MakeCode	(x=0X2201);
	OpDecimal	(x,	1);
	MakeComm	(0X2207,	"[es:di+BDS.heads]");
	MakeCode	(x=0X2207);
	OpDecimal	(x,	1);
	MakeComm	(0X220B,	"[es:di+BDS.secpertrack]\nassume sectors per cyl. < 64k.");
	MakeCode	(x=0X220B);
	OpDecimal	(x,	1);
	MakeComm	(0X220F,	"cx has # sectors per cylinder");
	MakeComm	(0X2212,	"dx:ax = total sectors");
	MakeComm	(0X221F,	"div #sec by sec/cyl to get # cyl.");
	MakeComm	(0X2223,	"came out even");
	MakeComm	(0X2225,	"round up");
	MakeComm	(0X2226,	"[es:di+BDS.cylinders]");
	MakeCode	(x=0X2226);
	OpDecimal	(x,	0);
	MakeComm	(0X222C,	"[di+BDS.bytespersec]\nds:si -> bpb for hard file");
	MakeCode	(0X2231);
	MakeComm	(0X223B,	"ffother\nspecial case \"other\" type of medium");
	MakeName	(0X2240,	"process_other");
	MakeComm	(0X2242,	"[di+BDS.cylinders]");
	MakeCode	(x=0X2242);
	OpDecimal	(x,	1);
	MakeComm	(0X2245,	"[di+BDS.rheads]");
	MakeCode	(x=0X2245);
	OpDecimal	(x,	1);
	MakeComm	(0X2248,	"[di+BDS.rsecpertrack]");
	MakeCode	(x=0X2248);
	OpDecimal	(x,	1);
	MakeComm	(0X224B,	"[di+BDS.rtotalsecs16]\nhave the total number of sectors");
	MakeCode	(x=0X224B);
	OpDecimal	(x,	0);
	MakeComm	(0X2251,	"4096-10");
	MakeCode	(x=0X2251);
	OpHex		(x,	1);
	MakeCode	(x=0X2256);
	OpHex		(x,	1);
	MakeCode	(x=0X2258);
	OpHex		(x,	1);
	MakeComm	(0X225C,	"is it a small disk ?");
	MakeCode	(0X225C);
	MakeName	(0X225C,	"_@@");
	MakeComm	(0X225F,	"yes, 224 root entries is enuf");
	MakeComm	(0X2261,	"[di+BDS.rdirentries]");
	MakeCode	(x=0X2261);
	OpDecimal	(x,	0);
	OpDecimal	(x,	1);
	MakeComm	(0X2266,	"[di+BDS.rsecperclus]");
	MakeCode	(x=0X2266);
	OpDecimal	(x,	0);
	MakeComm	(0X2269,	"* 3");
	MakeComm	(0X226E,	"/ 2");
	MakeComm	(0X2275,	"/ 512");
	MakeComm	(0X227A,	"+ 1");
	MakeComm	(0X227B,	"[di+BDS.rfatsecs]");
	MakeCode	(x=0X227B);
	OpDecimal	(x,	0);
	MakeName	(0X227B,	"no_round_up");
	MakeComm	(0X2280,	"bx is word index into table of bpbs");
	MakeCode	(x=0X2280);
	OpHex		(x,	1);
	MakeCode	(x=0X2282);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2285,	"get address of bpb");
	MakeComm	(0X2287,	"[di+BDS.R_BPB]\nes:di -> recbpb");
	MakeCode	(x=0X2287);
	OpDecimal	(x,	1);
	MakeName	(0X2287,	"set_recbpb");
	MakeComm	(0X228A,	"bpbx.size");
	MakeCode	(x=0X228A);
	OpDecimal	(x,	1);
	MakeComm	(0X228D,	"move (size bpbx) bytes");
	MakeComm	(0X2290,	"restore pointer to bds");
	MakeComm	(0X2291,	"[es:di+BDS.link]");
	MakeComm	(0X2294,	"-1");
	MakeCode	(x=0X2294);
	OpSign		(x,	1);
	OpDecimal	(x,	1);
	MakeCode	(0X229C);
	MakeCode	(0X229D);
	MakeName	(0X229D,	"print_init");
	MakeComm	(0X229E,	"AL = device number");
	MakeComm	(0X22A2,	"PRINTER - INITIALIZE\nDX = printer port (0-3)\nReturn: AH = status");
	MakeCode	(x=0X22A2);
	OpHex		(x,	0);
	MakeCode	(0X22A5);
	MakeName	(0X22A5,	"aux_init");
	MakeComm	(0X22A8,	"RSINIT ; 2400,n,1,8 (msequ.inc)");
	MakeCode	(x=0X22A8);
	OpHex		(x,	1);
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_1(void) {
        auto x;
#define id x

	MakeComm	(0X22AC,	"SERIAL I/O - INITIALIZE USART\nAL = initializing parameters, DX = port number (0-3)\nReturn: AH = RS-232 status code bits, AL = modem status bits");
	MakeCode	(x=0X22AC);
	OpHex		(x,	0);
	MakeComm	(0X22AF,	"get number of hardfiles");
	MakeCode	(0X22AF);
	MakeName	(0X22AF,	"domini");
	MakeComm	(0X22B6,	"no hard file? then exit.");
	MakeComm	(0X22B8,	"start with hardfile 80h");
	MakeCode	(x=0X22B8);
	OpHex		(x,	1);
	MakeName	(0X22BA,	"domini_loop");
	MakeComm	(0X22C1,	"DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)\nDL = drive number\nReturn: CF set on error, AH = status code, BL = drive type\nDL = number of consecutive drives\nDH = maximum value for head number, ES:DI -> drive parameter");
	MakeCode	(x=0X22C1);
	OpHex		(x,	0);
	MakeComm	(0X22C9,	"# of heads");
	MakeCode	(x=0X22CC);
	OpHex		(x,	1);
	MakeComm	(0X22D1,	"# of sectors/track");
	MakeComm	(0X22D9,	"read master boot record into\ninitbootsegment:bootbias");
	MakeComm	(0X22E3,	"next hard file");
	MakeName	(0X22E9,	"dominiret");
	MakeComm	(0X22EA,	"bx -> file system id");
	MakeCode	(x=0X22EA);
	OpHex		(x,	1);
	MakeName	(0X22EA,	"find_mini_partition");
	MakeComm	(0X22EE,	"extended partition id. = 5");
	MakeName	(0X22EE,	"fmpnext");
	MakeCode	(x=0X22F4);
	OpDecimal	(x,	1);
	MakeComm	(0X22F7,	"202h+bootbias");
	MakeCode	(x=0X22F7);
	OpHex		(x,	1);
	MakeComm	(0X22FD,	"extended partition not found");
	MakeComm	(0X22FF,	"found my partition.             \ncheck for drvmax already 26");
	MakeCode	(0X22FF);
	MakeComm	(0X2302,	"done if too many");
	MakeComm	(0X2304,	"get next free bds");
	MakeComm	(0X2308,	"[di+BDS.bdsm_ismini]");
	MakeCode	(x=0X2308);
	OpDecimal	(x,	0);
	MakeComm	(0X230D,	"or byte [di+BDS.flags],fNon_Removable");
	MakeCode	(x=0X230D);
	OpDecimal	(x,	0);
	OpHex		(x,	1);
	MakeComm	(0X2311,	"mov byte [di+BDS.formfactor],ffHardFile");
	MakeCode	(x=0X2311);
	OpDecimal	(x,	0);
	MakeComm	(0X2315,	"assume 12 bit fat.");
	MakeComm	(0X231D,	"[di+BDS.heads]");
	MakeComm	(0X2323,	"[di+BDS.secpertrack]");
	MakeComm	(0X2329,	"[di+BDS.drivenum]\nset physical number");
	MakeComm	(0X232F,	"[di+BDS.drivelet]\nset logical number");
	MakeCode	(x=0X2332);
	OpDecimal	(x,	0);
	MakeComm	(0X2339,	"with current bpb,\nonly lower word is meaningful.");
	MakeCode	(x=0X2339);
	OpDecimal	(x,	1);
	MakeComm	(0X233E,	"should be bigger than 64 sectors at least");
	MakeComm	(0X2340,	"let bx point to the start of the entry");
	MakeComm	(0X2343,	"cylinder");
	MakeComm	(0X2347,	"get higher bits of cyl");
	MakeCode	(x=0X2347);
	OpHex		(x,	1);
	MakeCode	(x=0X234A);
	OpHex		(x,	1);
	MakeCode	(x=0X234C);
	OpHex		(x,	1);
	MakeComm	(0X234E,	"cyl byte");
	MakeComm	(0X2352,	"[di+BDS.bdsm_hidden_trks]\nset hidden trks");
	MakeCode	(x=0X2352);
	OpDecimal	(x,	0);
	MakeComm	(0X2355,	"cylinder,cylinder/sector");
	MakeComm	(0X2359,	"head");
	MakeComm	(0X2361,	"bootbias");
	MakeCode	(x=0X2361);
	OpHex		(x,	1);
	MakeComm	(0X2367,	"DISK - READ SECTORS INTO MEMORY\nAL = number of sectors to read, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer to fill\nReturn: CF set on error, AH = status, AL = number of sectors read");
	MakeCode	(x=0X2367);
	OpHex		(x,	0);
	MakeComm	(0X236B,	"1C2h+bootbias");
	MakeComm	(0X236F,	"install a mini disk.\nbx value saved.");
	MakeComm	(0X2375,	"-- install the bdsm into table");
	MakeComm	(0X2378,	"let's find out if we have any chained partition");
	MakeCode	(0X237B);
	MakeCode	(0X237C);
	MakeName	(0X237C,	"setmini");
	MakeComm	(0X2380,	"FAT12 partition");
	MakeComm	(0X2386,	"FAT16 partition");
	MakeComm	(0X238C,	"FAT16 BIG partition");
	MakeCode	(x=0X2392);
	OpDecimal	(x,	1);
	MakeComm	(0X2395,	"202h+bootbias");
	MakeCode	(x=0X2395);
	OpHex		(x,	1);
	MakeCode	(0X23A1);
	MakeComm	(0X23A4,	"checks for drvmax < 26");
	MakeCode	(x=0X23A4);
	OpDecimal	(x,	1);
	MakeName	(0X23A4,	"dmax_check");
	MakeComm	(0X23A9,	"return with carry if okay");
	MakeComm	(0X23AC,	"SYSINIT segment (SYSINITSEG)");
	MakeCode	(x=0X23AC);
	OpHex		(x,	1);
	MakeComm	(0X23B1,	"SYSINITSEG:TOOMANYDRIVESFLAG");
	MakeCode	(x=0X23B1);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X23B8,	"cf = 0 -> error (too many drives), cf = 1 -> ok");
	MakeCode	(0X23B9);
	MakeName	(0X23B9,	"xinstall_bds");
	MakeComm	(0X23BB,	"get first bds");
	MakeComm	(0X23BF,	"-1 ; is this the last one?");
	MakeCode	(x=0X23BF);
	OpHex		(x,	1);
	MakeComm	(0X23C2,	"skip ahead if so");
	MakeComm	(0X23C4,	"[si+BDS.link] ; chain through list");
	MakeComm	(0X23C8,	"[si+BDS.link]");
	MakeCode	(0X23C8);
	MakeComm	(0X23CA,	"[si+BDS.link+2]");
	MakeComm	(0X23CD,	"[di+BDS.link],-1\nmake sure it is a null ptr.");
	MakeComm	(0X23D1,	"might as well plug segment");
	MakeComm	(0X23E6,	"BDS.size = 100");
	MakeCode	(x=0X23E6);
	OpDecimal	(x,	1);
	MakeCode	(0X23EE);
	MakeName	(0X23EE,	"cmos_clock_read");
	MakeComm	(0X23FA,	"CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)\nReturn: CH = hours in BCD\nCL = minutes in BCD\nDH = seconds in BCD");
	MakeCode	(x=0X23FA);
	OpHex		(x,	0);
	MakeComm	(0X2406,	"read again after a slight delay, in case clock");
	MakeComm	(0X2409,	"was at zero setting.");
	MakeComm	(0X240B,	"only perform delay once.");
	MakeComm	(0X240C,	"16384");
	MakeCode	(x=0X240C);
	OpHex		(x,	1);
	MakeComm	(0X2413,	"set the flag for cmos clock");
	MakeCode	(0X2413);
	MakeComm	(0X2419,	"reset cmos clock rate that may be\npossibly destroyed by cp dos and\npost routine did not restore that.");
	MakeComm	(0X241D,	"read real-time clock for date");
	MakeComm	(0X2421,	"set system date");
	MakeCode	(0X242C);
	MakeName	(0X242C,	"cmosck");
	MakeComm	(0X242D,	"Exit if not an AT model");
	MakeCode	(x=0X242D);
	OpHex		(x,	1);
	MakeComm	(0X2435,	"Is it 06 for the industral AT ?");
	MakeComm	(0X243B,	"Go reset CMOS periodic rate if 06");
	MakeComm	(0X243D,	"Is it 00, 01, 02, or 03 ?");
	MakeComm	(0X2443,	"EXIT if problem fixed by POST  \nAlso,Secondary_model_byte = 0");
	MakeComm	(0X2445,	"cmos_reg_a|nmi\nNMI disabled on return");
	MakeCode	(x=0X2445);
	OpHex		(x,	1);
	MakeComm	(0X2447,	"00100110b ; Set divider & rate selection");
	MakeCode	(x=0X2447);
	OpHex		(x,	1);
	MakeComm	(0X244C,	"cmos_reg_b|nmi\nNMI disabled on return");
	MakeCode	(x=0X244C);
	OpHex		(x,	1);
	MakeComm	(0X2451,	"00000111b ; clear SET,PIE,AIE,UIE,SQWE");
	MakeCode	(x=0X2451);
	OpHex		(x,	1);
	MakeComm	(0X2455,	"cmos_reg_b ; NMI enabled on return");
	MakeCode	(0X245C);
	MakeName	(0X245C,	"cmos_read");
	MakeComm	(0X245F,	"AL = cmos table address to be read");
	MakeCode	(x=0X2460);
	OpHex		(x,	1);
	MakeComm	(0X2462,	"CMOS Memory/RTC Index Register: RTC Seconds");
	MakeCode	(x=0X2462);
	OpHex		(x,	0);
	MakeComm	(0X2464,	"(undocumented delay needed)");
	MakeComm	(0X2465,	"CMOS Memory/RTC Data Register");
	MakeCode	(x=0X2465);
	OpHex		(x,	1);
	MakeCode	(x=0X246A);
	OpHex		(x,	1);
	MakeCode	(x=0X246C);
	OpHex		(x,	1);
	MakeComm	(0X246E,	"CMOS Memory/RTC Index Register: RTC Seconds");
	MakeCode	(x=0X246E);
	OpHex		(x,	0);
	MakeComm	(0X2471,	"CMOS Memory/RTC Data Register");
	MakeCode	(x=0X2471);
	OpHex		(x,	1);
	MakeComm	(0X2476,	"*place code segment in stack and\n*handle popf for b- level 80286");
	MakeComm	(0X247A,	"return with flags restored");
	MakeComm	(0X247B,	"popf for level b- parts\nreturn far and restore flags");
	MakeCode	(0X247B);
	MakeName	(0X247B,	"cmod_popf");
	MakeComm	(0X247C,	"write (ah) to location (al)");
	MakeCode	(0X247C);
	MakeName	(0X247C,	"cmos_write");
	MakeComm	(0X247F,	"save user nmi state");
	MakeComm	(0X2480,	"disable nmi for us");
	MakeCode	(x=0X2480);
	OpHex		(x,	1);
	MakeComm	(0X2482,	"CMOS Memory/RTC Index Register: RTC Seconds");
	MakeCode	(x=0X2482);
	OpHex		(x,	0);
	MakeComm	(0X2487,	"CMOS Memory/RTC Data Register");
	MakeCode	(x=0X2487);
	OpHex		(x,	0);
	MakeComm	(0X2489,	"get user nmi");
	MakeCode	(x=0X248A);
	OpHex		(x,	1);
	MakeCode	(x=0X248C);
	OpHex		(x,	1);
	MakeComm	(0X248E,	"CMOS Memory/RTC Index Register: RTC Seconds");
	MakeCode	(x=0X248E);
	OpHex		(x,	0);
	MakeComm	(0X2491,	"CMOS Memory/RTC Data Register");
	MakeCode	(x=0X2491);
	OpHex		(x,	1);
	MakeComm	(0X2494,	"*place code segment in stack and");
	MakeComm	(0X2495,	"*handle popf for b- level 80286");
	MakeComm	(0X2499,	"bx = cluster to read\ncx = sectors per cluster\nes:di = load location");
	MakeCode	(0X2499);
	MakeName	(0X2499,	"getclus");
	MakeComm	(0X24A4,	"convert to logical sector\ndx:ax = matching logical sector number\nstarting from the data sector");
	MakeComm	(0X24AB,	"dx:ax = first logical sector to read");
	MakeComm	(0X24BA,	"next cluster");
	MakeComm	(0X24BC,	"fbig\n16 bit fat?");
	MakeCode	(x=0X24BC);
	OpHex		(x,	1);
	MakeComm	(0X24C2,	"yes");
	MakeCode	(x=0X24C4);
	OpHex		(x,	1);
	MakeName	(0X24C4,	"unpack12");
	MakeComm	(0X24C6,	"12 bit fat. si=si/2\nsi = clus + clus/2\n(si = byte offset of the cluster in the FAT)");
	MakeComm	(0X24CF,	"save cluster number into ax");
	MakeComm	(0X24D1,	"if not a splitted fat, check even-odd");
	MakeComm	(0X24D3,	"(not needed!) Erdogan Tan - 2023");
	MakeComm	(0X24D5,	"splitted fat");
	MakeComm	(0X24D9,	"(next byte)");
	MakeCode	(x=0X24E1);
	MakeComm	(0X24EC,	"restore old fat entry value");
	MakeComm	(0X24EE,	"was it even or odd?");
	MakeCode	(x=0X24EE);
	OpHex		(x,	1);
	MakeComm	(0X24F0,	"it was even");
	MakeComm	(0X24F2,	"odd. massage fat value and keep\nthe highest 12 bits.");
	MakeCode	(x=0X24F2);
	OpHex		(x,	1);
	MakeCode	(x=0X24F4);
	OpHex		(x,	1);
	MakeCode	(x=0X24F6);
	OpHex		(x,	1);
	MakeCode	(x=0X24F8);
	OpHex		(x,	1);
	MakeComm	(0X24FA,	"now bx = new fat entry");
	MakeComm	(0X24FC,	"keep low 12 bits");
	MakeCode	(x=0X24FC);
	OpHex		(x,	1);
	MakeCode	(0X2502);
	MakeComm	(0X2503,	"extend to 32 bit offset");
	MakeComm	(0X2505,	"cluster number * 2");
	MakeCode	(x=0X2505);
	OpHex		(x,	1);
	MakeComm	(0X250E,	"bx = new fat entry");
	MakeComm	(0X2513,	"previous - current (or current - new)");
	MakeComm	(0X2515,	"one apart? (current = previous+1)");
	MakeCode	(x=0X2515);
	OpSign		(x,	1);
	OpDecimal	(x,	1);
	MakeComm	(0X251A,	"consequental cluster read, +1 cluster sectors\n(cx = sectors per cluster)");
	MakeCode	(0X2521);
	MakeComm	(0X2522,	"sector to read (high)");
	MakeComm	(0X2523,	"sector to read (low)");
	MakeComm	(0X2524,	"get drive and fat spec");
	MakeComm	(0X252D,	"sector to read for diskrd (low)");
	MakeComm	(0X252E,	"sector to read for diskrd (high)");
	MakeComm	(0X2536,	"simulate far call");
	MakeComm	(0X2537,	"BIOSCODE:8E5h ; 2C7h:8E5h");
	MakeCode	(x=0X2537);
	OpOff		(x,	1,	0X25C0);
	OpOff		(x,	129,	0X25C0);
	MakeComm	(0X2540,	"sector count");
	MakeComm	(0X2546,	"ax = ax * 512 ; byte count");
	MakeCode	(x=0X2546);
	OpHex		(x,	1);
	MakeComm	(0X2548,	"update load location");
	MakeComm	(0X254C,	"dx:si = offset value (starting from fat entry 0)\n        of fat entry to find");
	MakeCode	(0X254C);
	MakeName	(0X254C,	"get_fat_sector");
	MakeComm	(0X2554,	"512");
	MakeComm	(0X255B,	"ax = sector number, dx = offset");
	MakeComm	(0X2562,	"get drive # and FAT id");
	MakeComm	(0X2566,	"BIOSCODE:04D7h");
	MakeCode	(x=0X2566);
	OpOff		(x,	1,	0X25C0);
	OpOff		(x,	129,	0X25C0);
	MakeComm	(0X256A,	"get bds for drive");
	MakeComm	(0X256D,	"(sector number -without reserved and hidden sectors-)");
	MakeComm	(0X256E,	"[es:di+BDS.resectors]\nadd #reserved_sectors");
	MakeComm	(0X257A,	"don't need to read it again");
	MakeComm	(0X257C,	"sector number\n(in the partition, without hidden sectors)");
	MakeComm	(0X2581,	"prepare to read the fat sector\nstart_sec_h is always 0 for fat sector");
	MakeComm	(0X258A,	"1 sector read");
	MakeComm	(0X2593,	"es:di -> fatloc segment:0");
	MakeComm	(0X2598,	"simulate far call");
	MakeComm	(0X2599,	"BIOSCODE:08E5h ; 2C7h:8E5h");
	MakeCode	(x=0X2599);
	OpOff		(x,	1,	0X25C0);
	OpOff		(x,	129,	0X25C0);
	MakeComm	(0X25A1,	"512");
	MakeComm	(0X25A6,	"511");
	MakeComm	(0X25A7,	"if offset points to the last byte of this sector,\nthen splitted entry.");
	MakeComm	(0X25A9,	"offset value from fatloc segment");
	MakeByte	(x=0X25B2);
	MakeArray	(x,	0XE);
	OpDecimal	(x,	0);
	MakeByte	(0X25C0);
	MakeArray	(0X25C0,	0X30);
	MakeName	(0X25C0,	"BCode_start");
	MakeComm	(0X25F0,	"BIOSDATA segment");
	MakeWord	(0X25F0);
	MakeName	(0X25F0,	"Bios_Data_Word");
	MakeCode	(0X25F2);
	MakeName	(0X25F2,	"_seg_reinit");
	MakeComm	(0X25F7,	"(offset cdev+2)");
	MakeCode	(x=0X25F7);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X25FA);
	OpHex		(x,	1);
	MakeComm	(0X25FD,	"ax = new code (BIOSCODE) segment value");
	MakeName	(0X25FD,	"_seg_reinit_1");
	MakeCode	(0X2603);
	MakeName	(0X2603,	"chardev_entry");
	MakeComm	(0X260E,	"get return address (dispatch table)");
	MakeCode	(x=0X260E);
	OpDecimal	(x,	1);
	MakeComm	(0X2611,	"BIOSDATA segment");
	MakeComm	(0X2616,	"get the device number if present");
	MakeCode	(x=0X2616);
	OpHex		(x,	1);
	MakeCode	(x=0X2619);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X261C);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2620,	"point to the device dispatch table");
	MakeComm	(0X2622,	"get pointer to i/o packet");
	MakeCode	(x=0X2622);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2626,	"[es:bx+unit] ; al = unit code");
	MakeCode	(x=0X2626);
	OpHex		(x,	1);
	MakeComm	(0X262A,	"[es:bx+media] ; ah = media descrip");
	MakeCode	(x=0X262A);
	OpDecimal	(x,	1);
	MakeComm	(0X262E,	"[es:bx+count] ; cx = count");
	MakeCode	(x=0X262E);
	OpDecimal	(x,	1);
	MakeComm	(0X2632,	"[es:bx+start] ; dx = start sector");
	MakeCode	(x=0X2632);
	OpDecimal	(x,	1);
	MakeComm	(0X2636,	"BIOSCODE:4A2h");
	MakeCode	(x=0X2636);
	OpOff		(x,	1,	0X25C0);
	OpOff		(x,	129,	0X25C0);
	MakeCode	(x=0X263C);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X2647,	"[es:bx+start_h]\n32 bit dsk req");
	MakeCode	(x=0X2647);
	OpDecimal	(x,	1);
	MakeComm	(0X264B,	"start_sec_h = packet.start_h");
	MakeCode	(x=0X264B);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X264F,	"[es:bx+start_l]\ndx = packet.start_l");
	MakeCode	(x=0X264F);
	OpDecimal	(x,	1);
	MakeName	(0X2653,	"no_sector32_mapping");
	MakeComm	(0X2654,	"[es:bx+cmd]");
	MakeCode	(x=0X2654);
	OpHex		(x,	1);
	MakeComm	(0X265D,	"note that al <= 15 means ok");
	MakeCode	(x=0X265E);
	OpHex		(x,	1);
	MakeComm	(0X2663,	"[es:bx+trans]");
	MakeCode	(x=0X2663);
	OpDecimal	(x,	1);
	MakeCode	(x=0X2668);
	OpHex		(x,	0);
	MakeCode	(x=0X266E);
	OpHex		(x,	1);
	MakeName	(0X2670,	"already_got_ah_status");
	MakeCode	(x=0X2675);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2679,	"[bx+status]\nmark operation complete");
	MakeCode	(x=0X2679);
	OpHex		(x,	0);
	MakeComm	(0X2685,	"get rid of fake return address");
	MakeCode	(x=0X2685);
	OpHex		(x,	1);
	MakeName	(0X2688,	"bc_retf");
	MakeCode	(0X2689);
	MakeName	(0X2689,	"command_error");
	MakeWord	(0X268E);
	MakeComm	(0X2690,	"5 bytes from 0:C0h will be copied onto here\nwhich is the CP/M call 5 entry point");
	MakeByte	(0X2690);
	MakeArray	(0X2690,	0X5);
	MakeName	(0X2690,	"_offset_D0h");
	MakeComm	(0X2695,	"unknown command error");
	MakeCode	(x=0X2695);
	OpHex		(x,	1);
	MakeName	(0X2695,	"bc_cmderr");
	MakeCode	(x=0X2697);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X2697,	"bc_err_cnt");
	MakeCode	(x=0X269B);
	OpDecimal	(x,	0);
	MakeComm	(0X269F,	"mark error return");
	MakeCode	(x=0X269F);
	OpHex		(x,	1);
	MakeComm	(0X26A1,	"indicate abnormal end");
	MakeByte	(0X26A3);
	MakeComm	(0X26A4,	"((con_table_end - con_table)-1)/2 = 11");
	MakeByte	(x=0X26A4);
	OpDecimal	(x,	0);
	MakeName	(0X26A4,	"con_table");
	MakeWord	(x=0X26A5);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26A7);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26A9);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26AB);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26AD);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26AF);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26B1);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26B3);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26B5);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26B7);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26B9);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X26BB,	"((prn_table_end - prn_table)-1)/2 = 26");
	MakeByte	(x=0X26BB);
	OpDecimal	(x,	0);
	MakeName	(0X26BB,	"prn_table");
	MakeWord	(x=0X26BC);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26BE);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26C0);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26C2);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26C4);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26C6);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26C8);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26CA);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26CC);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26CE);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26D0);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26D2);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26D4);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26D6);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26D8);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26DA);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26DC);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26DE);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26E0);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26E2);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26E4);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26E6);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26E8);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26EA);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26EC);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26EE);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X26F0,	"((aux_table_end - aux_table)-1)/2 = 11");
	MakeByte	(x=0X26F0);
	OpDecimal	(x,	0);
	MakeName	(0X26F0,	"aux_table");
	MakeWord	(x=0X26F1);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26F3);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26F5);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26F7);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26F9);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26FB);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26FD);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X26FF);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2701);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2703);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2705);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X2707,	"((tim_table_end - tim_table)-1)/2 = 10");
	MakeByte	(x=0X2707);
	OpDecimal	(x,	0);
	MakeName	(0X2707,	"tim_table");
	MakeWord	(x=0X2708);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X270A);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X270C);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X270E);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2710);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2712);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2714);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2716);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2718);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X271A);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X271C,	"read cx bytes from keyboard into buffer");
	MakeCode	(0X271C);
	MakeName	(0X271C,	"con_read");
	MakeComm	(0X271E,	"get char in al");
	MakeName	(0X271E,	"con_loop");
	MakeComm	(0X2721,	"store char at es:di");
	MakeName	(0X2724,	"con_exit");
	MakeComm	(0X2726,	"set by msinit. 0 or 10h");
	MakeCode	(x=0X2726);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X2726,	"chrin");
	MakeComm	(0X272C,	"get character & zero altah");
	MakeCode	(x=0X272C);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2734,	"KEYBOARD - ");
	MakeCode	(x=0X2734);
	OpHex		(x,	0);
	MakeName	(0X2736,	"alt10");
	MakeComm	(0X273A,	"check for ctrl-prtsc");
	MakeCode	(x=0X273A);
	OpHex		(x,	1);
	MakeCode	(x=0X273F);
	OpHex		(x,	1);
	MakeCode	(x=0X2743);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeName	(0X2743,	"alt_ext_chk");
	MakeCode	(x=0X274A);
	OpHex		(x,	1);
	MakeComm	(0X2756,	"special case?");
	MakeCode	(0X2756);
	MakeComm	(0X275A,	"store special key");
	MakeCode	(x=0X275A);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X275F,	"keyboard non destructive read, no wait");
	MakeCode	(x=0X275F);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X275F,	"con_rdnd");
	MakeCode	(x=0X2766);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X276A,	"KEYBOARD - ");
	MakeCode	(x=0X276A);
	OpHex		(x,	0);
	MakeCode	(x=0X276E);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeCode	(x=0X2775);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2779,	"[es:bx+status]");
	MakeCode	(x=0X2779);
	OpHex		(x,	0);
	OpHex		(x,	1);
	MakeCode	(x=0X2781);
	OpHex		(x,	1);
	MakeComm	(0X2786,	"SYSTEM - WAIT ON EXTERNAL EVENT (CONVERTIBLE)\nAL = condition type, BH = condition compare or mask value\nBL = timeout value times 55 milliseconds, 00h means no timeout\nDX = I/O port address if AL bit 4 set");
	MakeCode	(x=0X2786);
	OpHex		(x,	0);
	MakeName	(0X2788,	"z_bus_exit");
	MakeComm	(0X2789,	"indicate busy status");
	MakeCode	(x=0X2789);
	OpHex		(x,	1);
	MakeCode	(0X278C);
	MakeName	(0X278C,	"gotchr");
	MakeComm	(0X278E,	"check for null after break");
	MakeComm	(0X2790,	"issue keyboard read function");
	MakeCode	(x=0X2790);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2794,	"KEYBOARD - ");
	MakeCode	(x=0X2794);
	OpHex		(x,	0);
	MakeComm	(0X2796,	"get a real status");
	MakeComm	(0X2798,	"check for ctrl-prtsc");
	MakeCode	(x=0X2798);
	OpHex		(x,	1);
	MakeName	(0X2798,	"notbrk");
	MakeComm	(0X279D,	"('P' & 1Fh) ; return control p");
	MakeCode	(x=0X279D);
	OpHex		(x,	1);
	MakeComm	(0X27A1,	"extended keyboard function?");
	MakeCode	(x=0X27A1);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeName	(0X27A1,	"rd_ext_chk");
	MakeComm	(0X27A8,	"extended key value or greek alpha?");
	MakeCode	(x=0X27A8);
	OpHex		(x,	1);
	MakeComm	(0X27AC,	"scan code exist?");
	MakeCode	(x=0X27AC);
	OpHex		(x,	1);
	MakeComm	(0X27AF,	"yes. greek alpha char.");
	MakeComm	(0X27B1,	"no. extended key stroke.\nchange it for compatibility");
	MakeCode	(x=0X27B1);
	OpHex		(x,	1);
	MakeCode	(x=0X27B3);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X27B3,	"rdexit");
	MakeComm	(0X27B7,	"[es:bx+media]\n return keyboard character here");
	MakeCode	(x=0X27B7);
	OpDecimal	(x,	0);
	MakeComm	(0X27BB,	"indicate normal termination");
	MakeName	(0X27BB,	"bc_exvec");
	MakeComm	(0X27BD,	"console write routine");
	MakeCode	(0X27BD);
	MakeName	(0X27BD,	"con_writ");
	MakeName	(0X27BF,	"con_lp");
	MakeComm	(0X27C3,	"DOS 2+ internal - FAST PUTCHAR\nAL = character to display");
	MakeCode	(x=0X27C3);
	OpHex		(x,	0);
	MakeComm	(0X27C9,	"flush out keyboard queue\nclear out holding buffer");
	MakeCode	(x=0X27C9);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeName	(0X27C9,	"con_flush");
	MakeComm	(0X27CE,	"while (charavail()) charread();");
	MakeCode	(x=0X27CE);
	OpHex		(x,	1);
	MakeComm	(0X27D0,	"KEYBOARD - CHECK BUFFER, DO NOT CLEAR\nReturn: ZF clear if character in buffer\nAH = scan code, AL = character\nZF set if no character in buffer");
	MakeCode	(x=0X27D0);
	OpHex		(x,	0);
	MakeComm	(0X27D6,	"KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY\nReturn: AH = scan code, AL = character");
	MakeCode	(x=0X27D6);
	OpHex		(x,	0);
	MakeComm	(0X27DA,	"reset count to zero\n(sub reqpkt.count,cx)");
	MakeCode	(0X27DA);
	MakeName	(0X27DA,	"prn_input");
	MakeComm	(0X27DD,	"but return with carry   reset for no error");
	MakeComm	(0X27DF,	"write cx bytes from es:di to printer device");
	MakeCode	(0X27DF);
	MakeName	(0X27DF,	"prn_writ");
	MakeComm	(0X27E1,	"retry count");
	MakeCode	(x=0X27E1);
	OpHex		(x,	1);
	MakeName	(0X27E1,	"prn_loop");
	MakeComm	(0X27E4,	"get status");
	MakeName	(0X27E4,	"prn_out");
	MakeComm	(0X27E9,	"get character to print");
	MakeComm	(0X27EE,	"print to printer");
	MakeComm	(0X27F1,	"no error - continue");
	MakeComm	(0X27F3,	"MODE_CTRLBRK");
	MakeCode	(x=0X27F3);
	OpHex		(x,	1);
	MakeComm	(0X27F8,	"error_I24_gen_failure");
	MakeCode	(x=0X27F8);
	OpHex		(x,	1);
	MakeCode	(x=0X27FA);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X2801,	"timeoutstatus");
	MakeCode	(x=0X2801);
	OpHex		(x,	1);
	MakeName	(0X2801,	"_prnwf");
	MakeComm	(0X2806,	"retry until count is exhausted");
	MakeName	(0X2806,	"TestPrnError");
	MakeName	(0X2809,	"pmessg");
	MakeComm	(0X280C,	"point to next char and continue");
	MakeCode	(0X280C);
	MakeName	(0X280C,	"prn_con");
	MakeName	(0X280F,	"prn_done");
	MakeComm	(0X2811,	"device in dx");
	MakeCode	(0X2811);
	MakeName	(0X2811,	"prn_stat");
	MakeComm	(0X2816,	"notbusystatus");
	MakeCode	(x=0X2816);
	OpHex		(x,	1);
	MakeComm	(0X281E,	"PRINTER - GET STATUS\nset command for get status\nDX = printer port (0-3)\nReturn: AH = status");
	MakeCode	(x=0X281E);
	OpHex		(x,	1);
	MakeName	(0X281E,	"prnstat");
	MakeComm	(0X2820,	"get printer number");
	MakeCode	(x=0X2820);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X2820,	"prnop");
	MakeComm	(0X2824,	"PRINTER - GET STATUS\nDX = printer port (0-3)\nReturn: AH = status");
	MakeCode	(x=0X2824);
	OpHex		(x,	0);
	MakeCode	(x=0X2827);
	OpHex		(x,	1);
	MakeComm	(0X282A,	"noprinter error");
	MakeCode	(x=0X282A);
	OpHex		(x,	1);
	MakeComm	(0X2830,	"~nopaperstatus");
	MakeCode	(x=0X2830);
	OpHex		(x,	1);
	MakeComm	(0X2833,	"ioerrstatus");
	MakeCode	(x=0X2833);
	OpHex		(x,	1);
	MakeComm	(0X2836,	"(ioerrstatus+nopaperstatus)\ni/o error?");
	MakeCode	(x=0X2836);
	OpHex		(x,	1);
	MakeName	(0X2836,	"NextTest");
	MakeComm	(0X2839,	"no, try not ready");
	MakeComm	(0X283B,	"error_I24_out_of_paper\nfirst, assume out of paper");
	MakeCode	(x=0X283B);
	OpHex		(x,	1);
	MakeComm	(0X283D,	"out of paper set?");
	MakeCode	(x=0X283D);
	OpHex		(x,	1);
	MakeComm	(0X2840,	"yes, error is set");
	MakeComm	(0X2842,	"return al=10 (i/o error)");
	MakeComm	(0X2845,	"assume not-ready");
	MakeCode	(x=0X2845);
	OpHex		(x,	1);
	MakeCode	(x=0X2847);
	OpHex		(x,	1);
	MakeCode	(0X284B);
	MakeName	(0X284B,	"prn_tilbusy");
	MakeName	(0X284D,	"prn_tilbloop");
	MakeCode	(x=0X2851);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X2855);
	OpHex		(x,	1);
	MakeComm	(0X2857,	"wait count times to come ready");
	MakeCode	(x=0X2857);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X285C,	"get status");
	MakeName	(0X285C,	"prn_getstat");
	MakeComm	(0X285F,	"error");
	MakeComm	(0X2861,	"ready yet?");
	MakeCode	(x=0X2861);
	OpHex		(x,	1);
	MakeComm	(0X2864,	"no, go for more");
	MakeComm	(0X2866,	"get original count");
	MakeComm	(0X2867,	"still not ready => done");
	MakeComm	(0X2874,	"normal no-error return");
	MakeCode	(0X2876);
	MakeName	(0X2876,	"prn_bperr");
	MakeName	(0X2877,	"prn_berr");
	MakeCode	(x=0X287A);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X287A,	"prn_genioctl");
	MakeComm	(0X287E,	"[es:di+IOCTL_REQ.MAJORFUNCTION]\nioc_pc");
	MakeCode	(x=0X287E);
	OpDecimal	(x,	0);
	OpHex		(x,	1);
	MakeName	(0X2885,	"prnfuncerr");
	MakeComm	(0X2888,	"[es:di+IOCTL_REQ.MINORFUNCTION]");
	MakeCode	(x=0X2888);
	OpDecimal	(x,	1);
	MakeName	(0X2888,	"prnfunc_ok");
	MakeComm	(0X288C,	"[es:di+IOCTL_REQ.GENERICIOCTL_PACKET]");
	MakeCode	(x=0X288C);
	OpDecimal	(x,	1);
	MakeCode	(x=0X2892);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X2896);
	OpHex		(x,	1);
	MakeComm	(0X2898,	"pull out retry count for device");
	MakeCode	(x=0X2898);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X289C,	"get_retry_count");
	MakeCode	(x=0X289C);
	OpHex		(x,	1);
	MakeComm	(0X28A0,	"set_retry_count");
	MakeCode	(x=0X28A0);
	OpHex		(x,	1);
	MakeCode	(x=0X28A7);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X28A7,	"prngetcount");
	MakeComm	(0X28AB,	"[es:di+A_RETRYCOUNT.RC_COUNT]\nreturn current retry count");
	MakeCode	(x=0X28B0);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X28B0,	"prn_ioctl_query");
	MakeComm	(0X28B4,	"[es:di+IOCTL_REQ.MAJORFUNCTION]\nioc_pc");
	MakeCode	(x=0X28B4);
	OpDecimal	(x,	0);
	OpHex		(x,	1);
	MakeComm	(0X28BB,	"[es:di+IOCTL_REQ.MINORFUNCTION]");
	MakeCode	(x=0X28BB);
	OpDecimal	(x,	1);
	MakeComm	(0X28BF,	"GET_RETRY_COUNT");
	MakeCode	(x=0X28BF);
	OpHex		(x,	1);
	MakeComm	(0X28C3,	"SET_RETRY_COUNT");
	MakeCode	(x=0X28C3);
	OpHex		(x,	1);
	MakeName	(0X28C7,	"IOCtlSupported");
	MakeCode	(0X28C9);
	MakeName	(0X28C9,	"prn_query_err");
	MakeCode	(0X28CD);
	MakeName	(0X28CD,	"aux_read");
	MakeComm	(0X28CF,	"put address of auxbuf in bx");
	MakeComm	(0X28DA,	"get character from port\nwon't return if error");
	MakeName	(0X28DA,	"aux1");
	MakeName	(0X28DD,	"aux2");
	MakeComm	(0X28DE,	"if more characters, go around again");
	MakeComm	(0X28E0,	"all done, successful exit");
	MakeName	(0X28E0,	"exvec2");
	MakeCode	(x=0X28E2);
	OpHex		(x,	1);
	MakeName	(0X28E2,	"auxin");
	MakeComm	(0X28E7,	"flag_frame|flag_parity|flag_overrun");
	MakeCode	(x=0X28E7);
	OpHex		(x,	1);
	MakeCode	(0X28ED);
	MakeComm	(0X28F0,	"flag_rec_sig|flag_dsr|flag_cts");
	MakeCode	(x=0X28F0);
	OpHex		(x,	1);
	MakeComm	(0X28F5,	"non-destructive aux port read");
	MakeCode	(0X28F5);
	MakeName	(0X28F5,	"aux_rdnd");
	MakeComm	(0X28FC,	"if al is non-zero (char in buffer)\nthen return character");
	MakeComm	(0X28FE,	"if not, get status of   aux device");
	MakeComm	(0X2901,	"flag_data_ready - test data ready");
	MakeCode	(x=0X2901);
	OpHex		(x,	1);
	MakeComm	(0X2904,	"then device is busy (not ready)");
	MakeComm	(0X2906,	"flag_dsr - test data set ready");
	MakeCode	(x=0X2906);
	OpHex		(x,	1);
	MakeComm	(0X2908,	"then device is busy (not ready)");
	MakeComm	(0X290A,	"else aux is ready, get character");
	MakeComm	(0X290F,	"return busy status");
	MakeName	(0X290F,	"auxrdx");
	MakeCode	(0X2912);
	MakeName	(0X2912,	"auxbus");
	MakeComm	(0X2915,	"return aux port write status");
	MakeCode	(0X2915);
	MakeName	(0X2915,	"aux_wrst");
	MakeComm	(0X2918,	"test data set ready");
	MakeCode	(x=0X2918);
	OpHex		(x,	1);
	MakeComm	(0X291A,	"then device is busy (not ready)");
	MakeComm	(0X291C,	"flag_tranhol_emp - test transmit hold reg");
	MakeCode	(x=0X291C);
	OpHex		(x,	1);
	MakeComm	(0X291F,	"then device is busy (not ready)");
	MakeComm	(0X2923,	"auxfunc_status");
	MakeCode	(x=0X2923);
	OpHex		(x,	1);
	MakeName	(0X2923,	"auxstat");
	MakeComm	(0X2925,	"ah=function code\n0=init, 1=send, 2=receive, 3=status\nget port number");
	MakeCode	(x=0X2925);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X2925,	"auxop");
	MakeComm	(0X2929,	"SERIAL I/O - GET USART STATUS\nDX = port number (0-3)\nReturn: AX = port status code");
	MakeCode	(x=0X2929);
	OpHex		(x,	0);
	MakeComm	(0X292C,	"flush aux input buffer\nget bx to point to auxbuf\nzero out buffer\nall done, successful return");
	MakeCode	(0X292C);
	MakeName	(0X292C,	"aux_flsh");
	MakeCode	(x=0X292F);
	OpHex		(x,	1);
	MakeComm	(0X2934,	"write to aux device (if cx > 0)");
	MakeCode	(0X2934);
	MakeName	(0X2934,	"aux_writ");
	MakeComm	(0X2936,	"get character to be written");
	MakeName	(0X2936,	"aux_loop");
	MakeComm	(0X2939,	"move di pointer to next character");
	MakeComm	(0X293A,	"auxfunc_send - indicates a write");
	MakeCode	(x=0X293A);
	OpHex		(x,	1);
	MakeComm	(0X293C,	"send character over aux port");
	MakeComm	(0X293F,	"check for error");
	MakeCode	(x=0X293F);
	OpHex		(x,	1);
	MakeComm	(0X2942,	"then no error");
	MakeComm	(0X2944,	"else indicate write fault");
	MakeCode	(x=0X2944);
	OpDecimal	(x,	1);
	MakeComm	(0X2946,	"call error routines");
	MakeComm	(0X2949,	"return bx -> single byte input buffer\nfor selected aux port ([auxnum])");
	MakeCode	(0X2949);
	MakeName	(0X2949,	"awok");
	MakeCode	(x=0X294D);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X294D,	"getbx");
	MakeCode	(x=0X2951);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2956,	"convert time to ticks\ninput : time in cx and dx\noutput: ticks returned in cx:dx\n\nthe clock ticks at the rate of:\n1193180/65536 ticks/second\n(about 18.2 ticks per second)");
	MakeCode	(x=0X2956);
	OpDecimal	(x,	1);
	MakeName	(0X2956,	"time_to_ticks");
	MakeComm	(0X2958,	"hours to minutes ///\nfirst convert from hour,min,sec,hund. to\ntotal number of 100th of seconds");
	MakeComm	(0X295C,	"total minutes");
	MakeComm	(0X295E,	"60*100");
	MakeCode	(x=0X295E);
	OpDecimal	(x,	1);
	MakeComm	(0X2963,	"convert to 1/100 sec");
	MakeCode	(x=0X2967);
	OpDecimal	(x,	1);
	MakeComm	(0X2969,	"convert seconds to 1/100 sec");
	MakeComm	(0X296B,	"combine seconds with hours and min");
	MakeComm	(0X2972,	"combine 1/100 sec");
	MakeComm	(0X2974,	"dx:cx is time in 1/100 sec");
	MakeComm	(0X2978,	"now time is in cx:ax");
	MakeCode	(x=0X2979);
	OpDecimal	(x,	1);
	MakeComm	(0X297C,	"multiply low half");
	MakeComm	(0X2980,	"cx->ax, ax->dx, dx->cx");
	MakeComm	(0X2981,	"multiply high half");
	MakeComm	(0X2983,	"combine overlapping products");
	MakeComm	(0X2988,	"ax:dx=time*59659");
	MakeComm	(0X298C,	"divide high half by 5");
	MakeComm	(0X2992,	"remainder of divide-by-5");
	MakeComm	(0X2995,	"use it to extend low half");
	MakeComm	(0X2996,	"divide low half by 5");
	MakeComm	(0X2998,	"cx:dx is now number of ticks in time");
	MakeComm	(0X299B,	"sets the current time");
	MakeCode	(0X299B);
	MakeName	(0X299B,	"tim_writ");
	MakeComm	(0X299E,	"daycnt. we need to set this at the very\nend to avoid tick windows");
	MakeCode	(x=0X299F);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X29A6,	"get binary hours\nconvert to bcd");
	MakeCode	(x=0X29AA);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X29AE,	"ch = bcd hours");
	MakeComm	(0X29B0,	"get binary minutes");
	MakeCode	(x=0X29B4);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X29B8,	"cl = bcd minutes");
	MakeComm	(0X29BA,	"get binary seconds");
	MakeCode	(x=0X29BE);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X29C2,	"dh = bcd seconds");
	MakeComm	(0X29C4,	"dl = 0 (st) or 1 (dst)");
	MakeComm	(0X29C9,	"CLOCK - SET REAL TIME CLOCK (AT,XT286,CONV,PS)\nCH = hours in BCD, CL = minutes in BCD\n DH = seconds in BCD,DL = 01h if daylight savings, 00h if standard time\nReturn: CMOS clock set");
	MakeCode	(x=0X29C9);
	OpHex		(x,	0);
	MakeName	(0X29CC,	"no_cmos_1");
	MakeComm	(0X29D4,	"convert time to ticks\ncx:dx now has time in ticks");
	MakeCode	(x=0X29D4);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X29DB,	"CLOCK - SET TIME OF DAY\nCX:DX = clock count\nReturn: time of day set");
	MakeCode	(x=0X29DB);
	OpHex		(x,	0);
	MakeCode	(x=0X29DD);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X29E2);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X29E9);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X29F0,	"CLOCK - SET DATE IN REAL TIME CLOCK (AT,XT286,CONV,PS)\nDL = day in BCD, DH = month in BCD, CL = year in BCD\nCH = century (19h or 20h)\nReturn: CMOS clock set");
	MakeCode	(x=0X29F0);
	OpHex		(x,	0);
	MakeName	(0X29F3,	"no_cmos_2");
	MakeComm	(0X29F5,	"gettime reads date and time\n\n65,536 seconds = 1,193,180 ticks\n\ntime in 100th of seconds\n   = ticks from clock  * 65,536 * 100 / 1,193,180\n   = ticks from clock * 5 * 65,536 / 59,659");
	MakeCode	(0X29F5);
	MakeName	(0X29F5,	"tim_read");
	MakeCode	(x=0X29F8);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X29FE,	"start with ticks in cx:dx\nmultiply by 5");
	MakeCode	(x=0X2A00);
	OpHex		(x,	1);
	MakeCode	(x=0X2A02);
	OpHex		(x,	1);
	MakeCode	(x=0X2A04);
	OpHex		(x,	1);
	MakeCode	(x=0X2A06);
	OpHex		(x,	1);
	MakeComm	(0X2A0D,	"multiply by 65536 and divide by 59659");
	MakeCode	(x=0X2A0D);
	OpDecimal	(x,	1);
	MakeComm	(0X2A10,	"dx has remainder\nax has high word of final quotient");
	MakeComm	(0X2A12,	"put high word in safe place");
	MakeComm	(0X2A14,	"multiply by 65536");
	MakeComm	(0X2A16,	"bx:ax has time in 100th of seconds");
	MakeComm	(0X2A1A,	"division by 200 is necessary \nto ensure no overflow--max result\nis number of seconds in a day/2 = 43200.");
	MakeCode	(x=0X2A1A);
	OpDecimal	(x,	1);
	MakeComm	(0X2A1F,	"remainder over 100?");
	MakeCode	(x=0X2A1F);
	OpDecimal	(x,	1);
	MakeComm	(0X2A24,	"keep 1/100's less than 100");
	MakeCode	(x=0X2A24);
	OpDecimal	(x,	1);
	MakeComm	(0X2A27,	"if we subtracted 100, carry is now set");
	MakeName	(0X2A27,	"noadj");
	MakeComm	(0X2A28,	"save 1/100's");
	MakeComm	(0X2A2A,	"multiply by two");
	MakeCode	(x=0X2A2A);
	OpHex		(x,	1);
	MakeCode	(x=0X2A2E);
	OpHex		(x,	1);
	MakeComm	(0X2A30,	"divide out seconds");
	MakeCode	(x=0X2A30);
	OpDecimal	(x,	1);
	MakeComm	(0X2A35,	"save the seconds");
	MakeComm	(0X2A37,	"break into hours and minutes");
	MakeComm	(0X2A3F,	"al = hours, ah = minutes");
	MakeComm	(0X2A44,	"[es:di] = count of days since 1-1-80\n   [es:di+2] = hours\n   [es:di+3] = minutes\n   [es:di+4] = seconds\n   [es:di+5] = hundredths of seconds");
	MakeComm	(0X2A46,	"Returns the tick count in cx:dx\nTakes care of DayCnt in case of rollover\nif ( rollover ) {\n    if ( t_switch )\n           daycnt++ ;\n    else\n           daycnt += rollover ;\n    }");
	MakeCode	(0X2A46);
	MakeName	(0X2A46,	"GetTickCnt");
	MakeComm	(0X2A48,	"CLOCK - GET TIME OF DAY\nReturn: CX:DX = clock count\nAL = 00h if clock was read or written (via AH=0,1) since the previous\nmidnight\nOtherwise, AL > 0");
	MakeCode	(x=0X2A48);
	OpHex		(x,	0);
	MakeComm	(0X2A4A,	"use old method ? (>0 is yes)");
	MakeCode	(x=0X2A4A);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2A4F,	"old method assumes that Int 1Ah returns rollover flag");
	MakeComm	(0X2A51,	"new method assumes that Int 1Ah returns roll over count\nand not flag");
	MakeCode	(x=0X2A53);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(0X2A58);
	MakeCode	(x=0X2A5C);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeByte	(0X2A61);
	MakeByte	(x=0X2A62);
	OpDecimal	(x,	0);
	MakeName	(0X2A62,	"DSKTBL");
	MakeWord	(x=0X2A63);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A65);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A67);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A69);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A6B);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A6D);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A6F);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A71);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A73);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A75);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A77);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A79);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A7B);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A7D);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A7F);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A81);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A83);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A85);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A87);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A89);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A8B);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A8D);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A8F);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A91);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A93);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeWord	(x=0X2A95);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X2A97,	"Point es:di to first bds");
	MakeCode	(x=0X2A97);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X2A97,	"SetDrive");
	MakeComm	(0X2A9B,	"logical drive number (BDS.drivelet)");
	MakeName	(0X2A9B,	"X_Scan_Loop");
	MakeComm	(0X2AA1,	"[es:di+BDS.link] ; Go to next bds");
	MakeCode	(0X2AAB);
	MakeName	(0X2AAB,	"media_chk");
	MakeComm	(0X2AB1,	"[es:di+BDS.flags+1], fchanged_by_format");
	MakeCode	(x=0X2AB1);
	OpHex		(x,	1);
	MakeComm	(0X2AB8,	"[es:di+BDS.flags],\n~fchanged_by_format ; reset flag");
	MakeCode	(x=0X2AB8);
	OpHex		(x,	1);
	MakeComm	(0X2ABE,	"-1\nEnsure that we ask the rom if media has changed");
	MakeCode	(x=0X2ABE);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X2AC3);
	OpHex		(x,	1);
	MakeComm	(0X2ACA,	"-1");
	MakeComm	(0X2ACF,	"[es:di+BDS.flags], fnon_removable");
	MakeCode	(x=0X2ACF);
	OpHex		(x,	1);
	MakeName	(0X2ACF,	"WeAreNotFakingIt");
	MakeComm	(0X2AD6,	"0 ; Presume \"I don't know\"");
	MakeName	(0X2AD6,	"WeHaveaFloppy");
	MakeComm	(0X2AD8,	"Do we have changeline support?");
	MakeCode	(x=0X2AD8);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2ADD,	"Brif not");
	MakeComm	(0X2ADF,	"Call into removable routine");
	MakeComm	(0X2AE9,	"Presume no change");
	MakeName	(0X2AE9,	"mChk_NoChangeLine");
	MakeComm	(0X2AEC,	"Last drive accessed");
	MakeCode	(x=0X2AEC);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2AEF,	"[es:di+BDS.drivenum]\nIs drive of last access the same?");
	MakeComm	(0X2AF3,	"No, then \"i don't know\"");
	MakeComm	(0X2AFA,	"0 ; Return \"I don't know\"");
	MakeCode	(0X2AFA);
	MakeName	(0X2AFA,	"Media_Unk");
	MakeName	(0X2AFB,	"Media_Done");
	MakeCode	(x=0X2AFC);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2B00,	"[es:bx+trans]");
	MakeCode	(x=0X2B00);
	OpDecimal	(x,	0);
	MakeComm	(0X2B07,	"volidok");
	MakeCode	(x=0X2B09);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X2B13);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpSign		(x,	1);
	OpDecimal	(x,	1);
	MakeName	(0X2B13,	"mChk1_NoChangeLine");
	MakeComm	(0X2B18,	"volidok");
	MakeName	(0X2B18,	"ret_carry_clear");
	MakeComm	(0X2B1A,	"guaranteed to set carry");
	MakeCode	(0X2B1A);
	MakeName	(0X2B1A,	"Err_Exitj");
	MakeComm	(0X2B1D,	"return error status");
	MakeCode	(x=0X2B1D);
	OpHex		(x,	1);
	MakeName	(0X2B1D,	"ret81");
	MakeComm	(0X2B1F,	"return with carry set");
	MakeComm	(0X2B20,	"presume no change");
	MakeCode	(0X2B20);
	MakeName	(0X2B20,	"Check_Time_Of_Access");
	MakeComm	(0X2B23,	"cx:dx is the elapsed time");
	MakeComm	(0X2B26,	"[es:di+BDS.tim_lo]\nget stored time");
	MakeComm	(0X2B2C,	"[es:di+BDS.tim_hi]");
	MakeComm	(0X2B32,	"cx<>0 => >1 hour");
	MakeComm	(0X2B34,	"time must pass");
	MakeComm	(0X2B36,	"yes, examine max value");
	MakeCode	(x=0X2B38);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X2B3C);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2B41,	"if count is less than threshold, ok");
	MakeCode	(x=0X2B43);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2B49,	"18*2 ; 18.2 tics per second.\nmin elapsed time? (2 seconds)");
	MakeCode	(x=0X2B49);
	OpDecimal	(x,	1);
	MakeComm	(0X2B4E,	"presume i don't know");
	MakeCode	(0X2B50);
	MakeName	(0X2B50,	"Err_Exitj2");
	MakeComm	(0X2B52,	"Build a valid bpb for the disk in the drive.\nget fat id byte read by dos");
	MakeCode	(0X2B52);
	MakeName	(0X2B52,	"get_bpb");
	MakeComm	(0X2B58,	"[es:di+BDS.flags], fnon_removable");
	MakeCode	(x=0X2B58);
	OpHex		(x,	1);
	MakeComm	(0X2B5D,	"no need to build for fixed disks");
	MakeComm	(0X2B62,	"indicate to set system id in bds");
	MakeCode	(x=0X2B62);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2B67,	"build a bpb if necessary");
	MakeComm	(0X2B6C,	"already, volume_label set from boot");
	MakeCode	(x=0X2B6C);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2B71,	"record to bds table?");
	MakeCode	(x=0X2B71);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2B76,	"do not set it again from root dir\notherwise, conventional boot record");
	MakeComm	(0X2B78,	"do we have changeline support?");
	MakeCode	(x=0X2B78);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2B7D,	"brif not");
	MakeComm	(0X2B82,	"BDS.BPB (BDS offset 6)");
	MakeCode	(x=0X2B82);
	OpHex		(x,	1);
	MakeName	(0X2B82,	"already_gotbpb");
	MakeComm	(0X2B85,	"return point for dsk_init");
	MakeName	(0X2B85,	"SetPtrSav");
	MakeCode	(x=0X2B87);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2B8B,	"[es:bx+media]");
	MakeCode	(x=0X2B8B);
	OpDecimal	(x,	0);
	MakeComm	(0X2B8F,	"[es:bx+count]");
	MakeCode	(x=0X2B8F);
	OpDecimal	(x,	0);
	MakeComm	(0X2B93,	"[es:bx+count+2]");
	MakeCode	(x=0X2B93);
	OpDecimal	(x,	0);
	MakeCode	(0X2B99);
	MakeName	(0X2B99,	"clear_ids");
	MakeComm	(0X2B9A,	"0");
	MakeComm	(0X2B9C,	"[es:di+BDS.vol_serial]");
	MakeComm	(0X2BA0,	"[es:di+BDS.vol_serial+2]");
	MakeCode	(x=0X2BA4);
	OpDecimal	(x,	1);
	MakeCode	(x=0X2BA7);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2BAA,	"BDS.volid");
	MakeCode	(x=0X2BAA);
	OpDecimal	(x,	1);
	MakeComm	(0X2BAF,	"(here, es:di points to the BDS offset +136)\n[es:di+BDS.fatsiz], fbig\n\n! NOTE - 26/06/2023 - Erdogan Tan\nMicrosoft code has a bug here because the BDS's\n.volid and .filesys_id fields will be reset\n(to their default text) according to 'BDS.fatsiz' flags\nat the BDS offset 31 but current (this) code checks flags\nat ES:DI+31 while DI points the BDS offset 86!?\n\nCorrect Code:\ntest byte [ES:DI+31-86],40h or\nDI_POSITION equ BDS.volid + size_of_EXT_BOOT_VOL_LABEL\ntest byte [ES:DI:BDS.fatsiz-DI_POSITION],40h ; fbig\n\n(Why this bug did not affect MSDOS applications:\n'clear_ids' is used for floppy disks only and the default\noption of 'clear_ids' is FAT12 volid and filesys_id text\nwhen the flag bit has wrong value for FAT16/40h.)");
	MakeCode	(x=0X2BAF);
	OpDecimal	(x,	0);
	OpHex		(x,	1);
	MakeCode	(x=0X2BB4);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X2BB9);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2BBC,	"size_of_EXT_SYSTEM_ID");
	MakeComm	(0X2BBF,	"BDS.filesys_id (BDS offset 91)");
	MakeComm	(0X2BC4,	"restore bds pointer");
	MakeComm	(0X2BC5,	"26/06/2023");
	MakeName	(0X2BC5,	"getbp_retn");
	MakeComm	(0X2BC6,	"return_fake_bpb|fnon_removable");
	MakeCode	(x=0X2BC6);
	OpHex		(x,	1);
	MakeName	(0X2BC6,	"GetBp");
	MakeComm	(0X2BCD,	"26/06/2023 - (useless far jump to 'retn'!)\n\nCorrect code here:\nretn ; (instead of jmp getret_exit)\n;or\njnz short getbp_retn ; (short jump to 'retn')");
	MakeCode	(0X2BD0);
	MakeComm	(0X2BD8,	"bx is 0 if boot sector is valid");
	MakeCode	(0X2BE1);
	MakeComm	(0X2BE4,	"puts media descriptor byte in ah");
	MakeCode	(0X2BE4);
	MakeComm	(0X2BE9,	"changeline support available?");
	MakeCode	(x=0X2BE9);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2BEE,	"brif not");
	MakeComm	(0X2BF3,	"[es:di+BDS.formfactor], ffSmall");
	MakeName	(0X2BF3,	"bpb_nochangeline");
	MakeComm	(0X2BFA,	"is it a valid fat id byte for 3.5\" ?");
	MakeCode	(x=0X2BFA);
	OpHex		(x,	1);
	MakeComm	(0X2BFD,	"no");
	MakeComm	(0X2BFF,	"pointer to correct bpb");
	MakeCode	(x=0X2BFF);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X2BFF,	"Has720K");
	MakeComm	(0X2C02,	"bpbtype.sbf = 3");
	MakeComm	(0X2C06,	"bpbtype.csec = 1440");
	MakeComm	(0X2C0A,	"dl = bpbtype.spau = 2\ndh = bpbtype.chead = 2");
	MakeComm	(0X2C0E,	"bl = bpbtype.spt = 9\nbh = bpbtype.dire = 112");
	MakeCode	(x=0X2C14);
	OpHex		(x,	1);
	MakeComm	(0X2C19,	"pbtype.sbf = 1");
	MakeCode	(x=0X2C19);
	OpDecimal	(x,	1);
	MakeComm	(0X2C1B,	"bl = bpbtype.spt = 8\nbh = bpbtype.dire = 64");
	MakeCode	(x=0X2C1B);
	OpHex		(x,	1);
	MakeComm	(0X2C1E,	"bpbtype.csec = 1440");
	MakeCode	(x=0X2C1E);
	OpDecimal	(x,	1);
	MakeComm	(0X2C21,	"dl = bpbtype.spau = 1\ndh = bpbtype.chead = 1");
	MakeCode	(x=0X2C21);
	OpHex		(x,	1);
	MakeCode	(x=0X2C24);
	OpHex		(x,	1);
	MakeComm	(0X2C29,	"bpbtype.sbf = 2");
	MakeComm	(0X2C2B,	"bpbtype.spt = 9");
	MakeComm	(0X2C2D,	"180K (360 sectors)");
	MakeCode	(x=0X2C2D);
	OpDecimal	(x,	1);
	MakeComm	(0X2C30,	"bpbtype.sbf = 1");
	MakeCode	(x=0X2C30);
	OpHex		(x,	1);
	MakeComm	(0X2C37,	"bh = bpbtype.dire = 112");
	MakeCode	(x=0X2C37);
	OpDecimal	(x,	1);
	MakeComm	(0X2C3D,	"[es:di+BDS.secperclus]");
	MakeName	(0X2C3D,	"Has1");
	MakeComm	(0X2C41,	"[es:di+BDS.direntries]");
	MakeComm	(0X2C45,	"[es:di+BDS.totalsecs16]");
	MakeComm	(0X2C49,	"[es:di+BDS.media]");
	MakeComm	(0X2C4D,	"[es:di+BDS.fatsecs]");
	MakeComm	(0X2C51,	"[es:di+BDS.secpertrack]");
	MakeComm	(0X2C55,	"[es:di+BDS.heads]");
	MakeComm	(0X2C59,	"[es:di+BDS.hiddensecs+2]");
	MakeComm	(0X2C5F,	"[es:di+BDS.hiddensecs]");
	MakeComm	(0X2C65,	"[es:di+BDS.totalsecs32+2]");
	MakeCode	(x=0X2C6F);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X2C79);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2C83,	"head 0");
	MakeCode	(0X2C83);
	MakeName	(0X2C83,	"readbootsec");
	MakeComm	(0X2C85,	"cylinder 0, sector 1");
	MakeComm	(0X2C8D,	"bx = 0");
	MakeComm	(0X2C8F,	"is it a direct jump?");
	MakeCode	(x=0X2C8F);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X2C94,	"don't need to find a nop");
	MakeComm	(0X2C96,	"dos 2.0 jump?");
	MakeCode	(x=0X2C96);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X2C9B,	"no need for nop");
	MakeComm	(0X2C9D,	"how about a short jump?");
	MakeCode	(x=0X2C9D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X2CA4,	"is next one a nop?");
	MakeCode	(x=0X2CA4);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X2CAB,	"\n[disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]");
	MakeCode	(x=0X2CAB);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X2CAE);
	OpHex		(x,	1);
	MakeComm	(0X2CB0,	"allow for strange media");
	MakeCode	(x=0X2CB0);
	OpHex		(x,	1);
	MakeCode	(x=0X2CB4);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X2CB4,	"checksinglesided");
	MakeCode	(x=0X2CB7);
	OpHex		(x,	1);
	MakeCode	(x=0X2CBB);
	OpHex		(x,	1);
	MakeComm	(0X2CBF,	"2E33h ; '3.'");
	MakeCode	(x=0X2CBF);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpChr		(x,	1);
	MakeComm	(0X2CC7,	"32h");
	MakeCode	(x=0X2CC7);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpChr		(x,	1);
	MakeComm	(0X2CCE,	"we must have a pre-3.20 diskette.\nset the sec/clus field to 1\n[disksector+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER]");
	MakeCode	(x=0X2CCE);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2CD5,	"indicate that boot sector invalid (bx = 1)");
	MakeCode	(0X2CD5);
	MakeCode	(0X2CD8);
	MakeComm	(0X2CD9,	"sectors per unit (cluster)");
	MakeCode	(x=0X2CD9);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X2CD9,	"movbpb");
	MakeComm	(0X2CDD,	"number of directory entries");
	MakeCode	(x=0X2CDD);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2CE1,	"size of drive (volume)");
	MakeCode	(x=0X2CE1);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2CE5,	"media descriptor");
	MakeCode	(x=0X2CE5);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2CE9,	"number of fat sectors");
	MakeCode	(x=0X2CE9);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2CEC,	"sectors per track");
	MakeCode	(x=0X2CEC);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2CF0,	"number of heads");
	MakeCode	(x=0X2CF0);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2CF4,	"called by get_bpb?");
	MakeCode	(x=0X2CF4);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2CFE,	"conventional boot record?");
	MakeComm	(0X2D00,	"signals that volume id is set");
	MakeCode	(x=0X2D00);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X2D05);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2D0C,	"reset flags in bds to not fchanged");
	MakeComm	(0X2D11,	"[disksector+EXT_BOOT.SIG],\n             EXT_BOOT_SIGNATURE");
	MakeCode	(x=0X2D11);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeName	(0X2D11,	"mov_media_ids");
	MakeComm	(0X2D19,	"\n[disksector+EXT_BOOT.SERIAL]");
	MakeCode	(x=0X2D19);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2D21,	"\n[disksector+EXT_BOOT.SERIAL+2]");
	MakeCode	(x=0X2D21);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2D25,	"[es:di+BDS.vol_serial+2]");
	MakeComm	(0X2D2B,	"size_of_EXT_BOOT_VOL_LABEL");
	MakeCode	(x=0X2D2B);
	OpDecimal	(x,	1);
	MakeComm	(0X2D2E,	"\ndisksector+EXT_BOOT.VOL_LABEL");
	MakeCode	(x=0X2D2E);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2D31,	"BDS.volid");
	MakeCode	(x=0X2D31);
	OpDecimal	(x,	1);
	MakeComm	(0X2D36,	"size_of_EXT_SYSTEM_ID");
	MakeCode	(x=0X2D36);
	OpHex		(x,	1);
	MakeComm	(0X2D39,	"\ndisksector+EXT_BOOT.SYSTEM_ID");
	MakeCode	(x=0X2D39);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2D3C,	"\n(BDS.filesys_id-BDS.volid)-size_of_EXT_BOOT_VOL_LABEL");
	MakeCode	(x=0X2D3C);
	OpHex		(x,	1);
	MakeComm	(0X2D44,	"this clc is not required (16/06/2019 - Erdogan Tan)\n(20/09/2022 - 27/06/2023)");
	MakeCode	(0X2D46);
	MakeComm	(0X2D48,	"head 0");
	MakeCode	(0X2D48);
	MakeName	(0X2D48,	"readfat");
	MakeComm	(0X2D4A,	"cylinder 0, sector 2");
	MakeComm	(0X2D52,	"media byte");
	MakeCode	(0X2D55);
	MakeName	(0X2D55,	"read_sector");
	MakeComm	(0X2D56,	"make 3 attempts");
	MakeCode	(x=0X2D56);
	OpHex		(x,	1);
	MakeComm	(0X2D59,	"[es:di+BDS.drivenum]");
	MakeComm	(0X2D5D,	"BIOSDATA:014Eh");
	MakeCode	(x=0X2D5D);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2D66,	"DISK - READ SECTORS INTO MEMORY\nAL = number of sectors to read, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer to fill\nReturn: CF set on error, AH = status, AL = number of sectors read");
	MakeCode	(x=0X2D66);
	OpHex		(x,	0);
	MakeComm	(0X2D6B,	"reset disk, decrement bp");
	MakeComm	(0X2D70,	"[es:di+BDS.flags], fnon_removable\n(BDS offset 35)");
	MakeCode	(x=0X2D70);
	OpHex		(x,	1);
	MakeCode	(x=0X2D77);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2D7F,	"for retry, set the head settle time to 0Fh");
	MakeCode	(x=0X2D80);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2D84,	"[si+DISK_PARMS.DISK_HEAD_STTL]");
	MakeComm	(0X2D87,	"NORMSETTLE");
	MakeCode	(x=0X2D87);
	OpDecimal	(x,	1);
	MakeCode	(x=0X2D8C);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2D96,	"DISK - READ SECTORS INTO MEMORY\nAL = number of sectors to read, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer to fill\nReturn: CF set on error, AH = status, AL = number of sectors read");
	MakeCode	(x=0X2D96);
	OpHex		(x,	0);
	MakeCode	(x=0X2D9A);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X2DA2);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X2DA6);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2DAA,	"[si+DISK_PARMS.DISK_HEAD_STTL]");
	MakeCode	(0X2DB4);
	MakeCode	(x=0X2DB7);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X2DBB);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2DBF,	"[es:di+BDS.track]\n(BDS offset 70)\nsave last track accessed on this drive");
	MakeComm	(0X2DC7,	"restore flags");
	MakeCode	(x=0X2DCA);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X2DCA,	"dsk_open");
	MakeComm	(0X2DD4,	"[es:di+BDS.opcnt]\n(BDS offset 32)");
	MakeComm	(0X2DD8,	"CF is already ZERO here - Erdogan Tan");
	MakeName	(0X2DD8,	"dsk_open_exit");
	MakeCode	(x=0X2DDA);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X2DDA,	"dsk_close");
	MakeComm	(0X2DDF,	"done if no changeline support");
	MakeComm	(0X2DE1,	"get bds for drive");
	MakeComm	(0X2DE4,	"[es:di+BDS.opcnt]");
	MakeComm	(0X2DE9,	"watch out for wrap");
	MakeComm	(0X2DEF,	"CF is already ZERO here - Erdogan Tan");
	MakeName	(0X2DEF,	"exitjx");
	MakeCode	(0X2DF1);
	MakeName	(0X2DF1,	"dsk_rem");
	MakeComm	(0X2DF4,	"[es:di+BDS.flags], fnon_removable");
	MakeCode	(x=0X2DF4);
	OpHex		(x,	1);
	MakeComm	(0X2DFB,	"CF is already ZERO here - Erdogan Tan");
	MakeComm	(0X2DFD,	"non_rem\nreturn busy status");
	MakeCode	(0X2DFD);
	MakeName	(0X2DFD,	"x_bus_exit");
	MakeName	(0X2E00,	"dsk_ret");
	MakeComm	(0X2E01,	"write and verify");
	MakeCode	(x=0X2E01);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeName	(0X2E01,	"dsk_writv");
	MakeComm	(0X2E09,	"romwrite");
	MakeCode	(x=0X2E09);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X2E09,	"dsk_writ");
	MakeComm	(0X2E0F,	"prepare for rombios read/write");
	MakeName	(0X2E0F,	"dsk_cl");
	MakeName	(0X2E12,	"dsk_io");
	MakeCode	(0X2E17);
	MakeName	(0X2E17,	"dsk_read");
	MakeCode	(0X2E1C);
	MakeName	(0X2E1C,	"checksingle");
	MakeComm	(0X2E1E,	"[es:di+BDS.flags]");
	MakeComm	(0X2E22,	"fnon_removable|fi_own_physical");
	MakeCode	(x=0X2E22);
	OpHex		(x,	1);
	MakeComm	(0X2E27,	"fi_am_mult\nis there a drive sharing this physical drive?");
	MakeCode	(x=0X2E27);
	OpHex		(x,	1);
	MakeComm	(0X2E2C,	"[es:di+BDS.drivenum]\nget physical drive number");
	MakeComm	(0X2E30,	"preserve pointer to current bds");
	MakeComm	(0X2E32,	"get first bds");
	MakeCode	(x=0X2E32);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2E3A,	"Not our drive. Try next bds.");
	MakeComm	(0X2E3C,	"fi_own_physical ; test ownership flag");
	MakeCode	(x=0X2E3C);
	OpHex		(x,	1);
	MakeComm	(0X2E42,	"he doesn't own it either. continue");
	MakeComm	(0X2E44,	"reset ownership flag");
	MakeCode	(x=0X2E4E);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2E55,	"are we handling drive number 0 ?");
	MakeComm	(0X2E5C,	"[es:di+BDS.drivelet]\nget the DOS drive letter");
	MakeCode	(x=0X2E61);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2E65,	"[es:LSTDRV]\nset up sdsb");
	MakeCode	(x=0X2E65);
	MakeComm	(0X2E69,	"restore bds pointer");
	MakeComm	(0X2E6C,	"if (single_drive_system)");
	MakeCode	(x=0X2E6C);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2E74,	"if (curr_drv == req_drv)");
	MakeCode	(x=0X2E7B);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2E7F,	"[es:LSTDRV]\nthen swap(curr_drv,req_drv)");
	MakeCode	(x=0X2E7F);
	MakeComm	(0X2E85,	"else");
	MakeComm	(0X2E87,	"swap(curr_drv,req_drv)");
	MakeComm	(0X2E88,	"issue swap_dsk_msg");
	MakeName	(0X2E8A,	"ignore_sdsb");
	MakeCode	(0X2E8F);
	MakeName	(0X2E8F,	"scan_skip");
	MakeComm	(0X2E92,	"-1 ; end of list?");
	MakeCode	(x=0X2E92);
	OpHex		(x,	1);
	MakeComm	(0X2E95,	"continue until hit end of list");
	MakeComm	(0X2E98,	"restore current bds");
	MakeComm	(0X2E9D,	"sector not found");
	MakeCode	(0X2E9D);
	MakeComm	(0X2EA1,	"unknown media");
	MakeCode	(0X2EA1);
	MakeName	(0X2EA4,	"ioret");
	MakeComm	(0X2EA5,	"romread");
	MakeCode	(x=0X2EA5);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X2EA5,	"DISKRD");
	MakeComm	(0X2EAA,	"al = drive number\ncx = sector count\ndx = first sector (low)\n[start_sec_h] = first sector (high)\n\nes:bx = transfer address");
	MakeName	(0X2EAA,	"diskio");
	MakeComm	(0X2EAC,	"save transfer segment");
	MakeCode	(x=0X2EAC);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2EB3,	"[es:di+BDS.media]");
	MakeCode	(x=0X2EB7);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2EBC,	"[es:di+BDS.flags+1],\n unformatted_media");
	MakeCode	(x=0X2EBC);
	OpHex		(x,	1);
	MakeComm	(0X2EC3,	"save sector count");
	MakeCode	(x=0X2EC3);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2EC7,	"save sp");
	MakeCode	(x=0X2EC7);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2ED4,	"[es:di+BDS.totalsecs16]\n> 32 bit sector ?");
	MakeComm	(0X2EE0,	"[es:di+BDS.totalsecs16]");
	MakeCode	(x=0X2EE8);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2EEC,	"[es:di+BDS.totalsecs32+2]");
	MakeComm	(0X2EF4,	"[es:di+BDS.totalsecs32]");
	MakeCode	(x=0X2EFA);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2EFE,	"[es:di+BDS.hiddensecs]");
	MakeComm	(0X2F02,	"[es:di+BDS.hiddensecs+2]");
	MakeComm	(0X2F06,	"save the sector number (low)");
	MakeCode	(x=0X2F06);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2F0A,	"0");
	MakeCode	(x=0X2F0A);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2F0E,	"[es:DSKADR] ; INT 1Eh vector\ncurrent disk parm table");
	MakeCode	(x=0X2F13);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X2F17);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2F1C,	"[es:di+BDS.flags],\nfnon_removable");
	MakeCode	(x=0X2F1C);
	OpHex		(x,	1);
	MakeComm	(0X2F26,	"do we have changeline support?");
	MakeCode	(x=0X2F26);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2F2B,	"brif not");
	MakeComm	(0X2F2D,	"will do a sneaky pop stack return\nif a disk error occurs");
	MakeComm	(0X2F30,	"set up tables and variables for i/o");
	MakeComm	(0X2F37,	"[es:di+BDS.secpertrack]\ndivide by sec per track");
	MakeCode	(x=0X2F3B);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X2F3E);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2F41,	"[es:di+BDS.secpertrack]\nnow, [temp_h]:ax = track #, dx = sector\nsector number is 1 based.");
	MakeComm	(0X2F47,	"save current sector");
	MakeCode	(x=0X2F47);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2F4B,	"[es:di+BDS.heads]\nget number of heads");
	MakeComm	(0X2F52,	"divide tracks by heads per cylinder");
	MakeCode	(x=0X2F52);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X2F57);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2F5B,	"now, [temp_h]:ax = cylinder #, dx = head");
	MakeCode	(x=0X2F5D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2F64,	"2^10 currently maxium for track #.");
	MakeCode	(x=0X2F64);
	OpDecimal	(x,	1);
	MakeComm	(0X2F69,	"save current head");
	MakeCode	(x=0X2F69);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2F6D,	"save current track");
	MakeCode	(x=0X2F6D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X2F70);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(0X2F7A);
	MakeComm	(0X2F7D,	"[es:di+BDS.drivenum]");
	MakeCode	(x=0X2F7D);
	OpHex		(x,	1);
	MakeName	(0X2F7D,	"iosetup");
	MakeComm	(0X2F81,	"save drive letter");
	MakeCode	(x=0X2F81);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X2F84);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X2F8B,	"fetch up eot before changing ds");
	MakeCode	(x=0X2F8B);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2F8F,	"get pointer to disk base table");
	MakeCode	(x=0X2F8F);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X2F93);
	OpHex		(x,	0);
	MakeComm	(0X2F96,	"[si+DISK_PARMS.DISK_MOTOR_STRT]");
	MakeCode	(x=0X2F96);
	OpDecimal	(x,	1);
	MakeComm	(0X2F99,	"[si+DISK_PARMS.DISK_EOT]");
	MakeCode	(x=0X2F99);
	OpHex		(x,	1);
	MakeCode	(x=0X2F9D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X2FA0);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X2FA5);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2FA9,	"[es:di+BDS.formfactor], ffSmall");
	MakeCode	(x=0X2FA9);
	OpDecimal	(x,	0);
	OpHex		(x,	1);
	MakeCode	(x=0X2FB0);
	OpHex		(x,	1);
	MakeComm	(0X2FB2,	"[si+DISK_PARMS.DISK_MOTOR_STRT]");
	MakeCode	(x=0X2FB2);
	OpDecimal	(x,	1);
	MakeComm	(0X2FB7,	"ibm wants fast settle to be 1");
	MakeComm	(0X2FB9,	"[si+DISK_PARMS.DISK_HEAD_STTL]\nget settle and set up for fast");
	MakeCode	(x=0X2FB9);
	OpHex		(x,	1);
	MakeCode	(x=0X2FBD);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X2FC0,	"NORMSETTLE\nsomeone has diddled the settle");
	MakeCode	(x=0X2FC0);
	OpDecimal	(x,	1);
	MakeCode	(x=0X2FC2);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X2FC6);
	OpHex		(x,	1);
	MakeName	(0X2FC6,	"done");
	MakeComm	(0X2FCB,	"do not set for non-removable media");
	MakeName	(0X2FD0,	"diddle_back");
	MakeCode	(x=0X2FD1);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X2FDA);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X2FDE);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2FE1,	"[es:si+DISK_PARMS.DISK_EOT]");
	MakeCode	(x=0X2FE5);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X2FE8);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X2FEC,	"[es:si+DISK_PARMS.DISK_HEAD_STTL]");
	MakeComm	(0X2FF0,	"[es:si+DISK_PARMS.DISK_SECTOR_SIZ]");
	MakeComm	(0X2FF5,	"[es:si+DISK_PARMS.DISK_MOTOR_STRT]");
	MakeName	(0X2FFC,	"ddbx");
	MakeCode	(0X2FFD);
	MakeName	(0X2FFD,	"block");
	MakeComm	(0X3001,	"[es:di+BDS.flags], fnon_removable");
	MakeCode	(x=0X3001);
	OpHex		(x,	1);
	MakeComm	(0X3008,	"multrk_on");
	MakeCode	(x=0X3008);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeCode	(x=0X3015);
	OpDecimal	(x,	1);
	MakeCode	(x=0X301B);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3030,	"reduce sectors-remaining by last i/o");
	MakeCode	(x=0X3032);
	OpHex		(x,	1);
	MakeComm	(0X3034,	"adjust transfer address");
	MakeCode	(0X3038);
	MakeComm	(0X303B,	"al = number of sectors (1-8, all on one track)\nes:di point to drive parameters\nxfer_seg:bx = transfer address \n     (must not cross a 64k physical boundary)\n[rflag] = 2 if read, 3 if write\n[verify] = 0 for normal, 1 for verify after write\n\nbp = MAXERR \n     retry_count");
	MakeCode	(0X303B);
	MakeName	(0X303B,	"disk");
	MakeComm	(0X303E,	"[es:di+BDS.flags], fnon_removable");
	MakeCode	(x=0X303E);
	OpHex		(x,	1);
	MakeComm	(0X3045,	"romverify ; Is this a track verify?");
	MakeComm	(0X304A,	"This is not verify so only 1 retry");
	MakeComm	(0X304D,	"verify op. retry cnt for write-verify");
	MakeCode	(x=0X304D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3051,	"soft ecc error retry count");
	MakeCode	(x=0X3051);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3055,	"get read/write indicator");
	MakeCode	(x=0X3055);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X305A);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X305E,	"[es:di+BDS.bdsm_ismini]\nis this a mini disk? ((logical dos partition))");
	MakeCode	(x=0X305E);
	OpHex		(x,	1);
	MakeComm	(0X3063,	"no. continue to next");
	MakeComm	(0X306C,	"[es:di+BDS.bdsm_hidden_trks]\nadd hidden tracks");
	MakeCode	(x=0X3070);
	OpHex		(x,	1);
	MakeCode	(x=0X3072);
	OpHex		(x,	1);
	MakeCode	(x=0X3074);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X307A,	"cl = sector, ch = cylinder");
	MakeComm	(0X307C,	"load current head number and");
	MakeCode	(x=0X307C);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3080,	"physical drive number\n[es:di+BDS.drivenum]");
	MakeComm	(0X3084,	"[es:di+BDS.formfactor], ffHardFile");
	MakeComm	(0X3089,	"hard files use fast speed");
	MakeComm	(0X308B,	"-1");
	MakeCode	(x=0X308B);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X3092,	"romread");
	MakeComm	(0X3097,	"romverify");
	MakeComm	(0X309E,	"change settle mode");
	MakeCode	(0X309E);
	MakeCode	(x=0X30A3);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X30A7,	"[es:di+BDS.track]");
	MakeCode	(x=0X30AB);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X30B4,	"[es:di+BDS.flags], fnon_removable");
	MakeCode	(x=0X30B4);
	OpHex		(x,	1);
	MakeComm	(0X30BB,	"multrk_on");
	MakeCode	(x=0X30BB);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X30C2,	"eliminate cylinder bits from sector");
	MakeCode	(x=0X30C2);
	OpHex		(x,	1);
	MakeComm	(0X30C7,	"reduce count of sectors to go next sector");
	MakeCode	(x=0X30C7);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X30CD);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X30D1,	"[es:di+BDS.secpertrack]\nsee if sector/track limit reached");
	MakeCode	(x=0X30D7);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X30DC);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X30E8,	"head 0");
	MakeComm	(0X30EA,	"next track");
	MakeCode	(x=0X30EA);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X30EE);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X30F4);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X3100,	"do_norm");
	MakeCode	(0X3105);
	MakeComm	(0X310E,	"soft ecc error ?");
	MakeCode	(x=0X3113);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3117,	"no more retry");
	MakeComm	(0X311C,	"retry");
	MakeCode	(0X311E);
	MakeCode	(x=0X3121);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3127,	"do we have changeline support?");
	MakeCode	(x=0X3127);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X3127,	"loc_3127");
	MakeComm	(0X312C,	"brif not");
	MakeComm	(0X3131,	"multi trk format request?");
	MakeCode	(x=0X3131);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3136,	"no more retry");
	MakeComm	(0X313B,	"clear the flag");
	MakeCode	(x=0X313B);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3145,	"[es:di+BDS.flags], fnon_removable");
	MakeCode	(x=0X3145);
	OpHex		(x,	1);
	MakeComm	(0X314C,	"timeout?");
	MakeCode	(x=0X314C);
	OpHex		(x,	1);
	MakeComm	(0X3151,	"write fault error?");
	MakeCode	(x=0X3151);
	OpHex		(x,	1);
	MakeComm	(0X3154,	"then, don't retry.");
	MakeComm	(0X3156,	"MAXERR\nset soft_ecc_cnt back   to maxerr");
	MakeCode	(x=0X3156);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X315C,	"estore sector count");
	MakeComm	(0X3160,	"just retry only once\nfor write fault error");
	MakeCode	(0X3160);
	MakeCode	(0X3165);
	MakeName	(0X3165,	"harderr");
	MakeComm	(0X3168,	"force a media check through rom");
	MakeCode	(x=0X3168);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeName	(0X3168,	"harderr2");
	MakeComm	(0X316D,	"get count of sectors to go");
	MakeCode	(x=0X316D);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3171,	"recover entry stack pointer");
	MakeCode	(x=0X3171);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X3178);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X3178,	"normspeed");
	MakeCode	(x=0X3181);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3184,	"current disk parm table");
	MakeCode	(x=0X3184);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3188,	"[es:si+DISK_PARMS.DISK_HEAD_STTL]");
	MakeCode	(x=0X3192);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3196,	"[es:si+DISK_PARMS.DISK_HEAD_STTL]\n1 is fast settle value");
	MakeComm	(0X319D,	"[es:di+BDS.fatsiz], ftoobig");
	MakeCode	(x=0X319D);
	OpHex		(x,	0);
	OpHex		(x,	1);
	MakeName	(0X319D,	"fastspeed");
	MakeCode	(x=0X31A5);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X31A9,	"DISK - ");
	MakeCode	(x=0X31A9);
	OpHex		(x,	0);
	MakeCode	(x=0X31AB);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(0X31B1);
	MakeCode	(x=0X31B2);
	OpHex		(x,	1);
	MakeCode	(0X31B5);
	MakeName	(0X31B5,	"maperror");
	MakeComm	(0X31B8,	"set es=Bios_Data");
	MakeComm	(0X31BB,	"terminate list with error code");
	MakeCode	(x=0X31BB);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X31BE,	"numerr (= errout-errin)\nnumber of possible error conditions");
	MakeCode	(x=0X31BE);
	OpHex		(x,	1);
	MakeCode	(x=0X31C1);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X31C6,	"[di+numerr-1]\nget translation");
	MakeCode	(x=0X31C6);
	OpHex		(x,	1);
	MakeComm	(0X31CC,	"flag error condition");
	MakeComm	(0X31CE,	"set the time of last access for this drive.\nthis is done only for removable media.\nes:di -> bds");
	MakeCode	(0X31CE);
	MakeName	(0X31CE,	"set_tim");
	MakeComm	(0X31CF,	"Does INT 1A ah=0 & updates daycnt");
	MakeComm	(0X31D2,	"[es:di+BDS.tim_lo]");
	MakeComm	(0X31DE,	"the time has passed\nreset the threshold counter");
	MakeCode	(x=0X31DE);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(0X31EE);
	MakeName	(0X31EE,	"again");
	MakeComm	(0X31F1,	"If it is a media change error\ndo not decrement retry count");
	MakeComm	(0X31F6,	"decrement retry count");
	MakeCode	(0X31F8);
	MakeByte	(0X31FB);
	MakeByte	(0X31FC);
	MakeName	(0X31FC,	"IoReadJumpTable");
	MakeComm	(0X31FD,	"60h");
	MakeWord	(x=0X31FD);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X31FF,	"61h");
	MakeWord	(x=0X31FF);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X3201,	"62h");
	MakeWord	(x=0X3201);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X3203,	"63h");
	MakeWord	(x=0X3203);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X3205,	"64h");
	MakeWord	(x=0X3205);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X3207,	"65h");
	MakeWord	(x=0X3207);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X3209,	"66h");
	MakeWord	(x=0X3209);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X320B,	"67h");
	MakeWord	(x=0X320B);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X320D,	"68h");
	MakeWord	(x=0X320D);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeByte	(0X320F);
	MakeName	(0X320F,	"IoWriteJumpTable");
	MakeComm	(0X3210,	"40h");
	MakeWord	(x=0X3210);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X3212,	"41h");
	MakeWord	(x=0X3212);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X3214,	"42h");
	MakeWord	(x=0X3214);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X3216,	"43h");
	MakeWord	(x=0X3216);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X3218,	"44h");
	MakeWord	(x=0X3218);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X321A,	"45h");
	MakeWord	(x=0X321A);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X321C,	"46h");
	MakeWord	(x=0X321C);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeComm	(0X321E,	"47h");
	MakeWord	(x=0X321E);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeByte	(0X3220);
	MakeArray	(0X3220,	0XB);
	MakeName	(0X3220,	"IOC_DC_Table");
	MakeComm	(0X322B,	"es:di points to bds for drive");
	MakeCode	(0X322B);
	MakeName	(0X322B,	"Do_Generic_IOCtl");
	MakeComm	(0X322F,	"es:bx points to request header");
	MakeCode	(x=0X322F);
	OpDecimal	(x,	1);
	MakeComm	(0X3233,	"[es:bx+IOCTL_REQ.MAJORFUNCTION],\nRAWIO");
	MakeCode	(x=0X323F);
	OpOff		(x,	1,	0X25C0);
	OpOff		(x,	129,	0X25C0);
	MakeComm	(0X3242,	"GEN_IOCTL_FN_TST ; test of req. function");
	MakeCode	(x=0X3242);
	OpHex		(x,	1);
	MakeCode	(x=0X3246);
	OpOff		(x,	1,	0X25C0);
	OpOff		(x,	129,	0X25C0);
	MakeComm	(0X3249,	"~GEN_IOCTL_FN_TST ; get rid of read/write bit");
	MakeCode	(x=0X3249);
	OpHex		(x,	1);
	MakeName	(0X3249,	"NotGenericWrite");
	MakeComm	(0X324B,	"offset for base function");
	MakeCode	(x=0X324B);
	OpHex		(x,	1);
	MakeCode	(x=0X3253);
	OpHex		(x,	1);
	MakeComm	(0X3260,	"Return this status in case of carry");
	MakeCode	(x=0X3260);
	OpHex		(x,	1);
	MakeCode	(0X3263);
	MakeName	(0X3263,	"Cmd_Error_Proc");
	MakeName	(0X3264,	"IoctlFuncErr");
	MakeComm	(0X3267,	"ds:bx points to request header");
	MakeCode	(x=0X3267);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X3267,	"GetDeviceParameters");
	MakeComm	(0X326B,	"[bx+IOCTL_REQ.GENERICIOCTL_PACKET]\n(ds:bx) = return buffer");
	MakeComm	(0X326E,	"[es:di+BDS.formfactor]");
	MakeComm	(0X3272,	"[bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]");
	MakeComm	(0X3275,	"[es:di+BDS.flags]");
	MakeComm	(0X3279,	"fnon_removable+fchangeline\nMask off other bits");
	MakeCode	(x=0X3279);
	OpHex		(x,	1);
	MakeComm	(0X327C,	"[bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]");
	MakeComm	(0X327F,	"[es:di+BDS.cylinders]");
	MakeComm	(0X3283,	"[bx+A_DEVICEPARAMETERS.DP_CYLINDERS]");
	MakeComm	(0X3286,	"Set media type to default");
	MakeComm	(0X3288,	"[bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]");
	MakeComm	(0X328B,	"[di+BDS.rbytespersec] = [di+BDS.R_BPB]\n(copy recommended bpb)");
	MakeComm	(0X328E,	"[bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],\nBUILD_DEVICE_BPB");
	MakeCode	(x=0X328E);
	OpHex		(x,	1);
	MakeComm	(0X3291,	"Point back to BIOSDATA");
	MakeComm	(0X3294,	"Point back to BIOSDATA");
	MakeComm	(0X329C,	"Build the bpb from scratch");
	MakeComm	(0X32A2,	"[di+BDS.bytespersec] = [di+BSD.DP_BPB]\nUse this subfield of bds instead");
	MakeComm	(0X32A5,	"[bx+A_DEVICEPARAMETERS.DP_BPB]\nThis is where the result goes");
	MakeName	(0X32A5,	"UseBpbPresent");
	MakeComm	(0X32A8,	"A_BPB.size - 6\nFor now use 'small' bpb");
	MakeCode	(x=0X32A8);
	OpDecimal	(x,	1);
	MakeComm	(0X32AB,	"reverse segments for copy");
	MakeName	(0X32B2,	"GetParmRet");
	MakeComm	(0X32B3,	"ds:bx points to request header");
	MakeCode	(x=0X32B3);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X32B3,	"SetDeviceParameters");
	MakeComm	(0X32B7,	"[bx+IOCTL_REQ.GENERICIOCTL_PACKET]");
	MakeComm	(0X32BA,	"[es:di+BDS.flags],\n fchanged_by_format|fchanged");
	MakeCode	(x=0X32BA);
	OpHex		(x,	1);
	MakeComm	(0X32C0,	"[bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],\n ONLY_SET_TRACKLAYOUT");
	MakeCode	(x=0X32C0);
	OpHex		(x,	1);
	MakeComm	(0X32C5,	"[bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]");
	MakeComm	(0X32C8,	"[es:di+BDS.formfactor]");
	MakeComm	(0X32CC,	"[bx+A_DEVICEPARAMETERS.DP_CYLINDERS]");
	MakeComm	(0X32CF,	"[es:di+BDS.cylinders]");
	MakeComm	(0X32D3,	"[bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]");
	MakeComm	(0X32D7,	"BIOSDATA segment");
	MakeCode	(x=0X32DC);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X32E2,	"we have changeline support");
	MakeCode	(x=0X32E4);
	OpHex		(x,	1);
	MakeComm	(0X32E7,	"Ignore all bits except non_removable and changeline\nfnon_removable|fchangeline");
	MakeCode	(x=0X32E7);
	OpHex		(x,	1);
	MakeName	(0X32E7,	"HaveChange");
	MakeComm	(0X32EA,	"[es:di+BDS.flags]");
	MakeComm	(0X32EE,	"~(fnon_removable|fchangeline|good_tracklayout|unformatted_media)");
	MakeCode	(x=0X32EE);
	OpHex		(x,	1);
	MakeComm	(0X32F4,	"[es:di+BDS.flags]");
	MakeComm	(0X32F8,	"[bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]\nSet media type");
	MakeCode	(x=0X3301);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3305,	"[es:di+BDS.flags]\nset_dasd_true (the next time we format a track)");
	MakeCode	(x=0X3305);
	OpHex		(x,	1);
	MakeComm	(0X330C,	"[bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],\n INSTALL_FAKE_BPB");
	MakeCode	(x=0X330C);
	OpHex		(x,	1);
	MakeComm	(0X3311,	"[es:di+BDS.flags], return_fake_bpb\nwere we returning a fake bpb when asked to build a bpb?");
	MakeCode	(x=0X3311);
	OpHex		(x,	1);
	MakeComm	(0X3319,	"[es:di+BDS.flags], ~return_fake_bpb\nwe were returning a fake bpb but we can stop now");
	MakeCode	(x=0X3319);
	OpHex		(x,	1);
	MakeComm	(0X331E,	"A_BPB.size");
	MakeCode	(x=0X331E);
	OpDecimal	(x,	1);
	MakeName	(0X331E,	"InstallRecommendedBpb");
	MakeComm	(0X3321,	"[di+BDS.R_BPB] = [di+BDS.rbytespersec]");
	MakeCode	(x=0X3326);
	OpHex		(x,	1);
	MakeName	(0X3326,	"InstallFakeBpb");
	MakeComm	(0X332B,	"A_BPB.size - 6");
	MakeCode	(x=0X332B);
	OpDecimal	(x,	1);
	MakeComm	(0X332E,	"[es:di+BDS.BPB] = [es:di+BDS.bytespersec]");
	MakeComm	(0X3331,	"[bx+A_DEVICEPARAMETERS.DP_BPB]");
	MakeName	(0X3331,	"CopyTheBpb");
	MakeComm	(0X3336,	"Save packet segment");
	MakeComm	(0X3337,	"BIOSDATA segment");
	MakeComm	(0X3341,	"[bx+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]\noffset 31+7 (A_BPB.size+7)");
	MakeName	(0X3341,	"setTrackTable");
	MakeCode	(x=0X334A);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X334F,	"[es:di+BDS.flags], ~good_tracklayout");
	MakeCode	(x=0X334F);
	OpHex		(x,	1);
	MakeComm	(0X3354,	"[bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],\n TRACKLAYOUT_IS_GOOD");
	MakeCode	(x=0X3354);
	OpHex		(x,	1);
	MakeComm	(0X3359,	"[es:di+BDS.flags], good_tracklayout");
	MakeCode	(x=0X3359);
	OpHex		(x,	1);
	MakeComm	(0X335E,	"MAX_SECTORS_IN_TRACK");
	MakeCode	(x=0X335E);
	OpDecimal	(x,	1);
	MakeName	(0X335E,	"UglyTrackLayOut");
	MakeCode	(x=0X3365);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3368,	"[bx+A_DEVICEPARAMETERS.DP_SECTORTABLE]\noffset 31+9 (A_BPB.size+9)");
	MakeComm	(0X336B,	"BIOSDATA segment\nTrash our bds pointer");
	MakeName	(0X3370,	"StoreSectorInfo");
	MakeComm	(0X3371,	"Skip over cylinder and head");
	MakeComm	(0X3372,	"Get sector id");
	MakeComm	(0X3373,	"Copy it");
	MakeComm	(0X3374,	"Get sector size");
	MakeComm	(0X3375,	"SectSizeToSectIndex:\n     Input:  ax contains sector size in bytes\n     Output: al contains index");
	MakeName	(0X337B,	"SectorInfoSaved");
	MakeCode	(x=0X337D);
	OpHex		(x,	1);
	MakeName	(0X337D,	"TooManyPerTrack");
	MakeCode	(x=0X3381);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X3381,	"FormatTrack");
	MakeComm	(0X3385,	"[bx+IOCTL_REQ.GENERICIOCTL_PACKET]");
	MakeComm	(0X3388,	"bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],\n STATUS_FOR_FORMAT");
	MakeCode	(x=0X3388);
	OpHex		(x,	1);
	MakeComm	(0X3393,	"Also moves current Dpt to TempDpt");
	MakeComm	(0X3397,	"[bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]");
	MakeComm	(0X339B,	"[es:di+BDS.formfactor], DEV_HARDDISK");
	MakeCode	(0X339B);
	MakeName	(0X339B,	"DoFormatTrack");
	MakeComm	(0X33AA,	"[bx+A_FORMATPACKET.FP_HEAD]");
	MakeCode	(0X33AA);
	MakeName	(0X33AA,	"DoFormatDiskette");
	MakeComm	(0X33AD,	"[bx+A_FORMATPACKET.FP_CYLINDER]");
	MakeComm	(0X33B0,	"[bx+A_FORMATPACKET.FP_SPECIALFUNCTIONS]\n    FP_TRACKCOUNT is only meaningful\n    when FP_SPECIALFUNCTIONS bit 1 = 1");
	MakeCode	(x=0X33B0);
	OpHex		(x,	1);
	MakeComm	(0X33BD,	"Also moves current Dpt to TempDpt");
	MakeCode	(0X33BD);
	MakeName	(0X33BD,	"DoFormatDiskette_1");
	MakeComm	(0X33C2,	"Old rom");
	MakeComm	(0X33C4,	"Time out error?");
	MakeComm	(0X33C6,	"No,fine. (at this point, don't care\nabout the illegal combination)");
	MakeCode	(0X33CA);
	MakeName	(0X33CA,	"NeedToSetDasd");
	MakeComm	(0X33CB,	"INT 13h, ah=17h");
	MakeComm	(0X33CF,	"Do any needed diskette swapping");
	MakeName	(0X33CF,	"NoSetDasd");
	MakeComm	(0X33D2,	"Get track from packet");
	MakeCode	(x=0X33D4);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X33D7);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X33DD);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X33E0);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X33E4,	"Store into TrackTable");
	MakeName	(0X33E4,	"StoreCylinderHead");
	MakeComm	(0X33E6,	"Skip to next sector field");
	MakeComm	(0X33EB,	"MAXERR - Set up retry count");
	MakeComm	(0X33EE,	"Now verify the sectors just formatted.\nNOTE: because of bug in some BIOSes \n      we have to set ES:BX to 00:00");
	MakeName	(0X33EE,	"FormatRetry");
	MakeCode	(x=0X33EF);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X33F2);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X33F7);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X3405);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X3409);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X3417,	"FormatError");
	MakeCode	(x=0X341A);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X342C,	"WhileErr");
	MakeCode	(x=0X3431);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X3431,	"FormatFailed");
	MakeComm	(0X3436,	"DSK_CHANGELINE_ERR\nconvert change line error to time out error");
	MakeComm	(0X343B,	"DSK_TIMEOUT_ERR");
	MakeCode	(x=0X343B);
	OpHex		(x,	1);
	MakeName	(0X343D,	"DoMapIt");
	MakeComm	(0X3440,	"reset the format error flag");
	MakeCode	(x=0X3440);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X3440,	"FormatOk");
	MakeCode	(0X3446);
	MakeName	(0X3446,	"VerifyTrack");
	MakeComm	(0X3447,	"ds:bx points to request header.");
	MakeCode	(x=0X3447);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X344B,	"[bx+IOCTL_REQ.GENERICIOCTL_PACKET]");
	MakeComm	(0X344E,	"[bx+A_VERIFYPACKET.VP_CYLINDER]");
	MakeComm	(0X3451,	"[bx+A_VERIFYPACKET.VP_HEAD]");
	MakeComm	(0X3454,	"[bx+A_FORMATPACKET.FP_TRACKCOUNT]");
	MakeComm	(0X3457,	"[bx+A_FORMATPACKET.FP_SPECIALFUNCTIONS]");
	MakeComm	(0X345A,	"romverify");
	MakeCode	(x=0X345A);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X345F);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3463,	"assume heads < 256");
	MakeCode	(x=0X3463);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X3466);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X346A,	"DO_FAST_FORMAT");
	MakeCode	(x=0X346A);
	OpHex		(x,	1);
	MakeComm	(0X346F,	"Get ax = number of trks to verify");
	MakeComm	(0X3473,	"#tracks > 255");
	MakeComm	(0X347D,	"[es:di+BDS.flags], fnon_removable");
	MakeCode	(x=0X347D);
	OpHex		(x,	1);
	MakeComm	(0X3485,	"MULTI_TRK_ON");
	MakeCode	(x=0X3485);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeCode	(x=0X348D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3492,	"1st sector");
	MakeName	(0X3492,	"NormVerifyTrack");
	MakeComm	(0X3496,	"Use 0:0 as the transfer address for verify");
	MakeCode	(x=0X3496);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X349D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(0X34A3);
	MakeName	(0X34A3,	"VerifyTrack_Err");
	MakeComm	(0X34A8,	"romread");
	MakeCode	(x=0X34A8);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X34A8,	"ReadTrack");
	MakeCode	(x=0X34AF);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X34AF,	"WriteTrack");
	MakeName	(0X34B4,	"ReadWriteTrack");
	MakeComm	(0X34B5,	"es:bx -> to request header");
	MakeCode	(x=0X34B5);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X34B9,	"[es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]");
	MakeComm	(0X34BD,	"[es:bx+A_TRACKREADWRITEPACKET.TRWP_CYLINDER]");
	MakeCode	(x=0X34C1);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X34C4,	"[es:bx+A_TRACKREADWRITEPACKET.TRWP_HEAD]");
	MakeComm	(0X34C8,	"Assume heads < 256 !");
	MakeCode	(x=0X34C8);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X34CB,	"[es:bx+A_TRACKREADWRITEPACKET.TRWP_FIRSTSECTOR]");
	MakeComm	(0X34CF,	"[es:bx+A_TRACKREADWRITEPACKET.TRWP_SECTORSTOREADWRITE]");
	MakeComm	(0X34D3,	"[es:bx+A_TRACKREADWRITEPACKET.TRWP_TRANSFERADDRESS]\nGet transfer address");
	MakeComm	(0X34D7,	"Pass transfer segment");
	MakeCode	(x=0X34D7);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X34DC,	"performs track read/write/verify\n\n input:\n  rFlag - 2 = read\n          3 = write\n          4 = verify\n  ax - Index into track table of first sector to io\n  cx - Number of sectors to io\n  Xfer_Seg:bx - Transfer address\n  es:di - Pointer to bds\n  CurTrk - Current cylinder\n  CurHd - Current head");
	MakeCode	(x=0X34DC);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X34DC,	"TrackIo");
	MakeComm	(0X34E3,	"See if we have already set disk");
	MakeCode	(x=0X34E3);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X34EA,	"set up tables and variables for i/o");
	MakeComm	(0X34F1,	"Point si at the table entry of the          \nfirst sector to be io'd");
	MakeCode	(x=0X34F1);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X34F4);
	OpHex		(x,	1);
	MakeCode	(x=0X34F6);
	OpHex		(x,	1);
	MakeComm	(0X34FD,	"[es:di+BDS.flags], good_tracklayout");
	MakeCode	(x=0X34FD);
	OpHex		(x,	1);
	MakeComm	(0X3505,	"We can read all secs in one blow");
	MakeComm	(0X350A,	"Skip over the cylinder and head in\nthe track table");
	MakeComm	(0X350B,	"Get sector ID from track table");
	MakeCode	(x=0X350C);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X350F,	"[es:di+BDS.flags], fnon_removable\nFixed disk?");
	MakeCode	(x=0X350F);
	OpHex		(x,	1);
	MakeComm	(0X3515,	"No");
	MakeComm	(0X3517,	"MULTI_TRK_ON");
	MakeCode	(x=0X3517);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X351D,	"No,don't do that.");
	MakeCode	(x=0X351F);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X352C,	"Get sector size index from track\ntable and save it");
	MakeCode	(0X352C);
	MakeComm	(0X352F,	"Save BIOSDATA");
	MakeComm	(0X3531,	"Preserve whatever might be in ah\nFetch EOT while ds-> BIOSDATA");
	MakeCode	(x=0X3531);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X3535);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3539,	"[si+DISK_PARMS.DISK_SECTOR_SIZ]");
	MakeComm	(0X353C,	"[si+DISK_PARMS.DISK_EOT]");
	MakeCode	(x=0X3543);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3549,	"Advance buffer pointer by adding\nsector size");
	MakeCode	(x=0X3554);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3560,	"(0=>128,1=>256,2=>512,3=>1024)\n examine upper byte only");
	MakeCode	(0X3560);
	MakeName	(0X3560,	"SectSizeToSectIndex");
	MakeComm	(0X3565,	"value in ah is the index!");
	MakeCode	(0X3568);
	MakeCode	(0X356B);
	MakeName	(0X356B,	"SectorSizeIndexToSectorSize");
	MakeCode	(x=0X356D);
	OpHex		(x,	1);
	MakeComm	(0X3573,	"See if we've previously set dasd type");
	MakeCode	(x=0X3573);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X3573,	"SetDasd");
	MakeComm	(0X357A,	"[es:di+BDS.flags], set_dasd_true");
	MakeCode	(x=0X357A);
	OpHex		(x,	1);
	MakeComm	(0X3582,	"[es:di+BDS.flags], ~set_dasd_true");
	MakeCode	(x=0X3582);
	OpHex		(x,	1);
	MakeComm	(0X3588,	"Reset it");
	MakeCode	(x=0X3588);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X358D,	"Format gap for 48tpi disks");
	MakeCode	(x=0X358D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X3594,	"[es:di+BDS.formfactor], DEV_3INCH720KB");
	MakeComm	(0X359B,	"[es:di+BDS.formfactor], DEV_5INCH96TPI");
	MakeComm	(0X35A6,	"160/320k in a 1.2 meg drive");
	MakeCode	(0X35A6);
	MakeCode	(x=0X35A8);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X35AF,	"1.2meg in a 1.2meg drive");
	MakeComm	(0X35B1,	"Format gap for 96 tpi, 1.2MB diskette");
	MakeCode	(x=0X35B1);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeCode	(x=0X35B8);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X35BC,	"[DSKADR] (Int 1Eh)");
	MakeCode	(x=0X35BC);
	MakeComm	(0X35C0,	"[si+DISK_PARMS.DISK_HEAD_STTL]");
	MakeCode	(x=0X35C0);
	OpHex		(x,	1);
	MakeCode	(x=0X35C6);
	OpHex		(x,	1);
	MakeComm	(0X35CC,	"DISK - SET TYPE (AT,XT2,XT286,CONV,PS\nAL = disk type");
	MakeCode	(x=0X35CC);
	OpHex		(x,	0);
	MakeComm	(0X35CE,	"[es:di+BDS.secpertrack]");
	MakeCode	(x=0X35D2);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(0X35D7);
	MakeName	(0X35D7,	"SetMediaForFormat");
	MakeCode	(x=0X35D9);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X35E0,	"If already done return 0");
	MakeCode	(x=0X35E2);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X35E9,	"Media already set");
	MakeCode	(0X35EC);
	MakeComm	(0X35EE,	"0 ; Point to interrupt vectors");
	MakeCode	(x=0X35EE);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X35F2,	"[es:DSKADR]\nGet pointer to disk base table");
	MakeCode	(x=0X35F2);
	MakeCode	(x=0X35F7);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X35FB);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X35FF,	"[es:si+DISK_PARMS.DISK_HEAD_STTL]");
	MakeComm	(0X3606,	"[es:di+BDS.cylinders]");
	MakeCode	(x=0X360B);
	OpHex		(x,	1);
	MakeCode	(x=0X360E);
	OpHex		(x,	1);
	MakeCode	(x=0X3610);
	OpHex		(x,	1);
	MakeComm	(0X3614,	"[es:di+BDS.secpertrack]");
	MakeComm	(0X3618,	"[es:di+BDS.drivenum]");
	MakeCode	(x=0X3620);
	OpHex		(x,	1);
	MakeComm	(0X3622,	"DISK - SET MEDIA TYPE FOR FORMAT (AT model 3x9,XT2,XT286,PS)\nDL = drive number, CH = lower 8 bits of number of tracks, \nCL = sectors per track");
	MakeCode	(x=0X3622);
	OpHex		(x,	0);
	MakeCode	(x=0X3626);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X362E,	"0");
	MakeCode	(x=0X362E);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3632,	"[es:DSKADR] (Int 1Eh)\nGet current disk base table");
	MakeCode	(x=0X3632);
	MakeCode	(x=0X3637);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X363B,	"Save it");
	MakeCode	(x=0X363B);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X363F,	"0");
	MakeCode	(x=0X363F);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X3643);
	MakeCode	(x=0X364D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3652,	"Legal combination + rom support code");
	MakeComm	(0X3654,	"Reset the flag");
	MakeCode	(x=0X3654);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3659,	"DSK_ILLEGAL_COMBINATION\nIllegal combination = 0Ch");
	MakeCode	(x=0X3659);
	OpHex		(x,	1);
	MakeComm	(0X365E,	"DSK_TIMEOUT_ERR");
	MakeCode	(x=0X365E);
	OpHex		(x,	1);
	MakeComm	(0X3663,	"Function not supported.");
	MakeComm	(0X3667,	"Function supported, but\nIllegal sect/trk,trk combination.");
	MakeCode	(0X3667);
	MakeComm	(0X366B,	"Function supported, but\nMedia not present");
	MakeCode	(0X366B);
	MakeCode	(0X3674);
	MakeName	(0X3674,	"resetdisk");
	MakeComm	(0X3675,	"Reset while formatting?");
	MakeCode	(x=0X3675);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X367C,	"Then verify operation in \"fmt & vrfy\"\nMight have failed.\nSo signals that we had a format error.");
	MakeCode	(x=0X367C);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3683,	"DISK - RESET DISK SYSTEM\nDL = drive (if bit 7 is set both hard disks and floppy disks reset)");
	MakeCode	(x=0X3683);
	OpHex		(x,	0);
	MakeComm	(0X3685,	"-1\nZap up the speed");
	MakeCode	(x=0X3685);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(0X368C);
	MakeName	(0X368C,	"ToRom");
	MakeCode	(x=0X368E);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X3696,	"Save bds segment");
	MakeComm	(0X3697,	"[es:di+BDS.formfactor], ffSmall\nis it a 3.5\" drive?");
	MakeComm	(0X369D,	"0");
	MakeCode	(x=0X369D);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X36A1,	"Get pointer to disk base table");
	MakeCode	(x=0X36A1);
	MakeComm	(0X36A6,	"Save pointer to table");
	MakeCode	(x=0X36A6);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X36AA);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X36AE);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X36B1,	"[es:si+DISK_PARMS.DISK_EOT]");
	MakeCode	(x=0X36B5);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X36B8,	"[es:si+DISK_PARMS.DISK_FORMT_GAP]\nImportant for format");
	MakeComm	(0X36BC,	"[es:si+DISK_PARMS.DISK_HEAD_STTL]\nAssume we are doing a seek operation\nSetup motor start correctly for 3.5\" drives");
	MakeCode	(x=0X36BC);
	OpHex		(x,	1);
	MakeComm	(0X36C4,	"[es:si+DISK_PARMS.DISK_MOTOR_STRT]");
	MakeComm	(0X36C9,	"Restore bds segment");
	MakeComm	(0X36CB,	"Set track number");
	MakeCode	(x=0X36CB);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X36CF,	"Set low 8 bits in ch");
	MakeComm	(0X36D1,	"Set drive number");
	MakeComm	(0X36D5,	"Set head number");
	MakeCode	(x=0X36D5);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X36D9,	"Save bds segment");
	MakeComm	(0X36DE,	"DISK - ");
	MakeCode	(x=0X36DE);
	OpHex		(x,	0);
	MakeComm	(0X36E0,	"Restore bds segment");
	MakeCode	(0X36E4);
	MakeName	(0X36E4,	"ioctl_getown");
	MakeComm	(0X36E7,	"[es:di+BDS.drivenum]\nGet physical drive number");
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_2(void) {
        auto x;
#define id x

	MakeComm	(0X36EB,	"Get start of bds chain");
	MakeCode	(x=0X36EB);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X36EF,	"[es:di+BDS.drivenum]");
	MakeName	(0X36EF,	"OwnLoop");
	MakeComm	(0X36F5,	"[es:di+BDS.flags], fi_own_physical");
	MakeCode	(x=0X36F5);
	OpHex		(x,	1);
	MakeComm	(0X36FD,	"[es:di+BDS.link]");
	MakeName	(0X36FD,	"getnextBDS");
	MakeCode	(0X3702);
	MakeName	(0X3702,	"ioctl_setown");
	MakeComm	(0X3705,	"set flag for CheckSingle to look at.");
	MakeCode	(x=0X3705);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X370D,	"set ownership of drive reset flag");
	MakeCode	(x=0X370D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X3712,	"ExitOwn");
	MakeComm	(0X3714,	"[es:di+BDS.flags], fi_am_mult");
	MakeCode	(x=0X3714);
	OpHex		(x,	1);
	MakeComm	(0X371C,	"[es:di+BDS.drivelet]\nGet logical drive number");
	MakeComm	(0X3720,	"Get it 1-based");
	MakeCode	(x=0X3722);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X3722,	"ExitNoMult");
	MakeComm	(0X3726,	"[bx+unit]\nExit normal termination");
	MakeCode	(0X372B);
	MakeName	(0X372B,	"RestoreOldDpt");
	MakeComm	(0X372E,	"Reset flag and");
	MakeCode	(x=0X372E);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3731,	"get current flag setting");
	MakeCode	(x=0X3731);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X373C);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3745,	"es = 0");
	MakeCode	(x=0X3745);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X374A,	"[es:DSKADR] (Int 1Eh)");
	MakeCode	(x=0X374A);
	MakeComm	(0X374F,	"[es:DSKADR+2]");
	MakeCode	(x=0X374F);
	MakeCode	(0X375A);
	MakeName	(0X375A,	"GetMediaId");
	MakeComm	(0X375D,	"[es:di+BDS.drivelet] ; Logical drive number");
	MakeComm	(0X3761,	"Read operation");
	MakeCode	(x=0X3761);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3766,	"Read boot sector into DiskSector");
	MakeComm	(0X376B,	"Valid? (0F0h-0FFh?)");
	MakeCode	(x=0X376B);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X3770,	"brif not valid (0F0h - 0FFh)");
	MakeComm	(0X3772,	"disksector+EXT_BOOT.SIG\nBS_BootSig");
	MakeCode	(x=0X3772);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeCode	(x=0X3779);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X377D,	"[es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]");
	MakeCode	(x=0X377D);
	OpDecimal	(x,	1);
	MakeComm	(0X3781,	"BS_VolID");
	MakeCode	(x=0X3781);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3784,	"A_MEDIA_ID_INFO.MI_SERIAL");
	MakeComm	(0X3787,	"+size_of_EXT_BOOT_VOL_LABEL\n+size_of_EXT_SYSTEM_ID");
	MakeCode	(x=0X3787);
	OpDecimal	(x,	1);
	MakeCode	(0X378E);
	MakeName	(0X378E,	"IOCtl_If2");
	MakeName	(0X3791,	"IOCtl_If1");
	MakeCode	(0X3792);
	MakeName	(0X3792,	"SetMediaId");
	MakeComm	(0X3795,	"[es:di+BDS.drivelet]\nLogical drive number");
	MakeComm	(0X379B,	"romread");
	MakeCode	(x=0X379B);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X37A1,	"Read boot sector to BIOSDATA:DiskSector");
	MakeComm	(0X37A7,	"Valid? (0F0h-0FFh?)\n[disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]");
	MakeCode	(x=0X37A7);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeCode	(x=0X37AE);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X37B9,	"disksector+EXT_BOOT.SERIAL");
	MakeCode	(x=0X37B9);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X37BC);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X37C6,	"copy volume serial, label and system id\ncx = 23 = size_of_EXT_BOOT_SERIAL\n        + size_of_EXT_BOOT_VOL_LABEL\n        + size_of_EXT_SYSTEM_ID");
	MakeCode	(x=0X37C6);
	OpDecimal	(x,	1);
	MakeComm	(0X37CB,	"point ds back to BIOSDATA");
	MakeComm	(0X37CD,	"restore bds pointer");
	MakeComm	(0X37CF,	"update the bds media id info.");
	MakeComm	(0X37D4,	"romwrite");
	MakeCode	(x=0X37D4);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X37D9,	"write it back");
	MakeComm	(0X37DC,	"make sure chk_media check the driver\nreturn with error code from BootIo");
	MakeCode	(x=0X37DC);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X37E2,	"error_unknown_media");
	MakeCode	(0X37E2);
	MakeName	(0X37E2,	"IOCtl_If7");
	MakeName	(0X37E5,	"IOCtl_If6");
	MakeCode	(0X37E6);
	MakeName	(0X37E6,	"BootIo");
	MakeComm	(0X37EB,	"es:di -> transfer address");
	MakeCode	(x=0X37EB);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X37EE,	"First sector (h) -> 0");
	MakeComm	(0X37F0,	"Start sector (h) -> 0");
	MakeCode	(x=0X37F0);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X37FE,	"[es:di+BDS.drivenum]");
	MakeCode	(0X37FE);
	MakeName	(0X37FE,	"ChangeLineChk");
	MakeComm	(0X3802,	"Fixed disk?");
	MakeComm	(0X3806,	"[es:di+BDS.flags], return_fake_bpb");
	MakeCode	(x=0X3806);
	OpHex		(x,	1);
	MakeComm	(0X380E,	"This rom support change line?");
	MakeCode	(x=0X380E);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3813,	"no");
	MakeComm	(0X3815,	"This drive support change line?");
	MakeComm	(0X3818,	"Do nothing");
	MakeCode	(x=0X381A);
	OpHex		(x,	1);
	MakeComm	(0X381C,	"DISK - ");
	MakeCode	(x=0X381C);
	OpHex		(x,	0);
	MakeComm	(0X3821,	"fchanged\nUpdate flag in BDS for this physical drive");
	MakeCode	(x=0X3821);
	OpHex		(x,	1);
	MakeComm	(0X3829,	"ds:bx points to request header");
	MakeCode	(x=0X3829);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X3829,	"GetAccessFlag");
	MakeComm	(0X382D,	"[bx+IOCTL_REQ.GENERICIOCTL_PACKET]");
	MakeComm	(0X3830,	"Assume result is unformatted");
	MakeComm	(0X3832,	"[es:di+BDS.flags], unformatted_media");
	MakeCode	(x=0X3832);
	OpHex		(x,	1);
	MakeComm	(0X3838,	"Done if unformatted");
	MakeComm	(0X383A,	"Return true for formatted");
	MakeComm	(0X383C,	"[bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]");
	MakeName	(0X383C,	"GafDone");
	MakeComm	(0X3840,	"ds:bx points to request header");
	MakeCode	(0X3840);
	MakeName	(0X3840,	"SetAccessFlag");
	MakeComm	(0X3844,	"[bx+IOCTL_REQ.GENERICIOCTL_PACKET]");
	MakeComm	(0X3847,	"[es:di+BDS.flags], ~unformatted_media");
	MakeCode	(x=0X3847);
	OpHex		(x,	1);
	MakeComm	(0X384D,	"[bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]");
	MakeComm	(0X3853,	"[es:di+BDS.flags], unformatted_media");
	MakeCode	(x=0X3853);
	OpHex		(x,	1);
	MakeName	(0X3859,	"saf_Done");
	MakeCode	(0X385A);
	MakeName	(0X385A,	"ioctl_support_query");
	MakeComm	(0X385B,	"es:bx points to request header.");
	MakeCode	(x=0X385B);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X385F,	"[es:bx+IOCTL_REQ.MAJORFUNCTION]\nal == Major, ah == Minor");
	MakeComm	(0X3863,	"IOC_DC");
	MakeComm	(0X3869,	"IOC_DC_TABLE_LEN");
	MakeCode	(x=0X3869);
	OpDecimal	(x,	1);
	MakeCode	(x=0X386C);
	OpOff		(x,	1,	0X25C0);
	OpOff		(x,	129,	0X25C0);
	MakeCode	(0X387A);
	MakeName	(0X387A,	"ioctl_support");
	MakeCode	(0X387D);
	MakeName	(0X387D,	"NoSupport");
	MakeComm	(0X3881,	"s:bx points to request header.");
	MakeCode	(x=0X3881);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X3881,	"SenseMediaType");
	MakeComm	(0X3885,	"[bx+IOCTL_REQ.GENERICIOCTL_PACKET]");
	MakeComm	(0X3888,	"0 ; Initialize the 2 packet bytes\ninvalidate drive type (byte 1)\nand default type flag (byte 0)");
	MakeComm	(0X388C,	"[es:di+BDS.drivenum]");
	MakeCode	(x=0X3892);
	OpHex		(x,	1);
	MakeComm	(0X3894,	"Compaq, ATAPI Removable Media Device\nGET CURRENT MEDIA FORMAT\n  AH = 20h\n  DL = drive number (00h,01h)\nReturn: CF clear if successful\n  AL = media type\n  AH = 00h\n  CF set on error\n     AH = error code\n\n(Ref: Ralf Interrupt List, INTERRUP.B)");
	MakeCode	(x=0X3894);
	OpHex		(x,	0);
	MakeComm	(0X3898,	"[bx+A_MEDIA_SENSE.MS_ISDEFAULT]\n1 = default media type");
	MakeComm	(0X389A,	"3 -> 2, 4 -> 3, 6 -> 5");
	MakeName	(0X389A,	"DetermineMediaType");
	MakeComm	(0X389C,	"3.5 inch, 720 KB");
	MakeComm	(0X38A0,	"3 -> 6, 4 -> 7, 6 -> 9");
	MakeComm	(0X38A2,	"3.5 inch, 1.44 MB");
	MakeComm	(0X38A6,	"3.5 inch, 2.88 MB");
	MakeComm	(0X38A8,	"Just didn't recognize media type");
	MakeComm	(0X38AA,	"[bx+A_MEDIA_SENSE.MS_DEVICETYPE]");
	MakeName	(0X38AA,	"GotMediaType");
	MakeComm	(0X38AF,	"non-default media /\ndrive does not support media type");
	MakeCode	(x=0X38AF);
	OpHex		(x,	1);
	MakeName	(0X38AF,	"MediaSenseErr");
	MakeComm	(0X38B4,	"function supported but, drive not ready");
	MakeComm	(0X38B6,	"no such drive / media not present");
	MakeCode	(x=0X38B6);
	OpHex		(x,	1);
	MakeComm	(0X38BB,	"error_unknown_media");
	MakeName	(0X38BB,	"UnknownMediaType");
	MakeComm	(0X38BD,	"Return this status in case of carry");
	MakeCode	(x=0X38BD);
	OpHex		(x,	1);
	MakeName	(0X38BD,	"SenseErrExit");
	MakeCode	(x=0X38C2);
	OpHex		(x,	1);
	MakeName	(0X38C2,	"i2f_handler");
	MakeCode	(x=0X38C7);
	OpHex		(x,	1);
	MakeCode	(x=0X38CC);
	OpHex		(x,	1);
	MakeCode	(x=0X38D1);
	OpHex		(x,	1);
	MakeCode	(0X38D9);
	MakeName	(0X38D9,	"i2f_handler_iret");
	MakeCode	(0X38DA);
	MakeName	(0X38DA,	"int2f_replace_int13");
	MakeCode	(x=0X38E2);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X38E6);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X38EA);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X38EE);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X38F2);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X38F6);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X38F9);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X38FD);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X3906,	"i2f_iret");
	MakeComm	(0X3907,	"iret on reserved functions");
	MakeCode	(x=0X3907);
	OpHex		(x,	1);
	MakeName	(0X3907,	"mine");
	MakeComm	(0X390B,	"a get installed state request?");
	MakeCode	(x=0X390F);
	OpHex		(x,	1);
	MakeComm	(0X3913,	"request for installing bds?");
	MakeCode	(0X3913);
	MakeName	(0X3913,	"disp_func");
	MakeComm	(0X3917,	"get bds vector?");
	MakeCode	(x=0X3921);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X3925);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X392A,	"BIOSDATA:dsk_entry\n\nNOTE: jump to a FAR function, not an\nIRET type function. Callers of\nthis int2f subfunction will have\nto be careful to do a popf");
	MakeCode	(x=0X392A);
	MakeCode	(0X392F);
	MakeName	(0X392F,	"do_subfun_01");
	MakeComm	(0X3933,	"BIOSDATA segment");
	MakeCode	(0X393F);
	MakeName	(0X393F,	"do_get_bds_vector");
	MakeCode	(x=0X3944);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X3948,	"ii2f_iret");
	MakeCode	(0X394A);
	MakeName	(0X394A,	"win386call");
	MakeComm	(0X394B,	"BIOSDATA segment");
	MakeComm	(0X3950,	"Win386_Init\nis it win386 initializing?");
	MakeComm	(0X3954,	"Win386_Exit\nis it win386 exiting?");
	MakeComm	(0X3958,	"is it win386 or win286 dos extender?");
	MakeCode	(x=0X3958);
	OpHex		(x,	1);
	MakeComm	(0X395C,	"if not win386, then continue");
	MakeComm	(0X395E,	"indicate that win386 is not present");
	MakeCode	(x=0X395E);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X3965,	"is it win386 or win286 dos extender?");
	MakeCode	(x=0X3965);
	OpHex		(x,	1);
	MakeName	(0X3965,	"Win386Init");
	MakeComm	(0X3969,	"if not win386, then continue");
	MakeCode	(x=0X396B);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeCode	(x=0X3970);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3974,	"Hook our structure into chain");
	MakeCode	(x=0X3974);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3978,	"point es:bx to Win386_SI");
	MakeCode	(x=0X3978);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X397D,	"win_iret");
	MakeComm	(0X397E,	"return back up the chain");
	MakeCode	(0X3980);
	MakeName	(0X3980,	"handle_multmult");
	MakeComm	(0X3985,	"get offset of free HMA");
	MakeComm	(0X398B,	"seg of HMA");
	MakeName	(0X3996,	"try_1");
	MakeComm	(0X3999,	"multMULTALLOCHMA");
	MakeCode	(0X3999);
	MakeName	(0X3999,	"try_2");
	MakeComm	(0X399E,	"assume not enough space");
	MakeComm	(0X39A3,	"get offset of free HMA");
	MakeComm	(0X39AB,	"free space in HMA");
	MakeCode	(x=0X39B6);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X39B6,	"try_4");
	MakeCode	(x=0X39BA);
	OpDecimal	(x,	1);
	MakeCode	(x=0X39BD);
	OpHex		(x,	1);
	MakeComm	(0X39C0,	"update the free pointer");
	MakeCode	(x=0X39C0);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X39C6,	"-1\nno more HMA if we have wrapped");
	MakeCode	(x=0X39C6);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X39CC,	"InsuffHMA");
	MakeCode	(0X39D0);
	MakeName	(0X39D0,	"try_3");
	MakeCode	(0X39D3);
	MakeName	(0X39D3,	"HMAPtr");
	MakeCode	(x=0X39D8);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X39E1);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X39E8,	"call far [MoveDOSIntoHMA]");
	MakeCode	(x=0X39E8);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X39EC);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(0X39F1);
	MakeName	(0X39F1,	"move_sector");
	MakeCode	(x=0X39F3);
	OpDecimal	(x,	1);
	MakeCode	(x=0X3A06);
	OpHex		(x,	1);
	MakeCode	(0X3A0C);
	MakeName	(0X3A0C,	"check_wrap");
	MakeComm	(0X3A10,	"get pointer to bds for drive in dl");
	MakeComm	(0X3A13,	"finished if DOS doesn't use it");
	MakeComm	(0X3A15,	"[es:di+BDS.flags],fnon_removable");
	MakeCode	(x=0X3A15);
	OpHex		(x,	1);
	MakeComm	(0X3A1B,	"no wrapping for removable media");
	MakeComm	(0X3A1D,	"[es:di+BDS.secpertrack]");
	MakeComm	(0X3A23,	"extract sector number");
	MakeCode	(x=0X3A23);
	OpHex		(x,	1);
	MakeComm	(0X3A26,	"are we going to wrap?");
	MakeComm	(0X3A2A,	"ah=new sector #, al=# of head wraps");
	MakeComm	(0X3A30,	"set sector=BDS_BPB.BPB_SECTORSPERTRACK");
	MakeComm	(0X3A32,	"if on boundary\nalso decrement # of head wrap");
	MakeComm	(0X3A34,	"zero out sector #");
	MakeCode	(x=0X3A34);
	OpHex		(x,	1);
	MakeComm	(0X3A37,	"or in new sector #");
	MakeComm	(0X3A39,	"ax = # of head wraps");
	MakeComm	(0X3A3C,	"add in starting head #");
	MakeComm	(0X3A3E,	"catch any carry");
	MakeComm	(0X3A41,	"[es:di+BDS.heads]\nare we going to wrap around a head?");
	MakeComm	(0X3A47,	"preserve drive number and head number");
	MakeComm	(0X3A4A,	"[es:di+BDS.heads]\ndx = new head #, ax = # of cylinder wraps");
	MakeComm	(0X3A50,	"if new head # is 0, then we are on the last head");
	MakeComm	(0X3A54,	"on boundary. set to BDS_BPB.BPB_HEADS");
	MakeComm	(0X3A56,	"if we had some cylinder wraps,\nwe need to reduce them by on");
	MakeComm	(0X3A5A,	"reduce number of cylinder wraps");
	MakeComm	(0X3A5B,	"bh has new head number");
	MakeComm	(0X3A5D,	"restore drive number and head number");
	MakeComm	(0X3A64,	"preserve sector number");
	MakeCode	(x=0X3A64);
	OpHex		(x,	1);
	MakeCode	(x=0X3A67);
	OpHex		(x,	1);
	MakeComm	(0X3A6B,	"get ms cylinder bits to ls end");
	MakeComm	(0X3A6D,	"add in cylinder wrap");
	MakeComm	(0X3A6F,	"add in high byte");
	MakeComm	(0X3A71,	"move up to ms end");
	MakeComm	(0X3A73,	"restore cylinder bits into cl");
	MakeComm	(0X3A75,	"or in sector number");
	MakeComm	(0X3A7D,	"do not lose new head number");
	MakeCode	(0X3A7D);
	MakeComm	(0X3A7F,	"get it 0-based");
	MakeComm	(0X3A83,	"point es:di to first bds");
	MakeCode	(x=0X3A83);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X3A83,	"find_bds");
	MakeComm	(0X3A87,	"[es:di+BDS.drivenum]");
	MakeComm	(0X3A8D,	"[es:di+BDS.link]\ngo to next bds");
	MakeComm	(0X3A97,	"[bp+INT13FRAME.olddx]\nget physical drive number");
	MakeCode	(0X3A97);
	MakeName	(0X3A97,	"doint");
	MakeComm	(0X3A9F,	"if zero sectors, return ax=0");
	MakeComm	(0X3AA1,	"[bp+INT13FRAME.oldax+1]\nget request code");
	MakeComm	(0X3AA5,	"[bp+INT13FRAME.oldf]");
	MakeComm	(0X3AAA,	"call BIOSDATA:call_orig13\ncall DOSBIOSSEG:call_orig13");
	MakeCode	(x=0X3AAA);
	MakeComm	(0X3AB0,	"[bp+INT13FRAME.oldf]");
	MakeComm	(0X3AB5,	"40h:90h is drive type array");
	MakeDword	(0X3AB5);
	MakeName	(0X3AB5,	"dtype_array");
	MakeComm	(0X3AB9,	"do we have changeline support?");
	MakeCode	(x=0X3AB9);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X3AB9,	"format_special_stuff");
	MakeComm	(0X3ABE,	"brif not");
	MakeComm	(0X3AC1,	"fchanged_by_format+fchanged");
	MakeCode	(x=0X3AC1);
	OpHex		(x,	1);
	MakeComm	(0X3AC4,	"indicate that media changed by format");
	MakeComm	(0X3ACA,	"floppy or hard disk?");
	MakeCode	(0X3ACA);
	MakeName	(0X3ACA,	"ec35_special_stuff");
	MakeComm	(0X3ACC,	"if hard drive, we're done");
	MakeComm	(0X3ACE,	"see if this PARTICULAR drive is ec35");
	MakeComm	(0X3AD0,	"turn drive number into bit map");
	MakeComm	(0X3AD2,	"assume drive 0");
	MakeComm	(0X3AD4,	"shift over correct number of times");
	MakeComm	(0X3AD6,	"electrically compatible 3.5 incher?");
	MakeCode	(x=0X3AD6);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3ADC,	"done if this floppy is not an ec35");
	MakeComm	(0X3ADE,	"free up a far pointer (es:bx)");
	MakeComm	(0X3AE7,	"find entry for this drive");
	MakeComm	(0X3AEA,	"establish drive type as:\n(360k disk in 360k drive,\nno double-stepping, 250 kbs transfer rate)");
	MakeCode	(x=0X3AEA);
	OpHex		(x,	1);
	MakeComm	(0X3AF2,	"(ps2_30)\nread driver parm?");
	MakeCode	(x=0X3AF2);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X3AF2,	"ps2_special_stuff");
	MakeComm	(0X3AF9,	"apparently function 15h fails, too");
	MakeCode	(x=0X3AF9);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X3B00,	"ps2_30_problem");
	MakeComm	(0X3B03,	"call BIOSDATA:call_orig13");
	MakeCode	(x=0X3B03);
	MakeCode	(0X3B0B);
	MakeName	(0X3B0B,	"i13z");
	MakeComm	(0X3B11,	"save request");
	MakeCode	(x=0X3B11);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3B14,	"romformat");
	MakeComm	(0X3B19,	"any electrically compat 3.5 inchers?");
	MakeCode	(x=0X3B19);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X3B19,	"format_special_stuff_done");
	MakeComm	(0X3B1E,	"go handle it out of line if so");
	MakeComm	(0X3B20,	"call BIOSDATA:call_orig13");
	MakeCode	(x=0X3B20);
	MakeName	(0X3B20,	"ec35_special_stuff_done");
	MakeComm	(0X3B26,	"is this a ps2/30?\nmdl_ps2_30");
	MakeCode	(x=0X3B26);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X3B2B,	"exit mainline to address special");
	MakeName	(0X3B2D,	"ps2_special_stuff_done");
	MakeComm	(0X3B2E,	"error on original orig13 call-thru?");
	MakeName	(0X3B30,	"ret_from_i13");
	MakeComm	(0X3B31,	"restore ds & iret w/flags");
	MakeComm	(0X3B34,	"done if not an error termination");
	MakeCode	(0X3B34);
	MakeName	(0X3B34,	"i13ret_ck_chglinerr");
	MakeComm	(0X3B36,	"did i see a change event?");
	MakeName	(0X3B36,	"i13_ret_error");
	MakeComm	(0X3B39,	"skip if wrong error");
	MakeComm	(0X3B3B,	"is this for the hard disk?");
	MakeComm	(0X3B3D,	"yes, ignore");
	MakeCode	(x=0X3B3F);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3B44,	"just in case ROM returned this\nerror even though it told us it\nnever would");
	MakeComm	(0X3B47,	"fchanged");
	MakeCode	(x=0X3B47);
	OpHex		(x,	1);
	MakeComm	(0X3B4E,	"now return the error");
	MakeName	(0X3B4E,	"int13b");
	MakeComm	(0X3B51,	"dma error?");
	MakeCode	(0X3B51);
	MakeName	(0X3B51,	"goterr13");
	MakeComm	(0X3B56,	"ecc error?");
	MakeName	(0X3B56,	"goterr13_xxxx");
	MakeComm	(0X3B59,	"other error. just return back.");
	MakeComm	(0X3B5B,	"formatting?");
	MakeCode	(x=0X3B5B);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3B62,	"ecc-corrected error\n(2 = romread)\nECC correction only applies to reads");
	MakeCode	(x=0X3B62);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3B6B,	"call BIOSDATA:call_orig13\ncall DOSBIOSSEG:call_orig13");
	MakeCode	(x=0X3B6B);
	MakeCode	(x=0X3B70);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3B73,	"return code = no error");
	MakeComm	(0X3B75,	"if request for one sector, assume ok");
	MakeComm	(0X3B77,	"return with carry clear");
	MakeCode	(x=0X3B7C);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3B7F,	"read one sector");
	MakeCode	(x=0X3B7F);
	OpHex		(x,	1);
	MakeName	(0X3B7F,	"loop_ecc");
	MakeComm	(0X3B82,	"get correct parameters for int 13");
	MakeComm	(0X3B85,	"call BIOSDATA:call_orig13\ncall DOSBIOSSEG:call_orig13");
	MakeCode	(x=0X3B85);
	MakeComm	(0X3B8C,	"DMA error during ECC read?");
	MakeCode	(x=0X3B8C);
	OpHex		(x,	1);
	MakeComm	(0X3B91,	"only allow ecc errors");
	MakeCode	(x=0X3B91);
	OpHex		(x,	1);
	MakeCode	(x=0X3B96);
	OpHex		(x,	1);
	MakeComm	(0X3B98,	"ecc error. reset the system again.\nclear the error code so that if this\nwas the last sector, no error code\nwill be returned for the corrected read.\n(clear carry too.)");
	MakeCode	(x=0X3B9A);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X3B9A,	"ok11_op");
	MakeComm	(0X3B9E,	"all done?");
	MakeComm	(0X3BA0,	"advance sector number\nadd 200h to address");
	MakeComm	(0X3BA8,	"set carry bit again.");
	MakeCode	(0X3BA8);
	MakeName	(0X3BA8,	"ok11_exit_err");
	MakeName	(0X3BA9,	"ok11_exit");
	MakeCode	(0X3BAE);
	MakeName	(0X3BAE,	"handle_dma_during_ecc");
	MakeComm	(0X3BB0,	"BIOSDATA:014Eh");
	MakeCode	(x=0X3BB0);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3BB4,	"point es:bx to buffer");
	MakeComm	(0X3BB5,	"read one sector");
	MakeCode	(x=0X3BB5);
	OpHex		(x,	1);
	MakeComm	(0X3BB8,	"call BIOSDATA:call_orig13");
	MakeCode	(x=0X3BB8);
	MakeCode	(x=0X3BC1);
	OpHex		(x,	1);
	MakeName	(0X3BC6,	"handle_dma_during_ecc_noerr");
	MakeCode	(x=0X3BCA);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X3BD4);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X3BD4,	"gotdmaerr");
	MakeComm	(0X3BD8,	"romread");
	MakeComm	(0X3BDD,	"romverify");
	MakeComm	(0X3BE2,	"romformat");
	MakeComm	(0X3BE9,	"set up stack frame here!");
	MakeComm	(0X3BF0,	"check for 64k boundary error");
	MakeCode	(x=0X3BF2);
	OpHex		(x,	1);
	MakeCode	(x=0X3BF4);
	OpHex		(x,	1);
	MakeCode	(x=0X3BF6);
	OpHex		(x,	1);
	MakeComm	(0X3BF8,	"dx = dx*16");
	MakeCode	(x=0X3BF8);
	OpHex		(x,	1);
	MakeCode	(x=0X3BFC);
	OpDecimal	(x,	1);
	MakeComm	(0X3C02,	"restore dh=head & do buffer");
	MakeComm	(0X3C05,	"dh = number of sectors before address");
	MakeCode	(x=0X3C05);
	OpHex		(x,	1);
	MakeName	(0X3C05,	"no_skip_first");
	MakeComm	(0X3C07,	"ah = max number of sectors in segment");
	MakeCode	(x=0X3C07);
	OpDecimal	(x,	1);
	MakeComm	(0X3C0B,	"can we fit it in?");
	MakeComm	(0X3C0D,	"no, perform blocking.\nyes, the request fits. let it happe");
	MakeComm	(0X3C0F,	"[bp+INT13FRAME.olddx+1]\nset up head number");
	MakeComm	(0X3C15,	"and return from this place");
	MakeComm	(0X3C18,	"pass dma error thru to caller");
	MakeCode	(0X3C18);
	MakeName	(0X3C18,	"i13_done_dmaerr");
	MakeComm	(0X3C1B,	"return with error,\nwe know it's not a changeline error");
	MakeComm	(0X3C1E,	"save caller's dma address");
	MakeCode	(0X3C1E);
	MakeName	(0X3C1E,	"intverify");
	MakeComm	(0X3C22,	"es:bx -> BIOSDATA:disksector");
	MakeCode	(x=0X3C22);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X3C22,	"dosimple");
	MakeComm	(0X3C25,	"call DOSBIOSSEG:call_orig13\ncall BIOSDATA:call_orig13");
	MakeCode	(x=0X3C25);
	MakeCode	(0X3C2F);
	MakeName	(0X3C2F,	"intformat");
	MakeComm	(0X3C3A,	"user's data into BIOSDATA:disksector");
	MakeCode	(x=0X3C3A);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3C42,	"do the i/o from");
	MakeComm	(0X3C43,	"BIOSDATA:disksector");
	MakeComm	(0X3C45,	"[bp+INT13FRAME.olddx]\nget head #, drive #");
	MakeCode	(0X3C45);
	MakeName	(0X3C45,	"doblock");
	MakeComm	(0X3C4A,	"ah - # of sectors before dma boundary\nal - requested # of sectors for i/o.");
	MakeComm	(0X3C4E,	"[es:di+BDS.secpertrack]");
	MakeComm	(0X3C52,	"[es:di+BDS.flags], fnon_removable");
	MakeCode	(x=0X3C52);
	OpHex		(x,	1);
	MakeComm	(0X3C5A,	"set al=ah for floppies");
	MakeComm	(0X3C5C,	"they are track by track operation");
	MakeComm	(0X3C5E,	"ah = 63-secpt (# safe sectors??)");
	MakeCode	(x=0X3C5E);
	OpDecimal	(x,	1);
	MakeComm	(0X3C60,	"al - # of sectors before dma boundary");
	MakeName	(0X3C62,	"doblockflop");
	MakeComm	(0X3C63,	"if safe_# >= #_of_sectors_to_go_before dma,");
	MakeName	(0X3C63,	"doblockcontinue");
	MakeComm	(0X3C65,	"then #_of_sectors_to_go as it is for doint.");
	MakeComm	(0X3C68,	"otherwise, set al to ah to operate.");
	MakeCode	(0X3C6C);
	MakeName	(0X3C6C,	"doblocklast");
	MakeName	(0X3C6F,	"doblockdoint");
	MakeComm	(0X3C89,	"[bp+INT13FRAME.olddx+1]\nset up head number");
	MakeCode	(0X3C89);
	MakeName	(0X3C89,	"bufferx");
	MakeName	(0X3C8C,	"buffer");
	MakeComm	(0X3C8D,	"[bp+INT13FRAME.oldax+1]");
	MakeComm	(0X3C90,	"romwrite");
	MakeComm	(0X3C9D,	"where to move");
	MakeCode	(x=0X3C9D);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3CA0,	"save it");
	MakeComm	(0X3CA1,	"source");
	MakeComm	(0X3CA3,	"move sector into local buffer");
	MakeComm	(0X3CA6,	"new transfer address\n(es:bx = BIOSDATA:disksector)");
	MakeComm	(0X3CA7,	"restore caller's di & si");
	MakeComm	(0X3CA9,	"restore BIOSDATA");
	MakeComm	(0X3CAC,	"[bp+INT13FRAME.olddx]\nget drive number");
	MakeComm	(0X3CAF,	"sets up registers if wrap-around\n\nah is function\nal is 1 for single sector transfer\nes:bx is local transfer addres\ncx is track/sector number\ndx is head/drive number\nsi, di unchanged");
	MakeComm	(0X3CB5,	"restore caller's dma segment");
	MakeComm	(0X3CB6,	"go clean up");
	MakeCode	(0X3CBA);
	MakeName	(0X3CBA,	"doread");
	MakeComm	(0X3CBD,	"es = BIOSCODE segment");
	MakeCode	(x=0X3CBE);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3CC3,	"[bp+INT13FRAME.olddx]\nget drive number");
	MakeComm	(0X3CC6,	"ah = function\nal = 1 for single sector\nes:bx points to local   buffer\ncx, dx are track/sector, head/drive");
	MakeCode	(x=0X3CD4);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3CDC,	"retrieve new dma area");
	MakeName	(0X3CDC,	"dotail");
	MakeComm	(0X3CDD,	"advance over sector");
	MakeComm	(0X3CE1,	"[bp+INT13FRAME.oldax]");
	MakeComm	(0X3CE7,	"no more i/o");
	MakeComm	(0X3CE9,	"[bp+INT13FRAME.olddx]");
	MakeName	(0X3CF2,	"bad13");
	MakeComm	(0X3CF9,	"go handle ECC errors");
	MakeComm	(0X3CFB,	"non-error exit");
	MakeCode	(0X3CFE);
	MakeName	(0X3CFE,	"xgoterr13_xxxx");
	MakeCode	(x=0X3D02);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeName	(0X3D02,	"dsk_init");
	MakeComm	(0X3D06,	"pass result in es:di");
	MakeCode	(x=0X3D06);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3D0E,	"save Bios_Data (BIOSDATA) segment");
	MakeCode	(0X3D0E);
	MakeName	(0X3D0E,	"install_bds");
	MakeComm	(0X3D0F,	"beginning of chain");
	MakeCode	(x=0X3D0F);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3D12,	"[si+BDS.link]\nfetch next bds");
	MakeComm	(0X3D14,	"[es:di+BDS.drivenum]");
	MakeComm	(0X3D18,	"does this one share a physical\ndrive with new one?");
	MakeComm	(0X3D1D,	"fi_am_mult");
	MakeComm	(0X3D1F,	"[es:di+BDS.flags]\nset both of them to i_am_mult if so");
	MakeComm	(0X3D23,	"[si+BDS.flags]");
	MakeComm	(0X3D26,	"[es:di+BDS.flags],~fi_own_physical\nwe don't own it");
	MakeCode	(x=0X3D26);
	OpHex		(x,	1);
	MakeComm	(0X3D2B,	"[si+BDS.flags]\ndetermine if changeline available");
	MakeComm	(0X3D2E,	"fchangeline");
	MakeCode	(x=0X3D2E);
	OpHex		(x,	1);
	MakeComm	(0X3D31,	"[es:di+BDS.flags]");
	MakeComm	(0X3D35,	"[si+BDS.link],-1\nare we at end of list?");
	MakeComm	(0X3D3A,	"[si+BDS.link+2], es\ninstall bds");
	MakeComm	(0X3D3F,	"[es:di+BDS.link],-1\nset next pointer to null");
	MakeComm	(0X3D45,	"[es:di+BDS.rsecpertrack]");
	MakeCode	(x=0X3D49);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X3D4F);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3D53,	"Is win386 present?");
	MakeCode	(x=0X3D53);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeName	(0X3D53,	"swpdsk");
	MakeComm	(0X3D58,	"no, skip SetFocus");
	MakeComm	(0X3D5A,	"call DOSBIOSSEG:V86_Crit_SetFocus\ncall BIOSDATA:V86_Crit_SetFocus");
	MakeCode	(x=0X3D5A);
	MakeComm	(0X3D61,	"[es:di+BDS.drivelet]\nget the drive letter");
	MakeCode	(x=0X3D67);
	OpHex		(x,	1);
	MakeComm	(0X3D6A,	"nobody has handled swap disk");
	MakeComm	(0X3D6C,	"multMULT<<8)|multMULTSWPDSK\nbroadcast code for swap disk\nBroadcast it");
	MakeCode	(x=0X3D6C);
	OpHex		(x,	1);
	MakeCode	(x=0X3D6F);
	OpHex		(x,	0);
	MakeCode	(x=0X3D74);
	OpChr		(x,	1);
	MakeCode	(x=0X3D7C);
	OpOff		(x,	1,	0X25C0);
	OpOff		(x,	129,	0X25C0);
	MakeComm	(0X3D80,	"get the next character of the message");
	MakeComm	(0X3D82,	"DOS 2+ internal - FAST PUTCHAR\nAL = character to display");
	MakeCode	(x=0X3D82);
	OpHex		(x,	0);
	MakeComm	(0X3D84,	"get the next character of the message");
	MakeComm	(0X3D8A,	"flush out keyboard queue\ncall rom-bios");
	MakeComm	(0X3D8F,	"KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY\nReturn: AH = scan code, AL = character");
	MakeCode	(x=0X3D8F);
	OpHex		(x,	0);
	MakeStr		(0X3D95,	0X3DB1);
	MakeName	(0X3D95,	"sngmsg");
	MakeStr		(0X3DB1,	0X3DD4);
	MakeName	(0X3DB1,	"drvlet");
	MakeComm	(0X3DD4,	"[es:di+BDS.opcnt]");
	MakeCode	(0X3DD4);
	MakeName	(0X3DD4,	"chkopcnt");
	MakeComm	(0X3DDA,	"make sure correct disk is in place");
	MakeCode	(0X3DDA);
	MakeName	(0X3DDA,	"MediaCheck");
	MakeComm	(0X3DE4,	"[es:di+BDS.flags], fchanged ; 40h\n(BDS offset 63)");
	MakeComm	(0X3DEB,	"[es:di+BDS.drivenum]");
	MakeComm	(0X3DF1,	"DISK - FLOPPY DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)\nDL = drive to check\nReturn: AH = disk change status");
	MakeCode	(x=0X3DF1);
	OpHex		(x,	0);
	MakeComm	(0X3DFA,	"get last drive accessed");
	MakeCode	(x=0X3DFA);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3DFE,	"[es:di+BDS.drivenum]\n(If the last drive accessed is not current drive\nmedia change status may be incorrect. So,\n\"I don't now\" will be returned even if it is indicated\nas media is not changed.)");
	MakeComm	(0X3E02,	"(same drive, media changeline indication is reliable)");
	MakeComm	(0X3E0F,	"check_time says \">= 2 secs passed\"\n(volume id will be checked)");
	MakeComm	(0X3E11,	"return \"i don't know\"");
	MakeComm	(0X3E14,	"build a new bpb in current bds");
	MakeCode	(0X3E14);
	MakeComm	(0X3E1E,	"fix up al for return to dos");
	MakeComm	(0X3E21,	" [es:di+BDS.opcnt] > 0");
	MakeCode	(0X3E21);
	MakeName	(0X3E21,	"checklatchio");
	MakeComm	(0X3E24,	"done if zero");
	MakeComm	(0X3E26,	"test [es:di+BDS.flags], fchanged ; 40h");
	MakeComm	(0X3E29,	"not changed");
	MakeComm	(0X3E35,	"is changed for sure?");
	MakeComm	(0X3E37,	"no");
	MakeComm	(0X3E39,	"yes");
	MakeComm	(0X3E3C,	"fix up al for return to dos");
	MakeComm	(0X3E40,	"pop off return address");
	MakeName	(0X3E41,	"checkret");
	MakeComm	(0X3E42,	"check the fat and the vid");
	MakeCode	(0X3E42);
	MakeName	(0X3E42,	"checkfatvid");
	MakeComm	(0X3E47,	"fall into check_vid");
	MakeComm	(0X3E49,	"BS_FAT_BootSig ; BS_BootSig\n[disksector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE");
	MakeCode	(x=0X3E49);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeName	(0X3E49,	"check_vid");
	MakeComm	(0X3E57,	"BPB_NumFATs\n[disksector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS]");
	MakeCode	(x=0X3E57);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X3E5C,	"don't read vol id if not fat system");
	MakeComm	(0X3E66,	"-1\ndefinitely changed");
	MakeName	(0X3E70,	"checkfatret");
	MakeComm	(0X3E71,	"cas -- return no error");
	MakeCode	(0X3E71);
	MakeName	(0X3E71,	"changed_drv");
	MakeComm	(0X3E72,	"ensure that we ask rom for media\n check next time round");
	MakeCode	(x=0X3E72);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeCode	(0X3E78);
	MakeComm	(0X3E79,	"[DiskSector+EXT_BOOT.SERIAL]");
	MakeCode	(x=0X3E79);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3E7C,	"[DiskSector+EXT_BOOT.SERIAL] = [di+BDS.vol_serial] ?");
	MakeComm	(0X3E80,	"no");
	MakeCode	(x=0X3E82);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3E85,	"[DiskSector+EXT_BOOT.SERIAL+2] = [di+BDS.vol_serial+2] ?");
	MakeComm	(0X3E89,	"no");
	MakeComm	(0X3E8B,	"don't know");
	MakeComm	(0X3E8E,	"reset the flag");
	MakeCode	(0X3E90);
	MakeComm	(0X3E91,	"-1\ndisk changed!");
	MakeCode	(0X3E97);
	MakeName	(0X3E97,	"checkio");
	MakeComm	(0X3E9C,	"[es:di+BDS.opcnt] > 0 ?");
	MakeComm	(0X3E9F,	"no");
	MakeComm	(0X3EA9,	"disk error trying to read in.");
	MakeComm	(0X3EAB,	"is changed for sure?");
	MakeComm	(0X3EAD,	"yes changed");
	MakeComm	(0X3EAF,	"allow a retry");
	MakeCode	(0X3EB1);
	MakeComm	(0X3EB4,	"make sure carry gets passed through");
	MakeCode	(0X3EB8);
	MakeComm	(0X3EBB,	"trans+8\noffset into pointer to return value");
	MakeCode	(x=0X3EBB);
	OpDecimal	(x,	1);
	MakeName	(0X3EBB,	"returnvid");
	MakeComm	(0X3EC5,	"trans+1");
	MakeCode	(x=0X3EC5);
	OpDecimal	(x,	1);
	MakeName	(0X3EC5,	"Media_Set_vId");
	MakeName	(0X3EC8,	"vid_into_packet");
	MakeCode	(x=0X3EC9);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3ECD,	"BDS.volid (BDS offset 75)");
	MakeCode	(x=0X3ECD);
	OpDecimal	(x,	1);
	MakeComm	(0X3ED2,	"BDS start (BDS offset 0)");
	MakeCode	(x=0X3ED2);
	OpDecimal	(x,	1);
	MakeComm	(0X3EDA,	"check for correct drive\nis it special?  \n[es:di+BDS.flags], fchangeline");
	MakeCode	(x=0X3EDA);
	OpHex		(x,	1);
	MakeName	(0X3EDA,	"hidensity");
	MakeComm	(0X3EE0,	"no, do normal floppy test");
	MakeComm	(0X3EE2,	"is it single-media?");
	MakeComm	(0X3EE7,	"[es:di+BDS.formfactor], ffSmall\nyes, use fatid.");
	MakeCode	(x=0X3EE9);
	OpHex		(x,	1);
	MakeComm	(0X3EEE,	"[es:di+BDS.formfactor], ffOther");
	MakeComm	(0X3EF5,	"[es:di+BDS.formfactor], ff288");
	MakeComm	(0X3EFC,	"seven sectors / fat");
	MakeComm	(0X3EFE,	"224*256+0Fh (57359)\n224 root dir entries & 0Fh sector max");
	MakeCode	(x=0X3EFE);
	OpHex		(x,	1);
	MakeComm	(0X3F01,	"80*15*2\n80 tracks, 15 sectors/track, 2 sides");
	MakeCode	(x=0X3F01);
	OpDecimal	(x,	1);
	MakeComm	(0X3F04,	"1*256+2\nsectors/allocation unit & head max");
	MakeCode	(x=0X3F04);
	OpDecimal	(x,	1);
	MakeComm	(0X3F07,	"pop off return address");
	MakeCode	(x=0X3F07);
	OpHex		(x,	1);
	MakeComm	(0X3F0A,	"return to tail of getbp");
	MakeComm	(0X3F0D,	"pop off return address");
	MakeCode	(x=0X3F0D);
	OpHex		(x,	1);
	MakeComm	(0X3F10,	"return to 720K code");
	MakeCode	(0X3F13);
	MakeCode	(0X3F14);
	MakeName	(0X3F14,	"Set_Changed_DL");
	MakeCode	(x=0X3F16);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3F1A,	"[es:di+BDS.drivenum]");
	MakeComm	(0X3F20,	"[es:di+BDS.flags]\nsignal change on other drive");
	MakeComm	(0X3F24,	"[es:di+BDS.link]\ngo to next bds");
	MakeComm	(0X3F27,	"loop unless end of chain");
	MakeComm	(0X3F2F,	"[es:di+BDS.flags], fchanged");
	MakeCode	(x=0X3F2F);
	OpHex		(x,	1);
	MakeName	(0X3F2F,	"checkromchange");
	MakeComm	(0X3F36,	"[es:di+BDS.flags], ~fchanged");
	MakeCode	(x=0X3F36);
	OpHex		(x,	1);
	MakeName	(0X3F36,	"resetchanged");
	MakeComm	(0X3F3C,	"[es:di+BDS.flags], fchangeline");
	MakeCode	(x=0X3F3C);
	OpHex		(x,	1);
	MakeName	(0X3F3C,	"HasChange");
	MakeCode	(0X3F43);
	MakeName	(0X3F43,	"set_volume_id");
	MakeComm	(0X3F45,	"does drive have changeline support?");
	MakeComm	(0X3F48,	"no, get out");
	MakeComm	(0X3F4F,	"copy the volume id to special drive");
	MakeComm	(0X3F59,	"pop stack but don't overwrite ax");
	MakeCode	(0X3F59);
	MakeWord	(0X3F5C);
	MakeName	(0X3F5C,	"root_sec");
	MakeCode	(0X3F5E);
	MakeName	(0X3F5E,	"read_volume_id");
	MakeComm	(0X3F62,	"stack the bds last");
	MakeComm	(0X3F64,	"point es to Bios_Data (BIOSDATA)");
	MakeCode	(x=0X3F66);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X3F69);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3F6C,	"initialize tmp_vid to null vi_id");
	MakeCode	(x=0X3F6C);
	OpDecimal	(x,	1);
	MakeComm	(0X3F73,	"[es:di+BDS.fats]\n# of fats");
	MakeComm	(0X3F77,	"[es:di+BDS.fatsecs]\nsectors / fat");
	MakeComm	(0X3F7D,	"[es:di+BDS.resectors]\nadd on reserved sectors\nnow, ax is sector # (0 based)");
	MakeComm	(0X3F85,	"[es:di+BDS.direntries]\n# root dir entries");
	MakeComm	(0X3F89,	"16 entries/sector");
	MakeComm	(0X3F8B,	"divide by 16");
	MakeComm	(0X3F8D,	"cx is # of sectors to scan");
	MakeComm	(0X3F8F,	"save outer loop counter");
	MakeComm	(0X3F90,	"get sector #");
	MakeComm	(0X3F94,	"[es:di+BDS.secpertrack]\nsectors / track");
	MakeComm	(0X3F9C,	"dx = sectors into track\nax = track count from 0");
	MakeComm	(0X3F9D,	"sector to read");
	MakeComm	(0X3FA1,	"[es:di+BDS.heads]\n# heads on this disc");
	MakeComm	(0X3FA5,	"head number");
	MakeComm	(0X3FA7,	"track #");
	MakeComm	(0X3FA9,	"get first sector of the root directory,\nds:bx -> directory sector");
	MakeComm	(0X3FAE,	"# of dir entries in a block of root");
	MakeCode	(x=0X3FAE);
	OpDecimal	(x,	1);
	MakeComm	(0X3FB1,	"volume label bit");
	MakeCode	(x=0X3FB1);
	OpHex		(x,	1);
	MakeComm	(0X3FB3,	"end of dir?");
	MakeComm	(0X3FB6,	"yes, no vol id");
	MakeComm	(0X3FB8,	"empty entry?");
	MakeCode	(x=0X3FB8);
	OpHex		(x,	1);
	MakeComm	(0X3FBB,	"yes, skip");
	MakeComm	(0X3FBD,	"is volume label bit set in fcb?");
	MakeCode	(x=0X3FBD);
	OpDecimal	(x,	0);
	MakeComm	(0X3FC0,	"yes");
	MakeComm	(0X3FC2,	"add length of directory entry");
	MakeCode	(x=0X3FC2);
	OpDecimal	(x,	1);
	MakeComm	(0X3FC7,	"outer loop");
	MakeComm	(0X3FC8,	"inc word [root_sec]\nnext sector");
	MakeComm	(0X3FCD,	"continue");
	MakeComm	(0X3FD3,	"clean stack of outer loop counter");
	MakeCode	(0X3FD3);
	MakeComm	(0X3FD4,	"point to volume_id");
	MakeComm	(0X3FD6,	"preserve current bds");
	MakeComm	(0X3FD8,	"point es to Bios_Data (BIOSDATA)");
	MakeCode	(x=0X3FDA);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3FDD,	"VOLID_SIZ-1\nlength of string minus nul");
	MakeCode	(x=0X3FDD);
	OpDecimal	(x,	1);
	MakeComm	(0X3FE4,	"null terminate");
	MakeComm	(0X3FE7,	"restore current bds");
	MakeCode	(0X3FEF);
	MakeCode	(0X3FF2);
	MakeCode	(0X3FF6);
	MakeName	(0X3FF6,	"transfer_volume_id");
	MakeCode	(x=0X3FF9);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X3FFC,	"BDS.volid");
	MakeCode	(x=0X3FFC);
	OpDecimal	(x,	1);
	MakeComm	(0X3FFF,	"VOLID_SIZ");
	MakeCode	(x=0X3FFF);
	OpDecimal	(x,	1);
	MakeCode	(0X4009);
	MakeName	(0X4009,	"check_volume_id");
	MakeCode	(x=0X400B);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X400E,	"BDS.volid");
	MakeCode	(x=0X400E);
	OpDecimal	(x,	1);
	MakeComm	(0X4011,	"VOLID_SIZ");
	MakeCode	(x=0X4011);
	OpDecimal	(x,	1);
	MakeCode	(0X401A);
	MakeName	(0X401A,	"fat_check");
	MakeComm	(0X401B,	"say fat id's are same.");
	MakeCode	(x=0X401D);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X4020,	"[es:di+BDS.media]\ncompare it with the bds medbyte");
	MakeCode	(x=0X4020);
	OpHex		(x,	1);
	MakeByte	(0X4029);
	MakeArray	(0X4029,	0X7);
	MakeWord	(0X4030);
	MakeName	(0X4030,	"SYSINIT$");
	MakeWord	(0X4032);
	MakeName	(0X4032,	"stackcount");
	MakeWord	(0X4034);
	MakeName	(0X4034,	"stackat");
	MakeWord	(0X4036);
	MakeName	(0X4036,	"stacksize");
	MakeWord	(0X4038);
	MakeArray	(0X4038,	0X2);
	MakeName	(0X4038,	"stacks");
	MakeComm	(0X403C,	"stacks+(defaultcount*entrysize)-entrysize");
	MakeWord	(x=0X403C);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X403C,	"firstentry");
	MakeComm	(0X403E,	"stacks+(defaultcount*entrysize)-entrysize");
	MakeWord	(0X403E);
	MakeName	(0X403E,	"lastentry");
	MakeWord	(0X4040);
	MakeName	(0X4040,	"nextentry");
	MakeDword	(0X4042);
	MakeName	(0X4042,	"old02");
	MakeCode	(0X4046);
	MakeName	(0X4046,	"int02");
	MakeComm	(0X404D,	"mdl_convert ; check if convertible");
	MakeCode	(x=0X404D);
	OpHex		(x,	1);
	MakeComm	(0X4056,	"PC/XT PPI port C. Bits:\n0-3: values of DIP switches\n5: 1=Timer 2 channel out\n6: 1=I/O channel check\n7: 1=RAM parity check error occurred.");
	MakeCode	(x=0X4056);
	OpHex		(x,	1);
	MakeCode	(x=0X4058);
	OpHex		(x,	1);
	MakeCode	(0X4062);
	MakeName	(0X4062,	"normal02");
	MakeWord	(x=0X4066);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeDword	(0X4068);
	MakeName	(0X4068,	"old08");
	MakeCode	(0X406C);
	MakeName	(0X406C,	"int08");
	MakeWord	(x=0X406F);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeDword	(0X4071);
	MakeName	(0X4071,	"old09");
	MakeCode	(0X4075);
	MakeName	(0X4075,	"int09");
	MakeCode	(0X4077);
	MakeByte	(0X4078);
	MakeCode	(0X4079);
	MakeName	(0X4079,	"keyboard_lbl");
	MakeWord	(x=0X407C);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeDword	(0X407E);
	MakeName	(0X407E,	"old70");
	MakeCode	(0X4082);
	MakeName	(0X4082,	"int70");
	MakeWord	(x=0X4085);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X4087);
	MakeName	(0X4087,	"int0A");
	MakeDword	(0X4089);
	MakeName	(0X4089,	"old0A");
	MakeWord	(0X408D);
	MakeByte	(0X408F);
	MakeName	(0X408F,	"firstflag0A");
	MakeCode	(0X4090);
	MakeByte	(0X4092);
	MakeArray	(0X4092,	0X7);
	MakeCode	(0X4099);
	MakeName	(0X4099,	"entry_int0A_stk");
	MakeWord	(x=0X409C);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X409E);
	MakeName	(0X409E,	"intret_0A");
	MakeCode	(0X409F);
	MakeName	(0X409F,	"int0B");
	MakeDword	(0X40A1);
	MakeName	(0X40A1,	"old0B");
	MakeWord	(0X40A5);
	MakeByte	(0X40A7);
	MakeCode	(0X40A8);
	MakeByte	(0X40AA);
	MakeArray	(0X40AA,	0X7);
	MakeCode	(0X40B1);
	MakeName	(0X40B1,	"entry_int0B_stk");
	MakeWord	(x=0X40B4);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X40B6);
	MakeName	(0X40B6,	"intret_0B");
	MakeCode	(0X40B7);
	MakeName	(0X40B7,	"int0C");
	MakeDword	(0X40B9);
	MakeName	(0X40B9,	"old0C");
	MakeWord	(0X40BD);
	MakeByte	(0X40BF);
	MakeName	(0X40BF,	"firstflag0C");
	MakeCode	(0X40C0);
	MakeByte	(0X40C2);
	MakeArray	(0X40C2,	0X7);
	MakeCode	(0X40C9);
	MakeName	(0X40C9,	"entry_int0C_stk");
	MakeWord	(x=0X40CC);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X40CE);
	MakeName	(0X40CE,	"intret_0C");
	MakeCode	(0X40CF);
	MakeName	(0X40CF,	"int0D");
	MakeDword	(0X40D1);
	MakeName	(0X40D1,	"old0D");
	MakeWord	(0X40D5);
	MakeByte	(0X40D7);
	MakeName	(0X40D7,	"firstflag0D");
	MakeCode	(0X40D8);
	MakeByte	(0X40DA);
	MakeArray	(0X40DA,	0X7);
	MakeCode	(0X40E1);
	MakeName	(0X40E1,	"int0D_stk");
	MakeWord	(x=0X40E4);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X40E6);
	MakeName	(0X40E6,	"intret_0D");
	MakeCode	(0X40E7);
	MakeName	(0X40E7,	"int0Eh");
	MakeDword	(0X40E9);
	MakeName	(0X40E9,	"old0E");
	MakeWord	(0X40ED);
	MakeByte	(0X40EF);
	MakeName	(0X40EF,	"firstflag0E");
	MakeCode	(0X40F0);
	MakeByte	(0X40F2);
	MakeArray	(0X40F2,	0X7);
	MakeCode	(0X40F9);
	MakeName	(0X40F9,	"entry_int0E_stk");
	MakeWord	(x=0X40FC);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X40FE);
	MakeName	(0X40FE,	"intret_0E");
	MakeCode	(0X40FF);
	MakeName	(0X40FF,	"int72");
	MakeDword	(0X4101);
	MakeName	(0X4101,	"old72");
	MakeWord	(0X4105);
	MakeByte	(0X4107);
	MakeName	(0X4107,	"firstflag72");
	MakeCode	(0X4108);
	MakeByte	(0X410A);
	MakeArray	(0X410A,	0X7);
	MakeCode	(0X4111);
	MakeName	(0X4111,	"entry_int72_stk");
	MakeWord	(x=0X4114);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X4116);
	MakeName	(0X4116,	"intret_72");
	MakeCode	(0X4117);
	MakeName	(0X4117,	"int73");
	MakeDword	(0X4119);
	MakeName	(0X4119,	"old73");
	MakeWord	(0X411D);
	MakeByte	(0X411F);
	MakeName	(0X411F,	"firstflag73");
	MakeCode	(0X4120);
	MakeByte	(0X4122);
	MakeArray	(0X4122,	0X7);
	MakeCode	(0X4129);
	MakeName	(0X4129,	"entry_int73_stk");
	MakeWord	(x=0X412C);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X412E);
	MakeName	(0X412E,	"intret_73");
	MakeCode	(0X412F);
	MakeName	(0X412F,	"int74");
	MakeDword	(0X4131);
	MakeName	(0X4131,	"old74");
	MakeWord	(0X4135);
	MakeByte	(0X4137);
	MakeName	(0X4137,	"firstflag74");
	MakeCode	(0X4138);
	MakeByte	(0X413A);
	MakeArray	(0X413A,	0X7);
	MakeCode	(0X4141);
	MakeName	(0X4141,	"entry_int74_stk");
	MakeWord	(x=0X4144);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X4146);
	MakeName	(0X4146,	"intret_74");
	MakeCode	(0X4147);
	MakeName	(0X4147,	"int76");
	MakeDword	(0X4149);
	MakeName	(0X4149,	"old76");
	MakeWord	(0X414D);
	MakeByte	(0X414F);
	MakeName	(0X414F,	"firstflag76");
	MakeCode	(0X4150);
	MakeByte	(0X4152);
	MakeArray	(0X4152,	0X7);
	MakeCode	(0X4159);
	MakeName	(0X4159,	"entry_int76_stk");
	MakeWord	(x=0X415C);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X415E);
	MakeName	(0X415E,	"intret_76");
	MakeCode	(0X415F);
	MakeName	(0X415F,	"int77");
	MakeDword	(0X4161);
	MakeName	(0X4161,	"old77");
	MakeWord	(0X4165);
	MakeByte	(0X4167);
	MakeName	(0X4167,	"firstflag77");
	MakeCode	(0X4168);
	MakeByte	(0X416A);
	MakeArray	(0X416A,	0X7);
	MakeCode	(0X4171);
	MakeName	(0X4171,	"entry_int77_stk");
	MakeWord	(x=0X4174);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X4176);
	MakeName	(0X4176,	"intret_77");
	MakeCode	(0X4177);
	MakeName	(0X4177,	"do_int_stacks");
	MakeComm	(0X417A,	"Get segment of stacks");
	MakeComm	(0X417F,	"get most likely candidate");
	MakeComm	(0X4184,	"allocated");
	MakeComm	(0X4186,	"grab the entry");
	MakeComm	(0X418A,	"free ; still avail?");
	MakeComm	(0X418E,	"entrysize ; set for next interrupt");
	MakeComm	(0X4194,	"[es:bp+savedsp],sp ; save sp value");
	MakeComm	(0X4198,	"[es:bp+savedss],ss ; save ss also");
	MakeComm	(0X419C,	"temp save of table offset");
	MakeComm	(0X419E,	"[es:bp+newsp] ; get new SP value");
	MakeComm	(0X41A2,	"check for offset into table");
	MakeComm	(0X41A8,	"point ss,sp to the new stack");
	MakeComm	(0X41BB,	"go execute the real interrupt handler");
	MakeComm	(0X41BC,	"which will iret back to here\ncall far [cs:bp]");
	MakeComm	(0X41C0,	"retrieve the table offset for us");
	MakeComm	(0X41C2,	"but leave it on the stack");
	MakeComm	(0X41C6,	"[es:bp+savedss] ; get old stack back");
	MakeComm	(0X41CA,	"[es:bp+savedsp]");
	MakeComm	(0X41CE,	"[es:bp+allocbyte],free ; free the entry");
	MakeComm	(0X41D3,	"setup to use next time");
	MakeComm	(0X41D8,	"saved on entry");
	MakeComm	(0X41D9,	"saved on entry");
	MakeComm	(0X41DA,	"saved on entry");
	MakeComm	(0X41DB,	"(skip near call return addr)");
	MakeCode	(x=0X41DB);
	OpHex		(x,	1);
	MakeComm	(0X41DE,	"done with this interrupt");
	MakeComm	(0X41DF,	"allocated ; error flag");
	MakeCode	(0X41DF);
	MakeComm	(0X41E1,	"no, continue");
	MakeComm	(0X41E3,	"[es:bp+allocbyte] ; yes, restore error value");
	MakeCode	(0X41EC);
	MakeComm	(0X41F3,	"flag this entry");
	MakeComm	(0X41F5,	"clobbered");
	MakeComm	(0X41FA,	"keep looking");
	MakeCode	(0X41FC);
	MakeName	(0X41FC,	"longpath");
	MakeComm	(0X4201,	"free ?");
	MakeComm	(0X4206,	"no, try next one");
	MakeComm	(0X420A,	"[es:bp+allocbyte] ; allocate entry");
	MakeComm	(0X420E,	"is it still free?");
	MakeComm	(0X4210,	"yes, go use it");
	MakeComm	(0X4212,	"allocated ?\nis it other than Allocated or Free?");
	MakeComm	(0X4214,	"no, check the next one");
	MakeComm	(0X4216,	"yes, put back the error state");
	MakeCode	(0X4226);
	MakeCode	(0X4227);
	MakeComm	(0X4228,	"look at the model byte");
	MakeComm	(0X422D,	"mdl_convert ; convertible?");
	MakeCode	(x=0X422D);
	OpHex		(x,	1);
	MakeComm	(0X4235,	"disable pc convertible nmis");
	MakeComm	(0X4237,	"CMOS Memory/RTC Index Register (Extended RAM)");
	MakeCode	(x=0X4237);
	OpHex		(x,	0);
	MakeComm	(0X4239,	"disable and mask");
	MakeComm	(0X423A,	"all other ints");
	MakeComm	(0X423C,	"Interrupt controller, 8259A.");
	MakeCode	(x=0X423C);
	OpHex		(x,	0);
	MakeComm	(0X423E,	"Interrupt Controller #2, 8259A");
	MakeCode	(x=0X423E);
	OpHex		(x,	0);
	MakeComm	(0X4244,	"'Internal stack overflow'\n     'System halted");
	MakeCode	(x=0X4244);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X4249,	"DOSBIODATASEG (BIOSDATA segment)");
	MakeCode	(x=0X4249);
	OpHex		(x,	1);
	MakeComm	(0X424E,	"BIOSDATA:08D0h");
	MakeCode	(x=0X424E);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X4257,	"call DOSBIODATASEG:V86_Crit_SetFocus");
	MakeCode	(x=0X4257);
	MakeComm	(0X4265,	"(whoops, this enables ints)\n- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)");
	MakeCode	(x=0X4265);
	OpHex		(x,	0);
	MakeCode	(0X4269);
	MakeByte	(0X426B);
	MakeName	(0X426B,	"fatal_msg");
	MakeByte	(0X426C);
	MakeStr		(0X426D,	0X4299);
	MakeCode	(0X4299);
	MakeName	(0X4299,	"_SYSINIT");
	MakeByte	(0X429C);
	MakeName	(0X429C,	"runhigh");
	MakeComm	(0X429D,	"address of the DOS Sysini Variables");
	MakeDword	(0X429D);
	MakeName	(0X429D,	"DOSINFO");
	MakeWord	(0X42A1);
	MakeName	(0X42A1,	"dosinit");
	MakeWord	(0X42A3);
	MakeName	(0X42A3,	"CURRENT_DOS_LOCATION");
	MakeDword	(0X42A5);
	MakeName	(0X42A5,	"DEVICE_LIST");
	MakeComm	(0X42A9,	"pointer to country table in dos");
	MakeDword	(0X42A9);
	MakeName	(0X42A9,	"sysi_country");
	MakeComm	(0X42AD,	"room for dword");
	MakeDword	(0X42AD);
	MakeName	(0X42AD,	"dos_segreinit");
	MakeComm	(0X42B1,	"dos code size when in low mem");
	MakeWord	(0X42B1);
	MakeName	(0X42B1,	"lo_doscod_size");
	MakeComm	(0X42B3,	"dos code size when in HMA");
	MakeWord	(0X42B3);
	MakeName	(0X42B3,	"hi_doscod_size");
	MakeWord	(0X42B5);
	MakeName	(0X42B5,	"def_php");
	MakeComm	(0X42B7,	"BIOSCODE:0032h");
	MakeWord	(x=0X42B7);
	OpOff		(x,	0,	0X25C0);
	OpOff		(x,	128,	0X25C0);
	MakeName	(0X42B7,	"_seg_reinit_ptr");
	MakeComm	(0X42B9,	"DOSBIOCODESEG (BIOSCODE)");
	MakeWord	(0X42B9);
	MakeName	(0X42B9,	"temp_bcode_seg");
	MakeComm	(0X42BB,	"set to 1 if this machine\ndoes not have any floppies!!!");
	MakeByte	(0X42BB);
	MakeName	(0X42BB,	"fake_floppy_drv");
	MakeComm	(0X42BC,	"defaultcount ; 9");
	MakeWord	(0X42BC);
	MakeName	(0X42BC,	"stack_count");
	MakeComm	(0X42BE,	"defaultsize  ; 128");
	MakeWord	(x=0X42BE);
	OpDecimal	(x,	0);
	MakeName	(0X42BE,	"stack_size");
	MakeWord	(0X42C0);
	MakeArray	(0X42C0,	0X2);
	MakeName	(0X42C0,	"stack_addr");
	MakeWord	(0X42C4);
	MakeName	(0X42C4,	"MEMORY_SIZE");
	MakeWord	(0X42C6);
	MakeName	(0X42C6,	"RPLMemTop");
	MakeComm	(0X42C8,	"initialized by ibminit");
	MakeByte	(0X42C8);
	MakeName	(0X42C8,	"DEFAULT_DRIVE");
	MakeComm	(0X42C9,	"initialized during buffer allocation");
	MakeWord	(0X42C9);
	MakeName	(0X42C9,	"buffers");
	MakeComm	(0X42CB,	"# of the heuristic buffers. initially 0.");
	MakeWord	(0X42CB);
	MakeName	(0X42CB,	"h_buffers");
	MakeComm	(0X42CD,	"maximum sector size + buffer head");
	MakeWord	(0X42CD);
	MakeName	(0X42CD,	"singlebuffersize");
	MakeComm	(0X42CF,	"enough files for pipe");
	MakeByte	(0X42CF);
	MakeName	(0X42CF,	"FILES");
	MakeComm	(0X42D0,	"performance for recycling");
	MakeByte	(0X42D0);
	MakeName	(0X42D0,	"FCBS");
	MakeComm	(0X42D1,	"keep original set");
	MakeByte	(0X42D1);
	MakeName	(0X42D1,	"KEEP");
	MakeComm	(0X42D2,	"5 net drives");
	MakeByte	(0X42D2);
	MakeName	(0X42D2,	"NUM_CDS");
	MakeWord	(0X42D3);
	MakeName	(0X42D3,	"CONFBOT");
	MakeWord	(0X42D5);
	MakeName	(0X42D5,	"ALLOCLIM");
	MakeWord	(0X42D7);
	MakeName	(0X42D7,	"top_of_cdss");
	MakeComm	(0X42D9,	"string for the root directory of a drive");
	MakeStr		(0X42D9,	0X42DD);
	MakeName	(0X42D9,	"DirStrng");
	MakeByte	(0X42DD);
	MakeName	(0X42DD,	"ZERO");
	MakeByte	(0X42DE);
	MakeName	(0X42DE,	"sepchr");
	MakeComm	(0X42DF,	"line count in config.sys");
	MakeWord	(0X42DF);
	MakeName	(0X42DF,	"linecount");
	MakeComm	(0X42E1,	"used to convert linecount to ascii.");
	MakeStr		(0X42E1,	0X42E9);
	MakeName	(0X42E1,	"showcount");
	MakeWord	(0X42E9);
	MakeName	(0X42E9,	"buffer_linenum");
	MakeComm	(0X42EB,	"model byte used in sysinit");
	MakeByte	(0X42EB);
	MakeName	(0X42EB,	"sys_model_byte");
	MakeComm	(0X42EC,	"secondary model byte used in sysinit");
	MakeByte	(0X42EC);
	MakeName	(0X42EC,	"sys_scnd_model_byte");
	MakeWord	(0X42ED);
	MakeName	(0X42ED,	"buf_prev_off");
	MakeComm	(0X42EF,	"COMEXE ; seg addr of environment");
	MakeWord	(0X42EF);
	MakeName	(0X42EF,	"EXEC0_ENVIRON");
	MakeComm	(0X42F1,	"pointer to asciz command line");
	MakeWord	(x=0X42F1);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X42F1,	"EXEC0_COM_LINE");
	MakeComm	(0X42F3,	"SYSINIT segment");
	MakeWord	(0X42F3);
	MakeWord	(x=0X42F5);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X42F5,	"EXEC0_5C_FCB");
	MakeComm	(0X42F7,	"SYSINIT segment");
	MakeWord	(0X42F7);
	MakeWord	(x=0X42F9);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X42F9,	"EXEC0_6C_FCB");
	MakeComm	(0X42FB,	"SYSINIT segment");
	MakeWord	(0X42FB);
	MakeComm	(0X42FD,	"parameter passed to multi_pass\nindicating the pass number\n 0 - do scan for DOS=HIGH/LOW\n 1 - load device drivers\n 2 - was to load IFS\n     now it is unused\n 3 - do install=\n>3 - nop");
	MakeByte	(0X42FD);
	MakeName	(0X42FD,	"multi_pass_id");
	MakeComm	(0X42FE,	"bit 0 - config.sys has install= commands\nbit 1 - sysinit_base installed");
	MakeWord	(0X42FE);
	MakeName	(0X42FE,	"install_flag");
	MakeComm	(0X4300,	"size of config.sys file");
	MakeWord	(0X4300);
	MakeName	(0X4300,	"config_size");
	MakeComm	(0X4302,	"pointer to sysinit_base");
	MakeDword	(0X4302);
	MakeName	(0X4302,	"sysinit_base_ptr");
	MakeComm	(0X4306,	"returning address from sysinit_base");
	MakeWord	(0X4306);
	MakeArray	(0X4306,	0X2);
	MakeName	(0X4306,	"sysinit_ptr");
	MakeWord	(0X430A);
	MakeName	(0X430A,	"checksum");
	MakeComm	(0X430C,	"db 20 dup (' ') ; big enough");
	MakeByte	(0X430C);
	MakeArray	(0X430C,	0X14);
	MakeName	(0X430C,	"ldexec_fcb");
	MakeComm	(0X4320,	"# of parm characters");
	MakeByte	(0X4320);
	MakeName	(0X4320,	"ldexec_line");
	MakeByte	(x=0X4321);
	OpChr		(x,	0);
	MakeName	(0X4321,	"ldexec_start");
	MakeComm	(0X4322,	"times 80 db 0");
	MakeByte	(x=0X4322);
	MakeArray	(x,	0X50);
	OpDecimal	(x,	0);
	MakeName	(0X4322,	"ldexec_parm");
	MakeComm	(0X4372,	"instexe ; seg addr of environment");
	MakeWord	(0X4372);
	MakeName	(0X4372,	"iexec_environ");
	MakeComm	(0X4374,	"pointer to asciiz command line");
	MakeWord	(x=0X4374);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X4374,	"iexec_ldexec_line");
	MakeWord	(0X4376);
	MakeName	(0X4376,	"iexec_ldexec_line_seg");
	MakeComm	(0X4378,	"default fcb at 5Ch");
	MakeWord	(x=0X4378);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X4378,	"iexec_ldexec_5c_fcb");
	MakeWord	(0X437A);
	MakeName	(0X437A,	"iexec_ldexec_5c_fcb_seg");
	MakeComm	(0X437C,	"default fcb at 6Ch");
	MakeWord	(x=0X437C);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X437C,	"iexec_ldexec_6c_fcb");
	MakeWord	(0X437E);
	MakeName	(0X437E,	"iexec_ldexec_6c_fcb_seg");
	MakeComm	(0X4380,	"level of \" \" in command line");
	MakeByte	(0X4380);
	MakeName	(0X4380,	"com_level");
	MakeComm	(0X4381,	"length of comment string token");
	MakeByte	(0X4381);
	MakeName	(0X4381,	"cmmt");
	MakeComm	(0X4382,	"token");
	MakeByte	(0X4382);
	MakeName	(0X4382,	"cmmt1");
	MakeComm	(0X4383,	"token");
	MakeByte	(0X4383);
	MakeName	(0X4383,	"cmmt2");
	MakeByte	(0X4384);
	MakeName	(0X4384,	"cmd_indicator");
	MakeByte	(0X4385);
	MakeName	(0X4385,	"donotshownum");
	MakeWord	(0X4386);
	MakeName	(0X4386,	"count");
	MakeWord	(0X4388);
	MakeName	(0X4388,	"org_count");
	MakeWord	(0X438A);
	MakeName	(0X438A,	"chrptr");
	MakeWord	(0X438C);
	MakeName	(0X438C,	"cntryfilehandle");
	MakeWord	(0X438E);
	MakeName	(0X438E,	"old_area");
	MakeComm	(0X4390,	"paragraph");
	MakeWord	(0X4390);
	MakeName	(0X4390,	"impossible_owner_size");
	MakeComm	(0X4392,	"bufptr, bucketptr (dword)");
	MakeWord	(0X4392);
	MakeName	(0X4392,	"memlo");
	MakeComm	(0X4394,	"prmblk (word)");
	MakeWord	(0X4394);
	MakeName	(0X4394,	"memhi");
	MakeWord	(0X4396);
	MakeName	(0X4396,	"ldoff");
	MakeWord	(0X4398);
	MakeName	(0X4398,	"area");
	MakeComm	(0X439A,	"was 22");
	MakeByte	(x=0X439A);
	OpDecimal	(x,	0);
	MakeName	(0X439A,	"packet");
	MakeByte	(0X439B);
	MakeComm	(0X439C,	"initialize code");
	MakeByte	(0X439C);
	MakeWord	(0X439D);
	MakeByte	(0X439F);
	MakeArray	(0X439F,	0X8);
	MakeByte	(0X43A7);
	MakeName	(0X43A7,	"unitcount");
	MakeWord	(0X43A8);
	MakeArray	(0X43A8,	0X2);
	MakeName	(0X43A8,	"break_addr");
	MakeDword	(0X43AC);
	MakeName	(0X43AC,	"bpb_addr");
	MakeByte	(0X43B0);
	MakeName	(0X43B0,	"devdrivenum");
	MakeComm	(0X43B1,	"used to control \"error in config.sys line #\" message\n(configmsgflag is the last word of the 25 byte packet)\n((default value is 0, device driver init may change? it))");
	MakeByte	(x=0X43B1);
	OpDecimal	(x,	0);
	MakeName	(0X43B1,	"configmsgflag");
	MakeByte	(0X43B2);
	MakeByte	(0X43B3);
	MakeName	(0X43B3,	"drivenumber");
	MakeComm	(0X43B4,	">24 fixed disk partitions flag");
	MakeByte	(0X43B4);
	MakeName	(0X43B4,	"toomanydrivesflag");
	MakeComm	(0X43B5,	"DOSBIOCODESEG (BIOSCODE segment)");
	MakeWord	(0X43B5);
	MakeName	(0X43B5,	"BCodeSeg");
	MakeDword	(0X43B7);
	MakeName	(0X43B7,	"Magicbackdoor");
	MakeCode	(0X43BB);
	MakeName	(0X43BB,	"NullBackdoor");
	MakeWord	(0X43BC);
	MakeName	(0X43BC,	"_timer_lw_");
	MakeComm	(0X43BE,	"BIOSDATA:08FDh");
	MakeWord	(x=0X43BE);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeName	(0X43BE,	"BiosComBlock");
	MakeComm	(0X43C0,	"BIOSDATA segment");
	MakeWord	(0X43C0);
	MakeByte	(x=0X43C2);
	MakeArray	(x,	0X80);
	OpDecimal	(x,	0);
	MakeName	(0X43C2,	"tempstack");
	MakeCode	(x=0X4442);
	OpHex		(x,	1);
	MakeName	(0X4442,	"goinit");
	MakeComm	(0X4444,	"SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)");
	MakeCode	(x=0X4444);
	OpHex		(x,	0);
	MakeComm	(0X444D,	"[es:bx+ROMBIOS_DESC.bios_sd_modelbyte]");
	MakeComm	(0X4455,	"[es:bx+ROMBIOS_DESC.bios_sd_scnd_modelbyte]");
	MakeCode	(0X445F);
	MakeName	(0X445F,	"no_rom_config");
	MakeComm	(0X446B,	"EQUIPMENT DETERMINATION\nReturn: AX = equipment flag bits");
	MakeCode	(x=0X446B);
	OpHex		(x,	0);
	MakeComm	(0X446D,	"have any floppies?");
	MakeCode	(x=0X446D);
	OpHex		(x,	1);
	MakeComm	(0X4470,	"yes,normal system");
	MakeComm	(0X4475,	"get disk parameters");
	MakeComm	(0X4479,	"DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)\nDL = drive number\nReturn: CF set on error, AH = status code, BL = drive type\nDL = number of consecutive drives\nDH = maximum value for head number, ES:DI -> drive parameter");
	MakeCode	(x=0X4479);
	OpHex		(x,	0);
	MakeComm	(0X447C,	"if error lets assume that the ROM BIOS lied");
	MakeComm	(0X447E,	"double check (max sec no cannot be 0)");
	MakeComm	(0X4483,	"number of flp drvs == 0?");
	MakeComm	(0X4487,	"set fake flag");
	MakeComm	(0X448D,	"set up move");
	MakeName	(0X448D,	"move_myself");
	MakeComm	(0X449C,	"0");
	MakeComm	(0X449E,	"Int 2Fh vector (4*2Fh)");
	MakeCode	(x=0X449E);
	MakeCode	(x=0X44A3);
	MakeComm	(0X44A8,	"'RP'");
	MakeCode	(x=0X44A8);
	OpHex		(x,	1);
	MakeComm	(0X44B0,	"'L'");
	MakeCode	(x=0X44B0);
	OpHex		(x,	1);
	MakeComm	(0X44B7,	"get TOM into DX");
	MakeComm	(0X44BA,	"(multMULT<<8)+multMULTRPLTOM");
	MakeComm	(0X44BD,	"Get new TOM from any RPL");
	MakeCode	(x=0X44BD);
	OpHex		(x,	0);
	MakeComm	(0X44CC,	"SI_end ; need this much room for sysinit\n(SI_end == sysinit code size)");
	MakeName	(0X44CC,	"NoRPL");
	MakeComm	(0X44D4,	"DOSSIZE/16 (2560)\nleave this much room for DOS");
	MakeComm	(0X44D8,	"BCODE_END");
	MakeComm	(0X44DB,	"leave this much room for BIOS code");
	MakeComm	(0X44E0,	"offset where sysinit will be located");
	MakeComm	(0X44E2,	"SI_end ; (sysinit code size)");
	MakeComm	(0X44E5,	"divide by 2 to get words");
	MakeCode	(x=0X44E5);
	OpHex		(x,	1);
	MakeComm	(0X44E7,	"relocate sysinit");
	MakeComm	(0X44E9,	"push relocated segment");
	MakeComm	(0X44EA,	"SYSINIT:048Fh");
	MakeCode	(x=0X44EA);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X44ED,	"push relocated entry point");
	MakeComm	(0X44EE,	"far jump to relocated sysinit");
	MakeCode	(x=0X44EF);
	OpHex		(x,	1);
	MakeName	(0X44EF,	"SYSIN");
	MakeComm	(0X44F4,	"set seg of routine to move DOS\nupdate SYSINITSEG field\nMoveDOSIntoHMA+2");
	MakeCode	(x=0X44F4);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X44F8,	"flag that MoveDOSIntoHMA can be called");
	MakeCode	(x=0X44F8);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X44FD,	"SI_end ; how big is sysinitseg?");
	MakeComm	(0X4503,	"pick a buffer for msdos above us");
	MakeComm	(0X450D,	"where it is (set by msinit)");
	MakeComm	(0X4512,	"DOSSIZE/2 (20480)");
	MakeComm	(0X451C,	"get offset of dos\nax = 3DE0h for MSDOS 6.21 kernel\n (MSDOS.SYS, offset 3)");
	MakeComm	(0X4523,	"subtract this much from segment");
	MakeComm	(0X4526,	"FINAL_DOS_LOCATION");
	MakeComm	(0X452D,	"DOSSIZE/16 ; DOSSIZE = 0A000h = 40960");
	MakeComm	(0X4532,	"swap with original home of Bios_Code");
	MakeComm	(0X4537,	"point to loaded image of Bios_Code");
	MakeComm	(0X4539,	"BCODESTART (= BiosDataWord)\nBIOSCODE:BCODESTART (BIOSCODE:0030h)");
	MakeCode	(x=0X4539);
	OpOff		(x,	1,	0X25C0);
	OpOff		(x,	129,	0X25C0);
	MakeComm	(0X453E,	"BCODE_END = (SYSINITSEG-DOSBIOCODESEG)*16\n(473h-2CCh)*10h = 1A70h (for MSDOS 6.21 IO.SYS)");
	MakeCode	(x=0X4543);
	OpHex		(x,	1);
	MakeComm	(0X4545,	"move Bios_Code into place");
	MakeComm	(0X4547,	"tell it what segment it's in");
	MakeCode	(x=0X4549);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X4562,	"set stack\nmov sp, 532h ; mov sp, locstack\n%define locstack ($ - SYSINIT$) & 0FFFEh\nlocstack = $ & 0FFFEh (SYSINIT:SYSINIT=473h:0)");
	MakeCode	(x=0X4562);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeName	(0X4562,	"locstack");
	MakeComm	(0X4566,	"call dosinit\nes:di -> sysinitvars_ext");
	MakeComm	(0X456B,	"save pointer to PSP");
	MakeComm	(0X4570,	"size of doscode (including exepatch)");
	MakeComm	(0X4574,	"(as exepatch excluded)");
	MakeComm	(0X4579,	"save offset of segreinit");
	MakeComm	(0X457E,	"[es:di+SysInitVars_Ext.SYSI_InitVars]");
	MakeComm	(0X4585,	"[es:di+SysInitVars_Ext.SYSI_InitVars+2]");
	MakeComm	(0X458D,	"[es:di+SysInitVars_Ext.SYSI_Country_Tab]");
	MakeComm	(0X4595,	"[es:di+SysInitVars_Ext.SYSI_Country_Tab+2]");
	MakeComm	(0X459D,	"= [FINAL_DOS_LOCATION]");
	MakeCode	(x=0X45B2);
	OpHex		(x,	1);
	MakeComm	(0X45B4,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired");
	MakeCode	(x=0X45B4);
	OpHex		(x,	0);
	MakeCode	(x=0X45B6);
	OpHex		(x,	1);
	MakeComm	(0X45B8,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired");
	MakeCode	(x=0X45B8);
	OpHex		(x,	0);
	MakeComm	(0X45BC,	"resize upto RPL mem");
	MakeCode	(x=0X45C7);
	OpHex		(x,	1);
	MakeComm	(0X45C9,	"DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)\nES = segment address of block to change\nBX = new size in paragraphs");
	MakeCode	(x=0X45C9);
	OpHex		(x,	0);
	MakeCode	(x=0X45CE);
	OpHex		(x,	1);
	MakeComm	(0X45D0,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired");
	MakeCode	(x=0X45D0);
	OpHex		(x,	0);
	MakeCode	(x=0X45D2);
	OpHex		(x,	1);
	MakeComm	(0X45D4,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired");
	MakeCode	(x=0X45D4);
	OpHex		(x,	0);
	MakeComm	(0X45D9,	"[es:arena_owner]");
	MakeComm	(0X45E0,	"[es:arena_name],'RP'");
	MakeCode	(x=0X45E0);
	OpHex		(x,	1);
	MakeComm	(0X45E7,	"[es:arena_name+2],'L'");
	MakeCode	(x=0X45E7);
	OpHex		(x,	1);
	MakeComm	(0X45EE,	"[es:arena_name+4]");
	MakeComm	(0X45F5,	"[es:arena_name+6]");
	MakeCode	(x=0X45FD);
	OpHex		(x,	1);
	MakeComm	(0X45FF,	"DOS - 2+ - FREE MEMORY\nES = segment address of area to be freed");
	MakeCode	(x=0X45FF);
	OpHex		(x,	0);
	MakeName	(0X4601,	"NoRPLArena");
	MakeCode	(x=0X4607);
	OpHex		(x,	1);
	MakeComm	(0X4609,	"EXTENDED MEMORY - GET MEMORY SIZE (AT,XT286,PS)\nReturn: AX = memory size in K");
	MakeCode	(x=0X4609);
	OpHex		(x,	0);
	MakeComm	(0X460D,	"[es:di+SYSI_EXT_MEM],ax\nsave extended memory size");
	MakeComm	(0X4618,	"[es:di+SYSI_MAXSEC] ; get the sector size");
	MakeName	(0X4618,	"no_ext_memory");
	MakeComm	(0X461C,	"bufinsiz ; size of buffer header");
	MakeCode	(x=0X461C);
	OpDecimal	(x,	1);
	MakeComm	(0X4627,	"[es:di+SYSI_BOOT_DRIVE]");
	MakeName	(0X462B,	"_get_cpu_type:");
	MakeCode	(x=0X4635);
	OpHex		(x,	1);
	MakeCode	(x=0X4644);
	OpHex		(x,	1);
	MakeName	(0X4649,	"_cpu_386");
	MakeName	(0X464A,	"_cpu_286");
	MakeName	(0X464B,	"_cpu_8086");
	MakeComm	(0X4654,	"[es:di+SYSI_DWMOVE],1 \nset doubleword moving flag");
	MakeComm	(0X4659,	"[es:di+SYSI_NUMIO]");
	MakeName	(0X4659,	"_not_386_cpu");
	MakeComm	(0X465D,	"save start of installable block drvs");
	MakeComm	(0X4663,	"room for PSP we will copy shortly");
	MakeComm	(0X4666,	"temporary single buffer area");
	MakeCode	(x=0X466B);
	OpHex		(x,	1);
	MakeCode	(x=0X466D);
	OpHex		(x,	1);
	MakeCode	(x=0X466F);
	OpHex		(x,	1);
	MakeComm	(0X4671,	"divide size by 16..\n...to get paragraphs...");
	MakeCode	(x=0X4671);
	OpHex		(x,	1);
	MakeComm	(0X4673,	"... and round up");
	MakeComm	(0X4676,	"temp \"unsafe\" location");
	MakeComm	(0X467C,	"save pointer for buffer");
	MakeComm	(0X467E,	"sub ax,((26 *(curdirlen))+15)/16\n(curdirlen=88)");
	MakeCode	(x=0X467E);
	OpDecimal	(x,	1);
	MakeComm	(0X4689,	"[es:di+SYSI_BUF]");
	MakeComm	(0X468D,	"[es:di+BUFFINF.Dirty_Buff_Count]");
	MakeComm	(0X4693,	"[es:di+BUFFINF.Buff_Queue]");
	MakeComm	(0X4698,	"[es:di+BUFFINF.Buff_Queue+2]\ncx = [top_of_cdss]");
	MakeComm	(0X46A2,	"[es:di+buffinfo.buf_next],0");
	MakeComm	(0X46A5,	"[es:di+buffinfo.buf_prev],0");
	MakeComm	(0X46A9,	"[es:di+buffinfo.buf_ID],00FFh\nfree buffer,clear flag");
	MakeComm	(0X46AF,	"[es:di+buffinfo.buf_sector]");
	MakeComm	(0X46B5,	"[es:di+buffinfo.buf_sector+2]");
	MakeComm	(0X46BF,	"set up cdss so re_init and sysinit\ncan make disk system calls\ntempcds trashes ds");
	MakeComm	(0X46C2,	"retrieve pointer to PSP returned by DOSINIT");
	MakeComm	(0X46C7,	"call DOSBIODATASEG:re_init");
	MakeCode	(x=0X46C7);
	MakeCode	(x=0X46D9);
	OpDecimal	(x,	1);
	MakeComm	(0X46DE,	"[es:PDB.JFN_POINTER+2],es ; Relocate");
	MakeCode	(x=0X46DE);
	MakeCode	(x=0X46E3);
	OpHex		(x,	1);
	MakeComm	(0X46E5,	"DOS - 2+ internal - SET PSP SEGMENT\nBX = segment address of new PSP");
	MakeCode	(x=0X46E5);
	OpHex		(x,	0);
	MakeComm	(0X46EA,	"set up int 24h handler");
	MakeCode	(x=0X46EA);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X46ED);
	OpHex		(x,	1);
	MakeComm	(0X46F0,	"DOS - SET INTERRUPT VECTOR\nAL = interrupt number\nDS:DX = new vector to be used for specified interrupt");
	MakeCode	(x=0X46F0);
	OpHex		(x,	0);
	MakeCode	(x=0X46F9);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeName	(0X46FF,	"no_err");
	MakeCode	(x=0X470B);
	OpHex		(x,	1);
	MakeComm	(0X470D,	"DOS - SELECT DISK\nDL = new default drive number (0 = A, 1 = B, etc.)\nReturn: AL = number of logical drives");
	MakeCode	(x=0X470D);
	OpHex		(x,	0);
	MakeName	(0X470F,	"nodrvset");
	MakeComm	(0X4712,	"0 ; ROMBIOS data area");
	MakeComm	(0X4714,	"Counter for Interrupt 1Ah\ntimer tick count (18.2 ticks per second)");
	MakeCode	(x=0X4714);
	MakeCode	(x=0X471C);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X4728,	"get the largest free block from DOS");
	MakeComm	(0X472B,	"**** PRE-LOAD MAGICDRV!!! ****");
	MakeCode	(x=0X4741);
	OpHex		(x,	1);
	MakeComm	(0X4743,	"DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)\nES = segment address of block to change\nBX = new size in paragraphs");
	MakeCode	(x=0X4743);
	OpHex		(x,	0);
	MakeComm	(0X474A,	"[es:arena_owner], 8 ; set impossible owner");
	MakeComm	(0X4751,	"[es:arena_name],'SD' ; System Data");
	MakeComm	(0X4758,	"get Magicdrv arena");
	MakeComm	(0X475A,	"get MCB length");
	MakeComm	(0X475F,	"get addr of next MCB");
	MakeComm	(0X4760,	"get to arena header");
	MakeComm	(0X4765,	"store that");
	MakeComm	(0X476B,	"Dealloc ; free the block if no load");
	MakeCode	(x=0X476B);
	OpHex		(x,	1);
	MakeName	(0X476B,	"PreloadFailed");
	MakeComm	(0X4772,	"DOS - 2+ - FREE MEMORY\nES = segment address of area to be freed");
	MakeCode	(x=0X4772);
	OpHex		(x,	0);
	MakeName	(0X4774,	"ProcessConfig");
	MakeCode	(0X478D);
	MakeName	(0X478D,	"dont_install_stub");
	MakeName	(0X479F,	"do_multi_pass");
	MakeComm	(0X47A2,	"magic backdoor to place int hooks");
	MakeCode	(x=0X47C9);
	OpHex		(x,	1);
	MakeCode	(x=0X47CE);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X47D4);
	OpHex		(x,	1);
	MakeName	(0X47E5,	"dolast");
	MakeName	(0X47F0,	"_@@_");
	MakeName	(0X47FB,	"ConfigDone");
	MakeComm	(0X4806,	"DEALLOC ; free allocated memory for command.com");
	MakeCode	(x=0X4806);
	OpHex		(x,	1);
	MakeComm	(0X4808,	"DOS - 2+ - FREE MEMORY\nES = segment address of area to be freed");
	MakeCode	(x=0X4808);
	OpHex		(x,	0);
	MakeComm	(0X480A,	"has_installed");
	MakeCode	(x=0X480A);
	OpHex		(x,	1);
	MakeComm	(0X4811,	"no");
	MakeCode	(x=0X481F);
	OpHex		(x,	1);
	MakeComm	(0X4821,	"DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)\nES = segment address of block to change\nBX = new size in paragraphs");
	MakeCode	(x=0X4821);
	OpHex		(x,	0);
	MakeComm	(0X4826,	"point to arena");
	MakeComm	(0X4828,	"[es:ARENA.OWNER],8 ; set impossible owner");
	MakeComm	(0X482F,	"[es:ARENA.NAME],'SD' ; System Data");
	MakeName	(0X4838,	"skip_free_sysinitbase");
	MakeComm	(0X4840,	"Install VDISK header (allocates some mem from DOS)");
	MakeName	(0X4843,	"_@@@_");
	MakeComm	(0X4845,	"set special code for query_user");
	MakeComm	(0X484A,	"to issue the AUTOEXEC prompt");
	MakeComm	(0X484D,	"we should process autoexec normally");
	MakeComm	(0X484F,	"set \"skip all\" flag");
	MakeCode	(x=0X484F);
	OpHex		(x,	1);
	MakeComm	(0X4854,	"no, we should disable it");
	MakeName	(0X4857,	"process_autoexec");
	MakeCode	(x=0X4861);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X4866,	"cr-terminate command line");
	MakeCode	(x=0X4869);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeName	(0X4869,	"retry");
	MakeComm	(0X486C,	"save pointer to file name");
	MakeComm	(0X486D,	"get biggest piece (second time gets it)");
	MakeCode	(x=0X4870);
	OpHex		(x,	1);
	MakeComm	(0X4872,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired");
	MakeCode	(x=0X4872);
	OpHex		(x,	0);
	MakeCode	(x=0X4874);
	OpHex		(x,	1);
	MakeComm	(0X4876,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired");
	MakeCode	(x=0X4876);
	OpHex		(x,	0);
	MakeComm	(0X4878,	"oooops!");
	MakeCode	(x=0X487C);
	OpHex		(x,	1);
	MakeComm	(0X487E,	"DOS - 2+ - FREE MEMORY\nES = segment address of area to be freed");
	MakeCode	(x=0X487E);
	OpHex		(x,	0);
	MakeComm	(0X4882,	"get location of end of memory");
	MakeComm	(0X4886,	"get location of beginning of sysinit");
	MakeComm	(0X488C,	"use config_wrkseg only if there's env data");
	MakeName	(0X4891,	"no_env");
	MakeComm	(0X4893,	"add the sysinit php");
	MakeComm	(0X4896,	"sub sysinit size from amount of free memory");
	MakeComm	(0X4898,	"if there isn't even this much memory, give up");
	MakeComm	(0X489E,	"DOS - 2+ - OPEN DISK FILE WITH HANDLE\nDS:DX -> ASCIZ filename\nAL = access mode\n0 - read");
	MakeCode	(x=0X489E);
	OpHex		(x,	0);
	MakeComm	(0X48A4,	"was a new shell selected?");
	MakeComm	(0X48A9,	"yes");
	MakeComm	(0X48AB,	"SYSINIT:0835h");
	MakeCode	(x=0X48AB);
	MakeCode	(x=0X48B1);
	OpHex		(x,	1);
	MakeComm	(0X48B3,	"DOS - 2+ - READ FROM FILE WITH HANDLE\nBX = file handle, CX = number of bytes to read\nDS:DX -> buffer");
	MakeCode	(x=0X48B3);
	OpHex		(x,	0);
	MakeCode	(x=0X48B5);
	OpHex		(x,	1);
	MakeComm	(0X48BC,	"COMMAND.COM Version 6.20  (not 6.21!)\n((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)");
	MakeCode	(x=0X48BC);
	OpHex		(x,	1);
	MakeName	(0X48C3,	"skip_validation");
	MakeComm	(0X48CB,	"DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)\nAL = method: offset from end of file");
	MakeCode	(x=0X48CB);
	OpHex		(x,	0);
	MakeComm	(0X48CF,	"convert size in dx:ax to para in ax");
	MakeComm	(0X48D2,	"round up size for conversion to para");
	MakeCode	(x=0X48D8);
	OpDecimal	(x,	1);
	MakeComm	(0X48DA,	"low nibble of dx to high nibble");
	MakeComm	(0X48DC,	"ax is now # of para for file");
	MakeComm	(0X48DE,	"100h byte php");
	MakeComm	(0X48E1,	"will command fit in available mem?");
	MakeComm	(0X48E3,	"jump if yes.");
	MakeCode	(x=0X48E5);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeName	(0X48E5,	"memerrjx");
	MakeCode	(x=0X48ED);
	OpHex		(x,	1);
	MakeName	(0X48ED,	"okld");
	MakeComm	(0X48EF,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle");
	MakeCode	(x=0X48EF);
	OpHex		(x,	0);
	MakeComm	(0X48F3,	"offset COMEXE\npoint to exec block");
	MakeCode	(x=0X48F3);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X4901,	"set segments\n[bx+EXEC0.ENVIRON],cx");
	MakeName	(0X4901,	"no_envdata");
	MakeComm	(0X4903,	"[bx+EXEC0.COM_LINE+2],cs");
	MakeComm	(0X4906,	"[bx+EXEC0.5C_FCB+2],cs");
	MakeComm	(0X4909,	"[bx+EXEC0.6C_FCB+2],cs");
	MakeComm	(0X490C,	"(EXEC<<8)");
	MakeComm	(0X4910,	"DOS - 2+ - LOAD OR EXECUTE (EXEC)\nDS:DX -> ASCIZ filename\nES:BX -> parameter block\nAL = subfunc: load & execute program");
	MakeCode	(x=0X4910);
	OpHex		(x,	0);
	MakeName	(0X4915,	"comerr");
	MakeComm	(0X491A,	"all defaults exhausted, print err msg");
	MakeComm	(0X4921,	"don't print err msg for defaults just yet");
	MakeCode	(x=0X4923);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeName	(0X4923,	"comerr2");
	MakeName	(0X4929,	"continue");
	MakeCode	(x=0X492A);
	OpHex		(x,	1);
	MakeComm	(0X492C,	"DOS - GET DEFAULT DISK NUMBER");
	MakeCode	(x=0X492C);
	OpHex		(x,	0);
	MakeCode	(x=0X492E);
	OpChr		(x,	1);
	MakeComm	(0X4930,	"dl == default drive letter");
	MakeCode	(x=0X4932);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X4935,	"if a SHELL= was given");
	MakeComm	(0X493A,	"then try the 2nd alternate;");
	MakeComm	(0X493C,	"otherwise, the default SHELL= was tried,");
	MakeComm	(0X493F,	"which is the same as our 2nd alt, so skip it");
	MakeComm	(0X4941,	"has 2nd alternate been tried?");
	MakeCode	(0X4941);
	MakeName	(0X4941,	"do_def2");
	MakeComm	(0X4944,	"no");
	MakeCode	(x=0X4946);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeName	(0X4946,	"do_def3");
	MakeComm	(0X4949,	"has 3rd alternate been tried?");
	MakeComm	(0X494C,	"no");
	MakeCode	(x=0X494E);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X4951,	"has 4th alternate been tried?");
	MakeComm	(0X4954,	"no");
	MakeCode	(x=0X4957);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X495D,	"recover default drive letter in dl");
	MakeComm	(0X495E,	"STD_CON_OUTPUT");
	MakeCode	(x=0X495E);
	OpHex		(x,	1);
	MakeName	(0X495E,	"request_input");
	MakeComm	(0X4960,	"DOS - DISPLAY OUTPUT\nDL = character to send to standard output");
	MakeCode	(x=0X4960);
	OpHex		(x,	0);
	MakeComm	(0X4963,	"3Eh");
	MakeCode	(x=0X4963);
	OpChr		(x,	1);
	MakeComm	(0X4965,	"DOS - DISPLAY OUTPUT\nDL = character to send to standard output");
	MakeCode	(x=0X4965);
	OpHex		(x,	0);
	MakeComm	(0X4967,	"[tmplate] = max. chars buffer can hold = 64");
	MakeCode	(x=0X4967);
	OpDecimal	(x,	1);
	MakeCode	(x=0X496D);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X4972);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X4975,	"STD_CON_STRING_INPUT");
	MakeCode	(x=0X4975);
	OpHex		(x,	1);
	MakeComm	(0X4977,	"DOS - BUFFERED KEYBOARD INPUT\nDS:DX -> buffer");
	MakeCode	(x=0X4977);
	OpHex		(x,	0);
	MakeCode	(x=0X4979);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X4984,	"was anything typed?");
	MakeComm	(0X4988,	"disable validation for user-specified binaries");
	MakeComm	(0X498D,	"NULL-terminate it before execing it");
	MakeCode	(x=0X498D);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X499A);
	MakeName	(0X499A,	"do_alt");
	MakeComm	(0X499C,	"force validation for alternate binaries");
	MakeCode	(x=0X49A1);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X49A4,	"copy the alternate, zapping it as we go");
	MakeName	(0X49A4,	"do_alt1");
	MakeComm	(0X49A5,	"so that we know it's been tried");
	MakeCode	(x=0X49AE);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X49B1);
	OpChr		(x,	1);
	MakeComm	(0X49B7,	"stuff default drive into alt. command line");
	MakeName	(0X49BA,	"do_alt2");
	MakeComm	(0X49C0,	"cr");
	MakeName	(0X49CF,	"do_exec");
	MakeCode	(0X49D2);
	MakeName	(0X49D2,	"AllocFreeMem");
	MakeCode	(x=0X49D5);
	OpHex		(x,	1);
	MakeComm	(0X49D7,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired");
	MakeCode	(x=0X49D7);
	OpHex		(x,	0);
	MakeCode	(x=0X49D9);
	OpHex		(x,	1);
	MakeComm	(0X49DB,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired");
	MakeCode	(x=0X49DB);
	OpHex		(x,	0);
	MakeStr		(0X49E6,	0X4A0B);
	MakeName	(0X49E6,	"DOSLOMSG");
	MakeStr		(0X4A0B,	0X4A39);
	MakeName	(0X4A0B,	"FEmsg");
	MakeComm	(0X4A39,	"Try moving it into HMA");
	MakeCode	(0X4A39);
	MakeName	(0X4A39,	"LoadDOSHiOrLo");
	MakeComm	(0X4A3C,	"If that don't work...");
	MakeCode	(0X4A3F);
	MakeCode	(x=0X4A43);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X4A46,	"DOS - PRINT STRING\nDS:DX -> string terminated by \"$\"");
	MakeCode	(x=0X4A46);
	OpHex		(x,	0);
	MakeComm	(0X4A48,	"use int 21 alloc for mem");
	MakeComm	(0X4A4E,	"give dos its temporary loc.");
	MakeComm	(0X4A5A,	"mark that we are running lo");
	MakeCode	(0X4A61);
	MakeName	(0X4A61,	"TryToMovDOSHi");
	MakeComm	(0X4A66,	"give dos its temporary loc.");
	MakeComm	(0X4A6B,	"ax = 0 --> install stub");
	MakeComm	(0X4A7A,	"did we get HMA?");
	MakeCode	(0X4A7A);
	MakeName	(0X4A7A,	"MovDOSHi");
	MakeComm	(0X4A7D,	"no");
	MakeComm	(0X4A7F,	"yes, HMA seg = 0ffffh");
	MakeComm	(0X4A84,	"First move BIOS into HMA");
	MakeComm	(0X4A87,	"when it is in HMA");
	MakeComm	(0X4A8C,	"and move it");
	MakeComm	(0X4A94,	"incestuosly!");
	MakeCode	(0X4A94);
	MakeName	(0X4A94,	"MovDOSLo");
	MakeComm	(0X4A97,	"pass the segment to MovBIOS");
	MakeComm	(0X4A9C,	"DOS code size when loaded");
	MakeCode	(0X4AA5);
	MakeName	(0X4AA5,	"MovBIOS");
	MakeComm	(0X4AAA,	"BCODE_START");
	MakeCode	(x=0X4AAA);
	OpHex		(x,	1);
	MakeComm	(0X4AAF,	"BCODE_END");
	MakeComm	(0X4AB2,	"size of BIOS");
	MakeComm	(0X4AB4,	"Both the labels are para aligned");
	MakeCode	(x=0X4AB4);
	OpHex		(x,	1);
	MakeComm	(0X4AB9,	"save end of BIOS");
	MakeComm	(0X4ABC,	"save it for later use");
	MakeComm	(0X4AC0,	"far call to seg_reinit\ncall far [cs:seg_reinit_ptr]");
	MakeComm	(0X4AC5,	"get back end of BIOS");
	MakeCode	(0X4AC8);
	MakeName	(0X4AC8,	"MovDOS");
	MakeComm	(0X4AD1,	"get back offset into which DOS was moved");
	MakeComm	(0X4AD2,	"get the offset at which DOS wants to run");
	MakeComm	(0X4ADB,	"get the segment at which we moved DOS into");
	MakeComm	(0X4ADC,	"Adjust segment");
	MakeComm	(0X4ADE,	"and save it");
	MakeComm	(0X4AE4,	"BCODE_END");
	MakeCode	(0X4AE4);
	MakeName	(0X4AE4,	"AllocMemForDOS");
	MakeComm	(0X4AE7,	"BCODE_START\nBCODE_END-BCODE_START = BIOS code size");
	MakeCode	(x=0X4AE7);
	OpHex		(x,	1);
	MakeComm	(0X4AF2,	"convert to para");
	MakeComm	(0X4AF5,	"can we use int 21h for alloc ?");
	MakeComm	(0X4AF9,	"no");
	MakeCode	(x=0X4AFB);
	OpHex		(x,	1);
	MakeComm	(0X4AFD,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired");
	MakeCode	(x=0X4AFD);
	OpHex		(x,	0);
	MakeComm	(0X4B01,	"Take care ORG 30h of BIOS code");
	MakeComm	(0X4B06,	"[es:20h+ARENA.OWNER],08h");
	MakeComm	(0X4B0D,	"'SC' ; mark it as system code area");
	MakeCode	(0X4B15);
	MakeComm	(0X4B19,	"get ptr to DOS var");
	MakeComm	(0X4B1F,	"Arena head is immediately before sysvar");
	MakeComm	(0X4B20,	"es = arena head");
	MakeComm	(0X4B22,	"[es:ARENA.SIZE] ; total low mem size");
	MakeComm	(0X4B27,	"is it sufficient ?");
	MakeComm	(0X4B29,	"no, fatal error");
	MakeComm	(0X4B2B,	"[es:ARENA.SIGNATURE]");
	MakeComm	(0X4B32,	"ax = new arena head");
	MakeComm	(0X4B34,	"store it in DOS data area");
	MakeComm	(0X4B38,	"[ARENA.SIGNATURE] ; type of arena");
	MakeComm	(0X4B3C,	"[ARENA.OWNER],0 ; free");
	MakeComm	(0X4B42,	"size of the new block");
	MakeComm	(0X4B44,	"[ARENA.SIZE],cx ; store it in the arena");
	MakeComm	(0X4B48,	"return seg to the caller");
	MakeComm	(0X4B4A,	"Take care ORG 30h of BIOS code");
	MakeCode	(0X4B52);
	MakeCode	(x=0X4B54);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X4B57);
	OpHex		(x,	1);
	MakeComm	(0X4B59,	"DOS - PRINT STRING\nDS:DX -> string terminated by \"$\"");
	MakeCode	(x=0X4B59);
	OpHex		(x,	0);
	MakeCode	(0X4B5E);
	MakeName	(0X4B5E,	"AllocHMA");
	MakeComm	(0X4B5F,	"DOSBIODATASEG ; BIOSDATA segment");
	MakeCode	(x=0X4B5F);
	OpHex		(x,	1);
	MakeComm	(0X4B6C,	"- Multiplex - XMS - GET DRIVER ADDRESS\nReturn: ES:BX -> driver entry point");
	MakeCode	(x=0X4B6C);
	OpHex		(x,	0);
	MakeCode	(x=0X4B6E);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X4B72);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X4B76,	"request HMA");
	MakeComm	(0X4B7B,	"call far [xms]");
	MakeCode	(x=0X4B7B);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X4B80,	"error if not able to allocate HMA");
	MakeCode	(x=0X4B82);
	OpHex		(x,	1);
	MakeComm	(0X4B84,	"Get Extended Memory Size\nReturn: CF clear on success\nAX = size of memory above 1M in K");
	MakeCode	(x=0X4B84);
	OpHex		(x,	0);
	MakeComm	(0X4B86,	"less than 64 K of hma ?");
	MakeCode	(x=0X4B86);
	OpDecimal	(x,	1);
	MakeComm	(0X4B8B,	"localenableA20");
	MakeCode	(x=0X4B8D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X4B92,	"error if couldn't enable A20");
	MakeComm	(0X4B97,	"yes, we cant use HMA");
	MakeComm	(0X4B9E,	"see if we can really read/write there");
	MakeCode	(x=0X4B9E);
	MakeCode	(x=0X4BA5);
	MakeComm	(0X4BAC,	"don't try to load there if XMS lied");
	MakeCode	(0X4BB1);
	MakeCode	(0X4BB4);
	MakeName	(0X4BB4,	"IsXMSLoaded");
	MakeComm	(0X4BB7,	"- Multiplex - XMS - INSTALLATION CHECK\nReturn: AL = 80h XMS driver installed\nAL <> 80h no driver");
	MakeCode	(x=0X4BB7);
	OpHex		(x,	0);
	MakeComm	(0X4BB9,	"XMS installed?");
	MakeCode	(x=0X4BB9);
	OpHex		(x,	1);
	MakeCode	(0X4BBC);
	MakeName	(0X4BBC,	"FTryToMovDOSHi");
	MakeCode	(x=0X4BC4);
	OpHex		(x,	1);
	MakeName	(0X4BCF,	"_ftymdh_1");
	MakeComm	(0X4BD8,	"link to next device driver");
	MakeDword	(0X4BD8);
	MakeName	(0X4BD8,	"StartVDHead");
	MakeComm	(0X4BDC,	"device attribute");
	MakeWord	(0X4BDC);
	MakeComm	(0X4BDE,	"strategy routine offset");
	MakeWord	(0X4BDE);
	MakeComm	(0X4BE0,	"interrupt routine offset");
	MakeWord	(0X4BE0);
	MakeComm	(0X4BE2,	"number of units");
	MakeByte	(0X4BE2);
	MakeComm	(0X4BE3,	"reserved area");
	MakeByte	(0X4BE3);
	MakeArray	(0X4BE3,	0X7);
	MakeStr		(0X4BEA,	0X4BEF);
	MakeName	(0X4BEA,	"VDiskSig1");
	MakeComm	(0X4BEF,	"vdisk label ; VLEN1 equ ($-VDiskSig1)");
	MakeStr		(0X4BEF,	0X4BF5);
	MakeComm	(0X4BF5,	"pad");
	MakeByte	(x=0X4BF5);
	MakeArray	(x,	0XF);
	OpDecimal	(x,	0);
	MakeComm	(0X4C04,	"bits 0-15 of free HMA");
	MakeWord	(0X4C04);
	MakeComm	(0X4C06,	"bits 16-23 of free HMA (1M + 64K)");
	MakeByte	(0X4C06);
	MakeComm	(0X4C07,	"jmp to old vector");
	MakeByte	(0X4C07);
	MakeName	(0X4C07,	"VDInt19");
	MakeWord	(0X4C08);
	MakeArray	(0X4C08,	0X2);
	MakeName	(0X4C08,	"OldVDInt19");
	MakeComm	(0X4C0C,	"EndVDHead\nnon-bootable disk");
	MakeByte	(0X4C0C);
	MakeArray	(0X4C0C,	0X3);
	MakeName	(0X4C0C,	"VDiskHMAHead");
	MakeStr		(0X4C0F,	0X4C14);
	MakeName	(0X4C0F,	"VDiskSig2");
	MakeComm	(0X4C14,	"VLEN2 equ ($-VDiskSig2)\nOEM - signature");
	MakeStr		(0X4C14,	0X4C17);
	MakeComm	(0X4C17,	"number of bytes/sector");
	MakeWord	(x=0X4C17);
	OpDecimal	(x,	0);
	MakeComm	(0X4C19,	"sectors/cluster");
	MakeByte	(0X4C19);
	MakeComm	(0X4C1A,	"reserved sectors");
	MakeWord	(0X4C1A);
	MakeComm	(0X4C1C,	"number of FAT copies");
	MakeByte	(0X4C1C);
	MakeComm	(0X4C1D,	"number of root dir entries");
	MakeWord	(x=0X4C1D);
	OpDecimal	(x,	0);
	MakeComm	(0X4C1F,	"number of sectors");
	MakeWord	(x=0X4C1F);
	OpDecimal	(x,	0);
	MakeComm	(0X4C21,	"media descriptor");
	MakeByte	(0X4C21);
	MakeComm	(0X4C22,	"number of sectors/FAT");
	MakeWord	(0X4C22);
	MakeComm	(0X4C24,	"sectors per track");
	MakeWord	(0X4C24);
	MakeComm	(0X4C26,	"number of heads");
	MakeWord	(0X4C26);
	MakeComm	(0X4C28,	"number of hidden sectors");
	MakeWord	(0X4C28);
	MakeComm	(0X4C2A,	"Start of free HMA in K (1M+64K)");
	MakeWord	(0X4C2A);
	MakeComm	(0X4C2C,	"EndVDiskHMAHead (SYSINIT:0BFCh)");
	MakeCode	(0X4C2C);
	MakeName	(0X4C2C,	"InstVDiskHeader");
	MakeComm	(0X4C2E,	"seg of int vect table");
	MakeComm	(0X4C30,	"[19h*4]");
	MakeCode	(x=0X4C30);
	MakeComm	(0X4C37,	"[19h*4+2]");
	MakeCode	(x=0X4C37);
	MakeCode	(x=0X4C3E);
	OpHex		(x,	1);
	MakeComm	(0X4C43,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired");
	MakeCode	(x=0X4C43);
	OpHex		(x,	0);
	MakeComm	(0X4C48,	"[es:ARENA.OWNER],8 ; owner = System");
	MakeComm	(0X4C4F,	"[es:ARENA.NAME],'SC' ; System Code");
	MakeComm	(0X4C57,	"get back to allocated memory");
	MakeComm	(0X4C59,	"no reboots at this time\ninstall new int 19 vector");
	MakeComm	(0X4C5A,	"(VDInt19-StartVDHead)\n0BD7h-0BA8h = 2Fh = 47");
	MakeCode	(x=0X4C5A);
	OpDecimal	(x,	1);
	MakeCode	(x=0X4C60);
	MakeComm	(0X4C63,	"(EndVDHead-StartVDHead)");
	MakeCode	(x=0X4C63);
	OpDecimal	(x,	1);
	MakeComm	(0X4C66,	"SYSINIT:0BA8h");
	MakeCode	(x=0X4C66);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X4C70,	"mov the HMA VDisk head into HMA");
	MakeCode	(x=0X4C78);
	OpHex		(x,	1);
	MakeComm	(0X4C7B,	"(EndVDiskHMAHead-VDiskHMAHead)");
	MakeCode	(x=0X4C7B);
	OpDecimal	(x,	1);
	MakeComm	(0X4C7E,	"SYSINIT:0BDCh");
	MakeCode	(x=0X4C7E);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X4C86,	"bmove");
	MakeByte	(0X4C86);
	MakeArray	(0X4C86,	0X8);
	MakeName	(0X4C86,	"dummy");
	MakeComm	(0X4C8E,	"times desc.size db 0");
	MakeByte	(0X4C8E);
	MakeArray	(0X4C8E,	0X8);
	MakeName	(0X4C8E,	"gdt");
	MakeComm	(0X4C96,	"des <0ffffh,0,0,93h,0>");
	MakeWord	(0X4C96);
	MakeName	(0X4C96,	"src_desc");
	MakeWord	(0X4C98);
	MakeName	(0X4C98,	"desc_lo_word");
	MakeByte	(0X4C9A);
	MakeName	(0X4C9A,	"desc_hi_byte");
	MakeByte	(0X4C9B);
	MakeWord	(0X4C9C);
	MakeComm	(0X4C9E,	"desc <0ffffh,0,10h,93h,0>  ; 1MB\ndesc.seg_lim");
	MakeWord	(0X4C9E);
	MakeName	(0X4C9E,	"tgt_desc");
	MakeComm	(0X4CA0,	"desc.lo_word");
	MakeWord	(0X4CA0);
	MakeComm	(0X4CA2,	"desc.hi_byte");
	MakeByte	(0X4CA2);
	MakeComm	(0X4CA3,	"desc.acc_rights");
	MakeByte	(0X4CA3);
	MakeComm	(0X4CA4,	"desc.reserved");
	MakeWord	(0X4CA4);
	MakeComm	(0X4CA6,	"times desc.size db 0");
	MakeByte	(0X4CA6);
	MakeArray	(0X4CA6,	0X8);
	MakeName	(0X4CA6,	"rombios_code");
	MakeComm	(0X4CAE,	"times desc.size db 0");
	MakeByte	(0X4CAE);
	MakeArray	(0X4CAE,	0X8);
	MakeName	(0X4CAE,	"temp_stack");
	MakeByte	(x=0X4CB6);
	MakeArray	(x,	0X20);
	OpDecimal	(x,	0);
	MakeName	(0X4CB6,	"ClrdVDISKHead");
	MakeComm	(0X4CD6,	"8042 keyboard controller status register\n7:  PERR    1=parity error in data received from keyboard\n   +----------- AT Mode ----------+------------ PS/2 Mode ------------+\n6: |RxTO    receive (Rx) timeout  | TO      general timeout (Rx or Tx)|\n5: |TxTO    transmit (Tx) timeout | MOBF    mouse output buffer full  |\n   +------------------------------+-----------------------------------+\n4:  INH     0=keyboard communications inhibited\n3:  A2      0=60h was the port last written to, 1=64h was last\n2:  SYS     distinguishes reset types: 0=cold reboot, 1=warm reboot\n1:  IBF     1=input buffer full (keyboard can't accept data)\n0:  OBF     1=output buffer full (data from keyboard is available)");
	MakeCode	(x=0X4CD6);
	OpHex		(x,	1);
	MakeName	(0X4CD6,	"ClrVDISKHeader");
	MakeComm	(0X4CD8,	"test bit 4 - Is keyboard inhibited?");
	MakeCode	(x=0X4CD8);
	OpHex		(x,	1);
	MakeComm	(0X4CDA,	"no, go do block move");
	MakeComm	(0X4CDC,	"check for TORTUGA models");
	MakeComm	(0X4CE3,	"do not use INT 15h block move code\n(while 8042 is disabled)");
	MakeComm	(0X4CE5,	"Check for PS/2 30-286 model");
	MakeCode	(0X4CEF);
	MakeCode	(x=0X4CF4);
	OpDecimal	(x,	1);
	MakeComm	(0X4CF6,	"dx = higher 4 bits of the segment number\n   = segment number / 4096 (= byte address / 65536)");
	MakeComm	(0X4CFA,	"ax = (lower 12 bits of the segment number)*16");
	MakeCode	(x=0X4CFC);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X4CFF,	"dl:ax = 24 bit linear address");
	MakeComm	(0X4D0B,	"16 words");
	MakeCode	(x=0X4D0B);
	OpDecimal	(x,	1);
	MakeComm	(0X4D10,	"offset bmove");
	MakeCode	(x=0X4D10);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X4D13);
	OpHex		(x,	1);
	MakeComm	(0X4D15,	"EXTENDED MEMORY - BLOCK MOVE (AT,XT286,PS)\nCX = number of words to move, ES:SI -> global descriptor table\nReturn: CF set on error, AH = status");
	MakeCode	(x=0X4D15);
	OpHex		(x,	0);
	MakeCode	(0X4D19);
	MakeName	(0X4D19,	"SaveFreeHMAPtr");
	MakeComm	(0X4D1B,	"HMA segment");
	MakeComm	(0X4D20,	"para round");
	MakeCode	(x=0X4D20);
	OpDecimal	(x,	1);
	MakeCode	(x=0X4D23);
	OpHex		(x,	1);
	MakeComm	(0X4D2D,	"DOSBIODATASEG ; BIOSDATA segment");
	MakeCode	(x=0X4D2D);
	OpHex		(x,	1);
	MakeComm	(0X4D32,	"BIOSDATA:08F7h");
	MakeCode	(x=0X4D32);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X4D36,	"BIOSDATA:000Dh");
	MakeCode	(x=0X4D36);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(0X4D3D);
	MakeName	(0X4D3D,	"IsVDiskInstalled");
	MakeComm	(0X4D41,	"[13h*4+2]");
	MakeCode	(x=0X4D41);
	MakeComm	(0X4D45,	"VDiskSig1-StartVDHead");
	MakeComm	(0X4D48,	"VLEN1");
	MakeCode	(x=0X4D4D);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X4D59,	"10h+(VDiskSig2-VDiskHMAHead)");
	MakeCode	(x=0X4D5C);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X4D65);
	MakeName	(0X4D65,	"CPMHack");
	MakeCode	(x=0X4D6F);
	OpHex		(x,	1);
	MakeCode	(x=0X4D72);
	OpHex		(x,	1);
	MakeComm	(0X4D79,	"move 5 bytes from 0:C0h to FFFFh:D0h");
	MakeCode	(x=0X4D7D);
	OpHex		(x,	1);
	MakeName	(0X4D7D,	"_off_to_para");
	MakeCode	(x=0X4D7F);
	OpHex		(x,	1);
	MakeCode	(x=0X4D81);
	OpHex		(x,	1);
	MakeCode	(x=0X4D83);
	OpHex		(x,	1);
	MakeCode	(x=0X4D86);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeName	(0X4D86,	"TempCDS");
	MakeComm	(0X4D8A,	"[es:di+SYSI_NUMIO]");
	MakeComm	(0X4D8E,	"(cx) = # of block devices");
	MakeComm	(0X4D90,	"[es:di+SYSI_NCDS] ; one CDS per device");
	MakeComm	(0X4D96,	"curdirlen ; curdir_list.size");
	MakeCode	(x=0X4D96);
	OpDecimal	(x,	1);
	MakeCode	(x=0X4D9D);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X4DA3,	"[es:di+SYSI_CDS+2]");
	MakeComm	(0X4DA9,	"[es:di+SYSI_CDS]\nset address of CDS list");
	MakeComm	(0X4DAF,	"lds si,[es:di+SYSI_DPB]\n(ds:si) = address of first DPB");
	MakeComm	(0X4DB4,	"(es:di) = address of 1st CDS");
	MakeComm	(0X4DB6,	"\"A:\\\"");
	MakeName	(0X4DB6,	"fooset");
	MakeComm	(0X4DBA,	"setup the root as the curdir");
	MakeComm	(0X4DBB,	"get dpb for drive in dpb\n(ds:si) = address of DPB\n   (si) = -1 if no drive");
	MakeComm	(0X4DBE,	"\"\\\",0");
	MakeComm	(0X4DC3,	"\"A:\\\"");
	MakeComm	(0X4DCB,	"curdir_list.cdir_flags - 4");
	MakeCode	(x=0X4DCB);
	OpDecimal	(x,	1);
	MakeComm	(0X4DCE,	"zero out rest of CURDIR_TEXTs\n(ax) = 0\n(es:di) = CURDIR_FLAGS in the CDS records\n(ds:si) = Next DPB (-1 if none)");
	MakeComm	(0X4DD0,	"-1");
	MakeComm	(0X4DD3,	"don't have any physical drive.");
	MakeComm	(0X4DDB,	"machine has floppy drives");
	MakeComm	(0X4DDD,	"cmp [si+DPB.drive],1\nif dpb_drive = 0 (A) or 1 (B).");
	MakeComm	(0X4DE2,	"the next dbp pointer");
	MakeComm	(0X4DE4,	"ax should be zero here");
	MakeCode	(0X4DE9);
	MakeComm	(0X4DEE,	"jmp short fincds");
	MakeCode	(0X4DF0);
	MakeComm	(0X4DF1,	"[si+DPB.FAT_COUNT] ; non fat system?");
	MakeComm	(0X4DF5,	"yes. set curdir_flags to 0. ax = 0 now.");
	MakeComm	(0X4DF7,	"curdir_inuse ; else,fat system.\nset the flag to curdir_inuse.");
	MakeComm	(0X4DFA,	"curdir_flags");
	MakeComm	(0X4DFD,	"curdir_devptr");
	MakeComm	(0X4E01,	"entry point for fake_fooset_zero\nmov ax,-1");
	MakeComm	(0X4E04,	"curdir_id");
	MakeComm	(0X4E05,	"curdir_id");
	MakeComm	(0X4E06,	"curdir_user_word");
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_3(void) {
        auto x;
#define id x

	MakeComm	(0X4E07,	"curdir_end");
	MakeComm	(0X4E0B,	"clear out 7 bytes (curdir_type,");
	MakeComm	(0X4E0E,	"curdir_ifs_hdr,curdir_fsda)");
	MakeComm	(0X4E13,	"\"A:\\\",0");
	MakeCode	(x=0X4E13);
	OpChr		(x,	1);
	MakeComm	(0X4E1A,	"point to first DPB");
	MakeCode	(0X4E1A);
	MakeName	(0X4E1A,	"get_dpb_for_drive_al");
	MakeComm	(0X4E1F,	"(ds:si) = address of first DPB");
	MakeCode	(x=0X4E21);
	OpChr		(x,	1);
	MakeComm	(0X4E23,	"cmp al,[si+DPB.DRIVE] ; match?");
	MakeComm	(0X4E27,	"lds si,[si+DPB.NEXT_DPB]");
	MakeComm	(0X4E2D,	"loop until hit end of DPBs");
	MakeComm	(0X4E30,	"Build DOS structures");
	MakeCode	(0X4E30);
	MakeName	(0X4E30,	"endfile");
	MakeComm	(0X4E31,	"DOSBIODATASEG");
	MakeCode	(x=0X4E31);
	OpHex		(x,	1);
	MakeComm	(0X4E36,	"multrk_off1\nmultrack= command entered?");
	MakeCode	(x=0X4E36);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X4E3D,	"or [multrk_flag],multrk_on");
	MakeCode	(x=0X4E3D);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X4E5A,	"devmark_files");
	MakeCode	(x=0X4E5A);
	OpChr		(x,	1);
	MakeComm	(0X4E5C,	"set devmark for sfts (files)");
	MakeComm	(0X4E60,	"do not use cbw instruction!\nit does sign extend.");
	MakeComm	(0X4E6C,	"get pointer to dos data");
	MakeComm	(0X4E71,	"lds di,[di+SYSI_SFT] ; ds:di points to sft");
	MakeComm	(0X4E74,	"[di+SF.SFLink],bx");
	MakeComm	(0X4E76,	"[di+SF.SFLink+2],dx ; set pointer to new sft");
	MakeComm	(0X4E7B,	"point to new sft");
	MakeComm	(0X4E80,	"mov word [es:di+SF.SFLink],-1");
	MakeComm	(0X4E85,	"mov [es:di+SF.SFCount],ax");
	MakeComm	(0X4E89,	"SF_ENTRY.size");
	MakeCode	(x=0X4E89);
	OpDecimal	(x,	1);
	MakeComm	(0X4E8D,	"ax = number of bytes to clear");
	MakeComm	(0X4E8F,	"allocate memory");
	MakeComm	(0X4E97,	"remember the header too");
	MakeComm	(0X4E9C,	"for_devmark");
	MakeCode	(x=0X4E9C);
	OpHex		(x,	1);
	MakeComm	(0X4EA2,	"check for mem error before the stosb");
	MakeComm	(0X4EA5,	"ax = 6");
	MakeComm	(0X4EA9,	"clean out the stuff");
	MakeComm	(0X4EB0,	"devmark_fcbs");
	MakeCode	(x=0X4EB0);
	OpChr		(x,	1);
	MakeComm	(0X4EB9,	"do not use cbw instruction!\nit does sign extend.");
	MakeComm	(0X4EC5,	"get pointer to dos data");
	MakeComm	(0X4ECA,	"[di+SYSI_FCB]");
	MakeComm	(0X4ECD,	"[di+SYSI_FCB+2] ; set pointer to new table");
	MakeComm	(0X4ED7,	"[di+SYSI_KEEP]");
	MakeComm	(0X4EDC,	"point to new table");
	MakeComm	(0X4EE0,	"[es:di+SF.SFLink],-1");
	MakeComm	(0X4EE5,	"[es:di+SF.SFCount]");
	MakeComm	(0X4EE9,	"SF_ENTRY.size");
	MakeCode	(x=0X4EE9);
	OpDecimal	(x,	1);
	MakeComm	(0X4EEF,	"ax = number of bytes to clear");
	MakeComm	(0X4EF3,	"SF.size-2");
	MakeComm	(0X4EF6,	"remember the header too");
	MakeComm	(0X4EFA,	"for_devmark");
	MakeCode	(x=0X4EFA);
	OpHex		(x,	1);
	MakeComm	(0X4EFF,	"check for mem error before the stosb");
	MakeComm	(0X4F02,	"skip over header");
	MakeCode	(x=0X4F04);
	OpChr		(x,	1);
	MakeComm	(0X4F06,	"save count");
	MakeComm	(0X4F07,	"number of bytes to fill");
	MakeCode	(x=0X4F07);
	OpDecimal	(x,	1);
	MakeComm	(0X4F0B,	"filled");
	MakeComm	(0X4F0D,	"[es:di-(SF_ENTRY.size)+SF_ENTRY.sf_ref_count]");
	MakeComm	(0X4F13,	"[es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position]");
	MakeComm	(0X4F19,	"[es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position+2]");
	MakeComm	(0X4F22,	"-1 ; has buffers been already set?");
	MakeComm	(0X4F29,	"the user entered the buffers=.");
	MakeComm	(0X4F2C,	"default is no heuristic buffers.");
	MakeCode	(0X4F2C);
	MakeComm	(0X4F32,	"default to 2 buffers");
	MakeComm	(0X4F3A,	"search through the dpb's");
	MakeComm	(0X4F3F,	"[es:bp+SYSI_DPB] ; get first dpb");
	MakeComm	(0X4F45,	"[es:bp+DPB.drive]");
	MakeComm	(0X4F4B,	"(IOCTL<<8)|8");
	MakeCode	(x=0X4F4B);
	OpHex		(x,	1);
	MakeComm	(0X4F4E,	"DOS - 2+ - IOCTL - ");
	MakeCode	(x=0X4F4E);
	OpHex		(x,	0);
	MakeComm	(0X4F50,	"0 = removable disk, 1 = fixed disk");
	MakeComm	(0X4F52,	"ax is nonzero if disk is nonremoveable");
	MakeComm	(0X4F54,	"get parameters of (removable) drive");
	MakeComm	(0X4F56,	"[es:bp+DPB.drive]");
	MakeCode	(x=0X4F5C);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X4F5F,	"(IOCTL<<8)|GENERIC_IOCTL");
	MakeComm	(0X4F62,	"(RAWIO<<8)|GET_DEVICE_PARAMETERS");
	MakeComm	(0X4F65,	"DOS - 2+ - IOCTL - ");
	MakeCode	(x=0X4F65);
	OpHex		(x,	0);
	MakeComm	(0X4F67,	"get next dpb if driver doesn't support\ngeneric ioctl");
	MakeComm	(0X4F69,	"[deviceparameters+15]\n[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]");
	MakeComm	(0X4F6D,	"[deviceparameters+7]\n[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_BYTESPERSECTOR]");
	MakeComm	(0X4F72,	"scale sector size in factor of 512 bytes");
	MakeCode	(x=0X4F72);
	OpDecimal	(x,	1);
	MakeComm	(0X4F77,	"ax = #sectors * size factor");
	MakeComm	(0X4F79,	"just in case of large floppies");
	MakeComm	(0X4F7D,	"720 sectors * size factor of 1");
	MakeCode	(x=0X4F7D);
	OpDecimal	(x,	1);
	MakeComm	(0X4F88,	"now check the memory size\nfor default buffer count");
	MakeComm	(0X4F8A,	"[es:bp+DPB.NEXT_DPB],-1");
	MakeCode	(0X4F8A);
	MakeComm	(0X4F91,	"les bp,[es:bp+DPB.NEXT_DPB]");
	MakeComm	(0X4F97,	"128kb");
	MakeCode	(0X4F97);
	MakeComm	(0X4FA5,	"256kb");
	MakeCode	(x=0X4FAD);
	OpDecimal	(x,	1);
	MakeComm	(0X4FB3,	"512kb");
	MakeCode	(x=0X4FBB);
	OpDecimal	(x,	1);
	MakeComm	(0X4FC3,	"ds:bx -> sysinitvar");
	MakeComm	(0X4FCC,	"[bx+SYSI_BUFFERS] ; set sysi_buffers");
	MakeComm	(0X4FD3,	"[bx+SYSI_BUFFERS+2]");
	MakeComm	(0X4FD6,	"[bx+SYSI_BUF] ; now, ds:bx -> buffinfo");
	MakeComm	(0X4FD9,	"get [memhi]:[memlo]");
	MakeComm	(0X4FDC,	"devmark_buf");
	MakeCode	(x=0X4FDC);
	OpChr		(x,	1);
	MakeComm	(0X4FE1,	"save buffer info. ptr.");
	MakeComm	(0X4FE6,	"restore buffer info. ptr.");
	MakeComm	(0X4FE8,	"set the secondary buffer if specified");
	MakeComm	(0X4FF8,	"[bx+BUFFINF.Cache_ptr]");
	MakeComm	(0X5000,	"[bx+BUFFINF.Cache_ptr+2]");
	MakeComm	(0X5008,	"[bx+BUFFINF.Cache_count]");
	MakeCode	(x=0X5008);
	OpDecimal	(x,	0);
	MakeComm	(0X500B,	"512 bytes");
	MakeCode	(x=0X500B);
	OpDecimal	(x,	1);
	MakeComm	(0X5014,	"for_devmark");
	MakeCode	(x=0X5014);
	OpHex		(x,	1);
	MakeComm	(0X501D,	"buf1");
	MakeComm	(0X5021,	"devmark_cds");
	MakeCode	(x=0X5021);
	OpChr		(x,	1);
	MakeComm	(0X502D,	"[es:di+SYSI_NUMIO]");
	MakeComm	(0X5036,	"user setting must be at least numio");
	MakeComm	(0X503F,	"[es:di+SYSI_NCDS]");
	MakeComm	(0X5047,	"[es:di+SYSI_CDS+2]");
	MakeComm	(0X504F,	"[es:di+SYSI_CDS]");
	MakeComm	(0X5055,	"curdirlen ; curdir_list.size");
	MakeCode	(x=0X5055);
	OpDecimal	(x,	1);
	MakeComm	(0X5061,	"for_devmark");
	MakeCode	(x=0X5061);
	OpHex		(x,	1);
	MakeComm	(0X5067,	"check for mem error before initializing");
	MakeComm	(0X506A,	"lds si,[es:di+SYSI_DPB] ; [es:di+0]");
	MakeComm	(0X506D,	"les di,[es:di+SYSI_CDS] ; [es:di+22]");
	MakeComm	(0X5076,	"-1 ; has the user entered \"stacks=\" command?");
	MakeComm	(0X507B,	"then install as specified by the user");
	MakeComm	(0X507D,	"pc1,xt has the secondary model byte = 0");
	MakeComm	(0X5082,	"other model should have default stack of 9,128");
	MakeComm	(0X5084,	"pc1, pc/xt or pc portable ?");
	MakeCode	(x=0X5084);
	OpHex		(x,	1);
	MakeComm	(0X508B,	"stack_count = 0?");
	MakeComm	(0X508E,	"then, stack size must be 0 too.");
	MakeComm	(0X5090,	"don't install stack.");
	MakeComm	(0X5092,	"dynamic relocation of stack code.\n[memhi] = seg. for stack code\n[memlo] = 0");
	MakeComm	(0X5095,	"devmark_stk");
	MakeCode	(x=0X5095);
	OpChr		(x,	1);
	MakeComm	(0X509D,	"es -> seg. the stack code is going to move.");
	MakeComm	(0X50A1,	"! we know that stack code is at the beginning of sysinit.");
	MakeComm	(0X50A5,	"offset endstackcode = offset _SYSINIT\nSYSINIT:0269h");
	MakeCode	(x=0X50A5);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X50AC,	"have enough space for relocation?");
	MakeComm	(0X50B2,	"DOSBIODATASEG");
	MakeCode	(x=0X50B2);
	OpHex		(x,	1);
	MakeComm	(0X50B7,	"[BIOSDATA:NextStack],\n offset SYSINIT:nextentry (SYSINIT:0010h)");
	MakeCode	(x=0X50B7);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X50BD);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X50C5,	"set for stack area initialization");
	MakeComm	(0X50C9,	"pass it as Instance Data, too");
	MakeCode	(x=0X50C9);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X50CC,	"this will be used by stack_init routine.");
	MakeCode	(x=0X50D4);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X50D7,	"entrysize");
	MakeComm	(0X50E4,	"pass through to Instance Table");
	MakeCode	(x=0X50E4);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X50F0,	"for_devmark\nto set the devmark_size for stack by round routine.");
	MakeCode	(x=0X50F0);
	OpHex		(x,	1);
	MakeComm	(0X50F6,	"check for memory error before continuing");
	MakeComm	(0X50F9,	"initialize hardware stack.\ncs=ds=sysinitseg,es=relocated stack code & data");
	MakeComm	(0X5101,	"do not use cbw instruction!\nit does sign extend.");
	MakeComm	(0X5105,	"close standard input");
	MakeCode	(x=0X5107);
	OpHex		(x,	1);
	MakeComm	(0X5109,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle");
	MakeCode	(x=0X5109);
	OpHex		(x,	0);
	MakeComm	(0X510B,	"close everybody but standard output\nneed output so we can print message\n in case we can't get new one open.");
	MakeCode	(x=0X510E);
	OpHex		(x,	1);
	MakeComm	(0X5110,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle");
	MakeCode	(x=0X5110);
	OpHex		(x,	0);
	MakeCode	(x=0X5115);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X511A,	"open con for read/write");
	MakeCode	(x=0X511A);
	OpHex		(x,	1);
	MakeComm	(0X511C,	"set for possible int 24");
	MakeComm	(0X511D,	"DOS - 2+ - OPEN DISK FILE WITH HANDLE\nDS:DX -> ASCIZ filename\nAL = access mode\n2 - read & write");
	MakeCode	(x=0X511D);
	OpHex		(x,	0);
	MakeCode	(0X5126);
	MakeComm	(0X5127,	"close standard output");
	MakeCode	(x=0X512A);
	OpHex		(x,	1);
	MakeComm	(0X512C,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle");
	MakeCode	(x=0X512C);
	OpHex		(x,	0);
	MakeComm	(0X512F,	"new device handle");
	MakeComm	(0X5131,	"XDUP ; dup to 1, stdout");
	MakeCode	(x=0X5131);
	OpHex		(x,	1);
	MakeComm	(0X5133,	"DOS - 2+ - CREATE DUPLICATE HANDLE (DUP)\nBX = file handle to duplicate");
	MakeCode	(x=0X5133);
	OpHex		(x,	0);
	MakeComm	(0X5135,	"XDUP ; dup to 2, stderr");
	MakeCode	(x=0X5135);
	OpHex		(x,	1);
	MakeComm	(0X5137,	"DOS - 2+ - CREATE DUPLICATE HANDLE (DUP)\nBX = file handle to duplicate");
	MakeCode	(x=0X5137);
	OpHex		(x,	0);
	MakeCode	(x=0X5139);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X513C,	"read/write access");
	MakeCode	(x=0X5141);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X5144,	"write only");
	MakeComm	(0X514D,	"reset h/w by writing to port");
	MakeComm	(0X514F,	"get starting address");
	MakeComm	(0X5152,	"out 02f2h,0ffh");
	MakeComm	(0X515C,	"out 02f7h,0ffh");
	MakeComm	(0X515D,	"get machine type");
	MakeComm	(0X5162,	"is it a at type machine");
	MakeCode	(x=0X5162);
	OpHex		(x,	1);
	MakeComm	(0X5168,	"*if AT no need to check");
	MakeCode	(x=0X516A);
	OpHex		(x,	1);
	MakeComm	(0X516C,	"SYSTEM - GET CONFIGURATION \n(XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)");
	MakeCode	(x=0X516C);
	OpHex		(x,	0);
	MakeComm	(0X516E,	"*jmp if old rom");
	MakeComm	(0X5170,	"[es:bx+ROMBIOS_DESC.bios_sd_featurebyte1],\nScndIntController");
	MakeCode	(x=0X5170);
	OpHex		(x,	1);
	MakeComm	(0X5177,	"write any pattern to port");
	MakeComm	(0X5179,	"get starting address");
	MakeComm	(0X517E,	"out 06f3h,0ffh");
	MakeComm	(0X5180,	"out 06f4h,0ffh");
	MakeComm	(0X5183,	"out 06f6h,0ffh");
	MakeComm	(0X5185,	"out 06f7h,0ffh");
	MakeComm	(0X518A,	"sysinit_base will be established \nin the secure area of lower memory\nwhen it handles the first install= command.\nif sysinit module (in high memory) has been broken,\nthen \"memory error...\" message is displayed\nby sysinit_base");
	MakeName	(0X518A,	"set_sysinit_base");
	MakeCode	(x=0X5195);
	OpChr		(x,	1);
	MakeComm	(0X51A1,	"save this entry for the next use.");
	MakeComm	(0X51A7,	"es:di -> destination.");
	MakeComm	(0X51AB,	"ds:si -> source code to be relocated.");
	MakeCode	(x=0X51AB);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X51AE,	"end_sysinit_base-sysinit_base ; 129");
	MakeCode	(x=0X51AE);
	OpDecimal	(x,	1);
	MakeComm	(0X51B5,	"for_devmark");
	MakeCode	(x=0X51B5);
	OpHex		(x,	1);
	MakeComm	(0X51C0,	"returning address from\nsysinit_base back to sysinit");
	MakeCode	(x=0X51C0);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X51CA,	"for_devmark");
	MakeCode	(x=0X51CA);
	OpHex		(x,	1);
	MakeComm	(0X51D9,	"save [area]");
	MakeComm	(0X51DC,	"calc what we needed");
	MakeComm	(0X51E0,	"SETBLOCK");
	MakeCode	(x=0X51E0);
	OpHex		(x,	1);
	MakeComm	(0X51E2,	"DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)\nES = segment address of block to change\nBX = new size in paragraphs");
	MakeCode	(x=0X51E2);
	OpHex		(x,	0);
	MakeComm	(0X51E8,	"point to arena");
	MakeComm	(0X51EA,	"[es:ARENA.OWNER],8 ; set impossible owner");
	MakeComm	(0X51F1,	"[es:ARENA.NAME],'SD' ; System Data");
	MakeCode	(x=0X51FC);
	OpHex		(x,	1);
	MakeComm	(0X51FE,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired");
	MakeCode	(x=0X51FE);
	OpHex		(x,	0);
	MakeComm	(0X5200,	"allocate the rest of the memory");
	MakeCode	(x=0X5200);
	OpHex		(x,	1);
	MakeComm	(0X5202,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired");
	MakeCode	(x=0X5202);
	OpHex		(x,	0);
	MakeComm	(0X5204,	"start of the allocated memory");
	MakeComm	(0X5207,	"to be used next.");
	MakeComm	(0X5213,	"confbot - memhi");
	MakeComm	(0X5215,	"make a room for the memory block id.");
	MakeComm	(0X5216,	"make sure!");
	MakeComm	(0X5217,	"this will free (confbot to top of memory)");
	MakeCode	(x=0X5217);
	OpHex		(x,	1);
	MakeComm	(0X5219,	"DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)\nES = segment address of block to change\nBX = new size in paragraphs");
	MakeCode	(x=0X5219);
	OpHex		(x,	0);
	MakeCode	(x=0X521E);
	OpHex		(x,	1);
	MakeComm	(0X5220,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired");
	MakeCode	(x=0X5220);
	OpHex		(x,	0);
	MakeComm	(0X5222,	"allocate (confbot to top of memory)");
	MakeCode	(x=0X5222);
	OpHex		(x,	1);
	MakeComm	(0X5224,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired");
	MakeCode	(x=0X5224);
	OpHex		(x,	0);
	MakeComm	(0X5226,	"save allocated memory segment.\nneed this to free this area for command.com.");
	MakeComm	(0X522D,	"free allocated memory\nfree (memhi to confbot(=area))");
	MakeCode	(x=0X522D);
	OpHex		(x,	1);
	MakeComm	(0X522F,	"DOS - 2+ - FREE MEMORY\nES = segment address of area to be freed");
	MakeCode	(x=0X522F);
	OpHex		(x,	0);
	MakeComm	(0X5232,	"EXEC a program being loaded via the \n\"install=\" mechanism in config.sys");
	MakeCode	(0X5232);
	MakeName	(0X5232,	"do_install_exec");
	MakeComm	(0X5236,	"es->sysinitseg,ds->confbot seg");
	MakeComm	(0X5237,	"ds:dx->file name,0 in config.sys image.");
	MakeComm	(0X523C,	"clear out the parm area");
	MakeCode	(x=0X5242);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X5245,	"skip the file name\nal = ds:si; si++");
	MakeComm	(0X524C,	"copy the parameters to ldexec_parm");
	MakeCode	(0X524C);
	MakeComm	(0X5250,	"lf ; line feed?");
	MakeComm	(0X5254,	"# of char. in the parm.");
	MakeComm	(0X5259,	"length of the parm.");
	MakeCode	(0X5259);
	MakeComm	(0X525E,	"if no parm,then");
	MakeComm	(0X5261,	"let the parm area");
	MakeComm	(0X5263,	"cr ; starts with cr.");
	MakeComm	(0X5269,	"make a null environment segment");
	MakeCode	(x=0X5269);
	MakeComm	(0X5270,	"by overlap jmp instruction of sysinitseg.");
	MakeComm	(0X5281,	"[cs:instexe.exec0_environ]\nset the environment seg.");
	MakeComm	(0X5286,	"[cs:instexe.exec0_com_line+2]\nset the seg.");
	MakeComm	(0X528A,	"[cs:instexe.exec0_5c_fcb+2]");
	MakeComm	(0X528E,	"[cs:instexe.exec0_6c_fcb+2]");
	MakeComm	(0X5295,	"save the value of the sum");
	MakeComm	(0X529B,	"EXEC ; load/exec");
	MakeCode	(x=0X529B);
	OpHex		(x,	1);
	MakeComm	(0X529D,	"instexe ; es:bx -> parm block.");
	MakeCode	(x=0X529D);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X52A0,	"save es,ds for load/exec");
	MakeComm	(0X52A1,	"these registers will be restored in sysinit_base.");
	MakeComm	(0X52A2,	"jmp to sysinit_base to execute\nload/exec function and check sum.");
	MakeComm	(0X52A7,	"returning far address from sysinit_base\nrestore si for config.sys file.");
	MakeCode	(0X52A7);
	MakeName	(0X52A7,	"sysinitptr");
	MakeComm	(0X52AB,	"now ds - sysinitseg, es - confbot");
	MakeComm	(0X52AE,	"error in loading the file for install=.");
	MakeComm	(0X52AF,	"es:si-> path,filename,0.");
	MakeName	(0X52B3,	"install_exit_ret");
	MakeComm	(0X52B4,	"round up length in paragraphs\n0Fh");
	MakeCode	(x=0X52B4);
	OpDecimal	(x,	1);
	MakeName	(0X52B4,	"ParaRound");
	MakeCode	(x=0X52B7);
	OpHex		(x,	1);
	MakeCode	(x=0X52B9);
	OpHex		(x,	1);
	MakeCode	(x=0X52BB);
	OpHex		(x,	1);
	MakeCode	(x=0X52BD);
	OpHex		(x,	1);
	MakeComm	(0X52C0,	"sysinit_base module");
	MakeCode	(x=0X52C0);
	MakeName	(0X52C0,	"sysinit_base");
	MakeCode	(x=0X52C5);
	MakeComm	(0X52CA,	"load/exec dos call");
	MakeCode	(x=0X52CA);
	OpHex		(x,	0);
	MakeCode	(x=0X52CC);
	MakeCode	(x=0X52D1);
	MakeCode	(x=0X52DD);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X52E4,	"memory broken. \nshow \"memory allocation error\" message and stall.");
	MakeComm	(0X52E8,	"mem_alloc_err_msgx-sysinit_base ; 66h");
	MakeCode	(x=0X52E8);
	OpDecimal	(x,	1);
	MakeComm	(0X52EB,	"DOS - PRINT STRING\nDS:DX -> string terminated by \"$\"");
	MakeCode	(x=0X52EB);
	OpHex		(x,	0);
	MakeComm	(0X52ED,	"use HLT to minimize energy consumption");
	MakeName	(0X52ED,	"stall");
	MakeCode	(0X52EE);
	MakeComm	(0X52F0,	"return back to sysinit module");
	MakeCode	(x=0X52F0);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X52F0,	"sysinit_base_end");
	MakeCode	(0X52F5);
	MakeName	(0X52F5,	"sum_up");
	MakeCode	(x=0X52F6);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X5300,	"if config_size has been broken, then this\nwhole test better fail.");
	MakeCode	(x=0X5300);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X5305,	"make it a word count");
	MakeCode	(x=0X5305);
	OpHex		(x,	1);
	MakeComm	(0X5307,	"when config.sys file not exist.");
	MakeComm	(0X530F,	"532h\nstarting after the stack.\nthis does not cover the possible stack code!");
	MakeCode	(x=0X530F);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X5312,	"SI_end (22688)\nSI_end is the label at the end of sysinit\nfrom after_checksum to SI_end");
	MakeCode	(x=0X5317);
	OpHex		(x,	1);
	MakeComm	(0X5322,	"sysinit_base_ss equ $-sysinit_base ; 62");
	MakeWord	(0X5322);
	MakeName	(0X5322,	"sysinit_base_ssx");
	MakeComm	(0X5324,	"sysinit_base_sp equ $-sysinit_base ; 64");
	MakeWord	(0X5324);
	MakeName	(0X5324,	"sysinit_base_spx");
	MakeStr		(0X5326,	0X5341);
	MakeName	(0X5326,	"mem_alloc_err_msgx");
	MakeComm	(0X5341,	"input:\n  ds:bx -> buffinfo.\n  [memhi]:[memlo=0] = available space for the hash bucket.    \n  singlebuffersize = buff header size + sector size       \noutput:\n  buffers Queue established.\n  [memhi]:[memlo] = addr of the next available free space.\n\nassume buffers not in HMA");
	MakeCode	(0X5341);
	MakeName	(0X5341,	"set_buffer");
	MakeComm	(0X5348,	"buffers in HMA");
	MakeComm	(0X534A,	"[bx+BUFFINF.Buff_Queue] ; head of Buff Q");
	MakeComm	(0X534C,	"[bx+BUFFINF.Buff_Queue+2]");
	MakeComm	(0X534F,	"[bx+BUFFINF.Dirty_Buff_Count] ; set dirty_count to 0.");
	MakeComm	(0X535B,	"remember first buffer");
	MakeComm	(0X535C,	"set buf_link,buf_id...");
	MakeComm	(0X5363,	"point to last buffer");
	MakeComm	(0X5368,	"get first buffer");
	MakeComm	(0X5369,	"[es:di+buffinfo.buf_next] ; last->next = first");
	MakeComm	(0X536E,	"[es:di+buffinfo.buf_prev] ; first->prev = last");
	MakeComm	(0X5372,	"In HMa ?");
	MakeComm	(0X5374,	"no");
	MakeComm	(0X5376,	"mov byte [bx+BUFFINF.Buff_In_HMA],1");
	MakeComm	(0X537A,	"seg of scratch buff");
	MakeComm	(0X537E,	"[bx+BUFFINF.Lo_Mem_Buff] ; offset of scratch buff is 0");
	MakeComm	(0X5383,	"mov [bx+BUFFINF.Lo_Mem_Buff+2],ax");
	MakeComm	(0X5386,	"size of scratch buff");
	MakeComm	(0X538A,	"bufinsiz ; buffer head not required");
	MakeCode	(x=0X538A);
	OpDecimal	(x,	1);
	MakeCode	(x=0X5392);
	OpHex		(x,	1);
	MakeCode	(0X539C);
	MakeName	(0X539C,	"GetBufferAddr");
	MakeComm	(0X53A7,	"15");
	MakeComm	(0X53AA,	"~15 ; not 0Fh");
	MakeCode	(x=0X53AA);
	OpHex		(x,	1);
	MakeComm	(0X53AF,	"((multMULT<<8)+multMULTALLOCHMA)");
	MakeComm	(0X53B2,	"DOS 5+ - ALLOCATE HMA SPACE\n    AX = 4A02h\n    BX = number of bytes\nReturn:\n    ES:DI -> start of allocated HMA block or FFFFh:FFFFh\n    BX = number of bytes actually allocated (rounded up to next  \n         paragraph for DOS 5.0 and 6.0)\nNotes:\n    this call is not valid unless DOS is loaded in the HMA (DOS=HIGH)\n    \n    called by Windows 3.1 DOSX.EXE\n    supported by Novell DOS 7");
	MakeCode	(x=0X53B2);
	OpHex		(x,	0);
	MakeComm	(0X53B9,	"dont xor di,di Z flag needed");
	MakeComm	(0X53C4,	"es:di -> buffer header to be set.\nax = di");
	MakeCode	(0X53C4);
	MakeName	(0X53C4,	"set_buffer_info");
	MakeComm	(0X53C9,	"[es:di+buffinfo.buf_prev]");
	MakeComm	(0X53D1,	"adjust ax");
	MakeComm	(0X53D6,	"[es:di+buffinfo.buf_next]");
	MakeComm	(0X53D9,	"[es:di+buffinfo.buf_ID]\nnew buffer free");
	MakeComm	(0X53DF,	"[es:di+buffinfo.buf_sector]");
	MakeComm	(0X53E5,	"[es:di+buffinfo.buf_sector+2]");
	MakeComm	(0X53EC,	"ibmstack initialization routine\nin - cs, ds -> sysinitseg,\n     es -> relocated stack code & data.");
	MakeCode	(0X53EC);
	MakeName	(0X53EC,	"stackinit");
	MakeCode	(x=0X53F9);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X53FD);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X5400);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X5404,	"offset");
	MakeCode	(x=0X5408);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X5410,	"segment");
	MakeCode	(x=0X5410);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X5414,	"\"firstentry\" will always be at stacks\nthe stacks will always immediately follow the table entries");
	MakeCode	(x=0X5414);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X5419);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X541E,	"entrysize");
	MakeCode	(x=0X5421);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X542A);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X5433,	"zero the entire stack area to start with");
	MakeCode	(x=0X5433);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X5438);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X5440,	"0");
	MakeComm	(0X5443,	"ds = relocated stack code seg.");
	MakeComm	(0X5444,	"get segment of stack area.");
	MakeCode	(x=0X5444);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X544B,	"loop for \"count\" times, building a table entry\ncs = sysinitseg, ds = relocated stack code seg,\nes = segment of stack space\ncx = number of entries\nes:bp => base of stacks - 2\nes:bx => first table entry");
	MakeCode	(x=0X544B);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X544F,	"[es:bp+allocbyte],free");
	MakeComm	(0X5454,	"[es:bp+intlevel]\nax = 0");
	MakeComm	(0X5458,	"[es:bp+savedsp]");
	MakeComm	(0X545C,	"[es:bp+savedss]");
	MakeCode	(x=0X5460);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X5464,	"[es:bp+newsp]");
	MakeComm	(0X546B,	"entrysize");
	MakeComm	(0X5470,	"entrysize");
	MakeCode	(x=0X5473);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X5477);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X547C,	"look at the model byte");
	MakeComm	(0X5481,	"mdl_convert ; convertible?");
	MakeCode	(x=0X5481);
	OpHex		(x,	1);
	MakeComm	(0X5489,	"disable convertible nmis");
	MakeComm	(0X548B,	"CMOS Memory/RTC Index Register (Extended RAM)");
	MakeCode	(x=0X548B);
	OpHex		(x,	0);
	MakeComm	(0X5492,	"Int 02h vector table offset");
	MakeCode	(x=0X5492);
	OpHex		(x,	1);
	MakeName	(0X5492,	"stkinit_02");
	MakeCode	(x=0X5495);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X5498);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X549B);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X54A1,	"Int 08h vector table offset");
	MakeCode	(x=0X54A1);
	OpHex		(x,	1);
	MakeName	(0X54A1,	"stkinit_08");
	MakeCode	(x=0X54A4);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X54A7);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X54AA);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X54B0,	"Int 09h vector table offset");
	MakeCode	(x=0X54B0);
	OpHex		(x,	1);
	MakeName	(0X54B0,	"stkinit_09");
	MakeCode	(x=0X54B3);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X54B6);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X54B9);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X54BF,	"Int 70h vector table offset");
	MakeCode	(x=0X54BF);
	OpHex		(x,	1);
	MakeName	(0X54BF,	"stkinit_70");
	MakeCode	(x=0X54C2);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X54C5);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X54C8);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X54CE,	"0Ah*4 ; 40\nInt 0Ah vector table offset");
	MakeCode	(x=0X54CE);
	OpHex		(x,	1);
	MakeName	(0X54CE,	"stkinit_0A");
	MakeComm	(0X54D1,	"save relocated stack code segment");
	MakeComm	(0X54D2,	"ds:bx -> original interrupt handler");
	MakeComm	(0X54D6,	"dx = segment value");
	MakeComm	(0X54DC,	"does vector point to an iret?");
	MakeCode	(x=0X54DC);
	OpHex		(x,	1);
	MakeComm	(0X54E1,	"magic offset (see int&aa, msstack.inc)");
	MakeCode	(x=0X54E1);
	OpHex		(x,	1);
	MakeComm	(0X54E8,	"rom bios segment");
	MakeComm	(0X54FE,	"not the first. we are going to hook vector.");
	MakeComm	(0X54FF,	"we have to set old&aa for int19 handler too.");
	MakeCode	(x=0X54FF);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X5502,	"pass where to save original owner pointer");
	MakeCode	(x=0X5502);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X5505,	"pass where new handler is");
	MakeCode	(x=0X5505);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X5508,	"adjust the vector to new handler,\nsaving pointer to original owner.");
	MakeComm	(0X550D,	"the first. don't have to hook stack code.");
	MakeCode	(0X550D);
	MakeComm	(0X550E,	"Int 0Bh vector table offset");
	MakeCode	(x=0X550E);
	OpHex		(x,	1);
	MakeCode	(x=0X551C);
	OpHex		(x,	1);
	MakeCode	(x=0X5521);
	OpHex		(x,	1);
	MakeCode	(x=0X553F);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X5542);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X5545);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X554D);
	MakeComm	(0X554E,	"Int 0Ch vector table offset");
	MakeCode	(x=0X554E);
	OpHex		(x,	1);
	MakeCode	(x=0X555C);
	OpHex		(x,	1);
	MakeCode	(x=0X5561);
	OpHex		(x,	1);
	MakeCode	(x=0X557F);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X5582);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X5585);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X558D);
	MakeComm	(0X558E,	"Int 0Dh vector table offset");
	MakeCode	(x=0X558E);
	OpHex		(x,	1);
	MakeCode	(x=0X559C);
	OpHex		(x,	1);
	MakeCode	(x=0X55A1);
	OpHex		(x,	1);
	MakeCode	(x=0X55BF);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X55C2);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X55C5);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X55CD);
	MakeComm	(0X55CE,	"0Eh*4 ; Int 0Eh vector table offset");
	MakeCode	(x=0X55CE);
	OpHex		(x,	1);
	MakeCode	(x=0X55DC);
	OpHex		(x,	1);
	MakeCode	(x=0X55E1);
	OpHex		(x,	1);
	MakeCode	(x=0X55FF);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X5602);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X5605);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X560D);
	MakeComm	(0X560E,	"72h*4 ; 456\nInt 72h vector table offset");
	MakeCode	(x=0X561C);
	OpHex		(x,	1);
	MakeCode	(x=0X5621);
	OpHex		(x,	1);
	MakeCode	(x=0X563F);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X5642);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X5645);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X564D);
	MakeComm	(0X564E,	"73h*4 ; 460");
	MakeCode	(x=0X565C);
	OpHex		(x,	1);
	MakeCode	(x=0X5661);
	OpHex		(x,	1);
	MakeCode	(x=0X567F);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X5682);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X5685);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X568D);
	MakeComm	(0X568E,	"74h*4 ; 464");
	MakeCode	(x=0X569C);
	OpHex		(x,	1);
	MakeCode	(x=0X56A1);
	OpHex		(x,	1);
	MakeCode	(x=0X56BF);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X56C2);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X56C5);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X56CD);
	MakeComm	(0X56CE,	"76h*4 ; 472");
	MakeCode	(x=0X56DC);
	OpHex		(x,	1);
	MakeCode	(x=0X56E1);
	OpHex		(x,	1);
	MakeCode	(x=0X56FF);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X5702);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X5705);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X570D);
	MakeComm	(0X570E,	"mov si,77h*4 ; 476\nInt 77h vector table offset");
	MakeComm	(0X5711,	"save relocated stack code segment");
	MakeComm	(0X5712,	"ds:bx -> original interrupt handler");
	MakeComm	(0X5716,	"dx = segment value");
	MakeComm	(0X571C,	"does vector point to an iret?");
	MakeCode	(x=0X571C);
	OpHex		(x,	1);
	MakeComm	(0X5721,	"magic offset (see int&aa, msstack.inc)");
	MakeCode	(x=0X5721);
	OpHex		(x,	1);
	MakeComm	(0X5728,	"rom bios segment");
	MakeComm	(0X573E,	"not the first. we are going to hook vector.");
	MakeComm	(0X573F,	"we have to set old&aa for int19 handler too.");
	MakeCode	(x=0X573F);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeComm	(0X5742,	"pass where to save original owner pointer");
	MakeCode	(x=0X5742);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X5745,	"pass where new handler is");
	MakeCode	(x=0X5745);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X5748,	"adjust the vector to new handler,\nsaving pointer to original owner.");
	MakeComm	(0X574D,	"the first. don't have to hook stack code.");
	MakeCode	(0X574D);
	MakeComm	(0X5754,	"mdl_convert ; pc convertible?");
	MakeCode	(x=0X5754);
	OpHex		(x,	1);
	MakeComm	(0X575C,	"enable convertible nmis");
	MakeCode	(x=0X575C);
	OpHex		(x,	1);
	MakeComm	(0X575E,	"CMOS Memory/RTC Index Register (Extended RAM)");
	MakeCode	(x=0X575E);
	OpHex		(x,	0);
	MakeComm	(0X5761,	"DOSBIODATASEG");
	MakeCode	(x=0X5761);
	OpHex		(x,	1);
	MakeComm	(0X5766,	"indicate that int 19h\ninitialization is complete");
	MakeCode	(x=0X5766);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X5775,	"new stack initialization\n(dx = new handler offset,\n bx = original handler saving addr,\n si = int vector table offset\n di = int19old?? field offset\n                -in DOSBIOSDATASEG-\n es = zero, segid of vector table\n ds = relocated stack code segment)");
	MakeCode	(0X5775);
	MakeName	(0X5775,	"new_init_loop");
	MakeComm	(0X5782,	"DOSBIODATASEG");
	MakeCode	(x=0X5782);
	OpHex		(x,	1);
	MakeComm	(0X579C,	"set the devmark for mem command.\nin:\n  [memhi] - the address to place devmark\n  [memlo] = 0\n  al = id for devmark_id\nout:\n  devmark established.\n  the address saved in cs:[devmark_addr]\n  [memhi] increase by 1.");
	MakeCode	(0X579C);
	MakeName	(0X579C,	"setdevmark");
	MakeComm	(0X57BC,	"when config_wrkseg is being used as\na scratch env, this is its length");
	MakeWord	(0X57BC);
	MakeName	(0X57BC,	"config_envlen");
	MakeComm	(0X57BE,	"config work area (above confbot)\nsegment of work area");
	MakeWord	(0X57BE);
	MakeName	(0X57BE,	"config_wrkseg");
	MakeComm	(0X57C0,	"current config cmd\n(with CONFIG_OPTION_QUERY bit intact)");
	MakeByte	(0X57C0);
	MakeName	(0X57C0,	"config_cmd");
	MakeComm	(0X57C1,	"non-zero if multi-config config.sys");
	MakeByte	(0X57C1);
	MakeName	(0X57C1,	"config_multi");
	MakeByte	(0X57C2);
	MakeName	(0X57C2,	"multdeviceflag");
	MakeComm	(0X57C3,	"segment address for devmark.");
	MakeWord	(0X57C3);
	MakeName	(0X57C3,	"devmark_addr");
	MakeComm	(0X57C5,	"flag used for devmark");
	MakeByte	(0X57C5);
	MakeName	(0X57C5,	"setdevmarkflag");
	MakeComm	(0X57C6,	"total unitcount for driver");
	MakeByte	(0X57C6);
	MakeName	(0X57C6,	"driver_units");
	MakeComm	(0X57C7,	"(not used)");
	MakeByte	(0X57C7);
	MakeName	(0X57C7,	"ems_stub_installed");
	MakeComm	(0X57C8,	"badparm_off equ badparm_ptr\nbadparm_seg equ badparm_ptr+2");
	MakeDword	(0X57C8);
	MakeName	(0X57C8,	"badparm_ptr");
	MakeComm	(0X57CC,	"Operand ordinal save area");
	MakeWord	(0X57CC);
	MakeName	(0X57CC,	"_$P_ORDINAL");
	MakeComm	(0X57CE,	"Return code from parser");
	MakeWord	(0X57CE);
	MakeName	(0X57CE,	"_$P_RC");
	MakeComm	(0X57D0,	"Pointer of command buffer");
	MakeWord	(0X57D0);
	MakeName	(0X57D0,	"_$P_SI_Save");
	MakeComm	(0X57D2,	"Return result buffer address");
	MakeWord	(0X57D2);
	MakeName	(0X57D2,	"_$P_DX");
	MakeComm	(0X57D4,	"Terminator code (ASCII)");
	MakeByte	(0X57D4);
	MakeName	(0X57D4,	"_$P_Terminator");
	MakeComm	(0X57D5,	"Offset of DBCS EV");
	MakeWord	(0X57D5);
	MakeName	(0X57D5,	"_$P_DBCSEV_OFF");
	MakeComm	(0X57D7,	"Segment of DBCS EV");
	MakeWord	(0X57D7);
	MakeName	(0X57D7,	"_$P_DBCSEV_SEG");
	MakeComm	(0X57D9,	"Parser internal flags\n%define _$P_Flags1 _$P_Flags\n        to reference 1st byte flags\n%define _$P_Flags2 _$P_Flags+1\n        to reference 2nd byte flags only");
	MakeByte	(0X57D9);
	MakeName	(0X57D9,	"_$P_Flags");
	MakeByte	(0X57DA);
	MakeName	(0X57DA,	"_$P_Flags2");
	MakeComm	(0X57DB,	"save si for later use by complex");
	MakeWord	(0X57DB);
	MakeName	(0X57DB,	"_$P_SaveSI_Cmpx");
	MakeComm	(0X57DD,	"points next to \"=\" or \":\" code");
	MakeWord	(0X57DD);
	MakeName	(0X57DD,	"_$P_KEYorSW_Ptr");
	MakeComm	(0X57DF,	"save pointer to EOB");
	MakeWord	(0X57DF);
	MakeName	(0X57DF,	"_$P_Save_EOB");
	MakeComm	(0X57E1,	"es:@ points to found synonym");
	MakeWord	(0X57E1);
	MakeName	(0X57E1,	"_$P_Found_SYNONYM");
	MakeComm	(0X57E3,	"Pick a operand from command line");
	MakeByte	(x=0X57E3);
	MakeArray	(x,	0X80);
	OpDecimal	(x,	0);
	MakeName	(0X57E3,	"_$P_STRING_BUF");
	MakeComm	(0X5863,	"info id");
	MakeByte	(0X5863);
	MakeName	(0X5863,	"_$P_Char_CAP_Ptr");
	MakeComm	(0X5864,	"offset of char case map table");
	MakeWord	(0X5864);
	MakeComm	(0X5866,	"segment of char case map table");
	MakeWord	(0X5866);
	MakeComm	(0X5868,	"delimitters of file spec\n_$P_FileSp_Len equ $-_$P_FileSp_Char");
	MakeStr		(0X5868,	0X5871);
	MakeName	(0X5868,	"_$P_FileSp_Char");
	MakeComm	(0X5871,	"flag set if filespec parsing error\nwas detected");
	MakeByte	(0X5871);
	MakeName	(0X5871,	"_$P_err_flag");
	MakeComm	(0X5872,	"Clear all internal flags");
	MakeCode	(0X5872);
	MakeName	(0X5872,	"SysParse");
	MakeComm	(0X5879,	"confirm forward direction");
	MakeComm	(0X587A,	"save operand ordinal");
	MakeComm	(0X587F,	"_$P_No_Error ; assume no error");
	MakeComm	(0X5886,	"initalize synonym pointer");
	MakeComm	(0X588D,	"The table of special chars _$P_FileSp_Char\nshould be initialized on every entry to SysParse");
	MakeComm	(0X58B0,	"Move si to 1st non white space");
	MakeComm	(0X58B3,	"If EOL is not encountered, do parse");
	MakeComm	(0X58B5,	"_$P_RC_EOL  ; set exit code to -1");
	MakeComm	(0X58B9,	"[es:di+_$P_PARMS_Blk.PARMSX_Address]\nGet the PARMSX address to");
	MakeComm	(0X58BC,	"[es:bx+_$P_PARMSX_Blk.MinP]\ncheck ORDINAL to see if the minimum");
	MakeComm	(0X58BF,	"positional found.");
	MakeComm	(0X58C1,	"$P_Op_Missing ; If no, set exit code to missing operand");
	MakeComm	(0X58C5,	"return to the caller");
	MakeComm	(0X58C8,	"save ptr to command line for later use\nby complex quoted string or file spec.");
	MakeCode	(0X58C8);
	MakeComm	(0X58D0,	"set buffer to copy from command string");
	MakeCode	(x=0X58D0);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X58D4,	"_$P_Extra ; 3/9 extra delimiter encountered ?");
	MakeCode	(x=0X58D4);
	OpHex		(x,	1);
	MakeComm	(0X58DA,	"3/9 if yes, no need to copy");
	MakeComm	(0X58DC,	"Pick a operand from buffer");
	MakeComm	(0X58DD,	"Check switch character");
	MakeComm	(0X58E0,	"if carry set found delimiter type slash, \nneed backup si, else continue");
	MakeComm	(0X58E2,	"Check EOL character");
	MakeComm	(0X58E5,	"need backup si");
	MakeComm	(0X58E7,	"Check delimiter");
	MakeComm	(0X58EA,	"If no, process next byte");
	MakeComm	(0X58EC,	"_$P_Extra ; 3/9 If yes and white spec,");
	MakeCode	(x=0X58EC);
	OpHex		(x,	1);
	MakeComm	(0X58F2,	"3/9 then");
	MakeComm	(0X58F4,	"skip subsequent white space,too");
	MakeComm	(0X58F7,	"finish copy by placing NUL at end");
	MakeComm	(0X58F9,	"_$P_SW+_$P_equ");
	MakeCode	(x=0X58F9);
	OpHex		(x,	1);
	MakeComm	(0X5904,	"move byte to STRING_BUF");
	MakeCode	(0X5904);
	MakeComm	(0X5907,	"_$P_Keyword ; if it is equal character,");
	MakeComm	(0X5909,	"then");
	MakeComm	(0X590B,	"_$P_equ ; remember it in flag");
	MakeCode	(x=0X590B);
	OpHex		(x,	1);
	MakeComm	(0X5911,	"ready to see next byte");
	MakeComm	(0X5912,	"was it 1st byte of DBCS ?");
	MakeComm	(0X5915,	"if no, process to next byte");
	MakeComm	(0X5918,	"if yes, store 2nd byte of DBCS");
	MakeComm	(0X591B,	"update pointer");
	MakeComm	(0X591C,	"process to next byte");
	MakeComm	(0X591E,	"backup si pointer");
	MakeCode	(0X591E);
	MakeComm	(0X591F,	"save next pointer, SI");
	MakeComm	(0X5924,	"_$P_NULL ; put NULL at the end");
	MakeComm	(0X5928,	"keep the address for later use of complex");
	MakeComm	(0X592D,	"[es:di+_$P_PARMS_Blk.PARMSX_Address]\nget PARMSX address");
	MakeCode	(x=0X5930);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X5934,	"the operand begins w/ switch char ?\n_$P_Switch");
	MakeComm	(0X5938,	"if yes, process as switch");
	MakeComm	(0X593A,	"_$P_DQuote  ; is it a string?");
	MakeComm	(0X593E,	"if so, process as one!");
	MakeComm	(0X5940,	"$P_equ ; the operand includes equal");
	MakeCode	(x=0X5940);
	OpHex		(x,	1);
	MakeComm	(0X5946,	"if yes, process as keyword");
	MakeComm	(0X5948,	"else process as positional\nget maxp");
	MakeComm	(0X594C,	"ax = maxp");
	MakeComm	(0X594E,	"too many positional ?");
	MakeComm	(0X5953,	"if yes, set exit code to too many");
	MakeComm	(0X5955,	"see what the current ordinal");
	MakeComm	(0X5959,	"ax = ax*2");
	MakeCode	(x=0X5959);
	OpHex		(x,	1);
	MakeComm	(0X595C,	"add '2' to bx reg\nnow bx points to 1st CONTROL");
	MakeComm	(0X595D,	"now bx points to specified CONTROL address");
	MakeComm	(0X595F,	"now bx points to specified CONTROL itself");
	MakeComm	(0X5962,	"Do process for positional");
	MakeComm	(0X5965,	"and return to the caller");
	MakeComm	(0X5967,	"set exit code");
	MakeCode	(0X5967);
	MakeComm	(0X596E,	"and return to the caller");
	MakeComm	(0X5970,	"[es:bx+_$P_PARMSX_Blk.MaxP] ; get maxp");
	MakeCode	(0X5970);
	MakeComm	(0X5974,	"ax = maxp");
	MakeComm	(0X5977,	"ax = (ax+1)*2");
	MakeCode	(x=0X5977);
	OpHex		(x,	1);
	MakeComm	(0X5979,	"now bx points to maxs");
	MakeComm	(0X597E,	"cx = maxs");
	MakeComm	(0X5980,	"at least one switch ?");
	MakeComm	(0X5982,	"no");
	MakeComm	(0X5984,	"now bx points to 1st CONTROL address");
	MakeComm	(0X5986,	"bx points to Switch CONTROL itself");
	MakeComm	(0X5989,	"do process for switch");
	MakeComm	(0X598D,	"\nif the CONTROL is for the switch, exit");
	MakeComm	(0X5990,	"   add '2' to bx reg\nelse bx points to the next CONTROL");
	MakeComm	(0X5991,	"and loop");
	MakeComm	(0X5993,	"_$P_Not_In_SW \nhere no CONTROL for the switch has");
	MakeComm	(0X599C,	"[es:bx+_$P_PARMSX_Blk.MaxP] ; get maxp");
	MakeCode	(0X599C);
	MakeComm	(0X59A0,	"ax = maxp");
	MakeComm	(0X59A3,	"ax = (ax+1)*2");
	MakeCode	(x=0X59A3);
	OpHex		(x,	1);
	MakeComm	(0X59A5,	"now bx points to maxs");
	MakeComm	(0X59AA,	"ax = maxs");
	MakeCode	(x=0X59AC);
	OpHex		(x,	1);
	MakeComm	(0X59AE,	"ax = ax*2+1");
	MakeComm	(0X59AF,	"now bx points to maxk");
	MakeComm	(0X59B4,	"cx = maxk");
	MakeComm	(0X59B6,	"at least one keyword ?");
	MakeComm	(0X59B8,	"no");
	MakeComm	(0X59BA,	"now bx points to 1st CONTROL");
	MakeComm	(0X59BC,	"bx points to keyword CONTROL itself");
	MakeComm	(0X59BF,	"do process for keyword");
	MakeComm	(0X59C3,	"\nif the CONTROL is for the keyword, exit");
	MakeComm	(0X59C6,	"   add '2' to bx reg\nelse bx points to the next CONTROL");
	MakeComm	(0X59C7,	"and loop");
	MakeComm	(0X59C9,	"_$P_Not_In_Key\nhere no CONTROL for the keyword has");
	MakeComm	(0X59D3,	"return next ordinal");
	MakeComm	(0X59D8,	"return exit code");
	MakeComm	(0X59DC,	"return next operand pointer");
	MakeComm	(0X59E1,	"return result buffer address");
	MakeComm	(0X59E6,	"return delimiter code found");
	MakeCode	(0X59ED);
	MakeName	(0X59ED,	"_$P_Chk_Pos_Control");
	MakeComm	(0X59EE,	"[es:bx+_$P_Control_Blk.Match_Flag]");
	MakeComm	(0X59F1,	"$P_Repeat ; repeat allowed ?");
	MakeCode	(x=0X59F1);
	OpHex		(x,	1);
	MakeComm	(0X59F4,	"then do not increment ORDINAL");
	MakeComm	(0X59F6,	"update the ordinal");
	MakeComm	(0X59FB,	"_$P_NULL ; no data ?");
	MakeComm	(0X5A01,	"_$P_Optional ; yes, then is it optional ?");
	MakeCode	(x=0X5A01);
	OpHex		(x,	1);
	MakeComm	(0X5A06,	"_$P_Op_Missing ; no, then error");
	MakeCode	(0X5A0F);
	MakeComm	(0X5A10,	"_$P_String");
	MakeComm	(0X5A12,	"_$P_No_Tag\nif it is optional return NULL\nno item tag indication");
	MakeCode	(0X5A1A);
	MakeComm	(0X5A1F,	"this logic works \nwhen the KeySW is reset.");
	MakeCode	(0X5A1F);
	MakeName	(0X5A1F,	"_$P_Chk_Key_Control");
	MakeCode	(0X5A21);
	MakeName	(0X5A21,	"_$P_Search_KEYorSW");
	MakeComm	(0X5A23,	"[es:bx+_$P_Control_Blk.nid] ; Get synonym count");
	MakeComm	(0X5A27,	"and set it to cx");
	MakeComm	(0X5A29,	"No synonyms specified ?");
	MakeComm	(0X5A2B,	"then indicate not found by CY");
	MakeComm	(0X5A2D,	"[bx+_$P_Control_Blk.KEYorSW]");
	MakeComm	(0X5A30,	"compare string in buffer w/ the synonym");
	MakeComm	(0X5A33,	"If match, set it to synonym pointer");
	MakeComm	(0X5A35,	"else, bp points to the next string");
	MakeComm	(0X5A38,	"loop nid times");
	MakeComm	(0X5A3A,	"indicate not found in synonym list");
	MakeComm	(0X5A3B,	"and exit");
	MakeComm	(0X5A3D,	"set synonym pointer");
	MakeCode	(0X5A3D);
	MakeComm	(0X5A42,	"indicate found");
	MakeComm	(0X5A46,	"_$P_NULL\nIncrement BP that points");
	MakeCode	(0X5A46);
	MakeName	(0X5A46,	"_$P_MoveBP_NUL");
	MakeComm	(0X5A4B,	"to the synomym list");
	MakeComm	(0X5A4D,	"until");
	MakeComm	(0X5A4E,	"NULL encountered.\n_$P_MBP_Loop");
	MakeComm	(0X5A50,	"bp points to next to NULL");
	MakeCode	(0X5A50);
	MakeComm	(0X5A52,	"(Check if switch is supported)\n_$P_SW_Cmp\nIndicate switch for later string comparison");
	MakeCode	(x=0X5A52);
	OpHex		(x,	1);
	MakeName	(0X5A52,	"_$P_Chk_SW_Control");
	MakeComm	(0X5A58,	"Search the switch in the CONTROL block");
	MakeComm	(0X5A5B,	"not found, then try next CONTROL");
	MakeComm	(0X5A5D,	"and byte [cs:_$P_Flags2],0FFh-_$P_SW_Cmp\nreset the indicator previously set /switch");
	MakeCode	(x=0X5A5D);
	OpHex		(x,	1);
	MakeComm	(0X5A68,	"[si] = KEY or SW");
	MakeComm	(0X5A6A,	"update for complex list");
	MakeComm	(0X5A70,	"set si at the end or colon");
	MakeComm	(0X5A75,	"_$P_NULL ; any data after colon ?");
	MakeComm	(0X5A79,	"if yes, process match flags");
	MakeComm	(0X5A7B,	"_$P_Colon\nif no, the switch terminated by colon ?");
	MakeCode	(x=0X5A7B);
	OpChr		(x,	1);
	MakeComm	(0X5A80,	"\nif yes,");
	MakeComm	(0X5A82,	"_$P_Syntax ; return syntax error");
	MakeComm	(0X5A8B,	"[es:bx+_$P_Control_Blk.Match_Flag]\nshould have data? \nzero match flag means switch followed by nothing is OK");
	MakeCode	(0X5A8B);
	MakeComm	(0X5A8F,	"match flags not zero so\nshould have something if optional bit is not on");
	MakeComm	(0X5A91,	"_$P_Optional ; see if no value is valid");
	MakeCode	(x=0X5A91);
	OpHex		(x,	1);
	MakeComm	(0X5A96,	"if so, then leave, else yell");
	MakeComm	(0X5A98,	"_$P_Op_Missing\nreturn required operand missing");
	MakeComm	(0X5AA1,	"process match flag");
	MakeCode	(0X5AA1);
	MakeComm	(0X5AA4,	"indicate match");
	MakeComm	(0X5AA7,	"not found in switch synonym list");
	MakeCode	(0X5AA7);
	MakeCode	(0X5AAA);
	MakeComm	(0X5AAB,	"_$P_String");
	MakeComm	(0X5AAD,	"_$ P_No_Tag");
	MakeComm	(0X5AAF,	"set result buffer");
	MakeCode	(0X5AB5);
	MakeName	(0X5AB5,	"_$P_Fill_Result");
	MakeComm	(0X5AB6,	"[es:bx+_$P_Control_Blk.Result_Buf]\ndi points to result buffer");
	MakeComm	(0X5ABA,	"set returned result address");
	MakeComm	(0X5ABF,	"[es:di+_$P_Result_Blk.Type] ; store type");
	MakeComm	(0X5AC2,	"[es:di+_$P_Result_Blk.Item_Tag] ; store item tag");
	MakeComm	(0X5ACB,	"[es:di+_$P_Result_Blk.SYNONYM_Ptr]");
	MakeComm	(0X5AD0,	"\n_$P_Number ; if number");
	MakeName	(0X5AD0,	"_$P_RLT04");
	MakeComm	(0X5AD2,	"\nthen store 32 bit");
	MakeComm	(0X5AD4,	"[es:di+_$P_Result_Blk.Picked_Val]");
	MakeComm	(0X5AD8,	"[es:di+_$P_Result_Blk.Picked_Val+2]");
	MakeComm	(0X5ADE,	"_$P_List_Idx ; if list index");
	MakeCode	(0X5ADE);
	MakeComm	(0X5AE0,	"\nthen store list index");
	MakeComm	(0X5AE2,	"[es:di+_$P_Result_Blk.Picked_Val]");
	MakeComm	(0X5AE8,	"_$P_Date_F ; Date format ?");
	MakeCode	(0X5AE8);
	MakeComm	(0X5AEC,	"_$P_Time_F ; Time format ?");
	MakeComm	(0X5AF0,	"_$P_Drive ; drive format ?");
	MakeComm	(0X5AF4,	"[es:di+_$P_Result_Blk.Picked_Val]\nstore drive number");
	MakeComm	(0X5AFA,	"_$P_Complex ; complex format ?");
	MakeCode	(0X5AFA);
	MakeComm	(0X5AFE,	"\nthen get pointer in command buffer");
	MakeComm	(0X5B02,	"skip left Parentheses");
	MakeComm	(0X5B03,	"[es:di+_$P_Result_Blk.Picked_Val]\nstore offset");
	MakeComm	(0X5B07,	"[es:di+_$P_Result_Blk.Picked_Val+2]\nstore segment");
	MakeComm	(0X5B0D,	"AL = 3, 5, or 9\n[es:di+_$P_Result_Blk.Picked_Val]\nstore offset of STRING_BUF");
	MakeCode	(0X5B0D);
	MakeComm	(0X5B11,	"[es:di+_$P_Result_Blk.Picked_Val+2]\nstore segment of STRING_BUF");
	MakeComm	(0X5B16,	"[es:bx+_$P_Control_Blk.Function_Flag],\n_$P_CAP_File \nneed CAPS by file table?");
	MakeCode	(x=0X5B16);
	OpHex		(x,	1);
	MakeComm	(0X5B1D,	"_$P_DOSTBL_File ; use file upper case table");
	MakeComm	(0X5B21,	"[es:bx+_$P_Control_Blk.Function_Flag],\n_$P_CAP_Char \nneed CAPS by char table");
	MakeCode	(x=0X5B21);
	OpHex		(x,	1);
	MakeComm	(0X5B28,	"_$P_DOSTBL_Char\nuse character upper case table");
	MakeComm	(0X5B2A,	"process CAPS along the table");
	MakeComm	(0X5B2E,	"[es:bx+_$P_Control_Blk.Function_Flag],\n_$P_Rm_Colon \nremoving colon at end ?");
	MakeCode	(x=0X5B2E);
	OpHex		(x,	1);
	MakeComm	(0X5B35,	"then process it.");
	MakeComm	(0X5B3A,	"_$P_NULL ; clear filespec error flag.");
	MakeCode	(0X5B3A);
	MakeName	(0X5B3A,	"_$P_Check_Match_Flags");
	MakeComm	(0X5B41,	"[es:bx+_$P_Control_Blk.Match_Flag]\nload match flag (16bit) to ax");
	MakeComm	(0X5B44,	"test ax for zero");
	MakeComm	(0X5B4C,	"_$P_Syntax");
	MakeComm	(0X5B53,	"_$P_No_Tag");
	MakeComm	(0X5B55,	"_$P_String");
	MakeCode	(0X5B60);
	MakeCode	(0X5B62);
	MakeComm	(0X5B64,	"90h");
	MakeCode	(0X5B64);
	MakeComm	(0X5B65,	"_$P_Num_Val ; Numeric value");
	MakeCode	(x=0X5B65);
	OpHex		(x,	1);
	MakeComm	(0X5B6A,	"_$P_No_Error ; assume no error");
	MakeComm	(0X5B71,	"do process");
	MakeComm	(0X5B74,	"_$P_Syntax ; if error, examine the next type");
	MakeComm	(0X5B7C,	"_$P_SNum_Val ; Signed numeric value");
	MakeCode	(x=0X5B7C);
	OpHex		(x,	1);
	MakeComm	(0X5B81,	"_$P_No_Error ; assume no error");
	MakeComm	(0X5B88,	"do process");
	MakeComm	(0X5B8B,	"_$P_Syntax ; if error, examine the next type");
	MakeComm	(0X5B93,	"_$P_Drv_Only ; Drive only");
	MakeCode	(x=0X5B93);
	OpHex		(x,	1);
	MakeComm	(0X5B98,	"_$P_No_Error ; assume no error");
	MakeComm	(0X5B9F,	"1st, call file format");
	MakeComm	(0X5BA2,	"check drive format, next");
	MakeComm	(0X5BA5,	"_$P_Syntax ; if error, examine the next type");
	MakeComm	(0X5BAD,	"_$P_File_Spc ; File spec");
	MakeCode	(x=0X5BAD);
	OpHex		(x,	1);
	MakeComm	(0X5BB2,	"_$P_No_Error ; assume no error");
	MakeComm	(0X5BB9,	"do process");
	MakeComm	(0X5BBC,	"_$P_Syntax ; if error, examine the next type");
	MakeComm	(0X5BC4,	"_$P_Simple_S ; Simple string");
	MakeCode	(x=0X5BC4);
	OpHex		(x,	1);
	MakeComm	(0X5BC9,	"_$P_No_Error ; assume no error");
	MakeComm	(0X5BD0,	"do process");
	MakeComm	(0X5BD3,	"_$P_error_filespec ; bad filespec ?");
	MakeComm	(0X5BD9,	"no, continue");
	MakeComm	(0X5BDB,	"_$P_No_Error ; check for other errors ?");
	MakeComm	(0X5BE1,	"no, continue");
	MakeComm	(0X5BE3,	"_$P_Syntax ; set error flag");
	MakeCode	(0X5BEC);
	MakeName	(0X5BEC,	"_$P_Remove_Colon");
	MakeComm	(0X5BEE,	"get character");
	MakeComm	(0X5BF1,	"end of string ?");
	MakeComm	(0X5BF3,	"if yes, just exit");
	MakeComm	(0X5BF5,	"_$P_Colon ; is it colon ?");
	MakeCode	(x=0X5BF5);
	OpChr		(x,	1);
	MakeComm	(0X5BF9,	"_$P_NULL\nif so, next is NULL ?");
	MakeComm	(0X5C00,	"_$P_NULL ; yes, remove colon");
	MakeComm	(0X5C04,	"and exit.");
	MakeComm	(0X5C06,	"if not colon, then check if\nDBCS leading byte.");
	MakeCode	(0X5C06);
	MakeComm	(0X5C0B,	"if yes, skip trailing byte");
	MakeComm	(0X5C0C,	"si points to next byte");
	MakeComm	(0X5C0D,	"loop until NULL encountered");
	MakeCode	(0X5C0F);
	MakeCode	(0X5C12);
	MakeName	(0X5C12,	"_$P_Do_CAPS_String");
	MakeComm	(0X5C14,	"save info id");
	MakeComm	(0X5C16,	"load charater and");
	MakeComm	(0X5C19,	"check if DBCS leading byte");
	MakeComm	(0X5C1C,	"if yes, do not need CAPS");
	MakeComm	(0X5C1E,	"end of string ?");
	MakeComm	(0X5C20,	"then exit.");
	MakeComm	(0X5C22,	"Here a SBCS char need to be CAPS");
	MakeComm	(0X5C25,	"stored upper case char to buffer");
	MakeComm	(0X5C28,	"process next");
	MakeComm	(0X5C2A,	"skip DBCS leading and trailing byte");
	MakeCode	(0X5C2A);
	MakeComm	(0X5C2B,	"si points to next byte");
	MakeComm	(0X5C2C,	"loop until NULL encountered");
	MakeCode	(0X5C2E);
	MakeComm	(0X5C31,	"_$P_ASCII80 ; need upper case table ?");
	MakeCode	(x=0X5C31);
	OpHex		(x,	1);
	MakeName	(0X5C31,	"_$P_Do_CAPS_Char");
	MakeComm	(0X5C33,	"no");
	MakeComm	(0X5C35,	"check if  \"a\" <= AL <= \"z\"");
	MakeCode	(x=0X5C35);
	OpChr		(x,	1);
	MakeCode	(x=0X5C39);
	OpChr		(x,	1);
	MakeComm	(0X5C3D,	"_$P_Make_Upper ; make CAPS");
	MakeCode	(x=0X5C3D);
	OpHex		(x,	1);
	MakeCode	(0X5C41);
	MakeComm	(0X5C44,	"or use char CAPS table ?");
	MakeCode	(x=0X5C44);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X5C48,	"already got table address ?");
	MakeComm	(0X5C4B,	"no");
	MakeComm	(0X5C52,	"_$P_DOS_Get_TBL");
	MakeCode	(x=0X5C52);
	OpHex		(x,	1);
	MakeComm	(0X5C54,	"function");
	MakeComm	(0X5C56,	"_$P_DOSTBL_Def = -1");
	MakeComm	(0X5C59,	"_$P_DOSTBL_BL");
	MakeComm	(0X5C5C,	"_$P_DOSTBL_Def");
	MakeComm	(0X5C5F,	"DOS - 4.x internal\nCOUNTRY-DEPENDENT FILENAME CAPITALIZATION\nAL = function -\n\nDI already set to point to buffer");
	MakeCode	(x=0X5C5F);
	OpHex		(x,	0);
	MakeComm	(0X5C64,	"[cs:di+_$P_DOS_TBL.Off]\nget offset of table");
	MakeComm	(0X5C68,	"[cs:di+_$P_DOS_TBL.Seg]\nget segment of table");
	MakeComm	(0X5C6D,	"add 2 to bx reg");
	MakeComm	(0X5C6E,	"_$P_ASCII80 ; make char to index");
	MakeCode	(x=0X5C6E);
	OpHex		(x,	1);
	MakeComm	(0X5C70,	"perform case map");
	MakeCode	(0X5C76);
	MakeName	(0X5C76,	"_$P_SValue");
	MakeComm	(0X5C77,	"_$P_Signed ; indicate a signed numeric");
	MakeCode	(x=0X5C77);
	OpHex		(x,	1);
	MakeComm	(0X5C7D,	"0FFh-_$P_Neg ; assume positive value\nand byte [cs:$_Flags2],~_$P_Neg ; ~2");
	MakeCode	(x=0X5C7D);
	OpHex		(x,	1);
	MakeComm	(0X5C83,	"get sign");
	MakeComm	(0X5C86,	"_$P_Plus");
	MakeCode	(x=0X5C86);
	OpChr		(x,	1);
	MakeComm	(0X5C8A,	"_$P_Minus");
	MakeCode	(x=0X5C8A);
	OpChr		(x,	1);
	MakeComm	(0X5C8E,	"_$P_Neg\nset this is negative value");
	MakeCode	(x=0X5C8E);
	OpHex		(x,	1);
	MakeComm	(0X5C94,	"skip sign char");
	MakeComm	(0X5C95,	"and process value");
	MakeCode	(0X5C9A);
	MakeName	(0X5C9A,	"_$P_Value");
	MakeComm	(0X5C9E,	"cx = higher 16 bits");
	MakeComm	(0X5CA0,	"dx = lower 16 bits");
	MakeComm	(0X5CA3,	"get character");
	MakeComm	(0X5CA6,	"end of line ?");
	MakeComm	(0X5CAA,	"make asc(0..9) to bin(0..9)");
	MakeComm	(0X5CAD,	"then error, exit");
	MakeComm	(0X5CB1,	"save binary number");
	MakeComm	(0X5CB3,	"to have 2*x");
	MakeCode	(x=0X5CB3);
	OpHex		(x,	1);
	MakeComm	(0X5CB5,	"shift left w/ carry");
	MakeCode	(x=0X5CB5);
	OpHex		(x,	1);
	MakeComm	(0X5CB7,	"Overflow occurred ?");
	MakeComm	(0X5CBA,	"then error, exit");
	MakeComm	(0X5CBC,	"save low(2*x)");
	MakeComm	(0X5CBE,	"save high(2*x)");
	MakeComm	(0X5CC0,	"to have 4*x");
	MakeCode	(x=0X5CC0);
	OpHex		(x,	1);
	MakeComm	(0X5CC2,	"shift left w/ carry");
	MakeCode	(x=0X5CC2);
	OpHex		(x,	1);
	MakeComm	(0X5CC4,	"Overflow occurred ?");
	MakeComm	(0X5CC7,	"then error, exit");
	MakeComm	(0X5CC9,	"to have 8*x");
	MakeCode	(x=0X5CC9);
	OpHex		(x,	1);
	MakeComm	(0X5CCB,	"shift left w/ carry");
	MakeCode	(x=0X5CCB);
	OpHex		(x,	1);
	MakeComm	(0X5CD2,	"now have 10*x");
	MakeComm	(0X5CD4,	"32bit ADD");
	MakeComm	(0X5CD6,	"Overflow occurred ?");
	MakeComm	(0X5CD9,	"then error, exit");
	MakeComm	(0X5CDB,	"Add the current one degree decimal");
	MakeComm	(0X5CDD,	"if carry, add 1 to high 16bit");
	MakeComm	(0X5CE0,	"Overflow occurred ?");
	MakeComm	(0X5CE3,	"then error, exit");
	MakeComm	(0X5CE5,	"update pointer");
	MakeComm	(0X5CE6,	"loop until NULL encountered");
	MakeCode	(0X5CE8);
	MakeComm	(0X5CE9,	"bridge");
	MakeComm	(0X5CEC,	"restore control pointer\nhere cx,dx = 32bit value");
	MakeCode	(0X5CEC);
	MakeComm	(0X5CED,	"_$P_Neg ; was it negative ?");
	MakeCode	(x=0X5CED);
	OpHex		(x,	1);
	MakeComm	(0X5CF5,	"| Make 2's complement");
	MakeComm	(0X5CF7,	"|");
	MakeComm	(0X5CF9,	"|");
	MakeComm	(0X5CFC,	"|");
	MakeComm	(0X5CFF,	"[es:bx+_$P_Control_Blk.Value_List]\nsi points to value list");
	MakeComm	(0X5D03,	"get nval");
	MakeComm	(0X5D06,	"_$P_nval_None ; no value list ?");
	MakeComm	(0X5D0A,	"_$P_Number ; Set type");
	MakeComm	(0X5D0C,	"_$P_No_Tag ; No ITEM_TAG set");
	MakeComm	(0X5D10,	"90h");
	MakeCode	(0X5D10);
	MakeComm	(0X5D12,	"al = number of range");
	MakeComm	(0X5D15,	"_$P_No_nrng");
	MakeComm	(0X5D17,	"_$P_Value03");
	MakeComm	(0X5D19,	"si points to 1st item_tag");
	MakeComm	(0X5D1A,	"_$P_Signed");
	MakeCode	(x=0X5D1A);
	OpHex		(x,	1);
	MakeComm	(0X5D22,	"[es:si+_$P_Val_List.Val_XH]\ncomp cx with XH");
	MakeComm	(0X5D2A,	"[es:si+_$P_Val_List.Val_XL]\ncomp dx with XL");
	MakeComm	(0X5D30,	"[es:si+_$P_Val_List.Val_YH]\ncomp cx with YH");
	MakeComm	(0X5D38,	"[es:si+_$P_Val_List.Val_YL]\ncomp dx with YL");
	MakeComm	(0X5D40,	"[es:si+_$P_Val_List.Val_XH]\ncomp cx with XH");
	MakeCode	(0X5D40);
	MakeComm	(0X5D48,	"[es:si+_$P_Val_List.Val_XL]\ncomp dx with XL");
	MakeComm	(0X5D4E,	"[es:si+_$P_Val_List.Val_YH]\ncomp cx with YH");
	MakeComm	(0X5D56,	"[es:si+_$P_Val_List.Val_YL]\ncomp dx with YL");
	MakeComm	(0X5D5E,	"_$P_Len_Range");
	MakeCode	(0X5D5E);
	MakeComm	(0X5D61,	"loop nrng times in AL");
	MakeComm	(0X5D65,	"_$P_Out_Of_Range");
	MakeComm	(0X5D6C,	"_$P_Number");
	MakeComm	(0X5D6E,	"_$P_No_Tag");
	MakeComm	(0X5D72,	"_$P_Number");
	MakeCode	(0X5D72);
	MakeComm	(0X5D74,	"found ITEM_TAG set");
	MakeComm	(0X5D79,	"_$P_Syntax");
	MakeCode	(0X5D79);
	MakeComm	(0X5D80,	"_$P_String ; Set type");
	MakeComm	(0X5D82,	"_$P_No_Tag ; No ITEM_TAG set");
	MakeCode	(0X5D8C);
	MakeName	(0X5D8C,	"_$P_Check_OVF");
	MakeComm	(0X5D8D,	"_$P_Neg ; is it negative value ?");
	MakeCode	(x=0X5D8D);
	OpHex		(x,	1);
	MakeComm	(0X5D95,	"if no, check overflow by the CY bit");
	MakeComm	(0X5D97,	"else, check overflow by the OF");
	MakeCode	(0X5D97);
	MakeComm	(0X5D9A,	"indicate it with CY bit\nCY=0 means no overflow");
	MakeComm	(0X5D9C,	"and CY=1 means overflow");
	MakeCode	(0X5D9C);
	MakeComm	(0X5D9E,	"must be 0 =< al =< 9");
	MakeCode	(x=0X5D9E);
	OpChr		(x,	1);
	MakeName	(0X5D9E,	"_$P_0099");
	MakeCode	(x=0X5DA2);
	OpChr		(x,	1);
	MakeComm	(0X5DA6,	"sub al,30h ; make char -> bin");
	MakeCode	(x=0X5DA6);
	OpChr		(x,	1);
	MakeComm	(0X5DA8,	"indicate no error\n(clc is not required here, cf=0)");
	MakeCode	(0X5DAA);
	MakeCode	(0X5DAC);
	MakeName	(0X5DAC,	"_$P_Simple_String");
	MakeComm	(0X5DB0,	"[es:bx+_$P_Control_Blk.Value_List]\ndi points to value list");
	MakeComm	(0X5DB4,	"get nval");
	MakeComm	(0X5DB7,	"no value list ?");
	MakeComm	(0X5DBB,	"_$P_No_Tag ; then, No ITEM_TAG set");
	MakeComm	(0X5DBD,	"and set result buffer");
	MakeComm	(0X5DBF,	"Check if keyword or value list id #3 is supported\n_$P_nval_String ; String choice list provided ?");
	MakeCode	(0X5DBF);
	MakeComm	(0X5DC1,	"if no, syntax error");
	MakeComm	(0X5DC4,	"al = nrng");
	MakeComm	(0X5DC7,	"_$P_Len_Range");
	MakeComm	(0X5DC9,	"Skip nrng field");
	MakeComm	(0X5DCB,	"ax = (nrng*9)+1");
	MakeComm	(0X5DCC,	"di points to nnval");
	MakeComm	(0X5DCE,	"get nnval");
	MakeComm	(0X5DD1,	"_$P_Len_Value");
	MakeComm	(0X5DD3,	"skip nnval field");
	MakeComm	(0X5DD5,	"ax = (nnval*5)+1");
	MakeComm	(0X5DD6,	"di points to nstrval");
	MakeComm	(0X5DD8,	"get nstrval c");
	MakeComm	(0X5DDC,	"add '2' to di reg\ndi points to 1st string in list");
	MakeComm	(0X5DDD,	"get string pointer");
	MakeComm	(0X5DE0,	"compare it with operand");
	MakeComm	(0X5DE3,	"found on list");
	MakeComm	(0X5DE5,	"_$P_Len_String ; if no, point to next choice");
	MakeComm	(0X5DE8,	"loop nstval times in AL");
	MakeComm	(0X5DEC,	"/ Not found ; _$P_Not_In_Str");
	MakeComm	(0X5DF3,	"_$P_No_Tag  ; No ITEM_TAG set");
	MakeComm	(0X5DF7,	"set item_tag");
	MakeCode	(0X5DF7);
	MakeComm	(0X5DFB,	"_$P_List_Idx");
	MakeComm	(0X5DFD,	"get address of STRING");
	MakeComm	(0X5E02,	"_$P_Syntax");
	MakeCode	(0X5E02);
	MakeComm	(0X5E09,	"_$P_No_Tag");
	MakeComm	(0X5E0B,	"_$P_String ; Set type");
	MakeCode	(0X5E15);
	MakeName	(0X5E15,	"_$P_String_Comp");
	MakeComm	(0X5E19,	"_$P_DOSTBL_Char ; use character case map table");
	MakeComm	(0X5E1B,	"get command character");
	MakeComm	(0X5E1E,	"DBCS ?");
	MakeComm	(0X5E21,	"yes");
	MakeComm	(0X5E23,	"else, upper case map before comparison");
	MakeComm	(0X5E26,	"Check if keyword or switch is supported\n_$P_Key_Cmp ; keyword search ?");
	MakeCode	(x=0X5E26);
	OpHex		(x,	1);
	MakeComm	(0X5E2E,	"_$P_Keyword  ; \"=\" is delimiter");
	MakeCode	(x=0X5E2E);
	OpChr		(x,	1);
	MakeComm	(0X5E30,	"IF \"=\" on command line AND \n(bp+1=> char after the \"=\" in synonym list)");
	MakeComm	(0X5E32,	"_$P_NULL ; at end of keyword string \n                 in the control block THEN");
	MakeComm	(0X5E39,	"keyword found in synonym list");
	MakeComm	(0X5E3B,	"_$P_SW_Cmp ; switch search ?");
	MakeCode	(x=0X5E3B);
	OpHex		(x,	1);
	MakeComm	(0X5E43,	"_$P_Colon ; \":\" is delimiter, \n           at end of switch on command line");
	MakeCode	(x=0X5E43);
	OpChr		(x,	1);
	MakeComm	(0X5E47,	"_$P_NULL\nIF at end of switch on command AND");
	MakeComm	(0X5E4C,	"\nat end of switch string \nin the control block THEN");
	MakeComm	(0X5E4E,	"found a match\nsi points to just after \"=\" or \":\"");
	MakeComm	(0X5E4F,	"exit");
	MakeComm	(0X5E51,	"compare operand w/ a synonym");
	MakeCode	(0X5E51);
	MakeComm	(0X5E55,	"if different, \ncheck ignore colon option");
	MakeComm	(0X5E57,	"end of line ?");
	MakeComm	(0X5E59,	"if so, exit");
	MakeComm	(0X5E5B,	"update operand pointer");
	MakeComm	(0X5E5C,	"and synonym pointer");
	MakeComm	(0X5E5D,	"loop until NULL or \"=\" or \":\"\n found in case");
	MakeComm	(0X5E5F,	"Here al is DBCS leading byte\ncompare leading byte");
	MakeCode	(0X5E5F);
	MakeComm	(0X5E63,	"if not match, say different");
	MakeComm	(0X5E65,	"else, load next byte");
	MakeComm	(0X5E6A,	"and compare 2nd byte");
	MakeComm	(0X5E6E,	"if not match, say different, too");
	MakeComm	(0X5E70,	"else update operand pointer");
	MakeComm	(0X5E71,	"and synonym pointer");
	MakeComm	(0X5E72,	"loop until NULL or \"=\" \nor \"/\" found in case");
	MakeComm	(0X5E74,	"_$P_SW");
	MakeCode	(x=0X5E74);
	OpHex		(x,	1);
	MakeComm	(0X5E7C,	"[es:bx+_$P_Control_Blk.Function_Flag],\n_$P_colon_is_not_necessary");
	MakeCode	(x=0X5E7C);
	OpHex		(x,	1);
	MakeComm	(0X5E84,	"_$P_NULL");
	MakeComm	(0X5E8B,	"[es:bx+_$P_Control_Blk.Match_Flag],\n_$P_Ig_Colon \nignore colon option specified ?");
	MakeCode	(x=0X5E8B);
	OpHex		(x,	1);
	MakeComm	(0X5E92,	"_$P_Colon ; End up with \":\" and subseqently");
	MakeCode	(x=0X5E92);
	OpChr		(x,	1);
	MakeComm	(0X5E96,	"_$P_NULL ; null ?");
	MakeComm	(0X5E9B,	"if no, say different");
	MakeComm	(0X5E9D,	"else, say same");
	MakeComm	(0X5E9F,	"_$P_NULL ; end up NULL and :");
	MakeCode	(0X5E9F);
	MakeComm	(0X5EA3,	"$P_Colon ; if no, say different");
	MakeCode	(x=0X5EA3);
	OpChr		(x,	1);
	MakeComm	(0X5EA8,	"else, say same");
	MakeComm	(0X5EAA,	"indicate not found");
	MakeComm	(0X5EAD,	"for later use by keyword or switch");
	MakeCode	(0X5EAD);
	MakeComm	(0X5EB2,	"indicate found\n(cf is already 0 here.. clc is not needed)");
	MakeCode	(0X5EB8);
	MakeName	(0X5EB8,	"_$P_File_Format");
	MakeComm	(0X5EBB,	"get user buffer address");
	MakeComm	(0X5EC0,	"/ skip special characters\nload character");
	MakeName	(0X5EC0,	"_$P_FileF_Loop0");
	MakeComm	(0X5EC3,	"end of line ?");
	MakeComm	(0X5EC5,	"if yes, error exit");
	MakeComm	(0X5EC7,	"else, check if file special character");
	MakeComm	(0X5ECC,	"$P_error_filespec\nset error flag - bad char.");
	MakeComm	(0X5ED3,	"_$P_NULL");
	MakeCode	(0X5EDA);
	MakeComm	(0X5EDB,	"_$P_NULL");
	MakeComm	(0X5EE0,	"[es:bx+_$P_Control_Blk.Match_Flag],\n_$P_Optional");
	MakeCode	(x=0X5EE0);
	OpHex		(x,	1);
	MakeComm	(0X5EE7,	"_$P_Op_Missing");
	MakeComm	(0X5EF0,	"discard si on top of stack");
	MakeCode	(0X5EF0);
	MakeComm	(0X5EF1,	"save new si");
	MakeComm	(0X5EF2,	"load character (not special char)");
	MakeComm	(0X5EF5,	"end of line ?");
	MakeComm	(0X5EF9,	"File special character ?");
	MakeComm	(0X5EFE,	"no, then DBCS ?");
	MakeComm	(0X5F05,	"if yes, skip next byte");
	MakeCode	(0X5F09);
	MakeComm	(0X5F0D,	"_$P_NULL ; update end of string");
	MakeComm	(0X5F12,	"update next pointer in command line");
	MakeComm	(0X5F1A,	"_$P_File_Spc");
	MakeCode	(x=0X5F1A);
	OpHex		(x,	1);
	MakeComm	(0X5F20,	"_$P_No_Tag");
	MakeComm	(0X5F22,	"_$P_File_Spec");
	MakeComm	(0X5F24,	"set result buffer to file spec");
	MakeCode	(0X5F29);
	MakeName	(0X5F29,	"_$P_FileSp_Chk");
	MakeCode	(x=0X5F2B);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X5F2F,	"_$P_FileSp_Len\nload length of special character table\nat SYSINIT:1838h (for MSDOS 6.21 IO.SYS)");
	MakeComm	(0X5F32,	"is it one of special character ?");
	MakeComm	(0X5F3A,	"reset ZF");
	MakeCode	(0X5F3E);
	MakeName	(0X5F3E,	"_$P_Drive_Format");
	MakeComm	(0X5F43,	"if null string");
	MakeComm	(0X5F45,	"do nothing");
	MakeComm	(0X5F47,	"is it leading byte ?");
	MakeComm	(0X5F4A,	"yes, error");
	MakeComm	(0X5F4C,	"_$P_Colon\n\"d\", \":\", 0 ?");
	MakeComm	(0X5F53,	"[es:bx+_$P_Control_Blk.Match_Flag],\n_$P_Ig_Colon\ncolon can be ignored?");
	MakeCode	(x=0X5F53);
	OpHex		(x,	1);
	MakeComm	(0X5F5A,	"_$P_NULL ; \"d\", 0 ?");
	MakeComm	(0X5F61,	"_$P_Make_Lower ; lower case");
	MakeCode	(x=0X5F61);
	OpHex		(x,	1);
	MakeComm	(0X5F63,	"drive letter must");
	MakeComm	(0X5F65,	"in range of");
	MakeComm	(0X5F67,	"\"a\"-\"z\"");
	MakeComm	(0X5F69,	"if no, error");
	MakeComm	(0X5F6B,	"\"a\"-1 ; make text drive to binary drive");
	MakeCode	(x=0X5F6B);
	OpHex		(x,	1);
	MakeComm	(0X5F6F,	"_$P_No_Tag");
	MakeComm	(0X5F71,	"_$P_Drive");
	MakeComm	(0X5F73,	"set result buffer to drive");
	MakeComm	(0X5F78,	"_$P_Syntax");
	MakeCode	(0X5F78);
	MakeCode	(0X5F82);
	MakeName	(0X5F82,	"_$P_Skip_Delim");
	MakeComm	(0X5F83,	"is it EOL character ?");
	MakeComm	(0X5F86,	"if yes, exit w/ CY on");
	MakeComm	(0X5F88,	"is it one of delimiters ?");
	MakeComm	(0X5F8B,	"if no, exit w/ CY off");
	MakeComm	(0X5F8D,	"_$P_Extra ; extra delim or comma found");
	MakeCode	(x=0X5F8D);
	OpHex		(x,	1);
	MakeComm	(0X5F93,	"_$P_Skip_Delim_Loop\nif no, loop");
	MakeComm	(0X5F95,	"_$P_SW+_$P_equ ; /x , or xxx=zzz ,");
	MakeCode	(x=0X5F95);
	OpHex		(x,	1);
	MakeComm	(0X5F9B,	"no switch, no keyword");
	MakeComm	(0X5FA0,	"indicate EOL");
	MakeCode	(0X5FA0);
	MakeComm	(0X5FA3,	"indicate non delim");
	MakeCode	(0X5FA3);
	MakeComm	(0X5FA4,	"in this case, need backup index pointer");
	MakeComm	(0X5FA6,	"indicate extra delim");
	MakeCode	(0X5FA6);
	MakeCode	(0X5FA8);
	MakeName	(0X5FA8,	"_$P_Chk_EOL");
	MakeComm	(0X5FAA,	"_$P_CR ; Carriage return ?");
	MakeComm	(0X5FAE,	"_$P_NULL ; zero ?");
	MakeComm	(0X5FB2,	"_$P_LF ; Line feed ?");
	MakeComm	(0X5FB6,	"[es:di+_$P_PARMS_Blk.Num_Extra],\n_$P_I_Have_EOL");
	MakeComm	(0X5FBF,	"[es:di+_$P_PARMS_Blk.Len_Extra_Delim]\nget length of delimiter list");
	MakeComm	(0X5FC3,	"_$P_Len_PARMS ; skip it");
	MakeComm	(0X5FC6,	"_$P_I_Use_Default\nNo extra EOL character ?");
	MakeComm	(0X5FCC,	"Get number of extra character");
	MakeComm	(0X5FD2,	"Check extra EOL character");
	MakeComm	(0X5FD9,	"_$P_CR ; reset ZF");
	MakeCode	(0X5FDE);
	MakeName	(0X5FDE,	"_$P_Chk_Delim");
	MakeComm	(0X5FE0,	"_$P_Space \nassume terminated by space");
	MakeComm	(0X5FE6,	"0FFh-_$P_Extra ; ~$P_Extra ; ~20h");
	MakeCode	(x=0X5FE6);
	OpHex		(x,	1);
	MakeComm	(0X5FEC,	"_$P_Space ; Space ?");
	MakeComm	(0X5FF0,	"_$P_TAB ; TAB ?");
	MakeComm	(0X5FF4,	"_$P_Comma ; Comma ?");
	MakeComm	(0X5FF8,	"Note: _$P_Chk_Delim00 part of code is nonsense\n      here because _$P_Space = _$P_DBSP1 = 20h\n      Erdogan Tan - 08/07/2023\n\n_$P_DBSP1 ; 1st byte of DBCS Space ?");
	MakeName	(0X5FF8,	"_$P_Chk_Delim00");
	MakeComm	(0X5FFC,	"_$P_DBSP2 ; 2nd byte of DBCS Space ?");
	MakeComm	(0X6001,	"_$P_Space");
	MakeComm	(0X6003,	"make si point to next character");
	MakeComm	(0X6004,	"Set ZF");
	MakeComm	(0X6008,	"[es:di-_$P_PARMS_Blk.Num_Extra],\n_$P_I_Have_Delim \ndelimiter character specified ?");
	MakeCode	(0X6008);
	MakeComm	(0X600D,	"no");
	MakeComm	(0X6011,	"[es:di+_$P_PARMS_Blk.Len_Extra_Delim] \nget length of delimiter list");
	MakeComm	(0X6017,	"no extra delim character");
	MakeComm	(0X6019,	"_$P_Len_PARMS-1\nset bx to 1st extra delimiter");
	MakeComm	(0X601D,	"check extra delim character");
	MakeComm	(0X6022,	"examine all extra delimiter");
	MakeComm	(0X6024,	"_$P_Space ; reset ZF");
	MakeComm	(0X6029,	"keep terminated delimiter");
	MakeCode	(0X6029);
	MakeComm	(0X602D,	"_$P_equ ; if terminating a key=");
	MakeCode	(x=0X602D);
	OpHex		(x,	1);
	MakeComm	(0X6033,	"then do not set the EXTRA bit");
	MakeComm	(0X6035,	"_$P_Extra \nflag terminated extra delim or comma");
	MakeCode	(x=0X6035);
	OpHex		(x,	1);
	MakeComm	(0X603B,	"set ZF");
	MakeComm	(0X603F,	"BP = Offset of _$P_String_Buf\n(mov bp, offset _$P_STRING_BUF)");
	MakeCode	(x=0X603F);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeName	(0X603F,	"_$P_Chk_Switch");
	MakeComm	(0X6043,	"IF not first char THEN");
	MakeComm	(0X6047,	"_$P_Switch ; see if a slash");
	MakeComm	(0X604B,	"not in first position and is slash");
	MakeCode	(0X604E);
	MakeComm	(0X6051,	"_$P_Switch");
	MakeCode	(0X6051);
	MakeComm	(0X6053,	"not a slash");
	MakeComm	(0X6055,	"_$P_SW\ncould be valid switch,\nfirst char and is slash");
	MakeCode	(x=0X6055);
	OpHex		(x,	1);
	MakeComm	(0X605B,	"is first char in the buffer, ZF=0\n(CF=0 indicating first char)");
	MakeCode	(0X605D);
	MakeName	(0X605D,	"_$P_Chk_DBCS");
	MakeComm	(0X6060,	"already set ?");
	MakeComm	(0X6066,	"yes");
	MakeComm	(0X6073,	"_$P_DOS_GetEV ; GET DBCS EV CALL");
	MakeCode	(x=0X6073);
	OpHex		(x,	1);
	MakeComm	(0X6076,	"DOS - 3.2+ only\nGET DOUBLE BYTE CHARACTER SET LEAD TABLE");
	MakeCode	(x=0X6076);
	OpHex		(x,	0);
	MakeComm	(0X6085,	"save EV offset");
	MakeComm	(0X608A,	"save EV segment");
	MakeComm	(0X608F,	"load EV offset and segment");
	MakeComm	(0X6099,	"zero vector ?");
	MakeComm	(0X609C,	"then exit");
	MakeComm	(0X609E,	"Check if AL is in range of the vector");
	MakeComm	(0X60A7,	"if yes, indicate DBCS and exit");
	MakeComm	(0X60AA,	"add 2 to si reg");
	MakeCode	(0X60AA);
	MakeComm	(0X60AB,	"get next vector");
	MakeComm	(0X60AC,	"loop until zero vector found");
	MakeComm	(0X60AE,	"indicate SBCS\n(note: cf is already 0 here)");
	MakeCode	(0X60AE);
	MakeComm	(0X60B3,	"buffer = [n | n,m] {/e}");
	MakeWord	(x=0X60B3);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X60B3,	"buf_parms");
	MakeComm	(0X60B5,	"an extra delimiter list");
	MakeByte	(0X60B5);
	MakeComm	(0X60B6,	"length is 1");
	MakeByte	(0X60B6);
	MakeComm	(0X60B7,	"delimiter");
	MakeByte	(x=0X60B7);
	OpChr		(x,	0);
	MakeByte	(0X60B8);
	MakeName	(0X60B8,	"buf_parmsx");
	MakeComm	(0X60B9,	"min 1, max 2 positionals");
	MakeByte	(0X60B9);
	MakeWord	(x=0X60BA);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X60BC);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X60BE,	"one switch");
	MakeByte	(0X60BE);
	MakeWord	(x=0X60BF);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X60C1,	"no keywords\n\nbuf_pos1 p_pos <8000h,0,result_val,buf_range_1>\nnumeric");
	MakeByte	(0X60C1);
	MakeComm	(0X60C2,	"match_flags - numeric value");
	MakeWord	(0X60C2);
	MakeName	(0X60C2,	"buf_pos1");
	MakeComm	(0X60C4,	"function flags");
	MakeWord	(0X60C4);
	MakeComm	(0X60C6,	"result value buffer");
	MakeWord	(x=0X60C6);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X60C8,	"value list");
	MakeWord	(x=0X60C8);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X60CA,	"no switches/keywords");
	MakeByte	(0X60CA);
	MakeComm	(0X60CB,	"range definition");
	MakeByte	(0X60CB);
	MakeName	(0X60CB,	"buf_range_1");
	MakeComm	(0X60CC,	"1 definition of range");
	MakeByte	(0X60CC);
	MakeComm	(0X60CD,	"item tag for this range");
	MakeByte	(0X60CD);
	MakeComm	(0X60CE,	"numeric min");
	MakeDword	(0X60CE);
	MakeComm	(0X60D2,	"numeric max\n\nbuf_pos2 p_pos <8001h,0,result_val,buf_range_2>\noptional num.");
	MakeDword	(x=0X60D2);
	OpDecimal	(x,	0);
	MakeWord	(0X60D6);
	MakeName	(0X60D6,	"buf_pos2");
	MakeWord	(0X60D8);
	MakeWord	(x=0X60DA);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X60DC);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X60DE,	"\nbuf_range_2 p_range <,,,0,8>");
	MakeByte	(0X60DE);
	MakeByte	(0X60DF);
	MakeName	(0X60DF,	"buf_range_2");
	MakeByte	(0X60E0);
	MakeByte	(0X60E1);
	MakeDword	(0X60E2);
	MakeComm	(0X60E6,	"\nsw_x_ctrl p_pos <0,0,result_val,noval,1>\nfollowed by one switch");
	MakeDword	(0X60E6);
	MakeWord	(0X60EA);
	MakeName	(0X60EA,	"sw_x_ctrl");
	MakeWord	(0X60EC);
	MakeWord	(x=0X60EE);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X60F0);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X60F2,	"1 switch");
	MakeByte	(0X60F2);
	MakeStr		(0X60F3,	0X60F6);
	MakeName	(0X60F3,	"switch_x");
	MakeWord	(0X60F6);
	MakeName	(0X60F6,	"p_buffers");
	MakeWord	(0X60F8);
	MakeName	(0X60F8,	"p_h_buffers");
	MakeComm	(0X60FA,	"\ncommon definitions");
	MakeByte	(0X60FA);
	MakeName	(0X60FA,	"p_buffer_slash_x");
	MakeByte	(0X60FB);
	MakeName	(0X60FB,	"noval");
	MakeComm	(0X60FC,	"type returned");
	MakeByte	(0X60FC);
	MakeName	(0X60FC,	"result_val");
	MakeComm	(0X60FD,	"item tag returned");
	MakeByte	(0X60FD);
	MakeName	(0X60FD,	"result_val_itag");
	MakeComm	(0X60FE,	"es:offset of the switch defined");
	MakeWord	(0X60FE);
	MakeName	(0X60FE,	"result_val_swoff");
	MakeComm	(0X6100,	"rv_byte\nvalue if number, or seg:offset to string.\n;;");
	MakeDword	(0X6100);
	MakeName	(0X6100,	"rv_dword");
	MakeComm	(0X6104,	"break = [ on | off ]");
	MakeWord	(x=0X6104);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X6104,	"brk_parms");
	MakeComm	(0X6106,	"an extra delimiter list");
	MakeByte	(0X6106);
	MakeComm	(0X6107,	"length is 1");
	MakeByte	(0X6107);
	MakeComm	(0X6108,	"delimiter");
	MakeByte	(x=0X6108);
	OpChr		(x,	0);
	MakeByte	(0X6109);
	MakeName	(0X6109,	"brk_parmsx");
	MakeComm	(0X610A,	"min,max = 1 positional");
	MakeByte	(0X610A);
	MakeWord	(x=0X610B);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X610D,	"no switches");
	MakeByte	(0X610D);
	MakeComm	(0X610E,	"no keywords\n\nbrk_pos p_pos <2000h,0,result_val,on_off_string>\nsimple string");
	MakeByte	(0X610E);
	MakeWord	(0X610F);
	MakeName	(0X610F,	"brk_pos");
	MakeWord	(0X6111);
	MakeWord	(x=0X6113);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X6115);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X6117);
	MakeComm	(0X6118,	"signals that there is a string choice");
	MakeByte	(0X6118);
	MakeName	(0X6118,	"on_off_string");
	MakeComm	(0X6119,	"no range definition");
	MakeByte	(0X6119);
	MakeComm	(0X611A,	"no numeric values choice");
	MakeByte	(0X611A);
	MakeComm	(0X611B,	"2 strings for choice");
	MakeByte	(0X611B);
	MakeComm	(0X611C,	"the 1st string tag");
	MakeByte	(0X611C);
	MakeWord	(x=0X611D);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X611F,	"the 2nd string tag");
	MakeByte	(0X611F);
	MakeWord	(x=0X6120);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeStr		(0X6122,	0X6125);
	MakeName	(0X6122,	"_on_string");
	MakeStr		(0X6125,	0X6129);
	MakeName	(0X6125,	"_off_string");
	MakeComm	(0X6129,	"local variable\n;;");
	MakeByte	(0X6129);
	MakeName	(0X6129,	"p_ctrl_break");
	MakeComm	(0X612A,	"country = n {m {path}} \nor country = n,,path");
	MakeWord	(x=0X612A);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X612A,	"cntry_parms");
	MakeByte	(0X612C);
	MakeByte	(0X612D);
	MakeByte	(x=0X612E);
	OpChr		(x,	0);
	MakeComm	(0X612F,	"min 1, max 3 pos.");
	MakeByte	(0X612F);
	MakeName	(0X612F,	"cntry_parmsx");
	MakeByte	(0X6130);
	MakeWord	(x=0X6131);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X6133);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X6135);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X6137,	"no switches");
	MakeByte	(0X6137);
	MakeComm	(0X6138,	"no keywords");
	MakeByte	(0X6138);
	MakeComm	(0X6139,	"cntry_pos1 p_pos <8000h,0,result_val,cc_range>\nnumeric value");
	MakeWord	(0X6139);
	MakeName	(0X6139,	"cntry_pos1");
	MakeWord	(0X613B);
	MakeWord	(x=0X613D);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X613F);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X6141);
	MakeComm	(0X6142,	"cc_range p_range <,,,1,999>");
	MakeByte	(0X6142);
	MakeName	(0X6142,	"cc_range");
	MakeByte	(0X6143);
	MakeByte	(0X6144);
	MakeDword	(0X6145);
	MakeDword	(x=0X6149);
	OpDecimal	(x,	0);
	MakeComm	(0X614D,	"cntry_pos2 p_pos <8001h,0,result_val,cc_range>\noptional num.");
	MakeWord	(0X614D);
	MakeName	(0X614D,	"cntry_pos2");
	MakeWord	(0X614F);
	MakeWord	(x=0X6151);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X6153);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X6155);
	MakeComm	(0X6156,	"cntry_pos3 p_pos <201h,0,result_val,noval>\noptional filespec");
	MakeWord	(0X6156);
	MakeName	(0X6156,	"cntry_pos3");
	MakeWord	(0X6158);
	MakeWord	(x=0X615A);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X615C);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X615E);
	MakeComm	(0X615F,	"local variable");
	MakeWord	(0X615F);
	MakeName	(0X615F,	"p_cntry_code");
	MakeComm	(0X6161,	"local variable\n;;");
	MakeWord	(0X6161);
	MakeName	(0X6161,	"p_code_page");
	MakeComm	(0X6163,	"files = n");
	MakeWord	(x=0X6163);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X6163,	"files_parms");
	MakeByte	(0X6165);
	MakeByte	(0X6166);
	MakeByte	(x=0X6167);
	OpChr		(x,	0);
	MakeByte	(0X6168);
	MakeName	(0X6168,	"files_parmsx");
	MakeComm	(0X6169,	"min,max 1 positional");
	MakeByte	(0X6169);
	MakeWord	(x=0X616A);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X616C,	"no switches");
	MakeByte	(0X616C);
	MakeComm	(0X616D,	"no keywords");
	MakeByte	(0X616D);
	MakeComm	(0X616E,	"files_pos p_pos <8000h,0,result_val,files_range,0>\nnumeric value");
	MakeWord	(0X616E);
	MakeName	(0X616E,	"files_pos");
	MakeWord	(0X6170);
	MakeWord	(x=0X6172);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X6174);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X6176);
	MakeComm	(0X6177,	"files_range p_range <,,,8,255>");
	MakeByte	(0X6177);
	MakeName	(0X6177,	"files_range");
	MakeByte	(0X6178);
	MakeByte	(0X6179);
	MakeDword	(0X617A);
	MakeDword	(x=0X617E);
	OpDecimal	(x,	0);
	MakeComm	(0X6182,	"local variable\n;;");
	MakeByte	(0X6182);
	MakeName	(0X6182,	"p_files");
	MakeComm	(0X6183,	"fcbs = n,m");
	MakeWord	(x=0X6183);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X6183,	"fcbs_parms");
	MakeByte	(0X6185);
	MakeByte	(0X6186);
	MakeByte	(x=0X6187);
	OpChr		(x,	0);
	MakeByte	(0X6188);
	MakeName	(0X6188,	"fcbs_parmsx");
	MakeByte	(0X6189);
	MakeWord	(x=0X618A);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X618C);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X618E,	"no switches");
	MakeByte	(0X618E);
	MakeComm	(0X618F,	"no keywords");
	MakeByte	(0X618F);
	MakeComm	(0X6190,	"fcbs_pos_1 p_pos <8000h,0,result_val,fcbs_range>\nnumeric value");
	MakeWord	(0X6190);
	MakeName	(0X6190,	"fcbs_pos_1");
	MakeWord	(0X6192);
	MakeWord	(x=0X6194);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X6196);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X6198);
	MakeComm	(0X6199,	"fcbs_range p_range <,,,1,255>");
	MakeByte	(0X6199);
	MakeName	(0X6199,	"fcbs_range");
	MakeByte	(0X619A);
	MakeByte	(0X619B);
	MakeDword	(0X619C);
	MakeDword	(x=0X61A0);
	OpDecimal	(x,	0);
	MakeComm	(0X61A4,	"fcbs_pos_2 p_pos <8000h,0,result_val,fcbs_keep_range>\nnumeric value");
	MakeWord	(0X61A4);
	MakeName	(0X61A4,	"fcbs_pos_2");
	MakeWord	(0X61A6);
	MakeWord	(x=0X61A8);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X61AA);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X61AC);
	MakeComm	(0X61AD,	"fcbs_keep_range p_range <,,,0,255>");
	MakeByte	(0X61AD);
	MakeName	(0X61AD,	"fcbs_keep_range");
	MakeByte	(0X61AE);
	MakeByte	(0X61AF);
	MakeDword	(0X61B0);
	MakeDword	(x=0X61B4);
	OpDecimal	(x,	0);
	MakeComm	(0X61B8,	"local variable");
	MakeByte	(0X61B8);
	MakeName	(0X61B8,	"p_fcbs");
	MakeComm	(0X61B9,	"local variable\n;;");
	MakeByte	(0X61B9);
	MakeName	(0X61B9,	"p_keep");
	MakeComm	(0X61BA,	"lastdrive = x");
	MakeWord	(x=0X61BA);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X61BA,	"ldrv_parms");
	MakeByte	(0X61BC);
	MakeByte	(0X61BD);
	MakeByte	(x=0X61BE);
	OpChr		(x,	0);
	MakeByte	(0X61BF);
	MakeName	(0X61BF,	"ldrv_parmsx");
	MakeComm	(0X61C0,	"min,max = 1 positional");
	MakeByte	(0X61C0);
	MakeWord	(x=0X61C1);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X61C3,	"no switches");
	MakeByte	(0X61C3);
	MakeComm	(0X61C4,	"no keywords");
	MakeByte	(0X61C4);
	MakeComm	(0X61C5,	"ldrv_pos p_pos <110h,10h,result_val,noval>\ndrive only, ignore colon at end");
	MakeWord	(0X61C5);
	MakeName	(0X61C5,	"ldrv_pos");
	MakeWord	(0X61C7);
	MakeWord	(x=0X61C9);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X61CB);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X61CD);
	MakeComm	(0X61CE,	"local variable\n;;");
	MakeByte	(0X61CE);
	MakeName	(0X61CE,	"p_ldrv");
	MakeComm	(0X61CF,	"stacks = n,m");
	MakeWord	(x=0X61CF);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X61CF,	"stks_parms");
	MakeByte	(0X61D1);
	MakeByte	(0X61D2);
	MakeByte	(x=0X61D3);
	OpChr		(x,	0);
	MakeByte	(0X61D4);
	MakeName	(0X61D4,	"stks_parmsx");
	MakeComm	(0X61D5,	"min,max = 2 positionals");
	MakeByte	(0X61D5);
	MakeWord	(x=0X61D6);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X61D8);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X61DA,	"no switches");
	MakeByte	(0X61DA);
	MakeComm	(0X61DB,	"no keywords");
	MakeByte	(0X61DB);
	MakeComm	(0X61DC,	"stks_pos_1 p_pos <8000h,0,result_val,stks_range>\nnumeric value");
	MakeWord	(0X61DC);
	MakeName	(0X61DC,	"stks_pos_1");
	MakeWord	(0X61DE);
	MakeWord	(x=0X61E0);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X61E2);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X61E4);
	MakeComm	(0X61E5,	"stks_range p_range <,,,0,64>");
	MakeByte	(0X61E5);
	MakeName	(0X61E5,	"stks_range");
	MakeByte	(0X61E6);
	MakeByte	(0X61E7);
	MakeDword	(0X61E8);
	MakeDword	(x=0X61EC);
	OpDecimal	(x,	0);
	MakeComm	(0X61F0,	"stks_pos_2 p_pos <8000h,0,result_val,stk_size_range>\nnumeric value");
	MakeWord	(0X61F0);
	MakeName	(0X61F0,	"stks_pos_2");
	MakeWord	(0X61F2);
	MakeWord	(x=0X61F4);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X61F6);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X61F8);
	MakeComm	(0X61F9,	"stk_size_range p_range <,,,0,512>");
	MakeByte	(0X61F9);
	MakeName	(0X61F9,	"stk_size_range");
	MakeByte	(0X61FA);
	MakeByte	(0X61FB);
	MakeDword	(0X61FC);
	MakeDword	(x=0X6200);
	OpDecimal	(x,	0);
	MakeComm	(0X6204,	"local variable");
	MakeWord	(0X6204);
	MakeName	(0X6204,	"p_stack_count");
	MakeComm	(0X6206,	"local variable\n;;");
	MakeWord	(0X6206);
	MakeName	(0X6206,	"p_stack_size");
	MakeComm	(0X6208,	"multitrack = [ on | off ]");
	MakeWord	(x=0X6208);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X6208,	"mtrk_parms");
	MakeByte	(0X620A);
	MakeByte	(0X620B);
	MakeByte	(x=0X620C);
	OpChr		(x,	0);
	MakeComm	(0X620D,	"min,max = 1 positional");
	MakeByte	(0X620D);
	MakeName	(0X620D,	"mtrk_parmsx");
	MakeByte	(0X620E);
	MakeWord	(x=0X620F);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X6211,	"no switches");
	MakeByte	(0X6211);
	MakeComm	(0X6212,	"no keywords");
	MakeByte	(0X6212);
	MakeComm	(0X6213,	"mtrk_pos p_pos <2000h,0,result_val,on_off_string>\nsimple string");
	MakeWord	(0X6213);
	MakeName	(0X6213,	"mtrk_pos");
	MakeWord	(0X6215);
	MakeWord	(x=0X6217);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X6219);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X621B);
	MakeComm	(0X621C,	"local variable\n;;");
	MakeByte	(0X621C);
	MakeName	(0X621C,	"p_mtrk");
	MakeComm	(0X621D,	"switches=/k");
	MakeWord	(x=0X621D);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X621D,	"swit_parms");
	MakeByte	(0X621F);
	MakeByte	(0X6220);
	MakeByte	(x=0X6221);
	OpChr		(x,	0);
	MakeComm	(0X6222,	"no positionals");
	MakeWord	(0X6222);
	MakeName	(0X6222,	"swit_parmsx");
	MakeComm	(0X6224,	"# of switches");
	MakeByte	(0X6224);
	MakeComm	(0X6225,	"/k control");
	MakeWord	(x=0X6225);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X6227,	"/n control (for MULTI_CONFIG only)");
	MakeWord	(x=0X6227);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X6229,	"/f control (for MULTI_CONFIG only)");
	MakeWord	(x=0X6229);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X622B,	"/t control");
	MakeWord	(x=0X622B);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X622D,	"/w control");
	MakeWord	(x=0X622D);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X622F,	"no keywords");
	MakeByte	(0X622F);
	MakeComm	(0X6230,	"swit_k_ctrl p_pos <0,0,result_val,noval,1>\nswitch string follows");
	MakeWord	(0X6230);
	MakeName	(0X6230,	"swit_k_ctrl");
	MakeWord	(0X6232);
	MakeWord	(x=0X6234);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X6236);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X6238);
	MakeStr		(0X6239,	0X623C);
	MakeName	(0X6239,	"swit_k");
	MakeComm	(0X623C,	"swit_n_ctrl p_pos <0,0,result_val,noval,1>\nswitch string follows");
	MakeWord	(0X623C);
	MakeName	(0X623C,	"swit_n_ctrl");
	MakeWord	(0X623E);
	MakeWord	(x=0X6240);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X6242);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X6244);
	MakeStr		(0X6245,	0X6248);
	MakeName	(0X6245,	"swit_n");
	MakeComm	(0X6248,	"swit_f_ctrl p_pos <0,0,result_val,noval,1>\nswitch string follows");
	MakeWord	(0X6248);
	MakeName	(0X6248,	"swit_f_ctrl");
	MakeWord	(0X624A);
	MakeWord	(x=0X624C);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X624E);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X6250);
	MakeStr		(0X6251,	0X6254);
	MakeName	(0X6251,	"swit_f");
	MakeComm	(0X6254,	"swit_t_ctrl p_pos <0,0,result_val,noval,1>\nswitch string follows");
	MakeWord	(0X6254);
	MakeName	(0X6254,	"swit_t_ctrl");
	MakeWord	(0X6256);
	MakeWord	(x=0X6258);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X625A);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X625C);
	MakeStr		(0X625D,	0X6260);
	MakeName	(0X625D,	"swit_t");
	MakeComm	(0X6260,	"swit_w_ctrl p_pos <0,0,result_val,noval,1>\nswitch string follows");
	MakeWord	(0X6260);
	MakeName	(0X6260,	"swit_w_ctrl");
	MakeWord	(0X6262);
	MakeWord	(x=0X6264);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X6266);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X6268);
	MakeStr		(0X6269,	0X626C);
	MakeName	(0X6269,	"swit_w");
	MakeComm	(0X626C,	"local variable");
	MakeByte	(0X626C);
	MakeName	(0X626C,	"p_swit_k");
	MakeComm	(0X626D,	"local variable");
	MakeByte	(0X626D);
	MakeName	(0X626D,	"p_swit_t");
	MakeComm	(0X626E,	"local variable\n;;");
	MakeByte	(0X626E);
	MakeName	(0X626E,	"p_swit_w");
	MakeComm	(0X626F,	"DOS = [ high | low ]\nDOS = HIGH|LOW[,UMB|,NOUMB]");
	MakeWord	(x=0X626F);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X626F,	"dos_parms");
	MakeByte	(0X6271);
	MakeByte	(0X6272);
	MakeByte	(x=0X6273);
	OpChr		(x,	0);
	MakeComm	(0X6274,	"min parameters");
	MakeByte	(0X6274);
	MakeName	(0X6274,	"dos_parmsx");
	MakeByte	(0X6275);
	MakeWord	(x=0X6276);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X6278);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X627A,	"no switches");
	MakeComm	(0X627B,	"no keywords");
	MakeComm	(0X627C,	"dos_pos p_pos <2000h,0,result_val,dos_strings>\nsimple string");
	MakeWord	(0X627C);
	MakeName	(0X627C,	"dos_pos");
	MakeWord	(0X627E);
	MakeWord	(x=0X6280);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X6282);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X6284);
	MakeComm	(0X6285,	"dos_pos p_pos <2000h,0,result_val,dos_strings>\nsimple string\n(this is not needed) - E.TAN - 08/07/2023");
	MakeWord	(0X6285);
	MakeName	(0X6285,	"dos_pos2");
	MakeWord	(0X6287);
	MakeWord	(x=0X6289);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeWord	(x=0X628B);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X628D);
	MakeComm	(0X628E,	"signals that there is a string choice");
	MakeByte	(0X628E);
	MakeName	(0X628E,	"dos_strings");
	MakeComm	(0X628F,	"no range definition");
	MakeByte	(0X628F);
	MakeComm	(0X6290,	"no numeric values choice");
	MakeByte	(0X6290);
	MakeComm	(0X6291,	"4 strings for choice");
	MakeByte	(0X6291);
	MakeComm	(0X6292,	"the 1st string tag");
	MakeByte	(0X6292);
	MakeWord	(x=0X6293);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X6295,	"the 2nd string tag");
	MakeByte	(0X6295);
	MakeWord	(x=0X6296);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X6298);
	MakeWord	(x=0X6299);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeByte	(0X629B);
	MakeWord	(x=0X629C);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeStr		(0X629E,	0X62A3);
	MakeName	(0X629E,	"hi_string");
	MakeStr		(0X62A3,	0X62A7);
	MakeName	(0X62A3,	"lo_string");
	MakeStr		(0X62A7,	0X62AB);
	MakeName	(0X62A7,	"umb_string");
	MakeStr		(0X62AB,	0X62B1);
	MakeName	(0X62AB,	"noumb_string");
	MakeComm	(0X62B1,	"local variable (parser does not use this)\n\nfor LoadHigh and DeviceHigh:\n   fInHigh  - Is set to 1 during HideUMBs(), and back to zero in\n              UnHideUMBs().\n   fUmbTiny - Is set to 1 iff the user has specified /S on the     \n              command line.\n   SegLoad  - Segment address for first UMB specified; set                        \n              automatically.\n   UmbLoad  - The load UMB number; for example, this is 3 if the  \n              user has given a command-line like \"/L:3,500;4\"\n   fm_umb   - Set to the old UMB link-state (0x80 or 0x00)\n   fm_strat - Set to the old memory-allocation strategy (0$00000???)\n   fm_argc  - Number of arguments received by ParseVar()");
	MakeByte	(0X62B1);
	MakeName	(0X62B1,	"p_dos_hi");
	MakeByte	(0X62B2);
	MakeName	(0X62B2,	"fInHigh");
	MakeByte	(0X62B3);
	MakeName	(0X62B3,	"fUmbTiny");
	MakeWord	(0X62B4);
	MakeName	(0X62B4,	"SegLoad");
	MakeComm	(0X62B6,	"UmbUsed - An array of characters, each of which is 1 if the UMB\n          matching its index number was specified on the \n          command line;\n       for example, after \"/L:3,500;4;7\", UmbUsed[3],[4] & [7]\n       will be set to 1. All others will be set to 0.\nUmbSize - An array of words, each of which is interpereted as a   \n          size specified by the user for a UMB (in the above \n          example, all elements would be zero save UmbSize[3], \n          which would be 500.");
	MakeByte	(0X62B6);
	MakeName	(0X62B6,	"UmbLoad");
	MakeComm	(0X62B7,	"times MAXUMB db 0");
	MakeByte	(x=0X62B7);
	MakeArray	(x,	0X10);
	OpDecimal	(x,	0);
	MakeName	(0X62B7,	"UmbUsed");
	MakeComm	(0X62C7,	"times MAXUMB dw 0");
	MakeWord	(x=0X62C7);
	MakeArray	(x,	0X10);
	OpDecimal	(x,	0);
	MakeName	(0X62C7,	"UmbSize");
	MakeByte	(0X62E7);
	MakeName	(0X62E7,	"fm_umb");
	MakeByte	(0X62E8);
	MakeName	(0X62E8,	"fm_strat");
	MakeByte	(0X62E9);
	MakeName	(0X62E9,	"fm_argc");
	MakeComm	(0X62EA,	"size of the device driver being loaded (paras)");
	MakeWord	(0X62EA);
	MakeName	(0X62EA,	"DevSize");
	MakeComm	(0X62EC,	"Mem addr where the device driver is 2 b loaded");
	MakeWord	(0X62EC);
	MakeName	(0X62EC,	"DevLoadAddr");
	MakeComm	(0X62EE,	"MaxAddr to which device can be loaded");
	MakeWord	(0X62EE);
	MakeName	(0X62EE,	"DevLoadEnd");
	MakeComm	(0X62F0,	"Entry point to the device driver");
	MakeDword	(0X62F0);
	MakeName	(0X62F0,	"DevEntry");
	MakeComm	(0X62F4,	"Break address of the device driver");
	MakeDword	(0X62F4);
	MakeName	(0X62F4,	"DevBrkAddr");
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_4(void) {
        auto x;
#define id x

	MakeComm	(0X62F8,	"Use conventional (dos 5 style) InitDevLoad?");
	MakeByte	(0X62F8);
	MakeName	(0X62F8,	"ConvLoad");
	MakeComm	(0X62F9,	"byte indicating whether to load DDs in UMBs");
	MakeByte	(0X62F9);
	MakeName	(0X62F9,	"DevUMB");
	MakeComm	(0X62FA,	"current UMB used for loading devices (paras)");
	MakeWord	(0X62FA);
	MakeName	(0X62FA,	"DevUMBAddr");
	MakeComm	(0X62FC,	"Size of the current UMB being used (paras)");
	MakeWord	(0X62FC);
	MakeName	(0X62FC,	"DevUMBSize");
	MakeComm	(0X62FE,	"Start of free mem blk in the current UMB (paras)");
	MakeWord	(0X62FE);
	MakeName	(0X62FE,	"DevUMBFree");
	MakeDword	(0X6300);
	MakeName	(0X6300,	"DevXMSAddr");
	MakeComm	(0X6304,	"Device load address parameter to Exec call");
	MakeWord	(0X6304);
	MakeName	(0X6304,	"DevExecAddr");
	MakeComm	(0X6306,	"Device load relocation factor");
	MakeWord	(0X6306);
	MakeName	(0X6306,	"DevExecReloc");
	MakeComm	(0X6308,	"Flag indicating whether the current device\nis being loaded into UMB");
	MakeByte	(0X6308);
	MakeName	(0X6308,	"DeviceHi");
	MakeComm	(0X6309,	"SIZE= option");
	MakeWord	(0X6309);
	MakeName	(0X6309,	"DevSizeOption");
	MakeComm	(0X630B,	"did we trap int 12h ?");
	MakeByte	(0X630B);
	MakeName	(0X630B,	"Int12Lied");
	MakeComm	(0X630C,	"value in 40:13h (int 12h ram)");
	MakeWord	(0X630C);
	MakeName	(0X630C,	"OldInt12Mem");
	MakeComm	(0X630E,	"3Com Device name");
	MakeStr		(0X630E,	0X6316);
	MakeName	(0X630E,	"ThreeComName");
	MakeByte	(0X6316);
	MakeName	(0X6316,	"FirstUMBLinked");
	MakeComm	(0X6317,	"segment of DOS Data");
	MakeWord	(0X6317);
	MakeName	(0X6317,	"DevDOSData");
	MakeComm	(0X6319,	"Current Command line");
	MakeDword	(0X6319);
	MakeName	(0X6319,	"DevCmdLine");
	MakeComm	(0X631D,	"The delimiter which was replaced with null\nto use the file name in the command line");
	MakeByte	(0X631D);
	MakeName	(0X631D,	"DevSavedDelim");
	MakeComm	(0X631E,	"set non-zero when MagicDrv is final placed");
	MakeByte	(0X631E);
	MakeName	(0X631E,	"MagicHomeFlag");
	MakeCode	(0X631F);
	MakeName	(0X631F,	"doconf");
	MakeCode	(x=0X6321);
	OpHex		(x,	1);
	MakeComm	(0X6324,	"DOS - 2+ internal - GET SWITCHAR/AVAILDEV\nReturn: AL = FFh unsupported subfunction\nDL = current switch character");
	MakeCode	(x=0X6324);
	OpHex		(x,	0);
	MakeComm	(0X632A,	"save default switchchar");
	MakeCode	(x=0X632E);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6331,	"OPEN<<8");
	MakeComm	(0X6334,	"(in case of int 24h)");
	MakeComm	(0X6335,	"DOS - 2+ - OPEN DISK FILE WITH HANDLE\nDS:DX -> ASCIZ filename\nAL = access mode\n0 - read");
	MakeCode	(x=0X6335);
	OpHex		(x,	0);
	MakeComm	(0X6337,	"brif opened okay\n\nconfig.sys file open error");
	MakeComm	(0X6339,	"we still want to give the guy\na chance to select clean boot!\n(ie, no autoexec.bat processing)");
	MakeComm	(0X633C,	"set it to unreasonable number");
	MakeCode	(x=0X633C);
	OpDecimal	(x,	1);
	MakeComm	(0X6342,	"get file size (note < 64k!!)\nFile handle");
	MakeCode	(0X6342);
	MakeCode	(x=0X6348);
	OpHex		(x,	1);
	MakeComm	(0X634B,	"DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)\nAL = method: offset from end of file");
	MakeCode	(x=0X634B);
	OpHex		(x,	0);
	MakeComm	(0X6350,	"reset pointer to beginning of file");
	MakeCode	(x=0X6352);
	OpHex		(x,	1);
	MakeComm	(0X6355,	"DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)\nAL = method: offset from beginning of file");
	MakeCode	(x=0X6355);
	OpHex		(x,	0);
	MakeComm	(0X6357,	"use current alloclim value");
	MakeComm	(0X635E,	"save the size of config.sys file.");
	MakeComm	(0X6366,	"reserve 1 additional paragraph");
	MakeComm	(0X6367,	"this is the segment to be used for");
	MakeComm	(0X636B,	"rebuilding the config.sys memory image");
	MakeComm	(0X636D,	"room for header");
	MakeComm	(0X6370,	"config starts here. new alloclim value.");
	MakeCode	(x=0X6383);
	OpHex		(x,	1);
	MakeComm	(0X6385,	"(in case of int 24h)");
	MakeComm	(0X6386,	"DOS - 2+ - READ FROM FILE WITH HANDLE\nBX = file handle, CX = number of bytes to read\nDS:DX -> buffer");
	MakeCode	(x=0X6386);
	OpHex		(x,	0);
	MakeComm	(0X6389,	"find the eof mark in the file.\nif present,then trim length.");
	MakeComm	(0X638C,	"eof mark");
	MakeComm	(0X638E,	"point to buffer");
	MakeComm	(0X6390,	"no chars");
	MakeComm	(0X6392,	"find end");
	MakeComm	(0X6394,	"none found and count exhausted");
	MakeComm	(0X6396,	"backup past 1Ah");
	MakeComm	(0X6397,	"cr,lf");
	MakeComm	(0X639D,	"difference moved");
	MakeComm	(0X639F,	"new count");
	MakeCode	(x=0X63AA);
	OpHex		(x,	1);
	MakeComm	(0X63AC,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle");
	MakeCode	(x=0X63AC);
	OpHex		(x,	0);
	MakeComm	(0X63B0,	"we've got a problem");
	MakeComm	(0X63B4,	"if ax <(>) cx\ncouldn't read the file");
	MakeCode	(x=0X63B6);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeName	(0X63BC,	"endconv");
	MakeCode	(0X63BD);
	MakeName	(0X63BD,	"multi_pass");
	MakeComm	(0X63BF,	"do nothing. just return.");
	MakeCode	(x=0X63BF);
	OpDecimal	(x,	1);
	MakeComm	(0X63CA,	"es = [confbot] (CONFIG.SYS image seg)");
	MakeComm	(0X63CB,	"set count");
	MakeComm	(0X63D3,	"0");
	MakeComm	(0X63D5,	"reset chrptr");
	MakeComm	(0X63D9,	"reset linecount");
	MakeComm	(0X63E2,	"organize the file");
	MakeCode	(0X63E2);
	MakeName	(0X63E2,	"getcom");
	MakeComm	(0X63EA,	"increase linecount");
	MakeComm	(0X63EE,	"reset multdeviceflag.");
	MakeComm	(0X63F3,	"reset setdevmarkflag.");
	MakeComm	(0X63F8,	"lf ; linefeed?");
	MakeComm	(0X63FA,	"then ignore this line.\n\nIf this is a genuine CONFIG.SYS command,\nthen there should be a line number\nimmediately following it");
	MakeComm	(0X63FC,	"save original command code");
	MakeComm	(0X63FF,	"~CONFIG_OPTION_QUERY");
	MakeCode	(x=0X63FF);
	OpHex		(x,	1);
	MakeComm	(0X6401,	"is this a multi-config config.sys?");
	MakeComm	(0X6406,	"no, line number is not embedded");
	MakeComm	(0X6409,	"ignore end-of-image errors");
	MakeComm	(0X640C,	"because if there's an error");
	MakeComm	(0X640E,	"fetching the line number that's");
	MakeComm	(0X6411,	"supposed to be there, the next");
	MakeComm	(0X6413,	"getchr call will get the same error");
	MakeComm	(0X6417,	"final pass?");
	MakeComm	(0X641C,	"no");
	MakeComm	(0X641E,	"have_install_cmd\nare there install commands?");
	MakeCode	(x=0X641E);
	OpHex		(x,	1);
	MakeComm	(0X6424,	"no install cmds, yes it is");
	MakeComm	(0X6426,	"final pass?");
	MakeComm	(0X642B,	"no");
	MakeComm	(0X642D,	"save backward-compatible command code");
	MakeComm	(0X643C,	"it would be 'jnb short endconv' \n(E.TAN - 09/07/2023)\ndo not show badop again for multi_pass.");
	MakeCode	(0X6441);
	MakeCode	(0X6448);
	MakeCode	(0X644D);
	MakeComm	(0X644F,	"the initial pass for DOS=HI");
	MakeComm	(0X6459,	"the second pass was for ifs=");
	MakeCode	(0X6459);
	MakeComm	(0X645E,	"now it is NOPs\n\nThis pass can be made use of if\nwe want do some config.sys process\nafter device drivers are loaded and\nbefore install= commands are processed");
	MakeComm	(0X6460,	"the third pass for install= ?");
	MakeComm	(0X6467,	"CONFIG_DOS");
	MakeComm	(0X646C,	"CONFIG_INSTALL ; install= command?");
	MakeComm	(0X646F,	"\nthe first pass is for normal operation.");
	MakeComm	(0X6471,	"have_install_cmd ; set the flag");
	MakeCode	(x=0X6471);
	OpHex		(x,	1);
	MakeComm	(0X6476,	"and handles the next command");
	MakeComm	(0X6478,	"CONFIG_INSTALLHIGH ; signifier for INSTALLHIGH");
	MakeCode	(0X6478);
	MakeComm	(0X647B,	"carry on with normal processing");
	MakeComm	(0X647D,	"have_install_cmd");
	MakeCode	(x=0X647D);
	OpHex		(x,	1);
	MakeComm	(0X6484,	"CONFIG_INSTALL ; install= command?");
	MakeCode	(0X6484);
	MakeComm	(0X6487,	"no, check for installhigh");
	MakeComm	(0X6489,	"query the user if config_cmd");
	MakeComm	(0X648C,	"has the CONFIG_OPTION_QUERY bit set");
	MakeComm	(0X648E,	"install it.");
	MakeComm	(0X6491,	"to handle next install= command.");
	MakeComm	(0X6493,	"CONFIG_INSTALLHIGH ; installhigh= command?");
	MakeCode	(0X6493);
	MakeComm	(0X6498,	"query the user if config_cmd");
	MakeComm	(0X649B,	"has the CONFIG_OPTION_QUERY bit set");
	MakeCode	(x=0X649D);
	OpHex		(x,	1);
	MakeComm	(0X64A0,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: get allocation strategy");
	MakeCode	(x=0X64A0);
	OpHex		(x,	0);
	MakeComm	(0X64A4,	"save for the return");
	MakeComm	(0X64A5,	"HIGH_FIRST ; set alloc to HighFirst");
	MakeCode	(x=0X64A5);
	OpHex		(x,	1);
	MakeComm	(0X64A9,	"(ALLOCOPER<<8)|1");
	MakeCode	(x=0X64A9);
	OpHex		(x,	1);
	MakeComm	(0X64AC,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: set allocation strategy");
	MakeCode	(x=0X64AC);
	OpHex		(x,	0);
	MakeCode	(x=0X64AE);
	OpHex		(x,	1);
	MakeComm	(0X64B1,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) get UMB link state");
	MakeCode	(x=0X64B1);
	OpHex		(x,	0);
	MakeComm	(0X64B5,	"save for the return");
	MakeComm	(0X64B6,	"(ALLOCOPER<<8)|3");
	MakeComm	(0X64B9,	"link in UMBs");
	MakeComm	(0X64BC,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) set UMB link state");
	MakeCode	(x=0X64BC);
	OpHex		(x,	0);
	MakeComm	(0X64BE,	"install it.");
	MakeComm	(0X64C4,	"recover original link state");
	MakeComm	(0X64C5,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) set UMB link state");
	MakeCode	(x=0X64C5);
	OpHex		(x,	0);
	MakeComm	(0X64C7,	"recover original alloc strategy");
	MakeCode	(x=0X64C8);
	OpHex		(x,	1);
	MakeComm	(0X64CB,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: set allocation strategy");
	MakeCode	(x=0X64CB);
	OpHex		(x,	0);
	MakeComm	(0X64CD,	"to handle next install= commands.");
	MakeComm	(0X64D0,	"CONFIG_COMMENT ; comment?");
	MakeCode	(0X64D0);
	MakeComm	(0X64D5,	"CONFIG_UNKNOWN ; bad command?");
	MakeComm	(0X64DA,	"CONFIG_REM ; rem?");
	MakeComm	(0X64DD,	"ignore the rest of the commands.");
	MakeComm	(0X64DF,	"these commands need to\nadjust chrptr,count");
	MakeComm	(0X64E3,	"for newline proc.");
	MakeComm	(0X64E7,	"to handle next install= commands.");
	MakeComm	(0X64EA,	"CONFIG_BUFFERS");
	MakeCode	(0X64EA);
	MakeComm	(0X64EF,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set");
	MakeCode	(x=0X64F9);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6503,	"\nparse error,\nand show messages and end the search");
	MakeComm	(0X650A,	"_$P_RC_EOL ; end of line?");
	MakeCode	(0X650A);
	MakeComm	(0X650D,	"then jmp to $endloop for semantic check");
	MakeComm	(0X650F,	"(/X switch)\n[result_val+_$P_Result_Blk.SYNONYM_Ptr]");
	MakeCode	(x=0X650F);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6519,	"[result_val+_$P_Result_Blk.Picked_Val]");
	MakeCode	(0X6519);
	MakeCode	(0X6526);
	MakeCode	(x=0X652B);
	OpDecimal	(x,	1);
	MakeComm	(0X653D,	"we don't have any problem.");
	MakeCode	(0X653D);
	MakeComm	(0X6540,	"now,let's set it really.");
	MakeComm	(0X654C,	"save the line number\nfor the future use");
	MakeComm	(0X6552,	"CONFIG_BREAK");
	MakeCode	(0X6552);
	MakeComm	(0X6557,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set");
	MakeCode	(x=0X655C);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6566,	"\nparse error");
	MakeComm	(0X656D,	"_$P_RC_EOL ; end of line?");
	MakeCode	(0X656D);
	MakeComm	(0X6570,	"then end the $endloop");
	MakeComm	(0X6572,	"[result_val+_$P_Result_Blk.Item_Tag]");
	MakeComm	(0X6579,	"turn it on");
	MakeComm	(0X6580,	"turn it off");
	MakeCode	(0X6580);
	MakeComm	(0X6585,	"we actually set the ctrl break");
	MakeComm	(0X6587,	"SET_CTRL_C_TRAPPING\nif we don't have any parse error.");
	MakeCode	(x=0X6587);
	OpHex		(x,	1);
	MakeComm	(0X658F,	"DOS - EXTENDED CONTROL-BREAK CHECKING\nAL = 00h get state / 01h set state / 02h set AND get\nDL = 00h for OFF or 01h for ON");
	MakeCode	(x=0X658F);
	OpHex		(x,	0);
	MakeComm	(0X6594,	"CONFIG_MULTITRACK");
	MakeCode	(0X6594);
	MakeComm	(0X6599,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set");
	MakeCode	(x=0X659E);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X65A8,	"\nparse_error");
	MakeComm	(0X65AA,	"show message and end the search loop.");
	MakeComm	(0X65AF,	"_$P_RC_EOL ; end of line?");
	MakeCode	(0X65AF);
	MakeComm	(0X65B4,	"[result_val+_$P_Result_Blk.Item_Tag]");
	MakeComm	(0X65BB,	"turn it on temporarily.");
	MakeComm	(0X65C2,	"turn it off temporarily.");
	MakeCode	(0X65C2);
	MakeComm	(0X65C7,	"we actually set the multrk_flag here");
	MakeCode	(0X65C9);
	MakeComm	(0X65CA,	"DOSBIODATASEG ; BIOSDATA segment");
	MakeCode	(x=0X65CA);
	OpHex		(x,	1);
	MakeComm	(0X65D7,	"multrk_off2");
	MakeCode	(x=0X65D7);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X65DF,	"multrk_on");
	MakeCode	(x=0X65DF);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	OpHex		(x,	1);
	MakeComm	(0X65E9,	"CONFIG_DOS");
	MakeCode	(0X65E9);
	MakeCode	(x=0X65EE);
	OpSign		(x,	0);
	OpHex		(x,	0);
	MakeComm	(0X65F1,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set");
	MakeCode	(0X65F1);
	MakeCode	(x=0X65F6);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6602,	"parse error\nshow message and end the search loop.");
	MakeName	(0X6602,	"h_badparm");
	MakeComm	(0X6607,	"_$P_RC_EOL ; end of line?");
	MakeCode	(0X6607);
	MakeComm	(0X660A,	"then end the $endloop");
	MakeCode	(0X6611);
	MakeComm	(0X6614,	"CONFIG_DEVICEHIGH");
	MakeCode	(0X6614);
	MakeComm	(0X6619,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set");
	MakeComm	(0X6621,	"process the size= option");
	MakeComm	(0X6624,	"\nstash it there in case of an error");
	MakeCode	(0X6636);
	MakeComm	(0X6643,	"\nIf ParseVar up there failed, then\nES:SI points to its problem area..");
	MakeComm	(0X664D,	"so all we have to do is choke and\ndie, rather verbosely.");
	MakeCode	(0X6653);
	MakeComm	(0X6658,	"cr");
	MakeComm	(0X665C,	"lf");
	MakeComm	(0X6668,	"Save the delimiter\nbefore replacing it with null");
	MakeCode	(0X6668);
	MakeComm	(0X6672,	"See if UMBs are around...");
	MakeComm	(0X6675,	"yep. So do that normal thang.");
	MakeComm	(0X6677,	"nope... so load low.");
	MakeCode	(0X667F);
	MakeComm	(0X6685,	"do we support UMBs ?");
	MakeComm	(0X668B,	"no, we don't");
	MakeComm	(0X6695,	"CONFIG_DEVICE");
	MakeCode	(0X6695);
	MakeComm	(0X669D,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set");
	MakeCode	(0X669D);
	MakeComm	(0X66A2,	"not to be loaded in UMB");
	MakeComm	(0X66AF,	"In case of DEVICE= \nthe null has to be replaced with a ' '");
	MakeComm	(0X66B7,	"\npass the command line to the device");
	MakeComm	(0X66BF,	"save it for ourself");
	MakeComm	(0X66C7,	"clear total block units for driver");
	MakeComm	(0X66D4,	"Doesn't matter if DeviceHi==0");
	MakeComm	(0X66D9,	"If not using upper memory,\n('mov al, [DeviceHi]' is not needed here\n because al value is not used after here)");
	MakeComm	(0X66DC,	"(or al, al) - Erdogan Tan - 10/07/2023");
	MakeCode	(x=0X66DC);
	OpHex		(x,	1);
	MakeComm	(0X66E1,	"Skip all this and go on \nto the actual load.");
	MakeComm	(0X66E3,	"('mov al, [UmbLoad]' would be better here)");
	MakeComm	(0X66E6,	"-1 ; If umb0 not specified, it's old style");
	MakeComm	(0X66E8,	"so load high even if SIZE= is smaller");
	MakeComm	(0X66EA,	"0 ; They specified /L, so use new loader");
	MakeComm	(0X66EE,	"Returns size of first UMB specified");
	MakeComm	(0X66F3,	"If size is not specified..");
	MakeComm	(0X66F5,	"/L:...,Size < DevSize?");
	MakeComm	(0X66FB,	"Size < DevSize, so write DevSize as");
	MakeComm	(0X66FE,	"minsize for load UMB.");
	MakeComm	(0X6716,	"Does nothing if didn't call HideUMBs");
	MakeCode	(0X6716);
	MakeComm	(0X6719,	"blank/space");
	MakeCode	(0X6722);
	MakeCode	(0X6728);
	MakeComm	(0X672A,	"ds:dx points to file name");
	MakeComm	(0X672C,	"load device driver using exec call");
	MakeComm	(0X6730,	"es:si back to config.sys");
	MakeComm	(0X6732,	"ds back to sysinit");
	MakeComm	(0X6745,	"[si+SYSDEV.ATT],DEVTYP\nblock device driver?");
	MakeCode	(x=0X6745);
	OpHex		(x,	1);
	MakeComm	(0X674A,	"no.");
	MakeComm	(0X674C,	"ds:si -> sys_var");
	MakeComm	(0X6751,	"[si+SYSI_NUMIO]\nno more than 26 drive number");
	MakeCode	(x=0X6751);
	OpDecimal	(x,	1);
	MakeComm	(0X6759,	"clear the stack");
	MakeComm	(0X675B,	"Do this before we leave");
	MakeCode	(0X6761);
	MakeComm	(0X6766,	"update the PSP:2 value");
	MakeComm	(0X6769,	"Pass limit only for\nthe 1st device driver in the file");
	MakeComm	(0X6771,	"pass the limit to the DD");
	MakeComm	(0X6783,	"ds:bx -> sys_var");
	MakeComm	(0X6788,	"temporarily use this next drv value");
	MakeComm	(0X678C,	"pass drive number in packet to driver");
	MakeComm	(0X6792,	"[bx+SYSI_NUMIO]\nswap with existing values");
	MakeComm	(0X6796,	"save real sysi_numio/ncds in ax\n\nmov word ptr cs:configmsgflag, 0\nPCDOS 7.1 IBMBIO.COM - SYSINIT:2C5Fh\n(disable \"error in config.sys line #\" msg)\n((before loading -next- device driver))\nE.TAN - 10/07/2023\n;");
	MakeComm	(0X6797,	"SYSDEV.STRAT");
	MakeComm	(0X679A,	"calldev (sdevstrat);");
	MakeComm	(0X679D,	"SYSDEV.INT");
	MakeComm	(0X67A0,	"calldev (sdevint);");
	MakeComm	(0X67A3,	"get real sysi_numio value");
	MakeComm	(0X67A5,	"ds:bx -> sys_var");
	MakeComm	(0X67AA,	"[bx+SYSI_NUMIO]\nrestore previous/real value");
	MakeComm	(0X67B1,	"move break addr from the req packet");
	MakeComm	(0X67C1,	"There we go... all done.");
	MakeComm	(0X67D7,	"move DOS into HMA if requsted");
	MakeComm	(0X67DC,	"*p = 0;");
	MakeCode	(0X67E3);
	MakeCode	(x=0X67E5);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X67EB,	"(Note: 'call CheckDoubleSpace'\nhas been removed at 'erase_dev_do:' pos\nin PCDOS 7.1 IBMBIO.COM - SYSINIT:2CBAh)\nErdogan Tan - 10/07/2023");
	MakeComm	(0X67F2,	"is error_line msg disabled ?");
	MakeComm	(0X67F8,	"yes");
	MakeComm	(0X67FA,	"show \"error in config.sys ...\" message.");
	MakeComm	(0X67FD,	"set the default value again.");
	MakeCode	(0X6807);
	MakeComm	(0X6817,	"set ds:dx to header");
	MakeCode	(0X6817);
	MakeComm	(0X681E,	"es:di point to dos info");
	MakeComm	(0X6823,	"[si+SYSDEV.ATT] ; get attributes");
	MakeComm	(0X6826,	"DEVTYP ; test if block dev");
	MakeCode	(x=0X6826);
	OpHex		(x,	1);
	MakeComm	(0X682B,	"for_devmark");
	MakeCode	(x=0X682B);
	OpHex		(x,	1);
	MakeComm	(0X6831,	"go ahead and alloc mem for device");
	MakeComm	(0X6834,	"device driver's init routine failed.");
	MakeComm	(0X6836,	"ISCIN ; is it a console in?");
	MakeCode	(x=0X6836);
	OpHex		(x,	1);
	MakeComm	(0X683B,	"[es:di+SYSI_CON]");
	MakeComm	(0X683F,	"[es:di+SYSI_CON+2]");
	MakeComm	(0X6843,	"ISCLOCK ; is it a clock device?");
	MakeCode	(x=0X6843);
	OpHex		(x,	1);
	MakeComm	(0X6848,	"[es:di+SYSI_CLOCK]");
	MakeComm	(0X684C,	"[es:di+SYSI_CLOCK]");
	MakeCode	(0X6853);
	MakeComm	(0X6857,	"if no units found, erase the device");
	MakeComm	(0X685B,	"[si+SYSDEV.NAME]\nnumber of units in name field");
	MakeComm	(0X685E,	"keep total for all drivers in file");
	MakeComm	(0X6863,	"warning no device > 127 units");
	MakeName	(0X6863,	"perdrv");
	MakeComm	(0X6868,	"[es:di+SYSI_NUMIO]\nget number of devices");
	MakeComm	(0X686E,	"check for too many devices");
	MakeComm	(0X6870,	"'A' - 'Z' is 26 devices");
	MakeCode	(x=0X6870);
	OpDecimal	(x,	1);
	MakeComm	(0X6878,	"for_devmark");
	MakeCode	(x=0X6878);
	OpHex		(x,	1);
	MakeComm	(0X687E,	"alloc the device");
	MakeComm	(0X6883,	"[es:di+SYSI_NUMIO]\nupdate the amount");
	MakeComm	(0X6887,	"remember amount for next device");
	MakeComm	(0X688C,	"point to bpb array");
	MakeComm	(0X6896,	"[es:bp+SYSI_DPB] ; get first dpb");
	MakeComm	(0X689A,	"[es:bp+DPB.NEXT_DPB],-1");
	MakeComm	(0X68A1,	"[es:bp+DPB.NEXT_DPB] ; [es:bp+25]");
	MakeCode	(0X68A7);
	MakeComm	(0X68AB,	"[es:bp+DPB.NEXT_DPB]");
	MakeComm	(0X68B3,	"[es:bp+DPB.NEXT_DPB+2]");
	MakeComm	(0X68BC,	"DPBSIZ = 33 \n(61 in PCDOS 7.1 IBMBIO.COM)");
	MakeCode	(x=0X68BC);
	OpDecimal	(x,	1);
	MakeComm	(0X68C5,	"[es:bp+DPB.NEXT_DPB],-1");
	MakeComm	(0X68CB,	"[es:bp+DPB.FIRST_ACCESS],-1 ; byte");
	MakeComm	(0X68D0,	"ds:si points to bpb");
	MakeComm	(0X68D3,	"point to next bpb");
	MakeComm	(0X68D4,	"[es:bp+DPB.DRIVE]");
	MakeComm	(0X68D8,	"SETDPB ; hidden system call");
	MakeCode	(x=0X68D8);
	OpHex		(x,	1);
	MakeComm	(0X68DA,	"DOS - 2+ internal - TRANSLATE BIOS PARAMETER BLOCK\nDS:SI -> BPB (BIOS Parameter Block)\nES:BP -> buffer for DOS Drive Parameter Block");
	MakeCode	(x=0X68DA);
	OpHex		(x,	0);
	MakeComm	(0X68DC,	"[es:bp+DPB.SECTOR_SIZE]");
	MakeComm	(0X68E1,	"es:di point to dos info");
	MakeComm	(0X68E6,	"[es:di+SYSI_MAXSEC]");
	MakeCode	(0X68F0);
	MakeComm	(0X68F7,	"[es:bp+DPB.DRIVER_ADDR]");
	MakeComm	(0X68FB,	"[es:bp+DPB.DRIVER_ADDR+2]");
	MakeComm	(0X6904,	"cx = cx - 1\ncx = remain count from [cs:unitcount]\nloop until cx is 0");
	MakeComm	(0X690B,	"es:di = dos table");
	MakeComm	(0X6910,	"[es:di+SYSI_DEV] ; dx:cx = head of list");
	MakeComm	(0X6914,	"[es:di+SYSI_DEV+2]");
	MakeComm	(0X6918,	"ds:si = device location");
	MakeComm	(0X691D,	"set head of list in dos\n[es:di+SYSI_DEV]");
	MakeComm	(0X6921,	"[es:di+SYSI_DEV+2]");
	MakeComm	(0X6925,	"get pointer to next device");
	MakeComm	(0X6927,	"and save it");
	MakeComm	(0X692B,	"link in the driver");
	MakeComm	(0X6932,	"ax = 0FFFFh (no more devs if yes)?");
	MakeComm	(0X6935,	"possibly multiple device driver.");
	MakeComm	(0X693D,	"otherwise pretend we loaded it in");
	MakeComm	(0X6940,	"reset the flag");
	MakeCode	(0X6940);
	MakeComm	(0X6949,	"adjust alloclim if Protman$ just\ncreated a bogus arena to try\nto protect some of its resident-\ninit code.");
	MakeComm	(0X694C,	"\ninquire of MagicDrv whether it is present,\nand final located");
	MakeComm	(0X6952,	"already home?");
	MakeCode	(0X6952);
	MakeName	(0X6952,	"CheckDoubleSpace");
	MakeComm	(0X6958,	"nothing more to do if so");
	MakeComm	(0X695A,	"multMagicdrv");
	MakeComm	(0X695D,	"MD_VERSION");
	MakeComm	(0X6960,	" ch = number of MagicDrv drive letters");
	MakeCode	(x=0X6960);
	OpHex		(x,	0);
	MakeComm	(0X6962,	"is it there?");
	MakeComm	(0X6964,	"done if not");
	MakeComm	(0X6966,	"is it final placed?");
	MakeCode	(x=0X6966);
	OpHex		(x,	1);
	MakeComm	(0X696A,	"skip if not");
	MakeComm	(0X696C,	"set the flag!");
	MakeComm	(0X6972,	"add number of MagicDrv volumes to\nthe drive number we'll pass to the\nnext loadable block device.");
	MakeComm	(0X6977,	"and finished.\n(retn)");
	MakeCode	(0X6979);
	MakeComm	(0X697B,	"pass it a work buffer");
	MakeComm	(0X6980,	"address in cx (segment)");
	MakeComm	(0X6985,	"for len dx (paragraphs)");
	MakeComm	(0X698A,	"shuffle magicdrives and new drives\nby this many units");
	MakeComm	(0X698E,	"backdoor won't shuffle unless it\nsees this, to prevent bad things\nfrom happening if people run the\nnew driver with an old (dos) BIOS");
	MakeCode	(x=0X698E);
	OpHex		(x,	1);
	MakeCode	(0X6998);
	MakeCode	(x=0X699A);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X699D);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X69A6,	"CONFIG_COUNTRY");
	MakeCode	(0X69A6);
	MakeComm	(0X69AE,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set");
	MakeCode	(0X69AE);
	MakeComm	(0X69B3,	"\nreset the drive,path to default value.");
	MakeCode	(x=0X69C0);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X69CA,	"parse error,check error code and");
	MakeComm	(0X69CC,	"show message and end the search loop.");
	MakeComm	(0X69CF,	"-1 ; signals that parse error.");
	MakeComm	(0X69D8,	"_$P_RC_EOL ; end of line?");
	MakeCode	(0X69D8);
	MakeComm	(0X69DD,	"_$P_Number");
	MakeComm	(0X69E5,	"\n[cs:result_val+_$P_Result_Blk.Picked_Val]");
	MakeCode	(0X69F4);
	MakeComm	(0X69F8,	"path entered");
	MakeCode	(0X69FA);
	MakeComm	(0X6A00,	"move the path to known place.");
	MakeCode	(x=0X6A05);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6A11,	"-1 ; had a parse error?");
	MakeCode	(0X6A11);
	MakeCode	(0X6A1C);
	MakeCode	(x=0X6A1D);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X6A23);
	MakeCode	(x=0X6A2B);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X6A30);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6A33,	"open a file");
	MakeComm	(0X6A37,	"DOS - 2+ - OPEN DISK FILE WITH HANDLE\nDS:DX -> ASCIZ filename\nAL = access mode\n0 - read");
	MakeCode	(x=0X6A37);
	OpHex		(x,	0);
	MakeComm	(0X6A3B,	"save file handle");
	MakeComm	(0X6A45,	"ax=country id, bx=filehandle");
	MakeComm	(0X6A4F,	"need 6k buffer to handle country.sys\n(384*16 bytes)");
	MakeCode	(x=0X6A4F);
	OpDecimal	(x,	1);
	MakeComm	(0X6A58,	"cannot allocate the buffer for country.sys");
	MakeCode	(x=0X6A5A);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6A5D,	"default path?");
	MakeComm	(0X6A60,	"no");
	MakeComm	(0X6A63,	"ds:si -> cntry_root");
	MakeComm	(0X6A64,	"es:di -> country info tab in dos");
	MakeComm	(0X6A69,	"save di");
	MakeComm	(0X6A6A,	"country_cdpg_info.ccPath_CountrySys");
	MakeComm	(0X6A6D,	"set the path to country.sys in dos.");
	MakeComm	(0X6A70,	"es:di -> country info tab again.");
	MakeComm	(0X6A78,	"ds:si -> 2k buffer to be used.");
	MakeComm	(0X6A7A,	"now do the job!");
	MakeComm	(0X6A7D,	"read error or could not find country,\ncode page combination");
	MakeComm	(0X6A7F,	"-1\ncould not find matching country_id, code page?");
	MakeComm	(0X6A82,	"then \"invalid country code or code page\"");
	MakeComm	(0X6A86,	"is the default file used?");
	MakeCode	(x=0X6A8E);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6A93,	"default file has been used.\nes:si -> \\country.sys in sysinit_seg");
	MakeCode	(x=0X6A93);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6A9E,	"restore es -> confbot.");
	MakeCode	(x=0X6AA2);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6AAA,	"restore es -> confbot seg");
	MakeComm	(0X6AAD,	"restore ds to sysinit_seg");
	MakeComm	(0X6AAE,	"if no error,then exit");
	MakeComm	(0X6AB0,	"else show error message");
	MakeComm	(0X6AB6,	"close a file.\ndon't care even if it fails.");
	MakeCode	(x=0X6ABB);
	OpHex		(x,	1);
	MakeComm	(0X6ABD,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle");
	MakeCode	(x=0X6ABD);
	OpHex		(x,	0);
	MakeComm	(0X6AC2,	"_$P_Out_Of_Range");
	MakeCode	(0X6AC2);
	MakeName	(0X6AC2,	"cntry_error");
	MakeCode	(x=0X6AC7);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X6ACC);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6AD6,	"CONFIG_FILES");
	MakeCode	(0X6AD6);
	MakeComm	(0X6ADB,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set");
	MakeCode	(x=0X6AE0);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6AEA,	"\nparse error\nshow messages and end the search loop.");
	MakeComm	(0X6AF1,	"_$P_RC_EOL ; end of line?");
	MakeCode	(0X6AF1);
	MakeComm	(0X6AF4,	"then end the $endloop");
	MakeComm	(0X6AF6,	"\n[result_val+_$P_Result_Blk.Picked_Val]");
	MakeComm	(0X6AFA,	"save it temporarily");
	MakeCode	(0X6B00);
	MakeComm	(0X6B04,	"no error. really set the value now.");
	MakeComm	(0X6B0B,	"CONFIG_LASTDRIVE");
	MakeCode	(0X6B0B);
	MakeComm	(0X6B10,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set");
	MakeCode	(x=0X6B15);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6B1F,	"\nparse error\nshow messages and end the search loop.");
	MakeComm	(0X6B26,	"_$P_RC_EOL ; end of line?");
	MakeCode	(0X6B26);
	MakeComm	(0X6B29,	"then end the $endloop");
	MakeComm	(0X6B2B,	"[rv_byte]\npick up the drive number");
	MakeComm	(0X6B2F,	"save it temporarily");
	MakeCode	(0X6B35);
	MakeComm	(0X6B39,	"no error.\nreally set the value now.");
	MakeComm	(0X6B40,	"CONFIG_DRIVPARM");
	MakeCode	(0X6B40);
	MakeComm	(0X6B45,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set");
	MakeCode	(0X6B58);
	MakeComm	(0X6B5B,	"CONFIG_STACKS");
	MakeCode	(0X6B5B);
	MakeComm	(0X6B63,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set");
	MakeCode	(0X6B63);
	MakeCode	(x=0X6B68);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6B72,	"parse error");
	MakeCode	(x=0X6B74);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6B77,	"show messages and end the search loop.");
	MakeComm	(0X6B7D,	"(jmp coff)");
	MakeComm	(0X6B80,	"_$P_RC_EOL ; end of line?");
	MakeCode	(0X6B80);
	MakeComm	(0X6B83,	"then end the $endloop");
	MakeComm	(0X6B85,	"\n[cs:result_val+_$P_Result_Blk.Picked_Val]");
	MakeCode	(0X6B94);
	MakeCode	(0X6B9A);
	MakeComm	(0X6BA2,	"mincount");
	MakeCode	(x=0X6BA2);
	OpHex		(x,	1);
	MakeComm	(0X6BAA,	"minsize");
	MakeCode	(x=0X6BAA);
	OpDecimal	(x,	1);
	MakeCode	(0X6BBB);
	MakeComm	(0X6BC3,	"-1 ; invalid");
	MakeComm	(0X6BCA,	"-1 ; invalid?");
	MakeComm	(0X6BD2,	"defaultcount\nreset to default value.");
	MakeComm	(0X6BD9,	"defaultsize");
	MakeCode	(x=0X6BD9);
	OpDecimal	(x,	1);
	MakeComm	(0X6BE0,	"stacks= been accepted.");
	MakeCode	(x=0X6BE7);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X6BF2);
	MakeComm	(0X6C02,	"-1 ; stacks= been accepted.");
	MakeComm	(0X6C0C,	"CONFIG_SHELL");
	MakeCode	(0X6C0C);
	MakeComm	(0X6C11,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set");
	MakeComm	(0X6C1C,	"\nzap length,first byte of command-line");
	MakeComm	(0X6C23,	"we already have the first char");
	MakeCode	(x=0X6C23);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6C26,	"of the new shell in AL, save it now");
	MakeComm	(0X6C2C,	"this is the normal case: \"organize\"");
	MakeComm	(0X6C2E,	"put a ZERO right after the filename");
	MakeComm	(0X6C30,	"this may happen if there are no args");
	MakeComm	(0X6C32,	"I suppose...");
	MakeComm	(0X6C37,	"commnd+63\nthis makes sure we don't overflow\ncommnd (the filename)");
	MakeCode	(x=0X6C37);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6C3F,	"zero-terminate the filename");
	MakeCode	(0X6C3F);
	MakeComm	(0X6C42,	"\nprepare to process the command-line");
	MakeCode	(x=0X6C42);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6C4F,	"command_line+126");
	MakeCode	(x=0X6C4F);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X6C57);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6C60,	"zero-terminate the filename\n(or the command-line as the case may be)");
	MakeComm	(0X6C63,	"lf ; the safest way to eat the rest of");
	MakeComm	(0X6C65,	"the line: watch for ever-present LF");
	MakeComm	(0X6C6F,	"CONFIG_FCBS");
	MakeCode	(0X6C6F);
	MakeComm	(0X6C74,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set");
	MakeComm	(0X6C85,	"parse error\nshow messages and end the search loop.");
	MakeComm	(0X6C8A,	"_$P_RC_EOL ; end of line?");
	MakeCode	(0X6C8A);
	MakeComm	(0X6C8D,	"then end the $endloop");
	MakeComm	(0X6C8F,	"\n[cs:result_val+_$P_Result_Blk.Picked_Val]");
	MakeComm	(0X6C93,	"the first positional?");
	MakeCode	(0X6C9E);
	MakeCode	(0X6CA4);
	MakeComm	(0X6CB5,	"CONFIG_SWITCHES\nswitches= command entered?");
	MakeCode	(0X6CB5);
	MakeComm	(0X6CB8,	"yes");
	MakeComm	(0X6CBD,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set");
	MakeCode	(0X6CBD);
	MakeCode	(x=0X6CC2);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6CCC,	"\nparse error\nshow messages and end the search loop.");
	MakeComm	(0X6CD3,	"_$P_RC_EOL ; end of line?");
	MakeCode	(0X6CD3);
	MakeComm	(0X6CD6,	"then jmp to $endloop for semantic check");
	MakeComm	(0X6CD8,	"offset \"/K\"\n[cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]");
	MakeCode	(x=0X6CD8);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6CE1,	"set the flag");
	MakeComm	(0X6CE9,	"offset \"/T\"\n[cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]");
	MakeCode	(x=0X6CE9);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6CF2,	"set the flag");
	MakeCode	(x=0X6CFA);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6D03,	"set the flag");
	MakeComm	(0X6D0B,	"if /k entered,");
	MakeCode	(0X6D0B);
	MakeComm	(0X6D12,	"DOSBIODATASEG ; BIOSDATA segment");
	MakeCode	(x=0X6D12);
	OpHex		(x,	1);
	MakeComm	(0X6D19,	"BIOSDATA:04E5h\nuse the conventional keyboard functions");
	MakeCode	(x=0X6D19);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X6D1E,	"BIOSDATA:04E6h");
	MakeCode	(x=0X6D1E);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeCode	(x=0X6D27);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X6D34,	"GET_IN_VARS");
	MakeCode	(x=0X6D34);
	OpHex		(x,	1);
	MakeComm	(0X6D36,	"DOS - 2+ internal - GET LIST OF LISTS\nReturn: ES:BX -> DOS list of lists");
	MakeCode	(x=0X6D36);
	OpHex		(x,	0);
	MakeComm	(0X6D38,	"[es:DOS_FLAG_OFFSET], SUPPRESS_WINA20");
	MakeCode	(x=0X6D38);
	OpHex		(x,	1);
	MakeComm	(0X6D44,	"CONFIG_SET ; set var=value<cr/lf>");
	MakeCode	(0X6D44);
	MakeComm	(0X6D49,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set");
	MakeComm	(0X6D4E,	"copy var at ES:SI to \"config_wrkseg\"");
	MakeComm	(0X6D51,	"no error");
	MakeComm	(0X6D53,	"whoops, display error in line XXX");
	MakeComm	(0X6D56,	"jump to coff (to skip to next line)");
	MakeComm	(0X6D58,	"CONFIG_NUMLOCK ; numlock=on|off");
	MakeCode	(0X6D58);
	MakeComm	(0X6D5D,	"query the user if config_cmd\nhas the CONFIG_OPTION_QUERY bit set");
	MakeComm	(0X6D67,	"all done");
	MakeComm	(0X6D69,	"CONFIG_COMMENT\n(do nothing with this line.)");
	MakeCode	(0X6D69);
	MakeCode	(x=0X6D6E);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X6D72);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X6D79,	"CONFIG_REM\n(do nothing with this line.)");
	MakeCode	(0X6D79);
	MakeComm	(0X6D7E,	"null/bogus command?");
	MakeCode	(x=0X6D83);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X6D87);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X6D8D,	"adjusts alloclim if Protman$ \nreduced our arena through a manual hack");
	MakeCode	(0X6D8D);
	MakeName	(0X6D8D,	"CheckProtmanArena");
	MakeComm	(0X6D8E,	"get our arena header");
	MakeComm	(0X6D95,	"[es:ARENA.SIZE] ; find end of arena");
	MakeComm	(0X6D9B,	"is it less than alloclim?");
	MakeComm	(0X6DA2,	"reduce alloclim then");
	MakeComm	(0X6DA8,	"set up registers for sysparse\nin:\n   es:si -> command line in confbot\n      di -> offset of the parse control definition.\nout:\n   calls sysparse.\n   carry will set if parse error.\n   *** the caller should check the eol condition by looking at ax\n   *** after each call.\n   *** if no parameters are found,then ax will contain a error code.\n   *** if the caller needs to look at the synomym@ of the result,\n   *** the caller should use cs:@ instead of es:@.\n   cx should be set to 0 at the 1st time the caller calls this proc.\n   ax - exit code\n   bl - terminated delimeter code\n   cx - new positional ordinal\n   si - set to pase scanned operand\n   dx - selected result buffer");
	MakeCode	(0X6DA8);
	MakeName	(0X6DA8,	"sysinit_parse");
	MakeComm	(0X6DAA,	"now ds:si -> command line");
	MakeComm	(0X6DAD,	"now es:di -> control definition");
	MakeComm	(0X6DAE,	"save the pointer to the parm");
	MakeComm	(0X6DB3,	"we are about to parse for badparm msg.");
	MakeComm	(0X6DBE,	"_$P_No_Error ; no error");
	MakeComm	(0X6DC1,	"cf=0");
	MakeComm	(0X6DC3,	"_$P_RC_EOL ; end of line?");
	MakeComm	(0X6DC6,	"or the end of line?");
	MakeCode	(0X6DCB);
	MakeComm	(0X6DCF,	"'badop_p' is not used in \nMSDOS 6.21 IO.SYS and PCDOS 7.1 IBMBIO.COM\n(but it was/is not removed)\nErdogan Tan - 11/07/2023");
	MakeCode	(0X6DCF);
	MakeName	(0X6DCF,	"badop_p");
	MakeCode	(x=0X6DD1);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X6DDB);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X6DE7);
	MakeName	(0X6DE7,	"badparm_p");
	MakeCode	(x=0X6DEC);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6DF6,	"print \"xxxx\" until cr.");
	MakeComm	(0X6DF8,	"cr ?");
	MakeComm	(0X6DFB,	"yes");
	MakeComm	(0X6DFD,	"display character");
	MakeCode	(x=0X6DFD);
	OpHex		(x,	1);
	MakeComm	(0X6DFF,	"DOS - DISPLAY OUTPUT\nDL = character to send to standard output");
	MakeCode	(x=0X6DFF);
	OpHex		(x,	0);
	MakeCode	(0X6E04);
	MakeCode	(x=0X6E06);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X6E13);
	MakeName	(0X6E13,	"getchr");
	MakeCode	(x=0X6E14);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X6E1A);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X6E21);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X6E25);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X6E2C);
	MakeComm	(0X6E2F,	"'incorrect_order' is not used in \nMSDOS 6.21 IO.SYS and PCDOS 7.1 IBMBIO.COM\n(but it was/is not removed)\nErdogan Tan - 11/07/2023");
	MakeCode	(x=0X6E2F);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeName	(0X6E2F,	"incorrect_order");
	MakeCode	(0X6E39);
	MakeName	(0X6E39,	"error_line");
	MakeCode	(x=0X6E3B);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X6E45);
	MakeName	(0X6E45,	"showlinenum");
	MakeComm	(0X6E4C,	"\ndi -> the least significant decimal field.");
	MakeCode	(x=0X6E4C);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X6E4F);
	OpDecimal	(x,	1);
	MakeComm	(0X6E56,	"< 10 ?");
	MakeCode	(x=0X6E56);
	OpDecimal	(x,	1);
	MakeComm	(0X6E59,	"yes");
	MakeComm	(0X6E5D,	"cx = 10");
	MakeComm	(0X6E5F,	"convert to ascii numeric char (\"0\" to \"9\")");
	MakeCode	(x=0X6E5F);
	OpHex		(x,	1);
	MakeComm	(0X6E67,	"convert to ascii numeric char (\"0\" to \"9\")");
	MakeCode	(x=0X6E67);
	OpHex		(x,	1);
	MakeComm	(0X6E6D,	"show it");
	MakeCode	(0X6E74);
	MakeName	(0X6E74,	"ProcDOS");
	MakeComm	(0X6E76,	"\n[cs:result_val+_$P_Result_Blk.Item_Tag]\n\nresult_val._$P_item_tag\n         = 1 for DOS=HIGH\n         = 2 for DOS=LOW\n         = 3 for DOS=UMB\n         = 4 for DOS=NOUMB");
	MakeCode	(0X6E8A);
	MakeCode	(0X6E91);
	MakeCode	(0X6E98);
	MakeComm	(0X6E9F,	"lie INT 12h as alloclim\nassuming that it is 3Com");
	MakeCode	(0X6E9F);
	MakeName	(0X6E9F,	"LieInt12Mem");
	MakeComm	(0X6EA3,	"Is it 3Com driver?");
	MakeComm	(0X6EA6,	"yes, lie to him differently");
	MakeComm	(0X6EA8,	"Is the DD being loaded in UMB");
	MakeComm	(0X6EAE,	"no, don't lie");
	MakeComm	(0X6EB0,	"lie INT 12h as end of UMB");
	MakeCode	(0X6EB8);
	MakeName	(0X6EB8,	"SetInt12Mem");
	MakeComm	(0X6EB9,	"ROMBIOS data area segment");
	MakeCode	(x=0X6EB9);
	OpHex		(x,	1);
	MakeComm	(0X6EBE,	"memory size (KB)");
	MakeComm	(0X6EC7,	"16*64 = 1024");
	MakeComm	(0X6EC9,	"convert paragraphs to kilobyte");
	MakeComm	(0X6ECE,	"mark that we are lying");
	MakeComm	(0X6ED6,	"were we lying so far?");
	MakeCode	(0X6ED6);
	MakeName	(0X6ED6,	"TrueInt12Mem");
	MakeComm	(0X6EE2,	"yes\nno, we weren't");
	MakeCode	(x=0X6EE5);
	OpHex		(x,	1);
	MakeComm	(0X6EEE,	"restore INT 12h memory");
	MakeCode	(0X6EF3);
	MakeName	(0X6EF3,	"IsIt3Com");
	MakeComm	(0X6EF6,	"ptr to device header");
	MakeComm	(0X6EFB,	"SYSDEV.NAME ; ptr device name");
	MakeCode	(x=0X6EFB);
	OpDecimal	(x,	1);
	MakeCode	(x=0X6F00);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6F03,	"name length");
	MakeCode	(0X6F0C);
	MakeName	(0X6F0C,	"UpdatePDB");
	MakeCode	(x=0X6F0D);
	OpHex		(x,	1);
	MakeComm	(0X6F0F,	"DOS - 3+ - GET PSP ADDRESS");
	MakeCode	(x=0X6F0F);
	OpHex		(x,	0);
	MakeComm	(0X6F18,	"[PDB.BLOCK_LEN]");
	MakeCode	(0X6F1E);
	MakeName	(0X6F1E,	"InitVar");
	MakeComm	(0X6F24,	"0");
	MakeComm	(0X6F26,	"Shrink UMBs? (made 1 if /S given)");
	MakeComm	(0X6F2A,	"Set to 1 when DH/LH has been called");
	MakeComm	(0X6F2E,	"Load Address (seg), used for DH only");
	MakeComm	(0X6F32,	"UNSPECIFIED\nLater is the # of the 1st spec'd UMB");
	MakeComm	(0X6F38,	"Start with zero args having been read");
	MakeComm	(0X6F3D,	"MAXUMB");
	MakeCode	(x=0X6F3D);
	OpDecimal	(x,	1);
	MakeComm	(0X6F40,	"\nFor each entry on the UmbUsed array,");
	MakeCode	(x=0X6F40);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6F43,	"Store 0");
	MakeComm	(0X6F45,	"MAXUMB");
	MakeCode	(x=0X6F45);
	OpDecimal	(x,	1);
	MakeComm	(0X6F48,	"Okay... \nfor each entry on the UmbSize array,");
	MakeCode	(x=0X6F48);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X6F4B,	"Store 0");
	MakeComm	(0X6F52,	"scans the upper memory chain \nand concatenates adjacent free MCBs");
	MakeCode	(0X6F52);
	MakeName	(0X6F52,	"FixMem");
	MakeComm	(0X6F57,	"Link in UMBs");
	MakeComm	(0X6F5A,	"Get first upper-memory MCB address (0x9FFF)");
	MakeComm	(0X6F5D,	"(if couldn't get it, leave now).");
	MakeComm	(0X6F5F,	"It returns in AX, so move it to ES.");
	MakeComm	(0X6F61,	"We're keeping the address of the last MCB");
	MakeComm	(0X6F63,	"in CX... and the last owner");
	MakeComm	(0X6F65,	"in dx as we go through the loop");
	MakeComm	(0X6F66,	"[es:ARENA.SIGNATURE]\nif 'Z', don't repeat loop");
	MakeComm	(0X6F6A,	"[es:ARENA.OWNER] ; if not zero, do nothing");
	MakeComm	(0X6F6F,	"dx was owner of previous MCB");
	MakeComm	(0X6F71,	"If not both zero, don't cat.");
	MakeComm	(0X6F73,	"[es:ARENA.SIZE]\nGrab this block's Size,");
	MakeName	(0X6F73,	"fm20");
	MakeComm	(0X6F78,	"Go back to prev MCB's address");
	MakeComm	(0X6F7A,	"[es:ARENA.SIGNATURE]\n& move the SECOND sig here");
	MakeCode	(x=0X6F7A);
	MakeComm	(0X6F7E,	"[es:ARENA.SIZE] \nSize += first MCB's size");
	MakeCode	(x=0X6F7E);
	MakeComm	(0X6F83,	"And add one for the header");
	MakeComm	(0X6F86,	"[es:ARENA.SIZE] ; Write the size");
	MakeCode	(x=0X6F86);
	MakeComm	(0X6F8B,	"Save MCB address");
	MakeComm	(0X6F8D,	"[es:ARENA.OWNER] ; And remember its owner");
	MakeCode	(x=0X6F8D);
	MakeComm	(0X6F92,	"Move to the next MCB");
	MakeComm	(0X6F9C,	"arena_signature_end");
	MakeComm	(0X6F9E,	"If signature != 'Z', there are more.");
	MakeComm	(0X6FA0,	"Unlink UMBs");
	MakeComm	(0X6FA9,	"DOS_CHECK_UMBLINK");
	MakeCode	(x=0X6FA9);
	OpHex		(x,	1);
	MakeName	(0X6FA9,	"fm_link");
	MakeComm	(0X6FAC,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) get UMB link state");
	MakeCode	(x=0X6FAC);
	OpHex		(x,	0);
	MakeComm	(0X6FB1,	"store current link-state (to use/set later)");
	MakeComm	(0X6FBC,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) set UMB link state");
	MakeCode	(x=0X6FBC);
	OpHex		(x,	0);
	MakeCode	(0X6FBF);
	MakeName	(0X6FBF,	"fm_unlink");
	MakeComm	(0X6FC4,	"old link-state (to set again)");
	MakeComm	(0X6FC9,	"DOS_SET_UMBLINK");
	MakeCode	(x=0X6FC9);
	OpHex		(x,	1);
	MakeComm	(0X6FCC,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) set UMB link state");
	MakeCode	(x=0X6FCC);
	OpHex		(x,	0);
	MakeComm	(0X6FCF,	"parses [/S][/L:umb[,size][;umb[,size]]*] \n  and builds the table laid out in highvar.inc\nENTRY: \n  ES:SI points to command tail of LoadHigh/DeviceHigh\n      (whitespace ok)\nEXIT:\n  ES:SI points to first character in child program name");
	MakeCode	(0X6FCF);
	MakeName	(0X6FCF,	"ParseVar");
	MakeComm	(0X6FD2,	"Make DS:SI point to it, as well as ES:SI");
	MakeComm	(0X6FD3,	"(regardless if we're in devhigh or loadhigh)");
	MakeComm	(0X6FD5,	"here, ES:SI==\"  /L...\"--must eat whitespace");
	MakeComm	(0X6FD9,	"ES:SI==\" /L...\"--keep eating.");
	MakeComm	(0X6FDB,	"SWTCH ; ES:SI==\"/L...\"--go process a switch");
	MakeComm	(0X6FDF,	"Backup--it's now \"odule options\", and we need");
	MakeComm	(0X6FE0,	"that \"m\" we just read (or whatever it is).");
	MakeComm	(0X6FE1,	"Then return with carry clear == we're done.");
	MakeComm	(0X6FE3,	"Just read 'S' or 'L', hopefully");
	MakeCode	(0X6FE3);
	MakeComm	(0X6FE4,	"So we make it upper-case, and...");
	MakeCode	(x=0X6FE4);
	OpHex		(x,	1);
	MakeComm	(0X6FE6,	"just read 'S'?");
	MakeComm	(0X6FEA,	"If it's /S, it's another arg for LH to skip.\n\nNote: 'inc byte [cs:fm_argc]' would be enough here\nErdogan Tan - 19/04/2019 (Retro DOS v4) - 11/07/2023");
	MakeComm	(0X6FF0,	"/S, so ES:SI==\"  /L...\" or \" module opts\", or");
	MakeComm	(0X6FF7,	"possibly even \"/L...\".");
	MakeComm	(0X6FF9,	"If it's not 'L' either, then it's a bad switch!");
	MakeCode	(0X6FF9);
	MakeComm	(0X7000,	"If no carry, go back and look for more");
	MakeComm	(0X7005,	"Else, back up and exit.");
	MakeComm	(0X7006,	"AX has already been set by parseL");
	MakeComm	(0X7008,	"PV_InvSwt ; Unrecognized switch passed");
	MakeCode	(0X7008);
	MakeCode	(0X7012);
	MakeName	(0X7012,	"parseL");
	MakeComm	(0X7013,	"Make sure they did /L:");
	MakeComm	(0X7015,	"If they didn't, return with carry set.");
	MakeComm	(0X7017,	"After this, it's \",size\" or \";umb\" or \" mod\"");
	MakeComm	(0X701A,	"And error if it's a bad number.");
	MakeComm	(0X701C,	"Convert any address to a UMB number");
	MakeComm	(0X701F,	"Remember the UMB number");
	MakeComm	(0X7021,	"Mark this UMB # as used;");
	MakeComm	(0X7024,	"If it was already marked, it'll error");
	MakeComm	(0X7026,	"Each UMB number is another arg for LH to skip\n('inc byte [cs:fm_argc]' would be enough)\nErdogan Tan - 08/04/2019 (Retro DOS v4) - 11/07/2023");
	MakeComm	(0X702A,	"Did \"umb;\" ?");
	MakeComm	(0X702C,	"Yep: go back and get another UMB.");
	MakeComm	(0X702E,	"Did \"umb \" ?");
	MakeComm	(0X7031,	"Yep: return (it'll go back to whitespace)");
	MakeComm	(0X7033,	"Did \"umb\" ?");
	MakeComm	(0X7036,	"If so, backup and exit like everything's ok");
	MakeComm	(0X7038,	"Did \"umb/\" ? (as in, \"/L:1,100;2/S\")");
	MakeComm	(0X703A,	"If so, back up ES:SI one character and return");
	MakeComm	(0X703C,	"Did \"umb,\" ?");
	MakeComm	(0X703E,	"Just what the heck DID they do? Return error.");
	MakeComm	(0X7040,	"Stop on \"size;\" or \"size \" or anything else");
	MakeComm	(0X7043,	"And error if it's a bad size.");
	MakeComm	(0X7045,	"Convert from bytes to paragraphs");
	MakeComm	(0X7048,	"CL still has the UMB number for this routine");
	MakeComm	(0X704B,	"Each UMB size is another arg for LH to skip\n('inc byte [cs:fm_argc]')");
	MakeComm	(0X704F,	"They did \"umb,size;\", so get another UMB.");
	MakeComm	(0X7053,	"Did it end with whitespace?");
	MakeComm	(0X7056,	"If so, we're done here--go back.");
	MakeComm	(0X7058,	"Did they do \"umb,size\" and end??? (stupid)");
	MakeComm	(0X705B,	"If so, backup and exit like everything's ok");
	MakeComm	(0X705D,	"SWTCH ; Did they do \"umb,size/\" ?");
	MakeComm	(0X705F,	"If so, again, we're done here.");
	MakeComm	(0X7061,	"PV_InvArg ; If not, we don't know WHAT they did.");
	MakeComm	(0X7067,	"In this case, they've specified a UMB twice");
	MakeCode	(0X7067);
	MakeComm	(0X706C,	"If we hit a '/' character, back up one char\nso the whitespace checker will see it too.");
	MakeCode	(0X706C);
	MakeComm	(0X706D,	"Then just return with carry clear, so\nParseVar will go about its business.");
	MakeComm	(0X706F,	"increments fm_argc,\nfor use with LoadHigh command-line parsing\n***\n('inc byte [cs:fm_argc]' would be enough)\nErdogan Tan - 11/07/2023");
	MakeCode	(0X706F);
	MakeName	(0X706F,	"incArgc");
	MakeComm	(0X7073,	"Obtain previous value of fm_argc,");
	MakeComm	(0X7077,	"Increment it,");
	MakeComm	(0X707C,	"And store it right back.");
	MakeComm	(0X7083,	"Null-terminator");
	MakeCode	(0X7083);
	MakeName	(0X7083,	"isEOL");
	MakeComm	(0X7087,	"CR ; Carriage Return");
	MakeComm	(0X708B,	"LF ; LineFeed");
	MakeComm	(0X708D,	"zf=1 if AL contains EOL character");
	MakeComm	(0X708E,	"Space");
	MakeCode	(0X708E);
	MakeName	(0X708E,	"isWhite");
	MakeComm	(0X7092,	"Equals (treat as whitespace)");
	MakeComm	(0X7096,	"Tab");
	MakeComm	(0X7098,	"zf=1 if AL contains space,\n        tab or equals character");
	MakeComm	(0X7099,	"marks a given UMB as unused\nAL contains UMB number");
	MakeCode	(0X7099);
	MakeName	(0X7099,	"unMarkUMB");
	MakeCode	(x=0X70A3);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X70AE,	"If unmarked the load UMB,\nload into convent.");
	MakeComm	(0X70BB,	"MAXUMB");
	MakeCode	(x=0X70BB);
	OpDecimal	(x,	1);
	MakeName	(0X70BB,	"stowUMB");
	MakeComm	(0X70BF,	"Ooops-- UMB # >= MAXUMB");
	MakeCode	(0X70C1);
	MakeComm	(0X70CA,	"UNSPECIFIED\nIf this, we haven't been here before");
	MakeComm	(0X70D1,	"So remember this UMB as the load UMB slot.");
	MakeComm	(0X70D4,	"If they gave UMB 0, there's really nothing");
	MakeComm	(0X70D6,	"that we should do here.");
	MakeComm	(0X70DC,	"Now, AX = 1, and BX = UMB Number");
	MakeCode	(x=0X70DF);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X70E4,	"If it was already 1,\nthen al==1... and that means an error.");
	MakeComm	(0X70E8,	"OOOPS! This one's been used before. :(");
	MakeCode	(0X70EF);
	MakeName	(0X70EF,	"stowSiz");
	MakeComm	(0X70F4,	"Now bl==UMB number, AX==size");
	MakeComm	(0X70F6,	"bx==UMB number, AX==size");
	MakeComm	(0X70F8,	"bx==offset into array, AX=size");
	MakeCode	(x=0X70F8);
	OpHex		(x,	1);
	MakeComm	(0X70FA,	"Store the size");
	MakeCode	(x=0X70FA);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X7103,	"Must be a word--16x16 multiplication");
	MakeWord	(0X7103);
	MakeName	(0X7103,	"gnradix");
	MakeCode	(0X7105);
	MakeName	(0X7105,	"toDigit");
	MakeComm	(0X710B,	"Don't check hex digits if radix isn't 16");
	MakeComm	(0X7115,	"Nothing valid above 'f' at all...");
	MakeComm	(0X7117,	"'a'-10 ; 87 ; Make 'a'==10 and return.");
	MakeCode	(x=0X7117);
	OpHex		(x,	1);
	MakeComm	(0X711B,	"Below 'A'? Not a letter...");
	MakeCode	(0X711B);
	MakeComm	(0X7120,	"Above 'F'? Not a digit.");
	MakeComm	(0X7125,	"'A'-10 ; 55 ; Make 'A'==10 and return.");
	MakeCode	(x=0X7125);
	OpHex		(x,	1);
	MakeComm	(0X7129,	"If less than zero,");
	MakeCode	(0X7129);
	MakeComm	(0X712C,	"Done.");
	MakeComm	(0X712E,	"Or, if greater than nine,");
	MakeComm	(0X7131,	"Done.");
	MakeComm	(0X7133,	"Okay--make '0'==0 and return.");
	MakeCode	(0X7137);
	MakeComm	(0X7139,	"reads a 32-bit ASCII number at ES:SI\nand returns it in DX:AX");
	MakeCode	(0X7139);
	MakeName	(0X7139,	"GetXNum");
	MakeComm	(0X7143,	"Start with 0 (makes sense)");
	MakeComm	(0X7145,	"And default to a radix of 10 (dec)");
	MakeComm	(0X7152,	"If it's not a digit, leave now.");
	MakeComm	(0X7156,	"Doesn't have '0x'");
	MakeComm	(0X715C,	"Either 'x'...");
	MakeCode	(x=0X715C);
	OpChr		(x,	1);
	MakeCode	(x=0X7161);
	OpChr		(x,	1);
	MakeCode	(x=0X7166);
	OpDecimal	(x,	1);
	MakeComm	(0X716D,	"Since we read \"0x\", march over it.");
	MakeComm	(0X716F,	"Now DX:AX=current total, CH=0/CL=char");
	MakeComm	(0X7173,	" Accepts only valid digits, A-F -> 10-16");
	MakeComm	(0X7176,	"<- Ah... wasn't a digit. Stop.");
	MakeCode	(0X7185);
	MakeCode	(0X7188);
	MakeComm	(0X718E,	"multiplies the number in DX:AX by gnradix\nDX=old:hi, AX=old:lo, TOS=old:lo, BX=0");
	MakeCode	(0X718E);
	MakeName	(0X718E,	"mul32");
	MakeComm	(0X7191,	"DX=?, AX=new:hi, TOS=old:lo, BX=0");
	MakeComm	(0X7196,	"Too big?");
	MakeComm	(0X7198,	"DX=new:hi, AX=new:hi, TOS=old:lo, BX=0");
	MakeComm	(0X719A,	"DX=new:hi, AX=old:lo, TOS=orig, BX=0");
	MakeComm	(0X719B,	"DX=0, AX=old:lo, TOS=orig, BX=new:hi");
	MakeComm	(0X719D,	"DX=carry, AX=new:lo, TOS=orig, BX=new:hi");
	MakeComm	(0X71A4,	"DX=new:hi, AX=new:lo, TOS=orig, BX=carry");
	MakeComm	(0X71A6,	"BX=0");
	MakeCode	(0X71A9);
	MakeComm	(0X71AB,	"divides DX:AX by 16; result in AX only");
	MakeCode	(0X71AB);
	MakeName	(0X71AB,	"toPara");
	MakeComm	(0X71AC,	"DX:AX=HHHH hhhh hhhh hhhh:LLLL llll llll llll");
	MakeComm	(0X71AE,	"DX:AX=HHHH hhhh hhhh hhhh:0000 LLLL llll llll");
	MakeComm	(0X71B0,	"DX:AX=0000 LLLL llll llll:HHHH hhhh hhhh hhhh");
	MakeCode	(x=0X71B1);
	OpDecimal	(x,	1);
	MakeComm	(0X71B3,	"DX:AX=0000 LLLL llll llll:hhhh 0000 0000 0000");
	MakeComm	(0X71B5,	"AX=hhhh LLLL llll llll");
	MakeCode	(0X71B9);
	MakeName	(0X71B9,	"UmbHead");
	MakeComm	(0X71BC,	"GET_IN_VARS");
	MakeCode	(x=0X71BC);
	OpHex		(x,	1);
	MakeComm	(0X71BE,	"DOS - 2+ internal - GET LIST OF LISTS\nReturn: ES:BX -> DOS list of lists");
	MakeCode	(x=0X71BE);
	OpHex		(x,	0);
	MakeComm	(0X71C0,	"[es:DOS_UMB_HEAD]");
	MakeCode	(0X71CC);
	MakeComm	(0X71D1,	"sets ZF if ES points to an MCB owned by \"SC\"");
	MakeCode	(0X71D1);
	MakeName	(0X71D1,	"isSysMCB");
	MakeComm	(0X71D2,	"[es:ARENA.OWNER]");
	MakeComm	(0X71D6,	"SystemPSPOwner ; 8 (for US or Japan) is valid");
	MakeComm	(0X71DB,	"JapanPSPOwner ; 9 (for Japan) is valid");
	MakeComm	(0X71E2,	"[es:ARENA.NAME]");
	MakeCode	(0X71E2);
	MakeComm	(0X71E6,	"'SC'");
	MakeComm	(0X71EB,	"converts a segment address in AX\nto its appropriate UMB number");
	MakeCode	(0X71EB);
	MakeName	(0X71EB,	"AddrToUmb");
	MakeComm	(0X71EE,	"DX = address to search for");
	MakeComm	(0X71F0,	"AX = first segment");
	MakeComm	(0X71F3,	"If it couldn't get it, error out");
	MakeComm	(0X71F7,	"0");
	MakeComm	(0X71FB,	"Present segment >= given segment?");
	MakeComm	(0X71FD,	"yes, done.");
	MakeComm	(0X71FF,	"Returns with ZF set if this is a system MCB");
	MakeComm	(0X7204,	"If it _was_ a system MCB, we're in a new UMB.");
	MakeComm	(0X7205,	"[es:ARENA.SIGNATURE]");
	MakeComm	(0X720B,	"'Z' means this was the last MCB... that's it.");
	MakeComm	(0X720F,	"[es:ARENA.SIZE]");
	MakeCode	(0X7219);
	MakeComm	(0X721B,	"[es:ARENA.SIZE]");
	MakeComm	(0X7220,	"Present >= given?");
	MakeComm	(0X7222,	"Yep! It _was_ inside.");
	MakeComm	(0X7226,	"Address is above UM Range,\nAX will return as 0FFFFh.");
	MakeComm	(0X7227,	"Return the UMB number in AX (0==conv)");
	MakeComm	(0X722D,	"convert address to UMB number after GetXNum\n(GetXNum has read a hex number)");
	MakeCode	(0X722D);
	MakeName	(0X722D,	"convUMB");
	MakeComm	(0X7233,	"GetXNum didn't read in hex, it is not an addr");
	MakeComm	(0X7235,	"convert the address to a UMB number");
	MakeComm	(0X723D,	"If too high, ignore it (make it conventional)");
	MakeCode	(0X723F);
	MakeName	(0X723F,	"setUMBs");
	MakeComm	(0X7247,	"loadLow subroutine is not used\nanywhere of MSDOS 6.21 (& 5.0) IO.SYS\nErdogan Tan - 18/07/2023");
	MakeCode	(0X7247);
	MakeName	(0X7247,	"loadLow");
	MakeComm	(0X724D,	"UNSPECIFIED ; -1");
	MakeCode	(0X7256);
	MakeName	(0X7256,	"ll10");
	MakeName	(0X725D,	"llx");
	MakeComm	(0X725F,	"links UMBs and hides upper-memory as appropriate");
	MakeCode	(0X725F);
	MakeName	(0X725F,	"HideUMBs");
	MakeComm	(0X7263,	"cf=0 if UMBs are available");
	MakeComm	(0X7266,	"there is nothing to do.");
	MakeComm	(0X7268,	"Concatenate adjacent free MCBs in upper mem");
	MakeComm	(0X726B,	"Link UMBs and set memory-allocation strategy");
	MakeComm	(0X7271,	"Remember that we're now running high");
	MakeComm	(0X7278,	"See if they gave us a list to leave free");
	MakeComm	(0X727B,	"UNSPECIFIED ; If they didn't,");
	MakeComm	(0X727F,	"0");
	MakeComm	(0X7281,	"+1 for each UMB");
	MakeComm	(0X7282,	"MAXUMB");
	MakeCode	(x=0X7282);
	OpDecimal	(x,	1);
	MakeComm	(0X728A,	"ES:0 points to first MCB in UMB\nCarry set if couldn't reach UMB");
	MakeComm	(0X728E,	"outside of the valid range of UMBs");
	MakeComm	(0X7290,	"hide what we need to hide.");
	MakeComm	(0X7295,	"mov al,[cs:UmbLoad]");
	MakeCode	(0X7295);
	MakeComm	(0X7298,	"or byte [cs:UmbLoad],0\nIs the load UMB 0? (-1==unspecified)");
	MakeComm	(0X729A,	"no, done.");
	MakeComm	(0X729C,	"fix UMBs and strategy.");
	MakeComm	(0X72A4,	"Instead of calling this subroutine\n\"or byte [cs:UmbLoad],0\" then \"jz/jnz ..\"\nwould be enough. Erdogan Tan - 18/07/2023");
	MakeCode	(0X72A4);
	MakeName	(0X72A4,	"GetLoadUMB");
	MakeCode	(0X72AC);
	MakeName	(0X72AC,	"GetLoadSize");
	MakeComm	(0X72B6,	"array");
	MakeCode	(x=0X72B6);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X72B9);
	OpHex		(x,	1);
	MakeComm	(0X72BF,	"ax==size");
	MakeComm	(0X72C4,	"Returns the UMB in AL's minimum size\n (0 if not specified)");
	MakeCode	(0X72C4);
	MakeName	(0X72C4,	"GetSize");
	MakeComm	(0X72CB,	"array");
	MakeCode	(x=0X72CB);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X72CE);
	OpHex		(x,	1);
	MakeComm	(0X72D4,	"ax==size");
	MakeComm	(0X72D9,	"StoLoadUMB subroutine is not used\nanywhere of MSDOS 6.21 (& 5.0) IO.SYS\nErdogan Tan - 18/07/2023");
	MakeCode	(0X72D9);
	MakeName	(0X72D9,	"StoLoadUMB");
	MakeComm	(0X72DC,	"Overrides the load UMB number with what's in AL");
	MakeComm	(0X72E2,	"Overrides the load UMB min. size with what's in AX");
	MakeCode	(0X72E2);
	MakeName	(0X72E2,	"StoLoadSize");
	MakeComm	(0X72E6,	"Put UMB# in DL\n\nBUG ! CL would be used here instead of DL (*)\n18/07/2023");
	MakeComm	(0X72EB,	"UNSPECIFIED");
	MakeComm	(0X72F0,	"We've got a function to do just this\n\nBUG ! stowSiz uses CL instead of DL !\n(CL is set in ParseL which calls stowSiz)\n(This BUG existing in PCDOS 7.1 IBMBIO.COM also)\nErdogan Tan - 18/07/2023");
	MakeComm	(0X72F5,	"marks as HIDDEN all FREE elements in UMB passed as AL");
	MakeCode	(0X72F5);
	MakeName	(0X72F5,	"hideUMB");
	MakeComm	(0X72F7,	"Returns with carry if err, else ES == MCB");
	MakeComm	(0X72FC,	"Returns with ZF set if owner is SYSTEM");
	MakeComm	(0X7301,	"or word [es:ARENA.OWNER],0");
	MakeComm	(0X7309,	"[es:ARENA.SIGNATURE]");
	MakeComm	(0X730D,	"cmp byte [es:ARENA.SIGNATURE],arena_signature_end");
	MakeComm	(0X7311,	"Go on forward.");
	MakeComm	(0X7313,	"[es:ARENA.SIZE]");
	MakeCode	(0X731D);
	MakeComm	(0X7320,	"returns with ZF set if user didn't specify /S");
	MakeCode	(0X7320);
	MakeName	(0X7320,	"isTiny");
	MakeComm	(0X732C,	"or word [es:ARENA.OWNER],0");
	MakeCode	(x=0X732C);
	OpHex		(x,	1);
	MakeName	(0X732C,	"isFreeMCB");
	MakeComm	(0X7333,	"marks as HIDDEN the MCB at ES:0");
	MakeCode	(0X7333);
	MakeName	(0X7333,	"hideMCB");
	MakeComm	(0X733A,	"'HI'");
	MakeComm	(0X7341,	"'DD'");
	MakeComm	(0X7348,	"'EN'");
	MakeComm	(0X734F,	"'  '");
	MakeComm	(0X7357,	"marks as FREE the MCB at ES:0");
	MakeCode	(0X7357);
	MakeName	(0X7357,	"unHideMCB");
	MakeComm	(0X7358,	"[es:ARENA.OWNER],FreePSPOwner");
	MakeComm	(0X735F,	"'  '");
	MakeComm	(0X7362,	"[es:ARENA.NAME+0]");
	MakeComm	(0X7366,	"[es:ARENA.NAME+2]");
	MakeComm	(0X736A,	"[es:ARENA.NAME+4]");
	MakeComm	(0X736E,	"[es:ARENA.NAME+6]");
	MakeComm	(0X7374,	"makes ES:0 point to the first MCB in UMB given as AL");
	MakeCode	(0X7374);
	MakeName	(0X7374,	"findUMB");
	MakeComm	(0X7379,	"Store the to-be-found UMB number in DX");
	MakeComm	(0X737B,	"Returns first UMB segment in AX");
	MakeComm	(0X7380,	"Pretend we're on UMB 0 for now...");
	MakeComm	(0X7382,	"If CX==DX, the UMB is found");
	MakeComm	(0X7386,	"Returns with ZF set if owner is SYSTEM");
	MakeComm	(0X7390,	"cmp byte [es:ARENA.SIGNATURE],arena_signature_end");
	MakeComm	(0X7392,	"'Z' means this was the last MCB");
	MakeComm	(0X7394,	"Go on forward.");
	MakeComm	(0X7396,	"[es:ARENA.SIZE]");
	MakeCode	(0X73A0);
	MakeComm	(0X73A3,	"The address is already in ES.");
	MakeComm	(0X73A5,	"makes ES:0 point to the largest free MCB\nin UMB given as AL");
	MakeCode	(0X73A5);
	MakeName	(0X73A5,	"BigFree");
	MakeComm	(0X73A7,	"Returns with CF if err, else ES==MCB");
	MakeComm	(0X73AC,	"Segment address of largest free MCB");
	MakeComm	(0X73AE,	"Size of largest free MCB");
	MakeComm	(0X73B0,	"If we've left the MCB, we're done.");
	MakeComm	(0X73B5,	"or word [es:ARENA.OWNER],0");
	MakeComm	(0X73BA,	"[es:ARENA.SIZE] ; Compare sizes..");
	MakeComm	(0X73C1,	"Unless we're bigger,");
	MakeComm	(0X73C3,	"Store this new element's addr and size.");
	MakeComm	(0X73CC,	"[es:ARENA.SIGNATURE],arena_signature_end");
	MakeComm	(0X73D0,	"NextMCB es,ax ; (macro) ; Go on forward.");
	MakeComm	(0X73D2,	"es:ARENA.SIZE]");
	MakeComm	(0X73DC,	"Return the address");
	MakeCode	(0X73DC);
	MakeComm	(0X73DE,	"Return the size");
	MakeComm	(0X73E4,	"(if size==0, there's nothing free)");
	MakeComm	(0X73E8,	"sets ZF if UMB in AL wasn't specified in DH/LH line.");
	MakeCode	(0X73E8);
	MakeName	(0X73E8,	"isSpecified");
	MakeCode	(x=0X73F0);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X73F5,	"ets ZF if al==0 (ie, if unspecified)");
	MakeComm	(0X73F9,	"breaks an MCB into two pieces, the lowest one's size==AX\nAX == new size, ES:0 == current MCB");
	MakeCode	(0X73F9);
	MakeName	(0X73F9,	"shrinkMCB");
	MakeComm	(0X73FC,	"requested size (lowest one)");
	MakeComm	(0X7400,	"[es:ARENA.SIZE]");
	MakeComm	(0X7405,	"MIN_SPLIT_SIZE = 32");
	MakeCode	(x=0X7405);
	OpDecimal	(x,	1);
	MakeComm	(0X7408,	"{New size} vs {Current Size-20h}");
	MakeComm	(0X740A,	"if wanted_size > cur-20h, abort.");
	MakeComm	(0X740C,	"[es:ARENA.SIGNATURE]");
	MakeComm	(0X7416,	"[es:ARENA.SIZE]");
	MakeComm	(0X741B,	"[es:ARENA.SIGNATURE],'M'");
	MakeComm	(0X7424,	"Move to new arena area");
	MakeComm	(0X742A,	"And prepare the new size");
	MakeComm	(0X742B,	"[es:ARENA.SIGNATURE],dl");
	MakeComm	(0X7430,	"[es:ARENA.OWNER]");
	MakeComm	(0X7437,	"[es:ARENA.SIZE]");
	MakeComm	(0X743B,	"'  '");
	MakeComm	(0X743E,	"[es:ARENA.NAME+0]");
	MakeComm	(0X7442,	"[es:ARENA.NAME+2]");
	MakeComm	(0X7446,	"[es:ARENA.NAME+4]");
	MakeComm	(0X744A,	"[es:ARENA.NAME+6]");
	MakeCode	(0X7451);
	MakeComm	(0X7456,	"hides as appropriate the UMB in CL");
	MakeCode	(0X7456);
	MakeName	(0X7456,	"_hideUMB_");
	MakeComm	(0X745B,	"Returns ZF set if al's umb was NOT specified");
	MakeComm	(0X7462,	"Retrieve the size of the largest free element\nin AX, put its address in ES.");
	MakeComm	(0X7467,	"TOS==size of BigFree in UMB");
	MakeComm	(0X7468,	"Retrieve the user's specified");
	MakeComm	(0X746A,	"minimum size for this umb (into AX)");
	MakeComm	(0X746D,	"BX==BigFree, AX==Specified Size");
	MakeComm	(0X746E,	"If they didn't specify one,\nskip over all this.");
	MakeComm	(0X7472,	"if (specified > max free)");
	MakeComm	(0X7476,	"then mark that UMB as unused.");
	MakeComm	(0X747D,	"or byte [cs:fUmbTiny],0");
	MakeCode	(0X747D);
	MakeComm	(0X7482,	"They specified /S, so shrink the MCB to AX");
	MakeComm	(0X7489,	"Skip the spec check.. we wanna hide this one.");
	MakeCode	(0X748B);
	MakeComm	(0X748D,	"If they specified this UMB, we're done.");
	MakeComm	(0X7490,	"so leave.");
	MakeComm	(0X7492,	"0");
	MakeComm	(0X7496,	"Hides everything in UMB #al");
	MakeComm	(0X7499,	"Did we shrink a UMB? If not, DX==0,");
	MakeComm	(0X749B,	"So we should leave.");
	MakeComm	(0X749D,	"Ah, but if it isn't, DX==the MCB's address;");
	MakeComm	(0X749F,	"Un-hides the lower portion of that MCB.");
	MakeComm	(0X74A6,	"Marks FROZEN elements as FREE");
	MakeCode	(0X74A6);
	MakeName	(0X74A6,	"UnFreeze");
	MakeComm	(0X74A8,	"Returns with carry if err, else ES == MCB");
	MakeComm	(0X74AF,	"Returns with ZF set if MCB is FROZEN");
	MakeComm	(0X74C1,	"[es:ARENA.SIZE]");
	MakeCode	(0X74CB);
	MakeCode	(0X74CE);
	MakeName	(0X74CE,	"isFrozMCB");
	MakeComm	(0X74CF,	"[es:ARENA.OWNER] ; Check the owner..");
	MakeComm	(0X74D3,	"8 (for US OR Japan) is valid");
	MakeComm	(0X74D8,	"[es:ARENA.NAME+0]");
	MakeComm	(0X74DC,	"'FR'");
	MakeComm	(0X74E1,	"[es:ARENA.NAME+2]");
	MakeComm	(0X74E5,	"'OZ'");
	MakeComm	(0X74EA,	"[es:ARENA.NAME+4]");
	MakeComm	(0X74EE,	"'EN'");
	MakeComm	(0X74F3,	"[es:ARENA.NAME+6]");
	MakeComm	(0X74F7,	"'  '");
	MakeComm	(0X74FC,	"marks as 8+FROZEN the MCB at ES:0\nmov word [es:ARENA.OWNER],SystemPSPOwner");
	MakeCode	(0X74FC);
	MakeName	(0X74FC,	"frezMCB");
	MakeComm	(0X7503,	"[es:ARENA.NAME+0],'FR'");
	MakeComm	(0X750A,	"[es:ARENA.NAME+2],'OZ'");
	MakeComm	(0X7511,	"[es:ARENA.NAME+4],'EN'");
	MakeComm	(0X7518,	"[es:ARENA.NAME+6],'  '");
	MakeComm	(0X7520,	"Marks FROZEN all UM elements now FREE,\nsave those in load UMB");
	MakeCode	(0X7520);
	MakeName	(0X7520,	"FreezeUM");
	MakeComm	(0X7524,	"mov al,[cs:UmbLoad]");
	MakeComm	(0X7527,	"0");
	MakeComm	(0X7529,	"Store the load UMB in DX, so we can skip it");
	MakeComm	(0X752B,	"Returns first UMB segment in AX");
	MakeComm	(0X7530,	"Pretend we're on UMB 0 for now..");
	MakeComm	(0X7532,	"Returns with ZF set if owner is SYSTEM");
	MakeComm	(0X7537,	"If it _was_ SYSTEM, we're in a new UMB.");
	MakeComm	(0X7538,	"DX - UMB number to skip (load UMB)\n\nIf this is the load UMB, we don't want to\nfreeze anything.. so skip that section.");
	MakeComm	(0X753C,	"or word [es:ARENA.OWNER],0\nIf it's not free, we can't freeze it");
	MakeComm	(0X7548,	"cmp byte [es:ARENA.SIGNATURE],arena_signature_end");
	MakeComm	(0X754C,	"NextMCB es, ax (macro) ; Go on forward.");
	MakeComm	(0X754E,	"[es:ARENA.SIZE]");
	MakeCode	(0X7558);
	MakeComm	(0X755D,	"returns with carry set if UMBs are not available,\n else CF==false");
	MakeCode	(0X755D);
	MakeName	(0X755D,	"UmbTest");
	MakeComm	(0X7561,	"Link in UMBs (if not already linked)");
	MakeComm	(0X7564,	"Check to see if they're really linked");
	MakeComm	(0X7567,	"And remember what we found out");
	MakeComm	(0X7568,	"Unlink UMBs (if we have linked 'em)");
	MakeComm	(0X756B,	"And restore what we found out.");
	MakeComm	(0X7571,	"WalkMem - travels memory chain and\nreturns carry clear if UMBs are linked");
	MakeCode	(0X7571);
	MakeName	(0X7571,	"WalkMem");
	MakeCode	(x=0X7574);
	OpHex		(x,	1);
	MakeComm	(0X7576,	"DOS - 2+ internal - GET LIST OF LISTS\nReturn: ES:BX -> DOS list of lists");
	MakeCode	(x=0X7576);
	OpHex		(x,	0);
	MakeComm	(0X757C,	"ES = Current MCB pointer");
	MakeComm	(0X7582,	"cmp byte [es:ARENA.SIGNATURE],arena_signature_end ; 'Z'");
	MakeComm	(0X7586,	"Move to the next MCB");
	MakeComm	(0X7588,	"[es:ARENA.SIZE]");
	MakeCode	(0X7592);
	MakeComm	(0X7594,	"This sets CF if ax < 9FFFh.");
	MakeComm	(0X759B,	"unlinks UMBs if fm_umb is set to 0;\n restores strategy too");
	MakeCode	(0X759B);
	MakeName	(0X759B,	"hl_unlink");
	MakeComm	(0X75A5,	"DOS_SET_UMBLINK");
	MakeCode	(x=0X75A5);
	OpHex		(x,	1);
	MakeComm	(0X75A8,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) set UMB link state");
	MakeCode	(x=0X75A8);
	OpHex		(x,	0);
	MakeComm	(0X75AB,	"Marks HIDDEN elements as FREE");
	MakeCode	(0X75AB);
	MakeName	(0X75AB,	"UnHideUMBs");
	MakeComm	(0X75AF,	"mov al,[cs:fInHigh]");
	MakeComm	(0X75B5,	"If didn't call loadhigh/devicehigh earlier,");
	MakeComm	(0X75B7,	"then there's nothing to do here.");
	MakeComm	(0X75BA,	"Make sure UMBs are linked in.");
	MakeCode	(0X75BA);
	MakeComm	(0X75C3,	"We're leaving, so update fInHigh.");
	MakeComm	(0X75CA,	"Unlink UMBs");
	MakeComm	(0X75D0,	"unlinks UMBs if fm_umb is set to 0");
	MakeCode	(0X75D0);
	MakeName	(0X75D0,	"he_unlink");
	MakeCode	(x=0X75DA);
	OpHex		(x,	1);
	MakeComm	(0X75DD,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) set UMB link state");
	MakeCode	(x=0X75DD);
	OpHex		(x,	0);
	MakeComm	(0X75E0,	"frees all HIDDEN memory elements in upper-memory");
	MakeCode	(0X75E0);
	MakeName	(0X75E0,	"FreeUMBs");
	MakeComm	(0X75E2,	"Returns with carry if err, else ES == MCB");
	MakeComm	(0X75E7,	"Prepare for the loop; ES = current MCB addr.");
	MakeComm	(0X75E9,	"Returns with ZF set if owner is 0");
	MakeComm	(0X75F5,	"cmp byte [es:ARENA.SIGNATURE],arena_signature_end");
	MakeComm	(0X75FB,	"[es:ARENA.SIZE]");
	MakeComm	(0X7603,	"Go on forward.");
	MakeCode	(0X7605);
	MakeComm	(0X7608,	"returns with ZF set if current MCB (ES:0) is HIDDEN");
	MakeCode	(0X7608);
	MakeName	(0X7608,	"isHideMCB");
	MakeComm	(0X7609,	"[es:ARENA.OWNER],SystemPSPOwner\nIf the owner's SYSTEM then check for HIDDEN");
	MakeComm	(0X7615,	"cmp word [es:ARENA.NAME+0],'HI'");
	MakeComm	(0X761E,	"cmp word [es:ARENA.NAME+2],'DD'");
	MakeComm	(0X7627,	"cmp word [es:ARENA.NAME+4],'EN'");
	MakeComm	(0X7630,	"[es:ARENA.NAME+4],'  '");
	MakeComm	(0X7635,	"marks as free the MCB at ES:0");
	MakeCode	(0X7635);
	MakeName	(0X7635,	"freeMCB");
	MakeComm	(0X763C,	"'  '");
	MakeComm	(0X763F,	"mov word [es:ARENA.NAME+0],'  '");
	MakeComm	(0X764B,	"[es:ARENA.NAME+6]");
	MakeComm	(0X7650,	"returns in AX the addr of the 1st UMB block (0x9FFF)");
	MakeCode	(0X7650);
	MakeName	(0X7650,	"HeadUmb");
	MakeCode	(x=0X7653);
	OpHex		(x,	1);
	MakeComm	(0X7655,	"DOS - 2+ internal - GET LIST OF LISTS\nReturn: ES:BX -> DOS list of lists");
	MakeCode	(x=0X7655);
	OpHex		(x,	0);
	MakeComm	(0X7657,	"[es:UMB_HeadIdx]");
	MakeComm	(0X765E,	"If it's 0xFFFF, it's an error...");
	MakeComm	(0X7660,	"AX contains 0x9FFF for most systems");
	MakeComm	(0X7663,	"error");
	MakeCode	(0X7663);
	MakeCode	(x=0X7668);
	OpHex		(x,	1);
	MakeName	(0X7668,	"linkumb");
	MakeComm	(0X766B,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) get UMB link state");
	MakeCode	(x=0X766B);
	OpHex		(x,	0);
	MakeComm	(0X7677,	"DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: (DOS 5beta) set UMB link state");
	MakeCode	(x=0X7677);
	OpHex		(x,	0);
	MakeComm	(0X767A,	"Are we loading in UMB ?");
	MakeCode	(0X767A);
	MakeName	(0X767A,	"InitDevLoad");
	MakeComm	(0X7680,	"no, init for lo mem");
	MakeComm	(0X7682,	"Are we loading as per Dos 5?");
	MakeComm	(0X768A,	"Stop using the old device arena");
	MakeComm	(0X768D,	"Mark up the UM area as we see fit");
	MakeComm	(0X7690,	"Hide everything BUT the load area");
	MakeComm	(0X7693,	"And grab that load area as needed");
	MakeComm	(0X7697,	"Then unhide everything frozen");
	MakeComm	(0X769B,	"(if carry, it's loading low)");
	MakeComm	(0X769F,	"Do we have space left in the current UMB ?");
	MakeCode	(0X769F);
	MakeComm	(0X76A2,	"yes, we have");
	MakeComm	(0X76A4,	"shrink the current UMB in use");
	MakeComm	(0X76A7,	"else try to allocate new UMB");
	MakeComm	(0X76AA,	"we didn't succeed, so load in low memory");
	MakeComm	(0X76AC,	"get Para addr of free mem");
	MakeComm	(0X76B0,	"UMB start addr");
	MakeComm	(0X76B5,	"dx = UMB End addr");
	MakeComm	(0X76BC,	"in case we failed to load into UMB\nindicate that we are loading low");
	MakeCode	(0X76BC);
	MakeComm	(0X76C2,	"start of Low memory");
	MakeComm	(0X76C6,	"end of Low memory");
	MakeComm	(0X76CB,	"setup a sub-arena for DD");
	MakeComm	(0X76CE,	"init the Device load address");
	MakeComm	(0X76D2,	"init the limit of the block");
	MakeComm	(0X76D7,	"init Entry point to DD");
	MakeCode	(0X76E3);
	MakeName	(0X76E3,	"SpaceInUMB");
	MakeComm	(0X76E7,	"End of UMB");
	MakeComm	(0X76EC,	"- Free = Remaining space");
	MakeComm	(0X76F1,	"Nospace ?");
	MakeComm	(0X76F7,	"space for sub-arena");
	MakeCode	(0X76F7);
	MakeComm	(0X76F8,	"do we have space ?");
	MakeCode	(0X76FE);
	MakeName	(0X76FE,	"PrepareMark");
	MakeComm	(0X7701,	"[ARENA.OWNER]");
	MakeComm	(0X7707,	"[ARENA.NAME],'SD'");
	MakeComm	(0X7717,	"update the UMB Variables");
	MakeCode	(0X771D);
	MakeName	(0X771D,	"GetUMBForDev");
	MakeCode	(x=0X7720);
	OpHex		(x,	1);
	MakeComm	(0X7723,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired");
	MakeCode	(x=0X7723);
	OpHex		(x,	0);
	MakeCode	(x=0X7732);
	OpHex		(x,	1);
	MakeComm	(0X7735,	"DOS - 2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired");
	MakeCode	(x=0X7735);
	OpHex		(x,	0);
	MakeComm	(0X773F,	"0");
	MakeCode	(0X773F);
	MakeComm	(0X7741,	"erase the previous values");
	MakeComm	(0X774F,	"Input : \nAX - Free segment were device is going to be loaded\nOutput :\nAX - Segment at which device can be loaded (AX=AX+1)\n\nCreates a sub-arena for the device driver\nputs 'D' marker in the sub-arena");
	MakeCode	(0X774F);
	MakeName	(0X774F,	"DevSetMark");
	MakeComm	(0X7755,	"[es:devmark.id],devmark_device ; 'D'");
	MakeComm	(0X775C,	"[es:devmark.seg]");
	MakeComm	(0X7760,	"save load address");
	MakeComm	(0X7761,	"command line is still there");
	MakeCode	(0X7772);
	MakeCode	(0X777A);
	MakeComm	(0X7780,	"devmark.filename ; 8");
	MakeComm	(0X7783,	"maximum 8 characters");
	MakeComm	(0X7796,	"blank out the rest");
	MakeComm	(0X7798,	"restore load address");
	MakeComm	(0X779E,	"Calculates the size of the device file in paras\nand stores it in DevSize");
	MakeCode	(0X779E);
	MakeName	(0X779E,	"SizeDevice");
	MakeCode	(x=0X77A3);
	OpHex		(x,	1);
	MakeComm	(0X77A6,	"DOS - 2+ - OPEN DISK FILE WITH HANDLE\nDS:DX -> ASCIZ filename\nAL = access mode\n0 - read");
	MakeCode	(x=0X77A6);
	OpHex		(x,	0);
	MakeComm	(0X77AA,	"BX - file handle");
	MakeComm	(0X77B3,	"DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)\nAL = method: offset from end of file");
	MakeCode	(x=0X77B3);
	OpHex		(x,	0);
	MakeComm	(0X77BD,	"size > 0ffffh paras ?");
	MakeCode	(x=0X77BD);
	OpHex		(x,	1);
	MakeComm	(0X77C1,	"no");
	MakeComm	(0X77C3,	"invalid device size\n assuming that we fail later");
	MakeComm	(0X77CC,	"convert it to paras");
	MakeCode	(0X77CC);
	MakeComm	(0X77D6,	"save file size (in paragraphs)");
	MakeComm	(0X77DA,	"CLC is not needed here\n(OR instruction clears CF) - E.TAN 22/07/2023");
	MakeComm	(0X77DB,	"save carry flag");
	MakeCode	(x=0X77DC);
	OpHex		(x,	1);
	MakeComm	(0X77DF,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle");
	MakeCode	(x=0X77DF);
	OpHex		(x,	0);
	MakeComm	(0X77E1,	"restore carry flag\n(we are not checking for 'close file' err)");
	MakeCode	(0X77E4);
	MakeName	(0X77E4,	"ExecDev");
	MakeComm	(0X77E9,	"Load the parameter block");
	MakeComm	(0X77EE,	"block for exec with  load address");
	MakeComm	(0X77F7,	"es:bx points to parameters");
	MakeCode	(x=0X77F7);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X77FA,	"(load program only)");
	MakeComm	(0X77FC,	"load in the device driver");
	MakeCode	(x=0X77FC);
	OpHex		(x,	1);
	MakeComm	(0X77FE,	"DOS - 2+ - LOAD OR EXECUTE (EXEC)\nDS:DX -> ASCIZ filename\nES:BX -> parameter block\nAL = subfunc: called by MSC spawn(P_NOWAIT,...) when running DOS 4.x.");
	MakeCode	(x=0X77FE);
	OpHex		(x,	0);
	MakeCode	(0X7801);
	MakeName	(0X7801,	"RetFromUM");
	MakeComm	(0X7802,	"ConvLoad set if didn't previously call HideUMBs");
	MakeComm	(0X780D,	"ConvLoad clear if did.");
	MakeCode	(0X7815);
	MakeName	(0X7815,	"RemoveNull");
	MakeComm	(0X7818,	"null ?");
	MakeComm	(0X781C,	"advance the pointer");
	MakeCode	(0X781F);
	MakeComm	(0X7824,	"replace null with blank");
	MakeComm	(0X7828,	"Rounds DevBrkAddr to a para addr\nso that it is of the form xxxx:0");
	MakeCode	(0X7828);
	MakeName	(0X7828,	"RoundBreakAddr");
	MakeCode	(0X7849);
	MakeCode	(0X784A);
	MakeName	(0X784A,	"DevSetBreak");
	MakeComm	(0X784B,	"remove the init code");
	MakeComm	(0X7855,	"do not check it.");
	MakeComm	(0X785C,	"if not same, then o.k.");
	MakeComm	(0X7864,	"[DevBrkAddr+2]=[memhi] & [DevBrkAddr]=0");
	MakeCode	(0X786C);
	MakeComm	(0X786F,	"Marks a succesful install of a device driver\nSets device size field in sub-arena &\nUpdates Free ptr in UMB or adjusts memhi");
	MakeCode	(0X786F);
	MakeName	(0X786F,	"DevBreak");
	MakeComm	(0X7879,	"seg of sub-arena");
	MakeComm	(0X787C,	"Back to Device segment");
	MakeComm	(0X787F,	"size of device in paras");
	MakeComm	(0X7881,	"[devmark.size]\nstore it in sub-arena");
	MakeComm	(0X788C,	"update Free ptr in UMB");
	MakeCode	(0X7893);
	MakeComm	(0X78A1,	"Parses the command line for SIZE= command");
	MakeCode	(0X78A1);
	MakeName	(0X78A1,	"ParseSize");
	MakeComm	(0X78A4,	"init the value");
	MakeComm	(0X78B8,	"'SI'");
	MakeComm	(0X78BF,	"'ZE'");
	MakeComm	(0X78CE,	"cf=0 here");
	MakeComm	(0X78DF,	"cf=0 here");
	MakeComm	(0X78E4,	"cf=0 here (clc is not needed)\n22/07/2023 - Erdogan Tan");
	MakeCode	(0X78E6);
	MakeComm	(0X78E9,	"Skips delimiters in the string pointed to by ES:SI\nReturns ptr to first non-delimiter character in ES:SI");
	MakeCode	(0X78E9);
	MakeName	(0X78E9,	"SkipDelim");
	MakeCode	(0X78F4);
	MakeComm	(0X78F5,	"Converts an ascii string \nterminated by a delimiter into binary.\nAssumes that the ES:SI\npoints to a Hexadecimal string");
	MakeCode	(0X78F5);
	MakeName	(0X78F5,	"GetHexNum");
	MakeComm	(0X78FC,	"cr");
	MakeComm	(0X7901,	"lf");
	MakeCode	(x=0X7917);
	OpHex		(x,	1);
	MakeCode	(x=0X7919);
	OpHex		(x,	1);
	MakeCode	(x=0X7922);
	OpDecimal	(x,	1);
	MakeCode	(x=0X7928);
	OpHex		(x,	1);
	MakeCode	(x=0X7932);
	OpHex		(x,	1);
	MakeCode	(x=0X7934);
	OpHex		(x,	1);
	MakeComm	(0X7938,	"AX = number of paras equivalent to the\nhex number of bytes specified\nby the hexadecimal string.");
	MakeComm	(0X793A,	"encountered a non-hex character or crlf");
	MakeCode	(0X793A);
	MakeComm	(0X793C,	"Convert one nibble (hex digit) in BL into binary");
	MakeCode	(0X793C);
	MakeName	(0X793C,	"GetNibble");
	MakeCode	(0X794A);
	MakeCode	(0X7958);
	MakeComm	(0X795A,	"Allocate all UMBs and link it to DOS arena chain\nlink in the first UMB");
	MakeCode	(0X795A);
	MakeName	(0X795A,	"AllocUMB");
	MakeComm	(0X795D,	"quit on error");
	MakeComm	(0X795F,	"allocate");
	MakeComm	(0X7964,	"& insert till no UMBs");
	MakeComm	(0X7969,	"coalesce all UMBs");
	MakeCode	(0X7969);
	MakeCode	(0X796D);
	MakeName	(0X796D,	"InitAllocUMB");
	MakeComm	(0X7970,	"quit on no XMS driver");
	MakeCode	(x=0X7972);
	OpHex		(x,	1);
	MakeComm	(0X7974,	"DOS - 2+ internal - GET LIST OF LISTS\nReturn: ES:BX -> DOS list of lists");
	MakeCode	(x=0X7974);
	OpHex		(x,	0);
	MakeComm	(0X7976,	"save dos data segment");
	MakeComm	(0X797E,	"- Multiplex - XMS - GET DRIVER ADDRESS\nReturn: ES:BX -> driver entry point");
	MakeCode	(x=0X797E);
	OpHex		(x,	0);
	MakeComm	(0X7980,	"get XMS driver address");
	MakeComm	(0X798A,	"have we already linked a UMB?");
	MakeComm	(0X7990,	"quit if we already did it");
	MakeComm	(0X7992,	"else link the first UMB");
	MakeComm	(0X7997,	"mark that 1st UMB linked");
	MakeComm	(0X799D,	"(cf is already zero here)\nErdogan tan - 27/07/2023");
	MakeCode	(0X799F);
	MakeCode	(0X79A1);
	MakeName	(0X79A1,	"umb_allocate");
	MakeComm	(0X79A2,	"XMM_REQUEST_UMB");
	MakeCode	(x=0X79A2);
	OpDecimal	(x,	1);
	MakeComm	(0X79A4,	"try to allocate largest possible");
	MakeCode	(x=0X79B0);
	OpDecimal	(x,	1);
	MakeComm	(0X79B7,	"Q: was the reqst successful");
	MakeComm	(0X79BA,	"N: error");
	MakeCode	(0X79BF);
	MakeComm	(0X79C2,	"links the UMB into the arena chain");
	MakeCode	(0X79C2);
	MakeName	(0X79C2,	"umb_insert");
	MakeComm	(0X79C8,	"[UMB_ARENA]  ; ds = UMB_HEAD");
	MakeComm	(0X79D0,	"BX = seg address of UMB to be linked in");
	MakeComm	(0X79D2,	"current block above new block, insert it");
	MakeComm	(0X79D4,	"[es:ARENA.SIGNATURE],arena_signature_end");
	MakeComm	(0X79DA,	"if current block is the last,\nappend new block to chain");
	MakeComm	(0X79E1,	"ax = es = next block");
	MakeComm	(0X79E3,	"ds = previous arena");
	MakeCode	(0X79E3);
	MakeComm	(0X79E5,	"top of previous block");
	MakeComm	(0X79E8,	"cx = size of used block");
	MakeComm	(0X79EA,	"[ARENA.SIGNATURE],arena_signature_normal");
	MakeComm	(0X79EF,	"[ARENA.OWNER],8 ; mark as system owned");
	MakeComm	(0X79F5,	"[ARENA.SIZE],cx");
	MakeComm	(0X79F9,	"[ARENA.NAME],'SC'");
	MakeComm	(0X79FF,	"prepare the arena at start of new block");
	MakeComm	(0X7A01,	"[es:ARENA.SIGNATURE],arena_signature_normal");
	MakeComm	(0X7A07,	"[es:ARENA.OWNER],arena_owner_system ; mark as free");
	MakeComm	(0X7A0E,	"DX = size of UMB to be linked in paras\nmake room for arena at start & end of new block");
	MakeComm	(0X7A11,	"[es:ARENA.SIZE],dx");
	MakeComm	(0X7A16,	"prepare arena at end of new block");
	MakeComm	(0X7A19,	"es = arena at top of new block");
	MakeComm	(0X7A1B,	"bx = top of new block");
	MakeComm	(0X7A1C,	"ax contains arena just above this block\nresult: ax = size of used block");
	MakeComm	(0X7A1E,	"[es:ARENA.SIGNATURE],arena_signature_normal");
	MakeComm	(0X7A24,	"[es:ARENA.OWNER],8 ; mark as system owned");
	MakeComm	(0X7A2B,	"[es:ARENA.SIZE],ax");
	MakeComm	(0X7A2F,	"[es:ARENA.NAME],'SC'");
	MakeComm	(0X7A38,	"es = arena of last block\n[es:ARENA.SIZE] ; ax=top of last block-1 para");
	MakeCode	(0X7A38);
	MakeComm	(0X7A3D,	"reserve space on top of this\nblock for the next arena.");
	MakeComm	(0X7A43,	"[es:ARENA.SIGNATURE],arena_signature_normal");
	MakeComm	(0X7A49,	"cx = top of prev block-1");
	MakeComm	(0X7A4C,	"ax = top of prev block - seg. addr of new block");
	MakeComm	(0X7A50,	"ds = arena of unused block");
	MakeComm	(0X7A52,	"[es:ARENA.SIGNATURE],arena_signature_normal");
	MakeComm	(0X7A58,	"[es:ARENA.OWNER],8 ; mark as system owned");
	MakeComm	(0X7A5F,	"mov [es:ARENA.SIZE],ax");
	MakeComm	(0X7A63,	"mov word [es:ARENA.NAME],'SC'");
	MakeComm	(0X7A6A,	"prepare the arena at start of new block");
	MakeComm	(0X7A6C,	"[es:ARENA.SIGNATURE],arena_signature_end");
	MakeComm	(0X7A72,	"[es:ARENA.OWNER],arena_owner_system\nmark as free");
	MakeComm	(0X7A79,	"make room for arena");
	MakeComm	(0X7A7A,	"mov [es:ARENA.SIZE],dx");
	MakeComm	(0X7A81,	"Combine free blocks ahead with current block");
	MakeCode	(0X7A81);
	MakeName	(0X7A81,	"umb_coalesce");
	MakeComm	(0X7A88,	"[es:UMB_ARENA] ; es = UMB_HEAD");
	MakeComm	(0X7A91,	"[es:ARENA.OWNER],di\nQ: is current arena free");
	MakeComm	(0X7A96,	"Y: try to coalesce with next block\nN: get next arena");
	MakeComm	(0X7A98,	"es, ax = next arena");
	MakeComm	(0X7A9F,	"es, ax = next arena");
	MakeCode	(0X7A9F);
	MakeComm	(0X7AA4,	"[es:ARENA.OWNER],di\nQ: is arena free");
	MakeComm	(0X7AA9,	"N: get next free arena\nY: coalesce");
	MakeComm	(0X7AAB,	"[es:ARENA.SIZE]\ncx = next block size");
	MakeComm	(0X7AB0,	"cx = cx + 1 (for header size)");
	MakeComm	(0X7AB1,	"[ARENA.SIZE],cx\ncurrent size = current size + cx");
	MakeComm	(0X7AB5,	"move up signature");
	MakeComm	(0X7ABA,	"try again");
	MakeCode	(0X7ABC);
	MakeComm	(0X7ABD,	"Find Next item in Arena\ncmp byte [ARENA.SIGNATURE],arena_signature_end");
	MakeCode	(0X7ABD);
	MakeName	(0X7ABD,	"get_next");
	MakeComm	(0X7AC4,	"ax = current block");
	MakeComm	(0X7AC6,	"add ax,[ARENA.SIZE]\nax = ax + current block length");
	MakeComm	(0X7ACA,	"remember that header!");
	MakeCode	(0X7ACF);
	MakeCode	(0X7AD1);
	MakeName	(0X7AD1,	"LinkFirstUMB");
	MakeComm	(0X7AD6,	"MEMORY SIZE - \nReturn: AX = number of contiguous 1K blocks of memory");
	MakeCode	(x=0X7AD6);
	OpHex		(x,	0);
	MakeComm	(0X7ADA,	"ax = size in paragraphs");
	MakeComm	(0X7ADE,	"bx = segment of allocated UMB\nax = - size of unused block");
	MakeComm	(0X7AE2,	"cx = first umb_arena");
	MakeComm	(0X7AE5,	"es = first umb_arena");
	MakeComm	(0X7AE7,	"[es:ARENA.SIGNATURE],arena_signature_normal");
	MakeComm	(0X7AED,	"[es:ARENA.OWNER],8 ; mark as system owned");
	MakeComm	(0X7AF4,	"mov [es:ARENA.SIZE],ax");
	MakeComm	(0X7AF8,	"[es:ARENA.NAME],'SC'");
	MakeComm	(0X7AFF,	"put in the arena for the first UMB\nes has first free umb seg");
	MakeComm	(0X7B01,	"[es:ARENA.SIGNATURE],arena_signature_end");
	MakeComm	(0X7B07,	"es:ARENA.OWNER],arena_owner_system  \nmark as free");
	MakeComm	(0X7B0E,	"dx = size of UMB\nmake room for arena");
	MakeComm	(0X7B0F,	"[es:ARENA.SIZE],dx");
	MakeComm	(0X7B19,	"UMB_ARENA");
	MakeCode	(x=0X7B19);
	OpHex		(x,	1);
	MakeComm	(0X7B1C,	"initialize umb_head in DOS data segment\nwith the arena just below Top of Memory\n\nwe must now scan the arena chain and\nupdate the size of the last arena");
	MakeComm	(0X7B1F,	"DOS_ARENA");
	MakeCode	(x=0X7B1F);
	OpHex		(x,	1);
	MakeComm	(0X7B22,	"es = start arena");
	MakeComm	(0X7B27,	"arena_signature_end");
	MakeComm	(0X7B2F,	"[es:ARENA.SIZE]");
	MakeComm	(0X7B39,	"sub word [es:ARENA.SIZE],1");
	MakeCode	(0X7B39);
	MakeComm	(0X7B3F,	"[es:ARENA.SIGNATURE],arena_signature_normal");
	MakeCode	(0X7B47);
	MakeComm	(0X7B49,	"Shrinks the current UMB in use, \nso that the unused portions of the UMB\nis given back to the DOS free mem pool");
	MakeCode	(0X7B49);
	MakeName	(0X7B49,	"ShrinkUMB");
	MakeCode	(x=0X7B62);
	OpHex		(x,	1);
	MakeComm	(0X7B65,	"DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)\nES = segment address of block to change\nBX = new size in paragraphs");
	MakeCode	(x=0X7B65);
	OpHex		(x,	0);
	MakeComm	(0X7B6C,	"[es:ARENA.OWNER]");
	MakeComm	(0X7B76,	"Unlinks the UMBs from the DOS arena chain");
	MakeCode	(0X7B76);
	MakeName	(0X7B76,	"UnlinkUMB");
	MakeComm	(0X7B7E,	"nothing to unlink");
	MakeComm	(0X7B80,	"get DOS data seg");
	MakeComm	(0X7B85,	"[es:DOS_ARENA]");
	MakeComm	(0X7B8A,	"[es:UMB_ARENA]");
	MakeComm	(0X7B94,	"is the next one UMB ?");
	MakeComm	(0X7B9C,	"[ARENA.SIGNATURE],arena_signature_end");
	MakeCode	(0X7B9C);
	MakeStr		(0X7BA4,	0X7BB2);
	MakeName	(0X7BA4,	"MagicDDName");
	MakeComm	(0X7BB2,	"not to be loaded in UMB");
	MakeCode	(0X7BB2);
	MakeName	(0X7BB2,	"MagicPreload");
	MakeCode	(x=0X7BC1);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X7BC4,	"pass the command line to the device");
	MakeComm	(0X7BCE,	"save it for error reporting");
	MakeComm	(0X7BD8,	"normalize memhi:memlo (first free memory)");
	MakeComm	(0X7BDD,	"get size of device file into DevSize");
	MakeComm	(0X7BE0,	"SYSPRE_BADFILE_ERROR");
	MakeCode	(x=0X7BE0);
	OpHex		(x,	1);
	MakeComm	(0X7BE5,	"Doesn't matter if DeviceHi==0");
	MakeComm	(0X7BEB,	"set up sub-arena, DevLoadAddr,\nDevLoadEnd, and DevEntry\ngets arena name from bpb_addr");
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_5(void) {
        auto x;
#define id x

	MakeComm	(0X7BF2,	"calculate seg after DD load");
	MakeComm	(0X7BF7,	"choke if overflows address space");
	MakeComm	(0X7BF9,	"does it overflow available space?");
	MakeComm	(0X7BFE,	"we're golden if not");
	MakeComm	(0X7C00,	"SYSPRE_MEMORY_ERROR");
	MakeCode	(x=0X7C00);
	OpHex		(x,	1);
	MakeComm	(0X7C06,	"get the load file name");
	MakeCode	(0X7C06);
	MakeComm	(0X7C0B,	"load device driver using exec call");
	MakeComm	(0X7C0E,	"SYSPRE_EXEC_FAIL_ERROR");
	MakeCode	(x=0X7C0E);
	OpHex		(x,	1);
	MakeComm	(0X7C13,	"pass the limit to the DD");
	MakeComm	(0X7C22,	"point to the Magic DD header");
	MakeComm	(0X7C27,	"'.,' ; is it our stamp?\n(',.' in NASM syntax)");
	MakeComm	(0X7C2D,	"SYSPRE_NOT_MAGIC");
	MakeCode	(x=0X7C2D);
	OpHex		(x,	1);
	MakeComm	(0X7C30,	"abort if not MagicDrv!");
	MakeComm	(0X7C32,	"save the backdoor entry");
	MakeComm	(0X7C3E,	"pass drive number to DBLSPACE as if");
	MakeComm	(0X7C42,	"it is a normal block device driver");
	MakeComm	(0X7C47,	"calldev needs packet segment in es");
	MakeCode	(x=0X7C48);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X7C4B,	"DS_INTERNAL_REVISION \ntell it what revision we expect");
	MakeCode	(x=0X7C4B);
	OpDecimal	(x,	1);
	MakeComm	(0X7C4E,	"first time call is init entry point\nwith a standard device driver\ninit packet at es:bx");
	MakeCode	(x=0X7C57);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X7C5A,	"display the message");
	MakeCode	(x=0X7C5A);
	OpHex		(x,	1);
	MakeComm	(0X7C5C,	"DOS - PRINT STRING\nDS:DX -> string terminated by \"$\"");
	MakeCode	(x=0X7C5C);
	OpHex		(x,	0);
	MakeComm	(0X7C60,	"error code returned?");
	MakeCode	(0X7C60);
	MakeComm	(0X7C62,	"skip if no error");
	MakeComm	(0X7C64,	"\npoint backdoor call back to safe far return");
	MakeCode	(x=0X7C64);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X7C70,	"SYSPRE_DRIVER_FAILED ; error code");
	MakeCode	(x=0X7C70);
	OpHex		(x,	1);
	MakeCode	(0X7C75);
	MakeCode	(x=0X7C79);
	OpDecimal	(x,	1);
	MakeCode	(x=0X7C7C);
	OpHex		(x,	1);
	MakeCode	(x=0X7C7E);
	OpHex		(x,	1);
	MakeCode	(x=0X7C80);
	OpHex		(x,	1);
	MakeComm	(0X7C82,	"convert to paragraphs");
	MakeCode	(x=0X7C82);
	OpHex		(x,	1);
	MakeComm	(0X7C84,	"add to terminate segment");
	MakeComm	(0X7C8D,	"store normalized end here");
	MakeComm	(0X7C94,	"inquire how many paragraphs it wants");
	MakeComm	(0X7C9C,	"get top of free memory");
	MakeComm	(0X7CA1,	"see how much we'll lower it");
	MakeComm	(0X7CA3,	"is there that much room free?");
	MakeComm	(0X7CA8,	"if not, just leave it low");
	MakeComm	(0X7CAA,	"allocate space!");
	MakeComm	(0X7CB4,	"tell the driver to move itself");
	MakeComm	(0X7CBC,	"save end of low stub");
	MakeComm	(0X7CC0,	"get terminate segment");
	MakeComm	(0X7CC4,	"terminate size TOO big?");
	MakeComm	(0X7CC9,	"SYSPRE_MEMORY_ERROR");
	MakeCode	(x=0X7CC9);
	OpHex		(x,	1);
	MakeComm	(0X7CCC,	"error out if so");
	MakeComm	(0X7CCE,	"set ds:si to header");
	MakeComm	(0X7CD3,	"es:di point to dos info");
	MakeComm	(0X7CDA,	"SYSPRE_MEMORY_ERROR");
	MakeCode	(x=0X7CDA);
	OpHex		(x,	1);
	MakeComm	(0X7CE0,	"if no units found, erase the device");
	MakeCode	(0X7CE0);
	MakeComm	(0X7CE8,	"mov [si+SYSDEV.NAME],al\nnumber of units in name field\ndevice drivers are *supposed*\nto do this for themselves.");
	MakeCode	(x=0X7CE8);
	OpDecimal	(x,	0);
	MakeComm	(0X7CF1,	"[es:di+SYSI_NUMIO]\nget number of devices");
	MakeComm	(0X7CF7,	"check for too many devices");
	MakeComm	(0X7CF9,	"'A' - 'Z' is 26 devices");
	MakeCode	(x=0X7CF9);
	OpDecimal	(x,	1);
	MakeComm	(0X7D03,	"[es:di+SYSI_NUMIO] ; update the amount");
	MakeName	(0X7D03,	"_ok_block");
	MakeComm	(0X7D07,	"point to bpb array (*)");
	MakeComm	(0X7D11,	"es:[bp.sysi_dpb]\nget first dpb\n[es:bp+SysInitvars.SYSI_DPB] ; [es:bp+0]");
	MakeComm	(0X7D15,	"-1 ; es:[bp.dpb_next_dpb]");
	MakeComm	(0X7D1C,	"les bp,es:[bp.dpb_next_dpb]\n[es:bp+DPB.NEXT_DPB]");
	MakeComm	(0X7D22,	"SYSPRE_TOO_MANY_UNITS_ERROR");
	MakeCode	(x=0X7D22);
	OpHex		(x,	1);
	MakeComm	(0X7D27,	"SYSPRE_NO_UNITS_ERROR");
	MakeCode	(x=0X7D27);
	OpHex		(x,	1);
	MakeCode	(0X7D2D);
	MakeComm	(0X7D31,	"es:[bp.dpb_next_dpb] ; DPB.NEXT_DPB");
	MakeComm	(0X7D39,	"es:[bp.dpb_next_dpb+2] ; DPB.NEXT_DPB+2");
	MakeComm	(0X7D42,	"DPBSIZ ; 21h");
	MakeCode	(x=0X7D42);
	OpDecimal	(x,	1);
	MakeComm	(0X7D4B,	"-1");
	MakeComm	(0X7D51,	"es:[bp.dpb_first_access],-1\nDPB.FIRST_ACCESS");
	MakeComm	(0X7D56,	"ds:si points to bpb (*)\n(mov si,[bx] ..and then.. add bx,2)\nNote: If unit count > 1, bx points to a BPB in the BPB array,\nthe array address is in [bpb_addr] (*) -I don't understand how and\nwhat for but DBLSPACE.BIN code may set this- (bx=bx+2 for next)\nErdogan Tan - 07/07/2023");
	MakeComm	(0X7D59,	"point to next BPB\n(in the BPB array) (*) -add bx,2-");
	MakeComm	(0X7D5A,	"mov word ptr es:[bp.dpb_drive],dx\n[es:bp+DPB.DRIVE],dl ; [es:bp+DPB.UNIT],dh");
	MakeComm	(0X7D5E,	"SETDPB ; hidden system call");
	MakeCode	(x=0X7D5E);
	OpHex		(x,	1);
	MakeComm	(0X7D60,	"DOS - 2+ internal - TRANSLATE BIOS PARAMETER BLOCK\nDS:SI -> BPB (BIOS Parameter Block)\nES:BP -> buffer for DOS Drive Parameter Block");
	MakeCode	(x=0X7D60);
	OpHex		(x,	0);
	MakeComm	(0X7D62,	"es:[bp.dpb_sector_size]  ; [es:bp+DPB.SECTOR_SIZE]");
	MakeComm	(0X7D6C,	"es:[di.sysi_maxsec] ; [es:di+SysInitvars.SYSI_MAXSEC]");
	MakeComm	(0X7D71,	"SYSPRE_BAD_SECTOR_SIZE_ERROR");
	MakeCode	(x=0X7D71);
	OpHex		(x,	1);
	MakeComm	(0X7D7C,	"[es:bp+DPB.DRIVER_ADDR]");
	MakeComm	(0X7D80,	"[es:bp+DPB.DRIVER_ADDR+2]");
	MakeComm	(0X7D85,	"increment drive number");
	MakeComm	(0X7D87,	"increment unix number");
	MakeComm	(0X7D8D,	"set cds for new drives");
	MakeComm	(0X7D90,	"es:di = dos table (SysInitVars)");
	MakeComm	(0X7D95,	"[es:di+SYSI_DEV] ; dx:cx = head of list");
	MakeComm	(0X7D99,	"[es:di+SYSI_DEV+2]");
	MakeComm	(0X7D9D,	"ds:si = device location");
	MakeComm	(0X7DA2,	"[es:di+SYSI_DEV] ; set head of list in dos");
	MakeComm	(0X7DA6,	"[es:di+SYSI_DEV+2]");
	MakeComm	(0X7DAA,	"link in the driver");
	MakeComm	(0X7DB2,	"pass it a work buffer");
	MakeComm	(0X7DB7,	"address in cx (segment)");
	MakeComm	(0X7DBC,	"for len dx (paragraphs)");
	MakeComm	(0X7DBE,	"we're shuffle aware, but don't move\nany drives at this point.");
	MakeComm	(0X7DC1,	"switch what we can now");
	MakeComm	(0X7DC9,	"no errors!\nzf=1");
	MakeComm	(0X7DCB,	"reset zero flag if error");
	MakeComm	(0X7DCE,	"multMagicdrv\nDBLSPACE.BIN - \"GetVersion\" - \n              INSTALLATION CHECK\n(BX = 0)");
	MakeCode	(0X7DCE);
	MakeName	(0X7DCE,	"MagicPostload");
	MakeComm	(0X7DD1,	"MD_VERSION");
	MakeCode	(x=0X7DD4);
	OpHex		(x,	0);
	MakeComm	(0X7DD6,	"ax = 0 (successful, zf=1)\nis it there?");
	MakeComm	(0X7DD8,	"done if not");
	MakeComm	(0X7DDA,	"is it already permanent?");
	MakeCode	(x=0X7DDA);
	OpHex		(x,	1);
	MakeComm	(0X7DDE,	"no, done if so (not in final position)");
	MakeComm	(0X7DE0,	"-1 ; how much space does it want?");
	MakeComm	(0X7DE3,	"multMagicdrv\nDBLSPACE.BIN - GET RELOCATION SIZE");
	MakeComm	(0X7DE6,	"get paragraphs into ax");
	MakeCode	(x=0X7DE6);
	OpHex		(x,	0);
	MakeComm	(0X7DE8,	"extra 2 paragraphs for the stub\nadd ax,((tiny_stub_end-tiny_stub_start)+15)/16\n(18+15)/16 = 2");
	MakeComm	(0X7DEB,	"store that (**)");
	MakeComm	(0X7DEF,	"not to be loaded in UMB");
	MakeComm	(0X7DFC,	"conventional (memory) load");
	MakeCode	(x=0X7E04);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X7E0B,	"pass name so that\narena header can be set");
	MakeComm	(0X7E10,	"normalize memhi:memlo");
	MakeComm	(0X7E13,	"set up sub-arena, DevLoadAddr,\nDevLoadEnd, and DevEntry\ngets arena name from bpb_addr");
	MakeComm	(0X7E16,	"(**) (InitDevload sets this)");
	MakeComm	(0X7E1A,	"calculate seg after DD load");
	MakeComm	(0X7E1F,	"save as ending address!");
	MakeCode	(x=0X7E2F);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X7E32,	"move a little header in place\nso that this looks to the mem command\nlike a legitimate driver load");
	MakeComm	(0X7E34,	"(tiny_stub_end-tiny_stub_start)");
	MakeCode	(x=0X7E34);
	OpDecimal	(x,	1);
	MakeComm	(0X7E37,	"move it!");
	MakeComm	(0X7E39,	"advance es appropriately");
	MakeComm	(0X7E3B,	"add ax,((tiny_stub_end-tiny_stub_start)+15)/16");
	MakeComm	(0X7E40,	"multMagicdrv");
	MakeComm	(0X7E43,	"-2 ; final placement!");
	MakeComm	(0X7E46,	"DBLSPACE.BIN - RELOCATE\nes = segment to which to relocate DBLSPACE.BIN");
	MakeCode	(x=0X7E46);
	OpHex		(x,	0);
	MakeComm	(0X7E48,	"go ahead and alloc mem for device");
	MakeComm	(0X7E4F,	"multMagicdrv\nDBLSPACE.BIN - \"GetVersion\" - \n              INSTALLATION CHECK\n(BX = 0)");
	MakeCode	(0X7E4F);
	MakeName	(0X7E4F,	"MagicSetCdss");
	MakeComm	(0X7E52,	"MD_VERSION");
	MakeCode	(x=0X7E55);
	OpHex		(x,	0);
	MakeComm	(0X7E57,	"ax = 0 (successful, zf=1)\nis it there?");
	MakeComm	(0X7E59,	"done if not");
	MakeComm	(0X7E5B,	"get first DblSpace drive letter");
	MakeComm	(0X7E5D,	"make it zero based.");
	MakeCode	(x=0X7E5D);
	OpChr		(x,	1);
	MakeComm	(0X7E5F,	"and save for drive testing loop");
	MakeComm	(0X7E61,	"point to DOS data area (SysInitVars)");
	MakeComm	(0X7E66,	"les si,es:[si].sysi_cds ; fetch CDSs\n[es:si+SYSI_CDS]");
	MakeComm	(0X7E6A,	"curdirLen");
	MakeCode	(x=0X7E6A);
	OpDecimal	(x,	1);
	MakeComm	(0X7E6C,	"find first DblSpace CDS");
	MakeComm	(0X7E6E,	"cds pointer");
	MakeComm	(0X7E70,	"get DblSpace drive count into cx");
	MakeComm	(0X7E78,	"multMagicdrv");
	MakeComm	(0X7E7B,	"MD_DRIVE_MAP ; inquire drive map");
	MakeComm	(0X7E7E,	"DBLSPACE.BIN - \"GetDriveMapping\"\nsee if this is an unused DblSpace drive");
	MakeCode	(x=0X7E7E);
	OpHex		(x,	0);
	MakeComm	(0X7E84,	"if mapped to itself, it is vacant");
	MakeComm	(0X7E86,	"skip if used");
	MakeComm	(0X7E88,	"reset the bit in flags (curdir_inuse bit)\n[si+curdir_list.cdir_flags],~curdir_inuse ; word\n(.. [si+1+curdir_list.cdir_flags],0BFh ; byte)");
	MakeCode	(x=0X7E88);
	OpHex		(x,	1);
	MakeComm	(0X7E8E,	"curdirLen");
	MakeCode	(x=0X7E8E);
	OpDecimal	(x,	1);
	MakeComm	(0X7E91,	"next drive");
	MakeComm	(0X7E96,	"phony device driver link");
	MakeWord	(0X7E96);
	MakeName	(0X7E96,	"tiny_stub_start");
	MakeComm	(0X7E98,	"dw -1, -1");
	MakeWord	(0X7E98);
	MakeComm	(0X7E9A,	"mark as character device for MEM display");
	MakeWord	(0X7E9A);
	MakeComm	(0X7E9C,	"strat and irpt");
	MakeWord	(0X7E9C);
	MakeArray	(0X7E9C,	0X2);
	MakeComm	(0X7EA0,	"magic default load\n(tiny_stub_end-tiny_stub_start = 18)");
	MakeStr		(0X7EA0,	0X7EA8);
	MakeComm	(0X7EA8,	"tiny_stub_end equ $");
	MakeByte	(0X7EA8);
	MakeName	(0X7EA8,	"insert_blank");
	MakeCode	(0X7EA9);
	MakeName	(0X7EA9,	"setparms");
	MakeComm	(0X7EB6,	"get it correct for ioctl call\n(1=A,2=A...)");
	MakeComm	(0X7EB8,	"offset deviceparameters");
	MakeCode	(x=0X7EB8);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X7EBB,	"IOCTL");
	MakeCode	(x=0X7EBB);
	OpHex		(x,	1);
	MakeComm	(0X7EBD,	"GENERIC_IOCTL");
	MakeCode	(x=0X7EBD);
	OpHex		(x,	1);
	MakeComm	(0X7EBF,	"RAWIO");
	MakeCode	(x=0X7EBF);
	OpHex		(x,	1);
	MakeComm	(0X7EC1,	"SET_DEVICE_PARAMETERS");
	MakeCode	(x=0X7EC1);
	OpHex		(x,	1);
	MakeComm	(0X7EC3,	"DOS - 2+ - IOCTL - ");
	MakeCode	(x=0X7EC3);
	OpHex		(x,	0);
	MakeComm	(0X7EC5,	"DOSBIODATASEG ; BIOSDATA segment");
	MakeCode	(x=0X7EC5);
	OpHex		(x,	1);
	MakeComm	(0X7ECA,	"flagec35");
	MakeCode	(x=0X7ECA);
	OpHex		(x,	1);
	MakeComm	(0X7ED3,	"which drive was this for?");
	MakeComm	(0X7ED8,	"assume drive 0");
	MakeComm	(0X7EDA,	"set proper bit depending on drive");
	MakeComm	(0X7EDC,	"set the bit in the permanent flags");
	MakeCode	(x=0X7EDC);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X7EE0,	"mov al,[cs:deviceparameters+20]\n[cs:deviceparameters+A_DEVICEPARAMETERS.DP_BPB\n+A_BPB.BPB_SECTORSPERTRACK]");
	MakeCode	(x=0X7EE4);
	OpOff		(x,	1,	0);
	OpOff		(x,	129,	0);
	MakeCode	(x=0X7EEA);
	OpOff		(x,	0,	0);
	OpOff		(x,	128,	0);
	MakeComm	(0X7EF3,	"replace default values for further drivparm commands");
	MakeCode	(0X7EF3);
	MakeName	(0X7EF3,	"diddleback");
	MakeComm	(0X7EF6,	"[deviceparameters+4],80\n[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],80");
	MakeCode	(x=0X7EF6);
	OpDecimal	(x,	1);
	MakeComm	(0X7EFC,	"[deviceparameters+1],2\n[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_3INCH720KB");
	MakeComm	(0X7F01,	"[deviceparameters+2],0\n[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],0");
	MakeComm	(0X7F07,	"zero all switches");
	MakeCode	(0X7F0F);
	MakeName	(0X7F0F,	"parseline");
	MakeComm	(0X7F12,	"al contains the first character in command line.");
	MakeComm	(0X7F14,	"cr");
	MakeComm	(0X7F18,	"lf ; put it back and done");
	MakeComm	(0X7F1C,	"skip over space");
	MakeComm	(0X7F22,	"mark error invalid-character-in-input");
	MakeCode	(0X7F25);
	MakeComm	(0X7F28,	"save switches read so far");
	MakeComm	(0X7F35,	"exit if error");
	MakeCode	(0X7F35);
	MakeComm	(0X7F37,	"flagdrive ; see if drive specified");
	MakeCode	(x=0X7F37);
	OpHex		(x,	1);
	MakeComm	(0X7F3F,	"mark error no-drive-specified");
	MakeCode	(0X7F42);
	MakeComm	(0X7F45,	"get flag bits for changeline and non-rem");
	MakeCode	(x=0X7F45);
	OpHex		(x,	1);
	MakeComm	(0X7F48,	"[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]");
	MakeComm	(0X7F4B,	"[deviceparameters+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]");
	MakeComm	(0X7F51,	"everything is fine");
	MakeComm	(0X7F57,	"one more char to scan");
	MakeCode	(x=0X7F57);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X7F5B,	"back up over linefeed");
	MakeCode	(x=0X7F5B);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X7F61);
	MakeName	(0X7F61,	"check_switch");
	MakeComm	(0X7F66,	"convert it to upper case");
	MakeCode	(x=0X7F66);
	OpHex		(x,	1);
	MakeComm	(0X7F73,	"get number of valid switches");
	MakeCode	(x=0X7F73);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X7F79,	"point to string of valid switches");
	MakeCode	(x=0X7F79);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X7F84,	"set bit to indicate switch");
	MakeComm	(0X7F86,	"get switches so far");
	MakeCode	(x=0X7F86);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X7F8A,	"save this with other switches");
	MakeComm	(0X7F8E,	"switchnum ; 0F8h\ntest against switches that require number to follow");
	MakeCode	(x=0X7F8E);
	OpHex		(x,	1);
	MakeCode	(x=0X7F98);
	OpChr		(x,	1);
	MakeComm	(0X7F9F,	"preserve switches");
	MakeComm	(0X7FA0,	"allow space separators");
	MakeComm	(0X7FAF,	"restore switches");
	MakeComm	(0X7FB5,	"remove this switch from the records");
	MakeCode	(0X7FB5);
	MakeComm	(0X7FB9,	"if this switch has been done before,");
	MakeCode	(x=0X7FB9);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X7FB9,	"process_num");
	MakeComm	(0X7FBD,	"ignore this one.");
	MakeComm	(0X7FBF,	"flagdrive");
	MakeCode	(x=0X7FBF);
	OpHex		(x,	1);
	MakeCode	(x=0X7FC5);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X7FCA,	"flagff");
	MakeCode	(x=0X7FCA);
	OpHex		(x,	1);
	MakeComm	(0X7FD5,	"if number entered was 0, assume default value");
	MakeCode	(0X7FD5);
	MakeComm	(0X7FD9,	"flagcyln");
	MakeCode	(x=0X7FD9);
	OpHex		(x,	1);
	MakeComm	(0X7FDF,	"[deviceparameters+4],ax\n[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]");
	MakeCode	(x=0X7FDF);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X7FE4,	"flagseclim");
	MakeCode	(x=0X7FE4);
	OpHex		(x,	1);
	MakeComm	(0X7FE8,	"must be for number of heads");
	MakeCode	(x=0X7FEA);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X7FEF);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X7FF2,	"(test instruction resets cf)");
	MakeCode	(0X7FF4);
	MakeName	(0X7FF4,	"setdeviceparameters");
	MakeComm	(0X7FF9,	"[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE]");
	MakeCode	(x=0X7FF9);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X7FFD,	"DEV_5INCH");
	MakeComm	(0X8002,	"[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]\n48 tpi = 40 cyl");
	MakeCode	(x=0X8002);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpDecimal	(x,	1);
	MakeComm	(0X8008,	"get index into bpb table");
	MakeCode	(x=0X8008);
	OpHex		(x,	1);
	MakeComm	(0X800A,	"get address of bpb");
	MakeCode	(x=0X800A);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X800E,	"deviceparameters+7  \ndeviceparameters+A_DEVICEPARAMETERS.DP_BPB\nes:di -> bpb");
	MakeCode	(x=0X800E);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8011,	"A_BPB.size");
	MakeCode	(x=0X8011);
	OpDecimal	(x,	1);
	MakeComm	(0X8018,	"flagseclim");
	MakeCode	(x=0X8018);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeCode	(x=0X8020);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8023,	"[deviceparameters+20]\n[deviceparameters+A_DEVICEPARAMETERS.DP_BPB\n +A_BPB.BPB_SECTORSPERTRACK]");
	MakeCode	(x=0X8023);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8026,	"flagheads");
	MakeCode	(x=0X8026);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeCode	(x=0X802E);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8031,	"[deviceparameters+22]   \n[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]");
	MakeCode	(x=0X8031);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8034,	"[deviceparameters+9],2\n[deviceparameters+A_DEVICEPARAMETERS.DP_BPB   \n +A_BPB.BPB_SECTORSPERCLUSTER]");
	MakeCode	(x=0X8034);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8039,	"get default mediabyte");
	MakeComm	(0X803B,	"[deviceparameters+17]\n[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR]");
	MakeCode	(x=0X803B);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X803F);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8044,	"just use default if heads>2");
	MakeComm	(0X8046,	"one head, do one head stuff");
	MakeComm	(0X804A,	"[deviceparameters+A_DEVICEPARAMETERS.DP_BPB\n +A_BPB.BPB_SECTORSPERTRACK]");
	MakeCode	(x=0X804A);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpDecimal	(x,	1);
	MakeComm	(0X8051,	"[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]");
	MakeCode	(x=0X8051);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpDecimal	(x,	1);
	MakeComm	(0X8058,	"cyl=80, heads=2, secpertrack=18.\n Set cluster size to 1.");
	MakeCode	(x=0X805A);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpDecimal	(x,	1);
	MakeCode	(x=0X8061);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X8068);
	OpHex		(x,	1);
	MakeComm	(0X806C,	"[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_5INCH");
	MakeCode	(x=0X806C);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X8073);
	OpHex		(x,	1);
	MakeComm	(0X8075,	"[deviceparameters+A_DEVICEPARAMETERS.DP_BPB\n +A_BPB.BPB_SECTORSPERTRACK],8");
	MakeCode	(x=0X8075);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X807A,	"okay if anything besides 8");
	MakeComm	(0X807C,	"160K mediaid");
	MakeCode	(x=0X807C);
	OpHex		(x,	1);
	MakeComm	(0X807E,	"[deviceparameters+A_DEVICEPARAMETERS.DP_BPB\n +A_BPB.BPB_SECTORSPERCLUSTER],1");
	MakeCode	(x=0X807E);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8083,	"[deviceparameters+A_DEVICEPARAMETERS.DP_BPB\n +A_BPB.BPB_MEDIADESCRIPTOR],bl");
	MakeCode	(x=0X8083);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8087,	"[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]");
	MakeCode	(x=0X8087);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X808A,	"[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]");
	MakeCode	(x=0X808A);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X808E,	"[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]");
	MakeCode	(x=0X808E);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8092,	"[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]");
	MakeCode	(x=0X8092);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X8097);
	MakeName	(0X8097,	"organize");
	MakeComm	(0X80AD,	"found a comment string and skipped.");
	MakeComm	(0X80AF,	"not a comment string. then get a char.");
	MakeComm	(0X80B2,	"lf");
	MakeComm	(0X80B4,	"starts with a blank line.");
	MakeComm	(0X80B8,	"skip leading control characters");
	MakeComm	(0X80BC,	"store line feed char in buffer for the linecount.");
	MakeCode	(0X80BC);
	MakeComm	(0X80BD,	"reset the command level.");
	MakeCode	(0X80C5);
	MakeComm	(0X80C7,	"prepare to search command table");
	MakeCode	(0X80C7);
	MakeCode	(x=0X80CD);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X80D9,	"CONFIG_SEMICOLON");
	MakeComm	(0X80E3,	"~20h ; force upper case");
	MakeCode	(x=0X80E3);
	OpHex		(x,	1);
	MakeComm	(0X80E6,	"compare to byte @es:di");
	MakeComm	(0X80EC,	"bump to next position without affecting flags");
	MakeComm	(0X80EF,	"get indicator letter");
	MakeComm	(0X80F2,	"the next char might be cr,lf");
	MakeComm	(0X80F8,	"such as in \"rem\",cr,lf case.");
	MakeComm	(0X80FE,	"CONFIG_BEGIN");
	MakeComm	(0X8103,	"now the next char. should be a delim.");
	MakeComm	(0X8106,	"explicit interactive command?");
	MakeComm	(0X8108,	"no");
	MakeComm	(0X810A,	"yes, so retrieve the original code");
	MakeComm	(0X810B,	"CONFIG_OPTION_QUERY ; and set the QUERY bit");
	MakeCode	(x=0X810B);
	OpHex		(x,	1);
	MakeComm	(0X810F,	"CONFIG_REM");
	MakeCode	(0X810F);
	MakeCode	(0X8113);
	MakeCode	(0X811E);
	MakeComm	(0X8121,	"CONFIG_UNKNOWN");
	MakeComm	(0X8123,	"save indicator char.");
	MakeComm	(0X8127,	"lf ; skip this bad command line");
	MakeComm	(0X812D,	"save indicator char in buffer");
	MakeCode	(0X812D);
	MakeComm	(0X812E,	"~CONFIG_OPTION_QUERY");
	MakeCode	(x=0X812E);
	OpHex		(x,	1);
	MakeComm	(0X8130,	"save it for the future use.");
	MakeComm	(0X8134,	"CONFIG_BEGIN");
	MakeComm	(0X8138,	"CONFIG_SUBMENU");
	MakeComm	(0X813C,	"CONFIG_MENUITEM");
	MakeComm	(0X8140,	"CONFIG_MENUDEFAULT");
	MakeComm	(0X8144,	"CONFIG_INCLUDE");
	MakeComm	(0X8148,	"map case of rest of line to UPPER");
	MakeComm	(0X814B,	"skip the command name until delimiter");
	MakeComm	(0X814E,	"lf");
	MakeComm	(0X8152,	"cr");
	MakeComm	(0X8156,	"Added to allow DEVHIGH/L:...");
	MakeComm	(0X8158,	"to be parsed properly");
	MakeComm	(0X8161,	"if cr or lf then");
	MakeCode	(0X8161);
	MakeComm	(0X8162,	"undo si, cx register and continue");
	MakeComm	(0X8163,	"CONFIG_COMMENT");
	MakeComm	(0X816B,	"CONFIG_DEVICE");
	MakeComm	(0X8173,	"CONFIG_INSTALL");
	MakeComm	(0X817B,	"CONFIG_INSTALLHIGH");
	MakeComm	(0X8183,	"CONFIG_SHELL");
	MakeComm	(0X818B,	"CONFIG_SWITCHES");
	MakeCode	(0X8196);
	MakeComm	(0X81A7,	"get the filename and put 0 at end");
	MakeCode	(0X81A7);
	MakeComm	(0X81AC,	"not a comment");
	MakeComm	(0X81B2,	"skip the possible delimiters");
	MakeComm	(0X81B4,	"copy the first non delim char found in buffer");
	MakeComm	(0X81B5,	"comment char in the filename?");
	MakeComm	(0X81B8,	"then stop copying filename at that point");
	MakeComm	(0X81BD,	"a switch char? (device=filename/xxx)");
	MakeComm	(0X81BF,	"this will be the special case.");
	MakeComm	(0X81C1,	"save the char. in buffer");
	MakeComm	(0X81C9,	"keep copying");
	MakeComm	(0X81CB,	"otherwise, assume end of the filename.");
	MakeComm	(0X81CD,	"get the token. just max. 2 char.");
	MakeCode	(0X81CD);
	MakeComm	(0X81D0,	"skip white spaces or \"=\" char.");
	MakeComm	(0X81D2,	"(we are allowing the other special");
	MakeComm	(0X81D4,	"characters can used for comment id.");
	MakeComm	(0X81D6,	"character.)");
	MakeComm	(0X81D8,	" = is special in this case.");
	MakeComm	(0X81DE,	"cannot accept the carriage return");
	MakeComm	(0X81E4,	"store it");
	MakeComm	(0X81E8,	"1 char. so far.");
	MakeComm	(0X81F5,	"tab");
	MakeComm	(0X81F9,	"cr");
	MakeComm	(0X81FD,	"lf");
	MakeComm	(0X820D,	"lf");
	MakeComm	(0X820F,	"skip it.");
	MakeComm	(0X8211,	"else jmp to end_commd_line");
	MakeComm	(0X8214,	"make the filename in front of\nthe comment string to be an asciiz.");
	MakeCode	(0X8214);
	MakeComm	(0X8219,	"(maybe null if device=/*)");
	MakeComm	(0X821C,	"al = \"/\" option char.\nmake a filename an asciiz");
	MakeCode	(0X821C);
	MakeComm	(0X8220,	"and");
	MakeComm	(0X8221,	"store \"/\" after that.");
	MakeComm	(0X8222,	"continue with the rest of the line");
	MakeComm	(0X8224,	"make it an asciiz and handle the next char.");
	MakeCode	(0X8224);
	MakeComm	(0X8229,	"lf");
	MakeComm	(0X822F,	"org4 skips all delimiters\nafter the command name except for '/'");
	MakeCode	(0X822F);
	MakeComm	(0X8237,	"skip delimiters except '/'");
	MakeComm	(0X823E,	"rest of the line is");
	MakeCode	(0X823E);
	MakeComm	(0X8241,	"comment.");
	MakeComm	(0X8243,	"not a comment.");
	MakeComm	(0X8246,	"copy the character");
	MakeComm	(0X8247,	"a quote ?");
	MakeComm	(0X824F,	"CONFIG_DEVICEHIGH\nQ: is this devicehigh");
	MakeCode	(x=0X824F);
	OpChr		(x,	1);
	MakeComm	(0X8255,	"N:");
	MakeComm	(0X8257,	"Q: is this line feed");
	MakeComm	(0X8259,	"Y: stuff a blank before the lf");
	MakeComm	(0X825B,	"Q: is this a cr");
	MakeComm	(0X825D,	"N:");
	MakeComm	(0X825F,	"overwrite cr with blank");
	MakeComm	(0X8264,	"put cr after blank");
	MakeComm	(0X8265,	"indicate that blank has been inserted");
	MakeComm	(0X826C,	"lf ; line feed?");
	MakeCode	(0X826C);
	MakeComm	(0X826E,	"handles the next command line.");
	MakeComm	(0X8270,	"handles next char in this line.");
	MakeComm	(0X8272,	"Q:has a blank already been inserted");
	MakeCode	(0X8272);
	MakeComm	(0X8278,	"Y:");
	MakeComm	(0X827A,	"overwrite lf with blank");
	MakeComm	(0X827F,	"put lf after blank");
	MakeComm	(0X8280,	"clear blank indicator for devicehigh");
	MakeCode	(0X8289);
	MakeComm	(0X8291,	"reset it");
	MakeComm	(0X8299,	"set it");
	MakeCode	(0X8299);
	MakeCode	(0X82A0);
	MakeName	(0X82A0,	"get2");
	MakeComm	(0X82A6,	"This was the rather kludgy way\nout of procedure \"organize\", \nbut instead of returning to doconf,\nwe now want to check config.sys BEGIN/END blocks\nand the new boot menu stuff");
	MakeCode	(0X82A6);
	MakeName	(0X82A6,	"noget");
	MakeComm	(0X82BD,	"get out of the organize routine.\n...\nskip the commented string until lf,\nif current es:si-> a comment string.\n...");
	MakeCode	(0X82BD);
	MakeName	(0X82BD,	"skip_comment");
	MakeComm	(0X82BF,	"only check it if parameter level is 0.");
	MakeComm	(0X82C5,	"(not inside quotations)");
	MakeComm	(0X82EC,	"get out of organize routine.");
	MakeComm	(0X82F3,	"lf ; line feed ?");
	MakeComm	(0X82F8,	"wait for keystroke");
	MakeCode	(x=0X82F8);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeName	(0X82F8,	"kbd_read");
	MakeComm	(0X82FD,	"\nthe bios timer tick count is incremented\n18.2 times per second;\nwatch the timer tick count for 37 transitions\nget initial value");
	MakeComm	(0X8304,	"peek the keyboard");
	MakeComm	(0X8306,	"KEYBOARD - CHECK BUFFER, DO NOT CLEAR\nReturn: ZF clear if character in buffer\nAH = scan code, AL = character\nZF set if no character in buffer");
	MakeCode	(x=0X8306);
	OpHex		(x,	0);
	MakeComm	(0X830C,	"KEYBOARD - GET SHIFT STATUS\nAL = shift status bits");
	MakeCode	(x=0X830C);
	OpHex		(x,	0);
	MakeComm	(0X830E,	"either right or left shift key bits set?");
	MakeCode	(x=0X830E);
	OpHex		(x,	1);
	MakeComm	(0X8312,	"system timer, lw");
	MakeCode	(x=0X8312);
	MakeComm	(0X8315,	"get difference");
	MakeComm	(0X831A,	"reached limit? ; (2 seconds)");
	MakeCode	(x=0X831A);
	OpDecimal	(x,	1);
	MakeComm	(0X831F,	"delay complete!");
	MakeComm	(0X8320,	"assume clean boot");
	MakeComm	(0X8322,	"peek the shift states");
	MakeComm	(0X8324,	"KEYBOARD - GET SHIFT STATUS\nAL = shift status bits");
	MakeCode	(x=0X8324);
	OpHex		(x,	0);
	MakeComm	(0X8326,	"either right or left shift key bits set?");
	MakeCode	(x=0X8326);
	OpHex		(x,	1);
	MakeComm	(0X8328,	"no");
	MakeComm	(0X832A,	"yes");
	MakeCode	(x=0X832C);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X8331,	"peek the keyboard");
	MakeComm	(0X8333,	"KEYBOARD - CHECK BUFFER, DO NOT CLEAR\nReturn: ZF clear if character in buffer\nAH = scan code, AL = character\nZF set if no character in buffer");
	MakeCode	(x=0X8333);
	OpHex		(x,	0);
	MakeComm	(0X8335,	"no key present");
	MakeComm	(0X8337,	"is it a function key?");
	MakeComm	(0X8339,	"no");
	MakeComm	(0X833B,	"CTRL F5");
	MakeCode	(x=0X833B);
	OpHex		(x,	1);
	MakeComm	(0X8340,	"F5 function key?");
	MakeCode	(x=0X8340);
	OpHex		(x,	1);
	MakeComm	(0X8343,	"no");
	MakeCode	(x=0X8345);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X834B);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X8350,	"yes, clean boot selected");
	MakeComm	(0X8352,	"CTRL F8");
	MakeCode	(x=0X8352);
	OpHex		(x,	1);
	MakeComm	(0X8357,	"F8");
	MakeCode	(x=0X8357);
	OpHex		(x,	1);
	MakeCode	(x=0X835C);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8362,	"yes, interactive-boot option enabled");
	MakeComm	(0X8364,	"change default setting");
	MakeCode	(x=0X8364);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8368,	"eat the key we assumed was a signal");
	MakeComm	(0X836A,	"KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY\nReturn: AH = scan code, AL = character");
	MakeCode	(x=0X836A);
	OpHex		(x,	0);
	MakeComm	(0X836C,	"-1");
	MakeCode	(x=0X836C);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X837A,	"yes, tell COMMAND to skip autoexec.bat");
	MakeComm	(0X837D,	"set carry to indicate abort");
	MakeComm	(0X837F,	"clear carry to indicate success");
	MakeCode	(0X837F);
	MakeComm	(0X8381,	"set numlock LED");
	MakeCode	(0X8381);
	MakeName	(0X8381,	"set_numlock");
	MakeComm	(0X8387,	"get 1st 2 bytes of value (ON or OF)");
	MakeComm	(0X8391,	"~20h ; turn it off");
	MakeCode	(x=0X8391);
	OpHex		(x,	1);
	MakeCode	(0X8398);
	MakeComm	(0X83A0,	"turn it on");
	MakeCode	(x=0X83A0);
	OpHex		(x,	1);
	MakeComm	(0X83A8,	"Search for SWITCHES,\ndetermine if /N or /F are present;\nif so, then disable clean/interactive boot options");
	MakeCode	(0X83A8);
	MakeName	(0X83A8,	"menu_check");
	MakeComm	(0X83AA,	"remains ZERO until first block");
	MakeComm	(0X83AC,	"get first char of current line");
	MakeComm	(0X83AF,	"hit eof");
	MakeComm	(0X83B5,	"remember that we've seen a block");
	MakeComm	(0X83B8,	"CONFIG_NUMLOCK");
	MakeCode	(0X83B8);
	MakeComm	(0X83BC,	"only do NUMLOCK commands that exist");
	MakeComm	(0X83BE,	"before the first block");
	MakeComm	(0X83C0,	"REM it out so we don't act on it later, too");
	MakeComm	(0X83C3,	"CONFIG_REM");
	MakeComm	(0X83CA,	"CONFIG_SWITCHES");
	MakeCode	(0X83CA);
	MakeComm	(0X83CC,	"this line ain't it");
	MakeComm	(0X83CE,	"look for /N or /F");
	MakeComm	(0X83D1,	"LF ; end of line ?");
	MakeComm	(0X83D5,	"switch-char?");
	MakeComm	(0X83D7,	"no");
	MakeComm	(0X83DC,	"~20h ; convert to upper case");
	MakeCode	(x=0X83DC);
	OpHex		(x,	1);
	MakeCode	(x=0X83DE);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X83E2,	"no");
	MakeCode	(x=0X83E4);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X83E9,	"continue looking for switches of interest");
	MakeCode	(x=0X83EB);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X83EF,	"no");
	MakeCode	(x=0X83F1);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X83F6,	"continue looking for switches of interest");
	MakeCode	(0X83F8);
	MakeCode	(0X83FD);
	MakeComm	(0X83FE,	"\nDo the keyboard tests for clean/interactive boot now,\nbut only if the DisableUI flag is still clear");
	MakeCode	(x=0X83FF);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X8404,	"\nWait for 2 seconds first, \nUNLESS the /F bit was set in bDisableUI, or\nthere is anything at all in the keyboard buffer");
	MakeComm	(0X840E,	"Search for MENU block;\nit is allowed to be anywhere in config.sys");
	MakeCode	(0X840E);
	MakeCode	(x=0X8410);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8413,	"find the MENU block\nif no MENU, default to zero for no_selection");
	MakeCode	(x=0X8418);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X841D,	"not found");
	MakeComm	(0X8420,	"Process the requested menu color(s)");
	MakeCode	(0X8420);
	MakeComm	(0X8422,	"default color setting");
	MakeComm	(0X8425,	"get first number");
	MakeComm	(0X8428,	"first # is foreground color (for low nibble)");
	MakeCode	(x=0X8428);
	OpHex		(x,	1);
	MakeComm	(0X842B,	"save it in CH");
	MakeCode	(x=0X842D);
	OpHex		(x,	1);
	MakeComm	(0X8432,	"did we hit a delimiter");
	MakeComm	(0X8435,	"no, all done");
	MakeComm	(0X8437,	"get next number");
	MakeComm	(0X843A,	"second # is background color (for high nibble)");
	MakeCode	(x=0X843A);
	OpHex		(x,	1);
	MakeComm	(0X843D,	"save it in DH");
	MakeCode	(x=0X843F);
	OpHex		(x,	1);
	MakeComm	(0X8448,	"are foreground/background the same?");
	MakeComm	(0X844A,	"no");
	MakeComm	(0X844C,	"yes, so modify the fgnd intensity");
	MakeCode	(x=0X844C);
	OpHex		(x,	1);
	MakeCode	(x=0X844F);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X8458);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X845D);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8463,	"-1");
	MakeCode	(x=0X8463);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8468,	"~2");
	MakeCode	(x=0X8468);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X846D,	"skip to next line");
	MakeComm	(0X8470,	"initialize total block count (0 => none yet)");
	MakeComm	(0X8472,	"get first char of current line");
	MakeComm	(0X8475,	"could happen if menu block at end (rare)");
	MakeComm	(0X8477,	"~CONFIG_OPTION_QUERY");
	MakeCode	(x=0X8477);
	OpHex		(x,	1);
	MakeComm	(0X8479,	"CONFIG_BEGIN");
	MakeComm	(0X847B,	"BEGIN implies END");
	MakeComm	(0X847D,	"CONFIG_SUBMENU");
	MakeComm	(0X847F,	"go process sub-menu");
	MakeComm	(0X8481,	"CONFIG_MENUITEM");
	MakeComm	(0X8483,	"go process menu item");
	MakeComm	(0X8485,	"CONFIG_MENUDEFAULT");
	MakeComm	(0X8487,	"go process menu default");
	MakeComm	(0X8489,	"CONFIG_MENUCOLOR");
	MakeComm	(0X848B,	"go process menu color");
	MakeComm	(0X848D,	"CONFIG_NUMLOCK");
	MakeComm	(0X8491,	"CONFIG_REM");
	MakeComm	(0X8493,	"allow remarks in menu block");
	MakeComm	(0X8495,	"allow blank lines and such");
	MakeComm	(0X849B,	"non-MENU command!");
	MakeCode	(0X84A0);
	MakeCode	(0X84A5);
	MakeComm	(0X84A7,	"save address of default block name");
	MakeCode	(x=0X84A7);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X84AB);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X84B0,	"secElapsed is only zero for the FIRST menu,");
	MakeComm	(0X84B2,	"and for subsequent menus IF nothing was typed;");
	MakeComm	(0X84B5,	"secElapsed becomes -1 forever as soon as");
	MakeComm	(0X84B7,	"something is typed");
	MakeComm	(0X84BE,	"get number (of seconds for timeout)");
	MakeComm	(0X84C1,	"limit it to a reasonable number");
	MakeCode	(x=0X84C1);
	OpDecimal	(x,	1);
	MakeComm	(0X84C4,	"(besides, 99 is the largest # my simple");
	MakeComm	(0X84C6,	"display function can handle)");
	MakeCode	(x=0X84C6);
	OpDecimal	(x,	1);
	MakeCode	(x=0X84C8);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X84CE,	"MAX_MULTI_CONFIG\nhave we reached the max # of items yet?");
	MakeCode	(0X84CE);
	MakeComm	(0X84D3,	"DS:DI -> block name to search for");
	MakeComm	(0X84D8,	"srch_block, having succeeded,\nreturns DI -> past the token that it just matched,\nwhich in this case should be a descriptive string;\nES:SI and CX are unmodified");
	MakeComm	(0X84DB,	"print error and pause");
	MakeComm	(0X84DE,	"if not found, ignore this menu item");
	MakeComm	(0X84E0,	"otherwise, increment total block count");
	MakeCode	(0X84E0);
	MakeComm	(0X84E1,	"and use it to index the arrays of offsets");
	MakeCode	(x=0X84E3);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X84E7,	"of recorded block names and descriptions");
	MakeComm	(0X84E9,	"\nThere should be a description immediately following\nthe block name on MENUITEM line; failing that,\nwe'll just use the block name as the description...");
	MakeCode	(x=0X84E9);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X84ED);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X84F1,	"skip_delim modifies BX, so stash it in DI");
	MakeComm	(0X84F6,	"hit eol/eof");
	MakeComm	(0X84FB,	"hit eol/eof");
	MakeCode	(x=0X84FF);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8506,	"go back for more lines");
	MakeComm	(0X8509,	"Display menu items now, \nafter determining which one is default\n\nwhere there any valid blocks at all?");
	MakeCode	(0X8509);
	MakeComm	(0X850B,	"yes");
	MakeComm	(0X850D,	"no, so force autoselect of 0");
	MakeComm	(0X850F,	"(meaning: process common blocks only)");
	MakeCode	(0X8512);
	MakeComm	(0X8514,	"first, record how many blocks we found");
	MakeCode	(x=0X8514);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X8518);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X851C,	" does a default block exist?");
	MakeComm	(0X851E,	"no");
	MakeComm	(0X8520,	"yes, walk name table, looking for default");
	MakeCode	(x=0X8524);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8528,	"arbitrary maximum length of a name");
	MakeCode	(x=0X8528);
	OpDecimal	(x,	1);
	MakeComm	(0X852E,	"is this block the same as the default?");
	MakeComm	(0X8533,	"yes");
	MakeComm	(0X8536,	"all done searching?");
	MakeCode	(x=0X8536);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X853A,	"not yet");
	MakeComm	(0X853C,	"if no default, force default to #1");
	MakeComm	(0X853E,	"yes, this will be the initial current block\n\nIf the timeout was explicitly set to 0 (or technically,\nanything that failed to resolve to a number, like \"NONE\"\nor \"EAT POTATOES\"), then we're supposed to skip menu display\nand run with the specified default block; however,\nif the user hit Enter prior to boot, thereby requesting fully\nINTERACTIVE boot, then we shall display the menu block anyway\n(though still with no timeout)");
	MakeCode	(x=0X853E);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8542,	"is timeout zero? (ie, assume default)");
	MakeCode	(x=0X8542);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8547,	"no");
	MakeComm	(0X8549,	"yes, but was INTERACTIVE requested?");
	MakeCode	(x=0X8549);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X854E,	"yes, so *don't* assume default after all");
	MakeComm	(0X8553,	"Reset the mode,\nso that we know screen is clean and cursor is home\n;");
	MakeCode	(0X8553);
	MakeComm	(0X8555,	"- VIDEO - GET CURRENT VIDEO MODE\nReturn: AH = number of columns on screen\nAL = current video mode\nBH = current active display page");
	MakeCode	(x=0X8555);
	OpHex		(x,	0);
	MakeComm	(0X8559,	"- VIDEO - SET VIDEO MODE\nAL = mode");
	MakeCode	(x=0X8559);
	OpHex		(x,	0);
	MakeComm	(0X855C,	"reach down into the ROM BIOS data area");
	MakeCode	(x=0X855C);
	OpHex		(x,	1);
	MakeComm	(0X855F,	"and save the current (default) video page");
	MakeComm	(0X8561,	"start address and page #, in case the");
	MakeCode	(x=0X8561);
	MakeComm	(0X8565,	"undocumented QUIET option was enabled");
	MakeCode	(x=0X8565);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X8568);
	MakeCode	(x=0X856C);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X856F,	"select new page for menu");
	MakeCode	(x=0X856F);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8572,	"- VIDEO - ");
	MakeCode	(x=0X8572);
	OpHex		(x,	0);
	MakeComm	(0X8574,	"clear entire screen");
	MakeComm	(0X8577,	"using this color");
	MakeCode	(x=0X8577);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X857B,	"upper left row/col");
	MakeComm	(0X857D,	"[es:CRT_Cols]");
	MakeCode	(x=0X857D);
	MakeComm	(0X8584,	"[es:CRT_Rows]");
	MakeCode	(x=0X8584);
	MakeComm	(0X8589,	"# of rows valid?");
	MakeComm	(0X858B,	"hopefully");
	MakeComm	(0X858D,	"no, use a default");
	MakeCode	(x=0X858D);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8591,	"clear the screen using the req. attribute\n\n- VIDEO - SCROLL PAGE UP\nAL = number of lines to scroll window (0 = blank whole window)\nBH = attributes to be used on blanked lines\nCH,CL = row,column of upper left corner of window to scroll\nDH,DL = row,column of lower right corner of window");
	MakeCode	(x=0X8591);
	OpHex		(x,	0);
	MakeComm	(0X8594,	"save DH");
	MakeCode	(x=0X8594);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X8598);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X859B,	"cursor now on row 3 (numbered from 0)");
	MakeCode	(x=0X859E);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeCode	(x=0X85A5);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X85A9,	"restore DH");
	MakeCode	(x=0X85A9);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X85AD,	"print the status line on row DH, col 0");
	MakeComm	(0X85AF,	"now that we can trash the cursor position");
	MakeComm	(0X85B1,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ");
	MakeCode	(x=0X85B1);
	OpHex		(x,	0);
	MakeCode	(x=0X85B3);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X85B9,	"get cursor position");
	MakeComm	(0X85BB,	"- VIDEO - READ CURSOR POSITION\nBH = page number\nReturn: DH,DL = row,column, CH = cursor start line, CL = cursor end line");
	MakeCode	(x=0X85BB);
	OpHex		(x,	0);
	MakeComm	(0X85C0,	"save column where status char will go");
	MakeCode	(x=0X85C0);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X85C4,	"now prepare to display all the menu items");
	MakeComm	(0X85C7,	"print item #BL");
	MakeComm	(0X85CA,	"why \"inc bx\"? because it's a 1-byte opcode");
	MakeComm	(0X85CB,	"all done?");
	MakeCode	(x=0X85CB);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X85CF,	"not yet");
	MakeComm	(0X85D1,	"Set cursor position to just below the menu items\ncolumn 0");
	MakeComm	(0X85D5,	"select row below menu");
	MakeCode	(x=0X85D8);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X85DC,	"set cursor position beneath the block list");
	MakeComm	(0X85DE,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ");
	MakeCode	(x=0X85DE);
	OpHex		(x,	0);
	MakeCode	(x=0X85E0);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X85E6,	"make a selection, return # in BX");
	MakeCode	(x=0X85E9);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X85EF);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X85F3);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X85F8,	"clear the status line now");
	MakeComm	(0X85FB,	"\nNow begins the \"re-organization\" process...");
	MakeCode	(x=0X85FB);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X85FF,	"-1 ; clean boot requested?");
	MakeComm	(0X8602,	"no");
	MakeComm	(0X860C,	"-2 ; back to top-level menu?");
	MakeCode	(0X860C);
	MakeComm	(0X8611,	"yes, start all over");
	MakeCode	(x=0X8611);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X861A,	"CONFIG_SUBMENU");
	MakeCode	(x=0X861A);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeCode	(x=0X8623);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8627,	"THIS CANNOT FAIL!");
	MakeComm	(0X862C,	"ES:SI and CX are ready for another round");
	MakeComm	(0X8631,	"get BX -> name of selected block");
	MakeCode	(0X8631);
	MakeComm	(0X8633,	"\nBX should now either be ZERO\n(meaning no block has been selected) or the offset\nrelative to ES of the block name to be processed\n(along with all the \"common\" lines of course)");
	MakeCode	(x=0X8633);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8637,	"save selection");
	MakeCode	(x=0X8637);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X863B,	"reset ES:SI and CX for reprocessing");
	MakeCode	(x=0X863B);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8642,	"this is where we'll store new config.sys image");
	MakeCode	(x=0X8642);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8646,	"\nES:SI-> config.sys, DS:DI -> new config.sys workspace\n\nWork our way through the config.sys image again, this time copying\nall lines that are (A) \"common\" lines outside any block or (B) lines\nwithin the requested block. Lines inside INCLUDEd blocks are \ntransparently copied by copy_block in a recursive fashion;\nthe amount of recursion is limited by the fact INCLUDE statements are\nREMed by copy_block as they are processed and by the number of unique\nINCLUDE stmts in config.sys...");
	MakeComm	(0X8648,	"save selected block name");
	MakeComm	(0X8649,	"process (named or common) block");
	MakeComm	(0X864F,	"copy_block can only return for two reasons:\n it hit eof or a new block");
	MakeComm	(0X8652,	"always do \"common\" blocks");
	MakeCode	(x=0X8653);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8663,	"is there a block name to check?");
	MakeComm	(0X8665,	"no");
	MakeComm	(0X8668,	"check block against given block name");
	MakeComm	(0X866D,	"is this the block we really want to do?");
	MakeComm	(0X8672,	"hit eof");
	MakeComm	(0X867B,	"this ain't the block we wanted, so skip it");
	MakeCode	(0X867B);
	MakeComm	(0X8681,	"hit eof");
	MakeComm	(0X8683,	"~CONFIG_OPTION_QUERY");
	MakeCode	(x=0X8683);
	OpHex		(x,	1);
	MakeComm	(0X8685,	"CONFIG_BEGIN");
	MakeComm	(0X8689,	"anything else is just skipped");
	MakeComm	(0X868B,	"To create as little risk to the rest of SysInit\nas little as possible, and to free the workspace\nat \"config_wrkseg\" for creating an environment,\ncopy the new config.sys image to \"confbot\".\n\nnow copy workspace at DS:DI to \"confbot\"");
	MakeCode	(0X868B);
	MakeComm	(0X868D,	"\nBut first, copy the CONFIG=<configuration><0> string\nto the workspace, since the configuration name only \ncurrently exists in the \"confbot\" area.\n;");
	MakeComm	(0X868E,	"szMenu-szBoot-1\nfirst copy the CONFIG= part");
	MakeCode	(x=0X8691);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8694,	"skip a byte, in case absolutely nothing\nwas copied to the workspace, because we always\nzero the first byte of the workspace (below)");
	MakeComm	(0X869C,	"then copy the configuration name");
	MakeComm	(0X869D,	"128-7 ; put an upper limit on the name, to be safe");
	MakeCode	(x=0X869D);
	OpDecimal	(x,	1);
	MakeComm	(0X86A0,	"ES:SI -> default block name");
	MakeComm	(0X86A5,	"valid?");
	MakeComm	(0X86A7,	"yes");
	MakeCode	(x=0X86AB);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X86BC,	"terminate the configuration string");
	MakeComm	(0X86C0,	"Now we can copy \"config_wrkseg\" (DS) to \"confbot\" (ES)");
	MakeComm	(0X86C9,	"recover the size of \"config_wrkseg\"");
	MakeComm	(0X86CB,	"moved!");
	MakeComm	(0X86D0,	"Now that the config_wrkseg is available once again,\nwe shall use it to create an environment. The first\nthing to go in will be the \"CONFIG=configuration\" thing.\nIt is also important to zero the first byte of the workspace,\nso that copy_envvar knows the buffer is empty.");
	MakeComm	(0X86D4,	"ES:SI -> \"CONFIG=configuration\"");
	MakeComm	(0X86D5,	"empty the environment block");
	MakeComm	(0X86DB,	"copy envvar at ES:SI to \"config_wrkseg\"");
	MakeComm	(0X86DE,	"\nBefore returning, restore the default video page setting\nbut do NOT do it using INT 10h's Set Active Page function,\nbecause if the menu was displayed on a different page,\nthen it's because we don't want to see all the device\ndriver/TSR goop (which goes to the default page)");
	MakeCode	(x=0X86DF);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X86E7);
	OpHex		(x,	1);
	MakeCode	(x=0X86EC);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X86EF);
	MakeCode	(x=0X86F3);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X86F6);
	MakeCode	(x=0X86FB);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(x=0X86FF);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8704,	"copy the envvar at ES:SI to \"config_wrkseg\"\nES:SI -> environment variable \n         (in the form \"var=string<cr/lf>\")");
	MakeCode	(0X8704);
	MakeName	(0X8704,	"copy_envvar");
	MakeComm	(0X8709,	"ES:DI to point to next available byte");
	MakeCode	(x=0X8709);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X870D,	"DS:SI to point to envvar");
	MakeComm	(0X8711,	"NULL?");
	MakeComm	(0X8714,	"yes, abort");
	MakeComm	(0X8716,	"cr");
	MakeComm	(0X871B,	"lf");
	MakeComm	(0X8727,	"save char after '='");
	MakeComm	(0X8729,	"back up to given varname");
	MakeComm	(0X872B,	"CX == # of bytes in varname");
	MakeComm	(0X872C,	"start looking for DS:SI at ES:0");
	MakeComm	(0X8731,	"search failed, just copy var");
	MakeComm	(0X8733,	"ES:BX -> start of this varname");
	MakeComm	(0X873B,	"no match, skip to next varname");
	MakeCode	(x=0X873D);
	OpChr		(x,	1);
	MakeComm	(0X8741,	"no match, there's more characters\n\nPrevious occurrence of variable has been found;\ndetermine the entire length and then destroy it");
	MakeComm	(0X8743,	"-1");
	MakeComm	(0X8746,	"guaranteed to get null (since we put it there)");
	MakeComm	(0X8752,	"destroy variable now");
	MakeComm	(0X8758,	"if there is nothing after the '='");
	MakeCode	(0X8764);
	MakeComm	(0X8765,	"-1");
	MakeCode	(0X876D);
	MakeComm	(0X876E,	"cr");
	MakeComm	(0X8772,	"lf");
	MakeComm	(0X8779,	"do SUB to clear carry as well");
	MakeCode	(0X8779);
	MakeComm	(0X877B,	"always null-terminate these puppies");
	MakeComm	(0X877C,	"and stick another null to terminate the env.");
	MakeComm	(0X8789,	"copy the current block to the new config.sys workspace\n\nCX == remaining bytes in \"organized\" config.sys memory image\nES:SI -> remaining bytes in \"organized\" config.sys memory image\nDS:DI -> new config.sys workspace (equal in size to the original\n       config.sys image) where the current block is to be copied\n\ncheck for include");
	MakeCode	(0X8789);
	MakeName	(0X8789,	"copy_block");
	MakeComm	(0X878E,	"~CONFIG_OPTION_QUERY");
	MakeCode	(x=0X878E);
	OpHex		(x,	1);
	MakeComm	(0X8790,	"CONFIG_BEGIN\nanother BEGIN implies END as well");
	MakeComm	(0X8794,	"CONFIG_INCLUDE ; 'J'");
	MakeComm	(0X8796,	"AL == the original line code");
	MakeComm	(0X8798,	"not an \"include\" line\n\nWe have hit an \"INCLUDE\" line; first, REM out the line\nso that we never try to include the block again\n(no infinite include loops please), then search for\nthe named block and call copy_block again.");
	MakeComm	(0X879A,	"CONFIG_REM");
	MakeCode	(x=0X87A0);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X87A3,	"don't allow INCLUDE MENU");
	MakeCode	(x=0X87A8);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X87AB,	"don't allow INCLUDE COMMON");
	MakeComm	(0X87B0,	"try to find the block");
	MakeComm	(0X87B8,	"no such block");
	MakeComm	(0X87C1,	"skip the rest of the \"block name\" line");
	MakeComm	(0X87C4,	"and copy in the rest of that block");
	MakeComm	(0X87C9,	"force skip_opt_line to skip...");
	MakeCode	(0X87CD);
	MakeComm	(0X87CF,	"note that carry is clear, no pause");
	MakeComm	(0X87D4,	"Copy the line at ES:SI\n to the current location at DS:DI");
	MakeCode	(0X87D4);
	MakeComm	(0X87D7,	"is this is a \"real\" line with a \"real\" code?");
	MakeComm	(0X87D9,	"no");
	MakeComm	(0X87E1,	"not a multi-config config.sys, don't embed #s");
	MakeComm	(0X87E3,	"BX == line # of line @ES:SI");
	MakeComm	(0X87E6,	"stash it immediately following the line code");
	MakeCode	(0X87EC);
	MakeComm	(0X87EF,	"end of file");
	MakeComm	(0X87F4,	"lf ; done with line?");
	MakeComm	(0X87F6,	"nope");
	MakeCode	(0X87FD);
	MakeComm	(0X87FE,	"return line # (in BX) of current line (@ES:SI)");
	MakeCode	(0X87FE);
	MakeName	(0X87FE,	"get_linenum");
	MakeComm	(0X87FF,	"BX == line # (to be returned)");
	MakeComm	(0X8802,	"DX == the offset we're looking for");
	MakeComm	(0X880A,	"prepare to scan entire file");
	MakeComm	(0X8812,	"have we exceeded the desired offset yet?");
	MakeComm	(0X8814,	"no");
	MakeComm	(0X881A,	"searches entire config.sys\nfor block name @ES:DI");
	MakeCode	(0X881A);
	MakeName	(0X881A,	"srch_block");
	MakeComm	(0X882A,	"ES:DI -> just past the name in the block heading, if found");
	MakeComm	(0X882C,	"BX == # bytes remaining from that point, if found");
	MakeComm	(0X8833,	"searches rest of config.sys for block name @DS:DI\nget line code");
	MakeCode	(0X8833);
	MakeName	(0X8833,	"find_block");
	MakeComm	(0X8836,	"end of file");
	MakeComm	(0X8838,	"~CONFIG_OPTION_QUERY");
	MakeCode	(x=0X8838);
	OpHex		(x,	1);
	MakeComm	(0X883A,	"CONFIG_BEGIN ; beginning of a block?");
	MakeComm	(0X883C,	"no");
	MakeComm	(0X883E,	"CONFIG_INCLUDE");
	MakeCode	(x=0X8842);
	OpHex		(x,	1);
	MakeCode	(x=0X884A);
	OpHex		(x,	1);
	MakeComm	(0X8850,	"compare block names");
	MakeComm	(0X8853,	"end of file, or names matched");
	MakeComm	(0X8855,	"no, so skip to next line");
	MakeCode	(0X885A);
	MakeComm	(0X885B,	"compares keyword @DS:DI \n to position in config.sys @ES:SI");
	MakeCode	(0X885B);
	MakeName	(0X885B,	"comp_names");
	MakeComm	(0X8861,	"is next character a delimiter?");
	MakeComm	(0X8864,	"(get next character we're supposed to match)");
	MakeComm	(0X8866,	"yes, it *could* be a match");
	MakeComm	(0X8869,	"~2020h");
	MakeCode	(x=0X8869);
	OpHex		(x,	1);
	MakeComm	(0X886C,	"match?");
	MakeComm	(0X886E,	"yes, keep looking at the characters");
	MakeComm	(0X8870,	"prevent erroneous eof indication: clear carry");
	MakeComm	(0X8873,	"we don't know for sure if it's a match");
	MakeCode	(0X8873);
	MakeComm	(0X8875,	"until we verify that the second string");
	MakeComm	(0X8878,	"has been exhausted also...");
	MakeComm	(0X887A,	"if we are, this call to any_delim will tell...");
	MakeCode	(0X887C);
	MakeName	(0X887C,	"omp_names_safe");
	MakeComm	(0X888A,	"display menu item #BL");
	MakeCode	(0X888A);
	MakeName	(0X888A,	"print_item");
	MakeComm	(0X888F,	"get cursor position");
	MakeComm	(0X8891,	"always page zero");
	MakeCode	(x=0X8891);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8895,	"- VIDEO - READ CURSOR POSITION\nBH = page number\nReturn: DH,DL = row,column, CH = cursor start line, CL = cursor end line");
	MakeCode	(x=0X8895);
	OpHex		(x,	0);
	MakeComm	(0X8898,	"set cursor position for correct row/col");
	MakeComm	(0X88A1,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ");
	MakeCode	(x=0X88A1);
	OpHex		(x,	0);
	MakeComm	(0X88A5,	"convert menu item # to ASCII digit");
	MakeComm	(0X88A7,	"normal attribute");
	MakeCode	(x=0X88A7);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X88AB,	"are we printing the current block?");
	MakeCode	(x=0X88AB);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X88B1,	"yes, set bgnd color to white");
	MakeCode	(x=0X88B1);
	OpHex		(x,	1);
	MakeComm	(0X88BA,	"are fgnd/bgnd the same?");
	MakeComm	(0X88BC,	"no");
	MakeComm	(0X88BE,	"yes, so modify the fgnd intensity");
	MakeCode	(x=0X88BE);
	OpHex		(x,	1);
	MakeCode	(x=0X88C5);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X88C9,	"put the attribute in the correct register now");
	MakeCode	(x=0X88CB);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X88CF,	"write char/attr");
	MakeComm	(0X88D4,	"- VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION\nAL = character, BH = display page\nBL = attributes of character (alpha modes) or color (graphics modes)\nCX = number of times to write character");
	MakeCode	(x=0X88D4);
	OpHex		(x,	0);
	MakeComm	(0X88DA,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ");
	MakeCode	(x=0X88DA);
	OpHex		(x,	0);
	MakeComm	(0X88DF,	"- VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION\nAL = character, BH = display page\nBL = attributes of character (alpha modes) or color (graphics modes)\nCX = number of times to write character");
	MakeCode	(x=0X88DF);
	OpHex		(x,	0);
	MakeComm	(0X88E5,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ");
	MakeCode	(x=0X88E5);
	OpHex		(x,	0);
	MakeComm	(0X88EA,	"- VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION\nAL = character, BH = display page\nBL = attributes of character (alpha modes) or color (graphics modes)\nCX = number of times to write character");
	MakeCode	(x=0X88EA);
	OpHex		(x,	0);
	MakeComm	(0X88F0,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ");
	MakeCode	(x=0X88F0);
	OpHex		(x,	0);
	MakeComm	(0X88F3,	"get a character of the description");
	MakeComm	(0X88F7,	"TAB ; substitute spaces for tabs");
	MakeComm	(0X88FF,	"stop at the 1st character < space");
	MakeComm	(0X8903,	"also stop on $");
	MakeComm	(0X8907,	"- VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION\nAL = character, BH = display page\nBL = attributes of character (alpha modes) or color (graphics modes)\nCX = number of times to write character");
	MakeCode	(x=0X8907);
	OpHex		(x,	0);
	MakeComm	(0X8909,	"increment column");
	MakeComm	(0X890B,	"far enough?");
	MakeCode	(x=0X890B);
	OpDecimal	(x,	1);
	MakeComm	(0X890E,	"yes");
	MakeComm	(0X8912,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ");
	MakeCode	(x=0X8912);
	OpHex		(x,	0);
	MakeCode	(0X8916);
	MakeComm	(0X8918,	"restore previous row/col");
	MakeComm	(0X891A,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ");
	MakeCode	(x=0X891A);
	OpHex		(x,	0);
	MakeComm	(0X8922,	"wait for user to select menu item, with time-out\n\nreturns digit value in BX (trashes AX/CX/DX)");
	MakeCode	(x=0X8922);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeName	(0X8922,	"select_item");
	MakeComm	(0X8926,	"BL will be the default block #");
	MakeComm	(0X892B,	"display current interactive status");
	MakeComm	(0X892E,	"-1");
	MakeCode	(x=0X892E);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8933,	"no time-out, just go to input");
	MakeComm	(0X8935,	"GET_TIME");
	MakeCode	(x=0X8935);
	OpHex		(x,	1);
	MakeComm	(0X8937,	"DOS - GET CURRENT TIME\nReturn: CH = hours, CL = minutes, DH = seconds\nDL = hundredths of seconds\n;");
	MakeCode	(x=0X8937);
	OpHex		(x,	0);
	MakeComm	(0X8939,	"BH = initial # of seconds");
	MakeCode	(x=0X893B);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X893E);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8944,	"disable all further prompting");
	MakeCode	(x=0X8944);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeCode	(x=0X8949);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X894E,	"time's up!");
	MakeCode	(0X8951);
	MakeComm	(0X8952,	"save # in BL");
	MakeCode	(x=0X8954);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X895A,	"- VIDEO - READ CURSOR POSITION\nBH = page number\nReturn: DH,DL = row,column, CH = cursor start line, CL = cursor end line");
	MakeCode	(x=0X895A);
	OpHex		(x,	0);
	MakeComm	(0X895D,	"move cursor to the right");
	MakeComm	(0X8962,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ");
	MakeCode	(x=0X8962);
	OpHex		(x,	0);
	MakeCode	(x=0X8964);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8967,	"print the \"Time remaining: \" prompt");
	MakeComm	(0X896A,	"recover # from BL");
	MakeComm	(0X896C,	"this works because AL is always <= 90");
	MakeCode	(x=0X896D);
	OpDecimal	(x,	1);
	MakeComm	(0X896F,	"AL = tens digit, AH = ones digit");
	MakeComm	(0X8973,	"write TTY tens digit");
	MakeCode	(x=0X8973);
	OpChr		(x,	1);
	MakeComm	(0X8977,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)");
	MakeCode	(x=0X8977);
	OpHex		(x,	0);
	MakeComm	(0X897B,	"write TTY ones digit");
	MakeCode	(x=0X897B);
	OpChr		(x,	1);
	MakeComm	(0X897F,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)");
	MakeCode	(x=0X897F);
	OpHex		(x,	0);
	MakeComm	(0X8982,	"set cursor position back to where it was");
	MakeComm	(0X8984,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ");
	MakeCode	(x=0X8984);
	OpHex		(x,	0);
	MakeComm	(0X8987,	"RAW_CON_IO");
	MakeComm	(0X8989,	"input request");
	MakeComm	(0X898B,	"DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT\nDL = character <> FFh\n Return: ZF set = no character\n  ZF clear = character recieved, AL = character");
	MakeCode	(x=0X898B);
	OpHex		(x,	0);
	MakeComm	(0X898F,	"-1 ; is there a time-out?");
	MakeCode	(x=0X898F);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8994,	"no, just go back to input");
	MakeComm	(0X8996,	"GET_TIME");
	MakeCode	(x=0X8996);
	OpHex		(x,	1);
	MakeComm	(0X8998,	"DOS - GET CURRENT TIME\nReturn: CH = hours, CL = minutes, DH = seconds\nDL = hundredths of seconds");
	MakeCode	(x=0X8998);
	OpHex		(x,	0);
	MakeComm	(0X899C,	"should generally be zero or one");
	MakeComm	(0X89A2,	"it wrapped back to zero, so assume one");
	MakeComm	(0X89A4,	"any change?");
	MakeComm	(0X89A6,	"no");
	MakeCode	(x=0X89A8);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeCode	(0X89AE);
	MakeComm	(0X89AF,	"-1 ; zap both secTimeOut and secElapsed");
	MakeCode	(x=0X89B2);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X89B6,	"-1 ; was time-out already disabled?");
	MakeComm	(0X89B8,	"yes");
	MakeComm	(0X89BA,	"let's disable # seconds display");
	MakeComm	(0X89BB,	"write multiple spaces");
	MakeCode	(x=0X89BE);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X89C2,	"80 of them, to be safe\nto completely obliterate # seconds display");
	MakeCode	(x=0X89C2);
	OpDecimal	(x,	1);
	MakeComm	(0X89C5,	"- VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION\nAL = character, BH = display page - alpha mode\nBL = color of character (graphics mode, PCjr only)\nCX = number of times to write character");
	MakeCode	(x=0X89C5);
	OpHex		(x,	0);
	MakeComm	(0X89C9,	"extended key pressed?");
	MakeComm	(0X89CB,	"no");
	MakeComm	(0X89CD,	"get the next part of the key then");
	MakeCode	(x=0X89CD);
	OpHex		(x,	0);
	MakeComm	(0X89CF,	"what happened to the second part!?");
	MakeComm	(0X89D1,	"up arrow?");
	MakeCode	(x=0X89D1);
	OpHex		(x,	1);
	MakeComm	(0X89D3,	"no");
	MakeComm	(0X89D5,	"are we as up as up can get?");
	MakeComm	(0X89D8,	"yes, ignore it");
	MakeCode	(x=0X89DA);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X89DE,	"re-print the current item");
	MakeComm	(0X89E1,	"and then print the new current item");
	MakeComm	(0X89E5,	"down arrow?");
	MakeCode	(0X89E5);
	MakeComm	(0X89E7,	"no");
	MakeComm	(0X89E9,	"are we as down as down can get?");
	MakeCode	(x=0X89E9);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X89ED,	"yes, ignore it");
	MakeCode	(x=0X89EF);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X89F3,	"re-print the current item");
	MakeComm	(0X89F6,	"and then print the new current item");
	MakeCode	(x=0X8A01);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X8A06,	"don't allow F8 or F5");
	MakeComm	(0X8A08,	"F8 function key?");
	MakeCode	(x=0X8A08);
	OpHex		(x,	1);
	MakeComm	(0X8A0A,	"no");
	MakeCode	(x=0X8A0C);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X8A17,	"F5 function key?");
	MakeCode	(x=0X8A17);
	OpHex		(x,	1);
	MakeComm	(0X8A19,	"no");
	MakeComm	(0X8A1B,	"no more queries");
	MakeCode	(x=0X8A1B);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X8A20,	"special return code (-1) indicating clean boot");
	MakeComm	(0X8A23,	"don't want to display anything really;");
	MakeComm	(0X8A27,	"Enter?");
	MakeCode	(0X8A27);
	MakeComm	(0X8A29,	"yes");
	MakeComm	(0X8A2B,	"backspace?");
	MakeComm	(0X8A2D,	"no");
	MakeComm	(0X8A2F,	"-2 ; yes, special return code");
	MakeComm	(0X8A33,	"is greater than '0'?");
	MakeCode	(0X8A33);
	MakeComm	(0X8A35,	"no");
	MakeComm	(0X8A37,	"is less than or equal to the maximum digit?");
	MakeCode	(x=0X8A37);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8A3B,	"no");
	MakeCode	(x=0X8A3D);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8A40,	"redisplay the current selection");
	MakeComm	(0X8A43,	"set new selection");
	MakeComm	(0X8A47,	"return a full 16-bit value (for indexing)");
	MakeCode	(0X8A47);
	MakeComm	(0X8A4B,	"convert it into a digit, then display it");
	MakeComm	(0X8A4D,	"display a single character + cr/lf");
	MakeName	(0X8A4D,	"disp_input");
	MakeCode	(x=0X8A56);
	OpHex		(x,	1);
	MakeComm	(0X8A58,	"DOS - DISPLAY OUTPUT\nDL = character to send to standard output");
	MakeCode	(x=0X8A58);
	OpHex		(x,	0);
	MakeCode	(x=0X8A5A);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X8A62);
	MakeName	(0X8A62,	"disp_num");
	MakeCode	(x=0X8A63);
	OpChr		(x,	1);
	MakeCode	(x=0X8A67);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8A6E,	"- VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION\nAL = character, BH = display page - alpha mode\nBL = color of character (graphics mode, PCjr only)\nCX = number of times to write character");
	MakeCode	(x=0X8A6E);
	OpHex		(x,	0);
	MakeComm	(0X8A72,	"display current interactive mode setting (on/off/none)");
	MakeCode	(0X8A72);
	MakeName	(0X8A72,	"show_status");
	MakeCode	(x=0X8A73);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8A79,	"- VIDEO - READ CURSOR POSITION\nBH = page number\nReturn: DH,DL = row,column, CH = cursor start line, CL = cursor end line");
	MakeCode	(x=0X8A79);
	OpHex		(x,	0);
	MakeComm	(0X8A7E,	"set correct row/col");
	MakeCode	(x=0X8A7E);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X8A82);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X8A87,	"just show on/off");
	MakeComm	(0X8A8B,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ");
	MakeCode	(x=0X8A8B);
	OpHex		(x,	0);
	MakeComm	(0X8A8D,	"write multiple spaces");
	MakeComm	(0X8A90,	"80 of them, to be exact to obliterate the status line");
	MakeCode	(x=0X8A90);
	OpDecimal	(x,	1);
	MakeComm	(0X8A93,	"- VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION\nAL = character, BH = display page - alpha mode\nBL = color of character (graphics mode, PCjr only)\nCX = number of times to write character");
	MakeCode	(x=0X8A93);
	OpHex		(x,	0);
	MakeComm	(0X8A97,	"- VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION\nAL = character, BH = display page - alpha mode\nBL = color of character (graphics mode, PCjr only)\nCX = number of times to write character");
	MakeCode	(x=0X8A97);
	OpHex		(x,	0);
	MakeCode	(x=0X8A99);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8A9C,	"is interactive mode on?");
	MakeCode	(x=0X8A9C);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8AA1,	"no");
	MakeCode	(x=0X8AA3);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8AA8,	"- VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)");
	MakeCode	(x=0X8AA8);
	OpHex		(x,	0);
	MakeComm	(0X8AAA,	"restore original cursor position");
	MakeComm	(0X8AAD,	"- VIDEO - SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number ");
	MakeCode	(x=0X8AAD);
	OpHex		(x,	0);
	MakeComm	(0X8AB1,	"advances ES:SI/CX past the current token");
	MakeCode	(0X8AB1);
	MakeName	(0X8AB1,	"skip_token");
	MakeComm	(0X8ABB,	"CR");
	MakeName	(0X8ABB,	"skip_check_eol");
	MakeComm	(0X8ABF,	"LF");
	MakeCode	(0X8AC6);
	MakeName	(0X8AC7,	"skip_token_done");
	MakeComm	(0X8AC8,	"advances ES:SI/CX past the current delimiter");
	MakeCode	(0X8AC8);
	MakeName	(0X8AC8,	"skip_delim");
	MakeComm	(0X8AD7,	"LF");
	MakeCode	(0X8AD7);
	MakeName	(0X8AD7,	"skip_opt_line");
	MakeName	(0X8ADB,	"skip_line");
	MakeComm	(0X8AE0,	"LF");
	MakeName	(0X8AE4,	"skip_line_done");
	MakeComm	(0X8AE5,	"return binary equivalent of numeric string\nBX = result");
	MakeCode	(0X8AE5);
	MakeName	(0X8AE5,	"get_number");
	MakeComm	(0X8AEC,	"convert to value");
	MakeComm	(0X8AEE,	"no more number");
	MakeCode	(x=0X8AF5);
	OpDecimal	(x,	1);
	MakeCode	(0X8B06);
	MakeComm	(0X8B07,	"return next character,\nadvance ES:SI, and decrement CX\n(use SUB to set carry,zero)");
	MakeCode	(0X8B07);
	MakeName	(0X8B07,	"get_char");
	MakeComm	(0X8B0C,	"es\nlodsb");
	MakeComm	(0X8B11,	"restore CX to zero\nleave carry set, zero not set");
	MakeCode	(0X8B11);
	MakeName	(0X8B14,	"nearby_ret");
	MakeComm	(0X8B15,	"ask user whether to execute current config.sys command\nanswer no to everything?");
	MakeCode	(x=0X8B15);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeName	(0X8B15,	"query_user");
	MakeComm	(0X8B1A,	"no");
	MakeComm	(0X8B1C,	"yes");
	MakeComm	(0X8B1F,	"answer yes to everything?");
	MakeCode	(x=0X8B1F);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X8B24,	"yes (and return carry clear!)");
	MakeCode	(x=0X8B27);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8B2A,	"query every command?");
	MakeCode	(x=0X8B2A);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X8B2F,	"yes");
	MakeComm	(0X8B31,	"CONFIG_OPTION_QUERY");
	MakeCode	(x=0X8B31);
	OpHex		(x,	1);
	MakeComm	(0X8B38,	"save pointer to rest of CONFIG.SYS line");
	MakeCode	(0X8B38);
	MakeCode	(x=0X8B39);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8B3C,	"~CONFIG_OPTION_QUERY");
	MakeCode	(x=0X8B3C);
	OpHex		(x,	1);
	MakeComm	(0X8B3E,	"config_cmd must have been 0");
	MakeComm	(0X8B40,	"save config_cmd in DH");
	MakeComm	(0X8B42,	"0");
	MakeCode	(x=0X8B44);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8B47,	"get size of current keyword");
	MakeComm	(0X8B4B,	"end of table");
	MakeComm	(0X8B4E,	"match?");
	MakeComm	(0X8B50,	"yes");
	MakeComm	(0X8B52,	"otherwise, skip this command code");
	MakeComm	(0X8B55,	"loop");
	MakeCode	(0X8B57);
	MakeComm	(0X8B5C,	"STD_CON_OUTPUT");
	MakeComm	(0X8B63,	"DOS - DISPLAY OUTPUT\nDL = character to send to standard output");
	MakeCode	(x=0X8B63);
	OpHex		(x,	0);
	MakeCode	(x=0X8B67);
	OpChr		(x,	1);
	MakeComm	(0X8B69,	"CONFIG_SET");
	MakeCode	(x=0X8B69);
	OpChr		(x,	1);
	MakeComm	(0X8B6E,	"for SET commands, don't display a '='");
	MakeComm	(0X8B70,	"DOS - DISPLAY OUTPUT\nDL = character to send to standard output");
	MakeCode	(x=0X8B70);
	OpHex		(x,	0);
	MakeComm	(0X8B7A,	"control code?");
	MakeComm	(0X8B7C,	"yes, assume end of line");
	MakeCode	(x=0X8B88);
	OpHex		(x,	1);
	MakeComm	(0X8B8A,	"DOS - DISPLAY OUTPUT\nDL = character to send to standard output");
	MakeCode	(x=0X8B8A);
	OpHex		(x,	0);
	MakeCode	(x=0X8B8E);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8B96,	"KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY\nReturn: AH = scan code, AL = character");
	MakeCode	(x=0X8B96);
	OpHex		(x,	0);
	MakeComm	(0X8B98,	"is it a function key?");
	MakeComm	(0X8B9A,	"no");
	MakeComm	(0X8B9C,	"F5 function key?");
	MakeCode	(x=0X8B9C);
	OpHex		(x,	1);
	MakeComm	(0X8B9F,	"no");
	MakeComm	(0X8BA4,	"no more queries");
	MakeCode	(x=0X8BA4);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X8BAB,	"~20h ; converting to upper case\nconverting to upper case\nverify character is legal");
	MakeCode	(x=0X8BAB);
	OpHex		(x,	1);
	MakeCode	(x=0X8BAD);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X8BB3);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X8BB9);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8BBE,	"don't allow Esc on this query");
	MakeComm	(0X8BC0,	"Esc?");
	MakeComm	(0X8BC4,	"no more interactive boot prompts");
	MakeCode	(x=0X8BC4);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeCode	(x=0X8BC9);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8BCF,	"restore pointer to rest of CONFIG.SYS line\nprocess line?");
	MakeCode	(x=0X8BD0);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8BD4,	"no");
	MakeComm	(0X8BD7,	"just do the command");
	MakeCode	(0X8BD9);
	MakeComm	(0X8BDA,	"CONFIG_REM ; fake out the rest of sysinit's processing");
	MakeComm	(0X8BDE,	"displays multi-config error conditions");
	MakeCode	(0X8BDE);
	MakeName	(0X8BDE,	"print_error");
	MakeCode	(x=0X8BF3);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8BF9,	"flush input buffer, then wait for key");
	MakeCode	(x=0X8BF9);
	OpHex		(x,	1);
	MakeComm	(0X8BFC,	"DOS - CLEAR KEYBOARD BUFFER\nAL must be 01h, 06h, 07h, 08h, or 0Ah.");
	MakeCode	(x=0X8BFC);
	OpHex		(x,	0);
	MakeComm	(0X8BFE,	"extended key?");
	MakeComm	(0X8C00,	"no");
	MakeComm	(0X8C02,	"yes, eat it too");
	MakeCode	(x=0X8C02);
	OpHex		(x,	1);
	MakeComm	(0X8C04,	"DOS - DIRECT STDIN INPUT, NO ECHO");
	MakeCode	(x=0X8C04);
	OpHex		(x,	0);
	MakeCode	(x=0X8C06);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8C12,	"This function is very simple:\nit merely prepends a \"/D\" to the command-line for the shell;\nthis (undocumented) switch disables AUTOEXEC.BAT processing\nand the date/time prompt that is usually displayed\nwhen there's no AUTOEXEC.BAT.");
	MakeCode	(x=0X8C12);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeName	(0X8C12,	"disable_autoexec");
	MakeCode	(x=0X8C19);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeCode	(x=0X8C20);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X8C25,	"[bDefBlock] = 1");
	MakeCode	(x=0X8C25);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X8C2B,	"2044h ; 'D ' (NASM syntax)");
	MakeCode	(x=0X8C2B);
	OpChr		(x,	1);
	MakeComm	(0X8C2E,	"get default switchchar");
	MakeCode	(x=0X8C2E);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeName	(0X8C2E,	"dae_1");
	MakeCode	(x=0X8C35);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8C39,	"BX == command-line length");
	MakeCode	(x=0X8C40);
	OpDecimal	(x,	1);
	MakeComm	(0X8C43,	"\nupdate length");
	MakeCode	(x=0X8C45);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X8C49,	"\nmake sure we move the NULL too");
	MakeCode	(x=0X8C49);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8C4D,	"(just for consistency sake)");
	MakeComm	(0X8C59,	"'D ' ; /D is stuffed into place now");
	MakeName	(0X8C5C,	"disable_exit");
	MakeCode	(x=0X8C5D);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X8C5D,	"CheckQueryOpt");
	MakeCode	(x=0X8C64);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeCode	(x=0X8C6B);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	OpHex		(x,	1);
	MakeComm	(0X8C70,	"'Y ' ; 2059h");
	MakeCode	(x=0X8C70);
	OpChr		(x,	1);
	MakeComm	(0X8C75,	"cr");
	MakeCode	(0X8C75);
	MakeName	(0X8C75,	"any_delim");
	MakeComm	(0X8C79,	"lf");
	MakeCode	(x=0X8C7D);
	OpChr		(x,	1);
	MakeCode	(x=0X8C81);
	OpChr		(x,	1);
	MakeComm	(0X8C85,	"ibm will assume \"/\" as an delimeter");
	MakeCode	(x=0X8C85);
	OpChr		(x,	1);
	MakeName	(0X8C85,	"delim");
	MakeComm	(0X8C89,	"special case for sysinit!");
	MakeComm	(0X8C8D,	"space");
	MakeName	(0X8C8D,	"org_delim");
	MakeComm	(0X8C91,	"tab");
	MakeCode	(x=0X8C95);
	OpChr		(x,	1);
	MakeCode	(x=0X8C99);
	OpChr		(x,	1);
	MakeCode	(x=0X8C9D);
	OpChr		(x,	1);
	MakeName	(0X8CA0,	"delim_ret");
	MakeCode	(0X8CA1);
	MakeName	(0X8CA1,	"newline");
	MakeComm	(0X8CA4,	"no char");
	MakeComm	(0X8CA6,	"lf");
	MakeComm	(0X8CAD,	"al = first character of next line (if cf=0)");
	MakeCode	(0X8CAE);
	MakeName	(0X8CAE,	"mapcase");
	MakeCode	(x=0X8CB6);
	OpChr		(x,	1);
	MakeCode	(x=0X8CBA);
	OpChr		(x,	1);
	MakeComm	(0X8CBE,	"convert to upper-case (and al,0DFh)");
	MakeCode	(x=0X8CBE);
	OpHex		(x,	1);
	MakeComm	(0X8CC3,	"CONFIG_SET ; preserve case for part of the line?");
	MakeCode	(x=0X8CC3);
	OpChr		(x,	1);
	MakeComm	(0X8CC6,	"no, just check for end-of-line");
	MakeComm	(0X8CC8,	"separator between SET var and value?");
	MakeCode	(x=0X8CC8);
	OpChr		(x,	1);
	MakeComm	(0X8CCA,	"yes\n(we don't want to upper-case\nanything after the \"=\" in a SET)");
	MakeComm	(0X8CCC,	"cr");
	MakeComm	(0X8CD0,	"lf");
	MakeComm	(0X8CDA,	"round the values in memlo and memhi\nto paragraph boundary.\nperform bounds check.");
	MakeCode	(0X8CDA);
	MakeName	(0X8CDA,	"round");
	MakeComm	(0X8CDF,	"para round up");
	MakeComm	(0X8CEE,	"ax = new memhi");
	MakeComm	(0X8CF2,	"if new memhi >= alloclim, error");
	MakeComm	(0X8CF9,	"for_devmark");
	MakeCode	(x=0X8CF9);
	OpHex		(x,	1);
	MakeComm	(0X8D0D,	"mov [es:devmark.size],ax ; paragraph");
	MakeComm	(0X8D11,	"~2 ; not 2\nnot_for_devmark");
	MakeCode	(x=0X8D11);
	OpHex		(x,	1);
	MakeCode	(x=0X8D1C);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeName	(0X8D1C,	"mem_err");
	MakeCode	(0X8D27);
	MakeName	(0X8D27,	"calldev");
	MakeComm	(0X8D2C,	"do a little relocation");
	MakeCode	(x=0X8D4A);
	OpChr		(x,	1);
	MakeName	(0X8D4A,	"todigit");
	MakeCode	(0X8D54);
	MakeComm	(0X8D56,	"getnum parses a decimal number.\nreturns it in ax, sets zero flag if ax = 0\n(may be considered an error),\nif number is bad carry is set, zero is set, ax=0.\n;;");
	MakeCode	(0X8D56);
	MakeName	(0X8D56,	"getnum");
	MakeComm	(0X8D57,	"running count is zero");
	MakeComm	(0X8D59,	"do we have a digit ?");
	MakeComm	(0X8D5C,	"no, bomb");
	MakeComm	(0X8D5E,	"put total in ax");
	MakeComm	(0X8D5F,	"save digit (0 to 9)");
	MakeComm	(0X8D60,	"base of arithmetic");
	MakeCode	(x=0X8D60);
	OpDecimal	(x,	1);
	MakeComm	(0X8D63,	"shift by one decimal digit");
	MakeComm	(0X8D65,	"get back digit (0 to 9)");
	MakeComm	(0X8D66,	"get total");
	MakeComm	(0X8D68,	"make that 16 bits");
	MakeComm	(0X8D6B,	"too big a number");
	MakeComm	(0X8D6D,	"stash total");
	MakeComm	(0X8D6E,	"get next digit");
	MakeComm	(0X8D71,	"no more characters");
	MakeComm	(0X8D73,	"space?");
	MakeCode	(x=0X8D73);
	OpChr		(x,	1);
	MakeComm	(0X8D75,	"then end of digits");
	MakeComm	(0X8D77,	"',' is a seperator!!!");
	MakeCode	(x=0X8D77);
	OpChr		(x,	1);
	MakeComm	(0X8D79,	"then end of digits.");
	MakeComm	(0X8D7B,	"tab");
	MakeComm	(0X8D7F,	"allow 0 or special separators");
	MakeComm	(0X8D86,	"see if another switch follows");
	MakeCode	(x=0X8D86);
	OpChr		(x,	1);
	MakeComm	(0X8D88,	"cas - remnant of old bad code");
	MakeComm	(0X8D89,	"(04/08/2023 - Erdogan Tan - 'nop,nop' is not neded)");
	MakeComm	(0X8D8C,	"lf ; line-feed?");
	MakeComm	(0X8D90,	"cr ; carriage return?");
	MakeComm	(0X8D94,	"end of line separator?");
	MakeComm	(0X8D96,	"no, try as a valid char...");
	MakeComm	(0X8D98,	"one more character to s...");
	MakeComm	(0X8D9D,	"clears carry, sets zero accordingly");
	MakeCode	(0X8DA8);
	MakeComm	(0X8DAE,	"set zero flag, and ax = 0");
	MakeComm	(0X8DB1,	"and carry set");
	MakeComm	(0X8DB3,	"input: \n  es:di -> pointer to dos_country_cdpg_info\n  ds:0  -> buffer.\n     si = 0\n     ax = country id\n     dx = code page id. (if 0, then use ccsyscodepage as a default.)\n     bx = file handle\n  this routine can handle maximum 438 country_data entries.\noutput:\n  dos_country_cdpg_info set.\n  carry set if any file read failure or wrong information in the file.\n  carry set and cx = -1 if cannot find the matching country_id, \n        codepage_id in the file.");
	MakeCode	(0X8DB3);
	MakeName	(0X8DB3,	"setdoscountryinfo");
	MakeComm	(0X8DBA,	"read 512 bytes");
	MakeCode	(x=0X8DBA);
	OpDecimal	(x,	1);
	MakeComm	(0X8DBD,	"read the file header");
	MakeComm	(0X8DC6,	"db 0FFh,'COUNTRY'");
	MakeCode	(x=0X8DC6);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeComm	(0X8DC9,	"length of the signature");
	MakeComm	(0X8DD0,	"signature mismatch");
	MakeCode	(x=0X8DD2);
	OpDecimal	(x,	1);
	MakeComm	(0X8DD5,	"si -> county info type\nonly accept type 1 (currently only 1 header type)");
	MakeComm	(0X8DD8,	"cannot proceed. error return");
	MakeComm	(0X8DDA,	"si -> file offset");
	MakeComm	(0X8DDB,	"get the info file offset.");
	MakeComm	(0X8DE0,	"read 6144 bytes.");
	MakeCode	(x=0X8DE0);
	OpDecimal	(x,	1);
	MakeComm	(0X8DE3,	"read info");
	MakeComm	(0X8DE8,	"get the # of country, codepage combination entries");
	MakeComm	(0X8DEA,	"cannot handle more than 438 entries.");
	MakeCode	(x=0X8DEA);
	OpDecimal	(x,	1);
	MakeComm	(0X8DF1,	"si -> entry information packet");
	MakeComm	(0X8DF2,	"restore code page id");
	MakeComm	(0X8DF3,	"restore country id");
	MakeComm	(0X8DF4,	"search for desired country_id,codepage_id.");
	MakeComm	(0X8DF5,	"compare country_id");
	MakeComm	(0X8DFA,	"no user specified code page ?");
	MakeComm	(0X8DFD,	"then no need to match code page id.");
	MakeComm	(0X8DFF,	"compare code page id");
	MakeComm	(0X8E04,	"next entry");
	MakeComm	(0X8E07,	"take a word for size of entry itself");
	MakeComm	(0X8E0A,	"-1 ; signals that bad country id entered.");
	MakeCode	(0X8E0F);
	MakeComm	(0X8E14,	"use the code_page_id of the country_id found.");
	MakeCode	(0X8E14);
	MakeComm	(0X8E17,	"save code page id for this country.");
	MakeComm	(0X8E1C,	"get the file offset of country data");
	MakeCode	(x=0X8E1C);
	OpDecimal	(x,	1);
	MakeCode	(x=0X8E1F);
	OpDecimal	(x,	1);
	MakeComm	(0X8E22,	"read 512 bytes");
	MakeCode	(x=0X8E22);
	OpDecimal	(x,	1);
	MakeComm	(0X8E2A,	"get the number of entries to handle.");
	MakeComm	(0X8E2D,	"si -> first entry");
	MakeComm	(0X8E2E,	"es:di -> dos_country_cdpg_info");
	MakeComm	(0X8E2F,	"save # of entry left");
	MakeComm	(0X8E30,	"si -> current entry in control buffer");
	MakeComm	(0X8E31,	"get data entry id");
	MakeComm	(0X8E34,	"get the address of destination in es:di");
	MakeComm	(0X8E37,	"no matching data entry id in dos");
	MakeComm	(0X8E39,	"get offset of data");
	MakeComm	(0X8E43,	"DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)\nAL = method: offset from beginning of file");
	MakeCode	(x=0X8E43);
	OpHex		(x,	0);
	MakeComm	(0X8E45,	"\nread the country.sys data");
	MakeComm	(0X8E47,	"start of data buffer");
	MakeCode	(x=0X8E47);
	OpDecimal	(x,	1);
	MakeComm	(0X8E4A,	"read 20 bytes only. we only need to");
	MakeCode	(x=0X8E4A);
	OpDecimal	(x,	1);
	MakeComm	(0X8E4D,	"look at the length of the data in the file.");
	MakeCode	(x=0X8E4D);
	OpHex		(x,	1);
	MakeComm	(0X8E50,	"DOS - 2+ - READ FROM FILE WITH HANDLE\nBX = file handle, CX = number of bytes to read\nDS:DX -> buffer");
	MakeCode	(x=0X8E50);
	OpHex		(x,	0);
	MakeComm	(0X8E52,	"read failure");
	MakeComm	(0X8E58,	"get offset of data again.");
	MakeComm	(0X8E5E,	"move pointer back again");
	MakeComm	(0X8E62,	"DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)\nAL = method: offset from beginning of file");
	MakeCode	(x=0X8E62);
	OpHex		(x,	0);
	MakeComm	(0X8E67,	"(512+8) ; get length of the data from the file");
	MakeCode	(x=0X8E67);
	OpDecimal	(x,	1);
	MakeComm	(0X8E6D,	"start of data buffer");
	MakeCode	(x=0X8E6D);
	OpDecimal	(x,	1);
	MakeComm	(0X8E70,	"signature + a word for the length itself");
	MakeCode	(x=0X8E70);
	OpDecimal	(x,	1);
	MakeComm	(0X8E73,	"read the data from the file.");
	MakeCode	(x=0X8E73);
	OpHex		(x,	1);
	MakeComm	(0X8E76,	"DOS - 2+ - READ FROM FILE WITH HANDLE\nBX = file handle, CX = number of bytes to read\nDS:DX -> buffer");
	MakeCode	(x=0X8E76);
	OpHex		(x,	0);
	MakeComm	(0X8E7E,	"save data id for future use.");
	MakeComm	(0X8E81,	"(512+8) ; si-> data buffer + id tag field");
	MakeCode	(x=0X8E81);
	OpDecimal	(x,	1);
	MakeComm	(0X8E84,	"get the length of the file");
	MakeComm	(0X8E86,	"take care of a word for lenght of tab itself.");
	MakeComm	(0X8E88,	"(2048-512-8) ; fit into the buffer?");
	MakeCode	(x=0X8E88);
	OpDecimal	(x,	1);
	MakeComm	(0X8E91,	"SetCountryInfo ; is the data for setcountryinfo table?");
	MakeComm	(0X8E93,	"no, don't worry");
	MakeComm	(0X8E95,	"\n[es:di+country_cdpg_info.ccMono_Ptr\n -country_cdpg_info.ccCountryInfoLen]");
	MakeCode	(x=0X8E95);
	OpDecimal	(x,	0);
	MakeComm	(0X8E99,	"\n[es:di+country_cdpg_info.ccMono_Ptr\n -country_cdpg_info.ccCountryInfoLen+2]\n\nat this time di -> cccountryinfolen");
	MakeCode	(x=0X8E99);
	OpDecimal	(x,	0);
	MakeComm	(0X8E9F,	"do not use the code page info in country_info");
	MakeComm	(0X8EA3,	"use the saved one for this !!!");
	MakeComm	(0X8EA7,	"copy the table into dos");
	MakeComm	(0X8EA9,	"SetCountryInfo ; was the ccmono_ptr saved?");
	MakeComm	(0X8EAE,	"\n[es:di+country_cdpg_info.ccMono_Ptr\n -country_cdpg_info.ccCountryInfoLen+2]");
	MakeCode	(x=0X8EAE);
	OpDecimal	(x,	0);
	MakeComm	(0X8EB2,	"\n[es:di+country_cdpg_info.ccMono_Ptr\n -country_cdpg_info.ccCountryInfoLen]");
	MakeCode	(x=0X8EB2);
	OpDecimal	(x,	0);
	MakeComm	(0X8EB6,	"restore control buffer pointer");
	MakeComm	(0X8EB7,	"restore # of entries left");
	MakeComm	(0X8EB8,	"restore pointer to dso_country_cdpg");
	MakeComm	(0X8EB9,	"try to get the next entry");
	MakeComm	(0X8EBC,	"take a word of entry length itself");
	MakeCode	(0X8EC6);
	MakeComm	(0X8EC7,	"SetDBCS ; dbcs vector set?");
	MakeCode	(0X8EC7);
	MakeName	(0X8EC7,	"setdbcs_before_copy");
	MakeComm	(0X8EC9,	"jump if not");
	MakeComm	(0X8ECB,	"zero byte data block?");
	MakeComm	(0X8ECF,	"jump if so");
	MakeComm	(0X8ED4,	"load block length");
	MakeComm	(0X8ED7,	"points actual data");
	MakeComm	(0X8EDA,	"fill bytes");
	MakeComm	(0X8EDC,	"clear data block");
	MakeComm	(0X8EE2,	"get the destination address\n in the dos country info table.");
	MakeCode	(0X8EE2);
	MakeName	(0X8EE2,	"getcountrydestination");
	MakeComm	(0X8EE3,	"country_cdpg_info.ccNumber_of_entries\nskip the reserved area, syscodepage etc.");
	MakeCode	(x=0X8EE3);
	OpDecimal	(x,	1);
	MakeComm	(0X8EE6,	"get the number of entries");
	MakeComm	(0X8EEA,	"si -> the first start entry id");
	MakeComm	(0X8EF0,	"SetCountryInfo ; was it setcountryinfo entry?");
	MakeComm	(0X8EF6,	"next data id");
	MakeComm	(0X8EFB,	"NEW_COUNTRY_SIZE+3 ; next data id");
	MakeCode	(x=0X8EFB);
	OpDecimal	(x,	1);
	MakeComm	(0X8F03,	"SetCountryInfo ; select country info?");
	MakeCode	(0X8F03);
	MakeComm	(0X8F07,	"now di -> cccountryinfolen");
	MakeComm	(0X8F0A,	"get the destination in es:di");
	MakeCode	(0X8F0A);
	MakeComm	(0X8F10,	"# of bytes to read");
	MakeCode	(0X8F10);
	MakeName	(0X8F10,	"readincontrolbuffer");
	MakeComm	(0X8F15,	"DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)\nAL = method: offset from beginning of file");
	MakeCode	(x=0X8F15);
	OpHex		(x,	0);
	MakeComm	(0X8F17,	"# of bytes to read");
	MakeComm	(0X8F1A,	"ds:dx -> control buffer");
	MakeComm	(0X8F1E,	"read into the buffer\nshould be less than 1024 bytes.");
	MakeCode	(x=0X8F1E);
	OpHex		(x,	1);
	MakeComm	(0X8F21,	"DOS - 2+ - READ FROM FILE WITH HANDLE\nBX = file handle, CX = number of bytes to read\nDS:DX -> buffer");
	MakeCode	(x=0X8F21);
	OpHex		(x,	0);
	MakeComm	(0X8F24,	"! this procedure is not called from anywhere !\nErdogan Tan - 04/08/2023");
	MakeCode	(0X8F24);
	MakeName	(0X8F24,	"set_country_path");
	MakeCode	(x=0X8F34);
	OpHex		(x,	1);
	MakeName	(0X8F34,	"scp_default_drv");
	MakeComm	(0X8F36,	"DOS - GET DEFAULT DISK NUMBER");
	MakeCode	(x=0X8F36);
	OpHex		(x,	0);
	MakeCode	(x=0X8F38);
	OpChr		(x,	1);
	MakeName	(0X8F3A,	"scp_setdrv");
	MakeCode	(x=0X8F3E);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(x=0X8F43);
	OpChr		(x,	1);
	MakeCode	(x=0X8F47);
	OpChr		(x,	1);
	MakeCode	(0X8F4D);
	MakeName	(0X8F4D,	"scp_root_dir");
	MakeName	(0X8F4E,	"scp_path");
	MakeCode	(x=0X8F51);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X8F5A);
	MakeName	(0X8F5A,	"chk_drive_letter");
	MakeCode	(x=0X8F5B);
	OpChr		(x,	1);
	MakeCode	(x=0X8F60);
	OpChr		(x,	1);
	MakeCode	(x=0X8F65);
	OpChr		(x,	1);
	MakeCode	(0X8F6D);
	MakeCode	(0X8F70);
	MakeName	(0X8F70,	"move_asciiz");
	MakeComm	(0X8F71,	"was it 0?");
	MakeCode	(0X8F78);
	MakeName	(0X8F78,	"badfil");
	MakeCode	(x=0X8F7C);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeName	(0X8F7C,	"badload");
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_6(void) {
        auto x;
#define id x

	MakeCode	(x=0X8F7F);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeName	(0X8F82,	"prnerr");
	MakeCode	(x=0X8F8E);
	OpHex		(x,	1);
	MakeComm	(0X8F90,	"DOS - DISPLAY OUTPUT\nDL = character to send to standard output");
	MakeCode	(x=0X8F90);
	OpHex		(x,	0);
	MakeCode	(0X8F95);
	MakeCode	(x=0X8FA6);
	OpHex		(x,	1);
	MakeName	(0X8FA6,	"print");
	MakeComm	(0X8FA8,	"DOS - PRINT STRING\nDS:DX -> string terminated by \"$\"");
	MakeCode	(x=0X8FA8);
	OpHex		(x,	0);
	MakeCode	(0X8FAB);
	MakeName	(0X8FAB,	"open_dev");
	MakeCode	(x=0X8FB0);
	OpOff		(x,	1,	0X4030);
	OpOff		(x,	129,	0X4030);
	MakeCode	(0X8FB7);
	MakeCode	(x=0X8FBB);
	OpHex		(x,	1);
	MakeComm	(0X8FBD,	"DOS - 2+ - IOCTL - GET DEVICE INFORMATION\nBX = file or device handle");
	MakeCode	(x=0X8FBD);
	OpHex		(x,	0);
	MakeCode	(x=0X8FBF);
	OpHex		(x,	1);
	MakeCode	(x=0X8FC4);
	OpHex		(x,	1);
	MakeComm	(0X8FC6,	"DOS - 2+ - CLOSE A FILE WITH HANDLE\nBX = file handle");
	MakeCode	(x=0X8FC6);
	OpHex		(x,	0);
	MakeComm	(0X8FCA,	"OPEN");
	MakeCode	(x=0X8FCA);
	OpHex		(x,	1);
	MakeName	(0X8FCA,	"open_file");
	MakeComm	(0X8FCD,	"DOS - 2+ - OPEN DISK FILE WITH HANDLE\nDS:DX -> ASCIZ filename\nAL = access mode\n0 - read");
	MakeCode	(x=0X8FCD);
	OpHex		(x,	0);
	MakeComm	(0X8FD0,	"fail the system call");
	MakeCode	(0X8FD0);
	MakeName	(0X8FD0,	"int24");
	MakeComm	(0X8FD2,	"return back to dos.");
	MakeStr		(0X8FD3,	0X9048);
	MakeName	(0X8FD3,	"MsDosVersion6Copyr");
	MakeStr		(0X9048,	0X904C);
	MakeName	(0X9048,	"nuldev");
	MakeStr		(0X904C,	0X9050);
	MakeName	(0X904C,	"condev");
	MakeStr		(0X9050,	0X9054);
	MakeName	(0X9050,	"auxdev");
	MakeStr		(0X9054,	0X9058);
	MakeName	(0X9054,	"prndev");
	MakeStr		(0X9058,	0X9064);
	MakeName	(0X9058,	"config");
	MakeStr		(0X9064,	0X9066);
	MakeName	(0X9064,	"cntry_drv");
	MakeByte	(x=0X9066);
	OpChr		(x,	0);
	MakeName	(0X9066,	"cntry_root");
	MakeStr		(0X9067,	0X9073);
	MakeName	(0X9067,	"cntry_path");
	MakeByte	(x=0X9073);
	MakeArray	(x,	0X34);
	OpDecimal	(x,	0);
	MakeByte	(0X90A7);
	MakeName	(0X90A7,	"country_file_signature");
	MakeStr		(0X90A8,	0X90AF);
	MakeWord	(0X90AF);
	MakeName	(0X90AF,	"cntrycodepage_id");
	MakeComm	(0X90B1,	"non-zero if non-std shell specified");
	MakeByte	(0X90B1);
	MakeName	(0X90B1,	"newcmd");
	MakeComm	(0X90B2,	"must precede commnd\nsize of commnd line (excl. null)\n50C4h-5084h = 40h = 64");
	MakeByte	(x=0X90B2);
	MakeArray	(x,	0X2);
	OpDecimal	(x,	0);
	MakeName	(0X90B2,	"tmplate");
	MakeComm	(0X90B3,	"must precede commnd\nsize of commnd line (excl. null)\n50C4h-5084h = 40h = 64");
	MakeStr		(0X90B4,	0X90C1);
	MakeName	(0X90B4,	"commnd");
	MakeByte	(x=0X90C1);
	MakeArray	(x,	0X32);
	OpDecimal	(x,	0);
	MakeByte	(0X90F3);
	MakeName	(0X90F3,	"commnd_63");
	MakeComm	(0X90F4,	"alternate commands to exec");
	MakeStr		(0X90F4,	0X9101);
	MakeName	(0X90F4,	"commnd2");
	MakeComm	(0X9101,	"followed by their respective alternate command lines");
	MakeStr		(0X9101,	0X9105);
	MakeStr		(0X9105,	0X9118);
	MakeName	(0X9105,	"commnd3");
	MakeByte	(x=0X9118);
	OpDecimal	(x,	0);
	MakeStr		(0X9119,	0X9125);
	MakeStr		(0X9125,	0X9136);
	MakeName	(0X9125,	"commnd4");
	MakeStr		(0X9137,	0X9141);
	MakeByte	(0X9141);
	MakeName	(0X9141,	"def_swchr");
	MakeComm	(0X9142,	"default command.com args");
	MakeStr		(0X9142,	0X9145);
	MakeName	(0X9142,	"command_line");
	MakeByte	(x=0X9145);
	MakeArray	(x,	0X7B);
	OpDecimal	(x,	0);
	MakeByte	(0X91C0);
	MakeName	(0X91C0,	"command_line_126");
	MakeByte	(0X91C1);
	MakeByte	(x=0X91C2);
	MakeArray	(x,	0X40);
	OpDecimal	(x,	0);
	MakeName	(0X91C2,	"pathstring");
	MakeByte	(0X9202);
	MakeName	(0X9202,	"dae_flag");
	MakeComm	(0X9203,	"default fgnd/bgnd color");
	MakeByte	(0X9203);
	MakeName	(0X9203,	"bMenuColor");
	MakeComm	(0X9204,	"menu video page (KEEP AFTER bMenuColor)");
	MakeByte	(0X9204);
	MakeName	(0X9204,	"bMenuPage");
	MakeComm	(0X9205,	"video page function # (KEEP AFTER bMenuPage)");
	MakeByte	(0X9205);
	MakeComm	(0X9206,	"ending column on status line");
	MakeByte	(0X9206);
	MakeName	(0X9206,	"bLastCol");
	MakeComm	(0X9207,	"row # of status line (KEEP AFTER bLastCol)");
	MakeByte	(x=0X9207);
	OpDecimal	(x,	0);
	MakeName	(0X9207,	"bLastRow");
	MakeComm	(0X9208,	"1=disable clean/interactive\n2=disable default 2-second delay");
	MakeByte	(0X9208);
	MakeName	(0X9208,	"bDisableUI");
	MakeComm	(0X9209,	"value saved from BIOS data area");
	MakeByte	(0X9209);
	MakeName	(0X9209,	"bCRTPage");
	MakeComm	(0X920A,	"value saved from BIOS data area");
	MakeWord	(0X920A);
	MakeName	(0X920A,	"wCRTStart");
	MakeComm	(0X920C,	"0=off, 1=prompt all, 2=prompt none, 4=skip all");
	MakeByte	(0X920C);
	MakeName	(0X920C,	"bQueryOpt");
	MakeComm	(0X920D,	"default block #");
	MakeByte	(0X920D);
	MakeName	(0X920D,	"bDefBlock");
	MakeComm	(0X920E,	"maximum block #");
	MakeByte	(0X920E);
	MakeName	(0X920E,	"bMaxBlock");
	MakeComm	(0X920F,	"offset of name of default block (if any)");
	MakeWord	(0X920F);
	MakeName	(0X920F,	"offDefBlock");
	MakeComm	(0X9211,	"# of seconds for timeout (-1 == indefinite)");
	MakeByte	(0X9211);
	MakeName	(0X9211,	"secTimeOut");
	MakeComm	(0X9212,	"# of seconds elapsed so far (KEEP AFTER secTimeOut)");
	MakeByte	(0X9212);
	MakeName	(0X9212,	"secElapsed");
	MakeComm	(0X9213,	"times MAX_MULTI_CONFIG+1 db 0\narray of block types");
	MakeByte	(x=0X9213);
	MakeArray	(x,	0XA);
	OpDecimal	(x,	0);
	MakeName	(0X9213,	"abBlockType");
	MakeComm	(0X921D,	"times MAX_MULTI_CONFIG+1 dw 0\narray of offsets of block names");
	MakeWord	(x=0X921D);
	MakeArray	(x,	0XA);
	OpDecimal	(x,	0);
	MakeName	(0X921D,	"aoffBlockName");
	MakeComm	(0X9231,	"times MAX_MULTI_CONFIG+1 dw 0\narray of offsets of block descriptions");
	MakeWord	(x=0X9231);
	MakeArray	(x,	0XA);
	OpDecimal	(x,	0);
	MakeName	(0X9231,	"aoffBlockDesc");
	MakeStr		(0X9245,	0X924D);
	MakeName	(0X9245,	"szBoot");
	MakeStr		(0X924D,	0X9252);
	MakeName	(0X924D,	"szMenu");
	MakeStr		(0X9252,	0X9259);
	MakeName	(0X9252,	"szCommon");
	MakeComm	(0X9259,	"CONFIG.SYS Command Table\nCONFIG_BEGIN");
	MakeStr		(0X9259,	0X925C);
	MakeName	(0X9259,	"comtab");
	MakeComm	(0X925C,	"CONFIG_BREAK");
	MakeStr		(0X925C,	0X9263);
	MakeName	(0X925C,	"aBreak");
	MakeComm	(0X9263,	"CONFIG_BUFFERS");
	MakeStr		(0X9263,	0X926C);
	MakeName	(0X9263,	"aBuffers");
	MakeComm	(0X926C,	"CONFIG_COMMENT");
	MakeStr		(0X926C,	0X9275);
	MakeName	(0X926C,	"aComment");
	MakeComm	(0X9275,	"CONFIG_COUNTRY");
	MakeStr		(0X9275,	0X927E);
	MakeName	(0X9275,	"aCountry");
	MakeComm	(0X927E,	"CONFIG_DEVICE");
	MakeStr		(0X927E,	0X9286);
	MakeName	(0X927E,	"aDevice");
	MakeComm	(0X9286,	"CONFIG_DEVICEHIGH");
	MakeStr		(0X9286,	0X9292);
	MakeName	(0X9286,	"aDevicehigh");
	MakeComm	(0X9292,	"CONFIG_DOS");
	MakeStr		(0X9292,	0X9297);
	MakeName	(0X9292,	"aDos");
	MakeComm	(0X9297,	"CONFIG_DRIVPARM");
	MakeStr		(0X9297,	0X92A1);
	MakeName	(0X9297,	"aDrivparm");
	MakeComm	(0X92A1,	"CONFIG_FCBS");
	MakeStr		(0X92A1,	0X92A7);
	MakeName	(0X92A1,	"aFcbs");
	MakeComm	(0X92A7,	"CONFIG_FILES");
	MakeStr		(0X92A7,	0X92AE);
	MakeName	(0X92A7,	"aFiles");
	MakeComm	(0X92AE,	"CONFIG_INCLUDE");
	MakeStr		(0X92AE,	0X92B7);
	MakeName	(0X92AE,	"aInclude");
	MakeComm	(0X92B7,	"CONFIG_INSTALL");
	MakeStr		(0X92B7,	0X92C0);
	MakeName	(0X92B7,	"aInstall");
	MakeComm	(0X92C0,	"CONFIG_INSTALLHIGH");
	MakeStr		(0X92C0,	0X92CD);
	MakeName	(0X92C0,	"aInstallhigh");
	MakeComm	(0X92CD,	"CONFIG_LASTDRIVE");
	MakeStr		(0X92CD,	0X92D8);
	MakeName	(0X92CD,	"aLastdrive");
	MakeComm	(0X92D8,	"CONFIG_SUBMENU");
	MakeStr		(0X92D8,	0X92E1);
	MakeName	(0X92D8,	"aSubmenu");
	MakeComm	(0X92E1,	"CONFIG_MENUCOLOR");
	MakeStr		(0X92E1,	0X92EC);
	MakeName	(0X92E1,	"aMenucolor");
	MakeComm	(0X92EC,	"CONFIG_MENUDEFAULT");
	MakeStr		(0X92EC,	0X92F9);
	MakeName	(0X92EC,	"aMenudefault");
	MakeComm	(0X92F9,	"CONFIG_MENUITEM");
	MakeStr		(0X92F9,	0X9303);
	MakeName	(0X92F9,	"aMenuitem");
	MakeComm	(0X9303,	"CONFIG_MULTITRACK");
	MakeStr		(0X9303,	0X930F);
	MakeName	(0X9303,	"aMultitrack");
	MakeComm	(0X930F,	"CONFIG_NUMLOCK");
	MakeStr		(0X930F,	0X9318);
	MakeName	(0X930F,	"aNumlock");
	MakeComm	(0X9318,	"CONFIG_REM");
	MakeStr		(0X9318,	0X931D);
	MakeName	(0X9318,	"aRem0Set");
	MakeComm	(0X931D,	"CONFIG_SET");
	MakeStr		(0X931D,	0X9322);
	MakeName	(0X931D,	"aSet");
	MakeComm	(0X9322,	"CONFIG_SHELL");
	MakeStr		(0X9322,	0X9329);
	MakeName	(0X9322,	"aShell");
	MakeComm	(0X9329,	"CONFIG_STACKS");
	MakeStr		(0X9329,	0X9331);
	MakeName	(0X9329,	"aStacks");
	MakeComm	(0X9331,	"CONFIG_SWITCHES");
	MakeStr		(0X9331,	0X933B);
	MakeName	(0X9331,	"aSwitches");
	MakeComm	(0X933B,	"end of command table");
	MakeByte	(0X933B);
	MakeComm	(0X933C,	"deviceparameters");
	MakeByte	(0X933C);
	MakeName	(0X933C,	"devp_specialfunc");
	MakeByte	(0X933D);
	MakeName	(0X933D,	"devp_devtype");
	MakeWord	(0X933E);
	MakeName	(0X933E,	"devp_devattr");
	MakeWord	(x=0X9340);
	OpDecimal	(x,	0);
	MakeName	(0X9340,	"devp_cylinders");
	MakeByte	(0X9342);
	MakeComm	(0X9343,	"A_DEVICEPARAMETERS.DP_BPB\nbytes per sectors");
	MakeWord	(0X9343);
	MakeName	(0X9343,	"devp_bps");
	MakeByte	(0X9345);
	MakeArray	(0X9345,	0X6);
	MakeName	(0X9345,	"devp_secperclus");
	MakeWord	(0X934B);
	MakeName	(0X934B,	"devp_totalsecs");
	MakeByte	(0X934D);
	MakeArray	(0X934D,	0X3);
	MakeName	(0X934D,	"devp_mediaid");
	MakeWord	(0X9350);
	MakeName	(0X9350,	"devp_spt");
	MakeWord	(0X9352);
	MakeName	(0X9352,	"devp_heads");
	MakeByte	(x=0X9354);
	MakeArray	(x,	0XE);
	OpDecimal	(x,	0);
	MakeWord	(0X9362);
	MakeName	(0X9362,	"devp_trktblents");
	MakeByte	(x=0X9364);
	MakeArray	(x,	0XFC);
	OpDecimal	(x,	0);
	MakeWord	(0X9460);
	MakeName	(0X9460,	"hlim");
	MakeWord	(0X9462);
	MakeName	(0X9462,	"slim");
	MakeByte	(0X9464);
	MakeName	(0X9464,	"drive");
	MakeWord	(0X9465);
	MakeName	(0X9465,	"switches");
	MakeComm	(0X9467,	"48 tpi diskettes");
	MakeWord	(x=0X9467);
	OpDecimal	(x,	0);
	MakeName	(0X9467,	"_bpb48t");
	MakeByte	(0X9469);
	MakeWord	(0X946A);
	MakeByte	(0X946C);
	MakeWord	(x=0X946D);
	OpDecimal	(x,	0);
	MakeComm	(0X946F,	"2*9*40");
	MakeWord	(x=0X946F);
	OpDecimal	(x,	0);
	MakeByte	(0X9471);
	MakeWord	(0X9472);
	MakeWord	(0X9474);
	MakeWord	(0X9476);
	MakeDword	(0X9478);
	MakeDword	(0X947C);
	MakeComm	(0X9480,	"96 tpi diskettes");
	MakeWord	(x=0X9480);
	OpDecimal	(x,	0);
	MakeName	(0X9480,	"_bpb96t");
	MakeByte	(0X9482);
	MakeWord	(0X9483);
	MakeByte	(0X9485);
	MakeWord	(x=0X9486);
	OpDecimal	(x,	0);
	MakeComm	(0X9488,	"2*15*80");
	MakeWord	(x=0X9488);
	OpDecimal	(x,	0);
	MakeByte	(0X948A);
	MakeWord	(0X948B);
	MakeWord	(x=0X948D);
	OpDecimal	(x,	0);
	MakeWord	(0X948F);
	MakeDword	(0X9491);
	MakeDword	(0X9495);
	MakeComm	(0X9499,	"3 1/2 inch diskette bpb");
	MakeWord	(x=0X9499);
	OpDecimal	(x,	0);
	MakeName	(0X9499,	"_bpb35");
	MakeByte	(0X949B);
	MakeWord	(0X949C);
	MakeByte	(0X949E);
	MakeWord	(x=0X949F);
	OpDecimal	(x,	0);
	MakeComm	(0X94A1,	"2*9*80");
	MakeWord	(x=0X94A1);
	OpDecimal	(x,	0);
	MakeByte	(0X94A3);
	MakeWord	(0X94A4);
	MakeWord	(0X94A6);
	MakeWord	(0X94A8);
	MakeDword	(0X94AA);
	MakeDword	(0X94AE);
	MakeWord	(x=0X94B2);
	OpDecimal	(x,	0);
	MakeName	(0X94B2,	"_bpb35h");
	MakeByte	(0X94B4);
	MakeWord	(0X94B5);
	MakeByte	(0X94B7);
	MakeWord	(x=0X94B8);
	OpDecimal	(x,	0);
	MakeComm	(0X94BA,	"2*18*80");
	MakeWord	(x=0X94BA);
	OpDecimal	(x,	0);
	MakeByte	(0X94BC);
	MakeWord	(0X94BD);
	MakeWord	(x=0X94BF);
	OpDecimal	(x,	0);
	MakeWord	(0X94C1);
	MakeDword	(0X94C3);
	MakeDword	(0X94C7);
	MakeWord	(x=0X94CB);
	OpDecimal	(x,	0);
	MakeName	(0X94CB,	"_bpb288");
	MakeByte	(0X94CD);
	MakeWord	(0X94CE);
	MakeByte	(0X94D0);
	MakeWord	(x=0X94D1);
	OpDecimal	(x,	0);
	MakeComm	(0X94D3,	"2*36*80");
	MakeWord	(x=0X94D3);
	OpDecimal	(x,	0);
	MakeByte	(0X94D5);
	MakeWord	(0X94D6);
	MakeWord	(x=0X94D8);
	OpDecimal	(x,	0);
	MakeWord	(0X94DA);
	MakeDword	(0X94DC);
	MakeDword	(0X94E0);
	MakeComm	(0X94E4,	"48tpi drives");
	MakeWord	(x=0X94E4);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeName	(0X94E4,	"_bpbtable");
	MakeComm	(0X94E6,	"96tpi drives");
	MakeWord	(x=0X94E6);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X94E8,	"3.5\" drives");
	MakeWord	(x=0X94E8);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X94EA,	"not used - 8\" drives - default to 3.5\"");
	MakeWord	(x=0X94EA);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X94EC,	"not used - 8\" drives - default to 3.5\"");
	MakeWord	(x=0X94EC);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X94EE,	"not used - hard files - default to 3.5\"");
	MakeWord	(x=0X94EE);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X94F0,	"not used - tape drives - default to 3.5\"");
	MakeWord	(x=0X94F0);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X94F2,	"3-1/2\" 1.44mb drive");
	MakeWord	(x=0X94F2);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X94F4,	"ERIMO");
	MakeWord	(x=0X94F4);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X94F6,	"2.88 MB diskette drives");
	MakeWord	(x=0X94F6);
	OpOff		(x,	0,	0X4030);
	OpOff		(x,	128,	0X4030);
	MakeComm	(0X94F8,	"preserve the positions of n and c");
	MakeStr		(0X94F8,	0X9501);
	MakeName	(0X94F8,	"switchlist");
	MakeByte	(0X9501);
	MakeStr		(0X9502,	0X9526);
	MakeName	(0X9502,	"badopm");
	MakeStr		(0X9526,	0X9529);
	MakeName	(0X9526,	"crlfm");
	MakeStr		(0X9529,	0X9548);
	MakeName	(0X9529,	"badparm");
	MakeStr		(0X9548,	0X9569);
	MakeName	(0X9548,	"badsiz_pre");
	MakeStr		(0X9569,	0X957B);
	MakeName	(0X9569,	"badld_pre");
	MakeStr		(0X957B,	0X958F);
	MakeName	(0X957B,	"badcom");
	MakeStr		(0X958F,	0X95B5);
	MakeName	(0X958F,	"badcountry");
	MakeStr		(0X95B5,	0X95D2);
	MakeName	(0X95B5,	"badcountrycom");
	MakeStr		(0X95D2,	0X95FF);
	MakeName	(0X95D2,	"insufmemory");
	MakeStr		(0X95FF,	0X9626);
	MakeName	(0X95FF,	"badmem");
	MakeStr		(0X9626,	0X9641);
	MakeName	(0X9626,	"badblock");
	MakeStr		(0X9641,	0X965E);
	MakeName	(0X9641,	"badstack");
	MakeStr		(0X965E,	0X9684);
	MakeName	(0X965E,	"badorder");
	MakeStr		(0X9684,	0X969E);
	MakeName	(0X9684,	"errorcmd");
	MakeStr		(0X969E,	0X96A0);
	MakeName	(0X969E,	"OnOff");
	MakeStr		(0X96A0,	0X96A3);
	MakeName	(0X96A0,	"OnOff2");
	MakeStr		(0X96A3,	0X96B9);
	MakeName	(0X96A3,	"StartMsg");
	MakeStr		(0X96B9,	0X96DB);
	MakeName	(0X96B9,	"_$PauseMsg");
	MakeStr		(0X96DB,	0X9719);
	MakeName	(0X96DB,	"_$CleanMsg");
	MakeStr		(0X9719,	0X9756);
	MakeName	(0X9719,	"_$InterMsg");
	MakeStr		(0X9756,	0X9773);
	MakeName	(0X9756,	"_$MenuHeader");
	MakeStr		(0X9773,	0X9775);
	MakeComm	(0X9775,	"db '=======================' ; ALT 205");
	MakeByte	(0X9775);
	MakeArray	(0X9775,	0X17);
	MakeStr		(0X978C,	0X978F);
	MakeStr		(0X978F,	0X97A2);
	MakeName	(0X978F,	"_$MenuPrmpt");
	MakeStr		(0X97A2,	0X97F2);
	MakeName	(0X97A2,	"_$StatusLine");
	MakeStr		(0X97F2,	0X97FA);
	MakeName	(0X97F2,	"_$InterPrmpt");
	MakeStr		(0X97FA,	0X97FE);
	MakeName	(0X97FA,	"_$YES");
	MakeStr		(0X97FE,	0X9802);
	MakeName	(0X97FE,	"_$NO");
	MakeStr		(0X9802,	0X9813);
	MakeName	(0X9802,	"_$TimeOut");
	MakeStr		(0X9813,	0X9854);
	MakeName	(0X9813,	"badcomprmpt");
	MakeStr		(0X9854,	0X9870);
	MakeName	(0X9854,	"_$AutoPrmpt");
	MakeStr		(0X9870,	0X98AC);
	MakeName	(0X9870,	"TooManyDrivesMsg");
	MakeStr		(0X98AC,	0X98C9);
	MakeName	(0X98AC,	"baddblspace");
	MakeByte	(0X98C9);
	MakeArray	(0X98C9,	0X7);
}

static Functions_0(void) {

	MakeFunction    (0X743,0X762);
	SetFunctionFlags(0X743,0);
	MakeNameEx(0X758, "ce_enter_codeseg", SN_LOCAL);
	MakeNameEx(0X75D, "not_from_dos", SN_LOCAL);
	MakeFunction    (0X762,0X774);
	SetFunctionFlags(0X762,0x2);
	MakeFrame(0X762, 0XA, 0, 0);
	MakeFunction    (0X774,0X797);
	SetFunctionFlags(0X774,0x4002);
	MakeFrame(0X774, 0, 0, 0X2);
	MakeFunction    (0X797,0X7BB);
	SetFunctionFlags(0X797,0x2);
	MakeNameEx(0X7B9, "c_o13_1", SN_LOCAL);
	MakeFunction    (0X7C3,0X7D5);
	SetFunctionFlags(0X7C3,0);
	MakeFunction    (0X7D5,0X7EF);
	SetFunctionFlags(0X7D5,0);
	MakeFrame(0X7D5, 0, 10, 0);
	MakeFunction    (0X878,0X893);
	SetFunctionFlags(0X878,0);
	MakeFrame(0X878, 0, 8, 0);
	MakeFunction    (0X8D1,0X8F7);
	SetFunctionFlags(0X8D1,0x2);
	MakeFrame(0X8D1, 0, 8, 0);
	MakeNameEx(0X8F2, "Skip", SN_LOCAL);
	MakeFunction    (0X1346,0X139E);
	SetFunctionFlags(0X1346,0x4000);
	MakeFunction    (0X139E,0X13DC);
	SetFunctionFlags(0X139E,0x20);
	MakeFrame(0X139E, 0, 0, 0);
	MakeNameEx(0X13A6, "doc1", SN_LOCAL);
	MakeNameEx(0X13B4, "rsct_loop", SN_LOCAL);
	MakeNameEx(0X13CF, "doc2", SN_LOCAL);
	MakeNameEx(0X13DB, "doc3", SN_LOCAL);
	MakeFunction    (0X13DC,0X13E4);
	SetFunctionFlags(0X13DC,0x20);
	MakeFrame(0X13DC, 0, 0, 0);
	MakeFunction    (0X13E4,0X13EC);
	SetFunctionFlags(0X13E4,0x20);
	MakeFrame(0X13E4, 0, 0, 0);
	MakeFunction    (0X13EC,0X13F4);
	SetFunctionFlags(0X13EC,0x20);
	MakeFrame(0X13EC, 0, 0, 0);
	MakeFunction    (0X13F4,0X13FC);
	SetFunctionFlags(0X13F4,0x20);
	MakeFrame(0X13F4, 0, 0, 0);
	MakeFunction    (0X13FC,0X1404);
	SetFunctionFlags(0X13FC,0x20);
	MakeFrame(0X13FC, 0, 0, 0);
	MakeFunction    (0X1404,0X140C);
	SetFunctionFlags(0X1404,0x20);
	MakeFrame(0X1404, 0, 0, 0);
	MakeFunction    (0X152B,0X15E6);
	SetFunctionFlags(0X152B,0);
	MakeFrame(0X152B, 0, 6, 0);
	MakeNameEx(0X1589, "century_19", SN_LOCAL);
	MakeNameEx(0X15AF, "leap_year", SN_LOCAL);
	MakeNameEx(0X15B6, "leap_adjustment", SN_LOCAL);
	MakeNameEx(0X15BB, "no_leap_adjustment", SN_LOCAL);
	MakeNameEx(0X15DC, "r_d_ret", SN_LOCAL);
	MakeFunction    (0X15EC,0X1625);
	SetFunctionFlags(0X15EC,0);
	MakeNameEx(0X15E6, "r_t_retj", SN_LOCAL);
	MakeFunction    (0X1625,0X164A);
	SetFunctionFlags(0X1625,0);
	MakeFunction    (0X164A,0X1655);
	SetFunctionFlags(0X164A,0);
	MakeFunction    (0X1655,0X1693);
	SetFunctionFlags(0X1655,0);
	MakeNameEx(0X166C, "century_20", SN_LOCAL);
	MakeNameEx(0X1691, "date_error", SN_LOCAL);
	MakeFunction    (0X1693,0X16AC);
	SetFunctionFlags(0X1693,0);
	MakeNameEx(0X16AA, "time_error", SN_LOCAL);
	MakeFunction    (0X16AC,0X16D5);
	SetFunctionFlags(0X16AC,0);
	MakeNameEx(0X16B2, "bv_loop", SN_LOCAL);
	MakeNameEx(0X16D3, "bv_error", SN_LOCAL);
	MakeFunction    (0X17EE,0X17FA);
	SetFunctionFlags(0X17EE,0x2);
	MakeFunction    (0X1D9E,0X1E03);
	SetFunctionFlags(0X1D9E,0);
	MakeNameEx(0X1DA3, "drive_loop", SN_LOCAL);
	MakeNameEx(0X1DB2, "fdrv_found", SN_LOCAL);
	MakeNameEx(0X1DB4, "fdrv_loop", SN_LOCAL);
	MakeNameEx(0X1DCF, "remap_loop1", SN_LOCAL);
	MakeNameEx(0X1DED, "remap_boot_flop", SN_LOCAL);
	MakeNameEx(0X1DF2, "remap_change_boot_drv", SN_LOCAL);
	MakeNameEx(0X1E02, "rmap_exit", SN_LOCAL);
	MakeFunction    (0X1E03,0X1E23);
	SetFunctionFlags(0X1E03,0);
	MakeNameEx(0X1E21, "erret", SN_LOCAL);
	MakeNameEx(0X1E22, "norm_ret", SN_LOCAL);
	MakeFunction    (0X1E23,0X219C);
	SetFunctionFlags(0X1E23,0);
	MakeFrame(0X1E23, 0, 8, 0);
	MakeNameEx(0X1E59, "act_part", SN_LOCAL);
	MakeNameEx(0X1E72, "got_good_act", SN_LOCAL);
	MakeNameEx(0X1E78, "not_act", SN_LOCAL);
	MakeNameEx(0X1E84, "get_primary", SN_LOCAL);
	MakeNameEx(0X1E9D, "got_prim", SN_LOCAL);
	MakeNameEx(0X1EA3, "not_prim", SN_LOCAL);
	MakeNameEx(0X1EAC, "setret", SN_LOCAL);
	MakeNameEx(0X1ED2, "okdrive", SN_LOCAL);
	MakeNameEx(0X1EF8, "okdrive_cont", SN_LOCAL);
	MakeNameEx(0X1F40, "oknotmini", SN_LOCAL);
	MakeNameEx(0X1F74, "check_1_ok", SN_LOCAL);
	MakeNameEx(0X1F90, "ck_power_of_two", SN_LOCAL);
	MakeNameEx(0X1F96, "invalid_boot_record", SN_LOCAL);
	MakeNameEx(0X1F9B, "valid_boot_record", SN_LOCAL);
	MakeNameEx(0X1FAE, "setret_brdg", SN_LOCAL);
	MakeNameEx(0X1FB1, "unknown3_0_j", SN_LOCAL);
	MakeNameEx(0X1FB4, "try5", SN_LOCAL);
	MakeNameEx(0X1FCC, "no_os2", SN_LOCAL);
	MakeNameEx(0X1FDD, "copybpb", SN_LOCAL);
	MakeNameEx(0X2023, "already_nonz", SN_LOCAL);
	MakeNameEx(0X203C, "copybpb_fat", SN_LOCAL);
	MakeNameEx(0X2057, "copy_totsec", SN_LOCAL);
	MakeNameEx(0X205D, "totsec_already_set", SN_LOCAL);
	MakeNameEx(0X20B6, "copymediaid", SN_LOCAL);
	MakeNameEx(0X20D1, "unknown", SN_LOCAL);
	MakeNameEx(0X20D6, "unknown3_0", SN_LOCAL);
	MakeNameEx(0X20EC, "scan_next", SN_LOCAL);
	MakeNameEx(0X216E, "massage_bpb", SN_LOCAL);
	MakeNameEx(0X2197, "ret_hard", SN_LOCAL);
	MakeFunction    (0X219C,0X21DC);
	SetFunctionFlags(0X219C,0);
	MakeFrame(0X219C, 0, 6, 0);
	MakeNameEx(0X21B6, "cfb_chk_BPB_TOTALSECTORS", SN_LOCAL);
	MakeNameEx(0X21D8, "cfb_retit", SN_LOCAL);
	MakeFunction    (0X21E2,0X229D);
	SetFunctionFlags(0X21E2,0);
	MakeNameEx(0X21E8, "next_bds", SN_LOCAL);
	MakeNameEx(0X2205, "get_ccyl", SN_LOCAL);
	MakeNameEx(0X2226, "no_cyl_rnd", SN_LOCAL);
	MakeNameEx(0X2231, "nothardff", SN_LOCAL);
	MakeNameEx(0X2251, "again", SN_LOCAL);
	MakeNameEx(0X2266, "__@@", SN_LOCAL);
	MakeNameEx(0X2280, "not_process_other", SN_LOCAL);
	MakeNameEx(0X228F, "go_to_next_bds", SN_LOCAL);
	MakeNameEx(0X229C, "got_end_of_bds_chain", SN_LOCAL);
	MakeFunction    (0X229D,0X22A5);
	SetFunctionFlags(0X229D,0);
	MakeFunction    (0X22A5,0X22AF);
	SetFunctionFlags(0X22A5,0);
	MakeFunction    (0X22AF,0X22EA);
	SetFunctionFlags(0X22AF,0);
	MakeNameEx(0X22E1, "domininext", SN_LOCAL);
	MakeFunction    (0X22EA,0X237C);
	SetFunctionFlags(0X22EA,0);
	MakeNameEx(0X22FF, "fmpgot", SN_LOCAL);
	MakeNameEx(0X2340, "fmpgot_cont", SN_LOCAL);
	MakeNameEx(0X2378, "fmpnextchain", SN_LOCAL);
	MakeNameEx(0X237B, "fmpret", SN_LOCAL);
	MakeFunction    (0X237C,0X23A4);
	SetFunctionFlags(0X237C,0);
	MakeFrame(0X237C, 0, 8, 0);
	MakeNameEx(0X2380, "setmini_1", SN_LOCAL);
	MakeNameEx(0X23A1, "setmini_2", SN_LOCAL);
	MakeFunction    (0X23A4,0X23B9);
	SetFunctionFlags(0X23A4,0);
	MakeNameEx(0X23B8, "dmax_ok", SN_LOCAL);
	MakeFunction    (0X23B9,0X23EE);
	SetFunctionFlags(0X23B9,0);
	MakeFrame(0X23B9, 0, 4, 0);
	MakeNameEx(0X23BF, "xinstall_bds_1", SN_LOCAL);
	MakeNameEx(0X23C8, "xinstall_bds_2", SN_LOCAL);
	MakeFunction    (0X23EE,0X242C);
	SetFunctionFlags(0X23EE,0);
	MakeFrame(0X23EE, 0, 8, 0);
	MakeNameEx(0X23F4, "loop_clock", SN_LOCAL);
	MakeNameEx(0X240F, "delay", SN_LOCAL);
	MakeNameEx(0X2413, "clock_present", SN_LOCAL);
	MakeNameEx(0X2427, "no_readdate", SN_LOCAL);
	MakeFunction    (0X242C,0X245C);
	SetFunctionFlags(0X242C,0);
	MakeFrame(0X242C, 0, 2, 0);
	MakeNameEx(0X2445, "cmosck4", SN_LOCAL);
	MakeNameEx(0X245A, "cmosck9", SN_LOCAL);
	MakeFunction    (0X245C,0X247B);
	SetFunctionFlags(0X245C,0);
	MakeFunction    (0X247B,0X247C);
	SetFunctionFlags(0X247B,0x2);
	MakeFunction    (0X247C,0X2499);
	SetFunctionFlags(0X247C,0);
	MakeFunction    (0X2499,0X254C);
	SetFunctionFlags(0X2499,0);
	MakeFrame(0X2499, 0, 4, 0);
	MakeNameEx(0X24B0, "unpack", SN_LOCAL);
	MakeNameEx(0X24EC, "even_odd", SN_LOCAL);
	MakeNameEx(0X24FA, "havclus", SN_LOCAL);
	MakeNameEx(0X2502, "unpack16", SN_LOCAL);
	MakeNameEx(0X2510, "unpackx", SN_LOCAL);
	MakeNameEx(0X2521, "getcl2", SN_LOCAL);
	MakeFunction    (0X254C,0X25B2);
	SetFunctionFlags(0X254C,0);
	MakeFrame(0X254C, 0, 12, 0);
	MakeNameEx(0X25A6, "gfs_split_chk", SN_LOCAL);
	MakeFunction    (0X2695,0X26A3);
	SetFunctionFlags(0X2695,0);
	MakeFunction    (0X271C,0X2726);
	SetFunctionFlags(0X271C,0x4000);
	MakeFunction    (0X2726,0X275F);
	SetFunctionFlags(0X2726,0);
	MakeNameEx(0X2756, "not_ext", SN_LOCAL);
	MakeNameEx(0X275A, "alt_save", SN_LOCAL);
	MakeNameEx(0X275E, "keyret", SN_LOCAL);
	MakeFunction    (0X275F,0X27BD);
	SetFunctionFlags(0X275F,0x4000);
	MakeFunction    (0X27BD,0X27C7);
	SetFunctionFlags(0X27BD,0);
	MakeFunction    (0X27C9,0X27DA);
	SetFunctionFlags(0X27C9,0);
	MakeNameEx(0X27C7, "cc_ret", SN_LOCAL);
	MakeNameEx(0X27CE, "flloop", SN_LOCAL);
	MakeFunction    (0X281E,0X2820);
	SetFunctionFlags(0X281E,0);
	MakeFunction    (0X2820,0X284B);
	SetFunctionFlags(0X2820,0);
	MakeNameEx(0X2844, "ret1", SN_LOCAL);
	MakeNameEx(0X2845, "checknotready", SN_LOCAL);
	MakeFunction    (0X28E2,0X28F5);
	SetFunctionFlags(0X28E2,0);
	MakeNameEx(0X28ED, "arbad", SN_LOCAL);
	MakeFunction    (0X2923,0X2925);
	SetFunctionFlags(0X2923,0);
	MakeFunction    (0X2925,0X292C);
	SetFunctionFlags(0X2925,0);
	MakeFunction    (0X294D,0X2956);
	SetFunctionFlags(0X294D,0);
	MakeFunction    (0X2A46,0X2A61);
	SetFunctionFlags(0X2A46,0);
	MakeNameEx(0X2A58, "inc_case", SN_LOCAL);
	MakeNameEx(0X2A60, "no_rollover", SN_LOCAL);
	MakeFunction    (0X2A97,0X2AAB);
	SetFunctionFlags(0X2A97,0);
	MakeNameEx(0X2AAA, "X_SetDrv", SN_LOCAL);
	MakeFunction    (0X2B20,0X2B50);
	SetFunctionFlags(0X2B20,0);
	MakeNameEx(0X2B49, "timepassed", SN_LOCAL);
	MakeNameEx(0X2B4E, "timecheck_unk", SN_LOCAL);
	MakeNameEx(0X2B4F, "timecheck_ret", SN_LOCAL);
	MakeFunction    (0X2B52,0X2B99);
	SetFunctionFlags(0X2B52,0x4000);
	MakeFunction    (0X2B99,0X2BC6);
	SetFunctionFlags(0X2B99,0);
	MakeFrame(0X2B99, 0, 2, 0);
	MakeNameEx(0X2BBC, "ci_bigfat", SN_LOCAL);
	MakeFunction    (0X2BC6,0X2C83);
	SetFunctionFlags(0X2BC6,0);
	MakeNameEx(0X2BD0, "getbp1", SN_LOCAL);
	MakeNameEx(0X2BE1, "getbp_err_ret_brdg", SN_LOCAL);
	MakeNameEx(0X2BE4, "dofatbpb", SN_LOCAL);
	MakeNameEx(0X2C14, "is_floppy", SN_LOCAL);
	MakeNameEx(0X2C30, "has8", SN_LOCAL);
	MakeNameEx(0X2C6B, "getret", SN_LOCAL);
	MakeNameEx(0X2C6E, "getret_exit", SN_LOCAL);
	MakeNameEx(0X2C6F, "getbp_err_ret", SN_LOCAL);
	MakeNameEx(0X2C79, "got_unknown_medium", SN_LOCAL);
	MakeFunction    (0X2C83,0X2CD9);
	SetFunctionFlags(0X2C83,0);
	MakeNameEx(0X2CAB, "check_bpb_mediabyte", SN_LOCAL);
	MakeNameEx(0X2CCE, "mustbeearlier", SN_LOCAL);
	MakeNameEx(0X2CD5, "invalidbootsec", SN_LOCAL);
	MakeNameEx(0X2CD6, "gooddsk", SN_LOCAL);
	MakeNameEx(0X2CD8, "err_ret", SN_LOCAL);
	MakeFunction    (0X2CD9,0X2D11);
	SetFunctionFlags(0X2CD9,0);
	MakeNameEx(0X2D05, "movbpb_conv", SN_LOCAL);
	MakeNameEx(0X2D0F, "movbpb_ret", SN_LOCAL);
	MakeFunction    (0X2D11,0X2D48);
	SetFunctionFlags(0X2D11,0);
	MakeNameEx(0X2D46, "mmi_not_ext", SN_LOCAL);
	MakeFunction    (0X2D48,0X2D55);
	SetFunctionFlags(0X2D48,0);
	MakeNameEx(0X2D54, "bad_fat_ret", SN_LOCAL);
	MakeFunction    (0X2D55,0X2DCA);
	SetFunctionFlags(0X2D55,0);
	MakeFrame(0X2D55, 0, 2, 0);
	MakeNameEx(0X2D60, "rd_ret", SN_LOCAL);
	MakeNameEx(0X2D6B, "rd_rty", SN_LOCAL);
	MakeNameEx(0X2D90, "rd_skip1_dpt", SN_LOCAL);
	MakeNameEx(0X2DAF, "rd_skip2_dpt", SN_LOCAL);
	MakeNameEx(0X2DB4, "err_rd_ret", SN_LOCAL);
	MakeNameEx(0X2DB7, "okret2", SN_LOCAL);
	MakeFunction    (0X2DCA,0X2DDA);
	SetFunctionFlags(0X2DCA,0x4000);
	MakeFunction    (0X2DDA,0X2DF1);
	SetFunctionFlags(0X2DDA,0x4000);
	MakeFunction    (0X2DF1,0X2E01);
	SetFunctionFlags(0X2DF1,0x4000);
	MakeFunction    (0X2E1C,0X2E9D);
	SetFunctionFlags(0X2E1C,0);
	MakeFrame(0X2E1C, 0, 4, 0);
	MakeNameEx(0X2E36, "scan_list", SN_LOCAL);
	MakeNameEx(0X2E6C, "not_fsetowner", SN_LOCAL);
	MakeNameEx(0X2E9A, "singleret", SN_LOCAL);
	MakeFunction    (0X2EA5,0X2EAA);
	SetFunctionFlags(0X2EA5,0);
	MakeFunction    (0X2EAA,0X2F7D);
	SetFunctionFlags(0X2EAA,0x4000);
	MakeNameEx(0X2E9D, "baddrive", SN_LOCAL);
	MakeNameEx(0X2EA1, "unformatteddrive", SN_LOCAL);
	MakeNameEx(0X2EA3, "baddrive_ret", SN_LOCAL);
	MakeNameEx(0X2EE8, "sanity32", SN_LOCAL);
	MakeNameEx(0X2EFA, "sanityok", SN_LOCAL);
	MakeNameEx(0X2F30, "diskio_nochangeline", SN_LOCAL);
	MakeNameEx(0X2F33, "skip_setup", SN_LOCAL);
	MakeNameEx(0X2F7A, "baddrive_brdg", SN_LOCAL);
	MakeFunction    (0X2F7D,0X2FC6);
	SetFunctionFlags(0X2F7D,0);
	MakeNameEx(0X2FB5, "motor_start_ok", SN_LOCAL);
	MakeNameEx(0X2FC5, "skip_dpt_setting", SN_LOCAL);
	MakeFunction    (0X2FC6,0X2FFD);
	SetFunctionFlags(0X2FC6,0);
	MakeNameEx(0X2FFB, "nodiddleback", SN_LOCAL);
	MakeFunction    (0X2FFD,0X3038);
	SetFunctionFlags(0X2FFD,0);
	MakeNameEx(0X3015, "block_floppy", SN_LOCAL);
	MakeNameEx(0X3027, "gotmin", SN_LOCAL);
	MakeFunction    (0X303B,0X3178);
	SetFunctionFlags(0X303B,0);
	MakeNameEx(0X3038, "dskerr_brdg", SN_LOCAL);
	MakeNameEx(0X304D, "GetRdWrInd", SN_LOCAL);
	MakeNameEx(0X3059, "_retry", SN_LOCAL);
	MakeNameEx(0X3070, "disk_not_mini", SN_LOCAL);
	MakeNameEx(0X309C, "do_writej", SN_LOCAL);
	MakeNameEx(0X309E, "do_fast", SN_LOCAL);
	MakeNameEx(0X30A1, "testerr", SN_LOCAL);
	MakeNameEx(0X30B3, "noverify", SN_LOCAL);
	MakeNameEx(0X30C2, "its_removable", SN_LOCAL);
	MakeNameEx(0X30EE, "noxor", SN_LOCAL);
	MakeNameEx(0X30F2, "disk_ret", SN_LOCAL);
	MakeNameEx(0X30F4, "do_write", SN_LOCAL);
	MakeNameEx(0X3105, "doverify", SN_LOCAL);
	MakeNameEx(0X311E, "not_softecc_err", SN_LOCAL);
	MakeNameEx(0X3127, "dskerr", SN_LOCAL);
	MakeNameEx(0X3131, "dskerr_nochangeline", SN_LOCAL);
	MakeNameEx(0X3140, "dochkagain", SN_LOCAL);
	MakeNameEx(0X3143, "dskerr0", SN_LOCAL);
	MakeNameEx(0X3151, "skip_timeout_chk", SN_LOCAL);
	MakeNameEx(0X315C, "dskerr1", SN_LOCAL);
	MakeNameEx(0X3160, "write_fault_err", SN_LOCAL);
	MakeFunction    (0X3178,0X319D);
	SetFunctionFlags(0X3178,0);
	MakeFunction    (0X319D,0X31B5);
	SetFunctionFlags(0X319D,0);
	MakeNameEx(0X31B1, "notready", SN_LOCAL);
	MakeFunction    (0X31B5,0X31CE);
	SetFunctionFlags(0X31B5,0);
	MakeFrame(0X31B5, 0, 6, 0);
	MakeFunction    (0X31CE,0X31EE);
	SetFunctionFlags(0X31CE,0);
	MakeFrame(0X31CE, 0, 2, 0);
	MakeNameEx(0X31DE, "setaccess", SN_LOCAL);
	MakeNameEx(0X31EB, "done_set", SN_LOCAL);
	MakeFunction    (0X31EE,0X31FB);
	SetFunctionFlags(0X31EE,0);
	MakeNameEx(0X31F8, "dont_dec_retry_count", SN_LOCAL);
	MakeFunction    (0X34DC,0X3560);
	SetFunctionFlags(0X34DC,0);
	MakeNameEx(0X34F1, "Dptalreadyset", SN_LOCAL);
	MakeNameEx(0X3507, "IoNextSector", SN_LOCAL);
	MakeNameEx(0X352C, "IoRemovable", SN_LOCAL);
	MakeNameEx(0X355E, "NoNeedDone", SN_LOCAL);
	MakeFunction    (0X3560,0X356B);
	SetFunctionFlags(0X3560,0);
	MakeNameEx(0X3568, "OneK", SN_LOCAL);
	MakeFunction    (0X356B,0X3573);
	SetFunctionFlags(0X356B,0);
	MakeFunction    (0X3573,0X35D7);
	SetFunctionFlags(0X3573,0);
	MakeNameEx(0X3588, "DoSetDasd", SN_LOCAL);
	MakeNameEx(0X35A6, "GotBig", SN_LOCAL);
	MakeNameEx(0X35B6, "DoSet", SN_LOCAL);
	MakeNameEx(0X35CE, "DasdHasBeenSet", SN_LOCAL);
	MakeFunction    (0X35D7,0X3674);
	SetFunctionFlags(0X35D7,0);
	MakeFrame(0X35D7, 0, 4, 0);
	MakeNameEx(0X35EC, "DoSetMediaForFormat", SN_LOCAL);
	MakeNameEx(0X3606, "SkipSaveDskAdr", SN_LOCAL);
	MakeNameEx(0X3652, "skip_disk_base_setting", SN_LOCAL);
	MakeNameEx(0X3659, "FormaStatErr", SN_LOCAL);
	MakeNameEx(0X3667, "FormatStatIllegalComb", SN_LOCAL);
	MakeNameEx(0X366B, "FormatStatTimeOut", SN_LOCAL);
	MakeNameEx(0X366D, "PopStatRet", SN_LOCAL);
	MakeNameEx(0X3671, "SetMediaRet", SN_LOCAL);
	MakeFunction    (0X3674,0X368C);
	SetFunctionFlags(0X3674,0);
	MakeFrame(0X3674, 0, 2, 0);
	MakeNameEx(0X3681, "ResetDisk_cont", SN_LOCAL);
	MakeFunction    (0X368C,0X36E4);
	SetFunctionFlags(0X368C,0);
	MakeFrame(0X368C, 0, 4, 0);
	MakeNameEx(0X36C9, "MotorStrtOK", SN_LOCAL);
	MakeNameEx(0X36CB, "GotValidDpt", SN_LOCAL);
	MakeFunction    (0X36E4,0X372B);
	SetFunctionFlags(0X36E4,0x4000);
	MakeFunction    (0X372B,0X375A);
	SetFunctionFlags(0X372B,0);
	MakeFrame(0X372B, 0, 2, 0);
	MakeNameEx(0X3757, "DontRestore", SN_LOCAL);
	MakeFunction    (0X375A,0X3792);
	SetFunctionFlags(0X375A,0x4000);
	MakeFunction    (0X37E6,0X37FE);
	SetFunctionFlags(0X37E6,0);
	MakeFrame(0X37E6, 0, 8, 0);
	MakeFunction    (0X37FE,0X3829);
	SetFunctionFlags(0X37FE,0);
	MakeNameEx(0X3828, "ChangeLnChkRet", SN_LOCAL);
	MakeFunction    (0X39D3,0X39F1);
	SetFunctionFlags(0X39D3,0);
	MakeNameEx(0X39F0, "HMAPtr_retn:", SN_LOCAL);
	MakeFunction    (0X39F1,0X3A0C);
	SetFunctionFlags(0X39F1,0);
	MakeNameEx(0X3A06, "movsec_bytes", SN_LOCAL);
	MakeFunction    (0X3A0C,0X3A83);
	SetFunctionFlags(0X3A0C,0);
	MakeFrame(0X3A0C, 0, 8, 0);
	MakeNameEx(0X3A34, "not_on_bound", SN_LOCAL);
	MakeNameEx(0X3A5B, "no_head_bound", SN_LOCAL);
	MakeNameEx(0X3A77, "no_wrap", SN_LOCAL);
	MakeNameEx(0X3A7D, "no_wrap_head", SN_LOCAL);
	MakeFunction    (0X3A83,0X3A97);
	SetFunctionFlags(0X3A83,0);
	MakeNameEx(0X3A87, "fbds_1", SN_LOCAL);
	MakeNameEx(0X3A96, "fbds_2", SN_LOCAL);
	MakeFunction    (0X3A97,0X3AB5);
	SetFunctionFlags(0X3A97,0);
	MakeNameEx(0X3AB4, "dointdone", SN_LOCAL);
	MakeFunction    (0X3D02,0X3D0E);
	SetFunctionFlags(0X3D02,0x4000);
	MakeFunction    (0X3D0E,0X3D53);
	SetFunctionFlags(0X3D0E,0);
	MakeFrame(0X3D0E, 0, 2, 0);
	MakeNameEx(0X3D12, "loop_next_bds", SN_LOCAL);
	MakeNameEx(0X3D35, "next_bds", SN_LOCAL);
	MakeNameEx(0X3D52, "_eot_ok", SN_LOCAL);
	MakeFunction    (0X3D53,0X3D95);
	SetFunctionFlags(0X3D53,0);
	MakeNameEx(0X3D5F, "no_win386", SN_LOCAL);
	MakeNameEx(0X3D82, "wrmsg_loop", SN_LOCAL);
	MakeNameEx(0X3D92, "swpdsk9", SN_LOCAL);
	MakeFunction    (0X3DD4,0X3DDA);
	SetFunctionFlags(0X3DD4,0);
	MakeFunction    (0X3DDA,0X3E21);
	SetFunctionFlags(0X3DDA,0);
	MakeNameEx(0X3E13, "mediaret", SN_LOCAL);
	MakeNameEx(0X3E14, "mediadovolid", SN_LOCAL);
	MakeFunction    (0X3E21,0X3E42);
	SetFunctionFlags(0X3E21,0);
	MakeFrame(0X3E21, 0, 0, 0);
	MakeNameEx(0X3E3C, "checklatchret", SN_LOCAL);
	MakeNameEx(0X3E3F, "ret_no_error_map", SN_LOCAL);
	MakeFunction    (0X3E42,0X3E49);
	SetFunctionFlags(0X3E42,0);
	MakeFunction    (0X3E49,0X3E97);
	SetFunctionFlags(0X3E49,0);
	MakeNameEx(0X3E6C, "vid_no_changed", SN_LOCAL);
	MakeNameEx(0X3E78, "do_ext_check_id", SN_LOCAL);
	MakeNameEx(0X3E90, "ext_changed", SN_LOCAL);
	MakeFunction    (0X3E97,0X3EBB);
	SetFunctionFlags(0X3E97,0);
	MakeNameEx(0X3EB1, "checkioerr", SN_LOCAL);
	MakeNameEx(0X3EB4, "checkioret", SN_LOCAL);
	MakeNameEx(0X3EB8, "no_error_map", SN_LOCAL);
	MakeFunction    (0X3EBB,0X3EC5);
	SetFunctionFlags(0X3EBB,0);
	MakeFunction    (0X3EC5,0X3EDA);
	SetFunctionFlags(0X3EC5,0);
	MakeFunction    (0X3EDA,0X3F14);
	SetFunctionFlags(0X3EDA,0);
	MakeNameEx(0X3F0D, "Is720K", SN_LOCAL);
	MakeNameEx(0X3F13, "dofloppy", SN_LOCAL);
	MakeFunction    (0X3F14,0X3F2F);
	SetFunctionFlags(0X3F14,0);
	MakeFrame(0X3F14, 0, 4, 0);
	MakeNameEx(0X3F1A, "scan_bds", SN_LOCAL);
	MakeNameEx(0X3F24, "get_next_bds", SN_LOCAL);
	MakeFunction    (0X3F2F,0X3F36);
	SetFunctionFlags(0X3F2F,0);
	MakeFunction    (0X3F36,0X3F3C);
	SetFunctionFlags(0X3F36,0);
	MakeFunction    (0X3F3C,0X3F43);
	SetFunctionFlags(0X3F3C,0);
	MakeFunction    (0X3F43,0X3F5C);
	SetFunctionFlags(0X3F43,0);
	MakeFrame(0X3F43, 0, 4, 0);
	MakeNameEx(0X3F55, "setvret", SN_LOCAL);
	MakeNameEx(0X3F59, "seterr", SN_LOCAL);
	MakeFunction    (0X3F5E,0X3FF6);
	SetFunctionFlags(0X3F5E,0);
	MakeFrame(0X3F5E, 0, 14, 0);
	MakeNameEx(0X3F8F, "next_sec", SN_LOCAL);
	MakeNameEx(0X3FB3, "fvid_loop", SN_LOCAL);
	MakeNameEx(0X3FC2, "ent_loop", SN_LOCAL);
	MakeNameEx(0X3FCF, "notfound", SN_LOCAL);
	MakeNameEx(0X3FD3, "found_vid", SN_LOCAL);
	MakeNameEx(0X3FE9, "fvid_ret", SN_LOCAL);
	MakeNameEx(0X3FEB, "rvidret", SN_LOCAL);
	MakeNameEx(0X3FEF, "no_vid", SN_LOCAL);
	MakeNameEx(0X3FF2, "readviderr", SN_LOCAL);
	MakeFunction    (0X3FF6,0X4009);
	SetFunctionFlags(0X3FF6,0);
	MakeFrame(0X3FF6, 0, 6, 0);
	MakeFunction    (0X4009,0X401A);
	SetFunctionFlags(0X4009,0);
	MakeFrame(0X4009, 0, 4, 0);
	MakeFunction    (0X401A,0X4029);
	SetFunctionFlags(0X401A,0);
	MakeFrame(0X401A, 0, 2, 0);
	MakeNameEx(0X4027, "okret1", SN_LOCAL);
	MakeFunction    (0X4177,0X41FC);
	SetFunctionFlags(0X4177,0x2);
	MakeFrame(0X4177, 0X4, 0, 0);
	MakeNameEx(0X4194, "fopund02", SN_LOCAL);
	MakeNameEx(0X41DF, "notfree02", SN_LOCAL);
	MakeNameEx(0X41E7, "findnext02", SN_LOCAL);
	MakeNameEx(0X41EC, "foundbad02", SN_LOCAL);
	MakeFunction    (0X41FC,0X426B);
	SetFunctionFlags(0X41FC,0x4000);
	MakeNameEx(0X4201, "lploopp", SN_LOCAL);
	MakeNameEx(0X421A, "inuse", SN_LOCAL);
	MakeNameEx(0X4226, "found", SN_LOCAL);
	MakeNameEx(0X4227, "fatal", SN_LOCAL);
	MakeNameEx(0X4239, "skip_nmis", SN_LOCAL);
	MakeNameEx(0X425C, "fatal_loop", SN_LOCAL);
	MakeNameEx(0X4269, "fatal_done", SN_LOCAL);
	MakeFunction    (0X49D2,0X49E6);
	SetFunctionFlags(0X49D2,0);
	MakeFunction    (0X4A39,0X4A61);
	SetFunctionFlags(0X4A39,0);
	MakeNameEx(0X4A3F, "LdngLo", SN_LOCAL);
	MakeFunction    (0X4A61,0X4A7A);
	SetFunctionFlags(0X4A61,0);
	MakeNameEx(0X4A79, "ttldhx", SN_LOCAL);
	MakeFunction    (0X4A7A,0X4A94);
	SetFunctionFlags(0X4A7A,0);
	MakeNameEx(0X4A93, "mdhx", SN_LOCAL);
	MakeFunction    (0X4A94,0X4AA5);
	SetFunctionFlags(0X4A94,0);
	MakeFunction    (0X4AA5,0X4AC8);
	SetFunctionFlags(0X4AA5,0);
	MakeFunction    (0X4AC8,0X4AE4);
	SetFunctionFlags(0X4AC8,0);
	MakeFrame(0X4AC8, 0, 4, 0);
	MakeFunction    (0X4AE4,0X4B5E);
	SetFunctionFlags(0X4AE4,0);
	MakeNameEx(0X4B15, "update_arena", SN_LOCAL);
	MakeNameEx(0X4B52, "FatalErr", SN_LOCAL);
	MakeFunction    (0X4B5E,0X4BB4);
	SetFunctionFlags(0X4B5E,0);
	MakeFrame(0X4B5E, 0, 2, 0);
	MakeNameEx(0X4B8B, "allocHMA_1", SN_LOCAL);
	MakeNameEx(0X4BB1, "grabhma_error", SN_LOCAL);
	MakeFunction    (0X4BB4,0X4BBC);
	SetFunctionFlags(0X4BB4,0);
	MakeFunction    (0X4C2C,0X4C86);
	SetFunctionFlags(0X4C2C,0);
	MakeFunction    (0X4CD6,0X4D19);
	SetFunctionFlags(0X4CD6,0);
	MakeNameEx(0X4CEE, "ClrVDISKno", SN_LOCAL);
	MakeNameEx(0X4CEF, "ClrVDISKok", SN_LOCAL);
	MakeFunction    (0X4D19,0X4D3D);
	SetFunctionFlags(0X4D19,0);
	MakeFunction    (0X4D3D,0X4D65);
	SetFunctionFlags(0X4D3D,0);
	MakeNameEx(0X4D64, "ivdins_retn", SN_LOCAL);
	MakeFunction    (0X4D65,0X4D7D);
	SetFunctionFlags(0X4D65,0);
	MakeFrame(0X4D65, 0, 2, 0);
	MakeFunction    (0X4D7D,0X4D86);
	SetFunctionFlags(0X4D7D,0);
	MakeFunction    (0X4D86,0X4DB6);
	SetFunctionFlags(0X4D86,0);
	MakeFunction    (0X4DB6,0X4E1A);
	SetFunctionFlags(0X4DB6,0x4000);
	MakeNameEx(0X4DE9, "fooset_zero", SN_LOCAL);
	MakeNameEx(0X4DF0, "normcds", SN_LOCAL);
	MakeNameEx(0X4DFA, "etnormcds", SN_LOCAL);
	MakeNameEx(0X4E01, "get_next_dpb", SN_LOCAL);
	MakeFunction    (0X4E1A,0X4E30);
	SetFunctionFlags(0X4E1A,0);
	MakeNameEx(0X4E23, "get_dpb_for_drive_1", SN_LOCAL);
	MakeNameEx(0X4E2F, "got_dpb_for_drive", SN_LOCAL);
	MakeFunction    (0X4E30,0X5232);
	SetFunctionFlags(0X4E30,0);
	MakeFrame(0X4E30, 0, 2, 0);
	MakeNameEx(0X4E43, "multrk_flag_done", SN_LOCAL);
	MakeNameEx(0X4EAB, "dofcbs", SN_LOCAL);
	MakeNameEx(0X4F06, "fillloop", SN_LOCAL);
	MakeNameEx(0X4F2C, "dodefaultbuff", SN_LOCAL);
	MakeNameEx(0X4F45, "nextdpb", SN_LOCAL);
	MakeNameEx(0X4F82, "setbuf", SN_LOCAL);
	MakeNameEx(0X4F8A, "nosetbuf", SN_LOCAL);
	MakeNameEx(0X4F97, "chk_memsize_for_buffers", SN_LOCAL);
	MakeNameEx(0X4FC1, "bufset", SN_LOCAL);
	MakeNameEx(0X4FC3, "dobuff", SN_LOCAL);
	MakeNameEx(0X501D, "xif16", SN_LOCAL);
	MakeNameEx(0X503D, "gotncds", SN_LOCAL);
	MakeNameEx(0X508B, "doinstallstack", SN_LOCAL);
	MakeNameEx(0X50FC, "skipstack", SN_LOCAL);
	MakeNameEx(0X510E, "rcclloop", SN_LOCAL);
	MakeNameEx(0X5126, "goaux", SN_LOCAL);
	MakeNameEx(0X5139, "goaux2", SN_LOCAL);
	MakeNameEx(0X5177, "startrearm", SN_LOCAL);
	MakeNameEx(0X5186, "finishrearm", SN_LOCAL);
	MakeFunction    (0X5232,0X52A7);
	SetFunctionFlags(0X5232,0);
	MakeFrame(0X5232, 0, 6, 0);
	MakeNameEx(0X5245, "installfilename", SN_LOCAL);
	MakeNameEx(0X524C, "got_installparm", SN_LOCAL);
	MakeNameEx(0X5259, "done_installparm", SN_LOCAL);
	MakeNameEx(0X5269, "install_seg_set", SN_LOCAL);
	MakeNameEx(0X5281, "no_envdata2", SN_LOCAL);
	MakeFunction    (0X52B4,0X52C0);
	SetFunctionFlags(0X52B4,0);
	MakeFunction    (0X52F5,0X5322);
	SetFunctionFlags(0X52F5,0);
	MakeFrame(0X52F5, 0, 2, 0);
	MakeNameEx(0X5309, "sum1", SN_LOCAL);
	MakeNameEx(0X530F, "sum_sys_code", SN_LOCAL);
	MakeNameEx(0X5319, "sum2", SN_LOCAL);
	MakeFunction    (0X5341,0X539C);
	SetFunctionFlags(0X5341,0);
	MakeNameEx(0X534A, "set_buff_1", SN_LOCAL);
	MakeNameEx(0X535C, "nxt_buff", SN_LOCAL);
	MakeNameEx(0X538D, "set_buff_2", SN_LOCAL);
	MakeFunction    (0X539C,0X53C4);
	SetFunctionFlags(0X539C,0);
	MakeFrame(0X539C, 0, 4, 0);
	MakeNameEx(0X53C1, "got_hma", SN_LOCAL);
	MakeFunction    (0X53C4,0X53EC);
	SetFunctionFlags(0X53C4,0);
	MakeFunction    (0X53EC,0X5775);
	SetFunctionFlags(0X53EC,0);
	MakeFrame(0X53EC, 0, 18, 0);
	MakeNameEx(0X544F, "buildloop", SN_LOCAL);
	MakeNameEx(0X548D, "skip_disablenmis", SN_LOCAL);
	MakeNameEx(0X54FE, "int_0A_not_first", SN_LOCAL);
	MakeNameEx(0X550D, "int_0A_first", SN_LOCAL);
	MakeNameEx(0X550E, "stkinit_0B", SN_LOCAL);
	MakeNameEx(0X553E, "int_0B_not_first", SN_LOCAL);
	MakeNameEx(0X554D, "int_0B_first", SN_LOCAL);
	MakeNameEx(0X554E, "stkinit_0C", SN_LOCAL);
	MakeNameEx(0X557E, "int_0C_not_first", SN_LOCAL);
	MakeNameEx(0X558D, "int_0C_first", SN_LOCAL);
	MakeNameEx(0X558E, "stkinit_0D", SN_LOCAL);
	MakeNameEx(0X55BE, "int_0D_not_first", SN_LOCAL);
	MakeNameEx(0X55CD, "int_0D_first", SN_LOCAL);
	MakeNameEx(0X55CE, "stkinit_0E", SN_LOCAL);
	MakeNameEx(0X55FE, "int_0E_not_first", SN_LOCAL);
	MakeNameEx(0X560D, "int_0E_first", SN_LOCAL);
	MakeNameEx(0X560E, "stkinit_72", SN_LOCAL);
	MakeNameEx(0X563E, "int_72_not_first", SN_LOCAL);
	MakeNameEx(0X564D, "int_72_first", SN_LOCAL);
	MakeNameEx(0X564E, "stkinit_73", SN_LOCAL);
	MakeNameEx(0X567E, "int_73_not_first", SN_LOCAL);
	MakeNameEx(0X568D, "int_73_first", SN_LOCAL);
	MakeNameEx(0X568E, "stkinit_74", SN_LOCAL);
	MakeNameEx(0X56BE, "int_74_not_first", SN_LOCAL);
	MakeNameEx(0X56CD, "int_74_first", SN_LOCAL);
	MakeNameEx(0X56CE, "stkinit_76", SN_LOCAL);
	MakeNameEx(0X56FE, "int_76_not_first", SN_LOCAL);
	MakeNameEx(0X570D, "int_76_first", SN_LOCAL);
	MakeNameEx(0X570E, "stkinit_77", SN_LOCAL);
	MakeNameEx(0X573E, "int_77_not_first", SN_LOCAL);
	MakeNameEx(0X574D, "int_77_first", SN_LOCAL);
	MakeNameEx(0X574E, "int_77_end", SN_LOCAL);
	MakeNameEx(0X5760, "skip_enablenmis", SN_LOCAL);
	MakeFunction    (0X5775,0X579C);
	SetFunctionFlags(0X5775,0);
	MakeFunction    (0X579C,0X57BC);
	SetFunctionFlags(0X579C,0);
	MakeFrame(0X579C, 0, 4, 0);
	MakeFunction    (0X5872,0X59ED);
	SetFunctionFlags(0X5872,0);
	MakeNameEx(0X58C4, "_$P_Fin", SN_LOCAL);
	MakeNameEx(0X58C8, "_$P_Start", SN_LOCAL);
	MakeNameEx(0X58DC, "_$P_Pack_Loop", SN_LOCAL);
	MakeNameEx(0X58F9, "_$P_Pack_End_backup_si", SN_LOCAL);
	MakeNameEx(0X5904, "_$P_PL01", SN_LOCAL);
	MakeNameEx(0X5911, "_$P_PL00", SN_LOCAL);
	MakeNameEx(0X591E, "_$P_Pack_End_BY_EOL", SN_LOCAL);
	MakeNameEx(0X591F, "_$P_Pack_End", SN_LOCAL);
	MakeNameEx(0X5948, "_$P_Positional_Manager", SN_LOCAL);
	MakeNameEx(0X5967, "_$P_Too_Many_Error", SN_LOCAL);
	MakeNameEx(0X5970, "_$P_SW_Manager", SN_LOCAL);
	MakeNameEx(0X5985, "_$P_SW_Mgr_Loop", SN_LOCAL);
	MakeNameEx(0X5993, "_$P_SW_Not_Found", SN_LOCAL);
	MakeNameEx(0X599C, "_$P_Key_Manager", SN_LOCAL);
	MakeNameEx(0X59BB, "_$P_Key_Mgr_Loop", SN_LOCAL);
	MakeNameEx(0X59C9, "_$P_Key_Not_Found", SN_LOCAL);
	MakeNameEx(0X59D0, "_$P_Return_to_Caller", SN_LOCAL);
	MakeNameEx(0X59EB, "_$P_Single_Exit", SN_LOCAL);
	MakeFunction    (0X59ED,0X5A1F);
	SetFunctionFlags(0X59ED,0);
	MakeFrame(0X59ED, 0, 2, 0);
	MakeNameEx(0X59FB, "_$P_CPC00", SN_LOCAL);
	MakeNameEx(0X5A0F, "_$P_CPC02", SN_LOCAL);
	MakeNameEx(0X5A1A, "_$P_CPC01", SN_LOCAL);
	MakeNameEx(0X5A1D, "_$P_CPC_Exit", SN_LOCAL);
	MakeFunction    (0X5A1F,0X5A21);
	SetFunctionFlags(0X5A1F,0);
	MakeFunction    (0X5A21,0X5A46);
	SetFunctionFlags(0X5A21,0);
	MakeFrame(0X5A21, 0, 4, 0);
	MakeNameEx(0X5A30, "_$P_KEYorSW_Loop", SN_LOCAL);
	MakeNameEx(0X5A3A, "_$P_KEYorSW_Not_Found", SN_LOCAL);
	MakeNameEx(0X5A3D, "_$P_KEYorSW_Found", SN_LOCAL);
	MakeNameEx(0X5A43, "_$P_KEYorSW_Exit", SN_LOCAL);
	MakeFunction    (0X5A46,0X5A52);
	SetFunctionFlags(0X5A46,0);
	MakeNameEx(0X5A50, "_$P_MBP_Exit", SN_LOCAL);
	MakeFunction    (0X5A52,0X5AB5);
	SetFunctionFlags(0X5A52,0);
	MakeNameEx(0X5A8B, "_$P_Chk_if_data_required", SN_LOCAL);
	MakeNameEx(0X5AA1, "_$P_CSW00", SN_LOCAL);
	MakeNameEx(0X5AA7, "_$P_Chk_SW_Err0", SN_LOCAL);
	MakeNameEx(0X5AAA, "_$P_Chk_SW_Exit", SN_LOCAL);
	MakeNameEx(0X5AB4, "_$P_Chk_SW_Single_Exit", SN_LOCAL);
	MakeFunction    (0X5AB5,0X5B3A);
	SetFunctionFlags(0X5AB5,0);
	MakeFrame(0X5AB5, 0, 2, 0);
	MakeNameEx(0X5AD4, "_$P_RLT02", SN_LOCAL);
	MakeNameEx(0X5ADE, "_$P_RLT00", SN_LOCAL);
	MakeNameEx(0X5AE8, "_$P_RLT01", SN_LOCAL);
	MakeNameEx(0X5AFA, "_$P_RLT03", SN_LOCAL);
	MakeNameEx(0X5B0D, "_$P_RLT05", SN_LOCAL);
	MakeNameEx(0X5B21, "_$P_RLT_CAP00", SN_LOCAL);
	MakeNameEx(0X5B2A, "_$P_RLT_CAP02", SN_LOCAL);
	MakeNameEx(0X5B2D, "_$P_RLT_CAP01", SN_LOCAL);
	MakeNameEx(0X5B38, "_$P_RLT_Exit", SN_LOCAL);
	MakeFunction    (0X5B3A,0X5BEC);
	SetFunctionFlags(0X5B3A,0);
	MakeNameEx(0X5B60, "_$P_Mat", SN_LOCAL);
	MakeNameEx(0X5B62, "_$P_Bridge", SN_LOCAL);
	MakeNameEx(0X5B65, "_$P_Match03", SN_LOCAL);
	MakeNameEx(0X5B7C, "_$P_Match04", SN_LOCAL);
	MakeNameEx(0X5B93, "_$P_Match05", SN_LOCAL);
	MakeNameEx(0X5BAD, "_$P_Match06", SN_LOCAL);
	MakeNameEx(0X5BC4, "_$P_Match07", SN_LOCAL);
	MakeNameEx(0X5BD3, "_$P_Match_Exit", SN_LOCAL);
	MakeNameEx(0X5BEA, "_$P_Match2_Exit", SN_LOCAL);
	MakeFunction    (0X5BEC,0X5C12);
	SetFunctionFlags(0X5BEC,0);
	MakeFrame(0X5BEC, 0, 4, 0);
	MakeNameEx(0X5BEE, "_$P_RCOL_Loop", SN_LOCAL);
	MakeNameEx(0X5C06, "_$P_RCOL00", SN_LOCAL);
	MakeNameEx(0X5C0C, "_$P_RCOL01", SN_LOCAL);
	MakeNameEx(0X5C0F, "_$P_RCOL_Exit", SN_LOCAL);
	MakeFunction    (0X5C12,0X5C31);
	SetFunctionFlags(0X5C12,0);
	MakeFrame(0X5C12, 0, 4, 0);
	MakeNameEx(0X5C16, "_$P_DCS_Loop", SN_LOCAL);
	MakeNameEx(0X5C2A, "_$P_DCS00", SN_LOCAL);
	MakeNameEx(0X5C2B, "_$P_DCS01", SN_LOCAL);
	MakeNameEx(0X5C2E, "_$P_DCS_Exit", SN_LOCAL);
	MakeFunction    (0X5C31,0X5C76);
	SetFunctionFlags(0X5C31,0);
	MakeNameEx(0X5C41, "_$P_DCC_Go", SN_LOCAL);
	MakeNameEx(0X5C64, "_$P_DCC01", SN_LOCAL);
	MakeNameEx(0X5C75, "_$P_CAPS_Ret", SN_LOCAL);
	MakeFunction    (0X5C76,0X5C9A);
	SetFunctionFlags(0X5C76,0);
	MakeFrame(0X5C76, 0, 2, 0);
	MakeNameEx(0X5C94, "_$P_SVal00", SN_LOCAL);
	MakeNameEx(0X5C95, "_$P_Sval01", SN_LOCAL);
	MakeFunction    (0X5C9A,0X5D8C);
	SetFunctionFlags(0X5C9A,0);
	MakeFrame(0X5C9A, 0, 8, 0);
	MakeNameEx(0X5CA3, "_$P_Value_Loop", SN_LOCAL);
	MakeNameEx(0X5CE8, "_$P_Value_Err0", SN_LOCAL);
	MakeNameEx(0X5CEC, "_$P_Value00", SN_LOCAL);
	MakeNameEx(0X5CFF, "_$P_Value01", SN_LOCAL);
	MakeNameEx(0X5D11, "_$P_Value02", SN_LOCAL);
	MakeNameEx(0X5D1A, "_$P_Val02_Loop", SN_LOCAL);
	MakeNameEx(0X5D30, "_$P_Val_In", SN_LOCAL);
	MakeNameEx(0X5D40, "_$P_Val02_Sign", SN_LOCAL);
	MakeNameEx(0X5D4E, "_$P_SVal_In", SN_LOCAL);
	MakeNameEx(0X5D5E, "_$P_Val02_Next", SN_LOCAL);
	MakeNameEx(0X5D72, "_$P_Val_Found", SN_LOCAL);
	MakeNameEx(0X5D79, "_$P_Value_Err", SN_LOCAL);
	MakeNameEx(0X5D84, "_$P_Value_Exit", SN_LOCAL);
	MakeFunction    (0X5D8C,0X5D9E);
	SetFunctionFlags(0X5D8C,0);
	MakeNameEx(0X5D97, "_$P_COVF", SN_LOCAL);
	MakeNameEx(0X5D9C, "_$P_COVF00", SN_LOCAL);
	MakeFunction    (0X5D9E,0X5DAC);
	SetFunctionFlags(0X5D9E,0);
	MakeNameEx(0X5DAA, "_$P_0099Err", SN_LOCAL);
	MakeFunction    (0X5DAC,0X5E15);
	SetFunctionFlags(0X5DAC,0);
	MakeFrame(0X5DAC, 0, 8, 0);
	MakeNameEx(0X5DBF, "_$P_Sim00", SN_LOCAL);
	MakeNameEx(0X5DDD, "_$P_Sim_Loop", SN_LOCAL);
	MakeNameEx(0X5DF7, "_$P_Sim_Found", SN_LOCAL);
	MakeNameEx(0X5E02, "_$P_Sim01", SN_LOCAL);
	MakeNameEx(0X5E0B, "_$P_Sim_Exit", SN_LOCAL);
	MakeNameEx(0X5E0D, "_$P_Sim_Exit0", SN_LOCAL);
	MakeFunction    (0X5E15,0X5EB8);
	SetFunctionFlags(0X5E15,0);
	MakeFrame(0X5E15, 0, 8, 0);
	MakeNameEx(0X5E1B, "_$P_SCOM_Loop", SN_LOCAL);
	MakeNameEx(0X5E3B, "_$P_SCOM04", SN_LOCAL);
	MakeNameEx(0X5E4E, "_$P_SCOM05", SN_LOCAL);
	MakeNameEx(0X5E51, "_$P_SCOM03", SN_LOCAL);
	MakeNameEx(0X5E5F, "_$P_SCOM00", SN_LOCAL);
	MakeNameEx(0X5E72, "_$P_SCOM01", SN_LOCAL);
	MakeNameEx(0X5E74, "_$P_SCOM_Differ0", SN_LOCAL);
	MakeNameEx(0X5E8B, "_$P_not_applicable", SN_LOCAL);
	MakeNameEx(0X5E9F, "_$P_SCOM02", SN_LOCAL);
	MakeNameEx(0X5EAA, "_$P_SCOM_Differ", SN_LOCAL);
	MakeNameEx(0X5EAD, "_$P_SCOM_Same", SN_LOCAL);
	MakeNameEx(0X5EB3, "_$P_SCOM_Exit", SN_LOCAL);
	MakeFunction    (0X5EB8,0X5F29);
	SetFunctionFlags(0X5EB8,0);
	MakeFrame(0X5EB8, 0, 6, 0);
	MakeNameEx(0X5EDA, "_$P_FileF_Err", SN_LOCAL);
	MakeNameEx(0X5EF0, "_$P_FileF03", SN_LOCAL);
	MakeNameEx(0X5EF2, "_$P_FileF_Loop1", SN_LOCAL);
	MakeNameEx(0X5F05, "_$P_FileF01", SN_LOCAL);
	MakeNameEx(0X5F09, "_$P_FileF00", SN_LOCAL);
	MakeNameEx(0X5F17, "_$P_FileF_RLT", SN_LOCAL);
	MakeNameEx(0X5F19, "_$P_FileF02", SN_LOCAL);
	MakeNameEx(0X5F28, "_$P_Drv_Only_Exit", SN_LOCAL);
	MakeFunction    (0X5F29,0X5F3E);
	SetFunctionFlags(0X5F29,0);
	MakeFrame(0X5F29, 0, 4, 0);
	MakeNameEx(0X5F32, "_$P_FileSp_Loop", SN_LOCAL);
	MakeNameEx(0X5F3B, "_$P_FileSp_Exit", SN_LOCAL);
	MakeFunction    (0X5F3E,0X5F82);
	SetFunctionFlags(0X5F3E,0);
	MakeFrame(0X5F3E, 0, 4, 0);
	MakeNameEx(0X5F61, "_$P_DrvF00", SN_LOCAL);
	MakeNameEx(0X5F78, "_$P_Drv_Err", SN_LOCAL);
	MakeNameEx(0X5F7F, "_$P_Drv_Exit", SN_LOCAL);
	MakeFunction    (0X5F82,0X5FA8);
	SetFunctionFlags(0X5F82,0);
	MakeNameEx(0X5FA0, "_$P_Skip_Delim_CY", SN_LOCAL);
	MakeNameEx(0X5FA3, "_$P_Skip_Delim_NCY", SN_LOCAL);
	MakeNameEx(0X5FA4, "_$P_Skip_Delim_Exit", SN_LOCAL);
	MakeNameEx(0X5FA6, "_$P_Exit_At_Extra", SN_LOCAL);
	MakeFunction    (0X5FA8,0X5FDE);
	SetFunctionFlags(0X5FA8,0);
	MakeFrame(0X5FA8, 0, 4, 0);
	MakeNameEx(0X5FD1, "_$P_Chk_EOL_Loop", SN_LOCAL);
	MakeNameEx(0X5FD9, "_$P_Chk_EOL_NZ", SN_LOCAL);
	MakeNameEx(0X5FDB, "_$P_Chk_EOL_Exit", SN_LOCAL);
	MakeFunction    (0X5FDE,0X603F);
	SetFunctionFlags(0X5FDE,0);
	MakeFrame(0X5FDE, 0, 4, 0);
	MakeNameEx(0X6008, "$P_Chk_Delim01", SN_LOCAL);
	MakeNameEx(0X601C, "_$P_Chk_Delim_Loop", SN_LOCAL);
	MakeNameEx(0X6024, "_$P_Chk_Delim_NZ", SN_LOCAL);
	MakeNameEx(0X6026, "_$P_Chk_Delim_Exit", SN_LOCAL);
	MakeNameEx(0X6029, "_$P_Chk_Delim_Exit0", SN_LOCAL);
	MakeNameEx(0X603B, "_$P_No_Set_Extra", SN_LOCAL);
	MakeFunction    (0X603F,0X605D);
	SetFunctionFlags(0X603F,0);
	MakeNameEx(0X604E, "_$P_STRUC_L5", SN_LOCAL);
	MakeNameEx(0X6051, "_$P_STRUC_L2", SN_LOCAL);
	MakeNameEx(0X605B, "_$P_STRUC_L12", SN_LOCAL);
	MakeNameEx(0X605C, "_$P_STRUC_L1", SN_LOCAL);
	MakeFunction    (0X605D,0X60B3);
	SetFunctionFlags(0X605D,0);
	MakeFrame(0X605D, 0, 6, 0);
	MakeNameEx(0X608F, "_$P_DBCS00", SN_LOCAL);
	MakeNameEx(0X6099, "_$P_DBCS_LOOP", SN_LOCAL);
	MakeNameEx(0X60AA, "$P_DBCS01", SN_LOCAL);
	MakeNameEx(0X60AE, "_$P_NON_DBCS", SN_LOCAL);
	MakeNameEx(0X60AF, "_$P_DBCS_EXIT", SN_LOCAL);
	MakeFunction    (0X631F,0X63BD);
	SetFunctionFlags(0X631F,0);
	MakeFrame(0X631F, 0, 2, 0);
	MakeNameEx(0X6342, "noprob", SN_LOCAL);
	MakeNameEx(0X6397, "puteol", SN_LOCAL);
	MakeNameEx(0X63B6, "conferr", SN_LOCAL);
	MakeFunction    (0X63BD,0X6952);
	SetFunctionFlags(0X63BD,0);
	MakeFrame(0X63BD, 0, 2, 0);
	MakeNameEx(0X63C4, "jae_endconv", SN_LOCAL);
	MakeNameEx(0X63E8, "conflp", SN_LOCAL);
	MakeNameEx(0X642D, "final", SN_LOCAL);
	MakeNameEx(0X6430, "not_final", SN_LOCAL);
	MakeNameEx(0X6441, "coff", SN_LOCAL);
	MakeNameEx(0X6448, "blank_line", SN_LOCAL);
	MakeNameEx(0X644F, "tryi", SN_LOCAL);
	MakeNameEx(0X6459, "not_init_pass", SN_LOCAL);
	MakeNameEx(0X6476, "multi_pass_coff2", SN_LOCAL);
	MakeNameEx(0X6478, "precheck_installhigh", SN_LOCAL);
	MakeNameEx(0X6484, "multi_try_i", SN_LOCAL);
	MakeNameEx(0X6493, "multi_try_n", SN_LOCAL);
	MakeNameEx(0X64D0, "multi_pass_filter", SN_LOCAL);
	MakeNameEx(0X64DF, "multi_pass_adjust", SN_LOCAL);
	MakeNameEx(0X64E7, "multi_pass_coff", SN_LOCAL);
	MakeNameEx(0X64EA, "tryb", SN_LOCAL);
	MakeNameEx(0X6500, "do7", SN_LOCAL);
	MakeNameEx(0X650A, "if7", SN_LOCAL);
	MakeNameEx(0X6519, "if11", SN_LOCAL);
	MakeNameEx(0X6526, "if13", SN_LOCAL);
	MakeNameEx(0X6529, "en11", SN_LOCAL);
	MakeNameEx(0X652B, "en7", SN_LOCAL);
	MakeNameEx(0X653D, "if18", SN_LOCAL);
	MakeNameEx(0X654F, "sr7", SN_LOCAL);
	MakeNameEx(0X6552, "tryc", SN_LOCAL);
	MakeNameEx(0X6563, "do22", SN_LOCAL);
	MakeNameEx(0X656D, "if22", SN_LOCAL);
	MakeNameEx(0X6580, "if26", SN_LOCAL);
	MakeNameEx(0X6585, "en26", SN_LOCAL);
	MakeNameEx(0X6587, "en22", SN_LOCAL);
	MakeNameEx(0X6591, "sr22", SN_LOCAL);
	MakeNameEx(0X6594, "trym", SN_LOCAL);
	MakeNameEx(0X65A5, "do31", SN_LOCAL);
	MakeNameEx(0X65AF, "if31", SN_LOCAL);
	MakeNameEx(0X65C2, "if35", SN_LOCAL);
	MakeNameEx(0X65C7, "en35", SN_LOCAL);
	MakeNameEx(0X65C9, "en31", SN_LOCAL);
	MakeNameEx(0X65DF, "if39", SN_LOCAL);
	MakeNameEx(0X65E5, "en39", SN_LOCAL);
	MakeNameEx(0X65E6, "sr31", SN_LOCAL);
	MakeNameEx(0X65E9, "multi_try_doshi", SN_LOCAL);
	MakeNameEx(0X65EE, "skip_it", SN_LOCAL);
	MakeNameEx(0X65F1, "it_is_h", SN_LOCAL);
	MakeNameEx(0X65FD, "h_do_parse", SN_LOCAL);
	MakeNameEx(0X6607, "h_parse_ok", SN_LOCAL);
	MakeNameEx(0X6611, "h_end", SN_LOCAL);
	MakeNameEx(0X6614, "tryu", SN_LOCAL);
	MakeNameEx(0X6636, "tryu_1", SN_LOCAL);
	MakeNameEx(0X6653, "tryu_2", SN_LOCAL);
	MakeNameEx(0X6655, "tryu_3", SN_LOCAL);
	MakeNameEx(0X6668, "tryu_4", SN_LOCAL);
	MakeNameEx(0X667F, "NrmTst", SN_LOCAL);
	MakeNameEx(0X6695, "tryd", SN_LOCAL);
	MakeNameEx(0X669A, "skip_it2", SN_LOCAL);
	MakeNameEx(0X669D, "gotd", SN_LOCAL);
	MakeNameEx(0X66B5, "LoadDevice", SN_LOCAL);
	MakeNameEx(0X66FB, "tryd_1", SN_LOCAL);
	MakeNameEx(0X6701, "DevConvLoad", SN_LOCAL);
	MakeNameEx(0X6713, "NoMem", SN_LOCAL);
	MakeNameEx(0X6716, "BadFile", SN_LOCAL);
	MakeNameEx(0X6722, "tryd_2", SN_LOCAL);
	MakeNameEx(0X6728, "LoadDev", SN_LOCAL);
	MakeNameEx(0X6735, "goodld", SN_LOCAL);
	MakeNameEx(0X6761, "got_device_com_cont", SN_LOCAL);
	MakeNameEx(0X6782, "skip_pass_limit", SN_LOCAL);
	MakeNameEx(0X67CF, "tryd_3", SN_LOCAL);
	MakeNameEx(0X67DA, "tryd_4", SN_LOCAL);
	MakeNameEx(0X67E3, "badnumblock", SN_LOCAL);
	MakeNameEx(0X67EB, "erase_dev_do", SN_LOCAL);
	MakeNameEx(0X6804, "no_error_line_msg", SN_LOCAL);
	MakeNameEx(0X6807, "was_device_com", SN_LOCAL);
	MakeNameEx(0X6817, "breakok", SN_LOCAL);
	MakeNameEx(0X6834, "jc_edd", SN_LOCAL);
	MakeNameEx(0X6843, "tryclk", SN_LOCAL);
	MakeNameEx(0X6850, "golink", SN_LOCAL);
	MakeNameEx(0X6853, "isblock", SN_LOCAL);
	MakeNameEx(0X6878, "ok_block", SN_LOCAL);
	MakeNameEx(0X6891, "perunit", SN_LOCAL);
	MakeNameEx(0X689A, "scandpb", SN_LOCAL);
	MakeNameEx(0X68A7, "founddpb", SN_LOCAL);
	MakeNameEx(0X68F0, "iblk_1", SN_LOCAL);
	MakeNameEx(0X690B, "linkit", SN_LOCAL);
	MakeNameEx(0X6940, "coffj3", SN_LOCAL);
	MakeNameEx(0X6998, "bad_bpb_size_sector", SN_LOCAL);
	MakeNameEx(0X69A6, "tryq", SN_LOCAL);
	MakeNameEx(0X69AB, "skip_it3", SN_LOCAL);
	MakeNameEx(0X69AE, "tryq_cont", SN_LOCAL);
	MakeNameEx(0X69C7, "do52", SN_LOCAL);
	MakeNameEx(0X69D8, "if52", SN_LOCAL);
	MakeNameEx(0X69F4, "if57", SN_LOCAL);
	MakeNameEx(0X69F8, "en57", SN_LOCAL);
	MakeNameEx(0X69FA, "if56", SN_LOCAL);
	MakeNameEx(0X6A0F, "en56", SN_LOCAL);
	MakeNameEx(0X6A11, "sr52", SN_LOCAL);
	MakeNameEx(0X6A1C, "tryqbad", SN_LOCAL);
	MakeNameEx(0X6A23, "tryq_open", SN_LOCAL);
	MakeNameEx(0X6A30, "tryq_def", SN_LOCAL);
	MakeNameEx(0X6A33, "tryq_openit", SN_LOCAL);
	MakeNameEx(0X6A64, "tryq_set_for_dos", SN_LOCAL);
	MakeNameEx(0X6A84, "tryqfilebad", SN_LOCAL);
	MakeNameEx(0X6A93, "tryqdefbad", SN_LOCAL);
	MakeNameEx(0X6A96, "tryqbadload", SN_LOCAL);
	MakeNameEx(0X6AA2, "tryqmemory", SN_LOCAL);
	MakeNameEx(0X6AA5, "tryqchkerr", SN_LOCAL);
	MakeNameEx(0X6AB6, "coffj4", SN_LOCAL);
	MakeNameEx(0X6AD6, "tryf", SN_LOCAL);
	MakeNameEx(0X6AE7, "do67", SN_LOCAL);
	MakeNameEx(0X6AF1, "if67", SN_LOCAL);
	MakeNameEx(0X6B00, "en67", SN_LOCAL);
	MakeNameEx(0X6B08, "sr67", SN_LOCAL);
	MakeNameEx(0X6B0B, "tryl", SN_LOCAL);
	MakeNameEx(0X6B1C, "do73", SN_LOCAL);
	MakeNameEx(0X6B26, "if73", SN_LOCAL);
	MakeNameEx(0X6B35, "en73", SN_LOCAL);
	MakeNameEx(0X6B3D, "badparm_p_coff", SN_LOCAL);
	MakeNameEx(0X6B40, "tryp", SN_LOCAL);
	MakeNameEx(0X6B58, "trypbad", SN_LOCAL);
	MakeNameEx(0X6B5B, "tryk", SN_LOCAL);
	MakeNameEx(0X6B60, "skip_it4", SN_LOCAL);
	MakeNameEx(0X6B63, "do_tryk", SN_LOCAL);
	MakeNameEx(0X6B6F, "do79", SN_LOCAL);
	MakeNameEx(0X6B80, "if79", SN_LOCAL);
	MakeNameEx(0X6B94, "if83", SN_LOCAL);
	MakeNameEx(0X6B98, "en83", SN_LOCAL);
	MakeNameEx(0X6B9A, "en79", SN_LOCAL);
	MakeNameEx(0X6BB2, "ll88", SN_LOCAL);
	MakeNameEx(0X6BB9, "if88", SN_LOCAL);
	MakeNameEx(0X6BBB, "if87", SN_LOCAL);
	MakeNameEx(0X6BCA, "en87", SN_LOCAL);
	MakeNameEx(0X6BF2, "if94", SN_LOCAL);
	MakeNameEx(0X6C09, "sr79", SN_LOCAL);
	MakeNameEx(0X6C0C, "trys", SN_LOCAL);
	MakeNameEx(0X6C29, "storeshell", SN_LOCAL);
	MakeNameEx(0X6C3F, "getshparms", SN_LOCAL);
	MakeNameEx(0X6C45, "parmloop", SN_LOCAL);
	MakeNameEx(0X6C55, "endofparms", SN_LOCAL);
	MakeNameEx(0X6C60, "endofshell", SN_LOCAL);
	MakeNameEx(0X6C63, "skipline", SN_LOCAL);
	MakeNameEx(0X6C6C, "endofline", SN_LOCAL);
	MakeNameEx(0X6C6F, "tryx", SN_LOCAL);
	MakeNameEx(0X6C80, "do98", SN_LOCAL);
	MakeNameEx(0X6C8A, "if98", SN_LOCAL);
	MakeNameEx(0X6C9E, "if102", SN_LOCAL);
	MakeNameEx(0X6CA2, "en102", SN_LOCAL);
	MakeNameEx(0X6CA4, "en98", SN_LOCAL);
	MakeNameEx(0X6CB2, "sr98", SN_LOCAL);
	MakeNameEx(0X6CB5, "try1", SN_LOCAL);
	MakeNameEx(0X6CBA, "skip_it5", SN_LOCAL);
	MakeNameEx(0X6CBD, "do_try1", SN_LOCAL);
	MakeNameEx(0X6CC9, "do110", SN_LOCAL);
	MakeNameEx(0X6CD3, "if110", SN_LOCAL);
	MakeNameEx(0X6CE9, "if115", SN_LOCAL);
	MakeNameEx(0X6CFA, "if116", SN_LOCAL);
	MakeNameEx(0X6D0B, "en110", SN_LOCAL);
	MakeNameEx(0X6D23, "if117", SN_LOCAL);
	MakeNameEx(0X6D40, "skip_dos_flag", SN_LOCAL);
	MakeNameEx(0X6D41, "sr110", SN_LOCAL);
	MakeNameEx(0X6D44, "tryv", SN_LOCAL);
	MakeNameEx(0X6D53, "err", SN_LOCAL);
	MakeNameEx(0X6D58, "tryn", SN_LOCAL);
	MakeNameEx(0X6D69, "tryy", SN_LOCAL);
	MakeNameEx(0X6D6E, "donothing", SN_LOCAL);
	MakeNameEx(0X6D79, "try0", SN_LOCAL);
	MakeNameEx(0X6DDB, "badop", SN_LOCAL);
	MakeFunction    (0X6952,0X6998);
	SetFunctionFlags(0X6952,0);
	MakeNameEx(0X6979, "magic_not_yet_home", SN_LOCAL);
	MakeNameEx(0X6997, "no_more_magic_calls", SN_LOCAL);
	MakeFunction    (0X6AC2,0X6AD6);
	SetFunctionFlags(0X6AC2,0);
	MakeNameEx(0X6ACC, "if64", SN_LOCAL);
	MakeNameEx(0X6ACF, "en64", SN_LOCAL);
	MakeFunction    (0X6D8D,0X6DA8);
	SetFunctionFlags(0X6D8D,0);
	MakeFrame(0X6D8D, 0, 2, 0);
	MakeNameEx(0X6DA6, "CheckProtmanDone", SN_LOCAL);
	MakeFunction    (0X6DA8,0X6DCF);
	SetFunctionFlags(0X6DA8,0);
	MakeFrame(0X6DA8, 0, 6, 0);
	MakeNameEx(0X6DC8, "ll4", SN_LOCAL);
	MakeNameEx(0X6DCB, "if4", SN_LOCAL);
	MakeNameEx(0X6DCC, "en4", SN_LOCAL);
	MakeFunction    (0X6DE7,0X6E13);
	SetFunctionFlags(0X6DE7,0);
	MakeFrame(0X6DE7, 0, 8, 0);
	MakeNameEx(0X6DF6, "do1", SN_LOCAL);
	MakeNameEx(0X6E04, "en1", SN_LOCAL);
	MakeFunction    (0X6E13,0X6E2F);
	SetFunctionFlags(0X6E13,0);
	MakeFrame(0X6E13, 0, 2, 0);
	MakeNameEx(0X6E2A, "get_ret", SN_LOCAL);
	MakeNameEx(0X6E2C, "nochar", SN_LOCAL);
	MakeFunction    (0X6E39,0X6E45);
	SetFunctionFlags(0X6E39,0);
	MakeFrame(0X6E39, 0, 2, 0);
	MakeFunction    (0X6E45,0X6E74);
	SetFunctionFlags(0X6E45,0);
	MakeFrame(0X6E45, 0, 8, 0);
	MakeNameEx(0X6E56, "sln_loop", SN_LOCAL);
	MakeNameEx(0X6E67, "sln_last", SN_LOCAL);
	MakeFunction    (0X6E74,0X6E9F);
	SetFunctionFlags(0X6E74,0);
	MakeNameEx(0X6E8A, "pd_umb", SN_LOCAL);
	MakeNameEx(0X6E91, "pd_lo", SN_LOCAL);
	MakeNameEx(0X6E98, "pd_hi", SN_LOCAL);
	MakeFunction    (0X6E9F,0X6EB8);
	SetFunctionFlags(0X6E9F,0);
	MakeNameEx(0X6EB4, "lim_set", SN_LOCAL);
	MakeNameEx(0X6EB7, "limx", SN_LOCAL);
	MakeFunction    (0X6EB8,0X6ED6);
	SetFunctionFlags(0X6EB8,0);
	MakeFrame(0X6EB8, 0, 2, 0);
	MakeFunction    (0X6ED6,0X6EF3);
	SetFunctionFlags(0X6ED6,0);
	MakeNameEx(0X6EF2, "timx", SN_LOCAL);
	MakeFunction    (0X6EF3,0X6F0C);
	SetFunctionFlags(0X6EF3,0);
	MakeFrame(0X6EF3, 0, 6, 0);
	MakeFunction    (0X6F0C,0X6F1E);
	SetFunctionFlags(0X6F0C,0);
	MakeFrame(0X6F0C, 0, 2, 0);
	MakeFunction    (0X6F1E,0X6F52);
	SetFunctionFlags(0X6F1E,0);
	MakeFrame(0X6F1E, 0, 10, 0);
	MakeFunction    (0X6F52,0X6FA9);
	SetFunctionFlags(0X6F52,0);
	MakeFrame(0X6F52, 0, 10, 0);
	MakeNameEx(0X6F66, "fm10", SN_LOCAL);
	MakeNameEx(0X6F8B, "fm30", SN_LOCAL);
	MakeNameEx(0X6FA0, "fmX", SN_LOCAL);
	MakeFunction    (0X6FA9,0X6FBF);
	SetFunctionFlags(0X6FA9,0);
	MakeFunction    (0X6FBF,0X6FCF);
	SetFunctionFlags(0X6FBF,0);
	MakeFunction    (0X6FCF,0X7012);
	SetFunctionFlags(0X6FCF,0);
	MakeFrame(0X6FCF, 0, 8, 0);
	MakeNameEx(0X6FD5, "pv10", SN_LOCAL);
	MakeNameEx(0X6FE3, "pv20", SN_LOCAL);
	MakeNameEx(0X6FF9, "pv30", SN_LOCAL);
	MakeNameEx(0X7008, "pvE1", SN_LOCAL);
	MakeNameEx(0X700B, "pvErr", SN_LOCAL);
	MakeNameEx(0X700E, "pvX", SN_LOCAL);
	MakeFunction    (0X7012,0X706F);
	SetFunctionFlags(0X7012,0);
	MakeNameEx(0X7017, "pl10", SN_LOCAL);
	MakeNameEx(0X7061, "plE1", SN_LOCAL);
	MakeNameEx(0X7067, "plE2", SN_LOCAL);
	MakeNameEx(0X706C, "plSwX", SN_LOCAL);
	MakeNameEx(0X706D, "plX", SN_LOCAL);
	MakeFunction    (0X706F,0X7083);
	SetFunctionFlags(0X706F,0);
	MakeFrame(0X706F, 0, 6, 0);
	MakeFunction    (0X7083,0X708E);
	SetFunctionFlags(0X7083,0);
	MakeNameEx(0X708D, "ieX", SN_LOCAL);
	MakeFunction    (0X708E,0X7099);
	SetFunctionFlags(0X708E,0);
	MakeNameEx(0X7098, "iwX", SN_LOCAL);
	MakeFunction    (0X7099,0X70BB);
	SetFunctionFlags(0X7099,0);
	MakeFrame(0X7099, 0, 10, 0);
	MakeNameEx(0X70B6, "umu10", SN_LOCAL);
	MakeFunction    (0X70BB,0X70EF);
	SetFunctionFlags(0X70BB,0);
	MakeNameEx(0X70C1, "su10", SN_LOCAL);
	MakeNameEx(0X70D4, "su20", SN_LOCAL);
	MakeNameEx(0X70E9, "su30", SN_LOCAL);
	MakeFunction    (0X70EF,0X7103);
	SetFunctionFlags(0X70EF,0);
	MakeFrame(0X70EF, 0, 8, 0);
	MakeFunction    (0X7105,0X7139);
	SetFunctionFlags(0X7105,0);
	MakeNameEx(0X711B, "td20", SN_LOCAL);
	MakeNameEx(0X7129, "td10", SN_LOCAL);
	MakeNameEx(0X7137, "tdE", SN_LOCAL);
	MakeFunction    (0X7139,0X718E);
	SetFunctionFlags(0X7139,0);
	MakeFrame(0X7139, 0, 6, 0);
	MakeNameEx(0X7166, "gxn10", SN_LOCAL);
	MakeNameEx(0X716F, "gxn20", SN_LOCAL);
	MakeNameEx(0X7185, "gxnE", SN_LOCAL);
	MakeNameEx(0X7188, "gxnQ", SN_LOCAL);
	MakeNameEx(0X718A, "gxnX", SN_LOCAL);
	MakeFunction    (0X718E,0X71AB);
	SetFunctionFlags(0X718E,0);
	MakeFrame(0X718E, 0, 2, 0);
	MakeNameEx(0X71A9, "m32E", SN_LOCAL);
	MakeFunction    (0X71AB,0X71B9);
	SetFunctionFlags(0X71AB,0);
	MakeFrame(0X71AB, 0, 2, 0);
	MakeFunction    (0X71B9,0X71D1);
	SetFunctionFlags(0X71B9,0);
	MakeFrame(0X71B9, 0, 6, 0);
	MakeNameEx(0X71CC, "uhE", SN_LOCAL);
	MakeNameEx(0X71CD, "uhX", SN_LOCAL);
	MakeFunction    (0X71D1,0X71EB);
	SetFunctionFlags(0X71D1,0);
	MakeFrame(0X71D1, 0, 2, 0);
	MakeNameEx(0X71E2, "ism10", SN_LOCAL);
	MakeNameEx(0X71E9, "ismX", SN_LOCAL);
	MakeFunction    (0X71EB,0X722D);
	SetFunctionFlags(0X71EB,0);
	MakeFrame(0X71EB, 0, 6, 0);
	MakeNameEx(0X71F9, "atu10", SN_LOCAL);
	MakeNameEx(0X7205, "atu20", SN_LOCAL);
	MakeNameEx(0X7219, "atu30", SN_LOCAL);
	MakeNameEx(0X7224, "atuE", SN_LOCAL);
	MakeNameEx(0X7227, "atuX", SN_LOCAL);
	MakeFunction    (0X722D,0X723F);
	SetFunctionFlags(0X722D,0);
	MakeNameEx(0X723E, "cu10", SN_LOCAL);
	MakeFunction    (0X723F,0X7247);
	SetFunctionFlags(0X723F,0);
	MakeFrame(0X723F, 0, 4, 0);
	MakeFunction    (0X725F,0X72A4);
	SetFunctionFlags(0X725F,0);
	MakeFrame(0X725F, 0, 8, 0);
	MakeNameEx(0X7281, "hus10", SN_LOCAL);
	MakeNameEx(0X7295, "hus20", SN_LOCAL);
	MakeNameEx(0X729F, "husX", SN_LOCAL);
	MakeFunction    (0X72A4,0X72AC);
	SetFunctionFlags(0X72A4,0);
	MakeFrame(0X72A4, 0, 4, 0);
	MakeFunction    (0X72AC,0X72C4);
	SetFunctionFlags(0X72AC,0);
	MakeFrame(0X72AC, 0, 8, 0);
	MakeFunction    (0X72C4,0X72D9);
	SetFunctionFlags(0X72C4,0);
	MakeFrame(0X72C4, 0, 8, 0);
	MakeFunction    (0X72E2,0X72F5);
	SetFunctionFlags(0X72E2,0);
	MakeFrame(0X72E2, 0, 6, 0);
	MakeNameEx(0X72F3, "sls10", SN_LOCAL);
	MakeFunction    (0X72F5,0X7320);
	SetFunctionFlags(0X72F5,0);
	MakeFrame(0X72F5, 0, 4, 0);
	MakeNameEx(0X72FC, "hu10", SN_LOCAL);
	MakeNameEx(0X7309, "hu20", SN_LOCAL);
	MakeNameEx(0X731D, "huX", SN_LOCAL);
	MakeFunction    (0X7320,0X732C);
	SetFunctionFlags(0X7320,0);
	MakeFrame(0X7320, 0, 6, 0);
	MakeFunction    (0X732C,0X7333);
	SetFunctionFlags(0X732C,0);
	MakeFunction    (0X7333,0X7357);
	SetFunctionFlags(0X7333,0);
	MakeFunction    (0X7357,0X7374);
	SetFunctionFlags(0X7357,0);
	MakeFrame(0X7357, 0, 2, 0);
	MakeFunction    (0X7374,0X73A5);
	SetFunctionFlags(0X7374,0);
	MakeFrame(0X7374, 0, 6, 0);
	MakeNameEx(0X7382, "fu10", SN_LOCAL);
	MakeNameEx(0X738C, "fu20", SN_LOCAL);
	MakeNameEx(0X73A0, "fuE", SN_LOCAL);
	MakeNameEx(0X73A1, "fuX", SN_LOCAL);
	MakeFunction    (0X73A5,0X73E8);
	SetFunctionFlags(0X73A5,0);
	MakeFrame(0X73A5, 0, 4, 0);
	MakeNameEx(0X73B0, "bf10", SN_LOCAL);
	MakeNameEx(0X73C8, "bf20", SN_LOCAL);
	MakeNameEx(0X73DC, "bf30", SN_LOCAL);
	MakeNameEx(0X73E5, "bfX", SN_LOCAL);
	MakeFunction    (0X73E8,0X73F9);
	SetFunctionFlags(0X73E8,0);
	MakeFrame(0X73E8, 0, 2, 0);
	MakeFunction    (0X73F9,0X7456);
	SetFunctionFlags(0X73F9,0);
	MakeFrame(0X73F9, 0, 6, 0);
	MakeNameEx(0X7451, "smE", SN_LOCAL);
	MakeNameEx(0X7452, "smX", SN_LOCAL);
	MakeFunction    (0X7456,0X74A6);
	SetFunctionFlags(0X7456,0);
	MakeFrame(0X7456, 0, 6, 0);
	MakeNameEx(0X747D, "hu_10", SN_LOCAL);
	MakeNameEx(0X748B, "hu_20", SN_LOCAL);
	MakeNameEx(0X7494, "hu_30", SN_LOCAL);
	MakeNameEx(0X74A2, "hu_X", SN_LOCAL);
	MakeFunction    (0X74A6,0X74CE);
	SetFunctionFlags(0X74A6,0);
	MakeFrame(0X74A6, 0, 4, 0);
	MakeNameEx(0X74AF, "uf10", SN_LOCAL);
	MakeNameEx(0X74B7, "uf20", SN_LOCAL);
	MakeNameEx(0X74CB, "ufX", SN_LOCAL);
	MakeFunction    (0X74CE,0X74FC);
	SetFunctionFlags(0X74CE,0);
	MakeFrame(0X74CE, 0, 2, 0);
	MakeNameEx(0X74FA, "ifmX", SN_LOCAL);
	MakeFunction    (0X74FC,0X7520);
	SetFunctionFlags(0X74FC,0);
	MakeFunction    (0X7520,0X755D);
	SetFunctionFlags(0X7520,0);
	MakeFrame(0X7520, 0, 8, 0);
	MakeNameEx(0X7532, "fum10", SN_LOCAL);
	MakeNameEx(0X7538, "fum20", SN_LOCAL);
	MakeNameEx(0X7544, "fum30", SN_LOCAL);
	MakeNameEx(0X7558, "fumX", SN_LOCAL);
	MakeFunction    (0X755D,0X7571);
	SetFunctionFlags(0X755D,0);
	MakeFrame(0X755D, 0, 8, 0);
	MakeFunction    (0X7571,0X759B);
	SetFunctionFlags(0X7571,0);
	MakeFrame(0X7571, 0, 6, 0);
	MakeNameEx(0X757E, "um10", SN_LOCAL);
	MakeNameEx(0X7592, "um20", SN_LOCAL);
	MakeFunction    (0X759B,0X75AB);
	SetFunctionFlags(0X759B,0);
	MakeFunction    (0X75AB,0X75D0);
	SetFunctionFlags(0X75AB,0);
	MakeFrame(0X75AB, 0, 6, 0);
	MakeNameEx(0X75BA, "uhu10", SN_LOCAL);
	MakeFunction    (0X75D0,0X75E0);
	SetFunctionFlags(0X75D0,0);
	MakeFunction    (0X75E0,0X7608);
	SetFunctionFlags(0X75E0,0);
	MakeFrame(0X75E0, 0, 4, 0);
	MakeNameEx(0X75E9, "fus10", SN_LOCAL);
	MakeNameEx(0X75F1, "fus20", SN_LOCAL);
	MakeNameEx(0X7605, "fusX", SN_LOCAL);
	MakeFunction    (0X7608,0X7635);
	SetFunctionFlags(0X7608,0);
	MakeFrame(0X7608, 0, 2, 0);
	MakeNameEx(0X7633, "ihm_x", SN_LOCAL);
	MakeFunction    (0X7635,0X7650);
	SetFunctionFlags(0X7635,0);
	MakeFunction    (0X7650,0X7668);
	SetFunctionFlags(0X7650,0);
	MakeFrame(0X7650, 0, 6, 0);
	MakeNameEx(0X7663, "xhu_e", SN_LOCAL);
	MakeNameEx(0X7664, "xhu_x", SN_LOCAL);
	MakeFunction    (0X7668,0X767A);
	SetFunctionFlags(0X7668,0);
	MakeNameEx(0X7679, "lumbX", SN_LOCAL);
	MakeFunction    (0X767A,0X76E3);
	SetFunctionFlags(0X767A,0);
	MakeNameEx(0X769F, "InitForConv", SN_LOCAL);
	MakeNameEx(0X76AC, "InitForHi", SN_LOCAL);
	MakeNameEx(0X76BC, "InitForLo", SN_LOCAL);
	MakeNameEx(0X76CB, "idl1", SN_LOCAL);
	MakeFunction    (0X76E3,0X76FE);
	SetFunctionFlags(0X76E3,0);
	MakeNameEx(0X76F7, "spcinumb1", SN_LOCAL);
	MakeFunction    (0X76FE,0X771D);
	SetFunctionFlags(0X76FE,0);
	MakeFrame(0X76FE, 0, 2, 0);
	MakeFunction    (0X771D,0X774F);
	SetFunctionFlags(0X771D,0);
	MakeNameEx(0X773F, "gufd_err", SN_LOCAL);
	MakeFunction    (0X774F,0X779E);
	SetFunctionFlags(0X774F,0);
	MakeFrame(0X774F, 0, 8, 0);
	MakeNameEx(0X7769, "dsm_again", SN_LOCAL);
	MakeNameEx(0X7772, "isit_slash", SN_LOCAL);
	MakeNameEx(0X777A, "isit_null", SN_LOCAL);
	MakeNameEx(0X7786, "dsm_next_char", SN_LOCAL);
	MakeNameEx(0X7792, "blankout", SN_LOCAL);
	MakeNameEx(0X7798, "dsm_exit", SN_LOCAL);
	MakeFunction    (0X779E,0X77E4);
	SetFunctionFlags(0X779E,0);
	MakeFrame(0X779E, 0, 4, 0);
	MakeNameEx(0X77CC, "szdev1", SN_LOCAL);
	MakeNameEx(0X77DB, "sd_close", SN_LOCAL);
	MakeNameEx(0X77E2, "sd_err", SN_LOCAL);
	MakeFunction    (0X77E4,0X7801);
	SetFunctionFlags(0X77E4,0);
	MakeFunction    (0X7801,0X7815);
	SetFunctionFlags(0X7801,0);
	MakeNameEx(0X7813, "rfUM1", SN_LOCAL);
	MakeFunction    (0X7815,0X7828);
	SetFunctionFlags(0X7815,0);
	MakeNameEx(0X781F, "rn_gotnull", SN_LOCAL);
	MakeFunction    (0X7828,0X784A);
	SetFunctionFlags(0X7828,0);
	MakeNameEx(0X7849, "rba_ok", SN_LOCAL);
	MakeFunction    (0X784A,0X786F);
	SetFunctionFlags(0X784A,0);
	MakeFrame(0X784A, 0, 2, 0);
	MakeNameEx(0X7866, "set_break_continue", SN_LOCAL);
	MakeNameEx(0X786C, "break_failed", SN_LOCAL);
	MakeFunction    (0X786F,0X78A1);
	SetFunctionFlags(0X786F,0);
	MakeFrame(0X786F, 0, 2, 0);
	MakeNameEx(0X7893, "db_lo", SN_LOCAL);
	MakeNameEx(0X789F, "db_exit", SN_LOCAL);
	MakeFunction    (0X78A1,0X78E9);
	SetFunctionFlags(0X78A1,0);
	MakeFrame(0X78A1, 0, 2, 0);
	MakeNameEx(0X78E1, "ps_no_size", SN_LOCAL);
	MakeNameEx(0X78E6, "ps_err", SN_LOCAL);
	MakeFunction    (0X78E9,0X78F5);
	SetFunctionFlags(0X78E9,0);
	MakeNameEx(0X78F4, "sd_ret", SN_LOCAL);
	MakeFunction    (0X78F5,0X793C);
	SetFunctionFlags(0X78F5,0);
	MakeNameEx(0X78F9, "ghn_next", SN_LOCAL);
	MakeNameEx(0X7917, "ghn_shift1", SN_LOCAL);
	MakeNameEx(0X7922, "ghn_into_paras", SN_LOCAL);
	MakeNameEx(0X7931, "ghn_shift2", SN_LOCAL);
	MakeNameEx(0X793A, "ghn_err", SN_LOCAL);
	MakeFunction    (0X793C,0X795A);
	SetFunctionFlags(0X793C,0);
	MakeNameEx(0X794A, "is_it_hex", SN_LOCAL);
	MakeNameEx(0X7958, "gnib_err", SN_LOCAL);
	MakeFunction    (0X795A,0X796D);
	SetFunctionFlags(0X795A,0);
	MakeNameEx(0X795F, "au_next", SN_LOCAL);
	MakeNameEx(0X7969, "au_coalesce", SN_LOCAL);
	MakeNameEx(0X796C, "au_exit", SN_LOCAL);
	MakeFunction    (0X796D,0X79A1);
	SetFunctionFlags(0X796D,0);
	MakeNameEx(0X799D, "ia_1", SN_LOCAL);
	MakeNameEx(0X799F, "iau_err", SN_LOCAL);
	MakeFunction    (0X79A1,0X79C2);
	SetFunctionFlags(0X79A1,0);
	MakeFrame(0X79A1, 0, 2, 0);
	MakeNameEx(0X79BD, "ua_done", SN_LOCAL);
	MakeNameEx(0X79BF, "ua_err", SN_LOCAL);
	MakeFunction    (0X79C2,0X7A81);
	SetFunctionFlags(0X79C2,0);
	MakeFrame(0X79C2, 0, 2, 0);
	MakeNameEx(0X79D0, "ui_next", SN_LOCAL);
	MakeNameEx(0X79E3, "ui_insert", SN_LOCAL);
	MakeNameEx(0X7A38, "ui_append", SN_LOCAL);
	MakeNameEx(0X7A7F, "ui_done", SN_LOCAL);
	MakeFunction    (0X7A81,0X7ABD);
	SetFunctionFlags(0X7A81,0);
	MakeNameEx(0X7A8D, "uc_nextfree", SN_LOCAL);
	MakeNameEx(0X7A9F, "uc_again", SN_LOCAL);
	MakeNameEx(0X7ABC, "uc_done", SN_LOCAL);
	MakeFunction    (0X7ABD,0X7AD1);
	SetFunctionFlags(0X7ABD,0);
	MakeNameEx(0X7ACF, "gn_err", SN_LOCAL);
	MakeFunction    (0X7AD1,0X7B49);
	SetFunctionFlags(0X7AD1,0);
	MakeNameEx(0X7B27, "scannext", SN_LOCAL);
	MakeNameEx(0X7B39, "got_last", SN_LOCAL);
	MakeNameEx(0X7B47, "lfu_er", SN_LOCAL);
	MakeFunction    (0X7B49,0X7B76);
	SetFunctionFlags(0X7B49,0);
	MakeNameEx(0X7B75, "su_exit", SN_LOCAL);
	MakeFunction    (0X7B76,0X7BA4);
	SetFunctionFlags(0X7B76,0);
	MakeFrame(0X7B76, 0, 4, 0);
	MakeNameEx(0X7B8F, "ulu_next", SN_LOCAL);
	MakeNameEx(0X7B9C, "ulu_found", SN_LOCAL);
	MakeNameEx(0X7BA1, "ulu_x", SN_LOCAL);
	MakeFunction    (0X7BB2,0X7DCE);
	SetFunctionFlags(0X7BB2,0);
	MakeNameEx(0X7C00, "pre_exit_memory_err1", SN_LOCAL);
	MakeNameEx(0X7C03, "pre_exit1", SN_LOCAL);
	MakeNameEx(0X7C06, "_LoadDev", SN_LOCAL);
	MakeNameEx(0X7C60, "no_driver_version_fail", SN_LOCAL);
	MakeNameEx(0X7C64, "fail_driver_load", SN_LOCAL);
	MakeNameEx(0X7C73, "pre_exit3", SN_LOCAL);
	MakeNameEx(0X7C75, "magic_is_resident", SN_LOCAL);
	MakeNameEx(0X7CC0, "cant_move_driver", SN_LOCAL);
	MakeNameEx(0X7CDA, "pre_exit_memory_err", SN_LOCAL);
	MakeNameEx(0X7CDD, "pre_exit_2", SN_LOCAL);
	MakeNameEx(0X7CE0, "_isblock", SN_LOCAL);
	MakeNameEx(0X7D0C, "_perunit", SN_LOCAL);
	MakeNameEx(0X7D15, "_scandpb", SN_LOCAL);
	MakeNameEx(0X7D22, "pre_exit_too_many_units_err", SN_LOCAL);
	MakeNameEx(0X7D27, "pre_exit_no_units_err", SN_LOCAL);
	MakeNameEx(0X7D2A, "pre_exit2", SN_LOCAL);
	MakeNameEx(0X7D2D, "_foundpb", SN_LOCAL);
	MakeNameEx(0X7DCB, "pre_exit", SN_LOCAL);
	MakeFunction    (0X7DCE,0X7E4F);
	SetFunctionFlags(0X7DCE,0);
	MakeNameEx(0X7E4E, "no_magic", SN_LOCAL);
	MakeFunction    (0X7E4F,0X7E96);
	SetFunctionFlags(0X7E4F,0);
	MakeNameEx(0X7E74, "magic_set_cdss_1", SN_LOCAL);
	MakeNameEx(0X7E8E, "magic_set_cdss_2", SN_LOCAL);
	MakeNameEx(0X7E95, "magic_set_exit", SN_LOCAL);
	MakeFunction    (0X7EA9,0X7EF3);
	SetFunctionFlags(0X7EA9,0);
	MakeFrame(0X7EA9, 0, 12, 0);
	MakeNameEx(0X7EE0, "not_ec35", SN_LOCAL);
	MakeNameEx(0X7EED, "eot_ok", SN_LOCAL);
	MakeFunction    (0X7EF3,0X7F0F);
	SetFunctionFlags(0X7EF3,0);
	MakeFrame(0X7EF3, 0, 4, 0);
	MakeFunction    (0X7F0F,0X7F61);
	SetFunctionFlags(0X7F0F,0);
	MakeFrame(0X7F0F, 0, 4, 0);
	MakeNameEx(0X7F12, "nextswtch", SN_LOCAL);
	MakeNameEx(0X7F25, "getparm", SN_LOCAL);
	MakeNameEx(0X7F2E, "getnext", SN_LOCAL);
	MakeNameEx(0X7F35, "swterr", SN_LOCAL);
	MakeNameEx(0X7F37, "done_line", SN_LOCAL);
	MakeNameEx(0X7F42, "okay", SN_LOCAL);
	MakeNameEx(0X7F55, "exitpl", SN_LOCAL);
	MakeNameEx(0X7F57, "put_back", SN_LOCAL);
	MakeFunction    (0X7F61,0X7FB9);
	SetFunctionFlags(0X7F61,0);
	MakeNameEx(0X7FB3, "done_swtch", SN_LOCAL);
	MakeNameEx(0X7FB5, "err_swtch", SN_LOCAL);
	MakeNameEx(0X7FB7, "err_chk", SN_LOCAL);
	MakeFunction    (0X7FB9,0X7FF4);
	SetFunctionFlags(0X7FB9,0);
	MakeNameEx(0X7FCA, "try_f", SN_LOCAL);
	MakeNameEx(0X7FD5, "try_t", SN_LOCAL);
	MakeNameEx(0X7FE4, "try_s", SN_LOCAL);
	MakeNameEx(0X7FEF, "try_h", SN_LOCAL);
	MakeNameEx(0X7FF2, "done_ret", SN_LOCAL);
	MakeFunction    (0X7FF4,0X8097);
	SetFunctionFlags(0X7FF4,0);
	MakeFrame(0X7FF4, 0, 4, 0);
	MakeNameEx(0X8008, "got_80", SN_LOCAL);
	MakeNameEx(0X8026, "see_heads", SN_LOCAL);
	MakeNameEx(0X8034, "heads_not_altered", SN_LOCAL);
	MakeNameEx(0X805A, "not_144m", SN_LOCAL);
	MakeNameEx(0X806C, "only_one_head", SN_LOCAL);
	MakeNameEx(0X807E, "got_one_secperclus_drive", SN_LOCAL);
	MakeNameEx(0X8083, "got_correct_mediaid", SN_LOCAL);
	MakeFunction    (0X8097,0X82A0);
	SetFunctionFlags(0X8097,0);
	MakeNameEx(0X80AA, "org1", SN_LOCAL);
	MakeNameEx(0X80BC, "end_commd_line", SN_LOCAL);
	MakeNameEx(0X80C5, "nochar1", SN_LOCAL);
	MakeNameEx(0X80C7, "findit", SN_LOCAL);
	MakeNameEx(0X80D2, "findcom", SN_LOCAL);
	MakeNameEx(0X80DF, "loopcom", SN_LOCAL);
	MakeNameEx(0X810F, "semicolon", SN_LOCAL);
	MakeNameEx(0X8113, "no_query", SN_LOCAL);
	MakeNameEx(0X8119, "gotcom0", SN_LOCAL);
	MakeNameEx(0X811E, "nocom", SN_LOCAL);
	MakeNameEx(0X8124, "_skipline", SN_LOCAL);
	MakeNameEx(0X812D, "gotcom", SN_LOCAL);
	MakeNameEx(0X814B, "org2", SN_LOCAL);
	MakeNameEx(0X8161, "org21", SN_LOCAL);
	MakeNameEx(0X8163, "org3", SN_LOCAL);
	MakeNameEx(0X8193, "org31", SN_LOCAL);
	MakeNameEx(0X8196, "org_switch", SN_LOCAL);
	MakeNameEx(0X81A7, "org_file", SN_LOCAL);
	MakeNameEx(0X81B5, "org_copy_file", SN_LOCAL);
	MakeNameEx(0X81CD, "get_cmt_token", SN_LOCAL);
	MakeNameEx(0X820A, "get_cmt_end", SN_LOCAL);
	MakeNameEx(0X8211, "end_commd_line_brdg", SN_LOCAL);
	MakeNameEx(0X8214, "org_put_zero", SN_LOCAL);
	MakeNameEx(0X821C, "end_file_slash", SN_LOCAL);
	MakeNameEx(0X8224, "end_copy_file", SN_LOCAL);
	MakeNameEx(0X822F, "org4", SN_LOCAL);
	MakeNameEx(0X823E, "org5", SN_LOCAL);
	MakeNameEx(0X8246, "org51", SN_LOCAL);
	MakeNameEx(0X826C, "not_dh", SN_LOCAL);
	MakeNameEx(0X8272, "org_dhlf", SN_LOCAL);
	MakeNameEx(0X8280, "org1_brdg", SN_LOCAL);
	MakeNameEx(0X8289, "at_quote", SN_LOCAL);
	MakeNameEx(0X8299, "up_level", SN_LOCAL);
	MakeFunction    (0X82BD,0X82F8);
	SetFunctionFlags(0X82BD,0);
	MakeNameEx(0X82EC, "skip_cmmt", SN_LOCAL);
	MakeNameEx(0X82F7, "no_commt", SN_LOCAL);
	MakeFunction    (0X82F8,0X8381);
	SetFunctionFlags(0X82F8,0);
	MakeNameEx(0X8304, "kbd_loop", SN_LOCAL);
	MakeNameEx(0X831F, "kbd_loopdone", SN_LOCAL);
	MakeNameEx(0X8320, "kbd_nodelay", SN_LOCAL);
	MakeNameEx(0X8331, "kbd_notshift", SN_LOCAL);
	MakeNameEx(0X8345, "kbd_cfg_bypass", SN_LOCAL);
	MakeNameEx(0X8352, "kbd_notf5", SN_LOCAL);
	MakeNameEx(0X835C, "kbd_cfg_confirm", SN_LOCAL);
	MakeNameEx(0X8368, "kbd_eat", SN_LOCAL);
	MakeNameEx(0X8375, "kbd_test", SN_LOCAL);
	MakeNameEx(0X837A, "kbd_clean", SN_LOCAL);
	MakeNameEx(0X837F, "kbd_exit", SN_LOCAL);
	MakeFunction    (0X8381,0X83A8);
	SetFunctionFlags(0X8381,0);
	MakeFrame(0X8381, 0, 4, 0);
	MakeNameEx(0X8398, "not_off", SN_LOCAL);
	MakeNameEx(0X83A5, "set_done", SN_LOCAL);
	MakeFunction    (0X83A8,0X8704);
	SetFunctionFlags(0X83A8,0x4000);
	MakeNameEx(0X83AC, "swchk_loop", SN_LOCAL);
	MakeNameEx(0X83B8, "swchk_next1", SN_LOCAL);
	MakeNameEx(0X83CA, "swchk_next2", SN_LOCAL);
	MakeNameEx(0X83CE, "swchk_scan", SN_LOCAL);
	MakeNameEx(0X83D1, "swchk_scan1", SN_LOCAL);
	MakeNameEx(0X83EB, "swchk_scan2", SN_LOCAL);
	MakeNameEx(0X83F8, "swchk_nextline", SN_LOCAL);
	MakeNameEx(0X83FD, "swchk_end", SN_LOCAL);
	MakeNameEx(0X840E, "menu_search", SN_LOCAL);
	MakeNameEx(0X8420, "menu_color", SN_LOCAL);
	MakeNameEx(0X8448, "check_color", SN_LOCAL);
	MakeNameEx(0X844F, "set_color", SN_LOCAL);
	MakeNameEx(0X8458, "menu_found", SN_LOCAL);
	MakeNameEx(0X8472, "menu_process", SN_LOCAL);
	MakeNameEx(0X84A0, "menu_numlock", SN_LOCAL);
	MakeNameEx(0X84A5, "to_menu_getdefault", SN_LOCAL);
	MakeNameEx(0X84A7, "menu_default", SN_LOCAL);
	MakeNameEx(0X84C8, "timeout_ok", SN_LOCAL);
	MakeNameEx(0X84CC, "timeout_skip", SN_LOCAL);
	MakeNameEx(0X84CE, "menu_item", SN_LOCAL);
	MakeNameEx(0X84E0, "menu_itemfound", SN_LOCAL);
	MakeNameEx(0X8503, "menu_nextitem", SN_LOCAL);
	MakeNameEx(0X8509, "menu_getdefault", SN_LOCAL);
	MakeNameEx(0X8512, "menu_valid", SN_LOCAL);
	MakeNameEx(0X8521, "menu_chkdefault", SN_LOCAL);
	MakeNameEx(0X853C, "menu_nodefault", SN_LOCAL);
	MakeNameEx(0X853E, "menu_setdefault", SN_LOCAL);
	MakeNameEx(0X8553, "menu_display", SN_LOCAL);
	MakeNameEx(0X8591, "menu_clear", SN_LOCAL);
	MakeNameEx(0X85C4, "menu_nostatus", SN_LOCAL);
	MakeNameEx(0X85C7, "menu_disploop", SN_LOCAL);
	MakeNameEx(0X85FF, "menu_autoselect", SN_LOCAL);
	MakeNameEx(0X8607, "menu_abort", SN_LOCAL);
	MakeNameEx(0X860C, "normal_boot", SN_LOCAL);
	MakeNameEx(0X861A, "not_topmenu", SN_LOCAL);
	MakeNameEx(0X8631, "not_submenu", SN_LOCAL);
	MakeNameEx(0X8637, "no_selection", SN_LOCAL);
	MakeNameEx(0X8648, "copyblock_loop", SN_LOCAL);
	MakeNameEx(0X864F, "copyblock_begin", SN_LOCAL);
	MakeNameEx(0X8672, "copyblock_check", SN_LOCAL);
	MakeNameEx(0X867B, "copyblock_skip", SN_LOCAL);
	MakeNameEx(0X868B, "move_config", SN_LOCAL);
	MakeNameEx(0X8695, "copy_boot", SN_LOCAL);
	MakeNameEx(0X86AE, "l1", SN_LOCAL);
	MakeNameEx(0X86BC, "l2", SN_LOCAL);
	MakeNameEx(0X86FB, "menu_exit", SN_LOCAL);
	MakeFunction    (0X8704,0X8789);
	SetFunctionFlags(0X8704,0);
	MakeFrame(0X8704, 0, 10, 0);
	MakeNameEx(0X8710, "copy_varlen", SN_LOCAL);
	MakeNameEx(0X872E, "copy_varsrch", SN_LOCAL);
	MakeNameEx(0X8758, "copy_envprep", SN_LOCAL);
	MakeNameEx(0X8764, "copy_varnext", SN_LOCAL);
	MakeNameEx(0X876D, "copy_envloop", SN_LOCAL);
	MakeNameEx(0X8779, "copy_envdone", SN_LOCAL);
	MakeNameEx(0X877C, "copy_envdel", SN_LOCAL);
	MakeNameEx(0X8784, "copy_envexit", SN_LOCAL);
	MakeFunction    (0X8789,0X87FE);
	SetFunctionFlags(0X8789,0);
	MakeNameEx(0X87CD, "copy_skip", SN_LOCAL);
	MakeNameEx(0X87CE, "copy_error", SN_LOCAL);
	MakeNameEx(0X87D4, "copy_line", SN_LOCAL);
	MakeNameEx(0X87EC, "copy_loop", SN_LOCAL);
	MakeNameEx(0X87F4, "copy_next", SN_LOCAL);
	MakeNameEx(0X87F8, "copy_nextline", SN_LOCAL);
	MakeNameEx(0X87FD, "copy_done", SN_LOCAL);
	MakeFunction    (0X87FE,0X881A);
	SetFunctionFlags(0X87FE,0);
	MakeFrame(0X87FE, 0, 2, 0);
	MakeNameEx(0X880C, "get_linenum_loop", SN_LOCAL);
	MakeNameEx(0X8816, "get_linenum_done", SN_LOCAL);
	MakeFunction    (0X881A,0X8833);
	SetFunctionFlags(0X881A,0);
	MakeFrame(0X881A, 0, 4, 0);
	MakeFunction    (0X8833,0X885B);
	SetFunctionFlags(0X8833,0);
	MakeNameEx(0X884A, "check_line", SN_LOCAL);
	MakeNameEx(0X8855, "next_line", SN_LOCAL);
	MakeNameEx(0X885A, "find_exit", SN_LOCAL);
	MakeFunction    (0X885B,0X887C);
	SetFunctionFlags(0X885B,0);
	MakeFrame(0X885B, 0, 2, 0);
	MakeNameEx(0X885C, "comp_loop", SN_LOCAL);
	MakeNameEx(0X8871, "comp_exit", SN_LOCAL);
	MakeNameEx(0X8873, "comp_almost", SN_LOCAL);
	MakeFunction    (0X887C,0X888A);
	SetFunctionFlags(0X887C,0);
	MakeFrame(0X887C, 0, 10, 0);
	MakeFunction    (0X888A,0X8922);
	SetFunctionFlags(0X888A,0);
	MakeFrame(0X888A, 0, 10, 0);
	MakeNameEx(0X88C1, "print_other", SN_LOCAL);
	MakeNameEx(0X88F3, "print_loop", SN_LOCAL);
	MakeNameEx(0X88FD, "print_montab", SN_LOCAL);
	MakeNameEx(0X8916, "print_done", SN_LOCAL);
	MakeFunction    (0X8922,0X8A4D);
	SetFunctionFlags(0X8922,0);
	MakeNameEx(0X893B, "check_time", SN_LOCAL);
	MakeNameEx(0X8951, "show_time", SN_LOCAL);
	MakeNameEx(0X8987, "input_key", SN_LOCAL);
	MakeNameEx(0X89A4, "got_time", SN_LOCAL);
	MakeNameEx(0X89AE, "got_key", SN_LOCAL);
	MakeNameEx(0X89C8, "timeout_disabled", SN_LOCAL);
	MakeNameEx(0X89E5, "not_up", SN_LOCAL);
	MakeNameEx(0X89F7, "print1", SN_LOCAL);
	MakeNameEx(0X89F9, "print2", SN_LOCAL);
	MakeNameEx(0X89FF, "to_input_key", SN_LOCAL);
	MakeNameEx(0X8A01, "not_down", SN_LOCAL);
	MakeNameEx(0X8A17, "not_f8", SN_LOCAL);
	MakeNameEx(0X8A27, "normal_key", SN_LOCAL);
	MakeNameEx(0X8A33, "not_backspace", SN_LOCAL);
	MakeNameEx(0X8A47, "select_done", SN_LOCAL);
	MakeFunction    (0X8A4D,0X8A62);
	SetFunctionFlags(0X8A4D,0x4000);
	MakeNameEx(0X8A54, "disp_ok", SN_LOCAL);
	MakeFunction    (0X8A62,0X8A72);
	SetFunctionFlags(0X8A62,0);
	MakeFrame(0X8A62, 0, 2, 0);
	MakeFunction    (0X8A72,0X8AB1);
	SetFunctionFlags(0X8A72,0);
	MakeFrame(0X8A72, 0, 2, 0);
	MakeNameEx(0X8A97, "show_onoff", SN_LOCAL);
	MakeNameEx(0X8AA6, "show_noton", SN_LOCAL);
	MakeNameEx(0X8AAA, "show_done", SN_LOCAL);
	MakeFunction    (0X8AB1,0X8AC8);
	SetFunctionFlags(0X8AB1,0);
	MakeNameEx(0X8AC6, "skip_token_eol", SN_LOCAL);
	MakeFunction    (0X8AC8,0X8AD7);
	SetFunctionFlags(0X8AC8,0);
	MakeFunction    (0X8AD7,0X8ADB);
	SetFunctionFlags(0X8AD7,0);
	MakeFunction    (0X8ADB,0X8AE5);
	SetFunctionFlags(0X8ADB,0x4000);
	MakeFunction    (0X8AE5,0X8B07);
	SetFunctionFlags(0X8AE5,0);
	MakeNameEx(0X8AE7, "num_loop", SN_LOCAL);
	MakeNameEx(0X8B06, "num_done", SN_LOCAL);
	MakeFunction    (0X8B07,0X8B15);
	SetFunctionFlags(0X8B07,0);
	MakeNameEx(0X8B11, "get_fail", SN_LOCAL);
	MakeFunction    (0X8B15,0X8BDE);
	SetFunctionFlags(0X8B15,0);
	MakeNameEx(0X8B1F, "qu_1", SN_LOCAL);
	MakeNameEx(0X8B38, "query_all", SN_LOCAL);
	MakeNameEx(0X8B47, "find_match", SN_LOCAL);
	MakeNameEx(0X8B57, "cmd_match", SN_LOCAL);
	MakeNameEx(0X8B5E, "cmd_print", SN_LOCAL);
	MakeNameEx(0X8B70, "cmd_notset", SN_LOCAL);
	MakeNameEx(0X8B72, "line_print", SN_LOCAL);
	MakeNameEx(0X8B7A, "non_null", SN_LOCAL);
	MakeNameEx(0X8B86, "non_space", SN_LOCAL);
	MakeNameEx(0X8B8E, "prompt_user", SN_LOCAL);
	MakeNameEx(0X8B91, "generic_prompt", SN_LOCAL);
	MakeNameEx(0X8B94, "input_loop", SN_LOCAL);
	MakeNameEx(0X8BAB, "not_func", SN_LOCAL);
	MakeNameEx(0X8BCC, "legal_char", SN_LOCAL);
	MakeNameEx(0X8BD6, "do_cmd", SN_LOCAL);
	MakeNameEx(0X8BD9, "skip_cmd", SN_LOCAL);
	MakeNameEx(0X8BDA, "skip_all", SN_LOCAL);
	MakeFunction    (0X8BDE,0X8C12);
	SetFunctionFlags(0X8BDE,0);
	MakeFrame(0X8BDE, 0, 12, 0);
	MakeNameEx(0X8C06, "pe_1", SN_LOCAL);
	MakeNameEx(0X8C0C, "pe_ret", SN_LOCAL);
	MakeFunction    (0X8C12,0X8C5D);
	SetFunctionFlags(0X8C12,0);
	MakeNameEx(0X8C4E, "disable_loop", SN_LOCAL);
	MakeFunction    (0X8C5D,0X8C75);
	SetFunctionFlags(0X8C5D,0);
	MakeFunction    (0X8C75,0X8C85);
	SetFunctionFlags(0X8C75,0);
	MakeFunction    (0X8C85,0X8CA1);
	SetFunctionFlags(0X8C85,0);
	MakeFrame(0X8C85, 0, 0, 0);
	MakeFunction    (0X8CA1,0X8CAE);
	SetFunctionFlags(0X8CA1,0);
	MakeNameEx(0X8CAD, "nl_ret", SN_LOCAL);
	MakeFunction    (0X8CAE,0X8CDA);
	SetFunctionFlags(0X8CAE,0);
	MakeFrame(0X8CAE, 0, 8, 0);
	MakeNameEx(0X8CB5, "convloop", SN_LOCAL);
	MakeNameEx(0X8CC3, "noconv", SN_LOCAL);
	MakeNameEx(0X8CCC, "check_eol", SN_LOCAL);
	MakeNameEx(0X8CD6, "convdone", SN_LOCAL);
	MakeFunction    (0X8CDA,0X8D27);
	SetFunctionFlags(0X8CDA,0);
	MakeFrame(0X8CDA, 0, 2, 0);
	MakeNameEx(0X8D19, "skip_set_devmarksize", SN_LOCAL);
	MakeFunction    (0X8D27,0X8D4A);
	SetFunctionFlags(0X8D27,0);
	MakeFunction    (0X8D4A,0X8D56);
	SetFunctionFlags(0X8D4A,0);
	MakeNameEx(0X8D54, "notdig", SN_LOCAL);
	MakeFunction    (0X8D56,0X8DB3);
	SetFunctionFlags(0X8D56,0);
	MakeFrame(0X8D56, 0, 2, 0);
	MakeNameEx(0X8D59, "b2", SN_LOCAL);
	MakeNameEx(0X8D98, "b15", SN_LOCAL);
	MakeNameEx(0X8DA2, "b1", SN_LOCAL);
	MakeNameEx(0X8DA8, "badnum", SN_LOCAL);
	MakeFunction    (0X8DB3,0X8EC7);
	SetFunctionFlags(0X8DB3,0);
	MakeFrame(0X8DB3, 0, 6, 0);
	MakeNameEx(0X8DF5, "setdoscntry_find", SN_LOCAL);
	MakeNameEx(0X8E04, "setdoscntry_next", SN_LOCAL);
	MakeNameEx(0X8E0D, "setdoscntry_fail", SN_LOCAL);
	MakeNameEx(0X8E0F, "setdosdata_fail", SN_LOCAL);
	MakeNameEx(0X8E14, "setdoscntry_any_codepage", SN_LOCAL);
	MakeNameEx(0X8E17, "setdoscntry_got_it", SN_LOCAL);
	MakeNameEx(0X8E2E, "setdoscntry_data", SN_LOCAL);
	MakeNameEx(0X8EA7, "setdoscntry_mov", SN_LOCAL);
	MakeNameEx(0X8EB6, "setdoscntry_data_next", SN_LOCAL);
	MakeNameEx(0X8EC6, "setdoscntry_ok", SN_LOCAL);
	MakeFunction    (0X8EC7,0X8EE2);
	SetFunctionFlags(0X8EC7,0);
	MakeNameEx(0X8EE1, "sdbcsbc", SN_LOCAL);
	MakeFunction    (0X8EE2,0X8F10);
	SetFunctionFlags(0X8EE2,0);
	MakeFrame(0X8EE2, 0, 2, 0);
	MakeNameEx(0X8EEB, "getcntrydest", SN_LOCAL);
	MakeNameEx(0X8EFB, "getcntrydest_1", SN_LOCAL);
	MakeNameEx(0X8EFE, "getcntrydest_loop", SN_LOCAL);
	MakeNameEx(0X8F03, "getcntrydest_ok", SN_LOCAL);
	MakeNameEx(0X8F0A, "getcntrydest_ok1", SN_LOCAL);
	MakeNameEx(0X8F0E, "getcntrydest_exit", SN_LOCAL);
	MakeFunction    (0X8F10,0X8F24);
	SetFunctionFlags(0X8F10,0);
	MakeFrame(0X8F10, 0, 2, 0);
	MakeNameEx(0X8F23, "ricb_exit", SN_LOCAL);
	MakeFunction    (0X8F5A,0X8F70);
	SetFunctionFlags(0X8F5A,0x4000);
	MakeNameEx(0X8F6D, "cdletter_no", SN_LOCAL);
	MakeNameEx(0X8F6E, "cdletter_exit", SN_LOCAL);
	MakeFunction    (0X8F70,0X8F78);
	SetFunctionFlags(0X8F70,0);
	MakeFunction    (0X8F78,0X8F82);
	SetFunctionFlags(0X8F78,0);
	MakeFrame(0X8F78, 0, 2, 0);
	MakeFunction    (0X8F82,0X8FA6);
	SetFunctionFlags(0X8F82,0x4000);
	MakeNameEx(0X8F87, "prn1", SN_LOCAL);
	MakeNameEx(0X8F95, "prn2", SN_LOCAL);
	MakeNameEx(0X8FA5, "prnexit", SN_LOCAL);
	MakeFunction    (0X8FA6,0X8FAB);
	SetFunctionFlags(0X8FA6,0);
	MakeFunction    (0X8FAB,0X8FCA);
	SetFunctionFlags(0X8FAB,0);
	MakeNameEx(0X8FB0, "open_dev1", SN_LOCAL);
	MakeNameEx(0X8FB6, "of_retn", SN_LOCAL);
	MakeNameEx(0X8FB7, "open_dev3", SN_LOCAL);
	MakeFunction    (0X8FCA,0X8FD0);
	SetFunctionFlags(0X8FCA,0);
}

//------------------------------------------------------------------------
// Information about functions

static Functions(void) {

	Functions_0();
}

//------------------------------------------------------------------------
// Information about segment registers

static SegRegs(void) {
	SetRegEx(0,"es",0X70,3);
	SetRegEx(0,"ss",0,3);
	SetRegEx(0,"ds",0,3);
	SetRegEx(0,"fs",0,3);
	SetRegEx(0,"gs",0,3);
	SetRegEx(0X794,"ds",0,3);
	SetRegEx(0X79B,"ds",0,3);
	SetRegEx(0X7A8,"ds",0,3);
	SetRegEx(0X7DF,"ds",0,3);
	SetRegEx(0X7E4,"es",0X70,3);
	SetRegEx(0X7ED,"es",0X70,3);
	SetRegEx(0X7EE,"ds",0,3);
	SetRegEx(0X7FD,"ds",0,3);
	SetRegEx(0X801,"es",0,3);
	SetRegEx(0X85B,"ds",0X40,3);
	SetRegEx(0X866,"ds",0,3);
	SetRegEx(0X872,"ds",0,3);
	SetRegEx(0X884,"es",0XFFFF,3);
	SetRegEx(0X88F,"es",0X70,3);
	SetRegEx(0X8D9,"es",0,3);
	SetRegEx(0X8F5,"es",0X70,3);
	SetRegEx(0X12FE,"ds",0X40,3);
	SetRegEx(0X131D,"es",0X70,3);
	SetRegEx(0X133E,"es",0X70,3);
	SetRegEx(0X133F,"ds",0,3);
	SetRegEx(0X1390,"es",0X70,3);
	SetRegEx(0X1422,"ds",0X40,3);
	SetRegEx(0X142A,"ds",0,3);
	SetRegEx(0X150C,"ds",0,3);
	SetRegEx(0X1801,"ds",0,3);
	SetRegEx(0X180D,"es",0,3);
	SetRegEx(0X1815,"ds",0X473,3);
	SetRegEx(0X1827,"ds",0,3);
	SetRegEx(0X188C,"es",0X70,3);
	SetRegEx(0X18CC,"ss",0,3);
	SetRegEx(0X18F6,"es",0XFFFF,3);
	SetRegEx(0X1941,"ds",0,3);
	SetRegEx(0X1943,"es",0,3);
	SetRegEx(0X19A8,"ds",0,3);
	SetRegEx(0X19B0,"ds",0,3);
	SetRegEx(0X19C8,"ds",0,3);
	SetRegEx(0X19DC,"ds",0X473,3);
	SetRegEx(0X19FA,"es",0X473,3);
	SetRegEx(0X19FE,"ds",0,3);
	SetRegEx(0X1A1B,"ds",0,3);
	SetRegEx(0X1A32,"ds",0,3);
	SetRegEx(0X1A34,"es",0,3);
	SetRegEx(0X1A52,"ds",0XF000,3);
	SetRegEx(0X1A7A,"ds",0,3);
	SetRegEx(0X1A8A,"ds",0,3);
	SetRegEx(0X1AEC,"es",0X70,3);
	SetRegEx(0X1AF0,"ds",0,3);
	SetRegEx(0X1B3C,"es",0X70,3);
	SetRegEx(0X1B40,"ds",0,3);
	SetRegEx(0X1C34,"es",0,3);
	SetRegEx(0X1C49,"es",0XF000,3);
	SetRegEx(0X1C64,"es",0XF000,3);
	SetRegEx(0X1CAC,"es",0,3);
	SetRegEx(0X1CBA,"es",0,3);
	SetRegEx(0X1CF2,"ds",0,3);
	SetRegEx(0X1CFB,"ds",0,3);
	SetRegEx(0X1D05,"ds",0,3);
	SetRegEx(0X1D2B,"ds",0,3);
	SetRegEx(0X1D3B,"es",0,3);
	SetRegEx(0X1D3D,"ds",0,3);
	SetRegEx(0X1D46,"ds",0,3);
	SetRegEx(0X1D47,"es",0X70,3);
	SetRegEx(0X1D71,"ds",0,3);
	SetRegEx(0X1D76,"ds",0,3);
	SetRegEx(0X1D7B,"es",0X473,3);
	SetRegEx(0X1D80,"es",0X70,3);
	SetRegEx(0X1DFE,"ds",0X473,3);
	SetRegEx(0X1E02,"ds",0,3);
	SetRegEx(0X1E09,"es",0X70,3);
	SetRegEx(0X1F54,"es",0,3);
	SetRegEx(0X1FF1,"es",0,3);
	SetRegEx(0X1FF3,"ds",0,3);
	SetRegEx(0X2029,"ds",0,3);
	SetRegEx(0X202D,"es",0,3);
	SetRegEx(0X202F,"ds",0,3);
	SetRegEx(0X2038,"ds",0,3);
	SetRegEx(0X2039,"es",0X70,3);
	SetRegEx(0X20B9,"es",0,3);
	SetRegEx(0X20BB,"ds",0,3);
	SetRegEx(0X20C4,"ds",0,3);
	SetRegEx(0X20C5,"es",0X70,3);
	SetRegEx(0X2164,"es",0,3);
	SetRegEx(0X2166,"ds",0,3);
	SetRegEx(0X216E,"ds",0,3);
	SetRegEx(0X2198,"es",0X70,3);
	SetRegEx(0X2199,"ds",0,3);
	SetRegEx(0X21E8,"es",0X70,3);
	SetRegEx(0X222C,"ds",0X70,3);
	SetRegEx(0X2233,"ds",0,3);
	SetRegEx(0X2291,"es",0X70,3);
	SetRegEx(0X2294,"es",0X70,3);
	SetRegEx(0X22E2,"es",0X70,3);
	SetRegEx(0X2373,"es",0X70,3);
	SetRegEx(0X239D,"es",0X70,3);
	SetRegEx(0X239E,"ds",0,3);
	SetRegEx(0X23B1,"es",0X473,3);
	SetRegEx(0X23B8,"es",0X70,3);
	SetRegEx(0X24BA,"ds",0,3);
	SetRegEx(0X2513,"ds",0,3);
	SetRegEx(0X2536,"ds",0,3);
	SetRegEx(0X253E,"ds",0,3);
	SetRegEx(0X2562,"ds",0,3);
	SetRegEx(0X2574,"ds",0,3);
	SetRegEx(0X2575,"es",0X70,3);
	SetRegEx(0X2593,"es",0,3);
	SetRegEx(0X2598,"ds",0,3);
	SetRegEx(0X25A0,"ds",0,3);
	SetRegEx(0X25AC,"ds",0,3);
	SetRegEx(0X25AD,"es",0X70,3);
	SetRegEx(0X25C0,"es",0XFFFFFFFF,3);
	SetRegEx(0X25C0,"ss",0XFFFFFFFF,3);
	SetRegEx(0X25C0,"ds",0XFFFFFFFF,3);
	SetRegEx(0X25C0,"fs",0XFFFFFFFF,3);
	SetRegEx(0X25C0,"gs",0XFFFFFFFF,3);
	SetRegEx(0X25F7,"es",0X70,3);
	SetRegEx(0X2616,"ds",0X70,3);
	SetRegEx(0X2626,"es",0XFFFFFFFF,3);
	SetRegEx(0X2667,"es",0XFFFFFFFF,3);
	SetRegEx(0X2675,"ds",0X70,3);
	SetRegEx(0X2679,"ds",0XFFFFFFFF,3);
	SetRegEx(0X267E,"es",0XFFFFFFFF,3);
	SetRegEx(0X267F,"ds",0XFFFFFFFF,3);
	SetRegEx(0X269B,"es",0XFFFFFFFF,3);
	SetRegEx(0X2779,"es",0XFFFFFFFF,3);
	SetRegEx(0X27B7,"es",0XFFFFFFFF,3);
	SetRegEx(0X287E,"es",0XFFFFFFFF,3);
	SetRegEx(0X2890,"es",0XFFFFFFFF,3);
	SetRegEx(0X28B4,"es",0XFFFFFFFF,3);
	SetRegEx(0X2A9B,"es",0XFFFFFFFF,3);
	SetRegEx(0X2AA4,"es",0XFFFFFFFF,3);
	SetRegEx(0X2B00,"es",0XFFFFFFFF,3);
	SetRegEx(0X2B05,"es",0XFFFFFFFF,3);
	SetRegEx(0X2B8B,"es",0XFFFFFFFF,3);
	SetRegEx(0X2D63,"es",0XFFFFFFFF,3);
	SetRegEx(0X2D69,"es",0XFFFFFFFF,3);
	SetRegEx(0X2D84,"ds",0XFFFFFFFF,3);
	SetRegEx(0X2D8C,"ds",0XFFFFFFFF,3);
	SetRegEx(0X2D93,"es",0XFFFFFFFF,3);
	SetRegEx(0X2D99,"es",0XFFFFFFFF,3);
	SetRegEx(0X2DAA,"ds",0XFFFFFFFF,3);
	SetRegEx(0X2DAE,"ds",0XFFFFFFFF,3);
	SetRegEx(0X2E36,"es",0XFFFFFFFF,3);
	SetRegEx(0X2E4A,"es",0XFFFFFFFF,3);
	SetRegEx(0X2E65,"es",0,3);
	SetRegEx(0X2E6A,"es",0XFFFFFFFF,3);
	SetRegEx(0X2E7F,"es",0,3);
	SetRegEx(0X2E85,"es",0XFFFFFFFF,3);
	SetRegEx(0X2E92,"es",0XFFFFFFFF,3);
	SetRegEx(0X2E9A,"es",0XFFFFFFFF,3);
	SetRegEx(0X2F0E,"es",0,3);
	SetRegEx(0X2F13,"es",0XFFFFFFFF,3);
	SetRegEx(0X2F1C,"es",0XFFFFFFFF,3);
	SetRegEx(0X2F93,"ds",0XFFFFFFFF,3);
	SetRegEx(0X2F9D,"ds",0XFFFFFFFF,3);
	SetRegEx(0X2FA9,"ds",0XFFFFFFFF,3);
	SetRegEx(0X2FBD,"ds",0XFFFFFFFF,3);
	SetRegEx(0X2FDE,"es",0XFFFFFFFF,3);
	SetRegEx(0X2FFA,"es",0XFFFFFFFF,3);
	SetRegEx(0X3188,"es",0XFFFFFFFF,3);
	SetRegEx(0X318E,"es",0XFFFFFFFF,3);
	SetRegEx(0X3196,"es",0XFFFFFFFF,3);
	SetRegEx(0X319C,"es",0XFFFFFFFF,3);
	SetRegEx(0X31A9,"es",0XFFFFFFFF,3);
	SetRegEx(0X31B0,"es",0XFFFFFFFF,3);
	SetRegEx(0X31B9,"es",0XFFFFFFFF,3);
	SetRegEx(0X31CB,"es",0XFFFFFFFF,3);
	SetRegEx(0X3233,"es",0XFFFFFFFF,3);
	SetRegEx(0X323D,"es",0XFFFFFFFF,3);
	SetRegEx(0X3260,"ds",0X70,3);
	SetRegEx(0X326B,"ds",0XFFFFFFFF,3);
	SetRegEx(0X326E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3299,"ds",0X70,3);
	SetRegEx(0X32A0,"ds",0XFFFFFFFF,3);
	SetRegEx(0X32AE,"ds",0XFFFFFFFF,3);
	SetRegEx(0X32AF,"es",0XFFFFFFFF,3);
	SetRegEx(0X32B7,"ds",0XFFFFFFFF,3);
	SetRegEx(0X32BA,"ds",0XFFFFFFFF,3);
	SetRegEx(0X32DC,"ds",0X70,3);
	SetRegEx(0X32E2,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3301,"ds",0X70,3);
	SetRegEx(0X3305,"ds",0XFFFFFFFF,3);
	SetRegEx(0X333C,"ds",0X70,3);
	SetRegEx(0X3340,"ds",0XFFFFFFFF,3);
	SetRegEx(0X334A,"ds",0X70,3);
	SetRegEx(0X334F,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3370,"es",0X70,3);
	SetRegEx(0X3385,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3388,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3393,"ds",0X70,3);
	SetRegEx(0X3397,"ds",0XFFFFFFFF,3);
	SetRegEx(0X33A7,"ds",0X70,3);
	SetRegEx(0X33B8,"ds",0X70,3);
	SetRegEx(0X344B,"ds",0XFFFFFFFF,3);
	SetRegEx(0X344E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X345A,"ds",0XFFFFFFFF,3);
	SetRegEx(0X34B9,"es",0XFFFFFFFF,3);
	SetRegEx(0X34BD,"es",0XFFFFFFFF,3);
	SetRegEx(0X34D7,"es",0XFFFFFFFF,3);
	SetRegEx(0X34DC,"es",0XFFFFFFFF,3);
	SetRegEx(0X3539,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3541,"ds",0XFFFFFFFF,3);
	SetRegEx(0X35BC,"ds",0,3);
	SetRegEx(0X35C0,"ds",0XFFFFFFFF,3);
	SetRegEx(0X35C6,"ds",0XFFFFFFFF,3);
	SetRegEx(0X35F2,"es",0,3);
	SetRegEx(0X35F7,"es",0XFFFFFFFF,3);
	SetRegEx(0X3606,"es",0XFFFFFFFF,3);
	SetRegEx(0X3632,"es",0,3);
	SetRegEx(0X3637,"es",0XFFFFFFFF,3);
	SetRegEx(0X3643,"es",0,3);
	SetRegEx(0X3670,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3671,"es",0XFFFFFFFF,3);
	SetRegEx(0X36A1,"es",0,3);
	SetRegEx(0X36A6,"es",0XFFFFFFFF,3);
	SetRegEx(0X36CA,"es",0XFFFFFFFF,3);
	SetRegEx(0X36DE,"es",0XFFFFFFFF,3);
	SetRegEx(0X36E1,"es",0XFFFFFFFF,3);
	SetRegEx(0X36EF,"es",0XFFFFFFFF,3);
	SetRegEx(0X3700,"es",0XFFFFFFFF,3);
	SetRegEx(0X3726,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3740,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3745,"es",0X70,3);
	SetRegEx(0X374A,"es",0,3);
	SetRegEx(0X3755,"es",0XFFFFFFFF,3);
	SetRegEx(0X3756,"ds",0XFFFFFFFF,3);
	SetRegEx(0X377D,"es",0XFFFFFFFF,3);
	SetRegEx(0X3781,"es",0XFFFFFFFF,3);
	SetRegEx(0X37B9,"es",0XFFFFFFFF,3);
	SetRegEx(0X37C0,"ds",0XFFFFFFFF,3);
	SetRegEx(0X37C3,"ds",0XFFFFFFFF,3);
	SetRegEx(0X37CD,"ds",0XFFFFFFFF,3);
	SetRegEx(0X37CF,"es",0XFFFFFFFF,3);
	SetRegEx(0X37EB,"es",0XFFFFFFFF,3);
	SetRegEx(0X37FD,"es",0XFFFFFFFF,3);
	SetRegEx(0X382D,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3830,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3844,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3847,"ds",0XFFFFFFFF,3);
	SetRegEx(0X385F,"es",0XFFFFFFFF,3);
	SetRegEx(0X3869,"es",0X25C,3);
	SetRegEx(0X387B,"es",0XFFFFFFFF,3);
	SetRegEx(0X387E,"es",0XFFFFFFFF,3);
	SetRegEx(0X3885,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3888,"ds",0XFFFFFFFF,3);
	SetRegEx(0X38E2,"ds",0X70,3);
	SetRegEx(0X3902,"es",0XFFFFFFFF,3);
	SetRegEx(0X3904,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3921,"ds",0X70,3);
	SetRegEx(0X392A,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3933,"es",0XFFFFFFFF,3);
	SetRegEx(0X3938,"ds",0X70,3);
	SetRegEx(0X393C,"ds",0XFFFFFFFF,3);
	SetRegEx(0X393D,"es",0XFFFFFFFF,3);
	SetRegEx(0X3944,"ds",0X70,3);
	SetRegEx(0X3948,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3950,"ds",0X70,3);
	SetRegEx(0X397D,"es",0X70,3);
	SetRegEx(0X397E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X398D,"es",0XFFFF,3);
	SetRegEx(0X3997,"ds",0XFFFFFFFF,3);
	SetRegEx(0X39A3,"es",0XFFFF,3);
	SetRegEx(0X39CD,"ds",0XFFFFFFFF,3);
	SetRegEx(0X39D8,"ds",0X70,3);
	SetRegEx(0X3A7A,"es",0XFFFFFFFF,3);
	SetRegEx(0X3A87,"es",0XFFFFFFFF,3);
	SetRegEx(0X3A90,"es",0XFFFFFFFF,3);
	SetRegEx(0X3AE5,"es",0XFFFFFFFF,3);
	SetRegEx(0X3AEF,"es",0XFFFFFFFF,3);
	SetRegEx(0X3B11,"ds",0X70,3);
	SetRegEx(0X3B31,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3BB5,"es",0XFFFFFFFF,3);
	SetRegEx(0X3BBF,"es",0XFFFFFFFF,3);
	SetRegEx(0X3C22,"es",0XFFFFFFFF,3);
	SetRegEx(0X3C2C,"es",0XFFFFFFFF,3);
	SetRegEx(0X3C37,"es",0XFFFFFFFF,3);
	SetRegEx(0X3C38,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3C41,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3C5A,"es",0XFFFFFFFF,3);
	SetRegEx(0X3C9C,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3C9D,"es",0XFFFFFFFF,3);
	SetRegEx(0X3CAA,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3CB6,"es",0XFFFFFFFF,3);
	SetRegEx(0X3CBE,"es",0XFFFFFFFF,3);
	SetRegEx(0X3CCE,"es",0XFFFFFFFF,3);
	SetRegEx(0X3D0B,"es",0XFFFFFFFF,3);
	SetRegEx(0X3D14,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3D45,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3ECD,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3ED9,"ds",0XFFFFFFFF,3);
	SetRegEx(0X3F1A,"es",0XFFFFFFFF,3);
	SetRegEx(0X3F27,"es",0XFFFFFFFF,3);
	SetRegEx(0X3F2E,"es",0XFFFFFFFF,3);
	SetRegEx(0X3F66,"es",0XFFFFFFFF,3);
	SetRegEx(0X3F73,"es",0XFFFFFFFF,3);
	SetRegEx(0X3FDA,"es",0XFFFFFFFF,3);
	SetRegEx(0X3FE9,"es",0XFFFFFFFF,3);
	SetRegEx(0X4030,"es",0XFFFFFFFF,3);
	SetRegEx(0X4030,"ss",0XFFFFFFFF,3);
	SetRegEx(0X4030,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4030,"fs",0XFFFFFFFF,3);
	SetRegEx(0X4030,"gs",0XFFFFFFFF,3);
	SetRegEx(0X404D,"es",0XF000,3);
	SetRegEx(0X4054,"es",0XFFFFFFFF,3);
	SetRegEx(0X417F,"es",0,3);
	SetRegEx(0X41AC,"es",0XFFFFFFFF,3);
	SetRegEx(0X41B3,"ss",0,3);
	SetRegEx(0X41B7,"es",0,3);
	SetRegEx(0X41CA,"ss",0XFFFFFFFF,3);
	SetRegEx(0X41D9,"es",0XFFFFFFFF,3);
	SetRegEx(0X422D,"ds",0XF000,3);
	SetRegEx(0X4233,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4244,"ds",0X403,3);
	SetRegEx(0X424E,"ds",0X70,3);
	SetRegEx(0X4254,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4464,"ds",0XF000,3);
	SetRegEx(0X447C,"es",0XFFFFFFFF,3);
	SetRegEx(0X4499,"ds",0X403,3);
	SetRegEx(0X449E,"es",0,3);
	SetRegEx(0X44A8,"es",0XFFFFFFFF,3);
	SetRegEx(0X44E2,"es",0XFFFFFFFF,3);
	SetRegEx(0X44F4,"ds",0X70,3);
	SetRegEx(0X4509,"es",0XFFFFFFFF,3);
	SetRegEx(0X4512,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4532,"es",0X9FF,3);
	SetRegEx(0X4539,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4553,"es",0XFFFFFFFF,3);
	SetRegEx(0X4558,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4562,"ss",0X403,3);
	SetRegEx(0X45A2,"es",0XFFFFFFFF,3);
	SetRegEx(0X45BC,"es",0XFFFFFFFF,3);
	SetRegEx(0X45D9,"es",0XFFFFFFFF,3);
	SetRegEx(0X45FD,"es",0XFFFFFFFF,3);
	SetRegEx(0X4606,"es",0XFFFFFFFF,3);
	SetRegEx(0X468D,"es",0XFFFFFFFF,3);
	SetRegEx(0X469E,"es",0XFFFFFFFF,3);
	SetRegEx(0X46BD,"es",0XFFFFFFFF,3);
	SetRegEx(0X46BF,"ds",0X403,3);
	SetRegEx(0X46C7,"ds",0XFFFFFFFF,3);
	SetRegEx(0X46D5,"es",0X3F3,3);
	SetRegEx(0X46EA,"ds",0X403,3);
	SetRegEx(0X4700,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4714,"ds",0,3);
	SetRegEx(0X4718,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4737,"es",0XFFFFFFFF,3);
	SetRegEx(0X474A,"es",0XFFFFFFFE,3);
	SetRegEx(0X4765,"es",0XFFFFFFFF,3);
	SetRegEx(0X4772,"es",0XFFFFFFFF,3);
	SetRegEx(0X4784,"es",0XFFFFFFFF,3);
	SetRegEx(0X479A,"es",0XFFFFFFFF,3);
	SetRegEx(0X47CE,"es",0X70,3);
	SetRegEx(0X4806,"es",0XFFFFFFFF,3);
	SetRegEx(0X481A,"es",0XFFFFFFFF,3);
	SetRegEx(0X4828,"es",0XFFFFFFFE,3);
	SetRegEx(0X4838,"es",0XFFFFFFFF,3);
	SetRegEx(0X4845,"ds",0X403,3);
	SetRegEx(0X487C,"es",0XFFFFFFFF,3);
	SetRegEx(0X48F3,"es",0X403,3);
	SetRegEx(0X4914,"ds",0X403,3);
	SetRegEx(0X499C,"es",0X403,3);
	SetRegEx(0X4A41,"ds",0X403,3);
	SetRegEx(0X4A53,"es",0XFFFFFFFF,3);
	SetRegEx(0X4A6B,"es",0XFFFFFFFF,3);
	SetRegEx(0X4A84,"es",0XFFFF,3);
	SetRegEx(0X4A99,"es",0XFFFFFFFF,3);
	SetRegEx(0X4AAA,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4AC7,"es",0XFFFFFFFF,3);
	SetRegEx(0X4ACF,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4B06,"es",0XFFFFFFFF,3);
	SetRegEx(0X4B1E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4B22,"es",0XFFFFFFFF,3);
	SetRegEx(0X4B38,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4B51,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4B54,"ds",0X403,3);
	SetRegEx(0X4B64,"ds",0X70,3);
	SetRegEx(0X4B9E,"es",0XFFFF,3);
	SetRegEx(0X4BB0,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4BB3,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4BD0,"es",0XFFFFFFFF,3);
	SetRegEx(0X4BD1,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4C30,"ds",0,3);
	SetRegEx(0X4C48,"es",0XFFFFFFFF,3);
	SetRegEx(0X4C59,"es",0XFFFFFFFF,3);
	SetRegEx(0X4C6D,"ds",0X403,3);
	SetRegEx(0X4C78,"es",0XFFFF,3);
	SetRegEx(0X4C85,"es",0XFFFFFFFF,3);
	SetRegEx(0X4D10,"es",0X403,3);
	SetRegEx(0X4D18,"es",0XFFFFFFFF,3);
	SetRegEx(0X4D32,"ds",0X70,3);
	SetRegEx(0X4D3C,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4D41,"ds",0,3);
	SetRegEx(0X4D45,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4D4D,"es",0X403,3);
	SetRegEx(0X4D59,"ds",0XFFFF,3);
	SetRegEx(0X4D6B,"es",0XFFFF,3);
	SetRegEx(0X4D6F,"ds",0,3);
	SetRegEx(0X4D7C,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4D8A,"es",0XFFFFFFFF,3);
	SetRegEx(0X4DB2,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4DB4,"es",0XFFFFFFFF,3);
	SetRegEx(0X4E1F,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4E21,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4E2A,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4E36,"ds",0X70,3);
	SetRegEx(0X4E44,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4E4E,"ds",0X403,3);
	SetRegEx(0X4E71,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4E74,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4E7B,"ds",0X403,3);
	SetRegEx(0X4E80,"es",0XFFFFFFFF,3);
	SetRegEx(0X4EAD,"ds",0X403,3);
	SetRegEx(0X4ECA,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4EDC,"ds",0X403,3);
	SetRegEx(0X4EE0,"es",0XFFFFFFFF,3);
	SetRegEx(0X4F3F,"es",0XFFFFFFFF,3);
	SetRegEx(0X4F43,"es",0XFFFFFFFF,3);
	SetRegEx(0X4F45,"ds",0X403,3);
	SetRegEx(0X4F95,"es",0XFFFFFFFF,3);
	SetRegEx(0X4FC2,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4FC8,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4FD9,"ds",0XFFFFFFFF,3);
	SetRegEx(0X4FE8,"ds",0XFFFFFFFF,3);
	SetRegEx(0X502D,"es",0XFFFFFFFF,3);
	SetRegEx(0X506D,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5071,"es",0XFFFFFFFF,3);
	SetRegEx(0X5076,"ds",0X403,3);
	SetRegEx(0X509F,"es",0XFFFFFFFF,3);
	SetRegEx(0X50A1,"ds",0X403,3);
	SetRegEx(0X50B7,"ds",0X70,3);
	SetRegEx(0X50E8,"ds",0XFFFFFFFF,3);
	SetRegEx(0X50FE,"ds",0X403,3);
	SetRegEx(0X5162,"es",0XF000,3);
	SetRegEx(0X5187,"es",0XFFFFFFFF,3);
	SetRegEx(0X51A1,"es",0XFFFFFFFF,3);
	SetRegEx(0X51DE,"es",0XFFFFFFFF,3);
	SetRegEx(0X51EA,"es",0XFFFFFFFE,3);
	SetRegEx(0X51F9,"es",0XFFFFFFFF,3);
	SetRegEx(0X520F,"es",0X48FE,3);
	SetRegEx(0X522D,"es",0XFFFFFFFF,3);
	SetRegEx(0X5236,"es",0X403,3);
	SetRegEx(0X5237,"ds",0XFFFFFFFF,3);
	SetRegEx(0X52AB,"es",0XFFFFFFFF,3);
	SetRegEx(0X52AC,"ds",0XFFFFFFFF,3);
	SetRegEx(0X52D1,"ss",0XFFFFFFFF,3);
	SetRegEx(0X52D7,"ds",0XFFFFFFFF,3);
	SetRegEx(0X52D8,"es",0XFFFFFFFF,3);
	SetRegEx(0X52E8,"ds",0X403,3);
	SetRegEx(0X52FC,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5321,"ds",0XFFFFFFFF,3);
	SetRegEx(0X53C1,"es",0XFFFFFFFF,3);
	SetRegEx(0X5444,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5448,"es",0XFFFFFFFF,3);
	SetRegEx(0X5481,"ds",0XF000,3);
	SetRegEx(0X5487,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5491,"es",0,3);
	SetRegEx(0X54D5,"ds",0XFFFFFFFF,3);
	SetRegEx(0X54F5,"es",0XF000,3);
	SetRegEx(0X54FC,"es",0XFFFFFFFF,3);
	SetRegEx(0X54FF,"ds",0XFFFFFFFF,3);
	SetRegEx(0X550E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5515,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5535,"es",0XF000,3);
	SetRegEx(0X553C,"es",0XFFFFFFFF,3);
	SetRegEx(0X553F,"ds",0XFFFFFFFF,3);
	SetRegEx(0X554E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5555,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5575,"es",0XF000,3);
	SetRegEx(0X557C,"es",0XFFFFFFFF,3);
	SetRegEx(0X557F,"ds",0XFFFFFFFF,3);
	SetRegEx(0X558E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5595,"ds",0XFFFFFFFF,3);
	SetRegEx(0X55B5,"es",0XF000,3);
	SetRegEx(0X55BC,"es",0XFFFFFFFF,3);
	SetRegEx(0X55BF,"ds",0XFFFFFFFF,3);
	SetRegEx(0X55CE,"ds",0XFFFFFFFF,3);
	SetRegEx(0X55D5,"ds",0XFFFFFFFF,3);
	SetRegEx(0X55F5,"es",0XF000,3);
	SetRegEx(0X55FC,"es",0XFFFFFFFF,3);
	SetRegEx(0X55FF,"ds",0XFFFFFFFF,3);
	SetRegEx(0X560E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5615,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5635,"es",0XF000,3);
	SetRegEx(0X563C,"es",0XFFFFFFFF,3);
	SetRegEx(0X563F,"ds",0XFFFFFFFF,3);
	SetRegEx(0X564E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5655,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5675,"es",0XF000,3);
	SetRegEx(0X567C,"es",0XFFFFFFFF,3);
	SetRegEx(0X567F,"ds",0XFFFFFFFF,3);
	SetRegEx(0X568E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5695,"ds",0XFFFFFFFF,3);
	SetRegEx(0X56B5,"es",0XF000,3);
	SetRegEx(0X56BC,"es",0XFFFFFFFF,3);
	SetRegEx(0X56BF,"ds",0XFFFFFFFF,3);
	SetRegEx(0X56CE,"ds",0XFFFFFFFF,3);
	SetRegEx(0X56D5,"ds",0XFFFFFFFF,3);
	SetRegEx(0X56F5,"es",0XF000,3);
	SetRegEx(0X56FC,"es",0XFFFFFFFF,3);
	SetRegEx(0X56FF,"ds",0XFFFFFFFF,3);
	SetRegEx(0X570E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5715,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5735,"es",0XF000,3);
	SetRegEx(0X573C,"es",0XFFFFFFFF,3);
	SetRegEx(0X573F,"ds",0XFFFFFFFF,3);
	SetRegEx(0X574E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5754,"ds",0XF000,3);
	SetRegEx(0X575A,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5766,"ds",0X70,3);
	SetRegEx(0X5772,"es",0XFFFFFFFF,3);
	SetRegEx(0X5773,"ds",0XFFFFFFFF,3);
	SetRegEx(0X5787,"ds",0X70,3);
	SetRegEx(0X5794,"ds",0XFFFFFFFF,3);
	SetRegEx(0X57AA,"es",0XFFFFFFFF,3);
	SetRegEx(0X57B6,"es",0XFFFFFFFF,3);
	SetRegEx(0X5C52,"es",0X403,3);
	SetRegEx(0X5C6C,"es",0XFFFFFFFF,3);
	SetRegEx(0X5C74,"es",0XFFFFFFFF,3);
	SetRegEx(0X6073,"ds",0,3);
	SetRegEx(0X607D,"es",0XFFFFFFFF,3);
	SetRegEx(0X6082,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6099,"ds",0XFFFFFFFF,3);
	SetRegEx(0X60B2,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6321,"ds",0X403,3);
	SetRegEx(0X637A,"ds",0XFFFFFFFF,3);
	SetRegEx(0X637C,"es",0XFFFFFFFF,3);
	SetRegEx(0X63A9,"ds",0X403,3);
	SetRegEx(0X63BF,"ds",0X403,3);
	SetRegEx(0X63CB,"es",0XFFFFFFFF,3);
	SetRegEx(0X6443,"ds",0X403,3);
	SetRegEx(0X644F,"ds",0X403,3);
	SetRegEx(0X65CF,"ds",0X70,3);
	SetRegEx(0X65E6,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6671,"es",0XFFFFFFFF,3);
	SetRegEx(0X66B7,"ds",0X403,3);
	SetRegEx(0X672A,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6731,"es",0XFFFFFFFF,3);
	SetRegEx(0X6733,"ds",0X403,3);
	SetRegEx(0X673E,"es",0X403,3);
	SetRegEx(0X6745,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6751,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6759,"ds",0XFFFFFFFF,3);
	SetRegEx(0X675B,"es",0XFFFFFFFF,3);
	SetRegEx(0X6763,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6788,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6796,"ds",0XFFFFFFFF,3);
	SetRegEx(0X67AA,"ds",0XFFFFFFFF,3);
	SetRegEx(0X67AE,"ds",0XFFFFFFFF,3);
	SetRegEx(0X67DC,"ds",0XFFFFFFFF,3);
	SetRegEx(0X67E1,"ds",0X403,3);
	SetRegEx(0X67E5,"ds",0X403,3);
	SetRegEx(0X67F0,"es",0XFFFFFFFF,3);
	SetRegEx(0X67F2,"ds",0X403,3);
	SetRegEx(0X6814,"es",0XFFFFFFFF,3);
	SetRegEx(0X681C,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6823,"es",0XFFFFFFFF,3);
	SetRegEx(0X6891,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6896,"es",0XFFFFFFFF,3);
	SetRegEx(0X689A,"es",0XFFFFFFFF,3);
	SetRegEx(0X68A5,"es",0XFFFFFFFF,3);
	SetRegEx(0X68BC,"es",0XFFFFFFFF,3);
	SetRegEx(0X68E6,"es",0XFFFFFFFF,3);
	SetRegEx(0X68EB,"es",0XFFFFFFFF,3);
	SetRegEx(0X68F7,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6901,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6908,"ds",0X403,3);
	SetRegEx(0X6910,"es",0XFFFFFFFF,3);
	SetRegEx(0X691D,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6932,"es",0XFFFFFFFF,3);
	SetRegEx(0X6997,"es",0XFFFFFFFF,3);
	SetRegEx(0X699A,"es",0XFFFFFFFF,3);
	SetRegEx(0X6A00,"es",0X403,3);
	SetRegEx(0X6A05,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6A0E,"es",0XFFFFFFFF,3);
	SetRegEx(0X6A0F,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6A69,"es",0XFFFFFFFF,3);
	SetRegEx(0X6A78,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6A86,"es",0X403,3);
	SetRegEx(0X6AA0,"es",0XFFFFFFFF,3);
	SetRegEx(0X6AAC,"es",0XFFFFFFFF,3);
	SetRegEx(0X6AAE,"ds",0X403,3);
	SetRegEx(0X6D17,"ds",0X70,3);
	SetRegEx(0X6D40,"es",0XFFFFFFFF,3);
	SetRegEx(0X6D41,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6D95,"es",0XFFFFFFFF,3);
	SetRegEx(0X6DA7,"es",0XFFFFFFFF,3);
	SetRegEx(0X6DAC,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6DAE,"es",0X403,3);
	SetRegEx(0X6DCD,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6DCE,"es",0XFFFFFFFF,3);
	SetRegEx(0X6DD1,"ds",0X403,3);
	SetRegEx(0X6DEC,"ds",0X403,3);
	SetRegEx(0X6DF6,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6E06,"ds",0X403,3);
	SetRegEx(0X6E12,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6E3B,"ds",0X403,3);
	SetRegEx(0X6E4A,"es",0X403,3);
	SetRegEx(0X6E4C,"ds",0X403,3);
	SetRegEx(0X6E72,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6E73,"es",0XFFFFFFFF,3);
	SetRegEx(0X6EBE,"ds",0X40,3);
	SetRegEx(0X6ED5,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6EEA,"ds",0X40,3);
	SetRegEx(0X6EF2,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6EFB,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6F00,"es",0X403,3);
	SetRegEx(0X6F0A,"es",0XFFFFFFFF,3);
	SetRegEx(0X6F0B,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6F13,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6F1D,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6F24,"es",0X403,3);
	SetRegEx(0X6F4E,"es",0XFFFFFFFF,3);
	SetRegEx(0X6F61,"es",0XFFFFFFFF,3);
	SetRegEx(0X6F7A,"es",0,3);
	SetRegEx(0X6F9C,"es",0XFFFFFFFF,3);
	SetRegEx(0X6FA4,"es",0XFFFFFFFF,3);
	SetRegEx(0X6FB1,"es",0X403,3);
	SetRegEx(0X6FB6,"es",0XFFFFFFFF,3);
	SetRegEx(0X6FC4,"ds",0X403,3);
	SetRegEx(0X6FC9,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6FD4,"ds",0XFFFFFFFF,3);
	SetRegEx(0X6FF0,"es",0X403,3);
	SetRegEx(0X6FF7,"es",0XFFFFFFFF,3);
	SetRegEx(0X700F,"es",0XFFFFFFFF,3);
	SetRegEx(0X7010,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7073,"ds",0X403,3);
	SetRegEx(0X7077,"ds",0XFFFFFFFF,3);
	SetRegEx(0X707C,"es",0X403,3);
	SetRegEx(0X7081,"es",0XFFFFFFFF,3);
	SetRegEx(0X709F,"es",0X403,3);
	SetRegEx(0X70B7,"es",0XFFFFFFFF,3);
	SetRegEx(0X70C8,"es",0X403,3);
	SetRegEx(0X70CA,"ds",0X403,3);
	SetRegEx(0X70EA,"es",0XFFFFFFFF,3);
	SetRegEx(0X70EB,"ds",0XFFFFFFFF,3);
	SetRegEx(0X70F4,"es",0X403,3);
	SetRegEx(0X7100,"es",0XFFFFFFFF,3);
	SetRegEx(0X718B,"ds",0XFFFFFFFF,3);
	SetRegEx(0X71CE,"es",0XFFFFFFFF,3);
	SetRegEx(0X71CF,"ds",0XFFFFFFFF,3);
	SetRegEx(0X71F7,"es",0XFFFFFFFF,3);
	SetRegEx(0X7217,"es",0XFFFFFFFF,3);
	SetRegEx(0X722A,"es",0XFFFFFFFF,3);
	SetRegEx(0X724A,"ds",0X403,3);
	SetRegEx(0X725E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7271,"es",0X403,3);
	SetRegEx(0X7278,"es",0XFFFFFFFF,3);
	SetRegEx(0X728E,"es",0XFFFFFFFF,3);
	SetRegEx(0X72A0,"es",0XFFFFFFFF,3);
	SetRegEx(0X72A1,"ds",0XFFFFFFFF,3);
	SetRegEx(0X72A7,"ds",0X403,3);
	SetRegEx(0X72AB,"ds",0XFFFFFFFF,3);
	SetRegEx(0X72B1,"ds",0X403,3);
	SetRegEx(0X72C1,"ds",0XFFFFFFFF,3);
	SetRegEx(0X72C9,"ds",0X403,3);
	SetRegEx(0X72D6,"ds",0XFFFFFFFF,3);
	SetRegEx(0X72DC,"es",0X403,3);
	SetRegEx(0X72E1,"es",0XFFFFFFFF,3);
	SetRegEx(0X72E6,"ds",0X403,3);
	SetRegEx(0X72EB,"ds",0XFFFFFFFF,3);
	SetRegEx(0X731B,"es",0XFFFFFFFF,3);
	SetRegEx(0X731E,"es",0XFFFFFFFF,3);
	SetRegEx(0X7324,"ds",0X403,3);
	SetRegEx(0X7328,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7380,"es",0XFFFFFFFF,3);
	SetRegEx(0X739E,"es",0XFFFFFFFF,3);
	SetRegEx(0X73DA,"es",0XFFFFFFFF,3);
	SetRegEx(0X73DE,"es",0XFFFFFFFF,3);
	SetRegEx(0X73F0,"ds",0X403,3);
	SetRegEx(0X73F5,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7426,"es",0XFFFFFFFF,3);
	SetRegEx(0X7453,"es",0XFFFFFFFF,3);
	SetRegEx(0X749F,"es",0XFFFFFFFF,3);
	SetRegEx(0X74A3,"es",0XFFFFFFFF,3);
	SetRegEx(0X74AF,"es",0XFFFFFFFF,3);
	SetRegEx(0X74C9,"es",0XFFFFFFFF,3);
	SetRegEx(0X74CC,"es",0XFFFFFFFF,3);
	SetRegEx(0X7530,"es",0XFFFFFFFF,3);
	SetRegEx(0X7556,"es",0XFFFFFFFF,3);
	SetRegEx(0X7559,"es",0XFFFFFFFF,3);
	SetRegEx(0X756D,"es",0XFFFFFFFF,3);
	SetRegEx(0X756E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X757E,"es",0XFFFFFFFF,3);
	SetRegEx(0X7590,"es",0XFFFFFFFF,3);
	SetRegEx(0X7598,"es",0XFFFFFFFF,3);
	SetRegEx(0X75A0,"ds",0X403,3);
	SetRegEx(0X75A5,"ds",0XFFFFFFFF,3);
	SetRegEx(0X75AF,"ds",0X403,3);
	SetRegEx(0X75B3,"ds",0XFFFFFFFF,3);
	SetRegEx(0X75C3,"es",0X403,3);
	SetRegEx(0X75CA,"es",0XFFFFFFFF,3);
	SetRegEx(0X75D5,"ds",0X403,3);
	SetRegEx(0X75DA,"ds",0XFFFFFFFF,3);
	SetRegEx(0X75E9,"es",0XFFFFFFFF,3);
	SetRegEx(0X7603,"es",0XFFFFFFFF,3);
	SetRegEx(0X7606,"es",0XFFFFFFFF,3);
	SetRegEx(0X7665,"es",0XFFFFFFFF,3);
	SetRegEx(0X7666,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7701,"ds",0XFFFFFFFF,3);
	SetRegEx(0X770E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7755,"es",0XFFFFFFFF,3);
	SetRegEx(0X7766,"ds",0XFFFFFFFF,3);
	SetRegEx(0X779B,"ds",0XFFFFFFFF,3);
	SetRegEx(0X779D,"es",0XFFFFFFFF,3);
	SetRegEx(0X77A1,"ds",0XFFFFFFFF,3);
	SetRegEx(0X77E3,"ds",0XFFFFFFFF,3);
	SetRegEx(0X77F7,"es",0X403,3);
	SetRegEx(0X787C,"ds",0XFFFFFFFF,3);
	SetRegEx(0X78A0,"ds",0XFFFFFFFF,3);
	SetRegEx(0X79C8,"ds",0XFFFFFFFF,3);
	SetRegEx(0X79CC,"ds",0XFFFFFFFF,3);
	SetRegEx(0X79D0,"es",0XFFFFFFFF,3);
	SetRegEx(0X79DE,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7A01,"es",0XFFFFFFFF,3);
	SetRegEx(0X7A1B,"es",0XFFFFFFFF,3);
	SetRegEx(0X7A52,"es",0XFFFFFFFF,3);
	SetRegEx(0X7A6C,"es",0XFFFFFFFF,3);
	SetRegEx(0X7A80,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7A88,"es",0XFFFFFFFF,3);
	SetRegEx(0X7A8D,"es",0XFFFFFFFF,3);
	SetRegEx(0X7A91,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7ACD,"es",0XFFFFFFFF,3);
	SetRegEx(0X7AE7,"es",0XFFFFFFFF,3);
	SetRegEx(0X7B01,"es",0XFFFFFFFF,3);
	SetRegEx(0X7B19,"es",0XFFFFFFFF,3);
	SetRegEx(0X7B25,"es",0XFFFFFFFF,3);
	SetRegEx(0X7B37,"es",0XFFFFFFFF,3);
	SetRegEx(0X7B62,"es",0XFFFFFFFF,3);
	SetRegEx(0X7B6C,"es",0XFFFFFFFE,3);
	SetRegEx(0X7B75,"es",0XFFFFFFFF,3);
	SetRegEx(0X7B85,"es",0XFFFFFFFF,3);
	SetRegEx(0X7B8A,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7B9A,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7BA2,"es",0XFFFFFFFF,3);
	SetRegEx(0X7BA3,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7BC1,"ds",0X403,3);
	SetRegEx(0X7BDD,"es",0X403,3);
	SetRegEx(0X7C0B,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7C27,"es",0XFFFFFFFF,3);
	SetRegEx(0X7C48,"es",0X403,3);
	SetRegEx(0X7C57,"ds",0X403,3);
	SetRegEx(0X7CB4,"es",0XFFFFFFFF,3);
	SetRegEx(0X7CD3,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7CD8,"es",0XFFFFFFFF,3);
	SetRegEx(0X7D0C,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7D11,"es",0XFFFFFFFF,3);
	SetRegEx(0X7D15,"es",0XFFFFFFFF,3);
	SetRegEx(0X7D20,"es",0XFFFFFFFF,3);
	SetRegEx(0X7D42,"es",0XFFFFFFFF,3);
	SetRegEx(0X7D6C,"es",0XFFFFFFFF,3);
	SetRegEx(0X7D71,"es",0XFFFFFFFF,3);
	SetRegEx(0X7D7C,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7D85,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7D8D,"ds",0X403,3);
	SetRegEx(0X7D95,"es",0XFFFFFFFF,3);
	SetRegEx(0X7DA2,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7E04,"ds",0X403,3);
	SetRegEx(0X7E2F,"es",0XFFFFFFFF,3);
	SetRegEx(0X7E40,"es",0X1,3);
	SetRegEx(0X7E66,"es",0XFFFFFFFF,3);
	SetRegEx(0X7E6A,"es",0XFFFFFFFF,3);
	SetRegEx(0X7E83,"es",0XFFFFFFFF,3);
	SetRegEx(0X7EB0,"ds",0X403,3);
	SetRegEx(0X7ECA,"ds",0X70,3);
	SetRegEx(0X7EF2,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7EF6,"ds",0X403,3);
	SetRegEx(0X7F0E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7F12,"ds",0X403,3);
	SetRegEx(0X7F56,"ds",0XFFFFFFFF,3);
	SetRegEx(0X7F73,"es",0X403,3);
	SetRegEx(0X7F7F,"es",0XFFFFFFFF,3);
	SetRegEx(0X7FF7,"es",0X403,3);
	SetRegEx(0X8018,"es",0XFFFFFFFF,3);
	SetRegEx(0X8304,"ds",0,3);
	SetRegEx(0X8320,"ds",0XFFFFFFFF,3);
	SetRegEx(0X8387,"ds",0,3);
	SetRegEx(0X83A6,"ds",0XFFFFFFFF,3);
	SetRegEx(0X852E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X8532,"ds",0XFFFFFFFF,3);
	SetRegEx(0X8561,"es",0X40,3);
	SetRegEx(0X8594,"es",0XFFFFFFFF,3);
	SetRegEx(0X8646,"ds",0XFFFFFFFF,3);
	SetRegEx(0X8659,"ds",0X403,3);
	SetRegEx(0X865D,"ds",0XFFFFFFFF,3);
	SetRegEx(0X866D,"ds",0XFFFFFFFF,3);
	SetRegEx(0X8671,"ds",0XFFFFFFFF,3);
	SetRegEx(0X86AB,"es",0X403,3);
	SetRegEx(0X86C0,"es",0XFFFFFFFF,3);
	SetRegEx(0X86D1,"ds",0XFFFFFFFF,3);
	SetRegEx(0X86D4,"es",0XFFFFFFFF,3);
	SetRegEx(0X86DF,"es",0XFFFFFFFF,3);
	SetRegEx(0X86EC,"es",0X40,3);
	SetRegEx(0X86FB,"es",0XFFFFFFFF,3);
	SetRegEx(0X870D,"es",0XFFFFFFFF,3);
	SetRegEx(0X870E,"ds",0XFFFFFFFF,3);
	SetRegEx(0X8785,"es",0XFFFFFFFF,3);
	SetRegEx(0X8786,"ds",0XFFFFFFFF,3);
	SetRegEx(0X8827,"ds",0XFFFFFFFF,3);
	SetRegEx(0X882F,"ds",0XFFFFFFFF,3);
	SetRegEx(0X8882,"ds",0X403,3);
	SetRegEx(0X8886,"ds",0XFFFFFFFF,3);
	SetRegEx(0X8917,"es",0XFFFFFFFF,3);
	SetRegEx(0X8BE5,"ds",0X403,3);
	SetRegEx(0X8C0D,"ds",0XFFFFFFFF,3);
	SetRegEx(0X8CB3,"ds",0XFFFFFFFF,3);
	SetRegEx(0X8CD7,"ds",0XFFFFFFFF,3);
	SetRegEx(0X8D0A,"es",0XFFFFFFFF,3);
	SetRegEx(0X8D19,"es",0XFFFFFFFF,3);
	SetRegEx(0X8D21,"ds",0X403,3);
	SetRegEx(0X8D2C,"ds",0XFFFFFFFF,3);
	SetRegEx(0X8DC6,"es",0X403,3);
	SetRegEx(0X8DD0,"es",0XFFFFFFFF,3);
	SetRegEx(0X8F0E,"es",0XFFFFFFFF,3);
	SetRegEx(0X8F28,"ds",0XFFFFFFFF,3);
	SetRegEx(0X8F29,"es",0XFFFFFFFF,3);
	SetRegEx(0X8F57,"ds",0XFFFFFFFF,3);
	SetRegEx(0X8F58,"es",0XFFFFFFFF,3);
	SetRegEx(0X8F7A,"es",0X403,3);
	SetRegEx(0X8F84,"ds",0X403,3);
}

//------------------------------------------------------------------------
// Information about all patched bytes:

static Patches(void) {
}

//------------------------------------------------------------------------
// Call all byte feature functions:

static Bytes(void) {
	Bytes_0();
	Bytes_1();
	Bytes_2();
	Bytes_3();
	Bytes_4();
	Bytes_5();
	Bytes_6();
        EndTypeUpdating(UTP_STRUCT);
}

// End of file.
